code	label	task	lineID
public class A { <line0> public void init(CamelContext camelContext) { <line1> if (!camelContext.hasService(this)) { <line2> try { <line3> camelContext.addService(this, true, true); <line4> } catch (Exception e) { <line5> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line3>        LOG.debug(""Initializing XRay tracer"");"	task4	
public class A { <line0> @Override <line1> protected Iterator<SimpleFeature> openIterator() { <line2> try { <line3> return openIterator(getQueryConstraints()); <line4> } catch (TransformException | FactoryException e) { <line5> } <line6> return featureCursor; <line7> } <line8> } <line9> 	"<line5>      LOGGER.warn(""Unable to transform geometry"", e);"	task4	
public class A { <line0> protected void handleRemoteDisconnect(final ProtonConnection con) { <line1> con.disconnect(); <line2> publishConnectionClosedEvent(con); <line3> } <line4> } <line5> 	"<line1>    log.debug(""client [container: {}] disconnected"", con.getRemoteContainer());"	task4	
public class A { <line0> @Override <line1> public Map<K, ICacheElement<K, V>> getMultiple(final Set<K> keys) { <line2> return getMultipleSetupMap.get(keys); <line3> } <line4> } <line5> 	"<line2>    log.info(""get ["" + keys + ""]"");"	task4	
public class A { <line0> protected void processInput(CharBuffer oldCharBuffer, Writer writer) throws Exception { <line1> int length = <line2> KMPSearch.search( <line3> oldCharBuffer, <line4> _MARKER_INPUT_OPEN.length + 1, <line5> _MARKER_INPUT_CLOSE, <line6> _MARKER_INPUT_CLOSE_NEXTS); <line7> if (length == -1) { <line8> if (log.isWarnEnabled()) { <line9> } <line10> outputOpenTag(oldCharBuffer, writer, _MARKER_INPUT_OPEN); <line11> return; <line12> } <line13> length += _MARKER_INPUT_CLOSE.length(); <line14> String content = extractContent(oldCharBuffer, length); <line15> writer.write(content); <line16> skipWhiteSpace(oldCharBuffer, writer, true); <line17> } <line18> } <line19> 	"<line9>        log.warn(""Missing />"");"	task4	
public class A { <line0> public void testForMemoryLeaks() throws Exception { <line1> final long differenceMemoryCache = thrashCache(); <line2> assertTrue(differenceMemoryCache < 500000); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Memory Difference is: "" + differenceMemoryCache);"	task4	
public class A { <line0> @Override <line1> public Boolean apply(Object param) { <line2> counter++; <line3> if (counter == 2) return success; <line4> jobCtx.holdcc(4000); <line5> try { <line6> jobCtx.holdcc(); <line7> } catch (IllegalStateException ignored) { <line8> success = true; <line9> } finally { <line10> new Timer() <line11> .schedule( <line12> new TimerTask() { <line13> @Override <line14> public void run() { <line15> jobCtx.callcc(); <line16> } <line17> }, <line18> 1000); <line19> } <line20> return false; <line21> } <line22> } <line23> 	"<line9>      log.info(""Second holdcc() threw IllegalStateException as expected."");"	task4	
public class A { <line0> public static void cleanup(Log log, java.io.Closeable... closeables) { <line1> for (java.io.Closeable c : closeables) { <line2> if (c != null) { <line3> try { <line4> c.close(); <line5> } catch (IOException e) { <line6> if (log != null && log.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	"<line7>            log.debug(""Exception in closing "" + c, e);"	task4	
"public class A { <line0> public static void updateFileEntryType( <line1> HttpPrincipal httpPrincipal, <line2> long fileEntryTypeId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> java.util.Map<java.util.Locale, String> descriptionMap, <line5> long[] ddmStructureIds, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> DLFileEntryTypeServiceUtil.class, <line12> ""updateFileEntryType"", <line13> _updateFileEntryTypeParameterTypes16); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, fileEntryTypeId, nameMap, descriptionMap, ddmStructureIds, serviceContext); <line17> try { <line18> TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> throw systemException; <line27> } <line28> } <line29> } <line30> "	<line26>      log.error(systemException, systemException);	task4	
public class A { <line0> public void analyseAnnotationConstant( <line1> List<ModifierContext> modifierList, <line2> TypeTypeContext typeType, <line3> VariableDeclaratorsContext variableDeclarators) { <line4> try { <line5> this.isLocalVariable = false; <line6> this.visibility = VisibilitySet.PUBLIC.toString(); <line7> this.isFinal = true; <line8> this.hasClassScope = true; <line9> dispatchAnnotationsOfMember(modifierList, belongsToClass); <line10> this.declareType = determineTypeOfTypeType(typeType, belongsToClass); <line11> determine_name(variableDeclarators); <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> 	"<line13>      logger.warn("" Exception while processing: ""+ belongsToClass+ "" Line: ""+ typeType.start.getLine()+ "" ""+ e.getMessage());"	task4	
"public class A { <line0> private void infolog(String msg) { <line1> processingLog += msg + "".\n""; <line2> } <line3> } <line4> "	<line1>    logger.info(msg);	task4	
public class A { <line0> public RestTemplate getRestTemplate(String requesterWebID) { <line1> RestTemplate restTemplate; <line2> try { <line3> restTemplate = getRestTemplateForReadingLinkedData(requesterWebID); <line4> } catch (Exception e) { <line5> throw new RuntimeException(e); <line6> } <line7> return restTemplate; <line8> } <line9> } <line10> 	"<line5>      logger.error(""Failed to create ssl tofu rest template"", e);"	task4	
public class A { <line0> private boolean finalizeParentTemplate( <line1> DatadiskTO dataDiskTemplate, <line2> VMTemplateVO templateVO, <line3> TemplateInfo parentTemplate, <line4> DataStore imageStore, <line5> int diskCount) <line6> throws ExecutionException, InterruptedException, CloudRuntimeException { <line7> TemplateInfo templateInfo = imageFactory.getTemplate(templateVO.getId(), imageStore); <line8> AsyncCallFuture<TemplateApiResult> templateFuture = <line9> createDatadiskTemplateAsync( <line10> parentTemplate, <line11> templateInfo, <line12> dataDiskTemplate.getPath(), <line13> dataDiskTemplate.getDiskId(), <line14> dataDiskTemplate.getFileSize(), <line15> dataDiskTemplate.isBootable()); <line16> TemplateApiResult result = null; <line17> result = templateFuture.get(); <line18> if (!result.isSuccess()) { <line19> cleanupDatadiskTemplates(templateInfo); <line20> } <line21> return result.isSuccess(); <line22> } <line23> } <line24> 	"<line19>      logger.debug(""Since creation of parent template: ""+ templateInfo.getId()+ "" failed, delete Datadisk templates that were created as part of parent""+ "" template download"");"	task4	
"public class A { <line0> public static com.liferay.fragment.model.FragmentComposition deleteFragmentComposition( <line1> HttpPrincipal httpPrincipal, long fragmentCompositionId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> FragmentCompositionServiceUtil.class, <line7> ""deleteFragmentComposition"", <line8> _deleteFragmentCompositionParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, fragmentCompositionId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.fragment.model.FragmentComposition) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> private CloseableIteration<? extends BindingSet, QueryEvaluationException> evaluateInternal( <line1> TupleExpr tupleExpr, Dataset dataset, BindingSet bindings, boolean includeInferred) <line2> throws SailException { <line3> tupleExpr = tupleExpr.clone(); <line4> if (!(tupleExpr instanceof QueryRoot)) { <line5> tupleExpr = new QueryRoot(tupleExpr); <line6> } <line7> new BindingAssigner().optimize(tupleExpr, dataset, bindings); <line8> List<SearchQueryEvaluator> queries = new ArrayList<>(); <line9> for (SearchQueryInterpreter interpreter : sail.getSearchQueryInterpreters()) { <line10> interpreter.process(tupleExpr, bindings, queries); <line11> } <line12> if (!queries.isEmpty()) { <line13> evaluateLuceneQueries(queries); <line14> } <line15> if (sail.getEvaluationMode() == TupleFunctionEvaluationMode.TRIPLE_SOURCE) { <line16> ValueFactory vf = sail.getValueFactory(); <line17> EvaluationStrategy strategy = <line18> new TupleFunctionEvaluationStrategy( <line19> new SailTripleSource(this, includeInferred, vf), <line20> dataset, <line21> sail.getFederatedServiceResolver(), <line22> sail.getTupleFunctionRegistry()); <line23> new BindingAssigner().optimize(tupleExpr, dataset, bindings); <line24> new ConstantOptimizer(strategy).optimize(tupleExpr, dataset, bindings); <line25> new CompareOptimizer().optimize(tupleExpr, dataset, bindings); <line26> new ConjunctiveConstraintSplitter().optimize(tupleExpr, dataset, bindings); <line27> new DisjunctiveConstraintOptimizer().optimize(tupleExpr, dataset, bindings); <line28> new SameTermFilterOptimizer().optimize(tupleExpr, dataset, bindings); <line29> new QueryModelNormalizer().optimize(tupleExpr, dataset, bindings); <line30> new QueryJoinOptimizer(new TupleFunctionEvaluationStatistics()) <line31> .optimize(tupleExpr, dataset, bindings); <line32> new IterativeEvaluationOptimizer().optimize(tupleExpr, dataset, bindings); <line33> new FilterOptimizer().optimize(tupleExpr, dataset, bindings); <line34> new OrderLimitOptimizer().optimize(tupleExpr, dataset, bindings); <line35> try { <line36> return strategy.evaluate(tupleExpr, bindings); <line37> } catch (QueryEvaluationException e) { <line38> throw new SailException(e); <line39> } <line40> } else { <line41> return super.evaluate(tupleExpr, dataset, bindings, includeInferred); <line42> } <line43> } <line44> } <line45> 	"<line35>      logger.trace(""Optimized query model:\n{}"", tupleExpr);"	task4	
public class A { <line0> private void complete(Session session) { <line1> assert head == tail; <line2> reset(session); <line3> if (onCompletion != null) { <line4> onCompletion.run(session); <line5> } <line6> } <line7> } <line8> 	"<line2>    log.trace(""#{} queue {} completed"", session.uniqueId(), var);"	task4	
public class A { <line0> @Override <line1> public void process(final FilterChain chain, final Request request, final Response response) { <line2> long tm = System.currentTimeMillis(); <line3> try { <line4> Session s = sessionManager.open(); <line5> chain.process(request, response); <line6> } finally { <line7> sessionManager.close(); <line8> } <line9> tm = System.currentTimeMillis() - tm; <line10> } <line11> } <line12> 	"<line10>    log.info(""Finished request: ""+ tm+ ""ms  for ""+ request.getAbsolutePath()+ "" method=""+ request.getMethod());"	task4	
public class A { <line0> @Override <line1> public void doStopSelfTest( <line2> final OslpEnvelope oslpRequest, <line3> final DeviceRequest deviceRequest, <line4> final DeviceResponseHandler deviceResponseHandler, <line5> final String ipAddress) <line6> throws IOException { <line7> this.saveOslpRequestLogEntry(deviceRequest, oslpRequest); <line8> final OslpResponseHandler oslpResponseHandler = <line9> new OslpResponseHandler() { <line10> @Override <line11> public void handleResponse(final OslpEnvelope response) { <line12> OslpDeviceService.this.handleOslpResponseStopSelfTest( <line13> deviceRequest, response, deviceResponseHandler); <line14> } <line15>  <line16> @Override <line17> public void handleException(final Throwable t) { <line18> OslpDeviceService.this.handleException(t, deviceRequest, deviceResponseHandler); <line19> } <line20> }; <line21> this.sendMessage(ipAddress, oslpRequest, oslpResponseHandler, deviceRequest); <line22> } <line23> } <line24> 	"<line7>    LOGGER.info(""doStopSelfTest() for device: {}."", deviceRequest.getDeviceIdentification());"	task4	
"public class A { <line0> @Override <line1> public FragmentEntryLink findByUUID_G(String uuid, long groupId) throws NoSuchEntryLinkException { <line2> FragmentEntryLink fragmentEntryLink = fetchByUUID_G(uuid, groupId); <line3> if (fragmentEntryLink == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchEntryLinkException(sb.toString()); <line14> } <line15> return fragmentEntryLink; <line16> } <line17> } <line18> "	<line12>        log.debug(sb.toString());	task4	
public class A { <line0> private MessageCheckpoint loadMessageCheckpoint() { <line1> final Snapshot<MessageCheckpoint> snapshot = messageCheckpointStore.latestSnapshot(); <line2> if (snapshot == null) { <line3> return new MessageCheckpoint(-1, new HashMap<>()); <line4> } else { <line5> return snapshot.getData(); <line6> } <line7> } <line8> } <line9> 	"<line3>      LOG.info(""no message log replay snapshot, return empty state."");"	task4	
public class A { <line0> @Override <line1> public ProjectVersion getVersion() { <line2> String historyVersion = getHistoryVersion(); <line3> if (historyVersion == null) { <line4> if (designFolderName != null) { <line5> try { <line6> return createProjectVersion(designRepository.check(designFolderName)); <line7> } catch (IOException e) { <line8> } <line9> } <line10> return null; <line11> } <line12> return super.getVersion(); <line13> } <line14> } <line15> 	<line8>          log.error(e.getMessage(), e);	task4	
"public class A { <line0> private void writeMessageLength(SSL2ServerHelloMessage message) { <line1> if (message.getPaddingLength().getValue() != 0) { <line2> throw new UnsupportedOperationException(""Long record headers are not supported""); <line3> } <line4> appendInt(message.getMessageLength().getValue(), SSL2ByteLength.LENGTH); <line5> } <line6> } <line7> "	"<line5>    LOGGER.debug(""MessageLength: "" + message.getMessageLength().getValue());"	task4	
public class A { <line0> public List<Asset> findAll( <line1> Long repositoryId, String path, Boolean deleted, Boolean virtual, Long branchId) { <line2> Specification<Asset> assetSpecifications = <line3> distinct(ifParamNotNull(repositoryIdEquals(repositoryId))) <line4> .and(ifParamNotNull(pathEquals(path))) <line5> .and(ifParamNotNull(deletedEquals(deleted))) <line6> .and(ifParamNotNull(virtualEquals(virtual))) <line7> .and(ifParamNotNull(branchId(branchId, deleted))); <line8> List<Asset> all = assetRepository.findAll(assetSpecifications); <line9> return all; <line10> } <line11> } <line12> 	"<line2>    logger.debug(""Find all assets for repositoryId: {}, path: {}, deleted: {}, virtual: {}, branchId: {}"",repositoryId,path,deleted,virtual,branchId);"	task4	
public class A { <line0> @Override <line1> public RequestResponse updateManagementContract( <line2> VitamContext vitamContext, String id, JsonNode queryDsl) <line3> throws AccessExternalClientException { <line4> VitamRequestBuilder request = <line5> put() <line6> .withPath(UPDATE_MANAGEMENT_CONTRACT + id) <line7> .withHeaders(vitamContext.getHeaders()) <line8> .withBody(queryDsl) <line9> .withJson(); <line10> try (Response response = make(request)) { <line11> check(response); <line12> return RequestResponse.parseFromResponse(response); <line13> } catch (VitamClientInternalException e) { <line14> throw new AccessExternalClientException(e); <line15> } catch (AdminExternalClientException e) { <line16> return e.getVitamError(); <line17> } <line18> } <line19> } <line20> 	<line16>      LOGGER.error(e);	task4	
public class A { <line0> public void run() { <line1> try { <line2> for (LatencyAwareHClientPool pool : allPools) { <line3> pool.clear(); <line4> } <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.info(""exceotuib reseting stats"", e);"	task4	
public class A { <line0> private void writeExtensions(CertificatePair pair) { <line1> appendBytes(pair.getExtensions().getValue()); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""Extensions: "" + ArrayConverter.bytesToHexString(pair.getExtensions().getValue()));"	task4	
public class A { <line0> public void deactivateVfModule(BuildingBlockExecution execution) { <line1> try { <line2> GeneralBuildingBlock gBBInput = execution.getGeneralBuildingBlock(); <line3> RequestContext requestContext = gBBInput.getRequestContext(); <line4> ServiceInstance serviceInstance = <line5> extractPojosForBB.extractByKey(execution, ResourceKey.SERVICE_INSTANCE_ID); <line6> GenericVnf vnf = extractPojosForBB.extractByKey(execution, ResourceKey.GENERIC_VNF_ID); <line7> VfModule vfModule = extractPojosForBB.extractByKey(execution, ResourceKey.VF_MODULE_ID); <line8> Customer customer = gBBInput.getCustomer(); <line9> CloudRegion cloudRegion = gBBInput.getCloudRegion(); <line10> SDNCRequest sdncRequest = new SDNCRequest(); <line11> GenericResourceApiVfModuleOperationInformation req = <line12> sdncVfModuleResources.deactivateVfModule( <line13> vfModule, <line14> vnf, <line15> serviceInstance, <line16> customer, <line17> cloudRegion, <line18> requestContext, <line19> buildCallbackURI(sdncRequest)); <line20> sdncRequest.setSDNCPayload(req); <line21> sdncRequest.setTopology(SDNCTopology.VFMODULE); <line22> execution.setVariable(SDNC_REQUEST, sdncRequest); <line23> } catch (Exception ex) { <line24> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, ex); <line25> } <line26> } <line27> } <line28> 	"<line24>      logger.error(""Exception occurred in SDNCDeactivateTasks deactivateVfModule"", ex);"	task4	
"public class A { <line0> public static <K, V> ICacheElement<K, V> getDeSerializedCacheElement( <line1> final ICacheElementSerialized<K, V> serialized, final IElementSerializer elementSerializer) <line2> throws IOException, ClassNotFoundException { <line3> if (serialized == null) { <line4> return null; <line5> } <line6> V deSerializedValue = null; <line7> if (elementSerializer == null) { <line8> throw new IOException(""Could not de-serialize object. The ElementSerializer is null.""); <line9> } <line10> try { <line11> deSerializedValue = elementSerializer.deSerialize(serialized.getSerializedValue(), null); <line12> } catch (final ClassNotFoundException | IOException e) { <line13> throw e; <line14> } <line15> final ICacheElement<K, V> deSerialized = <line16> new CacheElement<>(serialized.getCacheName(), serialized.getKey(), deSerializedValue); <line17> deSerialized.setElementAttributes(serialized.getElementAttributes()); <line18> return deSerialized; <line19> } <line20> } <line21> "	"<line13>      log.error(""Problem de-serializing object."", e);"	task4	
public class A { <line0> public void close() { <line1> running.set(false); <line2> receiver.interrupt(); <line3> connection.close(); <line4> } <line5> } <line6> 	"<line1>    LOG.debug(""thread {}: connection stop"", Thread.currentThread().getId());"	task4	
public class A { <line0> @Test <line1> public void testDb2TableCreation() { <line2> FhirSchemaGenerator gen = new FhirSchemaGenerator(ADMIN_SCHEMA_NAME, SCHEMA_NAME, false); <line3> PhysicalDataModel model = new PhysicalDataModel(); <line4> gen.buildSchema(model); <line5> PrintTarget tgt = new PrintTarget(null, logger.isLoggable(Level.FINE)); <line6> Db2Adapter adapter = new Db2Adapter(tgt); <line7> model.apply(adapter); <line8> } <line9> } <line10> 	"<line2>    logger.info(""Testing DB2 schema creation"");"	task4	
public class A { <line0> @Override <line1> public void startApplication(String applicationName) { <line2> delegate.startApplication(applicationName); <line3> } <line4> } <line5> 	<line2>    logger.debug(Messages.STARTING_APPLICATION_0, applicationName);	task4	
"public class A { <line0> @Path(""/getAllShouldSucceed"") <line1> @POST <line2> public void getAllShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET_ALL); <line4> Network[] networks = template.requestBody(uri, null, Network[].class); <line5> assertNotNull(networks); <line6> assertEquals(1, networks.length); <line7> assertEquals(NETWORK_NAME, networks[0].getName()); <line8> assertNotNull(networks[0].getSubnets()); <line9> assertEquals(1, networks[0].getSubnets().size()); <line10> assertEquals(""0c4faf33-8c23-4dc9-8bf5-30dd1ab452f9"", networks[0].getSubnets().get(0)); <line11> assertEquals(""73f6f1ac-5e58-4801-88c3-7e12c6ddfb39"", networks[0].getId()); <line12> assertEquals(NetworkType.VXLAN, networks[0].getNetworkType()); <line13> } <line14> } <line15> "	"<line3>    LOG.debug(""Calling OpenstackNeutronNetworkResource.getAllShouldSucceed()"");"	task4	
public class A { <line0> @Override <line1> public JainMgcpResponseEvent decodeResponse( <line2> byte[] data, SplitDetails[] msg, Integer txID, ReturnCode returnCode) throws ParseException { <line3> response = new NotificationRequestResponse(source != null ? source : stack, returnCode); <line4> response.setTransactionHandle(txID); <line5> try { <line6> (new ResponseContentHandle()).parse(data, msg); <line7> } catch (IOException e) { <line8> } <line9> return response; <line10> } <line11> } <line12> 	"<line8>      logger.error(""Decode RQNT Response failed"", e);"	task4	
"public class A { <line0> public void kinit(String user) throws Exception { <line1> UserGroupInformation.loginUserFromKeytab(user, KEYTAB_LOCATION + ""/"" + user + "".keytab""); <line2> } <line3> } <line4> "	"<line2>    LOGGER.info(""Kinited user: "" + user + "" keytab: "" + KEYTAB_LOCATION + ""/"" + user + "".keytab"");"	task4	
public class A { <line0> @Override <line1> public void onError(SubscriptionException error) { <line2> subscribeBroadcastWithSingleStructParameterCallbackResult = false; <line3> subscribeBroadcastWithSingleStructParameterCallbackDone = true; <line4> } <line5> } <line6> 	"<line2>    logger.info(name.getMethodName() + "" - callback - error"");"	task4	
public class A { <line0> private void changeTrackPosition(long positionOffsetInMs) throws SpeakerException { <line1> long currentPosition = speaker.getPlayState().getPositionInMs(); <line2> speaker.setPosition(currentPosition + positionOffsetInMs); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Jumping from old track position {} ms to new position {} ms"",currentPosition,currentPosition + positionOffsetInMs);"	task4	
"public class A { <line0> private void createUnusedTextFieldMaster(HashSet<String> usedFunctions) { <line1> UnoDictionary<XComponent> masters = <line2> UnoDictionary.create( <line3> UNO.XTextFieldsSupplier(model.doc).getTextFieldMasters(), XComponent.class); <line4> String prefix = ""com.sun.star.text.FieldMaster.User.""; <line5> for (Entry<String, XComponent> master : masters.entrySet()) { <line6> if (master == null || !master.getKey().startsWith(prefix)) { <line7> continue; <line8> } <line9> String varName = master.getKey().substring(prefix.length()); <line10> String trafoName = TextDocumentModel.getFunctionNameForUserFieldName(varName); <line11> if (trafoName != null && !usedFunctions.contains(trafoName)) { <line12> try { <line13> master.getValue().dispose(); <line14> } catch (java.lang.Exception e) { <line15> } <line16> } <line17> } <line18> } <line19> } <line20> "	"<line15>          LOGGER.error("""", e);"	task4	
public class A { <line0> private RegistryConfig readRegConfig(String parentAppName, String artifactName) { <line1> RegistryConfig regConfig = null; <line2> try { <line3> CarbonAppPersistenceManager capm = new CarbonAppPersistenceManager(getAxisConfig()); <line4> regConfig = <line5> capm.loadRegistryConfig( <line6> AppDeployerConstants.APPLICATIONS <line7> + parentAppName <line8> + AppDeployerConstants.APP_DEPENDENCIES <line9> + artifactName); <line10> } catch (Exception e) { <line11> } <line12> return regConfig; <line13> } <line14> } <line15> 	"<line11>      log.error(""Error while trying to load registry config for C-App : ""+ parentAppName+ "" artifact : ""+ artifactName,e);"	task4	
public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent event) { <line2> Object o = event.getSource(); <line3> OpenCVFilterSURF sf = (OpenCVFilterSURF) boundFilter.filter; <line4> if (o == objectFilename) { <line5> String val = ((JTextField) o).getText(); <line6> sf.loadObjectImageFilename(val); <line7> } else { <line8> } <line9> } <line10> } <line11> 	"<line8>      log.warn(""Inknown object invoked in surf filter ui"");"	task4	
"public class A { <line0> @Test <line1> public void testOKPKOnFact() throws Exception { <line2> context.checking( <line3> new Expectations() { <line4> { <line5> one(conn).getMetaData(); <line6> will(returnValue(meta)); <line7> allowing(meta).getPrimaryKeys(null, null, ""sales_fact_1997""); <line8> will(returnValue(rsSalesFact1997PrimaryKeys)); <line9> one(rsSalesFact1997PrimaryKeys).next(); <line10> will(returnValue(false)); <line11> allowing(meta) <line12> .getPrimaryKeys( <line13> with(any(String.class)), with(any(String.class)), with(any(String.class))); <line14> } <line15> }); <line16> List<ValidationMessage> messages = bean.validateCube(schema, getCubeByName(""Sales""), conn); <line17> assertTrue(isMessagePresent(messages, ERROR, ""sales_fact_1997"", ""primary key"")); <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } <line21> } <line22> "	"<line19>      logger.debug(""got "" + messages.size() + "" message(s): "" + messages);"	task4	
public class A { <line0> public List<HintApplication> getHints() { <line1> List<HintApplication> hints = new ArrayList<>(); <line2> if (mn.visibleAnnotations != null) { <line3> for (AnnotationNode an : mn.visibleAnnotations) { <line4> Type annotationType = typeSystem.Lresolve(an.desc, true); <line5> if (annotationType == null) { <line6> } else { <line7> Stack<Type> s = new Stack<>(); <line8> annotationType.collectHints(an, hints, new HashSet<>(), s); <line9> } <line10> } <line11> } <line12> return hints.size() == 0 ? Collections.emptyList() : hints; <line13> } <line14> } <line15> 	"<line6>          logger.debug(""Couldn't resolve ""+ an.desc+ "" annotation type whilst searching for hints on ""+ getName());"	task4	
"public class A { <line0> @Override <line1> public int ignite( <line2> String host, <line3> int port, <line4> SslStores sslStores, <line5> int maxThreads, <line6> int minThreads, <line7> int threadIdleTimeoutMillis) <line8> throws ContainerInitializationException { <line9> Timer.start(""SPARK_EMBEDDED_IGNITE""); <line10> if (sparkFilter == null) { <line11> sparkFilter = <line12> new MatcherFilter( <line13> applicationRoutes, <line14> staticFilesConfiguration, <line15> exceptionMapper, <line16> true, <line17> hasMultipleHandler); <line18> } <line19> sparkFilter.init(null); <line20> Timer.stop(""SPARK_EMBEDDED_IGNITE""); <line21> return port; <line22> } <line23> } <line24> "	"<line10>    log.info(""Starting Spark server, ignoring port and host"");"	task4	
public class A { <line0> public static com.liferay.commerce.price.list.model.CommercePriceListSoap <line1> fetchCatalogBaseCommercePriceListByType(long groupId, String type) throws RemoteException { <line2> try { <line3> com.liferay.commerce.price.list.model.CommercePriceList returnValue = <line4> CommercePriceListServiceUtil.fetchCatalogBaseCommercePriceListByType(groupId, type); <line5> return com.liferay.commerce.price.list.model.CommercePriceListSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> public void flush() { <line1> release(true); <line2> resetHitCounter(); <line3> } <line4> } <line5> 	"<line3>    log.debug(this.getName() + "" flushed."");"	task4	
"public class A { <line0> private List<Iterator<DataRow>> mergePartitions( <line1> final List<AbstractTableSorter> columnPartitions, <line2> final ExecutionMonitor exec, <line3> final int chunkCount) <line4> throws CanceledExecutionException { <line5> final List<Iterator<DataRow>> partitionRowIterators = new ArrayList<>(); <line6> final int numberOfNecessaryContainers = chunkCount * m_sortDescriptions.length; <line7> final Iterator<AbstractTableSorter> i = columnPartitions.iterator(); <line8> if (numberOfNecessaryContainers > m_maxOpenContainers && chunkCount > 1) { <line9> int tmp = numberOfNecessaryContainers; <line10> final int numExcessContainers = numberOfNecessaryContainers - m_maxOpenContainers; <line11> final double numExcessPartitions = numExcessContainers / chunkCount; <line12> final double numPartitionsToMergeSeparately = <line13> numExcessPartitions + Math.ceil(numExcessPartitions / (chunkCount - 1)); <line14> int index = 0; <line15> while (tmp > m_maxOpenContainers && i.hasNext()) { <line16> partitionRowIterators.add( <line17> i.next() <line18> .mergeChunks(exec.createSubProgress(index / numPartitionsToMergeSeparately), true)); <line19> index++; <line20> tmp = tmp - chunkCount + 1; <line21> } <line22> } <line23> exec.setProgress(1, ""Merging Done.""); <line24> while (i.hasNext()) { <line25> partitionRowIterators.add(i.next().mergeChunks(exec.createSubProgress(0), false)); <line26> } <line27> return partitionRowIterators; <line28> } <line29> } <line30> "	"<line5>    LOGGER.debug(""Merging tables"");"	task4	
public class A { <line0> @Override <line1> public void onEvent(SdpPortManagerEvent event) { <line2> if (event.getEventType().equals(SdpPortManagerEvent.ANSWER_GENERATED)) { <line3> if (event.isSuccessful()) { <line4> final byte[] sdp = event.getMediaServerSdp(); <line5> try { <line6> ((ApplicationContextImpl) _remoteParticipant.getApplicationContext()) <line7> .getRemoteCommunication() <line8> .joinAnswer(_remoteParticipant.getId(), _localParticipant.getRemoteAddress(), sdp); <line9> } catch (final Exception e) { <line10> notifyRemote = false; <line11> done(Cause.ERROR, e); <line12> } <line13> } else { <line14> Exception ex = new NegotiateException(event); <line15> notifyRemote = true; <line16> done(Cause.ERROR, ex); <line17> } <line18> } else { <line19> Exception ex = new NegotiateException(event); <line20> notifyRemote = true; <line21> done(Cause.ERROR, ex); <line22> } <line23> } <line24> } <line25> 	"<line10>          LOG.error("""", e);"	task4	
public class A { <line0> @Override <line1> public List<ReceiptDetail> reconstructReceiptDetail( <line2> final String billReferenceNumber, <line3> final BigDecimal actualAmountPaid, <line4> final List<ReceiptDetail> receiptDetailList) { <line5> final Long billID = Long.valueOf(billReferenceNumber); <line6> final List<EgBillDetails> billDetails = new ArrayList<>(0); <line7> final EgBill bill = applicationBpaBillService.updateBillWithLatest(billID); <line8> final CollectionApportioner apportioner = new CollectionApportioner(); <line9> billDetails.addAll(bill.getEgBillDetails()); <line10> return apportioner.reConstruct(actualAmountPaid, billDetails, functionDAO, chartOfAccountsDAO); <line11> } <line12> } <line13> 	"<line8>    LOGGER.debug(""Reconstruct consumer code :""+ bill.getConsumerId()+ "", with bill reference number: ""+ billReferenceNumber+ "", for Amount Paid :""+ actualAmountPaid);"	task4	
public class A { <line0> protected void logOrgExtChanges( <line1> OrgExt orgExt, EditOrgDetailsFormBean formBean, MultipartFile logo) { <line2> AdminLogType type = AdminLogType.ORG_ATTRIBUTE_CHANGED; <line3> String id = orgExt.getId(); <line4> try { <line5> if (logo != null <line6> && orgExt.getLogo() != null <line7> && !orgExt.getLogo().equals(transformLogoFileToBase64(logo))) { <line8> logUtils.createAndLogDetails(id, Org.JSON_LOGO, null, null, type); <line9> } <line10> } catch (IOException e) { <line11> } <line12> if (!orgExt.getDescription().equals(formBean.getDescription())) { <line13> logUtils.createAndLogDetails( <line14> id, Org.JSON_DESCRIPTION, orgExt.getDescription(), formBean.getDescription(), type); <line15> } <line16> if (!orgExt.getUrl().equals(formBean.getUrl())) { <line17> logUtils.createAndLogDetails(id, Org.JSON_URL, orgExt.getUrl(), formBean.getUrl(), type); <line18> } <line19> if (!orgExt.getAddress().equals(formBean.getAddress())) { <line20> logUtils.createAndLogDetails( <line21> id, OrgExt.JSON_ADDRESS, orgExt.getAddress(), formBean.getAddress(), type); <line22> } <line23> } <line24> } <line25> 	"<line11>      LOG.info(""Can't create admin log and detail for logo replacement."", e);"	task4	
public class A { <line0> public DialPlanExtension buildDialPlanExtension(final String extension) { <line1> DialPlanExtension dialPlan = null; <line2> try { <line3> dialPlan = new DialPlanExtension(extension); <line4> } catch (final IllegalArgumentException e) { <line5> } <line6> return dialPlan; <line7> } <line8> } <line9> 	<line5>      logger.error(e, e);	task4	
public class A { <line0> public boolean clientExists(Integer demographicNo) { <line1> boolean exists = getHibernateTemplate().get(Demographic.class, demographicNo) != null; <line2> return exists; <line3> } <line4> } <line5> 	"<line2>    log.debug(""exists: "" + exists);"	task4	
public class A { <line0> protected void onPageBiggerThanMaxSize(String urlStr, long pageSize) { <line1> } <line2> } <line3> 	"<line1>    logger.warn(""Skipping a URL: {} which was bigger ( {} ) than max allowed size"", urlStr, pageSize);"	task4	
public class A { <line0> @Override <line1> public void beginWindow(long windowId) { <line2> currentWindowId = windowId; <line3> store.beginTransaction(); <line4> } <line5> } <line6> 	"<line4>    logger.debug(""Transaction started for window {}"", windowId);"	task4	
public class A { <line0> protected void loadMethods() { <line1> methods = new ConcurrentHashMap<Method, Method>(); <line2> Method[] methods = getClass().getMethods(); <line3> for (Method method : methods) { <line4> if (method.getAnnotation(MethodWrapper.class) != null) { <line5> try { <line6> Method m = wrapee.getMethod(method.getName(), method.getParameterTypes()); <line7> this.methods.put(m, method); <line8> } catch (NoSuchMethodException e) { <line9> } <line10> } <line11> } <line12> } <line13> } <line14> 	<line9>          log.error(e, e);	task4	
"public class A { <line0> @Path(""/entity/{entityId}/groups"") <line1> @GET <line2> public String getGroups( <line3> @PathParam(""entityId"") String entityId, @QueryParam(""identityType"") String idType) <line4> throws EngineException, JsonProcessingException { <line5> Map<String, GroupMembership> groups = identitiesMan.getGroups(getEP(entityId, idType)); <line6> return mapper.writeValueAsString(groups.keySet()); <line7> } <line8> } <line9> "	"<line5>    log.debug(""getGroups query for "" + entityId);"	task4	
"public class A { <line0> @Override <line1> public List<PartitionGroup> findPartitionGroupLeaderBroker(String topic, String namespace) { <line2> try { <line3> List<TopicPartitionGroup> topicPartitionGroups = <line4> partitionGroupServerService.findByTopic(topic, namespace); <line5> if (null == topicPartitionGroups) { <line6> throw new IllegalArgumentException(""topic partition group is null""); <line7> } <line8> if (topicPartitionGroups.isEmpty()) { <line9> return Collections.EMPTY_LIST; <line10> } <line11> return findPartitionGroupLeaderBroker(topicPartitionGroups); <line12> } catch (Exception e) { <line13> throw new ServiceException(ServiceException.INTERNAL_SERVER_ERROR, e.getMessage(), e); <line14> } <line15> } <line16> } <line17> "	"<line13>      logger.error("""", e);"	task4	
public class A { <line0> public static String print(Node n, String encoding) { <line1> if (n == null) { <line2> return null; <line3> } <line4> try { <line5> Document document = null; <line6> if (n instanceof Document) { <line7> document = (Document) n; <line8> } else { <line9> document = n.getOwnerDocument(); <line10> } <line11> StringWriter stringOut = new StringWriter(); <line12> DOMImplementationLS domImpl = (DOMImplementationLS) document.getImplementation(); <line13> LSSerializer lsSerializer = domImpl.createLSSerializer(); <line14> lsSerializer.getDomConfig().setParameter(XML_DECLARATION, false); <line15> LSOutput lsout = domImpl.createLSOutput(); <line16> lsout.setEncoding(encoding); <line17> lsout.setCharacterStream(stringOut); <line18> if (n.getNodeType() == Node.ATTRIBUTE_NODE && n.hasChildNodes()) { <line19> n = n.getFirstChild(); <line20> } <line21> lsSerializer.write(n, lsout); <line22> return stringOut.toString(); <line23> } catch (DOMException | LSException e) { <line24> } <line25> return null; <line26> } <line27> } <line28> 	<line24>      LOGGER.debug(e.getMessage(), e);	task4	
"public class A { <line0> @Test <line1> public void testCreateGRETunnelTemplate() { <line2> template = ""/VM_files/createTunnel.vm""; <line3> String message = callGRETunnelVelocity(template, newParamsGRETunnelService()); <line4> Assert.assertNotNull(message); <line5> } <line6> } <line7> "	<line5>    log.info(message);	task4	
"public class A { <line0> @Override <line1> public Object getValueAt(int rowIndex, int columnIndex) { <line2> SRU sru = sruManager.getSRUsAsList()[rowIndex]; <line3> switch (columnIndex) { <line4> case 0: <line5> return Formatter.formatString(sru.getName()); <line6> case 1: <line7> return sru.getType(); <line8> case 2: <line9> return calculate.get(rowIndex); <line10> default: <line11> return new String(""""); <line12> } <line13> } <line14> } <line15> "	"<line11>        LOG.error(""Unknown column "" + columnIndex);"	task4	
public class A { <line0> @Override <line1> public void onSuccess(RetryContext context) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> fireConnectNotification(CONNECTION_CONNECTED, context.getDescription(), context); <line5> } <line6> } <line7> 	"<line3>      logger.debug(""Successfully connected to "" + context.getDescription());"	task4	
"public class A { <line0> private void createTestRole(String user, String roleName) throws Exception { <line1> Connection conn = context.createConnection(user); <line2> Statement stmt = conn.createStatement(); <line3> try { <line4> exec(stmt, ""DROP ROLE "" + roleName); <line5> } catch (Exception ex) { <line6> } finally { <line7> exec(stmt, ""CREATE ROLE "" + roleName); <line8> } <line9> if (stmt != null) { <line10> stmt.close(); <line11> } <line12> if (conn != null) { <line13> conn.close(); <line14> } <line15> } <line16> } <line17> "	"<line6>      LOGGER.info(""test role doesn't exist, but it's ok"");"	task4	
"public class A { <line0> public void splitPathListAndApplyPolicy( <line1> String allPathForAclCreation, <line2> Configuration conf, <line3> FileSystem fileSystem, <line4> String groupList, <line5> String hdfs_permission) <line6> throws IOException { <line7> String[] allKyloIntermediatePath = allPathForAclCreation.split("",""); <line8> for (int pathCounter = 0; pathCounter < allKyloIntermediatePath.length; pathCounter++) { <line9> try { <line10> individualIntermediatePathApplyPolicy( <line11> conf, fileSystem, allKyloIntermediatePath[pathCounter], groupList, hdfs_permission); <line12> } catch (IOException e) { <line13> throw new IOException(e); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line13>        log.error(""Unable to iterate on HDFS directories "" + e.getMessage());"	task4	
"public class A { <line0> private Boolean setEFSTag( <line1> final String resourceId, final Map<String, Object> clientMap, Map<String, String> pacTag) { <line2> com.amazonaws.services.elasticfilesystem.model.Tag tag = <line3> new com.amazonaws.services.elasticfilesystem.model.Tag(); <line4> for (Map.Entry<String, String> tags : pacTag.entrySet()) { <line5> tag.setKey(tags.getKey()); <line6> tag.setValue(tags.getValue()); <line7> } <line8> AmazonElasticFileSystem fileSystem = (AmazonElasticFileSystem) clientMap.get(""client""); <line9> com.amazonaws.services.elasticfilesystem.model.CreateTagsRequest createTagsRequest = <line10> new com.amazonaws.services.elasticfilesystem.model.CreateTagsRequest(); <line11> createTagsRequest.setFileSystemId(resourceId); <line12> createTagsRequest.setTags(Arrays.asList(tag)); <line13> try { <line14> fileSystem.createTags(createTagsRequest); <line15> return Boolean.TRUE; <line16> } catch (AmazonServiceException ase) { <line17> throw ase; <line18> } <line19> } <line20> } <line21> "	"<line17>      logger.error(""error tagging efs - > "" + resourceId, ase);"	task4	
"public class A { <line0> private SequenceContainer readSequenceContainer(SpaceSystem spaceSystem) <line1> throws XMLStreamException { <line2> checkStartElementPreconditions(); <line3> String value = readMandatoryAttribute(""name"", xmlEvent.asStartElement()); <line4> SequenceContainer seqContainer = new SequenceContainer(value); <line5> seqContainer.setShortDescription( <line6> readAttribute(""shortDescription"", xmlEvent.asStartElement(), null)); <line7> while (true) { <line8> xmlEvent = xmlEventReader.nextEvent(); <line9> if (isNamedItemProperty()) { <line10> readNamedItemProperty(seqContainer); <line11> } else if (isStartElementWithName(XTCE_ENTRY_LIST)) { <line12> readEntryList(spaceSystem, seqContainer, null); <line13> } else if (isStartElementWithName(XTCE_BASE_CONTAINER)) { <line14> readBaseContainer(spaceSystem, seqContainer); <line15> } else if (isStartElementWithName(XTCE_DEFAULT_RATE_IN_STREAM)) { <line16> seqContainer.setRateInStream(readRateInStream(spaceSystem)); <line17> } else if (isStartElementWithName(XTCE_BINARY_ENCODING)) { <line18> BinaryDataEncoding.Builder bde = readBinaryDataEncoding(spaceSystem); <line19> seqContainer.setSizeInBits(bde.getSizeInBits()); <line20> } else if (isEndElementWithName(XTCE_SEQUENCE_CONTAINER)) { <line21> return seqContainer; <line22> } else { <line23> logUnknown(); <line24> } <line25> } <line26> } <line27> } <line28> "	<line2>    log.trace(XTCE_SEQUENCE_CONTAINER);	task4	
public class A { <line0> @Override <line1> public Socket createSocket( <line2> final InetAddress address, final int port, final InetAddress localAddr, final int localPort) <line3> throws IOException { <line4> if (address instanceof Inet6Address) { <line5> final NetworkInterface network = this.findIPv6Interface((Inet6Address) address); <line6> if (null == network) { <line7> return delegate.createSocket(address, port, localAddr, localPort); <line8> } <line9> return delegate.createSocket( <line10> this.getByAddressForInterface(network, address), port, localAddr, localPort); <line11> } <line12> if (log.isDebugEnabled()) { <line13> } <line14> return delegate.createSocket(address, port, localAddr, localPort); <line15> } <line16> } <line17> 	"<line13>      log.debug(String.format(""Use default network interface to bind %s"", address));"	task4	
public class A { <line0> void notifyRemoval(Identifiable identifiable) { <line1> for (NetworkListener listener : listeners) { <line2> try { <line3> listener.onRemoval(identifiable); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>        LOGGER.error(t.toString(), t);	task4	
public class A { <line0> static synchronized ThreadPoolExecutor getExecutor( <line1> ThreadPoolBuilder builder, Map<String, Object> poolCache) { <line2> ThreadPoolExecutor pool = (ThreadPoolExecutor) poolCache.get(builder.getName()); <line3> if (pool == null || pool.isTerminating() || pool.isShutdown()) { <line4> pool = getDefaultExecutor(builder); <line5> poolCache.put(builder.getName(), pool); <line6> } <line7> ((ShutdownOnUnusedThreadPoolExecutor) pool).addReference(); <line8> return pool; <line9> } <line10> } <line11> 	"<line5>      LOG.info(""Creating new pool for "" + builder.getName());"	task4	
"public class A { <line0> private <T> ServiceResponse<T> executePatch(ServiceRequest request, boolean isChangeSet) { <line1> ServiceResponse<T> response = new ServiceResponse<>(); <line2> PersistenceManager pm = null; <line3> try { <line4> if (request.getUrlPath() == null || request.getUrlPath().equals(""/"")) { <line5> return errorResponse(response, 400, ""PATCH only allowed on Entities.""); <line6> } <line7> pm = getPm(); <line8> if (isChangeSet) { <line9> return handleChangeSet(pm, request, response); <line10> } <line11> return handlePatch(pm, request, response); <line12> } catch (IncompleteEntityException | IOException | RuntimeException exc) { <line13> if (pm != null) { <line14> pm.rollbackAndClose(); <line15> } <line16> return errorResponse(response, 500, ""Failed to store data.""); <line17> } finally { <line18> maybeRollbackAndClose(); <line19> } <line20> } <line21> } <line22> "	"<line13>      LOGGER.error("""", exc);"	task4	
"public class A { <line0> private Map<Interval, Int2ObjectMap<List<File>>> fetchSegmentFiles( <line1> TaskToolbox toolbox, Map<Interval, Int2ObjectMap<List<P>>> intervalToBuckets) <line2> throws IOException { <line3> final File tempDir = toolbox.getIndexingTmpDir(); <line4> FileUtils.deleteQuietly(tempDir); <line5> FileUtils.forceMkdir(tempDir); <line6> final Map<Interval, Int2ObjectMap<List<File>>> intervalToUnzippedFiles = new HashMap<>(); <line7> for (Entry<Interval, Int2ObjectMap<List<P>>> entryPerInterval : intervalToBuckets.entrySet()) { <line8> final Interval interval = entryPerInterval.getKey(); <line9> for (Int2ObjectMap.Entry<List<P>> entryPerBucketId : <line10> entryPerInterval.getValue().int2ObjectEntrySet()) { <line11> final int bucketId = entryPerBucketId.getIntKey(); <line12> final File partitionDir = <line13> FileUtils.getFile( <line14> tempDir, <line15> interval.getStart().toString(), <line16> interval.getEnd().toString(), <line17> Integer.toString(bucketId)); <line18> FileUtils.forceMkdir(partitionDir); <line19> for (P location : entryPerBucketId.getValue()) { <line20> final File zippedFile = <line21> toolbox.getShuffleClient().fetchSegmentFile(partitionDir, supervisorTaskId, location); <line22> try { <line23> final File unzippedDir = <line24> new File(partitionDir, StringUtils.format(""unzipped_%s"", location.getSubTaskId())); <line25> FileUtils.forceMkdir(unzippedDir); <line26> CompressionUtils.unzip(zippedFile, unzippedDir); <line27> intervalToUnzippedFiles <line28> .computeIfAbsent(interval, k -> new Int2ObjectOpenHashMap<>()) <line29> .computeIfAbsent(bucketId, k -> new ArrayList<>()) <line30> .add(unzippedDir); <line31> } finally { <line32> if (!zippedFile.delete()) { <line33> } <line34> } <line35> } <line36> } <line37> } <line38> return intervalToUnzippedFiles; <line39> } <line40> } <line41> "	"<line33>              LOG.warn(""Failed to delete temp file[%s]"", zippedFile);"	task4	
"public class A { <line0> public static File extractFile(String fileName, String targetInfix, TokenResolver tokenResolver) <line1> throws IOException { <line2> InputStream in = Externalization.class.getClassLoader().getResourceAsStream(fileName); <line3> if (in == null) return null; <line4> File target = getTempFile(fileName.replace(""."", ""_"" + targetInfix + ""."")); <line5> Reader reader = new TokenReplacingReader(new InputStreamReader(in), tokenResolver); <line6> FileWriter writer = new FileWriter(target); <line7> copyAndClose(reader, writer); <line8> return target; <line9> } <line10> } <line11> "	"<line5>    log.info(""Extracting "" + fileName + "" to "" + target);"	task4	
public class A { <line0> @Override <line1> public void addOrder(Transaction transaction, ColoredCoinsBidOrderPlacement attachment) { <line2> final BidOrder order = new BidOrder(transaction, attachment, blockchain.getHeight()); <line3> bidOrderTable.insert(order); <line4> } <line5> } <line6> 	"<line3>    log.trace("">> addOrder() bidOrder={}"", order);"	task4	
public class A { <line0> public void run(final SyncTaskChain chain) { <line1> if (isCancelled()) { <line2> callNext(chain); <line3> return; <line4> } <line5> try { <line6> getTask() <line7> .run( <line8> () -> { <line9> try { <line10> done(); <line11> } finally { <line12> callNext(chain); <line13> } <line14> }); <line15> } catch (Throwable t) { <line16> try { <line17> if (!(t instanceof OperationFailureException)) { <line18> } <line19> done(); <line20> } finally { <line21> callNext(chain); <line22> } <line23> } <line24> } <line25> } <line26> 	"<line18>          logger.warn(String.format(""unhandled exception happened when calling %s"", task.getClass().getName()),t);"	task4	
"public class A { <line0> @Test <line1> public void testAsyncCallUseProperAssignedExecutor() throws Exception { <line2> URL wsdl = getClass().getResource(""/wsdl/hello_world.wsdl""); <line3> assertNotNull(wsdl); <line4> SOAPService service = new SOAPService(wsdl, serviceName); <line5> class TestExecutor implements Executor { <line6> private AtomicInteger count = new AtomicInteger(); <line7>  <line8> public void execute(Runnable command) { <line9> int c = count.incrementAndGet(); <line10> command.run(); <line11> } <line12>  <line13> public int getCount() { <line14> return count.get(); <line15> } <line16> } <line17> Executor executor = new TestExecutor(); <line18> service.setExecutor(executor); <line19> assertNotNull(service); <line20> assertSame(executor, service.getExecutor()); <line21> assertEquals(((TestExecutor) executor).getCount(), 0); <line22> Greeter greeter = service.getPort(portName, Greeter.class); <line23> updateAddressPort(greeter, PORT); <line24> List<Response<GreetMeResponse>> responses = new ArrayList<>(); <line25> for (int i = 0; i < 5; i++) { <line26> responses.add(greeter.greetMeAsync(""asyn call"" + i)); <line27> } <line28> for (Response<GreetMeResponse> resp : responses) { <line29> resp.get(); <line30> } <line31> assertEquals(5, ((TestExecutor) executor).getCount()); <line32> } <line33> } <line34> "	"<line10>        LOG.info(""asyn call time "" + c);"	task4	
public class A { <line0> @Override <line1> public void setResponseString(String responseString) { <line2> waitResponseOpen(); <line3> synchronized (response) { <line4> response.setString(responseString); <line5> response.notifyAll(); <line6> } <line7> } <line8> } <line9> 	"<line6>      logger.debug(""Got response string from player: "" + getId());"	task4	
"public class A { <line0> public SearchResult<Series> getByQuery(SeriesSearchQuery query) throws SearchIndexException { <line1> final SearchRequest searchRequest = getSearchRequest(query, new SeriesQueryBuilder(query)); <line2> try { <line3> final Unmarshaller unmarshaller = Series.createUnmarshaller(); <line4> return executeQuery( <line5> query, <line6> searchRequest, <line7> metadata -> { <line8> try { <line9> return SeriesIndexUtils.toSeries(metadata, unmarshaller); <line10> } catch (IOException e) { <line11> return chuck(e); <line12> } <line13> }); <line14> } catch (Throwable t) { <line15> throw new SearchIndexException(""Error querying series index"", t); <line16> } <line17> } <line18> } <line19> "	"<line1>    logger.debug(""Searching index using series query '{}'"", query);"	task4	
public class A { <line0> @Override <line1> public void ack(Tuple input) { <line2> if (!ackingEnabled) { <line3> return; <line4> } <line5> long ackValue = ((TupleImpl) input).getAckVal(); <line6> Map<Long, Long> anchorsToIds = input.getMessageId().getAnchorsToIds(); <line7> for (Map.Entry<Long, Long> entry : anchorsToIds.entrySet()) { <line8> task.sendUnanchored( <line9> Acker.ACKER_ACK_STREAM_ID, <line10> new Values(entry.getKey(), Utils.bitXor(entry.getValue(), ackValue)), <line11> executor.getExecutorTransfer(), <line12> executor.getPendingEmits()); <line13> } <line14> long delta = tupleTimeDelta((TupleImpl) input); <line15> if (isDebug) { <line16> } <line17> if (!task.getUserContext().getHooks().isEmpty()) { <line18> BoltAckInfo boltAckInfo = new BoltAckInfo(input, taskId, delta); <line19> boltAckInfo.applyOn(task.getUserContext()); <line20> } <line21> if (delta >= 0) { <line22> executor <line23> .getStats() <line24> .boltAckedTuple(input.getSourceComponent(), input.getSourceStreamId(), delta); <line25> task.getTaskMetrics() <line26> .boltAckedTuple(input.getSourceComponent(), input.getSourceStreamId(), delta); <line27> } <line28> } <line29> } <line30> 	"<line16>      LOG.info(""BOLT ack TASK: {} TIME: {} TUPLE: {}"", taskId, delta, input);"	task4	
"public class A { <line0> @Override <line1> public void start( <line2> int port, int backlog, int listenThreadCount, int handleThreadCount, boolean forceExit) { <line3> EventLoopGroup bossGroup = new NioEventLoopGroup(listenThreadCount); <line4> EventLoopGroup workerGroup = new NioEventLoopGroup(handleThreadCount); <line5> server = new ServerBootstrap(); <line6> server <line7> .group(bossGroup, workerGroup) <line8> .channel(NioServerSocketChannel.class) <line9> .localAddress(port) <line10> .option(ChannelOption.SO_BACKLOG, backlog) <line11> .childHandler(new HttpServerInitializer(this)); <line12> try { <line13> this.host = NetworkHelper.getLocalIP(); <line14> this.port = port; <line15> server.bind().sync(); <line16> if (log.isTraceEnable()) { <line17> } <line18> } catch (Exception e) { <line19> log.err( <line20> this, <line21> ""HttpServiceComponent["" + this.cName + ""] for feature["" + this.feature + ""] starts FAIL."", <line22> e); <line23> if (forceExit == true) { <line24> System.exit(-1); <line25> } <line26> } <line27> } <line28> } <line29> "	"<line17>        log.info(this,""HttpServiceComponent[""+ this.cName+ ""] for feature[""+ this.feature+ ""] started SUCCESS: port=""+ this.port);"	task4	
"public class A { <line0> public void start() { <line1> if (authzPaths != null || authzPermissions != null) { <line2> boolean success = false; <line3> try { <line4> success = update(); <line5> } catch (Exception ex) { <line6> success = false; <line7> } <line8> if (!success) { <line9> waitUntil = System.currentTimeMillis() + retryWaitMillisec; <line10> } <line11> executor = <line12> Executors.newSingleThreadScheduledExecutor( <line13> new ThreadFactory() { <line14> @Override <line15> public Thread newThread(Runnable r) { <line16> Thread t = new Thread(r, SentryAuthorizationInfo.class.getName() + ""-refresher""); <line17> t.setDaemon(true); <line18> return t; <line19> } <line20> }); <line21> executor.scheduleWithFixedDelay( <line22> this, refreshIntervalMillisec, refreshIntervalMillisec, TimeUnit.MILLISECONDS); <line23> } <line24> } <line25> } <line26> "	"<line7>        LOG.warn(""Failed to do initial update, will retry in [{}]ms, error: "",new Object[] {retryWaitMillisec, ex.getMessage(), ex});"	task4	
"public class A { <line0> @Override <line1> public JPACommit getLastCommit(Map<String, Object> param) throws EDBException { <line2> synchronized (entityManager) { <line3> CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder(); <line4> CriteriaQuery<JPACommit> query = criteriaBuilder.createQuery(JPACommit.class); <line5> Root<JPACommit> from = query.from(JPACommit.class); <line6> query.select(from); <line7> Predicate[] predicates = analyzeParamMap(criteriaBuilder, from, param); <line8> query.where(criteriaBuilder.and(predicates)); <line9> query.orderBy(criteriaBuilder.desc(from.get(""timestamp""))); <line10> TypedQuery<JPACommit> typedQuery = entityManager.createQuery(query).setMaxResults(1); <line11> try { <line12> return typedQuery.getSingleResult(); <line13> } catch (NoResultException ex) { <line14> throw new EDBException(""there was no Object found with the given query parameters"", ex); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line3>      LOGGER.debug(""Get last commit which are given to a param map with {} elements"", param.size());"	task4	
"public class A { <line0> public void tryMkDir(final Path dir) throws IOException { <line1> callHdfsOperation( <line2> new HdfsOperation<Void>() { <line3> @Override <line4> public Void call() throws IOException { <line5> if (!fs.exists(dir)) { <line6> fs.mkdirs(dir); <line7> } <line8> if (fs.getFileStatus(dir).isFile()) { <line9> throw new IOException( <line10> dir.toString() <line11> + "" is file instead of directory, please remove "" <line12> + ""it or specify another directory""); <line13> } <line14> fs.mkdirs(dir); <line15> return null; <line16> } <line17> }); <line18> } <line19> } <line20> "	"<line7>              LOGGER.info(""Create dir {} in hdfs"", dir);"	task4	
"public class A { <line0> @Test <line1> void testXml() throws Exception { <line2> List<CamelEndpointDetails> endpoints = new ArrayList<>(); <line3> InputStream is = <line4> new FileInputStream( <line5> ""src/test/resources/org/apache/camel/parser/xml/mycamel-onexception.xml""); <line6> String fqn = ""src/test/resources/org/apache/camel/parser/xml/mycamel-onexception.xml""; <line7> String baseDir = ""src/test/resources""; <line8> XmlRouteParser.parseXmlRouteEndpoints(is, baseDir, fqn, endpoints); <line9> for (CamelEndpointDetails detail : endpoints) { <line10> } <line11> assertEquals(""log:all"", endpoints.get(0).getEndpointUri()); <line12> assertEquals(""mock:dead"", endpoints.get(1).getEndpointUri()); <line13> assertEquals(""log:done"", endpoints.get(2).getEndpointUri()); <line14> assertEquals(""stream:in?promptMessage=Enter something:"", endpoints.get(3).getEndpointUri()); <line15> assertEquals(""stream:out"", endpoints.get(4).getEndpointUri()); <line16> } <line17> } <line18> "	<line10>      LOG.info(detail.getEndpointUri());	task4	
"public class A { <line0> public void permissionDenied(final SessionId session) { <line1> invalidateSessionCookiesIfNeeded(); <line2> if (session == null) { <line3> authenticationFailedSessionInvalid(); <line4> return; <line5> } <line6> String baseRedirectUri = session.getSessionAttributes().get(AuthorizeRequestParam.REDIRECT_URI); <line7> String state = session.getSessionAttributes().get(AuthorizeRequestParam.STATE); <line8> ResponseMode responseMode = <line9> ResponseMode.fromString( <line10> session.getSessionAttributes().get(AuthorizeRequestParam.RESPONSE_MODE)); <line11> List<ResponseType> responseType = <line12> ResponseType.fromString( <line13> session.getSessionAttributes().get(AuthorizeRequestParam.RESPONSE_TYPE), "" ""); <line14> RedirectUri redirectUri = new RedirectUri(baseRedirectUri, responseType, responseMode); <line15> redirectUri.parseQueryString( <line16> errorResponseFactory.getErrorAsQueryString( <line17> AuthorizeErrorResponseType.ACCESS_DENIED, state)); <line18> Map<String, String> sessionAttribute = <line19> requestParameterService.getAllowedParameters(session.getSessionAttributes()); <line20> if (sessionAttribute.containsKey(AuthorizeRequestParam.AUTH_REQ_ID)) { <line21> String authReqId = sessionAttribute.get(AuthorizeRequestParam.AUTH_REQ_ID); <line22> CibaRequestCacheControl request = cibaRequestService.getCibaRequest(authReqId); <line23> if (request != null && request.getClient() != null) { <line24> if (request.getStatus() == CibaRequestStatus.PENDING) { <line25> cibaRequestService.removeCibaRequest(authReqId); <line26> } <line27> switch (request.getClient().getBackchannelTokenDeliveryMode()) { <line28> case POLL: <line29> request.setStatus(CibaRequestStatus.DENIED); <line30> request.setTokensDelivered(false); <line31> cibaRequestService.update(request); <line32> break; <line33> case PING: <line34> request.setStatus(CibaRequestStatus.DENIED); <line35> request.setTokensDelivered(false); <line36> cibaRequestService.update(request); <line37> cibaPingCallbackService.pingCallback( <line38> request.getAuthReqId(), <line39> request.getClient().getBackchannelClientNotificationEndpoint(), <line40> request.getClientNotificationToken()); <line41> break; <line42> case PUSH: <line43> cibaPushErrorService.pushError( <line44> request.getAuthReqId(), <line45> request.getClient().getBackchannelClientNotificationEndpoint(), <line46> request.getClientNotificationToken(), <line47> PushErrorResponseType.ACCESS_DENIED, <line48> ""The end-user denied the authorization request.""); <line49> break; <line50> } <line51> } <line52> } <line53> if (sessionAttribute.containsKey(DeviceAuthorizationService.SESSION_USER_CODE)) { <line54> processDeviceAuthDeniedResponse(sessionAttribute); <line55> } <line56> facesService.redirectToExternalURL(redirectUri.toString()); <line57> } <line58> } <line59> "	"<line1>    log.trace(""permissionDenied"");"	task4	
public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent ev) { <line2> boolean ok = toolsDialog.showDialog(config, true); <line3> if (!ok) { <line4> return; <line5> } <line6> } <line7> } <line8> 	"<line2>    logger.debug(""Edit tools"");"	task4	
"public class A { <line0> public static java.util.List<com.liferay.layout.page.template.model.LayoutPageTemplateEntry> <line1> getLayoutPageTemplateEntries( <line2> HttpPrincipal httpPrincipal, <line3> long groupId, <line4> int type, <line5> int status, <line6> int start, <line7> int end, <line8> com.liferay.portal.kernel.util.OrderByComparator< <line9> com.liferay.layout.page.template.model.LayoutPageTemplateEntry> <line10> orderByComparator) { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> LayoutPageTemplateEntryServiceUtil.class, <line15> ""getLayoutPageTemplateEntries"", <line16> _getLayoutPageTemplateEntriesParameterTypes12); <line17> MethodHandler methodHandler = <line18> new MethodHandler(methodKey, groupId, type, status, start, end, orderByComparator); <line19> Object returnObj = null; <line20> try { <line21> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line22> } catch (Exception exception) { <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (java.util.List<com.liferay.layout.page.template.model.LayoutPageTemplateEntry>) <line26> returnObj; <line27> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line28> throw systemException; <line29> } <line30> } <line31> } <line32> "	<line28>      log.error(systemException, systemException);	task4	
public class A { <line0> public void addAttachment(BasicIssue basicIssue, File snapshot) { <line1> if (snapshot != null) { <line2> Issue issue = restClient.getIssueClient().getIssue(basicIssue.getKey()).claim(); <line3> restClient.getIssueClient().addAttachments(issue.getAttachmentsUri(), snapshot).claim(); <line4> } <line5> } <line6> } <line7> 	"<line2>      LOG.info(""Attaching Jira {} with snapshot"", basicIssue.getKey());"	task4	
"public class A { <line0> @RequestMapping(""/adminStudies/deleteComprehensionQuestion.do"") <line1> public void deleteComprehensionTestQuestion( <line2> HttpServletRequest request, HttpServletResponse response) { <line3> logger.entry(""begin deleteComprehensionTestQuestion()""); <line4> JSONObject jsonobject = new JSONObject(); <line5> PrintWriter out = null; <line6> String message = FdahpStudyDesignerConstants.FAILURE; <line7> try { <line8> SessionObject sesObj = <line9> (SessionObject) <line10> request.getSession().getAttribute(FdahpStudyDesignerConstants.SESSION_OBJECT); <line11> if (sesObj != null) { <line12> String comprehensionQuestionId = <line13> FdahpStudyDesignerUtil.isEmpty( <line14> request.getParameter(FdahpStudyDesignerConstants.COMPREHENSION_QUESTION_ID)) <line15> ? """" <line16> : request.getParameter(FdahpStudyDesignerConstants.COMPREHENSION_QUESTION_ID); <line17> String studyId = <line18> FdahpStudyDesignerUtil.isEmpty( <line19> request.getParameter(FdahpStudyDesignerConstants.STUDY_ID)) <line20> ? """" <line21> : request.getParameter(FdahpStudyDesignerConstants.STUDY_ID); <line22> if (StringUtils.isNotEmpty(comprehensionQuestionId) && StringUtils.isNotEmpty(studyId)) { <line23> message = <line24> studyService.deleteComprehensionTestQuestion( <line25> Integer.valueOf(comprehensionQuestionId), Integer.valueOf(studyId), sesObj); <line26> } <line27> } <line28> jsonobject.put(FdahpStudyDesignerConstants.MESSAGE, message); <line29> response.setContentType(FdahpStudyDesignerConstants.APPLICATION_JSON); <line30> out = response.getWriter(); <line31> out.print(jsonobject); <line32> } catch (Exception e) { <line33> } <line34> logger.exit(""deleteComprehensionTestQuestion() - Ends""); <line35> } <line36> } <line37> "	"<line33>      logger.error(""StudyController - deleteComprehensionTestQuestion - ERROR"", e);"	task4	
public class A { <line0> @Override <line1> public void afterPropertiesSet() throws Exception { <line2> loadPlugins(); <line3> startPlugins(); <line4> AbstractAutowireCapableBeanFactory beanFactory = <line5> (AbstractAutowireCapableBeanFactory) applicationContext.getAutowireCapableBeanFactory(); <line6> ExtensionsInjector extensionsInjector = new ExtensionsInjector(this, beanFactory); <line7> extensionsInjector.injectExtensions(); <line8> for (PluginWrapper plugin : getStartedPlugins()) { <line9> Class pluginClass = plugin.getPlugin().getClass(); <line10> GenericApplicationContext pluginContext = <line11> (GenericApplicationContext) ((Plugin) plugin.getPlugin()).getApplicationContext(); <line12> pluginContext.setParent(applicationContext); <line13> } <line14> } <line15> } <line16> 	"<line10>      LOG.info(""Found plugin: {}"", plugin.getDescriptor().getPluginId());"	task4	
public class A { <line0> @Override <line1> public void handleResponse(final DeviceResponse deviceResponse) { <line2> if (((EmptyDeviceResponse) deviceResponse).getStatus().equals(DeviceMessageStatus.OK)) { <line3> } else { <line4> PublicLightingSetLightRequestMessageProcessor.this.handleEmptyDeviceResponse( <line5> deviceResponse, <line6> PublicLightingSetLightRequestMessageProcessor.this.responseMessageSender, <line7> domain, <line8> domainVersion, <line9> messageType, <line10> retryCount); <line11> } <line12> } <line13> } <line14> 	"<line3>      LOGGER.info(""setLight() successful for device : {}"", deviceResponse.getDeviceIdentification());"	task4	
"public class A { <line0> public void acceptReducedValues(DataInput reducedValuesInput) throws IOException { <line1> int numReducers = reducedValuesInput.readInt(); <line2> for (int i = 0; i < numReducers; i++) { <line3> String name = reducedValuesInput.readUTF(); <line4> GlobalCommType type = GlobalCommType.values()[reducedValuesInput.readByte()]; <line5> if (type != GlobalCommType.REDUCED_VALUE) { <line6> throw new IllegalStateException(""SendReducedToMasterRequest received "" + type); <line7> } <line8> Reducer<Object, Writable> reducer = reducerMap.get(name); <line9> if (reducer == null) { <line10> throw new IllegalStateException( <line11> ""acceptReducedValues: "" <line12> + ""Master received reduced value which isn't registered: "" <line13> + name); <line14> } <line15> Writable valueToReduce = reducer.createInitialValue(); <line16> valueToReduce.readFields(reducedValuesInput); <line17> if (reducer.getCurrentValue() != null) { <line18> reducer.reduceMerge(valueToReduce); <line19> } else { <line20> reducer.setCurrentValue(valueToReduce); <line21> } <line22> progressable.progress(); <line23> } <line24> if (LOG.isDebugEnabled()) { <line25> } <line26> } <line27> } <line28> "	"<line25>      LOG.debug(""acceptReducedValues: Accepted one set with "" + numReducers + "" aggregated values"");"	task4	
public class A { <line0> @Override <line1> public Map<K, ICacheElement<K, V>> getMatching(final String pattern) throws IOException { <line2> for (final RemoteCacheNoWait<K, V> nw : noWaits) { <line3> try { <line4> return nw.getMatching(pattern); <line5> } catch (final IOException ex) { <line6> } <line7> } <line8> return Collections.emptyMap(); <line9> } <line10> } <line11> 	"<line6>        log.debug(""Failed to getMatching."");"	task4	
public class A { <line0> public void stopCounting() { <line1> runCounting = false; <line2> stopLogReport(); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""Stop counting..."");"	task4	
public class A { <line0> public void addHandler(JettyHandler handler) { <line1> ServletHolder servletHolder = new ServletHolder(); <line2> servletHolder.setServlet(handler); <line3> servletContextHandler.addServlet(servletHolder, handler.pathSpec()); <line4> } <line5> } <line6> 	"<line1>    LOGGER.info(""Bind handler {} into jetty server {}:{}"",handler.getClass().getSimpleName(),jettyServerConfig.getHost(),jettyServerConfig.getPort());"	task4	
"public class A { <line0> @Test <line1> public void testManyFiles() throws Exception { <line2> Session s = conn.createSession(true, Session.SESSION_TRANSACTED); <line3> Queue jmsQueue = s.createQueue(address.toString()); <line4> MessageProducer p = s.createProducer(jmsQueue); <line5> p.setDeliveryMode(DeliveryMode.PERSISTENT); <line6> conn.start(); <line7> for (int i = 0; i < 1000; i++) { <line8> p.send(s.createTextMessage(""payload"")); <line9> server.getStorageManager().getMessageJournal().forceMoveNextFile(); <line10> } <line11> s.commit(); <line12> Assert.assertTrue( <line13> server <line14> .getStorageManager() <line15> .getJournalSequentialFileFactory() <line16> .getCriticalAnalyzer() <line17> .getNumberOfComponents() <line18> < 10); <line19> } <line20> } <line21> "	"<line19>    log.debug(""Number of components:""+ server.getStorageManager().getJournalSequentialFileFactory().getCriticalAnalyzer().getNumberOfComponents());"	task4	
public class A { <line0> public Double dot(Matrix m) { <line1> if (numRows != m.numRows || numCols != m.numCols) { <line2> return 0.0; <line3> } <line4> double sum = 0; <line5> for (int r = 0; r < numRows; r++) <line6> for (int c = 0; c < numCols; c++) sum += this.elements[r][c] * m.elements[r][c]; <line7> return sum; <line8> } <line9> } <line10> 	"<line2>      log.info(""dimensions bad in dot()"");"	task4	
public class A { <line0> @Override <line1> public void init( <line2> SortedKeyValueIterator<Key, Value> source, <line3> Map<String, String> options, <line4> IteratorEnvironment env) <line5> throws IOException { <line6> if (log.isTraceEnabled()) { <line7> } <line8> super.init(source, options, env); <line9> this.mustUseFieldIndex = true; <line10> fieldIndexKeyDataTypeFilter = <line11> parseIndexFilteringChain(new SourcedOptions<>(source, env, options)); <line12> disableIndexOnlyDocuments = false; <line13> } <line14> } <line15> 	"<line7>      log.trace(""AncestorQueryIterator init()"");"	task4	
public class A { <line0> @Override <line1> public void cleanup() { <line2> try { <line3> lookup.close(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.error(""Unable to cleanup access tracker"", e);"	task4	
public class A { <line0> @Override <line1> protected void doStop() throws Exception { <line2> super.doStop(); <line3> if (configuration.isWebhookAutoRegister() && delegateEndpoint != null) { <line4> delegateEndpoint.unregisterWebhook(); <line5> } <line6> ServiceHelper.stopService(delegateEndpoint); <line7> } <line8> } <line9> 	"<line4>      LOG.info(""Unregistering webhook for endpoint: {}"", delegateEndpoint);"	task4	
"public class A { <line0> private void insertObservations() <line1> throws UnsupportedEncodingException, IOException, XmlException, OwsExceptionReport { <line2> ExecutorService threadPool = <line3> Executors.newFixedThreadPool( <line4> 5, new GroupedAndNamedThreadFactory(""52n-sample-data-insert-observations"")); <line5> for (File observationFile : getFilesBySuffix(OBS_XML_FILE_ENDING)) { <line6> threadPool.submit(new InsertObservationTask(observationFile)); <line7> } <line8> try { <line9> threadPool.shutdown(); <line10> while (!threadPool.isTerminated()) { <line11> Thread.sleep(THREADPOOL_SLEEP_BETWEEN_CHECKS); <line12> } <line13> } catch (InterruptedException e) { <line14> } <line15> exceptions.throwIfNotEmpty(); <line16> } <line17> } <line18> "	"<line14>      LOG.error(""Insert obervations thread was interrupted!"", e);"	task4	
public class A { <line0> protected void doClean(Exchange exchange, String operation) throws Exception { <line1> Set<String> result = null; <line2> try { <line3> if (ObjectHelper.isNotEmpty(endpoint.getBranchName())) { <line4> git.checkout().setCreateBranch(false).setName(endpoint.getBranchName()).call(); <line5> } <line6> result = git.clean().setCleanDirectories(true).call(); <line7> } catch (Exception e) { <line8> throw e; <line9> } <line10> updateExchange(exchange, result); <line11> } <line12> } <line13> 	"<line8>      LOG.error(""There was an error in Git {} operation"", operation);"	task4	
public class A { <line0> protected void failRevertFileVersion(String version) throws PortalException { <line1> try { <line2> revertFileVersion(version, null); <line3> Assert.fail(); <line4> } catch (InvalidFileVersionException invalidFileVersionException) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>        log.debug(invalidFileVersionException, invalidFileVersionException);	task4	
public class A { <line0> @Override <line1> public NSDictionary objectForKey(final String key) { <line2> final NSObject value = dict.objectForKey(key); <line3> if (null == value) { <line4> return null; <line5> } <line6> if (value instanceof NSDictionary) { <line7> return (NSDictionary) value; <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line9>    log.warn(String.format(""Unexpected value type for serialized key %s"", key));"	task4	
"public class A { <line0> @Override <line1> public void rollback(Xid xid) throws XAException { <line2> if (this.xid == null || !this.xid.equals(xid)) { <line3> throw newXAException(XAER_INVAL, ""Invalid Xid""); <line4> } <line5> this.xid = null; <line6> try { <line7> owner.connection.rollback(); <line8> } catch (SQLException e) { <line9> throw newXAException(XAER_RMERR, ""Cannot rollback"", e); <line10> } finally { <line11> try { <line12> owner.connection.setAutoCommit(true); <line13> } catch (SQLException e) { <line14> } <line15> } <line16> } <line17> } <line18> "	"<line14>        log.error(""Cannot set autoCommit=true"", e);"	task4	
public class A { <line0> public Set<Artifact> resolveArtifacts(Set<String> coords) { <line1> Set<Artifact> result = new LinkedHashSet<>(); <line2> for (String coord : coords) { <line3> Artifact artifact = resolveArtifact(coord); <line4> if (artifact != null) { <line5> result.add(artifact); <line6> } <line7> } <line8> return result; <line9> } <line10> } <line11> 	"<line8>    LOG.trace(""resolveArtifacts({}) returns {}"", coords, result);"	task4	
public class A { <line0> public static PublicKey loadPublicKeyFromPem(String publicPart, String algorithm) { <line1> try { <line2> var reader = new StringReader(publicPart); <line3> var readerPem = new PemReader(reader); <line4> var obj = readerPem.readPemObject(); <line5> readerPem.close(); <line6> return KeyFactory.getInstance(algorithm) <line7> .generatePublic(new X509EncodedKeySpec(obj.getContent())); <line8> } catch (InvalidKeySpecException | NoSuchAlgorithmException | IOException e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	"<line9>      logger.warn(""Exception loading public key from PEM"", e);"	task4	
"public class A { <line0> @Path(""/entity/{entityId}/credential/{credential}/status/{status}"") <line1> @PUT <line2> public void setCredentialStatus( <line3> @PathParam(""entityId"") String entityId, <line4> @PathParam(""credential"") String credential, <line5> @QueryParam(""identityType"") String idType, <line6> @PathParam(""status"") String status) <line7> throws EngineException, JsonProcessingException { <line8> LocalCredentialState desiredCredentialState = LocalCredentialState.valueOf(status); <line9> entityCredMan.setEntityCredentialStatus( <line10> getEP(entityId, idType), credential, desiredCredentialState); <line11> } <line12> } <line13> "	"<line8>    log.info(""setCredential {} status for {} to {}"", credential, entityId, status);"	task4	
"public class A { <line0> @Test <line1> public void testBbox1() { <line2> Document doc = <line3> getAsDOM( <line4> ""wfs?request=GetFeature&version=1.1.0&typename=gsml:MappedFeature&srsName=EPSG:4979&bbox=-200,-200,0,200,200,50""); <line5> assertXpathCount(0, ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf1']"", doc); <line6> assertXpathCount(1, ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf2']"", doc); <line7> assertXpathCount(1, ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf3']"", doc); <line8> assertXpathCount(0, ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf4']"", doc); <line9> assertXpathEvaluatesTo( <line10> ""167.9388 -29.0434 7"", <line11> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf2']/gsml:shape/gml:Point/gml:pos"", <line12> doc); <line13> assertXpathEvaluatesTo( <line14> ""3"", <line15> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf2']/gsml:shape/gml:Point/@srsDimension"", <line16> doc); <line17> assertXpathEvaluatesTo( <line18> ""http://www.opengis.net/gml/srs/epsg.xml#4979"", <line19> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.mf2']/gsml:shape/gml:Point/@srsName"", <line20> doc); <line21> } <line22> } <line23> "	"<line5>    LOGGER.info(""WFS GetFeature&typename=gsml:MappedFeature response:\n"" + prettyString(doc));"	task4	
public class A { <line0> private ServerConnector createHttpConnector(Config config) { <line1> final ServerConnector httpConnector = <line2> new ServerConnector(jettyServer, new HttpConnectionFactory(baseHttpConfig())); <line3> httpConnector.setPort(config.getInt(DrillOnYarnConfig.HTTP_PORT)); <line4> return httpConnector; <line5> } <line6> } <line7> 	"<line1>    LOG.info(""Setting up HTTP connector for web server"");"	task4	
public class A { <line0> @Override <line1> public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException { <line2> return listStatus(f, null); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""List status of {}"", f.toString());"	task4	
"public class A { <line0> private void detectConflictingRoutes(Map<RouteMatcher, MethodInfo> matchers) { <line1> if (matchers.isEmpty()) { <line2> return; <line3> } <line4> Set<LinkedHashSet<RouteMatcher>> groups = new HashSet<>(); <line5> for (Iterator<Entry<RouteMatcher, MethodInfo>> iterator = matchers.entrySet().iterator(); <line6> iterator.hasNext(); ) { <line7> Entry<RouteMatcher, MethodInfo> entry = iterator.next(); <line8> LinkedHashSet<RouteMatcher> group = new LinkedHashSet<>(); <line9> group.add(entry.getKey()); <line10> matchers.entrySet().stream() <line11> .filter( <line12> e -> { <line13> if (e.getKey().equals(entry.getKey())) { <line14> return false; <line15> } <line16> if (e.getValue().equals(entry.getValue())) { <line17> return false; <line18> } <line19> if (e.getKey().getOrder() != entry.getKey().getOrder()) { <line20> return false; <line21> } <line22> return canMatchSameRequest(entry.getKey(), e.getKey()); <line23> }) <line24> .map(Entry::getKey) <line25> .forEach(group::add); <line26> groups.add(group); <line27> } <line28> boolean conflictExists = false; <line29> for (Set<RouteMatcher> group : groups) { <line30> if (group.size() > 1) { <line31> Iterator<RouteMatcher> it = group.iterator(); <line32> RouteMatcher firstMatcher = it.next(); <line33> MethodInfo firstMethod = matchers.get(firstMatcher); <line34> conflictExists = true; <line35> StringBuilder conflictingRoutes = new StringBuilder(); <line36> while (it.hasNext()) { <line37> RouteMatcher rm = it.next(); <line38> MethodInfo method = matchers.get(rm); <line39> conflictingRoutes <line40> .append(""\n\t- "") <line41> .append(method.declaringClass().name().toString()) <line42> .append(""#"") <line43> .append(method.name()) <line44> .append(""()""); <line45> } <line46> LOGGER.warnf( <line47> ""Route %s#%s() can match the same request and has the same order [%s] as:%s"", <line48> firstMethod.declaringClass().name(), <line49> firstMethod.name(), <line50> firstMatcher.getOrder(), <line51> conflictingRoutes); <line52> } <line53> } <line54> if (conflictExists) { <line55> } <line56> } <line57> } <line58> "	"<line55>      LOGGER.warn(""You can use @Route#order() to ensure the routes are not executed in random order"");"	task4	
public class A { <line0> @Override <line1> public boolean isEmpty() { <line2> return atomContainerCount == 0; <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Checking if the atom container set empty: "", atomContainerCount == 0);"	task4	
public class A { <line0> @Override <line1> public synchronized void triggerTimeout(final long timeout, final boolean causedBySession) { <line2> final Future<?> f = sessionFuture.get(); <line3> if (f != null && !f.isDone()) { <line4> if (closeReason.compareAndSet( <line5> null, causedBySession ? CloseReason.SESSION_TIMEOUT : CloseReason.REQUEST_TIMEOUT)) { <line6> actualTimeoutLengthWhenClosed = timeout; <line7> if (causedBySession || !sessionIdOnRequest) cancel(true); <line8> else { <line9> if (sessionThread != null) { <line10> sessionThread.interrupt(); <line11> } else { <line12> } <line13> } <line14> } <line15> } <line16> } <line17> } <line18> 	"<line12>            logger.debug(""{} is a {} which is not interruptable as the thread running the session has not ""+ ""been set - please check the implementation if this is not desirable"",sessionId,this.getClass().getSimpleName());"	task4	
public class A { <line0> @Override <line1> protected void onStop() { <line2> setPollingWait(-1); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Twilight plugin stopped "");"	task4	
"public class A { <line0> @Test <line1> public void testExecuteFailure() throws Exception { <line2> String command = getJavaCommand() + "" org.springframework.batch.sample.tasklet.UnknownClass""; <line3> tasklet.setCommand(command); <line4> tasklet.setTimeout(200L); <line5> tasklet.afterPropertiesSet(); <line6> try { <line7> StepContribution contribution = stepExecution.createStepContribution(); <line8> RepeatStatus exitStatus = tasklet.execute(contribution, null); <line9> assertEquals(RepeatStatus.FINISHED, exitStatus); <line10> assertEquals(ExitStatus.FAILED, contribution.getExitStatus()); <line11> } catch (RuntimeException e) { <line12> assertEquals(""Execution of system command did not finish within the timeout"", e.getMessage()); <line13> } <line14> } <line15> } <line16> "	"<line6>    log.info(""Executing command: "" + command);"	task4	
public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final RemediationTO ignore) { <line2> try { <line3> RemediationRestClient.delete(model.getObject().getKey()); <line4> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line5> target.add(container); <line6> } catch (SyncopeClientException e) { <line7> SyncopeConsoleSession.get().onException(e); <line8> } <line9> ((BasePage) pageRef.getPage()).getNotificationPanel().refresh(target); <line10> } <line11> } <line12> 	"<line7>      LOG.error(""While deleting {}"", model.getObject().getKey(), e);"	task4	
"public class A { <line0> public void runIteration( <line1> Configuration conf, <line2> Path corpusInput, <line3> Path modelInput, <line4> Path modelOutput, <line5> int iterationNumber, <line6> int maxIterations, <line7> int numReduceTasks) <line8> throws IOException, ClassNotFoundException, InterruptedException { <line9> String jobName = <line10> String.format( <line11> ""Iteration %d of %d, input path: %s"", iterationNumber, maxIterations, modelInput); <line12> Job job = <line13> prepareJob( <line14> corpusInput, <line15> modelOutput, <line16> CachingCVB0Mapper.class, <line17> IntWritable.class, <line18> VectorWritable.class, <line19> VectorSumReducer.class, <line20> IntWritable.class, <line21> VectorWritable.class); <line22> job.setCombinerClass(VectorSumReducer.class); <line23> job.setNumReduceTasks(numReduceTasks); <line24> job.setJobName(jobName); <line25> setModelPaths(job, modelInput); <line26> HadoopUtil.delete(conf, modelOutput); <line27> if (!job.waitForCompletion(true)) { <line28> throw new InterruptedException( <line29> String.format(""Failed to complete iteration %d stage 1"", iterationNumber)); <line30> } <line31> } <line32> } <line33> "	"<line12>    log.info(""About to run: {}"", jobName);"	task4	
"public class A { <line0> private String typeParser(FieldType fieldType, String fieldName, Object fieldValue, String sql) { <line1> switch (fieldType) { <line2> case STRING: <line3> sql += fieldName + "" = "" + ""'"" + fieldValue + ""'""; <line4> break; <line5> case DATETIME: <line6> sql += fieldName + "" = "" + ""'"" + new DateTimeColumnParser().getValue(fieldValue) + ""'""; <line7> break; <line8> case INT32: <line9> case INT64: <line10> case FLOAT32: <line11> case FLOAT64: <line12> case BIG_INTEGER: <line13> sql += fieldName + "" = "" + fieldValue; <line14> break; <line15> default: <line16> } <line17> return sql; <line18> } <line19> } <line20> "	"<line16>        log.error(""fieldType {} is illegal."", fieldType.toString());"	task4	
public class A { <line0> @Override <line1> public void onComplete(AsyncEvent asyncEvent) { <line2> if (Log.isTraceEnabled()) { <line3> } <line4> synchronized (connectionQueue) { <line5> connectionQueue.remove(connection); <line6> lastActivity = Instant.now(); <line7> } <line8> SessionEventDispatcher.dispatchEvent( <line9> HttpSession.this, SessionEventDispatcher.EventType.connection_closed, connection, context); <line10> } <line11> } <line12> 	"<line3>      Log.trace(""Session {} Request ID {}, event complete: {}"", streamID, rid, asyncEvent);"	task4	
public class A { <line0> private void log(String string) { <line1> System.out.println(string); <line2> } <line3> } <line4> 	<line1>    Log.info(string);	task4	
public class A { <line0> @Override <line1> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line2> throws IOException, ServletException { <line3> final HttpServletRequest req = (HttpServletRequest) request; <line4> final long startTime = currentTimeProvider.get(); <line5> try { <line6> chain.doFilter(request, response); <line7> } finally { <line8> final long elapsedNS = currentTimeProvider.get() - startTime; <line9> final long elapsedMS = NANOSECONDS.toMillis(elapsedNS); <line10> if (elapsedNS >= threshold) { <line11> } <line12> } <line13> } <line14> } <line15> 	"<line11>        logger.warn(""Slow request: {} {} ({}ms)"", req.getMethod(), getFullUrl(req), elapsedMS);"	task4	
"public class A { <line0> public static com.liferay.portal.reports.engine.console.model.Source addSource( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> String driverClassName, <line5> String driverUrl, <line6> String driverUserName, <line7> String driverPassword, <line8> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line9> throws com.liferay.portal.kernel.exception.PortalException { <line10> try { <line11> MethodKey methodKey = <line12> new MethodKey(SourceServiceUtil.class, ""addSource"", _addSourceParameterTypes0); <line13> MethodHandler methodHandler = <line14> new MethodHandler( <line15> methodKey, <line16> groupId, <line17> nameMap, <line18> driverClassName, <line19> driverUrl, <line20> driverUserName, <line21> driverPassword, <line22> serviceContext); <line23> Object returnObj = null; <line24> try { <line25> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line26> } catch (Exception exception) { <line27> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line28> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line29> } <line30> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line31> } <line32> return (com.liferay.portal.reports.engine.console.model.Source) returnObj; <line33> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line34> throw systemException; <line35> } <line36> } <line37> } <line38> "	<line34>      log.error(systemException, systemException);	task4	
"public class A { <line0> public void addSpatialFilter( <line1> String geometryWkt, Double inputRadius, String linearUnit, String spatialType) { <line2> Filter filter = null; <line3> try { <line4> if (geometryWkt == null || geometryWkt.isEmpty()) { <line5> return; <line6> } <line7> SpatialFilter spatialFilter = new SpatialFilter(geometryWkt); <line8> if (spatialType.equals(""CONTAINS"")) { <line9> filter = FILTER_FACTORY.within(Metacard.ANY_GEO, spatialFilter.getGeometry()); <line10> } else if (spatialType.equals(""OVERLAPS"")) { <line11> filter = FILTER_FACTORY.intersects(Metacard.ANY_GEO, spatialFilter.getGeometry()); <line12> } else if (spatialType.equals(""NEAREST_NEIGHBOR"")) { <line13> filter = <line14> FILTER_FACTORY.beyond( <line15> Metacard.ANY_GEO, spatialFilter.getGeometry(), 0.0, UomOgcMapping.METRE.name()); <line16> } else if (spatialType.equals(""POINT_RADIUS"")) { <line17> Double normalizedRadius = convertRadius(linearUnit, inputRadius); <line18> filter = <line19> FILTER_FACTORY.dwithin( <line20> Metacard.ANY_GEO, <line21> spatialFilter.getGeometry(), <line22> normalizedRadius, <line23> UomOgcMapping.METRE.name()); <line24> } else { <line25> return; <line26> } <line27> } catch (IllegalArgumentException e) { <line28> return; <line29> } <line30> if (filter != null) { <line31> filters.add(filter); <line32> } <line33> } <line34> } <line35> "	"<line28>      LOGGER.debug(""Invalid spatial query type specified.  Will not apply spatial filter."");"	task4	
"public class A { <line0> @Override <line1> public List<AssetEntry> getInfoList( <line2> InfoListProviderContext infoListProviderContext, Pagination pagination, Sort sort) { <line3> AssetEntryQuery assetEntryQuery = <line4> getAssetEntryQuery(infoListProviderContext, ""ratings"", ""DESC"", pagination); <line5> try { <line6> return _assetEntryService.getEntries(assetEntryQuery); <line7> } catch (Exception exception) { <line8> } <line9> return Collections.emptyList(); <line10> } <line11> } <line12> "	"<line8>      log.error(""Unable to get asset entries"", exception);"	task4	
"public class A { <line0> private MCRILogicalStructMapTypeProvider getTypeProvider() { <line1> try { <line2> return MCRConfiguration2.<MCRDefaultLogicalStructMapTypeProvider>getClass( <line3> ""MCR.Component.MetsMods.LogicalStructMapTypeProvider"") <line4> .orElse(MCRDefaultLogicalStructMapTypeProvider.class) <line5> .getDeclaredConstructor() <line6> .newInstance(); <line7> } catch (Exception e) { <line8> return new MCRDefaultLogicalStructMapTypeProvider(); <line9> } <line10> } <line11> } <line12> "	"<line8>      LOGGER.warn(""Could not load class"", e);"	task4	
public class A { <line0> @Override <line1> public OutputStream append(String path) throws IOException { <line2> return updateFile(path, true); <line3> } <line4> } <line5> 	"<line2>    log.debug(""append [{}]"", path);"	task4	
"public class A { <line0> @Override <line1> public void post(LogRecord event) { <line2> AppendLogResult<ScheduleIndex> result = facade.appendScheduleLog(event); <line3> int code = result.getCode(); <line4> if (MessageProducerCode.SUCCESS != code) { <line5> throw new AppendException(""appendScheduleLogError""); <line6> } <line7> iterateCallback.apply(result.getAdditional()); <line8> } <line9> } <line10> "	"<line5>      LOGGER.error(""appendMessageLog schedule log error,log:{} {},code:{}"",event.getSubject(),event.getMessageId(),code);"	task4	
"public class A { <line0> @PostConstruct <line1> protected synchronized void init() { <line2> if (mangoProperties != null && mangoProperties.getBoolean(""properties.reloading"", true)) { <line3> Path path = mangoProperties.getEnvPropertiesPath(); <line4> Path parent = path.getParent(); <line5> try { <line6> if (Files.isDirectory(parent)) { <line7> this.watchService = parent.getFileSystem().newWatchService(); <line8> parent.register( <line9> watchService, <line10> StandardWatchEventKinds.ENTRY_CREATE, <line11> StandardWatchEventKinds.ENTRY_MODIFY); <line12> this.scheduledTask = <line13> scheduledExecutorService.scheduleWithFixedDelay( <line14> this::doCheck, 10, 10, TimeUnit.SECONDS); <line15> } <line16> } catch (IOException e) { <line17> } <line18> } <line19> } <line20> } <line21> "	"<line17>        log.error(""Can't watch env.properties file for changes"", e);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> emgrFactory.runInTrans( <line3> emgr -> { <line4> final EntityManager em = emgr.getEntityManager(); <line5> final Set<String> alreadyReindexed = new HashSet<>(); <line6> final List<Entry> entryList = map.get(obj.getClass()); <line7> reindexDependents(em, obj, entryList, alreadyReindexed); <line8> final int size = alreadyReindexed.size(); <line9> if (size >= 10) { <line10> } <line11> return null; <line12> }); <line13> } <line14> } <line15> 	"<line10>            log.info(""Re-indexing of ""+ size+ "" objects done after updating ""+ obj.getClass().getName()+ "":""+ obj.getId());"	task4	
public class A { <line0> public static void printAST(ASTNode node) { <line1> try { <line2> printAST(getHiveTokenMapping(), node, 0, 0); <line3> } catch (Exception e) { <line4> } <line5> System.out.println(); <line6> } <line7> } <line8> 	"<line4>      log.error(""Error in printing AST."", e);"	task4	
public class A { <line0> @BeforeMethod(alwaysRun = true) <line1> public void setUp() throws Exception { <line2> startTime = TimeUtil.getTimeWrtSystemTime(0); <line3> endTime = TimeUtil.addMinsToTime(startTime, 20); <line4> bundles[0] = BundleUtil.readELBundle(); <line5> bundles[0] = new Bundle(bundles[0], cluster); <line6> bundles[0].generateUniqueBundle(this); <line7> bundles[0].setProcessWorkflow(aggregateWorkflowDir); <line8> bundles[0].setProcessValidity(startTime, endTime); <line9> bundles[0].setProcessPeriodicity(5, Frequency.TimeUnit.minutes); <line10> bundles[0].setOutputFeedPeriodicity(5, Frequency.TimeUnit.minutes); <line11> clusterName = Util.readEntityName(bundles[0].getDataSets().get(0)); <line12> } <line13> } <line14> 	"<line4>    LOGGER.info(""Time range between : "" + startTime + "" and "" + endTime);"	task4	
public class A { <line0> @Override <line1> public void setup(ProfilerPluginSetupContext context) { <line2> if (context == null) { <line3> return; <line4> } <line5> final ElasticsearchPluginConfig elasticsearchPluginConfig = <line6> new ElasticsearchPluginConfig(context.getConfig()); <line7> if (logger.isInfoEnabled()) { <line8> } <line9> if (!elasticsearchPluginConfig.isEnabled()) { <line10> return; <line11> } <line12> addElasticsearchInterceptors(); <line13> addElasticsearchExecutorInterceptors(); <line14> this.addParallelElasticsearchInterceptors(); <line15> } <line16> } <line17> 	"<line8>      logger.info(""ElasticsearchPlugin config:{}"", elasticsearchPluginConfig);"	task4	
"public class A { <line0> public void waitForIO() throws HyracksDataException { <line1> logManager.log(waitLog); <line2> synchronized (this) { <line3> while (numActiveIOOps > 0) { <line4> try { <line5> wait(); <line6> } catch (InterruptedException e) { <line7> Thread.currentThread().interrupt(); <line8> throw HyracksDataException.create(e); <line9> } <line10> } <line11> if (numActiveIOOps < 0) { <line12> if (LOGGER.isErrorEnabled()) { <line13> } <line14> throw new IllegalStateException(""Number of IO operations cannot be negative""); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line13>          LOGGER.error(""Number of IO operations cannot be negative for dataset: "" + this);"	task4	
"public class A { <line0> @Nullable <line1> @Override <line2> public DeviceStateData apply(@Nullable List<T> data) { <line3> try { <line4> long lastActivityTime = getEntryValue(data, LAST_ACTIVITY_TIME, 0L); <line5> long inactivityAlarmTime = getEntryValue(data, INACTIVITY_ALARM_TIME, 0L); <line6> long inactivityTimeout = <line7> getEntryValue( <line8> data, INACTIVITY_TIMEOUT, TimeUnit.SECONDS.toMillis(defaultInactivityTimeoutInSec)); <line9> boolean active = System.currentTimeMillis() < lastActivityTime + inactivityTimeout; <line10> DeviceState deviceState = <line11> DeviceState.builder() <line12> .active(active) <line13> .lastConnectTime(getEntryValue(data, LAST_CONNECT_TIME, 0L)) <line14> .lastDisconnectTime(getEntryValue(data, LAST_DISCONNECT_TIME, 0L)) <line15> .lastActivityTime(lastActivityTime) <line16> .lastInactivityAlarmTime(inactivityAlarmTime) <line17> .inactivityTimeout(inactivityTimeout) <line18> .build(); <line19> TbMsgMetaData md = new TbMsgMetaData(); <line20> md.putValue(""deviceName"", device.getName()); <line21> md.putValue(""deviceType"", device.getType()); <line22> return DeviceStateData.builder() <line23> .customerId(device.getCustomerId()) <line24> .tenantId(device.getTenantId()) <line25> .deviceId(device.getId()) <line26> .deviceCreationTime(device.getCreatedTime()) <line27> .metaData(md) <line28> .state(deviceState) <line29> .build(); <line30> } catch (Exception e) { <line31> throw new RuntimeException(e); <line32> } <line33> } <line34> } <line35> "	"<line31>      log.warn(""[{}] Failed to fetch device state data"", device.getId(), e);"	task4	
"public class A { <line0> private static <T, ID> void addCreateSchemaStatements( <line1> DatabaseType databaseType, <line2> String schemaName, <line3> List<String> statements, <line4> List<String> queriesAfter, <line5> boolean ifNotExists, <line6> boolean logDetails) { <line7> StringBuilder sb = new StringBuilder(256); <line8> if (logDetails) { <line9> } <line10> sb.append(""CREATE SCHEMA ""); <line11> if (ifNotExists && databaseType.isCreateIfNotExistsSupported()) { <line12> sb.append(""IF NOT EXISTS ""); <line13> } <line14> databaseType.appendEscapedEntityName(sb, schemaName); <line15> databaseType.appendCreateSchemaSuffix(sb); <line16> statements.add(sb.toString()); <line17> } <line18> } <line19> "	"<line9>      logger.info(""creating schema '{}'"", schemaName);"	task4	
"public class A { <line0> @Override <line1> protected void reduce(Text t, Iterable<VertexWritable> vertices, Context context) <line2> throws IOException, InterruptedException { <line3> Configuration conf = context.getConfiguration(); <line4> boolean zero = false; <line5> int i = -1; <line6> int j = -1; <line7> double k = 0; <line8> int count = 0; <line9> for (VertexWritable v : vertices) { <line10> count++; <line11> if (v.getType().equals(conf.get(EigencutsKeys.AFFINITY_PATH))) { <line12> i = v.getRow(); <line13> j = v.getCol(); <line14> k = v.getValue(); <line15> } else if (v.getValue() != 0.0) { <line16> zero = true; <line17> } <line18> } <line19> if (count == 2) { <line20> VertexWritable vw = new VertexWritable(i, j, k, ""unimportant""); <line21> context.write(new Text(String.valueOf(i)), vw); <line22> return; <line23> } <line24> VertexWritable outI = new VertexWritable(); <line25> VertexWritable outJ = new VertexWritable(); <line26> if (zero) { <line27> context.getCounter(CUTSCOUNTER.NUM_CUTS).increment(1); <line28> outI.setCol(i); <line29> outJ.setCol(j); <line30> VertexWritable zeroI = new VertexWritable(); <line31> VertexWritable zeroJ = new VertexWritable(); <line32> zeroI.setCol(j); <line33> zeroI.setValue(0); <line34> zeroJ.setCol(i); <line35> zeroJ.setValue(0); <line36> zeroI.setType(""unimportant""); <line37> zeroJ.setType(""unimportant""); <line38> context.write(new Text(String.valueOf(i)), zeroI); <line39> context.write(new Text(String.valueOf(j)), zeroJ); <line40> } else { <line41> outI.setCol(j); <line42> outJ.setCol(i); <line43> } <line44> outI.setValue(k); <line45> outJ.setValue(k); <line46> outI.setType(""unimportant""); <line47> outJ.setType(""unimportant""); <line48> context.write(new Text(String.valueOf(i)), outI); <line49> context.write(new Text(String.valueOf(j)), outJ); <line50> } <line51> } <line52> "	"<line4>    log.debug(""{}"", t);"	task4	
public class A { <line0> @Test <line1> public void rtreeTwoDimensionsInt() throws Exception { <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> ISerializerDeserializer[] fieldSerdes = { <line5> IntegerSerializerDeserializer.INSTANCE, <line6> IntegerSerializerDeserializer.INSTANCE, <line7> IntegerSerializerDeserializer.INSTANCE, <line8> IntegerSerializerDeserializer.INSTANCE, <line9> IntegerSerializerDeserializer.INSTANCE <line10> }; <line11> int numKeys = 4; <line12> IPrimitiveValueProviderFactory[] valueProviderFactories = <line13> RTreeUtils.createPrimitiveValueProviderFactories(numKeys, IntegerPointable.FACTORY); <line14> ITupleReference key = TupleUtils.createIntegerTuple(-1000, -1000, 1000, 1000); <line15> runTest(fieldSerdes, valueProviderFactories, numKeys, key, RTreePolicyType.RTREE); <line16> } <line17> } <line18> 	"<line3>      LOGGER.info(""RTree "" + getTestOpName() + "" Test With Two Dimensions With Integer Keys."");"	task4	
public class A { <line0> private void closeZooKeeper(ZooKeeper zooKeeper) { <line1> try { <line2> zooKeeper.close(); <line3> } catch (InterruptedException e) { <line4> Thread.currentThread().interrupt(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.warn(""could not close ZooKeeper client due to interrupt"", e);"	task4	
public class A { <line0> public void routine( <line1> String schemaName, <line2> String routineName, <line3> String language, <line4> Routine.CallingConvention callingConvention) { <line5> Routine routine = Routine.create(ais, schemaName, routineName, language, callingConvention); <line6> } <line7> } <line8> 	"<line5>    LOG.trace(""routine: {}.{} "", schemaName, routineName);"	task4	
public class A { <line0> @Override <line1> public void esbJobFactoryAdded(TalendESBJobFactory esbJobFactory, String name) { <line2> MultiThreadedOperation op = <line3> new MultiThreadedOperation(esbJobFactory, name, endpointRegistry, executorService); <line4> operations.put(name, op); <line5> if (esbJobFactory instanceof TalendESBJob) { <line6> ((TalendESBJob) esbJobFactory).setEndpointRegistry(endpointRegistry); <line7> } <line8> } <line9> } <line10> 	"<line2>    LOG.info(""Adding ESB job factory for job "" + name + ""."");"	task4	
"public class A { <line0> protected void cleanUnusedHBaseTables() throws IOException { <line1> if (""hbase"".equals(config.getStorageUrl().getScheme()) <line2> && !"""".equals(config.getMetadataUrl().getScheme())) { <line3> final int deleteTimeoutMin = 2; <line4> try { <line5> Class hbaseCleanUpUtil = <line6> Class.forName(""org.apache.kylin.rest.job.StorageCleanJobHbaseUtil""); <line7> Method cleanUnusedHBaseTables = <line8> hbaseCleanUpUtil.getDeclaredMethod( <line9> ""cleanUnusedHBaseTables"", boolean.class, int.class, int.class); <line10> hbaseGarbageTables = <line11> (List<String>) <line12> cleanUnusedHBaseTables.invoke( <line13> hbaseCleanUpUtil, delete, deleteTimeoutMin, threadsNum); <line14> } catch (Throwable e) { <line15> } <line16> } <line17> } <line18> } <line19> "	"<line15>        logger.error(""Error during HBase clean up"", e);"	task4	
"public class A { <line0> @RequestMapping(value = ""/all"", method = RequestMethod.GET) <line1> public List<ModuleTypeDto> getModuleTypes() { <line2> List<ModuleType> moduleTypes = moduleTypeService.findModuleTypes(); <line3> List<ModuleTypeDto> moduleTypeDtos = <line4> moduleTypeToModuleTypeDtoConverter.convertToList(moduleTypes); <line5> return moduleTypeDtos; <line6> } <line7> } <line8> "	"<line2>    log.debug(""getModuleTypes()"");"	task4	
public class A { <line0> @Override <line1> public void updateSensorState(FullSensor sensor, StateUpdate stateUpdate) { <line2> if (hueBridge != null) { <line3> hueBridge <line4> .setSensorState(sensor, stateUpdate) <line5> .thenAccept( <line6> result -> { <line7> try { <line8> hueBridge.handleErrors(result); <line9> } catch (Exception e) { <line10> handleSensorUpdateException(sensor, e); <line11> } <line12> }) <line13> .exceptionally( <line14> e -> { <line15> handleSensorUpdateException(sensor, e); <line16> return null; <line17> }); <line18> } else { <line19> } <line20> } <line21> } <line22> 	"<line19>      logger.debug(""No bridge connected or selected. Cannot set sensor state."");"	task4	
public class A { <line0> @Override <line1> public void paint(Graphics2D g2d) { <line2> super.paint(g2d); <line3> if (LOGGER.isTraceEnabled()) { <line4> for (TimelineLayer layer : myLayers) { <line5> long t0 = System.nanoTime(); <line6> layer.paint(g2d); <line7> } <line8> } else { <line9> for (TimelineLayer layer : myLayers) { <line10> layer.paint(g2d); <line11> } <line12> } <line13> } <line14> } <line15> 	"<line7>        LOGGER.trace(StringUtilities.formatTimingMessage(""Time to paint layer "" + layer.getClass().getSimpleName() + "": "",System.nanoTime() - t0));"	task4	
public class A { <line0> @Override <line1> protected void jumpToItem(int itemIndex) throws Exception { <line2> if (driverSupportsAbsolute) { <line3> try { <line4> rs.absolute(itemIndex); <line5> } catch (SQLException e) { <line6> moveCursorToRow(itemIndex); <line7> } <line8> } else { <line9> moveCursorToRow(itemIndex); <line10> } <line11> } <line12> } <line13> 	"<line6>        log.warn(""The JDBC driver does not appear to support ResultSet.absolute(). Consider""+ "" reverting to the default behavior setting the driverSupportsAbsolute to false"",e);"	task4	
"public class A { <line0> public CompletableFuture<Void> checkAndReconnect(Throwable t) { <line1> String message = t.getMessage(); <line2> if (t instanceof Mesos4xxException && message.contains(""403"")) { <line3> return CompletableFuture.runAsync( <line4> () -> scheduler.onUncaughtException(new PrematureChannelClosureException()), <line5> executorService); <line6> } <line7> return CompletableFuture.completedFuture(null); <line8> } <line9> } <line10> "	"<line1>    LOG.error(""Exception calling mesos ({} so far)"", failedMesosCalls.incrementAndGet(), t);"	task4	
public class A { <line0> public void stopContext() { <line1> if (_context != null && _publisher != null) { <line2> try { <line3> _publisher.destroy(_context); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>        LOGGER.error(e);	task4	
public class A { <line0> public void moveEyelids(double eyelidleftPos, double eyelidrightPos) { <line1> if (head != null) { <line2> head.moveEyelidsTo(eyelidleftPos, eyelidrightPos); <line3> } else { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.warn(""moveEyelids - I have a null head"");"	task4	
"public class A { <line0> public String getStatisticsType( <line1> Integer statisticTypeId, List<StatisticImageListDto> statisticImageList) throws DAOException { <line2> LOGGER.entry(""begin getStatisticsType()""); <line3> String statisticType = """"; <line4> try { <line5> if ((statisticImageList != null) && !statisticImageList.isEmpty()) { <line6> for (StatisticImageListDto statistic : statisticImageList) { <line7> if (statisticTypeId.intValue() == statistic.getStatisticImageId().intValue()) { <line8> statisticType = statistic.getValue(); <line9> break; <line10> } <line11> } <line12> } <line13> } catch (Exception e) { <line14> } <line15> LOGGER.exit(""getStatisticsType() :: Ends""); <line16> return statisticType; <line17> } <line18> } <line19> "	"<line14>      LOGGER.error(""DashboardMetaDataDao - getStatisticsType() :: ERROR"", e);"	task4	
"public class A { <line0> @Test <line1> public void testSMILESFileWithSpacesAndTabs() throws Exception { <line2> String filename = ""data/smiles/tabs.smi""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> IteratingSMILESReader reader = <line5> new IteratingSMILESReader(ins, DefaultChemObjectBuilder.getInstance()); <line6> int molCount = 0; <line7> while (reader.hasNext()) { <line8> Object object = reader.next(); <line9> Assert.assertNotNull(object); <line10> assertTrue(object instanceof IAtomContainer); <line11> molCount++; <line12> } <line13> Assert.assertEquals(5, molCount); <line14> reader.close(); <line15> } <line16> } <line17> "	"<line3>    logger.info(""Testing: "" + filename);"	task4	
public class A { <line0> private Properties loadRawGitProperties(String loc) { <line1> Properties p = new Properties(); <line2> try (InputStream in = getClass().getResourceAsStream(loc)) { <line3> p.load(in); <line4> } catch (Exception e) { <line5> } <line6> return p; <line7> } <line8> } <line9> 	"<line5>      log.warn(""Error loading {}, possibly jar was not compiled with maven."", GIT_PROPS, e);"	task4	
public class A { <line0> @Override <line1> public Date getAlertSystemRecoverTime() { <line2> try { <line3> return configDao.getByKey(KEY_ALERT_SYSTEM_ON).getUntil(); <line4> } catch (DalException e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	"<line5>      logger.error(""[getAlertSystemRecovertIME]"", e);"	task4	
"public class A { <line0> private void setUpKubernetes() { <line1> System.setProperty(""kubernetes.auth.tryKubeConfig"", ""false""); <line2> k8s = StyxScheduler.getKubernetesClient(schedulerConfig, ""default""); <line3> k8s.namespaces().createNew().withNewMetadata().withName(testNamespace).endMetadata().done(); <line4> } <line5> } <line6> "	"<line2>    log.info(""Creating k8s namespace: {}"", testNamespace);"	task4	
"public class A { <line0> @UsedAsLiferayAction <line1> public void unscheduleAllServices(ActionRequest request, ActionResponse response) <line2> throws PortletException, IOException { <line3> try { <line4> User user = UserCacheHolder.getUserFromRequest(request); <line5> RequestStatus requestStatus = <line6> new ThriftClients().makeScheduleClient().unscheduleAllServices(user); <line7> setSessionMessage(request, requestStatus, ""Every task"", ""unschedule""); <line8> } catch (TException e) { <line9> } <line10> } <line11> } <line12> "	<line9>      log.error(e);	task4	
public class A { <line0> private void prepareSalt(PasswordSaltExtensionMessage msg) { <line1> msg.setSalt(chooser.getConfig().getDefaultServerPWDSalt()); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""Salt: "" + ArrayConverter.bytesToHexString(msg.getSalt()));"	task4	
public class A { <line0> @Override <line1> protected final void dispatchWriteEvent(SelectionKey key) { <line2> Session session = (Session) key.attachment(); <line3> if (session != null) { <line4> ((NioSession) session).onEvent(EventType.WRITEABLE, key.selector()); <line5> } else { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.warn(""Could not find session for writable event,maybe it is closed"");"	task4	
public class A { <line0> public synchronized void writeConfigurationFile(Path xmlFilePath) { <line1> xmlDatenSchreiben(xmlFilePath); <line2> } <line3> } <line4> 	"<line1>    logger.info(""Daten Schreiben nach: {}"", xmlFilePath.toString());"	task4	
public class A { <line0> public void addDomain(final String domainId, final RepositoryFile child) { <line1> final Map<String, RepositoryFile> details = getDetails(domainId, true); <line2> if (details.get(DOMAIN_ID_KEY) != null) { <line3> } <line4> details.put(DOMAIN_ID_KEY, child); <line5> } <line6> } <line7> 	"<line3>      log.warn(""Adding domain when one already exists"");"	task4	
"public class A { <line0> @Test <line1> public void testWithGeometryCollection() <line2> throws CatalogTransformerException, IOException, ParseException { <line3> Date now = new Date(); <line4> MetacardImpl metacard = new MetacardImpl(); <line5> metacard.setLocation(""GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))""); <line6> setupBasicMetacard(now, metacard); <line7> GeoJsonMetacardTransformer transformer = new GeoJsonMetacardTransformer(); <line8> BinaryContent content = transformer.transform(metacard, null); <line9> assertEquals( <line10> content.getMimeTypeValue(), GeoJsonMetacardTransformer.DEFAULT_MIME_TYPE.getBaseType()); <line11> String jsonText = new String(content.getByteArray()); <line12> Object object = PARSER.parse(jsonText); <line13> JSONObject obj2 = (JSONObject) object; <line14> Map geometryMap = (Map) obj2.get(""geometry""); <line15> assertThat(geometryMap.get(CompositeGeometry.TYPE_KEY).toString(), is(GeometryCollection.TYPE)); <line16> assertThat(geometryMap.get(CompositeGeometry.GEOMETRIES_KEY), notNullValue()); <line17> verifyBasicMetacardJson(now, obj2); <line18> } <line19> } <line20> "	<line12>    LOGGER.debug(jsonText);	task4	
"public class A { <line0> public static ResponseEntity<Object> httpResponseForInternalServerError() { <line1> logger.entry(""AppUtil - httpResponseForInternalServerError() :: starts""); <line2> ErrorBean errorBean = null; <line3> try { <line4> errorBean = <line5> new ErrorBean() <line6> .setCode(ErrorCode.EC_500.code()) <line7> .setMessage(ErrorCode.EC_500.errorMessage()); <line8> } catch (Exception e) { <line9> } <line10> logger.exit(""AppUtil - httpResponseForInternalServerError() :: ends""); <line11> return new ResponseEntity<>(errorBean, HttpStatus.INTERNAL_SERVER_ERROR); <line12> } <line13> } <line14> "	"<line9>      logger.error(""ERROR: AppUtil - httpResponseForInternalServerError()"", e);"	task4	
public class A { <line0> @Override <line1> public Iterator iterator() { <line2> final App app = StructrApp.getInstance(fs.getSecurityContext()); <line3> final List<StructrPath> nodes = new LinkedList<>(); <line4> try (final Tx tx = app.tx()) { <line5> for (final SchemaMethod schemaMethod : schemaNode.getProperty(SchemaNode.schemaMethods)) { <line6> String name = schemaMethod.getProperty(SchemaMethod.virtualFileName); <line7> if (name == null) { <line8> name = schemaMethod.getName(); <line9> } <line10> nodes.add(new StructrSchemaMethodPath(fs, StructrSchemaMethodsPath.this, schemaNode, name)); <line11> } <line12> tx.success(); <line13> } catch (FrameworkException fex) { <line14> } <line15> return nodes.iterator(); <line16> } <line17> } <line18> 	"<line14>      logger.warn("""", fex);"	task4	
public class A { <line0> public static Optional<Geometry> wktToGeometry(String wkt, WKTReader wktReader) { <line1> try { <line2> return Optional.of(wktReader.read(wkt)); <line3> } catch (ParseException e) { <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	"<line4>      LOGGER.debug(""unable to convert WKT to a Geometry object: wkt={}"", wkt, e);"	task4	
public class A { <line0> @Override <line1> public void removeTaskManager(InstanceID instanceId) { <line2> Preconditions.checkNotNull(instanceId); <line3> final FineGrainedTaskManagerRegistration taskManager = <line4> Preconditions.checkNotNull(taskManagerRegistrations.remove(instanceId)); <line5> totalRegisteredResource = totalRegisteredResource.subtract(taskManager.getTotalResource()); <line6> for (AllocationID allocationId : taskManager.getAllocatedSlots().keySet()) { <line7> slots.remove(allocationId); <line8> } <line9> } <line10> } <line11> 	"<line6>    LOG.debug(""Remove task manager {}."", instanceId);"	task4	
public class A { <line0> public synchronized void unbindHook(ServiceReference<DeploymentHook> hook) { <line1> final Object rawHookId = hook.getProperty(ConfigurationService.KURA_SERVICE_PID); <line2> if (!(rawHookId instanceof String)) { <line3> return; <line4> } <line5> final String hookId = (String) rawHookId; <line6> final DeploymentHook removedHook = this.registeredHooks.remove(hookId); <line7> updateAssociations(); <line8> if (removedHook != null) { <line9> getBundleContext().ungetService(hook); <line10> } <line11> } <line12> } <line13> 	"<line10>      logger.info(""Hook unregistered: {}"", hookId);"	task4	
"public class A { <line0> @Test <line1> public void testProperties() throws Exception { <line2> Logger logger = LogManager.getLogger(""test""); <line3> File file = new File(""target/temp.A1""); <line4> assertTrue(""File A1 was not created"", file.exists()); <line5> assertTrue(""File A1 is empty"", file.length() > 0); <line6> file = new File(""target/temp.A2""); <line7> assertTrue(""File A2 was not created"", file.exists()); <line8> assertTrue(""File A2 is empty"", file.length() > 0); <line9> } <line10> } <line11> "	"<line3>    logger.debug(""This is a test of the root logger"");"	task4	
"public class A { <line0> public String getReplicationConnectionURI() { <line1> try { <line2> return getConfigConnectionURI(replicationMysql); <line3> } catch (URISyntaxException e) { <line4> throw new RuntimeException( <line5> ""Unable to generate bootstrap's replication jdbc connection URI"", e); <line6> } <line7> } <line8> } <line9> "	<line4>      LOGGER.error(e.getMessage(), e);	task4	
public class A { <line0> public static com.liferay.commerce.model.CommerceOrderItemSoap updateCommerceOrderItemUnitPrice( <line1> long commerceOrderItemId, int quantity, java.math.BigDecimal unitPrice) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.model.CommerceOrderItem returnValue = <line5> CommerceOrderItemServiceUtil.updateCommerceOrderItemUnitPrice( <line6> commerceOrderItemId, quantity, unitPrice); <line7> return com.liferay.commerce.model.CommerceOrderItemSoap.toSoapModel(returnValue); <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void setServiceDef(RangerServiceDef serviceDef) { <line2> if (isInitialized) { <line3> } <line4> this.serviceDef = serviceDef; <line5> } <line6> } <line7> 	"<line3>      LOG.warn(""RangerDefaultPolicyResourceMatcher is already initialized. init() must be done again""+ "" after updating serviceDef"");"	task4	
"public class A { <line0> protected Properties createUserFilterProperties() throws ApsSystemException { <line1> String filterKey = this.getUserFilterKey(); <line2> if (null == filterKey) { <line3> return null; <line4> } <line5> Properties properties = new Properties(); <line6> try { <line7> if (filterKey.equals(UserFilterOptionBean.KEY_FULLTEXT)) { <line8> properties.put(UserFilterOptionBean.PARAM_KEY, filterKey); <line9> properties.put(UserFilterOptionBean.PARAM_IS_ATTRIBUTE_FILTER, String.valueOf(false)); <line10> } else if (filterKey.equals(UserFilterOptionBean.KEY_CATEGORY)) { <line11> properties.put(UserFilterOptionBean.PARAM_KEY, filterKey); <line12> properties.put(UserFilterOptionBean.PARAM_IS_ATTRIBUTE_FILTER, String.valueOf(false)); <line13> if (null != this.getUserFilterCategoryCode() <line14> && this.getUserFilterCategoryCode().trim().length() > 0) { <line15> properties.put( <line16> UserFilterOptionBean.PARAM_CATEGORY_CODE, this.getUserFilterCategoryCode()); <line17> } <line18> } else if (filterKey.startsWith(UserFilterOptionBean.TYPE_ATTRIBUTE + ""_"")) { <line19> properties.put( <line20> UserFilterOptionBean.PARAM_KEY, <line21> filterKey.substring((UserFilterOptionBean.TYPE_ATTRIBUTE + ""_"").length())); <line22> properties.put(UserFilterOptionBean.PARAM_IS_ATTRIBUTE_FILTER, String.valueOf(true)); <line23> } <line24> if (properties.isEmpty()) { <line25> return null; <line26> } <line27> } catch (Throwable t) { <line28> throw new ApsSystemException(""Error creating user filter"", t); <line29> } <line30> return properties; <line31> } <line32> } <line33> "	"<line28>      logger.error(""Error creating user filter"", t);"	task4	
"public class A { <line0> @Override <line1> public void run(MessageReply reply) { <line2> if (!reply.isSuccess()) { <line3> } <line4> completion.fail(operr(""Failed because management node restarted."")); <line5> } <line6> } <line7> "	"<line3>      logger.warn(String.format(""delete image [%s] failed after management node restarted"", msg.getResourceUuid()));"	task4	
public class A { <line0> private long getBundleTime(Bundle bundle) { <line1> long bundleTime = JitterClock.globalTime(); <line2> if (timeField != null) { <line3> ValueObject vo = timeField.getField().getValue(bundle); <line4> if (vo == null) { <line5> } else { <line6> bundleTime = timeField.toUnix(vo); <line7> } <line8> } <line9> return bundleTime; <line10> } <line11> } <line12> 	"<line5>        log.debug(""missing time {} in [{}] --> {}"", timeField.getField(), bundle.getCount(), bundle);"	task4	
"public class A { <line0> @Override <line1> public synchronized void xaSuspend() throws Exception { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> if (tx == null) { <line5> final String msg = ""Cannot suspend, session is not doing work in a transaction ""; <line6> throw new ActiveMQXAException(XAException.XAER_PROTO, msg); <line7> } else { <line8> if (tx.getState() == Transaction.State.SUSPENDED) { <line9> final String msg = ""Cannot suspend, transaction is already suspended "" + tx.getXid(); <line10> throw new ActiveMQXAException(XAException.XAER_PROTO, msg); <line11> } else { <line12> tx.suspend(); <line13> tx = null; <line14> } <line15> } <line16> } <line17> } <line18> "	"<line3>      logger.trace(""xasuspend on "" + this.tx);"	task4	
public class A { <line0> private boolean hasPropagateRepoPermission(String repo) { <line1> if (!accessEvaluator.isAllowedPropagationRepo(repo)) { <line2> InApplicationMonitor.getInstance().incrementCounter(APPMON_ACCESS_PREVENTION); <line3> return false; <line4> } <line5> return true; <line6> } <line7> } <line8> 	"<line3>      LOGGER.warn(""preventing access to {}"", repo);"	task4	
public class A { <line0> private Either<Boolean, ResponseFormat> extractHeatParameters(ArtifactDefinition artifactInfo) { <line1> if (artifactInfo.getPayloadData() != null) { <line2> String heatDecodedPayload = new String(Base64.decodeBase64(artifactInfo.getPayloadData())); <line3> Either<List<HeatParameterDefinition>, ResultStatusEnum> heatParameters = <line4> ImportUtils.getHeatParamsWithoutImplicitTypes( <line5> heatDecodedPayload, artifactInfo.getArtifactType()); <line6> if (heatParameters.isRight() <line7> && (heatParameters.right().value() != ResultStatusEnum.ELEMENT_NOT_FOUND)) { <line8> ResponseFormat responseFormat = <line9> componentsUtils.getResponseFormat( <line10> ActionStatus.INVALID_DEPLOYMENT_ARTIFACT_HEAT, artifactInfo.getArtifactType()); <line11> return Either.right(responseFormat); <line12> } else if (heatParameters.isLeft() && heatParameters.left().value() != null) { <line13> artifactInfo.setListHeatParameters(heatParameters.left().value()); <line14> } <line15> } <line16> return Either.left(true); <line17> } <line18> } <line19> 	"<line8>        log.info(""failed to parse heat parameters "");"	task4	
"public class A { <line0> private void createTemplateFromRootVolume( <line1> final CreateTemplateFromVmRootVolumeMsg msg, final SyncTaskChain chain) { <line2> boolean callNext = true; <line3> try { <line4> refreshVO(); <line5> ErrorCode allowed = validateOperationByState(msg, self.getState(), SysErrors.OPERATION_ERROR); <line6> if (allowed != null) { <line7> bus.replyErrorByMessageType(msg, allowed); <line8> return; <line9> } <line10> final CreateTemplateFromVmRootVolumeReply reply = new CreateTemplateFromVmRootVolumeReply(); <line11> CreateTemplateFromVolumeOnPrimaryStorageMsg cmsg = <line12> new CreateTemplateFromVolumeOnPrimaryStorageMsg(); <line13> cmsg.setVolumeInventory(msg.getRootVolumeInventory()); <line14> cmsg.setBackupStorageUuid(msg.getBackupStorageUuid()); <line15> cmsg.setImageInventory(msg.getImageInventory()); <line16> bus.makeTargetServiceIdByResourceUuid( <line17> cmsg, <line18> PrimaryStorageConstant.SERVICE_ID, <line19> msg.getRootVolumeInventory().getPrimaryStorageUuid()); <line20> bus.send( <line21> cmsg, <line22> new CloudBusCallBack(chain) { <line23> private void fail(ErrorCode errorCode) { <line24> reply.setError( <line25> operr( <line26> errorCode, <line27> ""failed to create template from root volume[uuid:%s] on primary"" <line28> + "" storage[uuid:%s]"", <line29> msg.getRootVolumeInventory().getUuid(), <line30> msg.getRootVolumeInventory().getPrimaryStorageUuid())); <line31> bus.reply(msg, reply); <line32> } <line33>  <line34> @Override <line35> public void run(MessageReply r) { <line36> if (!r.isSuccess()) { <line37> fail(r.getError()); <line38> } else { <line39> CreateTemplateFromVolumeOnPrimaryStorageReply creply = <line40> (CreateTemplateFromVolumeOnPrimaryStorageReply) r; <line41> reply.setInstallPath(creply.getTemplateBackupStorageInstallPath()); <line42> reply.setFormat(creply.getFormat()); <line43> bus.reply(msg, reply); <line44> } <line45> chain.next(); <line46> } <line47> }); <line48> callNext = false; <line49> } finally { <line50> if (callNext) { <line51> chain.next(); <line52> } <line53> } <line54> } <line55> } <line56> "	<line31>              logger.warn(reply.getError().getDetails());	task4	
public class A { <line0> public final void searchUpdate() { <line1> final UpdaterConfig config = new UpdaterConfig(); <line2> if (!config.enabled) { <line3> return; <line4> } <line5> final long currentTime = new Date().getTime(); <line6> if (lastCheck + CHECK_DELAY > currentTime) { <line7> return; <line8> } <line9> lastCheck = currentTime; <line10> Bukkit.getScheduler() <line11> .runTaskAsynchronously( <line12> BetonQuest.getInstance(), <line13> () -> { <line14> searchUpdateTask(config); <line15> if (latest.getValue() != null) { <line16> if (config.automatic) { <line17> update(Bukkit.getConsoleSender()); <line18> } <line19> } <line20> }); <line21> } <line22> } <line23> 	<line16>                LOG.info(null, getUpdateNotification(config));	task4	
"public class A { <line0> protected void writeDigestFile(TaskCache taskCache, String digest) { <line1> Task task = taskCache.getTask(); <line2> Logger logger = task.getLogger(); <line3> File digestFile = new File(taskCache.getCacheDir(), DIGEST_FILE_NAME); <line4> try { <line5> Files.write(digestFile.toPath(), digest.getBytes(StandardCharsets.UTF_8)); <line6> if (logger.isInfoEnabled()) { <line7> } <line8> } catch (IOException ioException) { <line9> throw new GradleException(""Unable to write digest file"", ioException); <line10> } <line11> } <line12> } <line13> "	"<line7>        logger.info(""Updated digest file to "" + digest);"	task4	
"public class A { <line0> @Override <line1> public void doWork() throws IOException { <line2> mqConsumer.processMessage( <line3> new RabbitMQConsumer.MessageListener() { <line4> @Override <line5> public boolean onMessage(String message) throws Exception { <line6> @SuppressWarnings(""unchecked"") <line7> Map<String, Object> msgMap = <line8> (HashMap<String, Object>) <line9> (new Gson()) <line10> .fromJson(message, new TypeToken<HashMap<String, Object>>() {}.getType()); <line11> boolean finished = (Boolean) msgMap.get(Constants.FINISH_FIELD); <line12> if (finished) { <line13> success = (Boolean) msgMap.get(Constants.SUCCEED_FIELD); <line14> if (!success) { <line15> errorMessage = (String) msgMap.get(Constants.ERROR_MSG_FIELD); <line16> } <line17> } <line18> if (!success && messageHandler != null) { <line19> double progress = (Double) msgMap.get(Constants.PROGRESS_FIELD) / 100; <line20> messageHandler.setProgress(progress); <line21> } <line22> if (messageHandler != null) { <line23> messageHandler.onMessage(msgMap); <line24> } <line25> return !finished; <line26> } <line27> }); <line28> } <line29> } <line30> "	"<line6>            logger.info(""processing message: "" + message);"	task4	
public class A { <line0> @Test <line1> public void testNullFactory() throws Exception { <line2> factory = null; <line3> startGrids(); <line4> for (final Integer key : keys()) { <line5> eternal(key); <line6> } <line7> } <line8> } <line9> 	"<line5>      log.info(""Test eternalPolicy, key: "" + key);"	task4	
"public class A { <line0> @RuleAction( <line1> label = ""@text/sendMessageToDeviceActionLabel"", <line2> description = ""@text/sendMessageToDeviceActionDescription"") <line3> public @ActionOutput( <line4> name = ""sent"", <line5> label = ""@text/sendMessageActionOutputLabel"", <line6> description = ""@text/sendMessageActionOutputDescription"", <line7> type = ""java.lang.Boolean"") Boolean sendMessageToDevice( <line8> @ActionInput( <line9> name = ""device"", <line10> label = ""@text/sendMessageActionInputDeviceLabel"", <line11> description = ""@text/sendMessageActionInputDeviceDescription"", <line12> type = ""java.lang.String"", <line13> required = true) <line14> String device, <line15> @ActionInput( <line16> name = ""message"", <line17> label = ""@text/sendMessageActionInputMessageLabel"", <line18> description = ""@text/sendMessageActionInputMessageDescription"", <line19> type = ""java.lang.String"", <line20> required = true) <line21> String message, <line22> @ActionInput( <line23> name = ""title"", <line24> label = ""@text/sendMessageActionInputTitleLabel"", <line25> description = ""@text/sendMessageActionInputTitleDescription"", <line26> type = ""java.lang.String"", <line27> defaultValue = DEFAULT_TITLE) <line28> @Nullable <line29> String title) { <line30> if (device == null) { <line31> throw new IllegalArgumentException(""Skip sending message as 'device' is null.""); <line32> } <line33> return send(getDefaultPushoverMessageBuilder(message).withDevice(device), title); <line34> } <line35> } <line36> "	"<line30>    logger.trace(""ThingAction 'sendMessageToDevice' called with value(s): device='{}', message='{}',""+ "" title='{}'"",device,message,title);"	task4	
public class A { <line0> @Override <line1> public PatchStatus applyPatch(TypeDefPatch patch) throws AtlasBaseException { <line2> String typeName = patch.getTypeName(); <line3> AtlasBaseTypeDef typeDef = typeRegistry.getTypeDefByName(typeName); <line4> PatchStatus ret; <line5> if (typeDef == null) { <line6> throw new AtlasBaseException( <line7> AtlasErrorCode.PATCH_FOR_UNKNOWN_TYPE, patch.getAction(), typeName); <line8> } <line9> if (isPatchApplicable(patch, typeDef)) { <line10> if (typeDef.getClass().equals(AtlasEntityDef.class)) { <line11> AtlasEntityDef updatedDef = new AtlasEntityDef((AtlasEntityDef) typeDef); <line12> addOrUpdateAttributes(updatedDef, patch.getAttributeDefs()); <line13> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line14> typeDefStore.updateEntityDefByName(typeName, updatedDef); <line15> ret = APPLIED; <line16> } else if (typeDef.getClass().equals(AtlasClassificationDef.class)) { <line17> AtlasClassificationDef updatedDef = <line18> new AtlasClassificationDef((AtlasClassificationDef) typeDef); <line19> addOrUpdateAttributes(updatedDef, patch.getAttributeDefs()); <line20> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line21> typeDefStore.updateClassificationDefByName(typeName, updatedDef); <line22> ret = APPLIED; <line23> } else if (typeDef.getClass().equals(AtlasStructDef.class)) { <line24> AtlasStructDef updatedDef = new AtlasStructDef((AtlasStructDef) typeDef); <line25> addOrUpdateAttributes(updatedDef, patch.getAttributeDefs()); <line26> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line27> typeDefStore.updateStructDefByName(typeName, updatedDef); <line28> ret = APPLIED; <line29> } else { <line30> throw new AtlasBaseException( <line31> AtlasErrorCode.PATCH_NOT_APPLICABLE_FOR_TYPE, <line32> patch.getAction(), <line33> typeDef.getClass().getSimpleName()); <line34> } <line35> } else { <line36> ret = SKIPPED; <line37> } <line38> return ret; <line39> } <line40> } <line41> 	"<line36>      LOG.info(""patch skipped: typeName={}; applyToVersion={}; updateToVersion={}"",patch.getTypeName(),patch.getApplyToVersion(),patch.getUpdateToVersion());"	task4	
"public class A { <line0> @Test <line1> public void testContainerSpecSerialization() { <line2> final ContainerSpec spec = new ContainerSpec(); <line3> spec.setId(""id""); <line4> spec.setContainerName(""name""); <line5> spec.setStatus(KieContainerStatus.STARTED); <line6> spec.setReleasedId(new ReleaseId(""groupId"", ""artifactId"", ""1.0"")); <line7> final ProcessConfig processConfig = <line8> new ProcessConfig(""runtimeStrategy"", ""kBase"", ""kSession"", ""mergeMode""); <line9> spec.addConfig(Capability.PROCESS, processConfig); <line10> final RuleConfig ruleConfig = new RuleConfig(1L, KieScannerStatus.SCANNING); <line11> spec.addConfig(Capability.RULE, ruleConfig); <line12> final String specContent = WebSocketUtils.marshal(spec); <line13> final ContainerSpec specResult = WebSocketUtils.unmarshal(specContent, ContainerSpec.class); <line14> assertNotNull(specResult); <line15> assertEquals(spec, specResult); <line16> assertEquals(spec.getId(), specResult.getId()); <line17> assertEquals(spec.getStatus(), specResult.getStatus()); <line18> assertEquals(spec.getContainerName(), specResult.getContainerName()); <line19> assertEquals(spec.getReleasedId(), specResult.getReleasedId()); <line20> assertNotNull(specResult.getConfigs()); <line21> assertEquals(spec.getConfigs().size(), specResult.getConfigs().size()); <line22> final ContainerConfig processConfigResult = specResult.getConfigs().get(Capability.PROCESS); <line23> assertNotNull(processConfigResult); <line24> assertTrue(processConfigResult instanceof ProcessConfig); <line25> assertEquals(processConfig, processConfigResult); <line26> final ContainerConfig ruleConfigResult = specResult.getConfigs().get(Capability.RULE); <line27> assertNotNull(ruleConfigResult); <line28> assertTrue(ruleConfigResult instanceof RuleConfig); <line29> assertEquals(ruleConfig, ruleConfigResult); <line30> } <line31> } <line32> "	"<line13>    LOGGER.info(""JSON content\n{}"", specContent);"	task4	
public class A { <line0> private static Date parseDate(String dateString) { <line1> if (dateString != null) { <line2> try { <line3> Instant instant = parseInstant(dateString); <line4> return Date.from(instant); <line5> } catch (DateTimeParseException e) { <line6> } <line7> } <line8> return null; <line9> } <line10> } <line11> 	"<line6>        LOGGER.warn(MessageFormat.format(""Could not parse date string: \""{0}\"""", dateString), e);"	task4	
public class A { <line0> private Component getAndValidateOriginComponentOfComponentInstance( <line1> Component containerComponent, ComponentInstance componentInstance) { <line2> ComponentTypeEnum componentType = <line3> getComponentTypeByParentComponentType(containerComponent.getComponentType()); <line4> Component component; <line5> Either<Component, StorageOperationStatus> getComponentRes = <line6> toscaOperationFacade.getToscaFullElement(componentInstance.getComponentUid()); <line7> if (getComponentRes.isRight()) { <line8> ActionStatus actionStatus = <line9> componentsUtils.convertFromStorageResponse( <line10> getComponentRes.right().value(), componentType); <line11> throw new ByActionStatusComponentException(actionStatus, Constants.EMPTY_STRING); <line12> } <line13> component = getComponentRes.left().value(); <line14> LifecycleStateEnum resourceCurrState = component.getLifecycleState(); <line15> if (resourceCurrState == LifecycleStateEnum.NOT_CERTIFIED_CHECKOUT) { <line16> ActionStatus actionStatus = ActionStatus.CONTAINER_CANNOT_CONTAIN_COMPONENT_IN_STATE; <line17> throw new ByActionStatusComponentException( <line18> actionStatus, <line19> containerComponent.getComponentType().toString(), <line20> resourceCurrState.toString()); <line21> } <line22> if (Boolean.TRUE.equals(component.isArchived())) { <line23> ActionStatus actionStatus = ActionStatus.COMPONENT_IS_ARCHIVED; <line24> throw new ByActionStatusComponentException(actionStatus, component.getName()); <line25> } <line26> final Map<String, InterfaceDefinition> componentInterfaces = component.getInterfaces(); <line27> if (MapUtils.isNotEmpty(componentInterfaces)) { <line28> componentInterfaces.forEach(componentInstance::addInterface); <line29> } <line30> return component; <line31> } <line32> } <line33> 	"<line8>      log.debug(""Failed to get the component with id {} for component instance {} creation. "",componentInstance.getComponentUid(),componentInstance.getName());"	task4	
"public class A { <line0> @Override <line1> protected void doSubmit(final AjaxRequestTarget target) { <line2> try { <line3> UserSelfRestClient.changePassword(passwordField.getModelObject()); <line4> SyncopeEnduserSession.get().invalidate(); <line5> final PageParameters parameters = new PageParameters(); <line6> parameters.add(Constants.NOTIFICATION_MSG_PARAM, getString(""self.pwd.change.success"")); <line7> setResponsePage(getApplication().getHomePage(), parameters); <line8> setResponsePage(getApplication().getHomePage(), parameters); <line9> } catch (Exception e) { <line10> SyncopeEnduserSession.get().onException(e); <line11> notificationPanel.refresh(target); <line12> } <line13> } <line14> } <line15> "	"<line10>      LOG.error(""While changing password for {}"",SyncopeEnduserSession.get().getSelfTO().getUsername(),e);"	task4	
public class A { <line0> public static IActionSet getConnectionsActionSetService(String name, String version) <line1> throws ActivatorException { <line2> try { <line3> return (IActionSet) <line4> getServiceFromRegistry(context, createFilterConnectionsActionSet(name, version)); <line5> } catch (InvalidSyntaxException e) { <line6> throw new ActivatorException(e); <line7> } <line8> } <line9> } <line10> 	"<line3>      log.debug(""Calling ConnectionsActionSetService"");"	task4	
public class A { <line0> @Override <line1> public <T extends DomainObject> T fromOid(Object oid) { <line2> OgmOID internalId = (OgmOID) oid; <line3> if (logger.isTraceEnabled()) { <line4> } <line5> return (T) <line6> transactionManager <line7> .getEntityManager() <line8> .find(internalId.getObjClass(), internalId.getPrimaryKey()); <line9> } <line10> } <line11> 	"<line4>      logger.trace(""fromOid("" + internalId + "")"");"	task4	
"public class A { <line0> private void bindUser(String dn, char[] password) throws AuthenticationException { <line1> Hashtable<String, String> env = new Hashtable<>(); <line2> env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory""); <line3> env.put(Context.PROVIDER_URL, providerUrl); <line4> env.put(""com.sun.jndi.ldap.connect.pool"", ""true""); <line5> env.put(Context.SECURITY_AUTHENTICATION, ""simple""); <line6> env.put(Context.SECURITY_PRINCIPAL, dn); <line7> env.put(Context.SECURITY_CREDENTIALS, new String(password)); <line8> if (tls) { <line9> env.put(Context.SECURITY_PROTOCOL, ""ssl""); <line10> } <line11> try { <line12> DirContext ctx = new InitialDirContext(env); <line13> ctx.close(); <line14> } catch (javax.naming.AuthenticationException e) { <line15> throw new AuthenticationException(""Invalid password""); <line16> } catch (NamingException e) { <line17> throw new AuthenticationException(e); <line18> } <line19> } <line20> } <line21> "	"<line15>      log.warn(""Bind failed for dn '{}'"", dn, e);"	task4	
"public class A { <line0> @Operation(name = ""$refresh-generated-content"", type = Measure.class) <line1> public MethodOutcome refreshGeneratedContent( <line2> HttpServletRequest theRequest, RequestDetails theRequestDetails, @IdParam IdType theId) { <line3> Measure theResource = this.measureResourceProvider.getDao().read(theId); <line4> theResource <line5> .getRelatedArtifact() <line6> .removeIf( <line7> relatedArtifact -> <line8> relatedArtifact.getType().equals(RelatedArtifact.RelatedArtifactType.DEPENDSON)); <line9> CqfMeasure cqfMeasure = <line10> this.dataRequirementsProvider.createCqfMeasure(theResource, this.libraryResolutionProvider); <line11> if (!cqfMeasure.getRelatedArtifact().isEmpty()) { <line12> for (RelatedArtifact relatedArtifact : cqfMeasure.getRelatedArtifact()) { <line13> boolean artifactExists = false; <line14> for (RelatedArtifact resourceArtifact : theResource.getRelatedArtifact()) { <line15> if (resourceArtifact.equalsDeep(relatedArtifact)) { <line16> artifactExists = true; <line17> break; <line18> } <line19> } <line20> if (!artifactExists) { <line21> theResource.addRelatedArtifact(relatedArtifact.copy()); <line22> } <line23> } <line24> } <line25> try { <line26> Narrative n = <line27> this.narrativeProvider.getNarrative( <line28> this.measureResourceProvider.getContext(), cqfMeasure); <line29> theResource.setText(n.copy()); <line30> } catch (Exception e) { <line31> } <line32> return this.measureResourceProvider.update( <line33> theRequest, <line34> theResource, <line35> theId, <line36> theRequestDetails.getConditionalUrl(RestOperationTypeEnum.UPDATE), <line37> theRequestDetails); <line38> } <line39> } <line40> "	"<line31>      logger.info(""Error generating narrative"", e);"	task4	
public class A { <line0> public ASTNode readMathML(String mathML, TreeNodeChangeListener listener) <line1> throws XMLStreamException { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> Object object = readXMLFromString(mathML, listener); <line5> if (object != null && object instanceof Constraint) { <line6> ASTNode math = ((Constraint) object).getMath(); <line7> if (math != null) { <line8> cleanTreeNode(math); <line9> return math; <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line3>      logger.debug(""SBMLReader.readMathML called"");"	task4	
public class A { <line0> public void saveProgramAccess(ProgramAccess pa) { <line1> if (pa == null) { <line2> throw new IllegalArgumentException(); <line3> } <line4> getHibernateTemplate().saveOrUpdate(pa); <line5> programAccessListByProgramIdCache.remove(pa.getProgramId()); <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> 	"<line7>      log.debug(""saveProgramAccess:"" + pa.getId());"	task4	
public class A { <line0> public void setMaxTuples(int maxNumbers) { <line1> this.maxTuples = maxNumbers; <line2> } <line3> } <line4> 	"<line1>    LOG.debug(""setting max tuples to {}"", maxNumbers);"	task4	
public class A { <line0> protected void postCommit(Xid arg0) { <line1> } <line2> } <line3> 	"<line1>    logger.info(""In postCommit with: ["" + arg0 + ""]"");"	task4	
"public class A { <line0> @Override <line1> protected void doProcessAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws Exception { <line3> long newFolderId = ParamUtil.getLong(actionRequest, ""newFolderId""); <line4> long[] folderIds = ParamUtil.getLongValues(actionRequest, ""rowIdsJournalFolder""); <line5> ServiceContext serviceContext = <line6> ServiceContextFactory.getInstance(JournalArticle.class.getName(), actionRequest); <line7> for (long folderId : folderIds) { <line8> _journalFolderService.moveFolder(folderId, newFolderId, serviceContext); <line9> } <line10> List<String> invalidArticleIds = new ArrayList<>(); <line11> ThemeDisplay themeDisplay = (ThemeDisplay) actionRequest.getAttribute(WebKeys.THEME_DISPLAY); <line12> String[] articleIds = ParamUtil.getStringValues(actionRequest, ""rowIdsJournalArticle""); <line13> for (String articleId : articleIds) { <line14> try { <line15> _journalArticleService.moveArticle( <line16> themeDisplay.getScopeGroupId(), <line17> HtmlUtil.unescape(articleId), <line18> newFolderId, <line19> serviceContext); <line20> } catch (InvalidDDMStructureException invalidDDMStructureException) { <line21> if (log.isWarnEnabled()) { <line22> } <line23> invalidArticleIds.add(articleId); <line24> } <line25> } <line26> if (!invalidArticleIds.isEmpty()) { <line27> StringBundler sb = new StringBundler(4); <line28> sb.append(""Folder ""); <line29> sb.append(newFolderId); <line30> sb.append("" does not allow the structures for articles: ""); <line31> sb.append(StringUtil.merge(invalidArticleIds)); <line32> throw new InvalidDDMStructureException(sb.toString()); <line33> } <line34> } <line35> } <line36> "	<line22>          log.warn(invalidDDMStructureException.getMessage());	task4	
"public class A { <line0> protected String extractCategoryFormValues() { <line1> String selectedNode = this.getSelectedNode(); <line2> try { <line3> Category category = this.getCategory(selectedNode); <line4> if (null == category) { <line5> this.addActionError(this.getText(""error.category.selectCategory"")); <line6> return ""categoryTree""; <line7> } <line8> this.setParentCategoryCode(category.getParentCode()); <line9> this.setCategoryCode(category.getCode()); <line10> this.setTitles(category.getTitles()); <line11> } catch (Throwable t) { <line12> return FAILURE; <line13> } <line14> return SUCCESS; <line15> } <line16> } <line17> "	"<line12>      logger.error(""error in extractCategoryFormValues"", t);"	task4	
"public class A { <line0> private boolean initializePruningDebug(HttpResponder responder) { <line1> if (!pruneEnable) { <line2> responder.sendString(HttpResponseStatus.BAD_REQUEST, ""Invalid List Pruning is not enabled.""); <line3> return false; <line4> } <line5> synchronized (this) { <line6> if (pruningDebug != null) { <line7> return true; <line8> } <line9> Configuration configuration = new Configuration(); <line10> configuration.clear(); <line11> copyConf(configuration, hConf); <line12> copyConf(configuration, cConf); <line13> try { <line14> @SuppressWarnings(""unchecked"") <line15> Class<? extends InvalidListPruningDebug> clazz = <line16> (Class<? extends InvalidListPruningDebug>) <line17> getClass().getClassLoader().loadClass(PRUNING_TOOL_CLASS_NAME); <line18> this.pruningDebug = clazz.newInstance(); <line19> pruningDebug.initialize(configuration); <line20> } catch (Exception e) { <line21> responder.sendString( <line22> HttpResponseStatus.INTERNAL_SERVER_ERROR, <line23> ""Cannot instantiate the pruning debug tool: "" + e.getMessage()); <line24> pruningDebug = null; <line25> return false; <line26> } <line27> return true; <line28> } <line29> } <line30> } <line31> "	"<line21>        LOG.error(""Not able to instantiate pruning debug class"", e);"	task4	
public class A { <line0> @Override <line1> public boolean advance() throws IOException { <line2> if (isDone) { <line3> return false; <line4> } <line5> ImmutableBytesWritable startKey = this.currentRangeStartKey; <line6> ImmutableBytesWritable hash = this.currentHash; <line7> isDone = !readNextKey(); <line8> currentRangeHash = RangeHash.of(startKey, currentRangeStartKey, hash); <line9> return true; <line10> } <line11> } <line12> 	"<line3>      LOG.debug(""Ending workitem at key "" + immutableBytesToString(currentRangeStartKey) + "" ."");"	task4	
public class A { <line0> synchronized boolean removeKey(Integer keyId) { <line1> requireNonNull(keyId); <line2> return allKeys.remove(keyId) != null; <line3> } <line4> } <line5> 	"<line2>    log.debug(""Removing AuthenticatioKey with keyId {}"", keyId);"	task4	
public class A { <line0> @Override <line1> public void update(ActionDesignTrace actionDesignTrace) { <line2> String updateStatement = updateStatement(actionDesignTrace); <line3> getMetadataRepository().executeUpdate(updateStatement); <line4> } <line5> } <line6> 	"<line2>    LOGGER.trace(MessageFormat.format(""Updating ActionDesignTrace {0}."", actionDesignTrace.getMetadataKey().toString()));"	task4	
"public class A { <line0> @Test <line1> public void testDeserializeVectorUsingPolicy() throws Exception { <line2> Vector<Object> vector = new Vector<Object>(); <line3> vector.add(""pi""); <line4> vector.add(Integer.valueOf(314159)); <line5> vector.add(new Vector<String>()); <line6> vector.add(Boolean.FALSE); <line7> final JmsDefaultDeserializationPolicy policy = new JmsDefaultDeserializationPolicy(); <line8> ByteArrayInputStream input = new ByteArrayInputStream(serializeObject(vector)); <line9> TrustedClassFilter filter = <line10> new TrustedClassFilter() { <line11> @Override <line12> public boolean isTrusted(Class<?> clazz) { <line13> return policy.isTrustedType(new JmsQueue(), clazz); <line14> } <line15> }; <line16> ClassLoadingAwareObjectInputStream reader = <line17> new ClassLoadingAwareObjectInputStream(input, filter); <line18> Object result = null; <line19> try { <line20> result = reader.readObject(); <line21> } catch (Exception ex) { <line22> fail(""Should no throw any errors""); <line23> } finally { <line24> reader.close(); <line25> } <line26> assertNotNull(result); <line27> assertTrue(result instanceof Vector); <line28> assertEquals(4, ((Vector<?>) result).size()); <line29> } <line30> } <line31> "	"<line13>            LOG.trace(""Check for trust status of class: {}"", clazz.getName());"	task4	
public class A { <line0> @Override <line1> public void writeFinished(Connection c, Transfer t) { <line2> this.agent.releaseSendSlot(c); <line3> } <line4> } <line5> 	"<line2>    LOGGER.debug(""Finished sending ""+ (t.isFile() ? t.getFileName() : t.getObject())+ "" through connection ""+ c.hashCode());"	task4	
"public class A { <line0> protected GuiFragment buildGuiFragmentFromRes(ResultSet res) { <line1> GuiFragment guiFragment = null; <line2> try { <line3> guiFragment = new GuiFragment(); <line4> guiFragment.setCode(res.getString(""code"")); <line5> guiFragment.setWidgetTypeCode(res.getString(""widgettypecode"")); <line6> guiFragment.setPluginCode(res.getString(""plugincode"")); <line7> guiFragment.setGui(res.getString(""gui"")); <line8> guiFragment.setDefaultGui(res.getString(""defaultgui"")); <line9> Integer locked = res.getInt(""locked""); <line10> guiFragment.setLocked(null != locked && locked.intValue() == 1); <line11> } catch (Throwable t) { <line12> } <line13> return guiFragment; <line14> } <line15> } <line16> "	"<line12>      logger.error(""Error in buildGuiFragmentFromRes"", t);"	task4	
"public class A { <line0> @Override <line1> protected void setup(Context context) throws IOException, InterruptedException { <line2> String multipleOutputStr = context.getConfiguration().get(PROPERTY_MULTIPLEOUTPUTS); <line3> Preconditions.checkArgument( <line4> StringUtils.isNotBlank(multipleOutputStr), <line5> ""required parameter '%s' is missing!"", <line6> PROPERTY_MULTIPLEOUTPUTS); <line7> this.mos = instantiateMultipleOutputs(context); <line8> this.mimeTypeToPortNameMap = new HashMap<CharSequence, String>(); <line9> String[] portNames = <line10> StringUtils.split(context.getConfiguration().get(PROPERTY_MULTIPLEOUTPUTS)); <line11> for (String portName : portNames) { <line12> String currentMimeTypePropName = PROPERTY_PREFIX_MIMETYPES_CSV + portName; <line13> if (context.getConfiguration().get(currentMimeTypePropName) != null) { <line14> String[] currentPortMimeTypes = <line15> StringUtils.split( <line16> context.getConfiguration().get(currentMimeTypePropName), <line17> WorkflowRuntimeParameters.DEFAULT_CSV_DELIMITER); <line18> for (String currentPortMimeType : currentPortMimeTypes) { <line19> if (!currentPortMimeType.isEmpty() <line20> && !WorkflowRuntimeParameters.UNDEFINED_NONEMPTY_VALUE.equals(currentPortMimeType)) { <line21> this.mimeTypeToPortNameMap.put(currentPortMimeType.toLowerCase(), portName); <line22> } <line23> } <line24> } else { <line25> } <line26> } <line27> } <line28> } <line29> "	"<line25>        log.warn(""undefined property '""+ currentMimeTypePropName+ ""', no data will be dispatched to port '""+ portName+ ""'"");"	task4	
"public class A { <line0> public Study updateStudyDiseaseTraitByAccessionId(String trait, String accessionId) { <line1> Study study = <line2> this.getStudyByAccessionId(accessionId) <line3> .orElseThrow(() -> new ResourceNotFoundException(""Study"", accessionId)); <line4> DiseaseTrait diseaseTrait = <line5> Optional.ofNullable(diseaseTraitRepository.findByTraitIgnoreCase(trait)) <line6> .orElseThrow(() -> new ResourceNotFoundException(""Disease Trait"", trait)); <line7> study.setDiseaseTrait(diseaseTrait); <line8> studyRepository.save(study); <line9> return study; <line10> } <line11> } <line12> "	"<line9>    log.info(""Study with accession Id: {} found and updated"", accessionId);"	task4	
public class A { <line0> @Test <line1> @Ignore <line2> public final void testSendProcessConfigurationRequest() { <line3> ActiveRequestSenderTest.testType = TestType.CONFIG; <line4> ProcessConfiguration processConfiguration = new ProcessConfiguration(); <line5> processConfiguration.setProcessName(PROCESS_NAME); <line6> processConfiguration.setprocessPIK(PROCESS_PIK); <line7> ProcessConfigurationHolder.setInstance(processConfiguration); <line8> ProcessConfigurationResponse processConfigurationResponse = <line9> this.activeRequestSender.sendProcessConfigurationRequest(PROCESS_NAME); <line10> compareConfiguration(processConfigurationResponse); <line11> } <line12> } <line13> 	"<line4>    LOGGER.debug(""Starting "" + ActiveRequestSenderTest.testType.getName());"	task4	
"public class A { <line0> private CompletableFuture<AsyncBiFunctionService.WithSerdes<String, String, Integer>> <line1> createKafkaStreams( <line2> Config config, Properties kafkaProperties, String storeTopic, String storeName) { <line3> long timeoutMillis = config.get(Config.STALE_RESULT_TIMEOUT_MS); <line4> ForeachActionDispatcher<String, Integer> dispatcher = new ForeachActionDispatcher<>(); <line5> WaitForResultService serviceImpl = new WaitForResultService(timeoutMillis, dispatcher); <line6> closeables.add(serviceImpl); <line7> AtomicBoolean done = new AtomicBoolean(false); <line8> CompletableFuture<AsyncBiFunctionService.WithSerdes<String, String, Integer>> cf = <line9> new CompletableFuture<>(); <line10> KafkaStreams.StateListener listener = <line11> (newState, oldState) -> { <line12> if (newState == KafkaStreams.State.RUNNING && !done.getAndSet(true)) { <line13> cf.completeAsync(() -> serviceImpl); <line14> } <line15> if (newState == KafkaStreams.State.ERROR) { <line16> cf.completeExceptionally(new IllegalStateException(""KafkaStreams error"")); <line17> } <line18> }; <line19> Properties streamsProperties = new Properties(); <line20> streamsProperties.putAll(kafkaProperties); <line21> Object rf = kafkaProperties.get(StreamsConfig.REPLICATION_FACTOR_CONFIG); <line22> if (rf == null) { <line23> streamsProperties.put(StreamsConfig.REPLICATION_FACTOR_CONFIG, ""-1""); <line24> } <line25> Topology topology = <line26> new TopicStoreTopologyProvider(storeTopic, storeName, streamsProperties, dispatcher).get(); <line27> streams = new KafkaStreams(topology, streamsProperties); <line28> streams.setStateListener(listener); <line29> streams.setGlobalStateRestoreListener(new LoggingStateRestoreListener()); <line30> closeables.add(streams); <line31> streams.start(); <line32> return cf; <line33> } <line34> } <line35> "	"<line3>    log.info(""Creating Kafka Streams, store name: {}"", storeName);"	task4	
"public class A { <line0> @Override <line1> public void mouseClicked(MouseEvent mouseEvent) { <line2> JList theList = (JList) mouseEvent.getSource(); <line3> if (mouseEvent.getClickCount() == 2) { <line4> int index = theList.locationToIndex(mouseEvent.getPoint()); <line5> if (index >= 0) { <line6> Object o = theList.getModel().getElementAt(index); <line7> send(""toggleFilter"", o.toString()); <line8> } <line9> } <line10> } <line11> } <line12> "	"<line7>        log.info(""Double-clicked on: {} Toggling filter enabled."", o);"	task4	
"public class A { <line0> public CubeInstance createCubeAndDesc(String cubeName, String projectName, CubeDesc desc) <line1> throws IOException { <line2> if (getCubeManager().getCube(cubeName) != null) { <line3> throw new InternalErrorException(""The cube named "" + cubeName + "" already exists""); <line4> } <line5> String owner = SecurityContextHolder.getContext().getAuthentication().getName(); <line6> CubeDesc createdDesc = null; <line7> CubeInstance createdCube = null; <line8> boolean isNew = false; <line9> if (getCubeDescManager().getCubeDesc(desc.getName()) == null) { <line10> createdDesc = getCubeDescManager().createCubeDesc(desc); <line11> isNew = true; <line12> } else { <line13> createdDesc = getCubeDescManager().updateCubeDesc(desc); <line14> } <line15> if (!createdDesc.getError().isEmpty()) { <line16> if (isNew) { <line17> getCubeDescManager().removeCubeDesc(createdDesc); <line18> } <line19> throw new InternalErrorException(createdDesc.getError().get(0)); <line20> } <line21> try { <line22> int cuboidCount = CuboidCLI.simulateCuboidGeneration(createdDesc); <line23> } catch (Exception e) { <line24> getCubeDescManager().removeCubeDesc(createdDesc); <line25> throw new InternalErrorException(""Failed to deal with the request."", e); <line26> } <line27> createdCube = getCubeManager().createCube(cubeName, projectName, createdDesc, owner); <line28> accessService.init(createdCube, AclPermission.ADMINISTRATION); <line29> ProjectInstance project = getProjectManager().getProject(projectName); <line30> accessService.inherit(createdCube, project); <line31> return createdCube; <line32> } <line33> } <line34> "	"<line23>      logger.info(""New cube "" + cubeName + "" has "" + cuboidCount + "" cuboids"");"	task4	
public class A { <line0> private double addNetworkDelays( <line1> Solution bestSol, <line2> Topology topology, <line3> double[] numVisitsModule, <line4> SuitableOptions cloudCharacteristics) { <line5> double networkDelay = 0.0; <line6> for (int i = 0; i < topology.size(); i++) { <line7> TopologyElement element = topology.getElementIndex(i); <line8> double sumOfDelaysSingleModule = 0.0; <line9> for (TopologyElementCalled elementCalled : element) { <line10> sumOfDelaysSingleModule += <line11> elementCalled.getProbCall() <line12> * latencyBetweenElements( <line13> bestSol, <line14> element.getName(), <line15> elementCalled.getElement().getName(), <line16> cloudCharacteristics); <line17> } <line18> networkDelay += numVisitsModule[i] * sumOfDelaysSingleModule; <line19> } <line20> return networkDelay; <line21> } <line22> } <line23> 	"<line18>      log.trace(""calculated network delay for module {} in solution {} is (numVisitsModule[i] *""+ "" sumOfDelaysSingleModule): {}"",i,bestSol.toString(),numVisitsModule[i] * sumOfDelaysSingleModule);"	task4	
public class A { <line0> public int assertStatusCode(Response res, String testName) { <line1> int statusCode = res.getStatus(); <line2> Assert.assertTrue( <line3> testRequestType.isValidStatusCode(statusCode), <line4> invalidStatusCodeMessage(testRequestType, statusCode)); <line5> Assert.assertEquals(statusCode, testExpectedStatusCode); <line6> return statusCode; <line7> } <line8> } <line9> 	"<line2>    logger.debug(testName + "": status = "" + statusCode);"	task4	
public class A { <line0> public void createSessionIdCookie(SessionId sessionId, boolean isUma) { <line1> try { <line2> final Object response = externalContext.getResponse(); <line3> final Object request = externalContext.getRequest(); <line4> if (response instanceof HttpServletResponse && request instanceof HttpServletRequest) { <line5> final HttpServletResponse httpResponse = (HttpServletResponse) response; <line6> final HttpServletRequest httpRequest = (HttpServletRequest) request; <line7> createSessionIdCookie(sessionId, httpRequest, httpResponse, isUma); <line8> } <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> 	<line10>      log.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public void callCrawlerService() { <line2> getCrawlerService().crawlSite(getAudit(), getUrl()); <line3> } <line4> } <line5> 	"<line2>    LOGGER.info(""Launching crawler for page "" + getUrl());"	task4	
public class A { <line0> public static com.liferay.calendar.model.CalendarResourceSoap[] search( <line1> long companyId, <line2> long[] groupIds, <line3> long[] classNameIds, <line4> String code, <line5> String name, <line6> String description, <line7> boolean active, <line8> boolean andOperator, <line9> int start, <line10> int end, <line11> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.calendar.model.CalendarResource> <line12> orderByComparator) <line13> throws RemoteException { <line14> try { <line15> java.util.List<com.liferay.calendar.model.CalendarResource> returnValue = <line16> CalendarResourceServiceUtil.search( <line17> companyId, <line18> groupIds, <line19> classNameIds, <line20> code, <line21> name, <line22> description, <line23> active, <line24> andOperator, <line25> start, <line26> end, <line27> orderByComparator); <line28> return com.liferay.calendar.model.CalendarResourceSoap.toSoapModels(returnValue); <line29> } catch (Exception exception) { <line30> throw new RemoteException(exception.getMessage()); <line31> } <line32> } <line33> } <line34> 	<line30>      log.error(exception, exception);	task4	
public class A { <line0> private PropertyConverter createConverter(SecurityContext securityContext, GraphObject entity) { <line1> try { <line2> return (PropertyConverter<?, T>) constructor.newInstance(securityContext, entity); <line3> } catch (Throwable t) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line4>      logger.error(""Unable to instantiate converter of type {} for key {}"",new Object[] {constructor.getClass().getName(), dbName});"	task4	
"public class A { <line0> @Override <line1> public ConnectorPageSource createPageSource( <line2> ConnectorTransactionHandle transaction, <line3> ConnectorSession session, <line4> ConnectorSplit split, <line5> ConnectorTableHandle table, <line6> List<ColumnHandle> columns, <line7> DynamicFilter dynamicFilter) { <line8> BigQuerySplit bigQuerySplit = (BigQuerySplit) split; <line9> checkArgument( <line10> bigQuerySplit.getColumns().isEmpty() || bigQuerySplit.getColumns().equals(columns), <line11> ""Requested columns %s do not match list in split %s"", <line12> columns, <line13> bigQuerySplit.getColumns()); <line14> if (bigQuerySplit.representsEmptyProjection()) { <line15> return new BigQueryEmptyProjectionPageSource(bigQuerySplit.getEmptyRowsToGenerate()); <line16> } <line17> List<BigQueryColumnHandle> bigQueryColumnHandles = <line18> columns.stream().map(BigQueryColumnHandle.class::cast).collect(toImmutableList()); <line19> return new BigQueryResultPageSource( <line20> bigQueryStorageClientFactory, maxReadRowsRetries, bigQuerySplit, bigQueryColumnHandles); <line21> } <line22> } <line23> "	"<line8>    log.debug(""createPageSource(transaction=%s, session=%s, split=%s, table=%s, columns=%s)"",transaction, session, split, table, columns);"	task4	
"public class A { <line0> @Override <line1> public ReturnValue update_processing_status(int processingID, ProcessingStatus status) { <line2> if (status == null) { <line3> return new ReturnValue( <line4> null, ""Processing.Status argument cannot be null"", ReturnValue.INVALIDARGUMENT); <line5> } <line6> StringBuilder sql = new StringBuilder(); <line7> try { <line8> sql.append(""UPDATE processing SET status = ""); <line9> sql.append(""'"").append(status.name()).append(""'""); <line10> sql.append("", update_tstmp='"").append(new Timestamp(System.currentTimeMillis())).append(""' ""); <line11> sql.append("" WHERE processing_id = "").append(processingID); <line12> executeUpdate(sql.toString()); <line13> } catch (SQLException e) { <line14> return new ReturnValue( <line15> null, <line16> ""Could not execute one of the SQL commands: "" <line17> + sql.toString() <line18> + ""\nException: "" <line19> + e.getMessage(), <line20> ReturnValue.SQLQUERYFAILED); <line21> } <line22> return new ReturnValue(); <line23> } <line24> } <line25> "	"<line14>      logger.error(""SQL Command failed: "" + sql.toString() + "":"" + e.getMessage());"	task4	
"public class A { <line0> private void logError(Path path, IOException e) { <line1> if (logToStdErr) { <line2> System.err.println(""Unexpected file visiting failure: "" + path); <line3> e.printStackTrace(); <line4> } else { <line5> } <line6> } <line7> } <line8> "	"<line5>      LOGGER.error(""Unexpected file visiting failure: "" + path, e);"	task4	
"public class A { <line0> @Override <line1> public MLModel call() throws Exception { <line2> FileSystem fs = modelPath.getFileSystem(new HiveConf()); <line3> if (!fs.exists(modelPath)) { <line4> throw new IOException(""Model path not found "" + modelPath.toString()); <line5> } <line6> ObjectInputStream ois = null; <line7> try { <line8> ois = new ObjectInputStream(fs.open(modelPath)); <line9> MLModel model = (MLModel) ois.readObject(); <line10> return model; <line11> } catch (ClassNotFoundException e) { <line12> throw new IOException(e); <line13> } finally { <line14> IOUtils.closeQuietly(ois); <line15> } <line16> } <line17> } <line18> "	"<line10>      log.info(""Loaded model {} from location {}"", model.getId(), modelPath);"	task4	
public class A { <line0> @Override <line1> public void beforeDocumentChange(DocumentEvent e) { <line2> if (myDuringOnesideDocumentModification) return; <line3> if (myChangedBlockData == null) { <line4> return; <line5> } <line6> try { <line7> myDuringTwosideDocumentModification = true; <line8> Document twosideDocument = getDocument(myMasterSide); <line9> LineCol onesideStartPosition = LineCol.fromOffset(myDocument, e.getOffset()); <line10> LineCol onesideEndPosition = LineCol.fromOffset(myDocument, e.getOffset() + e.getOldLength()); <line11> int line1 = onesideStartPosition.line; <line12> int line2 = onesideEndPosition.line + 1; <line13> int shift = DiffUtil.countLinesShift(e); <line14> int twosideStartLine = transferLineFromOnesideStrict(myMasterSide, onesideStartPosition.line); <line15> int twosideEndLine = transferLineFromOnesideStrict(myMasterSide, onesideEndPosition.line); <line16> if (twosideStartLine == -1 || twosideEndLine == -1) { <line17> logDebugInfo(e, onesideStartPosition, onesideEndPosition, twosideStartLine, twosideEndLine); <line18> markSuppressEditorTyping(); <line19> return; <line20> } <line21> int twosideStartOffset = <line22> twosideDocument.getLineStartOffset(twosideStartLine) + onesideStartPosition.column; <line23> int twosideEndOffset = <line24> twosideDocument.getLineStartOffset(twosideEndLine) + onesideEndPosition.column; <line25> twosideDocument.replaceString(twosideStartOffset, twosideEndOffset, e.getNewFragment()); <line26> for (UnifiedDiffChange change : myChangedBlockData.getDiffChanges()) { <line27> change.processChange(line1, line2, shift); <line28> } <line29> LineNumberConvertor lineNumberConvertor = myChangedBlockData.getLineNumberConvertor(); <line30> lineNumberConvertor.handleOnesideChange(line1, line2, shift, myMasterSide); <line31> } finally { <line32> markStateIsOutOfDate(); <line33> scheduleRediff(); <line34> myDuringTwosideDocumentModification = false; <line35> } <line36> } <line37> } <line38> 	"<line4>      LOG.warn(""oneside beforeDocumentChange - myChangedBlockData == null"");"	task4	
"public class A { <line0> private Optional<TaskCleanupType> getCleanupType(SingularityTaskId taskId, String statusMessage) { <line1> try { <line2> String[] cleanupTypeString = statusMessage.split(""\\s+""); <line3> if (cleanupTypeString.length > 0) { <line4> return Optional.of(TaskCleanupType.valueOf(cleanupTypeString[0])); <line5> } <line6> } catch (Throwable t) { <line7> } <line8> return Optional.empty(); <line9> } <line10> } <line11> "	"<line7>      LOG.info(""Could not parse cleanup type from {} for {}"", statusMessage, taskId);"	task4	
public class A { <line0> public static void annotationMockSupportSetup( <line1> Class<?> testClass, String methodName, ActivitiMockSupport mockSupport) { <line2> Method method = null; <line3> try { <line4> method = testClass.getMethod(methodName, (Class<?>[]) null); <line5> } catch (Exception e) { <line6> return; <line7> } <line8> handleMockServiceTaskAnnotation(mockSupport, method); <line9> handleMockServiceTasksAnnotation(mockSupport, method); <line10> handleNoOpServiceTasksAnnotation(mockSupport, method); <line11> } <line12> } <line13> 	"<line6>      log.warn(""Could not get method by reflection. This could happen if you are using @Parameters in""+ "" combination with annotations."",e);"	task4	
public class A { <line0> @Override <line1> public void onWarning(String message) { <line2> if (loggingInitialized.get()) { <line3> } else { <line4> warnings.add(message); <line5> } <line6> } <line7> } <line8> 	<line3>      log.warn(message);	task4	
public class A { <line0> @Asynchronous <line1> public void processMetadataValidationTimerEvent( <line2> @Observes @Scheduled EntityIdMonitoringEvent entityIdMonitoringEvent) { <line3> if (this.isActive.get()) { <line4> return; <line5> } <line6> if (!this.isActive.compareAndSet(false, true)) { <line7> return; <line8> } <line9> try { <line10> process(); <line11> } catch (Throwable ex) { <line12> } finally { <line13> this.isActive.set(false); <line14> } <line15> } <line16> } <line17> 	"<line12>      log.error(""Exception happened while monitoring EntityId"", ex);"	task4	
"public class A { <line0> @Test <line1> public void TestCreateDupGenericVnfFailure_1002() { <line2> new MockAAIGenericVnfSearch(wireMockServer); <line3> MockAAICreateGenericVnf(wireMockServer); <line4> MockAAIVfModulePUT(wireMockServer, true); <line5> Map<String, Object> variables = new HashMap<>(); <line6> variables.put(""mso-request-id"", UUID.randomUUID().toString()); <line7> variables.put(""isDebugLogEnabled"", ""true""); <line8> variables.put(""isVidRequest"", ""false""); <line9> variables.put(""vnfName"", ""STMTN5MMSC21""); <line10> variables.put(""serviceId"", ""00000000-0000-0000-0000-000000000000""); <line11> variables.put(""personaModelId"", ""973ed047-d251-4fb9-bf1a-65b8949e0a73""); <line12> variables.put(""personaModelVersion"", ""1.0""); <line13> variables.put(""vfModuleName"", ""STMTN5MMSC21-MMSC::module-0-0""); <line14> variables.put(""vfModuleModelName"", ""MMSC::module-0""); <line15> String processId = invokeSubProcess(""CreateAAIVfModule"", variables); <line16> WorkflowException exception = <line17> BPMNUtil.getRawVariable(processEngine, ""CreateAAIVfModule"", ""WorkflowException"", processId); <line18> Assert.assertEquals(1002, exception.getErrorCode()); <line19> Assert.assertEquals( <line20> true, <line21> exception <line22> .getErrorMessage() <line23> .contains(""Invalid request for new Generic VNF which already exists"")); <line24> } <line25> } <line26> "	<line24>    logger.debug(exception.getErrorMessage());	task4	
public class A { <line0> public synchronized void setMaxActive(int maxActive) { <line1> if (maxActive != this.maxActive) { <line2> maxActiveSemaphore = makeSemaphore(maxActive); <line3> this.maxActive = maxActive; <line4> } <line5> } <line6> } <line7> 	"<line2>      log.debug(""change max [active] semaphore with new permit {}"", maxActive);"	task4	
public class A { <line0> @Override <line1> public void publishApi(Api api, IAsyncResultHandler<Void> handler) { <line2> super.publishApi(api, handler); <line3> proxy.publishApi(api); <line4> } <line5> } <line6> 	"<line4>    log.info(""Published an API {0}"", api);"	task4	
public class A { <line0> private void notifyFailure(Stream stream, FailureFrame frame, Callback callback) { <line1> Listener listener = this.listener; <line2> if (listener != null) { <line3> try { <line4> listener.onFailure( <line5> stream, frame.getError(), frame.getReason(), frame.getFailure(), callback); <line6> } catch (Throwable x) { <line7> callback.failed(x); <line8> } <line9> } else { <line10> callback.succeeded(); <line11> } <line12> } <line13> } <line14> 	"<line7>        LOG.info(""Failure while notifying listener {}"", listener, x);"	task4	
public class A { <line0> @Override <line1> protected void doResume() throws Exception { <line2> if (!initialized) { <line3> doStart(); <line4> } else { <line5> if (listenerContainer != null) { <line6> startListenerContainer(); <line7> } else { <line8> } <line9> } <line10> } <line11> } <line12> 	"<line8>        LOG.warn(""The listenerContainer is not instantiated. Probably there was a timeout during the""+ "" Suspend operation. Please restart your consumer route."");"	task4	
public class A { <line0> @Override <line1> public void doExceptionCaughtListeners(final long sessionId, final Throwable cause) { <line2> runManagementTask( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> try { <line7> final String exceptionMessage = Utils.getCauseString(cause); <line8> List<ServiceManagementListener> serviceListeners = getManagementListeners(); <line9> for (final ServiceManagementListener listener : serviceListeners) { <line10> listener.doExceptionCaught( <line11> DefaultServiceManagementBean.this, sessionId, exceptionMessage); <line12> } <line13> markChanged(); <line14> } catch (Exception ex) { <line15> } <line16> } <line17> }); <line18> } <line19> } <line20> 	"<line15>              logger.warn(""Error during doExceptionCaught service listener notifications:"", ex);"	task4	
public class A { <line0> protected MsoException runtimeExceptionToMsoException(RuntimeException e, String context) { <line1> MsoAdapterException me = new MsoAdapterException(e.getMessage(), e); <line2> me.addContext(context); <line3> me.setCategory(MsoExceptionCategory.INTERNAL); <line4> return me; <line5> } <line6> } <line7> 	"<line4>    logger.error(""{} {} An exception occured on {}: "",MessageEnum.RA_GENERAL_EXCEPTION_ARG,ErrorCode.DataError.getValue(),context,e);"	task4	
public class A { <line0> public static NotebookAuthorization getInstance() { <line1> if (instance == null) { <line2> init(ZeppelinConfiguration.create()); <line3> } <line4> return instance; <line5> } <line6> } <line7> 	"<line2>      LOG.warn(""Notebook authorization module was called without initialization,""+ "" initializing with default configuration"");"	task4	
public class A { <line0> public static <O extends ObjectType> PrismObject<O> reconstructObject( <line1> Class<O> type, String oid, String eventIdentifier, Task task, OperationResult result) { <line2> try { <line3> MidPointApplication application = (MidPointApplication) MidPointApplication.get(); <line4> return application <line5> .getAuditService() <line6> .reconstructObject(type, oid, eventIdentifier, task, result); <line7> } catch (Exception ex) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line8>      LOGGER.debug(""Error occurred while reconsructing the object, "" + ex.getMessage());"	task4	
"public class A { <line0> protected Pattern createNonProxyPattern(String nonProxyHosts) { <line1> if (nonProxyHosts == null || nonProxyHosts.isEmpty()) return null; <line2> nonProxyHosts = nonProxyHosts.replaceAll(""\\."", ""\\\\."").replaceAll(""\\*"", "".*?""); <line3> nonProxyHosts = ""("" + nonProxyHosts.replaceAll(""\\|"", "")|("") + "")""; <line4> try { <line5> return Pattern.compile(nonProxyHosts); <line6> } catch (Exception e) { <line7> return null; <line8> } <line9> } <line10> } <line11> "	"<line7>      logger.error(""Creating the nonProxyHosts pattern failed for http.nonProxyHosts="" + nonProxyHosts, e);"	task4	
public class A { <line0> @Override <line1> public void call(final Object... args) { <line2> handleError(Socket.EVENT_DISCONNECT, args); <line3> isConnected = false; <line4> } <line5> } <line6> 	"<line2>    logger.debug(""Listener: Disconnected from the ambient weather service)"");"	task4	
public class A { <line0> @ClientCacheEntryExpired <line1> public void expired(ClientCacheEntryExpiredEvent e) { <line2> for (ExpiredListener listener : expired) { <line3> try { <line4> listener.expired(e.getKey(), null); <line5> } catch (Exception ex) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        log.error(""Listener "" + listener + "" has thrown an exception"", ex);"	task4	
public class A { <line0> @Override <line1> public boolean saveAddress(AddressType address) throws LoadTestDataException { <line2> SaveAddressRequestMessageType request = new SaveAddressRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setAddress(address); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_SAVEADDRESS, request); <line9> logDebug(AdminWSConstants.ADMIN_LTD_SAVEADDRESS, response.isStatus(), response.getMessage()); <line10> return response.isStatus(); <line11> } catch (Exception e) { <line12> } <line13> return false; <line14> } <line15> } <line16> 	"<line12>      LOG.error(""error during save address: {}"", e.getLocalizedMessage(), e);"	task4	
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap <line1> addCommerceInventoryWarehouseItem( <line2> long userId, long commerceInventoryWarehouseId, String sku, int quantity) <line3> throws RemoteException { <line4> try { <line5> com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItem returnValue = <line6> CommerceInventoryWarehouseItemServiceUtil.addCommerceInventoryWarehouseItem( <line7> userId, commerceInventoryWarehouseId, sku, quantity); <line8> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap.toSoapModel( <line9> returnValue); <line10> } catch (Exception exception) { <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> } <line14> } <line15> 	<line11>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void onActivityTestGPRSRequest(ActivityTestGPRSRequest ind) { <line2> TestEvent te = <line3> TestEvent.createReceivedEvent(EventType.ActivityTestGPRSRequest, ind, sequence++); <line4> this.observerdEvents.add(te); <line5> } <line6> } <line7> 	"<line2>    this.logger.debug(""ActivityTestGPRSRequest"");"	task4	
"public class A { <line0> @Test <line1> public void testSendSlowClientSuccess() throws Exception { <line2> try (SiteToSiteClient client = <line3> getDefaultBuilder() <line4> .idleExpiration(1000, TimeUnit.MILLISECONDS) <line5> .portName(""input-running"") <line6> .build()) { <line7> final Transaction transaction = client.createTransaction(TransferDirection.SEND); <line8> assertNotNull(transaction); <line9> serverChecksum = ""3882825556""; <line10> for (int i = 0; i < 3; i++) { <line11> DataPacket packet = <line12> new DataPacketBuilder() <line13> .contents(""Example contents from client."") <line14> .attr(""Client attr 1"", ""Client attr 1 value"") <line15> .attr(""Client attr 2"", ""Client attr 2 value"") <line16> .build(); <line17> transaction.send(packet); <line18> long written = <line19> ((Peer) transaction.getCommunicant()).getCommunicationsSession().getBytesWritten(); <line20> Thread.sleep(50); <line21> } <line22> transaction.confirm(); <line23> transaction.complete(); <line24> } <line25> } <line26> } <line27> "	"<line20>        logger.info(""{} bytes have been written."", written);"	task4	
public class A { <line0> public void run() { <line1> synchronized (this) { <line2> if (retryTimer.isPresent()) { <line3> retryTimer = Optional.empty(); <line4> } else { <line5> return; <line6> } <line7> } <line8> cancelToResume(); <line9> } <line10> } <line11> 	"<line3>        LOG.warn(""Snapshot restore timed out, failed to restore snapshot for %s, snapshot %s"",queryId.getId(), lastTriedId.toString());"	task4	
"public class A { <line0> public static void deleteKeycloak(String namespace) { <line1> Exec.exec(true, ""/bin/bash"", PATH_TO_KEYCLOAK_TEARDOWN_SCRIPT, namespace); <line2> } <line3> } <line4> "	"<line1>    LOGGER.info(""Teardown Keycloak in namespace: {}"", namespace);"	task4	
"public class A { <line0> @Override <line1> public Map<String, Metric> getMetrics() { <line2> final Map<String, Metric> gauges = new HashMap<>(); <line3> for (String pool : POOLS) { <line4> for (int i = 0; i < ATTRIBUTES.length; i++) { <line5> final String attribute = ATTRIBUTES[i]; <line6> final String name = NAMES[i]; <line7> try { <line8> final ObjectName on = new ObjectName(""java.nio:type=BufferPool,name="" + pool); <line9> mBeanServer.getMBeanInfo(on); <line10> gauges.put(name(pool, name), new JmxAttributeGauge(mBeanServer, on, attribute)); <line11> } catch (JMException ignored) { <line12> } <line13> } <line14> } <line15> return Collections.unmodifiableMap(gauges); <line16> } <line17> } <line18> "	"<line12>          LOGGER.debug(""Unable to load buffer pool MBeans, possibly running on Java 6"");"	task4	
"public class A { <line0> public static void updateJobCredentialProviders(Configuration jobConf) { <line1> if (jobConf == null) { <line2> return; <line3> } <line4> String jobKeyStoreLocation = <line5> jobConf.get(HiveConf.ConfVars.HIVE_SERVER2_JOB_CREDENTIAL_PROVIDER_PATH.varname); <line6> String oldKeyStoreLocation = jobConf.get(Constants.HADOOP_CREDENTIAL_PROVIDER_PATH_CONFIG); <line7> if (StringUtils.isNotBlank(jobKeyStoreLocation)) { <line8> jobConf.set(Constants.HADOOP_CREDENTIAL_PROVIDER_PATH_CONFIG, jobKeyStoreLocation); <line9> } <line10> String credstorePassword = getJobCredentialProviderPassword(jobConf); <line11> if (credstorePassword != null) { <line12> String execEngine = jobConf.get(ConfVars.HIVE_EXECUTION_ENGINE.varname); <line13> if (""mr"".equalsIgnoreCase(execEngine)) { <line14> Collection<String> redactedProperties = <line15> jobConf.getStringCollection(MRJobConfig.MR_JOB_REDACTED_PROPERTIES); <line16> Stream.of( <line17> JobConf.MAPRED_MAP_TASK_ENV, <line18> JobConf.MAPRED_REDUCE_TASK_ENV, <line19> MRJobConfig.MR_AM_ADMIN_USER_ENV) <line20> .forEach( <line21> property -> { <line22> addKeyValuePair( <line23> jobConf, <line24> property, <line25> Constants.HADOOP_CREDENTIAL_PASSWORD_ENVVAR, <line26> credstorePassword); <line27> redactedProperties.add(property); <line28> }); <line29> jobConf.set( <line30> MRJobConfig.MR_JOB_REDACTED_PROPERTIES, StringUtils.join(redactedProperties, COMMA)); <line31> } <line32> } <line33> } <line34> } <line35> "	"<line9>      LOG.debug(""Setting job conf credstore location to ""+ jobKeyStoreLocation+ "" previous location was ""+ oldKeyStoreLocation);"	task4	
public class A { <line0> private void onReceiveServerStopInstanceReq(ServerStopInstanceReq req) { <line1> TaskTracker taskTracker = TaskTrackerPool.getTaskTrackerPool(req.getInstanceId()); <line2> if (taskTracker == null) { <line3> return; <line4> } <line5> taskTracker.destroy(); <line6> } <line7> } <line8> 	"<line3>      log.warn(""[TaskTrackerActor] receive ServerStopInstanceReq({}) but system can't find TaskTracker."",req);"	task4	
"public class A { <line0> @Override <line1> public UpdatePkgLocalizationResult updatePkgLocalization( <line2> UpdatePkgLocalizationRequest updatePkgLocalizationRequest) { <line3> Preconditions.checkArgument(null != updatePkgLocalizationRequest); <line4> Preconditions.checkArgument( <line5> !Strings.isNullOrEmpty(updatePkgLocalizationRequest.pkgName), <line6> ""the package name must be supplied""); <line7> final ObjectContext context = serverRuntime.newContext(); <line8> Pkg pkg = getPkg(context, updatePkgLocalizationRequest.pkgName); <line9> User authUser = obtainAuthenticatedUser(context); <line10> if (!permissionEvaluator.hasPermission( <line11> SecurityContextHolder.getContext().getAuthentication(), <line12> pkg, <line13> Permission.PKG_EDITLOCALIZATION)) { <line14> throw new AccessDeniedException(""unable to edit the package localization for ["" + pkg + ""]""); <line15> } <line16> for (org.haiku.haikudepotserver.api1.model.pkg.PkgLocalization requestPkgVersionLocalization : <line17> updatePkgLocalizationRequest.pkgLocalizations) { <line18> NaturalLanguage naturalLanguage = <line19> getNaturalLanguage(context, requestPkgVersionLocalization.naturalLanguageCode); <line20> pkgLocalizationService.updatePkgLocalization( <line21> context, <line22> pkg.getPkgSupplement(), <line23> naturalLanguage, <line24> requestPkgVersionLocalization.title, <line25> requestPkgVersionLocalization.summary, <line26> requestPkgVersionLocalization.description); <line27> } <line28> context.commitChanges(); <line29> return new UpdatePkgLocalizationResult(); <line30> } <line31> } <line32> "	"<line29>    LOGGER.info(""did update the localization for pkg {} for {} natural languages"",pkg.getName(),updatePkgLocalizationRequest.pkgLocalizations.size());"	task4	
public class A { <line0> private static KapuaMessage<?, ?> convertToKapuaMessage( <line1> Class<? extends DeviceMessage<?, ?>> deviceMessageType, <line2> Class<? extends KapuaMessage<?, ?>> kapuaMessageType, <line3> byte[] messageBody, <line4> String jmsTopic, <line5> Date queuedOn, <line6> String clientId) <line7> throws KapuaException { <line8> Translator<JmsMessage, DeviceMessage<?, ?>> translatorFromJms = <line9> Translator.getTranslatorFor(JmsMessage.class, deviceMessageType); <line10> DeviceMessage<?, ?> deviceMessage = <line11> translatorFromJms.translate( <line12> new JmsMessage(new JmsTopic(jmsTopic), queuedOn, new JmsPayload(messageBody))); <line13> Translator<DeviceMessage<?, ?>, KapuaMessage<?, ?>> translatorToKapua = <line14> Translator.getTranslatorFor(deviceMessageType, kapuaMessageType); <line15> KapuaMessage<?, ?> message = translatorToKapua.translate(deviceMessage); <line16> if (StringUtils.isEmpty(message.getClientId())) { <line17> message.setClientId(clientId); <line18> } <line19> return message; <line20> } <line21> } <line22> 	"<line17>      logger.debug(""Updating client id since the received value is null (new value {})"", clientId);"	task4	
public class A { <line0> @Test <line1> public void testStartNodes() throws Exception { <line2> for (int i = 0; i < ITERATIONS; i++) { <line3> try { <line4> doTest(); <line5> } finally { <line6> stopAllGrids(true); <line7> } <line8> } <line9> } <line10> } <line11> 	"<line4>        log.info(""Iteration: "" + (i + 1) + '/' + ITERATIONS);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> generateJobs(new Date()); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.info(""Exception caught at fault barrier while generating jobs."", e);"	task4	
"public class A { <line0> @Override <line1> public void exceptionCaught(IoSession session, Throwable cause) throws Exception { <line2> if (session.isClosing() && cause instanceof ClosedChannelException) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> } else { <line6> LoggingUtils.log(session, logger, ""Unexpected exception in broadcast service handler"", cause); <line7> } <line8> } <line9> } <line10> "	"<line4>        logger.debug(String.format(""BroadcastServiceHandler: caught exception %s, probably because session was closed""+ "" with pending writes"",cause));"	task4	
public class A { <line0> private void cleanupWorkspace(URI... workspaceURIs) { <line1> for (URI url : workspaceURIs) { <line2> try { <line3> workspace.delete(url); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.warn(""Could not delete {} from workspace: {}"", url, e.getMessage());"	task4	
public class A { <line0> @Override <line1> public void writeAndFlush(ByteBuf output) throws IOException { <line2> checkConnected(output); <line3> channel.writeAndFlush(output, channel.voidPromise()); <line4> } <line5> } <line6> 	"<line3>    LOG.trace(""Attempted write and flush of buffer: {}"", output);"	task4	
public class A { <line0> protected Function<InternalEvent, InternalEvent> doBefore( <line1> SourceInterceptor interceptor, Component component, Map<String, String> dslParameters) { <line2> return event -> { <line3> final InternalEvent eventWithResolvedParams = <line4> addResolvedParameters(event, component, dslParameters); <line5> DefaultInterceptionEvent interceptionEvent = <line6> new DefaultInterceptionEvent(eventWithResolvedParams); <line7> try { <line8> Thread currentThread = currentThread(); <line9> ClassLoader originalTCCL = currentThread.getContextClassLoader(); <line10> ClassLoader ctxClassLoader = interceptor.getClass().getClassLoader(); <line11> setContextClassLoader(currentThread, originalTCCL, ctxClassLoader); <line12> try { <line13> interceptor.beforeCallback( <line14> component.getLocation(), <line15> getResolvedParams(eventWithResolvedParams), <line16> interceptionEvent); <line17> } finally { <line18> setContextClassLoader(currentThread, ctxClassLoader, originalTCCL); <line19> } <line20> return interceptionEvent.resolve(); <line21> } catch (Exception e) { <line22> throw propagate( <line23> new MessagingException(interceptionEvent.resolve(), e.getCause(), component)); <line24> } <line25> }; <line26> } <line27> } <line28> 	"<line7>      LOGGER.debug(""Calling before() for '{}' in processor '{}'..."",interceptor,component.getLocation().getLocation());"	task4	
public class A { <line0> public void loadBundles(Map<String, Bundle> bundlesByLocation) { <line1> for (String loc : bundleLocations) { <line2> if (bundlesByLocation.containsKey(loc)) { <line3> if (bundlesByLocation.get(loc).getState() == Bundle.ACTIVE) { <line4> bundles.add(bundleToBundleInfo(bundlesByLocation.get(loc))); <line5> } else { <line6> } <line7> } <line8> } <line9> } <line10> } <line11> 	"<line6>          LOGGER.debug(""Unable to find bundle {} of app {} in system."", loc, name);"	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public ResidueSolvablePolynomial<C> parse(Reader r) { <line3> GenPolynomialTokenizer pt = new GenPolynomialTokenizer(this, r); <line4> ResidueSolvablePolynomial<C> p = null; <line5> try { <line6> GenSolvablePolynomial<SolvableResidue<C>> s = pt.nextSolvablePolynomial(); <line7> p = new ResidueSolvablePolynomial<C>(this, s); <line8> } catch (IOException e) { <line9> p = ZERO; <line10> } <line11> return p; <line12> } <line13> } <line14> "	"<line9>      logger.error(e.toString() + "" parse "" + this);"	task4	
public class A { <line0> public void removeTenant(String tenantId) { <line1> tenantIds.remove(tenantId); <line2> } <line3> } <line4> 	"<line2>    log.info(""[TRACKER] tenantId "" + tenantId + "" removed."");"	task4	
public class A { <line0> public void abort(AbortReason abortReason, Optional<Throwable> throwable) { <line1> if (!aborting.getAndSet(true)) { <line2> try { <line3> sendAbortNotification(abortReason, throwable); <line4> SingularityLifecycleManaged lifecycle = <line5> injector.getInstance(SingularityLifecycleManaged.class); <line6> SingularityPreJettyLifecycle preJettyLifecycle = <line7> injector.getInstance(SingularityPreJettyLifecycle.class); <line8> try { <line9> preJettyLifecycle.stop(); <line10> lifecycle.stop(); <line11> } catch (Throwable t) { <line12> } <line13> flushLogs(); <line14> } finally { <line15> exit(); <line16> } <line17> } <line18> } <line19> } <line20> 	"<line12>          LOG.error(""While shutting down"", t);"	task4	
"public class A { <line0> private void write(final Collection<Long> items) { <line1> if (items.isEmpty()) { <line2> state.update(c -> c.remove(key)); <line3> } else { <line4> state.update(b -> b.put(key, items.stream().map(String::valueOf))); <line5> } <line6> var value = state.getValue(key).orElse(""nothing""); <line7> } <line8> } <line9> "	"<line7>    LOGGER.trace(""'{}' wrote '{}'."", key, value);"	task4	
public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final PrivilegeTO ignore) { <line2> try { <line3> application.getPrivileges().remove(model.getObject()); <line4> ApplicationRestClient.update(application); <line5> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line6> customActionOnFinishCallback(target); <line7> } catch (SyncopeClientException e) { <line8> SyncopeConsoleSession.get().onException(e); <line9> } <line10> ((BaseWebPage) pageRef.getPage()).getNotificationPanel().refresh(target); <line11> } <line12> } <line13> 	"<line8>      LOG.error(""While deleting {}"", model.getObject().getKey(), e);"	task4	
public class A { <line0> @Override <line1> public void onNext(RaftClientReplyProto proto) { <line2> final long callId = proto.getRpcReply().getCallId(); <line3> try { <line4> final RaftClientReply reply = ClientProtoUtils.toRaftClientReply(proto); <line5> final NotLeaderException nle = reply.getNotLeaderException(); <line6> if (nle != null) { <line7> completeReplyExceptionally(nle, NotLeaderException.class.getName()); <line8> return; <line9> } <line10> final LeaderNotReadyException lnre = reply.getLeaderNotReadyException(); <line11> if (lnre != null) { <line12> completeReplyExceptionally(lnre, LeaderNotReadyException.class.getName()); <line13> return; <line14> } <line15> handleReplyFuture(callId, f -> f.complete(reply)); <line16> } catch (Exception e) { <line17> handleReplyFuture(callId, f -> f.completeExceptionally(e)); <line18> } <line19> } <line20> } <line21> 	"<line5>      LOG.trace(""{}: receive {}"", getName(), reply);"	task4	
"public class A { <line0> public MessageResponse handleMissingPayload( <line1> final URI affectedResource, final URI issuerConnector, final URI messageId) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> return ErrorResponse.withDefaultHeader( <line5> RejectionReason.BAD_PARAMETERS, <line6> ""Missing resource in payload."", <line7> connectorService.getConnectorId(), <line8> connectorService.getOutboundModelVersion()); <line9> } <line10> } <line11> "	"<line3>      log.debug(""Missing resource in payload. [resource=({}), issuer=({}), "" + ""messageId=({})]"",affectedResource,issuerConnector,messageId);"	task4	
"public class A { <line0> @Override <line1> public void activate(ComponentContext cc) { <line2> super.activate(cc); <line3> properties = cc.getProperties(); <line4> if (properties != null) { <line5> String commandString = (String) properties.get(COMMANDS_ALLOWED_PROPERTY); <line6> if (StringUtils.isNotBlank(commandString)) { <line7> for (String command : commandString.split(""\\s+"")) allowedCommands.add(command); <line8> } <line9> } <line10> this.bundleContext = cc.getBundleContext(); <line11> } <line12> } <line13> "	"<line7>        logger.info(""Execute Service permitted commands: {}"", commandString);"	task4	
"public class A { <line0> @Override <line1> public synchronized void onLeaderElection() { <line2> bulletinRepository.addBulletin( <line3> BulletinFactory.createBulletin( <line4> ""Cluster Coordinator"", <line5> Severity.INFO.name(), <line6> participantId + "" has been elected the Cluster Coordinator"")); <line7> FlowController.this.heartbeatMonitor.purgeHeartbeats(); <line8> } <line9> } <line10> "	"<line2>    LOG.info(""This node elected Active Cluster Coordinator"");"	task4	
public class A { <line0> public boolean login(String username) { <line1> try { <line2> LoginContext context = new SecondaryLoginContext(); <line3> ((WaspSession) Session.get()).login(context); <line4> continueToOriginalDestination(); <line5> setResponsePage(Application.get().getHomePage()); <line6> return true; <line7> } catch (LoginException e) { <line8> } <line9> return false; <line10> } <line11> } <line12> 	<line8>      log.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public void userQuitTournamentSubTables(UUID userId) { <line2> for (TableController controller : getControllers()) { <line3> if (controller.getTable() != null) { <line4> if (controller.getTable().isTournamentSubTable()) { <line5> controller.leaveTable(userId); <line6> } <line7> } else { <line8> } <line9> } <line10> } <line11> } <line12> 	"<line8>        logger.error(""TableManagerImpl.userQuitTournamentSubTables table == null - userId "" + userId);"	task4	
"public class A { <line0> @Test <line1> public void testI01RexCompat() { <line2> setup(VehicleType.ELECTRIC_REX.toString(), false); <line3> String content = FileReader.readFileInString(""src/test/resources/api/vehicle/vehicle-ccm.json""); <line4> VehicleAttributesContainer vac = <line5> Converter.getGson().fromJson(content, VehicleAttributesContainer.class); <line6> assertTrue( <line7> testVehicle( <line8> Converter.transformLegacyStatus(vac), <line9> STATUS_ELECTRIC + DOORS + RANGE_HYBRID + SERVICE_AVAILABLE + CHECK_AVAILABLE + POSITION, <line10> Optional.empty())); <line11> } <line12> } <line13> "	"<line2>    logger.info(""{}"", Thread.currentThread().getStackTrace()[1].getMethodName());"	task4	
public class A { <line0> public Map<String, Object> parseMap(String field) { <line1> Map<String, Object> metadata = null; <line2> try { <line3> JsonNode jsonNode = MAPPER.readValue(field, JsonNode.class); <line4> metadata = MAPPER.convertValue(jsonNode, Map.class); <line5> } catch (Exception ex) { <line6> } <line7> return metadata; <line8> } <line9> } <line10> 	"<line6>      LOGGER.warn(""failed in parseMap: "" + ex.getMessage());"	task4	
public class A { <line0> private void bindCustomPorts(@Nonnull BuiltInServer server) { <line1> if (myApplication.isUnitTestMode()) { <line2> return; <line3> } <line4> for (CustomPortServerManager customPortServerManager : <line5> CustomPortServerManager.EP_NAME.getExtensionList()) { <line6> try { <line7> new SubServer(customPortServerManager, server).bind(customPortServerManager.getPort()); <line8> } catch (Throwable e) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>        LOG.error(e);	task4	
public class A { <line0> public static boolean syncWorkflowState( <line1> ServiceContext<PoxPayloadIn, PoxPayloadOut> ctx, <line2> AuthorityResource authorityResource, <line3> String sasWorkflowState, <line4> String localParentCsid, <line5> String localItemCsid, <line6> DocumentModel localItemDocModel) <line7> throws Exception { <line8> String localItemWorkflowState = localItemDocModel.getCurrentLifeCycleState(); <line9> List<String> transitionList = <line10> AuthorityServiceUtils.getTransitionList(sasWorkflowState, localItemWorkflowState); <line11> if (!transitionList.isEmpty()) { <line12> try { <line13> for (String transition : transitionList) { <line14> authorityResource.updateItemWorkflowWithTransition( <line15> ctx, <line16> localParentCsid, <line17> localItemCsid, <line18> transition, <line19> AuthorityServiceUtils.DONT_UPDATE_REV, <line20> AuthorityServiceUtils.DONT_ROLLBACK_ON_EXCEPTION); <line21> } <line22> } catch (DocumentReferenceException de) { <line23> localItemDocModel.refresh(); <line24> AuthorityServiceUtils.setAuthorityItemDeprecated( <line25> ctx, authorityResource, localParentCsid, localItemCsid, localItemDocModel); <line26> } <line27> } <line28> return true; <line29> } <line30> } <line31> 	"<line23>        logger.info(String.format(""Failed to soft-delete %s (transition from %s to %s): item is referenced, and will""+ "" be deprecated instead"",localItemCsid, localItemWorkflowState, sasWorkflowState));"	task4	
"public class A { <line0> @Override <line1> public BpmWidgetInfo getBpmWidgetInfo(int id) throws ApsSystemException { <line2> BpmWidgetInfo bpmWidgetInfo = null; <line3> try { <line4> bpmWidgetInfo = this.getBpmWidgetInfoDAO().loadBpmWidgetInfo(id); <line5> } catch (Throwable t) { <line6> throw new ApsSystemException(""Error loading bpmWidgetInfo with id: "" + id, t); <line7> } <line8> return bpmWidgetInfo; <line9> } <line10> } <line11> "	"<line6>      logger.error(""Error loading bpmWidgetInfo with id '{}'"", id, t);"	task4	
"public class A { <line0> public List<CertificateDTO> getEntitlementCertificates( <line1> @Verify(Consumer.class) String consumerUuid, String serials) { <line2> Principal principal = ResteasyContext.getContextData(Principal.class); <line3> if (principal instanceof ConsumerPrincipal) { <line4> ConsumerPrincipal p = (ConsumerPrincipal) principal; <line5> consumerCurator.updateLastCheckin(p.getConsumer()); <line6> } <line7> Consumer consumer = consumerCurator.verifyAndLookupConsumer(consumerUuid); <line8> ConsumerType ctype = this.consumerTypeCurator.getConsumerType(consumer); <line9> revokeOnGuestMigration(consumer); <line10> poolManager.regenerateDirtyEntitlements(consumer); <line11> Set<Long> serialSet = this.extractSerials(serials); <line12> List<CertificateDTO> returnCerts = new LinkedList<>(); <line13> List<EntitlementCertificate> allCerts = entCertService.listForConsumer(consumer); <line14> for (EntitlementCertificate cert : allCerts) { <line15> if (serialSet.isEmpty() || serialSet.contains(cert.getSerial().getId())) { <line16> returnCerts.add(translator.translate(cert, CertificateDTO.class)); <line17> } <line18> } <line19> try { <line20> Certificate cert = this.contentAccessManager.getCertificate(consumer); <line21> if (cert != null) { <line22> returnCerts.add(translator.translate(cert, CertificateDTO.class)); <line23> } <line24> } catch (IOException ioe) { <line25> throw new BadRequestException(i18n.tr(""Cannot retrieve content access certificate""), ioe); <line26> } catch (GeneralSecurityException gse) { <line27> throw new BadRequestException(i18n.tr(""Cannot retrieve content access certificate""), gse); <line28> } <line29> return returnCerts; <line30> } <line31> } <line32> "	"<line2>    log.debug(""Getting client certificates for consumer: {}"", consumerUuid);"	task4	
public class A { <line0> public static void main(String[] args) throws IOException { <line1> Collection c = new SimpleXMLCollection(); <line2> while (c.nextDocument()) { <line3> Document d = c.getDocument(); <line4> if (logger.isInfoEnabled()) { <line5> } <line6> if (logger.isInfoEnabled()) { <line7> while (!d.endOfDocument()) { <line8> System.out.println(d.getNextTerm()); <line9> } <line10> } <line11> } <line12> c.close(); <line13> } <line14> } <line15> 	"<line5>        logger.info(""DOCID: "" + d.getProperty(""docno""));"	task4	
"public class A { <line0> @Override <line1> public void generateJson(String prefix, PrintWriter pw, VWorkspace vWorkspace) { <line2> JSONObject outputObject = new JSONObject(); <line3> try { <line4> outputObject.put(JsonKeys.updateType.name(), ""PublishPresetUpdate""); <line5> outputObject.put( <line6> JsonKeys.fileUrl.name(), <line7> contextParameters.getParameterValue(ContextParameter.JSON_PUBLISH_RELATIVE_DIR) <line8> + jsonFileName); <line9> outputObject.put(JsonKeys.worksheetId.name(), wsht.getId()); <line10> pw.println(outputObject.toString(4)); <line11> } catch (JSONException e) { <line12> } <line13> } <line14> } <line15> "	"<line12>      logger.error(""Error occured while generating JSON!"");"	task4	
"public class A { <line0> protected void stopIptablesImpl(final SshMachineLocation machine) { <line1> List<String> cmds = ImmutableList.<String>of(); <line2> Task<Integer> checkFirewall = checkLocationFirewall(machine); <line3> if (checkFirewall.getUnchecked() == 0) { <line4> cmds = <line5> ImmutableList.of( <line6> IptablesCommands.firewalldServiceStop(), IptablesCommands.firewalldServiceStatus()); <line7> } else { <line8> cmds = <line9> ImmutableList.of( <line10> IptablesCommands.iptablesServiceStop(), IptablesCommands.iptablesServiceStatus()); <line11> } <line12> subTaskHelperAllowingNonZeroExitCode( <line13> ""execute stop iptables"", machine, cmds.toArray(new String[cmds.size()])); <line14> } <line15> } <line16> "	"<line1>    log.info(""Stopping iptables for {} at {}"", entity(), machine);"	task4	
public class A { <line0> @Override <line1> public XAResource[] getXAResources(ActivationSpec[] specs) { <line2> return null; <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Returning XAResource [null]..."");"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public static <T> T invokeWithDefault( <line2> @Nullable Method method, Object obj, T defaultValue, @Nullable Object... args) { <line3> if (method == null) { <line4> return defaultValue; <line5> } <line6> try { <line7> Object value = method.invoke(obj, args); <line8> if (value == null) { <line9> return defaultValue; <line10> } <line11> return (T) value; <line12> } catch (Throwable t) { <line13> return defaultValue; <line14> } <line15> } <line16> } <line17> "	"<line13>      logger.warn(""error calling {}.{}()"", method.getDeclaringClass().getName(), method.getName(), t);"	task4	
public class A { <line0> private Iterator<IEntryPacket> getNextTieredBatch() { <line1> UidQueryPacket template = <line2> ((TieredSpaceIteratorResult) _iteratorResult) <line3> .buildQueryPacket(_spaceProxy, _batchSize, _queryResultType); <line4> if (template == null) return null; <line5> template.setProjectionTemplate(_queryPacket.getProjectionTemplate()); <line6> try { <line7> Object[] entries = <line8> _spaceProxy.readMultiple( <line9> template, _txn, template.getMultipleUIDs().length, _readModifiers); <line10> if (logger.isDebugEnabled()) { <line11> } <line12> return ArrayIterator.wrap(entries); <line13> } catch (RemoteException | UnusableEntryException | TransactionException e) { <line14> processNextBatchFailure(e); <line15> } <line16> return null; <line17> } <line18> } <line19> 	"<line11>        logger.debug(""getNextBatch returns with a buffer of "" + entries.length + "" entries."");"	task4	
"public class A { <line0> public boolean activityTabIsSelected() { <line1> return getDriver().findElements(By.cssSelector(""#activity.is-active"")).size() > 0; <line2> } <line3> } <line4> "	"<line1>    log.info(""Query is Activity tab displayed"");"	task4	
public class A { <line0> @Override <line1> public boolean isValidName(String name) { <line2> if (Validator.isNull(name)) { <line3> return false; <line4> } <line5> String[] charactersBlacklist = {}; <line6> try { <line7> JournalServiceConfiguration journalServiceConfiguration = <line8> _configurationProvider.getCompanyConfiguration( <line9> JournalServiceConfiguration.class, CompanyThreadLocal.getCompanyId()); <line10> charactersBlacklist = journalServiceConfiguration.charactersblacklist(); <line11> } catch (Exception exception) { <line12> } <line13> for (String blacklistChar : charactersBlacklist) { <line14> blacklistChar = StringEscapeUtils.unescapeJava(blacklistChar); <line15> if (name.contains(blacklistChar)) { <line16> return false; <line17> } <line18> } <line19> return true; <line20> } <line21> } <line22> 	<line12>      log.error(exception, exception);	task4	
"public class A { <line0> public void pauseQueue(String queueName) throws TimeoutException { <line1> doOperation(""queue."" + queueName, ""pause""); <line2> } <line3> } <line4> "	"<line1>    log.info(""Pausing queue {}"", queueName);"	task4	
public class A { <line0> @Override <line1> public void output(LocalDocument document) { <line2> } <line3> } <line4> 	"<line2>    logger.info(""Accepting document: "" + document.getID());"	task4	
"public class A { <line0> public static void changeCharsetToUtf(JdbcConnection jdbcCon) <line1> throws DatabaseException, SQLException { <line2> Statement stmt = jdbcCon.createStatement(); <line3> String dbName = jdbcCon.getCatalog(); <line4> String sql = <line5> String.format( <line6> ""ALTER DATABASE `%s` CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;"", dbName); <line7> int result = stmt.executeUpdate(sql); <line8> } <line9> } <line10> "	"<line8>    LOGGER.info(""ALTER charset execute result: {}"", result);"	task4	
public class A { <line0> public void sendMessage(Message message, User user) throws MessageException { <line1> String address = user.getUserProperty(OpenmrsConstants.USER_PROPERTY_NOTIFICATION_ADDRESS); <line2> if (address != null) { <line3> message.addRecipient(address); <line4> } <line5> Context.getMessageService().sendMessage(message); <line6> } <line7> } <line8> 	"<line1>    log.debug(""Sending message to user "" + user);"	task4	
public class A { <line0> private void setSystemProxy() { <line1> try { <line2> URI serverUri = new URI(getPreferences().getString(PreferenceConstants.VNSERVER_URI)); <line3> IProxyService proxyService = getProxyService(); <line4> IProxyData[] proxyDataForHost = proxyService.select(serverUri); <line5> if (proxyDataForHost == null || proxyDataForHost.length == 0) { <line6> clearSystemProxy(); <line7> } else { <line8> setSystemProxy(proxyDataForHost); <line9> } <line10> } catch (Exception t) { <line11> } <line12> } <line13> } <line14> 	"<line11>      LOG.error(""Error while setting proxy."", t);"	task4	
public class A { <line0> public static int getShippingCommerceAddressesCount( <line1> long companyId, String className, long classPK, String keywords) throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceAddressServiceUtil.getShippingCommerceAddressesCount( <line5> companyId, className, classPK, keywords); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
public class A { <line0> protected ValidationResult validatePropertyNames(final SchemaElementDefinition elementDef) { <line1> final ValidationResult result = new ValidationResult(); <line2> for (final String property : elementDef.getProperties()) { <line3> if (ReservedPropertyNames.contains(property)) { <line4> } <line5> } <line6> return result; <line7> } <line8> } <line9> 	"<line4>        LOGGER.warn(""Element definition contains a reserved property name {}. ""+ ""This may prevent some analytics from being used on this graph."",property);"	task4	
"public class A { <line0> @Override <line1> public void create(String testName) throws Exception { <line2> setupCreate(); <line3> AccountValue av = accValues.get(""acc-role-user1""); <line4> AccountRole accRole = createAccountRoleInstance(av, roleValues.values(), true, true); <line5> AccountRoleClient client = new AccountRoleClient(); <line6> Response res = client.create(av.getAccountId(), accRole); <line7> try { <line8> assertStatusCode(res, testName); <line9> knownResourceId = av.getAccountId(); <line10> if (logger.isDebugEnabled()) { <line11> } <line12> } finally { <line13> if (res != null) { <line14> res.close(); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line11>        logger.debug(testName+ "": Created an AccountRole instance for account with knownResourceId=""+ knownResourceId);"	task4	
"public class A { <line0> @RequestMapping( <line1> value = {ControllerConstants.Paths.ADMIN_INDEX, ControllerConstants.Paths.ADMIN_ROOT}, <line2> method = RequestMethod.GET) <line3> public ModelAndView get() { <line4> boolean warn = false; <line5> Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); <line6> if (principal instanceof AdministratorUserPrinciple) { <line7> AdministratorUserPrinciple administratorUserPrinciple = <line8> (AdministratorUserPrinciple) principal; <line9> if (administratorUserPrinciple.isDefaultAdmin()) { <line10> warn = true; <line11> } <line12> } <line13> Map<String, String> metadata = new HashMap<>(MetaDataHandler.Metadata.values().length); <line14> try { <line15> for (MetaDataHandler.Metadata m : MetaDataHandler.Metadata.values()) { <line16> metadata.put(m.name(), getMetaDataHandler().get(m)); <line17> } <line18> } catch (ConfigurationError ex) { <line19> } <line20> Map<String, Object> model = new HashMap<>(2); <line21> model.put(""metadata"", metadata); <line22> model.put(""warning"", warn); <line23> return new ModelAndView(ControllerConstants.Views.ADMIN_INDEX, model); <line24> } <line25> } <line26> "	"<line19>      LOG.error(""Error reading metadata properties"", ex);"	task4	
public class A { <line0> private void disposeEncoder(IoSession session) { <line1> ProtocolEncoder encoder = (ProtocolEncoder) session.removeAttribute(ENCODER); <line2> if (encoder == null) { <line3> return; <line4> } <line5> try { <line6> encoder.dispose(session); <line7> } catch (Throwable t) { <line8> } <line9> } <line10> } <line11> 	"<line8>      LOGGER.warn(""Failed to dispose: "" + encoder.getClass().getName() + "" ("" + encoder + ')');"	task4	
"public class A { <line0> public List<ActivityFrequencyScheduleBean> getQuestionnaireFrequencyDetailsForOneTime( <line1> QuestionnairesDto questionaire, List<ActivityFrequencyScheduleBean> runDetailsBean) <line2> throws DAOException { <line3> LOGGER.entry(""begin getQuestionnaireFrequencyDetailsForOneTime()""); <line4> try { <line5> if (questionaire != null) { <line6> ActivityFrequencyScheduleBean oneTimeBean = new ActivityFrequencyScheduleBean(); <line7> oneTimeBean.setStartTime( <line8> StudyMetaDataUtil.getFormattedDateTimeZone( <line9> questionaire.getStudyLifetimeStart(), <line10> StudyMetaDataConstants.SDF_DATE_PATTERN, <line11> StudyMetaDataConstants.SDF_DATE_TIME_TIMEZONE_MILLISECONDS_PATTERN)); <line12> oneTimeBean.setEndTime( <line13> StudyMetaDataUtil.getFormattedDateTimeZone( <line14> questionaire.getStudyLifetimeEnd(), <line15> StudyMetaDataConstants.SDF_DATE_PATTERN, <line16> StudyMetaDataConstants.SDF_DATE_TIME_TIMEZONE_MILLISECONDS_PATTERN)); <line17> runDetailsBean.add(oneTimeBean); <line18> } <line19> } catch (Exception e) { <line20> } <line21> LOGGER.exit(""getQuestionnaireFrequencyDetailsForOneTime() :: Ends""); <line22> return runDetailsBean; <line23> } <line24> } <line25> "	"<line20>      LOGGER.error(""ActivityMetaDataDao - getQuestionnaireFrequencyDetailsForOneTime() :: ERROR"", e);"	task4	
"public class A { <line0> @Test <line1> public void testTraceWithNArguments() { <line2> buf.setLength(0); <line3> final VitamUILogger logger = VitamUILoggerFactory.getInstance(VitamUITraceLoggerTest.class); <line4> final String message = ""message""; <line5> final String format = message + "" {} {} {}""; <line6> final Integer object1 = 1; <line7> final Integer object2 = 2; <line8> final Integer object3 = 3; <line9> assertTrue(""Log message should be written."", buf.length() > 0); <line10> assertTrue(""Log message should be written."", buf.lastIndexOf(message) > 0); <line11> assertTrue( <line12> ""Log message should be written."", <line13> buf.lastIndexOf( <line14> message <line15> + "" "" <line16> + object1.toString() <line17> + "" "" <line18> + object2.toString() <line19> + "" "" <line20> + object3.toString()) <line21> > 0); <line22> } <line23> } <line24> "	<line9>    logger.trace(format, object1, object2, object3);	task4	
public class A { <line0> @Override <line1> public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { <line2> } <line3> } <line4> 	"<line2>    LOG.debug(""Channel connected {}"", e);"	task4	
public class A { <line0> @Override <line1> public void execute(Template.Fragment frag, Writer out) throws IOException { <line2> String curVal = frag.execute(); <line3> if (curVal != null && !curVal.equals(lastVal)) { <line4> out.write(curVal); <line5> lastVal = curVal; <line6> } <line7> } <line8> } <line9> 	"<line3>    LOGGER.debug(""[lastVal={}, curVal={}]"", lastVal, curVal);"	task4	
public class A { <line0> public void cut() { <line1> try { <line2> ((XulWindow) this.getXulDomContainer().getDocumentRoot().getRootElement()).cut(); <line3> paste.setDisabled(false); <line4> } catch (XulException e) { <line5> } <line6> } <line7> } <line8> 	<line5>      logger.error(e.getMessage(), e);	task4	
public class A { <line0> private static synchronized void overrideInstance(ApplicationWarnings springInstance) { <line1> if (instance != null) { <line2> List<String> warnings = instance.getWarnings(); <line3> springInstance.addWarnings(warnings); <line4> if (!warnings.isEmpty()) { <line5> } <line6> } <line7> instance = springInstance; <line8> } <line9> } <line10> 	"<line5>        LOG.debug(""appending ["" + warnings.size() + ""] warning(s)"");"	task4	
"public class A { <line0> @Override <line1> public List<String> searchGroups(FieldSearchFilter[] filters) { <line2> List<String> groupsNames = null; <line3> try { <line4> groupsNames = super.searchId(filters); <line5> } catch (Throwable t) { <line6> throw new RuntimeException(""error in search groups"", t); <line7> } <line8> return groupsNames; <line9> } <line10> } <line11> "	"<line6>      logger.error(""error in search groups"", t);"	task4	
"public class A { <line0> void authenticationError(ChannelHandlerContext ctx, int errorCode) { <line1> ctx.fireExceptionCaught(new AuthenticationException(""Auth failed with error "" + errorCode)); <line2> } <line3> } <line4> "	"<line1>    LOG.error(""Error processing auth message, erroring connection {}"", errorCode);"	task4	
"public class A { <line0> @VisibleForTesting <line1> protected void timeoutPendingSlotRequest(SlotRequestId slotRequestId) { <line2> final PendingRequest pendingRequest = removePendingRequest(slotRequestId); <line3> if (pendingRequest != null) { <line4> pendingRequest <line5> .getAllocatedSlotFuture() <line6> .completeExceptionally( <line7> new TimeoutException(""Pending slot request timed out in SlotPool."")); <line8> } <line9> } <line10> } <line11> "	"<line2>    log.info(""Pending slot request [{}] timed out."", slotRequestId);"	task4	
public class A { <line0> public static void process(ServiceMeshMetric.Builder data) { <line1> try (HistogramMetrics.Timer ignored = MESH_ANALYSIS_METRICS.createTimer()) { <line2> if (data.getSourceServiceName() != null) { <line3> data.setSourceServiceName( <line4> NAME_LENGTH_CONTROL.formatServiceName(data.getSourceServiceName())); <line5> } <line6> if (data.getSourceServiceInstance() != null) { <line7> data.setSourceServiceInstance( <line8> NAME_LENGTH_CONTROL.formatInstanceName(data.getSourceServiceInstance())); <line9> } <line10> if (data.getDestServiceName() != null) { <line11> data.setDestServiceName(NAME_LENGTH_CONTROL.formatServiceName(data.getDestServiceName())); <line12> } <line13> if (data.getDestServiceInstance() != null) { <line14> data.setDestServiceInstance( <line15> NAME_LENGTH_CONTROL.formatInstanceName(data.getDestServiceInstance())); <line16> } <line17> if (data.getEndpoint() != null) { <line18> data.setEndpoint( <line19> NAME_LENGTH_CONTROL.formatEndpointName(data.getDestServiceName(), data.getEndpoint())); <line20> } <line21> if (data.getInternalErrorCode() == null) { <line22> data.setInternalErrorCode(Const.EMPTY_STRING); <line23> } <line24> doDispatch(data); <line25> } catch (Exception e) { <line26> MESH_ERROR_METRICS.inc(); <line27> } <line28> } <line29> } <line30> 	<line27>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> private void executeProcesses() { <line1> ThreadContext.put(""module"", ""orchestra""); <line2> try { <line3> Assertion.check().isNotNull(nodId, ""Node not already registered""); <line4> executeToDo(); <line5> nodeManager.updateHeartbeat(nodId); <line6> handleDeadNodeProcesses(); <line7> } catch (final Throwable t) { <line8> if (t instanceof InterruptedException) { <line9> throw t; <line10> } <line11> } finally { <line12> ThreadContext.remove(""module""); <line13> } <line14> } <line15> } <line16> "	"<line8>      LOGGER.error(""Exception launching activities to executes"", t);"	task4	
"public class A { <line0> public static String getCalendarBookingsRSS( <line1> HttpPrincipal httpPrincipal, <line2> long calendarId, <line3> long startTime, <line4> long endTime, <line5> int max, <line6> String type, <line7> double version, <line8> String displayStyle, <line9> com.liferay.portal.kernel.theme.ThemeDisplay themeDisplay) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> CalendarBookingServiceUtil.class, <line15> ""getCalendarBookingsRSS"", <line16> _getCalendarBookingsRSSParameterTypes14); <line17> MethodHandler methodHandler = <line18> new MethodHandler( <line19> methodKey, <line20> calendarId, <line21> startTime, <line22> endTime, <line23> max, <line24> type, <line25> version, <line26> displayStyle, <line27> themeDisplay); <line28> Object returnObj = null; <line29> try { <line30> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line31> } catch (Exception exception) { <line32> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line33> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line34> } <line35> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line36> } <line37> return (String) returnObj; <line38> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line39> throw systemException; <line40> } <line41> } <line42> } <line43> "	<line39>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> protected IgniteInternalFuture createAndRunConcurrentAction( <line2> final AtomicBoolean finished, final long endTime) { <line3> return GridTestUtils.runAsync( <line4> new Callable() { <line5> @Override <line6> public Object call() throws Exception { <line7> Thread.currentThread().setName(""restart-thread""); <line8> U.sleep(15_000); <line9> ThreadLocalRandom tlr = ThreadLocalRandom.current(); <line10> int idx = tlr.nextInt(1, GRIDS_COUNT); <line11> stopGrid(idx); <line12> IgniteEx ig0 = grid(0); <line13> ig0.cluster().setBaselineTopology(baselineNodes(ig0.cluster().forServers().nodes())); <line14> U.sleep(3_000); <line15> return null; <line16> } <line17> }); <line18> } <line19> } <line20> "	"<line11>            log.info(""Stopping node "" + idx);"	task4	
public class A { <line0> private void sendMessage(final DistributionAutomationRequestMessage requestMessage) { <line1> this.jmsTemplate.send( <line2> new MessageCreator() { <line3> @Override <line4> public Message createMessage(final Session session) throws JMSException { <line5> final ObjectMessage objectMessage = <line6> session.createObjectMessage(requestMessage.getRequest()); <line7> objectMessage.setJMSCorrelationID(requestMessage.getCorrelationUid()); <line8> objectMessage.setJMSType(requestMessage.getMessageType().name()); <line9> objectMessage.setStringProperty( <line10> Constants.ORGANISATION_IDENTIFICATION, <line11> requestMessage.getOrganisationIdentification()); <line12> objectMessage.setStringProperty( <line13> Constants.DEVICE_IDENTIFICATION, requestMessage.getDeviceIdentification()); <line14> return objectMessage; <line15> } <line16> }); <line17> } <line18> } <line19> 	"<line1>    LOGGER.info(""Sending message to the da requests queue"");"	task4	
public class A { <line0> @Override <line1> public void getOAuthAccessTokenAsync(final String oauthVerifier) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(OAUTH_ACCESS_TOKEN, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> AccessToken token = twitter.getOAuthAccessToken(oauthVerifier); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotOAuthAccessToken(token); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at getOAuthRequestTokenAsync"", e);"	task4	
"public class A { <line0> @Override <line1> public boolean updateIndexMapping(String indexName, final Map<String, Object> mapping) <line2> throws IOException { <line3> indexName = formatIndexName(indexName); <line4> PutMappingRequest putMappingRequest = new PutMappingRequest(indexName); <line5> Gson gson = new Gson(); <line6> putMappingRequest.source(gson.toJson(mapping), XContentType.JSON); <line7> putMappingRequest.type(""_doc""); <line8> AcknowledgedResponse response = <line9> client.indices().putMapping(putMappingRequest, RequestOptions.DEFAULT); <line10> return response.isAcknowledged(); <line11> } <line12> } <line13> "	"<line10>    log.debug(""put {} index mapping finished, isAcknowledged: {}"", indexName, response.isAcknowledged());"	task4	
public class A { <line0> @Override <line1> public void close() throws IOException { <line2> wasClosed = true; <line3> while (thread.isAlive()) { <line4> thread.interrupt(); <line5> try { <line6> thread.join(); <line7> } catch (InterruptedException e) { <line8> if (!thread.isAlive()) { <line9> Thread.currentThread().interrupt(); <line10> } <line11> } <line12> } <line13> if (thrown != null) { <line14> throw new IOException(thrown); <line15> } <line16> } <line17> } <line18> 	"<line11>        LOG.debug(taskName + "" interrupted while waiting for the writer thread to die"", e);"	task4	
public class A { <line0> private boolean isNamingReadiness(HttpServletRequest request) { <line1> try { <line2> apiCommands.metrics(request); <line3> return true; <line4> } catch (Exception e) { <line5> } <line6> return false; <line7> } <line8> } <line9> 	"<line5>      LOGGER.error(""Naming health check fail."", e);"	task4	
"public class A { <line0> private static Index indexJar(JarFile file) throws IOException { <line1> Indexer indexer = new Indexer(); <line2> Enumeration<JarEntry> e = file.entries(); <line3> boolean multiRelease = JarFiles.isMultiRelease(file); <line4> while (e.hasMoreElements()) { <line5> JarEntry entry = e.nextElement(); <line6> if (entry.getName().endsWith("".class"")) { <line7> if (multiRelease && entry.getName().startsWith(META_INF_VERSIONS)) { <line8> String part = entry.getName().substring(META_INF_VERSIONS.length()); <line9> int slash = part.indexOf(""/""); <line10> if (slash != -1) { <line11> try { <line12> int ver = Integer.parseInt(part.substring(0, slash)); <line13> if (ver <= JAVA_VERSION) { <line14> try (InputStream inputStream = file.getInputStream(entry)) { <line15> indexer.index(inputStream); <line16> } <line17> } <line18> } catch (NumberFormatException ex) { <line19> } <line20> } <line21> } else { <line22> try (InputStream inputStream = file.getInputStream(entry)) { <line23> indexer.index(inputStream); <line24> } <line25> } <line26> } <line27> } <line28> return indexer.complete(); <line29> } <line30> } <line31> "	"<line19>              log.debug(""Failed to parse META-INF/versions entry"", ex);"	task4	
public class A { <line0> @Override <line1> public boolean delete() { <line2> try { <line3> return this._storageAdaptor.deleteStoragePool(this); <line4> } catch (Exception e) { <line5> } <line6> return false; <line7> } <line8> } <line9> 	"<line5>      logger.debug(""Failed to delete storage pool"", e);"	task4	
public class A { <line0> private void updateContextWithTime(WorkflowExecutionContext context) { <line1> try { <line2> InstancesResult result = <line3> WorkflowEngineFactory.getWorkflowEngine() <line4> .getJobDetails(context.getClusterName(), context.getWorkflowId()); <line5> Date startTime = result.getInstances()[0].startTime; <line6> Date endTime = result.getInstances()[0].endTime; <line7> Date now = new Date(); <line8> if (startTime == null) { <line9> startTime = now; <line10> } <line11> if (endTime == null) { <line12> endTime = now; <line13> } <line14> context.setValue(WorkflowExecutionArgs.WF_START_TIME, Long.toString(startTime.getTime())); <line15> context.setValue(WorkflowExecutionArgs.WF_END_TIME, Long.toString(endTime.getTime())); <line16> } catch (FalconException e) { <line17> } <line18> } <line19> } <line20> 	"<line17>      LOG.error(""Unable to retrieve job details for ""+ context.getWorkflowId()+ "" on cluster ""+ context.getClusterName(),e);"	task4	
public class A { <line0> public void onError(Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TBase msg; <line3> unloadApplication_result result = new unloadApplication_result(); <line4> { <line5> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line6> msg = <line7> (org.apache.thrift.TBase) <line8> new org.apache.thrift.TApplicationException( <line9> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line10> } <line11> try { <line12> fcall.sendResponse(fb, msg, msgType, seqid); <line13> return; <line14> } catch (Exception ex) { <line15> } <line16> fb.close(); <line17> } <line18> } <line19> 	"<line15>      LOGGER.error(""Exception writing to internal frame buffer"", ex);"	task4	
public class A { <line0> public static int calculateSizeOfValue(Object value) { <line1> if (value instanceof String) { <line2> return ((String) value).length(); <line3> } else if (value instanceof Boolean) { <line4> return 4; <line5> } else if (value instanceof Number || value instanceof Date) { <line6> return 8; <line7> } else if (value instanceof Collection) { <line8> return calculateSizeOfCollection((Collection<?>) value); <line9> } else if (value instanceof Map) { <line10> return calculateSizeOfMap((Map<?, ?>) value); <line11> } else { <line12> return 100; <line13> } <line14> } <line15> } <line16> 	"<line12>      LOGGER.warn(""unhandled object to calculate size for: ""+ value.getClass().getName()+ "", defaulting to 100"");"	task4	
"public class A { <line0> @Override <line1> protected void doProcessAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws Exception { <line3> try { <line4> long groupId = ParamUtil.getLong(actionRequest, ""groupId""); <line5> long classNameId = ParamUtil.getLong(actionRequest, ""classNameId""); <line6> String className = _portal.getClassName(classNameId); <line7> long classPK = ParamUtil.getLong(actionRequest, ""classPK""); <line8> InfoItemReference infoItemReference = new InfoItemReference(className, classPK); <line9> InfoItemObjectProvider<Object> infoItemObjectProvider = <line10> _infoItemServiceTracker.getFirstInfoItemService( <line11> InfoItemObjectProvider.class, infoItemReference.getClassName()); <line12> InfoItemFieldValues infoItemFieldValues = <line13> InfoItemFieldValues.builder() <line14> .infoItemReference(infoItemReference) <line15> .infoFieldValues( <line16> _getInfoFieldValues( <line17> actionRequest, className, infoItemObjectProvider.getInfoItem(classPK))) <line18> .build(); <line19> ServiceContext serviceContext = ServiceContextFactory.getInstance(actionRequest); <line20> _translationEntryService.addOrUpdateTranslationEntry( <line21> groupId, <line22> _getTargetLanguageId(actionRequest), <line23> infoItemReference, <line24> infoItemFieldValues, <line25> serviceContext); <line26> } catch (Exception exception) { <line27> SessionErrors.add(actionRequest, exception.getClass(), exception); <line28> actionResponse.setRenderParameter(""mvcRenderCommandName"", ""/translation/translate""); <line29> } <line30> } <line31> } <line32> "	<line27>      log.error(exception, exception);	task4	
public class A { <line0> @Activate <line1> public void activate() { <line2> ScriptStandaloneSetup.doSetup(scriptServiceUtil, this); <line3> } <line4> } <line5> 	"<line3>    logger.debug(""Registered 'script' configuration parser"");"	task4	
"public class A { <line0> @Override <line1> public Exchange receiveNoWait(Endpoint endpoint) { <line2> if (camelContext.isStopped()) { <line3> throw new RejectedExecutionException(""CamelContext is stopped""); <line4> } <line5> PollingConsumer consumer = null; <line6> try { <line7> consumer = acquirePollingConsumer(endpoint); <line8> return consumer.receiveNoWait(); <line9> } finally { <line10> if (consumer != null) { <line11> releasePollingConsumer(endpoint, consumer); <line12> } <line13> } <line14> } <line15> } <line16> "	"<line5>    LOG.debug(""<<<< {}"", endpoint);"	task4	
public class A { <line0> @Override <line1> public IOpenField getField(String fname) { <line2> try { <line3> return getField(fname, true); <line4> } catch (AmbiguousFieldException e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	"<line5>      LOG.debug(""Ignored error: "", e);"	task4	
public class A { <line0> private void executeBatch() throws SQLException, IOException, InterruptedException { <line1> if (records.isEmpty()) { <line2> return; <line3> } <line4> if (connection == null) { <line5> connection = dataSource.getConnection(); <line6> connection.setAutoCommit(false); <line7> preparedStatement = connection.prepareStatement(spec.getStatement().get()); <line8> } <line9> Sleeper sleeper = Sleeper.DEFAULT; <line10> BackOff backoff = retryBackOff.backoff(); <line11> while (true) { <line12> try (PreparedStatement preparedStatement = <line13> connection.prepareStatement(spec.getStatement().get())) { <line14> try { <line15> for (T record : records) { <line16> processRecord(record, preparedStatement); <line17> } <line18> preparedStatement.executeBatch(); <line19> connection.commit(); <line20> break; <line21> } catch (SQLException exception) { <line22> if (!spec.getRetryStrategy().apply(exception)) { <line23> throw exception; <line24> } <line25> preparedStatement.clearBatch(); <line26> connection.rollback(); <line27> if (!BackOffUtils.next(sleeper, backoff)) { <line28> throw exception; <line29> } <line30> } <line31> } <line32> } <line33> records.clear(); <line34> } <line35> } <line36> 	"<line25>          LOG.warn(""Deadlock detected, retrying"", exception);"	task4	
public class A { <line0> private void initWebKeys(Conf conf) { <line1> final String jwksUri = conf.getDynamic().getJwksUri(); <line2> if (jwksUri.startsWith(conf.getDynamic().getIssuer())) { <line3> if (conf.getWebKeys() != null) { <line4> jwks = conf.getWebKeys(); <line5> } else { <line6> generateWebKeys(); <line7> } <line8> return; <line9> } <line10> final JSONObject keys = JwtUtil.getJSONWebKeys(jwksUri); <line11> final JSONWebKeySet keySet = JSONWebKeySet.fromJSONObject(keys); <line12> jwks = new WebKeysConfiguration(); <line13> jwks.setKeys(keySet.getKeys()); <line14> } <line15> } <line16> 	"<line11>    log.trace(""Downloaded external keys from "" + jwksUri + "", keys: "" + keys);"	task4	
public class A { <line0> public boolean containsUndeclaredUnits() { <line1> if (isSetRefId()) { <line2> CallableSBase reference = getReferenceInstance(); <line3> if (reference != null && reference instanceof QuantityWithUnit) { <line4> return !((QuantityWithUnit) reference).isSetUnits(); <line5> } else { <line6> return true; <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> 	"<line6>        logger.warn(""??"");"	task4	
public class A { <line0> @Override <line1> public void unscheduleRunOnceJob(String subject, String externalId) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> JobId jobId = new RunOnceJobId(subject, externalId); <line5> logObjectIfNotNull(jobId); <line6> unscheduleJob(jobId.value()); <line7> } <line8> } <line9> 	"<line3>      LOGGER.debug(format(""unscheduling run once job: "" + LOG_SUBJECT_EXTERNAL_ID, subject, externalId));"	task4	
public class A { <line0> void removeLocalArtifacts(Set<Artifact> artifacts) { <line1> if (localRepo != null) { <line2> Iterator<Artifact> it = artifacts.iterator(); <line3> while (it.hasNext()) { <line4> Artifact artifact = it.next(); <line5> if (getFileInLocalRepo(artifact.getFile()) != null) { <line6> it.remove(); <line7> } <line8> } <line9> } <line10> } <line11> } <line12> 	"<line6>          LOG.trace(""Removing artifact {}"", artifact);"	task4	
"public class A { <line0> @Override <line1> public void open() { <line2> String serviceEndpoint = getProperty(SPARQL_SERVICE_ENDPOINT); <line3> boolean replaceURIs = <line4> getProperty(SPARQL_REPLACE_URIS) != null && getProperty(SPARQL_REPLACE_URIS).equals(""true""); <line5> boolean removeDatatypes = <line6> getProperty(SPARQL_REMOVE_DATATYPES) != null <line7> && getProperty(SPARQL_REMOVE_DATATYPES).equals(""true""); <line8> String engineType = getProperty(SPARQL_ENGINE_TYPE); <line9> if (SparqlEngineType.JENA.toString().equals(engineType)) { <line10> engine = new JenaInterpreter(serviceEndpoint, replaceURIs, removeDatatypes); <line11> } <line12> } <line13> } <line14> "	"<line2>    LOGGER.info(""Properties: {}"", getProperties());"	task4	
public class A { <line0> public boolean datenLesen(Path xmlFilePath) { <line1> boolean ret = false; <line2> if (Files.exists(xmlFilePath)) { <line3> DatenPset datenPset = null; <line4> XMLStreamReader parser = null; <line5> try (InputStream is = Files.newInputStream(xmlFilePath); <line6> InputStreamReader in = new InputStreamReader(is, StandardCharsets.UTF_8)) { <line7> parser = inFactory.createXMLStreamReader(in); <line8> while (parser.hasNext()) { <line9> final int event = parser.next(); <line10> if (event == XMLStreamConstants.START_ELEMENT) { <line11> switch (parser.getLocalName()) { <line12> case MVConfig.SYSTEM -> readSystemConfiguration(parser); <line13> case DatenPset.TAG -> { <line14> datenPset = new DatenPset(); <line15> if (get(parser, DatenPset.TAG, DatenPset.XML_NAMES, datenPset.arr)) { <line16> Daten.listePset.add(datenPset); <line17> } <line18> } <line19> case DatenProg.TAG -> { <line20> DatenProg datenProg = new DatenProg(); <line21> if (get(parser, DatenProg.TAG, DatenProg.XML_NAMES, datenProg.arr)) { <line22> if (datenPset != null) { <line23> datenPset.addProg(datenProg); <line24> } <line25> } <line26> } <line27> case ReplaceList.REPLACELIST -> readReplacementList(parser); <line28> case DatenAbo.TAG -> readAboEntry(parser); <line29> case DatenDownload.TAG -> readDownloadEntry(parser); <line30> case BlacklistRule.TAG -> readBlacklist(parser); <line31> case DatenMediaPath.TAG -> readMediaPath(parser); <line32> } <line33> } <line34> } <line35> ret = true; <line36> } catch (Exception ex) { <line37> ret = false; <line38> } finally { <line39> if (parser != null) { <line40> try { <line41> parser.close(); <line42> } catch (XMLStreamException ignored) { <line43> } <line44> } <line45> } <line46> sortLists(); <line47> MVConfig.loadSystemParameter(); <line48> } <line49> return ret; <line50> } <line51> } <line52> 	"<line38>        logger.error(""datenLesen"", ex);"	task4	
public class A { <line0> private AtlasEdge updateEdge( <line1> AtlasAttributeDef attributeDef, <line2> Object value, <line3> AtlasEdge currentEdge, <line4> final AtlasVertex entityVertex) <line5> throws AtlasBaseException { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> AtlasVertex currentVertex = currentEdge.getInVertex(); <line9> String currentEntityId = getIdFromVertex(currentVertex); <line10> String newEntityId = getIdFromVertex(entityVertex); <line11> AtlasEdge newEdge = currentEdge; <line12> if (!currentEntityId.equals(newEntityId) && entityVertex != null) { <line13> try { <line14> newEdge = <line15> graphHelper.getOrCreateEdge( <line16> currentEdge.getOutVertex(), entityVertex, currentEdge.getLabel()); <line17> } catch (RepositoryException e) { <line18> throw new AtlasBaseException(AtlasErrorCode.INTERNAL_ERROR, e); <line19> } <line20> } <line21> return newEdge; <line22> } <line23> } <line24> 	"<line7>      LOG.debug(""Updating entity reference {} for reference attribute {}"", attributeDef.getName());"	task4	
"public class A { <line0> @RequestMapping(method = RequestMethod.GET, value = ""/secure/vcpeNetwork/isIPFree"") <line1> public @ResponseBody String isIPFree( <line2> String vcpeId, String router, String ip, Model model, Locale locale) { <line3> Boolean isFree = false; <line4> try { <line5> isFree = vcpeNetworkBO.isIPFree(vcpeId, router, ip); <line6> } catch (RestServiceException e) { <line7> model.addAttribute( <line8> ""errorMsg"", messageSource.getMessage(""vcpenetwork.check.ip.message.error"", null, locale)); <line9> } <line10> return isFree.toString(); <line11> } <line12> } <line13> "	"<line3>    LOGGER.debug(""Check if the IP: "" + ip + "" is free. The vcpeID: "" + vcpeId);"	task4	
"public class A { <line0> @Deprecated <line1> public String getFinancialYearId(String estDate) { <line2> String result = """"; <line3> Query query = <line4> getCurrentSession() <line5> .createQuery( <line6> ""select cfinancialyear.id from CFinancialYear cfinancialyear where"" <line7> + "" cfinancialyear.startingDate <= to_date('"" <line8> + estDate <line9> + ""','dd/MM/yyyy') and cfinancialyear.endingDate >= to_date('"" <line10> + estDate <line11> + ""','dd/MM/yyyy') ""); <line12> ArrayList list = (ArrayList) query.list(); <line13> if (list.size() > 0) result = list.get(0).toString(); <line14> return result; <line15> } <line16> } <line17> "	"<line2>    logger.info(""Obtained session"");"	task4	
public class A { <line0> @Override <line1> public void onMessage(Message<Long> message) { <line2> if (!message.getMessageObject().equals(received)) { <line3> failures++; <line4> } <line5> if (received % 10000 == 0) { <line6> } <line7> received++; <line8> } <line9> } <line10> 	"<line6>      logger.info(toString() + "" is at: "" + received);"	task4	
public class A { <line0> public void taskFailed(TaskGroup tg) { <line1> lock.lock(); <line2> try { <line3> this.failedTaskGroups.add(tg); <line4> if (--this.currentlyRunningCount == 0) { <line5> this.runningCondition.signalAll(); <line6> } <line7> } finally { <line8> lock.unlock(); <line9> } <line10> } <line11> } <line12> 	"<line1>    logger.info(""Task failed callback for taskId: "" + tg.getTaskId());"	task4	
public class A { <line0> public List<String> validatePartitioners(String[] tableNames, Job job) { <line1> ArrayList<String> validTableNames = new ArrayList<>(); <line2> for (String tableName : tableNames) { <line3> if (hasPartitionerOverride(new Text(tableName))) { <line4> try { <line5> Partitioner<BulkIngestKey, Value> partitionerForTable = <line6> cachePartitioner(new Text(tableName)); <line7> initializeJob(job, partitionerForTable); <line8> validTableNames.add(tableName); <line9> } catch (Exception e) { <line10> lazyInitializeDefaultPartitioner(job); <line11> } <line12> } else { <line13> lazyInitializeDefaultPartitioner(job); <line14> } <line15> } <line16> return validTableNames; <line17> } <line18> } <line19> 	"<line10>          log.warn(""Unable to create the partitioner for ""+ tableName+ "" despite its configuration.""+ ""Will use the default partitioner for this table."",e);"	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.EmailAddressSoap[] getEmailAddresses( <line1> String className, long classPK) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.portal.kernel.model.EmailAddress> returnValue = <line4> EmailAddressServiceUtil.getEmailAddresses(className, classPK); <line5> return com.liferay.portal.kernel.model.EmailAddressSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
"public class A { <line0> private static void convertTieLine( <line1> UcteNetwork ucteNetwork, MergedXnode mergedXnode, UcteExporterContext context) { <line2> Line line = mergedXnode.getExtendable(); <line3> convertXNode(ucteNetwork, mergedXnode, context); <line4> UcteElementId ucteElementId1 = <line5> context.getNamingStrategy().getUcteElementId(mergedXnode.getLine1Name()); <line6> String elementName1 = line.getProperty(ELEMENT_NAME_PROPERTY_KEY + ""_1"", null); <line7> UcteElementStatus status1 = <line8> line instanceof TieLine <line9> ? getStatusHalf((TieLine) line, Branch.Side.ONE) <line10> : getStatus(line, Branch.Side.ONE); <line11> UcteLine ucteLine1 = <line12> new UcteLine( <line13> ucteElementId1, <line14> status1, <line15> (float) line.getR() * mergedXnode.getRdp(), <line16> (float) line.getX() * mergedXnode.getXdp(), <line17> (float) line.getB1(), <line18> (int) line.getCurrentLimits1().getPermanentLimit(), <line19> elementName1); <line20> ucteNetwork.addLine(ucteLine1); <line21> UcteElementId ucteElementId2 = <line22> context.getNamingStrategy().getUcteElementId(mergedXnode.getLine2Name()); <line23> String elementName2 = line.getProperty(ELEMENT_NAME_PROPERTY_KEY + ""_2"", null); <line24> UcteElementStatus status2 = <line25> line instanceof TieLine <line26> ? getStatusHalf((TieLine) line, Branch.Side.TWO) <line27> : getStatus(line, Branch.Side.TWO); <line28> UcteLine ucteLine2 = <line29> new UcteLine( <line30> ucteElementId2, <line31> status2, <line32> (float) line.getR() * (1.0f - mergedXnode.getRdp()), <line33> (float) line.getX() * (1.0f - mergedXnode.getXdp()), <line34> (float) line.getB2(), <line35> (int) line.getCurrentLimits2().getPermanentLimit(), <line36> elementName2); <line37> ucteNetwork.addLine(ucteLine2); <line38> } <line39> } <line40> "	"<line3>    LOGGER.trace(""Converting TieLine {}"", line.getId());"	task4	
"public class A { <line0> public static ArrayList<String> loadSystemData(String system) { <line1> Path datapath = <line2> Paths.get(""./src/main/resources/QALD6MultilingualLogs/multilingual_"" + system + "".html""); <line3> ArrayList<String> result = Lists.newArrayList(); <line4> try { <line5> String loadedData = Files.lines(datapath).collect(Collectors.joining()); <line6> Document doc = Jsoup.parse(loadedData); <line7> Element table = doc.select(""table"").get(5); <line8> Elements tableRows = table.select(""tr""); <line9> for (Element row : tableRows) { <line10> Elements tableEntry = row.select(""td""); <line11> result.add(tableEntry.get(3).ownText()); <line12> } <line13> result.remove(0); <line14> return result; <line15> } catch (IOException e) { <line16> e.printStackTrace(); <line17> return result; <line18> } <line19> } <line20> } <line21> "	"<line17>      log.debug(""loading failed."");"	task4	
public class A { <line0> @Override <line1> public PollsQuestion findByPrimaryKey(Serializable primaryKey) throws NoSuchQuestionException { <line2> PollsQuestion pollsQuestion = fetchByPrimaryKey(primaryKey); <line3> if (pollsQuestion == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchQuestionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return pollsQuestion; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
"public class A { <line0> private boolean connect(String address, int port) { <line1> try { <line2> socket = TimedSocket.getSocket(address, port, SOCKET_TIMEOUT); <line3> socket.setSoTimeout(SOCKET_TIMEOUT); <line4> BufferedOutputStream buffOut = new BufferedOutputStream(socket.getOutputStream()); <line5> outputStream = new DataOutputStream(buffOut); <line6> return true; <line7> } catch (IOException e) { <line8> Freedomotic.logger.severe(""Unable to connect to host "" + address + "" on port "" + port); <line9> return false; <line10> } <line11> } <line12> } <line13> "	"<line1>    Freedomotic.logger.info(""Trying to connect to ethernet relay board on address "" + address + ':' + port);"	task4	
"public class A { <line0> @Override <line1> public void delete(Table hTable, Object rowKey, String colFamily, String colName) { <line2> try { <line3> byte[] rowBytes = HBaseUtils.getBytes(rowKey); <line4> Delete delete = new Delete(rowBytes); <line5> hTable.delete(delete); <line6> } catch (IOException e) { <line7> throw new PersistenceException(""Could not perform delete. Caused by: "", e); <line8> } <line9> } <line10> } <line11> "	"<line7>      logger.error(""Error while delete on hbase for : "" + rowKey);"	task4	
public class A { <line0> @Override <line1> public void fireBeforeRefreshStart(boolean asynchronous) { <line2> if (myRefreshCount++ == 0) { <line3> for (final VirtualFileManagerListener listener : myVirtualFileManagerListeners) { <line4> try { <line5> listener.beforeRefreshStart(asynchronous); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> } <line12> 	<line7>          LOG.error(e);	task4	
"public class A { <line0> private void dispatchInternal(UniformPair<EventBean[]> events) { <line1> if (statementResultNaturalStrategy != null) { <line2> statementResultNaturalStrategy.execute(events); <line3> } <line4> EventBean[] newEventArr = events != null ? events.getFirst() : null; <line5> EventBean[] oldEventArr = events != null ? events.getSecond() : null; <line6> for (UpdateListener listener : statementListenerSet.getListeners()) { <line7> try { <line8> listener.update(newEventArr, oldEventArr, epStatement, runtime); <line9> } catch (Throwable t) { <line10> String message = <line11> ""Unexpected exception invoking listener update method on listener class '"" <line12> + listener.getClass().getSimpleName() <line13> + ""' : "" <line14> + t.getClass().getSimpleName() <line15> + "" : "" <line16> + t.getMessage(); <line17> } <line18> } <line19> } <line20> } <line21> "	<line17>        log.error(message, t);	task4	
"public class A { <line0> @Override <line1> public void start(final Map<String, String> properties) { <line2> final String timeout = <line3> properties.getOrDefault( <line4> StatelessKafkaConnectorUtil.DATAFLOW_TIMEOUT, <line5> StatelessKafkaConnectorUtil.DEFAULT_DATAFLOW_TIMEOUT); <line6> timeoutMillis = (long) FormatUtils.getPreciseTimeDuration(timeout, TimeUnit.MILLISECONDS); <line7> topicName = properties.get(StatelessNiFiSourceConnector.TOPIC_NAME); <line8> topicNameAttribute = properties.get(StatelessNiFiSourceConnector.TOPIC_NAME_ATTRIBUTE); <line9> keyAttributeName = properties.get(StatelessNiFiSourceConnector.KEY_ATTRIBUTE); <line10> if (topicName == null && topicNameAttribute == null) { <line11> throw new ConfigException( <line12> ""Either the topic.name or topic.name.attribute configuration must be specified""); <line13> } <line14> final String headerRegex = properties.get(StatelessNiFiSourceConnector.HEADER_REGEX); <line15> headerAttributeNamePattern = headerRegex == null ? null : Pattern.compile(headerRegex); <line16> dataflow = StatelessKafkaConnectorUtil.createDataflow(properties); <line17> dataflow.initialize(); <line18> dataflowName = properties.get(StatelessKafkaConnectorUtil.DATAFLOW_NAME); <line19> outputPortName = properties.get(StatelessNiFiSourceConnector.OUTPUT_PORT_NAME); <line20> if (outputPortName == null) { <line21> final Set<String> outputPorts = dataflow.getOutputPortNames(); <line22> if (outputPorts.isEmpty()) { <line23> throw new ConfigException( <line24> ""The dataflow specified for <"" <line25> + dataflowName <line26> + ""> does not have an Output Port at the root level. Dataflows used for a Kafka"" <line27> + "" Connect Source Task must have at least one Output Port at the root level.""); <line28> } <line29> if (outputPorts.size() > 1) { <line30> throw new ConfigException( <line31> ""The dataflow specified for <"" <line32> + dataflowName <line33> + ""> has multiple Output Ports at the root level ("" <line34> + outputPorts.toString() <line35> + ""). The "" <line36> + StatelessNiFiSourceConnector.OUTPUT_PORT_NAME <line37> + "" property must be set to indicate which of these Ports Kafka records should be"" <line38> + "" retrieved from.""); <line39> } <line40> outputPortName = outputPorts.iterator().next(); <line41> } <line42> final String taskIndex = properties.get(STATE_MAP_KEY); <line43> localStatePartitionMap.put(STATE_MAP_KEY, taskIndex); <line44> final Map<String, String> localStateMap = <line45> (Map<String, String>) (Map) context.offsetStorageReader().offset(localStatePartitionMap); <line46> final Map<String, String> clusterStateMap = <line47> (Map<String, String>) (Map) context.offsetStorageReader().offset(clusterStatePartitionMap); <line48> dataflow.setComponentStates(localStateMap, Scope.LOCAL); <line49> dataflow.setComponentStates(clusterStateMap, Scope.CLUSTER); <line50> } <line51> } <line52> "	"<line2>    logger.info(""Starting Source Task with properties {}"",StatelessKafkaConnectorUtil.getLoggableProperties(properties));"	task4	
"public class A { <line0> @Override <line1> public List<String> getMatches(final String query, final int rows, final int start) { <line2> String url = composeURL(TERM_SEARCH_QUERY_SCRIPT, TERM_SEARCH_PARAM_NAME, query, rows, start); <line3> List<String> result = new ArrayList<String>(); <line4> try { <line5> Document response = readXML(url); <line6> NodeList nodes = response.getElementsByTagName(""IdList""); <line7> if (nodes.getLength() > 0) { <line8> nodes = nodes.item(0).getChildNodes(); <line9> for (int i = 0; i < nodes.getLength(); ++i) { <line10> Node n = nodes.item(i); <line11> if (n.getNodeType() == Node.ELEMENT_NODE && n.getNodeName().equals(""Id"")) { <line12> result.add(n.getTextContent()); <line13> } <line14> } <line15> } <line16> } catch (Exception ex) { <line17> } <line18> return result; <line19> } <line20> } <line21> "	"<line17>      this.logger.error(""Error while trying to retrieve matches for ""+ query+ "" ""+ ex.getClass().getName()+ "" ""+ ex.getMessage(),ex);"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.User updateIncompleteUser( <line1> HttpPrincipal httpPrincipal, <line2> long companyId, <line3> boolean autoPassword, <line4> String password1, <line5> String password2, <line6> boolean autoScreenName, <line7> String screenName, <line8> String emailAddress, <line9> long facebookId, <line10> String openId, <line11> java.util.Locale locale, <line12> String firstName, <line13> String middleName, <line14> String lastName, <line15> long prefixId, <line16> long suffixId, <line17> boolean male, <line18> int birthdayMonth, <line19> int birthdayDay, <line20> int birthdayYear, <line21> String jobTitle, <line22> boolean updateUserInformation, <line23> boolean sendEmail, <line24> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line25> throws com.liferay.portal.kernel.exception.PortalException { <line26> try { <line27> MethodKey methodKey = <line28> new MethodKey( <line29> UserServiceUtil.class, ""updateIncompleteUser"", _updateIncompleteUserParameterTypes60); <line30> MethodHandler methodHandler = <line31> new MethodHandler( <line32> methodKey, <line33> companyId, <line34> autoPassword, <line35> password1, <line36> password2, <line37> autoScreenName, <line38> screenName, <line39> emailAddress, <line40> facebookId, <line41> openId, <line42> locale, <line43> firstName, <line44> middleName, <line45> lastName, <line46> prefixId, <line47> suffixId, <line48> male, <line49> birthdayMonth, <line50> birthdayDay, <line51> birthdayYear, <line52> jobTitle, <line53> updateUserInformation, <line54> sendEmail, <line55> serviceContext); <line56> Object returnObj = null; <line57> try { <line58> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line59> } catch (Exception exception) { <line60> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line61> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line62> } <line63> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line64> } <line65> return (com.liferay.portal.kernel.model.User) returnObj; <line66> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line67> throw systemException; <line68> } <line69> } <line70> } <line71> "	<line67>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public void onFailure(final Throwable throwable) { <line2> sender.tell(new Failure(throwable), getSelf()); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""{}: getSchemaSource for {} failed"", id, sourceIdentifier, throwable);"	task4	
"public class A { <line0> @Watched(prefix = ""schema"") <line1> public Id removeVertexLabel(Id id) { <line2> SchemaCallable callable = new VertexLabelRemoveCallable(); <line3> VertexLabel schema = this.getVertexLabel(id); <line4> return asyncRun(this.graph(), schema, callable); <line5> } <line6> } <line7> "	"<line2>    LOG.debug(""SchemaTransaction remove vertex label '{}'"", id);"	task4	
public class A { <line0> @Override <line1> public Note get(String noteId, AuthenticationInfo subject) throws IOException { <line2> if (StringUtils.isBlank(noteId) || !isSubjectValid(subject)) { <line3> return EMPTY_NOTE; <line4> } <line5> String token = getUserToken(subject.getUser()); <line6> String response = restApiClient.get(token, noteId); <line7> Note note = Note.fromJson(response); <line8> if (note == null) { <line9> return EMPTY_NOTE; <line10> } <line11> return note; <line12> } <line13> } <line14> 	"<line11>    LOG.info(""ZeppelinHub REST API get note {} "", noteId);"	task4	
public class A { <line0> @Override <line1> public void close() { <line2> super.close(); <line3> ServerSocketChannel serverChannel = _acceptChannel; <line4> _acceptChannel = null; <line5> if (serverChannel != null) { <line6> removeBean(serverChannel); <line7> if (serverChannel.isOpen()) { <line8> try { <line9> serverChannel.close(); <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> _localPort = -2; <line15> } <line16> } <line17> 	"<line11>          LOG.warn(""Unable to close {}"", serverChannel, e);"	task4	
"public class A { <line0> private static Option<String> getMetadataValue( <line1> HoodieTableMetaClient metaClient, String extraMetadataKey, HoodieInstant instant) { <line2> try { <line3> HoodieCommitMetadata commitMetadata = <line4> HoodieCommitMetadata.fromBytes( <line5> metaClient.getCommitsTimeline().getInstantDetails(instant).get(), <line6> HoodieCommitMetadata.class); <line7> return Option.ofNullable(commitMetadata.getExtraMetadata().get(extraMetadataKey)); <line8> } catch (IOException e) { <line9> throw new HoodieIOException(""Unable to parse instant metadata "" + instant, e); <line10> } <line11> } <line12> } <line13> "	"<line3>      LOG.info(""reading checkpoint info for:"" + instant + "" key: "" + extraMetadataKey);"	task4	
"public class A { <line0> private void deleteUserConfigRecord(String username, Connection conn) { <line1> PreparedStatement stat = null; <line2> try { <line3> stat = conn.prepareStatement(DELETE_CONFIG); <line4> stat.setString(1, username); <line5> stat.executeUpdate(); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Error deleting user config record by id "" + username, t); <line8> } finally { <line9> this.closeDaoResources(null, stat); <line10> } <line11> } <line12> } <line13> "	"<line7>      logger.error(""Error deleting user config record by id {}"", username, t);"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.EmailAddress getEmailAddress( <line1> HttpPrincipal httpPrincipal, long emailAddressId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> EmailAddressServiceUtil.class, ""getEmailAddress"", _getEmailAddressParameterTypes3); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, emailAddressId); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.portal.kernel.model.EmailAddress) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
"public class A { <line0> public ArrayList<ServiceInfo> getServices(Properties properties) throws ApiException { <line1> ArrayList<ServiceInfo> services = new ArrayList<ServiceInfo>(); <line2> try { <line3> String defaultLangCode = this.getLangManager().getDefaultLang().getCode(); <line4> String langCode = properties.getProperty(SystemConstants.API_LANG_CODE_PARAMETER); <line5> String tagParamValue = properties.getProperty(""tag""); <line6> langCode = <line7> (null != langCode && null != this.getLangManager().getLang(langCode)) <line8> ? langCode <line9> : defaultLangCode; <line10> Map<String, ApiService> masterServices = <line11> this.getApiCatalogManager().getServices(tagParamValue); <line12> Iterator<ApiService> iter = masterServices.values().iterator(); <line13> while (iter.hasNext()) { <line14> ApiService service = (ApiService) iter.next(); <line15> if (service.isActive() <line16> && !service.isHidden() <line17> && this.checkServiceAuthorization(service, properties, false)) { <line18> ServiceInfo smallService = this.createServiceInfo(service, langCode, defaultLangCode); <line19> services.add(smallService); <line20> } <line21> } <line22> BeanComparator comparator = new BeanComparator(""description""); <line23> Collections.sort(services, comparator); <line24> } catch (Throwable t) { <line25> throw new ApiException(IApiErrorCodes.SERVER_ERROR, ""Internal error""); <line26> } <line27> return services; <line28> } <line29> } <line30> "	"<line25>      logger.error(""Error extracting services"", t);"	task4	
public class A { <line0> private String insertConfirmationToken(String state, int confirmationValidity) <line1> throws EngineException { <line2> Date createDate = new Date(); <line3> Calendar cl = Calendar.getInstance(); <line4> cl.setTime(createDate); <line5> cl.add(Calendar.MINUTE, confirmationValidity); <line6> Date expires = cl.getTime(); <line7> String token = UUID.randomUUID().toString(); <line8> try { <line9> tokensMan.addToken( <line10> CONFIRMATION_TOKEN_TYPE, <line11> token, <line12> state.getBytes(StandardCharsets.UTF_8), <line13> createDate, <line14> expires); <line15> } catch (Exception e) { <line16> throw e; <line17> } <line18> return token; <line19> } <line20> } <line21> 	"<line16>      log.error(""Cannot add token to db"", e);"	task4	
public class A { <line0> private void processReadRequest(final BookieProtocol.ReadRequest r, final Channel c) { <line1> ExecutorService fenceThreadPool = <line2> null == highPriorityThreadPool ? null : highPriorityThreadPool.chooseThread(c); <line3> ReadEntryProcessor read = <line4> ReadEntryProcessor.create(r, c, this, fenceThreadPool, throttleReadResponses); <line5> final OrderedExecutor threadPool; <line6> if (r.isHighPriority() || r.isFencing()) { <line7> threadPool = highPriorityThreadPool; <line8> } else { <line9> threadPool = readThreadPool; <line10> } <line11> if (null == threadPool) { <line12> read.run(); <line13> } else { <line14> try { <line15> threadPool.executeOrdered(r.getLedgerId(), read); <line16> } catch (RejectedExecutionException e) { <line17> if (LOG.isDebugEnabled()) { <line18> } <line19> read.sendResponse( <line20> BookieProtocol.ETOOMANYREQUESTS, <line21> ResponseBuilder.buildErrorResponse(BookieProtocol.ETOOMANYREQUESTS, r), <line22> requestStats.getReadRequestStats()); <line23> } <line24> } <line25> } <line26> } <line27> 	"<line18>          LOG.debug(""Failed to process request to read entry at {}:{}. Too many pending requests"",r.ledgerId,r.entryId);"	task4	
"public class A { <line0> protected void printConvenienceMethodTableValuedFunctionAsField( <line1> JavaWriter out, TableDefinition function, boolean parametersAsField, String methodName) { <line2> if (function.getParameters().size() > 254) { <line3> return; <line4> } <line5> if (function.getParameters().isEmpty()) <line6> if (parametersAsField) return; <line7> else if (scala) return; <line8> final String className = out.ref(getStrategy().getFullJavaClassName(function)); <line9> final String functionIdentifier = getStrategy().getFullJavaIdentifier(function); <line10> if (!printDeprecationIfUnknownTypes(out, function.getParameters())) <line11> out.javadoc(""Get <code>%s</code> as a table."", function.getQualifiedOutputName()); <line12> if (scala) out.print(""%sdef %s("", visibility(), methodName); <line13> else if (kotlin) out.print(""%sfun %s("", visibility(), methodName); <line14> else out.print(""%sstatic %s %s("", visibility(), className, methodName); <line15> if (!function.getParameters().isEmpty()) out.println(); <line16> printParameterDeclarations(out, function.getParameters(), parametersAsField, ""  ""); <line17> if (scala || kotlin) { <line18> out.println(""): %s = %s.call("", className, functionIdentifier); <line19> } else { <line20> out.println("") {""); <line21> out.println(""return %s.call("", functionIdentifier); <line22> } <line23> forEach( <line24> function.getParameters(), <line25> (parameter, separator) -> { <line26> out.println(""%s%s"", getStrategy().getJavaMemberName(parameter), separator); <line27> }); <line28> if (scala || kotlin) out.println("")""); <line29> else out.println("");"").println(""}""); <line30> } <line31> } <line32> "	"<line3>      log.warn(""Too many parameters"",""Function ""+ function+ "" has more than 254 in parameters. Skipping generation of convenience method."");"	task4	
public class A { <line0> @Activate <line1> protected void activate(BundleContext bundleContext) { <line2> _bundleContext = bundleContext; <line3> if (log.isInfoEnabled()) { <line4> } <line5> for (RemoteAppEntry remoteAppEntry : <line6> remoteAppEntryLocalService.getRemoteAppEntries(QueryUtil.ALL_POS, QueryUtil.ALL_POS)) { <line7> registerPortlet(remoteAppEntry); <line8> } <line9> } <line10> } <line11> 	"<line4>      log.info(""Starting remote app entries"");"	task4	
public class A { <line0> @Override <line1> public T get(K key, String[] fields) throws GoraException { <line2> try { <line3> if (fields == null) return infinispanClient.get(key); <line4> InfinispanQuery<K, T> query = new InfinispanQuery<K, T>(this); <line5> query.setKey(key); <line6> query.setFields(fields); <line7> query.build(); <line8> Result<K, T> result = query.execute(); <line9> result.next(); <line10> return result.get(); <line11> } catch (Exception e) { <line12> throw new GoraException(e); <line13> } <line14> } <line15> } <line16> 	"<line2>    LOG.debug(""get("" + key + "","" + fields + "")"");"	task4	
"public class A { <line0> void tryToSendFailSafeNotification() { <line1> try { <line2> if (failSafeEmail != null) { <line3> consoleWriter <line4> .a(""Send email notification to: "") <line5> .fg(Ansi.Color.CYAN) <line6> .a(failSafeEmail) <line7> .println(); <line8> Shell shell = new Shell(); <line9> shell.exec(buildFailSafeMailCommand()); <line10> } <line11> } catch (Throwable t) { <line12> String cantSendEmailMsg = <line13> ""Can't send fail safe email: "" + t.getMessage() + ""\n"" + ExceptionUtils.getStackTrace(t); <line14> consoleWriter.newLine().fg(Ansi.Color.RED).a(cantSendEmailMsg).println(2); <line15> } <line16> } <line17> } <line18> "	"<line15>      logger.error(""Unexpected error"", t);"	task4	
"public class A { <line0> @Override <line1> public JsonObject getLeaderBoard(String usecase) throws InsightsCustomException { <line2> try { <line3> AutoMLConfig mlConfig = autoMLConfigDAL.getMLConfigByUsecase(usecase); <line4> String modelId = mlConfig.getModelId(); <line5> return h2oApiCommunicator.getLeaderBoard(modelId); <line6> } catch (Exception e) { <line7> throw new InsightsCustomException(""Error getting leaderboard: "" + usecase); <line8> } <line9> } <line10> } <line11> "	"<line7>      log.error(""Error getting leaderboard: {} "", usecase);"	task4	
"public class A { <line0> private @Nullable String getIPv4inSubnet(String ipAddress, String subnetMask) { <line1> try { <line2> final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); <line3> while (interfaces.hasMoreElements()) { <line4> final NetworkInterface current = interfaces.nextElement(); <line5> if (!current.isUp() <line6> || current.isLoopback() <line7> || current.isVirtual() <line8> || current.isPointToPoint()) { <line9> continue; <line10> } <line11> for (InterfaceAddress ifAddr : current.getInterfaceAddresses()) { <line12> InetAddress addr = ifAddr.getAddress(); <line13> if (addr.isLoopbackAddress() || (addr instanceof Inet6Address)) { <line14> continue; <line15> } <line16> String ipv4AddressOnInterface = addr.getHostAddress(); <line17> String subnetStringOnInterface = <line18> getIpv4NetAddress(ipv4AddressOnInterface, ifAddr.getNetworkPrefixLength()) <line19> + ""/"" <line20> + String.valueOf(ifAddr.getNetworkPrefixLength()); <line21> String configuredSubnetString = <line22> getIpv4NetAddress(ipAddress, Short.parseShort(subnetMask)) + ""/"" + subnetMask; <line23> if (subnetStringOnInterface.equals(configuredSubnetString)) { <line24> return ipv4AddressOnInterface; <line25> } <line26> } <line27> } <line28> } catch (SocketException ex) { <line29> } <line30> return null; <line31> } <line32> } <line33> "	"<line29>      LOGGER.error(""Could not retrieve network interface: {}"", ex.getMessage(), ex);"	task4	
"public class A { <line0> public static HttpResponse retryGetRequestUntilDeployed( <line1> String requestUrl, Map<String, String> headers) throws IOException, InterruptedException { <line2> HttpResponse response; <line3> int retryCount = 0; <line4> do { <line5> response = HttpsClientRequest.doGet(requestUrl, headers); <line6> retryCount++; <line7> } while (response != null <line8> && response.getResponseCode() == 404 <line9> && response.getResponseMessage().contains(""Not Found"") <line10> && retry(retryCount)); <line11> return response; <line12> } <line13> } <line14> "	"<line5>      log.info(""Trying request with url : "" + requestUrl);"	task4	
public class A { <line0> @Override <line1> public Message getCommittedMessage(TopicPartition topicPartition) throws Exception { <line2> SimpleConsumer consumer = null; <line3> try { <line4> long committedOffset = mZookeeperConnector.getCommittedOffsetCount(topicPartition) - 1; <line5> if (committedOffset < 0) { <line6> return null; <line7> } <line8> consumer = createConsumer(topicPartition); <line9> if (consumer == null) { <line10> return null; <line11> } <line12> return getMessage(topicPartition, committedOffset, consumer); <line13> } catch (MessageDoesNotExistException e) { <line14> return null; <line15> } finally { <line16> if (consumer != null) { <line17> consumer.close(); <line18> } <line19> } <line20> } <line21> } <line22> 	"<line14>      LOG.warn(""no committed message for topic {} partition {}"",topicPartition.getTopic(),topicPartition.getPartition());"	task4	
"public class A { <line0> @Override <line1> public void adjustInContext(TlsContext context, ConnectionEndType ownerOfKey) { <line2> if (null == ownerOfKey) { <line3> throw new IllegalArgumentException(""Owner of Key "" + ownerOfKey + "" is not supported""); <line4> } else { <line5> switch (ownerOfKey) { <line6> case CLIENT: <line7> context.setClientEcPublicKey(point); <line8> if (group != null) { <line9> context.setEcCertificateCurve(group); <line10> } <line11> break; <line12> case SERVER: <line13> context.setServerEcPublicKey(point); <line14> if (group != null) { <line15> context.setEcCertificateCurve(group); <line16> } <line17> break; <line18> default: <line19> throw new IllegalArgumentException(""Owner of Key "" + ownerOfKey + "" is not supported""); <line20> } <line21> } <line22> } <line23> } <line24> "	"<line2>    LOGGER.debug(""Adjusting EC public key in context"");"	task4	
public class A { <line0> private Date _readDate(String text) { <line1> if (Validator.isNotNull(text)) { <line2> DateFormat dateFormat = <line3> DateFormatFactoryUtil.getSimpleDateFormat(Time.RFC822_FORMAT, LocaleUtil.US); <line4> try { <line5> return dateFormat.parse(text); <line6> } catch (Exception exception) { <line7> if (log.isWarnEnabled()) { <line8> } <line9> } <line10> } <line11> return new Date(); <line12> } <line13> } <line14> 	"<line8>          log.warn(""Unable to parse date "" + text, exception);"	task4	
public class A { <line0> private void createBackupArchiveBundle() { <line1> File file = new File(ARTIFACTS_BUNDLE_BACKUP_FILE_PATH); <line2> DeploymentGroupClient deploymentGroupClient = this.i3sClient.deploymentGroup(); <line3> ResourceCollection<DeploymentGroup> deploymentGroups = deploymentGroupClient.getAll(); <line4> String deploymentGrpUri = deploymentGroups.get(0).getUri(); <line5> TaskResource task = <line6> this.artifactsBundleClient.createBackupArchiveBundle(file, deploymentGrpUri); <line7> } <line8> } <line9> 	"<line7>    LOGGER.info(""Task object returned to client: {}"", task.toJsonString());"	task4	
"public class A { <line0> @Test <line1> public void testInvokeNormal() { <line2> NormalClass method = Container.getComp(NormalClass.class); <line3> String result = method.test(); <line4> assertEquals(""RESULT"", result); <line5> } <line6> } <line7> "	<line4>    LOG.info(result);	task4	
"public class A { <line0> private void setJsonTimeseries( <line1> JsonObject obj, String target, Pair<ZonedDateTime, ZonedDateTime> timeRange) { <line2> List<TimeValues> timeValues = databaseConnectService.querySeries(target, timeRange); <line3> JsonArray dataPoints = new JsonArray(); <line4> for (TimeValues tv : timeValues) { <line5> long time = tv.getTime(); <line6> Object value = tv.getValue(); <line7> JsonArray jsonArray = new JsonArray(); <line8> jsonArray.add(GSON.toJsonTree(value)); <line9> jsonArray.add(time); <line10> dataPoints.add(jsonArray); <line11> } <line12> obj.add(""datapoints"", dataPoints); <line13> } <line14> } <line15> "	"<line3>    logger.info(""query size: {}"", timeValues.size());"	task4	
public class A { <line0> @Override <line1> protected void doInAfterTrace( <line2> SpanEventRecorder recorder, <line3> Object target, <line4> Object[] args, <line5> Object result, <line6> Throwable throwable) { <line7> recorder.recordApi(methodDescriptor); <line8> recorder.recordException(throwable); <line9> if (isAsynchronousInvocation(target, args, result, throwable)) { <line10> final AsyncContext asyncContext = recorder.recordNextAsyncContext(); <line11> ((AsyncContextAccessor) result)._$PINPOINT$_setAsyncContext(asyncContext); <line12> if (isDebug) { <line13> } <line14> } <line15> } <line16> } <line17> 	"<line13>        logger.debug(""Set AsyncContext {}"", asyncContext);"	task4	
"public class A { <line0> private String getParagraphStyleName() { <line1> String paraStyleName = """"; <line2> try { <line3> paraStyleName = <line4> AnyConverter.toString(Utils.getProperty(textRange, UnoProperty.PARA_STYLE_NAME)); <line5> } catch (IllegalArgumentException e) { <line6> } <line7> return paraStyleName; <line8> } <line9> } <line10> "	"<line6>      LOGGER.trace("""", e);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> for (int i = 0; i < COUNT; i++) { <line4> blockingQueue.take(); <line5> } <line6> } catch (InterruptedException e) { <line7> throw new RuntimeException(e); <line8> } <line9> } <line10> } <line11> 	"<line7>      logger.error(""Interrupted"", e);"	task4	
public class A { <line0> public synchronized void stopLoadBalancing() { <line1> if (stopped) { <line2> return; <line3> } <line4> stopped = true; <line5> partitionReadLock.lock(); <line6> try { <line7> rebalancingPartition.stop(); <line8> for (final QueuePartition queuePartition : queuePartitions) { <line9> queuePartition.stop(); <line10> } <line11> } finally { <line12> partitionReadLock.unlock(); <line13> } <line14> } <line15> } <line16> 	"<line1>    logger.debug(""{} stopped. Will no longer distribute FlowFiles across the cluster"", this);"	task4	
public class A { <line0> @Override <line1> public void setJobContextInformation(String jobId, Object object) { <line2> runningJobs.put(jobId, (ActorRef) object); <line3> } <line4> } <line5> 	"<line3>    LOGGER.debug(""Running jobs: {}"", runningJobs.keySet());"	task4	
public class A { <line0> public static void deleteCommerceDiscountRule(long commerceDiscountRuleId) <line1> throws RemoteException { <line2> try { <line3> CommerceDiscountRuleServiceUtil.deleteCommerceDiscountRule(commerceDiscountRuleId); <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>      log.error(exception, exception);	task4	
"public class A { <line0> @Test <line1> public void shouldReturnEmptyBodyAndStatus404() { <line2> String response = <line3> given() <line4> .header(""Accept"", ""application/json"") <line5> .contentType(ContentType.JSON) <line6> .port(getHttpPort()) <line7> .expect() <line8> .statusCode(Response.Status.NOT_FOUND.getStatusCode()) <line9> .when() <line10> .get(BASE_REST_PATH + ""/does-not-exists"") <line11> .asString(); <line12> org.junit.Assert.assertTrue(response.isEmpty()); <line13> } <line14> } <line15> "	<line12>    logger.info(response);	task4	
"public class A { <line0> public static RandomAccessFile getRandomAccessFile(FileImageOutputStream fstream) { <line1> try { <line2> Field fRaf = FileImageOutputStream.class.getDeclaredField(""raf""); <line3> if (fRaf != null) { <line4> fRaf.setAccessible(true); <line5> return (RandomAccessFile) fRaf.get(fstream); <line6> } <line7> } catch (Exception e) { <line8> } <line9> return null; <line10> } <line11> } <line12> "	"<line8>      LOGGER.error(""getFileDescriptor from FileImageOutputStream"", e);"	task4	
"public class A { <line0> public static com.liferay.commerce.pricing.model.CommercePriceModifier <line1> deleteCommercePriceModifier(HttpPrincipal httpPrincipal, long commercePriceModifierId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommercePriceModifierServiceUtil.class, <line7> ""deleteCommercePriceModifier"", <line8> _deleteCommercePriceModifierParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commercePriceModifierId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.pricing.model.CommercePriceModifier) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> private static NtlmChallenge interrogate(CIFSContext tf, Address addr) throws SmbException { <line1> UniAddress dc = new UniAddress(addr); <line2> try (SmbTransportInternal trans = <line3> tf.getTransportPool() <line4> .getSmbTransport( <line5> tf, <line6> dc, <line7> 0, <line8> false, <line9> tf.hasDefaultCredentials() && tf.getConfig().isIpcSigningEnforced()) <line10> .unwrap(SmbTransportInternal.class)) { <line11> if (!tf.hasDefaultCredentials()) { <line12> trans.ensureConnected(); <line13> } else { <line14> try (SmbSessionInternal ssn = <line15> trans.getSmbSession(tf.withDefaultCredentials()).unwrap(SmbSessionInternal.class)) { <line16> ssn.treeConnectLogon(); <line17> } <line18> } <line19> return new NtlmChallenge(trans.getServerEncryptionKey(), dc); <line20> } catch (SmbException e) { <line21> throw e; <line22> } catch (IOException e) { <line23> throw new SmbException(""Connection failed"", e); <line24> } <line25> } <line26> } <line27> "	"<line13>        log.warn(""Default credentials (jcifs.smb.client.username/password)""+ "" not specified. SMB signing may not work propertly.""+ ""  Skipping DC interrogation."");"	task4	
public class A { <line0> @Override <line1> public void operationComplete(CloseFuture future) { <line2> if (session.getStatus() == INFO_SWITCHING_PROTOCOLS) { <line3> ProxyUpgradeHandler handler = new ProxyUpgradeHandler(attachedSession.getParent()); <line4> session.suspendRead(); <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> session.upgrade(handler); <line8> } <line9> } <line10> } <line11> 	"<line6>        LOGGER.debug(String.format(""http.proxy service is upgrading session %s"", session));"	task4	
public class A { <line0> private void initializeStorage() throws InvalidAlgorithmParameterException { <line1> mac = storage.get(STORAGE_MAC); <line2> final @Nullable Object saltConfig = storage.get(STORAGE_SALT); <line3> final @Nullable Object privateKeyConfig = storage.get(STORAGE_PRIVATE_KEY); <line4> if (mac == null) { <line5> mac = HomekitServer.generateMac(); <line6> storage.put(STORAGE_MAC, mac); <line7> } <line8> if (saltConfig == null) { <line9> salt = HomekitServer.generateSalt(); <line10> storage.put(STORAGE_SALT, salt.toString()); <line11> } else { <line12> salt = new BigInteger(saltConfig.toString()); <line13> } <line14> if (privateKeyConfig == null) { <line15> privateKey = HomekitServer.generateKey(); <line16> storage.put(STORAGE_PRIVATE_KEY, Base64.getEncoder().encodeToString(privateKey)); <line17> } else { <line18> privateKey = Base64.getDecoder().decode(privateKeyConfig.toString()); <line19> } <line20> } <line21> } <line22> 	"<line5>      logger.warn(""Could not find existing MAC in {}. Generating new MAC. This will require re-pairing of""+ "" iOS devices."",storage.getClass().getName());"	task4	
"public class A { <line0> private void loadLicenses(String versionHome) { <line1> String licensesSource = repository + File.separator + ""licenses""; <line2> String licensesTarget = versionHome + File.separator + ""licenses""; <line3> FolderTools.copyFromFolderToFolder(licensesSource, licensesTarget, true); <line4> String licensesReportSource = <line5> repository <line6> + File.separator <line7> + ""core"" <line8> + File.separator <line9> + ""java"" <line10> + File.separator <line11> + ""iesi-core"" <line12> + File.separator <line13> + ""target"" <line14> + File.separator <line15> + ""site""; <line16> String licensesReportTarget = <line17> versionHome + File.separator + ""licenses"" + File.separator + ""core""; <line18> FolderTools.copyFromFolderToFolder(licensesReportSource, licensesReportTarget, true); <line19> } <line20> } <line21> "	"<line1>    LOGGER.info(MessageFormat.format(""Loading licenses into version home: {0}"", versionHome));"	task4	
"public class A { <line0> @Override <line1> public ListenableFuture<Image> createImage(ImageTemplate template) { <line2> checkState( <line3> template instanceof CloneImageTemplate, <line4> "" openstack-nova only supports creating images through cloning.""); <line5> CloneImageTemplate cloneTemplate = (CloneImageTemplate) template; <line6> RegionAndId sourceImageRegionAndId = <line7> RegionAndId.fromSlashEncoded(cloneTemplate.getSourceNodeId()); <line8> String newImageId = <line9> novaApi <line10> .getServerApi(sourceImageRegionAndId.getRegion()) <line11> .createImageFromServer(cloneTemplate.getName(), sourceImageRegionAndId.getId()); <line12> final RegionAndId targetImageRegionAndId = <line13> RegionAndId.fromRegionAndId(sourceImageRegionAndId.getRegion(), newImageId); <line14> final AtomicReference<Image> image = <line15> Atomics.newReference( <line16> new ImageBuilder() <line17> .location(find(locations.get(), idEquals(targetImageRegionAndId.getRegion()))) <line18> .id(targetImageRegionAndId.slashEncode()) <line19> .providerId(targetImageRegionAndId.getId()) <line20> .description(cloneTemplate.getName()) <line21> .operatingSystem( <line22> OperatingSystem.builder().description(cloneTemplate.getName()).build()) <line23> .status(Image.Status.PENDING) <line24> .build()); <line25> return userExecutor.submit( <line26> new Callable<Image>() { <line27> @Override <line28> public Image call() throws Exception { <line29> if (imageAvailablePredicate.apply(image)) return image.get(); <line30> throw new UncheckedTimeoutException( <line31> ""Image was not created within the time limit: "" + image.get()); <line32> } <line33> }); <line34> } <line35> } <line36> "	"<line14>    logger.info("">> Registered new Image %s, waiting for it to become available."", newImageId);"	task4	
public class A { <line0> public static boolean tryParse( <line1> String serializedDistinctContinuationToken, <line2> Utils.ValueHolder<DistinctContinuationToken> outDistinctContinuationToken) { <line3> boolean parsed; <line4> try { <line5> DistinctContinuationToken distinctContinuationToken = <line6> new DistinctContinuationToken(serializedDistinctContinuationToken); <line7> distinctContinuationToken.getSourceToken(); <line8> distinctContinuationToken.getLastHash(); <line9> outDistinctContinuationToken.v = distinctContinuationToken; <line10> parsed = true; <line11> } catch (Exception ex) { <line12> parsed = false; <line13> outDistinctContinuationToken.v = null; <line14> } <line15> return parsed; <line16> } <line17> } <line18> 	"<line12>      logger.debug(""Received exception {} when trying to parse: {}"",ex.getMessage(),serializedDistinctContinuationToken);"	task4	
public class A { <line0> private void checkRackAfterAgentLoss(SingularityAgent lostAgent) { <line1> List<SingularityAgent> agents = agentManager.getObjectsFiltered(MachineState.ACTIVE); <line2> int numInRack = 0; <line3> for (SingularityAgent agent : agents) { <line4> if (agent.getRackId().equals(lostAgent.getRackId())) { <line5> numInRack++; <line6> } <line7> } <line8> if (numInRack == 0) { <line9> rackManager.changeState( <line10> lostAgent.getRackId(), MachineState.DEAD, Optional.empty(), Optional.empty()); <line11> } <line12> } <line13> } <line14> 	"<line8>    LOG.info(""Found {} agents left in rack {}"", numInRack, lostAgent.getRackId());"	task4	
"public class A { <line0> @Test <line1> public void testAtmostOnce2() throws Exception { <line2> try { <line3> HBaseTestHelper.clearHBase(); <line4> TestHBasePutOperator thop = new TestHBasePutOperator(); <line5> thop.getStore().setTableName(""table1""); <line6> thop.getStore().setZookeeperQuorum(""127.0.0.1""); <line7> thop.getStore().setZookeeperClientPort(2181); <line8> HBaseTuple t1 = new HBaseTuple(); <line9> t1.setColFamily(""colfam0""); <line10> t1.setColName(""street""); <line11> t1.setRow(""row1""); <line12> t1.setColValue(""ts""); <line13> HBaseTuple t2 = new HBaseTuple(); <line14> t2.setColFamily(""colfam0""); <line15> t2.setColName(""city""); <line16> t2.setRow(""row2""); <line17> t2.setColValue(""tc""); <line18> thop.beginWindow(0); <line19> thop.input.process(t1); <line20> AttributeMap.DefaultAttributeMap attributeMap = new AttributeMap.DefaultAttributeMap(); <line21> attributeMap.put(OperatorContext.PROCESSING_MODE, ProcessingMode.AT_MOST_ONCE); <line22> thop.setup(mockOperatorContext(0, attributeMap)); <line23> thop.input.process(t2); <line24> thop.endWindow(); <line25> HBaseTuple tuple; <line26> HBaseTuple tuple2; <line27> tuple = HBaseTestHelper.getHBaseTuple(""row1"", ""colfam0"", ""street""); <line28> tuple2 = HBaseTestHelper.getHBaseTuple(""row2"", ""colfam0"", ""city""); <line29> Assert.assertNull(""Tuple"", tuple); <line30> Assert.assertNotNull(""Tuple2"", tuple2); <line31> Assert.assertEquals(""Tuple row"", tuple2.getRow(), ""row2""); <line32> Assert.assertEquals(""Tuple column family"", tuple2.getColFamily(), ""colfam0""); <line33> Assert.assertEquals(""Tuple column name"", tuple2.getColName(), ""city""); <line34> Assert.assertEquals(""Tuple column value"", tuple2.getColValue(), ""tc""); <line35> } catch (IOException e) { <line36> } <line37> } <line38> } <line39> "	<line36>      logger.error(e.getMessage());	task4	
"public class A { <line0> @Override <line1> public List<String> find(String database) { <line2> String hostListString = configManager.getConfig(buildKey(database)); <line3> if (hostListString == null) { <line4> try { <line5> configManager.createConfig(ZK_PROJECT, buildKey(database), database); <line6> } catch (Throwable t) { <line7> } finally { <line8> hostListString = """"; <line9> } <line10> } <line11> return parseHostList(hostListString); <line12> } <line13> } <line14> "	"<line7>        logger.warn(""failed to create config"");"	task4	
"public class A { <line0> @Override <line1> protected void postProcessRequest( <line2> boolean isGet, <line3> HttpServletRequest httpReq, <line4> HttpServletResponse httpResp, <line5> String samlRequest, <line6> String relayState) <line7> throws IOException { <line8> try { <line9> SAMLBindings binding = isGet ? SAMLBindings.HTTP_REDIRECT : SAMLBindings.HTTP_POST; <line10> LogoutRequestDocument reqDoc = LogoutRequestDocument.Factory.parse(samlRequest); <line11> SAMLVerifiableElement verifiableMessage = <line12> binding == SAMLBindings.HTTP_REDIRECT <line13> ? new RedirectedMessage(httpReq.getQueryString()) <line14> : new XMLExpandedMessage(reqDoc, reqDoc.getLogoutRequest()); <line15> SAMLMessage<LogoutRequestDocument> requestMessage = <line16> new SAMLMessage<>(verifiableMessage, relayState, binding, reqDoc); <line17> logoutProcessor.handleAsyncLogoutFromSAML(requestMessage, httpResp); <line18> } catch (XmlException e) { <line19> httpResp.sendError( <line20> HttpServletResponse.SC_BAD_REQUEST, ""Invalid SLO request (XML is malformed)""); <line21> return; <line22> } catch (EopException e) { <line23> } <line24> } <line25> } <line26> "	"<line19>      log.warn(""Got a request to the SAML Single Logout endpoint, ""+ ""with invalid request (XML is broken)"",e);"	task4	
"public class A { <line0> public void connect(CometdProducerConsumer prodcon) throws Exception { <line1> Server server = null; <line2> CometdEndpoint endpoint = prodcon.getEndpoint(); <line3> String connectorKey = <line4> endpoint.getProtocol() + "":"" + endpoint.getUri().getHost() + "":"" + endpoint.getPort(); <line5> synchronized (connectors) { <line6> ConnectorRef connectorRef = connectors.get(connectorKey); <line7> if (connectorRef == null) { <line8> ServerConnector connector; <line9> server = createServer(); <line10> if (""cometds"".equals(endpoint.getProtocol())) { <line11> connector = getSslSocketConnector(server); <line12> } else { <line13> connector = new ServerConnector(server); <line14> } <line15> connector.setPort(endpoint.getPort()); <line16> connector.setHost(endpoint.getUri().getHost()); <line17> if (""localhost"".equalsIgnoreCase(endpoint.getUri().getHost())) { <line18> } <line19> server.addConnector(connector); <line20> CometDServlet servlet = createServletForConnector(server, connector, endpoint); <line21> connectorRef = new ConnectorRef(connector, servlet, server); <line22> server.start(); <line23> connectors.put(connectorKey, connectorRef); <line24> } else { <line25> connectorRef.increment(); <line26> } <line27> BayeuxServerImpl bayeux = connectorRef.servlet.getBayeux(); <line28> if (securityPolicy != null) { <line29> bayeux.setSecurityPolicy(securityPolicy); <line30> } <line31> if (extensions != null) { <line32> for (BayeuxServer.Extension extension : extensions) { <line33> bayeux.addExtension(extension); <line34> } <line35> } <line36> if (serverListeners != null) { <line37> for (BayeuxServer.BayeuxServerListener serverListener : serverListeners) { <line38> bayeux.addListener(serverListener); <line39> } <line40> } <line41> prodcon.setBayeux(bayeux); <line42> } <line43> } <line44> } <line45> "	"<line18>          LOG.warn(""You use localhost interface! It means that no external connections will be""+ "" available. Don't you want to use 0.0.0.0 instead (all network interfaces)?"");"	task4	
public class A { <line0> protected void writeProtocolVersion() { <line1> appendBytes(msg.getProtocolVersion().getValue()); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""ProtocolVersion: "" + ArrayConverter.bytesToHexString(msg.getProtocolVersion().getValue()));"	task4	
public class A { <line0> private void fail(ResponseCallback callback, Throwable failure) { <line1> try { <line2> callback.onFailure(failure); <line3> } catch (Throwable throwable) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.error(""[{}] Unexpected error while failing {}"", logPrefix, callback, throwable);"	task4	
public class A { <line0> @Override <line1> public Iterable<EntityBody> list(NeutralQuery neutralQuery) { <line2> listSecurityCheck(neutralQuery); <line3> return listImplementationAfterSecurityChecks(neutralQuery); <line4> } <line5> } <line6> 	"<line2>    LOG.debug("">>>BasicService.list(neutralQuery)"");"	task4	
"public class A { <line0> @Override <line1> public LoadState load(LevelData data, Path levelPath, String levelId) throws IOException { <line2> Path levelDatPath = levelPath.resolve(""level.dat""); <line3> Path levelDatOldPath = levelPath.resolve(""level.dat_old""); <line4> if (Files.notExists(levelDatPath) && Files.notExists(levelDatOldPath)) { <line5> return LoadState.NOT_FOUND; <line6> } <line7> try { <line8> loadData(data, levelDatPath); <line9> } catch (IOException e) { <line10> loadData(data, levelDatOldPath); <line11> } <line12> return LoadState.LOADED; <line13> } <line14> } <line15> "	"<line10>      log.warn(""Unable to load level.dat file, attempting to load backup."");"	task4	
"public class A { <line0> public void close() throws OHException { <line1> try { <line2> entityManager.close(); <line3> } catch (IllegalStateException e) { <line4> e.printStackTrace(); <line5> throw new OHException( <line6> MessageBundle.getMessage(""angal.sql.problemsoccurredwiththesqlistruction""), e); <line7> } <line8> } <line9> } <line10> "	"<line4>      LOGGER.error(""IllegalStateException"");"	task4	
public class A { <line0> public static com.liferay.layout.page.template.model.LayoutPageTemplateEntrySoap <line1> addLayoutPageTemplateEntry( <line2> long groupId, <line3> long layoutPageTemplateCollectionId, <line4> long classNameId, <line5> long classTypeId, <line6> String name, <line7> long masterLayoutPlid, <line8> int status, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws RemoteException { <line11> try { <line12> com.liferay.layout.page.template.model.LayoutPageTemplateEntry returnValue = <line13> LayoutPageTemplateEntryServiceUtil.addLayoutPageTemplateEntry( <line14> groupId, <line15> layoutPageTemplateCollectionId, <line16> classNameId, <line17> classTypeId, <line18> name, <line19> masterLayoutPlid, <line20> status, <line21> serviceContext); <line22> return com.liferay.layout.page.template.model.LayoutPageTemplateEntrySoap.toSoapModel( <line23> returnValue); <line24> } catch (Exception exception) { <line25> throw new RemoteException(exception.getMessage()); <line26> } <line27> } <line28> } <line29> 	<line25>      log.error(exception, exception);	task4	
public class A { <line0> private @Nullable Map<String, Object> normalizeConfiguration( <line1> @Nullable Map<String, Object> properties, String serviceId) { <line2> if (properties == null || properties.isEmpty()) { <line3> return properties; <line4> } <line5> ConfigurableServiceDTO service = getServiceById(serviceId); <line6> if (service == null) { <line7> return properties; <line8> } <line9> URI uri; <line10> try { <line11> uri = new URI(service.configDescriptionURI); <line12> } catch (URISyntaxException e) { <line13> return properties; <line14> } <line15> ConfigDescription configDesc = configDescRegistry.getConfigDescription(uri); <line16> if (configDesc == null) { <line17> return properties; <line18> } <line19> return ConfigUtil.normalizeTypes(properties, List.of(configDesc)); <line20> } <line21> } <line22> 	"<line13>      logger.warn(""Not a valid URI: {}"", service.configDescriptionURI);"	task4	
public class A { <line0> @Override <line1> public void onFailure(Throwable arg0) { <line2> } <line3> } <line4> 	"<line2>    LOG.error(""Failure reading ActionDefinition {}"", id.getValue());"	task4	
public class A { <line0> private void updateSelectedObject(OWLObject selObj) { <line1> selectedObject = selObj; <line2> updateLastSelection(); <line3> fireSelectionChanged(); <line4> } <line5> } <line6> 	"<line3>    logger.debug(""Set the selected object to: {}"", selObj);"	task4	
"public class A { <line0> protected void cleanupOrigin(Repository repository) { <line1> try { <line2> Git git = <line3> ((JGitPathImpl) pathUtil.convert(repository.getDefaultBranch().get().getPath())) <line4> .getFileSystem() <line5> .getGit(); <line6> new RemoveRemote(git, ""origin"", REMOTE_ORIGIN_REF).execute(); <line7> } catch (GitException e) { <line8> } <line9> } <line10> } <line11> "	"<line8>      log.warn(""Error cleaning up origin for repository '{}': {}"", repository.getAlias(), e);"	task4	
"public class A { <line0> public String fetchContent(URL url, boolean useProxy, String userKey, String passwordKey) <line1> throws DownloadFailedException, TooManyRequestsException, ResourceNotFoundException { <line2> InputStream in = null; <line3> try (HttpResourceConnection conn = <line4> new HttpResourceConnection(settings, useProxy, userKey, passwordKey); <line5> ByteArrayOutputStream out = new ByteArrayOutputStream()) { <line6> in = conn.fetch(url); <line7> IOUtils.copy(in, out); <line8> return out.toString(UTF8); <line9> } catch (IOException ex) { <line10> final String msg = <line11> format(""Download failed, unable to retrieve '%s'; %s"", url.toString(), ex.getMessage()); <line12> throw new DownloadFailedException(msg, ex); <line13> } finally { <line14> if (in != null) { <line15> try { <line16> in.close(); <line17> } catch (IOException ex) { <line18> } <line19> } <line20> } <line21> } <line22> } <line23> "	"<line18>          LOGGER.trace(""Ignorable error"", ex);"	task4	
public class A { <line0> @Override <line1> public void execute() { <line2> IBaseDao<Configuration, Serializable> confDao = getDaoFactory().getDAO(Configuration.class); <line3> List<Configuration> configurationList = confDao.findAll(); <line4> for (Configuration configurationCurrent : configurationList) { <line5> try { <line6> CnATreeElement personConfiguration = (CnATreeElement) configurationCurrent.getPerson(); <line7> if (personConfiguration != null && personConfiguration.getUuid().equals(person.getUuid())) { <line8> configuration = configurationCurrent; <line9> break; <line10> } <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> 	"<line12>        log.error(""Error"", e);"	task4	
public class A { <line0> @Override <line1> @EventListener <line2> public void onSave(EntityBatchSaveEvent event) { <line3> if (isEnabled()) { <line4> Stopwatch stopwatch = Stopwatch.createStarted(); <line5> timer.record(() -> jdbcTemplate.execute(SQL, callback(topicMessages))); <line6> } <line7> } <line8> } <line9> 	"<line6>      log.info(""Finished notifying {} messages in {}"", topicMessages.size(), stopwatch);"	task4	
public class A { <line0> @AfterClass <line1> public static void afterTest() { <line2> try { <line3> stopKafkaServer(); <line4> stopZookeeper(); <line5> } catch (Exception ex) { <line6> } <line7> } <line8> } <line9> 	"<line6>      logger.debug(""LSHIL {}"", ex.getLocalizedMessage());"	task4	
public class A { <line0> public void run() { <line1> try { <line2> while (!stopped_) { <line3> select(); <line4> processAcceptedConnections(); <line5> processInterestChanges(); <line6> } <line7> for (SelectionKey selectionKey : selector.keys()) { <line8> cleanupSelectionKey(selectionKey); <line9> } <line10> } catch (Throwable t) { <line11> } finally { <line12> TThreadedSelectorServer.this.stop(); <line13> } <line14> } <line15> } <line16> 	"<line11>      LOGGER.error(""run() exiting due to uncaught error"", t);"	task4	
"public class A { <line0> public static int getGroupEntriesCount( <line1> HttpPrincipal httpPrincipal, long groupId, java.util.Date displayDate, int status) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> BlogsEntryServiceUtil.class, <line6> ""getGroupEntriesCount"", <line7> _getGroupEntriesCountParameterTypes14); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, displayDate, status); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	<line17>      log.error(systemException, systemException);	task4	
"public class A { <line0> public String build() { <line1> HiveClientMode clientMode = <line2> HiveClientMode.valueOf(kylinConfig.getHiveClientMode().toUpperCase(Locale.ROOT)); <line3> String beelineShell = kylinConfig.getHiveBeelineShell(); <line4> String beelineParams = kylinConfig.getHiveBeelineParams(); <line5> if (kylinConfig.getEnableSparkSqlForTableOps()) { <line6> clientMode = HiveClientMode.BEELINE; <line7> beelineShell = kylinConfig.getSparkSqlBeelineShell(); <line8> beelineParams = kylinConfig.getSparkSqlBeelineParams(); <line9> if (StringUtils.isBlank(beelineShell)) { <line10> throw new IllegalStateException( <line11> ""Missing config 'kylin.source.hive.sparksql-beeline-shell', please check"" <line12> + "" kylin.properties""); <line13> } <line14> } <line15> StringBuilder buf = new StringBuilder(); <line16> switch (clientMode) { <line17> case CLI: <line18> buf.append(""hive -e \""""); <line19> for (String statement : statements) { <line20> buf.append(statement.replaceAll(""`"", ""\\\\`"")).append(""\n""); <line21> } <line22> buf.append(""\""""); <line23> buf.append(parseProps()); <line24> break; <line25> case BEELINE: <line26> String tmpHqlPath = null; <line27> StringBuilder hql = new StringBuilder(); <line28> try { <line29> tmpHqlPath = ""/tmp/"" + UUID.randomUUID().toString() + "".hql""; <line30> for (String statement : statements) { <line31> hql.append(statement.replaceAll(""`"", ""\\\\`"")); <line32> hql.append(""\n""); <line33> } <line34> String createFileCmd = <line35> String.format(Locale.ROOT, CREATE_HQL_TMP_FILE_TEMPLATE, tmpHqlPath, hql); <line36> buf.append(createFileCmd); <line37> buf.append(""\n""); <line38> buf.append(beelineShell); <line39> buf.append("" ""); <line40> buf.append(beelineParams); <line41> buf.append(parseProps()); <line42> buf.append("" -f ""); <line43> buf.append(tmpHqlPath); <line44> buf.append("";ret_code=$?;rm -f ""); <line45> buf.append(tmpHqlPath); <line46> buf.append("";exit $ret_code""); <line47> } finally { <line48> if (tmpHqlPath != null && logger.isDebugEnabled()) { <line49> } <line50> } <line51> break; <line52> default: <line53> throw new IllegalArgumentException(""Hive client cannot be recognized: "" + clientMode); <line54> } <line55> return buf.toString(); <line56> } <line57> } <line58> "	"<line49>            logger.debug(""The SQL to execute in beeline: {} \n"", hql);"	task4	
public class A { <line0> @Override <line1> public void atBeforeInvoke(Class<?> clazz, String invokeInfo, Object target) { <line2> ClassLoader classLoader = clazz.getClassLoader(); <line3> String[] info = splitInvokeInfo(invokeInfo); <line4> String owner = info[0]; <line5> String methodName = info[1]; <line6> String methodDesc = info[2]; <line7> List<AdviceListener> listeners = <line8> AdviceListenerManager.queryTraceAdviceListeners( <line9> classLoader, clazz.getName(), owner, methodName, methodDesc); <line10> if (listeners != null) { <line11> for (AdviceListener adviceListener : listeners) { <line12> try { <line13> if (skipAdviceListener(adviceListener)) { <line14> continue; <line15> } <line16> final InvokeTraceable listener = (InvokeTraceable) adviceListener; <line17> listener.invokeBeforeTracing( <line18> classLoader, owner, methodName, methodDesc, Integer.parseInt(info[3])); <line19> } catch (Throwable e) { <line20> } <line21> } <line22> } <line23> } <line24> } <line25> 	"<line20>          logger.error(""class: {}, invokeInfo: {}"", clazz.getName(), invokeInfo, e);"	task4	
"public class A { <line0> private static FunctionInvocationWrapper locateFunction( <line1> FunctionCatalog functionCatalog, MediaType contentType) { <line2> String handlerName = System.getenv(""DEFAULT_HANDLER""); <line3> FunctionInvocationWrapper function = <line4> functionCatalog.lookup(handlerName, contentType.toString()); <line5> if (function == null) { <line6> handlerName = System.getenv(""_HANDLER""); <line7> function = functionCatalog.lookup(handlerName, contentType.toString()); <line8> } <line9> if (function == null) { <line10> function = functionCatalog.lookup(null, contentType.toString()); <line11> } <line12> if (function == null) { <line13> handlerName = System.getenv(""spring.cloud.function.definition""); <line14> function = functionCatalog.lookup(handlerName, contentType.toString()); <line15> } <line16> if (function == null) { <line17> function = functionCatalog.lookup(null, contentType.toString()); <line18> } <line19> Assert.notNull( <line20> function, <line21> ""Failed to locate function. Tried locating default function, function by 'DEFAULT_HANDLER',"" <line22> + "" '_HANDLER' env variable as well as'spring.cloud.function.definition'. Functions"" <line23> + "" available in catalog are: "" <line24> + functionCatalog.getNames(null)); <line25> if (function != null && logger.isInfoEnabled()) { <line26> } <line27> return function; <line28> } <line29> } <line30> "	"<line26>      logger.info(""Located function "" + function.getFunctionDefinition());"	task4	
public class A { <line0> @Override <line1> public QueryResult fetchResultSet( <line2> LensSessionHandle sessionHandle, QueryHandle queryHandle, long startIndex, int fetchSize) <line3> throws LensException { <line4> try { <line5> acquire(sessionHandle); <line6> return getResultset(queryHandle).toQueryResult(); <line7> } finally { <line8> release(sessionHandle); <line9> } <line10> } <line11> } <line12> 	"<line5>      log.info(""FetchResultSet: session:{} query:{}"", sessionHandle, queryHandle);"	task4	
"public class A { <line0> private Field accessTaskResultField() { <line1> Field field = null; <line2> try { <line3> field = TaskRunner.class.getDeclaredField(""result""); <line4> field.setAccessible(true); <line5> } catch (Exception e) { <line6> throw new RuntimeException(""Incompatible Hive API found!"", e); <line7> } <line8> return field; <line9> } <line10> } <line11> "	"<line6>      LOG.fatal(""Can't access to TaskResult at "" + TaskRunner.class.getName() + ""!"");"	task4	
"public class A { <line0> private WebImage _getWebImage(JSONObject jsonObject) { <line1> try { <line2> String uuid = jsonObject.getString(""uuid""); <line3> long groupId = jsonObject.getLong(""groupId""); <line4> if (Validator.isNull(uuid) && (groupId == 0)) { <line5> return null; <line6> } <line7> FileEntry fileEntry = _dlAppService.getFileEntryByUuidAndGroupId(uuid, groupId); <line8> WebImage webImage = <line9> new WebImage( <line10> _dlURLHelper.getDownloadURL( <line11> fileEntry, fileEntry.getFileVersion(), null, StringPool.BLANK), <line12> new InfoItemReference( <line13> FileEntry.class.getName(), <line14> new ClassPKInfoItemIdentifier(fileEntry.getFileEntryId()))); <line15> webImage.setAlt(jsonObject.getString(""alt"")); <line16> return webImage; <line17> } catch (Exception exception) { <line18> if (log.isDebugEnabled()) { <line19> } <line20> } <line21> return null; <line22> } <line23> } <line24> "	<line19>        log.debug(exception, exception);	task4	
public class A { <line0> public JSONObject update(JSONObject event, String version) { <line1> if (this.version != null && versionComparator.compare(this.version, version) > 0) { <line2> return event; <line3> } else { <line4> this.version = version; <line5> } <line6> boolean validForCurrentNode; <line7> try { <line8> validForCurrentNode = <line9> Arrays.binarySearch( <line10> senseiCore.getPartitions(), shardingStrategy.caculateShard(maxPartition, event)) <line11> >= 0; <line12> } catch (JSONException e) { <line13> throw new RuntimeException(e); <line14> } <line15> for (PluggableSearchEngine pluggableSearchEngine : pluggableEngines) { <line16> if (pluggableSearchEngine.acceptEventsForAllPartitions() || validForCurrentNode) { <line17> try { <line18> event = pluggableSearchEngine.acceptEvent(event, version); <line19> } catch (Exception ex) { <line20> } <line21> } <line22> } <line23> return event; <line24> } <line25> } <line26> 	<line20>          logger.error(ex.getMessage(), ex);	task4	
"public class A { <line0> protected void updateNestedPortletLayoutTypeSettings() throws Exception { <line1> try (PreparedStatement preparedStatement = <line2> connection.prepareStatement( <line3> ""select plid, typeSettings from Layout where typeSettings "" <line4> + ""LIKE '%nested-column-ids%'""); <line5> ResultSet resultSet = preparedStatement.executeQuery()) { <line6> while (resultSet.next()) { <line7> long plid = resultSet.getLong(""plid""); <line8> String typeSettings = resultSet.getString(""typeSettings""); <line9> String oldPortletId = ""_118_INSTANCE_""; <line10> String newPortletId = ""_"" + NestedPortletsPortletKeys.NESTED_PORTLETS + ""_INSTANCE_""; <line11> String newTypeSettings = StringUtil.replace(typeSettings, oldPortletId, newPortletId); <line12> updateLayout(plid, newTypeSettings); <line13> } <line14> } catch (Exception exception) { <line15> if (log.isWarnEnabled()) { <line16> } <line17> } <line18> } <line19> } <line20> "	<line16>        log.warn(exception, exception);	task4	
public class A { <line0> @Override <line1> public boolean isSameFile(FileObject a, FileObject b) { <line2> return a.equals(b); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""isSameFile({},{})"", a, b);"	task4	
public class A { <line0> protected Folder createFolder(long userId, long groupId, long folderId, String name) <line1> throws PortalException { <line2> Folder folder = null; <line3> try { <line4> folder = dlAppLocalService.getFolder(groupId, folderId, name); <line5> } catch (NoSuchFolderException noSuchFolderException) { <line6> if (log.isWarnEnabled()) { <line7> } <line8> folder = <line9> dlAppLocalService.addFolder( <line10> userId, groupId, folderId, name, StringPool.BLANK, new ServiceContext()); <line11> } <line12> _folderIds.add(folder.getFolderId()); <line13> return folder; <line14> } <line15> } <line16> 	<line7>        log.warn(noSuchFolderException, noSuchFolderException);	task4	
"public class A { <line0> @Override <line1> public void write(int address, int value) { <line2> PinDefinition pinDef = getPin(address); <line3> if (pinDef.getMode() == ""OUTPUT"") { <line4> if (value == 0) { <line5> writeRegister = directionRegister &= ~(1 << address); <line6> } else { <line7> writeRegister = directionRegister |= (1 << address); <line8> } <line9> } else { <line10> } <line11> writeRegister(writeRegister); <line12> pinDef.setValue(value); <line13> } <line14> } <line15> "	"<line10>      log.error(""Can't write to a pin in input mode. Change direction to OUTPUT ({}) with pinMode first."",OUTPUT);"	task4	
public class A { <line0> @Override <line1> public boolean isEnabled(long companyId) { <line2> try { <line3> OpenIdConnectConfiguration openIdConfiguration = <line4> _configurationProvider.getConfiguration( <line5> OpenIdConnectConfiguration.class, <line6> new CompanyServiceSettingsLocator(companyId, OpenIdConnectConstants.SERVICE_NAME)); <line7> return openIdConfiguration.enabled(); <line8> } catch (ConfigurationException configurationException) { <line9> } <line10> return false; <line11> } <line12> } <line13> 	"<line9>      log.error(StringBundler.concat(""Unable to get OpenId configuration for company "",companyId,"": "",configurationException.getMessage()),configurationException);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> if (!initialized.get()) { <line3> throw new IllegalStateException( <line4> ""SimpleTaskScheduler initialization"" + "" is not yet finished!""); <line5> } <line6> while (initialized.get()) { <line7> Queue<JobInProgress> queue = queueManager.get().findQueue(WAIT_QUEUE); <line8> if (null == queue) { <line9> throw new NullPointerException(WAIT_QUEUE + "" does not exist.""); <line10> } <line11> JobInProgress job = queue.removeJob(); <line12> queueManager.get().addJob(PROCESSING_QUEUE, job); <line13> schedule(job); <line14> } <line15> } <line16> } <line17> "	"<line9>        LOG.error(WAIT_QUEUE + "" does not exist."");"	task4	
public class A { <line0> private void runCli(final CliArguments arguments, final DataCleanerConfiguration configuration) { <line1> int exitCode = 0; <line2> try (CliRunner runner = new CliRunner(arguments)) { <line3> runner.run(configuration); <line4> } catch (final Throwable e) { <line5> exitCode = 1; <line6> } finally { <line7> exitCommandLine(configuration, exitCode); <line8> } <line9> } <line10> } <line11> 	"<line5>      logger.error(""Error occurred while running DataCleaner command line mode"", e);"	task4	
public class A { <line0> @Override <line1> public boolean verifyJarSignature(String certificateDirectory, Path jarFilePath) { <line2> Set<Certificate> ordinaryCertificates = <line3> readCertificates(certificateDirectory, certificateSuffix, certificatePrefixes); <line4> for (Certificate certificate : ordinaryCertificates) { <line5> try { <line6> verifyJarSignature(certificate, jarFilePath); <line7> return true; <line8> } catch (SecurityException | IOException e) { <line9> } <line10> } <line11> return false; <line12> } <line13> } <line14> 	"<line9>        LOG.debug(""Certificate is not appropriate."" + UpdaterUtil.getStringRepresentation(certificate));"	task4	
public class A { <line0> @Override <line1> public void sessionRemoved(ServerSession session, boolean timedout) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	"<line3>      LOG.debug(""sessionRemoved: ""+ session.getId()+ "" timedout:""+ timedout+ "" channels: ""+ channelsAsString(session.getSubscriptions()));"	task4	
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> writeJsonResponse(ctx, INTERNAL_SERVER_ERROR, INTERNAL_SERVER_ERROR_RESPONSE); <line3> } <line4> } <line5> 	"<line2>    logger.error(""Exception in API http handler"", cause);"	task4	
public class A { <line0> private void startDownload() { <line1> port.clearModemDB(); <line2> lastMessageTimestamp = System.currentTimeMillis(); <line3> messageCount = 0; <line4> getFirstLinkRecord(); <line5> } <line6> } <line7> 	"<line1>    logger.trace(""starting modem database download"");"	task4	
public class A { <line0> @Override <line1> protected void doStartUp() throws Exception { <line2> super.doStartUp(); <line3> String backfillComplete = <line4> TransactionRunners.run( <line5> transactionRunner, <line6> (TxCallable<String>) <line7> context -> <line8> AppMetadataStore.create(context) <line9> .retrieveSubscriberState( <line10> getTopicId().getTopic(), BACKFILL_SUBSCRIBER_NAME)); <line11> if (backfillComplete != null) { <line12> didBackfill = true; <line13> } <line14> } <line15> } <line16> 	"<line12>      LOG.debug(""Plugin metadata back-fill was completed during a previous startup, skipping back-fill""+ "" this time."");"	task4	
public class A { <line0> private void copyURLToFile(final String address, final java.io.File fileOnDisk) <line1> throws IOException { <line2> try { <line3> HttpHelper.streamURLToFile(address, fileOnDisk); <line4> } catch (FrameworkException ex) { <line5> } <line6> } <line7> } <line8> 	<line5>      logger.warn(null, ex);	task4	
public class A { <line0> public void writeBucket(NodeId nodeId, GroupId groupId, Bucket bucket) { <line1> Preconditions.checkNotNull(nodeId); <line2> Preconditions.checkNotNull(groupId); <line3> Preconditions.checkNotNull(bucket); <line4> GroupBuilder gb = groupByIid.get(FlowUtils.createGroupPath(nodeId, groupId)); <line5> if (gb != null) { <line6> gb.getBuckets().getBucket().add(bucket); <line7> } else { <line8> throw new IllegalStateException(); <line9> } <line10> } <line11> } <line12> 	"<line8>      LOG.error(""Group {} on node {} does not exist"", groupId, nodeId);"	task4	
public class A { <line0> @Override <line1> public void updateFromPageModelChanged(PageModelChangedEvent event) { <line2> try { <line3> if (event.getOperationCode() != PageModelChangedEvent.UPDATE_OPERATION_CODE) { <line4> return; <line5> } <line6> PageModel model = event.getPageModel(); <line7> String pageModelCode = (null != model) ? model.getCode() : null; <line8> if (null != pageModelCode) { <line9> List<?> utilizers = this.getPageModelUtilizers(pageModelCode); <line10> if (null != utilizers && utilizers.size() > 0) { <line11> this.init(); <line12> } <line13> } <line14> } catch (Throwable t) { <line15> } <line16> } <line17> } <line18> 	"<line15>      logger.error(""Error during refres pages"", t);"	task4	
public class A { <line0> public void setSortByRelevanceFeatureProperty(String relevanceFeatureProperty) { <line1> this.sortByRelevanceFeatureProperty = relevanceFeatureProperty; <line2> } <line3> } <line4> 	"<line1>    LOGGER.debug(""Setting sortByRelevanceFeatureProperty to: {}"", relevanceFeatureProperty);"	task4	
public class A { <line0> @Override <line1> public OAuth2Application remove(Serializable primaryKey) throws NoSuchOAuth2ApplicationException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> OAuth2Application oAuth2Application = <line6> (OAuth2Application) session.get(OAuth2ApplicationImpl.class, primaryKey); <line7> if (oAuth2Application == null) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> throw new NoSuchOAuth2ApplicationException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(oAuth2Application); <line13> } catch (NoSuchOAuth2ApplicationException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	<line9>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
"public class A { <line0> private void setClientCache(ClientCache clientCache) { <line1> DistributionConfig config; <line2> ClusterManagementServiceInfo cmsInfo; <line3> List<InetSocketAddress> locators = clientCache.getDefaultPool().getLocators(); <line4> if (locators.size() == 0) { <line5> throw new IllegalStateException( <line6> ""the client needs to have a client pool connected with a locator.""); <line7> } <line8> config = ((GemFireCacheImpl) clientCache).getSystem().getConfig(); <line9> TcpClient client = <line10> new TcpClient( <line11> SocketCreatorFactory.setDistributionConfig(config) <line12> .getSocketCreatorForComponent(SecurableCommunicationChannel.LOCATOR), <line13> InternalDataSerializer.getDSFIDSerializer().getObjectSerializer(), <line14> InternalDataSerializer.getDSFIDSerializer().getObjectDeserializer(), <line15> TcpSocketFactory.DEFAULT); <line16> cmsInfo = null; <line17> for (InetSocketAddress locator : locators) { <line18> try { <line19> cmsInfo = <line20> (ClusterManagementServiceInfo) <line21> client.requestToServer( <line22> new HostAndPort(locator.getHostString(), locator.getPort()), <line23> new ClusterManagementServiceInfoRequest(), <line24> 1000, <line25> true); <line26> if (cmsInfo.isRunning()) { <line27> break; <line28> } <line29> } catch (Exception e) { <line30> } <line31> } <line32> if (cmsInfo == null || !cmsInfo.isRunning()) { <line33> throw new IllegalStateException( <line34> ""Unable to discover a locator that has ClusterManagementService running.""); <line35> } <line36> configureBuilder(config, cmsInfo); <line37> } <line38> } <line39> "	"<line30>        logger.warn(""unable to discover the ClusterManagementService on locator "" + locator.toString());"	task4	
public class A { <line0> @Override <line1> public boolean login() throws LoginException { <line2> tokenProvider = getTokenProvider(); <line3> if (tokenProvider == null) { <line4> return false; <line5> } <line6> Credentials credentials = getCredentials(); <line7> if (credentials instanceof TokenCredentials) { <line8> TokenCredentials tc = (TokenCredentials) credentials; <line9> TokenAuthentication authentication = <line10> new TokenAuthentication(tokenProvider, getLoginModuleMonitor()); <line11> if (authentication.authenticate(tc)) { <line12> tokenCredentials = tc; <line13> tokenInfo = authentication.getTokenInfo(); <line14> principal = authentication.getUserPrincipal(); <line15> sharedState.put(SHARED_KEY_LOGIN_NAME, tokenInfo.getUserId()); <line16> return true; <line17> } <line18> } <line19> return false; <line20> } <line21> } <line22> 	"<line15>        log.debug(""Login: adding login name to shared state."");"	task4	
public class A { <line0> @Override <line1> public void apply(IgniteInternalFuture<AffinityTopologyVersion> fut) { <line2> if (cctx.kernalContext().isStopping()) return; <line3> if (cacheChangeFailureMsgSent) return; <line4> FinishState finishState0; <line5> synchronized (mux) { <line6> finishState0 = finishState; <line7> } <line8> if (finishState0 == null) { <line9> assert (firstDiscoEvt.type() == EVT_NODE_JOINED && firstDiscoEvt.eventNode().isClient()) <line10> : GridDhtPartitionsExchangeFuture.this; <line11> ClusterNode node = cctx.node(nodeId); <line12> if (node == null) { <line13> if (log.isDebugEnabled()) { <line14> } <line15> return; <line16> } <line17> GridDhtPartitionsFullMessage msg = <line18> createPartitionsMessage( <line19> true, node.version().compareToIgnoreTimestamp(PARTIAL_COUNTERS_MAP_SINCE) >= 0); <line20> msg.rebalanced(rebalanced()); <line21> finishState0 = new FinishState(cctx.localNodeId(), initialVersion(), msg); <line22> } <line23> sendAllPartitionsToNode(finishState0, msg, nodeId); <line24> } <line25> } <line26> 	"<line14>          log.debug(""No node found for nodeId: ""+ nodeId+ "", handling of single message will be stopped: ""+ msg);"	task4	
"public class A { <line0> private void validateTokensParent(@NotNull Tree tokensParent) throws CommitFailedException { <line1> verifyHierarchy(tokensParent.getPath()); <line2> Tree userTree = tokensParent.getParent(); <line3> if (!UserConstants.NT_REP_USER.equals(TreeUtil.getPrimaryTypeName(userTree))) { <line4> throw constraintViolation(68, ""Invalid location of .tokens node.""); <line5> } <line6> String nt = TreeUtil.getPrimaryTypeName(tokensParent); <line7> if (!TOKENS_NT_NAME.equals(nt)) { <line8> } <line9> } <line10> } <line11> "	"<line8>      log.debug(""Unexpected node type of .tokens node {}."", nt);"	task4	
"public class A { <line0> @Override <line1> public Class<?>[] classSearch(String packageName, boolean subpackages) throws SystemException { <line2> try { <line3> String resourceName = packageNameToResourceName(packageName); <line4> URL url = classLoader.getResource(resourceName); <line5> if (url == null) { <line6> JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); <line7> JavaFileManager fm = <line8> compiler.getStandardFileManager(new DiagnosticCollector<JavaFileObject>(), null, null); <line9> Set<JavaFileObject.Kind> kinds = <line10> new HashSet<JavaFileObject.Kind>() { <line11> { <line12> add(JavaFileObject.Kind.CLASS); <line13> } <line14> }; <line15> Iterable<JavaFileObject> iterable; <line16> List<Class<?>> classes = new ArrayList<>(); <line17> iterable = fm.list(StandardLocation.PLATFORM_CLASS_PATH, packageName, kinds, subpackages); <line18> for (JavaFileObject javaFileObject : iterable) { <line19> if (javaFileObject.getKind() == JavaFileObject.Kind.CLASS) { <line20> String name = javaFileObject.getName(); <line21> int start = 0; <line22> if (name.lastIndexOf("".jar/"") != -1) { <line23> start = name.lastIndexOf("".jar/"") + "".jar/"".length(); <line24> } <line25> String clname = name.substring(start); <line26> if (clname.indexOf("".class"") != -1) { <line27> int end = clname.indexOf("".class"") + "".class"".length(); <line28> clname = clname.substring(0, end); <line29> } <line30> clname = resourceNameToClassName(clname); <line31> classes.add(Class.forName(clname)); <line32> } <line33> } <line34> return classes.toArray(new Class<?>[0]); <line35> } else { <line36> return findClasses(packageName).toArray(new Class<?>[0]); <line37> } <line38> } catch (Exception e) { <line39> throw new SystemException(e); <line40> } <line41> } <line42> } <line43> "	<line31>            log.info(clname);	task4	
public class A { <line0> @Override <line1> public void commit() throws SQLException { <line2> if (connection != null && !connection.getAutoCommit()) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> connection.commit(); <line6> } <line7> } <line8> } <line9> 	"<line4>        log.debug(""Committing JDBC Connection ["" + connection + ""]"");"	task4	
"public class A { <line0> protected void dump() { <line1> checkAccess(); <line2> String ts = DateHelper.getTimestampAsFilenameSuffix(new Date()); <line3> String filename = ""projectforgedump_"" + ts + "".xml.gz""; <line4> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line5> try (GZIPOutputStream gzout = new GZIPOutputStream(out)) { <line6> jpaXmlDumpService.dumpToXml(emf, gzout); <line7> } catch (IOException ex) { <line8> throw new RuntimeIOException(ex); <line9> } <line10> DownloadUtils.setDownloadTarget(out.toByteArray(), filename); <line11> } <line12> } <line13> "	"<line1>    log.info(""Administration: Database dump."");"	task4	
public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> Message in = exchange.getIn(); <line3> PullRequest pullRequest = (PullRequest) in.getBody(); <line4> User pullRequestUser = pullRequest.getUser(); <line5> pullRequest.getTitle(); <line6> pullRequest.getHtmlUrl(); <line7> pullRequest.getUser().getLogin(); <line8> pullRequest.getUser().getHtmlUrl(); <line9> } <line10> } <line11> 	"<line9>    LOG.debug(""Got PullRequest ""+ pullRequest.getHtmlUrl()+ "" [""+ pullRequest.getTitle()+ ""] From ""+ pullRequestUser.getLogin());"	task4	
"public class A { <line0> public List<Issue> getIssues( <line1> String project, List<String> labels, String reporter, long lookBackMillis) { <line2> List<Issue> issues = new ArrayList<>(); <line3> StringBuilder jiraQuery = new StringBuilder(); <line4> jiraQuery.append(""project="").append(project); <line5> jiraQuery.append("" and "").append(""reporter IN (\"""").append(reporter).append(""\"")""); <line6> jiraQuery.append("" and "").append(buildQueryOnLabels(labels)); <line7> jiraQuery.append("" and "").append(buildQueryOnCreatedBy(lookBackMillis)); <line8> Iterable<Issue> jiraIssuesIt = <line9> restClient.getSearchClient().searchJql(jiraQuery.toString()).claim().getIssues(); <line10> jiraIssuesIt.forEach(issues::add); <line11> return issues; <line12> } <line13> } <line14> "	"<line11>    LOG.info(""Fetched {} Jira tickets using query - {}"", issues.size(), jiraQuery.toString());"	task4	
public class A { <line0> private Decision checkAppLevelThrottled(String throttleKey, String tier) { <line1> Decision decision = dataHolder.isThrottled(throttleKey); <line2> return decision; <line3> } <line4> } <line5> 	"<line2>    log.debug(""Application Level throttle decision is {} for key:tier {}:{}"",decision.isThrottled(),throttleKey,tier);"	task4	
public class A { <line0> @Override <line1> public void onNext(final SuspendEvent suspendEvent) { <line2> NoopTask.this.stopTask(); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""NoopTask.TaskSuspendHandler.send() invoked."");"	task4	
public class A { <line0> @Override <line1> public void actionDone() { <line2> } <line3> } <line4> 	"<line2>    logger.debug(""[actionDone][already done]{}"", migrationState);"	task4	
public class A { <line0> @Override <line1> public IBond getBond(IAtom atom1, IAtom atom2) { <line2> return super.getBond(atom1, atom2); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting bond for atoms: atom1="" + atom1, "" atom2="" + atom2);"	task4	
public class A { <line0> public void filterAbstractHttpRequest(SubmitContext context, AbstractHttpRequest<?> wsdlRequest) { <line1> if (!wsdlRequest.isStripWhitespaces()) { <line2> return; <line3> } <line4> String content = (String) context.getProperty(BaseHttpRequestTransport.REQUEST_CONTENT); <line5> if (content == null) { <line6> } else { <line7> content = XmlUtils.stripWhitespaces(content); <line8> context.setProperty(BaseHttpRequestTransport.REQUEST_CONTENT, content); <line9> } <line10> } <line11> } <line12> 	"<line6>      log.warn(""Missing request content in context, skipping stripWhitespaces"");"	task4	
public class A { <line0> public String getPortletFooterPaths() { <line1> UnsyncStringWriter unsyncStringWriter = new UnsyncStringWriter(); <line2> PipingServletResponse pipingServletResponse = <line3> new PipingServletResponse(_httpServletResponse, unsyncStringWriter); <line4> for (Portlet portlet : _getPortlets()) { <line5> JSONObject jsonObject = JSONFactoryUtil.createJSONObject(); <line6> try { <line7> PortletJSONUtil.populatePortletJSONObject( <line8> _httpServletRequest, StringPool.BLANK, portlet, jsonObject); <line9> PortletJSONUtil.writeHeaderPaths(pipingServletResponse, jsonObject); <line10> } catch (Exception exception) { <line11> } <line12> } <line13> return unsyncStringWriter.toString(); <line14> } <line15> } <line16> 	"<line11>        log.error(""Unable to write portlet footer paths "" + portlet.getPortletId(), exception);"	task4	
"public class A { <line0> @Test <line1> public void test_02() { <line2> Itree intForest = newItree(markers); <line3> intForest.build(); <line4> Markers queries = createRandomLargeMarkers(chromosome, 10000); <line5> int i = 0; <line6> int totalResults = 0; <line7> for (Marker m : queries) { <line8> totalResults += compareQuery(m, intForest); <line9> Gpr.showMark(i++, 10); <line10> } <line11> Assert.assertTrue(""Not a signle result found in all queries!"", totalResults > 0); <line12> System.err.println(""""); <line13> } <line14> } <line15> "	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> public void report(Integer taskid, Communication communication) { <line1> if (communication.isFinished()) { <line2> return; <line3> } <line4> if (!tasks.containsKey(taskid)) { <line5> tasks.putIfAbsent(taskid, new TaskCommunication(taskid, communication)); <line6> } else { <line7> tasks.get(taskid).report(communication); <line8> } <line9> } <line10> } <line11> 	"<line5>      LOG.warn(""unexpected: taskid({}) missed."", taskid);"	task4	
"public class A { <line0> private void verbosePrintAllProjects() { <line1> if (options.isVerbose()) { <line2> Set<? extends ProjectConfigSnapshot> projects = workspaceManager.getProjectConfigs(); <line3> int maxPrjNameLength = <line4> projects.stream() <line5> .filter(p -> p.getName() != null) <line6> .mapToInt(p -> p.getName().length()) <line7> .max() <line8> .orElse(10); <line9> String prjNameWithPadding = ""%-"" + maxPrjNameLength + ""s""; <line10> if (!projects.isEmpty()) { <line11> Path workspace = options.getDir().toPath(); <line12> SortedMap<String, String> projectNameList = new TreeMap<>(); <line13> for (ProjectConfigSnapshot prj : projects) { <line14> String prjName = prj.getName() == null ? ""[no_name]"" : prj.getName(); <line15> String locationStr = null; <line16> if (prj.getPath() == null) { <line17> locationStr = ""[no_location]""; <line18> } else { <line19> locationStr = workspace.relativize(URIUtils.toPath(prj.getPath())).toString(); <line20> if (locationStr.isBlank()) { <line21> locationStr = "".""; <line22> } <line23> } <line24> String outputLine = String.format(prjNameWithPadding + "" at %s"", prjName, locationStr); <line25> projectNameList.put(locationStr, outputLine); <line26> } <line27> } <line28> } <line29> } <line30> } <line31> "	"<line27>        LOG.info(projects.size() + "" projects: \n   "" + String.join(""\n   "", projectNameList.values()));"	task4	
"public class A { <line0> private String _getFieldValuesXMLString(DDMFormInstanceRecord ddmFormInstanceRecord) { <line1> try { <line2> StringBundler sb = new StringBundler(10); <line3> sb.append(""<column><model><model-name>""); <line4> sb.append(""com.liferay.dynamic.data.mapping.model.DDMContent""); <line5> sb.append(""</model-name>""); <line6> DDMFormValuesSerializerSerializeResponse ddmFormValuesSerializerSerializeResponse = <line7> _ddmFormValuesSerializer.serialize( <line8> DDMFormValuesSerializerSerializeRequest.Builder.newBuilder( <line9> ddmFormInstanceRecord.getDDMFormValues()) <line10> .build()); <line11> JSONObject dataJSONObject = <line12> JSONFactoryUtil.createJSONObject(ddmFormValuesSerializerSerializeResponse.getContent()); <line13> JSONArray fieldValuesJSONArray = dataJSONObject.getJSONArray(""fieldValues""); <line14> fieldValuesJSONArray.forEach( <line15> fieldValue -> { <line16> JSONObject fieldValueJSONObject = (JSONObject) fieldValue; <line17> sb.append(""<column><column-name>""); <line18> sb.append(fieldValueJSONObject.get(""name"")); <line19> sb.append(""</column-name>""); <line20> sb.append(""<column-value><![CDATA[""); <line21> sb.append(fieldValueJSONObject.get(""value"")); <line22> sb.append(""]]></column-value></column>""); <line23> }); <line24> sb.append(""</model></column>""); <line25> return sb.toString(); <line26> } catch (PortalException portalException) { <line27> } <line28> return null; <line29> } <line30> } <line31> "	"<line27>      log.error(""Unable to get field values from dynamic data mapping form ""+ ""instance record ""+ ddmFormInstanceRecord.getFormInstanceRecordId(),portalException);"	task4	
public class A { <line0> private boolean isAcceptableLibrary(File file, Set<String> pathToClassFiles) { <line1> try { <line2> if (file.isDirectory()) { <line3> for (String criteria : pathToClassFiles) { <line4> if (new File(file, criteria).exists()) { <line5> return false; <line6> } <line7> } <line8> } else { <line9> JarFile jar = null; <line10> try { <line11> jar = new JarFile(file); <line12> for (String criteria : pathToClassFiles) { <line13> if (jar.getEntry(criteria) != null) { <line14> return false; <line15> } <line16> } <line17> } finally { <line18> if (jar != null) <line19> try { <line20> jar.close(); <line21> } catch (IOException ignored) { <line22> } <line23> } <line24> } <line25> } catch (IOException e) { <line26> } <line27> return true; <line28> } <line29> } <line30> 	"<line26>      LOG.trace(""IGNORED"", e);"	task4	
"public class A { <line0> @Test <line1> public void serializeWithSingleCustomConnectionTest() { <line2> try { <line3> WorkflowTrace trace = new WorkflowTrace(); <line4> AliasedConnection con = new OutboundConnection(""theAlias"", 1111, ""host1111""); <line5> trace.addConnection(con); <line6> action = new SendAction(new ClientHelloMessage(config)); <line7> action.setConnectionAlias(con.getAlias()); <line8> trace.addTlsAction(action); <line9> StringWriter sw = new StringWriter(); <line10> PrintWriter pw = new PrintWriter(sw); <line11> pw.println(""<workflowTrace>""); <line12> pw.println(""    <OutboundConnection>""); <line13> pw.println(""        <alias>theAlias</alias>""); <line14> pw.println(""        <port>1111</port>""); <line15> pw.println(""        <hostname>host1111</hostname>""); <line16> pw.println(""    </OutboundConnection>""); <line17> pw.println(""    <Send>""); <line18> pw.println(""        <messages>""); <line19> pw.println(""            <ClientHello>""); <line20> pw.println(""                <extensions>""); <line21> pw.println(""                    <ECPointFormat/>""); <line22> pw.println(""                    <EllipticCurves/>""); <line23> pw.println(""                    <SignatureAndHashAlgorithmsExtension/>""); <line24> pw.println(""                    <RenegotiationInfoExtension/>""); <line25> pw.println(""                </extensions>""); <line26> pw.println(""            </ClientHello>""); <line27> pw.println(""        </messages>""); <line28> pw.println(""    </Send>""); <line29> pw.println(""</workflowTrace>""); <line30> pw.close(); <line31> String expected = sw.toString(); <line32> DefaultNormalizeFilter.normalizeAndFilter(trace, config); <line33> String actual = WorkflowTraceSerializer.write(trace); <line34> Assert.assertEquals(expected, actual); <line35> } catch (JAXBException | IOException ex) { <line36> Assert.fail(); <line37> } <line38> } <line39> } <line40> "	<line36>      LOGGER.error(ex.getLocalizedMessage(), ex);	task4	
"public class A { <line0> public final void logRequest(RoutingContext ctx, String tenant) { <line1> Timer.Sample sample = MetricsHelper.getTimerSample(); <line2> StringBuilder mods = new StringBuilder(); <line3> if (modList != null && !modList.isEmpty()) { <line4> for (ModuleInstance mi : modList) { <line5> mods.append("" "").append(mi.getModuleDescriptor().getId()); <line6> } <line7> } <line8> if (logger.isInfoEnabled()) { <line9> } <line10> MetricsHelper.recordCodeExecutionTime(sample, ""ProxyContext.logRequest""); <line11> } <line12> } <line13> "	"<line9>      logger.info(""{} REQ {} {} {} {} {}"",reqId,ctx.request().remoteAddress(),tenant,ctx.request().method(),ctx.request().path(),mods);"	task4	
"public class A { <line0> @Test <line1> @Ignore <line2> public void testInitialization() { <line3> final String[] namespaces = { <line4> ""org.geotools.core"", <line5> ""org.geotools.resources"", <line6> ""org.geotools.referencing"", <line7> ""org.opengis.referencing"" <line8> }; <line9> for (String namespace : namespaces) { <line10> final Logger logger = Logging.getLogger(namespace); <line11> logger.severe(""Don't worry, just a test""); <line12> logger.warning(""This is an imaginary warning""); <line13> logger.config(""Not really configuring anything...""); <line14> logger.fine(""This is a detailed (but useless) message\nWe log this one on two lines!""); <line15> logger.finer(""This is a debug message""); <line16> } <line17> } <line18> } <line19> "	"<line13>      logger.info(""This is a pseudo-information message"");"	task4	
public class A { <line0> protected void notifyCache(String action, HugeType type, List<Id> ids) { <line1> EventHub eventHub; <line2> if (type.isGraph()) { <line3> eventHub = this.params.graphEventHub(); <line4> } else if (type.isSchema()) { <line5> eventHub = this.params.schemaEventHub(); <line6> } else { <line7> return; <line8> } <line9> try { <line10> if (ids == null) { <line11> eventHub.call(Events.CACHE, action, type); <line12> } else { <line13> if (ids.size() == 1) { <line14> eventHub.call(Events.CACHE, action, type, ids.get(0)); <line15> } else { <line16> eventHub.call(Events.CACHE, action, type, ids.toArray()); <line17> } <line18> } <line19> } catch (RejectedExecutionException e) { <line20> } <line21> } <line22> } <line23> 	"<line20>      LOG.warn(""Can't update cache due to EventHub is too busy"");"	task4	
public class A { <line0> private static boolean checkLineContingency( <line1> Contingency contingency, LineContingency element, Network network) { <line2> Line line = network.getLine(element.getId()); <line3> if (line == null <line4> || (element.getVoltageLevelId() != null <line5> && !(element.getVoltageLevelId().equals(line.getTerminal1().getVoltageLevel().getId()) <line6> || element <line7> .getVoltageLevelId() <line8> .equals(line.getTerminal2().getVoltageLevel().getId())))) { <line9> return false; <line10> } <line11> return true; <line12> } <line13> } <line14> 	"<line9>      LOGGER.warn(""Line '{}' of contingency '{}' not found"", element.getId(), contingency.getId());"	task4	
public class A { <line0> private void initDocTypePrefetch(DocumentType docType) { <line1> String docTypeName = docType.getName(); <line2> PrefetchInfo prefetch = docType.getPrefetchInfo(); <line3> if (prefetch != null) { <line4> Set<String> documentTypeFragments = getTypeFragments(docTypeName); <line5> for (String fieldName : prefetch.getFields()) { <line6> String fragment = fieldFragment.get(fieldName); <line7> if (fragment != null) { <line8> if (documentTypeFragments.contains(fragment)) { <line9> addDocTypePrefetchedFragments(docTypeName, Collections.singleton(fragment)); <line10> } <line11> } <line12> } <line13> for (String schemaName : prefetch.getSchemas()) { <line14> Set<String> fragments = schemaFragments.get(schemaName); <line15> if (fragments != null) { <line16> addDocTypePrefetchedFragments(docTypeName, fragments); <line17> } <line18> } <line19> } <line20> addDocTypePrefetchedFragments(docTypeName, getCommonFragmentsPrefetched()); <line21> } <line22> } <line23> 	"<line21>    log.debug(""Fragments for type ""+ docTypeName+ "": ""+ getTypeFragments(docTypeName)+ "", prefetch: ""+ getTypePrefetchedFragments(docTypeName));"	task4	
public class A { <line0> @Override <line1> public void log(String dataSourceName, boolean isForceClosing, long startTimeMilliseconds) { <line2> long cost = getElapsedMilliSeconds(); <line3> } <line4> } <line5> 	"<line3>    LOGGER.info(String.format(""**********DataSource %s has been closed,cost:%s ms.**********"", name, cost));"	task4	
public class A { <line0> @Override <line1> public void configure( <line2> @NonNull VocabCache<T> vocabCache, <line3> @NonNull WeightLookupTable<T> lookupTable, <line4> @NonNull VectorsConfiguration configuration) { <line5> this.vocabCache = vocabCache; <line6> this.lookupTable = lookupTable; <line7> this.configuration = configuration; <line8> this.window = configuration.getWindow(); <line9> this.useAdaGrad = configuration.isUseAdaGrad(); <line10> this.negative = configuration.getNegative(); <line11> this.sampling = configuration.getSampling(); <line12> if (configuration.getNegative() > 0) { <line13> if (((InMemoryLookupTable<T>) lookupTable).getSyn1Neg() == null) { <line14> ((InMemoryLookupTable<T>) lookupTable).setUseHS(configuration.isUseHierarchicSoftmax()); <line15> ((InMemoryLookupTable<T>) lookupTable).setNegative(configuration.getNegative()); <line16> ((InMemoryLookupTable<T>) lookupTable).resetWeights(false); <line17> } <line18> } <line19> this.syn0 = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getSyn0()); <line20> this.syn1 = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getSyn1()); <line21> this.syn1Neg = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getSyn1Neg()); <line22> this.expTable = <line23> new DeviceLocalNDArray( <line24> Nd4j.create( <line25> ((InMemoryLookupTable<T>) lookupTable).getExpTable(), <line26> new long[] {((InMemoryLookupTable<T>) lookupTable).getExpTable().length}, <line27> syn0.get().dataType())); <line28> this.table = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getTable()); <line29> this.variableWindows = configuration.getVariableWindows(); <line30> } <line31> } <line32> 	"<line14>        logger.info(""Initializing syn1Neg..."");"	task4	
"public class A { <line0> @Override <line1> public ArtifactClassesWithMetadata inspectArtifact( <line2> Id.Artifact artifactId, <line3> File artifactFile, <line4> @Nullable ClassLoader parentClassLoader, <line5> Set<PluginClass> additionalPlugins) <line6> throws IOException, InvalidArtifactException { <line7> Path tmpDir = <line8> Paths.get(cConf.get(Constants.CFG_LOCAL_DATA_DIR), cConf.get(Constants.AppFabric.TEMP_DIR)) <line9> .toAbsolutePath(); <line10> Files.createDirectories(tmpDir); <line11> Location artifactLocation = Locations.toLocation(artifactFile); <line12> Path stageDir = Files.createTempDirectory(tmpDir, artifactFile.getName()); <line13> try { <line14> File unpackedDir = <line15> BundleJarUtil.prepareClassLoaderFolder( <line16> artifactLocation, Files.createTempDirectory(stageDir, ""unpacked-"").toFile()); <line17> try (CloseableClassLoader artifactClassLoader = <line18> artifactClassLoaderFactory.createClassLoader(unpackedDir); <line19> PluginInstantiator pluginInstantiator = <line20> new PluginInstantiator( <line21> cConf, <line22> parentClassLoader == null ? artifactClassLoader : parentClassLoader, <line23> Files.createTempDirectory(stageDir, ""plugins-"").toFile(), <line24> false)) { <line25> pluginInstantiator.addArtifact(artifactLocation, artifactId.toArtifactId()); <line26> ArtifactClasses.Builder builder = <line27> inspectApplications( <line28> artifactId, ArtifactClasses.builder(), artifactLocation, artifactClassLoader); <line29> List<MetadataMutation> mutations = new ArrayList<>(); <line30> inspectPlugins( <line31> builder, <line32> artifactFile, <line33> artifactId.toEntityId(), <line34> pluginInstantiator, <line35> additionalPlugins, <line36> mutations); <line37> return new ArtifactClassesWithMetadata(builder.build(), mutations); <line38> } <line39> } catch (EOFException | ZipException e) { <line40> throw new InvalidArtifactException(""Artifact "" + artifactId + "" is not a valid zip file."", e); <line41> } finally { <line42> try { <line43> DirUtils.deleteDirectoryContents(stageDir.toFile()); <line44> } catch (IOException e) { <line45> } <line46> } <line47> } <line48> } <line49> "	"<line45>        LOG.warn(""Exception raised while deleting directory {}"", stageDir, e);"	task4	
public class A { <line0> @Override <line1> public PartitionGroup getMetaPartition(String path) { <line2> PartitionTable partitionTable = getPartitionTable(); <line3> if (partitionTable == null) { <line4> return null; <line5> } <line6> try { <line7> return partitionTable.partitionByPathTime(new PartialPath(path), 0); <line8> } catch (MetadataException e) { <line9> return new PartitionGroup(); <line10> } <line11> } <line12> } <line13> 	"<line9>      LOGGER.error(""The storage group of path {} doesn't exist."", path, e);"	task4	
"public class A { <line0> public static com.liferay.commerce.product.model.CPOption fetchCPOption( <line1> HttpPrincipal httpPrincipal, long cpOptionId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(CPOptionServiceUtil.class, ""fetchCPOption"", _fetchCPOptionParameterTypes3); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, cpOptionId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.commerce.product.model.CPOption) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static com.liferay.commerce.account.model.CommerceAccount getPersonalCommerceAccount( <line1> HttpPrincipal httpPrincipal, long userId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceAccountServiceUtil.class, <line7> ""getPersonalCommerceAccount"", <line8> _getPersonalCommerceAccountParameterTypes6); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, userId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.account.model.CommerceAccount) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> @Test(expected = RestoreEntryException.class) <line2> public void testTrashParentAndRestoreParentAndBaseModel() throws Exception { <line3> try { <line4> super.testTrashParentAndRestoreParentAndBaseModel(); <line5> } catch (com.liferay.trash.kernel.exception.RestoreEntryException restoreEntryException) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> throw new RestoreEntryException(); <line9> } <line10> } <line11> } <line12> 	<line7>        log.debug(restoreEntryException, restoreEntryException);	task4	
public class A { <line0> private GeneralisedQueryTree<N> getGeneralisedQueryTreeNotContainingNoSequence( <line1> List<GeneralisedQueryTree<N>> queue) { <line2> GeneralisedQueryTree<N> genTree; <line3> for (int i = 0; i < queue.size(); i++) { <line4> genTree = queue.get(i); <line5> boolean containsNoSequence = false; <line6> for (List<QueryTreeChange> seq : noSequences) { <line7> if (genTree.getChanges().containsAll(seq)) { <line8> containsNoSequence = true; <line9> break; <line10> } <line11> } <line12> if (!containsNoSequence) { <line13> return queue.remove(i); <line14> } <line15> } <line16> return queue.remove(0); <line17> } <line18> } <line19> 	"<line8>          logger.info(""Skipping sequence from queue ""+ genTree.getChanges()+ "" because it contains NO sequence""+ seq);"	task4	
"public class A { <line0> public void callWorkflowEngine( <line1> RequestClientParameter requestClientParameter, String orchestrationUri) <line2> throws WorkflowEngineConnectionException { <line3> try { <line4> camundaClient.post(requestClientParameter, orchestrationUri); <line5> } catch (ApiException e) { <line6> throw new WorkflowEngineConnectionException(""Error Calling Workflow Engine"", e); <line7> } <line8> } <line9> } <line10> "	"<line6>      logger.error(""Error Calling Workflow Engine"", e);"	task4	
"public class A { <line0> public Map<String, Object> createCustomSource(String sourceName) throws Exception { <line1> checkStarted(); <line2> String response = <line3> callApi( <line4> HttpMethod.POST, <line5> ""/ws/org/sources/form_create"", <line6> ""{service_type: \""custom\"", name: \"""" + sourceName + ""\""}""); <line7> response = <line8> ""{"" <line9> + ""\""id\"":\""FAKE_ID\"","" <line10> + ""\""acces_token\"":\""FAKE_TOKEN\"","" <line11> + ""\""key\"":\""FAKE_KEY\"""" <line12> + ""}""; <line13> JsonMapper mapper = JsonMapper.builder().build(); <line14> Map<String, Object> map = mapper.readValue(response, Map.class); <line15> return map; <line16> } <line17> } <line18> "	"<line15>    logger.debug(""Source [{}] created. id={}, acces_token={}, key={}"",sourceName,map.get(""id""),map.get(""accessToken""),map.get(""key""));"	task4	
public class A { <line0> @Override <line1> public long getLiveLogoId() { <line2> long logoId = 0; <line3> Group group = null; <line4> try { <line5> group = getGroup(); <line6> if (!group.isStagingGroup()) { <line7> return logoId; <line8> } <line9> } catch (Exception exception) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> return logoId; <line13> } <line14> Group liveGroup = group.getLiveGroup(); <line15> LayoutSet liveLayoutSet = null; <line16> if (isPrivateLayout()) { <line17> liveLayoutSet = liveGroup.getPrivateLayoutSet(); <line18> } else { <line19> liveLayoutSet = liveGroup.getPublicLayoutSet(); <line20> } <line21> return liveLayoutSet.getLogoId(); <line22> } <line23> } <line24> 	<line11>        log.debug(exception, exception);	task4	
public class A { <line0> public static void unsetOrganizationUsers(long organizationId, long[] userIds) <line1> throws RemoteException { <line2> try { <line3> UserServiceUtil.unsetOrganizationUsers(organizationId, userIds); <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>      log.error(exception, exception);	task4	
"public class A { <line0> public static <T> T getParameter( <line1> HttpServletRequest req, String param, Class<? extends T> paramtypes) <line2> throws InvalidParamException { <line3> String[] values = null; <line4> if (paramtypes.isArray() || List.class.isAssignableFrom(paramtypes)) { <line5> values = req.getParameterValues(param); <line6> } else { <line7> String str = req.getParameter(param); <line8> if (str != null) { <line9> values = new String[1]; <line10> values[0] = str; <line11> } <line12> } <line13> if (values == null || values.length == 0) { <line14> Object value = req.getAttribute(param); <line15> if (value == null) { <line16> HttpSession session = req.getSession(); <line17> value = session.getAttribute(param); <line18> } <line19> if (value == null) { <line20> return null; <line21> } <line22> if (paramtypes.isAssignableFrom(value.getClass())) { <line23> return (T) value; <line24> } else { <line25> if (value instanceof String) { <line26> values = new String[1]; <line27> values[0] = (String) value; <line28> return ValueConverter.conv(values, paramtypes); <line29> } else if (value instanceof String[]) { <line30> return ValueConverter.conv((String[]) value, paramtypes); <line31> } <line32> if (paramtypes.isAssignableFrom(String.class)) { <line33> return (T) value.toString(); <line34> } <line35> MessageResult messageResult = new MessageResult(); <line36> messageResult.setMessage(""""); <line37> messageResult.setStatus(HttpStatus.SC_400_BAD_REQUEST); <line38> throw new InvalidParamException(messageResult); <line39> } <line40> } else { <line41> return ValueConverter.conv(values, paramtypes); <line42> } <line43> } <line44> } <line45> "	"<line35>        log.error(""fail getParameter   [param]""+ param+ ""   [type]""+ paramtypes.getName()+ ""   [value]""+ PropertyUtil.reflectionToString(value));"	task4	
"public class A { <line0> private String getDatabaseScriptsPath() { <line1> DatabaseProductType dbType; <line2> String databaseProductName; <line3> String databaseScriptsPath = """"; <line4> try { <line5> dbType = <line6> JDBCTools.getDatabaseProductType( <line7> JDBCTools.CSADMIN_DATASOURCE_NAME, getServiceConfig().getDbCsadminName()); <line8> databaseProductName = dbType.getName(); <line9> databaseScriptsPath = <line10> getServerRootDir() <line11> + File.separator <line12> + JEEServerDeployment.DATABASE_SCRIPTS_DIR_PATH <line13> + File.separator <line14> + databaseProductName; <line15> } catch (Exception e) { <line16> } <line17> return databaseScriptsPath; <line18> } <line19> } <line20> "	"<line16>      logger.warn(String.format(""Could not get database product type: %s"", e.getMessage()));"	task4	
public class A { <line0> private void loadDefaultDisablingCodes( <line1> String disablingCodesFileName, Map<String, String> disablingCodes) { <line2> try { <line3> String xml = this.extractConfigFile(disablingCodesFileName); <line4> if (null != xml) { <line5> AttributeDisablingCodesDOM dom = new AttributeDisablingCodesDOM(); <line6> disablingCodes.putAll(dom.extractDisablingCodes(xml, disablingCodesFileName)); <line7> } <line8> } catch (Throwable t) { <line9> } <line10> } <line11> } <line12> 	"<line9>      logger.error(""Error loading disabling codes from file {}"", disablingCodesFileName, t);"	task4	
public class A { <line0> private String mapSoftRefValue(AttributeMutationContext ctx, EntityMutationContext context) { <line1> String ret = null; <line2> if (ctx.getValue() instanceof AtlasObjectId) { <line3> AtlasObjectId objectId = (AtlasObjectId) ctx.getValue(); <line4> String typeName = objectId.getTypeName(); <line5> String guid = <line6> AtlasTypeUtil.isUnAssignedGuid(objectId.getGuid()) <line7> ? context.getGuidAssignments().get(objectId.getGuid()) <line8> : objectId.getGuid(); <line9> ret = AtlasEntityUtil.formatSoftRefValue(typeName, guid); <line10> } else { <line11> if (ctx.getValue() != null) { <line12> } <line13> } <line14> setAssignedGuid(ctx.getValue(), context); <line15> return ret; <line16> } <line17> } <line18> 	"<line12>        LOG.warn(""mapSoftRefValue: Was expecting AtlasObjectId, but found: {}"",ctx.getValue().getClass());"	task4	
public class A { <line0> public boolean isNotAnalyzed(String name) { <line1> VitamDescriptionType description = vitamDescriptionResolver.resolve(name); <line2> if (description != null) { <line3> return !description.getType().equals(VitamDescriptionType.VitamType.text); <line4> } <line5> OntologyModel ontologyModel = ontologyModelsByName.get(name); <line6> if (ontologyModel != null) { <line7> return !ontologyModel.getType().isAnalyzed(); <line8> } <line9> return false; <line10> } <line11> } <line12> 	"<line9>    LOGGER.info(String.format(""By default unknown fields are analyzed so here '%s' is ANALYZED."", name));"	task4	
public class A { <line0> public static com.liferay.asset.category.property.model.AssetCategoryPropertySoap[] <line1> getCategoryPropertyValues(long companyId, String key) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.asset.category.property.model.AssetCategoryProperty> returnValue = <line4> AssetCategoryPropertyServiceUtil.getCategoryPropertyValues(companyId, key); <line5> return com.liferay.asset.category.property.model.AssetCategoryPropertySoap.toSoapModels( <line6> returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
public class A { <line0> int read(boolean log) throws Exception { <line1> while (true) { <line2> try { <line3> int d = getCommunications().read(); <line4> if (log) { <line5> } <line6> return d; <line7> } catch (TimeoutException e) { <line8> continue; <line9> } <line10> } <line11> } <line12> } <line13> 	"<line5>          Logger.trace(String.format(""< %02x"", d & 0xff));"	task4	
public class A { <line0> public void rollbackOnError( <line1> Message message, NotificationContext context, StateTransitionError error) { <line2> } <line3> } <line4> 	"<line2>    logger.error(""Default rollback method invoked on error. Error Code: "" + error.getCode());"	task4	
public class A { <line0> @Override <line1> public OrganizationListType transform(Bundle bundle) throws ExchangeTransformException { <line2> try { <line3> return buildOrganization(FHIRTransformHelper.extractFhirOrgResourceList(bundle)); <line4> } catch (Exception ex) { <line5> throw new ExchangeTransformException(ex); <line6> } <line7> } <line8> } <line9> 	"<line5>      LOG.error(""Transforming FHIR data resulted in exception: {}"", ex.getLocalizedMessage(), ex);"	task4	
"public class A { <line0> @Override <line1> public KieApiForm getBpmForm(final Properties properties) <line2> throws ApiException, ApsSystemException { <line3> KieApiForm form = null; <line4> final String configId = properties.getProperty(""configId""); <line5> if (null != configId) { <line6> int widgetInfoId = Integer.parseInt(configId); <line7> final BpmWidgetInfo bpmWidgetInfo = bpmWidgetInfoManager.getBpmWidgetInfo(widgetInfoId); <line8> final String information = bpmWidgetInfo.getInformationOnline(); <line9> if (StringUtils.isNotEmpty(information)) { <line10> final ApsProperties config = new ApsProperties(); <line11> try { <line12> config.loadFromXml(information); <line13> } catch (IOException e) { <line14> } <line15> String containerId = config.getProperty(""containerId""); <line16> String processId = config.getProperty(""processId""); <line17> String sourceId = config.getProperty(""kieSourceId""); <line18> String langCode = properties.getProperty(SystemConstants.API_LANG_CODE_PARAMETER); <line19> KieBpmConfig bpmConfig = kieFormManager.getKieServerConfigurations().get(sourceId); <line20> if (bpmConfig == null) { <line21> String msg = String.format(""Kie server configuration '%s' not found"", sourceId); <line22> throw new ApiException( <line23> IApiErrorCodes.API_VALIDATION_ERROR, msg, Response.Status.CONFLICT); <line24> } <line25> KieProcessFormQueryResult processForm = <line26> this.getKieFormManager().getProcessForm(bpmConfig, containerId, processId); <line27> if (null == processForm) { <line28> String msg = <line29> String.format( <line30> ""No form found with containerId %s and processId %s does not exist"", <line31> containerId, processId); <line32> throw new ApiException( <line33> IApiErrorCodes.API_VALIDATION_ERROR, msg, Response.Status.CONFLICT); <line34> } <line35> this.setLabels(processForm, langCode); <line36> form = <line37> KieApiUtil.createForm( <line38> processForm, <line39> this.getI18nManager(), <line40> langCode, <line41> this.getFormOverridesMap(widgetInfoId)); <line42> form.setProcessId(processId); <line43> form.setContainerId(containerId); <line44> } <line45> } <line46> return form; <line47> } <line48> } <line49> "	"<line14>          logger.error(""Error load configuration  {} "", e.getMessage());"	task4	
public class A { <line0> @Override <line1> public void spaceRemoved(SpaceLifeCycleEvent event) { <line2> } <line3> } <line4> 	"<line2>    LOG.debug(""space "" + event.getSpace().getDisplayName() + "" was removed!"");"	task4	
"public class A { <line0> private String getLabelName(String configDetails) throws InsightsCustomException { <line1> Gson gson = new Gson(); <line2> JsonElement jelement = gson.fromJson(configDetails.trim(), JsonElement.class); <line3> JsonObject json = jelement.getAsJsonObject(); <line4> List<String> labelDataValue = null; <line5> try { <line6> String labelData = <line7> json.get(""publish"").getAsJsonObject().get(""data"").getAsString().toUpperCase(); <line8> String labelHealth = <line9> json.get(""publish"").getAsJsonObject().get(""health"").getAsString().toUpperCase(); <line10> if (ValidationUtils.checkLabelNameString(labelData)) { <line11> throw new InsightsCustomException( <line12> ""Invalid data label Name, it should contain only alphanumeric character,underscore &"" <line13> + "" dot""); <line14> } <line15> if (ValidationUtils.checkLabelNameString(labelHealth)) { <line16> throw new InsightsCustomException( <line17> ""Invalid health label Name, it should contain only alphanumeric character,underscore &"" <line18> + "" dot""); <line19> } <line20> labelDataValue = Arrays.asList(labelData.split(MQMessageConstants.ROUTING_KEY_SEPERATOR)); <line21> } catch (Exception e) { <line22> throw new InsightsCustomException(e.getMessage()); <line23> } <line24> return labelDataValue.get(1); <line25> } <line26> } <line27> "	"<line22>      log.error(""Invalid label Name "", e);"	task4	
public class A { <line0> public void releaseMultiUserLock(String firstUser, String secondUser) { <line1> Resource resource = Resource.USER_LOCK; <line2> firstUser = generateResourceName(resource, firstUser); <line3> secondUser = generateResourceName(resource, secondUser); <line4> int compare = firstUser.compareTo(secondUser); <line5> String temp; <line6> if (compare > 0) { <line7> temp = secondUser; <line8> secondUser = firstUser; <line9> firstUser = temp; <line10> } <line11> if (compare == 0) { <line12> manager.writeUnlock(firstUser); <line13> } else { <line14> manager.writeUnlock(firstUser); <line15> manager.writeUnlock(secondUser); <line16> } <line17> if (LOG.isDebugEnabled()) { <line18> } <line19> lockSet.set(resource.clearLock(lockSet.get())); <line20> } <line21> } <line22> 	"<line18>      LOG.debug(""Release Write {} lock on resource {} and {}"", resource.name, firstUser, secondUser);"	task4	
"public class A { <line0> public void testReceivedMessageNotInFlightAfterScheduledAckFires() throws Exception { <line1> connection.setOptimizedAckScheduledAckInterval(TimeUnit.SECONDS.toMillis(10)); <line2> connection.start(); <line3> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line4> Queue queue = session.createQueue(""test""); <line5> MessageProducer producer = session.createProducer(queue); <line6> for (int i = 0; i < 10; i++) { <line7> producer.send(session.createTextMessage(""Hello"" + i)); <line8> } <line9> MessageConsumer consumer = session.createConsumer(queue); <line10> ArtemisBrokerWrapper broker = <line11> (ArtemisBrokerWrapper) ArtemisBrokerHelper.getBroker().getBroker(); <line12> Binding binding = broker.getServer().getPostOffice().getBinding(new SimpleString(""test"")); <line13> final QueueImpl coreQueue = (QueueImpl) binding.getBindable(); <line14> assertTrue( <line15> ""prefetch full"", <line16> Wait.waitFor( <line17> new Wait.Condition() { <line18> @Override <line19> public boolean isSatisified() throws Exception { <line20> return 10 == coreQueue.getDeliveringCount(); <line21> } <line22> })); <line23> for (int i = 0; i < 6; i++) { <line24> javax.jms.Message msg = consumer.receive(4000); <line25> assertNotNull(msg); <line26> assertEquals(""all prefetch is still in flight: "" + i, 10, coreQueue.getDeliveringCount()); <line27> } <line28> for (int i = 6; i < 10; i++) { <line29> javax.jms.Message msg = consumer.receive(4000); <line30> assertNotNull(msg); <line31> assertTrue( <line32> ""most are acked but 3 remain"", <line33> Wait.waitFor( <line34> new Wait.Condition() { <line35> @Override <line36> public boolean isSatisified() throws Exception { <line37> return 3 == coreQueue.getDeliveringCount(); <line38> } <line39> })); <line40> } <line41> assertTrue( <line42> ""After delay the scheduled ack should ack all inflight."", <line43> Wait.waitFor( <line44> new Wait.Condition() { <line45> @Override <line46> public boolean isSatisified() throws Exception { <line47> return 0 == coreQueue.getDeliveringCount(); <line48> } <line49> })); <line50> } <line51> } <line52> "	"<line47>                LOG.info(""inflight count: "" + coreQueue.getDeliveringCount());"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> if (portPublisher == null) { <line3> } <line4> if (portPublisher != null && portPublisher.isConnected()) { <line5> connectLight.setIcon(Util.getImageIcon(""green.png"")); <line6> ports.setEnabled(false); <line7> connect.setText(""disconnect""); <line8> ports.setSelectedItem(portPublisher.getPortName()); <line9> } else { <line10> connectLight.setIcon(Util.getImageIcon(""red.png"")); <line11> ports.setEnabled(true); <line12> connect.setText(""connect""); <line13> } <line14> } <line15> } <line16> "	"<line3>      log.info(""here"");"	task4	
public class A { <line0> protected void printSummary(Message message, long batchId, int size) { <line1> long memsize = 0; <line2> for (Entry entry : message.getEntries()) { <line3> memsize += entry.getHeader().getEventLength(); <line4> } <line5> String startPosition = null; <line6> String endPosition = null; <line7> if (!CollectionUtils.isEmpty(message.getEntries())) { <line8> startPosition = buildPositionForDump(message.getEntries().get(0)); <line9> endPosition = buildPositionForDump(message.getEntries().get(message.getEntries().size() - 1)); <line10> } <line11> SimpleDateFormat format = new SimpleDateFormat(DATE_FORMAT); <line12> } <line13> } <line14> 	<line12>    logger.info(context_format,new Object[] {batchId, size, memsize, format.format(new Date()), startPosition, endPosition});	task4	
public class A { <line0> @Override <line1> public VolumeInstance getInstance(VolumeOrder volumeOrder, CloudStackUser cloudStackUser) <line2> throws FogbowException { <line3> GetVolumeRequest request = <line4> new GetVolumeRequest.Builder().id(volumeOrder.getInstanceId()).build(this.cloudStackUrl); <line5> return doGetInstance(request, cloudStackUser); <line6> } <line7> } <line8> 	<line3>    LOGGER.info(String.format(Messages.Log.GETTING_INSTANCE_S, volumeOrder.getInstanceId()));	task4	
public class A { <line0> public void focus(String locator) { <line1> try { <line2> super.focus(locator); <line3> } catch (Throwable t) { <line4> try { <line5> waitForElementToBeVisible(locator, Constants.DEFAULT_TIMEOUT); <line6> } catch (Throwable e) { <line7> e.printStackTrace(); <line8> } <line9> super.focus(locator); <line10> } <line11> } <line12> } <line13> 	"<line1>    log.info(""Entering: focus"");"	task4	
"public class A { <line0> @Test <line1> public void test14ReadRead() { <line2> test09WriteCreate(); <line3> EntityUtils.filterAndCheck(serviceRead.things(), """", THINGS); <line4> } <line5> } <line6> "	"<line2>    LOGGER.info(""  test14ReadRead"");"	task4	
public class A { <line0> @Override <line1> public void deleteInstance(PublicIpOrder publicIpOrder, CloudStackUser cloudStackUser) <line2> throws FogbowException { <line3> doDeleteInstance(publicIpOrder, cloudStackUser); <line4> } <line5> } <line6> 	<line3>    LOGGER.info(String.format(Messages.Log.DELETING_INSTANCE_S, publicIpOrder.getInstanceId()));	task4	
public class A { <line0> @Override <line1> public void onTccTransactionEnded( <line2> GrpcTccTransactionEndedEvent request, StreamObserver<GrpcAck> responseObserver) { <line3> events.offer(request); <line4> sleep(); <line5> responseObserver.onNext(ALLOW); <line6> responseObserver.onCompleted(); <line7> } <line8> } <line9> 	"<line3>    LOG.info(""Received transaction end event, global tx id: {}"", request.getGlobalTxId());"	task4	
"public class A { <line0> @Override <line1> public void txStarted(String id) { <line2> logDebug(""New transaction '{0}' started by ModeShape..."", id); <line3> String activeTx = TransactionsHolder.activeTransaction(); <line4> if (activeTx != null && !activeTx.equals(id)) { <line5> } <line6> TransactionsHolder.setActiveTxId(id); <line7> connectionForActiveTx(); <line8> } <line9> } <line10> "	<line5>      LOGGER.warn(RelationalProviderI18n.threadAssociatedWithAnotherTransaction,Thread.currentThread().getName(),activeTx,id);	task4	
public class A { <line0> private String generateConsumerInfo( <line1> final SystemRequestDTO consumer, final CloudRequestDTO consumerCloud) { <line2> final StringBuilder sb = new StringBuilder(consumer.getSystemName()); <line3> if (consumerCloud != null) { <line4> sb.append(DOT) <line5> .append(consumerCloud.getName().trim()) <line6> .append(DOT) <line7> .append(consumerCloud.getOperator().trim()); <line8> } else { <line9> if (Utilities.isEmpty(ownCloudName)) { <line10> initOwnCloudInfo(); <line11> } <line12> sb.append(DOT).append(ownCloudName).append(DOT).append(ownCloudOperator); <line13> } <line14> return sb.toString().toLowerCase(); <line15> } <line16> } <line17> 	"<line2>    logger.debug(""generateConsumerInfo started..."");"	task4	
"public class A { <line0> public static void main(String[] args) { <line1> Main m = new Main(); <line2> try { <line3> m.parseArgs(args); <line4> m.configure(); <line5> long start = System.nanoTime(); <line6> m.process(); <line7> long end = System.nanoTime(); <line8> } catch (Exception x) { <line9> logger.log(Level.SEVERE, ""Failed to run"", x); <line10> } finally { <line11> m.shutdown(); <line12> System.exit(0); <line13> } <line14> } <line15> } <line16> "	"<line8>      logger.info(String.format(""Took: %6.3f seconds"", (end - start) / NANOS));"	task4	
public class A { <line0> @Override <line1> public void end(final Xid xid, final int flags) throws XAException { <line2> XAResource xaResource = getDelegate(false); <line3> if (ActiveMQXARecoveryLogger.LOGGER.isDebugEnabled()) { <line4> } <line5> try { <line6> xaResource.end(xid, flags); <line7> } catch (XAException e) { <line8> throw check(e); <line9> } <line10> } <line11> } <line12> 	"<line4>      ActiveMQXARecoveryLogger.LOGGER.debug(""end "" + xaResource + "" xid "");"	task4	
public class A { <line0> public ContentRenderizationInfo getBaseRenderizationInfo( <line1> PublicContentAuthorizationInfo authInfo, <line2> String contentId, <line3> long modelId, <line4> String langCode, <line5> UserDetails currentUser, <line6> RequestContext reqCtx) { <line7> ContentRenderizationInfo renderInfo = null; <line8> try { <line9> List<Group> userGroups = <line10> (null != currentUser) <line11> ? this.getAuthorizationManager().getUserGroups(currentUser) <line12> : new ArrayList<>(); <line13> if (authInfo.isUserAllowed(userGroups)) { <line14> Content contentToRender = this.getContentManager().loadContent(contentId, true); <line15> String renderedContent = <line16> this.buildRenderedContent(contentToRender, modelId, langCode, reqCtx); <line17> if (null != renderedContent && renderedContent.trim().length() > 0) { <line18> List<AttributeRole> roles = this.getContentManager().getAttributeRoles(); <line19> renderInfo = <line20> new ContentRenderizationInfo( <line21> contentToRender, renderedContent, modelId, langCode, roles); <line22> } <line23> } <line24> } catch (Throwable t) { <line25> return null; <line26> } <line27> return renderInfo; <line28> } <line29> } <line30> 	"<line25>      logger.error(""Error while rendering content {}"", contentId, t);"	task4	
"public class A { <line0> @Override <line1> public List<Map<String, Object>> getQualysDetail(String resourceId) throws DataException { <line2> Map<String, Object> mustFilter = new HashMap<>(); <line3> mustFilter.put(AssetConstants.INSTANCEID_KEYWORD, resourceId); <line4> try { <line5> return esRepository.getDataFromES( <line6> AssetConstants.AWS_EC2, <line7> Constants.QUALYS_INFO, <line8> mustFilter, <line9> null, <line10> null, <line11> Arrays.asList(""lastVulnScan"", ""totalMemory"", ""account.list.hostAssetAccount.username""), <line12> null); <line13> } catch (Exception e) { <line14> throw new DataException(); <line15> } <line16> } <line17> } <line18> "	"<line14>      LOGGER.error(""Exception in getQualysDetail "", e);"	task4	
public class A { <line0> public void explicitlyActivate(String profileId) { <line1> if (!activatedIds.contains(profileId)) { <line2> activatedIds.add(profileId); <line3> } <line4> } <line5> } <line6> 	"<line2>      logger.debug(""Profile with id: \'"" + profileId + ""\' has been explicitly activated."");"	task4	
"public class A { <line0> private void upgrade(UAVHttpMessage data) { <line1> Map<String, String> upgradeInfo = data.getRequest(); <line2> String rootDir = this.getConfigManager().getContext(IConfigurationManager.ROOT); <line3> String profileName = this.getConfigManager().getContext(IConfigurationManager.PROFILENAME); <line4> String upgrade_profile = null; <line5> if (profileName.contains(""pro"")) { <line6> upgrade_profile = ""upgrade_pro""; <line7> } else if (profileName.contains(""test"")) { <line8> upgrade_profile = ""upgrade_test""; <line9> } else { <line10> upgrade_profile = ""upgrade""; <line11> } <line12> StringBuffer sbf = <line13> new StringBuffer().append(""cd "").append(Paths.get(rootDir, ""bin"").toString()); <line14> if (JVMToolHelper.isWindows()) { <line15> sbf.append("" && wscript start_upgrade.vbs ""); <line16> } else { <line17> sbf.append("" && sh start_upgrade.sh ""); <line18> } <line19> sbf.append(upgrade_profile + "" ""); <line20> if (JVMToolHelper.isWindows()) { <line21> sbf.append(JSONHelper.toString(upgradeInfo).replace(""\"""", ""'"")); <line22> } else { <line23> sbf.append(""\"""" + JSONHelper.toString(upgradeInfo).replace(""\"""", ""'"") + ""\""""); <line24> } <line25> final String cmd = sbf.toString(); <line26> if (log.isTraceEnable()) { <line27> } <line28> Thread thread = <line29> new Thread( <line30> new Runnable() { <line31> @Override <line32> public void run() { <line33> try { <line34> if (JVMToolHelper.isWindows()) { <line35> RuntimeHelper.exec(5000, ""cmd.exe"", ""/c"", cmd); <line36> } else { <line37> RuntimeHelper.exec(5000, ""sh"", ""-c"", cmd); <line38> } <line39> } catch (Exception e) { <line40> e.printStackTrace(); <line41> return; <line42> } <line43> } <line44> }); <line45> thread.start(); <line46> data.putResponse(""rs"", ""OK""); <line47> } <line48> } <line49> "	"<line27>      log.info(this, ""Will execute cmd: "" + cmd);"	task4	
public class A { <line0> private void shutdownVm() { <line1> VcContext.inVcSessionDo( <line2> new VcSession<Void>() { <line3> @Override <line4> protected Void body() throws Exception { <line5> if (vm.isPoweredOn() <line6> && !vm.shutdownGuest(Constants.VM_FAST_SHUTDOWN_WAITING_SEC * 1000)) { <line7> vm.powerOff(); <line8> } <line9> return null; <line10> } <line11>  <line12> @Override <line13> protected boolean isTaskSession() { <line14> return true; <line15> } <line16> }); <line17> } <line18> } <line19> 	"<line7>              logger.info(""shutdown "" + vm.getName() + "" guest OS failed, power off directly"");"	task4	
public class A { <line0> private synchronized void checkForUpdates() { <line1> if (!forceReload <line2> && (reloadCheckIntervalInMs < 0 <line3> || System.currentTimeMillis() < (lastReloadCheck + reloadCheckIntervalInMs))) { <line4> return; <line5> } <line6> lastReloadCheck = System.currentTimeMillis(); <line7> if (forceReload <line8> || providers.isEmpty() <line9> || providers.stream().anyMatch(ConfigurationProviderState::shouldReload)) { <line10> reload(); <line11> forceReload = false; <line12> } <line13> } <line14> } <line15> 	"<line4>      LOG.debug(""reload not forced and reload check disabled or check interval not yet elapsed"");"	task4	
public class A { <line0> public void consume() throws InterruptedException { <line1> Item item = queue.take(); <line2> } <line3> } <line4> 	"<line2>    LOGGER.info(""Consumer [{}] consume item [{}] produced by [{}]"", name, item.getId(), item.getProducer());"	task4	
"public class A { <line0> public void testLoadPolicy() { <line1> PolicyFactory factory = PolicyFactory.getInstance(); <line2> Policies[] policies = PolicyFactory.Policies.values(); <line3> for (Policies policy : policies) { <line4> if (policy.toString().contains(""CADES"") || policy.toString().contains(""PADES"")) { <line5> } <line6> } <line7> } <line8> } <line9> "	<line5>        logger.info(factory.loadPolicy(policy).toString());	task4	
"public class A { <line0> private IncompleteType readArrayParameterType(SpaceSystem spaceSystem) throws XMLStreamException { <line1> StartElement element = checkStartElementPreconditions(); <line2> String name = readMandatoryAttribute(""name"", element); <line3> ArrayParameterType.Builder typeBuilder = new ArrayParameterType.Builder().setName(name); <line4> IncompleteType incompleteType = new IncompleteType(spaceSystem, typeBuilder); <line5> int dim; <line6> if (hasAttribute(""numberOfDimensions"", element)) { <line7> dim = readIntAttribute(""numberOfDimensions"", element); <line8> typeBuilder.setNumberOfDimensions(dim); <line9> } else { <line10> dim = -1; <line11> } <line12> String refName = readMandatoryAttribute(""arrayTypeRef"", xmlEvent.asStartElement()); <line13> NameReference nr = <line14> new NameReference(refName, Type.PARAMETER_TYPE) <line15> .addResolvedAction( <line16> nd -> { <line17> typeBuilder.setElementType((ParameterType) nd); <line18> }); <line19> incompleteType.addReference(nr); <line20> spaceSystem.addUnresolvedReference(nr); <line21> while (true) { <line22> xmlEvent = xmlEventReader.nextEvent(); <line23> if (isNamedItemProperty()) { <line24> readNamedItemProperty(typeBuilder); <line25> } else if (isStartElementWithName(XTCE_DIMENSION_LIST)) { <line26> List<IntegerValue> dimList = readDimensionList(spaceSystem); <line27> dim = dimList.size(); <line28> typeBuilder.setSize(dimList); <line29> } else if (isEndElementWithName(XTCE_ARRAY_PARAMETER_TYPE)) { <line30> if (dim == -1) { <line31> throw new XMLStreamException( <line32> ""Neither numberOfDimensions (XTCE 1.1) attribute nor "" <line33> + XTCE_DIMENSION_LIST <line34> + "" (XTCE 1.2) element defined for the ArrayParameter "" <line35> + name); <line36> } <line37> return incompleteType; <line38> } else { <line39> logUnknown(); <line40> } <line41> } <line42> } <line43> } <line44> "	<line1>    log.trace(XTCE_ARRAY_PARAMETER_TYPE);	task4	
"public class A { <line0> @SuppressWarnings(""PMD.AvoidCatchingThrowable"") <line1> private void exec(final Deck deck) throws IOException { <line2> final Collection<String> failure = new LinkedList<>(); <line3> for (final Agent agent : this.agents) { <line4> try { <line5> deck.exec(agent); <line6> } catch (final Throwable ex) { <line7> failure.add(agent.getClass().getSimpleName()); <line8> } <line9> } <line10> if (failure.isEmpty()) { <line11> deck.events().create(""success""); <line12> } else { <line13> deck.events().create(String.format(""failed: %s"", failure)); <line14> } <line15> } <line16> } <line17> "	"<line7>        Logger.error(this, ""%s"", ExceptionUtils.getStackTrace(ex));"	task4	
public class A { <line0> @Override <line1> protected void entityDeleted(FlowableEngineEntityEvent event) { <line2> JobEntity jobEntity = getJobEntity(event); <line3> if (jobEntity == null) { <line4> return; <line5> } <line6> if (hasJobEntityExpired(jobEntity)) { <line7> } <line8> } <line9> } <line10> 	<line7>      LOGGER.info(format(Messages.JOB_WITH_ID_AND_TASK_NAME_EXPIRED,jobEntity.getProcessInstanceId(),jobEntity.getElementName()));	task4	
public class A { <line0> @Override <line1> public void openEditorFor(Object o) throws PartInitException { <line2> TodoViewItem selection = (TodoViewItem) o; <line3> CnATreeElement element; <line4> try { <line5> element = <line6> CnAElementHome.getInstance().loadById(MassnahmenUmsetzung.TYPE_ID, selection.getDbId()); <line7> openEditor( <line8> element.getId(), new BSIElementEditorInput(element), BSIElementEditorMultiPage.EDITOR_ID); <line9> } catch (CommandException e) { <line10> ExceptionUtil.log(e, Messages.EditorFactory_2); <line11> } <line12> } <line13> } <line14> 	"<line10>      log.error(""Error while opening editor."", e);"	task4	
public class A { <line0> @Override <line1> protected void jumpToItem(int itemIndex) throws Exception { <line2> synchronized (lock) { <line3> page = itemIndex / pageSize; <line4> current = itemIndex % pageSize; <line5> } <line6> doJumpToPage(itemIndex); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> } <line11> 	"<line8>      logger.debug(""Jumping to page "" + getPage() + "" and index "" + current);"	task4	
public class A { <line0> public org.talend.mdm.webservice.WSStringArray getConceptsInDataCluster( <line1> org.talend.mdm.webservice.WSGetConceptsInDataCluster arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSStringArray _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	"<line2>    LOG.info(""Executing operation getConceptsInDataCluster"");"	task4	
"public class A { <line0> @Override <line1> public void commence( <line2> HttpServletRequest request, <line3> HttpServletResponse response, <line4> AuthenticationException authException) <line5> throws IOException, ServletException { <line6> String ajaxRequestHeader = request.getHeader(""X-Requested-With""); <line7> response.setHeader(""X-Frame-Options"", ""DENY""); <line8> if (""XMLHttpRequest"".equals(ajaxRequestHeader)) { <line9> response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); <line10> } else { <line11> response.sendRedirect(loginPath); <line12> } <line13> } <line14> } <line15> "	"<line11>      LOG.debug(""redirecting to login page loginPath"" + loginPath);"	task4	
public class A { <line0> public static WebSocketServer getInstance(final int fallbackPort) { <line1> if (instance != null) { <line2> return instance; <line3> } <line4> return createInstance(fallbackPort); <line5> } <line6> } <line7> 	"<line4>    LOG.warn(""No instance for WebSocketServer found, creating one with a fallback port: {}"",fallbackPort);"	task4	
"public class A { <line0> public <T extends YamcsService> void addGlobalService( <line1> String name, Class<T> serviceClass, YConfiguration args) <line2> throws ValidationException, InitException { <line3> for (ServiceWithConfig otherService : YAMCS.globalServiceList) { <line4> if (otherService.getName().equals(name)) { <line5> throw new ConfigurationException( <line6> String.format(""A service named '%s' already exists"", name)); <line7> } <line8> } <line9> ServiceWithConfig swc = createService(null, serviceClass.getName(), name, args, true); <line10> swc.service.init(null, name, swc.args); <line11> YAMCS.globalServiceList.add(swc); <line12> ManagementService managementService = ManagementService.getInstance(); <line13> managementService.registerService(null, name, swc.service); <line14> } <line15> } <line16> "	"<line9>    LOG.info(""Loading service {}"", name);"	task4	
public class A { <line0> private SimpleFeatureCollection readGmlFile(File file, CoordinateReferenceSystem targetCRS) <line1> throws IOException, ProjectionException { <line2> try { <line3> return readGmlFile(file, targetCRS, Version.GML3); <line4> } catch (IOException | RuntimeException e) { <line5> } <line6> return readGmlFile(file, targetCRS, Version.GML2); <line7> } <line8> } <line9> 	"<line5>      LOG.info(""Failure reading with GML3 parser. Trying with GML2"");"	task4	
"public class A { <line0> @Override <line1> @Transactional <line2> public void deleteAlert(Alert alert) { <line3> requireNotDisposed(); <line4> requireArgument(alert != null, ""Alert cannot be null.""); <line5> EntityManager em = _emProvider.get(); <line6> deleteEntity(em, alert); <line7> em.flush(); <line8> } <line9> } <line10> "	"<line5>    logger.debug(""Deleting an alert {}."", alert);"	task4	
public class A { <line0> private ComponentConfiguration getComponentDefinition(String pid) { <line1> final Tocd ocd = this.ocds.get(pid); <line2> Map<String, Object> defaultProperties = null; <line3> if (ocd != null) { <line4> try { <line5> defaultProperties = ComponentUtil.getDefaultProperties(ocd, this.ctx); <line6> } catch (Exception e) { <line7> } <line8> } <line9> return new ComponentConfigurationImpl( <line10> pid, ocd, defaultProperties != null ? defaultProperties : new HashMap<>()); <line11> } <line12> } <line13> 	"<line7>        logger.warn(""Failed to get default properties for component: {}"", pid, e);"	task4	
"public class A { <line0> protected String retrieveKieServerId(KieServerState kieServerState) { <line1> String kssServerId = null; <line2> try { <line3> kssServerId = kieServerState.getConfiguration().getConfigItemValue(KIE_SERVER_ID); <line4> } catch (Exception e) { <line5> } <line6> if (kssServerId == null || kssServerId.length() == 0) { <line7> throw new IllegalArgumentException(""Invalid KieServerId: Can not be null or empty.""); <line8> } <line9> return kssServerId; <line10> } <line11> } <line12> "	"<line5>      logger.error(""Failed to retrieve server id from KieServerState"", e);"	task4	
"public class A { <line0> private static DockstoreYaml12 convert11To12(final DockstoreYaml11 dockstoreYaml11) <line1> throws DockstoreYamlException { <line2> final DockstoreYaml12 dockstoreYaml12 = new DockstoreYaml12(); <line3> dockstoreYaml12.setVersion(Version.ONE_TWO.version); <line4> final Service12 service12 = new Service12(); <line5> try { <line6> final YamlService11 service11 = dockstoreYaml11.getService(); <line7> BeanUtils.copyProperties(service12, service11); <line8> final DescriptorLanguageSubclass descriptorLanguageSubclass = <line9> DescriptorLanguageSubclass.convertShortNameStringToEnum(service11.getType()); <line10> service12.setSubclass(descriptorLanguageSubclass); <line11> dockstoreYaml12.setService(service12); <line12> validate(dockstoreYaml12); <line13> return dockstoreYaml12; <line14> } catch (UnsupportedOperationException | InvocationTargetException | IllegalAccessException e) { <line15> final String msg = ""Error converting ; "" + e.getMessage(); <line16> throw new DockstoreYamlException(msg); <line17> } <line18> } <line19> } <line20> "	<line16>      LOG.error(msg, e);	task4	
public class A { <line0> @Override <line1> public void dispose() { <line2> if (controlApiKeyJob != null && !controlApiKeyJob.isCancelled()) { <line3> controlApiKeyJob.cancel(true); <line4> controlApiKeyJob = null; <line5> } <line6> } <line7> } <line8> 	"<line2>    logger.debug(""Disposing weatherunderground bridge handler."");"	task4	
"public class A { <line0> public Map<String, Object> refreshToken(final String refreshToken) { <line1> String requestBodyUrl = StringUtils.EMPTY; <line2> try { <line3> requestBodyUrl = <line4> ""grant_type=refresh_token&refresh_token="" <line5> .concat(URLEncoder.encode(refreshToken, ""UTF-8"")); <line6> return generateAccessToken(requestBodyUrl, oauth2ClientId); <line7> } catch (UnsupportedEncodingException exception) { <line8> return response(false, ""Unexpected Error Occured!!!""); <line9> } <line10> } <line11> } <line12> "	"<line8>      log.error(""Exception in loginProxy: "" + exception.getMessage());"	task4	
"public class A { <line0> protected void assertBroker(InfraConfiguration brokerConfig) { <line1> List<Pod> brokerPods = TestUtils.listBrokerPods(kubernetes, exampleAddressSpace); <line2> assertEquals(1, brokerPods.size()); <line3> Pod broker = brokerPods.stream().findFirst().get(); <line4> ResourceRequirements resources = <line5> broker.getSpec().getContainers().stream() <line6> .filter(container -> container.getName().equals(""broker"")) <line7> .findFirst() <line8> .map(Container::getResources) <line9> .get(); <line10> assertEquals( <line11> new Quantity(brokerConfig.getMemory()), <line12> resources.getLimits().get(""memory""), <line13> ""Broker memory limit incorrect""); <line14> assertEquals( <line15> new Quantity(brokerConfig.getMemory()), <line16> resources.getRequests().get(""memory""), <line17> ""Broker memory requests incorrect""); <line18> if (brokerConfig.getCpu() != null) { <line19> assertEquals( <line20> new Quantity(brokerConfig.getCpu()), <line21> resources.getLimits().get(""cpu""), <line22> ""Broker cpu limit incorrect""); <line23> assertEquals( <line24> new Quantity(brokerConfig.getCpu()), <line25> resources.getRequests().get(""cpu""), <line26> ""Broker cpu requests incorrect""); <line27> } <line28> if (brokerConfig.getBrokerStorage() != null) { <line29> PersistentVolumeClaim brokerVolumeClaim = getBrokerPVCData(broker); <line30> assertEquals( <line31> new Quantity(brokerConfig.getBrokerStorage()), <line32> brokerVolumeClaim.getSpec().getResources().getRequests().get(""storage""), <line33> ""Broker data storage request incorrect""); <line34> } <line35> if (brokerConfig.getBrokerJavaOpts() != null) { <line36> brokerPods.forEach( <line37> pod -> { <line38> ExecutionResultData result = <line39> KubeCMDClient.runOnCluster( <line40> ""exec"", <line41> pod.getMetadata().getName(), <line42> ""-n"", <line43> pod.getMetadata().getNamespace(), <line44> ""ps"", <line45> ""auxww""); <line46> assertTrue(result.getRetCode(), result.getStdOut()); <line47> assertTrue( <line48> result.getStdOut().contains(brokerConfig.getBrokerJavaOpts()), <line49> ""Unable to find expected java opts in process argument list: "" <line50> + result.getStdOut()); <line51> }); <line52> } <line53> if (brokerConfig.getTemplateSpec() != null) { <line54> assertTemplateSpec(broker, brokerConfig.getTemplateSpec()); <line55> } <line56> } <line57> } <line58> "	"<line1>    log.info(""Checking broker infra"");"	task4	
public class A { <line0> public QueryEndpointsResponse queryEndpoints(QueryEndpoints parameters) { <line1> return null; <line2> } <line3> } <line4> 	"<line1>    LOG.info(""Executing operation queryEndpoints"");"	task4	
"public class A { <line0> private void publish(List<MqttMessage> messages, int subscriberQos) throws Exception { <line1> Address dest = <line2> new AddressBuilder() <line3> .withNewMetadata() <line4> .withNamespace(getSharedAddressSpace().getMetadata().getNamespace()) <line5> .withName(AddressUtils.generateAddressMetadataName(getSharedAddressSpace(), MYTOPIC)) <line6> .endMetadata() <line7> .withNewSpec() <line8> .withType(""topic"") <line9> .withAddress(MYTOPIC) <line10> .withPlan(topicPlan()) <line11> .endSpec() <line12> .build(); <line13> resourcesManager.setAddresses(dest); <line14> Builder clientBuilder = <line15> new MqttClientFactory.Builder() <line16> .usernameAndPassword(defaultCredentials) <line17> .mqttConnectionOptions( <line18> options -> { <line19> options.setConnectionTimeout(options.getConnectionTimeout() * 2); <line20> options.setAutomaticReconnect(true); <line21> }); <line22> customizeClient(clientBuilder); <line23> try (IMqttClient client = clientBuilder.create()) { <line24> client.connect(); <line25> List<CompletableFuture<MqttMessage>> receiveFutures = <line26> MqttUtils.subscribeAndReceiveMessages( <line27> client, dest.getSpec().getAddress(), messages.size(), subscriberQos); <line28> List<CompletableFuture<Void>> publishFutures = <line29> MqttUtils.publish(client, dest.getSpec().getAddress(), messages); <line30> int publishCount = MqttUtils.awaitAndReturnCode(publishFutures, 1, TimeUnit.MINUTES); <line31> assertThat(""Incorrect count of messages published"", publishCount, is(messages.size())); <line32> int receivedCount = MqttUtils.awaitAndReturnCode(receiveFutures, 2, TimeUnit.MINUTES); <line33> assertThat(""Incorrect count of messages received"", receivedCount, is(messages.size())); <line34> } <line35> } <line36> } <line37> "	"<line24>      log.info(""Connecting"");"	task4	
public class A { <line0> @Override <line1> public synchronized void run() { <line2> try { <line3> syncContext(true); <line4> while (true) { <line5> processConnectors(); <line6> this.wait(interval); <line7> syncContext(false); <line8> } <line9> } catch (InterruptedException ex) { <line10> } <line11> } <line12> } <line13> 	"<line10>      log.debug(""Monitoring thread was interrupted"", ex);"	task4	
public class A { <line0> public Set<ADAPTER_API_LEVEL> getAdapterAPILevelsByServiceName(String serviceName) { <line1> Set<ADAPTER_API_LEVEL> apiLevels = null; <line2> try { <line3> String sHomeCommunityId = <line4> PropertyAccessor.getInstance() <line5> .getProperty( <line6> NhincConstants.GATEWAY_PROPERTY_FILE, NhincConstants.HOME_COMMUNITY_ID_PROPERTY); <line7> OrganizationType org = <line8> InternalExchangeManager.getInstance().getOrganization(sHomeCommunityId); <line9> apiLevels = getAPILevelsFromOrganization(org, serviceName); <line10> } catch (ExchangeManagerException | PropertyAccessException ex) { <line11> } <line12> return apiLevels; <line13> } <line14> } <line15> 	"<line11>      LOG.error(""Error getting API Level by Service Name: {}"", ex.getLocalizedMessage(), ex);"	task4	
public class A { <line0> public static synchronized LogicalData getData(String dataId) { <line1> LogicalData retVal = DATA.get(dataId); <line2> if (retVal == null) { <line3> } <line4> return retVal; <line5> } <line6> } <line7> 	"<line3>      LOGGER.warn(""Get data "" + dataId + "" is null."");"	task4	
public class A { <line0> public static List<PrincipalName> cryptoRetrieveX509Sans(List<Certificate> certificates) <line1> throws KrbException { <line2> List<PrincipalName> principalNames = new ArrayList<>(); <line3> for (Certificate cert : certificates) { <line4> } <line5> return principalNames; <line6> } <line7> } <line8> 	"<line4>      LOG.info(""Looking for SANs in cert: "" + cert.getTBSCertificate().getSubject());"	task4	
"public class A { <line0> public BoxFolder copyFolder(String folderId, String destinationFolderId, String newName) { <line1> try { <line2> if (folderId == null) { <line3> throw new IllegalArgumentException(""Parameter 'folderId' can not be null""); <line4> } <line5> if (destinationFolderId == null) { <line6> throw new IllegalArgumentException(""Parameter 'destinationFolderId' can not be null""); <line7> } <line8> BoxFolder folderToCopy = new BoxFolder(boxConnection, folderId); <line9> BoxFolder destinationFolder = new BoxFolder(boxConnection, destinationFolderId); <line10> if (newName == null) { <line11> return folderToCopy.copy(destinationFolder).getResource(); <line12> } else { <line13> return folderToCopy.copy(destinationFolder, newName).getResource(); <line14> } <line15> } catch (BoxAPIException e) { <line16> throw new RuntimeException( <line17> String.format( <line18> ""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), <line19> e); <line20> } <line21> } <line22> } <line23> "	"<line2>      LOG.debug(""Copying folder(id={}) to destination_folder(id={}) {}"",folderId,destinationFolderId,newName == null ? """" : "" with new name '"" + newName + ""'"");"	task4	
"public class A { <line0> private static long getMaxLifetimeFromProperty(CacheInfo cacheInfo) { <line1> String lifetimeProp = cacheInfo.getParams().get(""back-expiry""); <line2> if (lifetimeProp != null) { <line3> if (""0"".equals(lifetimeProp)) { <line4> return -1L; <line5> } <line6> long factor = 1; <line7> if (lifetimeProp.endsWith(""m"")) { <line8> factor = JiveConstants.MINUTE; <line9> } else if (lifetimeProp.endsWith(""h"")) { <line10> factor = JiveConstants.HOUR; <line11> } else if (lifetimeProp.endsWith(""d"")) { <line12> factor = JiveConstants.DAY; <line13> } <line14> try { <line15> return Long.parseLong(lifetimeProp.substring(0, lifetimeProp.length() - 1)) * factor; <line16> } catch (NumberFormatException nfe) { <line17> } <line18> } <line19> return CacheFactory.DEFAULT_MAX_CACHE_LIFETIME; <line20> } <line21> } <line22> "	"<line17>        Log.warn(""Unable to parse back-expiry for cache: "" + cacheInfo.getCacheName());"	task4	
public class A { <line0> public void startController() { <line1> if (!conf.shouldStartController()) { <line2> return; <line3> } <line4> ControllerConf conf = getControllerConf(); <line5> controllerStarter = new ControllerStarter(conf); <line6> controllerStarter.start(); <line7> } <line8> } <line9> 	"<line2>      LOGGER.info(""Skipping start controller step. Assumes controller is already started"");"	task4	
public class A { <line0> public static void info(Logger logger, String eventName, String format, Object arg) { <line1> } <line2> } <line3> 	<line1>    logger.info(constructFormatOrMsg(eventName, format), arg);	task4	
"public class A { <line0> protected static void writeInfo(OutputStream stream, String info) { <line1> if (info != null) { <line2> try { <line3> stream.write(info.getBytes()); <line4> stream.write("" "".getBytes()); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> } <line10> "	<line6>        log.error(e, e);	task4	
public class A { <line0> public void awaitUninterruptibly() { <line1> while (true) { <line2> try { <line3> await(); <line4> return; <line5> } catch (final InterruptedException e) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        logger.warn(""Interrupted while waiting for event latch."", e);"	task4	
public class A { <line0> private void deleteControlFromTreeViewer(RisikoMassnahmenUmsetzung massnahme) { <line1> try { <line2> GefaehrdungsUmsetzung parent = (GefaehrdungsUmsetzung) massnahme.getParent(); <line3> if (massnahme instanceof RisikoMassnahmenUmsetzung <line4> && parent instanceof GefaehrdungsUmsetzung) { <line5> RemoveMassnahmeFromGefaherdung command = <line6> new RemoveMassnahmeFromGefaherdung(parent, massnahme); <line7> command = ServiceFactory.lookupCommandService().executeCommand(command); <line8> parent = command.getParent(); <line9> parent.getChildren().remove(massnahme); <line10> GefaehrdungsBaumRoot baumElement = (GefaehrdungsBaumRoot) viewerScenario.getInput(); <line11> baumElement.replaceChild(parent); <line12> viewerScenario.refresh(); <line13> } <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> 	<line15>      LOG.error(e);	task4	
"public class A { <line0> @ExceptionHandler(HttpMediaTypeNotAcceptableException.class) <line1> @ResponseStatus(value = HttpStatus.BAD_REQUEST) <line2> protected ErrorResponse handleHttpMediaTypeNotAcceptableExceptionException( <line3> HttpMediaTypeNotAcceptableException ex) { <line4> return new ViewObjectErrorResponse( <line5> ErrorCode.INVALID_ARGUMENTS, <line6> new InvalidParameterView( <line7> ""Invalid Media Request Type"", <line8> ""required type is application/pdf"", <line9> """", <line10> Objects.toString(ex))); <line11> } <line12> } <line13> "	<line4>    logger.debug(ExceptionUtils.getStackTrace(ex));	task4	
"public class A { <line0> @Override <line1> public void heartbeat( <line2> JobHeartbeatPRequest request, StreamObserver<JobHeartbeatPResponse> responseObserver) { <line3> RpcUtils.call( <line4> LOG, <line5> (RpcUtils.RpcCallableThrowsIOException<JobHeartbeatPResponse>) <line6> () -> { <line7> List<TaskInfo> wireTaskInfoList = Lists.newArrayList(); <line8> for (alluxio.grpc.JobInfo taskInfo : request.getTaskInfosList()) { <line9> try { <line10> wireTaskInfoList.add(new TaskInfo(taskInfo)); <line11> } catch (IOException e) { <line12> } <line13> } <line14> JobWorkerHealth jobWorkerHealth = new JobWorkerHealth(request.getJobWorkerHealth()); <line15> return JobHeartbeatPResponse.newBuilder() <line16> .addAllCommands(mJobMaster.workerHeartbeat(jobWorkerHealth, wireTaskInfoList)) <line17> .build(); <line18> }, <line19> ""heartbeat"", <line20> ""request=%s"", <line21> responseObserver, <line22> request); <line23> } <line24> } <line25> "	"<line12>                  LOG.error(""task info deserialization failed "" + e);"	task4	
public class A { <line0> private long findInterval(final String dateFormat) { <line1> final long max = TimeUnit.DAYS.toMillis(365); <line2> final long step = TimeUnit.SECONDS.toMillis(60); <line3> try { <line4> final SimpleDateFormat format = new SimpleDateFormat(dateFormat); <line5> final long initial = format.parse(format.format(3600)).getTime(); <line6> for (long i = initial; i < max; i += step) { <line7> final long current = format.parse(format.format(i)).getTime(); <line8> if (initial != current) { <line9> return i - initial; <line10> } <line11> } <line12> return max; <line13> } catch (ParseException pex) { <line14> } <line15> return max; <line16> } <line17> } <line18> 	"<line14>      logger.warn("""", pex);"	task4	
public class A { <line0> private void ack(ResponseEvent evt, String answer) { <line1> try { <line2> Response resp = evt.getResponse(); <line3> Dialog dlg = evt.getDialog(); <line4> CSeqHeader cseqHead = (CSeqHeader) resp.getHeader(CSeqHeader.NAME); <line5> Request ack = dlg.createAck(cseqHead.getSeqNumber()); <line6> addSdp(ack, answer); <line7> dlg.sendAck(ack); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> 	"<line9>      log.error(""ack {}"", evt, e);"	task4	
"public class A { <line0> private void printHist(int[] hist, List<Double> target) { <line1> double total = Arrays.stream(hist).sum(); <line2> for (int i = 0; i < hist.length; i++) { <line3> String label = String.valueOf(i + 1); <line4> if (i == hist.length - 1) label += ""+""; <line5> double current = (hist[i] * 100) / total; <line6> String format = String.format(""%.2f"", current); <line7> String error = String.format(""%+.2f"", current - target.get(i)); <line8> } <line9> } <line10> } <line11> "	"<line8>      log.info(""Size {}: {} = {} % (diff: {}%)"", label, hist[i], format, error);"	task4	
"public class A { <line0> @Override <line1> public void transform(DDMFormFieldValue ddmFormFieldValue) throws PortalException { <line2> Value value = ddmFormFieldValue.getValue(); <line3> for (Locale locale : value.getAvailableLocales()) { <line4> String valueString = value.getString(locale); <line5> JSONObject jsonObject = null; <line6> try { <line7> jsonObject = JSONFactoryUtil.createJSONObject(valueString); <line8> } catch (JSONException jsonException) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> continue; <line12> } <line13> FileEntry importedFileEntry = <line14> fetchImportedFileEntry( <line15> _portletDataContext, jsonObject.getLong(""fileEntryId""), jsonObject.getString(""uuid"")); <line16> if (importedFileEntry == null) { <line17> continue; <line18> } <line19> String fileEntryJSON = <line20> toJSON(importedFileEntry, jsonObject.getString(""type""), jsonObject.getString(""alt"")); <line21> value.addString(locale, fileEntryJSON); <line22> StringBundler sb = new StringBundler(4); <line23> sb.append(""//dynamic-element[@type='image']""); <line24> sb.append(""/dynamic-content[contains(text(),""); <line25> sb.append(HtmlUtil.escapeXPathAttribute(valueString)); <line26> sb.append("")]""); <line27> XPath xPath = SAXReaderUtil.createXPath(sb.toString()); <line28> List<Node> imageNodes = xPath.selectNodes(_document); <line29> for (Node imageNode : imageNodes) { <line30> Element imageElement = (Element) imageNode; <line31> imageElement.clearContent(); <line32> imageElement.addCDATA(fileEntryJSON); <line33> } <line34> } <line35> } <line36> } <line37> "	"<line10>          log.debug(""Unable to parse JSON"", jsonException);"	task4	
public class A { <line0> public long getSize() { <line1> return size; <line2> } <line3> } <line4> 	"<line1>    logger.trace(""[{}] getSize() -> {}"", name, size);"	task4	
"public class A { <line0> @Override <line1> public void removeRepository(final Space space, final String alias) { <line2> spaceConfigStorage <line3> .getBatch(space.getName()) <line4> .run( <line5> context -> { <line6> final Optional<org.guvnor.structure.organizationalunit.config.RepositoryInfo> config = <line7> findRepositoryConfig(space.getName(), alias); <line8> try { <line9> OrganizationalUnit orgUnit = <line10> Optional.ofNullable( <line11> organizationalUnitService.getOrganizationalUnit(space.getName())) <line12> .orElseThrow( <line13> () -> <line14> new IllegalArgumentException( <line15> String.format( <line16> ""The given space [%s] does not exist."", space.getName()))); <line17> doRemoveRepository( <line18> orgUnit, <line19> alias, <line20> config, <line21> repo -> repositoryRemovedEvent.fire(new RepositoryRemovedEvent(repo)), <line22> true); <line23> } catch (final Exception e) { <line24> throw new RuntimeException(e); <line25> } <line26> return null; <line27> }); <line28> } <line29> } <line30> "	"<line24>                logger.error(""Error during remove repository"", e);"	task4	
public class A { <line0> private void initViewResolvers(ApplicationContext context) { <line1> this.viewResolvers = null; <line2> if (this.detectAllViewResolvers) { <line3> Map<String, ViewResolver> matchingBeans = <line4> BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, true, false); <line5> if (!matchingBeans.isEmpty()) { <line6> this.viewResolvers = new ArrayList<ViewResolver>(matchingBeans.values()); <line7> OrderComparator.sort(this.viewResolvers); <line8> } <line9> } else { <line10> try { <line11> ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class); <line12> this.viewResolvers = Collections.singletonList(vr); <line13> } catch (NoSuchBeanDefinitionException ex) { <line14> } <line15> } <line16> if (this.viewResolvers == null) { <line17> this.viewResolvers = getDefaultStrategies(context, ViewResolver.class); <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } <line21> } <line22> } <line23> 	"<line19>        logger.debug(""No ViewResolvers found in servlet '"" + getServletName() + ""': using default"");"	task4	
"public class A { <line0> private void updatePageMetatataUpdate( <line1> String pageCode, Date date, String tablename, Connection conn) throws SQLException { <line2> PreparedStatement stat = null; <line3> try { <line4> String query = ""UPDATE "" + tablename + "" SET updatedat = ? WHERE code = ?""; <line5> stat = conn.prepareStatement(query); <line6> stat.setTimestamp(1, new Timestamp(date.getTime())); <line7> stat.setString(2, pageCode); <line8> stat.executeUpdate(); <line9> } catch (Throwable t) { <line10> throw new RuntimeException( <line11> ""Error while updating the page metadata record for table "" <line12> + PageMetadataDraft.TABLE_NAME <line13> + "" and page "" <line14> + pageCode, <line15> t); <line16> } finally { <line17> closeDaoResources(null, stat); <line18> } <line19> } <line20> } <line21> "	"<line10>      logger.error(""Error while updating the page metadata record for table {} and page {}"",PageMetadataDraft.TABLE_NAME,pageCode,t);"	task4	
public class A { <line0> public void moveActiveInstanceToTerminationPendingInstances(String instanceId) { <line1> if (instanceId == null) { <line2> return; <line3> } <line4> synchronized (activeInstances) { <line5> Iterator<InstanceContext> iterator = activeInstances.listIterator(); <line6> while (iterator.hasNext()) { <line7> InstanceContext activeInstance = iterator.next(); <line8> if (activeInstance == null) { <line9> iterator.remove(); <line10> continue; <line11> } <line12> if (instanceId.equals(activeInstance.getId())) { <line13> iterator.remove(); <line14> this.terminatingPending.add(activeInstance); <line15> if (log.isDebugEnabled()) { <line16> } <line17> break; <line18> } <line19> } <line20> } <line21> } <line22> } <line23> 	"<line16>            log.debug(String.format(""Active instance is removed and added to the ""+ ""termination pending instance list. [Instance Id] %s"",instanceId));"	task4	
public class A { <line0> public void closeChannelPool(Location loc) { <line1> try { <line2> GenericObjectPool<Channel> pool = locToChannelPoolMap.get(loc); <line3> if (pool == null) { <line4> return; <line5> } else { <line6> try { <line7> pool.close(); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } finally { <line12> lock.unlock(); <line13> } <line14> } <line15> } <line16> 	"<line9>          LOG.error(""Close channel for location "" + loc + "" error "", e);"	task4	
public class A { <line0> private void handleEntityChangedEvent(EntityChangedMessage message) { <line1> logStatus.setEntityChangedQueueSize(entityChangedQueueSize.decrementAndGet()); <line2> if (message.getEventType() == EntityChangedMessage.Type.DELETE) { <line3> return; <line4> } <line5> EntityType entityType = message.getEntityType(); <line6> if (!subscriptions.containsKey(entityType)) { <line7> return; <line8> } <line9> Entity<?> entity = message.getEntity(); <line10> Set<Property> fields = message.getFields(); <line11> try (PersistenceManager persistenceManager = <line12> PersistenceManagerFactory.getInstance(settings).create()) { <line13> subscriptions.get(entityType).handleEntityChanged(persistenceManager, entity, fields); <line14> } catch (Exception ex) { <line15> } <line16> } <line17> } <line18> 	"<line15>      LOGGER.error(""error handling MQTT subscriptions"", ex);"	task4	
"public class A { <line0> public static void encryptProperties(String location, String[] properties) { <line1> try { <line2> File file = new File(location); <line3> if (file.exists()) { <line4> PropertiesConfiguration config = new PropertiesConfiguration(); <line5> config.setDelimiterParsingDisabled(true); <line6> config.setEncoding(StandardCharsets.UTF_8.name()); <line7> config.load(file); <line8> if (file.getName().equals(""mdm.conf"")) { <line9> dataSourceName = <line10> config.getString(DB_DEFAULT_DATASOURCE) == null <line11> ? StringUtils.EMPTY <line12> : config.getString(DB_DEFAULT_DATASOURCE); <line13> } <line14> updated = false; <line15> for (String property : properties) { <line16> String password = config.getString(property); <line17> if (StringUtils.isNotEmpty(password) && !password.endsWith(Crypt.ENCRYPT)) { <line18> password = Crypt.encrypt(password); <line19> config.setProperty(property, password); <line20> updated = true; <line21> } <line22> } <line23> if (updated) { <line24> config.save(file); <line25> } <line26> } <line27> } catch (Exception e) { <line28> } <line29> } <line30> } <line31> "	"<line28>      LOGGER.error(""Encrypt password in '"" + location + ""' error."", e);"	task4	
public class A { <line0> @Override <line1> public GetResult merge(List<PartitionGetResult> partResults) { <line2> int size = partResults.size(); <line3> List<ServerRow> rowSplits = new ArrayList<ServerRow>(size); <line4> for (int i = 0; i < size; i++) { <line5> rowSplits.add(((PartitionGetRowResult) partResults.get(i)).getRowSplit()); <line6> } <line7> SplitEntry splitEntry = new SplitEntry(); <line8> for (int i = 0; i < size; i++) { <line9> ServerIntDoubleRow row = <line10> (ServerIntDoubleRow) ((PartitionGetRowResult) partResults.get(i)).getRowSplit(); <line11> int fid = (int) row.get(0 + (int) row.getStartCol()); <line12> if (fid != -1) { <line13> int splitIndex = (int) row.get(1 + (int) row.getStartCol()); <line14> float lossGain = (float) row.get(2 + (int) row.getStartCol()); <line15> float leftSumGrad = (float) row.get(3 + (int) row.getStartCol()); <line16> float leftSumHess = (float) row.get(4 + (int) row.getStartCol()); <line17> float rightSumGrad = (float) row.get(5 + (int) row.getStartCol()); <line18> float rightSumHess = (float) row.get(6 + (int) row.getStartCol()); <line19> GradStats curLeftGradStat = new GradStats(leftSumGrad, leftSumHess); <line20> GradStats curRightGradStat = new GradStats(rightSumGrad, rightSumHess); <line21> SplitEntry curSplitEntry = new SplitEntry(fid, splitIndex, lossGain); <line22> curSplitEntry.leftGradStat = curLeftGradStat; <line23> curSplitEntry.rightGradStat = curRightGradStat; <line24> splitEntry.update(curSplitEntry); <line25> } <line26> } <line27> return new GBDTGradHistGetRowResult(ResponseType.SUCCESS, splitEntry); <line28> } <line29> } <line30> 	"<line19>        LOG.info(String.format(""psFunc: the best split after looping a split: fid[%d], fvalue[%d], loss gain[%f]""+ "", leftSumGrad[%f], leftSumHess[%f], rightSumGrad[%f], rightSumHess[%f]"",fid, splitIndex, lossGain, leftSumGrad, leftSumHess, rightSumGrad, rightSumHess));"	task4	
"public class A { <line0> @Override <line1> public String edit() { <line2> try { <line3> IUserProfile userProfile = null; <line4> UserDetails currentUser = this.getCurrentUser(); <line5> Object object = currentUser.getProfile(); <line6> if (null != object && object instanceof IUserProfile) { <line7> userProfile = (IUserProfile) object; <line8> this.checkTypeLabels(userProfile); <line9> } else { <line10> return ""currentUserWithoutProfile""; <line11> } <line12> IUserProfile currentProfile = this.getUserProfile(); <line13> if (null == currentProfile <line14> || !currentProfile.getUsername().equals(currentUser.getUsername())) { <line15> userProfile.disableAttributes( <line16> SystemConstants.USER_PROFILE_ATTRIBUTE_DISABLING_CODE_ON_EDIT); <line17> this.getRequest() <line18> .getSession() <line19> .setAttribute(SESSION_PARAM_NAME_CURRENT_PROFILE, userProfile); <line20> } <line21> } catch (Throwable t) { <line22> return FAILURE; <line23> } <line24> return SUCCESS; <line25> } <line26> } <line27> "	"<line22>      logger.error(""error in edit"", t);"	task4	
public class A { <line0> public static RequestStatus deleteRelease(PortletRequest request, Logger log) { <line1> String releaseId = request.getParameter(PortalConstants.RELEASE_ID); <line2> if (releaseId != null) { <line3> try { <line4> String deleteCommentEncoded = <line5> request.getParameter(PortalConstants.MODERATION_REQUEST_COMMENT); <line6> User user = UserCacheHolder.getUserFromRequest(request); <line7> if (deleteCommentEncoded != null) { <line8> String deleteComment = new String(Base64.getDecoder().decode(deleteCommentEncoded)); <line9> user.setCommentMadeDuringModerationRequest(deleteComment); <line10> } <line11> ComponentService.Iface client = new ThriftClients().makeComponentClient(); <line12> return client.deleteRelease(releaseId, UserCacheHolder.getUserFromRequest(request)); <line13> } catch (TException e) { <line14> } <line15> } <line16> return RequestStatus.FAILURE; <line17> } <line18> } <line19> 	"<line14>        log.error(""Could not delete release from DB"", e);"	task4	
"public class A { <line0> @GetMapping(""featured"") <line1> @ResponseBody <line2> @Deprecated <line3> public List<Object> getFeaturedOccurrences() { <line4> return Lists.newArrayList(); <line5> } <line6> } <line7> "	"<line4>    LOG.warn(""Featured occurrences have been removed."");"	task4	
public class A { <line0> private JavaPairRDD<HoodieKey, HoodieRecordLocation> lookupIndex( <line1> JavaPairRDD<String, String> partitionRecordKeyPairRDD, <line2> final HoodieEngineContext context, <line3> final HoodieTable hoodieTable) { <line4> Map<String, Long> recordsPerPartition = partitionRecordKeyPairRDD.countByKey(); <line5> List<String> affectedPartitionPathList = new ArrayList<>(recordsPerPartition.keySet()); <line6> List<Tuple2<String, BloomIndexFileInfo>> fileInfoList = <line7> loadInvolvedFiles(affectedPartitionPathList, context, hoodieTable); <line8> final Map<String, List<BloomIndexFileInfo>> partitionToFileInfo = <line9> fileInfoList.stream().collect(groupingBy(Tuple2::_1, mapping(Tuple2::_2, toList()))); <line10> JavaRDD<Tuple2<String, HoodieKey>> fileComparisonsRDD = <line11> explodeRecordRDDWithFileComparisons(partitionToFileInfo, partitionRecordKeyPairRDD); <line12> Map<String, Long> comparisonsPerFileGroup = <line13> computeComparisonsPerFileGroup( <line14> recordsPerPartition, partitionToFileInfo, fileComparisonsRDD, context); <line15> int inputParallelism = partitionRecordKeyPairRDD.partitions().size(); <line16> int joinParallelism = Math.max(inputParallelism, config.getBloomIndexParallelism()); <line17> return findMatchingFilesForRecordKeys( <line18> fileComparisonsRDD, joinParallelism, hoodieTable, comparisonsPerFileGroup); <line19> } <line20> } <line21> 	"<line17>    LOG.info(""InputParallelism: ${""+ inputParallelism+ ""}, IndexParallelism: ${""+ config.getBloomIndexParallelism()+ ""}"");"	task4	
public class A { <line0> @Test <line1> public void printLogWhenNoSchema() throws SQLException { <line2> StatusSummary status = StatusSummary.status(Status.NOT_INITIALIZED).build(); <line3> expect(databaseConnectionProvider.getConnection()).andReturn(databaseConnection); <line4> expect(cassandraSchemaService.getStatus()).andReturn(status); <line5> expect(injector.getInstance(NoopServer.class)).andReturn(noopServer); <line6> expectLastCall(); <line7> mocks.replay(); <line8> new ServerFactoryModule.LateInjectionServer(injector, serverConfiguration).createServer(); <line9> mocks.verify(); <line10> } <line11> } <line12> 	"<line6>    logger.error(""Cassandra schema not installed, starting administration services only"");"	task4	
public class A { <line0> @Override <line1> public String getPermanentDirectoryPath() { <line2> String dirPath = super.getPermanentDirectoryPath(); <line3> if (dirPath == null) { <line4> dirPath = <line5> getConfigurationSource() <line6> .getProperty(PROPERTY_DEPRECATED_PERMANENTDIRECTORY, String.class); <line7> if (dirPath != null) { <line8> } <line9> } <line10> return dirPath; <line11> } <line12> } <line13> 	"<line8>        this.logger.warn(""You're using the deprecated [{}] configuration property. You should instead use the ""+ ""newer [{}] one"",PROPERTY_DEPRECATED_PERMANENTDIRECTORY,""environment.permanentDirectory"");"	task4	
public class A { <line0> @Override <line1> public void removeUserFromCache(X509Certificate userCert) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> cache.evict(userCert); <line5> } <line6> } <line7> 	"<line3>      logger.debug(""Cache remove: "" + userCert.getSubjectDN());"	task4	
public class A { <line0> @Override <line1> public void addBooleanField(String fieldName, boolean value) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> m_pdxInstanceFactory.writeBoolean(fieldName, value); <line5> addIdentityField(fieldName); <line6> } <line7> } <line8> 	"<line3>      logger.trace(""addBooleanField fieldName: {}; value: {}"", fieldName, value);"	task4	
"public class A { <line0> public static SAXReader getSAXReader(final EntityResolver resolver) { <line1> SAXReader reader = new SAXReader(); <line2> if (resolver != null) { <line3> reader.setEntityResolver(resolver); <line4> } <line5> try { <line6> reader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true); <line7> reader.setFeature(""http://xml.org/sax/features/external-general-entities"", false); <line8> reader.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false); <line9> reader.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false); <line10> } catch (SAXException e) { <line11> } <line12> reader.setIncludeExternalDTDDeclarations(false); <line13> reader.setIncludeInternalDTDDeclarations(false); <line14> return reader; <line15> } <line16> } <line17> "	"<line11>      logger.error(""Some parser properties are not supported."");"	task4	
public class A { <line0> @Override <line1> public boolean isRegularFile() { <line2> if (file == null) { <line3> return false; <line4> } <line5> boolean isRegularFile = false; <line6> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line7> isRegularFile = file instanceof File; <line8> tx.success(); <line9> } catch (FrameworkException fex) { <line10> } <line11> return isRegularFile; <line12> } <line13> } <line14> 	"<line10>      logger.error("""", fex);"	task4	
public class A { <line0> @Override <line1> public <V> void expire(String key, int ttl) { <line2> try { <line3> _jedisClusterClient.expire(key, ttl); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.error(""Exception in cache service: {} "", ex.getMessage());"	task4	
"public class A { <line0> @PayloadRoot(localPart = ""ActivateOrganisationRequest"", namespace = DEVICE_MANAGEMENT_NAMESPACE) <line1> @ResponsePayload <line2> public ActivateOrganisationResponse activateOrganisation( <line3> @OrganisationIdentification final String organisationIdentification, <line4> @RequestPayload final ActivateOrganisationRequest request) <line5> throws OsgpException { <line6> try { <line7> this.deviceManagementService.activateOrganisation( <line8> organisationIdentification, request.getOrganisationIdentification()); <line9> } catch (final ConstraintViolationException e) { <line10> throw new FunctionalException( <line11> FunctionalExceptionType.VALIDATION_ERROR, <line12> ComponentType.WS_ADMIN, <line13> new ValidationException(e.getConstraintViolations())); <line14> } catch (final TransactionSystemException ex) { <line15> throw new TechnicalException(COMPONENT_TYPE_WS_ADMIN, ex.getApplicationException()); <line16> } catch (final Exception e) { <line17> this.handleException(e); <line18> } <line19> return new ActivateOrganisationResponse(); <line20> } <line21> } <line22> "	"<line6>    LOGGER.info(""Activate organisation: {}."", request.getOrganisationIdentification());"	task4	
public class A { <line0> @Override <line1> public void onResourceChange(TbResource resource, TbQueueCallback callback) { <line2> TenantId tenantId = resource.getTenantId(); <line3> TransportProtos.ResourceUpdateMsg resourceUpdateMsg = <line4> TransportProtos.ResourceUpdateMsg.newBuilder() <line5> .setTenantIdMSB(tenantId.getId().getMostSignificantBits()) <line6> .setTenantIdLSB(tenantId.getId().getLeastSignificantBits()) <line7> .setResourceType(resource.getResourceType().name()) <line8> .setResourceKey(resource.getResourceKey()) <line9> .build(); <line10> ToTransportMsg transportMsg = <line11> ToTransportMsg.newBuilder().setResourceUpdateMsg(resourceUpdateMsg).build(); <line12> broadcast(transportMsg, callback); <line13> } <line14> } <line15> 	"<line3>    log.trace(""[{}][{}][{}] Processing change resource"",tenantId,resource.getResourceType(),resource.getResourceKey());"	task4	
public class A { <line0> @Test <line1> public void test_09() { <line2> ScoreList pvlist = new ScoreList(); <line3> int max = 1000; <line4> for (int i = 0; i < max; i++) { <line5> double quantile = ((double) i) / max; <line6> pvlist.add(quantile); <line7> } <line8> for (int i = 0; i < max; i++) { <line9> double quantile = ((double) i) / max; <line10> double pval = pvlist.cdf(quantile); <line11> Assert.assertEquals(quantile, pval, EPSILON); <line12> } <line13> } <line14> } <line15> 	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> public void register() { <line1> Freedomotic.INJECTOR.injectMembers(this); <line2> listener = new BusMessagesListener(this, busService); <line3> listener.consumeEventFrom(channel); <line4> numberOfExecutions = 0; <line5> suspensionStart = System.currentTimeMillis(); <line6> } <line7> } <line8> 	"<line2>    LOG.info(""Registering the trigger named \""{}\"""", getName());"	task4	
public class A { <line0> @Override <line1> public Collection<S> loadServices(Class<S> service) { <line2> serviceLoaderWrapper.load(service); <line3> Collection<S> services = new ArrayList<>(); <line4> for (Iterator<S> iterator = serviceLoaderWrapper.iterator(); iterator.hasNext(); ) { <line5> try { <line6> S instance = iterator.next(); <line7> services.add(instance); <line8> } catch (ServiceConfigurationError serviceConfigurationError) { <line9> } <line10> } <line11> return services; <line12> } <line13> } <line14> 	"<line9>        logger.error(""Error while loading implementations of {}"",service.getName(),serviceConfigurationError);"	task4	
public class A { <line0> @Override <line1> public long takeSnapshot() throws IOException { <line2> TermIndex lastTermIndex = getLastAppliedTermIndex(); <line3> long lastAppliedIndex = lastTermIndex.getIndex(); <line4> if (!isInitialized) { <line5> return lastAppliedIndex; <line6> } <line7> long startTime = Time.monotonicNow(); <line8> TransactionInfo latestTrxInfo = transactionBuffer.getLatestTrxInfo(); <line9> TransactionInfo lastAppliedTrxInfo = TransactionInfo.fromTermIndex(lastTermIndex); <line10> if (latestTrxInfo.compareTo(lastAppliedTrxInfo) < 0) { <line11> transactionBuffer.updateLatestTrxInfo(lastAppliedTrxInfo); <line12> transactionBuffer.setLatestSnapshot(lastAppliedTrxInfo.toSnapshotInfo()); <line13> } else { <line14> lastAppliedIndex = latestTrxInfo.getTransactionIndex(); <line15> } <line16> transactionBuffer.flush(); <line17> return lastAppliedIndex; <line18> } <line19> } <line20> 	"<line17>    LOG.info(""Current Snapshot Index {}, takeSnapshot took {} ms"",lastAppliedIndex,Time.monotonicNow() - startTime);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> while (!shutdownRequestMade) { <line3> try { <line4> ObjectAndMethod objectAndMethod = <line5> taskQueue.poll(THREAD_SHUTDOWN_CHECK_INTERVAL, TimeUnit.MILLISECONDS); <line6> if (objectAndMethod != null) { <line7> callCorrectMethod(objectAndMethod); <line8> } <line9> } catch (InterruptedException e) { <line10> } <line11> } <line12> ObjectAndMethod objectAndMethod; <line13> while ((objectAndMethod = taskQueue.poll()) != null) { <line14> callCorrectMethod(objectAndMethod); <line15> } <line16> } <line17> } <line18> 	"<line10>        log.warn(""Cache Listener thread interrupted in MultiThreadedListener."", e);"	task4	
public class A { <line0> @Override <line1> public boolean test(Value value) { <line2> if (value == null) { <line3> return false; <line4> } <line5> try { <line6> Matcher matcher = pattern.matcher(value.getString()); <line7> return matcher.matches(); <line8> } catch (RepositoryException e) { <line9> return false; <line10> } <line11> } <line12> } <line13> 	"<line9>      log.warn(""Error checking string constraint "" + this, e);"	task4	
public class A { <line0> public void addNullField(Object fieldValue) { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> list.add(fieldValue); <line4> } <line5> } <line6> 	"<line2>      logger.trace(""addNULLField fieldValue: {}"", fieldValue);"	task4	
public class A { <line0> public static <T> HttpResponse<T> httpRequest( <line1> Logger logger, <line2> String url, <line3> String method, <line4> Object requestBodyData, <line5> TypeReference<T> responseFormat, <line6> int maxTries) <line7> throws IOException, InterruptedException { <line8> IOException exc = null; <line9> for (int tries = 0; tries < maxTries; tries++) { <line10> if (tries > 0) { <line11> Thread.sleep(tries > 1 ? 10 : 2); <line12> } <line13> try { <line14> return httpRequest(logger, url, method, requestBodyData, responseFormat); <line15> } catch (IOException e) { <line16> exc = e; <line17> } <line18> } <line19> throw exc; <line20> } <line21> } <line22> 	"<line16>        logger.info(""{} {}: error: {}"", method, url, e.getMessage());"	task4	
"public class A { <line0> @Test <line1> public void testAssignmentAfterRestarts() throws Exception { <line2> try { <line3> System.setProperty(IGNITE_PDS_CHECKPOINT_TEST_SKIP_SYNC, ""true""); <line4> final int gridsCnt = 5; <line5> final int groupsCnt = 2; <line6> final IgniteEx node = (IgniteEx) startGridsMultiThreaded(gridsCnt); <line7> final List<CacheConfiguration> cfgs = <line8> Arrays.asList( <line9> cacheConfiguration(""g1c1"", TRANSACTIONAL, PARTITIONED, gridsCnt, ""testGrp1""), <line10> cacheConfiguration(""g1c2"", TRANSACTIONAL, PARTITIONED, gridsCnt, ""testGrp1""), <line11> cacheConfiguration(""g2c1"", TRANSACTIONAL, PARTITIONED, gridsCnt, ""testGrp2""), <line12> cacheConfiguration(""g2c2"", TRANSACTIONAL, PARTITIONED, gridsCnt, ""testGrp2"")); <line13> node.getOrCreateCaches(cfgs); <line14> validateDepIds(groupsCnt); <line15> stopAllGrids(); <line16> IgniteEx node2 = (IgniteEx) startGridsMultiThreaded(gridsCnt); <line17> validateDepIds(groupsCnt); <line18> final int restartIdxFrom = 2; <line19> final AtomicInteger idx = new AtomicInteger(restartIdxFrom); <line20> IgniteInternalFuture fut = <line21> GridTestUtils.runMultiThreadedAsync( <line22> new Callable<Void>() { <line23> @Override <line24> public Void call() throws Exception { <line25> int nodeIdx = idx.getAndIncrement(); <line26> stopGrid(nodeIdx); <line27> return null; <line28> } <line29> }, <line30> gridsCnt - restartIdxFrom, <line31> ""stop-node""); <line32> fut.get(); <line33> awaitPartitionMapExchange(); <line34> checkAffinity(); <line35> idx.set(restartIdxFrom); <line36> fut = <line37> GridTestUtils.runMultiThreadedAsync( <line38> new Callable<Void>() { <line39> @Override <line40> public Void call() throws Exception { <line41> int nodeIdx = idx.getAndIncrement(); <line42> startGrid(nodeIdx); <line43> return null; <line44> } <line45> }, <line46> gridsCnt - restartIdxFrom, <line47> ""start-node""); <line48> fut.get(); <line49> awaitPartitionMapExchange(); <line50> AffinityTopologyVersion topVer = <line51> node2.context().cache().context().exchange().readyAffinityVersion(); <line52> checkAffinity(); <line53> } finally { <line54> System.clearProperty(IGNITE_PDS_CHECKPOINT_TEST_SKIP_SYNC); <line55> } <line56> } <line57> } <line58> "	"<line52>      log.info(""Using version: "" + topVer);"	task4	
"public class A { <line0> void deleteMessage(long messageId) { <line1> String sql = <line2> ""delete from "" + MessageShardingUtil.getMessageTable(messageId) + "" where _mid = ?""; <line3> Connection connection = null; <line4> PreparedStatement statement = null; <line5> try { <line6> connection = DBUtil.getConnection(); <line7> statement = connection.prepareStatement(sql); <line8> statement.setLong(1, messageId); <line9> int count = statement.executeUpdate(); <line10> } catch (SQLException e) { <line11> e.printStackTrace(); <line12> Utility.printExecption(LOG, e, RDBS_Exception); <line13> } finally { <line14> DBUtil.closeDB(connection, statement); <line15> } <line16> } <line17> } <line18> "	"<line10>      LOG.info(""Update rows {}"", count);"	task4	
public class A { <line0> public static Pair<Boolean, String> check(final ResourceTO resourceTO) { <line1> boolean check = false; <line2> String errorMessage = null; <line3> try { <line4> getService(ResourceService.class).check(resourceTO); <line5> check = true; <line6> } catch (Exception e) { <line7> errorMessage = e.getMessage(); <line8> } <line9> return Pair.of(check, errorMessage); <line10> } <line11> } <line12> 	"<line7>      LOG.error(""Connector not found {}"", resourceTO.getConnector(), e);"	task4	
"public class A { <line0> private int fetchDataValuesPageSizeFromSystemSettings(final Context context) throws SQLException { <line1> int dataValuesPageSize = 0; <line2> String sql = <line3> ""SELECT value FROM systemsetting WHERE name = '"" + DATA_VALUES_SYNC_PAGE_SIZE_KEY + ""';""; <line4> try (Statement stmt = context.getConnection().createStatement(); <line5> ResultSet rs = stmt.executeQuery(sql); ) { <line6> if (rs.next()) { <line7> dataValuesPageSize = (Integer) SerializationUtils.deserialize(rs.getBytes(""value"")); <line8> } <line9> } <line10> return dataValuesPageSize; <line11> } <line12> } <line13> "	"<line9>      log.info(""Value found in SystemSettings: dataValuePageSize: "" + dataValuesPageSize);"	task4	
public class A { <line0> private void getServerProfileTransformation() { <line1> ServerProfile serverProfile = this.serverProfileClient.getByName(SERVER_PROFILE_NAME).get(0); <line2> String enclosureGroupUri = <line3> enclosureGroupClient <line4> .getByName(EnclosureGroupClientSample.ENCLOSURE_GROUP_NAME) <line5> .get(0) <line6> .getUri(); <line7> ServerProfile serverProfileUpdated = <line8> serverProfileClient.getTransformation( <line9> serverProfile.getResourceId(), <line10> ServerHardwareTypeClientSample.SERVER_HARDWARE_TYPE_URI, <line11> enclosureGroupUri); <line12> } <line13> } <line14> 	"<line12>    LOGGER.info(""ServerProfile object returned to client : "" + serverProfileUpdated.toJsonString());"	task4	
public class A { <line0> @Override <line1> public void updateProcessBusinessKeyInHistory(ExecutionEntity processInstance) { <line2> if (isHistoryEnabled()) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> if (processInstance != null) { <line6> HistoricProcessInstanceEntity historicProcessInstance = <line7> getHistoricProcessInstanceEntityManager().findById(processInstance.getId()); <line8> if (historicProcessInstance != null) { <line9> historicProcessInstance.setBusinessKey(processInstance.getProcessInstanceBusinessKey()); <line10> getHistoricProcessInstanceEntityManager().update(historicProcessInstance, false); <line11> } <line12> } <line13> } <line14> } <line15> } <line16> 	"<line4>        log.debug(""updateProcessBusinessKeyInHistory : {}"", processInstance.getId());"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> Configuration conf = configurationParameter.getConfiguration(); <line3> List<DirectDataSourceProfile> profiles = HadoopDataSourceUtil.loadProfiles(conf); <line4> DirectDataSourceProfile spec = null; <line5> if (id != null) { <line6> spec = <line7> profiles.stream() <line8> .filter(it -> Objects.equal(it.getId(), id)) <line9> .findAny() <line10> .orElseThrow( <line11> () -> <line12> new CommandConfigurationException( <line13> MessageFormat.format( <line14> ""data source \""{0}\"" not found (available data source: {1})"", <line15> id, <line16> profiles.stream() <line17> .map(DirectDataSourceProfile::getId) <line18> .collect(Collectors.joining("", ""))))); <line19> } <line20> try (PrintWriter writer = outputParameter.open()) { <line21> if (spec == null) { <line22> verboseParameter.printf(writer, ""total %,d%n"", profiles.size()); <line23> profiles.forEach( <line24> it -> { <line25> writer.printf(""%s%n"", it.getId()); <line26> verboseParameter.ifRequired(() -> print(writer, it, 4)); <line27> }); <line28> } else { <line29> print(writer, spec, 0); <line30> } <line31> } <line32> } <line33> } <line34> "	"<line2>    LOG.debug(""starting {}"", getClass().getSimpleName());"	task4	
public class A { <line0> public void start() { <line1> super.start(); <line2> executor.scheduleWithFixedDelay( <line3> () -> { <line4> try { <line5> scan(); <line6> if (isFirst) { <line7> isFirst = false; <line8> } <line9> } catch (Throwable e) { <line10> } <line11> }, <line12> 0, <line13> scanIntervalInSecond, <line14> TimeUnit.SECONDS); <line15> } <line16> } <line17> 	"<line10>            logger.error(""scan failed"", e);"	task4	
public class A { <line0> public void debug(Marker marker, String format, Object... argArray) { <line1> if (!logger.isDebugEnabled(marker)) return; <line2> if (instanceofLAL) { <line3> FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray); <line4> ((LocationAwareLogger) logger) <line5> .log( <line6> marker, <line7> fqcn, <line8> LocationAwareLogger.DEBUG_INT, <line9> ft.getMessage(), <line10> argArray, <line11> ft.getThrowable()); <line12> } else { <line13> } <line14> } <line15> } <line16> 	<line13>      logger.debug(marker, format, argArray);	task4	
"public class A { <line0> private void loadCoverageStore( <line1> SingleResourceContents SingleResourceContents, CatalogImpl catalog, XStreamPersister xp) { <line2> CoverageStoreInfo cs = null; <line3> final Resource storeResource = SingleResourceContents.resource; <line4> try { <line5> cs = depersist(xp, SingleResourceContents.contents, CoverageStoreInfo.class); <line6> catalog.add(cs); <line7> if (LOGGER.isLoggable(Level.INFO)) { <line8> } <line9> } catch (Exception e) { <line10> LOGGER.log(Level.WARNING, ""Failed to load coverage store '"" + storeResource.name() + ""'"", e); <line11> return; <line12> } <line13> LayerLoader<CoverageInfo> coverageLoader = new LayerLoader<>(CoverageInfo.class, xp, catalog); <line14> try (AsynchResourceIterator<LayerContents> it = <line15> new AsynchResourceIterator<>( <line16> storeResource.parent(), Resources.DirectoryFilter.INSTANCE, COVERAGE_LAYER_MAPPER)) { <line17> while (it.hasNext()) { <line18> LayerContents lc = it.next(); <line19> coverageLoader.accept(lc); <line20> } <line21> } <line22> } <line23> } <line24> "	"<line8>        LOGGER.info(""Loaded coverage store '""+ cs.getName()+ ""', ""+ (cs.isEnabled() ? ""enabled"" : ""disabled""));"	task4	
"public class A { <line0> private void updateIdentityTypes( <line1> Map<String, EmailConfirmationConfiguration> idsConfig, ObjectNode contents) { <line2> ArrayNode idTypes = (ArrayNode) contents.get(""identityTypes""); <line3> if (idTypes != null) { <line4> for (JsonNode node : idTypes) { <line5> String name = node.get(""name"").asText(); <line6> EmailConfirmationConfiguration emailConfig = idsConfig.get(name); <line7> if (emailConfig != null) <line8> if (node.get(""identityTypeProvider"").asText().equals(""email"")) { <line9> ObjectNode nodeO = (ObjectNode) node; <line10> nodeO.set(""emailConfirmationConfiguration"", emailConfig.toJson()); <line11> } <line12> } <line13> } <line14> } <line15> } <line16> "	"<line11>            log.info(""Updating identity type {}, setting confirmationConfiguration to {}"",name,emailConfig.toJson());"	task4	
"public class A { <line0> public String getElapsedTime() { <line1> AsyncTaskHandle<Void> processHandle = searchIndexManager.getProcessHandle(); <line2> if (processHandle == null) { <line3> return """"; <line4> } else { <line5> long elapsedTime = processHandle.getExecutingTime(); <line6> return formatTimePeriod(elapsedTime); <line7> } <line8> } <line9> } <line10> "	"<line3>      log.error(""processHandle is null when looking up elapsed time"");"	task4	
"public class A { <line0> @Override <line1> public Obs saveObs(Obs obs) throws APIException { <line2> ComplexData complexData = obs.getComplexData(); <line3> if (complexData == null) { <line4> return obs; <line5> } <line6> BufferedWriter fout = null; <line7> try { <line8> File outfile = getOutputFileToWrite(obs); <line9> fout = new BufferedWriter(new FileWriter(outfile)); <line10> Reader tempRd = null; <line11> Object data = obs.getComplexData().getData(); <line12> if (data instanceof char[]) { <line13> fout.write((char[]) data); <line14> } else if (Reader.class.isAssignableFrom(data.getClass())) { <line15> try { <line16> tempRd = new BufferedReader((Reader) data); <line17> while (true) { <line18> int character = tempRd.read(); <line19> if (character == -1) { <line20> break; <line21> } <line22> fout.write(character); <line23> } <line24> tempRd.close(); <line25> } catch (IOException e) { <line26> throw new APIException( <line27> ""Obs.error.unable.convert.complex.data"", new Object[] {""Reader""}, e); <line28> } <line29> } <line30> obs.setValueComplex(outfile.getName() + "" file |"" + outfile.getName()); <line31> obs.setComplexData(null); <line32> } catch (IOException ioe) { <line33> throw new APIException(""Obs.error.trying.write.complex"", null, ioe); <line34> } finally { <line35> try { <line36> fout.close(); <line37> } catch (Exception e) { <line38> } <line39> } <line40> return obs; <line41> } <line42> } <line43> "	"<line4>      log.error(""Cannot save complex data where obsId=""+ obs.getObsId()+ "" because its ComplexData is null."");"	task4	
public class A { <line0> public void fixCaches(ICacheServiceNonLocal lateralService, ILateralCacheObserver lateralWatch) { <line1> synchronized (this.caches) { <line2> this.lateralService = lateralService; <line3> for (Iterator en = this.caches.values().iterator(); en.hasNext(); ) { <line4> LateralCacheNoWait cache = (LateralCacheNoWait) en.next(); <line5> cache.fixCache(this.lateralService); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line1>    log.debug(""Fixing lateral caches:"");"	task4	
public class A { <line0> void publishHintEvents(Collection<HintEvent> hintEvents, String atomURI) { <line1> BulkHintEvent bulkHintEvent = new BulkHintEvent(); <line2> bulkHintEvent.addHintEvents(hintEvents); <line3> pubSubMediator.tell( <line4> new DistributedPubSubMediator.Publish(bulkHintEvent.getClass().getName(), bulkHintEvent), <line5> getSelf()); <line6> } <line7> } <line8> 	"<line6>    log.debug(""sparql-based matching for atom {} (found {} matches)"",atomURI,bulkHintEvent.getHintEvents().size());"	task4	
"public class A { <line0> @RequestMapping(value = ""lists/artifact-definitions/edit.html"", method = RequestMethod.GET) <line1> protected String showEditForm( <line2> @RequestParam(""id"") String idString, <line3> @RequestParam(""groupid"") String idString2, <line4> ModelMap model, <line5> HttpServletRequest request) { <line6> AddArtifactCommand data = new AddArtifactCommand(); <line7> if (auth.userIsExperimenter() || auth.isAdmin()) { <line8> model.addAttribute(""userIsExperimenter"", true); <line9> int id = Integer.parseInt(idString2); <line10> data.setResearchGroupId(id); <line11> String title = researchGroupDao.getResearchGroupTitle(id); <line12> data.setResearchGroupTitle(title); <line13> id = Integer.parseInt(idString); <line14> Artifact artifact = artifactDao.read(id); <line15> data.setId(id); <line16> data.setCompensation(artifact.getCompensation()); <line17> data.setRejectCondition(artifact.getRejectCondition()); <line18> model.addAttribute(""addArtifact"", data); <line19> return ""lists/artifact/addItemForm""; <line20> } else { <line21> return ""lists/userNotExperimenter""; <line22> } <line23> } <line24> } <line25> "	"<line14>      log.debug(""Loading artifact to the command object for editing."");"	task4	
public class A { <line0> @Override <line1> public void discoverObjectInstance( <line2> ObjectInstanceHandle theObject, <line3> ObjectClassHandle theObjectClass, <line4> String objectName, <line5> FederateHandle producingFederate) <line6> throws FederateInternalError { <line7> System.out.println(); <line8> } <line9> } <line10> 	"<line7>    LOGGER.info(""Discover Object Instance : ""+ ""Object = ""+ theObject.toString()+ "", Object class = ""+ theObjectClass.toString()+ "", Object name = ""+ objectName+ "", Producing federate = ""+ producingFederate.toString());"	task4	
"public class A { <line0> protected Document getDocument(ClassLoader classLoader) { <line1> try { <line2> URL url = classLoader.getResource(""META-INF/javadocs-rt.xml""); <line3> if (url == null) { <line4> return null; <line5> } <line6> try (InputStream inputStream = url.openStream()) { <line7> return UnsecureSAXReaderUtil.read(inputStream, true); <line8> } <line9> } catch (Exception exception) { <line10> } <line11> return null; <line12> } <line13> } <line14> "	<line10>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void createTopic(String topic, int partitions, int replicationFactor) { <line2> AdminUtils.createTopic(zookeeperClient, topic, partitions, replicationFactor, new Properties()); <line3> } <line4> } <line5> 	"<line3>    LOGGER.debug(""Creating topic: ""+ topic+ "" , partitions: ""+ partitions+ "" , ""+ ""replication factor: ""+ replicationFactor+ ""."");"	task4	
"public class A { <line0> @Override <line1> public void validate(final InstallServiceValidationContext validationContext) <line2> throws RestErrorException { <line3> final String serviceName = validationContext.getService().getName(); <line4> if (serviceName.startsWith(CloudifyConstants.ILlEGAL_SERVICE_NAME_PREFIX)) { <line5> throw new RestErrorException( <line6> CloudifyErrorMessages.ILLEGAL_SERVICE_NAME.getName(), <line7> serviceName, <line8> ""starts with "" + CloudifyConstants.ILlEGAL_SERVICE_NAME_PREFIX); <line9> } <line10> if (serviceName.endsWith(CloudifyConstants.ILlEGAL_SERVICE_NAME_SUFFIX)) { <line11> throw new RestErrorException( <line12> CloudifyErrorMessages.ILLEGAL_SERVICE_NAME.getName(), <line13> serviceName, <line14> ""ends with "" + CloudifyConstants.ILlEGAL_SERVICE_NAME_SUFFIX); <line15> } <line16> } <line17> } <line18> "	"<line3>    logger.info(""Validating service name"");"	task4	
public class A { <line0> public static int searchCount(long companyId, long groupId, String keywords, int scope) <line1> throws RemoteException { <line2> try { <line3> int returnValue = DDLRecordSetServiceUtil.searchCount(companyId, groupId, keywords, scope); <line4> return returnValue; <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public DirectoryStream<Path> getDirectoryStream(DirectoryStream.Filter<? super Path> filter) { <line2> if (schemaNode != null) { <line3> return new DirectoryStream() { <line4> boolean closed = false; <line5>  <line6> @Override <line7> public Iterator iterator() { <line8> final App app = StructrApp.getInstance(fs.getSecurityContext()); <line9> final List<StructrPath> nodes = new LinkedList<>(); <line10> try (final Tx tx = app.tx()) { <line11> for (final SchemaView schemaView : schemaNode.getProperty(SchemaNode.schemaViews)) { <line12> nodes.add( <line13> new StructrSchemaViewPath( <line14> fs, StructrSchemaViewsPath.this, schemaNode, schemaView)); <line15> } <line16> tx.success(); <line17> } catch (FrameworkException fex) { <line18> } <line19> return nodes.iterator(); <line20> } <line21>  <line22> @Override <line23> public void close() throws IOException { <line24> closed = true; <line25> } <line26> }; <line27> } <line28> return null; <line29> } <line30> } <line31> 	"<line18>            logger.warn("""", fex);"	task4	
public class A { <line0> public void pauseEvenIfProcessorStopped() { <line1> if (this.eventProcessor != null) { <line2> this.getLifeCycleLock().writeLock().lock(); <line3> try { <line4> this.eventProcessor.pauseDispatching(); <line5> InternalDistributedSystem system = <line6> (InternalDistributedSystem) this.cache.getDistributedSystem(); <line7> system.handleResourceEvent(ResourceEvent.GATEWAYSENDER_PAUSE, this); <line8> enqueueTempEvents(); <line9> } finally { <line10> this.getLifeCycleLock().writeLock().unlock(); <line11> } <line12> } <line13> } <line14> } <line15> 	"<line8>        logger.info(""Paused {}"", this);"	task4	
"public class A { <line0> @Override <line1> public void init(NodeEngine engine, Properties hzProperties) { <line2> this.nodeEngine = (NodeEngineImpl) engine; <line3> this.jetInstance = new JetInstanceImpl(nodeEngine.getNode().hazelcastInstance, config); <line4> taskletExecutionService = <line5> new TaskletExecutionService( <line6> nodeEngine, <line7> config.getInstanceConfig().getCooperativeThreadCount(), <line8> nodeEngine.getProperties()); <line9> jobRepository = new JobRepository(jetInstance); <line10> jobExecutionService = <line11> new JobExecutionService(nodeEngine, taskletExecutionService, jobRepository); <line12> jobCoordinationService = createJobCoordinationService(); <line13> MetricsService metricsService = nodeEngine.getService(MetricsService.SERVICE_NAME); <line14> metricsService.registerPublisher( <line15> nodeEngine -> new JobMetricsPublisher(jobExecutionService, nodeEngine.getLocalMember())); <line16> nodeEngine.getMetricsRegistry().registerDynamicMetricsProvider(jobExecutionService); <line17> networking = <line18> new Networking( <line19> engine, jobExecutionService, config.getInstanceConfig().getFlowControlPeriodMs()); <line20> ClientEngine clientEngine = engine.getService(ClientEngineImpl.SERVICE_NAME); <line21> ClientExceptionFactory clientExceptionFactory = clientEngine.getExceptionFactory(); <line22> if (clientExceptionFactory != null) { <line23> ExceptionUtil.registerJetExceptions(clientExceptionFactory); <line24> } else { <line25> logger.fine( <line26> ""Jet exceptions are not registered to the ClientExceptionFactory"" <line27> + "" since the ClientExceptionFactory is not accessible.""); <line28> } <line29> if (sqlCoreBackend != null) { <line30> try { <line31> Method initJetInstanceMethod = <line32> sqlCoreBackend.getClass().getMethod(""init"", AbstractJetInstance.class); <line33> initJetInstanceMethod.invoke(sqlCoreBackend, jetInstance); <line34> } catch (ReflectiveOperationException e) { <line35> throw new RuntimeException(e); <line36> } <line37> } <line38> } <line39> } <line40> "	"<line29>    logger.info(""Setting number of cooperative threads and default parallelism to ""+ config.getInstanceConfig().getCooperativeThreadCount());"	task4	
public class A { <line0> private List<Long> getIdListForMap(Map<String, Boolean> boxIdMap) { <line1> List<Long> boxIds = new ArrayList<Long>(); <line2> if (boxIdMap == null || boxIdMap.isEmpty()) return boxIds; <line3> for (Entry<String, Boolean> entry : boxIdMap.entrySet()) { <line4> if (entry.getValue()) { <line5> long boxId = Long.valueOf(entry.getKey()); <line6> boxIds.add(boxId); <line7> } <line8> } <line9> return boxIds; <line10> } <line11> } <line12> 	"<line4>      log.debug(""key:"" + entry.getKey() + "" value:"" + entry.getValue());"	task4	
"public class A { <line0> protected List<JournalArticle> getDisplayPageTemplateArticles(Layout layout) { <line1> List<JournalArticle> journalArticles = new ArrayList<>(); <line2> if (layout == null) { <line3> return journalArticles; <line4> } <line5> DynamicQuery assetDisplayPageEntryDynamicQuery = <line6> _assetDisplayPageEntryLocalService.dynamicQuery(); <line7> long classNameId = _portal.getClassNameId(JournalArticle.class.getName()); <line8> Property classNameIdProperty = PropertyFactoryUtil.forName(""classNameId""); <line9> assetDisplayPageEntryDynamicQuery.add(classNameIdProperty.eq(classNameId)); <line10> Property layoutPageTemplateEntryIdProperty = <line11> PropertyFactoryUtil.forName(""layoutPageTemplateEntryId""); <line12> assetDisplayPageEntryDynamicQuery.add(layoutPageTemplateEntryIdProperty.ne(Long.valueOf(0))); <line13> Property plidProperty = PropertyFactoryUtil.forName(""plid""); <line14> assetDisplayPageEntryDynamicQuery.add(plidProperty.eq(layout.getPlid())); <line15> assetDisplayPageEntryDynamicQuery.setProjection(PropertyFactoryUtil.forName(""classPK"")); <line16> List<Long> resourcePrimKeys = <line17> _assetDisplayPageEntryLocalService.dynamicQuery(assetDisplayPageEntryDynamicQuery); <line18> for (Long resourcePrimKey : resourcePrimKeys) { <line19> try { <line20> JournalArticle journalArticle = _journalArticleService.getLatestArticle(resourcePrimKey); <line21> if (journalArticle.isIndexable()) { <line22> journalArticles.add(journalArticle); <line23> } <line24> } catch (Exception exception) { <line25> if (log.isDebugEnabled()) { <line26> } <line27> } <line28> } <line29> return journalArticles; <line30> } <line31> } <line32> "	<line26>          log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> public short readShort() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> return ((StreamMessage) message).readShort(); <line5> } <line6> } <line7> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""readShort()"");"	task4	
public class A { <line0> @Override <line1> public List<String> call() throws Exception { <line2> if (!skipWatchingNonExistNode) { <line3> exists(path, true); <line4> } <line5> try { <line6> return getChildren(path, true); <line7> } catch (ZkNoNodeException e) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line8>      LOG.info(""zkclient{} watchForChilds path not existing:{} skipWatchingNodeNoteExist: {}"",_uid,path,skipWatchingNonExistNode);"	task4	
"public class A { <line0> @Override <line1> public void onEntry(FilterContext filterContext, FilterChain next) throws SoaException { <line2> try { <line3> InvocationContextImpl invocationContext = <line4> (InvocationContextImpl) filterContext.getAttribute(""context""); <line5> filterContext.setAttribute(""startTime"", System.currentTimeMillis()); <line6> InvocationInfoImpl invocationInfo = new InvocationInfoImpl(); <line7> invocationContext.lastInvocationInfo(invocationInfo); <line8> if (!invocationContext.sessionTid().isPresent()) { <line9> if (TransactionContext.hasCurrentInstance() <line10> && TransactionContext.Factory.currentInstance().sessionTid().isPresent()) { <line11> invocationContext.sessionTid( <line12> TransactionContext.Factory.currentInstance().sessionTid().get()); <line13> } else { <line14> invocationContext.sessionTid(DapengUtil.generateTid()); <line15> } <line16> } <line17> String logLevel = invocationContext.cookie(SoaSystemEnvProperties.THREAD_LEVEL_KEY); <line18> if (logLevel != null) { <line19> MDC.put(SoaSystemEnvProperties.THREAD_LEVEL_KEY, logLevel); <line20> } <line21> MDC.put( <line22> SoaSystemEnvProperties.KEY_LOGGER_SESSION_TID, <line23> invocationContext.sessionTid().map(DapengUtil::longToHexStr).orElse(""0"")); <line24> String infoLog = <line25> ""request[seqId:"" <line26> + invocationContext.seqId() <line27> + "", server:"" <line28> + filterContext.getAttribute(""serverInfo"") <line29> + ""]:"" <line30> + ""service["" <line31> + invocationContext.serviceName() <line32> + ""]:version["" <line33> + invocationContext.versionName() <line34> + ""]:method["" <line35> + invocationContext.methodName() <line36> + ""]""; <line37> } finally { <line38> next.onEntry(filterContext); <line39> } <line40> } <line41> } <line42> "	"<line37>      LOGGER.info(getClass().getSimpleName() + ""::onEntry,"" + infoLog);"	task4	
public class A { <line0> private String _getMappedCollectionValue(String collectionFieldId, Object displayObject) { <line1> if (!(displayObject instanceof ClassedModel)) { <line2> return StringPool.BLANK; <line3> } <line4> ClassedModel classedModel = (ClassedModel) displayObject; <line5> String className = classedModel.getModelClassName(); <line6> if (classedModel instanceof FileEntry) { <line7> className = FileEntry.class.getName(); <line8> } <line9> InfoItemFieldValuesProvider<Object> infoItemFieldValuesProvider = <line10> _infoItemServiceTracker.getFirstInfoItemService( <line11> InfoItemFieldValuesProvider.class, className); <line12> if (infoItemFieldValuesProvider == null) { <line13> if (log.isWarnEnabled()) { <line14> } <line15> return StringPool.BLANK; <line16> } <line17> InfoFieldValue<Object> infoFieldValue = <line18> infoItemFieldValuesProvider.getInfoItemFieldValue(displayObject, collectionFieldId); <line19> if (infoFieldValue == null) { <line20> return StringPool.BLANK; <line21> } <line22> Object value = <line23> infoFieldValue.getValue(LocaleUtil.fromLanguageId(_themeDisplay.getLanguageId())); <line24> if (value instanceof ContentAccessor) { <line25> ContentAccessor contentAccessor = (ContentAccessor) infoFieldValue; <line26> return contentAccessor.getContent(); <line27> } <line28> if (value instanceof String) { <line29> return (String) value; <line30> } <line31> if (!(value instanceof WebImage)) { <line32> return StringPool.BLANK; <line33> } <line34> WebImage webImage = (WebImage) value; <line35> String url = webImage.getUrl(); <line36> if (Validator.isNotNull(url)) { <line37> return url; <line38> } <line39> return StringPool.BLANK; <line40> } <line41> } <line42> 	"<line14>        log.warn(""Unable to get info item field values provider for class "" + className);"	task4	
"public class A { <line0> public void shutdown() { <line1> if (!shuttingDown.compareAndSet(false, true)) return; <line2> try { <line3> try { <line4> } catch (Throwable t) { <line5> } <line6> System.out.println(""Shutting down: Stopping listeners...""); <line7> stopListeners(); <line8> System.out.println(""Shutting down: Stopping schedulers...""); <line9> if (proxyCheckinScheduler != null) proxyCheckinScheduler.shutdown(); <line10> managedExecutors.forEach(ExecutorService::shutdownNow); <line11> managedExecutors.forEach( <line12> x -> { <line13> try { <line14> x.awaitTermination(proxyConfig.getHttpRequestTimeout(), TimeUnit.MILLISECONDS); <line15> } catch (InterruptedException e) { <line16> } <line17> }); <line18> System.out.println(""Shutting down: Running finalizing tasks...""); <line19> shutdownTasks.forEach(Runnable::run); <line20> System.out.println(""Shutdown complete.""); <line21> } catch (Throwable t) { <line22> try { <line23> logger.log(Level.SEVERE, ""Error during shutdown: "", t); <line24> } catch (Throwable loggingError) { <line25> t.addSuppressed(loggingError); <line26> t.printStackTrace(); <line27> } <line28> } <line29> } <line30> } <line31> "	"<line4>        logger.info(""Shutting down the proxy..."");"	task4	
public class A { <line0> protected int validate() { <line1> if (ledgerId < 0) { <line2> return Code.NoSuchLedgerExistsOnMetadataServerException; <line3> } <line4> return Code.OK; <line5> } <line6> } <line7> 	"<line2>      LOG.error(""invalid ledgerId {} < 0"", ledgerId);"	task4	
"public class A { <line0> @RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE) <line1> public String importData(Reader in, Model m) throws IOException { <line2> JsonReader reader = new JsonReader(in); <line3> reader.beginObject(); <line4> while (reader.hasNext()) { <line5> JsonToken tok = reader.peek(); <line6> switch (tok) { <line7> case NAME: <line8> String name = reader.nextName(); <line9> if (supportedVersions.contains(name)) { <line10> for (MITREidDataService dataService : importers) { <line11> if (dataService.supportsVersion(name)) { <line12> dataService.importData(reader); <line13> break; <line14> } <line15> } <line16> } else { <line17> reader.skipValue(); <line18> } <line19> break; <line20> case END_OBJECT: <line21> break; <line22> case END_DOCUMENT: <line23> break; <line24> } <line25> } <line26> reader.endObject(); <line27> return ""httpCodeView""; <line28> } <line29> } <line30> "	"<line17>            logger.debug(""Skipping value for "" + name);"	task4	
public class A { <line0> @Override <line1> protected long incrementStorageSize(final long size) { <line2> return redisExecutor.execute( <line3> (RedisCallable<Long>) <line4> jedis -> { <line5> Long incremented = jedis.incrBy(sizeKey, size); <line6> if (log.isDebugEnabled()) { <line7> } <line8> return incremented; <line9> }); <line10> } <line11> } <line12> 	"<line7>                log.debug(String.format(""Incremented Redis key %s to %d"", sizeKey, incremented));"	task4	
public class A { <line0> @Override <line1> public String requestInstance(NetworkOrder networkOrder, AzureUser azureUser) <line2> throws FogbowException { <line3> String resourceName = AzureGeneralUtil.generateResourceName(); <line4> String cidr = networkOrder.getCidr(); <line5> String name = networkOrder.getName(); <line6> Map tags = Collections.singletonMap(AzureConstants.TAG_NAME, name); <line7> String instanceId = AzureGeneralUtil.defineInstanceId(resourceName); <line8> AzureCreateVirtualNetworkRef azureCreateVirtualNetworkRef = <line9> AzureCreateVirtualNetworkRef.builder() <line10> .resourceName(resourceName) <line11> .cidr(cidr) <line12> .tags(tags) <line13> .checkAndBuild(); <line14> AsyncInstanceCreationManager.Callbacks finishCreationCallbacks = <line15> startInstanceCreation(instanceId); <line16> doCreateInstance(azureUser, azureCreateVirtualNetworkRef, finishCreationCallbacks); <line17> waitAndCheckForInstanceCreationFailed(instanceId); <line18> return instanceId; <line19> } <line20> } <line21> 	<line3>    LOGGER.info(Messages.Log.REQUESTING_INSTANCE_FROM_PROVIDER);	task4	
public class A { <line0> @Override <line1> public void tearDownClass() throws Exception { <line2> super.tearDownClass(); <line3> try { <line4> if (server != null) { <line5> server.shutdown(); <line6> } <line7> } catch (Throwable ex) { <line8> } <line9> } <line10> } <line11> 	"<line8>      log.warn(""Exception occurred while shutting down HSQLDB :"" + StringUtils.stringifyException(ex));"	task4	
"public class A { <line0> private boolean isHostValid() { <line1> VersionDTO version = getVersion(); <line2> if (version != null) { <line3> if (checkSoftwareVersion(version.version) && checkApiVersion(version.apiVersion)) { <line4> return true; <line5> } <line6> } else { <line7> updateStatus( <line8> ThingStatus.OFFLINE, <line9> ThingStatusDetail.CONFIGURATION_ERROR, <line10> ""Can't get version information""); <line11> } <line12> return false; <line13> } <line14> } <line15> "	"<line1>    logger.debug(""Bridge: Checking for valid Zoneminder host: {}"", host);"	task4	
"public class A { <line0> public Properties loadProperties() { <line1> if (StringUtils.isBlank(getFileName())) { <line2> throw new IllegalStateException(""invalid (blank) fileName""); <line3> } <line4> Properties properties = new Properties(); <line5> ClassLoader loader = Thread.currentThread().getContextClassLoader(); <line6> URL url = loader.getResource(getFileName()); <line7> if (url == null) { <line8> throw new RiceRuntimeException(""unable to locate properties file '"" + getFileName() + ""'""); <line9> } <line10> InputStream in = null; <line11> try { <line12> in = url.openStream(); <line13> properties.load(in); <line14> } catch (IOException e) { <line15> throw new RiceRuntimeException( <line16> ""error loading from properties file '"" + getFileName() + ""'"", e); <line17> } finally { <line18> if (in != null) { <line19> try { <line20> in.close(); <line21> } catch (IOException e) { <line22> } <line23> } <line24> } <line25> return properties; <line26> } <line27> } <line28> "	"<line22>          log.error(""caught exception closing InputStream: "" + e);"	task4	
"public class A { <line0> public void configure() { <line1> from(""netty:tcp://127.0.0.1:{{port}}?sync=true&ssl=true&passphrase=changeit&keyStoreResource=#ksf&trustStoreResource=#tsf&needClientAuth=true"") <line2> .process( <line3> new Processor() { <line4> public void process(Exchange exchange) throws Exception { <line5> SSLSession session = <line6> exchange.getIn().getHeader(NettyConstants.NETTY_SSL_SESSION, SSLSession.class); <line7> if (session != null) { <line8> X509Certificate cert = (X509Certificate) session.getPeerCertificates()[0]; <line9> Principal principal = cert.getSubjectDN(); <line10> exchange <line11> .getOut() <line12> .setBody( <line13> ""When You Go Home, Tell Them Of Us And Say, For Your Tomorrow, We Gave"" <line14> + "" Our Today.""); <line15> } else { <line16> exchange.getOut().setBody(""Cannot start conversion without SSLSession""); <line17> } <line18> } <line19> }); <line20> } <line21> } <line22> "	"<line10>                  log.info(""Client Cert SubjectDN: {}"", principal.getName());"	task4	
public class A { <line0> public static InsertionIds getInsertionIds( <line1> final String entry, <line2> final EnumSet<TextSearchType> supportedSearchTypes, <line3> final EnumSet<CaseSensitivity> supportedCaseSensitivities, <line4> final int nGramCharacters) { <line5> if ((entry == null) || entry.isEmpty()) { <line6> return new InsertionIds(); <line7> } <line8> final Set<TextIndexType> indexTypes = <line9> supportedSearchTypes.stream().map(TextSearchType::getIndexType).collect(Collectors.toSet()); <line10> final List<SinglePartitionInsertionIds> retVal = new ArrayList<>(indexTypes.size()); <line11> for (final TextIndexType indexType : indexTypes) { <line12> for (final CaseSensitivity caseSensitivity : supportedCaseSensitivities) { <line13> final boolean caseSensitive = CaseSensitivity.CASE_SENSITIVE.equals(caseSensitivity); <line14> switch (indexType) { <line15> case FORWARD: <line16> retVal.add(getForwardInsertionIds(entry, caseSensitive)); <line17> break; <line18> case REVERSE: <line19> retVal.add(getReverseInsertionIds(entry, caseSensitive)); <line20> break; <line21> case NGRAM: <line22> final SinglePartitionInsertionIds i = <line23> getNGramInsertionIds( <line24> entry, <line25> nGramCharacters, <line26> indexTypes.contains(TextIndexType.FORWARD), <line27> caseSensitive); <line28> if (i != null) { <line29> retVal.add(i); <line30> } <line31> break; <line32> } <line33> } <line34> } <line35> return new InsertionIds(retVal); <line36> } <line37> } <line38> 	"<line6>      LOGGER.warn(""Cannot index null enum, skipping entry"");"	task4	
public class A { <line0> private static Optional<NetworkService> getCore() { <line1> try { <line2> ApplicationContext context = ApplicationContextProvider.getApplicationContext(); <line3> if (context == null) { <line4> return Optional.empty(); <line5> } <line6> Collection<ServiceOps> serviceOpsList = context.getBeansOfType(ServiceOps.class).values(); <line7> if (serviceOpsList.isEmpty()) { <line8> return Optional.empty(); <line9> } <line10> ServiceOps serviceOps = serviceOpsList.iterator().next(); <line11> return Optional.of(serviceOps.get(NetworkService.Type.CORE)); <line12> } catch (KeymasterException e) { <line13> } <line14> return Optional.empty(); <line15> } <line16> } <line17> 	<line13>      LOG.trace(e.getMessage());	task4	
public class A { <line0> protected static AccessControlList getAclFromEvent(Event event) { <line1> AccessControlList activeAcl = new AccessControlList(); <line2> try { <line3> if (event.getAccessPolicy() != null) <line4> activeAcl = AccessControlParser.parseAcl(event.getAccessPolicy()); <line5> } catch (Exception e) { <line6> } <line7> return activeAcl; <line8> } <line9> } <line10> 	"<line6>      logger.error(""Unable to parse access policy"", e);"	task4	
public class A { <line0> @Override <line1> public void _setNextWriteValue(Optional<String> valueOpt) throws OpenemsException { <line2> if (this.isDebug()) { <line3> } <line4> if (valueOpt.isPresent()) { <line5> ByteBuffer buff = ByteBuffer.allocate(2 * this.length).order(this.getByteOrder()); <line6> buff = this.toByteBuffer(buff, valueOpt.get()); <line7> byte[] b = buff.array(); <line8> Register[] registers = new Register[this.length]; <line9> for (int i = 0; i < this.length; i = i + 1) { <line10> registers[i] = new SimpleRegister(b[i * 2], b[i * 2 + 1]); <line11> } <line12> this.setNextWriteValueRegisters(Optional.of(registers)); <line13> } else { <line14> this.setNextWriteValueRegisters(Optional.empty()); <line15> } <line16> this.onSetNextWriteCallbacks.forEach(callback -> callback.accept(valueOpt)); <line17> } <line18> } <line19> 	"<line3>      log.info(""Element ["" + this + ""] set next write value to ["" + valueOpt.orElse(null) + ""]."");"	task4	
"public class A { <line0> @Override <line1> public IServiceProperties getByName(String name) { <line2> try { <line3> TypedQuery<IServiceProperties> query = <line4> entityManager.createNamedQuery( <line5> ServiceProperties.QUERY_FIND_BY_NAME, IServiceProperties.class); <line6> query.setParameter(""name"", name); <line7> IServiceProperties serviceProperties = new ServiceProperties(); <line8> serviceProperties = query.getSingleResult(); <line9> return serviceProperties; <line10> } catch (NoResultException e) { <line11> return null; <line12> } <line13> } <line14> } <line15> "	"<line11>      logger.debug(""No Result found: "" + e);"	task4	
public class A { <line0> public void onNewConnection(ChannelHandlerContext ctx) { <line1> } <line2> } <line3> 	"<line1>    logger.debug(""onNewConnection"");"	task4	
public class A { <line0> private void logAddressResult(AddressResult addressResult) { <line1> if (SINGLE_LOGGING_ENABLED) { <line2> try { <line3> if (addressResult.getAddress() != null) { <line4> sqlAddressLogger.logAddress(addressResult.getAddress()); <line5> } <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.warn(""Failed to insert address result in the DB "" + e.getMessage());"	task4	
public class A { <line0> private void sendPresence(User user, Set<JID> recipients) { <line1> if (recipients.isEmpty()) { <line2> return; <line3> } <line4> final PresenceManager presenceManager = XMPPServer.getInstance().getPresenceManager(); <line5> final Presence presence = presenceManager.getPresence(user); <line6> if (presence == null) { <line7> return; <line8> } <line9> for (final JID recipient : recipients) { <line10> try { <line11> if (presenceManager.canProbePresence(recipient, user.getUsername())) { <line12> presenceManager.probePresence( <line13> recipient.asBareJID(), XMPPServer.getInstance().createJID(user.getUsername(), null)); <line14> } <line15> } catch (UserNotFoundException e) { <line16> } <line17> } <line18> } <line19> } <line20> 	"<line16>        Log.error(""Unable to send presence information of user '{}' to unblocked entity '{}' as local""+ "" user is not found."",user.getUsername(),recipient);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void onBeforeRestore( <line3> UserXmlPreferencesDao userXmlPreferencesDao, <line4> final XStreamSavingConverter xstreamSavingConverter, <line5> final Object obj) { <line6> if (obj instanceof UserXmlPreferencesDO) { <line7> final UserXmlPreferencesDO userPrefs = (UserXmlPreferencesDO) obj; <line8> if (!TaskTree.USER_PREFS_KEY_OPEN_TASKS.equals(userPrefs.getKey())) { <line9> return; <line10> } <line11> final Object userPrefsObj = userXmlPreferencesDao.deserialize(null, userPrefs, true); <line12> if (userPrefsObj == null || !(userPrefsObj instanceof Set)) { <line13> return; <line14> } <line15> Set<Integer> oldIds = null; <line16> try { <line17> oldIds = (Set<Integer>) userPrefsObj; <line18> } catch (final ClassCastException ex) { <line19> } <line20> if (oldIds.size() == 0) { <line21> return; <line22> } <line23> final Set<Integer> newIds = new HashSet<>(); <line24> for (final Integer oldId : oldIds) { <line25> final Integer newId = xstreamSavingConverter.getNewIdAsInteger(TaskDO.class, oldId); <line26> newIds.add(newId); <line27> } <line28> userXmlPreferencesDao.serialize(userPrefs, newIds); <line29> return; <line30> } <line31> } <line32> } <line33> "	"<line19>        log.error(""Oups, Set of task id's is not of type Set<Integer>, can't migrate this list."");"	task4	
public class A { <line0> protected void extractParameterList( <line1> Map<String, String[]> requestParameter, <line2> Map<String, String[]> queryParameter, <line3> Map<String, String[]> solrParameter, <line4> Map<String, String[]> typeParameter, <line5> Map<String, String[]> sortParameter) { <line6> for (Entry<String, String[]> currentEntry : requestParameter.entrySet()) { <line7> String parameterName = currentEntry.getKey(); <line8> if (PHRASE_QUERY_PARAM.equals(parameterName)) { <line9> continue; <line10> } <line11> SolrParameterGroup parameterGroup = getParameterType(parameterName); <line12> switch (parameterGroup) { <line13> case SolrParameter: <line14> solrParameter.put(parameterName, currentEntry.getValue()); <line15> break; <line16> case TypeParameter: <line17> typeParameter.put(parameterName, currentEntry.getValue()); <line18> break; <line19> case QueryParameter: <line20> String[] strings = currentEntry.getValue(); <line21> for (String v : strings) { <line22> if (v != null && v.length() > 0) { <line23> queryParameter.put(parameterName, currentEntry.getValue()); <line24> } <line25> } <line26> break; <line27> case SortParameter: <line28> sortParameter.put(parameterName, currentEntry.getValue()); <line29> break; <line30> default: <line31> continue; <line32> } <line33> } <line34> } <line35> } <line36> 	"<line31>          LOGGER.warn(""Unknown parameter group. That should not happen."");"	task4	
public class A { <line0> @Override <line1> public boolean customPermissionAllowed( <line2> final Authentication authentication, final SequencingObject sf) { <line3> SampleSequencingObjectJoin sequencingObjectJoin = <line4> ssoRepository.getSampleForSequencingObject(sf); <line5> if (sequencingObjectJoin != null) { <line6> return samplePermission.isAllowed(authentication, sequencingObjectJoin.getSubject()); <line7> } else { <line8> return false; <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.trace(""Permission denied for reading sequencing object id=""+ sf.getId()+ "" by user=""+ authentication.getName()+ "", no joined sample found."");"	task4	
public class A { <line0> @Override <line1> public void doWith(Method m) throws IllegalArgumentException, IllegalAccessException { <line2> registerProxyCandidate(bean, id); <line3> } <line4> } <line5> 	"<line2>    log.info(""The method [ {} ] of bean [ {} ] is candidate to be overridden by plugin child contexts"",m.toString(),id);"	task4	
public class A { <line0> @Override <line1> protected ResourceResponse newResourceResponse(final Attributes attributes) { <line2> SAML2SP4UIService service = <line3> BaseSession.class.cast(Session.get()).getAnonymousService(SAML2SP4UIService.class); <line4> SAML2LoginResponse saml2Response = service.validateLoginResponse(extract(attributes)); <line5> if (saml2Response.isSelfReg()) { <line6> UserTO newUser = new UserTO(); <line7> newUser.setUsername(saml2Response.getUsername()); <line8> newUser.getPlainAttrs().addAll(saml2Response.getAttrs()); <line9> try { <line10> Pair<Class<? extends WebPage>, PageParameters> selfRegInfo = getSelfRegInfo(newUser); <line11> throw new RestartResponseException(selfRegInfo.getLeft(), selfRegInfo.getRight()); <line12> } catch (JsonProcessingException e) { <line13> throw new WicketRuntimeException(e); <line14> } <line15> } else { <line16> throw new RestartResponseException( <line17> getLoginPageClass(), <line18> new PageParameters() <line19> .set(SAML2SP4UIConstants.SAML2SP4UI_JWT, saml2Response.getAccessToken()) <line20> .set(SAML2SP4UIConstants.SAML2SP4UI_SLO_SUPPORTED, saml2Response.isSloSupported())); <line21> } <line22> } <line23> } <line24> 	"<line13>        LOG.error(""Could not serialize new user {}"", newUser, e);"	task4	
public class A { <line0> private String _getWorkflowTaskName(long companyId, long userId, long workflowInstanceId) { <line1> try { <line2> return Stream.of( <line3> _workflowTaskManager.search( <line4> companyId, <line5> userId, <line6> null, <line7> null, <line8> null, <line9> null, <line10> null, <line11> null, <line12> null, <line13> null, <line14> false, <line15> null, <line16> null, <line17> new Long[] {workflowInstanceId}, <line18> true, <line19> QueryUtil.ALL_POS, <line20> QueryUtil.ALL_POS, <line21> null)) <line22> .flatMap(List::stream) <line23> .map(WorkflowTask::getName) <line24> .findFirst() <line25> .orElse(StringPool.BLANK); <line26> } catch (WorkflowException workflowException) { <line27> if (log.isDebugEnabled()) { <line28> } <line29> } <line30> return StringPool.BLANK; <line31> } <line32> } <line33> 	<line28>        log.debug(workflowException, workflowException);	task4	
"public class A { <line0> public static String[] loadDefaultGbidsFromDefaultMessagingProperties() { <line1> Properties joynrDefaultProperties = <line2> PropertyLoader.loadProperties(DEFAULT_MESSAGING_PROPERTIES_FILE); <line3> if (!joynrDefaultProperties.containsKey(PROPERTY_GBIDS)) { <line4> throw new JoynrIllegalStateException(""No GBIDs found in default properties.""); <line5> } <line6> return Arrays.stream(joynrDefaultProperties.getProperty(PROPERTY_GBIDS).split("","")) <line7> .map(a -> a.trim()) <line8> .toArray(String[]::new); <line9> } <line10> } <line11> "	"<line4>      logger.error(""No GBIDs found in default properties: {}"", joynrDefaultProperties);"	task4	
public class A { <line0> void removePendingCompactionInstant(HoodieTimeline timeline, HoodieInstant instant) <line1> throws IOException { <line2> HoodieCompactionPlan plan = <line3> CompactionUtils.getCompactionPlan(metaClient, instant.getTimestamp()); <line4> removePendingCompactionOperations( <line5> CompactionUtils.getPendingCompactionOperations(instant, plan) <line6> .map( <line7> instantPair -> <line8> Pair.of( <line9> instantPair.getValue().getKey(), <line10> CompactionOperation.convertFromAvroRecordInstance( <line11> instantPair.getValue().getValue())))); <line12> } <line13> } <line14> 	"<line2>    LOG.info(""Removing completed compaction instant ("" + instant + "")"");"	task4	
public class A { <line0> @Override <line1> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { <line2> if (!file.getFileName().toString().equals(MCRMetsSave.getMetsFileName())) { <line3> MCRPath mcrPath = MCRPath.toMCRPath(file); <line4> String path; <line5> try { <line6> path = MCRXMLFunctions.encodeURIPath(mcrPath.getOwnerRelativePath().substring(1), true); <line7> } catch (URISyntaxException e) { <line8> throw new IOException(e); <line9> } <line10> if (!fileGroup.contains(path)) { <line11> complete.set(false); <line12> return FileVisitResult.TERMINATE; <line13> } <line14> } <line15> return super.visitFile(file, attrs); <line16> } <line17> } <line18> 	"<line11>        LOGGER.warn(""{} does not appear in {}!"", path, mcrPath.getOwner());"	task4	
public class A { <line0> private List<String> getOutputLines(JobSnapshot snapshot) throws IOException { <line1> String dataGuid = snapshot.getGeneratedDataGuids().stream().collect(SingleCollector.single()); <line2> JobDataWithByteSource jobSource = jobService.tryObtainData(dataGuid).get(); <line3> return jobSource.getByteSource().asCharSource(Charsets.UTF_8).readLines(); <line4> } <line5> } <line6> 	"<line3>    LOGGER.info(""actual output;\n{}"", jobSource.getByteSource().asCharSource(Charsets.UTF_8).read());"	task4	
"public class A { <line0> public static String jpsonicHomePathForTest() { <line1> if (jpsonicHomeDirForTest == null) { <line2> try { <line3> jpsonicHomeDirForTest = Files.createTempDirectory(""jpsonic_test_"").toFile(); <line4> } catch (IOException e) { <line5> throw new IllegalStateException( <line6> ""Error while creating temporary JPSONIC_HOME directory for tests"", e); <line7> } <line8> if (LOG.isInfoEnabled()) { <line9> } <line10> } <line11> return jpsonicHomeDirForTest.getAbsolutePath(); <line12> } <line13> } <line14> "	"<line9>        LOG.info(""JPSONIC_HOME directory will be {}"", jpsonicHomeDirForTest.getAbsolutePath());"	task4	
public class A { <line0> @Override <line1> protected void startScan() { <line2> if (usbSerialDiscovery != null) { <line3> usbSerialDiscovery.doSingleScan(); <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.info(""Could not scan, as there is no USB-Serial discovery service configured."");"	task4	
public class A { <line0> private void persistDimension( <line1> long cuboidId, <line2> List<Object> dimValueList, <line3> List<DimensionMetaInfo> dimensionMetaList, <line4> CountingOutputStream indexOut, <line5> TblColRef dimension, <line6> Map<TblColRef, Dictionary<String>> dictMaps) <line7> throws IOException { <line8> Stopwatch stopwatch = Stopwatch.createUnstarted(); <line9> stopwatch.start(); <line10> DimensionMetaInfo dimensionMeta = new DimensionMetaInfo(); <line11> dimensionMetaList.add(dimensionMeta); <line12> DimensionEncoding encoding; <line13> IIColumnDescriptor columnDescriptor; <line14> if (dimensionsUseDictEncoding.contains(dimension)) { <line15> Dictionary<String> dict = dictMaps.get(dimension); <line16> encoding = new DictionaryDimEnc(dict); <line17> if (dict instanceof TrieDictionary) { <line18> columnDescriptor = <line19> new SeqIIColumnDescriptor(dimension.getName(), dict.getMinId(), dict.getMaxId()); <line20> } else { <line21> columnDescriptor = <line22> new FixLenIIColumnDescriptor(dimension.getName(), encoding.getLengthOfEncoding()); <line23> } <line24> } else { <line25> RowKeyColDesc colDesc = cubeDesc.getRowkey().getColDesc(dimension); <line26> encoding = <line27> DimensionEncodingFactory.create( <line28> colDesc.getEncodingName(), colDesc.getEncodingArgs(), colDesc.getEncodingVersion()); <line29> columnDescriptor = <line30> new FixLenIIColumnDescriptor(dimension.getName(), encoding.getLengthOfEncoding()); <line31> } <line32> dimensionMeta.setName(dimension.getName()); <line33> dimensionMeta.setStartOffset((int) indexOut.getCount()); <line34> int fixEncodingLen = encoding.getLengthOfEncoding(); <line35> DataOutputStream dataOut = new DataOutputStream(indexOut); <line36> ColumnarStoreDimDesc cStoreDimDesc = getColumnarStoreDimDesc(dimension, encoding); <line37> ColumnDataWriter columnDataWriter = cStoreDimDesc.getDimWriter(dataOut, dimValueList.size()); <line38> for (Object cell : dimValueList) { <line39> byte[] fixLenBytes = new byte[fixEncodingLen]; <line40> if (cell != null) { <line41> encoding.encode((String) cell, fixLenBytes, 0); <line42> } else { <line43> encoding.encode(null, fixLenBytes, 0); <line44> dimensionMeta.setHasNull(true); <line45> } <line46> columnDescriptor.getWriter().addValue(fixLenBytes); <line47> columnDataWriter.write(fixLenBytes); <line48> } <line49> columnDataWriter.flush(); <line50> dimensionMeta.setDataLength(dataOut.size()); <line51> columnDescriptor.getWriter().write(indexOut); <line52> dimensionMeta.setIndexLength( <line53> (int) indexOut.getCount() - dimensionMeta.getStartOffset() - dimensionMeta.getDataLength()); <line54> dimensionMeta.setCompression(cStoreDimDesc.getCompression().name()); <line55> stopwatch.stop(); <line56> if (logger.isDebugEnabled()) { <line57> } <line58> } <line59> } <line60> 	"<line57>      logger.debug(""cuboid-{} saved dimension:{}, took: {}ms"",cuboidId,dimension.getName(),stopwatch.elapsed(MILLISECONDS));"	task4	
public class A { <line0> public synchronized void reloadPackage(String packageName) throws RuleBaseException { <line1> long start = System.currentTimeMillis(); <line2> reloadDeclarations(); <line3> packageStrings.clear(); <line4> StringBuffer packageString = initNewPackageString(packageName); <line5> for (RuleBaseElementId id : manager.list(RuleBaseElementType.Function, packageName)) { <line6> String code = manager.get(id); <line7> packageString.append(code); <line8> } <line9> for (RuleBaseElementId id : manager.list(RuleBaseElementType.Rule, packageName)) { <line10> String code = manager.get(id); <line11> String formattedRule = String.format(RULE_TEMPLATE, id.getName(), code); <line12> packageString.append(formattedRule); <line13> } <line14> Collection<String> flows = queryFlows(packageName); <line15> Collection<KnowledgePackage> compiledPackage = <line16> compileDrlString(packageString.toString(), flows); <line17> lockRuleBase(); <line18> if (base.getKnowledgePackage(packageName) != null) { <line19> base.removeKnowledgePackage(packageName); <line20> } <line21> base.addKnowledgePackages(compiledPackage); <line22> unlockRuleBase(); <line23> } <line24> } <line25> 	"<line23>    LOGGER.info(""Reloading only package {} took {}ms"", packageName, System.currentTimeMillis() - start);"	task4	
public class A { <line0> @Override <line1> public CqQuery newCq(String queryString, CqAttributes cqAttributes) <line2> throws QueryInvalidException, CqException { <line3> preOp(true); <line4> ClientCQ cq = null; <line5> try { <line6> cq = <line7> ((DefaultQueryService) realQueryService) <line8> .getCqService() <line9> .newCq( <line10> null, <line11> queryString, <line12> cqAttributes, <line13> ((DefaultQueryService) realQueryService).getPool(), <line14> false); <line15> cq.setProxyCache(this.proxyCache); <line16> this.cqNames.add(cq.getName()); <line17> } catch (CqExistsException cqe) { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } finally { <line21> postOp(); <line22> } <line23> return cq; <line24> } <line25> } <line26> 	"<line19>        logger.debug(""Unable to createCq. Error: {}"", cqe.getMessage(), cqe);"	task4	
public class A { <line0> public static File base64StringToFile(String encodedIsoData, String folder, String fileName) <line1> throws IOException { <line2> byte[] decoded = Base64.decodeBase64(encodedIsoData.getBytes(StandardCharsets.US_ASCII)); <line3> Path destPath = Paths.get(folder, fileName); <line4> try { <line5> Files.createDirectories(destPath.getParent()); <line6> } catch (final IOException e) { <line7> } <line8> return Files.write(destPath, decoded).toFile(); <line9> } <line10> } <line11> 	"<line7>      LOG.warn(""Exception hit while trying to recreate directory: "" + destPath.getParent().toString());"	task4	
public class A { <line0> @Override <line1> protected void startScan() { <line2> synchronized (this) { <line3> removeOlderResults(getTimestampOfLastScan(), null, accountHandler.getThing().getUID()); <line4> final ThingUID accountUID = accountHandler.getThing().getUID(); <line5> accountHandler.updateModelFromServerAndUpdateThingStatus(); <line6> final SensiboModel model = accountHandler.getModel(); <line7> for (final SensiboSky pod : model.getPods()) { <line8> final ThingUID podUID = <line9> new ThingUID( <line10> SensiboBindingConstants.THING_TYPE_SENSIBOSKY, <line11> accountUID, <line12> String.valueOf(pod.getMacAddress())); <line13> Map<String, String> properties = pod.getThingProperties(); <line14> Map<String, Object> stringObjectProperties = new HashMap<>(); <line15> stringObjectProperties.putAll(properties); <line16> final DiscoveryResult discoveryResult = <line17> DiscoveryResultBuilder.create(podUID) <line18> .withBridge(accountUID) <line19> .withLabel(pod.getProductName()) <line20> .withRepresentationProperty(Thing.PROPERTY_MAC_ADDRESS) <line21> .withProperties(stringObjectProperties) <line22> .build(); <line23> thingDiscovered(discoveryResult); <line24> } <line25> } <line26> } <line27> } <line28> 	"<line2>    logger.debug(""Start scan for Sensibo devices."");"	task4	
public class A { <line0> @Override <line1> public void close() throws IOException { <line2> IOException ex = null; <line3> for (MsgStreamer m : this.streamers) { <line4> try { <line5> m.close(); <line6> } catch (IOException e) { <line7> if (ex == null) { <line8> ex = e; <line9> } else { <line10> } <line11> } <line12> } <line13> if (ex != null) { <line14> throw ex; <line15> } <line16> } <line17> } <line18> 	"<line10>          logger.fatal(""Unknown error closing streamer: {}"", e.getMessage(), e);"	task4	
public class A { <line0> private void sendCQProfileOperation(operationType opType, ServerCQ cq) { <line1> if (!(this.region instanceof PartitionedRegion)) { <line2> return; <line3> } <line4> OperationMessage msg = new OperationMessage(); <line5> msg.regionName = this.region.getFullPath(); <line6> msg.opType = opType; <line7> msg.cq = cq; <line8> try { <line9> sendFilterProfileOperation(msg); <line10> } catch (Exception ex) { <line11> if (logger.isDebugEnabled()) { <line12> } <line13> } <line14> } <line15> } <line16> 	"<line12>        logger.debug(""Error sending CQ request to peers. {}"", ex.getLocalizedMessage(), ex);"	task4	
"public class A { <line0> @Override <line1> public void onClick() { <line2> try { <line3> HttpResourceStream stream = <line4> new HttpResourceStream( <line5> new ResponseHolder( <line6> ClientBuilder.newClient() <line7> .target( <line8> RequestCycle.get() <line9> .getUrlRenderer() <line10> .renderFullUrl( <line11> Url.parse( <line12> UrlUtils.rewriteToContextRelative( <line13> SAML2SP4UIConstants.URL_CONTEXT + ""/metadata"", <line14> RequestCycle.get())))) <line15> .request() <line16> .get())); <line17> ResourceStreamRequestHandler rsrh = new ResourceStreamRequestHandler(stream); <line18> rsrh.setFileName( <line19> stream.getFilename() == null <line20> ? SyncopeConsoleSession.get().getDomain() + ""-SAML-SP-Metadata.xml"" <line21> : stream.getFilename()); <line22> rsrh.setContentDisposition(ContentDisposition.ATTACHMENT); <line23> getRequestCycle().scheduleRequestHandlerAfterCurrent(rsrh); <line24> } catch (Exception e) { <line25> SyncopeConsoleSession.get().onException(e); <line26> } <line27> } <line28> } <line29> "	"<line25>      LOG.error(""While exporting SAML 2.0 SP metadata"", e);"	task4	
"public class A { <line0> @Override <line1> public List<UserAuthorityDto> getUserAuthorities(String username) { <line2> UserDetails user = this.loadUser(username); <line3> if (null == user) { <line4> return null; <line5> } <line6> List<UserAuthorityDto> dtos = new ArrayList<>(); <line7> try { <line8> List<Authorization> auths = this.getAuthorizationManager().getUserAuthorizations(username); <line9> if (null != auths) { <line10> auths.forEach(auth -> dtos.add(new UserAuthorityDto(auth))); <line11> } <line12> } catch (ApsSystemException e) { <line13> throw new RestServerError(""Error extracting auths for user "" + username, e); <line14> } <line15> return dtos; <line16> } <line17> } <line18> "	"<line13>      logger.error(""Error extracting auths for user {}"", username, e);"	task4	
"public class A { <line0> public ActionForward run_custom_filter( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> DynaActionForm ticklerForm = (DynaActionForm) form; <line6> CustomFilter filter = (CustomFilter) ticklerForm.get(""filter""); <line7> String name = filter.getName(); <line8> CustomFilter newFilter = ticklerManager.getCustomFilter(name, this.getProviderNo(request)); <line9> if (newFilter == null) { <line10> newFilter = new CustomFilter(); <line11> } <line12> ticklerForm.set(""filter"", newFilter); <line13> return filter(mapping, form, request, response); <line14> } <line15> } <line16> "	"<line5>    log.debug(""run_custom_filter"");"	task4	
public class A { <line0> public static boolean readPrimitiveBoolean(DataInput in) throws IOException { <line1> InternalDataSerializer.checkIn(in); <line2> boolean value = in.readBoolean(); <line3> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line4> } <line5> return value; <line6> } <line7> } <line8> 	"<line4>      logger.trace(LogMarker.SERIALIZER_VERBOSE, ""Read Boolean {}"", value);"	task4	
"public class A { <line0> @PayloadRoot(localPart = ""SetScheduleAsyncRequest"", namespace = NAMESPACE) <line1> @ResponsePayload <line2> public SetScheduleResponse getSetScheduleResponse( <line3> @OrganisationIdentification final String organisationIdentification, <line4> @RequestPayload final SetScheduleAsyncRequest request) <line5> throws OsgpException { <line6> final SetScheduleResponse response = new SetScheduleResponse(); <line7> try { <line8> final ResponseData responseData = <line9> this.responseDataService.dequeue( <line10> request.getAsyncRequest().getCorrelationUid(), COMPONENT_WS_TARIFF_SWITCHING); <line11> response.setResult(OsgpResultType.fromValue(responseData.getResultType().getValue())); <line12> if (responseData.getMessageData() instanceof String) { <line13> response.setDescription((String) responseData.getMessageData()); <line14> } <line15> } catch (final Exception e) { <line16> this.handleException(e); <line17> } <line18> return response; <line19> } <line20> } <line21> "	"<line6>    LOGGER.info(""Get Tariff Schedule Response Request received from organisation: {} for correlationUID:""+ "" {}."",organisationIdentification,request.getAsyncRequest().getCorrelationUid());"	task4	
"public class A { <line0> protected void printenv(String[] argv) throws Exception { <line1> Environment environ = getEnvironment(); <line2> Map<String, String> envValues = environ.getEnv(); <line3> OutputStream stdout = getOutputStream(); <line4> if (argv.length == 1) { <line5> envValues.entrySet().stream() <line6> .forEach( <line7> e -> <line8> println(argv[0], e.getKey() + ""="" + e.getValue(), stdout, envVarsEnodingCharset)); <line9> variables.put(STATUS, 0); <line10> return; <line11> } <line12> if (argv.length != 2) { <line13> signalError(argv[0], ""printenv: only one variable value at a time""); <line14> return; <line15> } <line16> String varName = argv[1]; <line17> String varValue = resolveEnvironmentVariable(varName, envValues); <line18> if (varValue == null) { <line19> signalError(argv[0], ""printenv: variable not set "" + varName); <line20> return; <line21> } <line22> if (log.isDebugEnabled()) { <line23> } <line24> println(argv[0], varValue, stdout, envVarsEnodingCharset); <line25> variables.put(STATUS, 0); <line26> } <line27> } <line28> "	"<line23>      log.debug(""printenv({}) {}={}"", getServerChannelSession(), varName, varValue);"	task4	
public class A { <line0> @Override <line1> public Object getRevision() { <line2> try { <line3> return getLastRevision(); <line4> } catch (Exception e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	<line5>      log.warn(e.getMessage(), e);	task4	
public class A { <line0> public GeometryRasterMaskBuilder buildTileRangeMask( <line1> final GeoRSSReader reader, String previousEntryUpdate) throws IOException { <line2> final GridSubset gridSubset = layer.getGridSubset(gridSetId); <line3> final int[] metaTilingFactors = layer.getMetaTilingFactors(); <line4> GeometryRasterMaskBuilder matrix = null; <line5> Entry entry; <line6> Geometry geom; <line7> try { <line8> while ((entry = reader.nextEntry()) != null) { <line9> if (entry.getUpdated() != null && entry.getUpdated().equals(previousEntryUpdate)) { <line10> } else { <line11> if (matrix == null) { <line12> matrix = new GeometryRasterMaskBuilder(gridSubset, metaTilingFactors, maxMaskLevel); <line13> } <line14> if ((entry.getUpdated() != null) <line15> && ((lastEntryUpdate == null) <line16> || (lastEntryUpdate.compareTo(entry.getUpdated()) < 0))) { <line17> lastEntryUpdate = entry.getUpdated(); <line18> } <line19> geom = entry.getWhere(); <line20> matrix.setMasksForGeometry(geom); <line21> } <line22> } <line23> } finally { <line24> if (matrix != null) { <line25> matrix.disposeGraphics(); <line26> } <line27> } <line28> return matrix; <line29> } <line30> } <line31> 	"<line10>          logger.warn(""Skipping entry with id ""+ entry.getId()+ "" since it has the same date as our last feed update."");"	task4	
public class A { <line0> static void gdalTransformation( <line1> File sourceFile, File file, WcsReaderRequest executedRequest, WcsReaderRequest targetRequest) <line2> throws IOException { <line3> File tmpDir = FileUtils.createTempDirectory(); <line4> try { <line5> File outFile = new File(tmpDir, sourceFile.getName()); <line6> reproject(sourceFile, executedRequest, targetRequest, outFile); <line7> transformFormat(outFile, executedRequest, targetRequest, file); <line8> } finally { <line9> FileUtils.delete(tmpDir); <line10> } <line11> } <line12> } <line13> 	"<line3>    LOG.info(""using GDAL command line to tranform the coverage"");"	task4	
public class A { <line0> @Override <line1> public SelectionCommandProcessor createPurgeCommandProcessor() { <line2> return (bounds, cmd) -> { <line3> if (LOGGER.isTraceEnabled()) { <line4> } <line5> myGeometryProcessor.purgeOccurred(bounds, null, cmd); <line6> }; <line7> } <line8> } <line9> 	"<line4>        LOGGER.trace(""Purge Occured: "" + cmd);"	task4	
public class A { <line0> @Override <line1> public String load(Long uid) { <line2> try { <line3> String userName = AlluxioFuseUtils.getGroupName(uid); <line4> return userName.isEmpty() ? DEFAULT_USER_NAME : userName; <line5> } catch (IOException e) { <line6> return DEFAULT_USER_NAME; <line7> } <line8> } <line9> } <line10> 	"<line6>      LOG.error(""Failed to get user name from uid {}, fallback to {}"", uid, DEFAULT_USER_NAME);"	task4	
public class A { <line0> @Override <line1> public void persistInterface(final MetaDataRegisterDTO metadata) { <line2> String rpcType = metadata.getRpcType(); <line3> String contextPath = metadata.getContextPath().substring(1); <line4> registerMetadata(rpcType, contextPath, metadata); <line5> if (RpcTypeEnum.HTTP.getName().equals(rpcType) <line6> || RpcTypeEnum.TARS.getName().equals(rpcType) <line7> || RpcTypeEnum.GRPC.getName().equals(rpcType)) { <line8> registerURI(rpcType, contextPath, metadata); <line9> } <line10> } <line11> } <line12> 	"<line10>    log.info(""{} zookeeper client register success: {}"", rpcType, metadata.toString());"	task4	
public class A { <line0> @Override <line1> public void handle( <line2> PacketClientCacheStatus packet, long currentTimeMillis, PlayerConnection connection) { <line3> connection.cachingSupported( <line4> packet.isEnabled() && connection.server().serverConfig().enableClientCache()); <line5> } <line6> } <line7> 	"<line3>    LOGGER.debug(""Setting client caching status to {}"", packet.isEnabled());"	task4	
"public class A { <line0> @Override <line1> public void portalInit() { <line2> try { <line3> doPortalInit(); <line4> } catch (Exception exception) { <line5> throw new IllegalStateException(""Unable to initialize portal"", exception); <line6> } <line7> } <line8> } <line9> "	<line5>      log.error(exception, exception);	task4	
"public class A { <line0> @Override <line1> public Repository findByG_N_P(long groupId, String name, String portletId) <line2> throws NoSuchRepositoryException { <line3> Repository repository = fetchByG_N_P(groupId, name, portletId); <line4> if (repository == null) { <line5> StringBundler sb = new StringBundler(8); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""groupId=""); <line8> sb.append(groupId); <line9> sb.append("", name=""); <line10> sb.append(name); <line11> sb.append("", portletId=""); <line12> sb.append(portletId); <line13> sb.append(""}""); <line14> if (log.isDebugEnabled()) { <line15> } <line16> throw new NoSuchRepositoryException(sb.toString()); <line17> } <line18> return repository; <line19> } <line20> } <line21> "	<line15>        log.debug(sb.toString());	task4	
"public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntry getFileEntry( <line1> HttpPrincipal httpPrincipal, long groupId, long folderId, String title) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(DLAppServiceUtil.class, ""getFileEntry"", _getFileEntryParameterTypes39); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, folderId, title); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.portal.kernel.repository.model.FileEntry) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
public class A { <line0> private Map<ParameterServerId, Integer> recoverPSAttemptIndex() { <line1> Map<ParameterServerId, Integer> psIdToAttemptIndexMap = null; <line2> if (appAttemptId.getAttemptId() > 1) { <line3> try { <line4> psIdToAttemptIndexMap = appStateStorage.loadPSMeta(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> return psIdToAttemptIndexMap; <line9> } <line10> } <line11> 	"<line6>        LOG.error(""load task meta from file failed."", e);"	task4	
public class A { <line0> @Override <line1> public void close() { <line2> for (ColumnFamilyHandle familyHandle : columnFamilyHandleMap.values()) { <line3> familyHandle.close(); <line4> } <line5> db.close(); <line6> } <line7> } <line8> 	"<line2>    logger.debug(""Close rocks db."");"	task4	
public class A { <line0> public void injectProxy( <line1> List<ArtifactRepository> repositories, List<org.apache.maven.settings.Proxy> proxies) { <line2> if (repositories != null) { <line3> for (ArtifactRepository repository : repositories) { <line4> org.apache.maven.settings.Proxy proxy = getProxy(repository, proxies); <line5> if (proxy != null) { <line6> SettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest(proxy); <line7> SettingsDecryptionResult result = settingsDecrypter.decrypt(request); <line8> proxy = result.getProxy(); <line9> if (logger.isDebugEnabled()) { <line10> for (SettingsProblem problem : result.getProblems()) { <line11> } <line12> } <line13> Proxy p = new Proxy(); <line14> p.setHost(proxy.getHost()); <line15> p.setProtocol(proxy.getProtocol()); <line16> p.setPort(proxy.getPort()); <line17> p.setNonProxyHosts(proxy.getNonProxyHosts()); <line18> p.setUserName(proxy.getUsername()); <line19> p.setPassword(proxy.getPassword()); <line20> repository.setProxy(p); <line21> } else { <line22> repository.setProxy(null); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> 	<line11>              logger.debug(problem.getMessage(), problem.getException());	task4	
public class A { <line0> public void blockAllInbound() { <line1> inboundSettings.clear(); <line2> setDefaultInboundSettings(false); <line3> } <line4> } <line5> 	"<line3>    LOGGER.debug(""[{}] Blocked inbound from all destinations"", address);"	task4	
"public class A { <line0> @POST <line1> @Path(""/{version:[vV][1]}/operationalEnvironments/{operationalEnvironmentId}/deactivate"") <line2> @Consumes(MediaType.APPLICATION_JSON) <line3> @Produces(MediaType.APPLICATION_JSON) <line4> @Operation( <line5> description = ""Deactivate an Operational Environment"", <line6> responses = <line7> @ApiResponse( <line8> content = <line9> @Content( <line10> array = @ArraySchema(schema = @Schema(implementation = Response.class))))) <line11> @Transactional <line12> public Response deactivateOperationEnvironment( <line13> String request, <line14> @PathParam(""version"") String version, <line15> @PathParam(""operationalEnvironmentId"") String operationalEnvironmentId, <line16> @Context ContainerRequestContext requestContext) <line17> throws ApiException { <line18> HashMap<String, String> instanceIdMap = new HashMap<>(); <line19> instanceIdMap.put(ENVIRONMENT_ID_KEY, operationalEnvironmentId); <line20> return cloudOrchestration( <line21> request, Action.deactivate, instanceIdMap, version, getRequestId(requestContext)); <line22> } <line23> } <line24> "	"<line18>    logger.debug(""Received request to Deactivate an Operational Environment"");"	task4	
"public class A { <line0> public void loadFont() throws InvalidFontException { <line1> if (ttf != null && font == null) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> String upperCaseTtf = ttf.trim().toUpperCase(); <line5> if (upperCaseTtf.endsWith("".TTF"") || upperCaseTtf.endsWith("".OTF"")) { <line6> font = AwtFontManager.instance().getAwtFont(jasperReportsContext, ttf); <line7> } else { <line8> FontUtil.getInstance(jasperReportsContext) <line9> .checkAwtFont( <line10> ttf, <line11> JRPropertiesUtil.getInstance(jasperReportsContext) <line12> .getBooleanProperty(JRStyledText.PROPERTY_AWT_IGNORE_MISSING_FONT)); <line13> font = <line14> new Font( <line15> ttf, <line16> Font.PLAIN, <line17> JRPropertiesUtil.getInstance(jasperReportsContext) <line18> .getIntegerProperty(JRFont.DEFAULT_FONT_SIZE)); <line19> } <line20> } <line21> } <line22> } <line23> "	"<line3>        log.debug(""Loading font "" + ttf);"	task4	
public class A { <line0> protected static void checkVersion( <line1> Set<TaskError> errors, String objectName, String field, String value) { <line2> try { <line3> Version.parseVersion(value); <line4> } catch (RuntimeException e) { <line5> errors.add(new TaskError(VERSION, field, objectName)); <line6> } <line7> } <line8> } <line9> 	"<line5>      LOGGER.error(""An exception occurred during validation of field - {}, objectName - {}, value - {}"",field,objectName,value);"	task4	
public class A { <line0> @BeforeClass <line1> public void createObjects() { <line2> log = LoggerFactory.getLogger(OptimizerTOSCADecember2015MultipleInputPointsTest.class); <line3> openInputFiles( <line4> TestConstants.APP_MODEL_FILENAME_MULTIPLE_INPUT_POINT, <line5> TestConstants.CLOUD_OFFER_FILENAME_IN_JSON_ATOS_7_MODULES); <line6> } <line7> } <line8> 	"<line3>    log.info(""Starting TEST optimizer for the TOSCA syntax of September 2015 Of an ""+ TEST_CHARACTERISTIC);"	task4	
public class A { <line0> public static void setCmsInstanceId(String id) { <line1> AuAssert.check(storedCmsInstanceId == null); <line2> storedCmsInstanceId = id; <line3> String bootstrapId = getBootstrapInstanceId(); <line4> if (!id.equals(bootstrapId)) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.warn(""Instance ID has changed from "" + bootstrapId + "" to "" + id);"	task4	
public class A { <line0> @Override <line1> public void onPaymentError(final PaymentErrorInternalEvent event) { <line2> notifyForCompletion(); <line3> } <line4> } <line5> 	"<line2>    log.info(""Got event PaymentError token='{}'"", event.getUserToken());"	task4	
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap <line1> addCommerceInventoryWarehouseItem( <line2> String externalReferenceCode, <line3> long userId, <line4> long commerceInventoryWarehouseId, <line5> String sku, <line6> int quantity) <line7> throws RemoteException { <line8> try { <line9> com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItem returnValue = <line10> CommerceInventoryWarehouseItemServiceUtil.addCommerceInventoryWarehouseItem( <line11> externalReferenceCode, userId, commerceInventoryWarehouseId, sku, quantity); <line12> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap.toSoapModel( <line13> returnValue); <line14> } catch (Exception exception) { <line15> throw new RemoteException(exception.getMessage()); <line16> } <line17> } <line18> } <line19> 	<line15>      log.error(exception, exception);	task4	
public class A { <line0> @OnWebSocketClose <line1> public void onClose(int statusCode, String reason) { <line2> String reasonToPass; <line3> LxErrorCode codeToPass; <line4> webSocketLock.lock(); <line5> try { <line6> if (security != null) { <line7> security.cancel(); <line8> } <line9> session = null; <line10> if (offlineCode != null) { <line11> codeToPass = offlineCode; <line12> reasonToPass = offlineReason; <line13> } else { <line14> codeToPass = LxErrorCode.getErrorCode(statusCode); <line15> reasonToPass = reason; <line16> } <line17> } finally { <line18> webSocketLock.unlock(); <line19> } <line20> responseLock.lock(); <line21> try { <line22> if (awaitedResponse != null) { <line23> awaitedResponse.subResponse = null; <line24> } <line25> responseAvailable.signalAll(); <line26> } finally { <line27> responseLock.unlock(); <line28> } <line29> thingHandler.setOffline(codeToPass, reasonToPass); <line30> } <line31> } <line32> 	"<line6>      logger.debug(""[{}] Websocket connection closed with code {} reason : {}"", debugId, statusCode, reason);"	task4	
public class A { <line0> public void channelActive(final ChannelHandlerContext ctx) throws Exception { <line1> } <line2> } <line3> 	"<line1>    LOGGER.info(""Channel active: {}"", ctx.channel());"	task4	
public class A { <line0> private void handleError(StateMachine.Fsm fsm) { <line1> while (timestampRequests.size() > 0) { <line2> RequestAndTimeout r = timestampRequests.remove(); <line3> if (r.getTimeout() != null) { <line4> r.getTimeout().cancel(); <line5> } <line6> queueRetryOrError(fsm, r.getRequest()); <line7> } <line8> Iterator<Map.Entry<Long, RequestAndTimeout>> iter = commitRequests.entrySet().iterator(); <line9> while (iter.hasNext()) { <line10> RequestAndTimeout r = iter.next().getValue(); <line11> if (r.getTimeout() != null) { <line12> r.getTimeout().cancel(); <line13> } <line14> queueRetryOrError(fsm, r.getRequest()); <line15> iter.remove(); <line16> } <line17> channel.close(); <line18> } <line19> } <line20> 	"<line1>    LOG.debug(""CONNECTED STATE: Cancelling Timeouts in handleError"");"	task4	
public class A { <line0> public static void registerGauge(String metricName, final long value) { <line1> try { <line2> MetricRegistry registry = Metrics.getInstance().getRegistry(); <line3> HoodieGauge guage = (HoodieGauge) registry.gauge(metricName, () -> new HoodieGauge<>(value)); <line4> guage.setValue(value); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.error(""Failed to send metrics: "", e);"	task4	
"public class A { <line0> public RetryPolicyFactory parse(Config retryPolicyConfig) { <line1> final Config boundedExponentialBackoffRetryConfig = <line2> new Configs().getConfig(retryPolicyConfig, BOUNDED_EXPONENTIAL_BACKOFF_RETRY_NAME); <line3> final long baseSleepTime = <line4> new Configs() <line5> .getNanoseconds( <line6> boundedExponentialBackoffRetryConfig, <line7> ""baseSleepTime"", <line8> TimeUnit.MILLISECONDS.toNanos(125)); <line9> final long maxSleepTime = <line10> new Configs() <line11> .getNanoseconds( <line12> boundedExponentialBackoffRetryConfig, ""maxSleepTime"", TimeUnit.SECONDS.toNanos(10)); <line13> final int maxRetries = <line14> new Configs().getInt(boundedExponentialBackoffRetryConfig, ""maxRetries"", 100); <line15> final long maxElapsedTime = <line16> new Configs() <line17> .getNanoseconds( <line18> boundedExponentialBackoffRetryConfig, <line19> ""maxElapsedTime"", <line20> TimeUnit.SECONDS.toNanos(3 * 60)); <line21> if (maxRetries <= 0 || maxElapsedTime <= 0) { <line22> return null; <line23> } <line24> return new DefaultRetryPolicyFactory( <line25> new FlexibleBoundedExponentialBackoffRetry( <line26> baseSleepTime, maxSleepTime, maxRetries, maxElapsedTime)); <line27> } <line28> } <line29> "	"<line21>    LOG.debug(""Parsed retry policy BoundedExponentialBackoffRetry with ""+ ""baseSleepTime:{}, maxSleepTime:{}, maxRetries:{}, maxElapsedTime:{}"",new Object[] {baseSleepTime, maxSleepTime, maxRetries, maxElapsedTime});"	task4	
"public class A { <line0> void addHandler(String key, EventHandlerMethod handler) { <line1> Preconditions.checkArgument( <line2> !this.handlers.containsKey(key), <line3> ""EventHandler can't be registered twice. Other instance: "" + this.handlers.get(key)); <line4> this.handlers.put(key, handler); <line5> EventHandlerMethod[] newArray = new EventHandlerMethod[this.insertIndex + 1]; <line6> if (this.sortedHandlerList.length > 0) { <line7> System.arraycopy(this.sortedHandlerList, 0, newArray, 0, this.sortedHandlerList.length); <line8> } <line9> newArray[this.insertIndex++] = handler; <line10> this.sortedHandlerList = newArray; <line11> this.dirty = true; <line12> } <line13> } <line14> "	"<line5>    LOGGER.debug(""Registering handler {} -> {}"", key, handler);"	task4	
public class A { <line0> @AsyncThread <line1> private void executeRightNow(final Runnable task) { <line2> try { <line3> task.run(); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.warn(String.format(""Unhandled exception happened when running %s"", task.getClass().getName()),t);"	task4	
public class A { <line0> private void removePeerMSPIDMap(final Peer peer) { <line1> Properties properties = peer.getProperties(); <line2> if (null != properties) { <line3> final String mspid = properties.getProperty(Peer.PEER_ORGANIZATION_MSPID_PROPERTY); <line4> if (!isNullOrEmpty(mspid)) { <line5> synchronized (peerMSPIDMap) { <line6> final Collection<Peer> peers = peerMSPIDMap.get(mspid); <line7> if (peers != null) { <line8> peers.remove(peer); <line9> if (peers.isEmpty()) { <line10> peerMSPIDMap.remove(mspid); <line11> } <line12> } <line13> } <line14> } <line15> } <line16> } <line17> } <line18> 	"<line5>        logger.debug(format(""Channel %s removing mapping peer %s to mspid %s"", name, peer, mspid));"	task4	
"public class A { <line0> private static String toString(final InputSource source) { <line1> try { <line2> final Reader reader = source.getReader(); <line3> if (null != reader) { <line4> if (reader instanceof StringReader) { <line5> final StringReader sr = (StringReader) reader; <line6> sr.reset(); <line7> } <line8> return IOUtils.toString(reader); <line9> } <line10> return """"; <line11> } catch (final IOException e) { <line12> return """"; <line13> } <line14> } <line15> } <line16> "	<line12>      LOG.error(e.getMessage(), e);	task4	
"public class A { <line0> private SaslServer createSaslKerberosServer( <line1> final AuthenticateCallbackHandler saslServerCallbackHandler, <line2> final Map<String, ?> configs, <line3> Subject subject) <line4> throws IOException { <line5> final String servicePrincipal = SaslClientAuthenticator.firstPrincipal(subject); <line6> KerberosName kerberosName; <line7> try { <line8> kerberosName = KerberosName.parse(servicePrincipal); <line9> } catch (IllegalArgumentException e) { <line10> throw new KafkaException(""Principal has name with unexpected format "" + servicePrincipal); <line11> } <line12> final String servicePrincipalName = kerberosName.serviceName(); <line13> final String serviceHostname = kerberosName.hostName(); <line14> try { <line15> return Subject.doAs( <line16> subject, <line17> (PrivilegedExceptionAction<SaslServer>) <line18> () -> <line19> Sasl.createSaslServer( <line20> saslMechanism, <line21> servicePrincipalName, <line22> serviceHostname, <line23> configs, <line24> saslServerCallbackHandler)); <line25> } catch (PrivilegedActionException e) { <line26> throw new SaslException( <line27> ""Kafka Server failed to create a SaslServer to interact with a client during session"" <line28> + "" authentication"", <line29> e.getCause()); <line30> } <line31> } <line32> } <line33> "	"<line14>    LOG.debug(""Creating SaslServer for {} with mechanism {}"", kerberosName, saslMechanism);"	task4	
public class A { <line0> private void prepareCek() { <line1> ASN1ObjectIdentifier param = <line2> new ASN1ObjectIdentifier(msg.getComputations().getEncryptionParamSet().getValue()); <line3> String sBoxName = oidMappings.get(param); <line4> byte[] wrapped = wrap(true, msg.getComputations().getPremasterSecret().getValue(), sBoxName); <line5> byte[] cek = new byte[32]; <line6> try { <line7> if (wrapped.length <= cek.length) { <line8> System.arraycopy(wrapped, 0, cek, 0, cek.length); <line9> } else { <line10> System.arraycopy(wrapped, 0, cek, 0, wrapped.length - 1); <line11> } <line12> } catch (ArrayIndexOutOfBoundsException E) { <line13> } <line14> msg.getComputations().setEncryptedKey(cek); <line15> byte[] mac = new byte[wrapped.length - cek.length]; <line16> System.arraycopy(wrapped, cek.length, mac, 0, mac.length); <line17> msg.getComputations().setMacKey(mac); <line18> } <line19> } <line20> 	"<line13>      LOGGER.warn(""Something going wrong here..."");"	task4	
"public class A { <line0> private void createScope() { <line1> Scope scope = new Scope(); <line2> scope.setName(SCOPE_NAME); <line3> scope.setType(Scope.TYPE); <line4> scope.setDescription(""Sample scope description.""); <line5> Scope createdScope = this.client.create(scope); <line6> } <line7> } <line8> "	"<line6>    LOGGER.info(""Created scope object returned to client : "" + createdScope.toJsonString());"	task4	
"public class A { <line0> public TransferredResource createFolder(String parentUUID, String folderName) <line1> throws GenericException, NotFoundException, AuthorizationDeniedException { <line2> Path parentPath; <line3> RodaCoreFactory.checkIfWriteIsAllowedAndIfFalseThrowException(nodeType); <line4> if (parentUUID != null) { <line5> TransferredResource parent = <line6> index.retrieve(TransferredResource.class, parentUUID, fieldsToReturn); <line7> parentPath = basePath.resolve(parent.getRelativePath()); <line8> } else { <line9> parentPath = basePath; <line10> } <line11> try { <line12> Path createdPath = Files.createDirectories(parentPath.resolve(folderName)); <line13> BasicFileAttributes attrs = Files.readAttributes(createdPath, BasicFileAttributes.class); <line14> TransferredResource resource = <line15> createTransferredResource(createdPath, attrs, 0L, basePath, new Date()); <line16> index.create(TransferredResource.class, resource); <line17> return resource; <line18> } catch (IOException e) { <line19> throw new GenericException(""Cannot create folder"", e); <line20> } <line21> } <line22> } <line23> "	"<line19>      LOGGER.error(""Cannot create folder"", e);"	task4	
public class A { <line0> private void createTimers(final String dbId, List<PersistenceStrategy> strategies) { <line1> for (PersistenceStrategy strategy : strategies) { <line2> if (strategy instanceof PersistenceCronStrategy) { <line3> PersistenceCronStrategy cronStrategy = (PersistenceCronStrategy) strategy; <line4> String cronExpression = cronStrategy.getCronExpression(); <line5> final PersistItemsJob job = new PersistItemsJob(this, dbId, cronStrategy.getName()); <line6> ScheduledCompletableFuture<?> schedule = scheduler.schedule(job, cronExpression); <line7> if (persistenceJobs.containsKey(dbId)) { <line8> persistenceJobs.get(dbId).add(schedule); <line9> } else { <line10> final Set<ScheduledCompletableFuture<?>> jobs = new HashSet<>(); <line11> jobs.add(schedule); <line12> persistenceJobs.put(dbId, jobs); <line13> } <line14> } <line15> } <line16> } <line17> } <line18> 	"<line14>        logger.debug(""Scheduled strategy {} with cron expression {}"",cronStrategy.getName(),cronExpression);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> registerAndInitializeHandler(child, getThingHandlerFactory(child)); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.error(""Registration resp. initialization of child '{}' of bridge '{}' has been failed: {}"",child.getUID(),bridge.getUID(),ex.getMessage(),ex);"	task4	
public class A { <line0> public void onDialogRelease(DialogRelease evt, ActivityContextInterface aci) { <line1> if (logger.isInfoEnabled()) { <line2> } <line3> } <line4> } <line5> 	"<line2>      this.logger.info(""Rx :  DialogRelease="" + evt);"	task4	
"public class A { <line0> @Test(timeout = 60000) <line1> public void testDisableCompaction() throws Exception { <line2> LedgerHandle[] lhs = prepareData(3, false); <line3> baseConf.setMinorCompactionThreshold(0.0f); <line4> baseConf.setMajorCompactionThreshold(0.0f); <line5> restartBookies(baseConf); <line6> bkc.deleteLedger(lhs[1].getId()); <line7> bkc.deleteLedger(lhs[2].getId()); <line8> Thread.sleep(baseConf.getMajorCompactionInterval() * 1000 + baseConf.getGcWaitTime()); <line9> for (File ledgerDirectory : tmpDirs) { <line10> assertTrue( <line11> ""Not Found entry log file ([0,1].log that should have been compacted in ledgerDirectory: "" <line12> + ledgerDirectory, <line13> TestUtils.hasLogFiles(ledgerDirectory, false, 0, 1)); <line14> } <line15> } <line16> } <line17> "	"<line8>    LOG.info(""Finished deleting the ledgers contains most entries."");"	task4	
public class A { <line0> public String enqueueUpdateDeviceSslCertificationRequest( <line1> final String organisationIdentification, <line2> final String deviceIdentification, <line3> final Certification certification, <line4> final int messagePriority) <line5> throws FunctionalException { <line6> final Organisation organisation = <line7> this.domainHelperService.findOrganisation(organisationIdentification); <line8> final Device device = this.domainHelperService.findActiveDevice(deviceIdentification); <line9> this.domainHelperService.isAllowed( <line10> organisation, device, DeviceFunction.UPDATE_DEVICE_SSL_CERTIFICATION); <line11> this.domainHelperService.isInMaintenance(device); <line12> final String correlationUid = <line13> this.correlationIdProviderService.getCorrelationId( <line14> organisationIdentification, deviceIdentification); <line15> final DeviceMessageMetadata deviceMessageMetadata = <line16> new DeviceMessageMetadata( <line17> deviceIdentification, <line18> organisationIdentification, <line19> correlationUid, <line20> MessageType.UPDATE_DEVICE_SSL_CERTIFICATION.name(), <line21> messagePriority); <line22> final CommonRequestMessage message = <line23> new CommonRequestMessage.Builder() <line24> .deviceMessageMetadata(deviceMessageMetadata) <line25> .request(certification) <line26> .build(); <line27> this.commonRequestMessageSender.send(message); <line28> return correlationUid; <line29> } <line30> } <line31> 	"<line12>    LOGGER.debug(""enqueueUpdateDeviceSslCertificationRequest called with organisation {} and device {}"",organisationIdentification,deviceIdentification);"	task4	
public class A { <line0> private void updateTaskWithChangedElementProperties() { <line1> if (!changedElementProperties.isEmpty()) { <line2> getTaskService().updateChangedElementProperties(task.getId(), changedElementProperties); <line3> changedElementProperties.clear(); <line4> } <line5> isModelModified = false; <line6> this.setPartName(EditorUtil.getEditorName(cnAElement) + Messages.BSIElementEditor_9); <line7> this.setTitleToolTip(EditorUtil.getEditorToolTipText(cnAElement)); <line8> firePropertyChange(IEditorPart.PROP_DIRTY); <line9> } <line10> } <line11> 	"<line4>      LOG.info(""Updated task: saved changes in element properties."");"	task4	
"public class A { <line0> public void truncate(String resourcePattern) throws IOException { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> try { <line4> dataSource.delete(basePath, FilePattern.compile(resourcePattern), true, new Counter()); <line5> } catch (InterruptedException e) { <line6> throw (IOException) new InterruptedIOException(""interrupted"").initCause(e); <line7> } <line8> } <line9> } <line10> "	"<line2>      LOG.debug(MessageFormat.format(""Truncating Direct I/O resources: {0}:{1} (id={2})"", fullPath, resourcePattern, id));"	task4	
"public class A { <line0> public void doCreateConsumer( <line1> RoutingContext routingContext, <line2> JsonObject bodyAsJson, <line3> Handler<SinkBridgeEndpoint<K, V>> handler) { <line4> this.groupId = routingContext.pathParam(""groupid""); <line5> this.name = <line6> bodyAsJson.getString( <line7> ""name"", <line8> bridgeConfig.getBridgeID() == null <line9> ? ""kafka-bridge-consumer-"" + UUID.randomUUID() <line10> : bridgeConfig.getBridgeID() + ""-"" + UUID.randomUUID()); <line11> this.consumerInstanceId = new ConsumerInstanceId(this.groupId, this.name); <line12> if (this.httpBridgeContext.getHttpSinkEndpoints().containsKey(this.consumerInstanceId)) { <line13> HttpBridgeError error = <line14> new HttpBridgeError( <line15> HttpResponseStatus.CONFLICT.code(), <line16> ""A consumer instance with the specified name already exists in the Kafka Bridge.""); <line17> HttpUtils.sendResponse( <line18> routingContext, <line19> HttpResponseStatus.CONFLICT.code(), <line20> BridgeContentType.KAFKA_JSON, <line21> error.toJson().toBuffer()); <line22> return; <line23> } <line24> String requestUri = this.buildRequestUri(routingContext); <line25> if (!routingContext.request().path().endsWith(""/"")) { <line26> requestUri += ""/""; <line27> } <line28> String consumerBaseUri = requestUri + ""instances/"" + this.name; <line29> Properties config = new Properties(); <line30> addConfigParameter( <line31> ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <line32> bodyAsJson.getString(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, null), <line33> config); <line34> Object enableAutoCommit = bodyAsJson.getValue(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG); <line35> addConfigParameter( <line36> ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <line37> enableAutoCommit != null ? String.valueOf(enableAutoCommit) : null, <line38> config); <line39> Object fetchMinBytes = bodyAsJson.getValue(ConsumerConfig.FETCH_MIN_BYTES_CONFIG); <line40> addConfigParameter( <line41> ConsumerConfig.FETCH_MIN_BYTES_CONFIG, <line42> fetchMinBytes != null ? String.valueOf(fetchMinBytes) : null, <line43> config); <line44> Object requestTimeoutMs = <line45> bodyAsJson.getValue(""consumer."" + ConsumerConfig.REQUEST_TIMEOUT_MS_CONFIG); <line46> addConfigParameter( <line47> ConsumerConfig.REQUEST_TIMEOUT_MS_CONFIG, <line48> requestTimeoutMs != null ? String.valueOf(requestTimeoutMs) : null, <line49> config); <line50> addConfigParameter(ConsumerConfig.CLIENT_ID_CONFIG, this.name, config); <line51> this.initConsumer(false, config); <line52> handler.handle(this); <line53> JsonObject body = <line54> new JsonObject().put(""instance_id"", this.name).put(""base_uri"", consumerBaseUri); <line55> HttpUtils.sendResponse( <line56> routingContext, <line57> HttpResponseStatus.OK.code(), <line58> BridgeContentType.KAFKA_JSON, <line59> body.toBuffer()); <line60> } <line61> } <line62> "	"<line53>    log.info(""Created consumer {} in group {}"", this.name, this.groupId);"	task4	
"public class A { <line0> @Test <line1> public void test() throws Exception { <line2> MockEndpoint result = getMockEndpoint(""mock:result""); <line3> result.setExpectedCount(1); <line4> final ProducerTemplate producerTemplate = context.createProducerTemplate(); <line5> ClassLoader tccl = Thread.currentThread().getContextClassLoader(); <line6> InputStream payloadIs = tccl.getResourceAsStream(""json-source.json""); <line7> producerTemplate.sendBody(""direct:start"", payloadIs); <line8> assertMockEndpointsSatisfied(); <line9> final String body = result.getExchanges().get(0).getIn().getBody(String.class); <line10> assertNotNull(body); <line11> InputStream schemaIs = tccl.getResourceAsStream(""xml-target-schemaset.xml""); <line12> AtlasXmlSchemaSetParser schemaParser = new AtlasXmlSchemaSetParser(tccl); <line13> Validator validator = schemaParser.createSchema(schemaIs).newValidator(); <line14> StreamSource source = new StreamSource(new StringReader(body)); <line15> validator.validate(source); <line16> } <line17> } <line18> "	"<line11>    LOG.debug("">>>>> {}"", body);"	task4	
"public class A { <line0> @Override <line1> public PCollection<Row> buildIOReader( <line2> PBegin begin, BeamSqlTableFilter filters, List<String> fieldNames) { <line3> final Schema schema = AvroUtils.toAvroSchema(table.getSchema()); <line4> Read read = ParquetIO.read(schema).withBeamSchemas(true).from(table.getLocation() + ""/*""); <line5> if (!fieldNames.isEmpty()) { <line6> Schema projectionSchema = projectSchema(schema, fieldNames); <line7> read = read.withProjection(projectionSchema, projectionSchema); <line8> } <line9> return begin.apply(""ParquetIORead"", read).apply(""ToRows"", Convert.toRows()); <line10> } <line11> } <line12> "	"<line7>      LOG.info(""Projecting fields schema : "" + projectionSchema.toString());"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private static int[] getSizeCoefficients(Class cl, boolean debug) { <line2> int primitives = 0; <line3> int arrays = 0; <line4> int references = nrOfRefsPerObj; <line5> int index = 0; <line6> for (; null != cl; cl = cl.getSuperclass()) { <line7> Field[] field = cl.getDeclaredFields(); <line8> if (null != field) { <line9> for (Field aField : field) { <line10> if (Modifier.isStatic(aField.getModifiers())) continue; <line11> Class fieldClass = aField.getType(); <line12> if (fieldClass.isArray()) { <line13> arrays++; <line14> references++; <line15> } else if (!fieldClass.isPrimitive()) { <line16> references++; <line17> } else { <line18> String name = fieldClass.getName(); <line19> if (name.equals(""int"") || name.equals(""I"")) primitives += Bytes.SIZEOF_INT; <line20> else if (name.equals(""long"") || name.equals(""J"")) primitives += Bytes.SIZEOF_LONG; <line21> else if (name.equals(""boolean"") || name.equals(""Z"")) primitives += Bytes.SIZEOF_BOOLEAN; <line22> else if (name.equals(""short"") || name.equals(""S"")) primitives += Bytes.SIZEOF_SHORT; <line23> else if (name.equals(""byte"") || name.equals(""B"")) primitives += Bytes.SIZEOF_BYTE; <line24> else if (name.equals(""char"") || name.equals(""C"")) primitives += Bytes.SIZEOF_CHAR; <line25> else if (name.equals(""float"") || name.equals(""F"")) primitives += Bytes.SIZEOF_FLOAT; <line26> else if (name.equals(""double"") || name.equals(""D"")) primitives += Bytes.SIZEOF_DOUBLE; <line27> } <line28> if (debug) { <line29> if (LOG.isDebugEnabled()) { <line30> } <line31> } <line32> index++; <line33> } <line34> } <line35> } <line36> return new int[] {primitives, arrays, references}; <line37> } <line38> } <line39> "	"<line30>              LOG.debug("""" + index + "" "" + aField.getName() + "" "" + aField.getType());"	task4	
"public class A { <line0> protected void addDefaultServlets(ContextHandlerCollection contexts, Configuration conf) <line1> throws IOException { <line2> addPrivilegedServlet(""stacks"", ""/stacks"", StackServlet.class); <line3> addPrivilegedServlet(""logLevel"", ""/logLevel"", LogLevel.Servlet.class); <line4> try { <line5> Class<?> clz = Class.forName(""org.apache.hadoop.metrics.MetricsServlet""); <line6> addPrivilegedServlet(""metrics"", ""/metrics"", clz.asSubclass(HttpServlet.class)); <line7> } catch (Exception e) { <line8> } <line9> addPrivilegedServlet(""jmx"", ""/jmx"", JMXJsonServlet.class); <line10> if (conf.getBoolean(HTTP_PRIVILEGED_CONF_KEY, HTTP_PRIVILEGED_CONF_DEFAULT)) { <line11> addPrivilegedServlet(""conf"", ""/conf"", ConfServlet.class); <line12> } else { <line13> addUnprivilegedServlet(""conf"", ""/conf"", ConfServlet.class); <line14> } <line15> final String asyncProfilerHome = ProfileServlet.getAsyncProfilerHome(); <line16> if (asyncProfilerHome != null && !asyncProfilerHome.trim().isEmpty()) { <line17> addPrivilegedServlet(""prof"", ""/prof"", ProfileServlet.class); <line18> Path tmpDir = Paths.get(ProfileServlet.OUTPUT_DIR); <line19> if (Files.notExists(tmpDir)) { <line20> Files.createDirectories(tmpDir); <line21> } <line22> ServletContextHandler genCtx = new ServletContextHandler(contexts, ""/prof-output""); <line23> genCtx.addServlet(ProfileOutputServlet.class, ""/*""); <line24> genCtx.setResourceBase(tmpDir.toAbsolutePath().toString()); <line25> genCtx.setDisplayName(""prof-output""); <line26> } else { <line27> addUnprivilegedServlet(""prof"", ""/prof"", ProfileServlet.DisabledServlet.class); <line28> } <line29> } <line30> } <line31> "	"<line28>      LOG.info(""ASYNC_PROFILER_HOME environment variable and async.profiler.home system property ""+ ""not specified. Disabling /prof endpoint."");"	task4	
public class A { <line0> @Override <line1> public <K, V> BlockDiskCache<K, V> createCache( <line2> final AuxiliaryCacheAttributes iaca, <line3> final ICompositeCacheManager cacheMgr, <line4> final ICacheEventLogger cacheEventLogger, <line5> final IElementSerializer elementSerializer) { <line6> final BlockDiskCacheAttributes idca = (BlockDiskCacheAttributes) iaca; <line7> final BlockDiskCache<K, V> cache = new BlockDiskCache<>(idca, elementSerializer); <line8> cache.setCacheEventLogger(cacheEventLogger); <line9> return cache; <line10> } <line11> } <line12> 	"<line7>    log.debug(""Creating DiskCache for attributes = {0}"", idca);"	task4	
public class A { <line0> @Override <line1> protected Object getEndpointInternal(MessageContext messageContext) throws Exception { <line2> T key = getLookupKeyForMessage(messageContext); <line3> if (key == null) { <line4> return null; <line5> } <line6> if (logger.isDebugEnabled()) { <line7> } <line8> return lookupEndpoint(key); <line9> } <line10> } <line11> 	"<line7>      logger.debug(""Looking up endpoint for ["" + key + ""]"");"	task4	
public class A { <line0> @Override <line1> public void contribute(Document document, ObjectEntry objectEntry) { <line2> try { <line3> _contribute(document, objectEntry); <line4> } catch (Exception exception) { <line5> if (log.isWarnEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        log.warn(""Unable to index object entry "" + objectEntry.getObjectEntryId(), exception);"	task4	
"public class A { <line0> @PostConstruct <line1> public void init() { <line2> logger = LoggerFactory.getLogger(getClass()); <line3> dataList = new ArrayList<Data>(); <line4> for (int i = 0; i < 20; i++) { <line5> Data data = new Data(); <line6> data.setText(MessageFormat.format(""Item {0}"", i)); <line7> dataList.add(data); <line8> } <line9> matrixRows = new ArrayList<MatrixRow>(); <line10> for (int i = 0; i < MATRIX_DIMENSION; i++) { <line11> MatrixRow matrixRow = new MatrixRow(); <line12> for (int j = 0; j < MATRIX_DIMENSION; j++) { <line13> MatrixCell matrixCell = new MatrixCell(); <line14> matrixRow.addCell(matrixCell); <line15> } <line16> matrixRows.add(matrixRow); <line17> } <line18> attributes = Attributes.getComponentAttributesFromFacesConfig(UIRepeat.class, getClass()); <line19> attributes.setAttribute(""rendered"", true); <line20> attributes.remove(""componentState""); <line21> attributes.remove(""iterationState""); <line22> attributes.remove(""iterationStatusVar""); <line23> attributes.remove(""rowKeyVar""); <line24> attributes.remove(""rowKeyConverter""); <line25> attributes.remove(""value""); <line26> attributes.remove(""stateVar""); <line27> attributes.remove(""var""); <line28> attributes.remove(""relativeRowIndex""); <line29> attributes.remove(""rowAvailable""); <line30> attributes.remove(""rowCount""); <line31> attributes.remove(""rowData""); <line32> attributes.remove(""rowIndex""); <line33> attributes.remove(""rowKey""); <line34> } <line35> } <line36> "	"<line3>    logger.debug(""initializing bean "" + getClass().getName());"	task4	
"public class A { <line0> public static <T extends ConfigDefaults> String getDefaultValue( <line1> Class<T> target, String fieldValue) { <line2> for (final Field f : target.getFields()) { <line3> try { <line4> if (!fieldValue.equals(f.get(target).toString())) { <line5> continue; <line6> } <line7> if (f.isAnnotationPresent(DefaultValue.class)) { <line8> return f.getAnnotation(DefaultValue.class).value(); <line9> } else if (f.isAnnotationPresent(DefaultValueInt.class)) { <line10> return Integer.toString(f.getAnnotation(DefaultValueInt.class).value()); <line11> } else if (f.isAnnotationPresent(DefaultValueBoolean.class)) { <line12> return Boolean.toString(f.getAnnotation(DefaultValueBoolean.class).value()); <line13> } <line14> } catch (IllegalAccessException e) { <line15> } <line16> } <line17> throw new IllegalArgumentException( <line18> target.getName() + "" has no default-annotated field "" + fieldValue); <line19> } <line20> } <line21> "	<line15>        LOGGER.warn(UNABLE_TO_ACCESS_FIELD_ON_OBJECT, f.getName(), target);	task4	
public class A { <line0> @Override <line1> public synchronized void shutdown() throws Exception { <line2> this.scheduledExecution.cancel(true); <line3> super.shutdown(); <line4> } <line5> } <line6> 	"<line2>    logger.info(""bot is shutting down"");"	task4	
"public class A { <line0> public String get(String name, String defaultValue) { <line1> String answer = null; <line2> if (envContext != null) { <line3> try { <line4> answer = (String) envContext.lookup(""hawtio/"" + name); <line5> } catch (Exception e) { <line6> } <line7> } <line8> if (answer == null) { <line9> answer = this.propertyResolver.apply(name); <line10> } <line11> if (answer == null) { <line12> answer = defaultValue; <line13> } <line14> return answer; <line15> } <line16> } <line17> "	"<line14>    LOG.debug(""Property {} is set to value {}"", name, answer);"	task4	
public class A { <line0> private boolean isPatternInDatabase(TestSuiteRun testSuiteRun) { <line1> boolean valid = false; <line2> SimpleDBKey dbKey = new SimpleDBKey(testSuiteRun.getCompany(), testSuiteRun.getProject()); <line3> String patternCorrelationId = testSuiteRun.getPatternCorrelationId(); <line4> String patternSuiteName = testSuiteRun.getPatternSuite(); <line5> if (patternCorrelationId == null && patternSuiteName == null) { <line6> valid = true; <line7> } else { <line8> Suite patternSuite = null; <line9> try { <line10> if (patternCorrelationId != null) { <line11> patternSuite = metadataDAO.getSuite(dbKey, patternCorrelationId); <line12> } else { <line13> patternSuite = metadataDAO.getLatestRun(dbKey, patternSuiteName); <line14> } <line15> } catch (StorageException se) { <line16> } <line17> if (patternSuite != null) { <line18> valid = true; <line19> } <line20> } <line21> return valid; <line22> } <line23> } <line24> 	"<line16>        LOG.error(""error while retrieving suite from mongo db: '{}', correlationId: '{}', suiteName:""+ "" '{}'"",dbKey,patternCorrelationId,patternSuiteName,se);"	task4	
public class A { <line0> public static Collection<RoomUsersView> getRoomUsers(UUID roomId) { <line1> try { <line2> return session.getRoomUsers(roomId); <line3> } catch (MageRemoteException e) { <line4> return Collections.emptyList(); <line5> } <line6> } <line7> } <line8> 	<line4>      logger.info(e);	task4	
public class A { <line0> private void removeFromTimeline(Collection<? extends Geometry> geoms, String dataTypeKey) { <line1> Collection<Long> ids = New.list(geoms.size()); <line2> for (Geometry geom : geoms) { <line3> if (geom instanceof TileGeometry) { <line4> TileGeometry tileGeometry = (TileGeometry) geom; <line5> if (tileGeometry.getDataModelId() != -1) { <line6> ids.add(Long.valueOf(tileGeometry.getDataModelId())); <line7> } <line8> } <line9> } <line10> if (!ids.isEmpty()) { <line11> DataTypeInfo dataType; <line12> synchronized (myDataTypeCache) { <line13> dataType = myDataTypeCache.apply(dataTypeKey); <line14> } <line15> if (dataType != null) { <line16> TimelineRegistry timelineRegistry = myToolbox.getUIRegistry().getTimelineRegistry(); <line17> timelineRegistry.removeData(dataType.getOrderKey(), ids); <line18> } else { <line19> } <line20> } <line21> } <line22> } <line23> 	"<line19>        LOGGER.error(""Failed to remove timeline data - no data type found for "" + dataTypeKey);"	task4	
public class A { <line0> @Override <line1> protected void onPostExecute(Void result) { <line2> super.onPostExecute(result); <line3> activity.showKeyFingerprints(); <line4> } <line5> } <line6> 	"<line3>    logger.trace(""onPostExecute()"");"	task4	
"public class A { <line0> @Override <line1> public void createSubscriptionData( <line2> final ByteString topic, <line3> final ByteString subscriberId, <line4> final SubscriptionData data, <line5> final Callback<Version> callback, <line6> final Object ctx) { <line7> ZkUtils.createFullPathOptimistic( <line8> zk, <line9> topicSubscriberPath(topic, subscriberId), <line10> data.toByteArray(), <line11> Ids.OPEN_ACL_UNSAFE, <line12> CreateMode.PERSISTENT, <line13> new SafeAsyncZKCallback.StringCallback() { <line14> @Override <line15> public void safeProcessResult(int rc, String path, Object ctx, String name) { <line16> if (rc == Code.NODEEXISTS.intValue()) { <line17> callback.operationFailed( <line18> ctx, <line19> PubSubException.create( <line20> StatusCode.SUBSCRIPTION_STATE_EXISTS, <line21> ""Subscription state for (topic:"" <line22> + topic.toStringUtf8() <line23> + "", subscriber:"" <line24> + subscriberId.toStringUtf8() <line25> + "") existed."")); <line26> return; <line27> } else if (rc == Code.OK.intValue()) { <line28> if (logger.isDebugEnabled()) { <line29> } <line30> callback.operationFinished(ctx, new ZkVersion(0)); <line31> } else { <line32> KeeperException ke = <line33> ZkUtils.logErrorAndCreateZKException( <line34> ""Could not record new subscription for topic: "" <line35> + topic.toStringUtf8() <line36> + "" subscriberId: "" <line37> + subscriberId.toStringUtf8(), <line38> path, <line39> rc); <line40> callback.operationFailed(ctx, new PubSubException.ServiceDownException(ke)); <line41> } <line42> } <line43> }, <line44> ctx); <line45> } <line46> } <line47> "	"<line29>                logger.debug(""Successfully recorded subscription for topic: ""+ topic.toStringUtf8()+ "" subscriberId: ""+ subscriberId.toStringUtf8()+ "" data: ""+ SubscriptionStateUtils.toString(data));"	task4	
public class A { <line0> private Long readForcedShardId() { <line1> Long res = null; <line2> String envVal = System.getProperty(FORCED_SHARD_ID_ENV); <line3> if (envVal != null) { <line4> try { <line5> res = Long.parseLong(envVal); <line6> } catch (NumberFormatException ex) { <line7> } <line8> } <line9> return res; <line10> } <line11> } <line12> 	"<line7>        log.debug(""Invalid shard ID:{}"", envVal);"	task4	
"public class A { <line0> @Override <line1> public double f(final double... x) { <line2> if (x.length != 1) { <line3> String msg = ""Laguerre(n,m;x) needs one argument""; <line4> throw new IllegalArgumentException(msg); <line5> } <line6> double ret = laguerre(n, m, x[0]); <line7> if (signed) ret = -ret; <line8> return ret; <line9> } <line10> } <line11> "	<line4>      logger.warn(msg);	task4	
public class A { <line0> private void bindPrimitive(final Named key, final long value) { <line1> bindConstant().annotatedWith(key).to(value); <line2> } <line3> } <line4> 	"<line2>    LOG.trace(""bound {} to {}"", key.value(), value);"	task4	
"public class A { <line0> public InternalCompletableFuture<Void> promoteToCPMember() { <line1> InternalCompletableFuture<Void> future = newCompletableFuture(); <line2> if (!metadataGroupManager.isDiscoveryCompleted()) { <line3> return complete( <line4> future, new IllegalStateException(""CP Subsystem discovery is not completed yet!"")); <line5> } <line6> if (nodeEngine.getLocalMember().isLiteMember()) { <line7> return complete( <line8> future, new IllegalStateException(""Lite members cannot be promoted to CP member!"")); <line9> } <line10> if (getLocalCPMember() != null) { <line11> future.complete(null); <line12> return future; <line13> } <line14> MemberImpl localMember = nodeEngine.getLocalMember(); <line15> CPMemberInfo member = new CPMemberInfo(newUnsecureUUID(), localMember.getAddress()); <line16> invocationManager <line17> .invoke(getMetadataGroupId(), new AddCPMemberOp(member)) <line18> .whenCompleteAsync( <line19> (response, t) -> { <line20> if (t == null) { <line21> metadataGroupManager.initPromotedCPMember(member); <line22> future.complete(null); <line23> } else { <line24> complete(future, t); <line25> } <line26> }); <line27> return future; <line28> } <line29> } <line30> "	"<line16>    logger.info(""Adding new CP member: "" + member);"	task4	
"public class A { <line0> public static InputStream getLocalizedFile( <line1> final String fullPath, final Locale locale, final IDocumentResourceLoader loader) { <line2> String language = locale.getLanguage(); <line3> String country = locale.getCountry(); <line4> String variant = locale.getVariant(); <line5> String fileName = fullPath; <line6> int dotIndex = fileName.indexOf('.'); <line7> String baseName = dotIndex == -1 ? fileName : fileName.substring(0, dotIndex); <line8> String extension = dotIndex == -1 ? """" : fileName.substring(dotIndex); <line9> InputStream in = null; <line10> try { <line11> if (!variant.equals("""")) { <line12> in = loader.loadXsl(baseName + ""_"" + language + ""_"" + country + ""_"" + variant + extension); <line13> } <line14> if (in == null) { <line15> in = loader.loadXsl(baseName + ""_"" + language + ""_"" + country + extension); <line16> } <line17> if (in == null) { <line18> in = loader.loadXsl(baseName + ""_"" + language + extension); <line19> } <line20> if (in == null) { <line21> in = loader.loadXsl(baseName + extension); <line22> } <line23> } catch (Exception e) { <line24> } <line25> return in; <line26> } <line27> } <line28> "	"<line24>      Logger.error(XmlHelper.class.getName(), ""Error loading localized file: "" + fullPath);"	task4	
"public class A { <line0> @Override <line1> public void doInAfterTrace( <line2> SpanEventRecorder recorder, <line3> Object target, <line4> Object[] args, <line5> Object result, <line6> Throwable throwable) { <line7> String endPoint = null; <line8> if (target instanceof EndPointAccessor) { <line9> endPoint = ((EndPointAccessor) target)._$PINPOINT$_getEndPoint(); <line10> } <line11> final InterceptorScopeInvocation invocation = interceptorScope.getCurrentInvocation(); <line12> final Object attachment = getAttachment(invocation); <line13> if (attachment instanceof CommandContext) { <line14> final CommandContext commandContext = (CommandContext) attachment; <line15> if (logger.isDebugEnabled()) { <line16> } <line17> recordIo(recorder, commandContext); <line18> invocation.removeAttachment(); <line19> } <line20> recorder.recordApi(getMethodDescriptor()); <line21> recorder.recordEndPoint(endPoint != null ? endPoint : ""Unknown""); <line22> recorder.recordDestinationId(JedisConstants.REDIS.getName()); <line23> recorder.recordServiceType(JedisConstants.REDIS); <line24> recorder.recordException(throwable); <line25> } <line26> } <line27> "	"<line16>        logger.debug(""Check command context {}"", commandContext);"	task4	
public class A { <line0> @Override <line1> public boolean deployPlanReference( <line2> final QName planId, final PlanModelReference planRef, final CsarId csarId) { <line3> if (storage == null) { <line4> return false; <line5> } <line6> Path planLocation = planLocationOnDisk(csarId, planId, planRef); <line7> if (planLocation == null) { <line8> return false; <line9> } <line10> return this.deployPlanFile(planLocation, csarId, planId, new HashMap<String, String>()); <line11> } <line12> } <line13> 	"<line4>      LOG.error(""Can't fetch relevant Csar from storage: StorageService not available"");"	task4	
"public class A { <line0> protected static void validateReturnedOutOfBandHeaderWithInsertion( <line1> Map<String, Object> responseContext, boolean expect) { <line2> List<OutofBandHeader> hdrToTest = new ArrayList<>(); <line3> List<Header> oobHdr = CastUtils.cast((List<?>) responseContext.get(Header.HEADER_LIST)); <line4> if (!expect) { <line5> if (oobHdr == null || (oobHdr != null && oobHdr.size() == 0)) { <line6> return; <line7> } <line8> fail(""Should have got *no* out-of-band headers, but some were found""); <line9> } <line10> if (oobHdr == null) { <line11> fail(""Should have got List of out-of-band headers""); <line12> } <line13> assertEquals( <line14> 2, <line15> oobHdr.size(), <line16> ""HeaderHolder list expected to conain 2 object received "" + oobHdr.size()); <line17> for (Header hdr1 : oobHdr) { <line18> if (hdr1.getObject() instanceof Node) { <line19> try { <line20> JAXBElement<?> job = <line21> (JAXBElement<?>) <line22> JAXBContext.newInstance(org.apache.cxf.outofband.header.ObjectFactory.class) <line23> .createUnmarshaller() <line24> .unmarshal((Node) hdr1.getObject()); <line25> hdrToTest.add((OutofBandHeader) job.getValue()); <line26> } catch (JAXBException ex) { <line27> } <line28> } <line29> } <line30> assertTrue(hdrToTest.size() > 0, ""out-of-band header should not be null""); <line31> assertEquals( <line32> ""testOobReturnHeaderName"", <line33> hdrToTest.get(0).getName(), <line34> ""Expected out-of-band Header name testOobReturnHeaderName recevied :"" <line35> + hdrToTest.get(0).getName()); <line36> assertEquals( <line37> ""testOobReturnHeaderValue"", <line38> hdrToTest.get(0).getValue(), <line39> ""Expected out-of-band Header value testOobReturnHeaderValue recevied :"" <line40> + hdrToTest.get(0).getValue()); <line41> assertEquals( <line42> ""testReturnHdrAttribute"", <line43> hdrToTest.get(0).getHdrAttribute(), <line44> ""Expected out-of-band Header attribute testReturnHdrAttribute recevied :"" <line45> + hdrToTest.get(0).getHdrAttribute()); <line46> assertEquals( <line47> ""New_testOobHeader"", <line48> hdrToTest.get(1).getName(), <line49> ""Expected out-of-band Header name New_testOobHeader recevied :"" <line50> + hdrToTest.get(1).getName()); <line51> assertEquals( <line52> ""New_testOobHeaderValue"", <line53> hdrToTest.get(1).getValue(), <line54> ""Expected out-of-band Header value New_testOobHeaderValue recevied :"" <line55> + hdrToTest.get(1).getValue()); <line56> assertEquals( <line57> ""testHdrAttribute"", <line58> hdrToTest.get(1).getHdrAttribute(), <line59> ""Expected out-of-band Header attribute testHdrAttribute recevied :"" <line60> + hdrToTest.get(1).getHdrAttribute()); <line61> } <line62> } <line63> "	"<line27>          LOG.warn(""JAXB error: {}"", ex.getMessage(), ex);"	task4	
"public class A { <line0> @SuppressWarnings(""rawtypes"") <line1> protected FormData extractFormData(final HttpServletRequest request) throws IOException { <line2> FileItemFactory factory = new DiskFileItemFactory(); <line3> ServletFileUpload upload = new ServletFileUpload(factory); <line4> upload.setHeaderEncoding(""UTF-8""); <line5> FormData data = new FormData(); <line6> GAV emptyGAV = new GAV(); <line7> try { <line8> List items = upload.parseRequest(request); <line9> Iterator it = items.iterator(); <line10> while (it.hasNext()) { <line11> FileItem item = (FileItem) it.next(); <line12> if (!item.isFormField()) { <line13> data.setFile(item); <line14> } <line15> if (item.isFormField() && item.getFieldName().equals(HTMLFileManagerFields.GROUP_ID)) { <line16> emptyGAV.setGroupId(item.getString()); <line17> } else if (item.isFormField() <line18> && item.getFieldName().equals(HTMLFileManagerFields.ARTIFACT_ID)) { <line19> emptyGAV.setArtifactId(item.getString()); <line20> } else if (item.isFormField() <line21> && item.getFieldName().equals(HTMLFileManagerFields.VERSION_ID)) { <line22> emptyGAV.setVersion(item.getString()); <line23> } <line24> } <line25> if (isNullOrEmpty(emptyGAV.getGroupId()) <line26> || isNullOrEmpty(emptyGAV.getArtifactId()) <line27> || isNullOrEmpty(emptyGAV.getVersion())) { <line28> data.setGav(null); <line29> } else { <line30> data.setGav(emptyGAV); <line31> } <line32> return data; <line33> } catch (FileUploadException e) { <line34> } <line35> return null; <line36> } <line37> } <line38> "	<line34>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> public void raiseNodeReconciliationAlarm(final Long nodeId) { <line1> String alarmText = getAlarmText(nodeId, "" started reconciliation""); <line2> String source = getSourceText(nodeId); <line3> invokeFMRaiseMethod(""NodeReconciliationOperationOngoing"", alarmText, source); <line4> } <line5> } <line6> "	"<line3>    LOG.debug(""Raising NodeReconciliationOperationOngoing alarm, alarmText {} source {}"",alarmText,source);"	task4	
"public class A { <line0> protected void endOfInput() { <line1> if (isUp()) { <line2> this.sessionListener.onSessionDown( <line3> thisInstance(), new IOException(""End of input detected. Close the session."")); <line4> } <line5> } <line6> } <line7> "	"<line1>    LOG.debug(""Session {} end of input detected while session was in state {}"",this,isUp() ? ""up"" : ""initialized"");"	task4	
public class A { <line0> private void parseMultipartContent() { <line1> final DiskFileItemFactory factory = new DiskFileItemFactory(); <line2> factory.setSizeThreshold(0); <line3> final ServletFileUpload upload = new ServletFileUpload(factory); <line4> try { <line5> final List<FileItem> items = upload.parseRequest(servletRequest); <line6> for (final FileItem item : items) { <line7> addParameter(params, item.getFieldName(), item); <line8> } <line9> } catch (final FileUploadException e) { <line10> } <line11> } <line12> } <line13> 	<line10>      LOG.error(e);	task4	
"public class A { <line0> private void copyDirectory(Path from, Path to) throws IOException { <line1> if (Files.mkdir(to, DIR_MODE) != 0) { <line2> Assert.fail(""Cannot create "" + to + "". Error: "" + Os.errno()); <line3> } <line4> java.nio.file.Path dest = FileSystems.getDefault().getPath(to.toString() + Files.SEPARATOR); <line5> java.nio.file.Path src = FileSystems.getDefault().getPath(from.toString() + Files.SEPARATOR); <line6> java.nio.file.Files.walk(src) <line7> .forEach( <line8> file -> { <line9> java.nio.file.Path destination = dest.resolve(src.relativize(file)); <line10> try { <line11> java.nio.file.Files.copy(file, destination, REPLACE_EXISTING); <line12> } catch (IOException e) { <line13> e.printStackTrace(); <line14> } <line15> }); <line16> } <line17> } <line18> "	"<line1>    LOG.info().$(""copying folder [from="").$(from).$("", to="").$(to).$(']').$();"	task4	
"public class A { <line0> @Override <line1> public String getFileName() { <line2> final SimpleDateFormat format = new SimpleDateFormat(""yyyyMMddHHmmss""); <line3> try { <line4> loadReport(); <line5> } catch (Exception e) { <line6> } <line7> final String name; <line8> if (report != null) name = report.getName(); <line9> else name = ""report""; <line10> return name + '_' + format.format(new Date()) + getExtention(); <line11> } <line12> } <line13> "	"<line6>      LOG.debug(""The project report cannot be found."", e);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> for (String jobId : jobIdPartition) { <line4> importJobData(jobId, sourceDataStore, targetDataStore, checkAllWrites); <line5> } <line6> } catch (Exception ex) { <line7> gotFailures.compareAndSet(false, true); <line8> } <line9> } <line10> } <line11> 	"<line8>      log.error(""Exception during datastore cutover"", ex);"	task4	
public class A { <line0> @Override <line1> public FileSystem getFileSystemByPath(Path path) { <line2> FileSystem desiredFs; <line3> try { <line4> desiredFs = requireNonNull(path).getFileSystem(hadoopConf); <line5> } catch (IOException ex) { <line6> throw new UncheckedIOException(ex); <line7> } <line8> URI desiredFsUri = desiredFs.getUri(); <line9> Collection<Volume> candidateVolumes = volumesByFileSystemUri.get(desiredFsUri); <line10> if (candidateVolumes != null) { <line11> return candidateVolumes.stream() <line12> .filter(volume -> volume.containsPath(path)) <line13> .map(Volume::getFileSystem) <line14> .findFirst() <line15> .orElse(desiredFs); <line16> } else { <line17> return desiredFs; <line18> } <line19> } <line20> } <line21> 	"<line17>      log.debug(""Could not determine volume for Path: {}"", path);"	task4	
"public class A { <line0> private void notifyRulesReady() { <line1> HttpToolResponse response = <line2> post( <line3> getConfig(SLA_ENDPOINT) <line4> + ""/seaclouds/commands/rulesready?agreementId="" <line5> + agreement.getAgreementId(), <line6> MediaType.APPLICATION_XML_UTF_8.toString(), <line7> getConfig(SLA_USERNAME), <line8> getConfig(SLA_PASSWORD), <line9> """".getBytes()); <line10> if (!HttpTool.isStatusCodeHealthy(response.getResponseCode())) { <line11> throw new RuntimeException( <line12> ""Something went wrong during the SLA Agreements installation. "" <line13> + ""Invalid response code, "" <line14> + response.getResponseCode() <line15> + "":"" <line16> + response.getContentAsString()); <line17> } <line18> } <line19> } <line20> "	"<line1>    LOG.info(""SeaCloudsInitializerPolicy is starting to enforce SLA Agreements for "" + entity.getId());"	task4	
public class A { <line0> @Override <line1> public void trace(String format, Object arg1, Object arg2) { <line2> traceMessages.add(new LogMessage(null, format, null, arg1, arg2)); <line3> } <line4> } <line5> 	<line3>    logger.trace(format, arg1, arg2);	task4	
"public class A { <line0> private void createFlightList( <line1> FlightCrewSolution solution, int flightRoundTripsPerDay, int dayCount) { <line2> int flightListSize = flightRoundTripsPerDay * dayCount; <line3> List<Flight> flightList = new ArrayList<>(flightListSize); <line4> List<Airport> airportList = solution.getAirportList(); <line5> Airport centerAirport = airportList.get(0); <line6> int homeAirportListSize = Math.min(airportList.size() / 10, flightRoundTripsPerDay / 5); <line7> homeAirportList = <line8> airportList.stream() <line9> .sorted(Comparator.comparingDouble(centerAirport::getHaversineDistanceInKmTo)) <line10> .limit(homeAirportListSize) <line11> .collect(Collectors.toList()); <line12> LocalDate firstDate = solution.getScheduleFirstUTCDate(); <line13> LocalDate lastDate = solution.getScheduleLastUTCDate(); <line14> int flightNumberSuffix = 1; <line15> long flightId = 0L; <line16> for (int i = 0; i < flightRoundTripsPerDay; i++) { <line17> int flightCount = i % 2 == 0 ? 2 : 3; <line18> ArrayList<Airport> selectedAirports = new ArrayList<>(flightCount); <line19> Airport firstAirport = extractRandomElement(random, homeAirportList); <line20> selectedAirports.add(firstAirport); <line21> ArrayList<Airport> nonFirstAirports = new ArrayList<>(airportList); <line22> nonFirstAirports.remove(firstAirport); <line23> Collections.shuffle(nonFirstAirports, random); <line24> selectedAirports.addAll(nonFirstAirports.subList(0, flightCount - 1)); <line25> for (int j = 0; j < flightCount; j++) { <line26> String flightNumber = ""AB"" + String.format(""%03d"", flightNumberSuffix); <line27> flightNumberSuffix++; <line28> Airport departureAirport = selectedAirports.get(j); <line29> Airport arrivalAirport = selectedAirports.get((j + 1) % flightCount); <line30> int flyingTime = <line31> (int) <line32> ((departureAirport.getHaversineDistanceInKmTo(arrivalAirport) <line33> / PLANE_SPEED_IN_KM_PER_MINUTE) <line34> + PLANE_TAKE_OFF_AND_LANDING_MINUTES); <line35> int departureMinute = <line36> START_MINUTE_OF_DAY <line37> + random.nextInt(END_MINUTE_OF_DAY - flyingTime - START_MINUTE_OF_DAY + 1); <line38> int arrivalMinute = departureMinute + flyingTime; <line39> for (LocalDate date = firstDate; date.compareTo(lastDate) <= 0; date = date.plusDays(1)) { <line40> Flight flight = new Flight(); <line41> flight.setId(flightId); <line42> flightId++; <line43> flight.setFlightNumber(flightNumber); <line44> flight.setDepartureAirport(departureAirport); <line45> flight.setDepartureUTCDateTime(date.atTime(departureMinute / 60, departureMinute % 60)); <line46> flight.setArrivalAirport(arrivalAirport); <line47> flight.setArrivalUTCDateTime(date.atTime(arrivalMinute / 60, arrivalMinute % 60)); <line48> flightList.add(flight); <line49> } <line50> } <line51> } <line52> flightList.sort(Flight::compareTo); <line53> solution.setFlightList(flightList); <line54> } <line55> } <line56> "	"<line48>          logger.trace(""Created flight ({})."", flight);"	task4	
public class A { <line0> private Exchange addSpecificContent( <line1> final Exchange exchange, final TImplementationArtifact implementationArtifact) { <line2> final Object any = implementationArtifact.getAny(); <line3> final Document specificContent = <line4> any instanceof Element ? XMLHelper.fromRootNode((Element) any) : null; <line5> if (specificContent != null) { <line6> exchange.getIn().setHeader(MBHeader.SPECIFICCONTENT_DOCUMENT.toString(), specificContent); <line7> } <line8> return exchange; <line9> } <line10> } <line11> 	"<line6>      LOG.debug(""ArtifactSpecificContent specified!"");"	task4	
"public class A { <line0> @Override <line1> public IndexClient getIndexClient(HetuFileSystemClient fs, HetuMetastore metastore, Path root) { <line2> requireNonNull(root, ""No root path specified""); <line3> return new HeuristicIndexClient(fs, metastore, root); <line4> } <line5> } <line6> "	"<line3>    LOG.debug(""Creating IndexClient with given filesystem client with root path %s"", root);"	task4	
"public class A { <line0> @Override <line1> public Channel getOperandChannel(OperandChannel operand) { <line2> final Channel channel; <line3> switch (operand) { <line4> case ACCEPTING_PARTY: <line5> channel = this._acceptingParty; <line6> break; <line7> case ORIGINATING_PARTY: <line8> channel = this._originatingParty; <line9> break; <line10> case REMOTE_PARTY: <line11> channel = getRemoteParty(); <line12> break; <line13> case TRANSFER_TARGET_PARTY: <line14> channel = this._transferTargetParty; <line15> break; <line16> case LOCAL_PARTY: <line17> channel = this.getLocalParty(); <line18> break; <line19> default: <line20> throw new IllegalArgumentException(""An unsupported operand was passed:"" + operand); <line21> } <line22> if (channel == null) { <line23> } <line24> return channel; <line25> } <line26> } <line27> "	"<line23>      logger.warn(""failed to get channel for "" + operand);"	task4	
"public class A { <line0> @Override <line1> public void deleteUserMessages(String username) throws ApsSystemException { <line2> Connection conn = null; <line3> try { <line4> conn = this.getConnection(); <line5> conn.setAutoCommit(false); <line6> super.executeQueryWithoutResultset(conn, DELETE_USERMESSAGES_ANSWERS, username); <line7> super.executeQueryWithoutResultset(conn, DELETE_USERMESSAGES_SEARCH_RECORD, username); <line8> super.executeQueryWithoutResultset(conn, DELETE_USERMESSAGES_ROLES, username); <line9> super.executeQueryWithoutResultset(conn, DELETE_USERMESSAGES, username); <line10> conn.commit(); <line11> } catch (Throwable t) { <line12> this.executeRollback(conn); <line13> throw new RuntimeException(""Error removing messages for user "" + username, t); <line14> } finally { <line15> this.closeConnection(conn); <line16> } <line17> } <line18> } <line19> "	"<line13>      logger.error(""Error removing messages for user {}"", username, t);"	task4	
"public class A { <line0> private synchronized void logTimingInfo() { <line1> if (!logger.isDebugEnabled()) { <line2> return; <line3> } <line4> final StringBuilder sb = new StringBuilder(); <line5> sb.append(String.format(""For %s %s Timing Info is as follows:\n"", method, uri)); <line6> for (final Map.Entry<String, Long> entry : timingInfo.entrySet()) { <line7> sb.append(entry.getKey()) <line8> .append("" took "") <line9> .append(TimeUnit.NANOSECONDS.toMillis(entry.getValue())) <line10> .append("" millis\n""); <line11> } <line12> } <line13> } <line14> "	<line12>    logger.debug(sb.toString());	task4	
public class A { <line0> @Override <line1> public void handleSysTemplateDownload(HypervisorType hostHyper, Long dcId) { <line2> Set<VMTemplateVO> toBeDownloaded = new HashSet<VMTemplateVO>(); <line3> List<DataStore> stores = _storeMgr.getImageStoresByScopeExcludingReadOnly(new ZoneScope(dcId)); <line4> if (stores == null || stores.isEmpty()) { <line5> return; <line6> } <line7> for (DataStore store : stores) { <line8> List<VMTemplateVO> rtngTmplts = _templateDao.listAllSystemVMTemplates(); <line9> List<VMTemplateVO> defaultBuiltin = _templateDao.listDefaultBuiltinTemplates(); <line10> for (VMTemplateVO rtngTmplt : rtngTmplts) { <line11> if (rtngTmplt.getHypervisorType() == hostHyper && !rtngTmplt.isDirectDownload()) { <line12> toBeDownloaded.add(rtngTmplt); <line13> } <line14> } <line15> for (VMTemplateVO builtinTmplt : defaultBuiltin) { <line16> if (builtinTmplt.getHypervisorType() == hostHyper && !builtinTmplt.isDirectDownload()) { <line17> toBeDownloaded.add(builtinTmplt); <line18> } <line19> } <line20> for (VMTemplateVO template : toBeDownloaded) { <line21> TemplateDataStoreVO tmpltHost = <line22> _vmTemplateStoreDao.findByStoreTemplate(store.getId(), template.getId()); <line23> if (tmpltHost == null) { <line24> associateTemplateToZone(template.getId(), dcId); <line25> TemplateInfo tmplt = _templateFactory.getTemplate(template.getId(), DataStoreRole.Image); <line26> createTemplateAsync(tmplt, store, null); <line27> } <line28> } <line29> } <line30> } <line31> } <line32> 	"<line25>          logger.info(""Downloading builtin template ""+ template.getUniqueName()+ "" to data center: ""+ dcId);"	task4	
public class A { <line0> @Override <line1> public InetSocketAddress resolve() { <line2> try { <line3> InetAddress inetAddress = getByName(host); <line4> InetSocketAddress updateAddress = new InetSocketAddress(inetAddress, port); <line5> checkDnsUpdate(updateAddress); <line6> return updateAddress; <line7> } catch (UnknownHostException e) { <line8> return InetSocketAddress.createUnresolved(host, port); <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.info(""dns lookup fail. host:{}"", host);"	task4	
public class A { <line0> private boolean enableRules(List<String> rules) { <line1> List<Rule> ruleIds = ruleRepository.findAll(); <line2> try { <line3> for (Rule rule : ruleIds) { <line4> if (rules.contains(rule.getRuleUUID())) { <line5> amazonClient <line6> .getAmazonCloudWatchEvents(config.getRule().getLambda().getRegion()) <line7> .enableRule(new EnableRuleRequest().withName(rule.getRuleUUID())); <line8> rule.setStatus(RuleState.ENABLED.name()); <line9> ruleRepository.save(rule); <line10> } <line11> } <line12> return true; <line13> } catch (Exception e) { <line14> return false; <line15> } <line16> } <line17> } <line18> 	"<line14>      log.error(""Error in enable rules"", e);"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.Country fetchCountryByA2( <line1> HttpPrincipal httpPrincipal, long companyId, String a2) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CountryServiceUtil.class, ""fetchCountryByA2"", _fetchCountryByA2ParameterTypes4); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, companyId, a2); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> return (com.liferay.portal.kernel.model.Country) returnObj; <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	<line15>      log.error(systemException, systemException);	task4	
public class A { <line0> public void invokeCallbacks() { <line1> IotHubTransportPacket packet = this.callbackPacketsQueue.poll(); <line2> while (packet != null) { <line3> IotHubStatusCode status = packet.getStatus(); <line4> IotHubEventCallback callback = packet.getCallback(); <line5> Object context = packet.getContext(); <line6> callback.execute(status, context); <line7> packet = this.callbackPacketsQueue.poll(); <line8> } <line9> } <line10> } <line11> 	"<line6>      log.debug(""Invoking the callback function for sent message, IoT Hub responded to message ({}) with""+ "" status {}"",packet.getMessage(),status);"	task4	
public class A { <line0> private void sendEventToSync(WorkerDoneEvent event) throws IOException, InterruptedException { <line1> if (log.isInfoEnabled()) { <line2> } <line3> this.toSync.broadcastEvent(event); <line4> } <line5> } <line6> 	"<line2>      log.info(formatLogString(""sending "" + WorkerDoneEvent.class.getSimpleName() + "" to sync""));"	task4	
"public class A { <line0> @RequiresPermissions(""objects:update"") <line1> public synchronized void setChanged(boolean value) { <line2> if (value) { <line3> ObjectHasChangedBehavior objectEvent = new ObjectHasChangedBehavior(this, this); <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> busService.send(objectEvent); <line7> } <line8> } <line9> } <line10> "	"<line5>        LOG.debug(""Thing \""{}\"" changes something in its status (eg: a behavior value)"",this.getPojo().getName());"	task4	
"public class A { <line0> public static java.io.File getFile(HttpPrincipal httpPrincipal, long commerceVirtualOrderItemId) <line1> throws Exception { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CommerceVirtualOrderItemServiceUtil.class, ""getFile"", _getFileParameterTypes0); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, commerceVirtualOrderItemId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof Exception) { <line12> throw (Exception) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (java.io.File) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.LayoutSoap getLayoutByUuidAndGroupId( <line1> String uuid, long groupId, boolean privateLayout) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Layout returnValue = <line4> LayoutServiceUtil.getLayoutByUuidAndGroupId(uuid, groupId, privateLayout); <line5> return com.liferay.portal.kernel.model.LayoutSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
"public class A { <line0> private Connection handleNewPendingConnection( <line1> InternalDistributedMember id, <line2> boolean sharedResource, <line3> boolean preserveOrder, <line4> Map m, <line5> PendingConnection pc, <line6> long startTime, <line7> long ackThreshold, <line8> long ackSAThreshold) <line9> throws IOException, DistributedSystemDisconnectedException { <line10> Connection con = null; <line11> try { <line12> con = <line13> Connection.createSender( <line14> owner.getMembership(), <line15> this, <line16> preserveOrder, <line17> id, <line18> sharedResource, <line19> startTime, <line20> ackThreshold, <line21> ackSAThreshold); <line22> owner.getStats().incSenders(sharedResource, preserveOrder); <line23> } finally { <line24> if (con == null) { <line25> owner.getStats().incFailedConnect(); <line26> synchronized (m) { <line27> Object rmObj = m.remove(id); <line28> if (rmObj != pc && rmObj != null) { <line29> m.put(id, rmObj); <line30> } <line31> } <line32> pc.notifyWaiters(null); <line33> } <line34> } <line35> synchronized (m) { <line36> Object e = m.get(id); <line37> if (e == pc) { <line38> m.put(id, con); <line39> } else if (e == null) { <line40> con.requestClose(""pending connection cancelled""); <line41> con = null; <line42> } else { <line43> if (e instanceof Connection) { <line44> Connection newCon = (Connection) e; <line45> if (!newCon.connected) { <line46> if (con != null) { <line47> con.requestClose(""pending connection closed""); <line48> con = null; <line49> } <line50> } else { <line51> if (con != null) { <line52> con.requestClose(""someone else created the connection""); <line53> } <line54> con = newCon; <line55> } <line56> } <line57> } <line58> } <line59> pc.notifyWaiters(con); <line60> if (con != null && logger.isDebugEnabled()) { <line61> } <line62> return con; <line63> } <line64> } <line65> "	"<line61>      logger.debug(""handleNewPendingConnection {} myAddr={} theirAddr={}"",con,getConduit().getMemberId(),con.getRemoteAddress());"	task4	
public class A { <line0> @Override <line1> public void run(long runtime) { <line2> try { <line3> new DataPurge().execute(runtime); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> static Path getBasePath(Configuration conf) { <line1> String basePathKey = ""hdfs."" + MrGeoConstants.MRGEO_HDFS_VECTOR; <line2> Path basePath = null; <line3> String strBasePath = null; <line4> if (conf != null) { <line5> strBasePath = conf.get(basePathKey); <line6> } <line7> if (strBasePath == null) { <line8> strBasePath = MrGeoProperties.getInstance().getProperty(MrGeoConstants.MRGEO_HDFS_VECTOR); <line9> } <line10> if (strBasePath != null) { <line11> try { <line12> basePath = new Path(new URI(strBasePath)); <line13> } catch (URISyntaxException e) { <line14> } <line15> } <line16> if (basePath == null) { <line17> basePath = new Path(""/mrgeo/vectors""); <line18> } <line19> return basePath; <line20> } <line21> } <line22> "	"<line14>        log.error(""Invalid HDFS base path for vectors: "" + strBasePath, e);"	task4	
public class A { <line0> private void validateAndFillPolicy( <line1> PolicyDefinition emptyPolicyDefinition, Map<String, Object> policyTemplateJsonMap) { <line2> String policyTypeName = (String) policyTemplateJsonMap.get(TYPE.getElementName()); <line3> if (StringUtils.isEmpty(policyTypeName)) { <line4> rollbackWithException( <line5> ActionStatus.POLICY_MISSING_POLICY_TYPE, emptyPolicyDefinition.getName()); <line6> } <line7> emptyPolicyDefinition.setType(policyTypeName); <line8> emptyPolicyDefinition.setTargets(validateFillPolicyTargets(policyTemplateJsonMap)); <line9> PolicyTypeDefinition policyTypeDefinition = validateGetPolicyTypeDefinition(policyTypeName); <line10> emptyPolicyDefinition.setProperties( <line11> validateFillPolicyProperties(policyTypeDefinition, policyTemplateJsonMap)); <line12> } <line13> } <line14> 	"<line4>      log.debug(""#validateAndFillPolicy - The 'type' member is not found under policy {}"",emptyPolicyDefinition.getName());"	task4	
"public class A { <line0> private void evaluateExpectations( <line1> String currentSpecLocation, AtomicAction<? extends Oaf> action, String serializedAction) <line2> throws Exception { <line3> Properties specProps = new OrderedProperties(); <line4> specProps.load(ClassPathResourceProvider.getResourceInputStream(currentSpecLocation.trim())); <line5> Iterator<Entry<Object, Object>> propsIter = specProps.entrySet().iterator(); <line6> while (propsIter.hasNext()) { <line7> Entry<Object, Object> entry = propsIter.next(); <line8> Object currentValue = accessor.getValue((String) entry.getKey(), action); <line9> if ((currentValue != null && !entry.getValue().equals(currentValue.toString())) <line10> || (currentValue == null && !NULL_VALUE_INDICATOR.equals(entry.getValue()))) { <line11> throw new Exception( <line12> ""invalid field value for path: "" <line13> + entry.getKey() <line14> + "", expected: '"" <line15> + entry.getValue() <line16> + ""', "" <line17> + ""got: '"" <line18> + currentValue <line19> + ""' Full object content: "" <line20> + serializedAction); <line21> } <line22> } <line23> } <line24> } <line25> "	"<line3>    log.info(""output specification location: "" + currentSpecLocation);"	task4	
"public class A { <line0> @Override <line1> protected SRARouteTO resolveReference(final Method method, final Object... args) <line2> throws UnresolvedReferenceException { <line3> String key = null; <line4> if (ArrayUtils.isNotEmpty(args) <line5> && (""create"".equals(method.getName()) <line6> || ""update"".equals(method.getName()) <line7> || ""delete"".equals(method.getName()))) { <line8> for (int i = 0; key == null && i < args.length; i++) { <line9> if (args[i] instanceof String) { <line10> key = (String) args[i]; <line11> } else if (args[i] instanceof SRARouteTO) { <line12> key = ((SRARouteTO) args[i]).getKey(); <line13> } <line14> } <line15> } <line16> if (key != null) { <line17> try { <line18> return binder.getSRARouteTO(routeDAO.find(key)); <line19> } catch (Throwable ignore) { <line20> throw new UnresolvedReferenceException(ignore); <line21> } <line22> } <line23> throw new UnresolvedReferenceException(); <line24> } <line25> } <line26> "	"<line20>        LOG.debug(""Unresolved reference"", ignore);"	task4	
public class A { <line0> static HFileMeta toAttr(byte[] bytes) { <line1> try { <line2> return (bytes == null) ? null : HFileMeta.deserialize(bytes); <line3> } catch (Exception internal) { <line4> throw new IllegalArgumentException(internal); <line5> } <line6> } <line7> } <line8> 	"<line4>      log.warn(""Argument 'bytes={}' was not a serialized HFileMeta!"", CommonUtils.hex(bytes));"	task4	
public class A { <line0> public static <T extends Container> void setContainerImplementation( <line1> String containerType, Class<T> containerClass) { <line2> containerImplementations.put(containerType, containerClass); <line3> } <line4> } <line5> 	"<line2>    logger.info(""Using <{}> for container type <{}>"", containerClass.getName(), containerType);"	task4	
public class A { <line0> public synchronized void refineRoot(BigRational e) { <line1> ensureEngine(); <line2> try { <line3> root = engine.complexRootRefinement(root, algebraic.modul, e); <line4> } catch (InvalidBoundaryException e1) { <line5> return; <line6> } <line7> this.eps = e; <line8> } <line9> } <line10> 	"<line5>      logger.warn(""new eps not set: "" + e);"	task4	
public class A { <line0> private boolean isNodeAuditEnabled(Engine engine) { <line1> for (Analyzer a : engine.getAnalyzers()) { <line2> if (a instanceof NodeAuditAnalyzer || a instanceof YarnAuditAnalyzer) { <line3> if (a.isEnabled()) { <line4> try { <line5> ((AbstractNpmAnalyzer) a).prepareFileTypeAnalyzer(engine); <line6> } catch (InitializationException ex) { <line7> } <line8> } <line9> return a.isEnabled(); <line10> } <line11> } <line12> return false; <line13> } <line14> } <line15> 	"<line7>            LOGGER.debug(""Error initializing the {}"", a.getName());"	task4	
public class A { <line0> private void logContentLength(ResponseValues httpResponse) { <line1> if (LOGGER.isDebugEnabled()) { <line2> long contentLength = 0; <line3> try { <line4> contentLength = httpResponse.getContentLength(); <line5> } catch (NumberFormatException ex) { <line6> contentLength = -1; <line7> } <line8> } <line9> } <line10> } <line11> 	"<line8>      LOGGER.debug(""Content-Length is "" + contentLength + "" bytes"");"	task4	
"public class A { <line0> public static java.util.List<com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordVersion> <line1> getFormInstanceRecordVersions( <line2> HttpPrincipal httpPrincipal, <line3> long ddmFormInstanceRecordId, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordVersion> <line8> orderByComparator) <line9> throws com.liferay.portal.kernel.exception.PortalException { <line10> try { <line11> MethodKey methodKey = <line12> new MethodKey( <line13> DDMFormInstanceRecordVersionServiceUtil.class, <line14> ""getFormInstanceRecordVersions"", <line15> _getFormInstanceRecordVersionsParameterTypes4); <line16> MethodHandler methodHandler = <line17> new MethodHandler(methodKey, ddmFormInstanceRecordId, start, end, orderByComparator); <line18> Object returnObj = null; <line19> try { <line20> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line21> } catch (Exception exception) { <line22> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line23> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line24> } <line25> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line26> } <line27> return (java.util.List<com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordVersion>) <line28> returnObj; <line29> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line30> throw systemException; <line31> } <line32> } <line33> } <line34> "	<line30>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public InputStream getContentStream() { <line2> ContentStream contentStream = _document.getContentStream(); <line3> try { <line4> DLAppHelperLocalServiceUtil.getFileAsStream(PrincipalThreadLocal.getUserId(), this, true); <line5> } catch (Exception exception) { <line6> } <line7> if (contentStream == null) { <line8> return null; <line9> } <line10> return contentStream.getStream(); <line11> } <line12> } <line13> 	<line6>      log.error(exception, exception);	task4	
public class A { <line0> public void failed(Throwable exception) { <line1> } <line2> } <line3> 	"<line1>    logger.info(""Failed "" + getProgress() + ""% -- "" + getTask() + "" ["" + getPrintable(getOwner()) + ""]"");"	task4	
public class A { <line0> @Override <line1> public boolean start(NodeState protectedParent) <line2> throws IllegalStateException, RepositoryException { <line3> if (isStarted()) { <line4> throw new IllegalStateException(); <line5> } <line6> if (isWorkspaceImport) { <line7> return false; <line8> } <line9> return false; <line10> } <line11> } <line12> 	"<line7>      log.debug(""AccessControlImporter may not be used with the WorkspaceImporter"");"	task4	
"public class A { <line0> protected HttpsServer createSSLServer() throws Exception { <line1> InetSocketAddress address = new InetSocketAddress(getProxyCallbackURLPrefix().getPort()); <line2> HttpsServer httpsServer = HttpsServer.create(address, 0); <line3> SSLContext sslContext = SSLContext.getInstance(""TLS""); <line4> char[] password = ""changeit"".toCharArray(); <line5> KeyStore ks = KeyStore.getInstance(""JKS""); <line6> File base = new File(System.getProperty(""user.home""), "".geoserver""); <line7> File keystore = new File(base, ""keystore.jks""); <line8> try (FileInputStream fis = new FileInputStream(keystore)) { <line9> ks.load(fis, password); <line10> } <line11> KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); <line12> kmf.init(ks, password); <line13> TrustManagerFactory tmf = <line14> TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); <line15> tmf.init(ks); <line16> sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null); <line17> httpsServer.setHttpsConfigurator( <line18> new HttpsConfigurator(sslContext) { <line19> @Override <line20> public void configure(HttpsParameters params) { <line21> try { <line22> SSLContext c = SSLContext.getDefault(); <line23> SSLEngine engine = c.createSSLEngine(); <line24> params.setNeedClientAuth(false); <line25> params.setCipherSuites(engine.getEnabledCipherSuites()); <line26> params.setProtocols(engine.getEnabledProtocols()); <line27> SSLParameters defaultSSLParameters = c.getDefaultSSLParameters(); <line28> params.setSSLParameters(defaultSSLParameters); <line29> } catch (Exception ex) { <line30> throw new RuntimeException(ex); <line31> } <line32> } <line33> }); <line34> httpsServer.createContext( <line35> ""/test"", <line36> t -> { <line37> t.getRequestBody().close(); <line38> t.sendResponseHeaders(200, 0); <line39> t.getResponseBody().close(); <line40> }); <line41> httpsServer.setExecutor(null); <line42> return httpsServer; <line43> } <line44> } <line45> "	"<line37>          LOGGER.info(""https server working"");"	task4	
"public class A { <line0> @RolesAllowed({""Peer-Management|Delete"", ""Peer-Management|Update""}) <line1> @Override <line2> public void unregisterPeer() throws BazaarManagerException { <line3> RegistrationManager registrationManager = new RegistrationManager(this, configManager); <line4> registrationManager.unregister(); <line5> if (!CollectionUtil.isCollectionEmpty(bazaarEventListeners)) { <line6> ExecutorService notifier = Executors.newFixedThreadPool(bazaarEventListeners.size()); <line7> for (final BazaarEventListener bazaarEventListener : bazaarEventListeners) { <line8> notifier.execute( <line9> new Runnable() { <line10> @Override <line11> public void run() { <line12> try { <line13> bazaarEventListener.onUnregister(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> }); <line18> } <line19> notifier.shutdown(); <line20> } <line21> } <line22> } <line23> "	"<line15>                  log.error(""Error notifying event listener"", e);"	task4	
"public class A { <line0> @Override <line1> public List<Category> loadCategories(ILangManager langManager) { <line2> Connection conn = null; <line3> Statement stat = null; <line4> ResultSet res = null; <line5> List<Category> categories = new ArrayList<Category>(); <line6> try { <line7> conn = this.getConnection(); <line8> stat = conn.createStatement(); <line9> res = stat.executeQuery(this.getLoadCategoriesQuery()); <line10> while (res.next()) { <line11> Category category = this.loadCategory(res, langManager); <line12> categories.add(category); <line13> } <line14> } catch (Throwable t) { <line15> throw new RuntimeException(""Error loading categories"", t); <line16> } finally { <line17> closeDaoResources(res, stat, conn); <line18> } <line19> return categories; <line20> } <line21> } <line22> "	"<line15>      logger.error(""Error loading categories"", t);"	task4	
public class A { <line0> public static com.liferay.commerce.discount.model.CommerceDiscountSoap updateCommerceDiscount( <line1> long commerceDiscountId, <line2> String title, <line3> String target, <line4> boolean useCouponCode, <line5> String couponCode, <line6> boolean usePercentage, <line7> java.math.BigDecimal maximumDiscountAmount, <line8> String level, <line9> java.math.BigDecimal level1, <line10> java.math.BigDecimal level2, <line11> java.math.BigDecimal level3, <line12> java.math.BigDecimal level4, <line13> String limitationType, <line14> int limitationTimes, <line15> int limitationTimesPerAccount, <line16> boolean rulesConjunction, <line17> boolean active, <line18> int displayDateMonth, <line19> int displayDateDay, <line20> int displayDateYear, <line21> int displayDateHour, <line22> int displayDateMinute, <line23> int expirationDateMonth, <line24> int expirationDateDay, <line25> int expirationDateYear, <line26> int expirationDateHour, <line27> int expirationDateMinute, <line28> boolean neverExpire, <line29> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line30> throws RemoteException { <line31> try { <line32> com.liferay.commerce.discount.model.CommerceDiscount returnValue = <line33> CommerceDiscountServiceUtil.updateCommerceDiscount( <line34> commerceDiscountId, <line35> title, <line36> target, <line37> useCouponCode, <line38> couponCode, <line39> usePercentage, <line40> maximumDiscountAmount, <line41> level, <line42> level1, <line43> level2, <line44> level3, <line45> level4, <line46> limitationType, <line47> limitationTimes, <line48> limitationTimesPerAccount, <line49> rulesConjunction, <line50> active, <line51> displayDateMonth, <line52> displayDateDay, <line53> displayDateYear, <line54> displayDateHour, <line55> displayDateMinute, <line56> expirationDateMonth, <line57> expirationDateDay, <line58> expirationDateYear, <line59> expirationDateHour, <line60> expirationDateMinute, <line61> neverExpire, <line62> serviceContext); <line63> return com.liferay.commerce.discount.model.CommerceDiscountSoap.toSoapModel(returnValue); <line64> } catch (Exception exception) { <line65> throw new RemoteException(exception.getMessage()); <line66> } <line67> } <line68> } <line69> 	<line65>      log.error(exception, exception);	task4	
"public class A { <line0> private String readFileFromClasspath(String filename, Log log) { <line1> var stream = getClass().getClassLoader().getResourceAsStream((filename)); <line2> String fileContent = """"; <line3> try (BufferedReader reader = <line4> new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) { <line5> fileContent = reader.lines().collect(Collectors.joining(""\n"")); <line6> } catch (IOException e) { <line7> } <line8> return fileContent; <line9> } <line10> } <line11> "	"<line7>      log.error(String.format(""Error reading file: \""%s\"""", filename), e);"	task4	
public class A { <line0> private boolean isForwardButtonVisible() { <line1> if (CaseWorkItemUtil.isCaseWorkItemClosed(getModelObject()) <line2> || CaseWorkItemUtil.isWorkItemClaimable(getModelObject())) { <line3> return false; <line4> } <line5> try { <line6> OperationResult result = new OperationResult(OPERATION_CHECK_DELEGATE_AUTHORIZATION); <line7> Task task = getPageBase().createSimpleTask(OPERATION_CHECK_DELEGATE_AUTHORIZATION); <line8> return WebComponentUtil.runUnderPowerOfAttorneyIfNeeded( <line9> () -> <line10> getPageBase() <line11> .getWorkflowManager() <line12> .isCurrentUserAuthorizedToDelegate(getModelObject(), task, result), <line13> getPowerDonor(), <line14> getPageBase(), <line15> task, <line16> result); <line17> } catch (Exception ex) { <line18> return false; <line19> } <line20> } <line21> } <line22> 	"<line18>      LOGGER.error(""Cannot check current user authorization to submit work item: {}"",ex.getLocalizedMessage(),ex);"	task4	
"public class A { <line0> @GET <line1> @Path(""upcomingRecording/{agent}"") <line2> @Produces(MediaType.TEXT_XML) <line3> @RestQuery( <line4> name = ""upcomingrecording"", <line5> description = ""Get the upcoming capture event as XML"", <line6> returnDescription = ""The upcoming capture event as XML"", <line7> pathParameters = { <line8> @RestParameter( <line9> name = ""agent"", <line10> isRequired = true, <line11> type = Type.STRING, <line12> description = ""The agent identifier"") <line13> }, <line14> responses = { <line15> @RestResponse( <line16> responseCode = HttpServletResponse.SC_OK, <line17> description = ""upcoming event is in the body of response""), <line18> @RestResponse( <line19> responseCode = HttpServletResponse.SC_NO_CONTENT, <line20> description = ""There is no upcoming recording"") <line21> }) <line22> public Response upcomingRecording(@PathParam(""agent"") String agentId) <line23> throws UnauthorizedException { <line24> try { <line25> Opt<MediaPackage> upcoming = service.getUpcomingRecording(agentId); <line26> if (upcoming.isNone()) { <line27> return Response.noContent().build(); <line28> } else { <line29> return Response.ok(MediaPackageParser.getAsXml(upcoming.get())).build(); <line30> } <line31> } catch (UnauthorizedException e) { <line32> throw e; <line33> } catch (Exception e) { <line34> throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR); <line35> } <line36> } <line37> } <line38> "	"<line34>      logger.error(""Unable to get the upcoming recording for agent '{}'"", agentId, e);"	task4	
"public class A { <line0> public MessageResponse handleMessageProcessingFailed( <line1> final Exception exception, <line2> final URI requestedArtifact, <line3> final URI transferContract, <line4> final URI issuerConnector, <line5> final URI messageId) { <line6> if (log.isWarnEnabled()) { <line7> } <line8> return ErrorResponse.withDefaultHeader( <line9> RejectionReason.INTERNAL_RECIPIENT_ERROR, <line10> ""Could not process request message. "" + exception.getMessage(), <line11> connectorService.getConnectorId(), <line12> connectorService.getOutboundModelVersion()); <line13> } <line14> } <line15> "	"<line7>      log.warn(""Could not process request message. [exception=({}), artifact=({}), ""+ ""contract=({}), issuer=({}), messageId=({})]"",exception.getMessage(),requestedArtifact,transferContract,issuerConnector,messageId,exception);"	task4	
public class A { <line0> public static void measureAndAssert(int nRuns, float expectedFactor, float allowedVariation) { <line1> long duration = System.currentTimeMillis() - currentMark; <line2> float perRun = (duration / (float) nRuns); <line3> float factor = perRun / computeBaseline(); <line4> assertThat(expectedFactor).isCloseTo(factor, Percentage.withPercentage(allowedVariation)); <line5> } <line6> } <line7> 	"<line3>    log.info(""Average time per run: {"" + perRun + ""} ms"");"	task4	
public class A { <line0> private void updateNotificationStatus( <line1> ODatabaseDocument db, IONotification notification, ODocument status) { <line2> for (int i = 1; i <= 10; i++) { <line3> try { <line4> db.begin(); <line5> notification.addStatusHistory(IONotificationStatusHistory.create(new Date(), status)); <line6> notification.setStatus(status); <line7> notification.save(); <line8> db.commit(); <line9> break; <line10> } catch (Exception e) { <line11> if (i == 10) { <line12> } else { <line13> notification.reload(); <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	"<line12>          LOG.error(""Couldn't save notification: {}"", notification.getDocument(), e);"	task4	
public class A { <line0> @Override <line1> public void createSchema() throws GoraException { <line2> try { <line3> if (manager.getCache(super.getPersistentClass().getSimpleName(), keyClass, persistentClass) <line4> == null) { <line5> cacheEntryList.clear(); <line6> cache = manager.createCache(persistentClass.getSimpleName(), cacheConfig); <line7> } <line8> cache.registerCacheEntryListener( <line9> new MutableCacheEntryListenerConfiguration<>( <line10> JCacheCacheFactoryBuilder.factoryOfEntryListener( <line11> new JCacheCacheEntryListener<K, T>(cacheEntryList)), <line12> null, <line13> true, <line14> true)); <line15> persistentDataStore.createSchema(); <line16> } catch (GoraException e) { <line17> throw e; <line18> } catch (Exception e) { <line19> throw new GoraException(e); <line20> } <line21> } <line22> } <line23> 	"<line16>      LOG.info(""Created schema on persistent store and initialized cache for persistent bean {}."",super.getPersistentClass().getSimpleName());"	task4	
"public class A { <line0> private long validateSystemId(final long systemId) { <line1> if (systemId < 1) { <line2> throw new IllegalArgumentException(""System id must be greater than zero""); <line3> } <line4> return systemId; <line5> } <line6> } <line7> "	"<line1>    logger.debug(""validateSystemId started..."");"	task4	
"public class A { <line0> public <T> T getManager(final Class<T> clz) { <line1> KylinConfig base = base(); <line2> if (base != this) return base.getManager(clz); <line3> Object mgr = managersCache.get(clz); <line4> if (mgr != null) return (T) mgr; <line5> synchronized (managersCache) { <line6> mgr = managersCache.get(clz); <line7> if (mgr != null) return (T) mgr; <line8> try { <line9> Method method = clz.getDeclaredMethod(""newInstance"", KylinConfig.class); <line10> method.setAccessible(true); <line11> mgr = method.invoke(null, this); <line12> } catch (Exception e) { <line13> throw new RuntimeException(e); <line14> } <line15> managersCache.put(clz, mgr); <line16> } <line17> return (T) mgr; <line18> } <line19> } <line20> "	"<line9>        logger.info(""Creating new manager instance of {}"", clz);"	task4	
public class A { <line0> public void registerClient(ClientProxyMembershipID proxyID, int maximumTimeBetweenPings) { <line1> if (!clientMaximumTimeBetweenPings.containsKey(proxyID)) { <line2> clientMaximumTimeBetweenPings.putIfAbsent(proxyID, maximumTimeBetweenPings); <line3> } <line4> if (!clientHeartbeats.containsKey(proxyID)) { <line5> if (null <line6> == clientHeartbeats.putIfAbsent(proxyID, new AtomicLong(System.currentTimeMillis()))) { <line7> if (stats != null) { <line8> stats.incClientRegisterRequests(); <line9> } <line10> if (logger.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> } <line15> } <line16> 	"<line11>          logger.debug(""ClientHealthMonitor: Registering client with member id {}"", proxyID);"	task4	
"public class A { <line0> public void testMapSubkeyUsage() throws Exception { <line1> entity.config().set(TestEntity.CONF_MAP_THING_OBJECT.subKey(""a""), 1); <line2> Assert.assertEquals( <line3> entity.getConfig(TestEntity.CONF_MAP_THING_OBJECT), <line4> ImmutableMap.<String, Object>of(""a"", 1)); <line5> } <line6> } <line7> "	"<line2>    log.info(""Map-SubKey: "" + MutableMap.copyOf(entity.getConfigMap().asMapWithStringKeys()));"	task4	
"public class A { <line0> @Override <line1> public SampleResponse deserialize( <line2> JsonElement json, Type typeOfT, JsonDeserializationContext context) <line3> throws JsonParseException { <line4> JsonObject jsonObj = json.getAsJsonObject(); <line5> ConnectorDetail detail = context.deserialize(jsonObj.get(""detail""), ConnectorDetail.class); <line6> JsonElement schemaJson = jsonObj.get(""schema""); <line7> Schema schema = schemaJson == null ? null : context.deserialize(schemaJson, Schema.class); <line8> if (schema == null) { <line9> return new SampleResponse(detail, schema, Collections.emptyList()); <line10> } <line11> JsonArray jsonArray = jsonObj.get(""sample"").getAsJsonArray(); <line12> List<StructuredRecord> sample = new ArrayList<>(); <line13> jsonArray <line14> .iterator() <line15> .forEachRemaining( <line16> jsonElement -> { <line17> String recordString = jsonElement.getAsString(); <line18> try { <line19> StructuredRecord record = <line20> StructuredRecordStringConverter.fromJsonString(recordString, schema); <line21> sample.add(record); <line22> } catch (IOException e) { <line23> } <line24> }); <line25> return new SampleResponse(detail, schema, sample); <line26> } <line27> } <line28> "	"<line23>                LOG.warn(""Error converting the json string {} to StructuredRecord"", recordString, e);"	task4	
"public class A { <line0> @Override <line1> protected synchronized void doSubscribe(final String eventName, SettableFuture<?> future) { <line2> boolean success = false; <line3> Throwable t = null; <line4> try { <line5> if (registrations.containsKey(eventName)) { <line6> throw new IllegalStateException(""Already subscribed to ["" + eventName + ""]""); <line7> } <line8> ITopic<String> topic = hazelcast.getTopic(eventName); <line9> MessageListener<String> listener = <line10> new MessageListener<String>() { <line11> @Override <line12> public void onMessage(Message<String> message) { <line13> String eventString = message.getMessageObject(); <line14> if (eventString != null) { <line15> onEvent(null, eventName, eventString); <line16> } <line17> } <line18> }; <line19> String id = topic.addMessageListener(listener); <line20> registrations.put(eventName, id); <line21> success = true; <line22> } catch (RuntimeException e) { <line23> t = e; <line24> throw e; <line25> } finally { <line26> if (success) { <line27> future.set(null); <line28> } else { <line29> if (t == null) { <line30> t = new IllegalStateException(""Failed to subscribe to ["" + eventName + ""]""); <line31> } <line32> future.setException(t); <line33> } <line34> } <line35> } <line36> } <line37> "	"<line20>      log.info(""Subscribing to [{}] id [{}]"", eventName, id);"	task4	
public class A { <line0> @Init <line1> public void init() { <line2> try { <line3> clazz = Class.forName(clazzName); <line4> ctor = clazz.getConstructor(long.class); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.trace(""Could not initialize generator "" + this, e);"	task4	
public class A { <line0> @Override <line1> public void onClose(WatcherException cause) { <line2> if (cause != null) { <line3> } <line4> } <line5> } <line6> 	<line3>      LOG.error(cause.getMessage(), cause);	task4	
public class A { <line0> @Nullable <line1> Pack getPack(AnyObjectId objectId) { <line2> PackList pList; <line3> do { <line4> pList = packList.get(); <line5> for (Pack p : pList.packs) { <line6> try { <line7> if (p.hasObject(objectId)) { <line8> return p; <line9> } <line10> } catch (IOException e) { <line11> remove(p); <line12> } <line13> } <line14> } while (searchPacksAgain(pList)); <line15> return null; <line16> } <line17> } <line18> 	<line11>          LOG.warn(MessageFormat.format(JGitText.get().unableToReadPackfile, p.getPackFile().getAbsolutePath()),e);	task4	
"public class A { <line0> @Bean( <line1> destroyMethod = ""stop"", <line2> name = ""wsDistributionAutomationOutboundDomainRequestsConnectionFactory"") <line3> public ConnectionFactory connectionFactory() { <line4> return this.jmsConfigurationFactory.getPooledConnectionFactory(); <line5> } <line6> } <line7> "	"<line4>    LOGGER.info(""Initializing wsDistributionAutomationOutboundDomainRequestsConnectionFactory bean."");"	task4	
public class A { <line0> @Test <line1> public void testDropMessagesExpiring() throws Exception { <line2> clearDataRecreateServerDirs(); <line3> HashMap<String, AddressSettings> settings = new HashMap<>(); <line4> AddressSettings set = new AddressSettings(); <line5> set.setAddressFullMessagePolicy(AddressFullMessagePolicy.DROP); <line6> settings.put(PagingTest.ADDRESS.toString(), set); <line7> server = createServer(true, createDefaultInVMConfig(), 1024, 1024 * 1024, settings); <line8> server.start(); <line9> final int numberOfMessages = 30000; <line10> locator.setAckBatchSize(0); <line11> sf = createSessionFactory(locator); <line12> ClientSession sessionProducer = sf.createSession(); <line13> sessionProducer.createQueue(new QueueConfiguration(PagingTest.ADDRESS)); <line14> ClientProducer producer = sessionProducer.createProducer(PagingTest.ADDRESS); <line15> ClientMessage message = null; <line16> ClientSession sessionConsumer = sf.createSession(); <line17> class MyHandler implements MessageHandler { <line18> int count; <line19>  <line20> @Override <line21> public void onMessage(ClientMessage message1) { <line22> try { <line23> Thread.sleep(1); <line24> } catch (Exception e) { <line25> } <line26> count++; <line27> if (count % 1000 == 0) { <line28> } <line29> try { <line30> message1.acknowledge(); <line31> } catch (Exception e) { <line32> e.printStackTrace(); <line33> } <line34> } <line35> } <line36> ClientConsumer consumer = sessionConsumer.createConsumer(PagingTest.ADDRESS); <line37> sessionConsumer.start(); <line38> consumer.setMessageHandler(new MyHandler()); <line39> for (int i = 0; i < numberOfMessages; i++) { <line40> byte[] body = new byte[1024]; <line41> message = sessionProducer.createMessage(false); <line42> message.getBodyBuffer().writeBytes(body); <line43> message.setExpiration(System.currentTimeMillis() + 100); <line44> producer.send(message); <line45> } <line46> sessionProducer.close(); <line47> sessionConsumer.close(); <line48> } <line49> } <line50> 	"<line28>          log.debug(""received "" + count);"	task4	
public class A { <line0> Permission find(final long id) { <line1> Permission result = null; <line2> EntityManager em = daoManager.getEntityManagerFromFactory(); <line3> try { <line4> result = em.find(PermissionEntity.class, id); <line5> } catch (Exception e) { <line6> } finally { <line7> daoManager.closeEntityManager(em); <line8> } <line9> return result; <line10> } <line11> } <line12> 	<line6>      LOG.error(e.getMessage());	task4	
"public class A { <line0> @Override <line1> public String getSCMCertificate(ScmNodeDetailsProto scmNodeDetails, String certSignReq) <line2> throws IOException { <line3> Objects.requireNonNull(scmNodeDetails); <line4> String primaryScmId = storageContainerManager.getScmStorageConfig().getPrimaryScmNodeId(); <line5> if (primaryScmId != null && primaryScmId.equals(storageContainerManager.getScmId())) { <line6> if (!storageContainerManager.getClusterId().equals(scmNodeDetails.getClusterId())) { <line7> throw new IOException( <line8> ""SCM ClusterId mismatch. Peer SCM ClusterId "" <line9> + scmNodeDetails.getClusterId() <line10> + "", primary SCM ClusterId "" <line11> + storageContainerManager.getClusterId()); <line12> } <line13> return getEncodedCertToString(certSignReq, NodeType.SCM); <line14> } else { <line15> throw new SCMSecurityException( <line16> ""Get SCM Certificate can be run only "" + ""primary SCM"", NOT_A_PRIMARY_SCM); <line17> } <line18> } <line19> } <line20> "	"<line6>      LOGGER.info(""Processing CSR for scm {}, nodeId: {}"",scmNodeDetails.getHostName(),scmNodeDetails.getScmNodeId());"	task4	
"public class A { <line0> @Test <line1> public void test_filesize_limit() throws Exception { <line2> Files.write( <line3> currentTestResourceDir.resolve(""small.txt""), <line4> ""This is a second file smaller than the previous one"".getBytes()); <line5> Fs fs = <line6> startCrawlerDefinition().setIgnoreAbove(ByteSizeValue.parseBytesSizeValue(""10kb"")).build(); <line7> startCrawler(getCrawlerName(), fs, endCrawlerDefinition(getCrawlerName()), null); <line8> countTestHelper(new ESSearchRequest().withIndex(getCrawlerName()), 1L, null); <line9> } <line10> } <line11> "	"<line2>    logger.info("" ---> Creating a smaller file small.txt"");"	task4	
public class A { <line0> @Override <line1> public void performAction(List<SimpleClient> objects) { <line2> for (SimpleClient simpleClient : objects) { <line3> processedCount++; <line4> } <line5> } <line6> } <line7> 	"<line5>    LOG.info(""Total processed: "" + processedCount);"	task4	
public class A { <line0> private ConnectionStateListener checkReconnect(TransportProtos.ServiceInfo self) { <line1> return (client, newState) -> { <line2> if (newState == ConnectionState.LOST) { <line3> reconnectExecutorService.submit(this::reconnect); <line4> } <line5> }; <line6> } <line7> } <line8> 	"<line2>      log.info(""[{}] ZK state changed: {}"", self.getServiceId(), newState);"	task4	
public class A { <line0> @Override <line1> public void process(Element elm, JID actorJID, IQ reqIQ, Element rsm) throws Exception { <line2> response = IQ.createResultIQ(reqIQ); <line3> request = reqIQ; <line4> actor = actorJID; <line5> node = elm.attributeValue(XMLConstants.NODE_ATTR); <line6> resultSetManagement = rsm; <line7> if (null == actor) { <line8> actor = request.getFrom(); <line9> } <line10> if (!isValidStanza()) { <line11> outQueue.put(response); <line12> return; <line13> } <line14> if (!Configuration.getInstance().isLocalJID(request.getFrom())) { <line15> response <line16> .getElement() <line17> .addAttribute(XMLConstants.REMOTE_SERVER_DISCOVER_ATTR, Boolean.FALSE.toString()); <line18> } <line19> pubsub = response.getElement().addElement(XMLConstants.PUBSUB_ELEM, JabberPubsub.NAMESPACE_URI); <line20> try { <line21> if (parseRsmElement()) { <line22> addRecentItems(); <line23> addRsmElement(); <line24> } <line25> } catch (NodeStoreException e) { <line26> response.getElement().remove(pubsub); <line27> setErrorCondition(PacketError.Type.wait, PacketError.Condition.internal_server_error); <line28> } <line29> outQueue.put(response); <line30> } <line31> } <line32> 	<line26>      LOGGER.error(e);	task4	
public class A { <line0> private void writeSignatureHandshakeAlgorithms(CertificateRequestMessage msg) { <line1> appendBytes(msg.getSignatureHashAlgorithms().getValue()); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""SignatureHashAlgorithms: ""+ ArrayConverter.bytesToHexString(msg.getSignatureHashAlgorithms().getValue()));"	task4	
"public class A { <line0> @Test <line1> public void testWrappedStreamSerialization() throws Exception { <line2> String result = <line3> checkSerializesAs( <line4> BrooklynTaskTags.tagForStream(""TEST"", Streams.byteArrayOfString(""x"")), null); <line5> Assert.assertFalse( <line6> result.contains(""error""), ""Shouldn't have had an error, instead got: "" + result); <line7> } <line8> } <line9> "	"<line5>    log.info(""WRAPPED STREAM json is: "" + result);"	task4	
"public class A { <line0> public static SentryOptions toSentryOptions(SentryConfig sentryConfig) { <line1> if (!sentryConfig.dsn.isPresent()) { <line2> throw new ConfigurationException( <line3> ""Configuration key \""quarkus.log.sentry.dsn\"" is required when Sentry is enabled, but its"" <line4> + "" value is empty/missing""); <line5> } <line6> final SentryOptions options = new SentryOptions(); <line7> if (!sentryConfig.inAppPackages.isPresent()) { <line8> } else { <line9> List<String> inAppPackages = sentryConfig.inAppPackages.get(); <line10> if (inAppPackages.size() != 1 || !Objects.equals(inAppPackages.get(0), ""*"")) { <line11> inAppPackages.forEach(options::addInAppInclude); <line12> } <line13> } <line14> options.setDsn(sentryConfig.dsn.get()); <line15> sentryConfig.environment.ifPresent(options::setEnvironment); <line16> sentryConfig.release.ifPresent(options::setRelease); <line17> sentryConfig.serverName.ifPresent(options::setServerName); <line18> options.setDebug(sentryConfig.debug); <line19> return options; <line20> } <line21> } <line22> "	"<line8>      LOG.warn(""No 'quarkus.sentry.in-app-packages' was configured, this option is highly recommended as""+ "" it affects stacktrace grouping and display on Sentry. See""+ "" https://quarkus.io/guides/logging-sentry#in-app-packages"");"	task4	
public class A { <line0> @Override <line1> public List<String> resolve(List<String> names) { <line2> List<String> racks = new ArrayList<String>(); <line3> for (String n : names) { <line4> String rack = name2Racks.get(n); <line5> if (null == rack) { <line6> rack = NetworkTopology.DEFAULT_RACK; <line7> } <line8> if (LOG.isDebugEnabled()) { <line9> } <line10> racks.add(rack); <line11> } <line12> return racks; <line13> } <line14> } <line15> 	"<line9>        LOG.debug(""Resolve name {} to rack {}."", n, rack);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public static List<Map<String, Object>> getSessionStatDataList(Object webStat) { <line2> if (webStat.getClass() == WebAppStat.class) { <line3> return ((WebAppStat) webStat).getSessionStatDataList(); <line4> } <line5> try { <line6> Method method = webStat.getClass().getMethod(""getSessionStatDataList""); <line7> Object obj = method.invoke(webStat); <line8> return (List<Map<String, Object>>) obj; <line9> } catch (Exception e) { <line10> return null; <line11> } <line12> } <line13> } <line14> "	"<line10>      LOG.error(""getSessionStatDataList error"", e);"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.Team getTeam( <line1> HttpPrincipal httpPrincipal, long groupId, String name) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(TeamServiceUtil.class, ""getTeam"", _getTeamParameterTypes4); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, name); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.portal.kernel.model.Team) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> public ManageSearchPage performSelectedActions() { <line1> clickElement(performButton); <line2> waitForAMoment() <line3> .withMessage(""displayed abort button"") <line4> .until(it -> readyElement(cancelButton).isDisplayed()); <line5> return new ManageSearchPage(getDriver()); <line6> } <line7> } <line8> "	"<line1>    log.info(""Click Perform Actions"");"	task4	
public class A { <line0> protected void emitData(List<Object> tuple, MessageId id) { <line1> if (outputStreamName == null) { <line2> collector.emit(tuple, id); <line3> } else { <line4> collector.emit(outputStreamName, tuple, id); <line5> } <line6> inflight.put(id, tuple); <line7> } <line8> } <line9> 	"<line1>    LOG.trace(""Emitting - {}"", id);"	task4	
public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public AuthorizationIntraCloudListResponseDTO createBulkAuthorizationIntraCloudResponse( <line2> final long consumerId, <line3> final Set<Long> providerIds, <line4> final Set<Long> serviceDefinitionIds, <line5> final Set<Long> interfaceIds) { <line6> final List<AuthorizationIntraCloud> entries = <line7> createBulkAuthorizationIntraCloud( <line8> consumerId, providerIds, serviceDefinitionIds, interfaceIds); <line9> final Page<AuthorizationIntraCloud> entryPage = new PageImpl<>(entries); <line10> return DTOConverter.convertAuthorizationIntraCloudListToAuthorizationIntraCloudListResponseDTO( <line11> entryPage); <line12> } <line13> } <line14> 	"<line6>    logger.debug(""createBulkAuthorizationIntraCloudResponse started..."");"	task4	
public class A { <line0> private LutronHandler findThingHandler(int integrationId) { <line1> for (Thing thing : getThing().getThings()) { <line2> if (thing.getHandler() instanceof LutronHandler) { <line3> LutronHandler handler = (LutronHandler) thing.getHandler(); <line4> try { <line5> if (handler != null && handler.getIntegrationId() == integrationId) { <line6> return handler; <line7> } <line8> } catch (IllegalStateException e) { <line9> } <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line9>          logger.trace(""Handler for id {} not initialized"", integrationId);"	task4	
"public class A { <line0> private void obtainKeys(final KeyStore keyStore, final ApplicationContext appContext) { <line1> @SuppressWarnings(""unchecked"") <line2> final Map<String, Object> context = <line3> appContext.getBean(CommonConstants.ARROWHEAD_CONTEXT, Map.class); <line4> final X509Certificate serverCertificate = Utilities.getSystemCertFromKeyStore(keyStore); <line5> publicKey = serverCertificate.getPublicKey(); <line6> context.put(CommonConstants.SERVER_PUBLIC_KEY, publicKey); <line7> final PrivateKey privateKey = Utilities.getPrivateKey(keyStore, sslProperties.getKeyPassword()); <line8> context.put(CommonConstants.SERVER_PRIVATE_KEY, privateKey); <line9> context.put(CommonConstants.SERVER_CERTIFICATE, serverCertificate); <line10> } <line11> } <line12> "	"<line1>    logger.debug(""obtainKeys started..."");"	task4	
"public class A { <line0> @Override <line1> public void deleteSeries(String seriesId) <line2> throws SeriesServiceDatabaseException, NotFoundException { <line3> EntityManager em = emf.createEntityManager(); <line4> EntityTransaction tx = em.getTransaction(); <line5> try { <line6> tx.begin(); <line7> SeriesEntity entity = getSeriesEntity(seriesId, em); <line8> if (entity == null) { <line9> throw new NotFoundException(""Series with ID "" + seriesId + "" does not exist""); <line10> } <line11> String accessControlXml = entity.getAccessControl(); <line12> if (accessControlXml != null) { <line13> AccessControlList acl = AccessControlParser.parseAcl(accessControlXml); <line14> User currentUser = securityService.getUser(); <line15> Organization currentOrg = securityService.getOrganization(); <line16> if (!AccessControlUtil.isAuthorized( <line17> acl, currentUser, currentOrg, Permissions.Action.WRITE.toString())) { <line18> throw new UnauthorizedException( <line19> currentUser + "" is not authorized to update series "" + seriesId); <line20> } <line21> } <line22> em.remove(entity); <line23> tx.commit(); <line24> } catch (NotFoundException e) { <line25> throw e; <line26> } catch (Exception e) { <line27> if (tx.isActive()) { <line28> tx.rollback(); <line29> } <line30> throw new SeriesServiceDatabaseException(e); <line31> } finally { <line32> em.close(); <line33> } <line34> } <line35> } <line36> "	"<line27>      logger.error(""Could not delete series: {}"", e.getMessage());"	task4	
public class A { <line0> @Override <line1> public SamlSpSession findByPrimaryKey(Serializable primaryKey) throws NoSuchSpSessionException { <line2> SamlSpSession samlSpSession = fetchByPrimaryKey(primaryKey); <line3> if (samlSpSession == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchSpSessionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return samlSpSession; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> public static List<String> getMinuteDatesOnEitherSide( <line1> DateTime startDate, DateTime endDate, int minuteSkip, DateTimeFormatter formatter) { <line2> if (minuteSkip == 0) { <line3> minuteSkip = 1; <line4> } <line5> List<String> dates = new ArrayList<>(); <line6> while (!startDate.isAfter(endDate)) { <line7> dates.add(formatter.print(startDate)); <line8> startDate = startDate.plusMinutes(minuteSkip); <line9> } <line10> return dates; <line11> } <line12> } <line13> 	"<line2>    LOGGER.info(""generating data between ""+ formatter.print(startDate)+ "" and ""+ formatter.print(endDate));"	task4	
public class A { <line0> public static com.liferay.commerce.model.CommerceSubscriptionEntrySoap[] <line1> getCommerceSubscriptionEntries( <line2> long companyId, <line3> long groupId, <line4> long userId, <line5> int start, <line6> int end, <line7> com.liferay.portal.kernel.util.OrderByComparator< <line8> com.liferay.commerce.model.CommerceSubscriptionEntry> <line9> orderByComparator) <line10> throws RemoteException { <line11> try { <line12> java.util.List<com.liferay.commerce.model.CommerceSubscriptionEntry> returnValue = <line13> CommerceSubscriptionEntryServiceUtil.getCommerceSubscriptionEntries( <line14> companyId, groupId, userId, start, end, orderByComparator); <line15> return com.liferay.commerce.model.CommerceSubscriptionEntrySoap.toSoapModels(returnValue); <line16> } catch (Exception exception) { <line17> throw new RemoteException(exception.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line17>      log.error(exception, exception);	task4	
"public class A { <line0> @PostMapping(CommonConstants.PATH_IMPORT) <line1> public JsonNode importAgencies( <line2> @RequestParam(""fileName"") String fileName, @RequestParam(""file"") MultipartFile file) { <line3> SafeFileChecker.checkSafeFilePath(file.getOriginalFilename()); <line4> final VitamContext vitamContext = <line5> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line6> return agencyInternalService.importAgencies(vitamContext, fileName, file); <line7> } <line8> } <line9> "	"<line3>    LOGGER.debug(""import agency file {}"", fileName);"	task4	
public class A { <line0> public static void closeQuietly(TopicSubscriber topicSubscriber) { <line1> if (topicSubscriber != null) { <line2> try { <line3> topicSubscriber.close(); <line4> } catch (JMSException ignore) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        LOG.error(""Error closing JMS topic subscriber: "" + topicSubscriber, ignore);"	task4	
public class A { <line0> @Override <line1> public void discoverObjectInstance( <line2> ObjectInstanceHandle theObject, ObjectClassHandle theObjectClass, String objectName) <line3> throws FederateInternalError { <line4> } <line5> } <line6> 	"<line4>    LOGGER.info(""Discover Object Instance : ""+ ""Object = ""+ theObject.toString()+ "", Object class = ""+ theObjectClass.toString()+ "", Object name = ""+ objectName);"	task4	
public class A { <line0> public void processPubAck(Channel client, MqttPubAckMessage pubAckMessage) { <line1> MqttMessageIdVariableHeader pubAckVariableMessage = pubAckMessage.variableHeader(); <line2> short packageId = (short) pubAckVariableMessage.messageId(); <line3> String clientId = NettyAttrManager.getAttrClientId(client); <line4> consumerManager.acknowledge(clientId, packageId); <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.debug(""Received PubAck packageID: {}"" + packageId);"	task4	
public class A { <line0> private void handleIncreaseDecrease(ChannelUID channelUID, IncreaseDecreaseType command) { <line1> sendOmnilinkCommand( <line2> IncreaseDecreaseType.INCREASE.equals(command) <line3> ? CommandMessage.CMD_UNIT_UPB_BRIGHTEN_STEP_1 <line4> : CommandMessage.CMD_UNIT_UPB_DIM_STEP_1, <line5> 0, <line6> thingID); <line7> } <line8> } <line9> 	"<line1>    logger.debug(""handleIncreaseDecrease called for channel: {}, command: {}"", channelUID, command);"	task4	
public class A { <line0> public void task() throws Exception { <line1> FromDefinition from = route.getInput(); <line2> from.setEndpoint(null); <line3> from.setUri(uri); <line4> } <line5> } <line6> 	"<line2>    LOG.info(""AdviceWith replace input from [{}] --> [{}]"", from.getEndpointUri(), uri);"	task4	
public class A { <line0> public String getResourceAsString(String url) { <line1> try { <line2> return Streams.readFullyStringAndClose(getResourceFromUrl(url)); <line3> } catch (Exception e) { <line4> throw Throwables.propagate(e); <line5> } <line6> } <line7> } <line8> 	"<line4>      log.debug(""ResourceUtils got error reading ""+ url+ (context == null ? """" : "" "" + context)+ "" (rethrowing): ""+ e);"	task4	
public class A { <line0> private String convertIterationType(DataType iterationType) { <line1> if (iterationType instanceof Text) { <line2> return iterationType.toString(); <line3> } else { <line4> return iterationType.toString(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.warn(MessageFormat.format(this.getActionExecution().getAction().getType()+ "" does not accept {0} as type for iterationType"",iterationType.getClass()));"	task4	
"public class A { <line0> @Override <line1> protected User checkAuthentication() throws BusinessException { <line2> User authUser = super.checkAuthentication(); <line3> if (!(authUser.hasSimpleRole() || authUser.hasAdminRole() || authUser.hasSuperAdminRole())) { <line4> throw new BusinessException( <line5> BusinessErrorCode.WEBSERVICE_FORBIDDEN, ""You are not authorized to use this service""); <line6> } <line7> return authUser; <line8> } <line9> } <line10> "	"<line4>      logger.error(""Current authUser is trying to access to a forbbiden api : ""+ authUser.getAccountRepresentation());"	task4	
public class A { <line0> protected final void log(String text) { <line1> } <line2> } <line3> 	<line1>    logger.info(text);	task4	
public class A { <line0> @Override <line1> public Double convertStringValue(String value) { <line2> if (value == null) { <line3> return null; <line4> } <line5> try { <line6> double d = parse(value); <line7> return d; <line8> } catch (CoordinateFormatException e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	"<line7>      Log.debug(""CoordinateEditor: '"" + value + ""' -> "" + d);"	task4	
public class A { <line0> @Override <line1> public void invalidateCollectionSyncRootMemberCache() { <line2> getCollectionSyncRootMemberCache().invalidateAll(); <line3> } <line4> } <line5> 	"<line2>    log.debug(""Invalidating collection sync root member cache for all users"");"	task4	
public class A { <line0> public static Set<Class<?>> getTypesAnnotatedWith(Class<? extends Annotation> clazz) { <line1> Set<Class<?>> classes = reflections.getTypesAnnotatedWith(clazz); <line2> return classes; <line3> } <line4> } <line5> 	"<line2>    log.info(""Found {} classes annotated with {} "", (classes != null ? classes.size() : 0), clazz);"	task4	
public class A { <line0> public BindFuture bindAsync(String name) throws LdapException { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> BindRequest bindRequest = createBindRequest(name, Strings.EMPTY_BYTES); <line4> return bindAsync(bindRequest); <line5> } <line6> } <line7> 	<line2>      LOG.debug(I18n.msg(I18n.MSG_04102_BIND_REQUEST, name));	task4	
public class A { <line0> public static String getFormatedString(DataType dataType, String mask, Object data) { <line1> try { <line2> switch (dataType) { <line3> case NUMERIC: <line4> DecimalFormat decimalFormat = new DecimalFormat(mask); <line5> decimalFormat.setParseBigDecimal(true); <line6> return decimalFormat.format(data); <line7> case DATE: <line8> SimpleDateFormat simpleDateFormat = new SimpleDateFormat(mask); <line9> if (data instanceof Date) { <line10> return simpleDateFormat.format(data); <line11> } <line12> Date dateFromstring = DateDetector.getDateFromString(String.valueOf(data)); <line13> return simpleDateFormat.format(dateFromstring); <line14> case STRING: <line15> case UNKNOWN: <line16> case BOOLEAN: <line17> case BINARY: <line18> case IMAGE: <line19> case URL: <line20> default: <line21> return String.valueOf(data); <line22> } <line23> } catch (Exception e) { <line24> return String.valueOf(data); <line25> } <line26> } <line27> } <line28> 	"<line24>      log.debug(DataFormatter.class.getName()+ "" could not apply mask to data. The original data was returned"");"	task4	
public class A { <line0> @Override <line1> public void setBlobStore(BlobStore blobStore) { <line2> splitBlobStore = new DefaultSplitBlobStore(repositoryDir, blobStore, newBlobStore); <line3> } <line4> } <line5> 	"<line2>    log.info(""Internal blob store set: {}"", blobStore);"	task4	
public class A { <line0> protected MessageConsumer createConsumer() throws JMSException { <line1> if (durable) { <line2> return consumeSession.createDurableSubscriber((Topic) consumerDestination, getName()); <line3> } <line4> return consumeSession.createConsumer(consumerDestination); <line5> } <line6> } <line7> 	"<line2>      LOG.info(""Creating durable consumer"");"	task4	
public class A { <line0> public static synchronized void doAddTriple( <line1> Triple t, RuleContext context, boolean addToDeductions) { <line2> context.add(t); <line3> boolean deductionsNotified = false; <line4> if (addToDeductions && context.getGraph() instanceof FBRuleInfGraph) { <line5> ((FBRuleInfGraph) context.getGraph()).addDeduction(t); <line6> deductionsNotified = true; <line7> } <line8> if (logger.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> 	"<line9>      logger.debug(""in Rule ""+ context.getRule().getName()+ "" added to context: [""+ t.toString()+ ""], deductions notified ""+ deductionsNotified);"	task4	
"public class A { <line0> public IApsEntity buildEntity( <line1> IApsEntity prototype, ICategoryManager categoryManager, String langCode) { <line2> try { <line3> prototype.setDescription(this.getDescription()); <line4> prototype.setId(this.getId()); <line5> prototype.setMainGroup(this.getMainGroup()); <line6> prototype.setTypeCode(this.getTypeCode()); <line7> prototype.setTypeDescription(this.getTypeDescription()); <line8> if (null != this.getGroups() && !this.getGroups().isEmpty()) { <line9> Iterator<String> iter = this.getGroups().iterator(); <line10> while (iter.hasNext()) { <line11> prototype.addGroup(iter.next()); <line12> } <line13> } <line14> if (null != this.getCategories() && !this.getCategories().isEmpty()) { <line15> Iterator<String> iter = this.getCategories().iterator(); <line16> while (iter.hasNext()) { <line17> String categoryCode = iter.next(); <line18> Category category = categoryManager.getCategory(categoryCode); <line19> if (null != category) { <line20> prototype.addCategory(category); <line21> } <line22> } <line23> } <line24> if (null == this.getAttributes()) { <line25> return prototype; <line26> } <line27> for (int i = 0; i < this.getAttributes().size(); i++) { <line28> AbstractJAXBAttribute jaxrAttribute = this.getAttributes().get(i); <line29> AttributeInterface attribute = <line30> (AttributeInterface) prototype.getAttribute(jaxrAttribute.getName()); <line31> if (null != attribute && attribute.getType().equals(jaxrAttribute.getType())) { <line32> attribute.valueFrom(jaxrAttribute, langCode); <line33> } <line34> } <line35> } catch (Throwable t) { <line36> throw new RuntimeException(""Error creating Entity"", t); <line37> } <line38> return prototype; <line39> } <line40> } <line41> "	"<line36>      logger.error(""Error creating Entity"", t);"	task4	
public class A { <line0> @Verify <line1> public void globalVerify() { <line2> ICacheOperationCounter total = new ICacheOperationCounter(); <line3> for (ICacheOperationCounter counter : results) { <line4> total.add(counter); <line5> } <line6> } <line7> } <line8> 	"<line6>    logger.info(name + "": "" + total + "" from "" + results.size() + "" worker threads"");"	task4	
"public class A { <line0> public static String getLocalAddress() { <line1> try { <line2> String customIP = System.getProperty(""qmq.ip""); <line3> if (!Strings.isNullOrEmpty(customIP)) return customIP; <line4> final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); <line5> final ArrayList<String> ipv4Result = new ArrayList<>(); <line6> final ArrayList<String> ipv6Result = new ArrayList<>(); <line7> while (interfaces.hasMoreElements()) { <line8> final NetworkInterface networkInterface = interfaces.nextElement(); <line9> if (!networkInterface.isUp()) continue; <line10> if (networkInterface.isVirtual()) continue; <line11> final Enumeration<InetAddress> addresses = networkInterface.getInetAddresses(); <line12> while (addresses.hasMoreElements()) { <line13> final InetAddress address = addresses.nextElement(); <line14> if (!address.isLoopbackAddress()) { <line15> if (address instanceof Inet6Address) { <line16> ipv6Result.add(address.getHostAddress()); <line17> } else { <line18> ipv4Result.add(address.getHostAddress()); <line19> } <line20> } <line21> } <line22> } <line23> if (!ipv4Result.isEmpty()) { <line24> for (String ip : ipv4Result) { <line25> if (ip.startsWith(""127.0"")) { <line26> continue; <line27> } <line28> return ip; <line29> } <line30> return ipv4Result.get(ipv4Result.size() - 1); <line31> } else if (!ipv6Result.isEmpty()) { <line32> return ipv6Result.get(0); <line33> } <line34> return InetAddress.getLocalHost().getHostAddress(); <line35> } catch (Exception e) { <line36> } <line37> return null; <line38> } <line39> } <line40> "	"<line36>      LOG.error(""get local address failed"", e);"	task4	
public class A { <line0> public Page<WebContent> findAll(final Pageable pageable) { <line1> return webContentRepository.findAll(pageable); <line2> } <line3> } <line4> 	"<line1>    log.debug(""findAll() - pageable: {}"", pageable);"	task4	
public class A { <line0> public static <K, V> Optional<Map<K, V>> decodeMapData( <line1> CloudEvent event, Class<K> keyClass, Class<V> valueClass) { <line2> try { <line3> JavaType mapType = <line4> Mapper.mapper().getTypeFactory().constructMapType(HashMap.class, keyClass, valueClass); <line5> return Optional.ofNullable(Mapper.mapper().readValue(event.getData(), mapType)); <line6> } catch (IOException e) { <line7> return Optional.empty(); <line8> } <line9> } <line10> } <line11> 	"<line7>      LOG.error(""Unable to decode CloudEvent data to Map<""+ keyClass.getName()+ "",""+ valueClass.getName()+ "">"",e);"	task4	
"public class A { <line0> @Override <line1> public String getRevisionID() throws KuraException { <line2> synchronized (this.atLock) { <line3> if (this.revisionId == null) { <line4> byte[] reply; <line5> CommConnection commAtConnection = openSerialPort(getAtPort()); <line6> if (!isAtReachable(commAtConnection)) { <line7> closeSerialPort(commAtConnection); <line8> throw new KuraException(KuraErrorCode.NOT_CONNECTED, MODEM_NOT_AVAILABLE_FOR_AT_CMDS_MSG); <line9> } <line10> try { <line11> reply = <line12> commAtConnection.sendCommand( <line13> SierraMc87xxAtCommands.getFirmwareVersion.getCommand().getBytes(), 1000, 100); <line14> } catch (IOException e) { <line15> closeSerialPort(commAtConnection); <line16> throw new KuraException(KuraErrorCode.CONNECTION_FAILED, e); <line17> } <line18> closeSerialPort(commAtConnection); <line19> if (reply != null) { <line20> String firmwareVersion = getResponseString(reply); <line21> if (firmwareVersion.startsWith(""!GVER:"")) { <line22> firmwareVersion = firmwareVersion.substring(""!GVER:"".length()).trim(); <line23> String[] aFirmwareVersion = firmwareVersion.split("" ""); <line24> this.revisionId = aFirmwareVersion[0]; <line25> } <line26> } <line27> } <line28> } <line29> return this.revisionId; <line30> } <line31> } <line32> "	"<line4>        logger.debug(""sendCommand getRevision :: {}"",SierraMc87xxAtCommands.getFirmwareVersion.getCommand());"	task4	
public class A { <line0> @Override <line1> public void setDoubleProperty(final String name, final double value) throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> message.setDoubleProperty(name, value); <line5> } <line6> } <line7> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""setDoubleProperty("" + name + "", "" + value + "")"");"	task4	
"public class A { <line0> @Override <line1> public Node handle(ComponentRequest request) { <line2> val uiComponent = new VBox(); <line3> val uiField = _fx.add(uiComponent, new TextField()); <line4> val uiValidationFeedback = _fx.newValidationFeedback(uiComponent); <line5> val valueSpec = request.getFeatureTypeSpec(); <line6> val converter = new NumberConverterForStringComponent(valueSpec); <line7> uiField.setTextFormatter( <line8> new TextFormatter<String>( <line9> change -> { <line10> val input = change.getText(); <line11> val parsingError = converter.tryParse(_Strings.suffix(input, ""0"")); <line12> if (parsingError.isPresent()) { <line13> return null; <line14> } <line15> return change; <line16> })); <line17> if (request.getManagedFeature() instanceof ManagedParameter) { <line18> val managedParameter = (ManagedParameter) request.getManagedFeature(); <line19> BindingsFx.bindBidirectional(uiField.textProperty(), managedParameter.getValue(), converter); <line20> BindingsFx.bindValidationFeeback( <line21> uiValidationFeedback.textProperty(), <line22> uiValidationFeedback.visibleProperty(), <line23> managedParameter.getValidationMessage()); <line24> } else if (request.getManagedFeature() instanceof ManagedProperty) { <line25> val managedProperty = (ManagedProperty) request.getManagedFeature(); <line26> BindingsFx.bind(uiField.textProperty(), managedProperty.getValue(), converter); <line27> uiField.editableProperty().set(false); <line28> } <line29> return uiComponent; <line30> } <line31> } <line32> "	"<line13>                log.warn(""Failed to parse UI input '{}': {}"", input, parsingError.get());"	task4	
"public class A { <line0> protected boolean deleteTaskNonRecursive(Task<?> task) { <line1> Set<?> tags = checkNotNull(task, ""task"").getTags(); <line2> for (Object tag : tags) { <line3> synchronized (tasksByTag) { <line4> Set<Task<?>> tasks = tasksWithTagLiveOrNull(tag); <line5> if (tasks != null) { <line6> tasks.remove(task); <line7> if (tasks.isEmpty()) { <line8> tasksByTag.remove(tag); <line9> } <line10> } <line11> } <line12> } <line13> Task<?> removed = tasksById.remove(task.getId()); <line14> incompleteTaskIds.remove(task.getId()); <line15> if (removed != null && removed.isSubmitted() && !removed.isDone()) { <line16> } <line17> return removed != null; <line18> } <line19> } <line20> "	"<line16>      log.warn(""Deleting submitted task before completion: ""+ removed+ ""; this task will continue to run in the background outwith ""+ this+ "", but perhaps it should have been cancelled?"");"	task4	
public class A { <line0> void applyPhysicalPlan(PhysicalPlan plan, DataGroupMember dataGroupMember) <line1> throws QueryProcessException, StorageGroupNotSetException, StorageEngineException { <line2> if (plan instanceof InsertPlan) { <line3> processPlanWithTolerance((InsertPlan) plan, dataGroupMember); <line4> } else if (plan != null && !plan.isQuery()) { <line5> try { <line6> getQueryExecutor().processNonQuery(plan); <line7> } catch (BatchProcessException e) { <line8> handleBatchProcessException(e, plan); <line9> } catch (QueryProcessException e) { <line10> if (e.getCause() instanceof StorageGroupNotSetException <line11> || e.getCause() instanceof UndefinedTemplateException) { <line12> executeAfterSync(plan); <line13> } else { <line14> throw e; <line15> } <line16> } catch (StorageGroupNotSetException e) { <line17> executeAfterSync(plan); <line18> } <line19> } else if (plan != null) { <line20> } <line21> } <line22> } <line23> 	"<line20>      logger.error(""Unsupported physical plan: {}"", plan);"	task4	
"public class A { <line0> public List<String> getWidgetUtilizerCodes(String widgetTypeCode) { <line1> List<String> utilizers = new ArrayList<>(); <line2> try { <line3> List<String> draftUtilizers = <line4> this.getPageManager().getDraftWidgetUtilizerCodes(widgetTypeCode); <line5> if (null != draftUtilizers && draftUtilizers.size() > 0) { <line6> utilizers.addAll(draftUtilizers); <line7> } <line8> List<String> onlineUtilizers = <line9> this.getPageManager().getOnlineWidgetUtilizerCodes(widgetTypeCode); <line10> if (null != onlineUtilizers && onlineUtilizers.size() > 0) { <line11> utilizers.addAll(onlineUtilizers); <line12> } <line13> } catch (Throwable t) { <line14> throw new RuntimeException( <line15> ""Error on extracting widgetUtilizers : widget type code "" + widgetTypeCode, t); <line16> } <line17> return utilizers; <line18> } <line19> } <line20> "	"<line14>      logger.error(""Error on extracting widgetUtilizers : widget type code {}"", t);"	task4	
"public class A { <line0> public static void deleteCommerceDiscountCommerceAccountGroupRelsByCommerceDiscountId( <line1> HttpPrincipal httpPrincipal, long commerceDiscountId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceDiscountCommerceAccountGroupRelServiceUtil.class, <line7> ""deleteCommerceDiscountCommerceAccountGroupRelsByCommerceDiscountId"", <line8> _deleteCommerceDiscountCommerceAccountGroupRelsByCommerceDiscountIdParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceDiscountId); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public void reload() { <line2> if (!shouldRun()) { <line3> return; <line4> } <line5> try { <line6> prepareConfigFile(); <line7> StringBuilder apiProxyUrl = new StringBuilder(); <line8> apiProxyUrl <line9> .append(""http://localhost:"") <line10> .append(getProxyPort()) <line11> .append(""/v1-api-interceptor/reload""); <line12> Request.Post(apiProxyUrl.toString()).execute(); <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> "	"<line14>      log.error(""Failed to reload api proxy service: {}"", e.getMessage());"	task4	
"public class A { <line0> private CatalogModel loadCatalogModel() { <line1> CatalogModel model = null; <line2> try { <line3> LoadModel<CatalogModel> loadModel = new LoadModel<>(CatalogModel.class); <line4> loadModel = getCommandService().executeCommand(loadModel); <line5> model = loadModel.getModel(); <line6> if (model != null) { <line7> fireLoad(model); <line8> } <line9> } catch (Exception e) { <line10> throw new RuntimeException(""Error loading the CatalogModel"", e); <line11> } <line12> return model; <line13> } <line14> } <line15> "	"<line10>      logger.error(""Error loading the CatalogModel"", e);"	task4	
public class A { <line0> private boolean updateHighWatermark() { <line1> List<ReplicaState> followersByDescendingFetchOffset = followersByDescendingFetchOffset(); <line2> int indexOfHw = voterStates.size() / 2; <line3> Optional<LogOffsetMetadata> highWatermarkUpdateOpt = <line4> followersByDescendingFetchOffset.get(indexOfHw).endOffset; <line5> if (highWatermarkUpdateOpt.isPresent()) { <line6> LogOffsetMetadata highWatermarkUpdateMetadata = highWatermarkUpdateOpt.get(); <line7> long highWatermarkUpdateOffset = highWatermarkUpdateMetadata.offset; <line8> if (highWatermarkUpdateOffset > epochStartOffset) { <line9> if (highWatermark.isPresent()) { <line10> LogOffsetMetadata currentHighWatermarkMetadata = highWatermark.get(); <line11> if (highWatermarkUpdateOffset > currentHighWatermarkMetadata.offset <line12> || (highWatermarkUpdateOffset == currentHighWatermarkMetadata.offset <line13> && !highWatermarkUpdateMetadata.metadata.equals( <line14> currentHighWatermarkMetadata.metadata))) { <line15> highWatermark = highWatermarkUpdateOpt; <line16> return true; <line17> } else if (highWatermarkUpdateOffset < currentHighWatermarkMetadata.offset) { <line18> return false; <line19> } else { <line20> return false; <line21> } <line22> } else { <line23> highWatermark = highWatermarkUpdateOpt; <line24> return true; <line25> } <line26> } <line27> } <line28> return false; <line29> } <line30> } <line31> 	"<line18>            log.error(""The latest computed high watermark {} is smaller than the current ""+ ""value {}, which suggests that one of the voters has lost committed data. ""+ ""Full voter replication state: {}"",highWatermarkUpdateOffset,currentHighWatermarkMetadata.offset,voterStates.values());"	task4	
"public class A { <line0> public List<IndexedRecord> filterAllTestRows(String random, List<IndexedRecord> rows) { <line1> List<IndexedRecord> checkedRows = new ArrayList<>(); <line2> for (IndexedRecord row : rows) { <line3> String check = (String) row.get(row.getSchema().getField(""ShippingStreet"").pos()); <line4> if (check == null || !check.equals(TEST_KEY)) { <line5> continue; <line6> } <line7> if (random != null) { <line8> check = (String) row.get(row.getSchema().getField(""BillingPostalCode"").pos()); <line9> if (check == null || !check.equals(random)) { <line10> continue; <line11> } <line12> } <line13> checkedRows.add(row); <line14> } <line15> return checkedRows; <line16> } <line17> } <line18> "	"<line13>      LOGGER.debug(""Found match: ""+ row.get(row.getSchema().getField(""Name"").pos())+ "" id: ""+ row.get(row.getSchema().getField(""Id"").pos())+ "" shippingPostalCode: ""+ row.get(row.getSchema().getField(""ShippingPostalCode"").pos())+ "" billingPostalCode: ""+ row.get(row.getSchema().getField(""BillingPostalCode"").pos())+ "" billingStreet: ""+ row.get(row.getSchema().getField(""BillingStreet"").pos()));"	task4	
public class A { <line0> @Override <line1> public void onTopologyUpdate(CacheTopology oldCacheTopology, CacheTopology newCacheTopology) { <line2> if (log.isTraceEnabled()) { <line3> } <line4> Address local = rpcManager.getAddress(); <line5> if (!newCacheTopology.getMembers().contains(local)) { <line6> return; <line7> } <line8> IntSet addedSegments = <line9> mutableCopyFrom(newCacheTopology.getWriteConsistentHash().getSegmentsForOwner(local)); <line10> if (oldCacheTopology.getMembers().contains(local)) { <line11> addedSegments.removeAll(oldCacheTopology.getWriteConsistentHash().getSegmentsForOwner(local)); <line12> } <line13> if (addedSegments.isEmpty()) { <line14> iracExecutor.run(); <line15> return; <line16> } <line17> Map<Address, IntSet> primarySegments = new HashMap<>(); <line18> for (int segment : addedSegments) { <line19> Address primary = <line20> newCacheTopology.getWriteConsistentHash().locatePrimaryOwnerForSegment(segment); <line21> primarySegments.computeIfAbsent(primary, DefaultIracManager::newIntSet).add(segment); <line22> } <line23> primarySegments.forEach(this::sendStateRequest); <line24> iracExecutor.run(); <line25> } <line26> } <line27> 	"<line3>      log.trace(""[IRAC] Topology Updated. Checking pending keys."");"	task4	
public class A { <line0> @PostConstruct <line1> public void postConstruct() { <line2> this.contractResources = <line3> Map.of( <line4> HOLDING_ACCESS_CONTRACT_NAME, <line5> holdingAccessContract, <line6> HOLDING_INGEST_CONTRACT_NAME, <line7> holdingIngestContract, <line8> LOGBOOK_ACCESS_CONTRACT_NAME, <line9> logbookAccessContract, <line10> ITEMS_INGEST_CONTRACT_NAME, <line11> itemsIngestContract, <line12> FULL_ACCESS_CONTRACT_NAME, <line13> fullAccessAccessContract); <line14> } <line15> } <line16> 	"<line2>    LOGGER.debug(""init vitam tenant is mandatory : {}"", mandatory);"	task4	
"public class A { <line0> private String getCompletionTargetString(String text, int cursor) { <line1> String[] completionSeqCharaters = {"" "", ""\n"", ""\t""}; <line2> int completionEndPosition = cursor; <line3> int completionStartPosition = cursor; <line4> int indexOfReverseSeqPostion = cursor; <line5> String resultCompletionText = """"; <line6> String completionScriptText = """"; <line7> try { <line8> completionScriptText = text.substring(0, cursor); <line9> } catch (Exception e) { <line10> return null; <line11> } <line12> completionEndPosition = completionScriptText.length(); <line13> String tempReverseCompletionText = new StringBuilder(completionScriptText).reverse().toString(); <line14> for (String seqCharacter : completionSeqCharaters) { <line15> indexOfReverseSeqPostion = tempReverseCompletionText.indexOf(seqCharacter); <line16> if (indexOfReverseSeqPostion < completionStartPosition && indexOfReverseSeqPostion > 0) { <line17> completionStartPosition = indexOfReverseSeqPostion; <line18> } <line19> } <line20> if (completionStartPosition == completionEndPosition) { <line21> completionStartPosition = 0; <line22> } else { <line23> completionStartPosition = completionEndPosition - completionStartPosition; <line24> } <line25> resultCompletionText = <line26> completionScriptText.substring(completionStartPosition, completionEndPosition); <line27> return resultCompletionText; <line28> } <line29> } <line30> "	<line10>      LOGGER.error(e.toString());	task4	
public class A { <line0> private void abort(Error error) { <line1> try { <line2> if (mContext == null || mContext.getError() != null || mContext.isDoneUnsafe()) { <line3> return; <line4> } <line5> mContext.setError(error); <line6> cleanupRequest(mContext); <line7> } catch (Exception e) { <line8> } finally { <line9> replyError(); <line10> } <line11> } <line12> } <line13> 	"<line8>      LOG.warn(""Failed to cleanup states with error {}."", e.toString());"	task4	
"public class A { <line0> public boolean isLinux() { <line1> String guestid = configSpec.getGuestId(); <line2> boolean isLinux = <line3> guestid.startsWith(""cent"") <line4> || guestid.startsWith(""debian"") <line5> || guestid.startsWith(""freebsd"") <line6> || guestid.startsWith(""oracle"") <line7> || guestid.startsWith(""other24xLinux"") <line8> || guestid.startsWith(""other26xLinux"") <line9> || guestid.startsWith(""otherLinux"") <line10> || guestid.startsWith(""redhat"") <line11> || guestid.startsWith(""rhel"") <line12> || guestid.startsWith(""sles"") <line13> || guestid.startsWith(""suse"") <line14> || guestid.startsWith(""ubuntu""); <line15> return isLinux; <line16> } <line17> } <line18> "	"<line15>    LOG.debug(""instanceName: ""+ instanceName+ "" isLinux: ""+ isLinux+ "" guestid: ""+ configSpec.getGuestId()+ "" OS: ""+ configSpec.getGuestFullName());"	task4	
public class A { <line0> public SignInPage clickSignInExpectError() { <line1> clickElement(signInButton); <line2> return new SignInPage(getDriver()); <line3> } <line4> } <line5> 	"<line1>    log.info(""Click Sign In"");"	task4	
public class A { <line0> @Override <line1> public void debug(final String format, final Object arg1, final Object arg2) { <line2> } <line3> } <line4> 	<line2>    log.debug(format, arg1, arg2);	task4	
public class A { <line0> private Object do4Update( <line1> ProceedingJoinPoint pjp, <line2> HttpServletRequest request, <line3> HttpServletResponse response, <line4> String dataId, <line5> String group, <line6> String tenant, <line7> String content) <line8> throws Throwable { <line9> if (!PropertyUtil.isCapacityLimitCheck()) { <line10> return pjp.proceed(); <line11> } <line12> try { <line13> boolean hasTenant = hasTenant(tenant); <line14> Capacity capacity = getCapacity(group, tenant, hasTenant); <line15> if (isSizeLimited(group, tenant, getCurrentSize(content), hasTenant, false, capacity)) { <line16> return response4Limit(request, response, LimitType.OVER_MAX_SIZE); <line17> } <line18> } catch (Exception e) { <line19> } <line20> return pjp.proceed(); <line21> } <line22> } <line23> 	"<line19>      LOGGER.error(""[capacityManagement] do4Update "", e);"	task4	
public class A { <line0> @Override <line1> public CompletableFuture<Acknowledge> notifyKvStateUnregistered( <line2> JobID jobId, JobVertexID jobVertexId, KeyGroupRange keyGroupRange, String registrationName) { <line3> try { <line4> schedulerNG.notifyKvStateUnregistered(jobId, jobVertexId, keyGroupRange, registrationName); <line5> return CompletableFuture.completedFuture(Acknowledge.get()); <line6> } catch (FlinkJobNotFoundException e) { <line7> return FutureUtils.completedExceptionally(e); <line8> } <line9> } <line10> } <line11> 	"<line7>      log.info(""Error while receiving notification about key-value state de-registration"", e);"	task4	
"public class A { <line0> @Test <line1> public void test_00() throws IOException { <line2> String fileName = path(""testLukas.vcf""); <line3> long hashExp = calcHashBufferedReader(fileName); <line4> long hash = calcHash(fileName); <line5> System.out.println(String.format(""%016x\t%016x\t%s"", hashExp, hash, fileName)); <line6> Assert.assertEquals(hashExp, hash); <line7> } <line8> } <line9> "	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> @Override <line1> public void run(Timeout timeout) throws Exception { <line2> if (!isConnected()) { <line3> return; <line4> } <line5> if (!syncPullCollectorCluster()) { <line6> timer.newTimeout( <line7> new PullCollectorClusterJob(), PULL_RETRY_INTERVAL_TIME_MILLIS, TimeUnit.MILLISECONDS); <line8> } <line9> } <line10> } <line11> 	"<line2>    logger.info(""Reserved {} started."", ClassUtils.simpleClassName(this));"	task4	
public class A { <line0> @Override <line1> public Map<Integer, GovernmentBodyAnnualSummary> getDataPerGovernmentBody(final String name) { <line2> final Map<Integer, GovernmentBodyAnnualSummary> map = new TreeMap<>(); <line3> try { <line4> final HSSFWorkbook myWorkBook = createGovermentBodyWorkBook(); <line5> for (int sheetNr = 0; sheetNr < myWorkBook.getNumberOfSheets(); sheetNr++) { <line6> final HSSFSheet mySheet = myWorkBook.getSheetAt(sheetNr); <line7> addDataForYearToMap(name, map, mySheet); <line8> } <line9> myWorkBook.close(); <line10> } catch (final IOException e) { <line11> } <line12> return map; <line13> } <line14> } <line15> 	"<line11>      LOGGER.warn(""Problem loading"", e);"	task4	
public class A { <line0> @Override <line1> public MCRIIIFManifest getManifest(String id) { <line2> try { <line3> Document metsDocument = getMets(id); <line4> return getConverter(id, metsDocument).convert(); <line5> } catch (IOException | JDOMException | SAXException e) { <line6> throw new MCRException(e); <line7> } <line8> } <line9> } <line10> 	<line4>      LOGGER.debug(() -> new XMLOutputter(Format.getPrettyFormat()).outputString(metsDocument));	task4	
public class A { <line0> private void printlnError(Object o) { <line1> } <line2> } <line3> 	"<line1>    logger.error("""" + o);"	task4	
"public class A { <line0> protected List<Blob> loadBlobs(List<Map<String, String>> blobInfos) { <line1> List<Blob> blobs = new ArrayList<>(); <line2> for (Map<String, String> info : blobInfos) { <line3> File blobFile = new File(cacheDir, info.get(""file"")); <line4> Blob blob = new FileBlob(blobFile); <line5> blob.setEncoding(info.get(""encoding"")); <line6> blob.setMimeType(info.get(""mimetype"")); <line7> blob.setFilename(info.get(""filename"")); <line8> blob.setDigest(info.get(""digest"")); <line9> blobs.add(blob); <line10> } <line11> return blobs; <line12> } <line13> } <line14> "	"<line1>    log.debug(""Loading blobs from the file system: "" + blobInfos);"	task4	
public class A { <line0> @Override <line1> public void bytesMessage(InputStream in) { <line2> try { <line3> handleMessage(in.read(), in); <line4> } catch (IOException ex) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.error(""Error reading message channel"", ex);"	task4	
"public class A { <line0> public boolean saveMetadataFile(String metadataFileName, InputStream stream) { <line1> if (appConfiguration.getShibboleth3FederationRootDir() == null) { <line2> throw new InvalidConfigurationException( <line3> ""Failed to save meta-data file due to undefined federation root folder""); <line4> } <line5> String spMetadataFile = getIdpMetadataDir() + metadataFileName; <line6> try { <line7> return documentStoreService.saveDocumentStream(spMetadataFile, stream); <line8> } catch (Exception ex) { <line9> } finally { <line10> IOUtils.closeQuietly(stream); <line11> } <line12> return false; <line13> } <line14> } <line15> "	"<line9>      log.error(""Failed to write meta-data file '{}'"", spMetadataFile, ex);"	task4	
public class A { <line0> public static void safeCopyFile(File child, File destChild) throws IOException { <line1> forceMkdirs(destChild.getParentFile()); <line2> IOException ioException = null; <line3> while (true) { <line4> try { <line5> FileUtils.copyFile(child, destChild); <line6> return; <line7> } catch (IOException e) { <line8> if (ioException == null) { <line9> ioException = e; <line10> } else { <line11> ioException.addSuppressed(e); <line12> } <line13> if (ioException.getSuppressed().length >= MAX_COPY_ATTEMPTS) { <line14> return; <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	"<line14>          LOGGER.warn(""Unable to copy {} to {} after "" + MAX_COPY_ATTEMPTS + "" attempts; skipping file"",child,destChild,e);"	task4	
public class A { <line0> @Override <line1> public void resolveCollision( <line2> CompositeMap<IOption, Object> composite, <line3> Map<IOption, Object> existing, <line4> Map<IOption, Object> added, <line5> Collection<IOption> intersect) { <line6> } <line7> } <line8> 	"<line6>    LOGGER.debug(""resolveCollision: {}, {}, {}, {}"", composite, existing, added, intersect);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> createGUI(); <line4> } catch (Throwable t) { <line5> t.printStackTrace(); <line6> } <line7> } <line8> } <line9> 	"<line4>      LOGGER.info(""GUI created"");"	task4	
"public class A { <line0> void doIndexTestSqlTest( <line1> String dataSource, <line2> String indexTaskFilePath, <line3> String queryFilePath, <line4> Function<String, String> taskSpecTransform) <line5> throws IOException { <line6> final String fullDatasourceName = dataSource + config.getExtraDatasourceNameSuffix(); <line7> final String taskSpec = <line8> taskSpecTransform.apply( <line9> StringUtils.replace( <line10> getResourceAsString(indexTaskFilePath), ""%%DATASOURCE%%"", fullDatasourceName)); <line11> Pair<Boolean, Boolean> dummyPair = new Pair<>(false, false); <line12> submitTaskAndWait(taskSpec, fullDatasourceName, false, true, dummyPair); <line13> try { <line14> sqlQueryHelper.testQueriesFromFile(queryFilePath); <line15> } catch (Exception e) { <line16> throw new RuntimeException(e); <line17> } <line18> } <line19> } <line20> "	"<line16>      LOG.error(e, ""Error while testing"");"	task4	
public class A { <line0> @Override <line1> public void removeByKeyPrefix(String preFix) { <line2> List<ContextKey> removeKeys = getContextValueMapSet().findByKeyPrefix(preFix); <line3> if (CollectionUtils.isNotEmpty(removeKeys)) { <line4> for (ContextKey key : removeKeys) { <line5> remove(key); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.warn(""Remove keyValue by key preFix: "" + preFix);"	task4	
"public class A { <line0> private void initiateSort(String sortId, String source, final String destination) <line1> throws KeeperException, InterruptedException { <line2> String work = source + ""|"" + destination; <line3> new DistributedWorkQueue( <line4> manager.getZooKeeperRoot() + Constants.ZRECOVERY, manager.getConfiguration()) <line5> .addWork(sortId, work.getBytes(UTF_8)); <line6> synchronized (this) { <line7> sortsQueued.add(sortId); <line8> } <line9> final String path = manager.getZooKeeperRoot() + Constants.ZRECOVERY + ""/"" + sortId; <line10> } <line11> } <line12> "	"<line10>    log.info(""Created zookeeper entry {} with data {}"", path, work);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> while (!closed) { <line4> if (changesHaveOccurred()) { <line5> trigger(); <line6> } <line7> Thread.sleep(scanPeriod); <line8> } <line9> } catch (Throwable e) { <line10> close(); <line11> } <line12> } <line13> } <line14> 	"<line10>      LOGGER.error(""An error have been encountered while watching resources - leaving the redeploy mode"", e);"	task4	
public class A { <line0> public WebContentModuleConfig findByModuleId(final Long moduleId) { <line1> return webContentModuleConfigRepository.findByModuleId(moduleId); <line2> } <line3> } <line4> 	"<line1>    log.debug(""findByModuleId() - moduleId: {}"", moduleId);"	task4	
public class A { <line0> @Override <line1> public byte[] toBytes(Object object) { <line2> ByteArrayOutputStream baos; <line3> try { <line4> baos = new ByteArrayOutputStream(); <line5> ObjectOutputStream oos = new ObjectOutputStream(baos); <line6> oos.writeObject(object); <line7> oos.close(); <line8> return baos.toByteArray(); <line9> } catch (IOException e) { <line10> throw new PropertyAccessException(e); <line11> } <line12> } <line13> } <line14> 	"<line10>      log.error(""IO exception, Caused by {}."", e);"	task4	
public class A { <line0> @Override <line1> public void delete(final LogicalDatastoreType store, final YangInstanceIdentifier path) { <line2> checkOpen(); <line3> processTransactionOperation(facade -> facade.delete(store, path)); <line4> } <line5> } <line6> 	"<line3>    LOG.debug(""{}: Delete {} {}"", id, store, path);"	task4	
public class A { <line0> private void handleChannel(ChannelUID channelUID, Command command, Enigma2Client client) { <line1> if (command instanceof RefreshType) { <line2> client.refreshChannel(); <line3> updateState(channelUID, new StringType(client.getChannel())); <line4> } else if (command instanceof StringType) { <line5> client.setChannel(command.toString()); <line6> } else { <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.info(""Channel {} only accepts StringType, RefreshType. Type was {}."",channelUID,command.getClass());"	task4	
public class A { <line0> public static void run(final Scenario scenario) { <line1> List<String> activityTypes = AccessibilityUtils.collectAllFacilityOptionTypes(scenario); <line2> Controler controler = new Controler(scenario); <line3> for (final String actType : activityTypes) { <line4> final AccessibilityModule module = new AccessibilityModule(); <line5> module.setConsideredActivityType(actType); <line6> controler.addOverridingModule(module); <line7> } <line8> controler.run(); <line9> } <line10> } <line11> 	"<line2>    LOG.info(""The following activity types were found: "" + activityTypes);"	task4	
"public class A { <line0> @Test <line1> public void testTokenMerge() throws Exception { <line2> final Text service = new Text(""service""); <line3> Token<?> token = Mockito.mock(Token.class); <line4> JobConf jobConf = new JobConf(); <line5> Mockito.when(token.getService()).thenReturn(service); <line6> try { <line7> helper.mergeTokenIntoJobConf(jobConf, token); <line8> } catch (IOException e) { <line9> return; <line10> } <line11> Collection<Token<?>> tokens = jobConf.getCredentials().getAllTokens(); <line12> assertEquals(1, tokens.size()); <line13> assertEquals(service, tokens.iterator().next().getService()); <line14> } <line15> } <line16> "	"<line9>      log.info(""Ignoring exception, likely coming from Hadoop 1"", e);"	task4	
public class A { <line0> public void deleteDeviceLogItems(final List<DeviceLogItem> deviceLogItems) { <line1> final int size = deviceLogItems.size(); <line2> final List<Long> ids = <line3> deviceLogItems.stream().map(DeviceLogItem::getId).collect(Collectors.toList()); <line4> final int listSize = ids.size(); <line5> for (int pageNumber = 0; pageNumber < (listSize + PAGE_SIZE - 1) / PAGE_SIZE; pageNumber++) { <line6> final int fromIndex = pageNumber * PAGE_SIZE; <line7> final int toIndex = Math.min(listSize, pageNumber * PAGE_SIZE + PAGE_SIZE); <line8> final List<Long> sublistToDelete = ids.subList(fromIndex, toIndex); <line9> this.deviceLogItemSlicingRepository.deleteBatchById(sublistToDelete); <line10> } <line11> } <line12> } <line13> 	"<line11>    LOGGER.info(""{} device log items deleted."", size);"	task4	
public class A { <line0> @Override <line1> public void abortJob(JobContext jobContext, State state) throws IOException { <line2> try { <line3> if (dynamicPartitioningUsed) { <line4> discoverPartitions(jobContext); <line5> } <line6> org.apache.hadoop.mapred.JobContext mapRedJobContext = <line7> HCatMapRedUtil.createJobContext(jobContext); <line8> if (getBaseOutputCommitter() != null && !dynamicPartitioningUsed) { <line9> getBaseOutputCommitter().abortJob(mapRedJobContext, state); <line10> } else if (dynamicPartitioningUsed) { <line11> for (JobContext currContext : contextDiscoveredByPath.values()) { <line12> try { <line13> new JobConf(currContext.getConfiguration()) <line14> .getOutputCommitter() <line15> .abortJob(currContext, state); <line16> } catch (Exception e) { <line17> throw new IOException(e); <line18> } <line19> } <line20> } <line21> Path src; <line22> OutputJobInfo jobInfo = HCatOutputFormat.getJobInfo(jobContext.getConfiguration()); <line23> Path tblPath = new Path(jobInfo.getTableInfo().getTableLocation()); <line24> if (dynamicPartitioningUsed) { <line25> if (!customDynamicLocationUsed) { <line26> src = <line27> new Path( <line28> getPartitionRootLocation( <line29> jobInfo.getLocation(), <line30> jobInfo.getTableInfo().getTable().getPartitionKeysSize())); <line31> } else { <line32> src = new Path(getCustomPartitionRootLocation(jobInfo, jobContext.getConfiguration())); <line33> } <line34> } else { <line35> src = new Path(jobInfo.getLocation()); <line36> } <line37> FileSystem fs = src.getFileSystem(jobContext.getConfiguration()); <line38> if (!src.equals(tblPath)) { <line39> fs.delete(src, true); <line40> } <line41> } finally { <line42> cancelDelegationTokens(jobContext); <line43> } <line44> } <line45> } <line46> 	"<line38>      LOG.info(""Job failed. Try cleaning up temporary directory [{}]."", src);"	task4	
"public class A { <line0> private void removePartition(short partition) { <line1> Partition p = partitionMap.remove(partition); <line2> if (null != p) { <line3> File partitionBase = new File(base, ""index"" + File.separator + partition); <line4> if (!partitionBase.renameTo( <line5> new File( <line6> partitionBase.getParent(), partitionBase.getName() + "".d."" + SystemClock.now()))) { <line7> } <line8> } <line9> } <line10> } <line11> "	"<line7>        logger.warn(""Rename directory {} failed!"", partitionBase.getAbsolutePath());"	task4	
public class A { <line0> protected void onLinkDeletePost( <line1> final String networkId, final Link link, final HashMap<String, Response> respList) { <line2> } <line3> } <line4> 	"<line2>    log.debug("""");"	task4	
"public class A { <line0> @ApiOperation( <line1> httpMethod = ""GET"", <line2> value = ""API to get target types details by name"", <line3> response = Response.class, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> @RequestMapping( <line6> path = ""/list-by-target-type-name"", <line7> method = RequestMethod.GET, <line8> produces = MediaType.APPLICATION_JSON_VALUE) <line9> public ResponseEntity<Object> getTargetTypesByName( <line10> @ApiParam(value = ""provide valid target type name"", required = true) <line11> @RequestParam(defaultValue = """", name = ""targetTypeName"", required = true) <line12> String targetTypeName) { <line13> try { <line14> return ResponseUtils.buildSucessResponse( <line15> targetTypesService.getTargetTypesByName(targetTypeName)); <line16> } catch (Exception exception) { <line17> return ResponseUtils.buildFailureResponse( <line18> new Exception(UNEXPECTED_ERROR_OCCURRED), exception.getMessage()); <line19> } <line20> } <line21> } <line22> "	<line17>      log.error(UNEXPECTED_ERROR_OCCURRED, exception);	task4	
"public class A { <line0> public SpecT configure(Map<?, ?> val) { <line1> for (Map.Entry<?, ?> entry : val.entrySet()) { <line2> if (entry.getKey() == null) throw new NullPointerException(""Null key not permitted""); <line3> if (entry.getKey() instanceof CharSequence) <line4> flags.put(entry.getKey().toString(), entry.getValue()); <line5> else if (entry.getKey() instanceof ConfigKey<?>) <line6> config.put((ConfigKey<?>) entry.getKey(), entry.getValue()); <line7> else if (entry.getKey() instanceof HasConfigKey<?>) <line8> config.put(((HasConfigKey<?>) entry.getKey()).getConfigKey(), entry.getValue()); <line9> else { <line10> } <line11> } <line12> return self(); <line13> } <line14> } <line15> "	"<line10>        log.warn(""Spec "" + this + "" ignoring unknown config key "" + entry.getKey());"	task4	
"public class A { <line0> public static com.liferay.wiki.model.WikiPage updatePage( <line1> HttpPrincipal httpPrincipal, <line2> long nodeId, <line3> String title, <line4> double version, <line5> String content, <line6> String summary, <line7> boolean minorEdit, <line8> String format, <line9> String parentTitle, <line10> String redirectTitle, <line11> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line12> throws com.liferay.portal.kernel.exception.PortalException { <line13> try { <line14> MethodKey methodKey = <line15> new MethodKey(WikiPageServiceUtil.class, ""updatePage"", _updatePageParameterTypes47); <line16> MethodHandler methodHandler = <line17> new MethodHandler( <line18> methodKey, <line19> nodeId, <line20> title, <line21> version, <line22> content, <line23> summary, <line24> minorEdit, <line25> format, <line26> parentTitle, <line27> redirectTitle, <line28> serviceContext); <line29> Object returnObj = null; <line30> try { <line31> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line32> } catch (Exception exception) { <line33> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line34> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line35> } <line36> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line37> } <line38> return (com.liferay.wiki.model.WikiPage) returnObj; <line39> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line40> throw systemException; <line41> } <line42> } <line43> } <line44> "	<line40>      log.error(systemException, systemException);	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.AddressSoap getAddress(long addressId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Address returnValue = <line4> AddressServiceUtil.getAddress(addressId); <line5> return com.liferay.portal.kernel.model.AddressSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> public boolean registerRqHandler( <line1> String pathSpec, <line2> Class<? extends SvBusMessage> rqMapping, <line3> Class<? extends SvBusMessage> respMapping, <line4> SvRequestHandler handler) { <line5> boolean res = false; <line6> PathSpecification spec = PathSpecification.fromSpecString(pathSpec); <line7> if (findHandler(spec.prefix) != null) { <line8> } else { <line9> res = true; <line10> HandlerRecord hrec = new HandlerRecord(); <line11> hrec.pathSpec = pathSpec; <line12> hrec.handler = handler; <line13> hrec.rqMapping = mapper.constructType(rqMapping); <line14> hrec.respMapping = mapper.constructType(respMapping); <line15> rqHandlers.putIfAbsent(spec, hrec); <line16> } <line17> return res; <line18> } <line19> } <line20> 	"<line8>      log.error(""Request handler for path specification with prefix {} is already registered"",spec.prefix);"	task4	
public class A { <line0> @Override <line1> public void after(Object target, Object[] args, Object result, Throwable throwable) { <line2> final InterceptorScopeInvocation transaction = scope.getCurrentInvocation(); <line3> if (transaction.canLeave(policy)) { <line4> interceptor.after(target, args, result, throwable); <line5> transaction.leave(policy); <line6> } else { <line7> if (debugEnabled) { <line8> } <line9> } <line10> } <line11> } <line12> 	"<line8>        logger.debug(""tryAfter() returns false: interceptorScopeTransaction: {}, executionPoint: {}. Skip""+ "" interceptor {}"",transaction,policy,interceptor.getClass());"	task4	
"public class A { <line0> @Test <line1> public void testJournalRolling() throws Exception { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> LedgerHandle[] lhs = writeLedgerEntries(4, 1024, 1024); <line5> long[] ledgerIds = new long[lhs.length]; <line6> for (int i = 0; i < lhs.length; i++) { <line7> ledgerIds[i] = lhs[i].getId(); <line8> } <line9> checkpointBookies(); <line10> for (File journalDir : tmpDirs) { <line11> File[] journals = journalDir.listFiles(); <line12> int numJournals = 0; <line13> for (File f : journals) { <line14> if (!f.getName().endsWith("".txn"")) { <line15> continue; <line16> } <line17> ++numJournals; <line18> } <line19> assertTrue(numJournals <= 2); <line20> } <line21> restartBookies(); <line22> validLedgerEntries(ledgerIds, 1024, 1024); <line23> } <line24> } <line25> "	"<line3>      LOG.debug(""Testing Journal Rolling"");"	task4	
public class A { <line0> public static void sendApplicationInstanceActivatedEvent(String appId, String instanceId) { <line1> if (log.isInfoEnabled()) { <line2> } <line3> ApplicationInstanceActivatedEvent applicationActivatedEvent = <line4> new ApplicationInstanceActivatedEvent(appId, instanceId); <line5> publishEvent(applicationActivatedEvent); <line6> } <line7> } <line8> 	"<line2>      log.info(""Publishing application instance active event: [application] ""+ appId+ "" [instance] ""+ instanceId);"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.LayoutSetPrototype fetchLayoutSetPrototype( <line1> HttpPrincipal httpPrincipal, long layoutSetPrototypeId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> LayoutSetPrototypeServiceUtil.class, <line7> ""fetchLayoutSetPrototype"", <line8> _fetchLayoutSetPrototypeParameterTypes5); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, layoutSetPrototypeId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.portal.kernel.model.LayoutSetPrototype) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> protected void processEmptyMessage() throws Exception { <line2> Exchange exchange = getEndpoint().createExchange(); <line3> exchange.setProperty(ExchangePropertyKey.BATCH_INDEX, 0); <line4> exchange.setProperty(ExchangePropertyKey.BATCH_SIZE, 1); <line5> exchange.setProperty(ExchangePropertyKey.BATCH_COMPLETE, true); <line6> getProcessor().process(exchange); <line7> } <line8> } <line9> 	"<line6>    LOG.debug(""Sending empty message as there were no messages from polling: {}"", this.getEndpoint());"	task4	
"public class A { <line0> @BeforeClass <line1> public static void setup() throws Exception { <line2> try { <line3> Configuration conf = new Configuration(); <line4> conf.setBoolean(""mapred.mapper.new-api"", true); <line5> conf.setBoolean(AngelConf.ANGEL_JOB_OUTPUT_PATH_DELETEONEXIST, true); <line6> conf.set(AngelConf.ANGEL_TASK_USER_TASKCLASS, DummyTask.class.getName()); <line7> conf.set(AngelConf.ANGEL_DEPLOY_MODE, ""LOCAL""); <line8> conf.setBoolean(AngelConf.ANGEL_AM_USE_DUMMY_DATASPLITER, true); <line9> conf.set(AngelConf.ANGEL_INPUTFORMAT_CLASS, CombineTextInputFormat.class.getName()); <line10> conf.set(AngelConf.ANGEL_SAVE_MODEL_PATH, LOCAL_FS + TMP_PATH + ""/out""); <line11> conf.set(AngelConf.ANGEL_TRAIN_DATA_PATH, LOCAL_FS + TMP_PATH + ""/in""); <line12> conf.set(AngelConf.ANGEL_LOG_PATH, LOCAL_FS + TMP_PATH + ""/log""); <line13> conf.setInt(AngelConf.ANGEL_WORKERGROUP_NUMBER, 1); <line14> conf.setInt(AngelConf.ANGEL_PS_NUMBER, 1); <line15> conf.setInt(AngelConf.ANGEL_WORKER_TASK_NUMBER, 2); <line16> conf.setInt(AngelConf.ANGEL_WORKER_HEARTBEAT_INTERVAL_MS, 1000); <line17> conf.setInt(AngelConf.ANGEL_PS_HEARTBEAT_INTERVAL_MS, 1000); <line18> angelClient = AngelClientFactory.get(conf); <line19> MatrixContext mMatrix = new MatrixContext(); <line20> mMatrix.setName(""w1""); <line21> mMatrix.setRowNum(1); <line22> mMatrix.setColNum(100000); <line23> mMatrix.setMaxRowNumInBlock(1); <line24> mMatrix.setMaxColNumInBlock(50000); <line25> mMatrix.setRowType(RowType.T_INT_DENSE); <line26> mMatrix.set(MatrixConf.MATRIX_OPLOG_ENABLEFILTER, ""false""); <line27> mMatrix.set(MatrixConf.MATRIX_HOGWILD, ""true""); <line28> mMatrix.set(MatrixConf.MATRIX_AVERAGE, ""false""); <line29> mMatrix.set(MatrixConf.MATRIX_OPLOG_TYPE, ""DENSE_INT""); <line30> angelClient.addMatrix(mMatrix); <line31> MatrixContext mMatrix2 = new MatrixContext(); <line32> mMatrix2.setName(""w2""); <line33> mMatrix2.setRowNum(1); <line34> mMatrix2.setColNum(100000); <line35> mMatrix2.setMaxRowNumInBlock(1); <line36> mMatrix2.setMaxColNumInBlock(50000); <line37> mMatrix2.setRowType(RowType.T_DOUBLE_DENSE); <line38> mMatrix2.set(MatrixConf.MATRIX_OPLOG_ENABLEFILTER, ""false""); <line39> mMatrix2.set(MatrixConf.MATRIX_HOGWILD, ""false""); <line40> mMatrix2.set(MatrixConf.MATRIX_AVERAGE, ""false""); <line41> mMatrix2.set(MatrixConf.MATRIX_OPLOG_TYPE, ""DENSE_DOUBLE""); <line42> angelClient.addMatrix(mMatrix2); <line43> angelClient.startPSServer(); <line44> angelClient.run(); <line45> Thread.sleep(5000); <line46> group0Id = new WorkerGroupId(0); <line47> worker0Id = new WorkerId(group0Id, 0); <line48> worker0Attempt0Id = new WorkerAttemptId(worker0Id, 0); <line49> task0Id = new TaskId(0); <line50> task1Id = new TaskId(1); <line51> } catch (Exception x) { <line52> throw x; <line53> } <line54> } <line55> } <line56> "	"<line52>      LOG.error(""setup failed "", x);"	task4	
public class A { <line0> @Override <line1> protected String getSEQWARE_PASSWORD() { <line2> if (settings.containsKey(SqwKeys.EXTENDED_TEST_DB_PASSWORD.getSettingKey())) { <line3> return settings.get(SqwKeys.EXTENDED_TEST_DB_PASSWORD.getSettingKey()); <line4> } <line5> return super.getSEQWARE_PASSWORD(); <line6> } <line7> } <line8> 	"<line5>    Log.debug(""Could not retrieve extended test db password, using default from unit tests"");"	task4	
"public class A { <line0> public Object transform(Object body) { <line1> if (verbose) { <line2> System.out.println("">>>> "" + value); <line3> } <line4> return new StringSource(value); <line5> } <line6> } <line7> "	"<line4>    LOG.info("">>>> "" + value);"	task4	
public class A { <line0> @Override <line1> protected String transform(String value) { <line2> String result = PREFIX + URLEncoder.encode(value, StandardCharsets.UTF_8); <line3> return result; <line4> } <line5> } <line6> 	"<line3>    LOG.debug(""{} -> {}"", value, result);"	task4	
"public class A { <line0> @Override <line1> public String getGID(URL url) throws MalformedURLException { <line2> try { <line3> return Utils.filesystemSafe(new URI(getTerm(url).replaceAll(""&tags="", """")).getPath()); <line4> } catch (URISyntaxException ex) { <line5> } <line6> throw new MalformedURLException( <line7> ""Expected xbooru.com URL format: "" <line8> + getHost() <line9> + "".com/index.php?tags=searchterm - got "" <line10> + url <line11> + "" instead""); <line12> } <line13> } <line14> "	<line5>      logger.error(ex);	task4	
public class A { <line0> protected void closeStream(FileInputStream fis, InputStreamReader ir, BufferedReader br) { <line1> try { <line2> if (fis != null) { <line3> fis.close(); <line4> } <line5> if (ir != null) { <line6> ir.close(); <line7> } <line8> if (br != null) { <line9> br.close(); <line10> } <line11> } catch (IOException continued) { <line12> } <line13> } <line14> } <line15> 	"<line12>      log.warn(""File-close threw the exception: "", continued);"	task4	
"public class A { <line0> @Override <line1> public synchronized int read(ByteBuffer dst) throws IOException { <line2> if (!dst.hasRemaining()) { <line3> return 0; <line4> } <line5> if (peerAppData.hasRemaining()) { <line6> peerAppData.flip(); <line7> return ByteBufferUtils.transferByteBuffer(peerAppData, dst); <line8> } <line9> peerNetData.compact(); <line10> int bytesRead = socketChannel.read(peerNetData); <line11> if (bytesRead > 0 || peerNetData.hasRemaining()) { <line12> peerNetData.flip(); <line13> while (peerNetData.hasRemaining()) { <line14> peerAppData.compact(); <line15> SSLEngineResult result; <line16> try { <line17> result = engine.unwrap(peerNetData, peerAppData); <line18> } catch (SSLException e) { <line19> throw e; <line20> } <line21> switch (result.getStatus()) { <line22> case OK: <line23> peerAppData.flip(); <line24> return ByteBufferUtils.transferByteBuffer(peerAppData, dst); <line25> case BUFFER_UNDERFLOW: <line26> peerAppData.flip(); <line27> return ByteBufferUtils.transferByteBuffer(peerAppData, dst); <line28> case BUFFER_OVERFLOW: <line29> peerAppData = enlargeApplicationBuffer(peerAppData); <line30> return read(dst); <line31> case CLOSED: <line32> closeConnection(); <line33> dst.clear(); <line34> return -1; <line35> default: <line36> throw new IllegalStateException(""Invalid SSL status: "" + result.getStatus()); <line37> } <line38> } <line39> } else if (bytesRead < 0) { <line40> handleEndOfStream(); <line41> } <line42> ByteBufferUtils.transferByteBuffer(peerAppData, dst); <line43> return bytesRead; <line44> } <line45> } <line46> "	"<line19>          log.error(""SSLException during unwrap"", e);"	task4	
public class A { <line0> @Override <line1> public MessageSet move( <line2> UserDataRequest udr, MailboxPath srcFolder, MailboxPath dstFolder, MessageSet messages) <line3> throws DaoException, MailException, ImapMessageNotFoundException, <line4> UnsupportedBackendFunctionException { <line5> try { <line6> StoreClient store = imapClientProvider.getImapClient(udr); <line7> assertMoveItemIsSupported(store); <line8> store.select(srcFolder.getPath()); <line9> MessageSet newUids = store.uidCopy(messages, dstFolder.getPath()); <line10> deleteMessage(store, messages); <line11> return newUids; <line12> } catch (IMAPException e) { <line13> throw new MailException(e); <line14> } catch (MailboxNotFoundException e) { <line15> throw new CollectionNotFoundException(e); <line16> } catch (ImapTimeoutException e) { <line17> throw new TimeoutException(e); <line18> } <line19> } <line20> } <line21> 	"<line8>      logger.debug(""Moving email, USER:{} UIDs:{} SRC:{} DST:{}"",udr.getUser().getLoginAtDomain(),messages,srcFolder,dstFolder);"	task4	
public class A { <line0> @Override <line1> public void doFilter(ServletRequest serv, ServletResponse resp, FilterChain chain) <line2> throws IOException, ServletException { <line3> try { <line4> HttpServletRequest request = (HttpServletRequest) serv; <line5> SessionBean session = getSession(request); <line6> if (session != null && session.getUser() == null) { <line7> HttpAuthentication httpAuthentification = new HttpAuthentication(request); <line8> if (httpAuthentification.hasLoginInfos()) { <line9> session.setUser(httpAuthentification.doLogin()); <line10> } <line11> } else if (session != null && session.getUser() != null) { <line12> if (isReloadUser(request, session.getUser())) { <line13> session.reloadUser(); <line14> } <line15> } <line16> } catch (Exception e) { <line17> } finally { <line18> chain.doFilter(serv, resp); <line19> } <line20> } <line21> } <line22> 	"<line17>      LOGGER.info(""We had some exception in Authentication filter"", e);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public I save(E e) { <line3> try { <line4> Session session = getCurrentSession(); <line5> I id = (I) session.save(e); <line6> session.flush(); <line7> session.evict(e); <line8> return id; <line9> } catch (Exception ex) { <line10> throw new HibernateException(""Save failed""); <line11> } <line12> } <line13> } <line14> "	"<line10>      logger.error(""Save failed"", ex);"	task4	
public class A { <line0> public DataToSign buildDataToSign() <line1> throws SignerCertificateRequiredException, DataFileMissingException { <line2> if (signatureParameters.getSigningCertificate() == null) { <line3> throw new SignerCertificateRequiredException(); <line4> } <line5> SignatureFinalizer signatureFinalizer = getSignatureFinalizer(); <line6> byte[] dataToBeSigned = signatureFinalizer.getDataToBeSigned(); <line7> return new DataToSign(dataToBeSigned, signatureFinalizer); <line8> } <line9> } <line10> 	"<line3>      logger.error(""Cannot invoke signing without signing certificate. Add 'withSigningCertificate()' method""+ "" call or call 'withSignatureToken() instead.'"");"	task4	
"public class A { <line0> @Override <line1> public BaseResult saveAttributes( <line2> String organizationId, List<ServiceAttribute> attributeValues, User requestingUser) { <line3> try { <line4> Query q = em.createNamedQuery(""CustomAttribute.deleteForOrg""); <line5> q.setParameter(""oid"", organizationId); <line6> q.executeUpdate(); <line7> CustomAttribute ca; <line8> for (ServiceAttribute attr : attributeValues) { <line9> ca = new CustomAttribute(); <line10> ca.setOrganizationId(organizationId); <line11> ca.setAttributeKey(attr.getAttributeId()); <line12> ca.setEncrypted(attr.isEncrypted()); <line13> ca.setDecryptedValue(attr.getValue()); <line14> ca.setControllerId(attr.getControllerId()); <line15> em.persist(ca); <line16> } <line17> return provResult.newOkBaseResult(); <line18> } catch (Exception e) { <line19> return provResult.getErrorResult(BaseResult.class, e, getLocale(requestingUser), null, null); <line20> } <line21> } <line22> } <line23> "	<line19>      logger.warn(e.getMessage(), e);	task4	
public class A { <line0> public Session getCurrentSession(EntityManager em) { <line1> try { <line2> return em.unwrap(Session.class); <line3> } catch (Exception e) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line4>      logger.error(""Error in getCurrentSession()"", e);"	task4	
"public class A { <line0> public static com.liferay.commerce.model.CommerceAddress updateCommerceAddress( <line1> HttpPrincipal httpPrincipal, <line2> long commerceAddressId, <line3> String name, <line4> String description, <line5> String street1, <line6> String street2, <line7> String street3, <line8> String city, <line9> String zip, <line10> long regionId, <line11> long countryId, <line12> String phoneNumber, <line13> boolean defaultBilling, <line14> boolean defaultShipping, <line15> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line16> throws com.liferay.portal.kernel.exception.PortalException { <line17> try { <line18> MethodKey methodKey = <line19> new MethodKey( <line20> CommerceAddressServiceUtil.class, <line21> ""updateCommerceAddress"", <line22> _updateCommerceAddressParameterTypes23); <line23> MethodHandler methodHandler = <line24> new MethodHandler( <line25> methodKey, <line26> commerceAddressId, <line27> name, <line28> description, <line29> street1, <line30> street2, <line31> street3, <line32> city, <line33> zip, <line34> regionId, <line35> countryId, <line36> phoneNumber, <line37> defaultBilling, <line38> defaultShipping, <line39> serviceContext); <line40> Object returnObj = null; <line41> try { <line42> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line43> } catch (Exception exception) { <line44> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line45> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line46> } <line47> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line48> } <line49> return (com.liferay.commerce.model.CommerceAddress) returnObj; <line50> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line51> throw systemException; <line52> } <line53> } <line54> } <line55> "	<line51>      log.error(systemException, systemException);	task4	
public class A { <line0> ActionResult<Wo> execute(EffectivePerson effectivePerson, ServletContext servletContext) <line1> throws Exception { <line2> ActionResult<Wo> result = new ActionResult<>(); <line3> com.x.base.core.project.Context ctx = <line4> (com.x.base.core.project.Context) <line5> servletContext.getAttribute(com.x.base.core.project.AbstractContext.class.getName()); <line6> LoggerFactory.setLevelDebug(); <line7> result.setData(new Wo(true)); <line8> return result; <line9> } <line10> } <line11> 	"<line6>    logger.info(""{} change logger level to DEBUG."", ctx.clazz().getName());"	task4	
public class A { <line0> @Override <line1> public void replaceAtomContainer(int position, IAtomContainer container) { <line2> super.replaceAtomContainer(position, container); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Replacing atom container at pos: "", position);"	task4	
"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> @Override <line2> public void prepare(Map conf, TopologyContext context, OutputCollector collector) { <line3> super.prepare(conf, context, collector); <line4> _collector = collector; <line5> try { <line6> connection = SolrConnection.getConnection(conf, BOLT_TYPE); <line7> } catch (Exception e) { <line8> throw new RuntimeException(e); <line9> } <line10> this.eventCounter = context.registerMetric(""SolrIndexerBolt"", new MultiCountMetric(), 10); <line11> } <line12> } <line13> "	"<line8>      LOG.error(""Can't connect to Solr: {}"", e);"	task4	
public class A { <line0> private void setSensor(int mode) { <line1> if (streamingSensor != null) { <line2> try { <line3> streamingSensor.setState(mode); <line4> } catch (jmri.JmriException ex) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        log.error(""Exception while setting ISSOUNDSTREAMING sensor {} to {}"",streamingSensor.getDisplayName(),mode);"	task4	
public class A { <line0> @Override <line1> public List<CubeAssignment> getAllCubeAssignments() { <line2> try { <line3> List<CubeAssignment> cubeAssignmentList = Lists.newArrayList(); <line4> List<String> cubes = client.getChildren().forPath(cubeRoot); <line5> for (String cube : cubes) { <line6> String cubeAssignmentPath = getCubeAssignmentPath(cube); <line7> if (client.checkExists().forPath(cubeAssignmentPath) != null) { <line8> byte[] data = client.getData().forPath(cubeAssignmentPath); <line9> CubeAssignment assignment = CubeAssignment.deserializeCubeAssignment(data); <line10> cubeAssignmentList.add(assignment); <line11> } <line12> } <line13> readSuccess.getAndIncrement(); <line14> return cubeAssignmentList; <line15> } catch (Exception e) { <line16> readFail.getAndIncrement(); <line17> throw new StoreException(e); <line18> } <line19> } <line20> } <line21> 	"<line17>      logger.error(""Error when get assignments"", e);"	task4	
public class A { <line0> private void setTempParam(AbstractDevice device) { <line1> NumericValueParam valueParam = <line2> (NumericValueParam) device.getParams().get(ParamType.TEMPERATURE_VALUE); <line3> if (valueParam == null) { <line4> return; <line5> } <line6> NumericValueParam tempParam = <line7> new NumericValueParam(ParamType.TEMPERATURE_DUAL, valueParam.getUnit(), null); <line8> tempParam.setValue(valueParam.getValue()); <line9> addParam(tempParam); <line10> } <line11> } <line12> 	"<line4>      logger.warn(""Linked Temperature device has no Value parameter: {}"", device);"	task4	
public class A { <line0> @Override <line1> public void debug(String msg) { <line2> for (Logger logger : this.loggers) { <line3> } <line4> } <line5> } <line6> 	<line3>      logger.debug(msg);	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected void onUpdated() { <line2> try { <line3> Object v = computing.apply(producer.getAttribute(sourceSensor)); <line4> if (v == null && Boolean.TRUE.equals(removingIfResultIsNull)) { <line5> v = Entities.REMOVE; <line6> } <line7> if (v == Entities.UNCHANGED) { <line8> } else { <line9> TKey key = this.key; <line10> if (key == null) key = (TKey) sourceSensor.getName(); <line11> ServiceStateLogic.updateMapSensorEntry(entity, targetSensor, key, (TVal) v); <line12> } <line13> } catch (Throwable t) { <line14> throw Exceptions.propagate(t); <line15> } <line16> } <line17> } <line18> "	"<line14>      LOG.warn(""Error calculating map update for enricher "" + this, t);"	task4	
"public class A { <line0> @Override <line1> public boolean canHandle(ActionParameter actionParameter) { <line2> if (actionParameter.getExpression() == null) { <line3> return false; <line4> } <line5> final RhinoSandbox sandbox = RhinoSandboxes.create(); <line6> try { <line7> String varName = actionParameter.getColumn(); <line8> if (actionParameter.getInputData() == null) { <line9> return false; <line10> } else { <line11> if (actionParameter.getInputData() instanceof Number) { <line12> return (Boolean) <line13> sandbox.eval( <line14> null, <line15> actionParameter.getInputData().toString() + actionParameter.getExpression()); <line16> } else if (actionParameter.getInputData() instanceof Date) { <line17> varName = actionParameter.getColumn() + ""Date""; <line18> } else { <line19> varName = actionParameter.getColumn() + ""String""; <line20> } <line21> Map<String, Object> values = new HashMap<String, Object>(); <line22> values.put(varName, actionParameter.getInputData()); <line23> return (Boolean) sandbox.eval(null, """" + varName + actionParameter.getExpression(), values); <line24> } <line25> } catch (EcmaError e) { <line26> } <line27> return false; <line28> } <line29> } <line30> "	<line26>      LOGGER.error(e.getMessage(), e);	task4	
public class A { <line0> private void deleteFileFromFileStore(FileMeta fileMeta) { <line1> try { <line2> fileStore.delete(fileMeta.getId()); <line3> } catch (UncheckedIOException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.warn(""Could not delete file '{}' from file store"", fileMeta.getId());"	task4	
public class A { <line0> public void debug(String arg0, Object arg1, Object arg2) { <line1> } <line2> } <line3> 	<line1>    log.debug(format(arg0, arg1, arg2));	task4	
public class A { <line0> public void setLastName(String value) { <line1> if (_Employee.LOG.isDebugEnabled()) { <line2> } <line3> takeStoredValueForKey(value, _Employee.LAST_NAME_KEY); <line4> } <line5> } <line6> 	"<line2>      _Employee.LOG.debug(""updating lastName from "" + lastName() + "" to "" + value);"	task4	
public class A { <line0> private boolean testForDuplicateSize( <line1> SearchResultItem result1, SearchResultItem result2, float duplicateSizeDifference) { <line2> if (result1.getSize() == null || result2.getSize() == null) { <line3> return false; <line4> } <line5> long sizeDifference = Math.abs(result1.getSize() - result2.getSize()); <line6> float sizeAverage = (result1.getSize() + result2.getSize()) / 2F; <line7> float sizeDiffPercent = Math.abs(sizeDifference / sizeAverage) * 100; <line8> boolean sameSize = sizeDiffPercent <= duplicateSizeDifference; <line9> return sameSize; <line10> } <line11> } <line12> 	"<line9>    logger.debug(LoggingMarkers.DUPLICATES, ""Same size: {}"", sameSize);"	task4	
"public class A { <line0> @Override <line1> public void testConnection(Connection conn) throws SQLException { <line2> Statement testStatement = null; <line3> try { <line4> testStatement = conn.createStatement(); <line5> testStatement.execute(""SELECT 1 FROM DUAL""); <line6> } finally { <line7> if (testStatement != null) { <line8> try { <line9> testStatement.close(); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> } <line15> } <line16> "	"<line11>          LOG.error(""Failed to close the connection"", e);"	task4	
public class A { <line0> @Override <line1> public Iterator<Container> iterator() { <line2> return new Iterator<Container>() { <line3> @Override <line4> public boolean hasNext() { <line5> return pathIterator.hasNext(); <line6> } <line7>  <line8> @Override <line9> public Container next() { <line10> Path next = pathIterator.next(); <line11> Container ret; <line12> try { <line13> ret = convertPathToContainer(basePath, next); <line14> } catch (NoSuchElementException | GenericException | RequestNotValidException e) { <line15> ret = null; <line16> } <line17> return ret; <line18> } <line19> }; <line20> } <line21> } <line22> 	"<line15>          LOGGER.error(""Error while listing containers, while parsing resource "" + next, e);"	task4	
"public class A { <line0> @GET <line1> @Produces(""text/html"") <line2> @Path(value = ""start/{pkgId}"") <line3> public Object startInstall( <line4> @PathParam(""pkgId"") String pkgId, @QueryParam(""source"") String source) { <line5> try { <line6> PackageUpdateService pus = Framework.getLocalService(PackageUpdateService.class); <line7> pus.removePackage(pkgId); <line8> return getView(""removeDone"").arg(""pkgId"", pkgId).arg(""source"", source); <line9> } catch (Exception e) { <line10> return getView(""removeError"").arg(""e"", e); <line11> } <line12> } <line13> } <line14> "	"<line10>      log.error(""Error during first step of installation"", e);"	task4	
"public class A { <line0> @Override <line1> public void registerExtension(Extension extension) throws Exception { <line2> ExtensionPoint xp = ri.getExtensionPoint(extension.getExtensionPoint()); <line3> if (xp != null) { <line4> String superCo = xp.getSuperComponent(); <line5> if (superCo != null) { <line6> ((ExtensionImpl) extension).target = new ComponentName(superCo); <line7> ri.manager.registerExtension(extension); <line8> return; <line9> } <line10> } else { <line11> Framework.handleDevError(null); <line12> } <line13> if (instance instanceof Component) { <line14> ((Component) instance).registerExtension(extension); <line15> } else { <line16> try { <line17> Method meth = instance.getClass().getDeclaredMethod(""registerExtension"", Extension.class); <line18> meth.setAccessible(true); <line19> meth.invoke(instance, extension); <line20> } catch (Exception e) { <line21> Framework.handleDevError(e); <line22> } <line23> } <line24> } <line25> } <line26> "	"<line11>      log.error(""Warning: target extension point '""+ extension.getExtensionPoint()+ ""' of '""+ extension.getTargetComponent().getName()+ ""' is unknown. Check your extension in component ""+ extension.getComponent().getName());"	task4	
"public class A { <line0> @Override <line1> public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) <line2> throws IOException, ServletException { <line3> String sourceHost = ((HttpServletRequest) request).getHeader(""Origin""); <line4> String origin = """"; <line5> try { <line6> if (SecurityUtils.isValidOrigin(sourceHost, ZeppelinConfiguration.create())) { <line7> origin = sourceHost; <line8> } <line9> } catch (URISyntaxException e) { <line10> } <line11> if (((HttpServletRequest) request).getMethod().equals(""OPTIONS"")) { <line12> HttpServletResponse resp = ((HttpServletResponse) response); <line13> addCorsHeaders(resp, origin); <line14> return; <line15> } <line16> if (response instanceof HttpServletResponse) { <line17> HttpServletResponse alteredResponse = ((HttpServletResponse) response); <line18> addCorsHeaders(alteredResponse, origin); <line19> } <line20> filterChain.doFilter(request, response); <line21> } <line22> } <line23> "	"<line10>      LOGGER.error(""Exception in WebDriverManager while getWebDriver "", e);"	task4	
"public class A { <line0> private void loadCertFromData() throws CertificateException { <line1> X509Certificate cert = null; <line2> CertContainer container = null; <line3> Key key = null; <line4> try { <line5> validate(); <line6> try { <line7> container = toCredential(); <line8> cert = container.getCert(); <line9> key = container.getKey(); <line10> } catch (CertificateException e) { <line11> } <line12> if (cert == null) { <line13> setThumbprint(""""); <line14> } else { <line15> setThumbprint(Thumbprint.toThumbprint(cert).toString()); <line16> setPrivateKey(key != null); <line17> } <line18> } catch (Exception e) { <line19> setData(NULL_CERT); <line20> throw new CertificateException( <line21> ""Data cannot be converted to a valid X.509 Certificate or IPKIX URL"", e); <line22> } <line23> } <line24> } <line25> "	"<line11>        LOG.warn(""Cert Container conversion failed: "" + e.getLocalizedMessage(), e);"	task4	
public class A { <line0> @Override <line1> protected void incrByte() { <line2> try { <line3> readByteOffset++; <line4> offset++; <line5> if (readByteOffset == size) { <line6> readByteOffset = 0; <line7> readFully(channel, buf, offset); <line8> } <line9> byteRead = inBuffer[readByteOffset]; <line10> } catch (IOException ioe) { <line11> } <line12> } <line13> } <line14> 	"<line11>      logger.error(""Input/Output exception while reading from a random access file. Stack trace follows"",ioe);"	task4	
public class A { <line0> private boolean cpeIdentifiersMatch(Dependency dependency1, Dependency dependency2) { <line1> if (dependency1 == null <line2> || dependency1.getVulnerableSoftwareIdentifiers() == null <line3> || dependency2 == null <line4> || dependency2.getVulnerableSoftwareIdentifiers() == null) { <line5> return false; <line6> } <line7> boolean matches = false; <line8> final int cpeCount1 = dependency1.getVulnerableSoftwareIdentifiers().size(); <line9> final int cpeCount2 = dependency2.getVulnerableSoftwareIdentifiers().size(); <line10> if (cpeCount1 > 0 && cpeCount1 == cpeCount2) { <line11> for (Identifier i : dependency1.getVulnerableSoftwareIdentifiers()) { <line12> matches |= dependency2.getVulnerableSoftwareIdentifiers().contains(i); <line13> if (!matches) { <line14> break; <line15> } <line16> } <line17> } <line18> return matches; <line19> } <line20> } <line21> 	"<line18>    LOGGER.debug(""IdentifiersMatch={} ({}, {})"",matches,dependency1.getFileName(),dependency2.getFileName());"	task4	
"public class A { <line0> <T extends BrokerPoolService> T register(final T brokerPoolService) { <line1> final ManagerState currentState = states.getCurrentState(); <line2> if (currentState != ManagerState.REGISTRATION) { <line3> throw new IllegalStateException( <line4> ""Services may only be registered during the registration state. Current state is: "" <line5> + currentState.name()); <line6> } <line7> brokerPoolServices.add(brokerPoolService); <line8> if (LOG.isTraceEnabled()) { <line9> } <line10> return brokerPoolService; <line11> } <line12> } <line13> "	"<line9>      LOG.trace(""Registered service: {}..."", brokerPoolService.getClass().getSimpleName());"	task4	
public class A { <line0> public String save() { <line1> try { <line2> String result = this.checkUser(); <line3> if (null != result) return result; <line4> if (!this.checkAuthorizationSessionBean()) { <line5> return USER_LIST; <line6> } <line7> UserAuthsFormBean authsBean = this.getUserAuthsFormBean(); <line8> this.getAuthorizationManager() <line9> .updateUserAuthorizations(username, authsBean.getAuthorizations()); <line10> this.getRequest().getSession().removeAttribute(CURRENT_FORM_USER_AUTHS_PARAM_NAME); <line11> } catch (Throwable t) { <line12> return FAILURE; <line13> } <line14> return SUCCESS; <line15> } <line16> } <line17> 	"<line12>      logger.error(""error in save"", t);"	task4	
public class A { <line0> public void init(String[] args) { <line1> initLogger(); <line2> conf = loadConfig(args); <line3> conf.startCleanup(); <line4> } <line5> } <line6> 	"<line4>    LOG.debug(""Loaded conf "" + conf);"	task4	
public class A { <line0> @Override <line1> public Note get(String noteId, String revId, AuthenticationInfo subject) { <line2> Note revisionNote = null; <line3> try { <line4> revisionNote = getRepo(0).get(noteId, revId, subject); <line5> } catch (IOException e) { <line6> } <line7> return revisionNote; <line8> } <line9> } <line10> 	"<line6>      LOG.error(""Failed to get revision {} of note {}"", revId, noteId, e);"	task4	
public class A { <line0> @Override <line1> public void start() throws Exception { <line2> initLoglevelConfig(); <line3> if (loglevelProperty.isEnabled()) { <line4> ioc.get(LoglevelService.class); <line5> } <line6> } <line7> } <line8> 	"<line4>      log.debug(""logback loglevel is starting..."");"	task4	
"public class A { <line0> private void updateDepthValues(CmdiVertex startVertex, Set<CmdiVertex> alreadySeenVerticesSet) { <line1> alreadySeenVerticesSet = new HashSet<>(); <line2> alreadySeenVerticesSet.add(startVertex); <line3> Set<DefaultEdge> outgoingEdgeSet = graph.outgoingEdgesOf(startVertex); <line4> if (!outgoingEdgeSet.isEmpty()) { <line5> Iterator<DefaultEdge> edgeIter = outgoingEdgeSet.iterator(); <line6> CmdiVertex maxVertex = new CmdiVertex(""DUMMY""); <line7> maxVertex.setHierarchyWeight(1); <line8> while (edgeIter.hasNext()) { <line9> CmdiVertex targetVertex = graph.getEdgeTarget(edgeIter.next()); <line10> if (targetVertex.getHierarchyWeight() <= maxVertex.getHierarchyWeight()) { <line11> maxVertex = targetVertex; <line12> } <line13> } <line14> if (maxVertex.getHierarchyWeight() <= startVertex.getHierarchyWeight()) { <line15> alreadySeenVerticesSet.add(maxVertex); <line16> startVertex.setHierarchyWeight(maxVertex.getHierarchyWeight() - 1); <line17> } <line18> } <line19> Set<DefaultEdge> incomingEdgeSet = graph.incomingEdgesOf(startVertex); <line20> if (!incomingEdgeSet.isEmpty()) { <line21> Iterator<DefaultEdge> edgeIter = incomingEdgeSet.iterator(); <line22> while (edgeIter.hasNext()) { <line23> backwardUpdate( <line24> graph.getEdgeSource(edgeIter.next()), <line25> startVertex.getHierarchyWeight() - 1, <line26> alreadySeenVerticesSet); <line27> } <line28> } <line29> } <line30> } <line31> "	"<line15>        LOG.debug(""UP UPDATE  \t""+ startVertex.getId()+ ""\t""+ maxVertex.getId()+ ""\t""+ startVertex.getHierarchyWeight()+ "" --> ""+ (maxVertex.getHierarchyWeight() - 1));"	task4	
"public class A { <line0> public void updateManagementV6AddressVnf(BuildingBlockExecution execution) { <line1> try { <line2> String managementV6Address = execution.getVariable(""oamManagementV6Address""); <line3> if (managementV6Address != null) { <line4> GenericVnf genericVnf = <line5> extractPojosForBB.extractByKey(execution, ResourceKey.GENERIC_VNF_ID); <line6> GenericVnf copiedGenericVnf = genericVnf.shallowCopyId(); <line7> genericVnf.setManagementV6Address(managementV6Address); <line8> copiedGenericVnf.setManagementV6Address(managementV6Address); <line9> aaiVnfResources.updateObjectVnf(copiedGenericVnf); <line10> } <line11> } catch (Exception ex) { <line12> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, ex); <line13> } <line14> } <line15> } <line16> "	"<line12>      logger.error(""Exception occurred in AAIUpdateTasks updateManagementV6AddressVnf"", ex);"	task4	
"public class A { <line0> @Override <line1> public Organization fetchByC_ERC( <line2> long companyId, String externalReferenceCode, boolean useFinderCache) { <line3> externalReferenceCode = Objects.toString(externalReferenceCode, """"); <line4> boolean productionMode = CTPersistenceHelperUtil.isProductionMode(Organization.class); <line5> Object[] finderArgs = null; <line6> if (useFinderCache && productionMode) { <line7> finderArgs = new Object[] {companyId, externalReferenceCode}; <line8> } <line9> Object result = null; <line10> if (useFinderCache && productionMode) { <line11> result = FinderCacheUtil.getResult(_finderPathFetchByC_ERC, finderArgs); <line12> } <line13> if (result instanceof Organization) { <line14> Organization organization = (Organization) result; <line15> if ((companyId != organization.getCompanyId()) <line16> || !Objects.equals(externalReferenceCode, organization.getExternalReferenceCode())) { <line17> result = null; <line18> } <line19> } <line20> if (result == null) { <line21> StringBundler sb = new StringBundler(4); <line22> sb.append(_SQL_SELECT_ORGANIZATION_WHERE); <line23> sb.append(_FINDER_COLUMN_C_ERC_COMPANYID_2); <line24> boolean bindExternalReferenceCode = false; <line25> if (externalReferenceCode.isEmpty()) { <line26> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_3); <line27> } else { <line28> bindExternalReferenceCode = true; <line29> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_2); <line30> } <line31> String sql = sb.toString(); <line32> Session session = null; <line33> try { <line34> session = openSession(); <line35> Query query = session.createQuery(sql); <line36> QueryPos queryPos = QueryPos.getInstance(query); <line37> queryPos.add(companyId); <line38> if (bindExternalReferenceCode) { <line39> queryPos.add(externalReferenceCode); <line40> } <line41> List<Organization> list = query.list(); <line42> if (list.isEmpty()) { <line43> if (useFinderCache && productionMode) { <line44> FinderCacheUtil.putResult(_finderPathFetchByC_ERC, finderArgs, list); <line45> } <line46> } else { <line47> if (list.size() > 1) { <line48> Collections.sort(list, Collections.reverseOrder()); <line49> if (log.isWarnEnabled()) { <line50> if (!productionMode || !useFinderCache) { <line51> finderArgs = new Object[] {companyId, externalReferenceCode}; <line52> } <line53> } <line54> } <line55> Organization organization = list.get(0); <line56> result = organization; <line57> cacheResult(organization); <line58> } <line59> } catch (Exception exception) { <line60> throw processException(exception); <line61> } finally { <line62> closeSession(session); <line63> } <line64> } <line65> if (result instanceof List<?>) { <line66> return null; <line67> } else { <line68> return (Organization) result; <line69> } <line70> } <line71> } <line72> "	"<line53>              log.warn(""OrganizationPersistenceImpl.fetchByC_ERC(long, String, boolean) with parameters""+ "" (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
public class A { <line0> @Override <line1> public void addProduct(IAtomContainer product, Double coefficient) { <line2> super.addProduct(product, coefficient); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Adding product with coefficient: "", product, """" + coefficient);"	task4	
"public class A { <line0> private Set<SystemResponseDTO> getAuthorizedPublishers(final SystemRequestDTO subscriberSystem) { <line1> Assert.notNull(subscriberSystem, ""subscriberSystem is null.""); <line2> final UriComponents checkUri = getAuthSubscriptionCheckUri(); <line3> final AuthorizationSubscriptionCheckRequestDTO payload = <line4> new AuthorizationSubscriptionCheckRequestDTO(subscriberSystem, null); <line5> final ResponseEntity<AuthorizationSubscriptionCheckResponseDTO> response = <line6> httpService.sendRequest( <line7> checkUri, HttpMethod.POST, AuthorizationSubscriptionCheckResponseDTO.class, payload); <line8> return response.getBody().getPublishers(); <line9> } <line10> } <line11> "	"<line1>    logger.debug(""getAuthorizedPublishers started..."");"	task4	
"public class A { <line0> public void setNodeTemplateInstanceProperties( <line1> final String serviceTemplateQName, <line2> final String nodeTemplateId, <line3> final Long id, <line4> final Document properties) <line5> throws ReflectiveOperationException { <line6> final NodeTemplateInstance node = <line7> resolveNodeTemplateInstance(serviceTemplateQName, nodeTemplateId, id); <line8> try { <line9> final NodeTemplateInstanceProperty property = <line10> this.convertDocumentToProperty(properties, NodeTemplateInstanceProperty.class); <line11> node.addProperty(property); <line12> this.nodeTemplateInstanceRepository.update(node); <line13> } catch (InstantiationException | IllegalAccessException e) { <line14> final String msg = <line15> String.format( <line16> ""An error occurred while instantiating an instance of the %s class."", <line17> NodeTemplateInstanceProperty.class); <line18> throw e; <line19> } <line20> } <line21> } <line22> "	<line18>      logger.debug(msg);	task4	
"public class A { <line0> @Override <line1> public InspectionStatus inspect(Configuration configuration) { <line2> String url = configuration.getServicesProperty(SPRING_DATASOURCE_URL); <line3> String username = configuration.getServicesProperty(SPRING_DATASOURCE_USERNAME); <line4> String password = configuration.getServicesProperty(SPRING_DATASOURCE_PASSWORD); <line5> String driver = configuration.getServicesProperty(SPRING_DATASOURCE_DRIVER_CLASS_NAME); <line6> try { <line7> ClassLoader classloader = configuration.getServicesClassloader(); <line8> Class<Driver> aClass = (Class<Driver>) classloader.loadClass(driver); <line9> Driver d = aClass.newInstance(); <line10> DriverManager.registerDriver(new DriverShim(d)); <line11> } catch (InstantiationException | IllegalAccessException e) { <line12> InspectionStatus status = new InspectionStatus(false); <line13> status.addError(String.format(""Failed to create driver '%s': %s"", driver, e.getMessage())); <line14> return status; <line15> } catch (ClassNotFoundException e) { <line16> InspectionStatus status = new InspectionStatus(false); <line17> status.addError( <line18> String.format( <line19> ""Failed to load database driver '%s' from kylo-services classpath '%s'. Ensure you"" <line20> + "" have added driver jar to classpath and jar is readable by kylo-services user"", <line21> driver, configuration.getServicesClasspath())); <line22> return status; <line23> } catch (SQLException e) { <line24> InspectionStatus status = new InspectionStatus(false); <line25> status.addError( <line26> String.format( <line27> ""Failed to register driver '%s' with DriverManager: %s"", driver, e.getMessage())); <line28> return status; <line29> } <line30> try { <line31> Connection connection = DriverManager.getConnection(url, username, password); <line32> connection.close(); <line33> } catch (SQLException e) { <line34> InspectionStatus status = new InspectionStatus(false); <line35> status.addError( <line36> String.format( <line37> ""Failed to establish connection to database '%s' with driver '%s' and username '%s':"" <line38> + "" %s. Check if values are correct for following properties: '%s', '%s', '%s' in"" <line39> + "" %s"", <line40> url, <line41> driver, <line42> username, <line43> e.getMessage(), <line44> SPRING_DATASOURCE_URL, <line45> SPRING_DATASOURCE_USERNAME, <line46> SPRING_DATASOURCE_PASSWORD, <line47> configuration.getServicesConfigLocation())); <line48> return status; <line49> } <line50> return new InspectionStatus(true); <line51> } <line52> } <line53> "	"<line2>    LOG.debug(""KyloDatabaseConnectionInspection.inspect"");"	task4	
public class A { <line0> public void syncStop() { <line1> _stopCountDown.countDown(); <line2> try { <line3> _waitStopFinishCountDown.await(); <line4> _started = false; <line5> } catch (InterruptedException e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.error(""Interrupted waiting for finish"", e);"	task4	
"public class A { <line0> private boolean loadConfigFromURL(JDBCLoaderProperties config) throws IOException { <line1> String propUrl = System.getProperty(replacePrefix(CONFIG_SYSPROP)); <line2> if (propUrl == null) { <line3> return false; <line4> } <line5> URL url = null; <line6> try { <line7> try { <line8> url = new URL(propUrl); <line9> } catch (MalformedURLException e) { <line10> File f = new File(propUrl); <line11> if (f.canRead() && f.exists()) { <line12> url = URLs.fileToUrl(f); <line13> } <line14> } <line15> } catch (Exception e) { <line16> LOGGER.log(Level.WARNING, ""Error trying to read "" + propUrl, e); <line17> } <line18> if (url != null) { <line19> InputStream in = url.openStream(); <line20> try { <line21> config.load(in); <line22> } finally { <line23> in.close(); <line24> } <line25> return true; <line26> } <line27> LOGGER.severe( <line28> ""System property "" <line29> + replacePrefix(CONFIG_SYSPROP) <line30> + "" specified "" <line31> + propUrl <line32> + "" but could not be read, ignoring.""); <line33> return false; <line34> } <line35> } <line36> "	"<line19>      LOGGER.info(""Configuring jdbcloader from "" + url.toString());"	task4	
"public class A { <line0> @Override <line1> public int doEndTag() throws JspException { <line2> ServletRequest request = this.pageContext.getRequest(); <line3> RequestContext reqCtx = (RequestContext) request.getAttribute(RequestContext.REQCTX); <line4> try { <line5> IContentListWidgetHelper helper = <line6> (IContentListWidgetHelper) <line7> ApsWebApplicationUtils.getBean( <line8> JacmsSystemConstants.CONTENT_LIST_HELPER, this.pageContext); <line9> List<UserFilterOptionBean> defaultUserFilterOptions = <line10> helper.getConfiguredUserFilters(this, reqCtx); <line11> this.addUserFilterOptions(defaultUserFilterOptions); <line12> this.extractExtraWidgetParameters(reqCtx); <line13> if (null != this.getUserFilterOptions() && null != this.getUserFilterOptionsVar()) { <line14> this.pageContext.setAttribute(this.getUserFilterOptionsVar(), this.getUserFilterOptions()); <line15> } <line16> List<String> contents = this.getContentsId(helper, reqCtx); <line17> this.pageContext.setAttribute(this.getListName(), contents); <line18> } catch (Throwable t) { <line19> throw new JspException(""Error detected while finalising the tag"", t); <line20> } <line21> this.release(); <line22> return EVAL_PAGE; <line23> } <line24> } <line25> "	"<line19>      logger.error(""error in end tag"", t);"	task4	
public class A { <line0> @EventListener <line1> @Order(5) <line2> public void onApplicationEvent(final ContextRefreshedEvent event) { <line3> arrowheadContext.put(CoreCommonConstants.SERVER_STANDALONE_MODE, true); <line4> } <line5> } <line6> 	"<line3>    logger.info(""STANDALONE mode is set..."");"	task4	
public class A { <line0> private void addToMapIfNotExist( <line1> Map<String, UserAttributeParam> userAttributeParamMap, <line2> Map.Entry<String, UserAttributeParam> addAttribute) { <line3> if (CollectionUtils.isEmpty(userAttributeParamMap)) { <line4> return; <line5> } <line6> UserAttributeParam userAttributeParam = userAttributeParamMap.get(addAttribute.getKey()); <line7> if (userAttributeParam == null) { <line8> userAttributeParamMap.put(addAttribute.getKey(), addAttribute.getValue()); <line9> } else { <line10> userAttributeParam.setValues(addAttribute.getValue().getValues()); <line11> } <line12> } <line13> } <line14> 	"<line4>      log.info(""Invalid map to add the entries"");"	task4	
public class A { <line0> @Override <line1> public Operation pollOperation(Operation operation, Long sleepMs) <line2> throws InterruptedException, IOException { <line3> while (operation.getDone() == null || !operation.getDone()) { <line4> Thread.sleep(sleepMs); <line5> operation = <line6> client.projects().locations().datasets().operations().get(operation.getName()).execute(); <line7> } <line8> return operation; <line9> } <line10> } <line11> 	"<line3>    LOG.debug(String.format(""started opertation %s. polling until complete."", operation.getName()));"	task4	
"public class A { <line0> public String validate(Source source) { <line1> try { <line2> final StringWriter writer = new StringWriter(); <line3> templates.newTransformer().transform(source, new StreamResult(writer)); <line4> return writer.toString(); <line5> } catch (TransformerException e) { <line6> throw new SchematronValidationException(""Failed to apply Schematron validation transform"", e); <line7> } <line8> } <line9> } <line10> "	<line6>      logger.error(e.getMessage());	task4	
"public class A { <line0> private void checkAssociationLinks(String response, List<String> entityTypes, List<Object> ids) { <line1> try { <line2> if (EntityType.isPlural(entityTypes.get(entityTypes.size() - 1))) { <line3> String message = <line4> ""The GET entities Association Link response does not match SensorThings API : missing"" <line5> + "" \""value\"" in response.: "" <line6> + entityTypes.toString() <line7> + ids.toString(); <line8> Assert.assertTrue(message, response.contains(""value"")); <line9> JSONArray value = new JSONObject(response).getJSONArray(""value""); <line10> int count = 0; <line11> for (int i = 0; i < value.length() && count < 2; i++) { <line12> count++; <line13> JSONObject obj = value.getJSONObject(i); <line14> try { <line15> message = <line16> ""The Association Link does not contain self-links.: "" <line17> + entityTypes.toString() <line18> + ids.toString(); <line19> Assert.assertNotNull(message, obj.get(ControlInformation.SELF_LINK)); <line20> } catch (JSONException e) { <line21> Assert.fail( <line22> ""The Association Link does not contain self-links.: "" <line23> + entityTypes.toString() <line24> + ids.toString()); <line25> } <line26> message = <line27> ""The Association Link contains properties other than self-link.: "" <line28> + entityTypes.toString() <line29> + ids.toString(); <line30> Assert.assertEquals(message, 1, obj.length()); <line31> } <line32> } else { <line33> JSONObject obj = new JSONObject(response); <line34> try { <line35> String message = <line36> ""The Association Link does not contain self-links.: "" <line37> + entityTypes.toString() <line38> + ids.toString(); <line39> Assert.assertNotNull(message, obj.get(ControlInformation.SELF_LINK)); <line40> } catch (JSONException e) { <line41> Assert.fail( <line42> ""The Association Link does not contain self-links.: "" <line43> + entityTypes.toString() <line44> + ids.toString()); <line45> } <line46> String message = <line47> ""The Association Link contains properties other than self-link.: "" <line48> + entityTypes.toString() <line49> + ids.toString(); <line50> Assert.assertEquals(message, 1, obj.length()); <line51> } <line52> } catch (JSONException e) { <line53> Assert.fail(""An Exception occurred during testing!:\n"" + e.getMessage()); <line54> } <line55> } <line56> } <line57> "	"<line53>      LOGGER.error(""Exception:"", e);"	task4	
"public class A { <line0> private long getTypeShellCount(String typeName) { <line1> Long ret = null; <line2> String indexQuery = <line3> indexSearchPrefix <line4> + ""\"""" <line5> + ENTITY_TYPE_PROPERTY_KEY <line6> + ""\"" : (%s)"" <line7> + AND_STR <line8> + indexSearchPrefix <line9> + ""\"""" <line10> + IS_INCOMPLETE_PROPERTY_KEY <line11> + ""\"" : "" <line12> + INCOMPLETE_ENTITY_VALUE.intValue(); <line13> indexQuery = String.format(indexQuery, typeName); <line14> try { <line15> ret = atlasGraph.indexQuery(VERTEX_INDEX, indexQuery).vertexTotals(); <line16> } catch (Exception e) { <line17> } <line18> return ret == null ? 0L : ret; <line19> } <line20> } <line21> "	"<line17>      LOG.error(""Failed fetching using indexQuery: "" + e.getMessage());"	task4	
"public class A { <line0> public void createMultiBranchPipeline( <line1> FolderJob folder, String pipelineName, String repositoryPath) throws IOException { <line2> deletePipeline(folder, pipelineName); <line3> URL url = Resources.getResource(this.getClass(), ""multibranch.xml""); <line4> jenkins.createJob( <line5> folder, <line6> pipelineName, <line7> Resources.toString(url, Charsets.UTF_8).replace(""{{repo}}"", repositoryPath), <line8> true); <line9> JobWithDetails job = jenkins.getJob(folder, pipelineName); <line10> job.build(true); <line11> } <line12> } <line13> "	"<line9>    LOGGER.info(""Created multibranch pipeline: "" + pipelineName);"	task4	
public class A { <line0> @Override <line1> public void runJob() { <line2> Model depModel = getReadOnlyModel(); <line3> Model model = ModelFactory.createDefaultModel().add(depModel); <line4> Bag depositBag = model.createBag(getDepositPID().getURI()); <line5> Map<String, String> status = getDepositStatus(); <line6> URI sourceUri = URI.create(status.get(DepositField.sourceUri.name())); <line7> Path sourcePath = Paths.get(sourceUri); <line8> File sourceFile = sourcePath.toFile(); <line9> Collection<File> fileListings = <line10> FileUtils.listFilesAndDirs(sourceFile, TrueFileFilter.TRUE, TrueFileFilter.TRUE); <line11> interruptJobIfStopped(); <line12> Bag sourceBag = getSourceBag(depositBag, sourceFile); <line13> int i = 0; <line14> for (File file : fileListings) { <line15> if (file.equals(sourceFile)) { <line16> continue; <line17> } <line18> Path filePath = sourcePath.getParent().relativize(file.toPath()); <line19> String filePathString = filePath.toString(); <line20> String filename = filePath.getFileName().toString(); <line21> if (!file.isDirectory()) { <line22> Resource originalResource = getFileResource(sourceBag, filePathString); <line23> Path storedPath = Paths.get(file.getAbsolutePath()); <line24> model.add(originalResource, CdrDeposit.stagingLocation, storedPath.toUri().toString()); <line25> } else { <line26> Bag folderBag = getFolderBag(sourceBag, filePathString); <line27> model.add(folderBag, CdrDeposit.label, filename); <line28> model.add(folderBag, RDF.type, Cdr.Folder); <line29> } <line30> } <line31> commit(() -> depModel.add(model)); <line32> } <line33> } <line34> 	"<line18>      log.debug(""Adding object {}: {}"", i++, file.getName());"	task4	
public class A { <line0> public static File getMetaDir(DBDefinition definition, OzoneConfiguration configuration) { <line1> File metadataDir = definition.getDBLocation(configuration); <line2> if (metadataDir == null) { <line3> metadataDir = getOzoneMetaDirPath(configuration); <line4> } <line5> return metadataDir; <line6> } <line7> } <line8> 	"<line3>      LOG.warn(""{} is not configured. We recommend adding this setting. ""+ ""Falling back to {} instead."",definition.getLocationConfigKey(),HddsConfigKeys.OZONE_METADATA_DIRS);"	task4	
public class A { <line0> @Override <line1> public void onNunchukRemovedEvent(NunchukRemovedEvent arg0) { <line2> } <line3> } <line4> 	"<line2>    log.debug(""NunchukRemovedEvent {}"", arg0);"	task4	
public class A { <line0> @OnReturn <line1> public static void onReturn(@BindReceiver HasStatementMirrorMixin resultSet) { <line2> try { <line3> StatementMirror mirror = resultSet.glowroot$getStatementMirror(); <line4> if (mirror == null) { <line5> return; <line6> } <line7> QueryEntry lastQueryEntry = mirror.getLastQueryEntry(); <line8> if (lastQueryEntry == null) { <line9> return; <line10> } <line11> lastQueryEntry.setCurrRow(((ResultSet) resultSet).getRow()); <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> 	<line13>      logger.warn(e.getMessage(), e);	task4	
public class A { <line0> private void endTransactionAndRegisterStats(Operation noTxOperation) { <line1> Request commitRequest = recording() ? stats.startRequest() : null; <line2> try { <line3> if (stage.commitTransactions) { <line4> ongoingTx.commit(); <line5> } else { <line6> ongoingTx.rollback(); <line7> } <line8> succeeded( <line9> commitRequest, stage.commitTransactions ? Transactional.COMMIT : Transactional.ROLLBACK); <line10> } catch (Exception e) { <line11> failed( <line12> commitRequest, stage.commitTransactions ? Transactional.COMMIT : Transactional.ROLLBACK); <line13> if (logTransactionExceptions) { <line14> } <line15> } finally { <line16> if (requests != null) { <line17> if (recording()) { <line18> requests.add(commitRequest); <line19> requests.finished(commitRequest.isSuccessful(), Transactional.DURATION); <line20> if (noTxOperation != null) { <line21> requests.finished(commitRequest.isSuccessful(), noTxOperation); <line22> } <line23> } else { <line24> requests.discard(); <line25> } <line26> requests = null; <line27> } <line28> clearTransaction(); <line29> } <line30> } <line31> } <line32> 	"<line14>        log.error(""Failed to end transaction"", e);"	task4	
public class A { <line0> @Override <line1> public void error(final SAXParseException e) { <line2> } <line3> } <line4> 	"<line2>    logger.warn(""Schema validation error parsing Flow Configuration at line {}, col {}: {}"",e.getLineNumber(),e.getColumnNumber(),e.getMessage());"	task4	
public class A { <line0> @Override <line1> public Map<Short, JoyQueueCode> batchCommitIndex( <line2> String topic, String app, Map<Short, Long> indexes, long timeout) { <line3> Table<String, Short, Long> topicTable = HashBasedTable.create(); <line4> for (Map.Entry<Short, Long> entry : indexes.entrySet()) { <line5> topicTable.put(topic, entry.getKey(), entry.getValue()); <line6> } <line7> Map<Short, JoyQueueCode> result = Maps.newHashMap(); <line8> Map<BrokerNode, Table<String, Short, Long>> brokerCommitMap = <line9> buildCommitIndexRequest(topic, app, indexes); <line10> for (Map.Entry<BrokerNode, Table<String, Short, Long>> entry : brokerCommitMap.entrySet()) { <line11> try { <line12> ConsumerClient client = consumerClientManager.getOrCreateClient(entry.getKey()); <line13> CommitIndexResponse commitIndexResponse = <line14> client.commitIndex(entry.getValue(), app, timeout); <line15> for (Map.Entry<String, Map<Short, JoyQueueCode>> resultEntry : <line16> commitIndexResponse.getResult().rowMap().entrySet()) { <line17> for (Map.Entry<Short, JoyQueueCode> ackEntry : resultEntry.getValue().entrySet()) { <line18> result.put(ackEntry.getKey(), ackEntry.getValue()); <line19> } <line20> } <line21> } catch (ClientException e) { <line22> for (Map.Entry<String, Map<Short, Long>> topicEntry : <line23> entry.getValue().rowMap().entrySet()) { <line24> for (Map.Entry<Short, Long> partitionEntry : topicEntry.getValue().entrySet()) { <line25> result.put(partitionEntry.getKey(), JoyQueueCode.valueOf(e.getCode())); <line26> } <line27> } <line28> } <line29> } <line30> for (Map.Entry<Short, JoyQueueCode> entry : result.entrySet()) { <line31> if (result.containsKey(entry.getKey())) { <line32> continue; <line33> } <line34> result.put(entry.getKey(), JoyQueueCode.CN_UNKNOWN_ERROR); <line35> } <line36> return result; <line37> } <line38> } <line39> 	"<line22>        logger.error(""commit index exception, commitMap: {}, app: {}"", entry.getValue(), app, e);"	task4	
"public class A { <line0> protected boolean isDocumentValid(final String schemaURL) throws DocServiceException { <line1> try { <line2> InputStream dataToValid = new ByteArrayInputStream(getContent().getBytes(""UTF-8"")); <line3> SchemaFactory factory = SchemaFactory.newInstance(""http://www.w3.org/2001/XMLSchema""); <line4> Schema schema = factory.newSchema(new URL(schemaURL)); <line5> Source source = new StreamSource(dataToValid); <line6> Validator validator = schema.newValidator(); <line7> validator.validate(source); <line8> return true; <line9> } catch (SAXException ex) { <line10> throw new DocServiceException( <line11> ""File is not valid. "" + ex.getMessage(), HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE); <line12> } catch (IOException e) { <line13> } <line14> return false; <line15> } <line16> } <line17> "	"<line13>      LOG.error(""Error while checking validity of the document"", e);"	task4	
"public class A { <line0> private void createUpdateCloudWatchEventJob(final JobExecutionManager jobDetails) <line1> throws PacManException { <line2> try { <line3> PutRuleRequest ruleRequest = <line4> new PutRuleRequest() <line5> .withName(jobDetails.getJobUUID()) <line6> .withDescription(jobDetails.getJobId()); <line7> ruleRequest <line8> .withScheduleExpression(""cron("".concat(jobDetails.getJobFrequency()).concat("")"")) <line9> .withState(RuleState.ENABLED); <line10> PutRuleResult ruleResult = <line11> amazonClient <line12> .getAmazonCloudWatchEvents(config.getJob().getLambda().getRegion()) <line13> .putRule(ruleRequest); <line14> AWSLambda awsLambdaClient = <line15> amazonClient.getAWSLambdaClient(config.getJob().getLambda().getRegion()); <line16> if (!checkIfPolicyAvailableForLambda( <line17> config.getJob().getLambda().getFunctionName(), awsLambdaClient)) { <line18> createPolicyForLambda(config.getJob().getLambda().getFunctionName(), awsLambdaClient); <line19> } <line20> if (ruleResult.getRuleArn() != null) { <line21> jobDetails.setJobArn(ruleResult.getRuleArn()); <line22> boolean isLambdaFunctionLinked = <line23> linkTargetWithRule( <line24> config.getJob().getLambda().getTargetId(), <line25> config.getJob().getLambda().getFunctionArn(), <line26> jobDetails.getJobParams(), <line27> jobDetails.getJobUUID()); <line28> if (!isLambdaFunctionLinked) { <line29> } else { <line30> jobExecutionManagerRepository.save(jobDetails); <line31> invokeRule( <line32> awsLambdaClient, <line33> config.getJob().getLambda().getFunctionName(), <line34> jobDetails.getJobParams()); <line35> } <line36> } else { <line37> throw new PacManException(UNEXPECTED_ERROR_OCCURRED); <line38> } <line39> } catch (Exception exception) { <line40> if (exception.getMessage().contains(""ScheduleExpression is not valid"")) { <line41> throw new PacManException(INVALID_JOB_FREQUENCY); <line42> } else { <line43> throw new PacManException(UNEXPECTED_ERROR_OCCURRED); <line44> } <line45> } <line46> } <line47> } <line48> "	<line40>      log.error(UNEXPECTED_ERROR_OCCURRED, exception);	task4	
"public class A { <line0> @Override <line1> protected void doMessageReceived(IoSessionEx session, Object message) throws Exception { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> BridgeSession bridgeSession = (BridgeSession) session; <line5> URI uriConnectURI = URI.create(connectURI); <line6> assertEquals( <line7> ""remote address of connect session was not "" + connectURI, <line8> uriConnectURI, <line9> BridgeSession.REMOTE_ADDRESS.get(bridgeSession).getResource()); <line10> assertEquals( <line11> ""local  address of connect session was not "" + connectURI, <line12> uriConnectURI, <line13> BridgeSession.LOCAL_ADDRESS.get(bridgeSession).getResource()); <line14> assertEquals( <line15> ""ephemeral port of local address' transport != ephemeral port of parent session's local"" <line16> + "" address"", <line17> BridgeSession.LOCAL_ADDRESS.get(bridgeSession).getTransport().getResource().getPort(), <line18> BridgeSession.LOCAL_ADDRESS.get(bridgeSession.getParent()).getResource().getPort()); <line19> checkpoint(); <line20> } <line21> } <line22> "	"<line3>      logger.debug(""Client Http Session received OK"");"	task4	
"public class A { <line0> @Override <line1> public Job concat( <line2> String profileId, <line3> Dimension outputDimension, <line4> float outputFrameRate, <line5> boolean sameCodec, <line6> Track... tracks) <line7> throws EncoderException, MediaPackageException { <line8> HttpPost post = new HttpPost(""/concat""); <line9> try { <line10> List<BasicNameValuePair> params = new ArrayList<BasicNameValuePair>(); <line11> params.add(new BasicNameValuePair(""profileId"", profileId)); <line12> if (outputDimension != null) <line13> params.add( <line14> new BasicNameValuePair(""outputDimension"", Serializer.json(outputDimension).toJson())); <line15> params.add( <line16> new BasicNameValuePair( <line17> ""outputFrameRate"", String.format(Locale.US, ""%f"", outputFrameRate))); <line18> params.add( <line19> new BasicNameValuePair( <line20> ""sourceTracks"", MediaPackageElementParser.getArrayAsXml(Arrays.asList(tracks)))); <line21> if (sameCodec) params.add(new BasicNameValuePair(""sameCodec"", ""true"")); <line22> post.setEntity(new UrlEncodedFormEntity(params, ""UTF-8"")); <line23> } catch (Exception e) { <line24> throw new EncoderException(e); <line25> } <line26> HttpResponse response = null; <line27> try { <line28> response = getResponse(post); <line29> if (response != null) { <line30> Job r = JobParser.parseJob(response.getEntity().getContent()); <line31> return r; <line32> } <line33> } catch (Exception e) { <line34> throw new EncoderException(e); <line35> } finally { <line36> closeConnection(response); <line37> } <line38> throw new EncoderException( <line39> ""Unable to concat videos from tracks "" <line40> + tracks <line41> + "" using the remote composer service proxy""); <line42> } <line43> } <line44> "	"<line31>        logger.info(""Concat video job {} started on a remote composer"", r.getId());"	task4	
"public class A { <line0> private void _read(ClassLoader classLoader, URL sourceURL, Map<String, String> sqls) <line1> throws Exception { <line2> try (InputStream inputStream = sourceURL.openStream()) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> Document document = UnsecureSAXReaderUtil.read(inputStream); <line6> Element rootElement = document.getRootElement(); <line7> for (Element sqlElement : rootElement.elements(""sql"")) { <line8> String file = sqlElement.attributeValue(""file""); <line9> if (Validator.isNotNull(file)) { <line10> URL fileURL = classLoader.getResource(file); <line11> _read(classLoader, fileURL, sqls); <line12> } else { <line13> String id = sqlElement.attributeValue(""id""); <line14> String content = transform(sqlElement.getText()); <line15> content = replaceIsNull(content); <line16> sqls.put(id, content); <line17> } <line18> } <line19> } <line20> } <line21> } <line22> "	"<line4>        log.debug(""Loading "" + sourceURL);"	task4	
public class A { <line0> @BuildStep <line1> void registerBeans( <line2> BuildProducer<AdditionalBeanBuildItem> beans, <line3> List<BindableServiceBuildItem> bindables, <line4> BuildProducer<FeatureBuildItem> features) { <line5> beans.produce(new AdditionalBeanBuildItem(GrpcService.class)); <line6> beans.produce(new AdditionalBeanBuildItem(GrpcRequestContextCdiInterceptor.class)); <line7> beans.produce(new AdditionalBeanBuildItem(GrpcEnableRequestContext.class)); <line8> if (!bindables.isEmpty() || LaunchMode.current() == LaunchMode.DEVELOPMENT) { <line9> beans.produce(AdditionalBeanBuildItem.unremovableOf(GrpcContainer.class)); <line10> features.produce(new FeatureBuildItem(GRPC_SERVER)); <line11> } else { <line12> } <line13> } <line14> } <line15> 	"<line12>      logger.debug(""Unable to find beans exposing the `BindableService` interface - not starting the gRPC""+ "" server"");"	task4	
public class A { <line0> public ContentDto getContent(Long versionId) { <line1> try { <line2> final ContentVersion contentVersion = versioningManager.getVersion(versionId); <line3> final Content content = versioningManager.getContent(contentVersion); <line4> final ContentDto contentDto = contentService.getDtoBuilder().convert(content); <line5> return contentDto; <line6> } catch (ApsSystemException e) { <line7> } <line8> return null; <line9> } <line10> } <line11> 	"<line7>      logger.error(""Error reading the content from version {} "", versionId, e);"	task4	
"public class A { <line0> private Map<String, Group> parseGroups( <line1> String appId, <line2> int tenantId, <line3> String key, <line4> List<GroupContext> groupCtxts, <line5> Map<String, SubscribableInfoContext> subscribableInformation) <line6> throws ApplicationDefinitionException, CartridgeGroupNotFoundException, <line7> CartridgeNotFoundException { <line8> Map<String, Group> groupAliasToGroup = new HashMap<String, Group>(); <line9> for (GroupContext groupCtxt : groupCtxts) { <line10> ServiceGroup serviceGroup = getServiceGroup(groupCtxt.getName()); <line11> if (serviceGroup == null) { <line12> throw new CartridgeGroupNotFoundException( <line13> ""Cartridge group not found group-name: "" + groupCtxt.getName()); <line14> } <line15> Group group = <line16> parseGroup(appId, tenantId, key, groupCtxt, subscribableInformation, serviceGroup); <line17> validateCartridgeGroupReference(appId, serviceGroup, group); <line18> groupAliasToGroup.put(group.getAlias(), group); <line19> } <line20> Set<Group> nestedGroups = new HashSet<Group>(); <line21> getNestedGroupContexts(nestedGroups, groupAliasToGroup.values()); <line22> filterDuplicatedGroupContexts(groupAliasToGroup.values(), nestedGroups); <line23> return groupAliasToGroup; <line24> } <line25> } <line26> "	"<line12>        log.error(""Cartridge group not found group-name: "" + groupCtxt.getName());"	task4	
"public class A { <line0> private void executeLock( <line1> ITransaction transaction, HttpServletRequest req, HttpServletResponse resp) <line2> throws LockFailedException, IOException, ServletException { <line3> if (macLockRequest) { <line4> doMacLockRequestWorkaround(transaction, req, resp); <line5> } else { <line6> if (getLockInformation(req, resp)) { <line7> int depth = getDepth(req); <line8> int lockDuration = getTimeout(req); <line9> boolean lockSuccess = false; <line10> if (exclusive) { <line11> lockSuccess = <line12> resourceLocks.exclusiveLock(transaction, path, lockOwner, depth, lockDuration); <line13> } else { <line14> lockSuccess = resourceLocks.sharedLock(transaction, path, lockOwner, depth, lockDuration); <line15> } <line16> if (lockSuccess) { <line17> LockedObject lo = resourceLocks.getLockedObjectByPath(transaction, path); <line18> if (lo != null) { <line19> generateXMLReport(resp, lo); <line20> } else { <line21> resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR); <line22> } <line23> } else { <line24> sendLockFailError(req, resp); <line25> throw new LockFailedException(); <line26> } <line27> } else { <line28> resp.setContentType(""text/xml; charset=UTF-8""); <line29> resp.sendError(WebdavStatus.SC_BAD_REQUEST); <line30> } <line31> } <line32> } <line33> } <line34> "	"<line4>      logger.trace(""DoLock.execute() : do workaround for user agent '"" + userAgent + ""'"");"	task4	
public class A { <line0> protected Key toKey(String expression, VariableResolver resolver) { <line1> Set<String> variablesUsed = <line2> variableCache.get().computeIfAbsent(expression, this::variablesUsed); <line3> Map<String, Object> input = new HashMap<>(); <line4> for (String v : variablesUsed) { <line5> input.computeIfAbsent(v, resolver::resolve); <line6> } <line7> Key cacheKey = new Key(expression, input); <line8> return cacheKey; <line9> } <line10> } <line11> 	"<line8>    LOG.debug(""Created cache key; {}"", cacheKey);"	task4	
"public class A { <line0> public static APIManagementProviderService getAPIManagementProviderService() { <line1> PrivilegedCarbonContext ctx = PrivilegedCarbonContext.getThreadLocalCarbonContext(); <line2> APIManagementProviderService apiManagementProviderService = <line3> (APIManagementProviderService) ctx.getOSGiService(APIManagementProviderService.class, null); <line4> if (apiManagementProviderService == null) { <line5> String msg = ""API management provider service has not initialized.""; <line6> throw new IllegalStateException(msg); <line7> } <line8> return apiManagementProviderService; <line9> } <line10> } <line11> "	<line6>      log.error(msg);	task4	
"public class A { <line0> @Override <line1> public void write(List<? extends T> items) { <line2> for (T data : items) { <line3> if (!failed && list.size() == failurePoint) { <line4> failed = true; <line5> throw new RuntimeException(""Failed processing: ["" + data + ""]""); <line6> } <line7> list.add(data); <line8> } <line9> } <line10> } <line11> "	"<line7>      logger.info(""Processing: ["" + data + ""]"");"	task4	
"public class A { <line0> public void handle(Activity failedActivity, LifecyclePhase failedCall, Throwable exception) { <line1> if (errorHandlingInProgress) { <line2> return; <line3> } <line4> try { <line5> errorHandlingInProgress = true; <line6> ActivityLifecycleError event = <line7> new ActivityLifecycleError(failedActivity, failedCall, exception); <line8> try { <line9> lifecycleErrorEvent.fire(event); <line10> } catch (Exception ex) { <line11> } <line12> if (!event.isErrorMessageSuppressed()) { <line13> StringBuilder message = new StringBuilder(); <line14> message.append(shortName(failedActivity.getClass()) + "" failed in "").append(failedCall); <line15> if (exception != null) { <line16> message.append("": "").append(exception.toString()); <line17> } <line18> notificationManager.addNotification( <line19> new NotificationEvent(message.toString(), NotificationType.ERROR)); <line20> } <line21> } finally { <line22> errorHandlingInProgress = false; <line23> } <line24> } <line25> } <line26> "	"<line11>        logger.warn(""A lifecycle error observer threw an exception"", ex);"	task4	
public class A { <line0> public Long getDiscoveryInitialWaitTimeout() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> return raProperties.getDiscoveryInitialWaitTimeout(); <line4> } <line5> } <line6> 	"<line2>      logger.trace(""getDiscoveryInitialWaitTimeout()"");"	task4	
"public class A { <line0> @Test <line1> public void testScheduleCampaignCloneFail() throws Exception { <line2> iprops.campaignAction.setValue(schedule); <line3> iprops.campaignId.setValue(BATCH_CAMPAIGN); <line4> iprops.cloneToProgramName.setValue(""undx_test_program""); <line5> iprops.afterCampaignAction(); <line6> MarketoRecordResult rs = getClient(iprops).scheduleCampaign(iprops); <line7> assertFalse(rs.isSuccess()); <line8> assertEquals(""{[611] System error}"", rs.getErrorsString()); <line9> } <line10> } <line11> "	"<line7>    LOG.debug(""[testScheduleCampaign] {}"", rs);"	task4	
public class A { <line0> @Override <line1> public Processor wrap(Route route, final Processor processor) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> return new ShiroSecurityProcessor(processor, this); <line5> } <line6> } <line7> 	"<line3>      LOG.debug(""Securing route {} using Shiro policy {}"", route.getRouteId(), this);"	task4	
"public class A { <line0> public void init(String authConfig) { <line1> InputStream in = null; <line2> try { <line3> try { <line4> in = AuthParamManager.class.getResourceAsStream(authConfig); <line5> param = SerializeUtils.bytesToObject(in, AuthParam.class); <line6> } finally { <line7> if (in != null) { <line8> in.close(); <line9> } <line10> } <line11> } catch (SerializeException | IOException e) { <line12> throw new SystemException(""config load error""); <line13> } <line14> } <line15> } <line16> "	"<line1>    LOG.debug(""Config loaded"" + authConfig);"	task4	
public class A { <line0> @Override <line1> public <TYPE> TYPE get(Layer layer, CacheCategory category, String key, Class<TYPE> type) { <line2> TYPE o = getCache(layer, category).get(key, type); <line3> if (log.isDebugEnabled()) { <line4> } <line5> return o; <line6> } <line7> } <line8> 	"<line4>      log.debug(""Get {}: {} {} {}"",new String[] {o != null ? ""Hit"" : ""Miss"", getLogLayerId(layer), category.toString(), key});"	task4	
public class A { <line0> @Override <line1> public <E> List<E> findAll(Class<E> entityClass, String[] columnsToSelect, Object... rowIds) { <line2> EntityMetadata entityMetadata = <line3> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, entityClass); <line4> if (rowIds == null) { <line5> return null; <line6> } <line7> List results = new ArrayList<E>(); <line8> MetamodelImpl metaModel = <line9> (MetamodelImpl) <line10> kunderaMetadata <line11> .getApplicationMetadata() <line12> .getMetamodel(entityMetadata.getPersistenceUnit()); <line13> EntityType entityType = metaModel.entity(entityClass); <line14> List<AbstractManagedType> subManagedType = <line15> ((AbstractManagedType) entityType).getSubManagedType(); <line16> try { <line17> if (!subManagedType.isEmpty()) { <line18> for (AbstractManagedType subEntity : subManagedType) { <line19> EntityMetadata subEntityMetadata = <line20> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, subEntity.getJavaType()); <line21> results = <line22> handler.readAll( <line23> subEntityMetadata.getSchema(), <line24> subEntityMetadata.getEntityClazz(), <line25> subEntityMetadata, <line26> Arrays.asList(rowIds), <line27> subEntityMetadata.getRelationNames()); <line28> if (!results.isEmpty()) { <line29> break; <line30> } <line31> } <line32> } else { <line33> results = <line34> handler.readAll( <line35> entityMetadata.getSchema(), <line36> entityMetadata.getEntityClazz(), <line37> entityMetadata, <line38> Arrays.asList(rowIds), <line39> entityMetadata.getRelationNames()); <line40> } <line41> } catch (IOException ioex) { <line42> throw new KunderaException(ioex); <line43> } <line44> return results; <line45> } <line46> } <line47> 	"<line42>      log.error(""Error during find All , Caused by: ."", ioex);"	task4	
"public class A { <line0> private ScheduledExecutorService createCleanUpExecutor() { <line1> final int numCleaningThreads = quotaConfig.getMaxConcurrentCleanUps(); <line2> CustomizableThreadFactory tf = new CustomizableThreadFactory(""GWC DiskQuota clean up thread-""); <line3> tf.setThreadPriority(1 + (Thread.MAX_PRIORITY - Thread.MIN_PRIORITY) / 5); <line4> ScheduledExecutorService executorService = <line5> Executors.newScheduledThreadPool(numCleaningThreads, tf); <line6> return executorService; <line7> } <line8> } <line9> "	"<line2>    log.info(""Setting up disk quota periodic enforcement task"");"	task4	
public class A { <line0> public ScriptingGauge newGauge(String name, double initialValue) { <line1> ScriptingGauge scriptingGauge = new ScriptingGauge(name, initialValue); <line2> ActivityMetrics.gauge(scriptContext, name, scriptingGauge); <line3> return scriptingGauge; <line4> } <line5> } <line6> 	"<line3>    logger.info(""registered scripting gauge:"" + name);"	task4	
public class A { <line0> @Override <line1> public int getReactionSchemeCount() { <line2> return super.getReactionSchemeCount(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting reactionScheme count: "", super.getReactionSchemeCount());"	task4	
"public class A { <line0> public void addSynchroToGraph(int synchId) { <line1> try { <line2> full_graph.newLine(); <line3> if (synchId == 0) { <line4> full_graph.write( <line5> ""Synchro"" <line6> + synchId <line7> + ""[label=\""main\"", shape=octagon, style=filled fillcolor=\""#8B0000\"""" <line8> + "" fontcolor=\""#FFFFFF\""];""); <line9> } else { <line10> full_graph.write( <line11> ""Synchro"" <line12> + synchId <line13> + ""[label=\""sync\"", shape=octagon, style=filled fillcolor=\""#ff0000\"""" <line14> + "" fontcolor=\""#FFFFFF\""];""); <line15> } <line16> } catch (IOException e) { <line17> } <line18> } <line19> } <line20> "	<line17>      LOGGER.error(ERROR_ADDING_DATA, e);	task4	
public class A { <line0> private void fireCompleteNotification(CoreEvent event, MessagingException messagingException) { <line1> if (event != null) { <line2> FlowCallStack flowCallStack = event.getFlowCallStack(); <line3> if (flowCallStack instanceof DefaultFlowCallStack) { <line4> ((DefaultFlowCallStack) flowCallStack).pop(); <line5> } <line6> } else { <line7> } <line8> notificationFirer.dispatch( <line9> new PipelineMessageNotification( <line10> createInfo(event, messagingException, AbstractPipeline.this), <line11> AbstractPipeline.this.getName(), <line12> PROCESS_COMPLETE)); <line13> } <line14> } <line15> 	"<line7>      LOGGER.warn(""No event on flow completion"", messagingException);"	task4	
public class A { <line0> @Transactional(readOnly = true) <line1> public ClusterCreate getClusterConfig(String clusterName, boolean needAllocIp) { <line2> ClusterEntity clusterEntity = clusterEntityMgr.findByName(clusterName); <line3> if (clusterEntity == null) { <line4> throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName); <line5> } <line6> ClusterCreate clusterConfig = new ClusterCreate(); <line7> clusterConfig.setName(clusterEntity.getName()); <line8> clusterConfig.setAppManager(clusterEntity.getAppManager()); <line9> clusterConfig.setDistro(clusterEntity.getDistro()); <line10> Map<NetTrafficType, List<ClusterNetConfigInfo>> networkConfigInfo = <line11> clusterEntity.getNetworkConfigInfo(); <line12> if (networkConfigInfo != null && !networkConfigInfo.isEmpty()) { <line13> for (NetTrafficType trafficType : networkConfigInfo.keySet()) { <line14> clusterConfig.setHostnamePrefix( <line15> networkConfigInfo.get(trafficType).get(0).getHostnamePrefix()); <line16> break; <line17> } <line18> } <line19> convertClusterConfig(clusterEntity, clusterConfig, needAllocIp); <line20> Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create(); <line21> String manifest = gson.toJson(clusterConfig); <line22> return clusterConfig; <line23> } <line24> } <line25> 	"<line22>    logger.debug(""final cluster spec: "" + manifest);"	task4	
public class A { <line0> public void activate() { <line1> } <line2> } <line3> 	"<line1>    logger.debug(""activate()"");"	task4	
"public class A { <line0> protected static Iterable<Object[]> defineParameters() throws ClassNotFoundException { <line1> initClasses(); <line2> List<Object[]> tests = new ArrayList<>(); <line3> for (Class<? extends IFormattedException> clazz : exceptionClasses) { <line4> Class<? extends IFormattedException> root = <line5> roots.stream() <line6> .filter(c -> c.isAssignableFrom(clazz)) <line7> .findAny() <line8> .orElseThrow(IllegalStateException::new); <line9> final Constructor<?>[] declaredConstructors = clazz.getDeclaredConstructors(); <line10> for (Constructor<?> ctor : declaredConstructors) { <line11> tests.add( <line12> new Object[] { <line13> clazz.getSimpleName() <line14> + "".<init>"" <line15> + Stream.of(ctor.getParameterTypes()) <line16> .map(Class::getSimpleName) <line17> .collect(Collectors.toList()), <line18> ctor, <line19> root <line20> }); <line21> } <line22> int methods = 0; <line23> for (Method m : clazz.getDeclaredMethods()) { <line24> if ((m.getModifiers() & PUBLIC_STATIC) == PUBLIC_STATIC) { <line25> methods++; <line26> tests.add( <line27> new Object[] { <line28> clazz.getSimpleName() <line29> + ""."" <line30> + m.getName() <line31> + Stream.of(m.getParameterTypes()) <line32> .map(Class::getSimpleName) <line33> .collect(Collectors.toList()), <line34> m, <line35> root <line36> }); <line37> } <line38> } <line39> } <line40> return tests; <line41> } <line42> } <line43> "	"<line39>      LOGGER.info(""discovered {} ctors, {} methods for class {}"",declaredConstructors.length,methods,clazz);"	task4	
"public class A { <line0> @SuppressWarnings({""unchecked""}) <line1> void execute(final HttpTransactionContext transactionCtx) throws IOException { <line2> try { <line3> transactionCtx <line4> .getConnection() <line5> .write(transactionCtx, createWriteCompletionHandler(transactionCtx.future)); <line6> } catch (Exception e) { <line7> if (e instanceof RuntimeException) { <line8> throw (RuntimeException) e; <line9> } else if (e instanceof IOException) { <line10> throw (IOException) e; <line11> } <line12> if (LOGGER.isWarnEnabled()) { <line13> } <line14> } <line15> } <line16> } <line17> "	<line13>        LOGGER.warn(e.toString(), e);	task4	
"public class A { <line0> @Post(path = ""admin.api/notices"", subscribeToken = ""csrf"") <line1> @Auth(roles = ""admin"") <line2> public Boundary postNotice() throws InvalidParamException { <line3> NoticesEntity entity = HttpUtil.parseJson(getRequest(), NoticesEntity.class); <line4> entity = NoticesLogic.get().insertNotice(entity); <line5> MessageResult result = <line6> new MessageResult( <line7> MessageStatus.Success, <line8> HttpStatus.SC_200_OK, <line9> getResource(""message.success.insert""), <line10> entity.getNo().toString()); <line11> return send(result); <line12> } <line13> } <line14> "	"<line3>    LOG.trace(""postNotice"");"	task4	
"public class A { <line0> @Override <line1> public CodegenOperation fromOperation( <line2> String path, String httpMethod, Operation operation, List<Server> servers) { <line3> Map<String, Schema> definitions = ModelUtils.getSchemas(this.openAPI); <line4> CodegenOperation op = super.fromOperation(path, httpMethod, operation, servers); <line5> if (op.vendorExtensions.containsKey(""x-bash-codegen-description"")) { <line6> String bash_description = (String) op.vendorExtensions.get(""x-bash-codegen-description""); <line7> op.vendorExtensions.put(""x-bash-codegen-description"", escapeText(bash_description)); <line8> } <line9> if (op.vendorExtensions.containsKey(""x-code-samples"")) { <line10> List codesamples = (List) op.vendorExtensions.get(""x-code-samples""); <line11> for (Object codesample : codesamples) { <line12> if (codesample instanceof ObjectNode) { <line13> ObjectNode codesample_object = (ObjectNode) codesample; <line14> if ((codesample_object.get(""lang"").asText()).equals(""Shell"")) { <line15> op.vendorExtensions.put( <line16> ""x-bash-codegen-sample"", <line17> escapeUnsafeCharacters(codesample_object.get(""source"").asText())); <line18> } <line19> } <line20> } <line21> } <line22> for (CodegenParameter p : op.bodyParams) { <line23> if (p.dataType != null && definitions.get(p.dataType) != null) { <line24> if (getConsumesInfo(this.openAPI, operation) != null <line25> && getConsumesInfo(this.openAPI, operation).contains(""application/json"") <line26> && definitions.get(p.dataType).getExample() != null) { <line27> ObjectMapper mapper = new ObjectMapper(); <line28> try { <line29> p.vendorExtensions.put( <line30> ""x-codegen-body-example"", <line31> mapper <line32> .writerWithDefaultPrettyPrinter() <line33> .writeValueAsString(definitions.get(p.dataType).getExample())); <line34> } catch (JsonProcessingException e) { <line35> } <line36> } else { <line37> p.vendorExtensions.put( <line38> ""x-codegen-body-example"", definitions.get(p.dataType).getExample()); <line39> } <line40> } <line41> } <line42> return op; <line43> } <line44> } <line45> "	<line35>            LOGGER.warn(e.getMessage(), e);	task4	
"public class A { <line0> @Override <line1> public CAS readCas(TrainingDocument aDocument) throws IOException { <line2> synchronized (lock) { <line3> File annotationFolder = getAutomationFolder(aDocument); <line4> String file = aDocument.getName() + "".ser""; <line5> try { <line6> File serializedCasFile = new File(annotationFolder, file); <line7> if (!serializedCasFile.exists()) { <line8> throw new FileNotFoundException( <line9> ""Annotation document of  Training document "" <line10> + ""["" <line11> + aDocument.getName() <line12> + ""] ("" <line13> + aDocument.getId() <line14> + "") not found in project["" <line15> + aDocument.getProject().getName() <line16> + ""] ("" <line17> + aDocument.getProject().getId() <line18> + "")""); <line19> } <line20> CAS cas = CasCreationUtils.createCas((TypeSystemDescription) null, null, null); <line21> CasPersistenceUtils.readSerializedCas(cas, serializedCasFile); <line22> analyzeAndRepair(aDocument, cas); <line23> return cas; <line24> } catch (UIMAException e) { <line25> throw new DataRetrievalFailureException(""Unable to parse annotation"", e); <line26> } <line27> } <line28> } <line29> } <line30> "	"<line2>    log.debug(""Reading CAs for Automation document [{}] ({}) in project [{}] ({})"",aDocument.getName(),aDocument.getId(),aDocument.getProject().getName(),aDocument.getProject().getId());"	task4	
public class A { <line0> @Override <line1> public PubAnnotationProviderTraits readTraits(DocumentRepository aDocumentRepository) { <line2> PubAnnotationProviderTraits traits = null; <line3> try { <line4> traits = <line5> fromJsonString(PubAnnotationProviderTraits.class, aDocumentRepository.getProperties()); <line6> } catch (IOException e) { <line7> } <line8> if (traits == null) { <line9> traits = new PubAnnotationProviderTraits(); <line10> } <line11> return traits; <line12> } <line13> } <line14> 	"<line7>      log.error(""Error while reading traits"", e);"	task4	
"public class A { <line0> @Override <line1> public Map<String, ByteBuffer> getAllFiles() throws IOException { <line2> Map<String, ByteBuffer> allFiles = new HashMap<>(); <line3> String base = templateDir.getCanonicalPath(); <line4> for (File file : <line5> FileUtils.listFiles(templateDir, new RegexFileFilter(""^(?!\\.).*""), TrueFileFilter.TRUE)) { <line6> byte[] byteArray = IOUtils.toByteArray(new FileInputStream(file)); <line7> String filePath = file.getCanonicalPath().substring(base.length() + 1); <line8> allFiles.put(filePath, ByteBuffer.wrap(byteArray)); <line9> } <line10> return allFiles; <line11> } <line12> } <line13> "	"<line8>      LOGGER.debug(""File's own path: {}"", filePath);"	task4	
"public class A { <line0> @Modified <line1> public void modify(Map<String, Object> properties) { <line2> Object portletName = properties.get(""javax.portlet.name""); <line3> } <line4> } <line5> "	"<line3>    log.info(""Portlet [""+ (portletName != null ? portletName : this.getClass().getSimpleName())+ ""] has been MODIFIED."");"	task4	
public class A { <line0> private void deleteMailbox(MailboxSession mailboxSession, MailboxPath mailboxPath) <line1> throws MailboxException { <line2> try { <line3> mailboxManager.deleteMailbox(mailboxPath, mailboxSession); <line4> } catch (MailboxNotFoundException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOGGER.info(""Attempt to delete mailbox {} for user {} that does not exists"",mailboxPath.getName(),mailboxPath.getUser());"	task4	
public class A { <line0> @Override <line1> public void objectInserted(ObjectInsertedEvent event) { <line2> } <line3> } <line4> 	<line2>    log.debug(event);	task4	
"public class A { <line0> @Override <line1> void executeWithSolrClient(SolrClient solrClient) <line2> throws SolrServerException, IOException, InterruptedException { <line3> Iterable<Result> iterable = <line4> ResultIterable.resultIterable(catalogFramework, getGazetteerFilter()); <line5> console.println(""Starting sync...""); <line6> long counter = 0; <line7> Instant start = Instant.now(); <line8> for (List<Result> results : Iterables.partition(iterable, PARTITION_SIZE)) { <line9> if (Thread.interrupted()) { <line10> printErrorMessage(""Catalog sync interrupted, exiting""); <line11> Thread.currentThread().interrupt(); <line12> throw new InterruptedException(); <line13> } <line14> solrClient.add( <line15> results.stream() <line16> .map(Result::getMetacard) <line17> .map(CatalogGazetteerForwardingPlugin::convert) <line18> .collect(Collectors.toList())); <line19> counter += results.size(); <line20> } <line21> printSuccessMessage( <line22> String.format( <line23> ""%nComplete. Processed %d items in %s%n"", <line24> counter, Duration.between(start, Instant.now()))); <line25> } <line26> } <line27> "	"<line10>        LOGGER.info(""Catalog sync interrupted early, exiting"");"	task4	
public class A { <line0> public ConnectionConsumer createConnectionConsumer( <line1> final Destination destination, final ServerSessionPool pool, final int maxMessages) <line2> throws JMSException { <line3> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line4> } <line5> throw new IllegalStateException(ISE); <line6> } <line7> } <line8> 	"<line4>      ActiveMQRALogger.LOGGER.trace(""createConnectionConsumer("" + destination + "", "" + pool + "", "" + maxMessages + "")"");"	task4	
"public class A { <line0> @Override <line1> public ObjectField fetchByODI_N(long objectDefinitionId, String name, boolean useFinderCache) { <line2> name = Objects.toString(name, """"); <line3> Object[] finderArgs = null; <line4> if (useFinderCache) { <line5> finderArgs = new Object[] {objectDefinitionId, name}; <line6> } <line7> Object result = null; <line8> if (useFinderCache) { <line9> result = finderCache.getResult(_finderPathFetchByODI_N, finderArgs); <line10> } <line11> if (result instanceof ObjectField) { <line12> ObjectField objectField = (ObjectField) result; <line13> if ((objectDefinitionId != objectField.getObjectDefinitionId()) <line14> || !Objects.equals(name, objectField.getName())) { <line15> result = null; <line16> } <line17> } <line18> if (result == null) { <line19> StringBundler sb = new StringBundler(4); <line20> sb.append(_SQL_SELECT_OBJECTFIELD_WHERE); <line21> sb.append(_FINDER_COLUMN_ODI_N_OBJECTDEFINITIONID_2); <line22> boolean bindName = false; <line23> if (name.isEmpty()) { <line24> sb.append(_FINDER_COLUMN_ODI_N_NAME_3); <line25> } else { <line26> bindName = true; <line27> sb.append(_FINDER_COLUMN_ODI_N_NAME_2); <line28> } <line29> String sql = sb.toString(); <line30> Session session = null; <line31> try { <line32> session = openSession(); <line33> Query query = session.createQuery(sql); <line34> QueryPos queryPos = QueryPos.getInstance(query); <line35> queryPos.add(objectDefinitionId); <line36> if (bindName) { <line37> queryPos.add(name); <line38> } <line39> List<ObjectField> list = query.list(); <line40> if (list.isEmpty()) { <line41> if (useFinderCache) { <line42> finderCache.putResult(_finderPathFetchByODI_N, finderArgs, list); <line43> } <line44> } else { <line45> if (list.size() > 1) { <line46> Collections.sort(list, Collections.reverseOrder()); <line47> if (log.isWarnEnabled()) { <line48> if (!useFinderCache) { <line49> finderArgs = new Object[] {objectDefinitionId, name}; <line50> } <line51> } <line52> } <line53> ObjectField objectField = list.get(0); <line54> result = objectField; <line55> cacheResult(objectField); <line56> } <line57> } catch (Exception exception) { <line58> throw processException(exception); <line59> } finally { <line60> closeSession(session); <line61> } <line62> } <line63> if (result instanceof List<?>) { <line64> return null; <line65> } else { <line66> return (ObjectField) result; <line67> } <line68> } <line69> } <line70> "	"<line51>              log.warn(""ObjectFieldPersistenceImpl.fetchByODI_N(long, String, boolean) with parameters (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
"public class A { <line0> @Override <line1> public boolean hasEquipmentCore() { <line2> if (queryCatalog.containsKey(MODEL_PROFILES)) { <line3> PropertyBags r = namedQuery(MODEL_PROFILES); <line4> if (r == null) { <line5> return false; <line6> } <line7> for (PropertyBag m : r) { <line8> String p = m.get(PROFILE); <line9> if (p != null && p.contains(""/EquipmentCore/"")) { <line10> if (LOG.isInfoEnabled()) { <line11> } <line12> return true; <line13> } <line14> } <line15> return false; <line16> } <line17> return true; <line18> } <line19> } <line20> "	"<line11>            LOG.info(""Model contains Equipment Core data profile in model {}"",m.get(CgmesNames.FULL_MODEL));"	task4	
"public class A { <line0> public static void fileProcessPattern() throws Exception { <line1> Pipeline p = Pipeline.create(); <line2> p.apply( <line3> FileIO.match() <line4> .filepattern(""..."") <line5> .continuously( <line6> Duration.standardSeconds(30), <line7> Watch.Growth.afterTimeSinceNewOutput(Duration.standardHours(1)))); <line8> p.apply( <line9> TextIO.read() <line10> .from(""<path-to-files>/*"") <line11> .watchForNewFiles( <line12> Duration.standardMinutes(1), <line13> Watch.Growth.afterTimeSinceNewOutput(Duration.standardHours(1)))); <line14> p.apply(FileIO.match().filepattern(""hdfs://path/to/*.gz"")) <line15> .apply(FileIO.readMatches().withCompression(Compression.GZIP)) <line16> .apply( <line17> ParDo.of( <line18> new DoFn<FileIO.ReadableFile, String>() { <line19> @ProcessElement <line20> public void process(@Element FileIO.ReadableFile file) { <line21> } <line22> })); <line23> } <line24> } <line25> "	"<line21>                    LOG.info(""File Metadata resourceId is {} "", file.getMetadata().resourceId());"	task4	
public class A { <line0> @Override <line1> public QueueSet subscribeToQueue(String publisherQueuePath, String subscriberQueuePath) { <line2> publisherQueuePath = normalizeQueuePath(publisherQueuePath); <line3> UUID publisherQueueId = getQueueId(publisherQueuePath); <line4> subscriberQueuePath = normalizeQueuePath(subscriberQueuePath); <line5> UUID subscriberQueueId = getQueueId(subscriberQueuePath); <line6> UUID timestampUuid = newTimeUUID(); <line7> long timestamp = getTimestampInMicros(timestampUuid); <line8> Mutator<ByteBuffer> batch = <line9> CountingMutator.createFlushingMutator(cass.getApplicationKeyspace(applicationId), be); <line10> batchSubscribeToQueue( <line11> batch, <line12> publisherQueuePath, <line13> publisherQueueId, <line14> subscriberQueuePath, <line15> subscriberQueueId, <line16> timestamp); <line17> try { <line18> Queue queue = getQueue(subscriberQueuePath, subscriberQueueId); <line19> if (queue != null) { <line20> batchUpdateQueuePropertiesIndexes( <line21> batch, <line22> publisherQueueId, <line23> subscriberQueuePath, <line24> subscriberQueueId, <line25> queue.getProperties(), <line26> timestampUuid); <line27> } <line28> } catch (Exception e) { <line29> } <line30> batchExecute(batch, RETRY_COUNT); <line31> return new QueueSet().addQueue(subscriberQueuePath, subscriberQueueId); <line32> } <line33> } <line34> 	"<line29>      logger.error(""Unable to update index"", e);"	task4	
public class A { <line0> private Resources findDriverResources( <line1> Collection<WorkflowNode> nodes, Map<String, Resources> runnablesResources) { <line2> Resources resources = new Resources(); <line3> for (WorkflowNode node : nodes) { <line4> switch (node.getType()) { <line5> case ACTION: <line6> String programName = ((WorkflowActionNode) node).getProgram().getProgramName(); <line7> Resources runnableResources = runnablesResources.get(programName); <line8> if (runnableResources != null) { <line9> resources = maxResources(resources, runnableResources); <line10> } <line11> break; <line12> case FORK: <line13> Resources forkResources = <line14> ((WorkflowForkNode) node) <line15> .getBranches().stream() <line16> .map(branches -> findDriverResources(branches, runnablesResources)) <line17> .reduce(this::mergeForkResources) <line18> .orElse(resources); <line19> resources = maxResources(resources, forkResources); <line20> break; <line21> case CONDITION: <line22> Resources branchesResources = <line23> maxResources( <line24> findDriverResources( <line25> ((WorkflowConditionNode) node).getIfBranch(), runnablesResources), <line26> findDriverResources( <line27> ((WorkflowConditionNode) node).getElseBranch(), runnablesResources)); <line28> resources = maxResources(resources, branchesResources); <line29> break; <line30> default: <line31> } <line32> } <line33> return resources; <line34> } <line35> } <line36> 	"<line31>          LOG.warn(""Ignoring unsupported Workflow node type {}"", node.getType());"	task4	
"public class A { <line0> private void handleResponse(final String correlationId, final Message message) { <line1> final var resultHandler = handlers.remove(correlationId); <line2> if (resultHandler == null) { <line3> } else { <line4> try { <line5> final int status = message.getIntProperty(MessageHelper.APP_PROPERTY_STATUS); <line6> if (StatusCodeMapper.isSuccessful(status)) { <line7> handleSuccess(message, status, resultHandler.one(), resultHandler.two()); <line8> } else { <line9> handleFailure(message, status, resultHandler.one()); <line10> } <line11> } catch (JMSException e) { <line12> resultHandler <line13> .one() <line14> .handle( <line15> Future.failedFuture( <line16> new ServerErrorException( <line17> HttpURLConnection.HTTP_INTERNAL_ERROR, <line18> ""server returned malformed response: no status code""))); <line19> } <line20> } <line21> } <line22> } <line23> "	"<line3>      LOG.debug(""discarding unexpected response [correlation-id: {}]"", correlationId);"	task4	
"public class A { <line0> public static void deleteCommercePriceListAccountGroupRelsByCommercePriceListId( <line1> HttpPrincipal httpPrincipal, long commercePriceListId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommercePriceListCommerceAccountGroupRelServiceUtil.class, <line7> ""deleteCommercePriceListAccountGroupRelsByCommercePriceListId"", <line8> _deleteCommercePriceListAccountGroupRelsByCommercePriceListIdParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commercePriceListId); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public void skipTo(long pos) { <line2> checkLife(); <line3> try { <line4> boolean available = rs.absolute((int) pos + 1); <line5> if (available) { <line6> next = fetchCurrent(); <line7> eof = false; <line8> this.pos = pos; <line9> } else { <line10> next = null; <line11> eof = true; <line12> this.pos = -1; <line13> } <line14> } catch (SQLException e) { <line15> } <line16> } <line17> } <line18> 	"<line15>      logger.error(""Error skipping to: "" + pos + "": "" + e.getMessage(), e);"	task4	
public class A { <line0> @Override <line1> public void onData(Stream stream, DataFrame frame, Callback callback) { <line2> byte[] bytes = new byte[frame.getData().remaining()]; <line3> frame.getData().get(bytes); <line4> response = new String(bytes); <line5> doAssert(response); <line6> callback.succeeded(); <line7> } <line8> } <line9> 	"<line5>    LOG.info(""---------------- Response with content received from '{}' ----------------\n""+ ""---------------- START Response-Body ----------------\n""+ ""{}\n""+ ""---------------- END Response-Body ----------------"",request.getURI(),response);"	task4	
"public class A { <line0> @POST <line1> @Path(""{noteId}/paragraph/{paragraphId}/move/{newIndex}"") <line2> @ZeppelinApi <line3> public Response moveParagraph( <line4> @PathParam(""noteId"") String noteId, <line5> @PathParam(""paragraphId"") String paragraphId, <line6> @PathParam(""newIndex"") String newIndex) <line7> throws IOException { <line8> notebookService.moveParagraph( <line9> noteId, <line10> paragraphId, <line11> Integer.parseInt(newIndex), <line12> getServiceContext(), <line13> new RestServiceCallback<Paragraph>() { <line14> @Override <line15> public void onSuccess(Paragraph result, ServiceContext context) throws IOException { <line16> notebookServer.broadcastNote(result.getNote()); <line17> } <line18> }); <line19> return new JsonResponse<>(Status.OK, """").build(); <line20> } <line21> } <line22> "	"<line8>    LOGGER.info(""Move paragraph {} {} {}"", noteId, paragraphId, newIndex);"	task4	
"public class A { <line0> public void sendWindowChange(int columns, int lines, int height, int width) throws IOException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> setPtyColumns(columns); <line4> setPtyLines(lines); <line5> setPtyHeight(height); <line6> setPtyWidth(width); <line7> Session session = getSession(); <line8> Buffer buffer = session.createBuffer(SshConstants.SSH_MSG_CHANNEL_REQUEST, Long.SIZE); <line9> buffer.putInt(getRecipient()); <line10> buffer.putString(""window-change""); <line11> buffer.putBoolean(false); <line12> buffer.putInt(getPtyColumns()); <line13> buffer.putInt(getPtyLines()); <line14> buffer.putInt(getPtyHeight()); <line15> buffer.putInt(getPtyWidth()); <line16> writePacket(buffer); <line17> } <line18> } <line19> "	"<line2>      log.debug(""sendWindowChange({}) cols={}, lines={}, height={}, width={}"",this,columns,lines,height,width);"	task4	
"public class A { <line0> public static com.liferay.mobile.device.rules.model.MDRRuleGroupInstance updateRuleGroupInstance( <line1> HttpPrincipal httpPrincipal, long ruleGroupInstanceId, int priority) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> MDRRuleGroupInstanceServiceUtil.class, <line7> ""updateRuleGroupInstance"", <line8> _updateRuleGroupInstanceParameterTypes5); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, ruleGroupInstanceId, priority); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.mobile.device.rules.model.MDRRuleGroupInstance) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static void killCmd(String[] cmd, Signal signal, CommandExecutorService executorService) { <line1> Map<String, Pid> pids = <line2> executorService.getPids(cmd).entrySet().stream() <line3> .filter(entry -> entry.getKey().equals(String.join("" "", cmd))) <line4> .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); <line5> for (Pid pid : pids.values()) { <line6> if (!executorService.stop(pid, signal)) { <line7> } <line8> } <line9> } <line10> } <line11> "	"<line7>        logger.warn(""Failed to stop command with pid {}"", pid.getPid());"	task4	
public class A { <line0> @Override <line1> public IQ handle(IQ iq) { <line2> IQ response = IQ.createResultIQ(iq); <line3> String orderId = unmarshalOrderId(iq); <line4> try { <line5> String senderId = <line6> IntercomponentUtil.getSender( <line7> iq.getFrom().toBareJID(), SystemConstants.XMPP_SERVER_NAME_PREFIX); <line8> RemoteFacade.getInstance().closeOrderAtRemoteRequester(senderId, orderId); <line9> } catch (Exception e) { <line10> XmppExceptionToErrorConditionTranslator.updateErrorCondition(response, e); <line11> } <line12> return response; <line13> } <line14> } <line15> 	<line2>    LOGGER.debug(String.format(Messages.Log.RECEIVING_REMOTE_REQUEST_S, iq.getID()));	task4	
"public class A { <line0> public synchronized void registerSimpleCommand(PluginContainer plugin, Object simpleCommand) { <line1> Objects.requireNonNull(simpleCommand, ""simpleCommand""); <line2> Objects.requireNonNull(plugin, ""plugin""); <line3> checkClosed(); <line4> for (Method method : simpleCommand.getClass().getDeclaredMethods()) { <line5> org.cloudburstmc.server.command.simple.Command def = <line6> method.getAnnotation(org.cloudburstmc.server.command.simple.Command.class); <line7> if (def != null) { <line8> String cmd = def.name(); <line9> NAME_MATCHER.reset(cmd); <line10> if (!NAME_MATCHER.matches()) { <line11> continue; <line12> } <line13> String perms = """"; <line14> CommandPermission perm = method.getAnnotation(CommandPermission.class); <line15> if (perm != null) { <line16> perms = perm.value(); <line17> } <line18> List<CommandParameter[]> params = new ArrayList<>(); <line19> CommandParameters parameters = method.getAnnotation(CommandParameters.class); <line20> if (parameters != null) { <line21> for (Parameters p : parameters.parameters()) { <line22> List<CommandParameter> p2 = new ArrayList<>(); <line23> for (Parameter parameter : p.parameters()) { <line24> p2.add( <line25> new CommandParameter(parameter.name(), parameter.type(), parameter.optional())); <line26> } <line27> params.add(p2.toArray(new CommandParameter[0])); <line28> } <line29> } <line30> SimpleCommand sc = <line31> new SimpleCommand( <line32> simpleCommand, <line33> method, <line34> cmd, <line35> def.description(), <line36> def.usageMessage(), <line37> def.aliases(), <line38> perms, <line39> params); <line40> Arguments args = method.getAnnotation(Arguments.class); <line41> if (args != null) { <line42> sc.setMaxArgs(args.max()); <line43> sc.setMinArgs(args.min()); <line44> } <line45> if (method.isAnnotationPresent(ForbidConsole.class)) { <line46> sc.setForbidConsole(true); <line47> } <line48> register(plugin, sc); <line49> } <line50> } <line51> } <line52> } <line53> "	"<line11>          log.error(""Invalid Command name in SimpleCommand: {}, skipping"", cmd);"	task4	
"public class A { <line0> @Override <line1> public Representation get() { <line2> StringRepresentation presentation = null; <line3> try { <line4> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line5> String instanceName = (String) getRequest().getAttributes().get(""instanceName""); <line6> String resourceGroup = (String) getRequest().getAttributes().get(""resourceName""); <line7> presentation = <line8> getInstanceCurrentStateRepresentation(clusterName, instanceName, resourceGroup); <line9> } catch (Exception e) { <line10> String error = ClusterRepresentationUtil.getErrorAsJsonStringFromException(e); <line11> presentation = new StringRepresentation(error, MediaType.APPLICATION_JSON); <line12> } <line13> return presentation; <line14> } <line15> } <line16> "	"<line12>      LOG.error("""", e);"	task4	
public class A { <line0> private void populateRegionSubRegions( <line1> RegionSubRegionSnapshot parentSnapShot, Set regions, InternalCache cache) { <line2> if (this.cancelled) { <line3> return; <line4> } <line5> for (Object region : regions) { <line6> Region subRegion = (Region) region; <line7> try { <line8> RegionSubRegionSnapshot subRegionSnapShot = new RegionSubRegionSnapshot(subRegion); <line9> parentSnapShot.addSubRegion(subRegionSnapShot); <line10> Set subRegions = subRegion.subregions(false); <line11> populateRegionSubRegions(subRegionSnapShot, subRegions, cache); <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> } <line17> 	"<line13>        logger.debug(""Failed to create snapshot for region: {}. Continuing with next region."",subRegion.getFullPath(),e);"	task4	
"public class A { <line0> @Override <line1> public Tuple exec(Tuple input) throws IOException { <line2> if (input == null || input.size() == 0) { <line3> return null; <line4> } <line5> try { <line6> DataBag categReal = (DataBag) input.get(0); <line7> DataBag categClassif = (DataBag) input.get(1); <line8> List<String> real = new ArrayList<String>(); <line9> List<String> classif = new ArrayList<String>(); <line10> for (Tuple t : categReal) { <line11> real.add((String) t.get(0)); <line12> } <line13> for (Tuple t : categClassif) { <line14> classif.add((String) t.get(0)); <line15> } <line16> int is = intersectSize(real, classif); <line17> double acc = (double) is / (double) sumSize(real, classif); <line18> double p = (double) is / (double) classif.size(); <line19> double r = (double) is / (double) real.size(); <line20> Double f1 = p + r != 0 ? 2 * p * r / (p + r) : null; <line21> double hl = sumSize(subs(real, classif), subs(classif, real)); <line22> int zol = is == real.size() && is == classif.size() ? 1 : 0; <line23> Object[] obj = new Object[] {acc, p, r, f1, hl, zol}; <line24> return TupleFactory.getInstance().newTuple(Arrays.asList(obj)); <line25> } catch (Exception e) { <line26> throw new IOException( <line27> ""Caught exception processing input row:\n"" + StackTraceExtractor.getStackTrace(e)); <line28> } <line29> } <line30> } <line31> "	"<line26>      logger.error(""Error in processing input row:"", e);"	task4	
"public class A { <line0> @Override <line1> TupleValue encodeFromRawInternal(Object o, Optional<CassandraOptions> cassandraOptions) { <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> Validator.validateTrue( <line5> Tuple2.class.isAssignableFrom(o.getClass()), <line6> ""The class of object %s to encode should be Tuple2"", <line7> o); <line8> return encodeFromJava((Tuple2<A, B>) o, cassandraOptions); <line9> } <line10> } <line11> "	"<line3>      LOGGER.trace(format(""Encode raw '%s' tuple2 object %s"", fieldName, o));"	task4	
public class A { <line0> @Override <line1> public void writeElement(SBMLObjectForXML xmlObject, Object sbmlElementToWrite) { <line2> super.writeElement(xmlObject, sbmlElementToWrite); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.debug(""writeElement: "" + sbmlElementToWrite.getClass().getSimpleName());"	task4	
"public class A { <line0> public static String extractKey(String documentURL) throws DataServiceFault { <line1> URI documentURI; <line2> try { <line3> documentURI = new URI(documentURL); <line4> } catch (URISyntaxException e) { <line5> String message = ""Document URL Syntax error:"" + documentURL; <line6> throw new DataServiceFault(e, message); <line7> } <line8> String extractedQuery = documentURI.getQuery(); <line9> if (extractedQuery == null) { <line10> return getKeyForNewSpreadsheetURLFormat(documentURL); <line11> } <line12> int i1 = extractedQuery.lastIndexOf(""key=""); <line13> int i2 = extractedQuery.indexOf(""&"", i1); <line14> if (i1 == -1) { <line15> return getKeyForNewSpreadsheetURLFormat(documentURL); <line16> } else if (i2 < 0) { <line17> return extractedQuery.substring(i1 + 4); <line18> } else { <line19> return extractedQuery.substring(i1 + 4, i2); <line20> } <line21> } <line22> } <line23> "	<line6>      log.warn(message, e);	task4	
"public class A { <line0> @Override <line1> protected void afterPropertiesSet() { <line2> super.afterPropertiesSet(); <line3> try { <line4> PartnerConnection partnerConnection = getPartnerConnection(); <line5> ConnectorConfig connectorConfig = partnerConnection.getConfig(); <line6> Map<String, Object> options = new HashMap<>(); <line7> options.put(ClientTransport.MAX_NETWORK_DELAY_OPTION, _transportTimeout * 6000); <line8> _httpClient.start(); <line9> URL url = new URL(connectorConfig.getServiceEndpoint()); <line10> _bayeuxClient = <line11> new BayeuxClient( <line12> StringBundler.concat(url.getProtocol(), ""://"", url.getHost(), ""/cometd/37.0""), <line13> new SalesforceTransport(connectorConfig.getSessionId(), options, _httpClient)); <line14> ClientSessionChannel handshakeClientSessionChannel = <line15> _bayeuxClient.getChannel(Channel.META_HANDSHAKE); <line16> handshakeClientSessionChannel.addListener(new SalesforceMessageListener()); <line17> ClientSessionChannel connectClientSessionChannel = <line18> _bayeuxClient.getChannel(Channel.META_CONNECT); <line19> connectClientSessionChannel.addListener(new SalesforceMessageListener()); <line20> ClientSessionChannel subscribeClientSessionChannel = <line21> _bayeuxClient.getChannel(Channel.META_SUBSCRIBE); <line22> subscribeClientSessionChannel.addListener(new SalesforceMessageListener()); <line23> } catch (Exception exception) { <line24> } <line25> } <line26> } <line27> "	<line24>      log.error(exception.getMessage(), exception);	task4	
public class A { <line0> private synchronized void nextGeneration() throws IOException { <line1> close(); <line2> processFile = new File(rootDir, prefix + IN_PROCESS.getFileNameSuffix()); <line3> writer = newWriter(processFile, UTF_8); <line4> } <line5> } <line6> 	"<line4>    LOG.info(""Created new process file and writer over {} "", processFile.getAbsolutePath());"	task4	
"public class A { <line0> @Override <line1> public void service(TupleResultBuilder builder, String xslPath) <line2> throws RepositoryException, QueryEvaluationException, MalformedQueryException, <line3> QueryResultHandlerException { <line4> builder.transform(xslPath, ""summary.xsl""); <line5> builder.start(""id"", ""description"", ""location"", ""server"", ""size"", ""contexts""); <line6> builder.link(Arrays.asList(INFO)); <line7> try (RepositoryConnection con = repository.getConnection()) { <line8> String size = null; <line9> String numContexts = null; <line10> try { <line11> List<Future<String>> futures = getRepositoryStatistics(con); <line12> size = getResult(""repository size."", futures.get(0)); <line13> numContexts = getResult(""labeled contexts."", futures.get(1)); <line14> } catch (InterruptedException e) { <line15> } <line16> builder.result( <line17> info.getId(), info.getDescription(), info.getLocation(), getServer(), size, numContexts); <line18> builder.end(); <line19> } <line20> } <line21> } <line22> "	"<line15>        LOGGER.warn(""Interrupted while requesting repository statistics."", e);"	task4	
public class A { <line0> @Override <line1> public void setFloat(final String name, final float value) throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> ((MapMessage) message).setFloat(name, value); <line5> } <line6> } <line7> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""setFloat("" + name + "", "" + value + "")"");"	task4	
public class A { <line0> public static JoyQueueCode convertProduceCode(int version, JoyQueueCode code) { <line1> switch (code) { <line2> case FW_TOPIC_NOT_EXIST: <line3> { <line4> return JoyQueueCode.FW_TOPIC_NOT_EXIST; <line5> } <line6> case FW_PRODUCE_MESSAGE_BROKER_NOT_LEADER: <line7> case FW_TOPIC_NO_PARTITIONGROUP: <line8> { <line9> return JoyQueueCode.FW_PRODUCE_MESSAGE_BROKER_NOT_LEADER; <line10> } <line11> case FW_PUT_MESSAGE_TOPIC_NOT_WRITE: <line12> { <line13> if (version == JoyQueueHeader.VERSION_V1) { <line14> return JoyQueueCode.CN_NO_PERMISSION; <line15> } <line16> return JoyQueueCode.FW_PUT_MESSAGE_TOPIC_NOT_WRITE; <line17> } <line18> case FW_PRODUCER_NOT_EXISTS: <line19> { <line20> return JoyQueueCode.FW_PRODUCER_NOT_EXISTS; <line21> } <line22> case FW_BROKER_NOT_WRITABLE: <line23> { <line24> return JoyQueueCode.FW_BROKER_NOT_WRITABLE; <line25> } <line26> default: <line27> { <line28> return JoyQueueCode.CN_NO_PERMISSION; <line29> } <line30> } <line31> } <line32> } <line33> 	"<line28>          logger.warn(""unknown produce code {}"", code);"	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""synthetic-access"") <line2> protected void initChannel(SocketChannel ch) throws Exception { <line3> IoServiceEventListener listener = getIoServiceEventListener(); <line4> SocketAddress local = ch.localAddress(); <line5> SocketAddress remote = ch.remoteAddress(); <line6> AttributeRepository context = ch.hasAttr(CONTEXT_KEY) ? ch.attr(CONTEXT_KEY).get() : null; <line7> try { <line8> if (listener != null) { <line9> try { <line10> listener.connectionEstablished(NettyIoConnector.this, local, context, remote); <line11> } catch (Exception e) { <line12> ch.close(); <line13> throw e; <line14> } <line15> } <line16> @SuppressWarnings(""resource"") <line17> NettyIoSession session = new NettyIoSession(NettyIoConnector.this, handler, null); <line18> if (context != null) { <line19> session.setAttribute(AttributeRepository.class, context); <line20> } <line21> ChannelPipeline p = ch.pipeline(); <line22> p.addLast(new LoggingHandler(LogLevel.INFO)); <line23> p.addLast(session.adapter); <line24> } catch (Exception e) { <line25> if (listener != null) { <line26> try { <line27> listener.abortEstablishedConnection(NettyIoConnector.this, local, context, remote, e); <line28> } catch (Exception exc) { <line29> if (log.isDebugEnabled()) { <line30> } <line31> } <line32> } <line33> throw e; <line34> } <line35> } <line36> } <line37> "	"<line30>            log.debug(""initChannel("" + ch + "") listener="" + listener + "" ignoring abort event exception"",exc);"	task4	
public class A { <line0> public void samplePoint(Integer x, Integer y) { <line1> } <line2> } <line3> 	"<line1>    log.info(""Sample point called "" + x + "" "" + y);"	task4	
"public class A { <line0> @VisibleForTesting <line1> static CPUResource getDefaultCpus(final Configuration configuration) { <line2> int fallback = configuration.getInteger(YarnConfigOptions.VCORES); <line3> double cpuCoresDouble = <line4> TaskExecutorProcessUtils.getCpuCoresWithFallback(configuration, fallback) <line5> .getValue() <line6> .doubleValue(); <line7> @SuppressWarnings(""NumericCastThatLosesPrecision"") <line8> long cpuCoresLong = Math.max((long) Math.ceil(cpuCoresDouble), 1L); <line9> if (cpuCoresLong != cpuCoresDouble) { <line10> } <line11> if (cpuCoresLong > Integer.MAX_VALUE) { <line12> throw new IllegalConfigurationException( <line13> String.format( <line14> ""The amount of cpu cores %d cannot exceed Integer.MAX_VALUE: %d"", <line15> cpuCoresLong, Integer.MAX_VALUE)); <line16> } <line17> return new CPUResource(cpuCoresLong); <line18> } <line19> } <line20> "	"<line10>      LOG.info(""The amount of cpu cores must be a positive integer on Yarn. Rounding {} up to the""+ "" closest positive integer {}."",cpuCoresDouble,cpuCoresLong);"	task4	
public class A { <line0> private int getNextAvailDirInTier( <line1> StorageTierView tierView, long blockSize, String mediumType, boolean skipReview) { <line2> int dirIndex = mTierAliasToLastDirMap.get(tierView.getTierViewAlias()); <line3> List<StorageDirView> dirs = tierView.getDirViews(); <line4> for (int i = 0; i < dirs.size(); i++) { <line5> dirIndex = (dirIndex + 1) % dirs.size(); <line6> StorageDirView dir = dirs.get(dirIndex); <line7> if ((mediumType.equals(BlockStoreLocation.ANY_MEDIUM) <line8> || dir.getMediumType().equals(mediumType)) <line9> && dir.getAvailableBytes() >= blockSize) { <line10> if (skipReview || mReviewer.acceptAllocation(dir)) { <line11> return dir.getDirViewIndex(); <line12> } <line13> } <line14> } <line15> return -1; <line16> } <line17> } <line18> 	"<line13>        LOG.debug(""Allocation to dirIndex {} rejected: {}"", dirIndex, dir.toBlockStoreLocation());"	task4	
public class A { <line0> public static void clearJmxCache() { <line1> if (LOG.isTraceEnabled()) { <line2> } <line3> ScheduledFuture future = fut.get(); <line4> if ((future != null && (!future.isDone() && future.getDelay(TimeUnit.MILLISECONDS) > 100))) { <line5> return; <line6> } <line7> if (stopped.get()) { <line8> return; <line9> } <line10> future = executor.getExecutor().schedule(new JmxCacheBusterRunnable(), 5, TimeUnit.SECONDS); <line11> fut.set(future); <line12> } <line13> } <line14> 	"<line2>      LOG.trace(""clearing JMX Cache"" + StringUtils.stringifyException(new Exception()));"	task4	
"public class A { <line0> @ExceptionHandler(Exception.class) <line1> public ModelAndView handleError(HttpServletRequest req, Exception exception) { <line2> ModelAndView mav = new ModelAndView(); <line3> mav.addObject(""exception"", exception); <line4> mav.setViewName(""00-error""); <line5> return mav; <line6> } <line7> } <line8> "	"<line2>    log.error(""Request: {} raised following exception."", req.getRequestURL(), exception);"	task4	
"public class A { <line0> public CompletableFuture<Void> clearBacklog(String cursorName) { <line1> PersistentSubscription sub = getSubscription(cursorName); <line2> if (sub != null) { <line3> return sub.clearBacklog(); <line4> } <line5> PersistentReplicator repl = (PersistentReplicator) getPersistentReplicator(cursorName); <line6> if (repl != null) { <line7> return repl.clearBacklog(); <line8> } <line9> return FutureUtil.failedFuture(new BrokerServiceException(""Cursor not found"")); <line10> } <line11> } <line12> "	"<line1>    log.info(""[{}] Clearing backlog for cursor {} in the topic."", topic, cursorName);"	task4	
public class A { <line0> private Histogram getHistogram(final String coverageName, final double resX, final double resY) <line1> throws IOException { <line2> RasterHistogramValue histogram = <line3> InternalStatisticsHelper.getDataTypeStatistic( <line4> geowaveStatisticsStore, <line5> RasterHistogramStatistic.STATS_TYPE, <line6> coverageName, <line7> authorizationSPI.getAuthorizations()); <line8> if (histogram != null) { <line9> return histogram.getValue().get(new Resolution(new double[] {resX, resY})); <line10> } else { <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line11>      LOGGER.warn(""Cannot find histogram for coverage '"" + coverageName + ""'"");"	task4	
"public class A { <line0> private void <line1> checkUniqueConstraintByConsumerSystemAndServiceAndProviderSystemIdAndInterfaceAndForeign( <line2> final System consumerSystem, <line3> final ServiceDefinition serviceDefinition, <line4> final long providerSystemId, <line5> final ServiceInterface serviceInterface, <line6> final boolean foreign) { <line7> final Optional<OrchestratorStore> orchestratorStoreOptional = <line8> orchestratorStoreRepository <line9> .findByConsumerSystemAndServiceDefinitionAndProviderSystemIdAndServiceInterfaceAndForeign( <line10> consumerSystem, serviceDefinition, providerSystemId, serviceInterface, foreign); <line11> if (orchestratorStoreOptional.isPresent()) { <line12> throw new InvalidParameterException( <line13> ""OrchestratorStore checkUniqueConstraintByConsumerSystemIdAndServiceIdAndProviderSystemId"" <line14> + "" "" <line15> + VIOLATES_UNIQUE_CONSTRAINT); <line16> } <line17> } <line18> } <line19> "	"<line7>    logger.debug(""checkUniqueConstraintByConsumerSystemIdAndServiceIdAndProviderSystemId started..."");"	task4	
"public class A { <line0> @Override <line1> public UpdateContainer doIt(Workspace workspace) throws CommandException { <line2> TripleStoreUtil util = new TripleStoreUtil(); <line3> try { <line4> util.deleteMappingFromTripleStore(tripleStoreURL, context, mappingURI); <line5> } catch (KarmaException e) { <line6> return new UpdateContainer(new ErrorUpdate(""Error occured while deleting R2RML model!"")); <line7> } <line8> UpdateContainer uc = new UpdateContainer(); <line9> uc.add( <line10> new AbstractUpdate() { <line11> public void generateJson(String prefix, PrintWriter pw, VWorkspace vWorkspace) { <line12> JSONObject outputObject = new JSONObject(); <line13> try { <line14> outputObject.put(JsonKeys.updateType.name(), ""DeleteModel""); <line15> pw.println(outputObject.toString()); <line16> } catch (JSONException e) { <line17> } <line18> } <line19> }); <line20> return uc; <line21> } <line22> } <line23> "	"<line17>              logger.error(""Error occured while generating JSON!"");"	task4	
"public class A { <line0> private void populateItems(final AuthModuleTO authModuleTO, final AuthModule authModule) { <line1> SyncopeClientCompositeException scce = SyncopeClientException.buildComposite(); <line2> SyncopeClientException invalidMapping = <line3> SyncopeClientException.build(ClientExceptionType.InvalidMapping); <line4> SyncopeClientException requiredValuesMissing = <line5> SyncopeClientException.build(ClientExceptionType.RequiredValuesMissing); <line6> authModuleTO <line7> .getItems() <line8> .forEach( <line9> itemTO -> { <line10> if (itemTO == null) { <line11> invalidMapping.getElements().add(""Null "" + ItemTO.class.getSimpleName()); <line12> } else if (itemTO.getIntAttrName() == null) { <line13> requiredValuesMissing.getElements().add(""intAttrName""); <line14> scce.addException(requiredValuesMissing); <line15> } else { <line16> if (!JexlUtils.isExpressionValid( <line17> itemTO.getMandatoryCondition() == null <line18> ? ""false"" <line19> : itemTO.getMandatoryCondition())) { <line20> SyncopeClientException invalidMandatoryCondition = <line21> SyncopeClientException.build(ClientExceptionType.InvalidValues); <line22> invalidMandatoryCondition.getElements().add(itemTO.getMandatoryCondition()); <line23> scce.addException(invalidMandatoryCondition); <line24> } <line25> AuthModuleItem item = entityFactory.newEntity(AuthModuleItem.class); <line26> item.setIntAttrName(itemTO.getIntAttrName()); <line27> item.setExtAttrName(itemTO.getExtAttrName()); <line28> item.setMandatoryCondition(itemTO.getMandatoryCondition()); <line29> item.setConnObjectKey(itemTO.isConnObjectKey()); <line30> item.setPassword(itemTO.isPassword()); <line31> item.setPropagationJEXLTransformer(itemTO.getPropagationJEXLTransformer()); <line32> item.setPullJEXLTransformer(itemTO.getPullJEXLTransformer()); <line33> item.setAuthModule(authModule); <line34> authModule.add(item); <line35> } <line36> }); <line37> if (!invalidMapping.getElements().isEmpty()) { <line38> scce.addException(invalidMapping); <line39> } <line40> if (scce.hasExceptions()) { <line41> throw scce; <line42> } <line43> } <line44> } <line45> "	"<line11>                LOG.error(""Null {}"", ItemTO.class.getSimpleName());"	task4	
"public class A { <line0> private String resolveDriveLabel(String name, String lang) { <line1> if (resourceBundleService == null) { <line2> resourceBundleService = WCMCoreUtils.getService(ResourceBundleService.class); <line3> resourceBundleNames = resourceBundleService.getSharedResourceBundleNames(); <line4> } <line5> if (StringUtils.isBlank(lang)) { <line6> lang = Locale.ENGLISH.getLanguage(); <line7> } <line8> Locale locale = new Locale(lang); <line9> ResourceBundle sharedResourceBundle = <line10> resourceBundleService.getResourceBundle(resourceBundleNames, locale); <line11> try { <line12> sharedResourceBundle = resourceBundleService.getResourceBundle(resourceBundleNames, locale); <line13> String key = ""ContentSelector.title."" + name.replaceAll("" "", """"); <line14> if (sharedResourceBundle.containsKey(key)) { <line15> return sharedResourceBundle.getString(key); <line16> } else { <line17> return getDriveTitle(name); <line18> } <line19> } catch (MissingResourceException e) { <line20> if (LOG.isDebugEnabled()) { <line21> } <line22> } <line23> return name; <line24> } <line25> } <line26> "	<line21>        LOG.debug(e.getMessage());	task4	
public class A { <line0> public void openSession() throws ClientException { <line1> if (session != null) { <line2> closeSession(); <line3> } <line4> session = openSessionAs(ADMINISTRATOR); <line5> assertNotNull(session); <line6> } <line7> } <line8> 	"<line2>      log.warn(""Closing session for you"");"	task4	
public class A { <line0> @Override <line1> protected void cleanup(Context context) throws IOException, InterruptedException { <line2> if (mapperException == null) { <line3> try { <line4> finishRemainingHashRanges(context); <line5> } catch (Throwable t) { <line6> mapperException = t; <line7> } <line8> } <line9> try { <line10> sourceTable.close(); <line11> targetTable.close(); <line12> sourceConnection.close(); <line13> targetConnection.close(); <line14> } catch (Throwable t) { <line15> if (mapperException == null) { <line16> mapperException = t; <line17> } else { <line18> } <line19> } <line20> if (mapperException != null) { <line21> Throwables.propagateIfInstanceOf(mapperException, IOException.class); <line22> Throwables.propagateIfInstanceOf(mapperException, InterruptedException.class); <line23> Throwables.propagate(mapperException); <line24> } <line25> } <line26> } <line27> 	"<line18>        LOG.error(""Suppressing exception from closing tables"", t);"	task4	
"public class A { <line0> public void copySavedReport(String saved, String copy) throws Exception { <line1> try { <line2> reportingAdminServiceStub.copySavedReport(saved, copy); <line3> } catch (Exception e) { <line4> String msg = ""Unable to copy the report""; <line5> throw new Exception(msg, e); <line6> } <line7> } <line8> } <line9> "	<line5>      log.error(msg);	task4	
"public class A { <line0> public void registerException( <line1> final String method, final String path, final int code, final String error) { <line2> final String key = method.toUpperCase() + "" "" + path; <line3> this.errors.put(key, new ContentResponse(method, path, code, error)); <line4> } <line5> } <line6> "	"<line3>    logger.info(""Registering error: {}, code: {}, body:\n{}"", key, code, error);"	task4	
public class A { <line0> @Override <line1> public boolean isRequestorAllowedTarget(ConnectionTargetCheck check) { <line2> boolean restrictsConnectionStates = isPresent(check.getAllowedConnectionStates()); <line3> boolean restrictsSocketTypes = isPresent(check.getAllowedSocketTypes()); <line4> boolean restrictsSockets = isPresent(check.getAllowedSockets()); <line5> int rcs = restrictsConnectionStates ? RESTRICTS_CONNECTION_STATES : 0; <line6> int rst = restrictsSocketTypes ? RESTRICTS_SOCKET_TYPES : 0; <line7> int rs = restrictsSockets ? RESTRICTS_SOCKETS : 0; <line8> int wnc = check.isWonNodeCheck() ? WON_NODE_CHECK : 0; <line9> int evaluatorIndex = wnc | rcs | rst | rs; <line10> ConnectionTargetCheckEvaluator evaluator = evaluators[evaluatorIndex]; <line11> if (logger.isDebugEnabled()) { <line12> } <line13> return evaluator.isRequestorAllowedTarget(check); <line14> } <line15> } <line16> 	"<line12>      logger.debug(""Using evaluator with index {} (wnc:{}, rcs:{}, rst:{}, rs:{}) "",new Object[] {evaluatorIndex, wnc, restrictsConnectionStates, restrictsSocketTypes, restrictsSockets});"	task4	
"public class A { <line0> @SuppressWarnings(""unused"") <line1> @Override <line2> public void abort() { <line3> try (Connection connection = this.connection; <line4> PreparedStatement statement = this.statement) { <line5> connection.rollback(); <line6> } catch (SQLException e) { <line7> } <line8> } <line9> } <line10> "	"<line7>      log.debug(e, ""SQLException when abort"");"	task4	
public class A { <line0> @Override <line1> public ReturnCode filterKeyValue(KeyValue v) { <line2> if (evaluate) { <line3> inputTuple.setKey(v.getBuffer(), v.getRowOffset(), v.getRowLength()); <line4> this.keepRow = Boolean.TRUE.equals(evaluate(inputTuple)); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> evaluate = false; <line8> } <line9> return keepRow ? ReturnCode.INCLUDE : ReturnCode.NEXT_ROW; <line10> } <line11> } <line12> 	"<line6>        logger.debug(""RowKeyComparisonFilter: "" + (this.keepRow ? ""KEEP"" : ""FILTER"") + "" row "" + inputTuple);"	task4	
"public class A { <line0> @Override <line1> public DoubleProperty getDoubleProperty(String name) { <line2> if (name == null) { <line3> return new DoublePropertyImpl(""""); <line4> } <line5> DoublePropertyImpl doubleProperty = new DoublePropertyImpl(name); <line6> weakConfigListeners.put(doubleProperty, true); <line7> return doubleProperty; <line8> } <line9> } <line10> "	"<line3>      logger.error(""getDoubleProperty(): argument 'name' must be non-null"");"	task4	
public class A { <line0> public void addMargins(int extent) { <line1> if (log.isTraceEnabled()) { <line2> } <line3> T firstEntry = entries.higher(entries.first()); <line4> int marginStart = (firstEntry == null || firstEntry.startCoord > 0) ? 0 : firstEntry.startCoord; <line5> T lastEntry = entries.lower(entries.last()); <line6> int marginEnd = <line7> (lastEntry == null || lastEntry.endCoord < extent) ? extent : lastEntry.endCoord; <line8> DimensionRange<T> range = getRange(marginStart, marginEnd); <line9> addEntries(range); <line10> } <line11> } <line12> 	"<line2>      log.trace(""add margins to extent "" + extent);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> protected Transformation<RowData> translateToPlanInternal(PlannerBase planner) { <line3> final TableConfig tableConfig = planner.getTableConfig(); <line4> if (grouping.length > 0 && tableConfig.getMinIdleStateRetentionTime() < 0) { <line5> } <line6> final ExecEdge inputEdge = getInputEdges().get(0); <line7> final Transformation<RowData> inputTransform = <line8> (Transformation<RowData>) inputEdge.translateToPlan(planner); <line9> final RowType inputRowType = (RowType) inputEdge.getOutputType(); <line10> final AggregateInfoList localAggInfoList = <line11> AggregateUtil.transformToStreamAggregateInfoList( <line12> localAggInputRowType, <line13> JavaScalaConversionUtil.toScala(Arrays.asList(aggCalls)), <line14> aggCallNeedRetractions, <line15> needRetraction, <line16> false, <line17> true); <line18> final AggregateInfoList globalAggInfoList = <line19> AggregateUtil.transformToStreamAggregateInfoList( <line20> localAggInputRowType, <line21> JavaScalaConversionUtil.toScala(Arrays.asList(aggCalls)), <line22> aggCallNeedRetractions, <line23> needRetraction, <line24> true, <line25> true); <line26> final GeneratedAggsHandleFunction localAggsHandler = <line27> generateAggsHandler( <line28> ""LocalGroupAggsHandler"", <line29> localAggInfoList, <line30> grouping.length, <line31> localAggInfoList.getAccTypes(), <line32> tableConfig, <line33> planner.getRelBuilder()); <line34> final GeneratedAggsHandleFunction globalAggsHandler = <line35> generateAggsHandler( <line36> ""GlobalGroupAggsHandler"", <line37> globalAggInfoList, <line38> 0, <line39> localAggInfoList.getAccTypes(), <line40> tableConfig, <line41> planner.getRelBuilder()); <line42> final int indexOfCountStar = globalAggInfoList.getIndexOfCountStar(); <line43> final LogicalType[] globalAccTypes = <line44> Arrays.stream(globalAggInfoList.getAccTypes()) <line45> .map(LogicalTypeDataTypeConverter::fromDataTypeToLogicalType) <line46> .toArray(LogicalType[]::new); <line47> final LogicalType[] globalAggValueTypes = <line48> Arrays.stream(globalAggInfoList.getActualValueTypes()) <line49> .map(LogicalTypeDataTypeConverter::fromDataTypeToLogicalType) <line50> .toArray(LogicalType[]::new); <line51> final GeneratedRecordEqualiser recordEqualiser = <line52> new EqualiserCodeGenerator(globalAggValueTypes) <line53> .generateRecordEqualiser(""GroupAggValueEqualiser""); <line54> final OneInputStreamOperator<RowData, RowData> operator; <line55> final boolean isMiniBatchEnabled = <line56> tableConfig <line57> .getConfiguration() <line58> .getBoolean(ExecutionConfigOptions.TABLE_EXEC_MINIBATCH_ENABLED); <line59> if (isMiniBatchEnabled) { <line60> MiniBatchGlobalGroupAggFunction aggFunction = <line61> new MiniBatchGlobalGroupAggFunction( <line62> localAggsHandler, <line63> globalAggsHandler, <line64> recordEqualiser, <line65> globalAccTypes, <line66> indexOfCountStar, <line67> generateUpdateBefore, <line68> tableConfig.getIdleStateRetention().toMillis()); <line69> operator = <line70> new KeyedMapBundleOperator<>( <line71> aggFunction, AggregateUtil.createMiniBatchTrigger(tableConfig)); <line72> } else { <line73> throw new TableException(""Local-Global optimization is only worked in miniBatch mode""); <line74> } <line75> final OneInputTransformation<RowData, RowData> transform = <line76> new OneInputTransformation<>( <line77> inputTransform, <line78> getDescription(), <line79> operator, <line80> InternalTypeInfo.of(getOutputType()), <line81> inputTransform.getParallelism()); <line82> final RowDataKeySelector selector = <line83> KeySelectorUtil.getRowDataSelector(grouping, InternalTypeInfo.of(inputRowType)); <line84> transform.setStateKeySelector(selector); <line85> transform.setStateKeyType(selector.getProducedType()); <line86> return transform; <line87> } <line88> } <line89> "	"<line5>      LOG.warn(""No state retention interval configured for a query which accumulates state. Please""+ "" provide a query configuration with valid retention interval to prevent excessive""+ "" state size. You may specify a retention time of 0 to not clean up the state."");"	task4	
public class A { <line0> private static void recoverDataverse(MetadataTransactionContext mdTxnCtx, Dataverse dataverse) <line1> throws AlgebricksException { <line2> if (dataverse.getPendingOp() != MetadataUtil.PENDING_NO_OP) { <line3> MetadataManager.INSTANCE.dropDataverse(mdTxnCtx, dataverse.getDataverseName()); <line4> if (LOGGER.isInfoEnabled()) { <line5> } <line6> } else { <line7> List<Dataset> datasets = <line8> MetadataManager.INSTANCE.getDataverseDatasets(mdTxnCtx, dataverse.getDataverseName()); <line9> for (Dataset dataset : datasets) { <line10> recoverDataset(mdTxnCtx, dataset); <line11> } <line12> List<Library> libraries = <line13> MetadataManager.INSTANCE.getDataverseLibraries(mdTxnCtx, dataverse.getDataverseName()); <line14> for (Library library : libraries) { <line15> recoverLibrary(mdTxnCtx, library); <line16> } <line17> } <line18> } <line19> } <line20> 	"<line5>        LOGGER.info(""Dropped a pending dataverse: "" + dataverse.getDataverseName());"	task4	
"public class A { <line0> private Dataset<Row> doOperation( <line1> final GetDataFrameOfElements operation, final ParquetStore store, final SparkSession spark) <line2> throws OperationException { <line3> if (!operation <line4> .getView() <line5> .equals( <line6> new View.Builder() <line7> .entities(store.getSchema().getEntityGroups()) <line8> .edges(store.getSchema().getEdgeGroups()) <line9> .build())) { <line10> throw new OperationException(""This operation does not currently support views""); <line11> } <line12> final StructType schema = <line13> new SchemaUtils(store.getSchema()).getMergedSparkSchema(store.getSchema().getGroups()); <line14> final Dataset<Row> dataframe = spark.read().schema(schema).parquet(store.getGraphPath()); <line15> return dataframe; <line16> } <line17> } <line18> "	"<line12>    LOGGER.debug(""Creating a Dataset<Row> from path {} with option mergeSchema=true"", store.getGraphPath());"	task4	
"public class A { <line0> public Image uploadImage(File file) throws Exception { <line1> HttpResponse<JsonNode> response = <line2> Unirest.post(""https://api.imgur.com/3/image"") <line3> .header(""accept"", ""application/json"") <line4> .header(""Authorization"", ""Client-ID "" + clientId) <line5> .field(""image"", file) <line6> .field(""name"", file.getName()) <line7> .field(""title"", file.getName()) <line8> .asJson(); <line9> if (!response.getBody().getObject().getBoolean(""success"")) { <line10> throw new Exception(response.getBody().getObject().getJSONObject(""data"").getString(""error"")); <line11> } <line12> Image image = new Image(); <line13> image.id = response.getBody().getObject().getJSONObject(""data"").getString(""id""); <line14> image.deleteHash = response.getBody().getObject().getJSONObject(""data"").getString(""deletehash""); <line15> return image; <line16> } <line17> } <line18> "	<line10>      Logger.debug(response.getBody().toString());	task4	
public class A { <line0> @Override <line1> public void open(FileInputSplit split) throws IOException { <line2> super.open(split); <line3> this.wrapper = InstantiationUtil.instantiate(avroWrapperTypeClass, AvroBaseValue.class); <line4> DatumReader<E> datumReader; <line5> if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(avroValueType)) { <line6> datumReader = new SpecificDatumReader<E>(avroValueType); <line7> } else { <line8> datumReader = new ReflectDatumReader<E>(avroValueType); <line9> } <line10> SeekableInput in = new FSDataInputStreamWrapper(stream, (int) split.getLength()); <line11> dataFileReader = DataFileReader.openReader(in, datumReader); <line12> dataFileReader.sync(split.getStart()); <line13> reuseAvroValue = null; <line14> } <line15> } <line16> 	"<line10>    LOG.info(""Opening split "" + split);"	task4	
"public class A { <line0> @Override <line1> public ServerContext createContext(TProtocol input, TProtocol output, Object remoteInstance) { <line2> SocketAddress remoteSocketAddress; <line3> SocketAddress localSocketAddress; <line4> if (remoteInstance instanceof SelectionKey) { <line5> SelectionKey selectionKey = (SelectionKey) remoteInstance; <line6> SocketChannel channel = (SocketChannel) selectionKey.channel(); <line7> Socket socket = channel.socket(); <line8> remoteSocketAddress = socket.getRemoteSocketAddress(); <line9> localSocketAddress = socket.getLocalSocketAddress(); <line10> } else if (remoteInstance instanceof TSocket) { <line11> TSocket tSocket = (TSocket) remoteInstance; <line12> Socket socket = tSocket.getSocket(); <line13> remoteSocketAddress = socket.getRemoteSocketAddress(); <line14> localSocketAddress = socket.getLocalSocketAddress(); <line15> } else { <line16> throw new RuntimeException(""Cannot track remote connection off ["" + remoteInstance + ""]""); <line17> } <line18> _connectionMeter.mark(); <line19> _connections.incrementAndGet(); <line20> return new ShardServerContext(localSocketAddress, remoteSocketAddress); <line21> } <line22> } <line23> "	"<line2>    LOG.debug(""Client connected"");"	task4	
public class A { <line0> static void deleteAllKnownFlows( <line1> final TxFacade txFacade, <line2> final InstanceIdentifier<FlowCapableNode> instanceIdentifier, <line3> final DeviceFlowRegistry deviceFlowRegistry) { <line4> if (!txFacade.isTransactionsEnabled()) { <line5> return; <line6> } <line7> final ListenableFuture<Optional<FlowCapableNode>> future; <line8> try (ReadTransaction readTx = txFacade.getReadTransaction()) { <line9> future = readTx.read(LogicalDatastoreType.OPERATIONAL, instanceIdentifier); <line10> } <line11> try { <line12> Futures.transform( <line13> Futures.catchingAsync( <line14> future, <line15> Throwable.class, <line16> Futures::immediateFailedFuture, <line17> MoreExecutors.directExecutor()), <line18> flowCapNodeOpt -> { <line19> if (flowCapNodeOpt != null && flowCapNodeOpt.isPresent()) { <line20> for (final Table tableData : flowCapNodeOpt.get().nonnullTable().values()) { <line21> final Table table = <line22> new TableBuilder(tableData).setFlow(Collections.emptyMap()).build(); <line23> final InstanceIdentifier<Table> iiToTable = <line24> instanceIdentifier.child(Table.class, tableData.key()); <line25> txFacade.writeToTransaction(LogicalDatastoreType.OPERATIONAL, iiToTable, table); <line26> } <line27> } <line28> return null; <line29> }, <line30> MoreExecutors.directExecutor()) <line31> .get(); <line32> } catch (InterruptedException | ExecutionException ex) { <line33> } <line34> } <line35> } <line36> 	"<line33>      LOG.debug(""Failed to delete {} flows"", deviceFlowRegistry.size(), ex);"	task4	
"public class A { <line0> public void removeRootControllerService(final ControllerServiceNode service) { <line1> final ControllerServiceNode existing = <line2> rootControllerServices.get(requireNonNull(service).getIdentifier()); <line3> if (existing == null) { <line4> throw new IllegalStateException(service + "" is not a member of this Process Group""); <line5> } <line6> service.verifyCanDelete(); <line7> try (final NarCloseable x = <line8> NarCloseable.withComponentNarLoader( <line9> service.getControllerServiceImplementation().getClass(), service.getIdentifier())) { <line10> final ConfigurationContext configurationContext = <line11> new StandardConfigurationContext( <line12> service, controllerServiceProvider, null, variableRegistry); <line13> ReflectionUtils.quietlyInvokeMethodsWithAnnotation( <line14> OnRemoved.class, service.getControllerServiceImplementation(), configurationContext); <line15> } <line16> for (final Map.Entry<PropertyDescriptor, String> entry : service.getProperties().entrySet()) { <line17> final PropertyDescriptor descriptor = entry.getKey(); <line18> if (descriptor.getControllerServiceDefinition() != null) { <line19> final String value = <line20> entry.getValue() == null ? descriptor.getDefaultValue() : entry.getValue(); <line21> if (value != null) { <line22> final ControllerServiceNode referencedNode = getRootControllerService(value); <line23> if (referencedNode != null) { <line24> referencedNode.removeReference(service); <line25> } <line26> } <line27> } <line28> } <line29> rootControllerServices.remove(service.getIdentifier()); <line30> getStateManagerProvider().onComponentRemoved(service.getIdentifier()); <line31> ExtensionManager.removeInstanceClassLoaderIfExists(service.getIdentifier()); <line32> } <line33> } <line34> "	"<line32>    LOG.info(""{} removed from Flow Controller"", service, this);"	task4	
public class A { <line0> public void success() { <line1> if (failures > 0) { <line2> } <line3> failures = 0; <line4> } <line5> } <line6> 	"<line2>      log.info(""Recieved ping for [{}]"", agentId);"	task4	
public class A { <line0> protected void activate(ComponentContext componentContext, Map<String, Object> properties) { <line1> this.options = new SslManagerServiceOptions(properties); <line2> this.sslContexts = new ConcurrentHashMap<>(); <line3> ServiceTracker<SslServiceListener, SslServiceListener> listenersTracker = <line4> new ServiceTracker<>(componentContext.getBundleContext(), SslServiceListener.class, null); <line5> this.sslServiceListeners = new SslServiceListeners(listenersTracker); <line6> } <line7> } <line8> 	"<line1>    logger.info(""activate..."");"	task4	
"public class A { <line0> @PreAuthorize( <line1> ""hasPermission(#id, '"" <line2> + AclClassName.Values.LAYOUT <line3> + ""', '"" <line4> + PermissionName.Values.LAYOUT_DELETE <line5> + ""')"") <line6> public void deleteLayout(final Long id) { <line7> layoutService.delete(id); <line8> } <line9> } <line10> "	"<line7>    log.debug(""deleteLayout() - id={}"", id);"	task4	
public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> IgniteTransactions txs = cache.unwrap(Ignite.class).transactions(); <line3> try (Transaction tx = txs.txStart(OPTIMISTIC, SERIALIZABLE)) { <line4> assertTrue(cache.get(key).equals(val)); <line5> readLatch.countDown(); <line6> writeLatch.await(10, TimeUnit.SECONDS); <line7> try { <line8> tx.commit(); <line9> } catch (TransactionOptimisticException e) { <line10> err[0] = e; <line11> } <line12> } <line13> return null; <line14> } <line15> } <line16> 	"<line10>        log.info(""Expected exception: "" + e);"	task4	
public class A { <line0> public void freeInstance(final ThreadContext callContext, final EntityBean bean) <line1> throws SystemException { <line2> discardInstance(callContext, bean); <line3> final Operation currentOp = callContext.getCurrentOperation(); <line4> callContext.setCurrentOperation(Operation.UNSET_CONTEXT); <line5> try { <line6> bean.unsetEntityContext(); <line7> } catch (final Exception e) { <line8> } finally { <line9> callContext.setCurrentOperation(currentOp); <line10> } <line11> } <line12> } <line13> 	"<line8>      logger.info(getClass().getName()+ "".freeInstance: ignoring exception ""+ e+ "" on bean instance ""+ bean);"	task4	
public class A { <line0> @Override <line1> public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { <line2> try { <line3> if (null != outEventStatsCollector || null != outHttpStatsCollector) { <line4> if (e.getMessage() instanceof DatabusRequest) { <line5> latestDbusRequest = (DatabusRequest) e.getMessage(); <line6> if (null != outEventStatsCollector) { <line7> latestDbusRequest <line8> .getParams() <line9> .put(outEventStatsCollector.getName(), connOutEventStatsCollector); <line10> } <line11> if (null != outHttpStatsCollector) { <line12> latestDbusRequest <line13> .getParams() <line14> .put(outHttpStatsCollector.getName(), connOutHttpStatsCollector); <line15> } <line16> if (latestDbusRequest.getParams().getProperty(ReadEventsRequestProcessor.CHECKPOINT_PARAM) <line17> != null) { <line18> Checkpoint cp = <line19> new Checkpoint( <line20> latestDbusRequest <line21> .getParams() <line22> .getProperty(ReadEventsRequestProcessor.CHECKPOINT_PARAM)); <line23> String peer = connOutHttpStatsCollector.getPeers().get(0); <line24> connOutHttpStatsCollector.getPeerStats(peer).registerStreamRequest(peer, cp); <line25> relay.getMetricsCollector().setClientSCN(peer, cp.getWindowScn()); <line26> } <line27> } else if (shouldMerge(e)) { <line28> mergePerConnStats(); <line29> } <line30> } <line31> super.messageReceived(ctx, e); <line32> } catch (Exception ex) { <line33> } <line34> } <line35> } <line36> 	"<line33>      LOGGER.error(""Exception while processing message in RelayStatisticsCollectingHandler"");"	task4	
public class A { <line0> @Override <line1> public void preDestruction() throws AuthorizerDestructionException { <line2> scheduler.shutdown(); <line3> try { <line4> if (!scheduler.awaitTermination(10000, TimeUnit.MILLISECONDS)) { <line5> scheduler.shutdownNow(); <line6> } <line7> } catch (final InterruptedException e) { <line8> } <line9> } <line10> } <line11> 	"<line8>      logger.warn(""Error shutting down user group refresh scheduler due to {}"", e.getMessage(), e);"	task4	
public class A { <line0> public List<StreamTestMatch> testMatch(Message message) { <line1> final List<StreamTestMatch> matches = Lists.newArrayList(); <line2> for (final Stream stream : streams) { <line3> final StreamTestMatch match = new StreamTestMatch(stream); <line4> for (final StreamRule streamRule : stream.getStreamRules()) { <line5> try { <line6> final Rule rule = new Rule(stream, streamRule, stream.getMatchingType()); <line7> match.addRule(rule); <line8> } catch (InvalidStreamRuleTypeException e) { <line9> } <line10> } <line11> match.matchMessage(message); <line12> matches.add(match); <line13> } <line14> return matches; <line15> } <line16> } <line17> 	"<line9>          LOG.warn(""Invalid stream rule type. Skipping matching for this rule. "" + e.getMessage(), e);"	task4	
public class A { <line0> private Maybe<Object> resolveRawValueFromContainerIgnoringDeprecatedNames( <line1> TContainer container, ConfigKey<?> key, Maybe<Object> value) { <line2> Map<ConfigKey<?>, Object> oc = <line3> ((AbstractConfigMapImpl<?>) <line4> ((BrooklynObjectInternal) container).config().getInternalConfigMap()) <line5> .ownConfig; <line6> if (key instanceof ConfigKeySelfExtracting) { <line7> if (((ConfigKeySelfExtracting<?>) key).isSet(oc)) { <line8> Map<ConfigKey<?>, ?> ownCopy; <line9> synchronized (oc) { <line10> ownCopy = MutableMap.copyOf(oc); <line11> } <line12> Maybe<Object> result = <line13> Maybe.of( <line14> (Object) <line15> ((ConfigKeySelfExtracting<?>) key) <line16> .extractValue(ownCopy, getExecutionContext(container))); <line17> postLocalEvaluate(key, bo, value, result); <line18> return result; <line19> } else { <line20> return Maybe.absent(); <line21> } <line22> } else { <line23> return Maybe.absent(); <line24> } <line25> } <line26> } <line27> 	"<line23>      LOG.warn(""Unexpected key type "" + key + "" ("" + key.getClass() + "") in "" + bo + ""; ignoring value"");"	task4	
public class A { <line0> @Override <line1> public void execute(IotHubStatusCode status, Object context) { <line2> Message msg = (Message) context; <line3> if (status == IotHubStatusCode.MESSAGE_CANCELLED_ONCLOSE) { <line4> failedMessageListOnClose.add(msg.getMessageId()); <line5> } <line6> } <line7> } <line8> 	"<line3>    log.debug("">> IoT Hub responded to message {} with status {}"", msg.getMessageId(), status.name());"	task4	
public class A { <line0> private void enableAZ( <line1> BaragonAgentMetadata agent, String availabilityZone, LoadBalancerDescription elb) { <line2> List<String> availabilityZones = elb.getAvailabilityZones(); <line3> availabilityZones.add(availabilityZone); <line4> EnableAvailabilityZonesForLoadBalancerRequest request = <line5> new EnableAvailabilityZonesForLoadBalancerRequest(); <line6> request.setAvailabilityZones(availabilityZones); <line7> request.setLoadBalancerName(elb.getLoadBalancerName()); <line8> elbClient.enableAvailabilityZonesForLoadBalancer(request); <line9> } <line10> } <line11> 	"<line2>    LOG.info(""Enabling availability zone {} in preparation for agent {}"",availabilityZone,agent.getAgentId());"	task4	
"public class A { <line0> protected String xmlDigest(JasperPrint print) <line1> throws NoSuchAlgorithmException, FileNotFoundException, JRException, IOException { <line2> File outputFile = createXmlOutputFile(); <line3> MessageDigest digest = MessageDigest.getInstance(""SHA-1""); <line4> FileOutputStream output = new FileOutputStream(outputFile); <line5> try { <line6> DigestOutputStream out = new DigestOutputStream(output, digest); <line7> xmlExport(print, out); <line8> } finally { <line9> output.close(); <line10> } <line11> return toDigestString(digest); <line12> } <line13> } <line14> "	"<line3>    log.debug(""XML export output at "" + outputFile.getAbsolutePath());"	task4	
"public class A { <line0> @Deprecated <line1> public <T> T update(Collection<String> path, T newValue) { <line2> checkPath(path); <line3> if (newValue == null) { <line4> newValue = typedNull(); <line5> } <line6> if (log.isTraceEnabled()) { <line7> } <line8> @SuppressWarnings(""unchecked"") <line9> T oldValue = (T) values.put(path, newValue); <line10> return (isNull(oldValue)) ? null : oldValue; <line11> } <line12> } <line13> "	"<line7>      log.trace(""setting sensor {}={} for {}"", new Object[] {path, newValue, entity});"	task4	
public class A { <line0> @Override <line1> public boolean isInSafeMode() { <line2> if (!mWorkerConnectWaitStartTimeMs.isMarked()) { <line3> return false; <line4> } <line5> Long startTime = mWorkerConnectWaitStartTimeMs.getReference(); <line6> if (startTime == null) { <line7> return true; <line8> } <line9> long waitTime = ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME); <line10> if (mClock.millis() - startTime < waitTime) { <line11> return true; <line12> } <line13> if (mWorkerConnectWaitStartTimeMs.compareAndSet(startTime, null, true, false)) { <line14> } <line15> return mWorkerConnectWaitStartTimeMs.isMarked(); <line16> } <line17> } <line18> 	"<line14>      LOG.debug(""Exiting safe mode."");"	task4	
"public class A { <line0> private void tryDenseMode() { <line1> if (numSpillFiles != 0) { <line2> return; <line3> } <line4> long minKey = Long.MAX_VALUE; <line5> long maxKey = Long.MIN_VALUE; <line6> long recordCount = 0; <line7> for (LongHashPartition p : this.partitionsBeingBuilt) { <line8> long partitionRecords = p.getBuildSideRecordCount(); <line9> recordCount += partitionRecords; <line10> if (partitionRecords > 0) { <line11> if (p.getMinKey() < minKey) { <line12> minKey = p.getMinKey(); <line13> } <line14> if (p.getMaxKey() > maxKey) { <line15> maxKey = p.getMaxKey(); <line16> } <line17> } <line18> } <line19> if (buildSpillRetBufferNumbers != 0) { <line20> throw new RuntimeException( <line21> ""buildSpillRetBufferNumbers should be 0: "" + buildSpillRetBufferNumbers); <line22> } <line23> long range = maxKey - minKey + 1; <line24> if (range > 0 && (range <= recordCount * 4 || range <= segmentSize / 8)) { <line25> int buffers = (int) Math.ceil(((double) (range * 8)) / segmentSize); <line26> MemorySegment[] denseBuckets = new MemorySegment[buffers]; <line27> for (int i = 0; i < buffers; i++) { <line28> MemorySegment seg = getNextBuffer(); <line29> if (seg == null) { <line30> returnAll(Arrays.asList(denseBuckets)); <line31> return; <line32> } <line33> denseBuckets[i] = seg; <line34> for (int j = 0; j < segmentSize; j += 8) { <line35> seg.putLong(j, INVALID_ADDRESS); <line36> } <line37> } <line38> denseMode = true; <line39> this.minKey = minKey; <line40> this.maxKey = maxKey; <line41> List<MemorySegment> segments = new ArrayList<>(); <line42> buildSpillReturnBuffers.drainTo(segments); <line43> returnAll(segments); <line44> ArrayList<MemorySegment> dataBuffers = new ArrayList<>(); <line45> long addressOffset = 0; <line46> for (LongHashPartition p : this.partitionsBeingBuilt) { <line47> p.iteratorToDenseBucket(denseBuckets, addressOffset, minKey); <line48> p.updateDenseAddressOffset(addressOffset); <line49> dataBuffers.addAll(Arrays.asList(p.getPartitionBuffers())); <line50> addressOffset += (p.getPartitionBuffers().length << segmentSizeBits); <line51> returnAll(Arrays.asList(p.getBuckets())); <line52> } <line53> this.denseBuckets = denseBuckets; <line54> this.densePartition = <line55> new LongHashPartition( <line56> this, buildSideSerializer, dataBuffers.toArray(new MemorySegment[0])); <line57> freeCurrent(); <line58> } <line59> } <line60> } <line61> "	"<line39>      LOG.info(""LongHybridHashTable: Use dense mode!"");"	task4	
public class A { <line0> @Override <line1> public void open() { <line2> if ((_noticeableThreadPoolExecutor != null) && !_noticeableThreadPoolExecutor.isShutdown()) { <line3> return; <line4> } <line5> if (_rejectedExecutionHandler == null) { <line6> _rejectedExecutionHandler = _createRejectionExecutionHandler(); <line7> } <line8> NoticeableThreadPoolExecutor noticeableThreadPoolExecutor = <line9> new NoticeableThreadPoolExecutor( <line10> _workersCoreSize, <line11> _workersMaxSize, <line12> 60L, <line13> TimeUnit.SECONDS, <line14> new LinkedBlockingQueue<>(_maximumQueueSize), <line15> new NamedThreadFactory( <line16> getName(), Thread.NORM_PRIORITY, PortalClassLoaderUtil.getClassLoader()), <line17> _rejectedExecutionHandler, <line18> new ThreadPoolHandlerAdapter()); <line19> NoticeableExecutorService oldNoticeableExecutorService = <line20> _portalExecutorManager.registerPortalExecutor(getName(), noticeableThreadPoolExecutor); <line21> if (oldNoticeableExecutorService != null) { <line22> if (log.isWarnEnabled()) { <line23> } <line24> noticeableThreadPoolExecutor.shutdownNow(); <line25> noticeableThreadPoolExecutor = (NoticeableThreadPoolExecutor) oldNoticeableExecutorService; <line26> } <line27> _noticeableThreadPoolExecutor = noticeableThreadPoolExecutor; <line28> } <line29> } <line30> 	"<line23>        log.warn(""Abort creating a new thread pool for destination ""+ getName()+ "" and reuse previous one"");"	task4	
"public class A { <line0> public void replaceIdentityStore( <line1> ConnectionType type, CertificateStoreConfiguration configuration, boolean createIfAbsent) <line2> throws CertificateStoreConfigException { <line3> if (type == null) { <line4> throw new IllegalArgumentException(""Argument 'type' cannot be null.""); <line5> } <line6> if (configuration == null) { <line7> throw new IllegalArgumentException(""Argument 'configuration' cannot be null.""); <line8> } <line9> final CertificateStoreConfiguration oldConfig = typeToIdentityStore.get(type); <line10> if (oldConfig == null || !oldConfig.equals(configuration)) { <line11> if (!identityStores.containsKey(configuration)) { <line12> final IdentityStore store = new IdentityStore(configuration, createIfAbsent); <line13> identityStores.put(configuration, store); <line14> storeWatcher.watch(store); <line15> } <line16> typeToIdentityStore.put(type, configuration); <line17> if (oldConfig != null && !typeToIdentityStore.containsValue(oldConfig)) { <line18> final IdentityStore store = identityStores.remove(oldConfig); <line19> if (store != null) { <line20> storeWatcher.unwatch(store); <line21> } <line22> } <line23> final ConnectionManagerImpl connectionManager = <line24> ((ConnectionManagerImpl) XMPPServer.getInstance().getConnectionManager()); <line25> for (ConnectionListener connectionListener : connectionManager.getListeners(type)) { <line26> try { <line27> connectionListener.setIdentityStoreConfiguration(configuration); <line28> } catch (RuntimeException e) { <line29> } <line30> } <line31> } <line32> JiveGlobals.setProperty(type.getPrefix() + ""keystore"", configuration.getFile().getPath()); <line33> JiveGlobals.setProperty( <line34> type.getPrefix() + ""keypass"", new String(configuration.getPassword()), true); <line35> } <line36> } <line37> "	"<line29>          Log.warn(""An exception occurred while trying to update the identity store configuration for""+ "" connection type '""+ type+ ""'"",e);"	task4	
public class A { <line0> private void processWmls(File baseDir) throws IOException { <line1> File dir = getUploadWmlDir(); <line2> for (File wml : baseDir.listFiles()) { <line3> String oldHash = OmFileHelper.getFileName(wml.getName()); <line4> String hash = hashMap.get(oldHash); <line5> if (hash == null) { <line6> continue; <line7> } <line8> changeHash(wml, dir, hash, null); <line9> } <line10> } <line11> } <line12> 	"<line1>    log.debug(""Entered WML folder"");"	task4	
public class A { <line0> public String getSecurityHeader() { <line1> if (this.securityHeader == null) { <line2> try { <line3> securityHeader = <line4> APIUtil.getOAuthConfigurationFromAPIMConfig(APIConstants.AUTHORIZATION_HEADER); <line5> if (securityHeader == null) { <line6> securityHeader = HttpHeaders.AUTHORIZATION; <line7> } <line8> } catch (APIManagementException e) { <line9> } <line10> } <line11> return securityHeader; <line12> } <line13> } <line14> 	"<line9>        log.error(""Error while reading authorization header from APIM configurations"", e);"	task4	
"public class A { <line0> public static com.liferay.portal.workflow.kaleo.forms.model.KaleoProcess deleteKaleoProcess( <line1> HttpPrincipal httpPrincipal, long kaleoProcessId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KaleoProcessServiceUtil.class, <line7> ""deleteKaleoProcess"", <line8> _deleteKaleoProcessParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, kaleoProcessId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.portal.workflow.kaleo.forms.model.KaleoProcess) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static boolean isFreeViewerPage( <line1> PageModel model, Widget[] widgets, String viewerWidgetCode) { <line2> try { <line3> if (model != null && widgets != null) { <line4> int mainFrame = model.getMainFrame(); <line5> if (mainFrame < 0) { <line6> return false; <line7> } <line8> Widget viewer = widgets[mainFrame]; <line9> if (null == viewer) { <line10> return false; <line11> } <line12> boolean isRightCode = <line13> null == viewerWidgetCode || viewer.getType().getCode().equals(viewerWidgetCode); <line14> String actionName = viewer.getType().getAction(); <line15> boolean isRightAction = <line16> (null != actionName && actionName.toLowerCase().indexOf(""viewer"") >= 0); <line17> List<WidgetTypeParameter> typeParameters = viewer.getType().getTypeParameters(); <line18> if ((isRightCode || isRightAction) <line19> && (null != typeParameters && !typeParameters.isEmpty()) <line20> && (null == viewer.getConfig() || viewer.getConfig().isEmpty())) { <line21> return true; <line22> } <line23> } <line24> } catch (Throwable t) { <line25> } <line26> return false; <line27> } <line28> } <line29> "	"<line25>      logger.error(""Error while checking page for widget '{}'"", viewerWidgetCode, t);"	task4	
public class A { <line0> @Override <line1> public void handleNewSession(final String sessionId) throws Exception { <line2> zkClient.waitUntilConnected(HelixZkClient.DEFAULT_CONNECTION_TIMEOUT, TimeUnit.SECONDS); <line3> waitNewSession.countDown(); <line4> } <line5> } <line6> 	"<line3>    LOG.info(""handleNewSession. sessionId: {}."", sessionId);"	task4	
"public class A { <line0> @GET <line1> @Path(""eventCount"") <line2> @Produces(MediaType.TEXT_PLAIN) <line3> @RestQuery( <line4> name = ""eventcount"", <line5> description = ""Get the number of scheduled events"", <line6> returnDescription = ""The number of scheduled events"", <line7> responses = { <line8> @RestResponse(responseCode = HttpServletResponse.SC_OK, description = ""The event count"") <line9> }) <line10> public Response eventCount() throws UnauthorizedException { <line11> try { <line12> return Response.ok("""" + service.getEventCount()).build(); <line13> } catch (UnauthorizedException e) { <line14> throw e; <line15> } catch (Exception e) { <line16> throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR); <line17> } <line18> } <line19> } <line20> "	"<line16>      logger.error(""Unable to get the event count"", e);"	task4	
public class A { <line0> @VisibleForTesting <line1> void setAsyncRequestInstanceSecondStep( <line2> SuccessfulAssociateIpAddressResponse response, <line3> AsyncRequestInstanceState asyncRequestInstanceState, <line4> String createFirewallRuleJobId) { <line5> SuccessfulAssociateIpAddressResponse.IpAddress ipAddress = response.getIpAddress(); <line6> String ipAddressId = ipAddress.getId(); <line7> String ip = ipAddress.getIpAddress(); <line8> asyncRequestInstanceState.setIpInstanceId(ipAddressId); <line9> asyncRequestInstanceState.setIp(ip); <line10> asyncRequestInstanceState.setCurrentJobId(createFirewallRuleJobId); <line11> asyncRequestInstanceState.setState(AsyncRequestInstanceState.StateType.CREATING_FIREWALL_RULE); <line12> } <line13> } <line14> 	<line12>    LOGGER.info(String.format(Messages.Log.ASYNCHRONOUS_PUBLIC_IP_STATE_S,asyncRequestInstanceState.getOrderInstanceId(),AsyncRequestInstanceState.StateType.CREATING_FIREWALL_RULE));	task4	
"public class A { <line0> public void deviceDiscovered(Device device) { <line1> if (device.active) { <line2> ThingUID accountUID = accountHandler.getThing().getUID(); <line3> ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing()); <line4> try { <line5> DiscoveryResult discoveryResult = <line6> DiscoveryResultBuilder.create(thingUID) <line7> .withBridge(accountUID) <line8> .withLabel( <line9> PropertyUtils.getPropertyValue( <line10> device, ""common.attributes.name.value"", String.class)) <line11> .withProperty(""id"", device.id) <line12> .withProperty(""type"", device.deviceType) <line13> .withRepresentationProperty(""id"") <line14> .build(); <line15> thingDiscovered(discoveryResult); <line16> } catch (GardenaException ex) { <line17> } <line18> } <line19> } <line20> } <line21> "	"<line17>        logger.warn(""{}"", ex.getMessage());"	task4	
public class A { <line0> @Override <line1> public void complete() throws IOException { <line2> delete(); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""Completing session: {}"", id);"	task4	
"public class A { <line0> public static com.liferay.commerce.application.model.CommerceApplicationModel <line1> getCommerceApplicationModel(HttpPrincipal httpPrincipal, long commerceApplicationModelId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceApplicationModelServiceUtil.class, <line7> ""getCommerceApplicationModel"", <line8> _getCommerceApplicationModelParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceApplicationModelId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.application.model.CommerceApplicationModel) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> public List<NoteInfo> listNotesInfo( <line1> boolean needsReload, ServiceContext context, ServiceCallback<List<NoteInfo>> callback) <line2> throws IOException { <line3> if (needsReload) { <line4> try { <line5> notebook.reloadAllNotes(context.getAutheInfo()); <line6> } catch (IOException e) { <line7> } <line8> } <line9> List<NoteInfo> notesInfo = <line10> notebook.getNotesInfo( <line11> noteId -> authorizationService.isReader(noteId, context.getUserAndRoles())); <line12> callback.onSuccess(notesInfo, context); <line13> return notesInfo; <line14> } <line15> } <line16> 	"<line7>        LOGGER.error(""Fail to reload notes from repository"", e);"	task4	
"public class A { <line0> private CMLMolecule cdkCrystalToCMLMolecule(ICrystal crystal, boolean setIDs) { <line1> CMLMolecule molecule = cdkAtomContainerToCMLMolecule(crystal, false, false); <line2> CMLCrystal cmlCrystal = new CMLCrystal(); <line3> if (useCMLIDs && setIDs) { <line4> IDCreator.createIDs(crystal); <line5> } <line6> if (crystal.getID() != null && !crystal.getID().equals("""")) cmlCrystal.setId(crystal.getID()); <line7> this.checkPrefix(cmlCrystal); <line8> cmlCrystal.setZ(crystal.getZ()); <line9> double[] params = <line10> CrystalGeometryTools.cartesianToNotional(crystal.getA(), crystal.getB(), crystal.getC()); <line11> cmlCrystal.setCellParameters(params); <line12> molecule.appendChild(cmlCrystal); <line13> return molecule; <line14> } <line15> } <line16> "	"<line11>    logger.debug(""Number of cell params: "", params.length);"	task4	
public class A { <line0> public BacklogQuota getBacklogQuota(TopicName topicName) { <line1> String policyPath = AdminResource.path(POLICIES, topicName.getNamespace()); <line2> if (!isTopicLevelPoliciesEnable) { <line3> return getBacklogQuota(topicName.getNamespace(), policyPath); <line4> } <line5> try { <line6> return Optional.ofNullable(pulsar.getTopicPoliciesService().getTopicPolicies(topicName)) <line7> .map(TopicPolicies::getBackLogQuotaMap) <line8> .map(map -> map.get(BacklogQuotaType.destination_storage.name())) <line9> .orElseGet(() -> getBacklogQuota(topicName.getNamespace(), policyPath)); <line10> } catch (Exception e) { <line11> } <line12> return getBacklogQuota(topicName.getNamespace(), policyPath); <line13> } <line14> } <line15> 	"<line11>      log.warn(""Failed to read topic policies data, will apply the namespace backlog quota:""+ "" topicName={}"",topicName,e);"	task4	
public class A { <line0> private <T> T fromJson(String json, final Class<T> classOfT) { <line1> if (!isJsonObject(json)) return null; <line2> json = json.substring(MAGIC_JSON_START.length()); <line3> try { <line4> return getObjectMapper().readValue(json, classOfT); <line5> } catch (IOException ex) { <line6> return null; <line7> } <line8> } <line9> } <line10> 	"<line6>      log.error(""Can't deserialize json object (may-be incompatible ProjectForge versions): ""+ ex.getMessage()+ "" json=""+ json,ex);"	task4	
"public class A { <line0> public void bitarchiveReply( <line1> String bitarchiveBatchID, <line2> String bitarchiveID, <line3> int noOfFilesProcessed, <line4> Collection<File> filesFailed, <line5> RemoteFile remoteFile, <line6> String errMsg, <line7> List<FileBatchJob.ExceptionOccurrence> exceptions) <line8> throws ArgumentNotValid { <line9> ArgumentNotValid.checkNotNullOrEmpty(bitarchiveBatchID, ""String bitarchiveBatchID""); <line10> ArgumentNotValid.checkNotNullOrEmpty(bitarchiveID, ""String bitarchiveID""); <line11> ArgumentNotValid.checkNotNegative(noOfFilesProcessed, ""int noOfFilesProcessed""); <line12> BatchJobStatus bjs = runningBatchJobs.get(bitarchiveBatchID); <line13> if (bjs == null) { <line14> if (remoteFile != null) { <line15> remoteFile.cleanup(); <line16> } <line17> } else { <line18> bjs.updateWithBitarchiveReply( <line19> bitarchiveID, noOfFilesProcessed, filesFailed, remoteFile, errMsg); <line20> } <line21> } <line22> } <line23> "	"<line14>      log.debug(""The batch ID '{}' of the received reply from bitarchives does not correspond to any""+ "" pending batch job. Ignoring and deleting RemoteFile '{}'.Only knows batchjob with""+ "" IDs: {}"",bitarchiveBatchID,remoteFile,runningBatchJobs.keySet());"	task4	
public class A { <line0> @Override <line1> public AccountRole fetchByRoleId(long roleId, boolean useFinderCache) { <line2> Object[] finderArgs = null; <line3> if (useFinderCache) { <line4> finderArgs = new Object[] {roleId}; <line5> } <line6> Object result = null; <line7> if (useFinderCache) { <line8> result = finderCache.getResult(_finderPathFetchByRoleId, finderArgs); <line9> } <line10> if (result instanceof AccountRole) { <line11> AccountRole accountRole = (AccountRole) result; <line12> if (roleId != accountRole.getRoleId()) { <line13> result = null; <line14> } <line15> } <line16> if (result == null) { <line17> StringBundler sb = new StringBundler(3); <line18> sb.append(_SQL_SELECT_ACCOUNTROLE_WHERE); <line19> sb.append(_FINDER_COLUMN_ROLEID_ROLEID_2); <line20> String sql = sb.toString(); <line21> Session session = null; <line22> try { <line23> session = openSession(); <line24> Query query = session.createQuery(sql); <line25> QueryPos queryPos = QueryPos.getInstance(query); <line26> queryPos.add(roleId); <line27> List<AccountRole> list = query.list(); <line28> if (list.isEmpty()) { <line29> if (useFinderCache) { <line30> finderCache.putResult(_finderPathFetchByRoleId, finderArgs, list); <line31> } <line32> } else { <line33> if (list.size() > 1) { <line34> Collections.sort(list, Collections.reverseOrder()); <line35> if (log.isWarnEnabled()) { <line36> if (!useFinderCache) { <line37> finderArgs = new Object[] {roleId}; <line38> } <line39> } <line40> } <line41> AccountRole accountRole = list.get(0); <line42> result = accountRole; <line43> cacheResult(accountRole); <line44> } <line45> } catch (Exception exception) { <line46> throw processException(exception); <line47> } finally { <line48> closeSession(session); <line49> } <line50> } <line51> if (result instanceof List<?>) { <line52> return null; <line53> } else { <line54> return (AccountRole) result; <line55> } <line56> } <line57> } <line58> 	"<line39>              log.warn(""AccountRolePersistenceImpl.fetchByRoleId(long, boolean) with parameters (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
"public class A { <line0> @Test <line1> public void testJmxDumpCBRRoutesAsXml() throws Exception { <line2> MBeanServer mbeanServer = getMBeanServer(); <line3> ObjectName on = getContextObjectName(); <line4> String xml = (String) mbeanServer.invoke(on, ""dumpRoutesAsXml"", null, null); <line5> assertNotNull(xml); <line6> assertTrue(xml.contains(""myRoute""), xml); <line7> assertTrue(xml.matches(""[\\S\\s]*<when id=\""when[0-9]+\"">[\\S\\s]*"")); <line8> assertTrue(xml.matches(""[\\S\\s]*<otherwise id=\""otherwise[0-9]+\"">[\\S\\s]*"")); <line9> assertTrue( <line10> xml.contains(""<route customId=\""true\"" id=\""myRoute\"">"") <line11> || xml.contains(""<route id=\""myRoute\"" customId=\""true\"">"")); <line12> assertTrue( <line13> xml.contains(""<choice customId=\""true\"" id=\""myChoice\"">"") <line14> || xml.contains(""<choice id=\""myChoice\"" customId=\""true\"">"")); <line15> } <line16> } <line17> "	<line6>    log.info(xml);	task4	
public class A { <line0> @Override <line1> public void afterDestroy(EntryEvent<K, V> event) { <line2> } <line3> } <line4> 	"<line2>    log.info(""In region ["" + event.getRegion().getName() + ""] destroyed key ["" + event.getKey() + ""] "");"	task4	
public class A { <line0> public final Statement startBouncing(final Statement next) { <line1> return new Statement() { <line2> @Override <line3> public void evaluate() throws Throwable { <line4> bouncingMembersTask = new FutureTask<Runnable>(new MemberUpDownMonkey(), null); <line5> Thread bounceMembersThread = new Thread(bouncingMembersTask); <line6> bounceMembersThread.setDaemon(true); <line7> bounceMembersThread.start(); <line8> next.evaluate(); <line9> } <line10> }; <line11> } <line12> } <line13> 	"<line4>        LOGGER.info(""Spawning member bouncing thread"");"	task4	
"public class A { <line0> @Override <line1> public void validate() { <line2> super.validate(); <line3> populateRemittanceList(); <line4> listData(); <line5> final SimpleDateFormat dateFomatter = new SimpleDateFormat(""yyyy-MM-dd"", Locale.getDefault()); <line6> if (receiptDateArray != null) { <line7> final String[] filterReceiptDateArray = removeNullValue(receiptDateArray); <line8> final String receiptEndDate = filterReceiptDateArray[filterReceiptDateArray.length - 1]; <line9> try { <line10> if (!receiptEndDate.isEmpty() <line11> && remittanceDate != null <line12> && remittanceDate.before(dateFomatter.parse(receiptEndDate))) <line13> addActionError(getText(""bankremittance.before.receiptdate"")); <line14> } catch (final ParseException e) { <line15> throw new ApplicationRuntimeException(""Exception while parsing receiptEndDate date"", e); <line16> } <line17> } <line18> } <line19> } <line20> "	"<line15>        LOGGER.debug(""Exception in parsing date  "" + receiptEndDate + "" - "" + e.getMessage());"	task4	
public class A { <line0> public static com.liferay.commerce.wish.list.model.CommerceWishListItemSoap[] <line1> getCommerceWishListItems( <line2> long commerceWishListId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator< <line6> com.liferay.commerce.wish.list.model.CommerceWishListItem> <line7> orderByComparator) <line8> throws RemoteException { <line9> try { <line10> java.util.List<com.liferay.commerce.wish.list.model.CommerceWishListItem> returnValue = <line11> CommerceWishListItemServiceUtil.getCommerceWishListItems( <line12> commerceWishListId, start, end, orderByComparator); <line13> return com.liferay.commerce.wish.list.model.CommerceWishListItemSoap.toSoapModels( <line14> returnValue); <line15> } catch (Exception exception) { <line16> throw new RemoteException(exception.getMessage()); <line17> } <line18> } <line19> } <line20> 	<line16>      log.error(exception, exception);	task4	
"public class A { <line0> public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException { <line1> final String path = new AnyURIValue(args[0].itemAt(0).getStringValue()).toString(); <line2> if (path.matches(""^[a-z]+://.*"")) { <line3> final MimeTable mimeTable = MimeTable.getInstance(); <line4> final MimeType mimeType = mimeTable.getContentTypeFor(path); <line5> if (mimeType != null) { <line6> return new StringValue(mimeType.getName()); <line7> } <line8> } else { <line9> try { <line10> XmldbURI pathUri = XmldbURI.xmldbUriFor(path); <line11> pathUri = context.getBaseURI().toXmldbURI().resolveCollectionPath(pathUri); <line12> try (final LockedDocument lockedDoc = <line13> context.getBroker().getXMLResource(pathUri, LockMode.READ_LOCK)) { <line14> if (lockedDoc != null) { <line15> return new StringValue(lockedDoc.getDocument().getMimeType()); <line16> } <line17> } <line18> } catch (final Exception e) { <line19> throw new XPathException(this, e); <line20> } <line21> } <line22> return Sequence.EMPTY_SEQUENCE; <line23> } <line24> } <line25> "	<line19>        logger.error(e.getMessage());	task4	
public class A { <line0> private void createControl(UIElementConfig element, boolean isMenu, String parentEntry) { <line1> if (element == null) { <line2> return; <line3> } <line4> if (!isMenu <line5> && (element.getType() == UIElementType.MENUITEM <line6> || element.getType() == UIElementType.BUTTON)) { <line7> XControl button = <line8> GuiFactory.createButton( <line9> UNO.xMCF, context, element.getLabel(), null, new Rectangle(0, 0, 100, 32), null); <line10> XButton xbutton = UNO.XButton(button); <line11> AbstractActionListener xButtonAction = event -> processUiElementEvent(element); <line12> xbutton.addActionListener(xButtonAction); <line13> controlContainer.addControl(element.getId(), button); <line14> layout.addControl(button); <line15> } else if (element.getType() == UIElementType.SENDERBOX) { <line16> createSenderbox(element); <line17> } else if (element.getType() == UIElementType.SEARCHBOX) { <line18> createSearchbox(element); <line19> } else if (element.getType() == UIElementType.MENU) { <line20> XMutableTreeNode node = dataModel.createNode(element.getLabel(), false); <line21> if (parentEntry == null) { <line22> ((XMutableTreeNode) dataModel.getRoot()).appendChild(node); <line23> } else { <line24> menus.get(parentEntry).appendChild(node); <line25> } <line26> menus.put(element.getMenu(), node); <line27> } else if (isMenu <line28> && menus.get(parentEntry) != null <line29> && (element.getType() == UIElementType.MENUITEM <line30> || element.getType() == UIElementType.BUTTON)) { <line31> XMutableTreeNode node = dataModel.createNode(element.getLabel(), false); <line32> menus.get(parentEntry).appendChild(node); <line33> UUID uuid = UUID.randomUUID(); <line34> actions.put(uuid.toString(), () -> processUiElementEvent(element)); <line35> node.setDataValue(uuid.toString()); <line36> } <line37> } <line38> } <line39> 	"<line2>      LOGGER.debug(""Unbekanntes Element."");"	task4	
public class A { <line0> @Before <line1> public void setUp() throws Exception { <line2> SUT = new Payload2TcpProtocol(); <line3> channelHandlerContextMock = mock(ChannelHandlerContext.class, RETURNS_DEEP_STUBS); <line4> byte[] bytes = amsTCPPacket.getBytes(); <line5> } <line6> } <line7> 	"<line5>    LOGGER.info(""amsPacket:\n{} has \n{}bytes\nHexDump:\n{}"",amsTCPPacket,bytes.length,amsTCPPacket.dump());"	task4	
public class A { <line0> private void publishRegisterURI(final List<URIRegisterDTO> registerDTOList) { <line1> publisher.publish(registerDTOList); <line2> } <line3> } <line4> 	"<line1>    log.info(""publish uri: {}"", registerDTOList);"	task4	
public class A { <line0> @Override <line1> public Future<Void> close(final SpanContext spanContext) { <line2> mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId); <line3> consumerLinkTenants.remove(tenantId); <line4> final Promise<Void> result = Promise.promise(); <line5> connection.closeAndFree(receiver, receiverClosed -> result.complete()); <line6> return result.future(); <line7> } <line8> } <line9> 	"<line2>    log.debug(""MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed locally"",tenantId);"	task4	
"public class A { <line0> @ExpectedLog( <line1> expectedClass = ElasticsearchIndexWriter.class, <line2> expectedLevel = ExpectedLog.Level.WARNING, <line3> expectedLog = ""no such index"") <line4> @Test <line5> public void testCommit() { <line6> SearchContext searchContext = new SearchContext(); <line7> searchContext.setCompanyId(1); <line8> IndexWriter indexWriter = getIndexWriter(); <line9> try { <line10> indexWriter.commit(searchContext); <line11> } catch (SearchException searchException) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> } <line15> } <line16> } <line17> "	<line13>        log.debug(searchException, searchException);	task4	
"public class A { <line0> protected CleanupJobState jobReachedTerminalState(ExecutionGraphInfo executionGraphInfo) { <line1> final ArchivedExecutionGraph archivedExecutionGraph = <line2> executionGraphInfo.getArchivedExecutionGraph(); <line3> Preconditions.checkArgument( <line4> archivedExecutionGraph.getState().isTerminalState(), <line5> ""Job %s is in state %s which is not terminal."", <line6> archivedExecutionGraph.getJobID(), <line7> archivedExecutionGraph.getState()); <line8> archiveExecutionGraph(executionGraphInfo); <line9> return archivedExecutionGraph.getState().isGloballyTerminalState() <line10> ? CleanupJobState.GLOBAL <line11> : CleanupJobState.LOCAL; <line12> } <line13> } <line14> "	"<line8>    log.info(""Job {} reached terminal state {}."",archivedExecutionGraph.getJobID(),archivedExecutionGraph.getState());"	task4	
public class A { <line0> protected void setPageType(File file, String pageType) { <line1> try { <line2> UserDefinedFileAttributeView view = getAttributeView(file); <line3> view.write(ATTRIBUTE_PAGE_TYPE, Charset.defaultCharset().encode(pageType)); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.debug(""cannot set pageType for {}"", file, ex);"	task4	
"public class A { <line0> protected void handleErrorRecord(String[] flatRow, Exception ex) throws IOException { <line1> errorRecordCounter++; <line2> if (errorRecordCounter > cubeSegment.getConfig().getErrorRecordThreshold()) { <line3> if (ex instanceof IOException) throw (IOException) ex; <line4> else if (ex instanceof RuntimeException) throw (RuntimeException) ex; <line5> else throw new RuntimeException("""", ex); <line6> } <line7> } <line8> } <line9> "	"<line1>    logger.error(""Insane record: "" + Arrays.toString(flatRow), ex);"	task4	
public class A { <line0> public static Collection<String> getFreeVars(TupleExpr tupleExpr) { <line1> if (tupleExpr instanceof FedXTupleExpr) { <line2> return ((FedXTupleExpr) tupleExpr).getFreeVars(); <line3> } <line4> if (tupleExpr instanceof VariableExpr) { <line5> return ((VariableExpr) tupleExpr).getFreeVars(); <line6> } <line7> if (tupleExpr instanceof NTuple) { <line8> HashSet<String> freeVars = new HashSet<>(); <line9> NTuple ntuple = (NTuple) tupleExpr; <line10> for (TupleExpr t : ntuple.getArgs()) { <line11> freeVars.addAll(getFreeVars(t)); <line12> } <line13> return freeVars; <line14> } <line15> if (tupleExpr instanceof FedXService) { <line16> return ((FedXService) tupleExpr).getFreeVars(); <line17> } <line18> if (tupleExpr instanceof Service) { <line19> return ((Service) tupleExpr).getServiceVars(); <line20> } <line21> if (tupleExpr instanceof StatementPattern) { <line22> List<String> freeVars = new ArrayList<>(); <line23> StatementPattern st = (StatementPattern) tupleExpr; <line24> if (st.getSubjectVar().getValue() == null) { <line25> freeVars.add(st.getSubjectVar().getName()); <line26> } <line27> if (st.getPredicateVar().getValue() == null) { <line28> freeVars.add(st.getPredicateVar().getName()); <line29> } <line30> if (st.getObjectVar().getValue() == null) { <line31> freeVars.add(st.getObjectVar().getName()); <line32> } <line33> return freeVars; <line34> } <line35> if (tupleExpr instanceof Projection) { <line36> Projection p = (Projection) tupleExpr; <line37> return new ArrayList<>(p.getBindingNames()); <line38> } <line39> if (tupleExpr instanceof BindingSetAssignment) { <line40> return new ArrayList<>(); <line41> } <line42> if (tupleExpr instanceof Extension) { <line43> return new ArrayList<>(tupleExpr.getBindingNames()); <line44> } <line45> if (tupleExpr instanceof ArbitraryLengthPath) { <line46> return getFreeVars(((ArbitraryLengthPath) tupleExpr).getPathExpression()); <line47> } <line48> if (tupleExpr instanceof LeftJoin) { <line49> LeftJoin l = (LeftJoin) tupleExpr; <line50> HashSet<String> freeVars = new HashSet<>(); <line51> freeVars.addAll(getFreeVars(l.getLeftArg())); <line52> freeVars.addAll(getFreeVars(l.getRightArg())); <line53> return freeVars; <line54> } <line55> return new ArrayList<>(); <line56> } <line57> } <line58> 	"<line55>    log.debug(""Type ""+ tupleExpr.getClass().getSimpleName()+ "" not supported for computing free vars. If you run into this, please report a bug."");"	task4	
"public class A { <line0> @LogToResult <line1> public void saveResult( <line2> String testCaseId, <line3> String startTime, <line4> String stopTime, <line5> String lastURL, <line6> String browserInfo, <line7> boolean forward) <line8> throws SakuliCheckedException { <line9> if (!loader.getCurrentTestCase().getId().equals(testCaseId)) { <line10> handleException( <line11> ""testcaseID '"" + testCaseId + ""' to save the test case Result ist is not valid!""); <line12> } <line13> TestSuite testSuite = loader.getTestSuite(); <line14> testSuite.setBrowserInfo(browserInfo); <line15> TestCase tc = loader.getCurrentTestCase(); <line16> tc.setLastURL(lastURL); <line17> try { <line18> tc.setStartDate(new Date(Long.parseLong(startTime))); <line19> tc.setStopDate(new Date(Long.parseLong(stopTime))); <line20> tc.refreshState(); <line21> } catch (NumberFormatException | NullPointerException e) { <line22> handleException( <line23> ""Duration could not be calculated! "" <line24> + ""Check if the warning and critical threshold is set correctly in your test case!  "" <line25> + ""=> START date: "" <line26> + startTime <line27> + ""\tSTOP date: "" <line28> + stopTime <line29> + ""\n"" <line30> + e.getMessage()); <line31> } <line32> loader.setCurrentTestCase(null); <line33> if (forward) { <line34> forwardTestDataEntity(tc); <line35> } <line36> } <line37> } <line38> "	"<line20>      logger.debug(""test case duration = "" + tc.getDuration());"	task4	
"public class A { <line0> public void connectToScaleDownTarget(ScaleDownPolicy scaleDownPolicy) { <line1> try { <line2> scaleDownServerLocator = <line3> ScaleDownPolicy.getScaleDownConnector(scaleDownPolicy, activeMQServer); <line4> scaleDownServerLocator.setProtocolManagerFactory( <line5> ActiveMQServerSideProtocolManagerFactory.getInstance( <line6> scaleDownServerLocator, activeMQServer.getStorageManager())); <line7> LiveNodeLocator nodeLocator = <line8> scaleDownPolicy.getGroupName() == null <line9> ? new AnyLiveNodeLocatorForScaleDown(activeMQServer) <line10> : new NamedLiveNodeLocatorForScaleDown( <line11> scaleDownPolicy.getGroupName(), activeMQServer); <line12> scaleDownServerLocator.addClusterTopologyListener(nodeLocator); <line13> nodeLocator.connectToCluster(scaleDownServerLocator); <line14> nodeLocator.locateNode(ActiveMQClient.DEFAULT_DISCOVERY_INITIAL_WAIT_TIMEOUT); <line15> ClientSessionFactoryInternal clientSessionFactory = null; <line16> while (clientSessionFactory == null) { <line17> Pair<TransportConfiguration, TransportConfiguration> possibleLive = null; <line18> possibleLive = nodeLocator.getLiveConfiguration(); <line19> if (possibleLive == null) break; <line20> try { <line21> clientSessionFactory = <line22> (ClientSessionFactoryInternal) <line23> scaleDownServerLocator.createSessionFactory(possibleLive.getA(), 0, false); <line24> } catch (Exception e) { <line25> nodeLocator.notifyRegistrationFailed(false); <line26> if (clientSessionFactory != null) { <line27> clientSessionFactory.close(); <line28> } <line29> clientSessionFactory = null; <line30> } <line31> } <line32> if (clientSessionFactory != null) { <line33> scaleDownClientSessionFactory = clientSessionFactory; <line34> } else { <line35> throw new ActiveMQException(""Unable to connect to server for scale-down""); <line36> } <line37> } catch (Exception e) { <line38> ActiveMQServerLogger.LOGGER.failedToScaleDown(e); <line39> } <line40> } <line41> } <line42> "	"<line25>          logger.trace(""Failed to connect to "" + possibleLive.getA());"	task4	
public class A { <line0> private void resolveLock(BackOffer backOffer, Lock lock) { <line1> if (lockResolverClient != null) { <line2> ResolveLockResult resolveLockResult = <line3> lockResolverClient.resolveLocks( <line4> backOffer, callerStartTS, Collections.singletonList(lock), forWrite); <line5> resolveLockResultCallback.apply(resolveLockResult); <line6> long msBeforeExpired = resolveLockResult.getMsBeforeTxnExpired(); <line7> if (msBeforeExpired > 0) { <line8> backOffer.doBackOffWithMaxSleep( <line9> BoTxnLockFast, msBeforeExpired, new KeyException(lock.toString())); <line10> } <line11> } <line12> } <line13> } <line14> 	"<line2>      logger.warn(""resolving lock"");"	task4	
"public class A { <line0> private void writeCalibrator(XMLStreamWriter doc, Calibrator calibrator) <line1> throws XMLStreamException { <line2> if (calibrator instanceof PolynomialCalibrator) { <line3> doc.writeStartElement(""PolynomialCalibrator""); <line4> double[] coefficients = ((PolynomialCalibrator) calibrator).getCoefficients(); <line5> for (int i = 0; i < coefficients.length; i++) { <line6> doc.writeStartElement(""Term""); <line7> doc.writeAttribute(""exponent"", Integer.toString(i)); <line8> doc.writeAttribute(""coefficient"", Double.toString(coefficients[i])); <line9> doc.writeEndElement(); <line10> } <line11> doc.writeEndElement(); <line12> } else if (calibrator instanceof SplineCalibrator) { <line13> doc.writeStartElement(""SplineCalibrator""); <line14> for (SplinePoint sp : ((SplineCalibrator) calibrator).getPoints()) { <line15> doc.writeStartElement(""SplinePoint""); <line16> doc.writeAttribute(""raw"", Double.toString(sp.getRaw())); <line17> doc.writeAttribute(""calibrated"", Double.toString(sp.getCalibrated())); <line18> doc.writeEndElement(); <line19> } <line20> doc.writeEndElement(); <line21> } else if (calibrator instanceof MathOperationCalibrator) { <line22> doc.writeStartElement(""MathOperationCalibrator""); <line23> writeMathOperation(doc, (MathOperationCalibrator) calibrator); <line24> doc.writeEndElement(); <line25> } else { <line26> } <line27> } <line28> } <line29> "	"<line26>      log.error(""Unsupported calibrator  type "" + calibrator.getClass());"	task4	
"public class A { <line0> protected ExecutionResult prepareNetworkElementCommand(final SetupGuestNetworkCommand cmd) { <line1> final NicTO nic = cmd.getNic(); <line2> final String domrName = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME); <line3> try { <line4> final URI broadcastUri = nic.getBroadcastUri(); <line5> final String vlanId = BroadcastDomainType.getValue(broadcastUri); <line6> final int ethDeviceNum = getVmNics(domrName, vlanId); <line7> if (ethDeviceNum > 0) { <line8> nic.setDeviceId(ethDeviceNum); <line9> } else { <line10> return new ExecutionResult( <line11> false, ""Prepare SetupGuestNetwork failed due to unable to find the nic""); <line12> } <line13> } catch (final Exception e) { <line14> final String msg = ""Prepare SetupGuestNetwork failed due to "" + e.toString(); <line15> return new ExecutionResult(false, msg); <line16> } <line17> return new ExecutionResult(true, null); <line18> } <line19> } <line20> "	<line15>      logger.warn(msg, e);	task4	
public class A { <line0> @Override <line1> public PolicyFinderResult findPolicy(EvaluationCtx context) { <line2> try { <line3> AbstractPolicy policy = m_policyManager.getPolicy(context); <line4> if (policy == null) { <line5> return new PolicyFinderResult(); <line6> } <line7> return new PolicyFinderResult(policy); <line8> } catch (TopLevelPolicyException tlpe) { <line9> return new PolicyFinderResult(tlpe.getStatus()); <line10> } catch (PolicyIndexException pdme) { <line11> if (logger.isDebugEnabled()) { <line12> } <line13> List<String> codes = new ArrayList<String>(); <line14> codes.add(Status.STATUS_PROCESSING_ERROR); <line15> return new PolicyFinderResult(new Status(codes, pdme.getMessage())); <line16> } <line17> } <line18> } <line19> 	"<line12>        logger.debug(""problem processing policy"", pdme);"	task4	
"public class A { <line0> @Override <line1> @Deprecated <line2> public String getExternalizableBusinessObjectInquiryUrl( <line3> Class inquiryBusinessObjectClass, Map<String, String[]> parameters) { <line4> if (!isExternalizable(inquiryBusinessObjectClass)) { <line5> return KRADConstants.EMPTY_STRING; <line6> } <line7> String businessObjectClassAttribute; <line8> Class implementationClass = <line9> getExternalizableBusinessObjectImplementation(inquiryBusinessObjectClass); <line10> if (implementationClass == null) { <line11> throw new RuntimeException( <line12> ""Can't find ExternalizableBusinessObject implementation class for interface "" <line13> + inquiryBusinessObjectClass.getName()); <line14> } <line15> businessObjectClassAttribute = implementationClass.getName(); <line16> return UrlFactory.parameterizeUrl( <line17> getInquiryUrl(inquiryBusinessObjectClass), <line18> getUrlParameters(businessObjectClassAttribute, parameters)); <line19> } <line20> } <line21> "	"<line11>      LOG.error(""Can't find ExternalizableBusinessObject implementation class for ""+ inquiryBusinessObjectClass.getName());"	task4	
public class A { <line0> @Override <line1> public void execute() { <line2> lock.lock(); <line3> try { <line4> while (!initialized) { <line5> initializedCond.await(); <line6> } <line7> } catch (InterruptedException e) { <line8> return; <line9> } finally { <line10> lock.unlock(); <line11> } <line12> task.execute(); <line13> } <line14> } <line15> 	"<line8>      log.error(""Task could not be initialized hence not be executed."", e);"	task4	
public class A { <line0> public Map<String, ApiMethod> getWidgetTypeApiMappings() { <line1> Map<String, ApiMethod> mappings = null; <line2> try { <line3> mappings = this.getApiCatalogManager().getRelatedWidgetMethods(); <line4> } catch (Throwable t) { <line5> } <line6> return mappings; <line7> } <line8> } <line9> 	"<line5>      logger.error(""error in getWidgetTypeApiMappings"", t);"	task4	
"public class A { <line0> public List<TripleStoreChange> convertUpdate(IidmChangeUpdate change) { <line1> TripleStoreSimpleUpdateReference simpleUpdateReference = simpleUpdateReference(change); <line2> if (simpleUpdateReference != null) { <line3> String subject = change.getIdentifiable().getId(); <line4> String value = simpleUpdateReference.value(change); <line5> TripleStoreChangeParams updateParams = <line6> new TripleStoreChangeParams(simpleUpdateReference, value); <line7> TripleStoreChange tschange = new TripleStoreChange(""update"", subject, updateParams); <line8> return Collections.singletonList(tschange); <line9> } else if (ignoredAttributes.contains(change.getAttribute())) { <line10> return Collections.emptyList(); <line11> } else { <line12> return Collections.emptyList(); <line13> } <line14> } <line15> } <line16> "	"<line12>      LOG.warn(""Convert to CGMES a change on IIDM {}.{}"",change.getIdentifiable().getClass().getSimpleName(),change.getAttribute());"	task4	
"public class A { <line0> private void checkClientJoinsWhenActivationIsInProgress(ClusterState state) throws Exception { <line1> assertActive(state); <line2> startGridsAndLoadData(5, state); <line3> stopAllGrids(); <line4> Ignite srv = startGrids(5); <line5> final CountDownLatch clientStartLatch = new CountDownLatch(1); <line6> IgniteInternalFuture clStartFut = <line7> GridTestUtils.runAsync( <line8> () -> { <line9> try { <line10> clientStartLatch.await(); <line11> Thread.sleep(10); <line12> client = true; <line13> Ignite cl = startGrid(""client0""); <line14> IgniteCache<Object, Object> atomicCache = cl.cache(CACHE_NAME_PREFIX + '0'); <line15> IgniteCache<Object, Object> txCache = cl.cache(CACHE_NAME_PREFIX + '1'); <line16> assertEquals(state == ACTIVE ? 100 : 0, atomicCache.size()); <line17> assertEquals(state == ACTIVE ? 100 : 0, txCache.size()); <line18> } catch (Exception e) { <line19> fail(""Error occurred in client thread. Msg: "" + e.getMessage()); <line20> } <line21> }, <line22> ""client-starter-thread""); <line23> clientStartLatch.countDown(); <line24> srv.cluster().state(state); <line25> clStartFut.get(); <line26> } <line27> } <line28> "	"<line19>                log.error(""Error occurred"", e);"	task4	
public class A { <line0> public static String map(String principal) { <line1> for (AuthorizationMapping am : authorizationMapping) { <line2> if (Log.isDebugEnabled()) { <line3> } <line4> String username = am.map(principal); <line5> if (!username.equals(principal)) { <line6> return username; <line7> } <line8> } <line9> return principal; <line10> } <line11> } <line12> 	"<line3>        Log.debug(""AuthorizationManager: Trying "" + am.name() + "".map("" + principal + "")"");"	task4	
"public class A { <line0> @Factory(scope = ScopeType.APPLICATION, value = ""connectUpdateStatusInfo"") <line1> public ConnectUpdateStatusInfo getConnectUpdateStatusInfo() { <line2> if (connectionStatusCache == null) { <line3> try { <line4> if (!isRegistred()) { <line5> connectionStatusCache = ConnectUpdateStatusInfo.unregistered(); <line6> } else { <line7> if (isConnectBannerEnabled() && isConnectServerReachable()) { <line8> if (getStatus().isError()) { <line9> connectionStatusCache = ConnectUpdateStatusInfo.connectServerUnreachable(); <line10> } else { <line11> if (ConnectStatusHolder.instance().getStatus().status() <line12> == SubscriptionStatusType.OK) { <line13> connectionStatusCache = ConnectUpdateStatusInfo.ok(); <line14> } else { <line15> connectionStatusCache = ConnectUpdateStatusInfo.notValid(); <line16> } <line17> } <line18> } else { <line19> connectionStatusCache = ConnectUpdateStatusInfo.connectServerUnreachable(); <line20> } <line21> } <line22> } catch (Exception e) { <line23> connectionStatusCache = null; <line24> } <line25> } <line26> return connectionStatusCache; <line27> } <line28> } <line29> "	<line23>        log.error(e);	task4	
"public class A { <line0> public static Map<String, Object> shipData(Map<String, String> params) { <line1> String jobName = params.get(""jobName""); <line2> if (jobName.isEmpty()) { <line3> jobName = ""aws-recommendations-collector""; <line4> } <line5> List<Map<String, String>> errorList = new ArrayList<>(); <line6> try { <line7> MainUtil.setup(params); <line8> } catch (Exception e) { <line9> Map<String, String> errorMap = new HashMap<>(); <line10> errorMap.put(ERROR, ""Exception in setting up Job ""); <line11> errorMap.put(ERROR_TYPE, WARN); <line12> errorMap.put(EXCEPTION, e.getMessage()); <line13> errorList.add(errorMap); <line14> return ErrorManageUtil.formErrorCode(jobName, errorList); <line15> } <line16> errorList.addAll(new RecommendationCollector().uploadRecommendationData()); <line17> Map<String, Object> status = ErrorManageUtil.formErrorCode(jobName, errorList); <line18> return status; <line19> } <line20> } <line21> "	"<line18>    LOGGER.info(""Job Return Status {} "", status);"	task4	
"public class A { <line0> public static Map<String, List<String>> fetchVPCtoNatIPInfo() { <line1> String endPoint = <line2> ""/aws_nat/nat/_search?filter_path=hits.hits._source.vpcid,hits.hits.inner_hits.nat_addresses.hits.hits._source.publicip""; <line3> String payLoad = <line4> ""{\""size\"":10000,\""_source\"":\""vpcid\"",\""query\"":{\""bool\"":{\""must\"":[{\""match\"":{\""latest\"":\""true\""}},{\""has_child\"":{\""type\"":\""nat_addresses\"",\""query\"":{\""match_all\"":{}},\""inner_hits\"":{\""size\"":100,\""_source\"":\""publicip\""}}}]}}}{\""size\"":10000,\""_source\"":\""vpcid\"",\""query\"":{\""bool\"":{\""must\"":[{\""match\"":{\""latest\"":\""true\""}},{\""has_child\"":{\""type\"":\""nat_addresses\"",\""query\"":{\""match_all\"":{}},\""inner_hits\"":{\""size\"":100,\""_source\"":\""publicip\""}}}]}}}""; <line5> Map<String, List<String>> VpcPublicIpInfo = new HashMap<>(); <line6> try { <line7> Response response = ElasticSearchManager.invokeAPI(""GET"", endPoint, payLoad); <line8> String responseJson = EntityUtils.toString(response.getEntity()); <line9> JsonParser jsonParser = new JsonParser(); <line10> JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson); <line11> JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(""hits"").toString()); <line12> JsonArray jsonArray = hitsJson.getAsJsonObject().get(""hits"").getAsJsonArray(); <line13> for (int i = 0; i < jsonArray.size(); i++) { <line14> JsonObject obj = (JsonObject) jsonArray.get(i); <line15> String vpcId = obj.get(SOURCE).getAsJsonObject().get(""vpcid"").getAsString(); <line16> JsonArray innerHits = <line17> obj.getAsJsonObject(""inner_hits"") <line18> .getAsJsonObject(""nat_addresses"") <line19> .getAsJsonObject(""hits"") <line20> .getAsJsonArray(""hits""); <line21> for (int j = 0; j < innerHits.size(); j++) { <line22> String ip = <line23> innerHits <line24> .get(j) <line25> .getAsJsonObject() <line26> .getAsJsonObject(SOURCE) <line27> .get(""publicip"") <line28> .getAsString(); <line29> List<String> ipList = VpcPublicIpInfo.get(vpcId); <line30> if (ipList == null) { <line31> ipList = new ArrayList<>(); <line32> VpcPublicIpInfo.put(vpcId, ipList); <line33> } <line34> ipList.add(ip); <line35> } <line36> } <line37> } catch (Exception e) { <line38> } <line39> return VpcPublicIpInfo; <line40> } <line41> } <line42> "	"<line38>      LOGGER.error(""Error in fetchVPCtoNatIPInfo"", e);"	task4	
"public class A { <line0> @Transition(to = ""MASTER"", from = ""SLAVE"") <line1> public void onBecomeMasterFromSlave(Message message, NotificationContext context) { <line2> String partitionName = message.getPartitionName(); <line3> String instanceName = message.getTgtName(); <line4> } <line5> } <line6> "	"<line4>    LOGGER.info(instanceName + "" becomes MASTER from SLAVE for "" + partitionName);"	task4	
public class A { <line0> public User find(final String username) { <line1> return userRepository.findByUsername(username); <line2> } <line3> } <line4> 	"<line1>    log.debug(""find() - username: {}"", username);"	task4	
public class A { <line0> @Override <line1> public CommerceOrder findByPrimaryKey(Serializable primaryKey) throws NoSuchOrderException { <line2> CommerceOrder commerceOrder = fetchByPrimaryKey(primaryKey); <line3> if (commerceOrder == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchOrderException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return commerceOrder; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
"public class A { <line0> private List<DataAvailabilityEventFilter> loadFilters() { <line1> List<DataAvailabilityEventFilter> filters = new ArrayList<>(config.getFilterClassList().size()); <line2> for (String filterClassName : config.getFilterClassList()) { <line3> try { <line4> DataAvailabilityEventFilter filter = <line5> (DataAvailabilityEventFilter) Class.forName(filterClassName).newInstance(); <line6> filters.add(filter); <line7> } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) { <line8> throw new IllegalArgumentException( <line9> ""Failed to initialize trigger event filter."", e.getCause()); <line10> } <line11> } <line12> return filters; <line13> } <line14> } <line15> "	"<line7>        LOG.info(""Loaded event filter: {}"", filterClassName);"	task4	
"public class A { <line0> private void parseIphoneSimSwitch(IItem item) { <line1> File file = null; <line2> try { <line3> file = File.createTempFile(""CellularUsage"", ""db""); <line4> try (InputStream is = item.getStream()) { <line5> Files.copy(is, file.toPath(), StandardCopyOption.REPLACE_EXISTING); <line6> } <line7> try (Connection conn = DriverManager.getConnection(""jdbc:sqlite:"" + file.getAbsolutePath()); <line8> Statement st = conn.createStatement()) { <line9> String sql = ""SELECT subscriber_mdn, last_update_time FROM subscriber_info""; <line10> ResultSet rs = st.executeQuery(sql); <line11> while (rs.next()) { <line12> String msisdn = rs.getString(1); <line13> if (msisdn != null && !msisdn.isEmpty()) { <line14> int time = rs.getInt(2); <line15> Date date = new Date((time + 978307200l) * 1000l); <line16> iphoneSimSwitch.put(date, msisdn); <line17> } <line18> } <line19> } <line20> } catch (Exception e) { <line21> e.printStackTrace(); <line22> } finally { <line23> if (file != null) file.delete(); <line24> } <line25> } <line26> } <line27> "	"<line21>      LOGGER.error(""Failed to parse "" + item.getPath(), e.toString());"	task4	
public class A { <line0> @Override <line1> public ReturnWithExceptions<Void, ModelObserver> aipCreated(final AIP aip) { <line2> ReturnWithExceptions<Void, ModelObserver> ret = new ReturnWithExceptions<>(this); <line3> try { <line4> List<String> ancestors = SolrUtils.getAncestors(aip.getParentId(), model); <line5> indexAIP(aip, ancestors).addTo(ret); <line6> if (ret.isEmpty()) { <line7> indexRepresentations(aip, ancestors).addTo(ret); <line8> if (ret.isEmpty()) { <line9> indexPreservationsEvents(aip.getId(), null).addTo(ret); <line10> if (ret.isEmpty()) { <line11> indexRetentionPeriod(aip, ancestors).addTo(ret); <line12> } <line13> } <line14> } <line15> } catch (RequestNotValidException | GenericException | AuthorizationDeniedException e) { <line16> ret.add(e); <line17> } <line18> return ret; <line19> } <line20> } <line21> 	"<line16>      LOGGER.error(""Error getting ancestors when creating AIP"", e);"	task4	
public class A { <line0> @Override <line1> protected @Nullable ThingHandler createHandler(Thing thing) { <line2> ThingTypeUID thingTypeUID = thing.getThingTypeUID(); <line3> if (BRIDGE_THING_TYPE.equals(thingTypeUID)) { <line4> return new BoxHandler((Bridge) thing, httpClient, commandDescriptionProvider); <line5> } else if (PL546E_STANDALONE_THING_TYPE.equals(thingTypeUID)) { <line6> return new Powerline546EHandler((Bridge) thing, httpClient, commandDescriptionProvider); <line7> } else if (SUPPORTED_BUTTON_THING_TYPES_UIDS.contains(thingTypeUID)) { <line8> return new AVMFritzButtonHandler(thing); <line9> } else if (SUPPORTED_HEATING_THING_TYPES.contains(thingTypeUID)) { <line10> return new AVMFritzHeatingDeviceHandler(thing); <line11> } else if (SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) { <line12> return new DeviceHandler(thing); <line13> } else if (GROUP_HEATING_THING_TYPE.equals(thingTypeUID)) { <line14> return new AVMFritzHeatingGroupHandler(thing); <line15> } else if (SUPPORTED_GROUP_THING_TYPES_UIDS.contains(thingTypeUID)) { <line16> return new GroupHandler(thing); <line17> } else { <line18> } <line19> return null; <line20> } <line21> } <line22> 	"<line18>      logger.error(""ThingHandler not found for {}"", thingTypeUID);"	task4	
"public class A { <line0> @Transactional <line1> private void deleteRecovery(ShardRecovery recovery) { <line2> int shardRecoveryDeleted = <line3> shardRecoveryDao.hardDeleteShardRecovery(recovery.getShardRecoveryId()); <line4> Shard shard = shardDao.getLastShard(); <line5> Objects.requireNonNull(shard, ""Shard record should exist!""); <line6> shardDao.hardDeleteShard(shard.getShardId()); <line7> } <line8> } <line9> "	"<line7>    log.debug(""Cleared shard records : shardRecovery - {}, shard id = {}"",shardRecoveryDeleted,shard.getShardId());"	task4	
public class A { <line0> public static int searchCount( <line1> long companyId, long[] groupIds, long[] classNameIds, String keywords, boolean active) <line2> throws RemoteException { <line3> try { <line4> int returnValue = <line5> CalendarResourceServiceUtil.searchCount( <line6> companyId, groupIds, classNameIds, keywords, active); <line7> return returnValue; <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public XAResource[] getXAResources(final ActivationSpec[] specs) throws ResourceException { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> if (useAutoRecovery) { <line5> return null; <line6> } else { <line7> List<XAResource> xaresources = new ArrayList<>(); <line8> for (ActivationSpec spec : specs) { <line9> ActiveMQActivation activation = activations.get(spec); <line10> if (activation != null) { <line11> xaresources.addAll(activation.getXAResources()); <line12> } <line13> } <line14> return xaresources.toArray(new XAResource[xaresources.size()]); <line15> } <line16> } <line17> } <line18> 	"<line3>      logger.trace(""getXAResources("" + Arrays.toString(specs) + "")"");"	task4	
public class A { <line0> public void selectLink() { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> } <line4> } <line5> 	"<line2>      LOG.debug(""selectLink() called ..."");"	task4	
public class A { <line0> private void createIndexWithMapping(Client client, String indexName, String indexType) { <line1> try { <line2> client <line3> .admin() <line4> .indices() <line5> .create(new CreateIndexRequest(indexName).mapping(indexType, jsonMapping)) <line6> .actionGet(); <line7> indexCache.add(indexName); <line8> } catch (IndexAlreadyExistsException e) { <line9> } <line10> } <line11> } <line12> 	"<line9>      logger.info(""The index "" + indexName + "" already exists"");"	task4	
"public class A { <line0> protected void doDone( <line1> Exchange original, <line2> Exchange subExchange, <line3> final Iterable<ProcessorExchangePair> pairs, <line4> AsyncCallback callback, <line5> boolean doneSync, <line6> boolean forceExhaust) { <line7> AggregationStrategy strategy = getAggregationStrategy(subExchange); <line8> if (strategy != null) { <line9> strategy.onCompletion(subExchange); <line10> } <line11> removeAggregationStrategyFromExchange(original); <line12> boolean stoppedOnException = false; <line13> boolean exception = false; <line14> ExtendedExchange see = (ExtendedExchange) subExchange; <line15> boolean exhaust = <line16> forceExhaust || see != null && (see.getException() != null || see.isRedeliveryExhausted()); <line17> if (original.getException() != null <line18> || subExchange != null && subExchange.getException() != null) { <line19> stoppedOnException = isStopOnException(); <line20> exception = true; <line21> } <line22> if (subExchange != null) { <line23> if (stoppedOnException) { <line24> original.setException(subExchange.getException()); <line25> } else { <line26> ExchangeHelper.copyResults(original, subExchange); <line27> } <line28> } <line29> if (processorExchangeFactory != null && pairs != null) { <line30> try { <line31> for (ProcessorExchangePair pair : pairs) { <line32> processorExchangeFactory.release(pair.getExchange()); <line33> } <line34> } catch (Throwable e) { <line35> } <line36> } <line37> if (pairs instanceof Closeable) { <line38> IOHelper.close((Closeable) pairs, ""pairs"", LOG); <line39> } <line40> if (exception) { <line41> original.adapt(ExtendedExchange.class).setRedeliveryExhausted(exhaust); <line42> } <line43> reactiveExecutor.schedule(callback); <line44> } <line45> } <line46> "	"<line35>        LOG.warn(""Error releasing exchange due to "" + e.getMessage() + "". This exception is ignored."",e);"	task4	
"public class A { <line0> public static boolean createInitialContent( <line1> final Session session, <line2> final InstallationLogger history, <line3> String path, <line4> Set<AceBean> aceBeanSetFromConfig) <line5> throws RepositoryException, PathNotFoundException, ItemExistsException, <line6> ConstraintViolationException, VersionException, InvalidSerializedDataException, <line7> LockException, AccessDeniedException { <line8> String initialContent = findInitialContentInConfigsForPath(aceBeanSetFromConfig, history); <line9> if (StringUtils.isBlank(initialContent)) { <line10> return false; <line11> } else { <line12> try { <line13> String parentPath = StringUtils.substringBeforeLast(path, ""/""); <line14> if (!session.nodeExists(parentPath)) { <line15> history.incMissingParentPathsForInitialContent(); <line16> history.addVerboseMessage( <line17> LOG, ""Parent path "" + parentPath + "" missing for initial content at "" + path); <line18> return false; <line19> } <line20> importContent(session, path, initialContent); <line21> history.addMessage(LOG, ""Created initial content for path "" + path); <line22> return true; <line23> } catch (Exception e) { <line24> history.addWarning(LOG, ""Failed creating initial content for path "" + path + "": "" + e); <line25> return false; <line26> } <line27> } <line28> } <line29> } <line30> "	"<line25>        LOG.debug(""Exception: "" + e, e);"	task4	
public class A { <line0> protected void updateTask(String task) { <line1> listenerForwarder.setTask(task); <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>      LOGGER.info(task);	task4	
"public class A { <line0> private ByteArrayOutputStream getMetadataExport(Date minDate) { <line1> ByteArrayOutputStream os; <line2> try { <line3> MetadataExportParams exportParams = new MetadataExportParams(); <line4> if (minDate != null) { <line5> List<String> defaultFilterList = new ArrayList<>(); <line6> defaultFilterList.add(""lastUpdated:gte:"" + DateUtils.getLongGmtDateString(minDate)); <line7> exportParams.setDefaultFilter(defaultFilterList); <line8> exportParams.setDefaultFields(Lists.newArrayList("":all"")); <line9> metadataExportService.validate(exportParams); <line10> } <line11> os = new ByteArrayOutputStream(1024); <line12> RootNode metadata = metadataExportService.getMetadataAsNode(exportParams); <line13> nodeService.serialize(metadata, ""application/json"", os); <line14> } catch (Exception ex) { <line15> String message = <line16> ""Exception occurred while exporting metadata for capturing a metadata version"" <line17> + ex.getMessage(); <line18> throw new MetadataVersionServiceException(message, ex); <line19> } <line20> return os; <line21> } <line22> } <line23> "	<line18>      log.error(message, ex);	task4	
public class A { <line0> @Override <line1> public void addCompositePhenomenonForProcedure( <line2> String procedure, Collection<String> compositePhenomenon) { <line3> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line4> CacheValidation.noNullOrEmptyValues(COMPOSITE_PHENOMENON, compositePhenomenon); <line5> this.compositePhenomenonsForProcedure <line6> .computeIfAbsent(procedure, createSynchronizedSet()) <line7> .addAll(compositePhenomenon); <line8> addCompositePhenomenon(compositePhenomenon); <line9> } <line10> } <line11> 	"<line5>    LOG.trace(""Adding composite phenomenons {} to procedure {}"", compositePhenomenon, procedure);"	task4	
"public class A { <line0> private void handleEventBusException(Throwable exception, SubscriberExceptionContext context) { <line1> LocalDateTime occurred = LocalDateTime.now(); <line2> String summary = <line3> ""Event Bus Exception within "" <line4> + context.getSubscriberMethod() <line5> + "" at "" <line6> + occurred <line7> + "" - "" <line8> + ExceptionUtils.getStackFrames(exception)[0]; <line9> String message = <line10> ""\nThe following exception occurred during event handling within "" <line11> + context.getSubscriberMethod() <line12> + "" at "" <line13> + occurred <line14> + "":\n"" <line15> + ExceptionUtils.getStackTrace(exception); <line16> Notification notification = new Notification(EVENT_BUS_EXCEPTION, occurred, summary, message); <line17> eventBus().post(notification); <line18> } <line19> } <line20> "	"<line1>    logger.error(""Event Bus Exception thrown during event handling within "" + context.getSubscriberMethod(),exception);"	task4	
public class A { <line0> @After <line1> public void tearDown() { <line2> SimulatorAssistant.waitForSwitchSimulatorOn(switchSim); <line3> SimulatorAssistant.tearDownSwitchSimulatorAfterScenario( <line4> switchSim, scenarioPool, getFailSafeTimeout()); <line5> if (finalCheck != null) { <line6> finalCheck.run(); <line7> } <line8> } <line9> } <line10> 	"<line6>      LOG.info(""starting final check"");"	task4	
"public class A { <line0> @Activate <line1> public void activate() { <line2> resourcePath = ""./target""; <line3> } <line4> } <line5> "	"<line2>    logger.info(""Document servlet started"");"	task4	
public class A { <line0> public void debug(Marker marker, String format, Object arg) { <line1> if (!logger.isDebugEnabled(marker)) { <line2> return; <line3> } <line4> } <line5> } <line6> 	"<line4>    logger.debug(marker, requestId + "" "" + format, arg);"	task4	
public class A { <line0> public static com.liferay.commerce.bom.model.CommerceBOMDefinitionSoap[] <line1> getCommerceBOMDefinitions(long commerceBOMFolderId, int start, int end) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.commerce.bom.model.CommerceBOMDefinition> returnValue = <line5> CommerceBOMDefinitionServiceUtil.getCommerceBOMDefinitions( <line6> commerceBOMFolderId, start, end); <line7> return com.liferay.commerce.bom.model.CommerceBOMDefinitionSoap.toSoapModels(returnValue); <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
public class A { <line0> private <T> boolean checkDqlRecord(ConsumerRecord<String, T> record) { <line1> errors++; <line2> if (errors >= expectedErrors) { <line3> return false; <line4> } <line5> return true; <line6> } <line7> } <line8> 	"<line1>    LOG.debug(""Received: {}"", record.value());"	task4	
public class A { <line0> private static final GanttTask convertToGanttObject( <line1> final GanttChartData ganttChartData, final TaskTree taskTree, final TaskDO task) { <line2> if (task == null) { <line3> return null; <line4> } <line5> final GanttTask ganttObject = convertToGanttObject(task); <line6> if (ganttChartData.getRootObject() == null) { <line7> ganttChartData.setRootObject(ganttObject); <line8> } <line9> final TaskNode taskNode = taskTree.getTaskNodeById(task.getId()); <line10> if (taskNode.hasChildren()) { <line11> for (final TaskNode childNode : taskNode.getChildren()) { <line12> if (!childNode.isDeleted()) { <line13> ganttObject.addChild(convertToGanttObject(ganttChartData, taskTree, childNode.getTask())); <line14> } <line15> } <line16> } <line17> return ganttObject; <line18> } <line19> } <line20> 	"<line3>      log.warn(""Oups, task shouldn't be null."");"	task4	
"public class A { <line0> private String _getLocalizedRootCategoryName(Group group, Locale locale) { <line1> try { <line2> return LanguageUtil.get(locale, ""home"") + "" - "" + group.getDescriptiveName(locale); <line3> } catch (PortalException portalException) { <line4> return LanguageUtil.get(locale, ""home""); <line5> } <line6> } <line7> } <line8> "	"<line4>      log.error(""Unable to get descriptive name for group "" + group.getGroupId(), portalException);"	task4	
"public class A { <line0> public void clearLocalStatistics(StatisticsKey key, Set<String> colNames) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> if (locStats == null) { <line4> log.warning(""Unable to clear local statistics for "" + key + "" on non server node.""); <line5> return; <line6> } <line7> locStats.computeIfPresent( <line8> key, <line9> (k, v) -> { <line10> ObjectStatisticsImpl locStatNew = subtract(v, colNames); <line11> return locStatNew.columnsStatistics().isEmpty() ? null : locStatNew; <line12> }); <line13> } <line14> } <line15> "	"<line2>      log.debug(""Clear local statistics [key="" + key + "", columns="" + colNames + ']');"	task4	
"public class A { <line0> public List<TimeValues> querySeriesInternal( <line1> String s, Pair<ZonedDateTime, ZonedDateTime> timeRange, String function) { <line2> Long from = zonedCovertToLong(timeRange.left); <line3> Long to = zonedCovertToLong(timeRange.right); <line4> final long hours = Duration.between(timeRange.left, timeRange.right).toHours(); <line5> String sql = <line6> String.format( <line7> ""SELECT %s FROM root.%s WHERE time > %d and time < %d"", <line8> s.substring(s.lastIndexOf('.') + 1), <line9> s.substring(0, s.lastIndexOf('.')), <line10> from * timestampRadioX, <line11> to * timestampRadioX); <line12> String columnName = ""root."" + s; <line13> String intervalLocal = getInterval(hours); <line14> if (!intervalLocal.equals("""")) { <line15> sql = <line16> String.format( <line17> ""SELECT "" <line18> + function <line19> + ""(%s) FROM root.%s WHERE time > %d and time < %d group by ([%d, %d),%s)"", <line20> s.substring(s.lastIndexOf('.') + 1), <line21> s.substring(0, s.lastIndexOf('.')), <line22> from * timestampRadioX, <line23> to * timestampRadioX, <line24> from * timestampRadioX, <line25> to * timestampRadioX, <line26> intervalLocal); <line27> columnName = function + ""(root."" + s + "")""; <line28> } <line29> return jdbcTemplate.query(sql, new TimeValuesRowMapper(columnName)); <line30> } <line31> } <line32> "	<line29>    logger.info(sql);	task4	
public class A { <line0> @Test <line1> public void testQueryWebPageQueryEmptyResults() throws Exception { <line2> DataStoreTestUtil.testQueryWebPageEmptyResults(webPageStore); <line3> } <line4> } <line5> 	"<line2>    log.info(""test method: testQueryEmptyResults"");"	task4	
"public class A { <line0> private void addEntryToTar(File source, String entryName, byte[] buffer, int length) <line1> throws IOException, ArchiveException { <line2> File tmpTar = Files.createTempFile(parentDir.toPath(), source.getName(), null).toFile(); <line3> tmpTar.delete(); <line4> if (!source.renameTo(tmpTar)) { <line5> throw new IOException(""Cannot create temp file: "" + source.getName()); <line6> } <line7> FileInputStream fis = new FileInputStream(tmpTar); <line8> TarArchiveInputStream tin = <line9> (TarArchiveInputStream) <line10> new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, fis); <line11> TarArchiveOutputStream tos = new TarArchiveOutputStream(new FileOutputStream(source)); <line12> tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX); <line13> tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX); <line14> ArchiveEntry nextEntry; <line15> while ((nextEntry = tin.getNextEntry()) != null) { <line16> tos.putArchiveEntry(nextEntry); <line17> IOUtils.copy(tin, tos); <line18> tos.closeArchiveEntry(); <line19> } <line20> TarArchiveEntry entry = new TarArchiveEntry(entryName); <line21> entry.setSize(length); <line22> tos.putArchiveEntry(entry); <line23> tos.write(buffer, 0, length); <line24> tos.closeArchiveEntry(); <line25> IOHelper.close(fis, tin, tos); <line26> FileUtil.deleteFile(tmpTar); <line27> } <line28> } <line29> "	"<line26>    LOG.trace(""Deleting temporary file: {}"", tmpTar);"	task4	
public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> store.close(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.error(""Could not close the metrics service, some metrics may have not been written"", e);"	task4	
"public class A { <line0> @Override <line1> public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName) <line2> throws SAXException { <line3> if (""Alarm"".equals(qName)) { <line4> int finalID = 0; <line5> int finalVolume = 0; <line6> boolean finalEnabled = !""0"".equals(enabled); <line7> boolean finalIncludeLinkedZones = !""0"".equals(includeLinkedZones); <line8> try { <line9> String id = this.id; <line10> if (id == null) { <line11> throw new NumberFormatException(); <line12> } <line13> finalID = Integer.parseInt(id); <line14> String volume = this.volume; <line15> if (volume == null) { <line16> throw new NumberFormatException(); <line17> } <line18> finalVolume = Integer.parseInt(volume); <line19> } catch (NumberFormatException e) { <line20> } <line21> alarms.add( <line22> new SonosAlarm( <line23> finalID, <line24> startTime, <line25> duration, <line26> recurrence, <line27> finalEnabled, <line28> roomUUID, <line29> programURI, <line30> programMetaData, <line31> playMode, <line32> finalVolume, <line33> finalIncludeLinkedZones)); <line34> } <line35> } <line36> } <line37> "	"<line20>        LOGGER.debug(""Error parsing Integer"");"	task4	
"public class A { <line0> protected void appendLimitQueryBlock(FieldSearchFilter[] filters, StringBuffer query) { <line1> try { <line2> if (null == filters || filters.length == 0) { <line3> return; <line4> } <line5> for (FieldSearchFilter filter : filters) { <line6> if (filter.getOffset() != null && filter.getLimit() != null) { <line7> query.append( <line8> QueryLimitResolver.createLimitBlock( <line9> filter, this.getDataSource(), this.getDataSourceClassName())); <line10> break; <line11> } <line12> } <line13> } catch (Throwable t) { <line14> throw new RuntimeException(""error building limit query"", t); <line15> } <line16> } <line17> } <line18> "	"<line3>        logger.warn(""no filters"");"	task4	
public class A { <line0> public boolean isRunning() { <line1> if (nuxeoProcess != null) { <line2> try { <line3> nuxeoProcess.exitValue(); <line4> nuxeoProcess = null; <line5> } catch (IllegalThreadStateException exception) { <line6> return true; <line7> } <line8> } <line9> try { <line10> return (getPid() != null); <line11> } catch (IOException e) { <line12> return false; <line13> } <line14> } <line15> } <line16> 	<line12>      log.error(e);	task4	
"public class A { <line0> private List<String> getConnectedDevices() { <line1> String deviceUDID = ""(.*)\\tdevice$""; <line2> String[] cmd = CmdLine.insertCommandsAfter(executor.getDefaultCmd(), ""devices""); <line3> List<String> cmdOutput = executor.execute(cmd); <line4> List<String> connectedDevices = <line5> cmdOutput.stream() <line6> .parallel() <line7> .filter((d) -> d.matches(deviceUDID)) <line8> .collect(Collectors.toList()); <line9> return connectedDevices; <line10> } <line11> } <line12> "	"<line9>    LOGGER.debug(""Connected devices: "".concat(connectedDevices.toString()));"	task4	
public class A { <line0> public static Trigger getTrigger(String name) { <line1> if ((name == null) || (name.trim().isEmpty())) { <line2> return null; <line3> } <line4> for (Trigger trigger : TRIGGERS_LIST) { <line5> if (trigger.getName().equalsIgnoreCase(name.trim())) { <line6> return trigger; <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line9>    LOG.warn(""Searching for a trigger named \""{}\"" but it doesn't exist"", name);"	task4	
public class A { <line0> public void initTaskanaProperties(String propertiesFile, String separator) { <line1> if (LOGGER.isDebugEnabled()) { <line2> } <line3> Properties props = readPropertiesFromFile(propertiesFile); <line4> initTaskanaRoles(props, separator); <line5> initJobParameters(props); <line6> initDomains(props); <line7> initClassificationTypes(props); <line8> initClassificationCategories(props); <line9> initBooleanProperty( <line10> props, TASKANA_GERMAN_HOLIDAYS_ENABLED, this::setGermanPublicHolidaysEnabled); <line11> initBooleanProperty( <line12> props, TASKANA_GERMAN_HOLIDAYS_CORPUS_CHRISTI_ENABLED, this::setCorpusChristiEnabled); <line13> initBooleanProperty( <line14> props, <line15> TASKANA_HISTORY_DELETION_ON_TASK_DELETION_ENABLED, <line16> this::setDeleteHistoryOnTaskDeletionEnabled); <line17> initCustomHolidays(props, separator); <line18> } <line19> } <line20> 	"<line2>      LOGGER.debug(""Reading taskana configuration from {} with separator {}"", propertiesFile, separator);"	task4	
public class A { <line0> @Override <line1> protected DynRealmTO resolveReference(final Method method, final Object... args) <line2> throws UnresolvedReferenceException { <line3> String key = null; <line4> if (ArrayUtils.isNotEmpty(args)) { <line5> for (int i = 0; key == null && i < args.length; i++) { <line6> if (args[i] instanceof String) { <line7> key = (String) args[i]; <line8> } else if (args[i] instanceof DynRealmTO) { <line9> key = ((DynRealmTO) args[i]).getKey(); <line10> } <line11> } <line12> } <line13> if (key != null) { <line14> try { <line15> return binder.getDynRealmTO(dynRealmDAO.find(key)); <line16> } catch (Throwable ignore) { <line17> throw new UnresolvedReferenceException(ignore); <line18> } <line19> } <line20> throw new UnresolvedReferenceException(); <line21> } <line22> } <line23> 	"<line17>        LOG.debug(""Unresolved reference"", ignore);"	task4	
public class A { <line0> @Override <line1> public List<GenericEntity> getStudentSummaries( <line2> String token, List<String> studentIds, String sessionId, String sectionId) { <line3> long startTime = System.nanoTime(); <line4> List<GenericEntity> studentSummaries = entityManager.getStudents(token, sectionId); <line5> return studentSummaries; <line6> } <line7> } <line8> 	"<line5>    LOG.warn(""@@@@@@@@@@@@@@@@@@ Benchmark for student section view: {}"",(System.nanoTime() - startTime) * 1.0e-9);"	task4	
public class A { <line0> protected String getPlan(final String queryStr, boolean expandFields, boolean expandValues) <line1> throws Exception { <line2> Date[] startEndDate = this.dataManager.getShardStartEndDate(); <line3> if (log.isDebugEnabled()) { <line4> } <line5> QueryImpl q = new QueryImpl(); <line6> q.setBeginDate(startEndDate[0]); <line7> q.setEndDate(startEndDate[1]); <line8> q.setQuery(queryStr); <line9> q.setId(UUID.randomUUID()); <line10> q.setPagesize(Integer.MAX_VALUE); <line11> q.setQueryAuthorizations(auths.toString()); <line12> return this.logic.getPlan(client, q, this.authSet, expandFields, expandValues); <line13> } <line14> } <line15> 	"<line4>      log.debug(""  query[""+ queryStr+ ""]  start(""+ YMD_DateFormat.format(startEndDate[0])+ "")  end(""+ YMD_DateFormat.format(startEndDate[1])+ "")"");"	task4	
"public class A { <line0> private Bundle _addBundle(String location, InputStream inputStream, boolean checkPermission) <line1> throws PortalException { <line2> if (_framework == null) { <line3> throw new IllegalStateException(""OSGi framework is not initialized""); <line4> } <line5> if (checkPermission) { <line6> _checkPermission(); <line7> } <line8> BundleContext bundleContext = _framework.getBundleContext(); <line9> if (inputStream != null) { <line10> UnsyncBufferedInputStream unsyncBufferedInputStream = <line11> new UnsyncBufferedInputStream(inputStream); <line12> unsyncBufferedInputStream.mark(1024 * 1000); <line13> Bundle bundle = null; <line14> if (location.contains(""static=true"")) { <line15> bundle = _getStaticBundle(bundleContext, unsyncBufferedInputStream, location); <line16> } else { <line17> bundle = getBundle(bundleContext, unsyncBufferedInputStream); <line18> } <line19> try { <line20> unsyncBufferedInputStream.reset(); <line21> } catch (IOException ioException) { <line22> throw new PortalException(ioException); <line23> } <line24> if (bundle != null) { <line25> return bundle; <line26> } <line27> inputStream = unsyncBufferedInputStream; <line28> } <line29> try { <line30> return bundleContext.installBundle(location, inputStream); <line31> } catch (BundleException bundleException) { <line32> throw new PortalException(bundleException); <line33> } <line34> } <line35> } <line36> "	<line32>      log.error(bundleException, bundleException);	task4	
public class A { <line0> public void setTo(List<MailAddress> mailAddresses) throws MessagingException { <line1> if (!mailAddresses.isEmpty()) { <line2> InternetAddress[] internetAddresses = MailAddressUtils.toInternetAddressArray(mailAddresses); <line3> mail.getMessage().setRecipients(Message.RecipientType.TO, internetAddresses); <line4> if (mailet.getInitParameters().isDebug()) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        LOGGER.debug(""apparentlyTo set to: {}"", (Object) internetAddresses);"	task4	
"public class A { <line0> public static void main(String args[]) { <line1> try { <line2> LateralUDPReceiver lur = new LateralUDPReceiver(""228.5.6.7"", 6789); <line3> Thread t = new Thread(lur); <line4> t.start(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> "	<line6>      log.error(e.toString());	task4	
public class A { <line0> public static ColumnVisibility getColumnVisibilityForHit(Document document, String hitTerm) { <line1> int idx = hitTerm.indexOf(':'); <line2> if (idx == -1) return null; <line3> String hitName = hitTerm.substring(0, idx); <line4> String hitValue = hitTerm.substring(idx + 1); <line5> Attribute<?> documentAttribute = document.get(hitName); <line6> if (documentAttribute == null) { <line7> } else if (documentAttribute instanceof Attributes) { <line8> Attributes documentAttributes = (Attributes) documentAttribute; <line9> for (Attribute<?> documentAttr : documentAttributes.getAttributes()) { <line10> if (documentAttr instanceof TypeAttribute) { <line11> TypeAttribute<?> typeAttribute = (TypeAttribute) documentAttr; <line12> Type<?> type = typeAttribute.getType(); <line13> Collection<String> expansions = <line14> Sets.newHashSet(type.getNormalizedValue(), type.getDelegate().toString()); <line15> for (String expansion : expansions) { <line16> if (expansion.equals(hitValue)) { <line17> return documentAttr.getColumnVisibility(); <line18> } <line19> } <line20> } else if (hitValue.equals(documentAttr.getData())) { <line21> return documentAttr.getColumnVisibility(); <line22> } <line23> } <line24> } else { <line25> if (documentAttribute instanceof TypeAttribute) { <line26> TypeAttribute<?> typeAttribute = (TypeAttribute<?>) documentAttribute; <line27> Type<?> type = typeAttribute.getType(); <line28> Collection<String> expansions = <line29> Sets.newHashSet(type.getNormalizedValue(), type.getDelegate().toString()); <line30> for (String expansion : expansions) { <line31> if (expansion.equals(hitValue)) { <line32> return documentAttribute.getColumnVisibility(); <line33> } <line34> } <line35> } else if (hitValue.equals(documentAttribute.getData())) { <line36> return documentAttribute.getColumnVisibility(); <line37> } <line38> } <line39> return null; <line40> } <line41> } <line42> 	"<line7>      log.warn(""documentAttribute for hitTerm:"" + hitTerm + "" is null in document:"" + document);"	task4	
public class A { <line0> private void recordBulkOpEvent(InternalCacheEvent event, ThreadIdentifier threadID) { <line1> EventID eventID = event.getEventId(); <line2> VersionTag tag = event.getVersionTag(); <line3> if (tag == null) { <line4> return; <line5> } <line6> if (logger.isDebugEnabled()) { <line7> } <line8> RegionVersionVector versionVector = ((LocalRegion) event.getRegion()).getVersionVector(); <line9> canonicalizeIDs(tag, versionVector); <line10> boolean retry = false; <line11> do { <line12> BulkOperationHolder bulkOpTracker = recordedBulkOpVersionTags.get(threadID); <line13> if (bulkOpTracker == null) { <line14> bulkOpTracker = new BulkOperationHolder(); <line15> BulkOperationHolder old = recordedBulkOpVersionTags.putIfAbsent(threadID, bulkOpTracker); <line16> if (old != null) { <line17> retry = true; <line18> continue; <line19> } <line20> } <line21> synchronized (bulkOpTracker) { <line22> if (bulkOpTracker.isRemoved()) { <line23> retry = true; <line24> continue; <line25> } <line26> bulkOpTracker.putVersionTag(eventID, event.getVersionTag()); <line27> retry = false; <line28> } <line29> } while (retry); <line30> } <line31> } <line32> 	"<line7>      logger.debug(""recording bulkOp event {} {} {} op={}"",threadID.expensiveToString(),eventID,tag,event.getOperation());"	task4	
"public class A { <line0> @Override <line1> public void leave() { <line2> synchronized (viewInstallationLock) { <line3> GMSMembershipView<ID> view = currentView; <line4> isStopping = true; <line5> stopCoordinatorServices(); <line6> if (view != null) { <line7> if (view.size() > 1) { <line8> List<ID> coords = view.getPreferredCoordinators(Collections.emptySet(), localAddress, 5); <line9> LeaveRequestMessage<ID> m = <line10> new LeaveRequestMessage<>(coords, this.localAddress, ""this member is shutting down""); <line11> services.getMessenger().send(m); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> "	"<line9>          logger.debug(""Sending my leave request to {}"", coords);"	task4	
"public class A { <line0> private Directory getStoreDirectory(String store) throws BackendException { <line1> Preconditions.checkArgument(StringUtils.isAlphanumeric(store), ""Invalid store name: %s"", store); <line2> String dir = basePath + File.separator + store; <line3> try { <line4> File path = new File(dir); <line5> if (!path.exists()) path.mkdirs(); <line6> if (!path.exists() || !path.isDirectory() || !path.canWrite()) <line7> throw new PermanentBackendException(""Cannot access or write to directory: "" + dir); <line8> return FSDirectory.open(path); <line9> } catch (IOException e) { <line10> throw new PermanentBackendException(""Could not open directory: "" + dir, e); <line11> } <line12> } <line13> } <line14> "	"<line8>      log.debug(""Opening store directory [{}]"", path);"	task4	
public class A { <line0> public static boolean initConfigCacheFromResources() { <line1> URL resource = <line2> ApplicationConfigCache.class.getClassLoader().getResource(ConfigOptions.CONFIG_FILE); <line3> File configFile = new File(resource.getFile()); <line4> StringBuilder json = new StringBuilder(); <line5> try (BufferedReader reader = new BufferedReader(new FileReader(configFile), 1024)) { <line6> String line; <line7> while ((line = reader.readLine()) != null) { <line8> json.append(line); <line9> } <line10> } catch (Exception e) { <line11> } <line12> return initialize(json.toString()); <line13> } <line14> } <line15> 	<line11>      log.error(e);	task4	
"public class A { <line0> @Test <line1> public void testDifferentEventTypesInBatchWithAvroReflect() throws IOException { <line2> loadProperties(""flume-log4jtest-avro-reflect.properties""); <line3> props.put(""log4j.appender.out2.Port"", String.valueOf(port)); <line4> PropertyConfigurator.configure(props); <line5> Logger logger = LogManager.getLogger(getClass()); <line6> List<Object> events = Arrays.asList(""string"", new AppEvent(""appEvent"")); <line7> Transaction transaction = ch.getTransaction(); <line8> transaction.begin(); <line9> for (Object o : events) { <line10> Event e = ch.take(); <line11> Assert.assertNotNull(e); <line12> ReflectDatumReader<?> reader = new ReflectDatumReader<>(o.getClass()); <line13> BinaryDecoder decoder = DecoderFactory.get().binaryDecoder(e.getBody(), null); <line14> Object readObject = reader.read(null, decoder); <line15> Assert.assertEquals(o, readObject); <line16> Map<String, String> hdrs = e.getHeaders(); <line17> Assert.assertNull(hdrs.get(Log4jAvroHeaders.MESSAGE_ENCODING.toString())); <line18> Assert.assertNull( <line19> ""Schema URL should not be set"", hdrs.get(Log4jAvroHeaders.AVRO_SCHEMA_URL.toString())); <line20> Assert.assertEquals( <line21> ""Schema string should be set"", <line22> ReflectData.get().getSchema(readObject.getClass()).toString(), <line23> hdrs.get(Log4jAvroHeaders.AVRO_SCHEMA_LITERAL.toString())); <line24> } <line25> Assert.assertNull(""There should be no more events in the channel"", ch.take()); <line26> } <line27> } <line28> "	<line7>    logger.info(events);	task4	
public class A { <line0> public static void setupMqttOutputAdapter() throws IOException { <line1> OutputEventAdapterConfiguration outputEventAdapterConfiguration = <line2> createMqttOutputEventAdapterConfiguration( <line3> DeviceTypeConstants.MQTT_ADAPTER_NAME, <line4> DeviceTypeConstants.MQTT_ADAPTER_TYPE, <line5> MessageType.TEXT); <line6> try { <line7> PrivilegedCarbonContext.startTenantFlow(); <line8> PrivilegedCarbonContext.getThreadLocalCarbonContext() <line9> .setTenantDomain(DeviceTypeConstants.DEVICE_TYPE_PROVIDER_DOMAIN, true); <line10> DeviceTypeManagementDataHolder.getInstance() <line11> .getOutputEventAdapterService() <line12> .create(outputEventAdapterConfiguration); <line13> } catch (OutputEventAdapterException e) { <line14> } finally { <line15> PrivilegedCarbonContext.endTenantFlow(); <line16> } <line17> } <line18> } <line19> 	"<line14>      log.error(""Unable to create Output Event Adapter : "" + DeviceTypeConstants.MQTT_ADAPTER_NAME, e);"	task4	
public class A { <line0> private void cancelTimeout(Timeout timeout) { <line1> if (timeout != null) { <line2> timeout.cancel(); <line3> } <line4> } <line5> } <line6> 	"<line2>      LOG.trace(""[{}] Cancelling timeout"", logPrefix);"	task4	
public class A { <line0> @Override <line1> public void getRetweetsOfMe() { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(RETWEETS_OF_ME, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> ResponseList<Status> statuses = twitter.getRetweetsOfMe(); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotRetweetsOfMe(statuses); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at getRwtweetsOfMe"", e);"	task4	
public class A { <line0> @Override <line1> public CPDefinitionSpecificationOptionValue findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchCPDefinitionSpecificationOptionValueException { <line3> CPDefinitionSpecificationOptionValue cpDefinitionSpecificationOptionValue = <line4> fetchByPrimaryKey(primaryKey); <line5> if (cpDefinitionSpecificationOptionValue == null) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> throw new NoSuchCPDefinitionSpecificationOptionValueException( <line9> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return cpDefinitionSpecificationOptionValue; <line12> } <line13> } <line14> 	<line7>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @Override <line1> public boolean isFileSystemItem( <line2> DocumentModel doc, boolean includeDeleted, boolean relaxSyncRootConstraint) { <line3> boolean isUserWorkspace = UserWorkspaceHelper.isUserWorkspace(doc); <line4> if (!isUserWorkspace) { <line5> return false; <line6> } <line7> return true; <line8> } <line9> } <line10> 	"<line5>      log.trace(""Document {} is not a user workspace, it cannot be adapted as a FileSystemItem."",doc::getId);"	task4	
"public class A { <line0> @Override <line1> public boolean processEvent(StateEvent event) { <line2> switch (event.encodeType(EventTypes.class)) { <line3> case DISCONNECT_EVENT: <line4> setTimer(REC_TIMEOUT); <line5> switchToNextState(FsmState.REOPEN); <line6> break; <line7> case TIMEOUT_EVENT: <line8> doDisconnect(); <line9> setTimer(REC_TIMEOUT); <line10> switchToNextState(FsmState.REOPEN); <line11> break; <line12> case STOP_EVENT: <line13> clearTimer(); <line14> doDisconnect(); <line15> switchToNextState(FsmState.DOWN); <line16> break; <line17> case CEA_EVENT: <line18> clearTimer(); <line19> if (context.processCeaMessage( <line20> ((FsmEvent) event).getKey(), ((FsmEvent) event).getMessage())) { <line21> switchToNextState(FsmState.OKAY); <line22> } else { <line23> doDisconnect(); <line24> setTimer(REC_TIMEOUT); <line25> switchToNextState(FsmState.REOPEN); <line26> } <line27> break; <line28> case SEND_MSG_EVENT: <line29> throw new RuntimeException(""Connection is down""); <line30> default: <line31> return false; <line32> } <line33> return true; <line34> } <line35> } <line36> "	"<line31>        logger.debug(""Unknown event type: {} in state {}"", event.encodeType(EventTypes.class), state);"	task4	
public class A { <line0> private Path createIfNotExistsDirectory(Path pathToDir) { <line1> try { <line2> if (!Files.exists(pathToDir)) Files.createDirectory(pathToDir); <line3> } catch (IOException e) { <line4> } <line5> return pathToDir; <line6> } <line7> } <line8> 	"<line4>      LOG.error(""Cannot create folder: "" + pathToDir.toAbsolutePath(), e);"	task4	
"public class A { <line0> private void checkDescribeOpportunities() throws IOException { <line1> MarketoSource source = new MarketoSource(); <line2> source.initialize(null, iprops); <line3> MarketoRESTClient client = (MarketoRESTClient) source.getClientService(null); <line4> MarketoRecordResult opps = client.describeOpportunity(iprops); <line5> assertNotNull(opps.getRecords()); <line6> assertNotNull(opps.getRecords().get(0)); <line7> IndexedRecord record = opps.getRecords().get(0); <line8> assertNotNull(record.get(record.getSchema().getField(""idField"").pos())); <line9> assertNotNull(record.get(record.getSchema().getField(""dedupeFields"").pos())); <line10> assertNotNull(record.get(record.getSchema().getField(""searchableFields"").pos())); <line11> assertNotNull(record.get(record.getSchema().getField(""fields"").pos())); <line12> } <line13> } <line14> "	"<line5>    LOG.debug(""opps = {}."", opps);"	task4	
"public class A { <line0> private IServerTypeDesc createServerTypeDescInstance( <line1> String typeName, <line2> ITypeDesc typeDesc, <line3> String superTypeName, <line4> Map<String, IServerTypeDesc> localTypeMap) { <line5> logEnter(""createServerTypeDescInstance"", ""typeName"", typeName); <line6> IServerTypeDesc superTypeDesc = superTypeName != null ? localTypeMap.get(superTypeName) : null; <line7> ServerTypeDesc serverTypeDesc = <line8> new ServerTypeDesc(_typeIdGenerator.incrementAndGet(), typeName, typeDesc, superTypeDesc); <line9> localTypeMap.put(typeName, serverTypeDesc); <line10> if (logger.isDebugEnabled()) { <line11> if (logger.isTraceEnabled()) logTypeMap(localTypeMap); <line12> else if (logger.isDebugEnabled()) logServerTypeDesc(serverTypeDesc, LogLevel.DEBUG); <line13> } <line14> for (IServerTypeDescListener listener : _typeDescListeners) <line15> listener.onTypeAdded(serverTypeDesc); <line16> logExit(""createServerTypeDescInstance"", ""typeName"", typeName); <line17> return serverTypeDesc; <line18> } <line19> } <line20> "	"<line11>      logger.debug(""Created ServerTypeDesc for type ["" + typeName + ""]."" + getClientAddressAddition());"	task4	
"public class A { <line0> private Optional<FileStatus> stat(Path path) { <line1> try { <line2> return Optional.of(dataSourceParameter.getHadoopFileSystem(path).getFileStatus(path)); <line3> } catch (FileNotFoundException e) { <line4> return Optional.empty(); <line5> } catch (IOException e) { <line6> throw new CommandConfigurationException( <line7> MessageFormat.format(""error occurred while resolving Hadoop path: {0}"", path), e); <line8> } <line9> } <line10> } <line11> "	"<line4>      LOG.trace(""not found: {}"", path, e);"	task4	
public class A { <line0> @Override <line1> public void onNoteNameChanged(Note note, String oldName) { <line2> if (note.isNameEmpty()) { <line3> return; <line4> } <line5> if (!index.containsKey(note)) { <line6> putNote(note); <line7> } else { <line8> Folder folder = index.get(note); <line9> if (folder.getId().equals(note.getFolderId())) { <line10> return; <line11> } <line12> removeNote(note); <line13> putNote(note); <line14> } <line15> } <line16> } <line17> 	"<line5>    logger.info(""Note name changed: {} -> {}"", oldName, note.getName());"	task4	
"public class A { <line0> public static void update() { <line1> final String jsonSerialiserClass = <line2> System.getProperty(JSON_SERIALISER_CLASS_KEY, DEFAULT_SERIALISER_CLASS_NAME); <line3> final JSONSerialiser newInstance; <line4> try { <line5> newInstance = <line6> Class.forName(jsonSerialiserClass).asSubclass(JSONSerialiser.class).newInstance(); <line7> } catch (final InstantiationException | IllegalAccessException | ClassNotFoundException e) { <line8> throw new IllegalArgumentException( <line9> ""Property "" <line10> + JSON_SERIALISER_CLASS_KEY <line11> + "" must be set to a class that is a sub class of "" <line12> + JSONSerialiser.class.getName() <line13> + "". This class is not valid: "" <line14> + jsonSerialiserClass, <line15> e); <line16> } <line17> final String moduleFactories = System.getProperty(JSON_SERIALISER_MODULES, """"); <line18> final Set<String> factoryClasses = Sets.newHashSet(moduleFactories.split("","")); <line19> factoryClasses.remove(""""); <line20> for (final String factoryClass : factoryClasses) { <line21> final JSONSerialiserModules factory; <line22> try { <line23> factory = Class.forName(factoryClass).asSubclass(JSONSerialiserModules.class).newInstance(); <line24> } catch (final InstantiationException | IllegalAccessException | ClassNotFoundException e) { <line25> throw new IllegalArgumentException( <line26> ""Property "" <line27> + JSON_SERIALISER_MODULES <line28> + "" must be set to a csv of classes that are a sub class of "" <line29> + JSONSerialiserModules.class.getName() <line30> + "". These classes are not valid: "" <line31> + factoryClass, <line32> e); <line33> } <line34> final List<Module> modules = factory.getModules(); <line35> if (null != modules) { <line36> newInstance.mapper.registerModules(modules); <line37> } <line38> } <line39> newInstance.mapper.configure( <line40> DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <line41> Boolean.parseBoolean(System.getProperty(STRICT_JSON, STRICT_JSON_DEFAULT_STR))); <line42> instance = newInstance; <line43> } <line44> } <line45> "	"<line43>    LOGGER.debug(""Updated json serialiser to use: {}, and modules: {}"",jsonSerialiserClass,moduleFactories);"	task4	
public class A { <line0> protected void logProgress(Object info) { <line1> if (logger.isDebugEnabled()) { <line2> Runtime runtime = Runtime.getRuntime(); <line3> } <line4> } <line5> } <line6> 	"<line3>      logger.debug(""Step: ""+ info+ "" memory: free / total / max MB ""+ runtime.freeMemory() / (1000 * 1000)+ "" / ""+ runtime.totalMemory() / (1000 * 1000)+ "" / ""+ runtime.maxMemory() / (1000 * 1000));"	task4	
"public class A { <line0> @Override <line1> public Response listEnvironments() { <line2> Set<Environment> environments = environmentManager.getEnvironments(); <line3> Set<EnvironmentDto> environmentDtos = Sets.newHashSet(); <line4> for (Environment environment : environments) { <line5> try { <line6> String dataSource = <line7> (environment instanceof BazaarEnvironment <line8> || String.format(""Of %s"", Common.BAZAAR_ID).equals(environment.getName())) <line9> ? Common.BAZAAR_ID <line10> : Common.SUBUTAI_ID; <line11> EnvironmentDto environmentDto = <line12> new EnvironmentDto( <line13> environment.getId(), <line14> environment.getName(), <line15> environment.getStatus(), <line16> convertContainersToContainerJson(environment.getContainerHosts(), dataSource), <line17> dataSource, <line18> environmentManager.getEnvironmentOwnerName(environment)); <line19> environmentDtos.add(environmentDto); <line20> } catch (Exception e) { <line21> } <line22> } <line23> return Response.ok(JsonUtil.toJson(removeXss(environmentDtos))).build(); <line24> } <line25> } <line26> "	"<line21>        LOG.error(""Error JSON-ifying environment {}: {}"", environment.getId(), e.getMessage());"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> Exception cause = <line3> new JmsOperationTimedOutException(""Remote did not respond to a drain request in time""); <line4> locallyClosed(session.getConnection(), cause); <line5> stopRequest.onFailure(cause); <line6> session.pumpToProtonTransport(stopRequest); <line7> } <line8> } <line9> "	"<line2>    LOG.trace(""Consumer {} drain request timed out"", this);"	task4	
public class A { <line0> @Override <line1> public void collisionResolve(SpaceStationMir mir) { <line2> } <line3> } <line4> 	"<line2>    LOGGER.info(""{} hits {}."", mir.getClass().getSimpleName(), this.getClass().getSimpleName());"	task4	
public class A { <line0> private boolean _isShowPublishAction() { <line1> PermissionChecker permissionChecker = _themeDisplay.getPermissionChecker(); <line2> long scopeGroupId = _themeDisplay.getScopeGroupId(); <line3> StagingGroupHelper stagingGroupHelper = StagingGroupHelperUtil.getStagingGroupHelper(); <line4> try { <line5> if (GroupPermissionUtil.contains( <line6> permissionChecker, scopeGroupId, ActionKeys.EXPORT_IMPORT_PORTLET_INFO) <line7> && stagingGroupHelper.isStagingGroup(scopeGroupId) <line8> && stagingGroupHelper.isStagedPortlet(scopeGroupId, JournalPortletKeys.JOURNAL)) { <line9> return true; <line10> } <line11> return false; <line12> } catch (PortalException portalException) { <line13> if (log.isDebugEnabled()) { <line14> } <line15> return false; <line16> } <line17> } <line18> } <line19> 	"<line14>        log.debug(""An exception occured when checking if the publish "" + ""action should be displayed"",portalException);"	task4	
"public class A { <line0> @Test( <line1> groups = {""Integration""}, <line2> enabled = false) <line3> public void testModifyEtcHosts() throws Exception { <line4> LocalManagementContextForTests mgmt = new LocalManagementContextForTests(); <line5> SshMachineLocation loc = <line6> mgmt.getLocationManager() <line7> .createLocation(LocalhostMachineProvisioningLocation.spec()) <line8> .obtain(); <line9> execRequiringZeroAndReturningStdout( <line10> loc, sudo(""cp /etc/hosts /etc/hosts-orig-testModifyEtcHosts"")) <line11> .get(); <line12> int numLinesOrig = <line13> Integer.parseInt( <line14> execRequiringZeroAndReturningStdout(loc, ""wc -l /etc/hosts"") <line15> .get() <line16> .trim() <line17> .split(""\\s"")[0]); <line18> try { <line19> String cmd = <line20> BashCommands.prependToEtcHosts( <line21> ""1.2.3.4"", ""myhostnamefor1234.at.start"", ""myhostnamefor1234b""); <line22> execRequiringZeroAndReturningStdout(loc, cmd).get(); <line23> String cmd2 = <line24> BashCommands.appendToEtcHosts(""5.6.7.8"", ""myhostnamefor5678.at.end"", ""myhostnamefor5678""); <line25> execRequiringZeroAndReturningStdout(loc, cmd2).get(); <line26> String grepFirst = <line27> execRequiringZeroAndReturningStdout(loc, ""grep -n myhostnamefor1234 /etc/hosts"").get(); <line28> String grepLast = <line29> execRequiringZeroAndReturningStdout(loc, ""grep -n myhostnamefor5678 /etc/hosts"").get(); <line30> int numLinesAfter = <line31> Integer.parseInt( <line32> execRequiringZeroAndReturningStdout(loc, ""wc -l /etc/hosts"") <line33> .get() <line34> .trim() <line35> .split(""\\s"")[0]); <line36> assertTrue( <line37> grepFirst.startsWith(""1:"") <line38> && grepFirst.contains(""1.2.3.4 myhostnamefor1234.at.start myhostnamefor1234""), <line39> ""first="" + grepFirst); <line40> assertTrue( <line41> grepLast.startsWith((numLinesOrig + 2) + "":"") <line42> && grepLast.contains(""5.6.7.8 myhostnamefor5678.at.end myhostnamefor5678""), <line43> ""last="" + grepLast); <line44> assertEquals( <line45> numLinesOrig + 2, <line46> numLinesAfter, <line47> ""lines orig="" + numLinesOrig + "", after="" + numLinesAfter); <line48> } finally { <line49> execRequiringZeroAndReturningStdout( <line50> loc, sudo(""cp /etc/hosts-orig-testModifyEtcHosts /etc/hosts"")) <line51> .get(); <line52> } <line53> } <line54> } <line55> "	"<line36>      log.info(""result: numLinesBefore=""+ numLinesOrig+ ""; numLinesAfter=""+ numLinesAfter+ ""; first=""+ grepFirst+ ""; last=""+ grepLast);"	task4	
"public class A { <line0> protected Response putTopology(Topology newTopology) throws Exception { <line1> if (newTopology.getVersion() != null <line2> && !topology.getVersion().equals(newTopology.getVersion())) { <line3> return createErrorResponse(Response.CONFLICT, topology); <line4> } <line5> if (!newTopology.validate()) { <line6> return createErrorResponse( <line7> Response.BAD_REQUEST, <line8> String.format(""Invalid Topology Format. [invalid topology: %s]"", newTopology)); <line9> } <line10> Map<String, Link> newLinks = newTopology.getLinkMap(); <line11> Map<String, Node> newNodes = newTopology.getNodeMap(); <line12> for (Link link : newLinks.values()) { <line13> if (link == null || !link.validate()) { <line14> return createErrorResponse( <line15> Response.BAD_REQUEST, <line16> String.format(""Invalid Topology's link Format. [invalid link: %s]"", link)); <line17> } <line18> } <line19> for (Node node : newNodes.values()) { <line20> if (node == null || !node.validate()) { <line21> return createErrorResponse( <line22> Response.BAD_REQUEST, <line23> String.format(""Invalid Topology's node Format. [invalid node: %s]"", node)); <line24> } <line25> for (Port port : node.getPortMap().values()) { <line26> if (port == null || !port.validate()) { <line27> return createErrorResponse( <line28> Response.BAD_REQUEST, <line29> String.format(""Invalid Topology's port Format. [invalid port: %s]"", port)); <line30> } <line31> } <line32> } <line33> Topology oldTopology = topology; <line34> topology = newTopology.clone(); <line35> if (oldTopology == null) { <line36> notifyTopologyChangedToAdd(newTopology); <line37> } else { <line38> notifyTopologyChangedToUpdate(oldTopology, newTopology); <line39> } <line40> return new Response(Response.OK, newTopology); <line41> } <line42> } <line43> "	"<line1>    log.debug("""");"	task4	
public class A { <line0> @Override <line1> public void addForward( <line2> long companyId, <line3> long userId, <line4> List<Filter> filters, <line5> List<String> emailAddresses, <line6> boolean leaveCopy) { <line7> if (log.isDebugEnabled()) { <line8> } <line9> } <line10> } <line11> 	"<line8>      log.debug(""addForward"");"	task4	
"public class A { <line0> public void process(Exchange exchange) throws Exception { <line1> if (""ExchangeTimedOutException"".equals(exchange.getIn().getBody(String.class))) { <line2> throw new ExchangeTimedOutException(exchange, 1); <line3> } else if (""Exception"".equals(exchange.getIn().getBody(String.class))) { <line4> throw new Exception(); <line5> } <line6> } <line7> } <line8> "	"<line1>    log.info(""B headers "" + exchange.getIn().getHeaders());"	task4	
"public class A { <line0> public List<BoxEvent> getEnterpriseEvents( <line1> String position, Date after, Date before, BoxEvent.Type... types) { <line2> try { <line3> if (after == null) { <line4> throw new IllegalArgumentException(""Parameter 'after' can not be null""); <line5> } <line6> if (before == null) { <line7> throw new IllegalArgumentException(""Parameter 'before' can not be null""); <line8> } <line9> if (types == null) { <line10> types = new BoxEvent.Type[0]; <line11> } <line12> EventLog eventLog = <line13> EventLog.getEnterpriseEvents(boxConnection, position, after, before, types); <line14> List<BoxEvent> results = new ArrayList<>(); <line15> for (BoxEvent event : eventLog) { <line16> results.add(event); <line17> } <line18> return results; <line19> } catch (BoxAPIException e) { <line20> throw new RuntimeException( <line21> String.format( <line22> ""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), <line23> e); <line24> } <line25> } <line26> } <line27> "	"<line3>      LOG.debug(""Getting all enterprise events occurring between {} and {} {}"",after == null ? ""unspecified date"" : DateFormat.getDateTimeInstance().format(after),before == null ? ""unspecified date"" : DateFormat.getDateTimeInstance().format(before),position == null ? """" : ("" starting at "" + position));"	task4	
"public class A { <line0> public E create() { <line1> try { <line2> E entity = getController().getEntityClass().newInstance(); <line3> for (ParentFilter pf : this.getParentFilters()) { <line4> FormModel<?> parent = <line5> (FormModel<?>) this.getController().get(pf.getParentForm()).getModel(); <line6> List<?> records = parent.getRecords(); <line7> if (records.size() > 0) { <line8> Object value = ((Entity) records.get(0)).get(pf.getParentId()); <line9> if (!(value instanceof List<?>) && value != null) { <line10> entity.set(pf.getXrefToParent(), value); <line11> } <line12> for (String labelName : pf.getParentLabels()) { <line13> Object label = ((Entity) records.get(0)).get(labelName); <line14> entity.set(pf.getXrefToParent() + ""_"" + labelName, label); <line15> } <line16> } <line17> } <line18> return entity; <line19> } catch (Exception e) { <line20> e.printStackTrace(); <line21> } <line22> return null; <line23> } <line24> } <line25> "	"<line20>      logger.error(""failed to create class "" + getController().getEntityClass() + "": "" + e);"	task4	
public class A { <line0> public boolean init7SegmentDisplay() { <line1> try { <line2> if (device == null) { <line3> return false; <line4> } <line5> device.write(0x21, (byte) 0x00); <line6> device.write(0x81, (byte) 0x00); <line7> device.write(0xEF, (byte) 0x00); <line8> device.write(0x00, new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 16); <line9> } catch (Exception e) { <line10> Logging.logError(e); <line11> } <line12> return true; <line13> } <line14> } <line15> 	"<line3>        log.error(""device is null"");"	task4	
public class A { <line0> @Override <line1> public void onFailure(IMqttToken token, Throwable throwable) { <line2> } <line3> } <line4> 	"<line2>    log.error(""error - {} {}"", tokenToString(token), throwable);"	task4	
public class A { <line0> @Override <line1> public SExpIR caseANarrowExp(ANarrowExp node, IRInfo question) throws AnalysisException { <line2> PExp exp = node.getTest(); <line3> PType type = null; <line4> if (node.getBasicType() != null) { <line5> type = node.getBasicType(); <line6> } else if (node.getTypedef() != null) { <line7> type = question.getTcFactory().createPDefinitionAssistant().getType(node.getTypedef()); <line8> } <line9> SExpIR expCg = exp.apply(question.getExpVisitor(), question); <line10> STypeIR typeCg; <line11> if (type != null) { <line12> typeCg = type.apply(question.getTypeVisitor(), question); <line13> } else { <line14> typeCg = new AUnknownTypeIR(); <line15> typeCg.setSourceNode(new SourceNode(node)); <line16> } <line17> ACastUnaryExpIR cast = new ACastUnaryExpIR(); <line18> cast.setExp(expCg); <line19> cast.setType(typeCg); <line20> return cast; <line21> } <line22> } <line23> 	"<line14>      log.error(""Could not find type of narrow expression"");"	task4	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> protected void internalUnsubscribeNamespaceBundle( <line2> String subscription, String bundleRange, boolean authoritative) { <line3> validateNamespaceOperation(namespaceName, NamespaceOperation.UNSUBSCRIBE); <line4> checkNotNull(subscription, ""Subscription should not be null""); <line5> checkNotNull(bundleRange, ""BundleRange should not be null""); <line6> Policies policies = getNamespacePolicies(namespaceName); <line7> if (namespaceName.isGlobal()) { <line8> validateGlobalNamespaceOwnership(namespaceName); <line9> } else { <line10> validateClusterOwnership(namespaceName.getCluster()); <line11> validateClusterForTenant(namespaceName.getTenant(), namespaceName.getCluster()); <line12> } <line13> validateNamespaceBundleOwnership( <line14> namespaceName, policies.bundles, bundleRange, authoritative, true); <line15> unsubscribe(namespaceName, bundleRange, subscription); <line16> } <line17> } <line18> "	"<line16>    log.info(""[{}] Successfully unsubscribed {} on namespace bundle {}/{}"",clientAppId(),subscription,namespaceName,bundleRange);"	task4	
public class A { <line0> @Override <line1> public T lookup(final CacheReference<T> reference) { <line2> for (AttributedList<T> entry : impl.asMap().values()) { <line3> final T f = entry.find(reference); <line4> if (null == f) { <line5> continue; <line6> } <line7> return f; <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line9>    log.warn(String.format(""Lookup failed for %s in cache"", reference));"	task4	
"public class A { <line0> private String handleAndReturnExceptionResponse(Exception e) { <line1> if (e instanceof InterruptedException) { <line2> Thread.currentThread().interrupt(); <line3> } <line4> StringBuilder response = new StringBuilder(); <line5> response <line6> .append(DEFAULT_EXCEPTION_RESPONSE) <line7> .append("": "") <line8> .append(e.getClass().getCanonicalName()); <line9> if (e.getMessage() != null) { <line10> response.append("": "").append(e.getMessage()); <line11> } <line12> return response.toString(); <line13> } <line14> } <line15> "	<line1>    LOG.warn(DEFAULT_EXCEPTION_RESPONSE, e);	task4	
public class A { <line0> private Map<EncodingStrategy<T>, Integer> getBufferSizes(List<T> values) { <line1> Map<EncodingStrategy<T>, Integer> bufferSizes = new HashMap<EncodingStrategy<T>, Integer>(); <line2> for (EncodingStrategy<T> strategy : getEncodingStrategies()) { <line3> Buffer encodedBuffer = new AutomaticBuffer(); <line4> codec.encodeValues(encodedBuffer, strategy, values); <line5> int encodedBufferSize = encodedBuffer.getBuffer().length; <line6> bufferSizes.put(strategy, encodedBufferSize); <line7> } <line8> return bufferSizes; <line9> } <line10> } <line11> 	"<line8>    logger.debug(""Strategies : {}"", bufferSizes);"	task4	
"public class A { <line0> protected void addCommandToResponse( <line1> final Response response, final CommandContext commandContext, final Span currentSpan) { <line2> final Command command = commandContext.getCommand(); <line3> final OptionSet options = response.getOptions(); <line4> options.addLocationQuery(Constants.HEADER_COMMAND + ""="" + command.getName()); <line5> if (command.isOneWay()) { <line6> options.setLocationPath(CommandConstants.COMMAND_ENDPOINT); <line7> } else { <line8> options.setLocationPath(CommandConstants.COMMAND_RESPONSE_ENDPOINT); <line9> } <line10> currentSpan.setTag(Constants.HEADER_COMMAND, command.getName()); <line11> commandContext.getTracingSpan().log(""forwarding command to device in CoAP response""); <line12> if (command.isTargetedAtGateway()) { <line13> options.addLocationPath(command.getTenant()); <line14> options.addLocationPath(command.getDeviceId()); <line15> currentSpan.setTag(Constants.HEADER_COMMAND_TARGET_DEVICE, command.getDeviceId()); <line16> } <line17> if (!command.isOneWay()) { <line18> options.addLocationPath(command.getRequestId()); <line19> currentSpan.setTag(Constants.HEADER_COMMAND_REQUEST_ID, command.getRequestId()); <line20> } <line21> final int formatCode = MediaTypeRegistry.parse(command.getContentType()); <line22> if (formatCode != MediaTypeRegistry.UNDEFINED) { <line23> options.setContentFormat(formatCode); <line24> } else { <line25> currentSpan.log( <line26> ""ignoring unknown content type ["" + command.getContentType() + ""] of command""); <line27> } <line28> Optional.ofNullable(command.getPayload()).ifPresent(b -> response.setPayload(b.getBytes())); <line29> } <line30> } <line31> "	"<line11>    LOG.debug(""adding command [name: {}, request-id: {}] to response for device [tenant-id: {},""+ "" device-id: {}]"",command.getName(),command.getRequestId(),command.getTenant(),command.getGatewayOrDeviceId());"	task4	
"public class A { <line0> private void deployTestSpecificResources(ExtensionContext extensionContext) { <line1> prepareEnvForOperator( <line2> extensionContext, <line3> CO_NAMESPACE, <line4> Arrays.asList(CO_NAMESPACE, SECOND_NAMESPACE, THIRD_NAMESPACE)); <line5> applyBindings(extensionContext, CO_NAMESPACE); <line6> List<ClusterRoleBinding> clusterRoleBindingList = <line7> ClusterRoleBindingTemplates.clusterRoleBindingsForAllNamespaces(CO_NAMESPACE); <line8> clusterRoleBindingList.forEach( <line9> clusterRoleBinding -> <line10> ClusterRoleBindingResource.clusterRoleBinding(extensionContext, clusterRoleBinding)); <line11> resourceManager.createResource( <line12> extensionContext, <line13> BundleResource.clusterOperator(CO_NAMESPACE, ""*"", Constants.RECONCILIATION_INTERVAL) <line14> .build()); <line15> String previousNamespace = cluster.setNamespace(THIRD_NAMESPACE); <line16> resourceManager.createResource( <line17> extensionContext, <line18> KafkaTemplates.kafkaEphemeral(MAIN_NAMESPACE_CLUSTER_NAME, 1, 1) <line19> .editSpec() <line20> .editEntityOperator() <line21> .editTopicOperator() <line22> .withWatchedNamespace(SECOND_NAMESPACE) <line23> .endTopicOperator() <line24> .editUserOperator() <line25> .withWatchedNamespace(SECOND_NAMESPACE) <line26> .endUserOperator() <line27> .endEntityOperator() <line28> .endSpec() <line29> .build()); <line30> cluster.setNamespace(SECOND_NAMESPACE); <line31> resourceManager.createResource( <line32> extensionContext, KafkaTemplates.kafkaEphemeral(SECOND_CLUSTER_NAME, 3).build()); <line33> cluster.setNamespace(previousNamespace); <line34> } <line35> } <line36> "	"<line1>    LOGGER.info(""Creating resources before the test class"");"	task4	
"public class A { <line0> @Override <line1> public void run(Timeout timeout) throws Exception { <line2> String message = <line3> ""Request ("" <line4> + _lastRequestId <line5> + "") to server "" <line6> + _server <line7> + "" timed-out waiting for response. Closing the channel !!""; <line8> Exception e = new Exception(message); <line9> _outstandingFuture.get().onError(e); <line10> close(); <line11> } <line12> } <line13> "	<line8>    LOGGER.error(message);	task4	
public class A { <line0> public void setChannel(String name) { <line1> if (channels.containsKey(name)) { <line2> String id = channels.get(name); <line3> transmitWithResult(PATH_ZAP + UrlEncoded.encodeString(id)) <line4> .ifPresent(document -> channel = name); <line5> } else { <line6> } <line7> } <line8> } <line9> 	"<line6>      logger.warn(""Channel {} not found."", name);"	task4	
public class A { <line0> public CharSequence postProcess(CharSequence object) { <line1> return (prefix + object); <line2> } <line3> } <line4> 	"<line1>    log.debug(""Altering '"", object, ""'"");"	task4	
public class A { <line0> private static String getURL( <line1> String action, String collectionName, MCRCategLinkReference reference, boolean absolute) { <line2> MCRCollection defaultCollection = <line3> reference != null ? getCollectionWithAction(reference.getType(), action, null) : null; <line4> MCRCollection collection = getCollectionWithAction(collectionName, action, defaultCollection); <line5> if (collection == null) { <line6> return null; <line7> } <line8> return getURL(action, collection, reference, absolute); <line9> } <line10> } <line11> 	"<line6>      LOGGER.warn(""Could not find action ''{}'' in collection: {}"", action, collectionName);"	task4	
"public class A { <line0> @RequestMapping(value = ""/clusters/"" + CLUSTER_NAME_PATH_VARIABLE, method = RequestMethod.PUT) <line1> public void updateCluster(@PathVariable String clusterName, @RequestBody ClusterTbl cluster) { <line2> clusterService.updateCluster(clusterName, cluster); <line3> } <line4> } <line5> "	"<line2>    logger.info(""[Update Cluster]{},{}"", clusterName, cluster);"	task4	
"public class A { <line0> @Override <line1> public List<String> getContentsId(IDataObjectListTagBean bean, RequestContext reqCtx) <line2> throws Throwable { <line3> List<String> dataObjectsId = null; <line4> try { <line5> dataObjectsId = this.extractContentsId(bean, reqCtx); <line6> dataObjectsId = this.executeFullTextSearch(bean, dataObjectsId, reqCtx); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error extracting dataObjects id"", t); <line9> } <line10> return dataObjectsId; <line11> } <line12> } <line13> "	"<line8>      logger.error(""Error extracting dataObjects id"", t);"	task4	
public class A { <line0> @Override <line1> public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent event) <line2> throws Exception { <line3> try { <line4> if (isConnected() <line5> && (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED) <line6> || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED) <line7> || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))) { <line8> synchronized (this) { <line9> Participant participant = leaderLatch.getLeader(); <line10> if (isLeader(participant) && !leaderLatch.hasLeadership()) { <line11> currentLeader = participant; <line12> } <line13> } <line14> } <line15> } catch (InterruptedException e) { <line16> } <line17> } <line18> } <line19> 	"<line16>      log.warn(""Oracle leadership watcher has been interrupted unexpectedly"");"	task4	
"public class A { <line0> @Effector( <line1> description = <line2> ""Deploys the given artifact, from a source URL, to a given deployment filename/context"") <line3> public void deploy( <line4> @EffectorParam(name = ""url"", description = ""URL of WAR file"") String url, <line5> @EffectorParam( <line6> name = ""targetName"", <line7> description = ""context path where WAR should be deployed (/ for ROOT)"") <line8> String targetName) { <line9> try { <line10> checkNotNull(url, ""url""); <line11> checkNotNull(targetName, ""targetName""); <line12> JavaWebAppDriver driver = getDriver(); <line13> String deployedName = driver.deploy(url, targetName); <line14> Set<String> deployedWars = getAttribute(DEPLOYED_WARS); <line15> if (deployedWars == null) { <line16> deployedWars = Sets.newLinkedHashSet(); <line17> } <line18> deployedWars.add(deployedName); <line19> sensors().set(DEPLOYED_WARS, deployedWars); <line20> } catch (RuntimeException e) { <line21> throw Throwables.propagate(e); <line22> } <line23> } <line24> } <line25> "	"<line21>      LOG.warn(""Error deploying '""+ url+ ""' to ""+ targetName+ "" on ""+ toString()+ ""; rethrowing..."",e);"	task4	
public class A { <line0> public void setWorkManager(final WorkManager workManager) { <line1> this.workManager = workManager; <line2> } <line3> } <line4> 	"<line2>    logger.debug(""WorkManager set."");"	task4	
public class A { <line0> private void getAllStorageSystems() { <line1> ResourceCollection<StorageSystem> storageSystems = this.storageSystemClient.getAll(); <line2> } <line3> } <line4> 	"<line2>    LOGGER.info(""StorageSystems returned to client : "" + storageSystems.toJsonString());"	task4	
public class A { <line0> public static com.liferay.journal.model.JournalArticleSoap[] getGroupArticles( <line1> long groupId, <line2> long userId, <line3> long rootFolderId, <line4> int status, <line5> int start, <line6> int end, <line7> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.journal.model.JournalArticle> <line8> orderByComparator) <line9> throws RemoteException { <line10> try { <line11> java.util.List<com.liferay.journal.model.JournalArticle> returnValue = <line12> JournalArticleServiceUtil.getGroupArticles( <line13> groupId, userId, rootFolderId, status, start, end, orderByComparator); <line14> return com.liferay.journal.model.JournalArticleSoap.toSoapModels(returnValue); <line15> } catch (Exception exception) { <line16> throw new RemoteException(exception.getMessage()); <line17> } <line18> } <line19> } <line20> 	<line16>      log.error(exception, exception);	task4	
public class A { <line0> private void replicate(final IndexedRaftLogEntry indexed, final AppendListener appendListener) { <line1> raft.checkThread(); <line2> appender <line3> .appendEntries(indexed.index()) <line4> .whenCompleteAsync( <line5> (commitIndex, commitError) -> { <line6> if (!isRunning()) { <line7> return; <line8> } <line9> if (commitError == null) { <line10> appendListener.onCommit(indexed); <line11> raft.notifyCommitListeners(indexed.index()); <line12> } else { <line13> appendListener.onCommitError(indexed, commitError); <line14> } <line15> }, <line16> raft.getThreadContext()); <line17> } <line18> } <line19> 	"<line14>                log.error(""Failed to replicate entry: {}"", indexed, commitError);"	task4	
"public class A { <line0> protected void doInitialize(IndexProvider provider) throws RepositoryException { <line1> Reflection.setValue(provider, ""context"", repository.context()); <line2> Reflection.setValue(provider, ""environment"", repository.environment()); <line3> provider.initialize(); <line4> Method postInitialize = Reflection.findMethod(IndexProvider.class, ""postInitialize""); <line5> Reflection.invokeAccessibly(provider, postInitialize, new Object[] {}); <line6> if (logger.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> "	"<line7>      logger.debug(""Successfully initialized index provider '{0}' in repository '{1}'"",provider.getName(), repository.name());"	task4	
"public class A { <line0> public void open( <line1> Connection conn, String fileName, long filePosition, final int serverId, boolean nonBlocking) <line2> throws IOException { <line3> try { <line4> this.conn = conn; <line5> Class<?> connClazz = Class.forName(""com.mysql.jdbc.ConnectionImpl""); <line6> Object unwrapConn = unwrapConnection(conn, connClazz); <line7> if (unwrapConn == null) { <line8> throw new IOException( <line9> ""Unable to unwrap "" + conn.getClass().getName() + "" to com.mysql.jdbc.ConnectionImpl""); <line10> } <line11> Object connIo = getDeclaredField(unwrapConn, connClazz, ""io""); <line12> if (connIo == null) { <line13> throw new IOException(""Get null field:"" + conn.getClass().getName() + ""#io""); <line14> } <line15> mysqlOutput = (OutputStream) getDeclaredField(connIo, connIo.getClass(), ""mysqlOutput""); <line16> mysqlInput = (InputStream) getDeclaredField(connIo, connIo.getClass(), ""mysqlInput""); <line17> if (filePosition == 0) filePosition = BIN_LOG_HEADER_SIZE; <line18> sendBinlogDump(fileName, filePosition, serverId, nonBlocking); <line19> position = 0; <line20> } catch (IOException e) { <line21> close(); <line22> throw e; <line23> } catch (ClassNotFoundException e) { <line24> close(); <line25> throw new IOException(""Unable to load com.mysql.jdbc.ConnectionImpl"", e); <line26> } <line27> } <line28> } <line29> "	"<line22>      logger.error(""Error on COM_BINLOG_DUMP: file = "" + fileName + "", position = "" + filePosition);"	task4	
public class A { <line0> public void leave(RoomParticipant user) { <line1> checkClosed(); <line2> this.removeParticipant(user.getName()); <line3> user.close(); <line4> } <line5> } <line6> 	"<line2>    log.debug(""PARTICIPANT {}: Leaving room {}"", user.getName(), this.name);"	task4	
public class A { <line0> public static com.liferay.commerce.model.CommerceOrderSoap executeWorkflowTransition( <line1> long commerceOrderId, long workflowTaskId, String transitionName, String comment) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.model.CommerceOrder returnValue = <line5> CommerceOrderServiceUtil.executeWorkflowTransition( <line6> commerceOrderId, workflowTaskId, transitionName, comment); <line7> return com.liferay.commerce.model.CommerceOrderSoap.toSoapModel(returnValue); <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
public class A { <line0> private static void createTarFile(File archiveFile) { <line1> try { <line2> archiveFile.createNewFile(); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.error(""Error creating a tar file"");"	task4	
public class A { <line0> private PolicyFinder createPolicyFinder() { <line1> PolicyFinder policyFinder = new PolicyFinder(); <line2> PollingPolicyFinderModule policyFinderModule = <line3> new PollingPolicyFinderModule( <line4> xacmlPolicyDirectories, defaultPollingIntervalInSeconds, securityLogger); <line5> policyFinderModule.start(); <line6> Set<PolicyFinderModule> policyFinderModules = new HashSet<>(1); <line7> policyFinderModules.add(policyFinderModule); <line8> policyFinder.setModules(policyFinderModules); <line9> return policyFinder; <line10> } <line11> } <line12> 	"<line1>    LOGGER.debug(""XACML policies will be looked for in the following location(s): {}"",xacmlPolicyDirectories);"	task4	
"public class A { <line0> @Test <line1> public void testRunAllParagraph_FirstFailed() throws IOException { <line2> Note note1 = null; <line3> try { <line4> note1 = TestUtils.getInstance(Notebook.class).createNote(""note1"", anonymous); <line5> Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS); <line6> Paragraph p2 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS); <line7> p1.setText( <line8> ""%python from __future__ import print_function\n"" <line9> + ""import time\n"" <line10> + ""time.sleep(1)\n"" <line11> + ""print(user2)""); <line12> p2.setText(""%python user2='abc'\nprint(user2)""); <line13> CloseableHttpResponse post = <line14> httpPost(""/notebook/job/"" + note1.getId() + ""?blocking=true"", """"); <line15> assertThat(post, isAllowed()); <line16> assertEquals(Job.Status.ERROR, p1.getStatus()); <line17> assertEquals(Job.Status.READY, p2.getStatus()); <line18> post.close(); <line19> } finally { <line20> if (null != note1) { <line21> TestUtils.getInstance(Notebook.class).removeNote(note1, anonymous); <line22> } <line23> } <line24> } <line25> } <line26> "	"<line2>    LOG.info(""Running testRunAllParagraph_FirstFailed"");"	task4	
public class A { <line0> @Override <line1> public void audit(AuditContext auditContext, AuditMessage... auditMessages) { <line2> for (var message : auditMessages) { <line3> var s = Current.toString(message, true); <line4> if (needValidation) { <line5> validator.validate(source(s), NEW_VALIDATION_SCHEMA); <line6> } <line7> messages.add(message); <line8> } <line9> } <line10> } <line11> 	<line4>      log.debug(s);	task4	
"public class A { <line0> @Override <line1> protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) { <line2> List<Configurer<SSLEngine>> sslEngineConfigurers = new LinkedList<>(); <line3> if (this.getClientAuthentication() != null) { <line4> final ClientAuthentication clientAuthValue = <line5> ClientAuthentication.valueOf(this.parsePropertyValue(this.getClientAuthentication())); <line6> Configurer<SSLEngine> sslEngineConfigurer = <line7> new Configurer<SSLEngine>() { <line8> @Override <line9> public SSLEngine configure(SSLEngine engine) { <line10> switch (clientAuthValue) { <line11> case NONE: <line12> engine.setWantClientAuth(false); <line13> engine.setNeedClientAuth(false); <line14> break; <line15> case WANT: <line16> engine.setWantClientAuth(true); <line17> break; <line18> case REQUIRE: <line19> engine.setNeedClientAuth(true); <line20> break; <line21> default: <line22> throw new RuntimeCamelException( <line23> ""Unknown ClientAuthentication value: "" + clientAuthValue); <line24> } <line25> return engine; <line26> } <line27> }; <line28> sslEngineConfigurers.add(sslEngineConfigurer); <line29> } <line30> return sslEngineConfigurers; <line31> } <line32> } <line33> "	"<line10>              LOG.trace(""Configuring client-auth on SSLEngine [{}] to [{}]."", engine, clientAuthValue);"	task4	
public class A { <line0> @Override <line1> public void onBeforeRemove(Group group) { <line2> try { <line3> CommerceChannel commerceChannel = <line4> _commerceChannelLocalService.fetchCommerceChannelBySiteGroupId(group.getGroupId()); <line5> if (commerceChannel != null) { <line6> _commerceChannelLocalService.updateCommerceChannel( <line7> commerceChannel.getCommerceChannelId(), <line8> GroupConstants.DEFAULT_PARENT_GROUP_ID, <line9> commerceChannel.getName(), <line10> commerceChannel.getType(), <line11> commerceChannel.getTypeSettingsProperties(), <line12> commerceChannel.getCommerceCurrencyCode()); <line13> } <line14> } catch (PortalException portalException) { <line15> if (log.isWarnEnabled()) { <line16> } <line17> } <line18> } <line19> } <line20> 	<line16>        log.warn(portalException, portalException);	task4	
public class A { <line0> @Override <line1> public List<LwM2mObject> findLwM2mObject( <line2> TenantId tenantId, String sortOrder, String sortProperty, String[] objectIds) { <line3> validateId(tenantId, INCORRECT_TENANT_ID + tenantId); <line4> List<TbResource> resources = <line5> resourceService.findTenantResourcesByResourceTypeAndObjectIds( <line6> tenantId, ResourceType.LWM2M_MODEL, objectIds); <line7> return resources.stream() <line8> .flatMap(s -> Stream.ofNullable(toLwM2mObject(s, false))) <line9> .sorted(getComparator(sortProperty, sortOrder)) <line10> .collect(Collectors.toList()); <line11> } <line12> } <line13> 	"<line3>    log.trace(""Executing findByTenantId [{}]"", tenantId);"	task4	
public class A { <line0> private void processEntry(FsDirectoryEntry entry, URI uri, String newPath) <line1> throws CommandExecutionException, IOException { <line2> String name = entry.getName(); <line3> if (!entry.isDirectory()) { <line4> final RequestMetaData metaData = new RequestMetaData(entry.getFile().getLength(), 2L, name); <line5> final RequestIdentifier identifier = new RequestIdentifier(uri); <line6> FatFileIdentificationRequest req = <line7> new FatFileIdentificationRequest(metaData, identifier, getTmpDir()); <line8> ByteBuffer buffer = ByteBuffer.allocate((int) entry.getFile().getLength()); <line9> entry.getFile().read(0, buffer); <line10> buffer.flip(); <line11> expandContainer( <line12> req, <line13> new ByteArrayInputStream(buffer.array(), buffer.position(), buffer.limit()), <line14> newPath); <line15> } else { <line16> } <line17> } <line18> } <line19> 	"<line16>      log.trace(""processing directory : "" + entry.getName());"	task4	
public class A { <line0> public static void setExecuteStatusLogLevelInfo(boolean executeStatusLogLevelInfo) { <line1> assertUnlocked(); <line2> if (log.isInfoEnabled()) { <line3> } <line4> _executeStatusLogLevelInfo = executeStatusLogLevelInfo; <line5> lock(); <line6> } <line7> } <line8> 	"<line3>      log.info(""...Setting executeStatusLogLevelInfo: "" + executeStatusLogLevelInfo);"	task4	
public class A { <line0> @Override <line1> public void processCancelSmResp(Command pduHeader, byte[] pdu, ResponseHandler responseHandler) <line2> throws IOException { <line3> PendingResponse<Command> pendingResp = <line4> responseHandler.removeSentItem(pduHeader.getSequenceNumber()); <line5> if (pendingResp != null) { <line6> CancelSmResp resp = pduDecomposer.cancelSmResp(pdu); <line7> pendingResp.done(resp); <line8> } else { <line9> } <line10> } <line11> } <line12> 	<line9>      logger.error(NO_REQUEST_FIND_FOR_SEQUENCE_NUMBER + pduHeader.getSequenceNumber());	task4	
public class A { <line0> private void executeService( <line1> String requestType, HttpServletRequest request, HttpServletResponse response) { <line2> CoreSettings coreSettings = <line3> (CoreSettings) request.getServletContext().getAttribute(TAG_CORE_SETTINGS); <line4> try (Service service = new Service(coreSettings)) { <line5> sendResponse(service.execute(serviceRequestFromHttpRequest(request, requestType)), response); <line6> } catch (Exception exc) { <line7> sendResponse(new ServiceResponse<>(500, exc.getMessage()), response); <line8> } <line9> } <line10> } <line11> 	"<line7>      LOGGER.error("""", exc);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public List<ClientReferral> getReferralsByFacility(Long clientId, Integer facilityId) { <line2> if (clientId == null || clientId.longValue() <= 0) { <line3> throw new IllegalArgumentException(); <line4> } <line5> if (facilityId == null || facilityId.intValue() < 0) { <line6> throw new IllegalArgumentException(); <line7> } <line8> String sSQL = <line9> ""from ClientReferral cr where cr.ClientId = ?  and ( (cr.FacilityId=?) or (cr.ProgramId in"" <line10> + "" (select s.id from Program s where s.facilityId=? or s.facilityId is null)))""; <line11> List<ClientReferral> results = <line12> this.getHibernateTemplate().find(sSQL, new Object[] {clientId, facilityId, facilityId}); <line13> if (log.isDebugEnabled()) { <line14> } <line15> results = displayResult(results); <line16> return results; <line17> } <line18> } <line19> "	"<line14>      log.debug(""getReferralsByFacility: clientId="" + clientId + "",# of results="" + results.size());"	task4	
"public class A { <line0> public static void addSegmentsEntryClassPKs( <line1> HttpPrincipal httpPrincipal, <line2> long segmentsEntryId, <line3> long[] classPKs, <line4> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line5> throws com.liferay.portal.kernel.exception.PortalException { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> SegmentsEntryServiceUtil.class, <line10> ""addSegmentsEntryClassPKs"", <line11> _addSegmentsEntryClassPKsParameterTypes2); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, segmentsEntryId, classPKs, serviceContext); <line14> try { <line15> TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public int getSeriesCount() throws SeriesException { <line2> try { <line3> return (int) index.count(); <line4> } catch (SeriesServiceDatabaseException e) { <line5> throw new SeriesException(e); <line6> } <line7> } <line8> } <line9> 	"<line5>      logger.error(""Exception occured while counting series."", e);"	task4	
"public class A { <line0> @Override <line1> public RemoveRepositorySourceMirrorResult removeRepositorySourceMirror( <line2> RemoveRepositorySourceMirrorRequest request) { <line3> Preconditions.checkArgument(null != request, ""the request is required""); <line4> Preconditions.checkArgument( <line5> StringUtils.isNotBlank(request.code), ""the code is required on the request""); <line6> final ObjectContext context = serverRuntime.newContext(); <line7> RepositorySourceMirror repositorySourceMirror = <line8> RepositorySourceMirror.tryGetByCode(context, request.code) <line9> .orElseThrow( <line10> () -> <line11> new ObjectNotFoundException( <line12> RepositorySourceMirror.class.getSimpleName(), request.code)); <line13> if (repositorySourceMirror.getIsPrimary()) { <line14> throw new IllegalStateException(""unable to remove the primary mirror""); <line15> } <line16> repositorySourceMirror.getRepositorySource().getRepository().setModifyTimestamp(); <line17> context.deleteObject(repositorySourceMirror); <line18> context.commitChanges(); <line19> return new RemoveRepositorySourceMirrorResult(); <line20> } <line21> } <line22> "	"<line19>    LOGGER.info(""did remote the repository source mirror [{}]"", request.code);"	task4	
"public class A { <line0> @Test <line1> public void testEventAvailabilityScope() throws Exception { <line2> startGrids(GRID_COUNT); <line3> final CacheEventListener lsnr = new CacheEventListener(); <line4> ContinuousQuery<Object, Object> qry = new ContinuousQuery<>(); <line5> qry.setLocalListener(lsnr); <line6> qry.setRemoteFilterFactory(new FilterFactory()); <line7> Object keys[] = new Object[GRID_COUNT]; <line8> for (int i = 0; i < GRID_COUNT; ++i) { <line9> keys[i] = primaryKey(grid(i).cache(DEFAULT_CACHE_NAME)); <line10> grid(0).cache(DEFAULT_CACHE_NAME).put(keys[i], -1); <line11> } <line12> try (QueryCursor<?> cur = grid(0).cache(DEFAULT_CACHE_NAME).query(qry)) { <line13> for (int i = 0; i < KEYS_COUNT; i++) { <line14> grid(i % GRID_COUNT).cache(DEFAULT_CACHE_NAME).put(keys[i % GRID_COUNT], i); <line15> } <line16> } <line17> assertTrue(""There are not filtered events"", !events.isEmpty()); <line18> for (CacheEntryEvent<?, ?> event : events) { <line19> assertNotNull(""Key is null"", event.getKey()); <line20> assertNotNull(""Value is null"", event.getValue()); <line21> assertNotNull(""Old value is null"", event.getOldValue()); <line22> } <line23> } <line24> } <line25> "	"<line14>        log.info(""Put key: "" + i);"	task4	
"public class A { <line0> private void deleteItem(String version, Connection conn) { <line1> PreparedStatement stat = null; <line2> try { <line3> stat = conn.prepareStatement(DELETE_ITEM); <line4> stat.setString(1, InitializerManager.REPORT_CONFIG_ITEM); <line5> stat.setString(2, version); <line6> stat.executeUpdate(); <line7> } catch (Throwable t) { <line8> throw new RuntimeException(""Error deleting item"", t); <line9> } finally { <line10> closeDaoResources(null, stat); <line11> } <line12> } <line13> } <line14> "	"<line8>      logger.error(""Error deleting item"", t);"	task4	
public class A { <line0> @Override <line1> public void addParentOfferings(final String offering, final Collection<String> parentOfferings) { <line2> CacheValidation.notNullOrEmpty(OFFERING, offering); <line3> CacheValidation.noNullOrEmptyValues(PARENT_OFFERINGS, parentOfferings); <line4> this.parentOfferingsForOfferings <line5> .computeIfAbsent(offering, createSynchronizedSet()) <line6> .addAll(parentOfferings); <line7> parentOfferings.forEach( <line8> parentOffering -> <line9> this.childOfferingsForOfferings <line10> .computeIfAbsent(parentOffering, createSynchronizedSet()) <line11> .add(offering)); <line12> } <line13> } <line14> 	"<line4>    LOG.trace(""Adding parentOfferings {} to offering {}"", parentOfferings, offering);"	task4	
public class A { <line0> @Test <line1> public void alertDetailsMessageTime() { <line2> alertingService.addAlertListener(member, SEVERE); <line3> assertThat(captureAlertDetails().getMsgTime()).isNotNull(); <line4> } <line5> } <line6> 	<line3>    logger.fatal(alertMessage);	task4	
"public class A { <line0> private PushErrorResponse _exec() { <line1> try { <line2> clientRequest.setHttpMethod(getHttpMethod()); <line3> clientRequest.header(""Content-Type"", getRequest().getContentType()); <line4> if (StringUtils.isNotBlank(getRequest().getClientNotificationToken())) { <line5> clientRequest.header( <line6> ""Authorization"", ""Bearer "" + getRequest().getClientNotificationToken()); <line7> } <line8> JSONObject requestBody = getRequest().getJSONParameters(); <line9> clientRequest.body(MediaType.APPLICATION_JSON, requestBody.toString(4)); <line10> clientResponse = clientRequest.post(String.class); <line11> setResponse(new PushErrorResponse(clientResponse)); <line12> } catch (Exception e) { <line13> } finally { <line14> closeConnection(); <line15> } <line16> return getResponse(); <line17> } <line18> } <line19> "	<line13>      LOG.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public RequestResponse updateContext(VitamContext vitamContext, String id, JsonNode queryDsl) <line2> throws AccessExternalClientException { <line3> VitamRequestBuilder request = <line4> put() <line5> .withPath(UPDATE_CONTEXT + id) <line6> .withHeaders(vitamContext.getHeaders()) <line7> .withBody(queryDsl) <line8> .withJson(); <line9> try (Response response = make(request)) { <line10> check(response); <line11> return RequestResponse.parseFromResponse(response); <line12> } catch (VitamClientInternalException e) { <line13> throw new AccessExternalClientServerException(e); <line14> } catch (AdminExternalClientException e) { <line15> return e.getVitamError(); <line16> } <line17> } <line18> } <line19> 	<line15>      LOGGER.error(e);	task4	
public class A { <line0> public ResourceResolver getTemplateResourceResolver( <line1> WebuiRequestContext context, String template) { <line2> try { <line3> DMSConfiguration dmsConfiguration = getApplicationComponent(DMSConfiguration.class); <line4> String workspace = dmsConfiguration.getConfig().getSystemWorkspace(); <line5> resourceResolver = new JCRResourceResolver(workspace); <line6> } catch (Exception e) { <line7> if (LOG.isWarnEnabled()) { <line8> } <line9> } <line10> return resourceResolver; <line11> } <line12> } <line13> 	<line8>        LOG.warn(e.getMessage());	task4	
public class A { <line0> public void resumeMinorGC() { <line1> if (suspendMinorCompaction.compareAndSet(true, false)) { <line2> } <line3> } <line4> } <line5> 	"<line2>      LOG.info(""{} Minor Compaction back to normal since bookie has enough space now."",Thread.currentThread().getName());"	task4	
public class A { <line0> @Override <line1> protected void implCloseChannel() throws IOException { <line2> } <line3> } <line4> 	"<line2>    log.debug(""Emulating close file channel"");"	task4	
"public class A { <line0> @RequestMapping(""/adminStudies/reOrderComprehensionTestQuestion.do"") <line1> public void reOrderComprehensionTestQuestion( <line2> HttpServletRequest request, HttpServletResponse response) { <line3> logger.entry(""begin reOrderComprehensionTestQuestion()""); <line4> String message = FdahpStudyDesignerConstants.FAILURE; <line5> JSONObject jsonobject = new JSONObject(); <line6> PrintWriter out = null; <line7> try { <line8> SessionObject sesObj = <line9> (SessionObject) <line10> request.getSession().getAttribute(FdahpStudyDesignerConstants.SESSION_OBJECT); <line11> int oldOrderNumber; <line12> int newOrderNumber; <line13> if (sesObj != null) { <line14> String studyId = <line15> (String) request.getSession().getAttribute(FdahpStudyDesignerConstants.STUDY_ID); <line16> if (StringUtils.isEmpty(studyId)) { <line17> studyId = <line18> FdahpStudyDesignerUtil.isEmpty( <line19> request.getParameter(FdahpStudyDesignerConstants.STUDY_ID)) <line20> ? """" <line21> : request.getParameter(FdahpStudyDesignerConstants.STUDY_ID); <line22> } <line23> String oldOrderNo = <line24> FdahpStudyDesignerUtil.isEmpty( <line25> request.getParameter(FdahpStudyDesignerConstants.OLD_ORDER_NUMBER)) <line26> ? """" <line27> : request.getParameter(FdahpStudyDesignerConstants.OLD_ORDER_NUMBER); <line28> String newOrderNo = <line29> FdahpStudyDesignerUtil.isEmpty( <line30> request.getParameter(FdahpStudyDesignerConstants.NEW_ORDER_NUMBER)) <line31> ? """" <line32> : request.getParameter(FdahpStudyDesignerConstants.NEW_ORDER_NUMBER); <line33> if (((studyId != null) && !studyId.isEmpty()) <line34> && !oldOrderNo.isEmpty() <line35> && !newOrderNo.isEmpty()) { <line36> oldOrderNumber = Integer.valueOf(oldOrderNo); <line37> newOrderNumber = Integer.valueOf(newOrderNo); <line38> message = <line39> studyService.reOrderComprehensionTestQuestion( <line40> Integer.valueOf(studyId), oldOrderNumber, newOrderNumber); <line41> } <line42> } <line43> jsonobject.put(FdahpStudyDesignerConstants.MESSAGE, message); <line44> response.setContentType(FdahpStudyDesignerConstants.APPLICATION_JSON); <line45> out = response.getWriter(); <line46> out.print(jsonobject); <line47> } catch (Exception e) { <line48> } <line49> logger.exit(""reOrderComprehensionTestQuestion() - Ends""); <line50> } <line51> } <line52> "	"<line48>      logger.error(""StudyController - reOrderComprehensionTestQuestion - ERROR"", e);"	task4	
"public class A { <line0> @Override <line1> public void enableResource( <line2> final String clusterName, final String resourceName, final boolean enabled) { <line3> String path = PropertyPathBuilder.idealState(clusterName, resourceName); <line4> BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_zkClient); <line5> if (!baseAccessor.exists(path, 0)) { <line6> throw new HelixException( <line7> ""Cluster "" <line8> + clusterName <line9> + "", resource: "" <line10> + resourceName <line11> + "", ideal-state does not exist""); <line12> } <line13> baseAccessor.update( <line14> path, <line15> new DataUpdater<ZNRecord>() { <line16> @Override <line17> public ZNRecord update(ZNRecord currentData) { <line18> if (currentData == null) { <line19> throw new HelixException( <line20> ""Cluster: "" <line21> + clusterName <line22> + "", resource: "" <line23> + resourceName <line24> + "", ideal-state is null""); <line25> } <line26> IdealState idealState = new IdealState(currentData); <line27> idealState.enable(enabled); <line28> return idealState.getRecord(); <line29> } <line30> }, <line31> AccessOption.PERSISTENT); <line32> } <line33> } <line34> "	"<line3>    logger.info(""{} resource {} in cluster {}."", enabled ? ""Enable"" : ""Disable"", resourceName, clusterName);"	task4	
"public class A { <line0> private void replyError() { <line1> if (dismissed.get()) { <line2> return; <line3> } <line4> ErrorCode err = <line5> err( <line6> SysErrors.MANAGEMENT_NODE_UNAVAILABLE_ERROR, <line7> ""management node[uuid:%s] is unavailable"", <line8> mgmtNodeId); <line9> if (rmeta.needApiEvent) { <line10> APIEvent evt = new APIEvent(rmeta.msgId); <line11> eventProperty(evt); <line12> evt.setError(err); <line13> wire.publish(evt); <line14> } else { <line15> MessageReply reply = new MessageReply(); <line16> reply.setError(err); <line17> AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder(); <line18> reply.setAMQPProperties(builder.deliveryMode(1).build()); <line19> reply.getHeaders().put(CloudBus.HEADER_IS_MESSAGE_REPLY, Boolean.TRUE.toString()); <line20> reply.putHeaderEntry(CloudBus.HEADER_CORRELATION_ID, rmeta.msgId); <line21> reply.setServiceId(rmeta.replyTo); <line22> wire.send(reply, false); <line23> } <line24> dismiss(); <line25> } <line26> } <line27> "	"<line9>    logger.warn(String.format(""management node[uuid:%s] becomes unavailable, reply %s to message[%s]. Message""+ "" metadata dump: %s"",mgmtNodeId, err, rmeta.messageName, JSONObjectUtil.toJsonString(rmeta)));"	task4	
public class A { <line0> @Override <line1> public MDRAction findByPrimaryKey(Serializable primaryKey) throws NoSuchActionException { <line2> MDRAction mdrAction = fetchByPrimaryKey(primaryKey); <line3> if (mdrAction == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchActionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return mdrAction; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> private DescendantConsumers getDescendantConsumers(PCollectionNode inputPCollection) { <line1> Set<PTransformNode> unfused = new HashSet<>(); <line2> NavigableSet<CollectionConsumer> downstreamConsumers = new TreeSet<>(); <line3> for (PTransformNode consumer : pipeline.getPerElementConsumers(inputPCollection)) { <line4> if (pipeline.getEnvironment(consumer).isPresent()) { <line5> downstreamConsumers.add(CollectionConsumer.of(inputPCollection, consumer)); <line6> } else { <line7> unfused.add(consumer); <line8> for (PCollectionNode output : pipeline.getOutputPCollections(consumer)) { <line9> DescendantConsumers descendants = getDescendantConsumers(output); <line10> unfused.addAll(descendants.getUnfusedNodes()); <line11> downstreamConsumers.addAll(descendants.getFusibleConsumers()); <line12> } <line13> } <line14> } <line15> return DescendantConsumers.of(unfused, downstreamConsumers); <line16> } <line17> } <line18> 	"<line7>        LOG.debug(""Adding {} {} to the set of runner-executed transforms"",PTransformNode.class.getSimpleName(),consumer.getId());"	task4	
"public class A { <line0> public Layout parseLayout(String className, Element layoutElement, XmlConfiguration config) { <line1> PluginType<?> plugin = plugins.get(className.toLowerCase()); <line2> if (plugin != null) { <line3> try { <line4> @SuppressWarnings(""unchecked"") <line5> LayoutBuilder builder = (LayoutBuilder) LoaderUtil.newInstanceOf(plugin.getPluginClass()); <line6> return builder.parseLayout(layoutElement, config); <line7> } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) { <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> "	"<line8>        LOGGER.warn(""Unable to load plugin: {} due to: {}"", plugin.getKey(), ex.getMessage());"	task4	
"public class A { <line0> public Map<String, String> statusOfSystem() throws PacManException { <line1> Map<String, String> status = new HashMap<>(); <line2> try { <line3> List<Rule> rules = ruleRepository.findAll(); <line4> List<JobExecutionManager> jobs = jobRepository.findAll(); <line5> boolean rulesEnabled = false; <line6> boolean jobsEnabled = false; <line7> for (Rule rule : rules) { <line8> if (rule.getStatus().equals(RuleState.ENABLED.name())) { <line9> rulesEnabled = true; <line10> break; <line11> } <line12> } <line13> for (JobExecutionManager job : jobs) { <line14> if (job.getStatus().equals(RuleState.ENABLED.name())) { <line15> jobsEnabled = true; <line16> break; <line17> } <line18> } <line19> if (rulesEnabled) { <line20> status.put(""rule"", RuleState.ENABLED.name()); <line21> } else { <line22> status.put(""rule"", RuleState.DISABLED.name()); <line23> } <line24> if (jobsEnabled) { <line25> status.put(""job"", RuleState.ENABLED.name()); <line26> } else { <line27> status.put(""job"", RuleState.DISABLED.name()); <line28> } <line29> return status; <line30> } catch (Exception e) { <line31> throw new PacManException(""Error in fetching the status of system""); <line32> } <line33> } <line34> } <line35> "	"<line31>      log.error(""Error in fetching status of system"", e);"	task4	
public class A { <line0> @Override <line1> protected String getSEQWARE_PASSWORD() { <line2> if (settings.containsKey(SqwKeys.BASIC_TEST_DB_PASSWORD.getSettingKey())) { <line3> return settings.get(SqwKeys.BASIC_TEST_DB_PASSWORD.getSettingKey()); <line4> } <line5> return super.getSEQWARE_PASSWORD(); <line6> } <line7> } <line8> 	"<line5>    Log.debug(""Could not retrieve basic test db password, using default from unit tests"");"	task4	
public class A { <line0> @Override <line1> public long getSize() { <line2> long size = 0L; <line3> try (Tx tx = StructrApp.getInstance().tx()) { <line4> size = page.getContent(RenderContext.EditMode.RAW).length(); <line5> tx.success(); <line6> } catch (FrameworkException fex) { <line7> } <line8> return size; <line9> } <line10> } <line11> 	"<line7>      logger.error(""Error while last modified date of "" + this, fex);"	task4	
public class A { <line0> public Set<DetectionAlertScheme> loadAlertSchemes( <line1> DetectionAlertConfigDTO alertConfig, <line2> ThirdEyeAnomalyConfiguration thirdeyeConfig, <line3> DetectionAlertFilterResult result) <line4> throws Exception { <line5> Preconditions.checkNotNull(alertConfig); <line6> Map<String, Object> alertSchemes = alertConfig.getAlertSchemes(); <line7> if (alertSchemes == null || alertSchemes.isEmpty()) { <line8> Map<String, Object> emailScheme = new HashMap<>(); <line9> emailScheme.put(PROP_CLASS_NAME, DEFAULT_ALERT_SCHEME); <line10> alertSchemes = Collections.singletonMap(PROP_EMAIL_SCHEME, emailScheme); <line11> } <line12> Set<DetectionAlertScheme> detectionAlertSchemeSet = new HashSet<>(); <line13> for (String alertSchemeType : alertSchemes.keySet()) { <line14> Preconditions.checkNotNull(alertSchemes.get(alertSchemeType)); <line15> Preconditions.checkNotNull( <line16> ConfigUtils.getMap(alertSchemes.get(alertSchemeType)).get(PROP_CLASS_NAME)); <line17> Constructor<?> constructor = <line18> Class.forName( <line19> ConfigUtils.getMap(alertSchemes.get(alertSchemeType)) <line20> .get(PROP_CLASS_NAME) <line21> .toString() <line22> .trim()) <line23> .getConstructor( <line24> DetectionAlertConfigDTO.class, <line25> ThirdEyeAnomalyConfiguration.class, <line26> DetectionAlertFilterResult.class); <line27> detectionAlertSchemeSet.add( <line28> (DetectionAlertScheme) constructor.newInstance(alertConfig, thirdeyeConfig, result)); <line29> } <line30> return detectionAlertSchemeSet; <line31> } <line32> } <line33> 	"<line14>      LOG.debug(""Loading Alert Scheme : {}"", alertSchemeType);"	task4	
"public class A { <line0> @Test <line1> public void testAggregateProcessDefinitions() throws Exception { <line2> String xml1 = read(this.getClass().getResourceAsStream(""/jaxb/process-def-1.xml"")); <line3> String xml2 = read(this.getClass().getResourceAsStream(""/jaxb/process-def-2.xml"")); <line4> JaxbXMLResponseAggregator aggregate = new JaxbXMLResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(xml1); <line7> data.add(xml2); <line8> String result = aggregate.aggregate(data); <line9> Document xml = toXml(result); <line10> assertNotNull(xml); <line11> NodeList processes = xml.getElementsByTagName(""process-definitions""); <line12> assertNotNull(processes); <line13> assertEquals(1, processes.getLength()); <line14> NodeList processDefs = xml.getElementsByTagName(""processes""); <line15> assertNotNull(processDefs); <line16> assertEquals(5, processDefs.getLength()); <line17> } <line18> } <line19> "	<line9>    logger.debug(result);	task4	
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/editors"") <line3> @RolesAllowed({ADMIN_ROLE}) <line4> public Collection<String> getEditors() { <line5> return appFormerActivities.getAllEditorIds(); <line6> } <line7> } <line8> "	"<line5>    logger.debug(""-----getEditors--- "");"	task4	
public class A { <line0> @Nonnull <line1> @Override <line2> public AccessLevel getAccessLevel( <line3> @Nullable final PrimaryEntity entity, @Nullable final EntityReference userOrGroup) { <line4> AccessLevel result = resolveAccessLevel(NONE); <line5> if (entity == null || userOrGroup == null) { <line6> return result; <line7> } <line8> try { <line9> final Owner ownerObj = getOwner(entity); <line10> final EntityReference owner = ownerObj == null ? null : ownerObj.getUser(); <line11> final Collection<Collaborator> collaborators = getCollaborators(entity); <line12> final Set<DocumentReference> processedEntities = new HashSet<>(); <line13> final Queue<DocumentReference> entitiesToCheck = new LinkedList<>(); <line14> entitiesToCheck.add((DocumentReference) userOrGroup); <line15> AccessLevel currentItemAccess; <line16> DocumentReference currentItem; <line17> final XWikiContext context = this.xcontextProvider.get(); <line18> final XWikiGroupService groupService = context.getWiki().getGroupService(context); <line19> while (!entitiesToCheck.isEmpty()) { <line20> currentItem = entitiesToCheck.poll(); <line21> currentItemAccess = getAccessLevel(currentItem, owner, collaborators); <line22> if (currentItemAccess.compareTo(result) > 0) { <line23> result = currentItemAccess; <line24> } <line25> processedEntities.add(currentItem); <line26> final Collection<DocumentReference> groups = <line27> groupService.getAllGroupsReferencesForMember(currentItem, 0, 0, context); <line28> groups.removeAll(processedEntities); <line29> entitiesToCheck.addAll(groups); <line30> } <line31> } catch (final XWikiException ex) { <line32> } <line33> return result; <line34> } <line35> } <line36> 	"<line32>      this.logger.warn(""Failed to compute access level for [{}] on [{}]: {}"",userOrGroup,entity.getId(),ex.getMessage());"	task4	
"public class A { <line0> byte[] readWithChecksum(int length) throws Exception { <line1> byte[] b = new byte[length]; <line2> for (int i = 0; i < length; i++) { <line3> b[i] = (byte) (read(false) & 0xff); <line4> } <line5> int checksum = read(false); <line6> StringBuffer sb = new StringBuffer(); <line7> for (int i = 0; i < b.length; i++) { <line8> sb.append(String.format(""%02x"", b[i] & 0xff)); <line9> } <line10> sb.append(String.format(""%02x"", checksum & 0xff)); <line11> return b; <line12> } <line13> } <line14> "	"<line11>    Logger.trace(""< "" + sb.toString());"	task4	
public class A { <line0> public void deployTarballResource(String url, String targetName) { <line1> try { <line2> doDeployTarballResource(url, targetName); <line3> } catch (RuntimeException e) { <line4> throw Throwables.propagate(e); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOG.error(""Error deploying '"" + url + ""' on "" + toString() + ""; rethrowing..."", e);"	task4	
public class A { <line0> @Override <line1> public List<TMTextUnit> doWithRetry(RetryContext context) throws DataIntegrityViolationException { <line2> if (context.getRetryCount() > 0) { <line3> long mapExactMatches = mapExactMatches(assetExtractionId, tmId, assetId); <line4> } <line5> return createTMTextUnitForUnmappedAssetTextUnits( <line6> createdByUser, assetExtractionId, tmId, assetId); <line7> } <line8> } <line9> 	"<line4>      logger.error(""Assume concurrent modification happened, perform remapping: {}"", mapExactMatches);"	task4	
public class A { <line0> public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) { <line1> if (minEvictableIdleTimeMillis < 1000 * 30) { <line2> } <line3> this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis; <line4> } <line5> } <line6> 	"<line2>      LOG.error(""minEvictableIdleTimeMillis should be greater than 30000"");"	task4	
public class A { <line0> public static com.liferay.commerce.pricing.model.CommercePricingClassCPDefinitionRelSoap <line1> fetchCommercePricingClassCPDefinitionRel(long commercePricingClassId, long cpDefinitionId) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.pricing.model.CommercePricingClassCPDefinitionRel returnValue = <line5> CommercePricingClassCPDefinitionRelServiceUtil.fetchCommercePricingClassCPDefinitionRel( <line6> commercePricingClassId, cpDefinitionId); <line7> return com.liferay.commerce.pricing.model.CommercePricingClassCPDefinitionRelSoap.toSoapModel( <line8> returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>      log.error(exception, exception);	task4	
"public class A { <line0> @GET <line1> @Path(""/listEffectiveAuthorizations"") <line2> @Produces({ <line3> ""application/xml"", <line4> ""text/xml"", <line5> ""text/plain"", <line6> ""application/json"", <line7> ""text/yaml"", <line8> ""text/x-yaml"", <line9> ""application/x-yaml"", <line10> ""application/x-protobuf"", <line11> ""text/html"" <line12> }) <line13> public AuthorizationsListBase listEffectiveAuthorizations() { <line14> final AuthorizationsListBase list = responseObjectFactory.getAuthorizationsList(); <line15> Principal p = context.getCallerPrincipal(); <line16> String name = p.getName(); <line17> if (p instanceof DatawavePrincipal) { <line18> DatawavePrincipal datawavePrincipal = (DatawavePrincipal) p; <line19> name = datawavePrincipal.getShortName(); <line20> DatawaveUser primaryUser = datawavePrincipal.getPrimaryUser(); <line21> list.setUserAuths( <line22> primaryUser.getDn().subjectDN(), <line23> primaryUser.getDn().issuerDN(), <line24> new HashSet<>(primaryUser.getAuths())); <line25> datawavePrincipal <line26> .getProxiedUsers() <line27> .forEach( <line28> u -> <line29> list.addAuths( <line30> u.getDn().subjectDN(), u.getDn().issuerDN(), new HashSet<>(u.getAuths()))); <line31> list.setAuthMapping(datawavePrincipal.getPrimaryUser().getRoleToAuthMapping().asMap()); <line32> } <line33> return list; <line34> } <line35> } <line36> "	"<line33>    log.trace(name + "" has authorizations union "" + list.getAllAuths());"	task4	
"public class A { <line0> @POST <line1> @Path(""submitAndSchedule/{extension-name}"") <line2> @Consumes({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.MULTIPART_FORM_DATA}) <line3> @Produces({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON}) <line4> public APIResult submitAndSchedule( <line5> @PathParam(""extension-name"") String extensionName, <line6> @Context HttpServletRequest request, <line7> @DefaultValue("""") @QueryParam(""doAs"") String doAsUser, <line8> @QueryParam(""jobName"") String jobName, <line9> @QueryParam(""colo"") final String coloExpr, <line10> @FormDataParam(""processes"") List<FormDataBodyPart> processForms, <line11> @FormDataParam(""feeds"") List<FormDataBodyPart> feedForms, <line12> @FormDataParam(""config"") InputStream config) { <line13> checkIfExtensionServiceIsEnabled(); <line14> checkIfExtensionIsEnabled(extensionName); <line15> checkIfExtensionJobNameExists(jobName, extensionName); <line16> SortedMap<EntityType, List<Entity>> entityMap; <line17> SortedMap<EntityType, List<String>> entityNameMap; <line18> ExtensionMetaStore metaStore = ExtensionStore.getMetaStore(); <line19> try { <line20> entityMap = getEntityList(extensionName, jobName, feedForms, processForms, config); <line21> submitEntities(extensionName, jobName, entityMap, config, request); <line22> entityNameMap = getJobEntities(metaStore.getExtensionJobDetails(jobName)); <line23> scheduleEntities(entityNameMap, request, coloExpr); <line24> } catch (FalconException | IOException | JAXBException e) { <line25> throw FalconWebException.newAPIException(e, Response.Status.INTERNAL_SERVER_ERROR); <line26> } <line27> return new APIResult( <line28> APIResult.Status.SUCCEEDED, ""Extension job submitted and scheduled successfully""); <line29> } <line30> } <line31> "	"<line25>      LOG.error(""Error while submitting extension job: "", e);"	task4	
public class A { <line0> @Override <line1> public void configure(JobConf job) { <line2> } <line3> } <line4> 	"<line2>    log.info(""Initialisation complete."");"	task4	
public class A { <line0> private Bundle getOwnerBundle(ServletContext context) { <line1> if (context instanceof OsgiServletContext) { <line2> return ((OsgiServletContext) context).getOsgiContextModel().getOwnerBundle(); <line3> } <line4> Object attribute = context.getAttribute(PaxWebConstants.CONTEXT_PARAM_BUNDLE_CONTEXT); <line5> if (attribute instanceof BundleContext) { <line6> return ((BundleContext) attribute).getBundle(); <line7> } <line8> if (attribute != null) { <line9> } <line10> return null; <line11> } <line12> } <line13> 	"<line9>      LOG.warn(""Wrong type of {} attribute. Expected {}, got {}"",PaxWebConstants.CONTEXT_PARAM_BUNDLE_CONTEXT,BundleContext.class.getName(),attribute.getClass().getName());"	task4	
public class A { <line0> private boolean isVersionEmpty(HProjectIteration version) { <line1> if (version.getDocuments().isEmpty()) { <line2> return true; <line3> } <line4> return false; <line5> } <line6> } <line7> 	"<line2>      log.error(""No documents in version {}:{}"", version.getProject().getSlug(), version.getSlug());"	task4	
public class A { <line0> public void removeTlsContext(String alias) { <line1> if (containsAlias(alias)) { <line2> TlsContext removeMe = tlsContexts.get(alias); <line3> inboundTlsContexts.remove(removeMe); <line4> outboundTlsContexts.remove(removeMe); <line5> tlsContexts.remove(alias); <line6> knownAliases.remove(alias); <line7> } else { <line8> } <line9> } <line10> } <line11> 	"<line8>      LOGGER.debug(""No context with alias "" + alias + "" found, nothing to remove"");"	task4	
public class A { <line0> public final List findByRowKeys( <line1> Class entityClass, <line2> List<String> relationNames, <line3> boolean isWrapReq, <line4> EntityMetadata metadata, <line5> Object... rowIds) { <line6> List entities = null; <line7> MetamodelImpl metaModel = <line8> (MetamodelImpl) <line9> kunderaMetadata.getApplicationMetadata().getMetamodel(metadata.getPersistenceUnit()); <line10> EntityType entityType = metaModel.entity(metadata.getEntityClazz()); <line11> List<AbstractManagedType> subManagedType = <line12> ((AbstractManagedType) entityType).getSubManagedType(); <line13> try { <line14> if (!subManagedType.isEmpty()) { <line15> for (AbstractManagedType subEntity : subManagedType) { <line16> EntityMetadata subEntityMetadata = <line17> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, subEntity.getJavaType()); <line18> entities = <line19> getDataHandler() <line20> .fromThriftRow( <line21> entityClass, <line22> subEntityMetadata, <line23> subEntityMetadata.getRelationNames(), <line24> isWrapReq, <line25> getConsistencyLevel(), <line26> rowIds); <line27> if (entities != null && !entities.isEmpty()) { <line28> break; <line29> } <line30> } <line31> } else { <line32> entities = <line33> getDataHandler() <line34> .fromThriftRow( <line35> entityClass, metadata, relationNames, isWrapReq, getConsistencyLevel(), rowIds); <line36> } <line37> } catch (Exception e) { <line38> throw new KunderaException(e); <line39> } <line40> return entities; <line41> } <line42> } <line43> 	"<line38>      log.error(""Error while retrieving records for entity {}, row keys {}"", entityClass, rowIds);"	task4	
"public class A { <line0> void doInstanceDiscovery( <line1> final Map<String, String> headers, final Proxy proxy, final SSLSocketFactory sslSocketFactory) <line2> throws Exception { <line3> if (!instanceDiscoveryCompleted) { <line4> if (!doStaticInstanceDiscovery()) { <line5> if (validateAuthority && !doDynamicInstanceDiscovery(headers, proxy, sslSocketFactory)) { <line6> throw new AuthenticationException(AuthenticationErrorMessage.AUTHORITY_NOT_IN_VALID_LIST); <line7> } <line8> } <line9> String msg = <line10> LogHelper.createMessage( <line11> ""Instance discovery was successful"", <line12> headers.get(ClientDataHttpHeaders.CORRELATION_ID_HEADER_NAME)); <line13> instanceDiscoveryCompleted = true; <line14> } <line15> } <line16> } <line17> "	<line13>      log.info(msg);	task4	
"public class A { <line0> @After <line1> public void tearDown() { <line2> try { <line3> if (nominalLabel != null) { <line4> entityManager.getTransaction().begin(); <line5> nominalLabelResourceFacadeImp.deleteNominalLabel(nominalLabel); <line6> entityManager.getTransaction().commit(); <line7> nominalLabel = null; <line8> } <line9> } catch (PropertyNotSetException e) { <line10> fail(""tearDown failed""); <line11> } <line12> } <line13> } <line14> "	"<line10>      logger.error(""PropertyNotSetException while deleting nominal label "" + e.getMessage());"	task4	
public class A { <line0> @Override <line1> public void onBeforeRemove(CommerceApplicationModel commerceApplicationModel) { <line2> try { <line3> _commerceApplicationModelLocalService.deleteCommerceApplicationModels( <line4> commerceApplicationModel.getCommerceApplicationModelId()); <line5> } catch (PortalException portalException) { <line6> if (log.isWarnEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>        log.warn(portalException, portalException);	task4	
public class A { <line0> private static void warningsForRemovedEndVars(Map<String, String> map) { <line1> if (map.containsKey(STRIMZI_DEFAULT_TLS_SIDECAR_KAFKA_IMAGE)) { <line2> } <line3> } <line4> } <line5> 	"<line2>      log.warn(""Kafka TLS sidecar container has been removed and the environment variable {} is not used""+ "" anymore. You can remove it from the Strimzi Cluster Operator deployment."",STRIMZI_DEFAULT_TLS_SIDECAR_KAFKA_IMAGE);"	task4	
public class A { <line0> private void figureOutLocalIP() { <line1> if (!config.outboundIP.trim().isEmpty()) { <line2> try { <line3> localAddress = InetAddress.getByName(config.outboundIP); <line4> return; <line5> } catch (UnknownHostException e) { <line6> } <line7> } <line8> NetworkAddressService network = networkAS; <line9> String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null; <line10> if (adr != null) { <line11> try { <line12> localAddress = InetAddress.getByName(adr); <line13> } catch (UnknownHostException e) { <line14> } <line15> } <line16> } <line17> } <line18> 	"<line4>        logger.debug(""Outbound local IP.\""{}\"""", localAddress);"	task4	
public class A { <line0> protected void resetAuthentication() { <line1> authenticationToken = emptyAuthenticationToken; <line2> return; <line3> } <line4> } <line5> 	"<line1>    logger.trace(""resetAuthentication() called."");"	task4	
public class A { <line0> @Override <line1> public boolean hasSoftwareVersion() { <line2> Avp terminalInfoAvp = super.message.getAvps().getAvp(Avp.TERMINAL_INFORMATION); <line3> if (terminalInfoAvp != null) { <line4> try { <line5> return terminalInfoAvp.getGrouped().getAvp(Avp.SOFTWARE_VERSION) != null; <line6> } catch (AvpDataException ex) { <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> 	"<line7>        logger.debug(""Failure trying to obtain (Terminal-Information) Software-Version AVP value"", ex);"	task4	
"public class A { <line0> @Override <line1> public ArrayList<GwtFirewallOpenPortEntry> findDeviceFirewallOpenPorts(GwtXSRFToken xsrfToken) <line2> throws GwtKuraException { <line3> checkXSRFToken(xsrfToken); <line4> NetworkAdminService nas = ServiceLocator.getInstance().getService(NetworkAdminService.class); <line5> List<GwtFirewallOpenPortEntry> gwtOpenPortEntries = new ArrayList<>(); <line6> try { <line7> List<NetConfig> firewallConfigs = nas.getFirewallConfiguration(); <line8> if (firewallConfigs != null && !firewallConfigs.isEmpty()) { <line9> for (NetConfig netConfig : firewallConfigs) { <line10> if (netConfig instanceof FirewallOpenPortConfigIP4) { <line11> GwtFirewallOpenPortEntry entry = new GwtFirewallOpenPortEntry(); <line12> if (((FirewallOpenPortConfigIP4) netConfig).getPortRange() != null) { <line13> entry.setPortRange(((FirewallOpenPortConfigIP4) netConfig).getPortRange()); <line14> } else { <line15> entry.setPortRange(String.valueOf(((FirewallOpenPortConfigIP4) netConfig).getPort())); <line16> } <line17> entry.setProtocol(((FirewallOpenPortConfigIP4) netConfig).getProtocol().toString()); <line18> entry.setPermittedNetwork( <line19> ((FirewallOpenPortConfigIP4) netConfig) <line20> .getPermittedNetwork() <line21> .getIpAddress() <line22> .getHostAddress() <line23> + ""/"" <line24> + ((FirewallOpenPortConfigIP4) netConfig).getPermittedNetwork().getPrefix()); <line25> entry.setPermittedInterfaceName( <line26> ((FirewallOpenPortConfigIP4) netConfig).getPermittedInterfaceName()); <line27> entry.setUnpermittedInterfaceName( <line28> ((FirewallOpenPortConfigIP4) netConfig).getUnpermittedInterfaceName()); <line29> entry.setPermittedMAC(((FirewallOpenPortConfigIP4) netConfig).getPermittedMac()); <line30> entry.setSourcePortRange(((FirewallOpenPortConfigIP4) netConfig).getSourcePortRange()); <line31> gwtOpenPortEntries.add(entry); <line32> } <line33> } <line34> } <line35> return new ArrayList<>(gwtOpenPortEntries); <line36> } catch (KuraException e) { <line37> throw new GwtKuraException(GwtKuraErrorCode.INTERNAL_ERROR, e); <line38> } <line39> } <line40> } <line41> "	"<line11>            logger.debug(""findDeviceFirewallOpenPorts() :: adding new Open Port Entry: {}"",((FirewallOpenPortConfigIP4) netConfig).getPort());"	task4	
public class A { <line0> @Test <line1> public void testPutMissedDhtRequest_UnstableTopology() throws Exception { <line2> blockRebalance = true; <line3> ccfg = cacheConfiguration(1, FULL_SYNC); <line4> startServers(4); <line5> client = true; <line6> Ignite client = startGrid(4); <line7> IgniteCache<Integer, Integer> nearCache = client.cache(TEST_CACHE); <line8> testSpi(ignite(0)) <line9> .blockMessages( <line10> new IgniteBiPredicate<ClusterNode, Message>() { <line11> @Override <line12> public boolean apply(ClusterNode node, Message msg) { <line13> return msg instanceof GridDhtAtomicAbstractUpdateRequest; <line14> } <line15> }); <line16> Integer key = primaryKey(ignite(0).cache(TEST_CACHE)); <line17> IgniteFuture<?> fut = nearCache.putAsync(key, key); <line18> U.sleep(500); <line19> assertFalse(fut.isDone()); <line20> stopGrid(0); <line21> fut.get(); <line22> checkData(F.asMap(key, key)); <line23> } <line24> } <line25> 	"<line17>    log.info(""Start put [key="" + key + ']');"	task4	
public class A { <line0> private ScheduledReporter createAndGetConfiguredCSVReporter(String prefix, String csvDir) <line1> throws IOException { <line2> File outputDir; <line3> if (Strings.isNullOrEmpty(prefix)) { <line4> outputDir = new File(csvDir, prefix); <line5> } else { <line6> outputDir = new File(csvDir); <line7> } <line8> FileUtils.forceMkdir(outputDir); <line9> return CsvReporter.forRegistry(metrics) <line10> .convertRatesTo(TimeUnit.SECONDS) <line11> .convertDurationsTo(TimeUnit.MILLISECONDS) <line12> .build(outputDir); <line13> } <line14> } <line15> 	"<line9>    LOG.info(""Configuring stats with csv output to directory [{}]"", outputDir.getAbsolutePath());"	task4	
public class A { <line0> @Override <line1> public void evict(TenantId tenantId, DeviceProfileId profileId) { <line2> DeviceProfile oldProfile = deviceProfilesMap.remove(profileId); <line3> DeviceProfile newProfile = get(tenantId, profileId); <line4> if (newProfile != null) { <line5> notifyProfileListeners(newProfile); <line6> } <line7> } <line8> } <line9> 	"<line3>    log.debug(""[{}] evict device profile from cache: {}"", profileId, oldProfile);"	task4	
"public class A { <line0> public static void restoreMessageAttachmentFromTrash( <line1> HttpPrincipal httpPrincipal, long messageId, String fileName) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> MBMessageServiceUtil.class, <line7> ""restoreMessageAttachmentFromTrash"", <line8> _restoreMessageAttachmentFromTrashParameterTypes32); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, messageId, fileName); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public void text(String text) { <line2> here.addChild(TreeNode.create_text(text)); <line3> } <line4> } <line5> 	<line2>    log.trace(text);	task4	
public class A { <line0> public void reportFPComplications(FormSubmission submission) { <line1> EligibleCouple couple = allEligibleCouples.findByCaseId(submission.entityId()); <line2> if (couple == null) { <line3> return; <line4> } <line5> FPProductInformation fpProductInformation = <line6> new FPProductInformation( <line7> submission.entityId(), <line8> submission.anmId(), <line9> null, <line10> null, <line11> null, <line12> null, <line13> null, <line14> null, <line15> submission.getField(SUBMISSION_DATE_FIELD_NAME), <line16> null, <line17> submission.getField(COMPLICATION_DATE_FIELD_NAME), <line18> submission.getField(NEEDS_FOLLOWUP_FIELD_NAME), <line19> submission.getField(NEEDS_REFERRAL_FOLLOWUP_FIELD_NAME)); <line20> schedulingService.reportFPComplications(fpProductInformation); <line21> } <line22> } <line23> 	"<line3>      logger.warn(""Tried to report FP Complications of a non-existing EC, with submission: "" + submission);"	task4	
public class A { <line0> @Override <line1> public Object visit(PropertyName expression, Object data) { <line2> return data; <line3> } <line4> } <line5> 	"<line2>    LOGGER.trace(""Visiting PropertyName expression"");"	task4	
public class A { <line0> @Override <line1> public Object unmarshal(final Node nodeToUnmarshal, final Class<?> destinationClazz) { <line2> try { <line3> final Unmarshaller u = JAXBSupport.createUnmarshaller(); <line4> final JAXBElement<?> jaxbElement = u.unmarshal(nodeToUnmarshal, destinationClazz); <line5> if (jaxbElement != null) { <line6> return jaxbElement.getValue(); <line7> } <line8> } catch (final JAXBException e) { <line9> e.printStackTrace(); <line10> } finally { <line11> this.printErrorsWhileSerialization(); <line12> } <line13> return null; <line14> } <line15> } <line16> 	"<line2>    LOG.trace(""Start the unmarshalling of the node: ""+ nodeToUnmarshal.toString()+ "" to clazz: ""+ destinationClazz.toString());"	task4	
"public class A { <line0> private void closeAndDeleteAfterEx(IOException ex, OplogFile olf) { <line1> if (olf == null) { <line2> return; <line3> } <line4> if (olf.raf != null) { <line5> try { <line6> olf.raf.close(); <line7> } catch (IOException e) { <line8> } <line9> } <line10> olf.RAFClosed = true; <line11> if (!olf.f.delete() && olf.f.exists()) { <line12> throw new DiskAccessException( <line13> String.format(""Could not delete %s."", olf.f.getAbsolutePath()), ex, getParent()); <line14> } <line15> } <line16> } <line17> "	"<line8>        logger.warn(String.format(""Failed to close file %s"", olf.f.getAbsolutePath()), e);"	task4	
public class A { <line0> public int saveAssessmentReport(JsonObject assessmentReportJson) throws InsightsCustomException { <line1> int assessmentReportId; <line2> try { <line3> InsightsAssessmentConfiguration assessmentConfig = <line4> populateAssessmentReportConfiguration(assessmentReportJson); <line5> assessmentReportId = reportConfigDAL.saveInsightsAssessmentConfig(assessmentConfig); <line6> return assessmentReportId; <line7> } catch (InsightsCustomException e) { <line8> throw new InsightsCustomException(e.getMessage()); <line9> } <line10> } <line11> } <line12> 	"<line8>      log.error(""Error while saving the report .. {}"", e.getMessage());"	task4	
public class A { <line0> public static long zip(File directory, File outputZipFile) throws IOException { <line1> if (!isZip(outputZipFile.getName())) { <line2> } <line3> try (final FileOutputStream out = new FileOutputStream(outputZipFile)) { <line4> return zip(directory, out); <line5> } <line6> } <line7> } <line8> 	"<line2>      log.warn(""No .zip suffix[%s], putting files from [%s] into it anyway."", outputZipFile, directory);"	task4	
public class A { <line0> protected ExecutorService createThreadExecutor(JRFillContext fillContext) { <line1> SubreportsThreadFactory threadFactory = new SubreportsThreadFactory(fillContext); <line2> ExecutorService threadExecutor = Executors.newCachedThreadPool(threadFactory); <line3> if (log.isDebugEnabled()) { <line4> } <line5> return threadExecutor; <line6> } <line7> } <line8> 	"<line4>      log.debug(""created subreports thread executor ""+ threadExecutor+ "" for ""+ fillContext.getMasterFiller().getJasperReport().getName());"	task4	
"public class A { <line0> private void showNoRepoLoadedNotification(NotificationController nc) { <line1> Platform.runLater( <line2> () -> { <line3> nc.addNotification( <line4> ""You need to load a repository before you can perform operations on it. Click on the"" <line5> + "" plus sign in the upper left corner!""); <line6> }); <line7> } <line8> } <line9> "	"<line3>          logger.warn(""No repo loaded warning."");"	task4	
public class A { <line0> @Transactional <line1> public void updateUserInfo( <line2> int userId, String name, String surname, int age, String userName, String password) { <line3> User user = this.entityManager.find(User.class, userId); <line4> user.setName(name); <line5> user.setSurname(surname); <line6> user.setAge(age); <line7> user.setUserName(userName); <line8> user.setPassword(password); <line9> } <line10> } <line11> 	"<line3>    logger.debug(""Updating user with id : "" + userId);"	task4	
public class A { <line0> private boolean reset(List<LogicalTable> requiredTables) { <line1> try { <line2> this.requiredTables = requiredTables; <line3> if (needsReset) { <line4> if (this.searchStack != null) { <line5> this.searchStack.clear(); <line6> } <line7> for (Node n : nodes) { <line8> n.clearRequirement(); <line9> } <line10> for (Arc a : arcs) { <line11> a.clearRequirement(); <line12> } <line13> } else { <line14> this.needsReset = true; <line15> } <line16> for (Node n : nodes) { <line17> if (requiredTables.contains(n.getTable())) { <line18> n.setRequirement(true); <line19> } <line20> } <line21> return true; <line22> } catch (ConsistencyException cx) { <line23> return false; <line24> } <line25> } <line26> } <line27> 	"<line23>      logger.debug(""failed to reset"", cx);"	task4	
public class A { <line0> private TransactionalDataSource createShardDatasource(Long shardId, DbVersion dbVersion) { <line1> long start = System.currentTimeMillis(); <line2> waitAvailability(); <line3> ShardDataSourceCreateHelper shardDataSourceCreateHelper = <line4> new ShardDataSourceCreateHelper(this, shardId).createUninitializedDataSource(); <line5> TransactionalDataSource shardDb = shardDataSourceCreateHelper.getShardDb(); <line6> shardDb.init(dbVersion); <line7> connectedShardDataSourceMap.put(shardId, shardDb); <line8> return shardDb; <line9> } <line10> } <line11> 	"<line8>    log.debug(""new SHARD datasource'{}' is ADDED in {} ms"",shardDataSourceCreateHelper.getShardName(),System.currentTimeMillis() - start);"	task4	
public class A { <line0> @Override <line1> public Double visit(LessEqualFilter lessEqualFilter) { <line2> int minBound = <line3> 9 <line4> - IntStream.rangeClosed(0, 9) <line5> .filter(i -> percentiles[9 - i] <= lessEqualFilter.getValue().doubleValue()) <line6> .findFirst() <line7> .orElse(0); <line8> final double result = ((double) minBound + 1.0) / 10.0; <line9> return result; <line10> } <line11> } <line12> 	"<line9>    log.debug(""cacheKey:{} LessEqualsFilter: {} percentiles[{}] = {} multiplier: {}"",cacheKey,lessEqualFilter,minBound,percentiles[minBound],result);"	task4	
"public class A { <line0> @Override <line1> public HttpURLConnection connect( <line2> final URI uri, <line3> final String method, <line4> final byte[] entity, <line5> final Map<String, List<String>> headers) <line6> throws HeliosException { <line7> final Endpoint endpoint = endpointIterator.next(); <line8> final String endpointHost = endpoint.getUri().getHost(); <line9> try { <line10> final HttpURLConnection connection = connect0(uri, method, entity, headers, endpointHost); <line11> if (connection.getResponseCode() == HTTP_BAD_GATEWAY) { <line12> throw new HeliosException( <line13> String.format( <line14> ""Request to %s returned %s, master is down"", uri, connection.getResponseCode())); <line15> } <line16> return connection; <line17> } catch (ConnectException | SocketTimeoutException | UnknownHostException e) { <line18> throw new HeliosException(""Unable to connect to master: "" + uri, e); <line19> } catch (IOException e) { <line20> throw new HeliosException(""Unexpected error connecting to "" + uri, e); <line21> } <line22> } <line23> } <line24> "	<line18>      log.debug(e.toString());	task4	
"public class A { <line0> @Test <line1> public void testThroughputCounterApp() throws FileNotFoundException, IOException { <line2> Logger logger = LoggerFactory.getLogger(ThroughputCounterAppTest.class); <line3> LocalMode lm = LocalMode.newInstance(); <line4> Configuration conf = new Configuration(); <line5> InputStream is = new FileInputStream(""src/site/conf/dt-site-testbench.xml""); <line6> conf.addResource(is); <line7> conf.get(""dt.application.ThroughputCounterApp.operator.hmapOper.keys""); <line8> conf.get(""dt.application.ThroughputCounterApp.operator.hmapOper.numKeys""); <line9> try { <line10> lm.prepareDAG(new ThroughputCounterApp(), conf); <line11> LocalMode.Controller lc = lm.getController(); <line12> lc.run(20000); <line13> } catch (Exception ex) { <line14> } <line15> is.close(); <line16> } <line17> } <line18> "	<line14>      logger.info(ex.getMessage());	task4	
"public class A { <line0> public String getAttachmentContentById( <line1> String containerId, Number taskId, Number attachmentId, String marshallingType) { <line2> containerId = <line3> context.getContainerId(containerId, new ByTaskIdContainerLocator(taskId.longValue())); <line4> Object attachment = <line5> userTaskService.getAttachmentContentById( <line6> containerId, taskId.longValue(), attachmentId.longValue()); <line7> if (attachment == null) { <line8> throw new IllegalStateException( <line9> ""No attachment found for id "" + attachmentId + "" for task "" + taskId); <line10> } <line11> String response = marshallerHelper.marshal(containerId, marshallingType, attachment); <line12> return response; <line13> } <line14> } <line15> "	"<line11>    logger.debug(""About to marshal task attachment with id '{}' {}"", attachmentId, attachment);"	task4	
public class A { <line0> private void findDefaultAutoIncrementingColumn(Connection db) throws SQLException { <line1> if (incrementingColumnName != null && incrementingColumnName.isEmpty()) { <line2> for (ColumnDefinition defn : <line3> dialect <line4> .describeColumns( <line5> db, tableId.catalogName(), tableId.schemaName(), tableId.tableName(), null) <line6> .values()) { <line7> if (defn.isAutoIncrement()) { <line8> incrementingColumnName = defn.id().name(); <line9> break; <line10> } <line11> } <line12> } <line13> if (incrementingColumnName != null && incrementingColumnName.isEmpty()) { <line14> for (ColumnDefinition defn : dialect.describeColumnsByQuerying(db, tableId).values()) { <line15> if (defn.isAutoIncrement()) { <line16> incrementingColumnName = defn.id().name(); <line17> break; <line18> } <line19> } <line20> } <line21> } <line22> } <line23> 	"<line14>      log.debug(""Falling back to describe '{}' table by querying {}"", tableId, db);"	task4	
public class A { <line0> private static synchronized RpcEngine getProtocolEngine(Class protocol, Configuration conf) { <line1> RpcEngine engine = PROTOCOL_ENGINES.get(protocol); <line2> if (engine == null) { <line3> Class<?> defaultEngine = ProtobufRpcEngine.class; <line4> Class<?> impl = defaultEngine; <line5> engine = (RpcEngine) ReflectionUtils.newInstance(impl, conf); <line6> if (protocol.isInterface()) <line7> PROXY_ENGINES.put(Proxy.getProxyClass(protocol.getClassLoader(), protocol), engine); <line8> PROTOCOL_ENGINES.put(protocol, engine); <line9> } <line10> return engine; <line11> } <line12> } <line13> 	"<line5>      LOG.debug(""Using "" + impl.getName() + "" for "" + protocol.getName());"	task4	
public class A { <line0> public static Properties makePropertiesWithEnvironmentVariables(String properties_file) { <line1> Properties properties = new Properties(); <line2> try { <line3> properties.load(PropertiesUtil.class.getClassLoader().getResourceAsStream(properties_file)); <line4> } catch (IOException ex) { <line5> } <line6> Properties env_properties = new Properties(); <line7> for (String name : properties.stringPropertyNames()) { <line8> env_properties.setProperty(name, resolveValueWithEnvVars(properties.getProperty(name))); <line9> } <line10> return env_properties; <line11> } <line12> } <line13> 	"<line5>      logger.error(""Unable to access "" + properties_file, ex);"	task4	
public class A { <line0> @Nonnull <line1> @Override <line2> public Optional<Link> extractLink(String s) { <line3> return extractLinkLiteral(s) <line4> .flatMap( <line5> l -> { <line6> try { <line7> URI uri = new URI(l); <line8> return Optional.of(new HTTPLink(uri)); <line9> } catch (URISyntaxException e) { <line10> return Optional.empty(); <line11> } <line12> }); <line13> } <line14> } <line15> 	"<line10>                logger.warn(""Link extractor ({}) returned invalid URI: {}"", name, e.getMessage());"	task4	
public class A { <line0> @Override <line1> public boolean restoreVMFromBackup(VirtualMachine vm, Backup backup) { <line2> return true; <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Restoring vm ""+ vm.getUuid()+ ""from backup ""+ backup.getUuid()+ "" on the Dummy Backup Provider"");"	task4	
public class A { <line0> private List<JRJsonNode> goDown(JRJsonNode jrJsonNode) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> List<JRJsonNode> result = new ArrayList<>(); <line4> JsonNode dataNode = jrJsonNode.getDataNode(); <line5> if (dataNode.isObject()) { <line6> if (expression.isWildcard()) { <line7> ArrayNode container = getEvaluationContext().getObjectMapper().createArrayNode(); <line8> Iterator<Map.Entry<String, JsonNode>> it = dataNode.fields(); <line9> while (it.hasNext()) { <line10> JsonNode current = it.next().getValue(); <line11> if (applyFilter(jrJsonNode.createChild(current))) { <line12> container.add(current); <line13> } <line14> } <line15> if (container.size() > 0) { <line16> result.add(jrJsonNode.createChild(container)); <line17> } <line18> } else { <line19> JRJsonNode deeperNode = goDeeperIntoObjectNode(jrJsonNode, isCalledFromFilter); <line20> if (deeperNode != null) { <line21> result.add(deeperNode); <line22> } <line23> } <line24> } else if (dataNode.isArray()) { <line25> if (expression.isWildcard()) { <line26> result = filterArrayNode(jrJsonNode, (ArrayNode) dataNode, null, isCalledFromFilter); <line27> } else { <line28> result = <line29> filterArrayNode( <line30> jrJsonNode, (ArrayNode) dataNode, expression.getObjectKey(), isCalledFromFilter); <line31> } <line32> } <line33> return result; <line34> } <line35> } <line36> 	"<line2>      log.debug(""going ""+ MemberExpression.DIRECTION.DOWN+ "" by ""+ (expression.isWildcard() ? ""wildcard"" : ""key: ["" + expression.getObjectKey() + ""]"")+ "" on ""+ jrJsonNode.getDataNode());"	task4	
public class A { <line0> public void onFailure(Object problem) { <line1> if (log != null) { <line2> } <line3> this.problem = problem; <line4> } <line5> } <line6> 	"<line2>      log.warn(""Detected failure in monitor accessing "" + getUrl() + "": "" + problem);"	task4	
public class A { <line0> @Override <line1> protected void doReceive(Message message) throws Exception { <line2> long backgroundTaskId = message.getLong(BackgroundTaskConstants.BACKGROUND_TASK_ID); <line3> if (backgroundTaskId != _backgroundTaskId) { <line4> return; <line5> } <line6> BackgroundTaskStatus backgroundTaskStatus = <line7> _backgroundTaskStatusRegistry.getBackgroundTaskStatus(backgroundTaskId); <line8> if (backgroundTaskStatus == null) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> return; <line12> } <line13> _backgroundTaskStatusMessageTranslator.translate(backgroundTaskStatus, message); <line14> } <line15> } <line16> 	"<line10>        log.debug(StringBundler.concat(""Unable to locate status for background task "",backgroundTaskId,"" to process "",message));"	task4	
"public class A { <line0> @Override <line1> public void joinTournament(final UUID tournamentId, final String sessionId) throws MageException { <line2> execute( <line3> ""joinTournament"", <line4> sessionId, <line5> () -> { <line6> Optional<Session> session = managerFactory.sessionManager().getSession(sessionId); <line7> if (!session.isPresent()) { <line8> } else { <line9> UUID userId = session.get().getUserId(); <line10> managerFactory.tournamentManager().joinTournament(tournamentId, userId); <line11> } <line12> }); <line13> } <line14> } <line15> "	"<line8>            logger.error(""Session not found : "" + sessionId);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public static MachineProvisioningLocation<? extends SshMachineLocation> createLocation( <line2> ManagementContext mgmt) { <line3> Location bestLocation = mgmt.getLocationRegistry().resolveIfPossible(""named:SaltTests""); <line4> if (bestLocation == null) { <line5> bestLocation = mgmt.getLocationRegistry().resolveIfPossible(""jclouds:aws-ec2:us-east-1""); <line6> } <line7> if (bestLocation == null) { <line8> throw new IllegalStateException( <line9> ""Need a location called named:SaltTests or AWS configured for these tests""); <line10> } <line11> return (MachineProvisioningLocation<? extends SshMachineLocation>) bestLocation; <line12> } <line13> } <line14> "	"<line5>      log.info(""using AWS for salt tests because named:SaltTests does not exist"");"	task4	
public class A { <line0> @Override <line1> public void onFileChange(File file) { <line2> super.onFileChange(file); <line3> try { <line4> if (hbaseAdapter.getHbaseMapping().containsKey(file.getName())) { <line5> String configContent = <line6> MappingConfigsLoader.loadConfig(adapterName + File.separator + file.getName()); <line7> if (configContent == null) { <line8> onFileDelete(file); <line9> return; <line10> } <line11> MappingConfig config = <line12> YmlConfigBinder.bindYmlToObj( <line13> null, configContent, MappingConfig.class, null, envProperties); <line14> if (config == null) { <line15> return; <line16> } <line17> config.validate(); <line18> if (hbaseAdapter.getHbaseMapping().containsKey(file.getName())) { <line19> deleteConfigFromCache(file); <line20> } <line21> addConfigToCache(file, config); <line22> } <line23> } catch (Exception e) { <line24> } <line25> } <line26> } <line27> 	<line24>      logger.error(e.getMessage(), e);	task4	
public class A { <line0> @GetMapping <line1> @Override <line2> public Collection<TenantDto> getAll(@RequestParam final Optional<String> criteria) { <line3> RestUtils.checkCriteria(criteria); <line4> return internalTenantService.getAll(criteria); <line5> } <line6> } <line7> 	"<line3>    LOGGER.debug(""Get all criteria={}"", criteria);"	task4	
"public class A { <line0> public ActivityFrequencyBean getFrequencyRunsDetailsForActiveTasks( <line1> ActiveTaskDto activeTask, ActivityFrequencyBean frequencyDetails, Session session) <line2> throws DAOException { <line3> LOGGER.entry(""begin getFrequencyRunsDetailsForActiveTasks()""); <line4> List<ActivityFrequencyScheduleBean> runDetailsBean = new ArrayList<>(); <line5> List<ActivityFrequencyAnchorRunsBean> anchorRunDetailsBean = new ArrayList<>(); <line6> try { <line7> switch (activeTask.getFrequency()) { <line8> case StudyMetaDataConstants.FREQUENCY_TYPE_DAILY: <line9> runDetailsBean = <line10> this.getActiveTaskFrequencyDetailsForDaily(activeTask, runDetailsBean, session); <line11> break; <line12> case StudyMetaDataConstants.FREQUENCY_TYPE_MANUALLY_SCHEDULE: <line13> runDetailsBean = <line14> this.getActiveTaskFrequencyDetailsForManuallySchedule( <line15> activeTask, runDetailsBean, session); <line16> break; <line17> default: <line18> break; <line19> } <line20> frequencyDetails.setRuns(runDetailsBean); <line21> anchorRunDetailsBean = <line22> this.getAcivetaskFrequencyAncorDetailsForManuallySchedule( <line23> activeTask, anchorRunDetailsBean, session); <line24> frequencyDetails.setAnchorRuns(anchorRunDetailsBean); <line25> } catch (Exception e) { <line26> } <line27> LOGGER.exit(""getFrequencyRunsDetailsForActiveTasks() :: Ends""); <line28> return frequencyDetails; <line29> } <line30> } <line31> "	"<line26>      LOGGER.error(""ActivityMetaDataDao - getFrequencyRunsDetailsForActiveTasks() :: ERROR"", e);"	task4	
public class A { <line0> public void truncateSchema() throws GoraException { <line1> try { <line2> this.client.getSession().execute(CassandraQueryFactory.getTruncateTableQuery(mapping)); <line3> } catch (Exception e) { <line4> throw new GoraException(e); <line5> } <line6> } <line7> } <line8> 	"<line2>      LOG.debug(""truncating Cassandra table {}"", mapping.getCoreName());"	task4	
"public class A { <line0> @Test( <line1> dependsOnMethods = {""createJob"", ""getJob""}, <line2> groups = {""expensive""}) <line3> public void canListAllJobIDs() throws IOException, InterruptedException { <line4> final MantaJob job1 = buildJob(); <line5> final UUID job1id = createJobAndSkipIfUnsupported(job1); <line6> final MantaJob job2 = buildJob(); <line7> final UUID job2id = createJobAndSkipIfUnsupported(job2); <line8> Assert.assertTrue(mantaClient.endJobInput(job1id)); <line9> Assert.assertTrue(mantaClient.endJobInput(job2id)); <line10> awaitJobCompletion(job1id); <line11> awaitJobCompletion(job2id); <line12> try (Stream<UUID> jobs = mantaClient.getAllJobIds()) { <line13> List<UUID> found = <line14> jobs.filter(id -> id.equals(job1id) || id.equals(job2id)).collect(Collectors.toList()); <line15> Assert.assertEquals(found.size(), 2, ""We should have found both jobs""); <line16> } catch (AssertionError e) { <line17> String msg = ""Couldn't find job in job list, retry test a few times to verify""; <line18> throw new SkipException(msg, e); <line19> } <line20> } <line21> } <line22> "	<line18>      LOG.error(msg, e);	task4	
public class A { <line0> private void prepareExtendedRandomLength(ExtendedRandomExtensionMessage msg) { <line1> msg.setExtendedRandomLength(msg.getExtendedRandom().getValue().length); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""ExtendedRandomLength: "" + msg.getExtendedRandomLength().getValue());"	task4	
public class A { <line0> private List<List<String>> getAllAvailablePipelines() { <line1> List<List<String>> configurations = new ArrayList<>(); <line2> CSVReader reader = null; <line3> try { <line4> reader = new CSVReader(new FileReader(csvFilePipelines)); <line5> String[] line; <line6> while ((line = reader.readNext()) != null) { <line7> List<String> configuration = new LinkedList<String>(); <line8> configuration.add(line[0]); <line9> configuration.add(line[1]); <line10> configurations.add(configuration); <line11> } <line12> } catch (IOException e) { <line13> e.printStackTrace(); <line14> } <line15> return configurations; <line16> } <line17> } <line18> 	"<line7>        logger.debug(""Pipelines [id={} , pipeline={} ]"", line[0], line[1]);"	task4	
public class A { <line0> @Override <line1> public Iterator<TypedValue<Item>> iterator() { <line2> return new Iterator<TypedValue<Item>>() { <line3> private SequenceIterator iterator; <line4>  <line5> private SequenceIterator getIterator() { <line6> if (iterator == null) { <line7> try { <line8> iterator = sequence.iterate(); <line9> } catch (final XPathException xpe) { <line10> iterator = SequenceIterator.EMPTY_ITERATOR; <line11> } <line12> } <line13> return iterator; <line14> } <line15>  <line16> @Override <line17> public boolean hasNext() { <line18> return getIterator().hasNext(); <line19> } <line20>  <line21> @Override <line22> public TypedValue<Item> next() { <line23> return createTypedValue(getIterator().nextItem()); <line24> } <line25>  <line26> @Override <line27> public void remove() {} <line28> }; <line29> } <line30> } <line31> 	"<line10>            LOG.error(""Unable to extract the underlying Sequence Iterator: {}. Falling back to""+ "" EMPTY_ITERATOR"",xpe.getMessage(),xpe);"	task4	
public class A { <line0> DLockGrantToken handleLockQuery(DLockQueryMessage query) throws InterruptedException { <line1> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line2> } <line3> if (acquireDestroyReadLock(0)) { <line4> try { <line5> checkDestroyed(); <line6> return getGrantToken(query.objectName); <line7> } finally { <line8> releaseDestroyReadLock(); <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	"<line2>      logger.trace(LogMarker.DLS_VERBOSE, ""[DLockGrantor.handleLockQuery] {}"", query);"	task4	
"public class A { <line0> @Override <line1> public List<Pipeline> createAllPossiblePipelines() { <line2> @SuppressWarnings(""unused"") <line3> List<Module> modules = moduleDAO.getModules(); <line4> return null; <line5> } <line6> } <line7> "	"<line2>    logger.info(""Get all modules from registry"");"	task4	
public class A { <line0> @Override <line1> public Future<Set<String>> listTopics() { <line2> try { <line3> ListTopicsOptions listOptions = new ListTopicsOptions().listInternal(true); <line4> return mapFuture(adminClient.listTopics(listOptions).names()); <line5> } catch (Exception e) { <line6> return Future.failedFuture(e); <line7> } <line8> } <line9> } <line10> 	"<line3>      LOGGER.debug(""Listing topics"");"	task4	
public class A { <line0> @Override <line1> public Note get(String noteId, String notePath, String revId, AuthenticationInfo subject) { <line2> Note revisionNote = null; <line3> try { <line4> if (isRevisionSupportedInDefaultRepo()) { <line5> revisionNote = <line6> ((NotebookRepoWithVersionControl) getRepo(0)).get(noteId, notePath, revId, subject); <line7> } <line8> } catch (IOException e) { <line9> } <line10> return revisionNote; <line11> } <line12> } <line13> 	"<line9>      LOGGER.error(""Failed to get revision {} of note {}"", revId, noteId, e);"	task4	
public class A { <line0> @Override <line1> public void restart(long seekTo) { <line2> lastCurrentPosition = 0; <line3> load(videoUri, seekTo, playWhenPrepared); <line4> } <line5> } <line6> 	"<line2>    logger.debug(""RestartFreezePosition="" + seekTo);"	task4	
"public class A { <line0> public void addGrid(String name, Vector3f pos, int size, String color) { <line1> Spatial s = find(name); <line2> if (s != null) { <line3> return; <line4> } <line5> Geometry g = new Geometry(""wireframe grid"", new Grid(size, size, 1.0f)); <line6> Material mat = new Material(assetManager, ""Common/MatDefs/Misc/Unshaded.j3md""); <line7> mat.getAdditionalRenderState().setWireframe(true); <line8> mat.setColor(""Color"", Jme3Util.toColor(color)); <line9> g.setMaterial(mat); <line10> g.center().move(pos); <line11> Node n = new Node(name); <line12> n.attachChild(g); <line13> rootNode.attachChild(n); <line14> } <line15> } <line16> "	"<line3>      log.warn(""addGrid {} already exists"");"	task4	
"public class A { <line0> private void processAttributes( <line1> Iterator<Attribute> att, <line2> QName currentNode, <line3> Stack<Object> sbmlElements, <line4> ReadingParser parser, <line5> boolean hasAttributes, <line6> boolean isInsideAnnotation) { <line7> ReadingParser attributeParser = null; <line8> while (att.hasNext()) { <line9> Attribute attribute = att.next(); <line10> boolean isLastAttribute = !att.hasNext(); <line11> QName attributeName = attribute.getName(); <line12> if (attribute.getName().getNamespaceURI().length() > 0) { <line13> String attributeNamespaceURI = attribute.getName().getNamespaceURI(); <line14> if (isInsideAnnotation) { <line15> attributeParser = initializedParsers.get(""anyXML""); <line16> } else { <line17> attributeParser = initializedParsers.get(attributeNamespaceURI); <line18> } <line19> } else { <line20> attributeParser = parser; <line21> } <line22> if (attributeParser != null) { <line23> boolean isAttributeRead = <line24> attributeParser.processAttribute( <line25> currentNode.getLocalPart(), <line26> attributeName.getLocalPart(), <line27> attribute.getValue(), <line28> attributeName.getNamespaceURI(), <line29> attributeName.getPrefix(), <line30> isLastAttribute, <line31> sbmlElements.peek()); <line32> if (!isAttributeRead) { <line33> AbstractReaderWriter.processUnknownAttribute( <line34> attributeName.getLocalPart(), <line35> attributeName.getNamespaceURI(), <line36> attribute.getValue(), <line37> attributeName.getPrefix(), <line38> sbmlElements.peek()); <line39> } <line40> } else { <line41> } <line42> } <line43> } <line44> } <line45> "	"<line41>        logger.warn(""Cannot find a parser for the "" + attribute.getName().getNamespaceURI() + "" namespace"");"	task4	
public class A { <line0> @Override <line1> public boolean doesExist(String string) throws FtpException { <line2> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line3> boolean exists = (getStructrUser(string) != null); <line4> tx.success(); <line5> return exists; <line6> } catch (FrameworkException fex) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	"<line7>      logger.error(""Unable to determine if user "" + string + "" exists"", fex);"	task4	
"public class A { <line0> public static java.util.List<com.liferay.wiki.model.WikiNode> getNodes( <line1> HttpPrincipal httpPrincipal, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(WikiNodeServiceUtil.class, ""getNodes"", _getNodesParameterTypes5); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (java.util.List<com.liferay.wiki.model.WikiNode>) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
public class A { <line0> private void clearResourceDefinitions() { <line1> resourceDefinitionRepository.deleteAll(); <line2> } <line3> } <line4> 	"<line1>    log.debug(""Clearing resource definitions"");"	task4	
public class A { <line0> public void removeHttpSession(String scoutSessionId, String httpSessionId) { <line1> final ServerSessionEntry removedEntry = <line2> m_lockBySessionId.remove(scoutSessionId, entry -> removeEntry(entry, httpSessionId)); <line3> if (removedEntry != null) { <line4> removedEntry.destroy(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOG.debug(""Removed Scout server session from cache [scoutSessionId={}, httpSessionId={}]."",scoutSessionId,httpSessionId);"	task4	
public class A { <line0> private void fixVfGroup( <line1> Resource resource, Map<String, ArtifactDefinition> artifactsMap, GroupDefinition group) { <line2> Set<String> groupArtifactsSet = new HashSet<>(group.getArtifacts()); <line3> List<String> groupArtifacts = new ArrayList<>(groupArtifactsSet); <line4> group.getArtifacts().clear(); <line5> group.getArtifactsUuid().clear(); <line6> for (String artifactId : groupArtifacts) { <line7> fixArtifactUnderGroup(artifactsMap, group, groupArtifacts, artifactId); <line8> } <line9> } <line10> } <line11> 	"<line2>    log.debug(""Migration1707ArtifactUuidFix  fix group:  resource id {}, group name {} "",resource.getUniqueId(),group.getName());"	task4	
public class A { <line0> @Override <line1> @DeadlockAutoRestart <line2> public void eoCleanup(Class VOClazz) { <line3> EntityInfo info = getEntityInfo(VOClazz); <line4> if (!info.hasEO()) { <line5> return; <line6> } <line7> _eoCleanup(VOClazz); <line8> } <line9> } <line10> 	"<line5>      logger.warn(String.format(""Class[%s] doesn't has EO."", VOClazz));"	task4	
public class A { <line0> @Override <line1> public void serviceStop() throws Exception { <line2> if (rpcServer != null) { <line3> this.rpcServer.shutdown(); <line4> } <line5> if (store != null) { <line6> store.close(); <line7> } <line8> super.serviceStop(); <line9> } <line10> } <line11> 	"<line2>    LOG.info(""Catalog Server ("" + bindAddress + "") shutdown"");"	task4	
public class A { <line0> @Override <line1> public NewSplitsAndState<T> call() throws Exception { <line2> List<Tuple2<Partition, T>> partitions = <line3> fetcher.fetchPartitions(fetcherContext, currentReadOffset); <line4> if (partitions.isEmpty()) { <line5> return new NewSplitsAndState<>( <line6> Collections.emptyList(), currentReadOffset, seenPartitionsSinceOffset); <line7> } <line8> partitions.sort(Comparator.comparing(o -> o.f1)); <line9> List<HiveSourceSplit> newSplits = new ArrayList<>(); <line10> T maxOffset = currentReadOffset; <line11> Set<List<String>> nextSeen = new HashSet<>(); <line12> for (Tuple2<Partition, T> tuple2 : partitions) { <line13> Partition partition = tuple2.f0; <line14> List<String> partSpec = partition.getValues(); <line15> if (seenPartitionsSinceOffset.add(partSpec)) { <line16> T offset = tuple2.f1; <line17> if (offset.compareTo(currentReadOffset) >= 0) { <line18> nextSeen.add(partSpec); <line19> } <line20> if (offset.compareTo(maxOffset) >= 0) { <line21> maxOffset = offset; <line22> } <line23> newSplits.addAll( <line24> HiveSourceFileEnumerator.createInputSplits( <line25> 0, <line26> Collections.singletonList(fetcherContext.toHiveTablePartition(partition)), <line27> jobConf)); <line28> } <line29> } <line30> currentReadOffset = maxOffset; <line31> if (!nextSeen.isEmpty()) { <line32> seenPartitionsSinceOffset.clear(); <line33> seenPartitionsSinceOffset.addAll(nextSeen); <line34> } <line35> return new NewSplitsAndState<>(newSplits, currentReadOffset, seenPartitionsSinceOffset); <line36> } <line37> } <line38> 	"<line23>        LOG.info(""Found new partition {} of table {}, generating splits for it"",partSpec,tablePath.getFullName());"	task4	
public class A { <line0> private ByteBuffer recommendProtocolVersion() { <line1> final ByteBuffer buffer = ByteBuffer.allocate(1); <line2> buffer.put((byte) protocolVersion); <line3> buffer.rewind(); <line4> readTimeout = System.currentTimeMillis() + timeoutMillis; <line5> phase = TransactionPhase.RECEIVE_PROTOCOL_VERSION_ACKNOWLEDGMENT; <line6> return buffer; <line7> } <line8> } <line9> 	"<line1>    logger.debug(""Recommending to Peer {} that Protocol Version {} be used"",peerDescription,protocolVersion);"	task4	
public class A { <line0> @Override <line1> protected InputStream decorate(final InputStream in, final MessageDigest digest) <line2> throws IOException { <line3> if (null == digest) { <line4> return super.decorate(in, null); <line5> } else { <line6> return new DigestInputStream(super.decorate(in, digest), digest); <line7> } <line8> } <line9> } <line10> 	"<line4>      log.warn(""MD5 calculation disabled"");"	task4	
"public class A { <line0> private static void createExperimentEntities() { <line1> ExperimentTest experimentTest = new ExperimentTest(); <line2> CreateExperiment createExperimentRequest = <line3> experimentTest.getCreateExperimentRequest(project.getId(), ""Experiment_1""); <line4> CreateExperiment.Response createExperimentResponse = <line5> experimentServiceStub.createExperiment(createExperimentRequest); <line6> experiment = createExperimentResponse.getExperiment(); <line7> assertEquals( <line8> ""Experiment name not match with expected Experiment name"", <line9> createExperimentRequest.getName(), <line10> experiment.getName()); <line11> } <line12> } <line13> "	"<line7>    LOGGER.info(""Experiment created successfully"");"	task4	
public class A { <line0> private static VoltageLevel createVoltageLevel( <line1> MBus mBus, <line2> String voltageLevelId, <line3> Substation substation, <line4> Network network, <line5> PerUnitContext perUnitContext) { <line6> double nominalV = <line7> perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage(); <line8> VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId); <line9> if (voltageLevel == null) { <line10> voltageLevel = <line11> substation <line12> .newVoltageLevel() <line13> .setId(voltageLevelId) <line14> .setNominalV(nominalV) <line15> .setTopologyKind(TopologyKind.BUS_BREAKER) <line16> .add(); <line17> } <line18> return voltageLevel; <line19> } <line20> } <line21> 	"<line17>      LOGGER.debug(""Created voltagelevel {}"", voltageLevel.getId());"	task4	
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> ResponseList<Status> statuses = twitter.getFavorites(screenName); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.gotFavorites(statuses); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.warn(""Exception at getFavorites"", e);"	task4	
public class A { <line0> @Override <line1> public synchronized void dispose() { <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> this.terminationRequest = true; <line5> this.notify(); <line6> } <line7> } <line8> 	"<line3>      LOGGER.info(""dispose: "" + this.getId());"	task4	
"public class A { <line0> private RestResponse<ObjectMap> getAcl() throws CatalogException, ClientException { <line1> StudyCommandOptions.AclsCommandOptions c = studiesCommandOptions.aclsCommandOptions; <line2> ObjectMap params = new ObjectMap(); <line3> params.putIfNotEmpty(""member"", c.memberId); <line4> return openCGAClient.getStudyClient().acl(getSingleValidStudy(c.study), params); <line5> } <line6> } <line7> "	"<line1>    logger.debug(""Get Acl"");"	task4	
"public class A { <line0> @PayloadRoot( <line1> localPart = ""FindDevicesWhichHaveNoOwnerRequest"", <line2> namespace = DEVICE_MANAGEMENT_NAMESPACE) <line3> @ResponsePayload <line4> public FindDevicesWhichHaveNoOwnerResponse findDevicesWhichHaveNoOwner( <line5> @OrganisationIdentification final String organisationIdentification, <line6> @RequestPayload final FindDevicesWhichHaveNoOwnerRequest request) <line7> throws OsgpException { <line8> final FindDevicesWhichHaveNoOwnerResponse response = new FindDevicesWhichHaveNoOwnerResponse(); <line9> try { <line10> final List<org.opensmartgridplatform.domain.core.entities.Device> devicesWithoutOwner = <line11> this.deviceManagementService.findDevicesWhichHaveNoOwner(organisationIdentification); <line12> response <line13> .getDevices() <line14> .addAll( <line15> this.deviceManagementMapper.mapAsList( <line16> devicesWithoutOwner, <line17> org.opensmartgridplatform.adapter.ws.schema.admin.devicemanagement.Device.class)); <line18> } catch (final ConstraintViolationException e) { <line19> throw new FunctionalException( <line20> FunctionalExceptionType.VALIDATION_ERROR, <line21> COMPONENT_TYPE_WS_ADMIN, <line22> new ValidationException(e.getConstraintViolations())); <line23> } catch (final Exception e) { <line24> this.handleException(e); <line25> } <line26> return response; <line27> } <line28> } <line29> "	"<line8>    LOGGER.info(""Finding devices which have no owner for organisation: {}."", organisationIdentification);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> monitorHeartbeats(); <line4> } catch (final Exception e) { <line5> clusterCoordinator.reportEvent( <line6> null, Severity.ERROR, ""Failed to process heartbeats from nodes due to "" + e.toString()); <line7> } <line8> } <line9> } <line10> "	"<line7>      logger.error(""Failed to process heartbeats"", e);"	task4	
"public class A { <line0> @Test <line1> public void testLiveIsolated() throws Exception { <line2> backupServer.stop(); <line3> FakeServiceComponent component = new FakeServiceComponent(""Component for "" + getName()); <line4> liveServer.getServer().addExternalComponent(component, true); <line5> liveServer <line6> .getServer() <line7> .getConfiguration() <line8> .setNetworkCheckList(badAddress) <line9> .setNetworkCheckPeriod(100) <line10> .setNetworkCheckTimeout(100); <line11> ((ActiveMQServerImpl) liveServer.getServer()).reloadNetworkHealthCheck(); <line12> try { <line13> Assert.assertEquals(100L, liveServer.getServer().getNetworkHealthCheck().getPeriod()); <line14> liveServer.getServer().getNetworkHealthCheck().setTimeUnit(TimeUnit.MILLISECONDS); <line15> Assert.assertFalse(liveServer.getServer().getNetworkHealthCheck().check()); <line16> Wait.assertFalse(liveServer::isStarted); <line17> liveServer <line18> .getServer() <line19> .getNetworkHealthCheck() <line20> .setIgnoreLoopback(true) <line21> .addAddress(""127.0.0.1""); <line22> Wait.assertTrue(liveServer::isStarted); <line23> Assert.assertTrue(component.isStarted()); <line24> } catch (Throwable e) { <line25> throw e; <line26> } finally { <line27> liveServer.getServer().stop(); <line28> backupServer.getServer().stop(); <line29> } <line30> } <line31> } <line32> "	<line25>      logger.warn(e.getMessage(), e);	task4	
"public class A { <line0> ErrorCodedDataAccessException translateUniqueKeyViolation( <line1> Throwable sourceThrowable, PSQLException pSqlException) { <line2> ServerErrorMessage serverErrorMessage = pSqlException.getServerErrorMessage(); <line3> String tableName = serverErrorMessage.getTable(); <line4> String detailMessage = serverErrorMessage.getDetail(); <line5> Matcher matcher = <line6> Pattern.compile(""Key \\(\""?(.*?)\""?\\)=\\((.*?)\\) already exists."").matcher(detailMessage); <line7> boolean matches = matcher.matches(); <line8> if (matches) { <line9> String[] columnNames = matcher.group(1).split("", ""); <line10> if (columnNames.length == 1) { <line11> String columnName = columnNames[0]; <line12> String value = matcher.group(2); <line13> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line14> String attributeName = tryGetAttributeName(tableName, columnName).orElse(null); <line15> return new ValueAlreadyExistsException(entityTypeId, attributeName, value, sourceThrowable); <line16> } else { <line17> String columnName = columnNames[columnNames.length - 1]; <line18> String[] values = matcher.group(2).split("", ""); <line19> String entityId = values[0]; <line20> String value = values[1]; <line21> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line22> String attributeName = tryGetAttributeName(tableName, columnName).orElse(null); <line23> return new ListValueAlreadyExistsException( <line24> entityTypeId, attributeName, entityId, value, sourceThrowable); <line25> } <line26> } else { <line27> matcher = <line28> Pattern.compile(""Key \\(\""?(.*?)\""?\\)=\\((.*?)\\) is duplicated."") <line29> .matcher(detailMessage); <line30> matches = matcher.matches(); <line31> if (matches) { <line32> String columnName = matcher.group(1); <line33> String value = matcher.group(2); <line34> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line35> String attributeName = tryGetAttributeName(tableName, columnName).orElse(null); <line36> return new DuplicateValueException(entityTypeId, attributeName, value, sourceThrowable); <line37> } else { <line38> throw new RuntimeException(ERROR_TRANSLATING_EXCEPTION_MSG, pSqlException); <line39> } <line40> } <line41> } <line42> } <line43> "	<line38>        LOG.error(ERROR_TRANSLATING_POSTGRES_EXC_MSG, pSqlException);	task4	
public class A { <line0> @Override <line1> public void update(EDBObject obj) throws EDBException { <line2> if (!updates.contains(obj)) { <line3> updates.add(EDBUtils.convertEDBObjectToJPAObject(obj)); <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.debug(""Added object {} to the commit for updating"", obj.getOID());"	task4	
public class A { <line0> private List<Cloud> getCloudsByCloudRequestDTOs(final List<CloudRequestDTO> cloudDTOs) { <line1> final List<Cloud> clouds = new ArrayList<>(); <line2> for (final CloudRequestDTO dto : cloudDTOs) { <line3> final Cloud cloud = <line4> gatekeeperDBService.getCloudByOperatorAndName(dto.getOperator(), dto.getName()); <line5> clouds.add(cloud); <line6> } <line7> return clouds; <line8> } <line9> } <line10> 	"<line1>    logger.debug(""getCloudsByCloudRequestDTOs started..."");"	task4	
public class A { <line0> @Override <line1> public boolean performFinish() { <line2> try { <line3> itNetworkPage.setMessage(Messages.ItNetworkConverterWizard_PageTitle, DialogPage.INFORMATION); <line4> runConvertingInWizard(); <line5> CnAElementFactory.getInstance().reloadBpModelFromDatabase(); <line6> } catch (InvocationTargetException | InterruptedException e) { <line7> itNetworkPage.setMessage( <line8> Messages.ItNetworkConverterWizard_ErrorInformation, DialogPage.ERROR); <line9> return false; <line10> } <line11> return true; <line12> } <line13> } <line14> 	"<line7>      log.error(""InvocationTargetException or InterruptedException during conversion"", e);"	task4	
"public class A { <line0> @Override <line1> public void registerDriver(String name, String clazz, Map<String, String> config) { <line2> try { <line3> Class.forName(clazz); <line4> providers.put(name, new DriverInfo(clazz, config)); <line5> } catch (ClassNotFoundException e) { <line6> throw new IllegalArgumentException(""Cannot register ASR driver "" + clazz, e); <line7> } <line8> } <line9> } <line10> "	"<line6>      logger.error(""Failed to instantiate asr driver (className = "" + clazz + "")"", e);"	task4	
public class A { <line0> public void onError(final Throwable t) { <line1> } <line2> } <line3> 	"<line1>    LOG.error(""TestReadListener error"", t);"	task4	
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> SavedSearch savedSearch = twitter.createSavedSearch(query); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.createdSavedSearch(savedSearch); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.warn(""Exception at createSavedSearch"", e);"	task4	
public class A { <line0> public List<String> close() throws SAXException, RepositoryException { <line1> if (states.peek() != State.INITIAL) { <line2> } <line3> List<String> paths = new ArrayList<>(); <line4> importPolicy.apply(paths); <line5> return paths; <line6> } <line7> } <line8> 	"<line2>      log.error(""Unexpected end state: {}"", states.peek());"	task4	
"public class A { <line0> private void addWithGroovyClassLoader(int x, int y) <line1> throws IllegalAccessException, InstantiationException, IOException { <line2> Class calcClass = <line3> loader.parseClass(new File(""src/main/groovy/com/baeldung/"", ""CalcMath.groovy"")); <line4> GroovyObject calc = (GroovyObject) calcClass.newInstance(); <line5> Object result = calc.invokeMethod(""calcSum"", new Object[] {x + 14, y + 14}); <line6> } <line7> } <line8> "	"<line6>    LOG.info(""Result of CalcMath.calcSum() method is {}"", result);"	task4	
"public class A { <line0> @Override <line1> public Map<String, Object> getLogsByGroupId(Integer groupId, Integer pageNo, Integer pageSize) { <line2> try { <line3> Map<String, Object> returnMap = new HashMap<>(); <line4> Page<OperationLog> page = PageHelper.startPage(pageNo, pageSize); <line5> operationLogDao.selectLogsByOperationGroupId(groupId); <line6> returnMap.put(""logData"", page); <line7> returnMap.put(""totalCount"", page.getTotal()); <line8> returnMap.put(""totalPage"", page.getPages()); <line9> return returnMap; <line10> } catch (Exception e) { <line11> return null; <line12> } <line13> } <line14> } <line15> "	"<line11>      logger.error(""query logs from db error"", e);"	task4	
"public class A { <line0> private void moveConfirmationConfiguration() { <line1> Map<String, EmailConfirmationConfiguration> attrsConfig = new HashMap<>(); <line2> Map<String, EmailConfirmationConfiguration> idsConfig = new HashMap<>(); <line3> List<GenericObjectBean> conConfs = <line4> genericObjectsDAO.getObjectsOfType(""confirmationConfiguration""); <line5> for (GenericObjectBean confirmationConfig : conConfs) { <line6> ObjectNode objContent = JsonUtil.parse(confirmationConfig.getContents()); <line7> EmailConfirmationConfiguration emailConfig = new EmailConfirmationConfiguration(); <line8> emailConfig.setMessageTemplate(objContent.get(""msgTemplate"").asText()); <line9> if (objContent.get(""validityTime"") != null) <line10> emailConfig.setValidityTime(objContent.get(""validityTime"").asInt()); <line11> if (objContent.get(""typeToConfirm"").asText().equals(""attribute"")) { <line12> attrsConfig.put(objContent.get(""nameToConfirm"").asText(), emailConfig); <line13> } else if (objContent.get(""typeToConfirm"").asText().equals(""identity"")) { <line14> idsConfig.put(objContent.get(""nameToConfirm"").asText(), emailConfig); <line15> } <line16> } <line17> updateAttributeTypes(attrsConfig); <line18> updateIdentityTypes(idsConfig); <line19> genericObjectsDAO.removeObjectsByType(""confirmationConfiguration""); <line20> } <line21> } <line22> "	"<line19>    log.info(""Removing all confirmationConfiguration objects"");"	task4	
"public class A { <line0> private FunctionInvocationWrapper functionFromExpression(String routingExpression, Object input) { <line1> Expression expression = spelParser.parseExpression(routingExpression); <line2> String functionName = expression.getValue(this.evalContext, input, String.class); <line3> Assert.hasText( <line4> functionName, <line5> ""Failed to resolve function name based on routing expression '"" <line6> + functionProperties.getRoutingExpression() <line7> + ""'""); <line8> FunctionInvocationWrapper function = functionCatalog.lookup(functionName); <line9> Assert.notNull( <line10> function, <line11> ""Failed to lookup function to route to based on the expression '"" <line12> + functionProperties.getRoutingExpression() <line13> + ""' whcih resolved to '"" <line14> + functionName <line15> + ""' function name.""); <line16> if (logger.isInfoEnabled()) { <line17> } <line18> return function; <line19> } <line20> } <line21> "	"<line17>      logger.info(""Resolved function from provided [routing-expression]  "" + routingExpression);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public ComprehensionTestQuestionBo getComprehensionTestQuestionById(Integer questionId) { <line3> logger.entry(""begin getComprehensionTestQuestionById()""); <line4> ComprehensionTestQuestionBo comprehensionTestQuestionBo = null; <line5> Session session = null; <line6> List<ComprehensionTestResponseBo> comprehensionTestResponsList = null; <line7> try { <line8> session = hibernateTemplate.getSessionFactory().openSession(); <line9> comprehensionTestQuestionBo = <line10> (ComprehensionTestQuestionBo) session.get(ComprehensionTestQuestionBo.class, questionId); <line11> if (null != comprehensionTestQuestionBo) { <line12> String searchQuery = <line13> ""From ComprehensionTestResponseBo CRBO where CRBO.comprehensionTestQuestionId=:id""; <line14> query = session.createQuery(searchQuery); <line15> query.setInteger(""id"", comprehensionTestQuestionBo.getId()); <line16> comprehensionTestResponsList = query.list(); <line17> comprehensionTestQuestionBo.setResponseList(comprehensionTestResponsList); <line18> } <line19> } catch (Exception e) { <line20> } finally { <line21> if ((null != session) && session.isOpen()) { <line22> session.close(); <line23> } <line24> } <line25> logger.exit(""getComprehensionTestQuestionById() - Ends""); <line26> return comprehensionTestQuestionBo; <line27> } <line28> } <line29> "	"<line20>      logger.error(""StudyDAOImpl - getComprehensionTestQuestionById() - Error"", e);"	task4	
public class A { <line0> protected void onNodeDeletePost( <line1> final String networkId, final Node node, final HashMap<String, Response> respList) { <line2> } <line3> } <line4> 	"<line2>    log.debug("""");"	task4	
public class A { <line0> @Override <line1> public KaleoTransition findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchTransitionException { <line3> KaleoTransition kaleoTransition = fetchByPrimaryKey(primaryKey); <line4> if (kaleoTransition == null) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchTransitionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return kaleoTransition; <line10> } <line11> } <line12> 	<line6>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @Override <line1> public STypeIR caseAUnresolvedType(AUnresolvedType node, IRInfo question) <line2> throws AnalysisException { <line3> return new AUnknownTypeIR(); <line4> } <line5> } <line6> 	"<line3>    log.error(""Found unresolved type in the VDM AST"");"	task4	
public class A { <line0> @Override <line1> public String returnAvatarStream() { <line2> AvatarConfig config = this.getAvatarManager().getConfig(); <line3> String stype = config.getStyle(); <line4> if (null == stype || AvatarConfig.STYLE_DEFAULT.equals(stype)) { <line5> return super.returnAvatarStream(); <line6> } else if (AvatarConfig.STYLE_GRAVATAR.equals(stype)) { <line7> return super.extractGravatar(); <line8> } <line9> try { <line10> String url = this.getAvatarManager().getAvatarUrl(this.getUsername()); <line11> if (null == url) { <line12> return this.extractDefaultAvatarStream(); <line13> } <line14> MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap(); <line15> this.setMimeType(mimeTypesMap.getContentType(url)); <line16> File avatar = this.getAvatarManager().getAvatarResource(this.getUsername()); <line17> if (null == avatar) { <line18> return this.extractDefaultAvatarStream(); <line19> } <line20> this.setInputStream(new FileInputStream(avatar)); <line21> } catch (Throwable t) { <line22> return this.extractDefaultAvatarStream(); <line23> } <line24> return SUCCESS; <line25> } <line26> } <line27> 	"<line22>      logger.info(""local avatar not available"", t);"	task4	
public class A { <line0> private void validateFailInConfigWithExplicitTotalFlinkAndManagedMem( <line1> final Configuration customConfig) { <line2> final Configuration config = configWithExplicitTotalFlinkAndManagedMem(); <line3> config.addAll(customConfig); <line4> validateFail(config); <line5> } <line6> } <line7> 	"<line2>    log.info(""Validating failing in configuration with explicit total flink and managed memory size."");"	task4	
public class A { <line0> private void waitForFinish(Paragraph p) { <line1> while (p.getStatus() != Status.FINISHED <line2> && p.getStatus() != Status.ERROR <line3> && p.getStatus() != Status.ABORT) { <line4> try { <line5> Thread.sleep(100); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        LOG.error(""Exception in WebDriverManager while getWebDriver "", e);"	task4	
public class A { <line0> private String getDataTagsConfigXML(final EquipmentCacheObject pEquipment) { <line1> StringBuilder str = new StringBuilder(); <line2> ThreadPoolExecutor tagXmlExecutor = <line3> new ThreadPoolExecutor( <line4> 8, <line5> 10, <line6> 5, <line7> TimeUnit.SECONDS, <line8> new LinkedBlockingQueue<>(10000), <line9> new ThreadPoolExecutor.CallerRunsPolicy()); <line10> Collection<Long> dataTags = equipmentFacade.getDataTagIds(pEquipment.getId()); <line11> for (Long subEquipmentId : pEquipment.getSubEquipmentIds()) { <line12> dataTags.addAll(subEquipmentFacade.getDataTagIds(subEquipmentId)); <line13> } <line14> if (dataTags != null) { <line15> LinkedList<Future<String>> futureXmlStrings = new LinkedList<>(); <line16> LinkedList<Long> partialList = new LinkedList<>(); <line17> Iterator<Long> it = dataTags.iterator(); <line18> while (it.hasNext()) { <line19> while (partialList.size() < 100 && it.hasNext()) { <line20> partialList.addLast(it.next()); <line21> } <line22> Callable<String> tagTask = new GetTagXmlTask((LinkedList<Long>) partialList.clone()); <line23> partialList.clear(); <line24> futureXmlStrings.addFirst(tagXmlExecutor.submit(tagTask)); <line25> } <line26> tagXmlExecutor.shutdown(); <line27> try { <line28> tagXmlExecutor.awaitTermination(120, TimeUnit.SECONDS); <line29> while (!futureXmlStrings.isEmpty()) { <line30> str.append(futureXmlStrings.pollFirst().get()); <line31> } <line32> } catch (InterruptedException | ExecutionException e) { <line33> } <line34> } <line35> str.append(appendAliveTagDaqXmlConfiguration(pEquipment.getAliveTagId())); <line36> for (Long subEquipmentId : pEquipment.getSubEquipmentIds()) { <line37> str.append( <line38> appendAliveTagDaqXmlConfiguration(subEquipmentCache.get(subEquipmentId).getAliveTagId())); <line39> } <line40> return str.toString(); <line41> } <line42> } <line43> 	"<line33>        log.error(""Interrupted while waiting for XML tag threads to terminate - no datatags were added!"");"	task4	
public class A { <line0> private void migrate(List<Event> events) <line1> throws EventStreamException, InterruptedException, ExecutionException { <line2> List<Event> eventsToSave = getEventsToSave(events); <line3> CompletableFuture<?> future = null; <line4> for (Iterator<Event> it = eventsToSave.iterator(); it.hasNext(); ) { <line5> future = migrate(it.next()); <line6> } <line7> if (future != null) { <line8> future.get(); <line9> } <line10> if (getRequest().isVerbose()) { <line11> } <line12> } <line13> } <line14> 	"<line11>      this.logger.info(""{} events were saved in the new store because they did not already exist"",eventsToSave.size());"	task4	
public class A { <line0> private void flushAndClear() { <line1> if (em != null) { <line2> em.flush(); <line3> em.clear(); <line4> } <line5> if (em != null && useTransaction) { <line6> em.getTransaction().commit(); <line7> } <line8> } <line9> } <line10> 	"<line6>      log.debug(""committing in TestTransactionUtil"");"	task4	
public class A { <line0> private void refresh() { <line1> List<Thing> things = <line2> getThing().getThings().stream() <line3> .filter(thing -> thing.getHandler() instanceof NikobusModuleHandler) <line4> .collect(Collectors.toList()); <line5> if (!commandListeners.isEmpty()) { <line6> NikobusConnection connection = this.connection; <line7> if (connection == null) { <line8> return; <line9> } <line10> try { <line11> connectIfNeeded(connection); <line12> } catch (IOException e) { <line13> connection.close(); <line14> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line15> return; <line16> } <line17> } <line18> if (things.isEmpty()) { <line19> return; <line20> } <line21> refreshThingIndex = (refreshThingIndex + 1) % things.size(); <line22> ThingHandler thingHandler = things.get(refreshThingIndex).getHandler(); <line23> if (thingHandler == null) { <line24> return; <line25> } <line26> NikobusModuleHandler handler = (NikobusModuleHandler) thingHandler; <line27> handler.refreshModule(); <line28> } <line29> } <line30> 	"<line19>      logger.debug(""Nothing to refresh"");"	task4	
public class A { <line0> private int logRunningTime( <line1> String operationName, SupplierWithException<Integer, IOException> supplier) <line2> throws IOException { <line3> long startTimeMillis = System.currentTimeMillis(); <line4> int result = supplier.get(); <line5> return result; <line6> } <line7> } <line8> 	"<line5>    LOG.info(""Hive source({}}) {} use time: {} ms, result: {}"",tablePath,operationName,System.currentTimeMillis() - startTimeMillis,result);"	task4	
"public class A { <line0> public List<InsightsWorkflowExecutionHistory> getWorkflowExecutionHistoryRecordsByWorkflowId( <line1> String workflowId) { <line2> try { <line3> Map<String, Object> parameters = new HashMap<>(); <line4> Map<String, Object> extraParameters = new HashMap<>(); <line5> parameters.put(AssessmentReportAndWorkflowConstants.WORKFLOW_ID, workflowId); <line6> extraParameters.put(""MaxResults"", 5); <line7> List<Long> executionIds = <line8> executeQueryWithExtraParameter( <line9> ""select distinct executionId FROM InsightsWorkflowExecutionHistory EH WHERE"" <line10> + "" EH.workflowConfig.workflowId = :workflowId ORDER BY executionId DESC"", <line11> Long.class, <line12> parameters, <line13> extraParameters); <line14> parameters.clear(); <line15> extraParameters.clear(); <line16> extraParameters.put(""executionIDs"", executionIds); <line17> return executeQueryWithExtraParameter( <line18> ""FROM InsightsWorkflowExecutionHistory EH WHERE EH.executionId IN (:executionIDs) ORDER"" <line19> + "" BY executionId DESC"", <line20> InsightsWorkflowExecutionHistory.class, <line21> parameters, <line22> extraParameters); <line23> } catch (Exception e) { <line24> throw e; <line25> } <line26> } <line27> } <line28> "	<line24>      log.error(e);	task4	
public class A { <line0> private List<File> searchCasesinFolder(File folder) { <line1> ArrayList<File> files = new ArrayList<File>(); <line2> File[] subFiles = folder.listFiles(); <line3> if (subFiles != null) <line4> for (File file : subFiles) { <line5> if (file.isDirectory()) { <line6> if (new File(file, MODULE_DIR).exists()) files.add(file); <line7> else files.addAll(searchCasesinFolder(file)); <line8> } <line9> } <line10> return files; <line11> } <line12> } <line13> 	"<line1>    LOGGER.info(""Searching cases in "" + folder.getPath());"	task4	
"public class A { <line0> public void log(UserData o) { <line1> Node n = o.getNode(); <line2> StringBuilder sb = new StringBuilder(); <line3> sb.append(n.getParent()); <line4> sb.append("" parent->""); <line5> sb.append(""(""); <line6> sb.append(n); <line7> sb.append("")->""); <line8> List<Spatial> children = n.getChildren(); <line9> for (int i = 0; i < children.size(); ++i) { <line10> sb.append(n.getChild(i)); <line11> if (i != children.size() - 1) { <line12> sb.append("",""); <line13> } <line14> } <line15> } <line16> } <line17> "	<line15>    log.info(sb.toString());	task4	
"public class A { <line0> @Override <line1> public void upgrade() { <line2> if (clusterConfigService.get(DefaultIndexSetCreated.class) != null) { <line3> return; <line4> } <line5> final IndexManagementConfig indexManagementConfig = <line6> clusterConfigService.get(IndexManagementConfig.class); <line7> checkState(indexManagementConfig != null, ""Couldn't find index management configuration""); <line8> final IndexSetConfig config = <line9> IndexSetConfig.builder() <line10> .title(""Default index set"") <line11> .description(""The Graylog default index set"") <line12> .indexPrefix(elasticsearchConfiguration.getIndexPrefix()) <line13> .shards(elasticsearchConfiguration.getShards()) <line14> .replicas(elasticsearchConfiguration.getReplicas()) <line15> .rotationStrategy(getRotationStrategyConfig(indexManagementConfig)) <line16> .retentionStrategy(getRetentionStrategyConfig(indexManagementConfig)) <line17> .creationDate(ZonedDateTime.now(ZoneOffset.UTC)) <line18> .indexAnalyzer(elasticsearchConfiguration.getAnalyzer()) <line19> .indexTemplateName(elasticsearchConfiguration.getTemplateName()) <line20> .indexOptimizationMaxNumSegments( <line21> elasticsearchConfiguration.getIndexOptimizationMaxNumSegments()) <line22> .indexOptimizationDisabled(elasticsearchConfiguration.isDisableIndexOptimization()) <line23> .build(); <line24> final IndexSetConfig savedConfig = indexSetService.save(config); <line25> clusterConfigService.write(DefaultIndexSetConfig.create(savedConfig.id())); <line26> clusterConfigService.write(DefaultIndexSetCreated.create()); <line27> } <line28> } <line29> "	"<line27>    LOG.debug(""Successfully created default index set: {}"", savedConfig);"	task4	
"public class A { <line0> public static void main(String[] args) { <line1> monkeyPatchBeansBinding(); <line2> for (String s : args) { <line3> if (s.equals(""--version"")) { <line4> System.out.println(getVersion()); <line5> System.exit(0); <line6> } <line7> } <line8> System.setProperty(""apple.laf.useScreenMenuBar"", ""true""); <line9> try { <line10> UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); <line11> } catch (Exception e) { <line12> throw new Error(e); <line13> } <line14> File configurationDirectory = new File(System.getProperty(""user.home"")); <line15> configurationDirectory = new File(configurationDirectory, "".openpnp2""); <line16> if (System.getProperty(""configDir"") != null) { <line17> configurationDirectory = new File(System.getProperty(""configDir"")); <line18> } <line19> configurationDirectory.mkdirs(); <line20> configureLogging(configurationDirectory); <line21> Configuration.initialize(configurationDirectory); <line22> final Configuration configuration = Configuration.get(); <line23> Locale.setDefault(Configuration.get().getLocale()); <line24> ThemeInfo theme = configuration.getThemeInfo(); <line25> new ThemeSettingsPanel().setTheme(theme, configuration.getFontSize()); <line26> ThemeDialog.getInstance().setOldTheme(theme); <line27> EventQueue.invokeLater( <line28> new Runnable() { <line29> public void run() { <line30> try { <line31> MainFrame frame = new MainFrame(configuration); <line32> frame.setVisible(true); <line33> configuration.getScripting().on(""Startup"", null); <line34> } catch (Exception e) { <line35> e.printStackTrace(); <line36> } <line37> } <line38> }); <line39> } <line40> } <line41> "	"<line33>              Logger.info(String.format(""Bienvenue, Bienvenido, Willkommen, Hello, Namaskar, Welkom, Bonjour to""+ "" OpenPnP version %s."",Main.getVersion()));"	task4	
public class A { <line0> private List<Certificate[]> getKeystoreCertificatesChains(KeyStore keystore) { <line1> List<Certificate[]> keystoreCertificateChains = new ArrayList<>(); <line2> try { <line3> Enumeration<String> aliases = keystore.aliases(); <line4> while (aliases.hasMoreElements()) { <line5> String alias = aliases.nextElement(); <line6> Certificate[] certificateChain = keystore.getCertificateChain(alias); <line7> if (certificateChain != null) { <line8> keystoreCertificateChains.add(certificateChain); <line9> } else { <line10> Certificate certificate = keystore.getCertificate(alias); <line11> keystoreCertificateChains.add(new Certificate[] {certificate}); <line12> } <line13> } <line14> } catch (KeyStoreException e) { <line15> } <line16> return keystoreCertificateChains; <line17> } <line18> } <line19> 	<line15>      LOGGER.warn(String.format(GENERIC_INSECURE_DEFAULTS_MSG, keystorePath), e);	task4	
"public class A { <line0> public void configureRequestLog() { <line1> LogConfiguration lc = configuration.logging(); <line2> if (lc.getLogNCSADirectory() == null) { <line3> throw new IllegalArgumentException( <line4> ""Log directory for NCSA logging is not specified. Please set"" <line5> + "" org.ops4j.pax.web.log.ncsa.directory property.""); <line6> } <line7> File logDir = new File(lc.getLogNCSADirectory()); <line8> if (logDir.isFile()) { <line9> throw new IllegalArgumentException( <line10> logDir + "" is not a valid directory to store request logs""); <line11> } <line12> RequestLogWriter writer = new RequestLogWriter(); <line13> writer.setAppend(lc.isLogNCSAAppend()); <line14> if (lc.getLogNCSAFile() != null) { <line15> writer.setFilename(new File(lc.getLogNCSADirectory(), lc.getLogNCSAFile()).getAbsolutePath()); <line16> } else { <line17> writer.setFilename( <line18> new File(lc.getLogNCSADirectory(), ""yyyy_mm_dd.request.log"").getAbsolutePath()); <line19> } <line20> writer.setFilenameDateFormat(lc.getLogNCSAFilenameDateFormat()); <line21> writer.setRetainDays(lc.getLogNCSARetainDays()); <line22> writer.setTimeZone(lc.getLogNCSATimeZone()); <line23> CustomRequestLog requestLog = <line24> new CustomRequestLog( <line25> writer, <line26> lc.isLogNCSAExtended() <line27> ? CustomRequestLog.EXTENDED_NCSA_FORMAT <line28> : CustomRequestLog.EXTENDED_NCSA_FORMAT); <line29> server.setRequestLog(requestLog); <line30> } <line31> } <line32> "	"<line30>    LOG.info(""NCSARequestlogging is using directory {}"", lc.getLogNCSADirectory());"	task4	
"public class A { <line0> @Override <line1> public void terminateAllResources(final long duration, final TimeUnit unit) <line2> throws TimeoutException, CloudProvisioningException { <line3> final long endTime = System.currentTimeMillis() + unit.toMillis(duration); <line4> try { <line5> terminateMachinesByPrefix(cloud.getProvider().getManagementGroup(), endTime); <line6> terminateMachinesByPrefix(cloud.getProvider().getMachineNamePrefix(), endTime); <line7> try { <line8> this.cleanAllSecurityGroups(); <line9> } catch (final Exception e) { <line10> logger.warning( <line11> ""Couldn't clean security groups "" + this.openstackPrefixes.getPrefix() + ""*""); <line12> logger.warning(""Reported error: "" + e.getMessage() + "", stack trace: "" + e.getStackTrace()); <line13> } <line14> try { <line15> this.cleanAllNetworks(); <line16> } catch (final Exception e) { <line17> logger.warning(""Couldn't clean networks "" + this.openstackPrefixes.getPrefix() + ""*""); <line18> logger.warning(""Reported error: "" + e.getMessage() + "", stack trace: "" + e.getStackTrace()); <line19> } <line20> } finally { <line21> if (this.computeApi != null) { <line22> this.computeApi.close(); <line23> } <line24> if (this.networkApi != null) { <line25> this.networkApi.close(); <line26> } <line27> } <line28> } <line29> } <line30> "	"<line3>    logger.info(""Attempting to terminate all cloud resources (timeout set to ""+ duration+ "" ""+ unit+ "")"");"	task4	
"public class A { <line0> protected IEntityManager extractEntityManager(String entityManagerCode) { <line1> IEntityManager entityManager = null; <line2> List<IEntityManager> managers = this.getEntityManagers(); <line3> for (IEntityManager manager : managers) { <line4> if (((IManager) manager).getName().equals(entityManagerCode)) { <line5> entityManager = manager; <line6> break; <line7> } <line8> } <line9> if (null == entityManager) { <line10> throw new ResourceNotFoundException(""entityManagerCode"", entityManagerCode); <line11> } <line12> return entityManager; <line13> } <line14> } <line15> "	"<line10>      logger.warn(""no entity manager found with code {}"", entityManagerCode);"	task4	
public class A { <line0> public synchronized void disconnect() throws IOException { <line1> for (IoSession session : getManagedSessions().values()) { <line2> session.close(true); <line3> } <line4> fireServiceInactivated(); <line5> idleChecker.destroy(); <line6> } <line7> } <line8> 	"<line1>    LOG.info(""Disconnecting sessions"");"	task4	
public class A { <line0> public static <T> T fromJsonStrict(final String jsonString, final TypeReference<T> clazz) { <line1> if (StringUtils.isNotBlank(jsonString)) { <line2> try { <line3> return STRICT_OBJECT_MAPPER.readValue(jsonString, clazz); <line4> } catch (final Exception ex) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	"<line5>        logger.warn(""Exception when de-serializing "" + clazz + "" with "" + jsonString, ex);"	task4	
public class A { <line0> @Override <line1> public void onNext(ResT value) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	"<line3>      logger.debug(""{} onNext:{}"", listener, value);"	task4	
public class A { <line0> private long doSeek(TopicPartition newTp, OffsetAndMetadata committedOffset) { <line1> if (committedOffset != null) { <line2> if (commitMetadataManager.isOffsetCommittedByThisTopology( <line3> newTp, committedOffset, Collections.unmodifiableMap(offsetManagers))) { <line4> consumer.seek(newTp, committedOffset.offset()); <line5> } else { <line6> if (firstPollOffsetStrategy.equals(EARLIEST)) { <line7> consumer.seekToBeginning(Collections.singleton(newTp)); <line8> } else if (firstPollOffsetStrategy.equals(LATEST)) { <line9> consumer.seekToEnd(Collections.singleton(newTp)); <line10> } else { <line11> consumer.seek(newTp, committedOffset.offset()); <line12> } <line13> } <line14> } else { <line15> if (firstPollOffsetStrategy.equals(EARLIEST) <line16> || firstPollOffsetStrategy.equals(UNCOMMITTED_EARLIEST)) { <line17> consumer.seekToBeginning(Collections.singleton(newTp)); <line18> } else if (firstPollOffsetStrategy.equals(LATEST) <line19> || firstPollOffsetStrategy.equals(UNCOMMITTED_LATEST)) { <line20> consumer.seekToEnd(Collections.singleton(newTp)); <line21> } <line22> } <line23> return consumer.position(newTp); <line24> } <line25> } <line26> 	"<line1>    LOG.trace(""Seeking offset for topic-partition [{}] with [{}] and committed offset [{}]"",newTp,firstPollOffsetStrategy,committedOffset);"	task4	
"public class A { <line0> @Override <line1> public String render(RenderRequest renderRequest, RenderResponse renderResponse) <line2> throws PortletException { <line3> try { <line4> CommerceVirtualOrderItemContentDisplayContext commerceVirtualOrderItemContentDisplayContext = <line5> new CommerceVirtualOrderItemContentDisplayContext( <line6> _commerceChannelLocalService, <line7> _commerceVirtualOrderItemLocalService, <line8> _cpDefinitionHelper, <line9> _commerceAccountHelper, <line10> _cpDefinitionVirtualSettingService, <line11> _cpInstanceHelper, <line12> _portal.getHttpServletRequest(renderRequest)); <line13> renderRequest.setAttribute( <line14> WebKeys.PORTLET_DISPLAY_CONTEXT, commerceVirtualOrderItemContentDisplayContext); <line15> } catch (PortalException portalException) { <line16> } <line17> return ""/view_commerce_virtual_order_item_terms_of_use.jsp""; <line18> } <line19> } <line20> "	<line16>      log.error(portalException, portalException);	task4	
"public class A { <line0> public void updateVmPriorityOnHost(HostInventory inv) { <line1> List<String> vmUuids = <line2> Q.New(VmInstanceVO.class) <line3> .select(VmInstanceVO_.uuid) <line4> .eq(VmInstanceVO_.hostUuid, inv.getUuid()) <line5> .eq(VmInstanceVO_.state, VmInstanceState.Running) <line6> .eq(VmInstanceVO_.type, VmInstanceConstant.USER_VM_TYPE) <line7> .listValues(); <line8> if (vmUuids.isEmpty()) { <line9> return; <line10> } <line11> List<String> updatedVms = <line12> Q.New(SystemTagVO.class) <line13> .select(SystemTagVO_.resourceUuid) <line14> .like(SystemTagVO_.tag, ""vmPriority::%"") <line15> .in(SystemTagVO_.resourceUuid, vmUuids) <line16> .listValues(); <line17> vmUuids.removeAll(updatedVms); <line18> vmUuids.removeIf(v -> !destinationMaker.isManagedByUs(v)); <line19> if (vmUuids.isEmpty()) { <line20> return; <line21> } <line22> VmPriorityConfigVO priorityVO = <line23> Q.New(VmPriorityConfigVO.class) <line24> .eq(VmPriorityConfigVO_.level, VmPriorityLevel.Normal) <line25> .find(); <line26> List<PriorityConfigStruct> priorityConfigStructs = new ArrayList<>(); <line27> vmUuids.forEach( <line28> v -> { <line29> priorityConfigStructs.add(new PriorityConfigStruct(priorityVO, v)); <line30> }); <line31> UpdateVmPriorityMsg msg = new UpdateVmPriorityMsg(); <line32> msg.setHostUuid(inv.getUuid()); <line33> msg.setPriorityConfigStructs(priorityConfigStructs); <line34> bus.makeTargetServiceIdByResourceUuid(msg, HostConstant.SERVICE_ID, inv.getUuid()); <line35> bus.send( <line36> msg, <line37> new CloudBusCallBack(msg) { <line38> @Override <line39> public void run(MessageReply reply) { <line40> UpdateVmPriorityReply r = new UpdateVmPriorityReply(); <line41> if (!reply.isSuccess()) { <line42> return; <line43> } <line44> new VmPriorityOperator().batchSetVmPriority(vmUuids, VmPriorityLevel.Normal); <line45> } <line46> }); <line47> } <line48> } <line49> "	"<line42>              logger.warn(String.format(""update vms priority failed on host[%s],because %s"",inv.getUuid(), reply.getError()));"	task4	
public class A { <line0> @Override <line1> public void removeAllElectronContainers() { <line2> super.removeAllElectronContainers(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Removing all electron containers"");"	task4	
"public class A { <line0> @Before <line1> public void setupManager() throws IOException, RepositoryException { <line2> String temp = System.getProperty(""java.io.tmpdir""); <line3> home = new File(temp, getClass().getName()); <line4> delete(home); <line5> home.deleteOnExit(); <line6> if (!home.mkdirs()) { <line7> throw new RuntimeException(""Could not create directory: "" + home.getAbsolutePath()); <line8> } <line9> InputStream configStream = getClass().getResourceAsStream(""repository.xml""); <line10> RepositoryConfig config = RepositoryConfig.create(configStream, home.getAbsolutePath()); <line11> repo = RepositoryImpl.create(config); <line12> Credentials credentials = new SimpleCredentials(""admin"", ""admin"".toCharArray()); <line13> Session session = repo.login(credentials); <line14> NamespaceRegistry nr = session.getWorkspace().getNamespaceRegistry(); <line15> nr.registerNamespace(""brix"", ""http://brix-cms.googlecode.com""); <line16> session.save(); <line17> manager = new LocalWorkspaceManager(repo).initialize(); <line18> } <line19> } <line20> "	"<line12>    logger.info(""Initializer Jackrabbit Repository in: "" + home.getAbsolutePath());"	task4	
public class A { <line0> @Override <line1> public PooledDataSourceFactory getDataSourceFactory(DPCAttributionConfiguration configuration) { <line2> return configuration.getDatabase(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Connecting to database {} at {}"",configuration.getDatabase().getDriverClass(),configuration.getDatabase().getUrl());"	task4	
public class A { <line0> public String toString() { <line1> try { <line2> JSONObject json = this.toJSON(); <line3> if (json != null) { <line4> return json.toString(); <line5> } <line6> return null; <line7> } catch (Exception e) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.error(""event=cns_topic_delivery_policy_to_string"", e);"	task4	
"public class A { <line0> @RestAccessControl(permission = Permission.MANAGE_PAGES) <line1> @RequestMapping( <line2> value = ""/pages/search"", <line3> method = RequestMethod.GET, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<PagedRestResponse<PageDto>> getPages( <line6> @ModelAttribute(""user"") UserDetails user, PageSearchRequest searchRequest) { <line7> this.getPageValidator().validateRestListRequest(searchRequest, PageDto.class); <line8> List<String> groups = this.getAuthorizationService().getAllowedGroupCodes(user); <line9> PagedMetadata<PageDto> result = this.getPageService().searchPages(searchRequest, groups); <line10> return new ResponseEntity<>(new PagedRestResponse<>(result), HttpStatus.OK); <line11> } <line12> } <line13> "	"<line7>    logger.debug(""getting page list with request {}"", searchRequest);"	task4	
"public class A { <line0> @Override <line1> public void _init() { <line2> panel = new JPanel(new BorderLayout()); <line3> final String groupId = context.getUserData(AzureFunctionsConstants.WIZARD_GROUPID_KEY); <line4> final String artifactId = context.getUserData(AzureFunctionsConstants.WIZARD_ARTIFACTID_KEY); <line5> final String version = context.getUserData(AzureFunctionsConstants.WIZARD_VERSION_KEY); <line6> final String packageName = context.getUserData(AzureFunctionsConstants.WIZARD_PACKAGE_NAME_KEY); <line7> try { <line8> final FormBuilder formBuilder = new FormBuilder(); <line9> final CollectionComboBoxModel<String> toolModel = <line10> new CollectionComboBoxModel<>(Arrays.asList(MAVEN_TOOL, GRADLE_TOOL)); <line11> toolComboBox = new ComboBox<>(toolModel); <line12> formBuilder.addLabeledComponent(""Tool:"", toolComboBox); <line13> groupIdField = new JBTextField(getCurrentOrDefaultValue(groupId, ""com.example"")); <line14> formBuilder.addLabeledComponent(""Group:"", groupIdField); <line15> artifactIdField = <line16> new JBTextField(getCurrentOrDefaultValue(artifactId, ""azure-function-examples"")); <line17> formBuilder.addLabeledComponent(""Artifact:"", artifactIdField); <line18> versionField = new JBTextField(getCurrentOrDefaultValue(version, ""1.0.0-SNAPSHOT"")); <line19> formBuilder.addLabeledComponent(""Version:"", versionField); <line20> packageNameField = <line21> new JBTextField(getCurrentOrDefaultValue(packageName, ""org.example.functions"")); <line22> formBuilder.addLabeledComponent(""Package name:"", packageNameField); <line23> panel.add(ScrollPaneFactory.createScrollPane(formBuilder.getPanel(), true), ""North""); <line24> } catch (final RuntimeException e) { <line25> throw e; <line26> } <line27> } <line28> } <line29> "	<line25>      LOGGER.error(e.getLocalizedMessage(), e);	task4	
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""getJobs"") <line2> public void testJobLifecycle(JobInfo jobInfo, String operationName) throws Exception { <line3> jobInfo = createJob(jobInfo); <line4> jobInfo = template().requestBody(""direct:getJob"", jobInfo, JobInfo.class); <line5> assertSame(JobStateEnum.OPEN, jobInfo.getState(), ""Job should be OPEN""); <line6> jobInfo = template().requestBody(""direct:closeJob"", jobInfo, JobInfo.class); <line7> assertSame(JobStateEnum.CLOSED, jobInfo.getState(), ""Job should be CLOSED""); <line8> jobInfo = template().requestBody(""direct:abortJob"", jobInfo, JobInfo.class); <line9> assertSame(JobStateEnum.ABORTED, jobInfo.getState(), ""Job should be ABORTED""); <line10> } <line11> } <line12> "	"<line3>    log.info(""Testing Job lifecycle for {} of type {}"",jobInfo.getOperation(),jobInfo.getContentType());"	task4	
"public class A { <line0> public NetworkPolicy generateNetworkPolicy( <line1> boolean connectorOperatorEnabled, String operatorNamespace, Labels operatorNamespaceLabels) { <line2> if (connectorOperatorEnabled) { <line3> List<NetworkPolicyIngressRule> rules = new ArrayList<>(2); <line4> NetworkPolicyIngressRule restApiRule = <line5> new NetworkPolicyIngressRuleBuilder() <line6> .addNewPort() <line7> .withNewPort(REST_API_PORT) <line8> .withNewProtocol(""TCP"") <line9> .endPort() <line10> .build(); <line11> List<NetworkPolicyPeer> peers = new ArrayList<>(2); <line12> NetworkPolicyPeer connectPeer = <line13> new NetworkPolicyPeerBuilder() <line14> .withNewPodSelector() <line15> .addToMatchLabels(getSelectorLabels().toMap()) <line16> .endPodSelector() <line17> .build(); <line18> peers.add(connectPeer); <line19> NetworkPolicyPeer clusterOperatorPeer = <line20> new NetworkPolicyPeerBuilder() <line21> .withNewPodSelector() <line22> .addToMatchLabels(Labels.STRIMZI_KIND_LABEL, ""cluster-operator"") <line23> .endPodSelector() <line24> .build(); <line25> ModelUtils.setClusterOperatorNetworkPolicyNamespaceSelector( <line26> clusterOperatorPeer, namespace, operatorNamespace, operatorNamespaceLabels); <line27> peers.add(clusterOperatorPeer); <line28> restApiRule.setFrom(peers); <line29> rules.add(restApiRule); <line30> if (isMetricsEnabled) { <line31> NetworkPolicyIngressRule metricsRule = <line32> new NetworkPolicyIngressRuleBuilder() <line33> .addNewPort() <line34> .withNewPort(METRICS_PORT) <line35> .withNewProtocol(""TCP"") <line36> .endPort() <line37> .withFrom() <line38> .build(); <line39> rules.add(metricsRule); <line40> } <line41> NetworkPolicy networkPolicy = <line42> new NetworkPolicyBuilder() <line43> .withNewMetadata() <line44> .withName(name) <line45> .withNamespace(namespace) <line46> .withLabels(labels.toMap()) <line47> .withOwnerReferences(createOwnerReference()) <line48> .endMetadata() <line49> .withNewSpec() <line50> .withNewPodSelector() <line51> .addToMatchLabels(getSelectorLabels().toMap()) <line52> .endPodSelector() <line53> .withIngress(rules) <line54> .endSpec() <line55> .build(); <line56> return networkPolicy; <line57> } else { <line58> return null; <line59> } <line60> } <line61> } <line62> "	"<line56>      log.trace(""Created network policy {}"", networkPolicy);"	task4	
"public class A { <line0> @Override <line1> public void onStartup(final Set<Class<?>> c, final ServletContext ctx) throws ServletException { <line2> try { <line3> ctx.getClassLoader().loadClass(""org.apache.logging.log4j.web.ServletRequestThreadContext""); <line4> } catch (final ClassNotFoundException e) { <line5> return; <line6> } <line7> final FilterRegistration.Dynamic filter = <line8> ctx.addFilter(""mdc-request-binder"", MdcRequestBinder.class); <line9> filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*""); <line10> filter.setAsyncSupported(true); <line11> } <line12> } <line13> "	"<line5>      log.debug(""log4j-web not available, skipping MDC setup"");"	task4	
"public class A { <line0> @PUT <line1> @Path(""/{id}"") <line2> public Response updateDocument( <line3> @PathParam(""id"") String id, @Context HttpHeaders headers, InputStream message) { <line4> return Response.ok().build(); <line5> } <line6> } <line7> "	"<line4>    LOGGER.info(""id={}"", id);"	task4	
"public class A { <line0> @Override <line1> public int compare(JSONObject a, JSONObject b) { <line2> if (a != null && b != null) { <line3> try { <line4> String aS = (String) a.get(""name""); <line5> String bS = (String) b.get(""name""); <line6> return aS.compareToIgnoreCase(bS); <line7> } catch (JSONException ex) { <line8> return 1; <line9> } <line10> } else { <line11> return 1; <line12> } <line13> } <line14> } <line15> "	"<line8>        LOG.error(""JSON Error Exception"", ex);"	task4	
public class A { <line0> public static boolean saveObject(String path, HVPSettings obj) { <line1> if (obj == null) { <line2> return false; <line3> } <line4> try { <line5> FileOutputStream fileOut = new FileOutputStream(path); <line6> ObjectOutputStream out = new ObjectOutputStream(fileOut); <line7> out.writeObject(obj); <line8> out.close(); <line9> fileOut.close(); <line10> } catch (Exception ex) { <line11> return false; <line12> } <line13> return true; <line14> } <line15> } <line16> 	"<line11>      LOGGER.warn(""Failed to save HexviewerPlus settings file. Error:{}"", ex.toString());"	task4	
"public class A { <line0> @Test <line1> public void testClassLdapConnectionPool() { <line2> LdapConnection ldapConnection = null; <line3> TrackingLdapConnectionFactory factory = (TrackingLdapConnectionFactory) ldapConnectionFactory; <line4> try { <line5> ldapConnection = ldapConnectionPool.getConnection(); <line6> assertEquals(1, factory.getBindCalled()); <line7> } catch (LdapException e) { <line8> fail(e.getMessage()); <line9> } finally { <line10> if (ldapConnection != null) { <line11> try { <line12> ldapConnectionPool.releaseConnection(ldapConnection); <line13> assertEquals(1, factory.getBindCalled()); <line14> } catch (LdapException e) { <line15> fail(""failed to release connection: "" + e.getMessage()); <line16> } <line17> } <line18> } <line19> try { <line20> ldapConnection = ldapConnectionPool.getConnection(); <line21> assertEquals(1, factory.getBindCalled()); <line22> ldapConnection.bind(ServerDNConstants.ADMIN_SYSTEM_DN, ""secret""); <line23> assertEquals(1, factory.getBindCalled()); <line24> } catch (LdapException e) { <line25> fail(e.getMessage()); <line26> } finally { <line27> if (ldapConnection != null) { <line28> try { <line29> ldapConnectionPool.releaseConnection(ldapConnection); <line30> assertEquals(2, factory.getBindCalled()); <line31> } catch (LdapException e) { <line32> fail(""failed to release connection: "" + e.getMessage()); <line33> } <line34> } <line35> } <line36> } <line37> } <line38> "	"<line2>    LOG.debug(""testClassLdapConnectionPool"");"	task4	
"public class A { <line0> @Override <line1> public void initialize(URI name, Configuration conf) throws IOException { <line2> super.initialize(name, conf); <line3> this.bucket = name.getHost(); <line4> if (this.store == null) { <line5> this.store = createDefaultStore(conf); <line6> } <line7> this.store.initialize(name, conf); <line8> setConf(conf); <line9> this.uri = URI.create(name.getScheme() + ""://"" + name.getAuthority()); <line10> this.workingDir = <line11> new Path(""/user"", System.getProperty(""user.name"")) <line12> .makeQualified(this.uri, this.getWorkingDirectory()); <line13> this.owner = getOwnerId(); <line14> this.group = getGroupId(); <line15> BufferPool.getInstance().initialize(this.getConf()); <line16> int uploadThreadPoolSize = <line17> this.getConf() <line18> .getInt( <line19> CosNConfigKeys.UPLOAD_THREAD_POOL_SIZE_KEY, <line20> CosNConfigKeys.DEFAULT_UPLOAD_THREAD_POOL_SIZE); <line21> int readAheadPoolSize = <line22> this.getConf() <line23> .getInt( <line24> CosNConfigKeys.READ_AHEAD_QUEUE_SIZE, CosNConfigKeys.DEFAULT_READ_AHEAD_QUEUE_SIZE); <line25> int ioThreadPoolSize = uploadThreadPoolSize + readAheadPoolSize / 3; <line26> long threadKeepAlive = <line27> this.getConf() <line28> .getLong( <line29> CosNConfigKeys.THREAD_KEEP_ALIVE_TIME_KEY, <line30> CosNConfigKeys.DEFAULT_THREAD_KEEP_ALIVE_TIME); <line31> this.boundedIOThreadPool = <line32> BlockingThreadPoolExecutorService.newInstance( <line33> ioThreadPoolSize / 2, <line34> ioThreadPoolSize, <line35> threadKeepAlive, <line36> TimeUnit.SECONDS, <line37> ""cos-transfer-thread-pool""); <line38> int copyThreadPoolSize = <line39> this.getConf() <line40> .getInt( <line41> CosNConfigKeys.COPY_THREAD_POOL_SIZE_KEY, <line42> CosNConfigKeys.DEFAULT_COPY_THREAD_POOL_SIZE); <line43> this.boundedCopyThreadPool = <line44> BlockingThreadPoolExecutorService.newInstance( <line45> CosNConfigKeys.DEFAULT_COPY_THREAD_POOL_SIZE, <line46> copyThreadPoolSize, <line47> 60L, <line48> TimeUnit.SECONDS, <line49> ""cos-copy-thread-pool""); <line50> } <line51> } <line52> "	"<line15>    LOG.debug(""owner:"" + owner + "", group:"" + group);"	task4	
public class A { <line0> public void setFinalLocalDefs( <line1> List<PDefinition> localDefs, List<AVarDeclIR> localDecls, IRInfo question) <line2> throws AnalysisException { <line3> for (PDefinition def : localDefs) { <line4> AVarDeclIR varDecl = null; <line5> if (def instanceof AValueDefinition) { <line6> varDecl = consLocalVarDecl((AValueDefinition) def, question); <line7> } else if (def instanceof AEqualsDefinition) { <line8> varDecl = consLocalVarDecl((AEqualsDefinition) def, question); <line9> } <line10> if (varDecl != null) { <line11> varDecl.setFinal(true); <line12> localDecls.add(varDecl); <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> 	"<line14>        log.error(""Problems encountered when trying to construct local variable"");"	task4	
public class A { <line0> private static int getCurrentIterationNumber( <line1> Configuration config, Path modelTempDir, int maxIterations) throws IOException { <line2> FileSystem fs = FileSystem.get(config); <line3> int iterationNumber = 1; <line4> Path iterationPath = modelPath(modelTempDir, iterationNumber); <line5> while (fs.exists(iterationPath) && iterationNumber <= maxIterations) { <line6> iterationNumber++; <line7> iterationPath = modelPath(modelTempDir, iterationNumber); <line8> } <line9> return iterationNumber - 1; <line10> } <line11> } <line12> 	"<line6>      log.info(""Found previous state: "" + iterationPath);"	task4	
public class A { <line0> private boolean processPsiFileRoots( <line1> @Nonnull List<VirtualFile> files, <line2> final int totalSize, <line3> int alreadyProcessedFiles, <line4> @Nonnull final ProgressIndicator progress, <line5> @Nonnull final Processor<? super PsiFile> localProcessor) { <line6> myManager.startBatchFilesProcessingMode(); <line7> try { <line8> final AtomicInteger counter = new AtomicInteger(alreadyProcessedFiles); <line9> final AtomicBoolean stopped = new AtomicBoolean(false); <line10> return processFilesConcurrentlyDespiteWriteActions( <line11> myManager.getProject(), <line12> files, <line13> progress, <line14> stopped, <line15> vfile -> { <line16> TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages(); <line17> try { <line18> processVirtualFile(vfile, stopped, localProcessor); <line19> } catch (ProcessCanceledException | IndexNotReadyException e) { <line20> throw e; <line21> } catch (Throwable e) { <line22> throw e; <line23> } <line24> if (progress.isRunning()) { <line25> double fraction = (double) counter.incrementAndGet() / totalSize; <line26> progress.setFraction(fraction); <line27> } <line28> return !stopped.get(); <line29> }); <line30> } finally { <line31> myManager.finishBatchFilesProcessingMode(); <line32> } <line33> } <line34> } <line35> 	"<line22>              LOG.error(""Error during processing of: "" + vfile.getName(), e);"	task4	
public class A { <line0> private void discoverDevices() { <line1> if (bridge.getThing().getStatus() != ThingStatus.ONLINE) { <line2> return; <line3> } <line4> for (Location location : bridge.getEvohomeConfig()) { <line5> for (Gateway gateway : location.getGateways()) { <line6> for (TemperatureControlSystem tcs : gateway.getTemperatureControlSystems()) { <line7> addDisplayDiscoveryResult(location, tcs); <line8> for (Zone zone : tcs.getZones()) { <line9> addZoneDiscoveryResult(location, zone); <line10> } <line11> } <line12> } <line13> } <line14> stopScan(); <line15> } <line16> } <line17> 	"<line2>      logger.debug(""Evohome Gateway not online, scanning postponed"");"	task4	
public class A { <line0> private static void stopSCM(StorageContainerManager scm) { <line1> if (scm != null) { <line2> scm.stop(); <line3> scm.join(); <line4> } <line5> } <line6> } <line7> 	"<line2>      LOG.info(""Stopping the StorageContainerManager"");"	task4	
public class A { <line0> protected void closeRandomAccessFileIfNotNull(RandomAccessFile raf) { <line1> if (raf != null) { <line2> try { <line3> raf.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>        LOG.error(e);	task4	
"public class A { <line0> @Test <line1> public void testCollectionToPrimitiveArrayConversion() throws Exception { <line2> List<Integer> list = new ArrayList<>(); <line3> list.add(5); <line4> list.add(6); <line5> Integer[] integerArray = converter.convertTo(Integer[].class, list); <line6> assertEquals(2, integerArray.length, ""Integer[] length""); <line7> int[] intArray = converter.convertTo(int[].class, list); <line8> assertEquals(2, intArray.length, ""int[] length""); <line9> long[] longArray = converter.convertTo(long[].class, intArray); <line10> assertEquals(2, longArray.length, ""long[] length""); <line11> List<?> resultList = converter.convertTo(List.class, intArray); <line12> assertEquals(2, resultList.size(), ""List size""); <line13> } <line14> } <line15> "	"<line13>    LOG.debug(""From primitive type array we've created the list: "" + resultList);"	task4	
"public class A { <line0> @Override <line1> public Path getPath(URI uri) { <line2> String str = uri.getSchemeSpecificPart(); <line3> int i = str.indexOf(""!/""); <line4> if (i == -1) { <line5> throw new IllegalArgumentException( <line6> ""URI: "" + uri + "" does not contain path info - e.g., root:file://foo/bar!/""); <line7> } <line8> FileSystem fs = getFileSystem(uri); <line9> String subPath = str.substring(i + 1); <line10> Path p = fs.getPath(subPath); <line11> if (log.isTraceEnabled()) { <line12> } <line13> return p; <line14> } <line15> } <line16> "	"<line12>      log.trace(""getPath({}): {}"", uri, p);"	task4	
public class A { <line0> @Deactivate <line1> protected void deactivate(ComponentContext context) { <line2> } <line3> } <line4> 	"<line2>    logger.debug(""deactivating..."");"	task4	
public class A { <line0> @Override <line1> public boolean isMembershipAllowed(long userId, long groupId) { <line2> try { <line3> Group group = GroupLocalServiceUtil.getGroup(groupId); <line4> if (group.isLimitedToParentSiteMembers() <line5> && !GroupLocalServiceUtil.hasUserGroup(userId, group.getParentGroupId(), false)) { <line6> return false; <line7> } <line8> } catch (Exception exception) { <line9> } <line10> return true; <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
"public class A { <line0> @Test <line1> public void testGetOrder() throws Exception { <line2> orderService.setupDummyOrders(); <line3> String response = <line4> template.requestBodyAndHeader( <line5> ""restlet:http://localhost:8080/orders/{id}?restletMethod=GET"", <line6> null, <line7> ""id"", <line8> ""1"", <line9> String.class); <line10> } <line11> } <line12> "	"<line10>    log.info(""Response: {}"", response);"	task4	
public class A { <line0> private <T, B extends T> void addAsRegistrationBean( <line1> ListableBeanFactory beanFactory, <line2> Class<T> type, <line3> Class<B> beanType, <line4> RegistrationBeanAdapter<T> adapter) { <line5> List<Map.Entry<String, B>> beans = getOrderedBeansOfType(beanFactory, beanType, this.seen); <line6> for (Entry<String, B> bean : beans) { <line7> if (this.seen.add(bean.getValue())) { <line8> int order = getOrder(bean.getValue()); <line9> String beanName = bean.getKey(); <line10> RegistrationBean registration = <line11> adapter.createRegistrationBean(beanName, bean.getValue(), beans.size()); <line12> registration.setName(beanName); <line13> registration.setOrder(order); <line14> this.initializers.add(type, registration); <line15> if (ServletContextInitializerBeans.logger.isDebugEnabled()) { <line16> } <line17> } <line18> } <line19> } <line20> } <line21> 	"<line16>          ServletContextInitializerBeans.logger.debug(""Created ""+ type.getSimpleName()+ "" initializer for bean '""+ beanName+ ""'; order=""+ order+ "", resource=""+ getResourceDescription(beanName, beanFactory));"	task4	
"public class A { <line0> private JsonObject addProperties(Project project) { <line1> JsonObject result = new JsonObject(); <line2> try { <line3> result.addProperty(""id"", project.getId()); <line4> result.addProperty(""name"", project.getName()); <line5> result.addProperty(""description"", project.getDescription()); <line6> result.addProperty(""description-html"", project.getDescriptionHtml()); <line7> result.addProperty(""type"", project.getType().name()); <line8> result.addProperty(""board"", project.getBoard()); <line9> result.addProperty(""private"", project.getPrivate()); <line10> result.addProperty(""shared"", project.getShared()); <line11> result.addProperty( <line12> ""modified"", DateConversion.toDateTimeString(project.getModified().getTime())); <line13> result.addProperty(""settings"", project.getSettings()); <line14> } catch (Exception ex) { <line15> } <line16> return result; <line17> } <line18> } <line19> "	"<line15>      LOG.error(""Exception {} detected."", ex.toString());"	task4	
"public class A { <line0> private ClusterDatabaseSet tryAdapt(DefaultDatabaseSet defaultDatabaseSet) { <line1> try { <line2> DataBase master = defaultDatabaseSet.getMasterDbs().iterator().next(); <line3> if ((master instanceof DefaultDataBase) && !(master instanceof ProviderDataBase)) { <line4> String databaseKey = master.getConnectionString(); <line5> Map<String, DalConnectionString> failedConnectionStrings = <line6> DataSourceConfigureLocatorManager.getInstance().getFailedConnectionStrings(); <line7> if (failedConnectionStrings == null || !failedConnectionStrings.containsKey(databaseKey)) { <line8> ClusterInfo clusterInfo = clusterInfoProvider.getClusterInfo(databaseKey); <line9> if (clusterInfo != null <line10> && clusterInfo.getRole() == DatabaseRole.MASTER <line11> && !clusterInfo.dbSharding()) { <line12> String clusterName = clusterInfo.getClusterName(); <line13> Cluster cluster = <line14> clusterManager.getOrCreateCluster( <line15> clusterName, new DefaultDalConfigCustomizedOption()); <line16> if (checkCluster(cluster)) { <line17> LOGGER.logEvent( <line18> DalLogTypes.DAL_VALIDATION, <line19> ""ClusterAdaptSucceeded"", <line20> String.format( <line21> ""databaseSet: %s, clusterName: %s"", <line22> defaultDatabaseSet.getName(), clusterName)); <line23> return new ClusterDatabaseSet( <line24> defaultDatabaseSet.getName(), cluster, connectionLocator); <line25> } <line26> } <line27> } <line28> } <line29> LOGGER.logEvent( <line30> DalLogTypes.DAL_VALIDATION, <line31> ""ClusterAdaptSkipped"", <line32> String.format(""databaseSet: %s"", defaultDatabaseSet.getName())); <line33> } catch (Throwable t) { <line34> LOGGER.logEvent( <line35> DalLogTypes.DAL_VALIDATION, <line36> ""ClusterAdaptFailed"", <line37> String.format(""databaseSet: %s"", defaultDatabaseSet.getName())); <line38> } <line39> return null; <line40> } <line41> } <line42> "	"<line38>      LOGGER.warn(""Adapt DefaultDatabaseSet to ClusterDatabaseSet exception"", t);"	task4	
public class A { <line0> @Override <line1> public void onSuccess(Request request) { <line2> final UserJS userJS = request.getResult(); <line3> if (userJS != null) { <line4> final UserDTO userDTO = userJS.toDTO(); <line5> transaction.getObjectCache().put(id, userDTO); <line6> orgUnitDAO.get( <line7> userJS.getMainOrgUnit(), <line8> new AsyncCallback<OrgUnitDTO>() { <line9> @Override <line10> public void onFailure(Throwable caught) { <line11> } <line12>  <line13> @Override <line14> public void onSuccess(OrgUnitDTO result) { <line15> userDTO.setMainOrgUnit(result); <line16> callback.onSuccess(userDTO); <line17> } <line18> }, <line19> transaction); <line20> } else { <line21> callback.onSuccess(null); <line22> } <line23> } <line24> } <line25> 	"<line11>              Log.error(""Error while retrieving org unit ""+ userJS.getMainOrgUnit()+ "" for user ""+ userJS.getId());"	task4	
"public class A { <line0> public void set(HelixConfigScope scope, Map<String, String> keyValueMap) { <line1> if (scope == null || scope.getType() == null || !scope.isFullKey()) { <line2> return; <line3> } <line4> String clusterName = scope.getClusterName(); <line5> if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) { <line6> throw new HelixException(""fail to set config. cluster: "" + clusterName + "" is NOT setup.""); <line7> } <line8> if (scope.getType() == ConfigScopeProperty.PARTICIPANT) { <line9> if (!ZKUtil.isInstanceSetup( <line10> _zkClient, <line11> scope.getClusterName(), <line12> scope.getParticipantName(), <line13> InstanceType.PARTICIPANT)) { <line14> throw new HelixException( <line15> ""fail to set config. instance: "" <line16> + scope.getParticipantName() <line17> + "" is NOT setup in cluster: "" <line18> + clusterName); <line19> } <line20> } <line21> String mapKey = scope.getMapKey(); <line22> String zkPath = scope.getZkPath(); <line23> String id = zkPath.substring(zkPath.lastIndexOf('/') + 1); <line24> ZNRecord update = new ZNRecord(id); <line25> if (mapKey == null) { <line26> update.getSimpleFields().putAll(keyValueMap); <line27> } else { <line28> update.setMapField(mapKey, keyValueMap); <line29> } <line30> ZKUtil.createOrMerge(_zkClient, zkPath, update, true, true); <line31> } <line32> } <line33> "	"<line2>      LOG.error(""fail to set config. invalid config scope. Scope: {}."", scope);"	task4	
"public class A { <line0> @Override <line1> public boolean process(Exchange exchange, AsyncCallback callback) { <line2> if (!isRunAllowed()) { <line3> exchange.setException(new RejectedExecutionException(""Run is not allowed"")); <line4> callback.done(true); <line5> return true; <line6> } <line7> long delay; <line8> try { <line9> delay = calculateDelay(exchange); <line10> if (delay <= 0) { <line11> if (LOG.isTraceEnabled()) { <line12> } <line13> return processor.process(exchange, callback); <line14> } <line15> } catch (Throwable e) { <line16> exchange.setException(e); <line17> callback.done(true); <line18> return true; <line19> } <line20> return processDelay(exchange, callback, delay); <line21> } <line22> } <line23> "	"<line12>          LOG.trace(""No delay for exchangeId: {}"", exchange.getExchangeId());"	task4	
"public class A { <line0> void writeHtmlToLastShutdownFile() { <line1> try { <line2> final File dir = Parameters.getStorageDirectory(getApplication()); <line3> if (!dir.mkdirs() && !dir.exists()) { <line4> throw new IOException(""JavaMelody directory can't be created: "" + dir.getPath()); <line5> } <line6> final File lastShutdownFile = new File(dir, ""last_shutdown.html""); <line7> try (BufferedWriter writer = new BufferedWriter(new FileWriter(lastShutdownFile))) { <line8> final JavaInformations javaInformations = <line9> new JavaInformations(Parameters.getServletContext(), true); <line10> final HtmlReport myHtmlReport = <line11> new HtmlReport( <line12> collector, <line13> collectorServer, <line14> Collections.singletonList(javaInformations), <line15> Period.JOUR, <line16> writer); <line17> myHtmlReport.writeLastShutdown(); <line18> } <line19> } catch (final IOException e) { <line20> } <line21> } <line22> } <line23> "	"<line20>      LOG.warn(""exception while writing the last shutdown report"", e);"	task4	
public class A { <line0> private void test_streamed_triples_bad(final String data, int expected) <line1> throws TimeoutException, InterruptedException { <line2> final PipedRDFIterator<Triple> it = new PipedRDFIterator<>(); <line3> final PipedTriplesStream out = new PipedTriplesStream(it); <line4> Runnable runParser = <line5> new Runnable() { <line6> @Override <line7> public void run() { <line8> Charset utf8 = StandardCharsets.UTF_8; <line9> ByteArrayInputStream input = new ByteArrayInputStream(data.getBytes(utf8)); <line10> try { <line11> RDFParser.source(input).lang(Lang.TTL).parse(out); <line12> } catch (Throwable t) { <line13> } <line14> return; <line15> } <line16> }; <line17> Callable<Integer> consumeTriples = <line18> new Callable<Integer>() { <line19> @Override <line20> public Integer call() { <line21> int count = 0; <line22> while (it.hasNext()) { <line23> it.next(); <line24> count++; <line25> } <line26> return count; <line27> } <line28> }; <line29> Future<?> genResult = executor.submit(runParser); <line30> Future<Integer> result = executor.submit(consumeTriples); <line31> Integer count = 0; <line32> try { <line33> count = result.get(10, TimeUnit.SECONDS); <line34> } catch (TimeoutException e) { <line35> try { <line36> genResult.get(); <line37> } catch (ExecutionException ex) { <line38> } <line39> throw e; <line40> } catch (ExecutionException e) { <line41> Assert.fail(e.getMessage()); <line42> } <line43> Assert.assertEquals(expected, (int) count); <line44> } <line45> } <line46> 	"<line38>        LOGGER.warn(""Errored as expected"", ex);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> for (ClusterTopologyListener listener : copy) { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> try { <line6> listener.nodeDown(uniqueEventID, nodeId); <line7> } catch (Exception e) { <line8> ActiveMQClientLogger.LOGGER.errorSendingTopologyNodedown(e); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line4>        logger.trace(this + "" informing "" + listener + "" about node down = "" + nodeId);"	task4	
public class A { <line0> public void destroy() throws Exception { <line1> if (remoteClientAssociation != null) { <line2> this.management.stopAssociation(remoteClientAssociationName); <line3> this.management.removeAssociation(remoteClientAssociationName); <line4> remoteClientAssociation = null; <line5> } <line6> if (serverAssociation != null) { <line7> this.management.stopAssociation(serverAssociationName); <line8> this.management.removeAssociation(serverAssociationName); <line9> this.management.stopServer(serverName); <line10> this.management.removeServer(serverName); <line11> this.management.stop(); <line12> serverAssociation = null; <line13> } <line14> } <line15> } <line16> 	"<line1>    logger.debug(""Destroying SCTP Server"");"	task4	
"public class A { <line0> @Override <line1> public void afterPropertiesSet() throws Exception { <line2> Assert.state(repository != null, ""A CrudRepository implementation is required""); <line3> if (this.methodName != null) { <line4> Assert.hasText(this.methodName, ""methodName must not be empty.""); <line5> } else { <line6> } <line7> } <line8> } <line9> "	"<line6>      logger.debug(""No method name provided, CrudRepository.saveAll will be used."");"	task4	
public class A { <line0> static boolean sanityCheckArenaBlockSize( <line1> long writeBufferSize, long arenaBlockSizeConfigured, long writeBufferManagerCapacity) <line2> throws IllegalStateException { <line3> long defaultArenaBlockSize = <line4> RocksDBMemoryControllerUtils.calculateRocksDBDefaultArenaBlockSize(writeBufferSize); <line5> long arenaBlockSize = <line6> arenaBlockSizeConfigured <= 0 ? defaultArenaBlockSize : arenaBlockSizeConfigured; <line7> long mutableLimit = <line8> RocksDBMemoryControllerUtils.calculateRocksDBMutableLimit(writeBufferManagerCapacity); <line9> if (RocksDBMemoryControllerUtils.validateArenaBlockSize(arenaBlockSize, mutableLimit)) { <line10> return true; <line11> } else { <line12> return false; <line13> } <line14> } <line15> } <line16> 	"<line12>      LOG.warn(""RocksDBStateBackend performance will be poor because of the current Flink memory""+ "" configuration! RocksDB will flush memtable constantly, causing high IO and CPU.""+ "" Typically the easiest fix is to increase task manager managed memory size. If""+ "" running locally, see the parameter taskmanager.memory.managed.size. Details:""+ "" arenaBlockSize {} > mutableLimit {} (writeBufferSize = {},""+ "" arenaBlockSizeConfigured = {}, defaultArenaBlockSize = {},""+ "" writeBufferManagerCapacity = {})"",arenaBlockSize,mutableLimit,writeBufferSize,arenaBlockSizeConfigured,defaultArenaBlockSize,writeBufferManagerCapacity);"	task4	
public class A { <line0> @Override <line1> public void handleEvent(Event event) { <line2> if (event.getTopic().equals(RawSocketTransport.ERROR_EVENT_TOPIC)) { <line3> Exception error = (Exception) event.getProperty(RawSocketTransport.ERROR_PROPERTY_NAME); <line4> if (error != null) { <line5> errorHappened(error); <line6> } <line7> } else if (event.getTopic().equals(CMD_RCVD_EVENT_TOPIC)) { <line8> String response = (String) event.getProperty(COMMAND_PROPERTY_NAME); <line9> if (response != null) { <line10> commandReceived(response); <line11> } <line12> } <line13> } <line14> } <line15> 	"<line2>    log.debug(""Event received"");"	task4	
public class A { <line0> public void doSomething() { <line1> log.getName(); <line2> } <line3> } <line4> 	"<line1>    log.info(""Information message text"");"	task4	
public class A { <line0> @Override <line1> protected long getLastModified(HttpServletRequest httpServletRequest) { <line2> try { <line3> URL url = getResourceURL(httpServletRequest); <line4> if (url != null) { <line5> URLConnection urlConnection = url.openConnection(); <line6> return urlConnection.getLastModified(); <line7> } <line8> return super.getLastModified(httpServletRequest); <line9> } catch (IOException ioException) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> return super.getLastModified(httpServletRequest); <line13> } <line14> } <line15> } <line16> 	<line11>        log.debug(ioException, ioException);	task4	
"public class A { <line0> @Override <line1> @Transactional <line2> public List<IpBlockEntity> merge( <line3> List<IpBlockEntity> ipBlocks, <line4> boolean ignoreOwner, <line5> boolean ignoreType, <line6> boolean silentWhenOverlap) { <line7> if (ipBlocks.size() <= 1) { <line8> return ipBlocks; <line9> } <line10> AuAssert.check(ignoreOwner || !ignoreType, ""must ignore owner if type is ignored""); <line11> boolean inHibernateSession = <line12> getSessionFactory().getCurrentSession().getTransaction().isActive(); <line13> Collections.sort(ipBlocks); <line14> List<IpBlockEntity> newBlocks = new ArrayList<IpBlockEntity>(ipBlocks.size()); <line15> Iterator<IpBlockEntity> iter = ipBlocks.iterator(); <line16> IpBlockEntity prev = iter.next(); <line17> while (iter.hasNext()) { <line18> IpBlockEntity curr = iter.next(); <line19> if (prev.canConcatWith(curr)) { <line20> if (prev.isOverlapedWith(curr)) { <line21> if (!silentWhenOverlap) { <line22> throw NetworkException.OVERLAPPED_IP_BLOCKS(prev, curr); <line23> } <line24> } <line25> if ((ignoreOwner || prev.getOwnerId().equals(curr.getOwnerId())) <line26> && (ignoreType || prev.getType() == curr.getType())) { <line27> prev.setEndIp(Math.max(curr.getEndIp(), prev.getEndIp())); <line28> if (curr.getId() != null) { <line29> if (inHibernateSession) { <line30> delete(curr); <line31> } else { <line32> AuAssert.unreachable(); <line33> } <line34> } <line35> continue; <line36> } <line37> } <line38> newBlocks.add(prev); <line39> prev = curr; <line40> } <line41> newBlocks.add(prev); <line42> return newBlocks; <line43> } <line44> } <line45> "	"<line21>          logger.warn(""detected overlapped IP blocks: "" + prev + "", "" + curr);"	task4	
public class A { <line0> private boolean hasSufficientTimeElapsed() { <line1> long now = Time.currentElapsedTime(); <line2> if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN) { <line3> return false; <line4> } <line5> setLastLogin(now); <line6> return true; <line7> } <line8> } <line9> 	"<line3>      LOG.warn(""Not attempting to re-login since the last re-login was ""+ ""attempted less than {} seconds before."",(MIN_TIME_BEFORE_RELOGIN / 1000));"	task4	
public class A { <line0> List<GitBlameWithUsage> getGitBlameWithUsagesFromLine( <line1> String line, List<GitBlameWithUsage> gitBlameWithUsages, FileType fileType) { <line2> List<GitBlameWithUsage> gitBlameWithUsagesWithLine = new ArrayList<>(); <line3> if (line != null) { <line4> for (GitBlameWithUsage gitBlameWithUsage : gitBlameWithUsages) { <line5> String textUnitNameInSource = <line6> textUnitNameToTextUnitNameInSource( <line7> gitBlameWithUsage.getTextUnitName(), <line8> fileType, <line9> gitBlameWithUsage.getPluralForm() != null); <line10> if (line.contains(textUnitNameInSource)) { <line11> gitBlameWithUsagesWithLine.add(gitBlameWithUsage); <line12> } <line13> } <line14> } <line15> return gitBlameWithUsagesWithLine; <line16> } <line17> } <line18> 	"<line11>          logger.debug(""Found match for string in source file: {} in line: {}"", textUnitNameInSource, line);"	task4	
public class A { <line0> @Override <line1> protected void afterDump(ErosaConnection connection) { <line2> if (metaConnection != null) { <line3> try { <line4> metaConnection.disconnect(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        logger.error(""ERROR # disconnect meta connection for address:{}"",metaConnection.getConnector().getAddress(),e);"	task4	
public class A { <line0> @Test <line1> public void testBench() { <line2> } <line3> } <line4> 	"<line2>    logger.info(""System benchmark result = {}"", SystemUtil.bench());"	task4	
public class A { <line0> private Collection<JobConfig> removeDuplicateByJobName(Set<JobConfig> streamChangedJobs) { <line1> Map<String, JobConfig> streamChangedJobsMap = new HashMap<>(); <line2> for (JobConfig streamChangedJob : streamChangedJobs) { <line3> String jobName = streamChangedJob.getJobName(); <line4> if (streamChangedJobsMap.containsKey(jobName)) { <line5> } else { <line6> streamChangedJobsMap.put(jobName, streamChangedJob); <line7> } <line8> } <line9> return streamChangedJobsMap.values(); <line10> } <line11> } <line12> 	"<line5>        log.warn(""the DB have duplicated jobName({})"", jobName);"	task4	
public class A { <line0> @Override <line1> public IOperatorNodePushable createPushRuntime( <line2> IHyracksTaskContext ctx, <line3> IRecordDescriptorProvider recordDescProvider, <line4> int partition, <line5> int nPartitions) <line6> throws HyracksDataException { <line7> return new AbstractLibraryNodePushable(ctx) { <line8> @Override <line9> protected void execute() throws IOException { <line10> if (LOGGER.isInfoEnabled()) { <line11> } <line12> try { <line13> closeLibrary(); <line14> } finally { <line15> FileReference libDir = getLibraryDir(); <line16> dropIfExists(libDir); <line17> flushDirectory(libDir.getFile().getParentFile()); <line18> } <line19> } <line20> }; <line21> } <line22> } <line23> 	"<line11>          LOGGER.info(""Undeploying library {}.{}"", dataverseName, libraryName);"	task4	
public class A { <line0> public void succeeded() { <line1> if (isEventWatched()) { <line2> reconciliationTimerSample.stop(reconciliationsTimer); <line3> successfulReconciliationsCounter.increment(); <line4> } <line5> } <line6> } <line7> 	"<line2>      LOGGER.debug(""succeeded reconciliation {}"", name);"	task4	
"public class A { <line0> @Override <line1> public ModelNode execute( <line2> ModelNode operation, <line3> OperationMessageHandler handler, <line4> OperationTransactionControl control, <line5> OperationAttachments attachments) { <line6> this.operation = operation; <line7> executeLatch.countDown(); <line8> try { <line9> Thread.sleep(10000000); <line10> ModelNode result = new ModelNode(); <line11> result.get(""testing"").set(operation.get(""test"")); <line12> return result; <line13> } catch (InterruptedException e) { <line14> interrupted.countDown(); <line15> throw new RuntimeException(e); <line16> } <line17> } <line18> } <line19> "	"<line9>      log.debug(""Waiting for interrupt"");"	task4	
public class A { <line0> private void installSnapshotUsers(IAuthorizer authorizer, MetaSimpleSnapshot snapshot) { <line1> try { <line2> authorizer.replaceAllUsers(snapshot.getUserMap()); <line3> } catch (AuthException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.error(""{}:replace users failed"", metaGroupMember.getName(), e);"	task4	
public class A { <line0> @Override <line1> public void onError(JoynrRuntimeException error) { <line2> subscribeAttributeEnumerationCallbackResult = false; <line3> subscribeAttributeEnumerationCallbackDone = true; <line4> } <line5> } <line6> 	"<line2>    logger.info(name.getMethodName() + "" - callback - got unexpected exception"");"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.json.JSONArray getWARThemes(HttpPrincipal httpPrincipal) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey(ThemeServiceUtil.class, ""getWARThemes"", _getWARThemesParameterTypes1); <line4> MethodHandler methodHandler = new MethodHandler(methodKey); <line5> Object returnObj = null; <line6> try { <line7> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line8> } catch (Exception exception) { <line9> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line10> } <line11> return (com.liferay.portal.kernel.json.JSONArray) returnObj; <line12> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line13> throw systemException; <line14> } <line15> } <line16> } <line17> "	<line13>      log.error(systemException, systemException);	task4	
"public class A { <line0> private static boolean isAndroid0() { <line1> boolean android; <line2> try { <line3> Class.forName(""android.app.Application"", false, getSystemClassLoader()); <line4> android = true; <line5> } catch (Throwable ignored) { <line6> android = false; <line7> } <line8> if (android) { <line9> } <line10> return android; <line11> } <line12> } <line13> "	"<line9>      logger.debug(""Platform: Android"");"	task4	
public class A { <line0> @Override <line1> public int getPrivateLayoutsPageCount() { <line2> try { <line3> Group group = getGroup(); <line4> if (group == null) { <line5> return 0; <line6> } <line7> return group.getPrivateLayoutsPageCount(); <line8> } catch (Exception exception) { <line9> } <line10> return 0; <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
public class A { <line0> public boolean validateBatchGeocodeResult( <line1> Class<? extends GeocodeService> source, <line2> ArrayList<Address> addresses, <line3> ArrayList<GeocodeResult> geocodeResults, <line4> List<GeocodedAddress> geocodedAddresses, <line5> Boolean freeze) { <line6> boolean hasValidResult = false; <line7> geocodeResults.clear(); <line8> if (geocodedAddresses != null && geocodedAddresses.size() == addresses.size()) { <line9> for (GeocodedAddress geocodedAddress : geocodedAddresses) { <line10> GeocodeResult geocodeResult = new GeocodeResult(source); <line11> if (validateGeocodeResult(source, geocodedAddress, geocodeResult, false)) { <line12> hasValidResult = true; <line13> } <line14> geocodeResults.add(geocodeResult); <line15> } <line16> } else { <line17> for (Address a : addresses) { <line18> geocodeResults.add(new GeocodeResult(source, NO_GEOCODE_RESULT, new GeocodedAddress(a))); <line19> } <line20> } <line21> if (hasValidResult) { <line22> removeGeocoderBlock(source); <line23> } else if (freeze) { <line24> recordFailedResult(source); <line25> } <line26> return hasValidResult; <line27> } <line28> } <line29> 	"<line17>      logger.warn(""Invalidating this batch! The results returned do not match the addresses given."");"	task4	
"public class A { <line0> @Override <line1> public Map<DistrictType, Map<String, DistrictMap>> extractData(ResultSet rs) throws SQLException { <line2> districtMapCache = new HashMap<>(); <line3> districtMapLookup = new HashMap<>(); <line4> while (rs.next()) { <line5> DistrictType type = DistrictType.resolveType(rs.getString(""type"")); <line6> if (type != null) { <line7> if (!districtMapCache.containsKey(type)) { <line8> districtMapCache.put(type, new ArrayList<DistrictMap>()); <line9> districtMapLookup.put(type, new HashMap<String, DistrictMap>()); <line10> } <line11> String code = getDistrictCode(rs); <line12> DistrictMetadata metadata = new DistrictMetadata(type, rs.getString(""name""), code); <line13> DistrictMap map = getDistrictMapFromJson(rs.getString(""map"")); <line14> map.setDistrictMetadata(metadata); <line15> if (code != null && map != null) { <line16> districtMapCache.get(type).add(map); <line17> districtMapLookup.get(type).put(code, map); <line18> } <line19> } <line20> } <line21> return districtMapLookup; <line22> } <line23> } <line24> "	"<line8>          logger.debug(""Caching "" + type.name());"	task4	
"public class A { <line0> public static void main(String[] args) { <line1> try { <line2> Runtime.start(""gui"", ""SwingGui""); <line3> OpenCV cv = (OpenCV) Runtime.start(""cv"", ""OpenCV""); <line4> OpenCVFilterAddMask mask = new OpenCVFilterAddMask(""mask""); <line5> cv.addFilter(mask); <line6> mask.test(); <line7> boolean done = true; <line8> if (done) { <line9> return; <line10> } <line11> cv.capture(""src\\test\\resources\\OpenCV\\multipleFaces.jpg""); <line12> cv.addFilter(mask); <line13> cv.capture(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> "	"<line15>      log.error(""main threw"", e);"	task4	
"public class A { <line0> @Override <line1> public void configure(Context context) { <line2> super.configure(context); <line3> serializerType = context.getString(""serializer"", ""TEXT""); <line4> useRawLocalFileSystem = context.getBoolean(""hdfs.useRawLocalFileSystem"", false); <line5> serializerContext = new Context(context.getSubProperties(EventSerializer.CTX_PREFIX)); <line6> } <line7> } <line8> "	"<line6>    logger.info(""Serializer = "" + serializerType + "", UseRawLocalFileSystem = "" + useRawLocalFileSystem);"	task4	
public class A { <line0> protected synchronized void debug(boolean hit) { <line1> if (hit) { <line2> match++; <line3> } else { <line4> miss++; <line5> } <line6> if (match + miss >= debug) { <line7> match = 0; <line8> miss = 0; <line9> } <line10> } <line11> } <line12> 	"<line7>      log.warn(""query["" + debugKey + ""]: match="" + match + "" miss="" + miss);"	task4	
"public class A { <line0> private PortletURL _getEditAssetEntryURL() { <line1> boolean showEditURL = ParamUtil.getBoolean(_httpServletRequest, ""showEditURL"", true); <line2> if (!showEditURL) { <line3> return null; <line4> } <line5> try { <line6> if (!_assetRenderer.hasEditPermission(_themeDisplay.getPermissionChecker())) { <line7> return null; <line8> } <line9> String redirect = _themeDisplay.getURLCurrent(); <line10> if (Validator.isNotNull(_fullContentRedirect)) { <line11> redirect = _fullContentRedirect; <line12> } <line13> return PortletURLBuilder.create( <line14> _assetRenderer.getURLEdit( <line15> _liferayPortletRequest, <line16> _liferayPortletResponse, <line17> LiferayWindowState.NORMAL, <line18> redirect)) <line19> .setParameter( <line20> ""portletResource"", <line21> () -> { <line22> PortletDisplay portletDisplay = _themeDisplay.getPortletDisplay(); <line23> return portletDisplay.getPortletName(); <line24> }) <line25> .build(); <line26> } catch (Exception exception) { <line27> if (log.isDebugEnabled()) { <line28> } <line29> } <line30> return null; <line31> } <line32> } <line33> "	<line28>        log.debug(exception, exception);	task4	
public class A { <line0> public List<InputSplit> getSplits(Configuration conf, int numSplits) { <line1> int nbTrees = Builder.getNbTrees(conf); <line2> int splitSize = nbTrees / numSplits; <line3> seed = Builder.getRandomSeed(conf); <line4> isSingleSeed = isSingleSeed(conf); <line5> if (rng != null && seed != null) { <line6> } <line7> rng = seed == null || isSingleSeed ? null : RandomUtils.getRandom(seed); <line8> int id = 0; <line9> List<InputSplit> splits = new ArrayList<>(numSplits); <line10> for (int index = 0; index < numSplits - 1; index++) { <line11> splits.add(new InMemInputSplit(id, splitSize, nextSeed())); <line12> id += splitSize; <line13> } <line14> splits.add(new InMemInputSplit(id, nbTrees - id, nextSeed())); <line15> return splits; <line16> } <line17> } <line18> 	"<line6>      log.warn(""getSplits() was called more than once and the 'seed' is set, ""+ ""this can lead to no-repeatable behavior"");"	task4	
"public class A { <line0> public synchronized boolean saveDataHostIndexToZk(String dataHost, int curIndex) { <line1> boolean result = false; <line2> try { <line3> try { <line4> dnindexLock.acquire(30, TimeUnit.SECONDS); <line5> String path = ZKUtils.getZKBasePath() + ""bindata/dnindex.properties""; <line6> Map<String, String> propertyMap = new HashMap<>(); <line7> propertyMap.put(dataHost, String.valueOf(curIndex)); <line8> result = ZKUtils.writeProperty(path, propertyMap); <line9> } finally { <line10> dnindexLock.release(); <line11> } <line12> } catch (Exception e) { <line13> } <line14> return result; <line15> } <line16> } <line17> "	"<line13>      LOGGER.warn(""saveDataHostIndexToZk err:"", e);"	task4	
public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> WonMessage message = WonCamelHelper.getResponseRequired(exchange); <line3> URI parentURI = WonCamelHelper.getParentURIRequired(exchange); <line4> if (logger.isDebugEnabled()) { <line5> } <line6> messageService.saveMessage(message, parentURI); <line7> } <line8> } <line9> 	"<line5>      logger.debug(""storing response message {}"", message.toStringForDebug(false));"	task4	
"public class A { <line0> @Test <line1> public void correctRecordsCompleteFile() throws Exception { <line2> try (AccumuloClient client = Accumulo.newClient().from(getClientProperties()).build()) { <line3> String table = ""table1""; <line4> client <line5> .tableOperations() <line6> .create( <line7> table, <line8> new NewTableConfiguration() <line9> .setProperties(singletonMap(Property.TABLE_REPLICATION.getKey(), ""true""))); <line10> try (BatchWriter bw = client.createBatchWriter(table)) { <line11> for (int i = 0; i < 10; i++) { <line12> Mutation m = new Mutation(Integer.toString(i)); <line13> m.put(new byte[0], new byte[0], new byte[0]); <line14> bw.addMutation(m); <line15> } <line16> } <line17> while (!ReplicationTable.isOnline(client)) { <line18> sleepUninterruptibly(MILLIS_BETWEEN_REPLICATION_TABLE_ONLINE_CHECKS, TimeUnit.MILLISECONDS); <line19> } <line20> assertTrue(""Replication table did not exist"", ReplicationTable.isOnline(client)); <line21> for (int i = 0; i < 5; i++) { <line22> if (client <line23> .securityOperations() <line24> .hasTablePermission(""root"", ReplicationTable.NAME, TablePermission.READ)) { <line25> break; <line26> } <line27> Thread.sleep(2000); <line28> } <line29> assertTrue( <line30> ""'root' user could not read the replication table"", <line31> client <line32> .securityOperations() <line33> .hasTablePermission(""root"", ReplicationTable.NAME, TablePermission.READ)); <line34> Set<String> replRows = new HashSet<>(); <line35> int attempts = 5; <line36> while (replRows.isEmpty() && attempts > 0) { <line37> try (Scanner scanner = ReplicationTable.getScanner(client)) { <line38> StatusSection.limit(scanner); <line39> for (Entry<Key, Value> entry : scanner) { <line40> Key k = entry.getKey(); <line41> String fileUri = k.getRow().toString(); <line42> try { <line43> new URI(fileUri); <line44> } catch (URISyntaxException e) { <line45> fail(""Expected a valid URI: "" + fileUri); <line46> } <line47> replRows.add(fileUri); <line48> } <line49> } <line50> } <line51> Set<String> wals = new HashSet<>(); <line52> attempts = 5; <line53> while (wals.isEmpty() && attempts > 0) { <line54> WalStateManager markers = new WalStateManager(getServerContext()); <line55> for (Entry<Path, WalState> entry : markers.getAllState().entrySet()) { <line56> wals.add(entry.getKey().toString()); <line57> } <line58> attempts--; <line59> } <line60> assertEquals(""Rows found: "" + replRows, 1, replRows.size()); <line61> replRows.removeAll(wals); <line62> assertEquals(2, wals.size()); <line63> assertEquals(0, replRows.size()); <line64> } <line65> } <line66> } <line67> "	"<line27>        log.info(""Could not read replication table, waiting and will retry"");"	task4	
public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture channelFuture) throws Exception { <line2> if (!channelFuture.isSuccess()) { <line3> statsLogger <line4> .getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE) <line5> .registerFailedEvent(MathUtils.elapsedMicroSec(writeStartNanos)); <line6> if (channelFuture.getCause() instanceof ClosedChannelException) { <line7> cb.operationComplete(ChannelRequestCompletionCode.ChannelClosedException, null); <line8> } else { <line9> cb.operationComplete(ChannelRequestCompletionCode.UnknownError, null); <line10> } <line11> } else { <line12> statsLogger <line13> .getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE) <line14> .registerSuccessfulEvent(MathUtils.elapsedMicroSec(writeStartNanos)); <line15> cb.operationComplete(ChannelRequestCompletionCode.OK, null); <line16> } <line17> } <line18> } <line19> 	"<line9>        LOG.warn(""Writing a request: {} to channel {} failed : cause = {}"",new Object[] {getBasicInfoFromRequest(request), channel, channelFuture.getCause().getMessage()});"	task4	
"public class A { <line0> private boolean sendCodeViaEmail() { <line1> try { <line2> backend.sendCode(settings.emailSecurityCodeMsgTemplate, false); <line3> return true; <line4> } catch (Exception e) { <line5> NotificationPopup.showError( <line6> msg.getMessage(""error""), msg.getMessage(""CredentialReset.resetNotPossible"")); <line7> onCancel(); <line8> return false; <line9> } <line10> } <line11> } <line12> "	"<line5>      log.warn(""Credential reset notification failed"", e);"	task4	
public class A { <line0> @Override <line1> public KuraMessage doDel(RequestHandlerContext context, KuraMessage reqMessage) <line2> throws KuraException { <line3> final List<String> resourcePath = extractResourcePath(reqMessage); <line4> KuraPayload reqPayload = reqMessage.getPayload(); <line5> if (resourcePath.size() != 2 <line6> || reqPayload.getBody() == null <line7> || reqPayload.getBody().length == 0 <line8> || !resourcePath.get(0).equals(KEYSTORES)) { <line9> throw new KuraException(KuraErrorCode.BAD_REQUEST); <line10> } <line11> if (resourcePath.get(1).equals(ENTRIES)) { <line12> String body = new String(reqPayload.getBody(), StandardCharsets.UTF_8); <line13> EntryInfo request = unmarshal(body, EntryInfo.class); <line14> if (request != null) { <line15> deleteKeyEntryInternal(request.getKeystoreServicePid(), request.getAlias()); <line16> return new KuraMessage(new KuraResponsePayload(200)); <line17> } else { <line18> throw new KuraException(KuraErrorCode.BAD_REQUEST); <line19> } <line20> } else { <line21> throw new KuraException(KuraErrorCode.BAD_REQUEST); <line22> } <line23> } <line24> } <line25> 	<line9>      logger.error(NONE_RESOURCE_FOUND_MESSAGE);	task4	
public class A { <line0> @Override <line1> public StreamsResultSet readCurrent() { <line2> StreamsResultSet result; <line3> try { <line4> lock.readLock().lock(); <line5> result = new StreamsResultSet(persistQueue); <line6> persistQueue = constructQueue(); <line7> } finally { <line8> lock.readLock().unlock(); <line9> } <line10> return result; <line11> } <line12> } <line13> 	"<line3>    LOGGER.debug(""Providing {} docs"", persistQueue.size());"	task4	
public class A { <line0> @Override <line1> public void accept(RedisMeta redisMeta) { <line2> if (!isInterestedInCluster(redisMeta.parent().parent())) { <line3> return; <line4> } <line5> instanceManager.getOrCreate(redisMeta).getCheckInfo().isMaster(redisMeta.isMaster()); <line6> } <line7> } <line8> 	"<line5>    logger.info(""[Redis-Change] {}, master: {}"", redisMeta, redisMeta.isMaster());"	task4	
"public class A { <line0> @Reference( <line1> policy = ReferencePolicy.DYNAMIC, <line2> policyOption = ReferencePolicyOption.GREEDY, <line3> target = ""(entity.model.name="" + ContextEntityModel.NAME + "")"", <line4> unbind = ""unbindFilterParser"") <line5> public void setFilterParser(FilterParser filterParser) { <line6> if (log.isInfoEnabled()) { <line7> } <line8> _filterParser = filterParser; <line9> } <line10> } <line11> "	"<line7>      log.info(""Binding "" + filterParser);"	task4	
public class A { <line0> public void writeDecimalType(String path, DecimalType value) throws OwException { <line1> OwserverPacket requestPacket = new OwserverPacket(OwserverMessageType.WRITE, path); <line2> requestPacket.appendPayload(String.valueOf(value)); <line3> OwserverPacket returnPacket = request(requestPacket); <line4> } <line5> } <line6> 	"<line4>    logger.trace(""wrote: {}, got: {} "", requestPacket, returnPacket);"	task4	
public class A { <line0> private void closeOnError() { <line1> connectionErrorCounter++; <line2> close(false); <line3> if (connectionErrorCounter > CONNECTION_MAX_RETRY) { <line4> owserverConnectionState = OwserverConnectionState.FAILED; <line5> tryingConnectionRecovery = false; <line6> thingHandlerCallback.reportConnectionState(owserverConnectionState); <line7> } else if (!tryingConnectionRecovery) { <line8> thingHandlerCallback.reportConnectionState(owserverConnectionState); <line9> } <line10> } <line11> } <line12> 	"<line4>      logger.debug(""OW connection state: set to failed as max retries exceeded."");"	task4	
public class A { <line0> public RulesValidator setRules(final String validationRuleFile) { <line1> try (final BufferedReader br = <line2> new BufferedReader( <line3> new InputStreamReader( <line4> new FileInputStream(validationRuleFile), StandardCharsets.UTF_8))) { <line5> processAssertions(br); <line6> } catch (final Exception ex) { <line7> } <line8> return this; <line9> } <line10> } <line11> 	"<line7>      log.error(""Error creating Drools base message validator."", ex);"	task4	
"public class A { <line0> @Override <line1> public UserDetails loadUserDetails(PreAuthenticatedAuthenticationToken token) <line2> throws UsernameNotFoundException { <line3> ApplicationUser user = (ApplicationUser) token.getPrincipal(); <line4> Set<GrantedAuthority> authorities = new HashSet<>(); <line5> authorities.addAll(securityHelper.mapRolesToFunctions(user.getRoles())); <line6> authorities.addAll(securityHelper.getUnrestrictedFunctions()); <line7> SecurityUserWrapper result = <line8> new SecurityUserWrapper(user.getUserId(), ""N/A"", true, true, true, true, authorities, user); <line9> return result; <line10> } <line11> } <line12> "	"<line9>    LOGGER.debug(""Loaded User: "" + result);"	task4	
"public class A { <line0> private void updateEntityInConfigStore(Entity oldEntity, Entity newEntity) { <line1> List<Entity> tokenList = new ArrayList<>(); <line2> try { <line3> configStore.initiateUpdate(newEntity); <line4> obtainEntityLocks(oldEntity, ""update"", tokenList); <line5> configStore.update(newEntity.getEntityType(), newEntity); <line6> } catch (Throwable e) { <line7> throw FalconWebException.newAPIException(e); <line8> } finally { <line9> ConfigurationStore.get().cleanupUpdateInit(); <line10> releaseEntityLocks(oldEntity.getName(), tokenList); <line11> } <line12> } <line13> } <line14> "	"<line7>      LOG.error(""Update failed"", e);"	task4	
public class A { <line0> private Field convertToField(String content) { <line1> try { <line2> switch (type) { <line3> case Type.INTEGER: <line4> case Type.LONG: <line5> case Type.UNSIGNED_LONG: <line6> long lvalue = Long.parseLong(content); <line7> return new LongField(fieldName, lvalue, LongField.TYPE_STORED); <line8> case Type.INT: <line9> case Type.UNSIGNED_INT: <line10> case Type.SHORT: <line11> case Type.UNSIGNED_SHORT: <line12> int ivalue = Integer.parseInt(content); <line13> return new IntField(fieldName, ivalue, IntField.TYPE_STORED); <line14> case Type.DECIMAL: <line15> case Type.DOUBLE: <line16> double dvalue = Double.parseDouble(content); <line17> return new DoubleField(fieldName, dvalue, DoubleField.TYPE_STORED); <line18> case Type.FLOAT: <line19> float fvalue = Float.parseFloat(content); <line20> return new FloatField(fieldName, fvalue, FloatField.TYPE_STORED); <line21> case Type.DATE: <line22> DateValue dv = new DateValue(content); <line23> long dl = dateToLong(dv); <line24> return new LongField(fieldName, dl, LongField.TYPE_STORED); <line25> case Type.TIME: <line26> TimeValue tv = new TimeValue(content); <line27> long tl = timeToLong(tv); <line28> return new LongField(fieldName, tl, LongField.TYPE_STORED); <line29> case Type.DATE_TIME: <line30> DateTimeValue dtv = new DateTimeValue(content); <line31> String dateStr = dateTimeToString(dtv); <line32> return new TextField(fieldName, dateStr, Field.Store.YES); <line33> default: <line34> return new TextField(fieldName, content, store ? Field.Store.YES : Field.Store.NO); <line35> } <line36> } catch (NumberFormatException | XPathException e) { <line37> } <line38> return null; <line39> } <line40> } <line41> 	"<line37>      LOG.trace(""Cannot convert field {} to type {}. Content was: {}"",fieldName,Type.getTypeName(type),content);"	task4	
public class A { <line0> public CreateProjectPage enterProjectId(String projectId) { <line1> enterText(readyElement(idField), projectId); <line2> return new CreateProjectPage(getDriver()); <line3> } <line4> } <line5> 	"<line1>    log.info(""Enter project ID {}"", projectId);"	task4	
public class A { <line0> @Override <line1> public double getDouble(Object bean, String param, double defaultValue) { <line2> double beanValue = defaultValue; <line3> if (bean != null) { <line4> try { <line5> Object value = BeanUtil.pojo.getProperty(bean, param); <line6> beanValue = _converter.toDoubleValue(value, defaultValue); <line7> } catch (Exception exception) { <line8> } <line9> } <line10> return beanValue; <line11> } <line12> } <line13> 	<line8>        log.error(exception, exception);	task4	
public class A { <line0> public boolean isDirectory() { <line1> return isDirectory; <line2> } <line3> } <line4> 	"<line1>    logger.trace(""[{}] isDirectory() -> {}"", name, isDirectory);"	task4	
"public class A { <line0> protected Response makeBearerError(BearerTokenError error) { <line1> String header = error.toWWWAuthenticateHeader(); <line2> return toResponse( <line3> Response.status(error.getHTTPStatusCode()).header(""WWW-Authenticate"", header)); <line4> } <line5> } <line6> "	"<line2>    log.debug(""Retuning OAuth bearer error response: "" + header);"	task4	
"public class A { <line0> private void buildNames(Set<Table> tables) { <line1> for (Table table : tables) { <line2> String graphqlName = NameConversions.toGraphql(table.name(), IdentifierType.TABLE); <line3> String clashingCqlName = entityNames.inverse().get(graphqlName); <line4> if (clashingCqlName != null) { <line5> String message = <line6> String.format( <line7> ""Couldn't convert table %s because its GraphQL name %s would collide with table %s"", <line8> table.name(), graphqlName, clashingCqlName); <line9> warnings.add(message); <line10> } else { <line11> if (!graphqlName.equals(table.name())) { <line12> warnings.add(String.format(""Table %s mapped as %s"", table.name(), graphqlName)); <line13> } <line14> entityNames.put(table.name(), graphqlName); <line15> columnNames.put(table.name(), buildColumnNames(table.columns())); <line16> } <line17> } <line18> } <line19> } <line20> "	<line10>        LOG.warn(message);	task4	
public class A { <line0> private void getServerProfileCompliancePreview() { <line1> ServerProfile serverProfile = this.serverProfileClient.getByName(SERVER_PROFILE_NAME).get(0); <line2> ServerProfileCompliancePreview compliance = <line3> serverProfileClient.getCompliancePreview(serverProfile.getResourceId()); <line4> } <line5> } <line6> 	"<line4>    LOGGER.info(""ServerProfileCompliancePreview object returned to client : ""+ JsonPrettyPrinter.print(compliance));"	task4	
"public class A { <line0> @Test <line1> void testFeedGetsUpdatedEvents() throws Exception { <line2> MockEndpoint endpoint = getMockEndpoint(""mock:results""); <line3> endpoint.expectedMessageCount(7); <line4> assertMockEndpointsSatisfied(); <line5> List<Exchange> list = endpoint.getReceivedExchanges(); <line6> String[] expectedTitles = { <line7> ""Speaking at the Irish Java Technology Conference on Thursday and Friday"", <line8> ""a great presentation on REST, JAX-WS and JSR 311"", <line9> ""my slides on ActiveMQ and Camel from last weeks Dublin Conference"", <line10> ""webcast today on Apache ActiveMQ"", <line11> ""Feedback on my Camel talk at the IJTC conference"", <line12> ""More thoughts on RESTful Message Queues"", <line13> ""ActiveMQ webinar archive available"" <line14> }; <line15> int counter = 0; <line16> for (Exchange exchange : list) { <line17> Entry entry = exchange.getIn().getBody(Entry.class); <line18> assertNotNull(entry, ""No entry found for exchange: "" + exchange); <line19> String expectedTitle = expectedTitles[counter]; <line20> String title = entry.getTitle(); <line21> assertEquals(expectedTitle, title, ""Title of message "" + counter); <line22> counter++; <line23> } <line24> } <line25> } <line26> "	"<line22>      LOG.debug(""<<<< {}"", entry);"	task4	
public class A { <line0> public SortedSet<String> queryAsSet(String sparqlQueryString, String variable) { <line1> ResultSet rs = null; <line2> try { <line3> String jsonString = query(sparqlQueryString); <line4> rs = SparqlQuery.convertJSONtoResultSet(jsonString); <line5> } catch (Exception e) { <line6> } <line7> return getStringSetForVariableFromResultSet(ResultSetFactory.makeRewindable(rs), variable); <line8> } <line9> } <line10> 	<line6>      logger.warn(e.getMessage());	task4	
public class A { <line0> @PermitAll <line1> @Override <line2> public void runAs(Session userSession, final Callable action) { <line3> if (userSession != null) { <line4> Subject.doAs( <line5> userSession.getSubject(), <line6> new PrivilegedAction<Void>() { <line7> @Override <line8> public Void run() { <line9> try { <line10> action.call(); <line11> } catch (Exception ex) { <line12> } <line13> return null; <line14> } <line15> }); <line16> } <line17> } <line18> } <line19> 	"<line12>                LOGGER.error(""**** Error!! Error running privileged action."", ex);"	task4	
public class A { <line0> @Override <line1> public Object convertFromString(Map context, String[] values, Class toClass) { <line2> if (values == null || values.length == 0 || values[0] == null || values[0].isEmpty()) { <line3> return null; <line4> } else { <line5> Calendar c = Calendar.getInstance(); <line6> c.setTimeInMillis(f.parseDateTime(values[0]).getMillis()); <line7> return c; <line8> } <line9> } <line10> } <line11> 	"<line2>    logger.debug(""convertFromString: values={}, toClass={}"", values, toClass);"	task4	
"public class A { <line0> private void checkTokenGenerationRequest(final TokenGenerationRequestDTO request) { <line1> final String origin = CommonConstants.AUTHORIZATION_URI + CommonConstants.OP_AUTH_TOKEN_URI; <line2> if (request.getConsumer() == null) { <line3> throw new BadPayloadException(""Consumer system is null"", HttpStatus.SC_BAD_REQUEST, origin); <line4> } <line5> checkSystemRequest(request.getConsumer(), origin, false); <line6> if (request.getConsumerCloud() != null <line7> && Utilities.isEmpty(request.getConsumerCloud().getOperator())) { <line8> throw new BadPayloadException( <line9> ""Consumer cloud's operator is null or blank"", HttpStatus.SC_BAD_REQUEST, origin); <line10> } <line11> if (request.getConsumerCloud() != null <line12> && Utilities.isEmpty(request.getConsumerCloud().getName())) { <line13> throw new BadPayloadException( <line14> ""Consumer cloud's name is null or blank"", HttpStatus.SC_BAD_REQUEST, origin); <line15> } <line16> if (request.getProviders() == null || request.getProviders().isEmpty()) { <line17> throw new BadPayloadException( <line18> ""Provider list is null or empty"", HttpStatus.SC_BAD_REQUEST, origin); <line19> } <line20> for (final TokenGenerationProviderDTO provider : request.getProviders()) { <line21> checkTokenGenerationProviderDTO(provider, origin); <line22> } <line23> if (Utilities.isEmpty(request.getService())) { <line24> throw new BadPayloadException(""Service is null or blank"", HttpStatus.SC_BAD_REQUEST, origin); <line25> } <line26> } <line27> } <line28> "	"<line1>    logger.debug(""checkTokenGenerationRequest started..."");"	task4	
"public class A { <line0> @Test <line1> public void add_failure() { <line2> IndexIndexer indexer = index.createIndexer(); <line3> setupHelper.getBackendAccessor().ensureIndexingOperationsFail(index.name()); <line4> CompletableFuture<?> future = <line5> indexer.add( <line6> referenceProvider(""1""), <line7> document -> document.addValue(index.binding().title, ""Document #1""), <line8> commitStrategy, <line9> refreshStrategy); <line10> Awaitility.await().until(future::isDone); <line11> assertThatFuture(future).isFailed(); <line12> try { <line13> setupHelper.cleanUp(); <line14> } catch (RuntimeException | IOException e) { <line15> } <line16> } <line17> } <line18> "	"<line15>      log.debug(""Expected error while shutting down Hibernate Search, caused by the deletion of an index"",e);"	task4	
public class A { <line0> protected void createOCFS2Sr(StorageFilerTO pool) throws XmlRpcException { <line1> OvmStoragePool.Details d = new OvmStoragePool.Details(); <line2> d.path = pool.getPath(); <line3> d.type = OvmStoragePool.OCFS2; <line4> d.uuid = pool.getUuid(); <line5> OvmStoragePool.create(_conn, d); <line6> } <line7> } <line8> 	"<line6>    logger.debug(String.format(""Created SR (mount point:%1$s)"", d.path));"	task4	
public class A { <line0> protected void writeCustomRequestHeaders(HttpRequest httpReq, Map<String, String> customHeaders) { <line1> if (customHeaders == null) { <line2> return; <line3> } <line4> for (Entry<String, String> header : customHeaders.entrySet()) { <line5> httpReq.getHeaders().set(header.getKey(), header.getValue()); <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.trace(""Added custom request header: {}: {}"", header.getValue(), header.getValue());"	task4	
public class A { <line0> @Override <line1> public void start(long offset) throws AdaptorException { <line2> try { <line3> bytesReceived = offset; <line4> connectionFactory = initializeConnectionFactory(brokerURL); <line5> connection = connectionFactory.createConnection(); <line6> if (topic != null) { <line7> initializeTopic(connection, topic, selector, new JMSListener()); <line8> } else if (queue != null) { <line9> initializeQueue(connection, queue, selector, new JMSListener()); <line10> } <line11> connection.start(); <line12> } catch (Exception e) { <line13> throw new AdaptorException(e); <line14> } <line15> } <line16> } <line17> 	"<line6>      log.info(""Starting JMS adaptor: ""+ adaptorID+ "" started on brokerURL=""+ brokerURL+ "", topic=""+ topic+ "", selector=""+ selector+ "", offset =""+ bytesReceived);"	task4	
"public class A { <line0> @Override <line1> public FlinkPod decorateFlinkPod(FlinkPod flinkPod) { <line2> final PodBuilder basicPodBuilder = new PodBuilder(flinkPod.getPodWithoutMainContainer()); <line3> final String serviceAccountName = <line4> KubernetesUtils.resolveUserDefinedValue( <line5> flinkConfig, <line6> KubernetesConfigOptions.JOB_MANAGER_SERVICE_ACCOUNT, <line7> kubernetesJobManagerParameters.getServiceAccount(), <line8> KubernetesUtils.getServiceAccount(flinkPod), <line9> ""service account""); <line10> if (flinkPod.getPodWithoutMainContainer().getSpec().getRestartPolicy() != null) { <line11> } <line12> basicPodBuilder <line13> .withApiVersion(API_VERSION) <line14> .editOrNewSpec() <line15> .withServiceAccount(serviceAccountName) <line16> .withServiceAccountName(serviceAccountName) <line17> .endSpec(); <line18> basicPodBuilder <line19> .editOrNewMetadata() <line20> .addToLabels(kubernetesJobManagerParameters.getLabels()) <line21> .addToAnnotations(kubernetesJobManagerParameters.getAnnotations()) <line22> .endMetadata() <line23> .editOrNewSpec() <line24> .addToImagePullSecrets(kubernetesJobManagerParameters.getImagePullSecrets()) <line25> .addToNodeSelector(kubernetesJobManagerParameters.getNodeSelector()) <line26> .addAllToTolerations( <line27> kubernetesJobManagerParameters.getTolerations().stream() <line28> .map(e -> KubernetesToleration.fromMap(e).getInternalResource()) <line29> .collect(Collectors.toList())) <line30> .endSpec(); <line31> final Container basicMainContainer = decorateMainContainer(flinkPod.getMainContainer()); <line32> return new FlinkPod.Builder(flinkPod) <line33> .withPod(basicPodBuilder.build()) <line34> .withMainContainer(basicMainContainer) <line35> .build(); <line36> } <line37> } <line38> "	"<line11>      logger.info(""The restart policy of JobManager pod will be overwritten to 'always' ""+ ""since it is controlled by the Kubernetes deployment."");"	task4	
"public class A { <line0> @Test <line1> public void testPostSettingExpectsOK() throws ParseException, IOException { <line2> String key = ""example_key""; <line3> String value = ""example_value""; <line4> JSONObject actual = <line5> (JSONObject) <line6> parser.parse( <line7> given() <line8> .formParam(""key"", key) <line9> .formParam(""value"", value) <line10> .expect() <line11> .statusCode(HttpStatus.SC_OK) <line12> .contentType(ContentType.JSON) <line13> .body(""key"", equalTo(key)) <line14> .body(""value"", equalTo(value)) <line15> .when() <line16> .post(rt.host(""setting"")) <line17> .asString()); <line18> } <line19> } <line20> "	<line18>    logger.info(actual.toJSONString());	task4	
public class A { <line0> @Override <line1> public Command modify(String uuid, Command data) { <line2> try { <line3> delete(uuid); <line4> data.setUUID(uuid); <line5> add(data); <line6> return data; <line7> } catch (Exception e) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	<line8>      LOG.error(Freedomotic.getStackTraceInfo(e));	task4	
"public class A { <line0> void updateCategory(String categoryUrl, String parentUrl, String name) throws IOException { <line1> Put request = new Put(categoryUrl, credentials); <line2> request.setAccept(APPLICATION_JSON); <line3> request.addString(""parent"", parentUrl); <line4> request.addString(""name"", name); <line5> String result = request.executeAsString(); <line6> if (request.isUnAuthorized()) <line7> throw new UnAuthorizedException(""Not authorized to update category "" + name, categoryUrl); <line8> if (request.isForbidden()) <line9> throw new ForbiddenException(""Forbidden to update category "" + name, categoryUrl); <line10> if (request.isNotFound()) throw new NotFoundException(""Category not found"", categoryUrl); <line11> if (request.isBadRequest()) <line12> throw new NotOwnerException(""Not owner of category to update"", categoryUrl); <line13> if (request.isPreconditionFailed()) <line14> throw new DuplicateNameException(""Category "" + name + "" already exists"", categoryUrl); <line15> if (!request.isSuccessful()) <line16> throw new IOException( <line17> ""PUT on "" <line18> + categoryUrl <line19> + "" with payload "" <line20> + parentUrl <line21> + ""/"" <line22> + name <line23> + "" not successful: "" <line24> + result); <line25> } <line26> } <line27> "	"<line1>    log.info(format(""Updating category %s to parent %s and name %s"", categoryUrl, parentUrl, name));"	task4	
public class A { <line0> private void wait(Thread thread) { <line1> long t0 = SystemClock.now(); <line2> long timeout = 1000L; <line3> while (SystemClock.now() - t0 < timeout && thread.isAlive()) { <line4> try { <line5> Thread.sleep(10); <line6> } catch (InterruptedException ignored) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line1>    logger.info(""Stopping thread {}..."", thread.getName());"	task4	
"public class A { <line0> @Override <line1> public void cmnRmMemberId(long drId, PersistentMemberID pmid) { <line2> DiskRegionView dr = getDiskRegionById(drId); <line3> if (dr != null) { <line4> if (!dr.rmOnlineMember(pmid)) { <line5> if (!dr.rmOfflineMember(pmid)) { <line6> dr.rmEqualMember(pmid); <line7> } <line8> } <line9> this.ifLiveRecordCount--; <line10> this.ifTotalRecordCount++; <line11> } else { <line12> if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY_VERBOSE)) { <line13> } else { <line14> throw new IllegalStateException(""bad disk region id""); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line13>        logger.trace(LogMarker.PERSIST_RECOVERY_VERBOSE, ""bad disk region id!"");"	task4	
public class A { <line0> @Override <line1> public boolean insert(PostgresPersistenceManager<J> pm, FeatureOfInterest foi) <line2> throws IncompleteEntityException { <line3> Map<Field, Object> insert = new HashMap<>(); <line4> insert.put(table.colName, foi.getName()); <line5> insert.put(table.colDescription, foi.getDescription()); <line6> insert.put(table.colProperties, new JsonValue(foi.getProperties())); <line7> String encodingType = foi.getEncodingType(); <line8> insert.put(table.colEncodingType, encodingType); <line9> EntityFactories.insertGeometry( <line10> insert, table.colFeature, table.colGeom, encodingType, foi.getFeature()); <line11> entityFactories.insertUserDefinedId(pm, insert, table.getId(), foi); <line12> DSLContext dslContext = pm.getDslContext(); <line13> Record1<J> result = <line14> dslContext.insertInto(table).set(insert).returningResult(table.getId()).fetchOne(); <line15> J generatedId = result.component1(); <line16> foi.setId(entityFactories.idFromObject(generatedId)); <line17> return true; <line18> } <line19> } <line20> 	"<line16>    LOGGER.debug(""Inserted FeatureOfInterest. Created id = {}."", generatedId);"	task4	
"public class A { <line0> @Test(timeout = 60 * 1000) <line1> public void automaticSplitWith250Same() throws Exception { <line2> final String tableName = getUniqueNames(1)[0]; <line3> try (AccumuloClient client = Accumulo.newClient().from(getClientProperties()).build()) { <line4> client.tableOperations().create(tableName); <line5> client <line6> .tableOperations() <line7> .setProperty(tableName, Property.TABLE_SPLIT_THRESHOLD.getKey(), ""10K""); <line8> client <line9> .tableOperations() <line10> .setProperty(tableName, Property.TABLE_FILE_COMPRESSION_TYPE.getKey(), ""none""); <line11> client <line12> .tableOperations() <line13> .setProperty(tableName, Property.TABLE_FILE_COMPRESSED_BLOCK_SIZE.getKey(), ""64""); <line14> client <line15> .tableOperations() <line16> .setProperty(tableName, Property.TABLE_MAX_END_ROW_SIZE.getKey(), ""1000""); <line17> BatchWriter batchWriter = client.createBatchWriter(tableName, new BatchWriterConfig()); <line18> byte[] data = <line19> new byte <line20> [(int) <line21> (ConfigurationTypeHelper.getFixedMemoryAsBytes( <line22> Property.TABLE_MAX_END_ROW_SIZE.getDefaultValue()) <line23> + 2)]; <line24> for (int i = 0; i < data.length - 1; i++) { <line25> data[i] = (byte) 'm'; <line26> } <line27> for (int i = 0; i < 250; i++) { <line28> data[data.length - 1] = (byte) i; <line29> Mutation m = new Mutation(data); <line30> m.put(""cf"", ""cq"", ""value""); <line31> batchWriter.addMutation(m); <line32> } <line33> batchWriter.close(); <line34> client.tableOperations().flush(tableName, new Text(), new Text(""z""), true); <line35> Thread.sleep(500); <line36> int count = 0; <line37> try (Scanner scanner = client.createScanner(tableName, Authorizations.EMPTY)) { <line38> for (Entry<Key, Value> entry : scanner) { <line39> Key k = entry.getKey(); <line40> data[data.length - 1] = (byte) count; <line41> String expected = new String(data, UTF_8); <line42> assertEquals(expected, k.getRow().toString()); <line43> assertEquals(""cf"", k.getColumnFamily().toString()); <line44> assertEquals(""cq"", k.getColumnQualifier().toString()); <line45> assertEquals(""value"", entry.getValue().toString()); <line46> count++; <line47> } <line48> } <line49> assertEquals(250, count); <line50> assertEquals(0, client.tableOperations().listSplits(tableName).size()); <line51> } <line52> } <line53> } <line54> "	"<line2>    log.info(""Automatic with 250 with same prefix"");"	task4	
"public class A { <line0> public MutablePortletParameters set(PortletParameters inParams) { <line1> checkNull(""params"", inParams); <line2> MutablePortletParameters oldparms = this.clone(); <line3> int ctr = 0; <line4> HashSet<String> remNames = new HashSet<String>(params.keySet()); <line5> boolean removed = params.keySet().retainAll(inParams.getNames()); <line6> if (removed && urlProvider != null) { <line7> remNames.removeAll(inParams.getNames()); <line8> for (String name : remNames) { <line9> urlProvider.removeParameter(windowId, name, type); <line10> } <line11> } <line12> for (String name : inParams.getNames()) { <line13> String[] vals = inParams.getValues(name).clone(); <line14> ctr++; <line15> params.put(name, vals); <line16> if (urlProvider != null) { <line17> urlProvider.setParameter(windowId, name, type, vals); <line18> } <line19> } <line20> if (isTrace) { <line21> StringBuilder txt = new StringBuilder(); <line22> txt.append(""Window ID: "") <line23> .append(windowId) <line24> .append("", Removed values from old map:  "") <line25> .append(removed) <line26> .append("", set "") <line27> .append(ctr) <line28> .append("" values.""); <line29> } <line30> return oldparms; <line31> } <line32> } <line33> "	<line29>      LOGGER.debug(txt.toString());	task4	
"public class A { <line0> private void loadLinkedReleasesRows(ResourceRequest request, ResourceResponse response) <line1> throws PortletException, IOException { <line2> final User user = UserCacheHolder.getUserFromRequest(request); <line3> String branchId = request.getParameter(PARENT_BRANCH_ID); <line4> request.setAttribute(PARENT_BRANCH_ID, branchId); <line5> ComponentService.Iface client = thriftClients.makeComponentClient(); <line6> if (branchId != null) { <line7> String id = branchId.split(""_"")[0]; <line8> try { <line9> Release release = client.getReleaseById(id, user); <line10> putDirectlyLinkedReleaseRelationsInRequest(request, release); <line11> } catch (TException e) { <line12> throw new PortletException(""cannot get projects"", e); <line13> } <line14> } else { <line15> putDirectlyLinkedReleaseRelationsInRequest(request, new Release()); <line16> } <line17> List<ReleaseLink> releaseLinkList = (List<ReleaseLink>) request.getAttribute(RELEASE_LIST); <line18> Set<String> releaseIds = <line19> releaseLinkList.stream().map(ReleaseLink::getId).collect(Collectors.toSet()); <line20> request.setAttribute(""relMainLineState"", fillMainLineState(releaseIds, client, user)); <line21> request.setAttribute( <line22> PortalConstants.PARENT_SCOPE_GROUP_ID, <line23> request.getParameter(PortalConstants.PARENT_SCOPE_GROUP_ID)); <line24> } <line25> } <line26> "	"<line12>        log.error(""Error getting projects!"", e);"	task4	
public class A { <line0> @Override <line1> public void aggregateTemporal( <line2> BinContext ctx, Vector spatialVector, int numSpatialObs, WritableVector temporalVector) { <line3> final float value = spatialVector.get(0); <line4> final float currentMax = temporalVector.get(0); <line5> if (value > currentMax) { <line6> temporalVector.set(0, value); <line7> for (int i = 0; i < numSetFeatures + 1; i++) { <line8> temporalVector.set(i + 1, spatialVector.get(i + 1)); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line4>    SystemUtils.LOG.info(""aggregateTemporal "" + ctx.getIndex() + "" onmaxvar contribution="" + value);"	task4	
public class A { <line0> public GetPQValuesResponse dequeueGetPQValuesResponse(final String correlationUid) <line1> throws OsgpException { <line2> return (GetPQValuesResponse) this.processResponse(correlationUid); <line3> } <line4> } <line5> 	"<line2>    LOGGER.debug(""dequeueGetPQValuesResponse called with correlation uid {}"", correlationUid);"	task4	
"public class A { <line0> @GET <line1> @Path(""{seriesId}/hasEvents.json"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @RestQuery( <line4> name = ""hasEvents"", <line5> description = ""Check if given series has events"", <line6> returnDescription = ""true if series has events, otherwise false"", <line7> pathParameters = { <line8> @RestParameter( <line9> name = ""seriesId"", <line10> isRequired = true, <line11> description = ""The series identifier"", <line12> type = Type.STRING) <line13> }, <line14> responses = { <line15> @RestResponse( <line16> responseCode = SC_BAD_REQUEST, <line17> description = ""The required form params were missing in the request.""), <line18> @RestResponse( <line19> responseCode = SC_NOT_FOUND, <line20> description = ""If the series has not been found.""), <line21> @RestResponse(responseCode = SC_OK, description = ""The access information "") <line22> }) <line23> public Response getSeriesEvents(@PathParam(""seriesId"") String seriesId) throws Exception { <line24> if (StringUtils.isBlank(seriesId)) <line25> return RestUtil.R.badRequest(""Path parameter series ID is missing""); <line26> long elementsCount = 0; <line27> try { <line28> EventSearchQuery query = <line29> new EventSearchQuery( <line30> securityService.getOrganization().getId(), securityService.getUser()); <line31> query.withSeriesId(seriesId); <line32> SearchResult<Event> result = searchIndex.getByQuery(query); <line33> elementsCount = result.getHitCount(); <line34> } catch (SearchIndexException e) { <line35> throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR); <line36> } <line37> JSONObject jsonReturnObj = new JSONObject(); <line38> jsonReturnObj.put(""hasEvents"", elementsCount > 0); <line39> return Response.ok(jsonReturnObj.toString()).build(); <line40> } <line41> } <line42> "	"<line35>      logger.warn(""Could not perform search query"", e);"	task4	
"public class A { <line0> protected static Collection<Generator> loadGenerators(KogitoBuildContext context) { <line1> Collection<CollectedResource> collectedResources = <line2> CollectedResourceProducer.fromPaths(context.getAppPaths().getPaths()); <line3> ServiceLoader<GeneratorFactory> generatorFactories = ServiceLoader.load(GeneratorFactory.class); <line4> List<Generator> generators = <line5> StreamSupport.stream(generatorFactories.spliterator(), false) <line6> .map(gf -> gf.create(context, collectedResources)) <line7> .sorted(Comparator.comparingInt(Generator::priority)) <line8> .collect(Collectors.toList()); <line9> if (LOGGER.isInfoEnabled()) { <line10> String generatorMessages = <line11> generators.stream().map(Generator::name).collect(Collectors.joining("", "")); <line12> } <line13> return generators; <line14> } <line15> } <line16> "	"<line12>      LOGGER.info(""Generator discovery performed, found [{}]"", generatorMessages);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private static ExtractedDocumentMetadata.Builder convertTitles( <line2> String id, Element titleGroup, ExtractedDocumentMetadata.Builder docMetaBuilder) { <line3> List<Element> titles = titleGroup.getChildren(""article-title""); <line4> if (!titles.isEmpty()) { <line5> if (titles.size() > 1) { <line6> } <line7> for (Element titleElem : titles) { <line8> String title = titleElem.getTextNormalize(); <line9> if (title != null && !title.isEmpty()) { <line10> docMetaBuilder.setTitle(title); <line11> break; <line12> } <line13> } <line14> } <line15> return docMetaBuilder; <line16> } <line17> } <line18> "	"<line6>        log.warn(""got multiple titles for document "" + id + "", storing first title only"");"	task4	
"public class A { <line0> private static SimpleFeatureType getSimpleFeatureType() { <line1> SimpleFeatureType type = null; <line2> try { <line3> type = <line4> DataUtilities.createType( <line5> ""testCityData"", <line6> CITY_ATTRIBUTE <line7> + "":String,"" <line8> + STATE_ATTRIBUTE <line9> + "":String,"" <line10> + POPULATION_ATTRIBUTE <line11> + "":Double,"" <line12> + LAND_AREA_ATTRIBUTE <line13> + "":Double,"" <line14> + GEOMETRY_ATTRIBUTE <line15> + "":Geometry""); <line16> } catch (final SchemaException e) { <line17> } <line18> return type; <line19> } <line20> } <line21> "	"<line17>      LOGGER.error(""Unable to create SimpleFeatureType"", e);"	task4	
"public class A { <line0> private StringBuilder addFlowFileProcessorFingerprint( <line1> final StringBuilder builder, final Element processorElem) throws FingerprintException { <line2> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""id"")); <line3> appendFirstValue( <line4> builder, DomUtils.getChildNodesByTagName(processorElem, ""versionedComponentId"")); <line5> final NodeList childNodes = DomUtils.getChildNodesByTagName(processorElem, ""class""); <line6> final String className = childNodes.item(0).getTextContent(); <line7> appendFirstValue(builder, childNodes); <line8> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""annotationData"")); <line9> final BundleDTO bundle = <line10> FlowFromDOMFactory.getBundle(DomUtils.getChild(processorElem, ""bundle"")); <line11> addBundleFingerprint(builder, bundle); <line12> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""maxConcurrentTasks"")); <line13> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""schedulingPeriod"")); <line14> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""penalizationPeriod"")); <line15> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""yieldPeriod"")); <line16> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""bulletinLevel"")); <line17> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""lossTolerant"")); <line18> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""schedulingStrategy"")); <line19> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""executionNode"")); <line20> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""runDurationNanos"")); <line21> final BundleCoordinate coordinate = getCoordinate(className, bundle); <line22> final ConfigurableComponent configurableComponent = <line23> extensionManager.getTempComponent(className, coordinate); <line24> if (configurableComponent == null) { <line25> } <line26> final NodeList propertyElems = DomUtils.getChildNodesByTagName(processorElem, ""property""); <line27> final List<Element> sortedPropertyElems = <line28> sortElements(propertyElems, getProcessorPropertiesComparator()); <line29> for (final Element propertyElem : sortedPropertyElems) { <line30> final String propName = <line31> DomUtils.getChildElementsByTagName(propertyElem, ""name"").get(0).getTextContent(); <line32> String propValue = <line33> getFirstValue(DomUtils.getChildNodesByTagName(propertyElem, ""value""), null); <line34> addPropertyFingerprint(builder, configurableComponent, propName, propValue); <line35> } <line36> final NodeList autoTerminateElems = <line37> DomUtils.getChildNodesByTagName(processorElem, ""autoTerminatedRelationship""); <line38> final List<Element> sortedAutoTerminateElems = <line39> sortElements(autoTerminateElems, getElementTextComparator()); <line40> for (final Element autoTerminateElem : sortedAutoTerminateElems) { <line41> builder.append(autoTerminateElem.getTextContent()); <line42> } <line43> return builder; <line44> } <line45> } <line46> "	"<line25>      logger.warn(""Unable to get Processor of type {}; its default properties will be fingerprinted instead""+ "" of being ignored."",className);"	task4	
"public class A { <line0> @Test <line1> public void shouldReturnNotActiveOnUnknownToken() throws Exception { <line2> TokensManagement tokensManagement = new MockTokensMan(); <line3> TokenIntrospectionResource tested = createIntrospectionResource(tokensManagement); <line4> setupInvocationContext(111); <line5> Response r = tested.introspectToken(""UNKNOWN-TOKEN""); <line6> assertEquals(HTTPResponse.SC_OK, r.getStatus()); <line7> JSONObject parsed = (JSONObject) JSONValue.parse((r.getEntity().toString())); <line8> assertThat(parsed.getAsString(""active"")).isEqualTo(""false""); <line9> assertThat(parsed.size()).isEqualTo(1); <line10> } <line11> } <line12> "	"<line8>    log.info(""{}"", parsed);"	task4	
"public class A { <line0> private void initializeLogging() throws ServletException { <line1> Context initialContext; <line2> String customLogLocation; <line3> final String defaultLogLocation = ""classpath:logback-config.xml""; <line4> try { <line5> initialContext = new InitialContext(); <line6> customLogLocation = (String) initialContext.lookup(this.logConfig); <line7> if (new File(customLogLocation).exists()) { <line8> this.initializeLoggingContext(customLogLocation); <line9> } else { <line10> this.initializeLoggingContext(defaultLogLocation); <line11> } <line12> } catch (final NamingException | FileNotFoundException | JoranException e) { <line13> throw new ServletException(e); <line14> } <line15> } <line16> } <line17> "	"<line13>      this.logger.info(""Failed to initialize logging using {} or {}"", this.logConfig, defaultLogLocation, e);"	task4	
"public class A { <line0> private GetRouterMonitorResultsAnswer parseLinesForHealthChecks( <line1> GetRouterMonitorResultsCommand cmd, String executionResult) { <line2> List<String> failingChecks = new ArrayList<>(); <line3> StringBuilder monitorResults = new StringBuilder(); <line4> String[] lines = executionResult.trim().split(""\n""); <line5> boolean readingFailedChecks = false, readingMonitorResults = false; <line6> for (String line : lines) { <line7> line = line.trim(); <line8> if (line.contains(""FAILING CHECKS"")) { <line9> readingFailedChecks = true; <line10> readingMonitorResults = false; <line11> } else if (line.contains(""MONITOR RESULTS"")) { <line12> readingFailedChecks = false; <line13> readingMonitorResults = true; <line14> } else if (readingFailedChecks && !readingMonitorResults) { <line15> failingChecks.addAll(getFailingChecks(line)); <line16> } else if (!readingFailedChecks && readingMonitorResults) { <line17> monitorResults.append(line); <line18> } else { <line19> } <line20> } <line21> return new GetRouterMonitorResultsAnswer(cmd, true, failingChecks, monitorResults.toString()); <line22> } <line23> } <line24> "	"<line19>        logger.error(""Unexpected lines reached while parsing health check response. Skipping line:- ""+ line);"	task4	
"public class A { <line0> private void identifyDuplicateGroupNames(final Collection<Group> groups) { <line1> final List<String> groupNames = new ArrayList<String>(); <line2> for (final Group group : groups) { <line3> if (groupNames.contains(group.getName())) { <line4> throw new WroRuntimeException(""Duplicate group name detected: "" + group.getName()); <line5> } <line6> groupNames.add(group.getName()); <line7> } <line8> } <line9> } <line10> "	"<line1>    LOG.debug(""identifyDuplicateGroupNames"");"	task4	
"public class A { <line0> private List<String> queryPatientsByLabelAndEid(String label, String id) throws QueryException { <line1> Query q = null; <line2> try { <line3> q = <line4> this.qm.createQuery( <line5> ""select doc.name from Document doc, doc.object(PhenoTips.LabeledIdentifierClass) obj "" <line6> + ""where obj.label = :label and obj.value = :value"", <line7> Query.XWQL); <line8> q.bindValue(KEY_LABEL, label); <line9> q.bindValue(KEY_VALUE, id); <line10> return q.execute(); <line11> } catch (QueryException ex) { <line12> throw new QueryException(ex.getMessage(), q, ex); <line13> } <line14> } <line15> } <line16> "	"<line12>      this.logger.warn(""Failed to query patient documents with label [{}] and corresponding external ID [{}]:""+ "" {}"",label,id,ex.getMessage(),ex);"	task4	
"public class A { <line0> private SubscriptionPath createRandomSubscription(PipelineOptions options) { <line1> TopicPath topicPath = topic.get(); <line2> ProjectPath projectPath; <line3> if (project != null) { <line4> projectPath = project.get(); <line5> } else { <line6> String projectId = options.as(GcpOptions.class).getProject(); <line7> checkState( <line8> projectId != null, <line9> ""Cannot create subscription to topic %s because pipeline option 'project' not specified"", <line10> topicPath); <line11> projectPath = PubsubClient.projectPathFromId(options.as(GcpOptions.class).getProject()); <line12> } <line13> try { <line14> try (PubsubClient pubsubClient = <line15> pubsubFactory.newClient( <line16> timestampAttribute, idAttribute, options.as(PubsubOptions.class))) { <line17> SubscriptionPath subscriptionPath = <line18> pubsubClient.createRandomSubscription(projectPath, topicPath, DEAULT_ACK_TIMEOUT_SEC); <line19> return subscriptionPath; <line20> } <line21> } catch (Exception e) { <line22> throw new RuntimeException( <line23> String.format( <line24> ""Failed to create subscription to topic %s on project %s: %s"", <line25> topicPath, projectPath, e.getMessage()), <line26> e); <line27> } <line28> } <line29> } <line30> "	"<line19>        LOG.warn(""Created subscription {} to topic {}.""+ "" Note this subscription WILL NOT be deleted when the pipeline terminates"",subscriptionPath,topic);"	task4	
public class A { <line0> private void scheduleConnectionMonitorJob() { <line1> connectionMonitorJob = <line2> scheduler.scheduleWithFixedDelay( <line3> connectionMonitorRunnable, <line4> CONNECTION_MONITOR_START_DELAY, <line5> CONNECTION_MONITOR_FREQUENCY, <line6> TimeUnit.SECONDS); <line7> } <line8> } <line9> 	"<line1>    logger.debug(""Starting connection monitor job for thing {} at IP {}"",thingID(),commandConnection.getIP());"	task4	
"public class A { <line0> public void logPerformance() { <line1> final ComponentLog logger = getLogger(); <line2> if (!logger.isDebugEnabled()) { <line3> return; <line4> } <line5> final long earliestTimestamp = performanceTracker.getEarliestTimestamp(); <line6> final long millis = System.currentTimeMillis() - earliestTimestamp; <line7> final long seconds = TimeUnit.MILLISECONDS.toSeconds(millis); <line8> for (final DiskOperation operation : DiskOperation.values()) { <line9> final OperationStatistics stats = performanceTracker.getOperationStatistics(operation); <line10> final StringBuilder sb = new StringBuilder(); <line11> if (stats.getCount() == 0) { <line12> sb.append(""Over the past "") <line13> .append(seconds) <line14> .append("" seconds, for Operation '"") <line15> .append(operation) <line16> .append(""' there were no operations performed""); <line17> } else { <line18> sb.append(""Over the past "") <line19> .append(seconds) <line20> .append("" seconds, For Operation '"") <line21> .append(operation) <line22> .append(""' there were "") <line23> .append(stats.getCount()) <line24> .append("" operations performed with an average time of "") <line25> .append(stats.getAverage()) <line26> .append("" milliseconds; Standard Deviation = "") <line27> .append(stats.getStandardDeviation()) <line28> .append("" millis; Min Time = "") <line29> .append(stats.getMin()) <line30> .append("" millis, Max Time = "") <line31> .append(stats.getMax()) <line32> .append("" millis""); <line33> if (logger.isDebugEnabled()) { <line34> final Map<String, Long> outliers = stats.getOutliers(); <line35> sb.append(""; "").append(stats.getOutliers().size()).append("" significant outliers: ""); <line36> sb.append(outliers); <line37> } <line38> } <line39> } <line40> performanceLoggingTimestamp = System.currentTimeMillis(); <line41> } <line42> } <line43> "	<line39>      logger.debug(sb.toString());	task4	
public class A { <line0> public void unset() { <line1> final LinkedList<Type> universeList = CURRENT_UNIVERSE.get(); <line2> if (universeList != null && !universeList.isEmpty()) { <line3> universeList.removeLast(); <line4> if (LOGGER.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        LOGGER.debug(""Restored universe: "" + Thread.currentThread());"	task4	
public class A { <line0> @Override <line1> public State calcState(Device dev) { <line2> TellstickDevice device = (TellstickDevice) dev; <line3> State st = null; <line4> switch (device.getStatus()) { <line5> case JNA.CLibrary.TELLSTICK_TURNON: <line6> st = OnOffType.ON; <line7> break; <line8> case JNA.CLibrary.TELLSTICK_TURNOFF: <line9> st = OnOffType.OFF; <line10> break; <line11> case JNA.CLibrary.TELLSTICK_DIM: <line12> BigDecimal dimValue = new BigDecimal(device.getData()); <line13> if (dimValue.intValue() == 0) { <line14> st = OnOffType.OFF; <line15> } else if (dimValue.intValue() >= 255) { <line16> st = OnOffType.ON; <line17> } else { <line18> st = OnOffType.ON; <line19> } <line20> break; <line21> default: <line22> } <line23> return st; <line24> } <line25> } <line26> 	"<line22>        logger.warn(""Could not handle {} for {}"", device.getStatus(), device);"	task4	
"public class A { <line0> public static long getOpenFileHandlesLimit() { <line1> if (OperatingSystem.isWindows()) { <line2> return -1L; <line3> } <line4> Class<?> sunBeanClass; <line5> try { <line6> sunBeanClass = Class.forName(""com.sun.management.UnixOperatingSystemMXBean""); <line7> } catch (ClassNotFoundException e) { <line8> return -1L; <line9> } <line10> try { <line11> Method fhLimitMethod = sunBeanClass.getMethod(""getMaxFileDescriptorCount""); <line12> Object result = fhLimitMethod.invoke(ManagementFactory.getOperatingSystemMXBean()); <line13> return (Long) result; <line14> } catch (Throwable t) { <line15> return -1L; <line16> } <line17> } <line18> } <line19> "	"<line15>      LOG.warn(""Unexpected error when accessing file handle limit"", t);"	task4	
public class A { <line0> boolean retractLiveEvent(MediaPackage mp) throws LiveScheduleException { <line1> retract(mp); <line2> try { <line3> String mpId = mp.getIdentifier().toString(); <line4> Snapshot snapshot = getSnapshot(mpId); <line5> MediaPackage archivedMp = snapshot.getMediaPackage(); <line6> removeLivePublicationChannel(archivedMp); <line7> snapshotVersionCache.put(mpId, assetManager.takeSnapshot(archivedMp).getVersion()); <line8> } catch (LiveScheduleException e) { <line9> } <line10> return true; <line11> } <line12> } <line13> 	"<line7>      logger.debug(""Removed live pub channel from archived media package {}"", mp);"	task4	
"public class A { <line0> protected void checkAndAddSpatialFilteringProfileCriterion( <line1> Criteria c, GetObservationRequest request, Session session, StringBuilder logArgs) <line2> throws OwsExceptionReport { <line3> if (request.hasSpatialFilteringProfileSpatialFilter()) { <line4> if (getGeometryHandler().isSpatialDatasource()) { <line5> c.add( <line6> SpatialRestrictions.filter( <line7> DataEntity.PROPERTY_GEOMETRY_ENTITY, <line8> ((GetObservationRequest) request).getSpatialFilter().getOperator(), <line9> getGeometryHandler() <line10> .switchCoordinateAxisFromToDatasourceIfNeeded( <line11> ((GetObservationRequest) request).getSpatialFilter().getGeometry()))); <line12> logArgs.append("", spatialFilter""); <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> "	"<line14>        LOGGER.warn(""Spatial filtering for lat/lon is not yet implemented!"");"	task4	
public class A { <line0> @Override <line1> public void onContainerStarted( <line2> ContainerId containerId, Map<String, ByteBuffer> allServiceResponse) { <line3> controller.containerStarted(containerId); <line4> } <line5> } <line6> 	"<line3>    LOG.trace(""NM: Container started: "" + containerId);"	task4	
public class A { <line0> @Override <line1> public void execute(Runnable command) { <line2> this.runnables.add(command); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Adding command {}"", command);"	task4	
public class A { <line0> private String getOxTrustImportPersonConfiguration( <line1> ImportPersonConfig oxTrustImportPersonConfiguration) { <line2> try { <line3> if (oxTrustImportPersonConfiguration != null) { <line4> return jsonService.objectToJson(oxTrustImportPersonConfiguration); <line5> } <line6> return null; <line7> } catch (Exception ex) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line8>      log.error(""Failed to prepare JSON from ImportPersonConfig: '{}'"",oxTrustImportPersonConfiguration,ex);"	task4	
public class A { <line0> public void stopThread() { <line1> CallMonitorThread thread = this.monitorThread; <line2> if (thread != null) { <line3> thread.interrupt(); <line4> monitorThread = null; <line5> } <line6> } <line7> } <line8> 	"<line1>    logger.debug(""Stopping Call Monitor thread..."");"	task4	
public class A { <line0> private void scheduleFlush() throws HyracksDataException { <line1> ILSMIndex selectedIndex = null; <line2> synchronized (GlobalVirtualBufferCache.this) { <line3> while (flushingIndexes.size() < maxConcurrentFlushes <line4> && ((selectedIndex = selectFlushIndex()) != null)) { <line5> flushingIndexes.add(selectedIndex); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line5>        LOGGER.debug(""Waiting for flushing primary index {} to complete..."", selectedIndex);"	task4	
public class A { <line0> @Override <line1> public void query( <line2> String deviceId, <line3> String startTs, <line4> String endTs, <line5> String notification, <line6> String sortField, <line7> String sortOrderSt, <line8> Integer take, <line9> Integer skip, <line10> @Suspended final AsyncResponse asyncResponse) { <line11> final Date timestampSt = TimestampQueryParamParser.parse(startTs); <line12> final Date timestampEnd = TimestampQueryParamParser.parse(endTs); <line13> DeviceVO byIdWithPermissionsCheck = deviceService.findById(deviceId); <line14> if (byIdWithPermissionsCheck == null) { <line15> ErrorResponse errorCode = <line16> new ErrorResponse( <line17> NOT_FOUND.getStatusCode(), String.format(Messages.DEVICE_NOT_FOUND, deviceId)); <line18> Response response = ResponseFactory.response(NOT_FOUND, errorCode); <line19> asyncResponse.resume(response); <line20> } else { <line21> Set<String> notificationNames = <line22> StringUtils.isNoneEmpty(notification) <line23> ? Collections.singleton(notification) <line24> : Collections.emptySet(); <line25> notificationService <line26> .find( <line27> Collections.singleton(deviceId), <line28> notificationNames, <line29> timestampSt, <line30> timestampEnd, <line31> sortField, <line32> sortOrderSt, <line33> take, <line34> skip) <line35> .thenApply( <line36> notifications -> <line37> ResponseFactory.response( <line38> OK, notifications, JsonPolicyDef.Policy.NOTIFICATION_TO_CLIENT)) <line39> .thenAccept(asyncResponse::resume); <line40> } <line41> } <line42> } <line43> 	"<line11>    logger.debug(""Device notification query requested for device {}"", deviceId);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> if (!hooked.isEmpty()) { <line3> final StringBuilder string = new StringBuilder(); <line4> for (final String plugin : hooked) { <line5> string.append(plugin).append("", ""); <line6> } <line7> final String plugins = string.substring(0, string.length() - 2); <line8> } <line9> } <line10> } <line11> "	"<line8>      LOG.info(null, ""Hooked into "" + plugins + ""!"");"	task4	
public class A { <line0> public void passivateObject(LdapConnection connection) { <line1> } <line2> } <line3> 	"<line1>    log.debug(""passivate connection: {}"", connection);"	task4	
public class A { <line0> private boolean isPolicyValid(EDXLDistribution body, AssertionType assertion) { <line1> boolean result = false; <line2> if (body != null) { <line3> result = policyChecker.checkIncomingPolicy(body, assertion); <line4> } else { <line5> } <line6> return result; <line7> } <line8> } <line9> 	"<line5>      LOG.warn(""Admin Dist request body was null"");"	task4	
"public class A { <line0> public void testCreateTemporaryQueueThenCreateAQueueFromItsName() throws Exception { <line1> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line2> Queue tempQueue = session.createTemporaryQueue(); <line3> String name = tempQueue.getQueueName(); <line4> Queue createdQueue = session.createQueue(name); <line5> assertEquals(""created queue not equal to temporary queue"", tempQueue, createdQueue); <line6> } <line7> } <line8> "	"<line4>    LOG.info(""Created queue named: "" + name);"	task4	
"public class A { <line0> public static ActivityStreamInfo unmarshalInfo(String xml) throws ApsSystemException { <line1> ActivityStreamInfo bodyObject = null; <line2> try { <line3> JAXBContext context = JAXBContext.newInstance(ActivityStreamInfo.class); <line4> Unmarshaller unmarshaller = context.createUnmarshaller(); <line5> ByteArrayInputStream is = new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)); <line6> bodyObject = (ActivityStreamInfo) unmarshaller.unmarshal(is); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error unmarshalling activity stream info config"", t); <line9> } <line10> return bodyObject; <line11> } <line12> } <line13> "	"<line8>      logger.error(""Error unmarshalling activity stream info config. xml: {}"", xml, t);"	task4	
public class A { <line0> @Override <line1> public void runAtDriver(RuntimeContainer container) { <line2> if (container != null) { <line3> DatabaseClient containerClient = <line4> (DatabaseClient) <line5> container.getComponentData( <line6> properties.getReferencedComponentId(), MarkLogicConnection.CONNECTION); <line7> if (containerClient != null) { <line8> containerClient.release(); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line9>        LOGGER.info(""Connection released"");"	task4	
public class A { <line0> @Override <line1> public void accept(AisMessage message) { <line2> try { <line3> queue.push(message); <line4> } catch (MessageQueueOverflowException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.error(""Message queue overflow, dropping message: "" + e.getMessage());"	task4	
"public class A { <line0> private MessageEvent unexpectedError(Exception exception) { <line1> MessageEvent msg = new MessageEvent(MessageEventEnum.DATA_OPERATION_ERROR_UNEXPECTED); <line2> msg.setDescription(msg.getDescription().replace(""%DESCRIPTION%"", exception.toString())); <line3> return msg; <line4> } <line5> } <line6> "	"<line1>    LOG.error(""Unable to execute query : "" + exception.toString());"	task4	
"public class A { <line0> private Firehose connectInternal( <line1> StringInputRowParser firehoseParser, <line2> @Nullable File temporaryDirectory, <line3> FetchConfig fetchConfig, <line4> CacheManager cacheManager) <line5> throws IOException { <line6> if (objects == null) { <line7> objects = ImmutableList.copyOf(Preconditions.checkNotNull(initObjects(), ""objects"")); <line8> } <line9> if (cacheManager.isEnabled() || fetchConfig.getMaxFetchCapacityBytes() > 0) { <line10> Preconditions.checkNotNull(temporaryDirectory, ""temporaryDirectory""); <line11> Preconditions.checkArgument( <line12> temporaryDirectory.exists(), ""temporaryDirectory[%s] does not exist"", temporaryDirectory); <line13> Preconditions.checkArgument( <line14> temporaryDirectory.isDirectory(), <line15> ""temporaryDirectory[%s] is not a directory"", <line16> temporaryDirectory); <line17> } <line18> final ExecutorService fetchExecutor = Execs.singleThreaded(""firehose_fetch_%d""); <line19> final FileFetcher<T> fetcher = <line20> new FileFetcher<T>( <line21> cacheManager, <line22> objects, <line23> fetchExecutor, <line24> temporaryDirectory, <line25> fetchConfig, <line26> new ObjectOpenFunction<T>() { <line27> @Override <line28> public InputStream open(T object) throws IOException { <line29> return openObjectStream(object); <line30> } <line31>  <line32> @Override <line33> public InputStream open(T object, long start) throws IOException { <line34> return openObjectStream(object, start); <line35> } <line36> }, <line37> getRetryCondition()); <line38> return new FileIteratingFirehose( <line39> new Iterator<LineIterator>() { <line40> @Override <line41> public boolean hasNext() { <line42> return fetcher.hasNext(); <line43> } <line44>  <line45> @Override <line46> public LineIterator next() { <line47> if (!hasNext()) { <line48> throw new NoSuchElementException(); <line49> } <line50> final OpenObject<T> openObject = fetcher.next(); <line51> try { <line52> return new ResourceCloseableLineIterator( <line53> new InputStreamReader( <line54> wrapObjectStream(openObject.getObject(), openObject.getObjectStream()), <line55> StandardCharsets.UTF_8), <line56> openObject.getResourceCloser()); <line57> } catch (IOException e) { <line58> try { <line59> openObject.getResourceCloser().close(); <line60> } catch (Throwable t) { <line61> e.addSuppressed(t); <line62> } <line63> throw new RuntimeException(e); <line64> } <line65> } <line66> }, <line67> firehoseParser, <line68> () -> { <line69> fetchExecutor.shutdownNow(); <line70> try { <line71> Preconditions.checkState( <line72> fetchExecutor.awaitTermination( <line73> fetchConfig.getFetchTimeout(), TimeUnit.MILLISECONDS)); <line74> } catch (InterruptedException e) { <line75> Thread.currentThread().interrupt(); <line76> throw new ISE(""Failed to shutdown fetch executor during close""); <line77> } <line78> }); <line79> } <line80> } <line81> "	"<line18>    LOG.info(""Create a new firehose for [%d] objects"", objects.size());"	task4	
"public class A { <line0> @Override <line1> public void executeImpl(DelegateExecution execution) throws Exception { <line2> String contentTypeString = <line3> activitiHelper <line4> .getRequiredExpressionVariableAsString(contentType, execution, ""ContentType"") <line5> .trim(); <line6> String requestString = <line7> activitiHelper <line8> .getRequiredExpressionVariableAsString( <line9> businessObjectDataStorageFilesCreateRequest, <line10> execution, <line11> ""BusinessObjectDataCreateRequest"") <line12> .trim(); <line13> BusinessObjectDataStorageFilesCreateRequest request = <line14> getRequestObject( <line15> contentTypeString, requestString, BusinessObjectDataStorageFilesCreateRequest.class); <line16> BusinessObjectDataStorageFilesCreateResponse businessObjectDataStorageFilesCreateResponse = <line17> businessObjectDataStorageFileService.createBusinessObjectDataStorageFiles(request); <line18> setJsonResponseAsWorkflowVariable(businessObjectDataStorageFilesCreateResponse, execution); <line19> } <line20> } <line21> "	"<line16>    LOGGER.info(""inside4 AddBusinessObjectDataStorageFiles"");"	task4	
public class A { <line0> @Override <line1> public void clearCache() { <line2> aclClassCache.invalidateAll(); <line3> } <line4> } <line5> 	"<line2>    LOGGER.debug(""Invalidate cache."");"	task4	
public class A { <line0> private Map<Integer, BookieId> getReplacementBookiesByIndexes( <line1> LedgerHandle lh, <line2> List<BookieId> ensemble, <line3> Set<Integer> bookieIndexesToRereplicate, <line4> Optional<Set<BookieId>> excludedBookies) <line5> throws BKException.BKNotEnoughBookiesException { <line6> Map<Integer, BookieId> targetBookieAddresses = <line7> Maps.newHashMapWithExpectedSize(bookieIndexesToRereplicate.size()); <line8> Set<BookieId> bookiesToExclude = Sets.newHashSet(); <line9> if (excludedBookies.isPresent()) { <line10> bookiesToExclude.addAll(excludedBookies.get()); <line11> } <line12> for (Integer bookieIndex : bookieIndexesToRereplicate) { <line13> BookieId bookie = ensemble.get(bookieIndex); <line14> bookiesToExclude.add(bookie); <line15> } <line16> for (Integer bookieIndex : bookieIndexesToRereplicate) { <line17> BookieId oldBookie = ensemble.get(bookieIndex); <line18> EnsemblePlacementPolicy.PlacementResult<BookieId> replaceBookieResponse = <line19> bkc.getPlacementPolicy() <line20> .replaceBookie( <line21> lh.getLedgerMetadata().getEnsembleSize(), <line22> lh.getLedgerMetadata().getWriteQuorumSize(), <line23> lh.getLedgerMetadata().getAckQuorumSize(), <line24> lh.getLedgerMetadata().getCustomMetadata(), <line25> ensemble, <line26> oldBookie, <line27> bookiesToExclude); <line28> BookieId newBookie = replaceBookieResponse.getResult(); <line29> PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy = <line30> replaceBookieResponse.isAdheringToPolicy(); <line31> if (isEnsembleAdheringToPlacementPolicy == PlacementPolicyAdherence.FAIL) { <line32> if (LOG.isDebugEnabled()) { <line33> } <line34> } <line35> targetBookieAddresses.put(bookieIndex, newBookie); <line36> bookiesToExclude.add(newBookie); <line37> } <line38> return targetBookieAddresses; <line39> } <line40> } <line41> 	"<line33>          LOG.debug(""replaceBookie for bookie: {} in ensemble: {} ""+ ""is not adhering to placement policy and chose {}"",oldBookie,ensemble,newBookie);"	task4	
"public class A { <line0> public String readInputResource(String path) { <line1> try { <line2> File inputFile = getInputResourcesTestDir().toPath().resolve(path).toFile(); <line3> if (!inputFile.exists()) { <line4> if (shouldCreateInputTestFiles()) { <line5> inputFile.getParentFile().mkdirs(); <line6> Files.write(""<replace with test data>"", inputFile, StandardCharsets.UTF_8); <line7> } <line8> } <line9> return Files.toString(inputFile, StandardCharsets.UTF_8); <line10> } catch (IOException e) { <line11> throw new UncheckedIOException(e); <line12> } <line13> } <line14> } <line15> "	"<line4>        logger.info(""Missing test input file. mvn test -DcreateInputTestFiles=true ""+ ""or temporarilly: System.setProperty(\""createInputTestFiles\"", \""true\"");"");"	task4	
"public class A { <line0> @Override <line1> protected PropertyWidget<?> createPropertyWidget( <line2> final ComponentBuilder componentBuilder, <line3> final ConfiguredPropertyDescriptor propertyDescriptor) { <line4> final PropertyWidget<?> propertyWidget = <line5> super.createPropertyWidget(componentBuilder, propertyDescriptor); <line6> final String propertyName = propertyDescriptor.getName(); <line7> if (""Token target"".equals(propertyName)) { <line8> _tokenTargetPropertyWidget = (SingleEnumPropertyWidget) propertyWidget; <line9> _tokenTargetPropertyWidget.addComboListener( <line10> item -> { <line11> if (_numTokensPropertyWidget == null) { <line12> return; <line13> } <line14> if (item == TokenTarget.ROWS) { <line15> if (!_numTokensPropertyWidget.isSet()) { <line16> _numTokensPropertyWidget.onValueTouched(2); <line17> } <line18> _numTokensPropertyWidget.setEnabled(false); <line19> } else { <line20> _numTokensPropertyWidget.setEnabled(true); <line21> } <line22> }); <line23> if (_numTokensPropertyWidget != null <line24> && _tokenTargetPropertyWidget.getValue() == TokenTarget.ROWS) { <line25> _numTokensPropertyWidget.setEnabled(false); <line26> } <line27> } else if (""Number of tokens"".equals(propertyName)) { <line28> _numTokensPropertyWidget = (SingleNumberPropertyWidget) propertyWidget; <line29> } <line30> return propertyWidget; <line31> } <line32> } <line33> "	"<line12>              logger.warn(""No property widget for 'num tokens' found!"");"	task4	
"public class A { <line0> @DELETE <line1> @Path(""{id}"") <line2> @Timed <line3> @ApiOperation(value = ""Delete index set"") <line4> @AuditEvent(type = AuditEventTypes.INDEX_SET_DELETE) <line5> @ApiResponses( <line6> value = { <line7> @ApiResponse(code = 403, message = ""Unauthorized""), <line8> @ApiResponse(code = 404, message = ""Index set not found""), <line9> }) <line10> public void delete( <line11> @ApiParam(name = ""id"", required = true) @PathParam(""id"") String id, <line12> @ApiParam(name = ""delete_indices"") @QueryParam(""delete_indices"") @DefaultValue(""true"") <line13> boolean deleteIndices) { <line14> checkPermission(RestPermissions.INDEXSETS_DELETE, id); <line15> final IndexSet indexSet = getIndexSet(indexSetRegistry, id); <line16> final IndexSet defaultIndexSet = indexSetRegistry.getDefault(); <line17> if (indexSet.equals(defaultIndexSet)) { <line18> throw new BadRequestException( <line19> ""Default index set <"" + indexSet.getConfig().id() + ""> cannot be deleted!""); <line20> } <line21> if (indexSetService.delete(id) == 0) { <line22> throw new NotFoundException(""Couldn't delete index set with ID <"" + id + "">""); <line23> } else { <line24> if (deleteIndices) { <line25> try { <line26> systemJobManager.submit(indexSetCleanupJobFactory.create(indexSet)); <line27> } catch (SystemJobConcurrencyException e) { <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	"<line28>          LOG.error(""Error running system job"", e);"	task4	
"public class A { <line0> @SuppressWarnings(""unused"") <line1> private void testScanRaw(String msg) throws IOException { <line2> long t = System.currentTimeMillis(); <line3> IGTScanner scan = <line4> simpleStore.scan( <line5> new GTScanRequestBuilder() <line6> .setInfo(info) <line7> .setRanges(null) <line8> .setDimensions(null) <line9> .setFilterPushDown(null) <line10> .createGTScanRequest()); <line11> ResultScanner innerScanner = ((SimpleHBaseStore.Reader) scan).getHBaseScanner(); <line12> int count = 0; <line13> for (Result r : innerScanner) { <line14> count++; <line15> } <line16> scan.close(); <line17> t = System.currentTimeMillis() - t; <line18> } <line19> } <line20> "	"<line18>    logger.info(msg + "", "" + count + "" rows, "" + speed(t) + ""K row/sec"");"	task4	
"public class A { <line0> @Override <line1> public void handle(HttpExchange exchange) { <line2> Optional<PrometheusMeterRegistry> registry = <line3> Metrics.globalRegistry.getRegistries().stream() <line4> .filter(meterRegistry -> meterRegistry instanceof PrometheusMeterRegistry) <line5> .map(meterRegistry -> (PrometheusMeterRegistry) meterRegistry) <line6> .findFirst(); <line7> if (registry.isPresent()) { <line8> this.render(registry.get().scrape(), exchange, HttpStatus.SC_OK); <line9> } else { <line10> this.render(""Not Found"", exchange, HttpStatus.SC_NOT_FOUND); <line11> } <line12> } <line13> } <line14> "	"<line10>      LOG.warn(""Trying to scrape prometheus, while it is disabled, set""+ "" \""secor.monitoring.metrics.collector.micrometer.prometheus.enabled\"" to""+ "" \""true\"""");"	task4	
"public class A { <line0> public void onGroupRenamed(UDGroup group) { <line1> Isy99iFrame.writeAreaLog( <line2> Isy99iUtilities.getDateTime() <line3> + "": Scene: "" <line4> + group.address <line5> + "" was removed by someone or something!""); <line6> } <line7> } <line8> "	"<line6>    Freedomotic.logger.info(""Scene: "" + group.address + "" was renamed to "" + group.name);"	task4	
"public class A { <line0> @RequestMapping(""/experimentoverview"") <line1> public @ResponseBody String experimentoverview( <line2> @RequestParam(value = ""experimentType"") String experimentType, <line3> @RequestParam(value = ""matching"") String matchingString) { <line4> Matching matching = MainController.getMatching(matchingString); <line5> ExperimentType eType = ExperimentType.valueOf(experimentType); <line6> String annotatorNames[] = loadAnnotators(eType); <line7> String datasetNames[] = loadDatasets(eType); <line8> double results[][] = loadLatestResults(eType, matching, annotatorNames, datasetNames); <line9> double correlations[][] = calculateCorrelations(results, datasetNames); <line10> return generateJson(results, correlations, annotatorNames, datasetNames); <line11> } <line12> } <line13> "	"<line4>    LOGGER.debug(""Got request on /experimentoverview(experimentType={}, matching={}"",experimentType,matchingString);"	task4	
public class A { <line0> private void handleRemove( <line1> List<HostInternetScsiHbaStaticTarget> targetsToRemove, HostMO host, List<HostMO> hosts) { <line2> try { <line3> for (HostInternetScsiHbaStaticTarget target : targetsToRemove) { <line4> String datastoreName = <line5> waitForDatastoreName(host.getHostDatastoreSystemMO(), target.getIScsiName()); <line6> unmountVmfsDatastore2(host.getContext(), host, datastoreName, hosts); <line7> } <line8> addRemoveInternetScsiTargetsToAllHosts(false, targetsToRemove, hosts); <line9> rescanAllHosts(hosts, true, false); <line10> } catch (Exception ex) { <line11> } <line12> } <line13> } <line14> 	<line11>      logger.warn(ex.getMessage());	task4	
"public class A { <line0> public static java.util.List<com.liferay.dynamic.data.mapping.model.DDMTemplate> <line1> getTemplatesByClassPK( <line2> HttpPrincipal httpPrincipal, <line3> long companyId, <line4> long groupId, <line5> long classPK, <line6> long resourceClassNameId, <line7> int status) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> DDMTemplateServiceUtil.class, <line12> ""getTemplatesByClassPK"", <line13> _getTemplatesByClassPKParameterTypes16); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, companyId, groupId, classPK, resourceClassNameId, status); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.dynamic.data.mapping.model.DDMTemplate>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line24>      log.error(systemException, systemException);	task4	
"public class A { <line0> protected Checksum compute( <line1> final InputStream in, final long offset, final ByteBuffer header, final NonceGenerator nonces) <line2> throws ChecksumException { <line3> if (log.isDebugEnabled()) { <line4> } <line5> try { <line6> final PipedOutputStream source = new PipedOutputStream(); <line7> final CryptoOutputStream<Void> out = <line8> new CryptoOutputStream<Void>( <line9> new VoidStatusOutputStream(source), <line10> cryptomator.getFileContentCryptor(), <line11> cryptomator.getFileHeaderCryptor().decryptHeader(header), <line12> nonces, <line13> cryptomator.numberOfChunks(offset)); <line14> final PipedInputStream sink = <line15> new PipedInputStream(source, PreferencesFactory.get().getInteger(""connection.chunksize"")); <line16> final ThreadPool pool = ThreadPoolFactory.get(""checksum"", 1); <line17> try { <line18> final Future execute = <line19> pool.execute( <line20> new Callable<TransferStatus>() { <line21> @Override <line22> public TransferStatus call() throws Exception { <line23> if (offset == 0) { <line24> source.write(header.array()); <line25> } <line26> final TransferStatus status = new TransferStatus(); <line27> new StreamCopier(status, status).transfer(in, out); <line28> return status; <line29> } <line30> }); <line31> try { <line32> return delegate.compute(sink, new TransferStatus()); <line33> } finally { <line34> try { <line35> execute.get(); <line36> } catch (InterruptedException e) { <line37> throw new ChecksumException( <line38> LocaleFactory.localizedString(""Checksum failure"", ""Error""), e.getMessage(), e); <line39> } catch (ExecutionException e) { <line40> if (e.getCause() instanceof BackgroundException) { <line41> throw (BackgroundException) e.getCause(); <line42> } <line43> throw new DefaultExceptionMappingService().map(e.getCause()); <line44> } <line45> } <line46> } finally { <line47> pool.shutdown(true); <line48> } <line49> } catch (ChecksumException e) { <line50> throw e; <line51> } catch (IOException | BackgroundException e) { <line52> throw new ChecksumException( <line53> LocaleFactory.localizedString(""Checksum failure"", ""Error""), e.getMessage(), e); <line54> } <line55> } <line56> } <line57> "	"<line4>      log.debug(String.format(""Calculate checksum with header %s"", header));"	task4	
"public class A { <line0> @PostConstruct <line1> public void start() { <line2> if (configuration.getApi().isDisableApiServer()) { <line3> return; <line4> } <line5> registerLoginProvider(); <line6> registerRolesProvider(); <line7> ApiConfiguration apiConfiguration = configuration.getApi(); <line8> String[] args = <line9> new String[] { <line10> ""secret="" + apiConfiguration.getSecret(), <line11> ""on.address="" + apiConfiguration.getListen(), <line12> ""on.port="" + apiConfiguration.getPort() <line13> }; <line14> On.changes().ignore(); <line15> GuiceBeans beans = Integrate.guice(injector); <line16> App.run(args).auth(); <line17> App.register(beans); <line18> } <line19> } <line20> "	"<line3>      logger.info(""Not starting the API..."");"	task4	
"public class A { <line0> @Test <line1> public void testUserExistsException() { <line2> final User user = new User(""admin""); <line3> user.setEmail(""matt@raibledesigns.com""); <line4> willThrow(new DataIntegrityViolationException("""")).given(userDao).saveUser(user); <line5> try { <line6> userManager.saveUser(user); <line7> fail(""Expected UserExistsException not thrown""); <line8> } catch (UserExistsException e) { <line9> assertNotNull(e); <line10> } <line11> } <line12> } <line13> "	"<line9>      log.debug(""expected exception: "" + e.getMessage());"	task4	
"public class A { <line0> protected void dropTitleColumn() throws Exception { <line1> try { <line2> runSQL(""alter table JournalArticle drop column title""); <line3> } catch (SQLException sqlException) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> "	<line5>        log.debug(sqlException, sqlException);	task4	
public class A { <line0> private FileWriteHandle closeBufAndRollover( <line1> FileWriteHandle currWriteHandle, @Nullable WALRecord rec, RolloverType rolloverType) <line2> throws IgniteCheckedException { <line3> long idx = currWriteHandle.getSegmentId(); <line4> currWriteHandle.closeBuffer(); <line5> FileWriteHandle res = <line6> rollOver(currWriteHandle, rolloverType == RolloverType.NEXT_SEGMENT ? rec : null); <line7> if (log != null && log.isInfoEnabled()) { <line8> } <line9> return res; <line10> } <line11> } <line12> 	"<line8>      log.info(""Rollover segment [""+ idx+ "" to ""+ res.getSegmentId()+ ""], recordType=""+ (rec == null ? null : rec.type()));"	task4	
public class A { <line0> @Before <line1> public void setUp() throws Exception { <line2> IOHelper.deleteFile(schedulerStoreDir); <line3> createBroker(); <line4> broker.start(); <line5> broker.waitUntilStarted(); <line6> schedulerStore = (JobSchedulerStoreImpl) broker.getJobSchedulerStore(); <line7> } <line8> } <line9> 	"<line3>    LOG.info(""Test Dir = {}"", schedulerStoreDir);"	task4	
"public class A { <line0> public static void main(String[] args) throws Exception { <line1> initTracing(); <line2> initStatsExporter(); <line3> Server server = new Server(8080); <line4> ServletContextHandler contextHandler = <line5> new ServletContextHandler(ServletContextHandler.SESSIONS); <line6> contextHandler.setContextPath(""/helloworld""); <line7> ServletHolder sh = new ServletHolder(new HelloServlet()); <line8> contextHandler.addServlet(sh, ""/request/*""); <line9> contextHandler.addFilter(OcHttpServletFilter.class, ""/*"", EnumSet.of(DispatcherType.REQUEST)); <line10> server.setHandler(contextHandler); <line11> try { <line12> server.start(); <line13> server.join(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> "	"<line15>      logger.error(""Failed to start application"", e);"	task4	
public class A { <line0> @Override <line1> public void forget(Xid xid) throws XAException { <line2> AbstractTransactionContext context = resourceManager.getTransactionalResource(xid); <line3> if (context == null) { <line4> throw new XAException(XAException.XAER_NOTA); <line5> } <line6> resourceManager.removeActiveTransactionalResource(xid); <line7> resourceManager.removeSuspendedTransactionalResource(xid); <line8> } <line9> } <line10> 	"<line2>    LOGGER.debug(""Forgetting transaction branch {}"", xid);"	task4	
public class A { <line0> @Override <line1> public boolean isReadOnly() { <line2> return false; <line3> } <line4> } <line5> 	"<line2>    logger.info(""x"");"	task4	
"public class A { <line0> @Override <line1> public void initialize() throws InitializationException { <line2> try { <line3> System.setProperty( <line4> ""groovy.root"", <line5> new File(this.environmentProvider.get().getPermanentDirectory(), ""cache/groovy"") <line6> .getAbsolutePath()); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	"<line8>      this.logger.debug(""No registered environment, keep default Groovy setup"", e);"	task4	
public class A { <line0> @Override <line1> public List<AggregateResult> calcResult(long curStartTime, long curEndTime) throws IOException { <line2> List<ByteBuffer> aggrBuffers; <line3> try { <line4> if (ClusterDescriptor.getInstance().getConfig().isUseAsyncServer()) { <line5> AsyncDataClient client = <line6> metaGroupMember <line7> .getClientProvider() <line8> .getAsyncDataClient(source, RaftServer.getReadOperationTimeoutMS()); <line9> aggrBuffers = <line10> SyncClientAdaptor.getGroupByResult( <line11> client, header, executorId, curStartTime, curEndTime); <line12> } else { <line13> try (SyncDataClient syncDataClient = <line14> metaGroupMember <line15> .getClientProvider() <line16> .getSyncDataClient(source, RaftServer.getReadOperationTimeoutMS())) { <line17> aggrBuffers = <line18> syncDataClient.getGroupByResult(header, executorId, curStartTime, curEndTime); <line19> } <line20> } <line21> } catch (TException e) { <line22> throw new IOException(e); <line23> } catch (InterruptedException e) { <line24> Thread.currentThread().interrupt(); <line25> throw new IOException(e); <line26> } <line27> resetAggregateResults(); <line28> if (aggrBuffers != null) { <line29> for (int i = 0; i < aggrBuffers.size(); i++) { <line30> AggregateResult result = AggregateResult.deserializeFrom(aggrBuffers.get(i)); <line31> results.get(i).merge(result); <line32> } <line33> } <line34> return results; <line35> } <line36> } <line37> 	"<line34>    logger.debug(""Fetched group by result from {} of [{}, {}]: {}"",source,curStartTime,curEndTime,results);"	task4	
public class A { <line0> public static TemplatePool getTemplatePool(Client client) throws InternalServerErrorException { <line1> TemplatePool templatePool = (TemplatePool) generateOnePool(client, TemplatePool.class); <line2> OneResponse response = templatePool.infoAll(); <line3> if (response.isError()) { <line4> throw new InternalServerErrorException(response.getErrorMessage()); <line5> } <line6> return templatePool; <line7> } <line8> } <line9> 	<line4>      LOGGER.error(String.format(Messages.Log.ERROR_WHILE_GETTING_TEMPLATES_S, response.getErrorMessage()));	task4	
public class A { <line0> @Override <line1> public void refresh(Collection<Refreshable> alreadyRefreshed) { <line2> reload(); <line3> } <line4> } <line5> 	"<line2>    log.debug(""Reloading..."");"	task4	
"public class A { <line0> private void initScheduledTask(Long batchWaitInterval) { <line1> try { <line2> if (batchWaitInterval > 0) { <line3> this.scheduler = <line4> new ScheduledThreadPoolExecutor(1, new DTThreadFactory(""hbase-batch-flusher"")); <line5> this.scheduledFuture = <line6> this.scheduler.scheduleWithFixedDelay( <line7> () -> { <line8> synchronized (HbaseOutputFormat.this) { <line9> if (!records.isEmpty()) { <line10> dealBatchOperation(records); <line11> } <line12> } <line13> }, <line14> batchWaitInterval, <line15> batchWaitInterval, <line16> TimeUnit.MILLISECONDS); <line17> } <line18> } catch (Exception e) { <line19> throw new RuntimeException(e); <line20> } <line21> } <line22> } <line23> "	"<line19>      LOG.error(""init schedule task failed !"");"	task4	
"public class A { <line0> public static void deleteFileVersion( <line1> HttpPrincipal httpPrincipal, long fileEntryId, String version) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLFileEntryServiceUtil.class, <line7> ""deleteFileVersion"", <line8> _deleteFileVersionParameterTypes10); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, fileEntryId, version); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
"public class A { <line0> public String getPredictionColumn(String usecase) { <line1> try { <line2> Map<String, Object> parameters = new HashMap<>(); <line3> parameters.put(USECASE, usecase); <line4> AutoMLConfig result = <line5> getSingleResult( <line6> ""FROM AutoMLConfig AC WHERE AC.usecase = :usecase"", AutoMLConfig.class, parameters); <line7> return result.getPredictionColumn(); <line8> } catch (Exception e) { <line9> throw e; <line10> } <line11> } <line12> } <line13> "	<line9>      log.error(e.getMessage());	task4	
public class A { <line0> @Override <line1> protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress) <line2> throws Exception { <line3> if (localAddress != null) { <line4> socket.bind(localAddress); <line5> } <line6> boolean success = false; <line7> try { <line8> socket.connect(remoteAddress); <line9> success = true; <line10> } finally { <line11> if (!success) { <line12> try { <line13> socket.close(); <line14> } catch (Throwable t) { <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	"<line15>          logger.warn(""Failed to close a socket."", t);"	task4	
public class A { <line0> @Override <line1> public String getURL(PortletRequest portletRequest, PortletResponse portletResponse) { <line2> String url = StringPool.BLANK; <line3> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line4> try { <line5> UserGroup userGroup = ActionUtil.getUserGroup(portletRequest); <line6> Group userGroupGroup = userGroup.getGroup(); <line7> url = <line8> PermissionsURLTag.doTag( <line9> StringPool.BLANK, <line10> Group.class.getName(), <line11> themeDisplay.getScopeGroupName(), <line12> null, <line13> String.valueOf(userGroupGroup.getGroupId()), <line14> LiferayWindowState.POP_UP.toString(), <line15> null, <line16> themeDisplay.getRequest()); <line17> } catch (Exception exception) { <line18> if (log.isDebugEnabled()) { <line19> } <line20> } <line21> return url; <line22> } <line23> } <line24> 	<line19>        log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> public MDRRuleGroupInstance findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchRuleGroupInstanceException { <line3> MDRRuleGroupInstance mdrRuleGroupInstance = fetchByPrimaryKey(primaryKey); <line4> if (mdrRuleGroupInstance == null) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchRuleGroupInstanceException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return mdrRuleGroupInstance; <line10> } <line11> } <line12> 	<line6>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
"public class A { <line0> @Override <line1> @ActionEvent( <line2> eventType = EventTypes.EVENT_EXTERNAL_SWITCH_MGMT_DEVICE_DELETE, <line3> eventDescription = ""deleting VSM"", <line4> async = true) <line5> public boolean deleteCiscoNexusVSM(DeleteCiscoNexusVSMCmd cmd) { <line6> boolean result; <line7> try { <line8> result = deleteCiscoNexusVSM(cmd.getCiscoNexusVSMDeviceId()); <line9> } catch (ResourceInUseException e) { <line10> throw new CloudRuntimeException(""Failed to delete specified VSM""); <line11> } <line12> return result; <line13> } <line14> } <line15> "	"<line10>      logger.info(""VSM could not be deleted"");"	task4	
"public class A { <line0> @Test <line1> public void testSyncCommandBasicExportImport() { <line2> try { <line3> createTestNodes(TestOne.class, 100); <line4> app.command(SyncCommand.class).execute(toMap(""mode"", ""export"", ""file"", EXPORT_FILENAME)); <line5> final Path exportFile = Paths.get(EXPORT_FILENAME); <line6> assertTrue(""Export file doesn't exist!"", Files.exists(exportFile)); <line7> cleanDatabaseAndSchema(); <line8> app.command(SyncCommand.class).execute(toMap(""mode"", ""import"", ""file"", EXPORT_FILENAME)); <line9> try (final Tx tx = app.tx()) { <line10> assertEquals(100, app.nodeQuery(TestOne.class).getAsList().size()); <line11> } <line12> Files.delete(exportFile); <line13> } catch (Exception ex) { <line14> fail(""Unexpected exception.""); <line15> } <line16> } <line17> } <line18> "	"<line14>      logger.warn("""", ex);"	task4	
"public class A { <line0> @Override <line1> public void initialise() throws InitialisationException { <line2> scheduler = <line3> schedulerService.customScheduler( <line4> SchedulerConfig.config() <line5> .withMaxConcurrentTasks(1) <line6> .withName(""PolicyManager-StaleCleaner"")); <line7> operationPolicyProcessorFactory = new DefaultOperationPolicyProcessorFactory(); <line8> sourcePolicyProcessorFactory = new DefaultSourcePolicyProcessorFactory(); <line9> policyProvider = registry.lookupByType(PolicyProvider.class).orElse(new NullPolicyProvider()); <line10> if (muleContext.getArtifactType().equals(APP)) { <line11> policyProvider.onPoliciesChanged( <line12> () -> { <line13> evictCaches(); <line14> isSourcePoliciesAvailable.set(policyProvider.isSourcePoliciesAvailable()); <line15> isOperationPoliciesAvailable.set(policyProvider.isOperationPoliciesAvailable()); <line16> }); <line17> isSourcePoliciesAvailable.set(policyProvider.isSourcePoliciesAvailable()); <line18> isOperationPoliciesAvailable.set(policyProvider.isOperationPoliciesAvailable()); <line19> } <line20> policyPointcutParametersManager = <line21> new PolicyPointcutParametersManager( <line22> registry.lookupAllByType(SourcePolicyPointcutParametersFactory.class), <line23> registry.lookupAllByType(OperationPolicyPointcutParametersFactory.class)); <line24> notificationManager.addListener( <line25> new FlowConstructNotificationListener<FlowConstructNotification>() { <line26> @Override <line27> public boolean isBlocking() { <line28> return false; <line29> } <line30>  <line31> @Override <line32> public void onNotification(FlowConstructNotification notification) { <line33> if (Integer.parseInt(notification.getAction().getIdentifier()) <line34> == FLOW_CONSTRUCT_STOPPED) { <line35> invalidateDisposedFlowFromCaches(notification.getResourceIdentifier()); <line36> } <line37> } <line38> }); <line39> } <line40> } <line41> "	"<line35>              LOGGER.debug(""Invalidating flow from caches named {}"", notification.getResourceIdentifier());"	task4	
public class A { <line0> @VisibleForTesting <line1> InternetAddress getUserEmail(UserDataRequest udr) throws UnexpectedObmSyncServerException { <line2> String email = authenticationService.getUserEmail(udr); <line3> try { <line4> InternetAddress address = new InternetAddress(email, true); <line5> address.setPersonal(udr.getUser().getDisplayName(), Charsets.UTF_8.name()); <line6> return address; <line7> } catch (UnsupportedEncodingException | AddressException e) { <line8> throw Throwables.propagate(e); <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.warn(""Cannot set internet address"", e);"	task4	
public class A { <line0> private void loadTasksFromDB(List<DataSourceInfoModel> dataSources) { <line1> try { <line2> for (final DataSourceInfoModel dataSource : dataSources) { <line3> initTask(dataSource); <line4> } <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.error(""sync db to tasks error"", e);"	task4	
public class A { <line0> @Nullable <line1> public static Ipv6ArbitraryMask extractIpv6AddressMask(final Ipv6Prefix ipv6Prefix) { <line2> Iterator<String> addressParts = PREFIX_SPLITTER.split(ipv6Prefix.getValue()).iterator(); <line3> addressParts.next(); <line4> int maskLength = 0; <line5> if (addressParts.hasNext()) { <line6> maskLength = Integer.parseInt(addressParts.next()); <line7> } <line8> BitSet ipmask = new BitSet(128); <line9> ipmask.set(0, maskLength, true); <line10> ipmask.set(maskLength + 1, 128, false); <line11> byte[] finalmask = new byte[16]; <line12> System.arraycopy(ipmask.toByteArray(), 0, finalmask, 0, ipmask.toByteArray().length); <line13> InetAddress inetAddress = null; <line14> try { <line15> inetAddress = InetAddress.getByAddress(finalmask); <line16> } catch (UnknownHostException e) { <line17> return null; <line18> } <line19> return new Ipv6ArbitraryMask(inetAddress.getHostAddress()); <line20> } <line21> } <line22> 	"<line17>      LOG.error(""Failed to convert the Ipv6 subnetmask from integer to mask value "", e);"	task4	
public class A { <line0> @Override <line1> public void onError(Throwable throwable) { <line2> XdsSchedulerManager.getInstance().startApplicationKeyMappingDiscoveryScheduling(); <line3> nack(throwable); <line4> } <line5> } <line6> 	"<line2>    logger.error(""Error occurred during Application Key Mappings discovery"", throwable);"	task4	
public class A { <line0> @Override <line1> public void updateUserStats(List<UserStatisticsVO> userStats) { <line2> TransactionLegacy txn = TransactionLegacy.currentTxn(); <line3> try { <line4> txn.start(); <line5> String sql = UPDATE_USER_STATS; <line6> PreparedStatement pstmt = null; <line7> pstmt = txn.prepareAutoCloseStatement(sql); <line8> for (UserStatisticsVO userStat : userStats) { <line9> pstmt.setLong(1, userStat.getNetBytesReceived()); <line10> pstmt.setLong(2, userStat.getNetBytesSent()); <line11> pstmt.setLong(3, userStat.getCurrentBytesReceived()); <line12> pstmt.setLong(4, userStat.getCurrentBytesSent()); <line13> pstmt.setLong(5, userStat.getAggBytesReceived()); <line14> pstmt.setLong(6, userStat.getAggBytesSent()); <line15> pstmt.setLong(7, userStat.getId()); <line16> pstmt.addBatch(); <line17> } <line18> pstmt.executeBatch(); <line19> txn.commit(); <line20> } catch (Exception ex) { <line21> txn.rollback(); <line22> throw new CloudRuntimeException(ex.getMessage()); <line23> } <line24> } <line25> } <line26> 	"<line22>      logger.error(""error updating user stats to cloud_usage db"", ex);"	task4	
"public class A { <line0> public ActionForward ajaxChangeDiagnosis( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> HttpSession session = request.getSession(); <line6> if (session.getAttribute(""userrole"") == null) return mapping.findForward(""expired""); <line7> String strIndex = request.getParameter(""change_diagnosis_id""); <line8> int idx = Integer.parseInt(strIndex); <line9> String substitution = request.getParameter(""newIssueId""); <line10> String sessionFrmName = ""caseManagementEntryForm"" + getDemographicNo(request); <line11> CaseManagementEntryFormBean sessionFrm = <line12> (CaseManagementEntryFormBean) session.getAttribute(sessionFrmName); <line13> CheckBoxBean[] curIssues = sessionFrm.getIssueCheckList(); <line14> if (substitution != null) { <line15> Issue iss = caseManagementMgr.getIssue(substitution); <line16> curIssues[idx].getIssue().setIssue(iss); <line17> curIssues[idx].getIssue().setIssue_id(iss.getId()); <line18> this.caseManagementMgr.saveCaseIssue(curIssues[idx].getIssue()); <line19> Set<CaseManagementIssue> issueset = new HashSet<CaseManagementIssue>(); <line20> for (int i = 0; i < curIssues.length; ++i) { <line21> if (curIssues[i].getChecked().equalsIgnoreCase(""on"")) issueset.add(curIssues[i].getIssue()); <line22> } <line23> sessionFrm.getCaseNote().setIssues(issueset); <line24> } <line25> sessionFrm.setIssueCheckList(curIssues); <line26> request.setAttribute(""caseManagementEntryForm"", sessionFrm); <line27> return mapping.findForward(""issueList_ajax""); <line28> } <line29> } <line30> "	"<line5>    logger.debug(""ajaxChangeDiagnosis"");"	task4	
"public class A { <line0> public TableState updateTableStateCache(TableId tableId) { <line1> synchronized (tableStateCache) { <line2> TableState tState = TableState.UNKNOWN; <line3> byte[] data = <line4> zooStateCache.get(zkRoot + Constants.ZTABLES + ""/"" + tableId + Constants.ZTABLE_STATE); <line5> if (data != null) { <line6> String sState = new String(data, UTF_8); <line7> try { <line8> tState = TableState.valueOf(sState); <line9> } catch (IllegalArgumentException e) { <line10> } <line11> tableStateCache.put(tableId, tState); <line12> } <line13> return tState; <line14> } <line15> } <line16> } <line17> "	"<line10>          log.error(""Unrecognized state for table with tableId={}: {}"", tableId, sState);"	task4	
"public class A { <line0> public ItemsVO createNewEntryInItemsTable(ItemsVO vo) { <line1> long timerStart = System.currentTimeMillis(); <line2> Long i = conf.getDBDAO().doCreateNewEntryInItemsTable(vo); <line3> vo.setItemid(i.intValue()); <line4> logTime(""doCreateNewEntryInItemsTable"", timerStart, System.currentTimeMillis()); <line5> return vo; <line6> } <line7> } <line8> "	"<line1>    logger.debug(""JDBC::createNewEntryInItemsTable"");"	task4	
public class A { <line0> private static void delete(File file) { <line1> if (file.isDirectory()) { <line2> for (File subFile : file.listFiles()) { <line3> delete(subFile); <line4> } <line5> } <line6> if (file.exists() && !file.delete()) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOGGER.warn(String.format(Locale.ROOT, ""Could not delete %s."", file));"	task4	
"public class A { <line0> @Override <line1> public void processAssetEntryQuery( <line2> long companyId, <line3> String userId, <line4> UnicodeProperties unicodeProperties, <line5> AssetEntryQuery assetEntryQuery) { <line6> if (Validator.isNull(userId)) { <line7> return; <line8> } <line9> boolean enableContentRecommendation = <line10> GetterUtil.getBoolean(unicodeProperties.getProperty(""enableContentRecommendation"")); <line11> if (!enableContentRecommendation || (_asahInterestTermProvider == null)) { <line12> return; <line13> } <line14> String[] interestTerms = _asahInterestTermProvider.getInterestTerms(companyId, userId); <line15> if (interestTerms.length == 0) { <line16> return; <line17> } <line18> if (log.isDebugEnabled()) { <line19> } <line20> assetEntryQuery.setAnyKeywords(interestTerms); <line21> } <line22> } <line23> "	"<line19>      log.debug(StringBundler.concat(""Adding interest terms \"""",StringUtil.merge(interestTerms),""\"" to asset query for user ID "",userId));"	task4	
public class A { <line0> private boolean processFolder() throws IOException { <line1> if (folderId == null && !subFolders.isEmpty()) { <line2> folderId = subFolders.get(0); <line3> subFolders.remove(0); <line4> request.setQ(format(query, folderId)); <line5> } <line6> searchResults.clear(); <line7> FileList files = request.execute(); <line8> for (File file : files.getFiles()) { <line9> if (canAddSubFolder(file.getMimeType())) { <line10> subFolders.add(file.getId()); <line11> } <line12> if (canAddFile(file.getMimeType())) { <line13> searchResults.add(file); <line14> result.totalCount++; <line15> } <line16> } <line17> request.setPageToken(files.getNextPageToken()); <line18> searchCount = searchResults.size(); <line19> if (StringUtils.isEmpty(request.getPageToken()) || searchCount == 0) { <line20> folderId = null; <line21> } <line22> return searchCount > 0; <line23> } <line24> } <line25> 	"<line5>      LOG.debug(""query = {} {}."", query, folderId);"	task4	
public class A { <line0> @Override <line1> public void stopService() { <line2> bus.stop(); <line3> DefaultTaskManager.get().requestStop(); <line4> for (Runnable runnable : shutdownHooks) { <line5> try { <line6> runnable.run(); <line7> } catch (Throwable e) { <line8> } <line9> } <line10> bus = null; <line11> config = null; <line12> sessionProvider = null; <line13> dispatcher = null; <line14> shutdownHooks = null; <line15> DefaultRemoteCallBuilder.destroyProxyFactory(); <line16> ErraiServiceSingleton.resetProxyAndService(); <line17> } <line18> } <line19> 	"<line8>        log.error(""error executing shutdown hook"", e);"	task4	
public class A { <line0> @Override <line1> public int addToInt(Session session, int delta) { <line2> SessionImpl impl = (SessionImpl) session; <line3> IntVar var = impl.requireSet(index, key); <line4> int prev = var.intValue(session); <line5> if (trace) { <line6> } <line7> var.set(prev + delta); <line8> return prev; <line9> } <line10> } <line11> 	"<line6>      log.trace(""#{} {} <- {}"", impl.uniqueId(), key, prev + delta);"	task4	
"public class A { <line0> @Then( <line1> ""^the platform buffers a set light schedule response message for device \""([^\""]*)\"" that"" <line2> + "" contains a soap fault$"") <line3> public void thePlatformBuffersASetLightScheduleResponseMessageForDeviceContainsSoapFault( <line4> final String deviceIdentification, final Map<String, String> expectedResponseData) <line5> throws Throwable { <line6> final SetScheduleAsyncRequest request = new SetScheduleAsyncRequest(); <line7> final AsyncRequest asyncRequest = new AsyncRequest(); <line8> asyncRequest.setDeviceId(deviceIdentification); <line9> asyncRequest.setCorrelationUid( <line10> (String) ScenarioContext.current().get(PlatformPubliclightingKeys.KEY_CORRELATION_UID)); <line11> request.setAsyncRequest(asyncRequest); <line12> Wait.untilAndReturn( <line13> () -> { <line14> try { <line15> this.client.getSetSchedule(request); <line16> } catch (final SoapFaultClientException ex) { <line17> final String faultString = ex.getFaultStringOrReason(); <line18> if (""CorrelationUid is unknown."".equals(faultString)) { <line19> throw new Exception( <line20> ""Received a SOAP fault on setSchedule that could be rejected because the"" <line21> + "" CorrelationUid is unknown""); <line22> } <line23> ScenarioContext.current().put(PlatformKeys.RESPONSE, ex); <line24> return null; <line25> } <line26> throw new Exception(""Received a setSchedule message without a SOAP fault""); <line27> }); <line28> GenericResponseSteps.verifySoapFault(expectedResponseData); <line29> } <line30> } <line31> "	"<line17>            LOGGER.info(""Received a SOAP fault on setSchedule"");"	task4	
public class A { <line0> protected boolean isBackOrderAllowed(CPInstance cpInstance) { <line1> try { <line2> if (cpDefinitionInventoryEngine.isBackOrderAllowed(cpInstance)) { <line3> return true; <line4> } <line5> } catch (PortalException portalException) { <line6> } <line7> return false; <line8> } <line9> } <line10> 	"<line6>      log.error(""Unable to check is back order allowed"", portalException);"	task4	
public class A { <line0> public void maybeTriggerWakeup() { <line1> if (!wakeupDisabled.get() && wakeup.get()) { <line2> wakeup.set(false); <line3> throw new WakeupException(); <line4> } <line5> } <line6> } <line7> 	"<line2>      log.debug(""Raising WakeupException in response to user wakeup"");"	task4	
public class A { <line0> @Override <line1> protected void doGet(final HttpServletRequest request, final HttpServletResponse response) <line2> throws ServletException, IOException { <line3> try { <line4> response.sendRedirect(StringExtensions.combinePath(request.getContextPath(), redirectTo)); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.error(""failed to redirect request to {}"", redirectTo, e);"	task4	
public class A { <line0> private void prepareStandardView(RenderRequest request) throws IOException { <line1> List<Component> componentList = getFilteredComponentList(request); <line2> Set<String> vendorNames; <line3> try { <line4> vendorNames = thriftClients.makeVendorClient().getAllVendorNames(); <line5> } catch (TException e) { <line6> vendorNames = Collections.emptySet(); <line7> } <line8> List<String> componentTypeNames = <line9> Arrays.asList(ComponentType.values()).stream() <line10> .map(ThriftEnumUtils::enumToString) <line11> .collect(Collectors.toList()); <line12> request.setAttribute(VENDOR_LIST, new ThriftJsonSerializer().toJson(vendorNames)); <line13> request.setAttribute(COMPONENT_LIST, componentList); <line14> request.setAttribute( <line15> COMPONENT_TYPE_LIST, new ThriftJsonSerializer().toJson(componentTypeNames)); <line16> } <line17> } <line18> 	"<line6>      log.error(""Problem retrieving all the Vendor names"", e);"	task4	
public class A { <line0> private boolean isDuplicatedSlot( <line1> TaskSlot taskSlot, JobID jobId, ResourceProfile resourceProfile, int index) { <line2> return taskSlot.getJobId().equals(jobId) <line3> && taskSlot.getResourceProfile().equals(resourceProfile) <line4> && (isDynamicIndex(index) || taskSlot.getIndex() == index); <line5> } <line6> } <line7> 	"<line2>    LOG.info(""Slot with allocationId {} already exist, with resource profile {}, job id {} and index {}.""+ "" The required index is {}."",taskSlot.getAllocationId(),taskSlot.getResourceProfile(),taskSlot.getJobId(),taskSlot.getIndex(),index);"	task4	
public class A { <line0> private boolean matchesPath(RequestUrlParts url) { <line1> if (pattern.equals(MATCH_ALL)) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> return true; <line5> } <line6> return matcher.matches(url.getPath()); <line7> } <line8> } <line9> 	"<line3>        logger.debug(""Request matched by universal pattern '/**'"");"	task4	
"public class A { <line0> public static com.liferay.commerce.price.list.model.CommerceTierPriceEntry <line1> getCommerceTierPriceEntry(HttpPrincipal httpPrincipal, long commerceTierPriceEntryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceTierPriceEntryServiceUtil.class, <line7> ""getCommerceTierPriceEntry"", <line8> _getCommerceTierPriceEntryParameterTypes11); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceTierPriceEntryId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.price.list.model.CommerceTierPriceEntry) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> protected void postProcessResponse( <line2> boolean isGet, <line3> HttpServletRequest httpReq, <line4> HttpServletResponse httpResp, <line5> String samlResponse, <line6> String relayState) <line7> throws IOException { <line8> try { <line9> SAMLBindings binding = isGet ? SAMLBindings.HTTP_REDIRECT : SAMLBindings.HTTP_POST; <line10> LogoutResponseDocument respDoc = LogoutResponseDocument.Factory.parse(samlResponse); <line11> SAMLVerifiableElement verifiableMessage = <line12> binding == SAMLBindings.HTTP_REDIRECT <line13> ? new RedirectedMessage(httpReq.getQueryString()) <line14> : new XMLExpandedMessage(respDoc, respDoc.getLogoutResponse()); <line15> SAMLMessage<LogoutResponseDocument> responseMessage = <line16> new SAMLMessage<>(verifiableMessage, relayState, binding, respDoc); <line17> logoutProcessor.handleAsyncLogoutResponse(responseMessage, httpResp); <line18> } catch (XmlException e) { <line19> httpResp.sendError( <line20> HttpServletResponse.SC_BAD_REQUEST, ""Invalid SLO response (XML is malformed)""); <line21> } catch (EopException e) { <line22> } <line23> } <line24> } <line25> "	"<line19>      log.warn(""Got an invalid SAML Single Logout response (XML is broken)"", e);"	task4	
"public class A { <line0> @Override <line1> public void initCache(IGroupDAO groupDAO) throws ApsSystemException { <line2> try { <line3> Cache cache = this.getCache(); <line4> this.releaseCachedObjects(cache); <line5> Map<String, Group> groups = groupDAO.loadGroups(); <line6> this.insertObjectsOnCache(cache, groups); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error loading groups"", t); <line9> } <line10> } <line11> } <line12> "	"<line8>      logger.error(""Error loading groups"", t);"	task4	
public class A { <line0> private QoSInterDirectPingMeasurementResponseDTO getInterDirectPingMeasurementFromQoSMonitor( <line1> final CloudSystemFormDTO request) { <line2> final QoSInterDirectPingMeasurementResponseDTO measurement = <line3> orchestratorDriver.getInterDirectPingMeasurement(request); <line4> if (measurement.hasRecord() && measurement.isAvailable()) { <line5> interDirectPingMeasurementCache.put(getCloudSystemCacheKey(request), measurement); <line6> } <line7> return measurement; <line8> } <line9> } <line10> 	"<line2>    logger.debug(""getInterDirectPingMeasurementFromQoSMonitor started..."");"	task4	
public class A { <line0> public PluginWithExecutionId<ExecutablePlugin> getLatestSuccessfulExecutablePlugin( <line1> String datasetId, Set<ExecutablePluginType> pluginTypes, boolean limitToValidData) { <line2> verifyEnumSetIsValidAndNotEmpty(pluginTypes); <line3> final Set<PluginType> convertedPluginTypes = <line4> pluginTypes.stream().map(ExecutablePluginType::toPluginType).collect(Collectors.toSet()); <line5> final PluginWithExecutionId<MetisPlugin> uncastResultWrapper = <line6> getFirstOrLastFinishedPlugin(datasetId, convertedPluginTypes, false); <line7> final MetisPlugin uncastResult = <line8> Optional.ofNullable(uncastResultWrapper).map(PluginWithExecutionId::getPlugin).orElse(null); <line9> if (uncastResult == null) { <line10> return null; <line11> } <line12> if (!(uncastResult instanceof ExecutablePlugin)) { <line13> return null; <line14> } <line15> final ExecutablePlugin castResult = (ExecutablePlugin) uncastResult; <line16> final PluginWithExecutionId<ExecutablePlugin> result; <line17> if (limitToValidData && MetisPlugin.getDataStatus(castResult) != DataStatus.VALID) { <line18> result = null; <line19> } else { <line20> result = new PluginWithExecutionId<>(uncastResultWrapper.getExecutionId(), castResult); <line21> } <line22> return result; <line23> } <line24> } <line25> 	"<line13>      LOGGER.warn(""Found plugin {} for executable plugin type {} that is not itself executable."",uncastResult.getId(),uncastResult.getPluginType());"	task4	
"public class A { <line0> @Override <line1> public void transform(Message message, DataType from, DataType to) throws Exception { <line2> assertEquals(""name=XOrder"", message.getBody()); <line3> message.setBody(new XOrder()); <line4> } <line5> } <line6> "	"<line3>    LOG.info(""Bean: Other -> XOrder"");"	task4	
public class A { <line0> protected <T> ServiceResponse<T> makeBackwardCompatibleHttpPostRequestAndCreateServiceResponse( <line1> String uri, String body, Class<T> resultType) { <line2> KieServerHttpRequest request = newRequest(uri).body(body).post(); <line3> KieServerHttpResponse response = request.response(); <line4> owner.setConversationId(response.header(KieServerConstants.KIE_CONVERSATION_ID_TYPE_HEADER)); <line5> if (response.code() == Response.Status.OK.getStatusCode()) { <line6> ServiceResponse serviceResponse = deserialize(response.body(), ServiceResponse.class); <line7> serviceResponse.setResult(serialize(serviceResponse.getResult())); <line8> checkResultType(serviceResponse, resultType); <line9> return serviceResponse; <line10> } else { <line11> throw createExceptionForUnexpectedResponseCode(request, response); <line12> } <line13> } <line14> } <line15> 	"<line2>    logger.debug(""About to send POST request to '{}' with payload '{}'"", uri, body);"	task4	
"public class A { <line0> public Integer getMrlPinType(PinDefinition pin) { <line1> if (board == null) { <line2> error(""must have pin board type to determin pin definition""); <line3> return null; <line4> } <line5> if (pin == null) { <line6> return null; <line7> } <line8> if (pin.isAnalog()) { <line9> return 1; <line10> } <line11> return 0; <line12> } <line13> } <line14> "	"<line6>      log.error(""pin definition null"");"	task4	
"public class A { <line0> @ServiceActivator(inputChannel = ""requests"", outputChannel = ""replies"") <line1> public String process(String message) { <line2> String result = message + "": "" + count; <line3> if (count < expected.size()) { <line4> processed.add(message); <line5> count++; <line6> } <line7> if (""fail"".equals(message)) { <line8> throw new RuntimeException(""Planned failure""); <line9> } <line10> return result; <line11> } <line12> } <line13> "	"<line3>    logger.debug(""Handling: "" + message);"	task4	
public class A { <line0> public void testCalculator() { <line1> try { <line2> IsotopicDistribution lCalc = new IsotopicDistribution(60, 13, 86, 13, 2); <line3> Assert.assertEquals(0.39350045799282984, lCalc.getPercMax()[2], 0); <line4> Assert.assertEquals(0.16628993915006032, lCalc.getPercTot()[2], 0); <line5> } catch (Exception e) { <line6> fail(e.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      logger.error(e.getMessage(), e);	task4	
"public class A { <line0> @Override <line1> public boolean needDeploy() { <line2> Ssh ssh = new Ssh(); <line3> ssh.setUsername(username) <line4> .setPrivateKey(privateKey) <line5> .setPassword(password) <line6> .setPort(sshPort) <line7> .setHostname(targetIp); <line8> try { <line9> for (SrcDestPair b : srcDestPairs) { <line10> String sourceFilePath = b.srcPath; <line11> String destFilePath = b.destPath; <line12> ssh.command( <line13> String.format(""echo %s | sudo -S md5sum %s 2>/dev/null"", password, destFilePath)); <line14> SshResult ret = ssh.run(); <line15> if (ret.getReturnCode() != 0) { <line16> return true; <line17> } <line18> ssh.reset(); <line19> String destMd5 = ret.getStdout().split("" "")[0]; <line20> ShellResult sret = ShellUtils.runAndReturn(String.format(""md5sum %s"", sourceFilePath)); <line21> sret.raiseExceptionIfFail(); <line22> String srcMd5 = sret.getStdout().split("" "")[0]; <line23> if (!destMd5.equals(srcMd5)) { <line24> return true; <line25> } <line26> } <line27> } finally { <line28> ssh.close(); <line29> } <line30> return false; <line31> } <line32> } <line33> "	"<line24>          logger.debug(String.format(""file MD5 changed, src[%s, md5:%s] dest[%s, md5, %s]"",sourceFilePath, srcMd5, destFilePath, destMd5));"	task4	
public class A { <line0> @Secured({ServicesData.ROLE_GET_SECURITY_PROFILES}) <line1> @PostMapping(CommonConstants.PATH_CHECK) <line2> public ResponseEntity<Void> check( <line3> @RequestBody SecurityProfileDto accessContractDto, <line4> @RequestHeader(value = CommonConstants.X_TENANT_ID_HEADER) Integer tenant) { <line5> final boolean exist = securityProfileExternalService.check(accessContractDto); <line6> return RestUtils.buildBooleanResponse(exist); <line7> } <line8> } <line9> 	"<line5>    LOGGER.debug(""check exist accessContract={}"", accessContractDto);"	task4	
public class A { <line0> private void printContainerLog(String containerId) { <line1> LogCallback loggingCallback = new LogCallback(); <line2> dockerClient <line3> .logContainerCmd(containerId) <line4> .withStdErr(true) <line5> .withStdOut(true) <line6> .withFollowStream(true) <line7> .withTailAll() <line8> .exec(loggingCallback); <line9> try { <line10> loggingCallback.awaitCompletion(3, TimeUnit.SECONDS); <line11> } catch (InterruptedException e) { <line12> Thread.currentThread().interrupt(); <line13> } <line14> } <line15> } <line16> 	<line12>      log.error(e.getMessage());	task4	
public class A { <line0> @Override <line1> public void trace(Marker marker, String msg) { <line2> traceMessages.add(new LogMessage(marker, msg, null)); <line3> } <line4> } <line5> 	<line3>    logger.trace(marker, msg);	task4	
"public class A { <line0> private static ConfigLoader getLoader(Resource resource) { <line1> ConfigLoader loader = null; <line2> Class<? extends ConfigLoader> loaderClass = resource.getFormat().getLoaderClass(); <line3> try { <line4> loader = loaderClass.newInstance(); <line5> } catch (Exception e) { <line6> throw new RuntimeException( <line7> ""Failed to create "" + Conf.class.getPackage().getName() + "" for "" + loaderClass.getName(), <line8> e); <line9> } <line10> loader.setResource(resource); <line11> return loader; <line12> } <line13> } <line14> "	"<line6>      LOGGER.error(""Failed to create "" + Conf.class.getPackage().getName() + "" for "" + loaderClass.getName(),e);"	task4	
public class A { <line0> @Override <line1> public void setParentExperimentRunId(String experimentRunId, String parentExperimentRunId) { <line2> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line3> ExperimentRunEntity experimentRunEntity = <line4> session.load(ExperimentRunEntity.class, experimentRunId, LockMode.PESSIMISTIC_WRITE); <line5> experimentRunEntity.setParent_id(parentExperimentRunId); <line6> long currentTimestamp = Calendar.getInstance().getTimeInMillis(); <line7> experimentRunEntity.setDate_updated(currentTimestamp); <line8> Transaction transaction = session.beginTransaction(); <line9> session.update(experimentRunEntity); <line10> transaction.commit(); <line11> } catch (Exception ex) { <line12> if (ModelDBUtils.needToRetry(ex)) { <line13> setParentExperimentRunId(experimentRunId, parentExperimentRunId); <line14> } else { <line15> throw ex; <line16> } <line17> } <line18> } <line19> } <line20> 	"<line11>      LOGGER.debug(""ExperimentRun parentId updated successfully"");"	task4	
"public class A { <line0> private void verifyRequestContentForAction(ExecutionServiceInput executionServiceInput) { <line1> ActionIdentifiers actionIdentifiers = executionServiceInput.getActionIdentifiers(); <line2> assertThat(actionIdentifiers.getBlueprintName()).isEqualTo(TEST_PNF_RESOURCE_BLUEPRINT_NAME); <line3> assertThat(actionIdentifiers.getBlueprintVersion()) <line4> .isEqualTo(TEST_PNF_RESOURCE_BLUEPRINT_VERSION); <line5> assertThat(actionIdentifiers.getActionName()).isEqualTo(this.action); <line6> CommonHeader commonHeader = executionServiceInput.getCommonHeader(); <line7> assertThat(commonHeader.getOriginatorId()).isEqualTo(""SO""); <line8> assertThat(commonHeader.getRequestId()).isEqualTo(TEST_MSO_REQUEST_ID); <line9> Struct payload = executionServiceInput.getPayload(); <line10> Struct requeststruct = payload.getFieldsOrThrow(this.action + ""-request"").getStructValue(); <line11> assertThat(requeststruct.getFieldsOrThrow(""resolution-key"").getStringValue()) <line12> .isEqualTo(TEST_PNF_CORRELATION_ID); <line13> Struct propertiesStruct = <line14> requeststruct.getFieldsOrThrow(this.action + ""-properties"").getStructValue(); <line15> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-name"").getStringValue()) <line16> .isEqualTo(TEST_PNF_CORRELATION_ID); <line17> assertThat(propertiesStruct.getFieldsOrThrow(""service-model-uuid"").getStringValue()) <line18> .isEqualTo(TEST_MODEL_UUID); <line19> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-customization-uuid"").getStringValue()) <line20> .isEqualTo(TEST_PNF_RESOURCE_CUSTOMIZATION_UUID); <line21> if (action.equalsIgnoreCase(DEPLOY_ACTION)) { <line22> assertThat(actionIdentifiers.getMode()).isEqualTo(""async""); <line23> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-ipv4-address"").getStringValue()) <line24> .isEqualTo(""1.1.1.1""); <line25> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-ipv6-address"").getStringValue()) <line26> .isEqualTo(""::/128""); <line27> } else if (!action.equalsIgnoreCase(ASSIGN_ACTION)) { <line28> assertThat(actionIdentifiers.getMode()).isEqualTo(""sync""); <line29> assertThat(propertiesStruct.getFieldsOrThrow(""target-software-version"").getStringValue()) <line30> .isEqualTo(TEST_SOFTWARE_VERSION); <line31> } else { <line32> assertThat(actionIdentifiers.getMode()).isEqualTo(""sync""); <line33> } <line34> } <line35> } <line36> "	"<line1>    logger.info(""Checking the "" + this.action + "" request"");"	task4	
public class A { <line0> @Override <line1> public CommerceShippingFixedOptionRel remove(Serializable primaryKey) <line2> throws NoSuchShippingFixedOptionRelException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> CommerceShippingFixedOptionRel commerceShippingFixedOptionRel = <line7> (CommerceShippingFixedOptionRel) <line8> session.get(CommerceShippingFixedOptionRelImpl.class, primaryKey); <line9> if (commerceShippingFixedOptionRel == null) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> throw new NoSuchShippingFixedOptionRelException( <line13> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line14> } <line15> return remove(commerceShippingFixedOptionRel); <line16> } catch (NoSuchShippingFixedOptionRelException noSuchEntityException) { <line17> throw noSuchEntityException; <line18> } catch (Exception exception) { <line19> throw processException(exception); <line20> } finally { <line21> closeSession(session); <line22> } <line23> } <line24> } <line25> 	<line11>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> private static void write( <line1> VeriniceElementTransfer transfer, TransferData transferData, List<?> elements) { <line2> try { <line3> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line4> ObjectOutputStream objectOut = new ObjectOutputStream(out); <line5> objectOut.writeObject(elements.toArray(new Object[elements.size()])); <line6> transfer.doJavaToNative(out.toByteArray(), transferData); <line7> } catch (IOException e) { <line8> } <line9> } <line10> } <line11> 	"<line8>      LOG.error(""Error while serializing object for dnd"", e);"	task4	
"public class A { <line0> public static com.liferay.site.navigation.model.SiteNavigationMenu addSiteNavigationMenu( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String name, <line4> int type, <line5> boolean auto, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> SiteNavigationMenuServiceUtil.class, <line12> ""addSiteNavigationMenu"", <line13> _addSiteNavigationMenuParameterTypes0); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, name, type, auto, serviceContext); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.site.navigation.model.SiteNavigationMenu) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	<line27>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public boolean isUploadDataRecoverable(String objectId, long fileSize) throws IOException { <line2> return retry.execute( <line3> ctx -> { <line4> try { <line5> serviceTemplate.exchange( <line6> endpoint + ""/upload/{object-id}/recovery?fileSize={file-size}"", <line7> HttpMethod.POST, <line8> defaultEntity(), <line9> Boolean.class, <line10> objectId, <line11> fileSize); <line12> } catch (NotRetryableException e) { <line13> return false; <line14> } <line15> return true; <line16> }); <line17> } <line18> } <line19> "	"<line2>    log.debug(""Recovering upload, object-id: {}"", objectId);"	task4	
"public class A { <line0> private Object convertLtreeArray(Column column, Field fieldDefn, Object data) { <line1> return convertValue( <line2> column, <line3> fieldDefn, <line4> data, <line5> Collections.emptyList(), <line6> r -> { <line7> if (data instanceof byte[]) { <line8> String s = new String((byte[]) data, databaseCharset); <line9> s = s.substring(1, s.length() - 1); <line10> List<String> ltrees = Arrays.asList(s.split("","")); <line11> r.deliver(ltrees); <line12> } else if (data instanceof List) { <line13> List<Object> list = (List<Object>) data; <line14> List<String> ltrees = new ArrayList<>(list.size()); <line15> for (Object value : list) { <line16> ltrees.add(value.toString()); <line17> } <line18> r.deliver(ltrees); <line19> } else if (data instanceof PgArray) { <line20> PgArray pgArray = (PgArray) data; <line21> try { <line22> Object[] array = (Object[]) pgArray.getArray(); <line23> List<String> ltrees = new ArrayList<>(array.length); <line24> for (Object value : array) { <line25> ltrees.add(value.toString()); <line26> } <line27> r.deliver(ltrees); <line28> } catch (SQLException e) { <line29> } <line30> } <line31> }); <line32> } <line33> } <line34> "	"<line29>              logger.error(""Failed to parse PgArray: "" + pgArray, e);"	task4	
public class A { <line0> private void checkWhetherTrackerCanBeRemoved(JobID jobId, JobScopedResourceTracker tracker) { <line1> if (tracker.isEmpty()) { <line2> trackers.remove(jobId); <line3> } <line4> } <line5> } <line6> 	"<line2>      LOG.debug(""Stopping tracking of resources for job {}."", jobId);"	task4	
"public class A { <line0> private static void convertModel( <line1> Configuration conf, <line2> String modelInputDir, <line3> String convertedModelDir, <line4> MatrixFilesMeta meta, <line5> ModelLineConvert lineConvert) <line6> throws IOException { <line7> List<List<MatrixPartitionMeta>> groupByParts = groupByPartitions(meta.getPartMetas()); <line8> Path modelPath = new Path(modelInputDir); <line9> Path convertedModelPath = new Path(convertedModelDir); <line10> FileSystem modelFs = modelPath.getFileSystem(conf); <line11> FileSystem convertedModelFs = convertedModelPath.getFileSystem(conf); <line12> if (convertedModelFs.exists(convertedModelPath)) { <line13> convertedModelFs.delete(convertedModelPath, true); <line14> } <line15> Vector<String> errorLogs = new Vector<>(); <line16> ConvertOp convertOp = <line17> new ConvertOp( <line18> modelPath, <line19> modelFs, <line20> convertedModelPath, <line21> convertedModelFs, <line22> lineConvert, <line23> groupByParts, <line24> meta, <line25> errorLogs, <line26> 0, <line27> groupByParts.size()); <line28> pool.execute(convertOp); <line29> convertOp.join(); <line30> if (!errorLogs.isEmpty()) { <line31> throw new IOException(String.join(""\n"", errorLogs)); <line32> } <line33> } <line34> } <line35> "	"<line13>      LOG.warn(""output directory "" + convertedModelDir + "" already exists"");"	task4	
public class A { <line0> private void scheduleOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) { <line1> if (scheduledFuture.get() == null && !context.isCurrentChangeSetProcessed()) { <line2> lock.lock(); <line3> try { <line4> Supplier<TaskAssigningSolution> solutionSupplier = () -> lastBestSolution.get(); <line5> ScheduledFuture<?> future = <line6> executorService.schedule( <line7> () -> executeSolutionChange(chBestSolution, solutionSupplier), <line8> delay, <line9> TimeUnit.MILLISECONDS); <line10> scheduledFuture.set(future); <line11> } finally { <line12> lock.unlock(); <line13> } <line14> } <line15> } <line16> } <line17> 	"<line3>      LOGGER.debug(""Schedule execute solution change with previous chBestSolution: {}"", chBestSolution);"	task4	
public class A { <line0> @Override <line1> public void shutdown() { <line2> if (log.isDebugEnabled()) { <line3> } <line4> scheduler.shutdown(); <line5> } <line6> } <line7> 	"<line3>      log.debug(""Shutting down scheduler thread pool"");"	task4	
"public class A { <line0> public boolean acquire(int numOps) { <line1> try { <line2> if (!semaphore.tryAcquire(numOps)) { <line3> Thread.sleep(WAIT_BEFORE_NEXT_ACQUIRE_PERMIT_IN_MS); <line4> return acquire(numOps); <line5> } <line6> } catch (InterruptedException e) { <line7> throw new RuntimeException(""Unable to acquire permits"", e); <line8> } <line9> return true; <line10> } <line11> } <line12> "	"<line6>      LOG.debug(String.format(""acquire permits: %s, maxPremits: %s"", numOps, maxPermits));"	task4	
public class A { <line0> private void loadWeightDataForOneDay(UpdateInfo updateInfo, String formattedDate) <line1> throws Exception { <line2> String json = getWeightData(updateInfo, formattedDate); <line3> String fatJson = getBodyFatData(updateInfo, formattedDate); <line4> JSONObject jsonWeight = JSONObject.fromObject(json); <line5> JSONObject jsonFat = JSONObject.fromObject(fatJson); <line6> json = mergeWeightInfos(jsonWeight, jsonFat); <line7> apiDataService.eraseApiData(updateInfo.apiKey, weightOT, Arrays.asList(formattedDate)); <line8> if (json != null) { <line9> JSONObject fitbitResponse = JSONObject.fromObject(json); <line10> final List<FitbitWeightFacet> createdOrUpdatedWeightFacets = <line11> fitbitPersistenceHelper.createOrUpdateWeightFacets(updateInfo, fitbitResponse); <line12> bodyTrackStorageService.storeApiData(updateInfo.apiKey, createdOrUpdatedWeightFacets); <line13> } <line14> } <line15> } <line16> 	"<line7>    logger.info(""guestId=""+ updateInfo.getGuestId()+ "" connector=fitbit action=loadWeightDataForOneDay json=""+ json);"	task4	
"public class A { <line0> public Map<String, Object> getUniqueApp(String assetGroup) { <line1> Map<String, Object> uniqueApp = new HashMap<>(); <line2> StringBuilder urlToQuery = new StringBuilder(esUrl).append(""/"").append(assetGroup); <line3> urlToQuery.append(""/"").append(""_search?filter_path=aggregations""); <line4> StringBuilder requestBody = <line5> new StringBuilder( <line6> ""{\""size\"":0,\""query\"":{\""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""_entity\"":true}}]}},"" <line7> + ""\""aggs\"":{\""severity\"":{\""filters\"":{\""filters\"":{\""S3\"":{\""has_child\"":{\""type\"":\""vulninfo\"",\""query\"":{"" <line8> + "" \""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""severitylevel.keyword\"":3}}]}}}},\""S4\"":{\""has_child\"":{\""type\"":\""vulninfo\"",\""query\"":{"" <line9> + "" \""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""severitylevel.keyword\"":4}}]}}}},\""S5\"":{\""has_child\"":{\""type\"":\""vulninfo\"",\""query\"":{"" <line10> + "" \""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""severitylevel.keyword\"":5}}]}}}}}},\""aggs\"":{\""NAME\"":{\""cardinality\"":{\""field\"":\""tags.Application.keyword\"",\""precision_threshold\"":"" <line11> + "" 40000}}}}}}""); <line12> String responseJson = """"; <line13> try { <line14> responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString()); <line15> } catch (Exception e) { <line16> } <line17> JsonParser jsonParser = new JsonParser(); <line18> if (StringUtils.isNotEmpty(responseJson)) { <line19> JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson); <line20> JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString()); <line21> JsonObject buckets = aggsJson.getAsJsonObject(SEVERITY).getAsJsonObject(BUCKETS); <line22> for (int i = 3; i <= 5; i++) { <line23> uniqueApp.put( <line24> String.valueOf(i), <line25> buckets <line26> .get(""S"" + i) <line27> .getAsJsonObject() <line28> .get(""NAME"") <line29> .getAsJsonObject() <line30> .get(VALUE) <line31> .getAsLong()); <line32> } <line33> } <line34> return uniqueApp; <line35> } <line36> } <line37> "	<line16>      LOGGER.error(Constants.ERROR_UNIQUEHOST, e);	task4	
"public class A { <line0> @Test <line1> public void findDuplicateVariables() throws IOException { <line2> Map<String, List<Variable>> variablesById = new LinkedHashMap<>(); <line3> for (SupportedCodebook supportedCodebook : SupportedCodebook.values()) { <line4> Codebook codebook = PdfParser.parseCodebookPdf(supportedCodebook); <line5> for (Variable variable : codebook.getVariables()) { <line6> if (!variablesById.containsKey(variable.getId())) <line7> variablesById.put(variable.getId(), new ArrayList<>()); <line8> variablesById.get(variable.getId()).add(variable); <line9> } <line10> } <line11> List<String> duplicatedVariableIds = new ArrayList<>(); <line12> for (String variableId : variablesById.keySet()) { <line13> List<Variable> variables = variablesById.get(variableId); <line14> if (variables.size() > 1) duplicatedVariableIds.add(variableId); <line15> } <line16> for (String duplicatedVariableId : duplicatedVariableIds) { <line17> List<Variable> duplicatedVariables = variablesById.get(duplicatedVariableId); <line18> } <line19> Assert.assertTrue(duplicatedVariableIds.contains(""BENE_ID"")); <line20> Assert.assertTrue(duplicatedVariableIds.contains(""DOB_DT"")); <line21> Assert.assertTrue(duplicatedVariableIds.contains(""GNDR_CD"")); <line22> Assert.assertEquals(87, duplicatedVariableIds.size()); <line23> } <line24> } <line25> "	"<line18>      LOGGER.warn(""The variable '{}' appears more than once: {}."",duplicatedVariableId,duplicatedVariables);"	task4	
public class A { <line0> @Test <line1> public void testOrganizationAdminRemovingOrganizationOwnerRoleByUsers() throws Exception { <line2> _organization = OrganizationTestUtil.addOrganization(); <line3> Role role = <line4> _roleLocalService.getRole(TestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER); <line5> _subjectUser = UserTestUtil.addOrganizationAdminUser(_organization); <line6> _objectUser = UserTestUtil.addOrganizationOwnerUser(_organization); <line7> try { <line8> _deleteUserGroupRolesByUser( <line9> _organization.getGroupId(), role.getRoleId(), _subjectUser, _objectUser); <line10> Assert.fail(); <line11> } catch (PrincipalException principalException) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> Assert.assertTrue( <line15> _userGroupRoleLocalService.hasUserGroupRole( <line16> _objectUser.getUserId(), _organization.getGroupId(), role.getRoleId())); <line17> } <line18> } <line19> } <line20> 	<line13>        log.debug(principalException, principalException);	task4	
public class A { <line0> protected ProcessBuilder createProcessBuilder(List<String> command, EnvironmentDescriptor env) { <line1> ProcessBuilder processBuilder = new ProcessBuilder(command); <line2> processBuilder.directory(new File(env.getWorkingDirectory())); <line3> processBuilder.environment().putAll(env.getParameters()); <line4> processBuilder.redirectErrorStream(true); <line5> return processBuilder; <line6> } <line7> } <line8> 	"<line2>    log.debug(""Building Process for command: {}"", () -> String.join("" "", processBuilder.command()));"	task4	
"public class A { <line0> public static int getGroupTagsCount(HttpPrincipal httpPrincipal, long groupId) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> AssetTagServiceUtil.class, ""getGroupTagsCount"", _getGroupTagsCountParameterTypes6); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line6> Object returnObj = null; <line7> try { <line8> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line11> } <line12> return ((Integer) returnObj).intValue(); <line13> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line14> throw systemException; <line15> } <line16> } <line17> } <line18> "	<line14>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> void repairMetadata() throws IOException { <line2> MCRContentInputStream cis = getContent().getContentInputStream(); <line3> IOUtils.copy(cis, DEV_NULL); <line4> cis.close(); <line5> String path = getPath(); <line6> writeData( <line7> e -> { <line8> e.setName(""file""); <line9> e.setAttribute(""name"", getName()); <line10> e.removeChildren(""file""); <line11> e.removeChildren(""directory""); <line12> String md5 = cis.getMD5String(); <line13> if (!md5.equals(e.getAttributeValue(""md5""))) { <line14> e.setAttribute(""md5"", md5); <line15> } <line16> }); <line17> } <line18> } <line19> "	"<line14>            LOGGER.warn(""Fixed MD5 of {} to {}"", path, md5);"	task4	
public class A { <line0> private List<Recommendation> createMetroPointRecommendations( <line1> VirtualArray srcVarray, <line2> List<VirtualArray> tgtVarrays, <line3> VirtualPool srcVpool, <line4> VirtualArray haVarray, <line5> VirtualPool haVpool, <line6> Project project, <line7> VirtualPoolCapabilityValuesWrapper capabilities, <line8> List<StoragePool> candidatePrimaryPools, <line9> List<StoragePool> candidateSecondaryPools, <line10> Volume vpoolChangeVolume) { <line11> List<Recommendation> recommendations = new ArrayList<Recommendation>(); <line12> RPProtectionRecommendation rpProtectionRecommendaton = null; <line13> Map<VirtualArray, List<StoragePool>> tgtVarrayStoragePoolsMap = <line14> getVplexTargetMatchingPools(tgtVarrays, srcVpool, project, capabilities, vpoolChangeVolume); <line15> rpProtectionRecommendaton = <line16> createRPProtectionRecommendationForMetroPoint( <line17> srcVarray, <line18> tgtVarrays, <line19> srcVpool, <line20> haVarray, <line21> haVpool, <line22> capabilities, <line23> candidatePrimaryPools, <line24> candidateSecondaryPools, <line25> tgtVarrayStoragePoolsMap, <line26> vpoolChangeVolume, <line27> project); <line28> recommendations.add(rpProtectionRecommendaton); <line29> return recommendations; <line30> } <line31> } <line32> 	"<line28>    log.info(String.format(""Produced %s recommendations for MetroPoint placement."",rpProtectionRecommendaton.getResourceCount()));"	task4	
public class A { <line0> public static void writeFile(File file, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> writeString((file != null) ? file.getCanonicalPath() : null, out); <line5> } <line6> } <line7> 	"<line3>      logger.trace(LogMarker.SERIALIZER_VERBOSE, ""Writing File {}"", file);"	task4	
"public class A { <line0> protected void releaseState(String peid, RunData rundata) { <line1> try { <line2> SessionState ss = ((JetspeedRunData) rundata).getPortletSessionState(peid); <line3> ControllerState state = (ControllerState) ss.getAttribute(""state""); <line4> state.recycle(); <line5> ss.removeAttribute(""state""); <line6> ss.clear(); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	<line8>      log.warn(e.getMessage(), e);	task4	
public class A { <line0> private void scheduleTMRequest(GetTranslationMemory action) { <line1> lastRequest = action; <line2> if (submittedRequest == null) { <line3> submitTMRequest(action); <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line5>      Log.debug(""blocking TM request until outstanding request returns"");"	task4	
public class A { <line0> @Override <line1> protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> final String servletBaseURL = req.getRequestURL().toString(); <line4> final Map<String, String> replaceMap = new HashMap<>(); <line5> handleSpotifyRedirect(replaceMap, servletBaseURL, req.getQueryString()); <line6> resp.setContentType(CONTENT_TYPE); <line7> replaceMap.put(KEY_REDIRECT_URI, servletBaseURL); <line8> replaceMap.put(KEY_PLAYERS, formatPlayers(playerTemplate, servletBaseURL)); <line9> resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap)); <line10> resp.getWriter().close(); <line11> } <line12> } <line13> 	"<line3>    logger.debug(""Spotify auth callback servlet received GET request {}."", req.getRequestURI());"	task4	
public class A { <line0> private void scheduleIdleChecks( <line1> Duration idleCheckInterval, ScheduledExecutorService idleCheckExecutor) { <line2> idleCheckExecutor.scheduleWithFixedDelay( <line3> () -> { <line4> try { <line5> cleanUpExpiredTransactions(); <line6> } catch (Throwable t) { <line7> } <line8> }, <line9> idleCheckInterval.toMillis(), <line10> idleCheckInterval.toMillis(), <line11> MILLISECONDS); <line12> } <line13> } <line14> 	"<line7>            log.error(t, ""Unexpected exception while cleaning up expired transactions"");"	task4	
public class A { <line0> public void setRunInfo(final RunInfo runInfo) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> this.runInfo = runInfo; <line4> for (final Reporter r : reporters) { <line5> r.setRunInfo(runInfo); <line6> } <line7> } <line8> } <line9> 	"<line2>      log.debug(""A new run info set "" + runInfo);"	task4	
"public class A { <line0> @Override <line1> public void configure( <line2> DBBroker broker, Txn transaction, Collection parent, Map<String, List<?>> parameters) <line3> throws TriggerException { <line4> super.configure(broker, transaction, parent, parameters); <line5> final String stylesheet = (String) parameters.get(""src"").get(0); <line6> if (stylesheet == null) { <line7> throw new TriggerException(""STXTransformerTrigger requires an attribute 'src'""); <line8> } <line9> XmldbURI stylesheetUri = null; <line10> try { <line11> stylesheetUri = XmldbURI.xmldbUriFor(stylesheet); <line12> } catch (final URISyntaxException e) { <line13> } <line14> if (stylesheetUri == null || stylesheet.indexOf(':') == Constants.STRING_NOT_FOUND) { <line15> stylesheetUri = parent.getURI().resolveCollectionPath(stylesheetUri); <line16> DocumentImpl doc; <line17> try { <line18> doc = (DocumentImpl) broker.getXMLResource(stylesheetUri); <line19> if (doc == null) { <line20> throw new TriggerException(""stylesheet "" + stylesheetUri + "" not found in database""); <line21> } <line22> if (doc instanceof BinaryDocument) { <line23> throw new TriggerException( <line24> ""stylesheet "" <line25> + stylesheetUri <line26> + "" must be stored as an xml document and not a binary document!""); <line27> } <line28> handler = <line29> factory.newTransformerHandler( <line30> STXTemplatesCache.getInstance().getOrUpdateTemplate(broker, doc)); <line31> } catch (final TransformerConfigurationException <line32> | PermissionDeniedException <line33> | SAXException <line34> | LockException e) { <line35> throw new TriggerException(e.getMessage(), e); <line36> } <line37> } else { <line38> try { <line39> final Templates template = factory.newTemplates(new StreamSource(stylesheet)); <line40> handler = factory.newTransformerHandler(template); <line41> } catch (final TransformerConfigurationException e) { <line42> throw new TriggerException(e.getMessage(), e); <line43> } <line44> } <line45> } <line46> } <line47> "	"<line39>        LOG.debug(""compiling stylesheet {}"", stylesheet);"	task4	
public class A { <line0> @Override <line1> public void removeBranchSession(GlobalSession globalSession, BranchSession branchSession) <line2> throws TransactionException { <line3> if (LOGGER.isDebugEnabled()) { <line4> } <line5> writeSession(LogOperation.BRANCH_REMOVE, branchSession); <line6> } <line7> } <line8> 	"<line4>      LOGGER.debug(""MANAGER["" + name + ""] SESSION["" + branchSession + ""] "" + LogOperation.BRANCH_REMOVE);"	task4	
"public class A { <line0> @Test <line1> public void testFilter() { <line2> String xml = <line3> ""<wfs:GetFeature service=\""WFS\"" version=\""1.1.0\"" outputFormat=\""gml32\"""" <line4> + "" xmlns:ogc=\""http://www.opengis.net/ogc\"" xmlns:wfs=\""http://www.opengis.net/wfs\"""" <line5> + "" xmlns:gml=\""http://www.opengis.net/gml/3.2\"""" <line6> + "" xmlns:wml2dr=\""http://www.opengis.net/waterml/DR/2.0\"""" <line7> + "" xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" "" <line8> + ""xsi:schemaLocation=\""http://www.opengis.net/wfs"" <line9> + "" http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\""><wfs:Query"" <line10> + "" typeName=\""wml2dr:MeasurementTimeseriesDomainRange\"">    <ogc:Filter>       "" <line11> + "" <ogc:PropertyIsLike wildCard=\""*\"" singleChar=\""#\"" escapeChar=\""\\\"">           "" <line12> + "" <ogc:PropertyName>wml2dr:MeasurementTimeseriesDomainRange/gml:rangeSet/gml:QuantityList</ogc:PropertyName>"" <line13> + ""            <ogc:Literal>*16.2*</ogc:Literal>        </ogc:PropertyIsLike>   "" <line14> + "" </ogc:Filter></wfs:Query> </wfs:GetFeature>""; <line15> validate(xml); <line16> Document doc = postAsDOM(""wfs"", xml); <line17> assertEquals(""wfs:FeatureCollection"", doc.getDocumentElement().getNodeName()); <line18> assertXpathEvaluatesTo(""1"", ""/wfs:FeatureCollection/@numberReturned"", doc); <line19> assertXpathCount(1, ""//wml2dr:MeasurementTimeseriesDomainRange"", doc); <line20> assertXpathEvaluatesTo(""ID2"", ""//wml2dr:MeasurementTimeseriesDomainRange/@gml:id"", doc); <line21> assertXpathEvaluatesTo( <line22> ""tpl."" + ""ID2"", <line23> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line24> + ""ID2"" <line25> + ""']/gml:domainSet/wml2dr:TimePositionList/@gml:id"", <line26> doc); <line27> assertXpathEvaluatesTo( <line28> ""16.2"", <line29> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line30> + ""ID2"" <line31> + ""']/gml:rangeSet/gml:QuantityList"", <line32> doc); <line33> assertXpathEvaluatesTo( <line34> ""degC"", <line35> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line36> + ""ID2"" <line37> + ""']/gml:rangeSet/gml:QuantityList/@uom"", <line38> doc); <line39> assertXpathEvaluatesTo( <line40> ""string"", <line41> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line42> + ""ID2"" <line43> + ""']/gml:coverageFunction/gml:MappingRule"", <line44> doc); <line45> assertXpathEvaluatesTo( <line46> ""http://ns.bgs.ac.uk/thesaurus/lithostratigraphy"", <line47> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line48> + ""ID2"" <line49> + ""']/gmlcov:rangeType/@xlink:href"", <line50> doc); <line51> assertXpathEvaluatesTo( <line52> ""1949-05-01T00:00:00Z"", <line53> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line54> + ""ID2"" <line55> + ""']/gml:domainSet/wml2dr:TimePositionList/wml2dr:timePositionList"", <line56> doc); <line57> } <line58> } <line59> "	"<line17>    LOGGER.info(""WFS filter GetFeature response:\n"" + prettyString(doc));"	task4	
public class A { <line0> protected final boolean isLayerizedNetwork(String networkId) { <line1> String connType = getConnectionType(networkId); <line2> if (LAYERIZED_NETWORK.equals(connType)) { <line3> return true; <line4> } <line5> return false; <line6> } <line7> } <line8> 	"<line1>    log.debug("""");"	task4	
public class A { <line0> private void handleProcessingTime(long processingTime, String documentId) <line1> throws IOException, InterruptedException { <line2> if (processingTime > processingTimeThreshold) { <line3> Map<CharSequence, CharSequence> supplementaryData = new HashMap<CharSequence, CharSequence>(); <line4> supplementaryData.put( <line5> FAULT_SUPPLEMENTARY_DATA_PROCESSING_TIME, String.valueOf(processingTime)); <line6> mos.write( <line7> namedOutputFault, <line8> new AvroKey<Fault>( <line9> Fault.newBuilder() <line10> .setInputObjectId(documentId) <line11> .setTimestamp(System.currentTimeMillis()) <line12> .setCode(FAULT_CODE_PROCESSING_TIME_THRESHOLD_EXCEEDED) <line13> .setSupplementaryData(supplementaryData) <line14> .build())); <line15> } <line16> } <line17> } <line18> 	"<line16>    log.info(""finished processing for id "" + documentId + "" in "" + (processingTime / 1000) + "" secs"");"	task4	
public class A { <line0> protected void rollback() { <line1> try { <line2> if (conn != null && !conn.isClosed()) { <line3> conn.rollback(); <line4> } <line5> } catch (SQLException e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.warn(""Rollback failed"", e);"	task4	
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrderItem updateCommerceOrderItemUnitPrice( <line1> HttpPrincipal httpPrincipal, <line2> long commerceOrderItemId, <line3> int quantity, <line4> java.math.BigDecimal unitPrice) <line5> throws com.liferay.portal.kernel.exception.PortalException { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> CommerceOrderItemServiceUtil.class, <line10> ""updateCommerceOrderItemUnitPrice"", <line11> _updateCommerceOrderItemUnitPriceParameterTypes29); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, commerceOrderItemId, quantity, unitPrice); <line14> Object returnObj = null; <line15> try { <line16> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line17> } catch (Exception exception) { <line18> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line19> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line20> } <line21> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line22> } <line23> return (com.liferay.commerce.model.CommerceOrderItem) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line25> throw systemException; <line26> } <line27> } <line28> } <line29> "	<line25>      log.error(systemException, systemException);	task4	
"public class A { <line0> @POST <line1> @Timed <line2> @Produces(""application/x-yaml"") <line3> @Path(""adps"") <line4> @ApiOperation(""Get SeaClouds-compliant ADP list from an AAM document"") <line5> public Response getAdps(@ApiParam() String aam) { <line6> if (aam == null) { <line7> return Response.status(Response.Status.NOT_ACCEPTABLE).build(); <line8> } else { <line9> return Response.ok(planner.getAdps(aam)).build(); <line10> } <line11> } <line12> } <line13> "	"<line7>      LOG.error(""Missing input parameters"");"	task4	
public class A { <line0> private static boolean isValidTemporalColumn(long tableId, Type type) { <line1> if (!type.equals(DATE) && !type.equals(TIMESTAMP)) { <line2> return false; <line3> } <line4> return true; <line5> } <line6> } <line7> 	"<line2>      log.warn(""Temporal column type of table ID %s set incorrectly to %s"", tableId, type);"	task4	
public class A { <line0> public List<Template> findAllTemplates() { <line1> return templateRepository.findAll(); <line2> } <line3> } <line4> 	"<line1>    log.debug(""findAllTemplates()"");"	task4	
"public class A { <line0> @RestAccessControl(permission = Permission.SUPERUSER) <line1> @RequestMapping( <line2> value = ""/kiebpm/serverConfigs/{configCode}/caseDefinitions/{deploymentUnit:.+}"", <line3> method = RequestMethod.GET, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<SimpleRestResponse<Map<String, Object>>> getCaseDefinitions( <line6> @PathVariable String configCode, @PathVariable String deploymentUnit) { <line7> JSONObject cases = null; <line8> try { <line9> KieServerConfigDto serverConfigDto = kieConfigService.getConfig(configCode); <line10> KieBpmConfig bpmConfig = kieConfigService.buildConfig(serverConfigDto); <line11> cases = caseManager.getCasesDefinitions(bpmConfig, deploymentUnit); <line12> } catch (Exception e) { <line13> } <line14> if (cases == null) { <line15> cases = new JSONObject(); <line16> } <line17> return new ResponseEntity<>(new SimpleRestResponse<>(cases.toMap()), HttpStatus.OK); <line18> } <line19> } <line20> "	"<line13>      logger.error(""Failed to fetch container ids "", e);"	task4	
"public class A { <line0> @Override <line1> public synchronized void start() { <line2> Assert.state(m_worker == null, ""The fiber has already run or is running""); <line3> m_worker = new Thread(this, getName()); <line4> m_worker.start(); <line5> m_status = STARTING; <line6> } <line7> } <line8> "	"<line6>    LOG.info(""start: scheduler started"");"	task4	
"public class A { <line0> private static MCRCategoryImpl buildCategoryFromPrefetchedList( <line1> List<MCRCategoryDTO> list, MCRCategoryID returnID) { <line2> MCRCategoryImpl predecessor = null; <line3> for (MCRCategoryDTO entry : list) { <line4> predecessor = entry.merge(predecessor); <line5> } <line6> return MCRStreamUtils.flatten( <line7> predecessor.getRoot(), MCRCategory::getChildren, Collection::parallelStream) <line8> .filter(c -> c.getId().equals(returnID)) <line9> .findFirst() <line10> .map(MCRCategoryImpl.class::cast) <line11> .orElseThrow(() -> new MCRException(""Could not find "" + returnID + "" in database result."")); <line12> } <line13> } <line14> "	"<line2>    LOGGER.debug(() -> ""using prefetched list: "" + list);"	task4	
public class A { <line0> public List<PersonInfo> getPeople() { <line1> List<PersonInfo> people = new LinkedList<PersonInfo>(); <line2> List<Person> peopleDb = personDao.getAllRecords(); <line3> for (Person subject : peopleDb) { <line4> PersonInfo person = createPersonInfo(subject); <line5> people.add(person); <line6> } <line7> return people; <line8> } <line9> } <line10> 	"<line7>    log.debug(""User "" + personDao.getLoggedPerson().getEmail() + "" retrieved list of people."");"	task4	
public class A { <line0> @Override <line1> public PipelinedSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) { <line2> synchronized (buffers) { <line3> checkState(!isReleased); <line4> releaseView(); <line5> readView = new PipelinedApproximateSubpartitionView(this, availabilityListener); <line6> } <line7> return readView; <line8> } <line9> } <line10> 	"<line5>      LOG.debug(""{}: Creating read view for subpartition {} of partition {}."",parent.getOwningTaskName(),getSubPartitionIndex(),parent.getPartitionId());"	task4	
public class A { <line0> private void refreshMemoryPools() { <line1> boolean reInitPools = false; <line2> Iterator<Map.Entry<MemoryPoolMXBean, Statistics>> it = mpMap.entrySet().iterator(); <line3> while (it.hasNext()) { <line4> Map.Entry<MemoryPoolMXBean, Statistics> me = it.next(); <line5> MemoryPoolMXBean mp = me.getKey(); <line6> Statistics s = me.getValue(); <line7> if (!mp.isValid()) { <line8> s.close(); <line9> it.remove(); <line10> reInitPools = true; <line11> } else { <line12> MemoryUsage mu = null; <line13> try { <line14> mu = mp.getUsage(); <line15> } catch (IllegalArgumentException ex) { <line16> continue; <line17> } catch (InternalError ie) { <line18> s.close(); <line19> it.remove(); <line20> reInitPools = true; <line21> continue; <line22> } <line23> s.setLong(mp_l_initMemoryId, mu.getInit()); <line24> s.setLong(mp_l_usedMemoryId, mu.getUsed()); <line25> s.setLong(mp_l_committedMemoryId, mu.getCommitted()); <line26> s.setLong(mp_l_maxMemoryId, mu.getMax()); <line27> if (mp.isUsageThresholdSupported()) { <line28> s.setLong(mp_usageThresholdId, mp.getUsageThreshold()); <line29> s.setLong(mp_usageExceededId, mp.getUsageThresholdCount()); <line30> } <line31> mu = null; <line32> if (!this.isCollectionUsageUnsupported(mp)) { <line33> try { <line34> mu = mp.getCollectionUsage(); <line35> } catch (UnsupportedOperationException ex) { <line36> this.setCollectionUsageUnsupported(mp); <line37> } catch (IllegalArgumentException ex) { <line38> this.setCollectionUsageUnsupported(mp); <line39> } <line40> } <line41> if (mu != null) { <line42> s.setLong(mp_gc_usedMemoryId, mu.getUsed()); <line43> if (mp.isCollectionUsageThresholdSupported()) { <line44> s.setLong(mp_collectionUsageThresholdId, mp.getCollectionUsageThreshold()); <line45> s.setLong(mp_collectionUsageExceededId, mp.getCollectionUsageThresholdCount()); <line46> } <line47> } <line48> } <line49> } <line50> if (reInitPools) { <line51> initMemoryPools(); <line52> } <line53> } <line54> } <line55> 	"<line21>          logger.warn(""Accessing MemoryPool '{}' threw an Internal Error: {}"",mp.getName(),ie.getMessage());"	task4	
public class A { <line0> private static void addAuthorization(SearchMetadataCollection doc, String aclString) { <line1> Map<String, List<String>> permissions = new HashMap<String, List<String>>(); <line2> for (Action action : Permissions.Action.values()) { <line3> permissions.put(action.toString(), new ArrayList<String>()); <line4> } <line5> AccessControlList acl = AccessControlParser.parseAclSilent(aclString); <line6> for (AccessControlEntry entry : acl.getEntries()) { <line7> if (!entry.isAllow()) { <line8> continue; <line9> } <line10> List<String> actionPermissions = permissions.get(entry.getAction()); <line11> if (actionPermissions == null) { <line12> actionPermissions = new ArrayList<String>(); <line13> permissions.put(entry.getAction(), actionPermissions); <line14> } <line15> actionPermissions.add(entry.getRole()); <line16> } <line17> for (Map.Entry<String, List<String>> entry : permissions.entrySet()) { <line18> String fieldName = EventIndexSchema.ACL_PERMISSION_PREFIX.concat(entry.getKey()); <line19> doc.addField(fieldName, entry.getValue(), false); <line20> } <line21> } <line22> } <line23> 	"<line8>        logger.info(""Event index does not support denial via ACL, ignoring {}"", entry);"	task4	
public class A { <line0> private void executeOrMerge() { <line1> int size = queueSize.incrementAndGet(); <line2> if (size > maxThreads) { <line3> return; <line4> } <line5> do { <line6> try { <line7> queue.poll().run(); <line8> } catch (Throwable e) { <line9> } <line10> } while (queueSize.getAndDecrement() > maxThreads); <line11> } <line12> } <line13> 	"<line9>        log.error(e, ""Task failed"");"	task4	
"public class A { <line0> @RequestMapping( <line1> value = ""/{jobId}"", <line2> method = {RequestMethod.GET}, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> public JobInstance get(@PathVariable String jobId) { <line6> JobInstance jobInstance = null; <line7> try { <line8> jobInstance = jobService.getJobInstance(jobId); <line9> } catch (Exception e) { <line10> throw new InternalErrorException(e); <line11> } <line12> return jobInstance; <line13> } <line14> } <line15> "	<line10>      logger.error(e.getLocalizedMessage(), e);	task4	
"public class A { <line0> public static int getFoldersAndFileEntriesAndFileShortcutsCount( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> long folderId, <line4> String[] mimeTypes, <line5> boolean includeMountFolders, <line6> com.liferay.portal.kernel.dao.orm.QueryDefinition<?> queryDefinition) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> DLFolderServiceUtil.class, <line12> ""getFoldersAndFileEntriesAndFileShortcutsCount"", <line13> _getFoldersAndFileEntriesAndFileShortcutsCountParameterTypes23); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, groupId, folderId, mimeTypes, includeMountFolders, queryDefinition); <line17> Object returnObj = null; <line18> try { <line19> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line20> } catch (Exception exception) { <line21> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line22> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line23> } <line24> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line25> } <line26> return ((Integer) returnObj).intValue(); <line27> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line28> throw systemException; <line29> } <line30> } <line31> } <line32> "	<line28>      log.error(systemException, systemException);	task4	
public class A { <line0> private void writeSerializedPublicKeyLength(SrpClientKeyExchangeMessage msg) { <line1> appendInt(msg.getPublicKeyLength().getValue(), HandshakeByteLength.SRP_PUBLICKEY_LENGTH); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""SerializedPublicKexLength: "" + msg.getPublicKeyLength().getValue());"	task4	
"public class A { <line0> @Override <line1> public void destroyNode(String id) { <line2> VirtualGuest guest = getNode(id); <line3> if (guest == null) return; <line4> if (guest.getBillingItemId() == -1) <line5> throw new IllegalStateException( <line6> String.format(""no billing item for guest(%s) so we cannot cancel the order"", id)); <line7> client.getVirtualGuestClient().cancelService(guest.getBillingItemId()); <line8> } <line9> } <line10> "	"<line7>    logger.debug("">> canceling service for guest(%s) billingItem(%s)"", id, guest.getBillingItemId());"	task4	
public class A { <line0> @Override <line1> public void debug(String msg, Throwable thrown) { <line2> } <line3> } <line4> 	<line2>    logger.debug(msg, thrown);	task4	
public class A { <line0> @Override <line1> public void appendAddEvent( <line2> long id, <line3> byte recordType, <line4> Persister persister, <line5> Object record, <line6> boolean sync, <line7> IOCompletion completionCallback) <line8> throws Exception { <line9> if (log.isTraceEnabled()) { <line10> } <line11> replicationManager.appendUpdateRecord( <line12> journalID, ADD_OPERATION_TYPE.EVENT, id, recordType, persister, record); <line13> localJournal.appendAddEvent(id, recordType, persister, record, sync, completionCallback); <line14> } <line15> } <line16> 	"<line10>      log.trace(""Append record id = "" + id + "" recordType = "" + recordType);"	task4	
public class A { <line0> @Override <line1> @Transactional(readOnly = false) <line2> public void setTimeZone(long guestId, String date, String timeZone) { <line3> } <line4> } <line5> 	"<line3>    logger.warn(""component=metadata action=setTimeZone message=attempt to set timezone"");"	task4	
"public class A { <line0> protected void startTraceJaegerGrpcListener( <line1> final String strPort, <line2> ReportableEntityHandlerFactory handlerFactory, <line3> @Nullable WavefrontSender wfSender, <line4> SpanSampler sampler) { <line5> if (tokenAuthenticator.authRequired()) { <line6> logger.warning(""Port: "" + strPort + "" is not compatible with HTTP authentication, ignoring""); <line7> return; <line8> } <line9> final int port = Integer.parseInt(strPort); <line10> startAsManagedThread( <line11> port, <line12> () -> { <line13> activeListeners.inc(); <line14> try { <line15> io.grpc.Server server = <line16> NettyServerBuilder.forPort(port) <line17> .addService( <line18> new JaegerGrpcCollectorHandler( <line19> strPort, <line20> handlerFactory, <line21> wfSender, <line22> () -> entityProps.get(ReportableEntityType.TRACE).isFeatureDisabled(), <line23> () -> <line24> entityProps <line25> .get(ReportableEntityType.TRACE_SPAN_LOGS) <line26> .isFeatureDisabled(), <line27> preprocessors.get(strPort), <line28> sampler, <line29> proxyConfig.getTraceJaegerApplicationName(), <line30> proxyConfig.getTraceDerivedCustomTagKeys())) <line31> .build(); <line32> server.start(); <line33> } catch (Exception e) { <line34> logger.log(Level.SEVERE, ""Jaeger gRPC trace collector exception"", e); <line35> } finally { <line36> activeListeners.dec(); <line37> } <line38> }, <line39> ""listener-jaeger-grpc-"" + strPort); <line40> } <line41> } <line42> "	"<line40>    logger.info(""listening on port: ""+ strPort+ "" for trace data ""+ ""(Jaeger Protobuf format over gRPC)"");"	task4	
public class A { <line0> private String cloneVMforVvols( <line1> VmwareContext context, <line2> VmwareHypervisorHost hyperHost, <line3> TemplateObjectTO template, <line4> VirtualMachineMO vmTemplate, <line5> VolumeObjectTO volume, <line6> DatacenterMO dcMo, <line7> DatastoreMO dsMo) <line8> throws Exception { <line9> ManagedObjectReference morDatastore = dsMo.getMor(); <line10> ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool(); <line11> ManagedObjectReference morCluster = hyperHost.getHyperHostCluster(); <line12> if (template.getSize() != null) { <line13> _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag; <line14> } <line15> String vmName = volume.getVmName(); <line16> if (volume.getVolumeType() == Volume.Type.DATADISK) vmName = volume.getName(); <line17> if (!_fullCloneFlag) { <line18> createVMLinkedClone(vmTemplate, dcMo, vmName, morDatastore, morPool); <line19> } else { <line20> createVMFullClone(vmTemplate, dcMo, dsMo, vmName, morDatastore, morPool); <line21> } <line22> VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmName); <line23> assert (vmMo != null); <line24> String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0); <line25> if (volume.getVolumeType() == Volume.Type.DATADISK) { <line26> vmMo.detachAllDisks(); <line27> vmMo.destroy(); <line28> } <line29> return vmdkFileBaseName; <line30> } <line31> } <line32> 	"<line26>      logger.info(""detach disks from volume-wrapper VM "" + vmName);"	task4	
public class A { <line0> @Override <line1> public void removeItemMetadata(String name) { <line2> getAll().stream() <line3> .filter(MetadataPredicates.ofItem(name)) <line4> .map(Metadata::getUID) <line5> .forEach(this::remove); <line6> } <line7> } <line8> 	"<line2>    logger.debug(""Removing all metadata for item {}"", name);"	task4	
"public class A { <line0> public static Node copy(Session session, String srcPath, String destPath) { <line1> try { <line2> session.getWorkspace().copy(srcPath, destPath); <line3> return session.getNode(destPath); <line4> } catch (AccessDeniedException e) { <line5> throw new AccessControlException(e.getMessage()); <line6> } catch (RepositoryException e) { <line7> throw new MetadataRepositoryException( <line8> ""Failed to copy source path: "" + srcPath + "" to destination path: "" + destPath, e); <line9> } <line10> } <line11> } <line12> "	"<line5>      log.debug(""Access denied"", e);"	task4	
"public class A { <line0> @Override <line1> public Map<String, String> start() { <line2> try { <line3> container = <line4> new GenericContainer<>(IMAGE) <line5> .withExposedPorts(TCP_PORT) <line6> .withLogConsumer(new Slf4jLogConsumer(LOGGER)) <line7> .waitingFor(Wait.forLogMessage("".* mosquitto version .* running"", 1)) <line8> .waitingFor(Wait.forListeningPort()); <line9> container.start(); <line10> return CollectionHelper.mapOf( <line11> ""paho5.broker.tcp.url"", <line12> String.format(""tcp://localhost:%d"", container.getMappedPort(TCP_PORT))); <line13> } catch (Exception e) { <line14> throw new RuntimeException(e); <line15> } <line16> } <line17> } <line18> "	<line2>    LOGGER.info(TestcontainersConfiguration.getInstance().toString());	task4	
public class A { <line0> @Override <line1> public Void doOperation(KieServicesClient client, Container container) { <line2> KieScannerResource scannerResource = new KieScannerResource(); <line3> scannerResource.setPollInterval(null); <line4> scannerResource.setStatus(KieScannerStatus.SCANNING); <line5> ServiceResponse<KieScannerResource> response = <line6> client.updateScanner(containerSpec.getId(), scannerResource); <line7> if (!response.getType().equals(ServiceResponse.ResponseType.SUCCESS)) { <line8> container.setStatus(KieContainerStatus.FAILED); <line9> } <line10> collectContainerInfo(containerSpec, client, container); <line11> return null; <line12> } <line13> } <line14> 	"<line8>      logger.debug(""Scanner (scan now) failed on server instance {} due to {}"",container.getUrl(),response.getMsg());"	task4	
public class A { <line0> @Override <line1> protected @Nullable ThingHandler createHandler(Thing thing) { <line2> ThingHandler resultHandler = null; <line3> ThingTypeUID thingTypeUID = thing.getThingTypeUID(); <line4> if (VeluxBindingConstants.SUPPORTED_THINGS_BINDING.contains(thingTypeUID)) { <line5> resultHandler = createBindingHandler(thing); <line6> } else if (VeluxBindingConstants.SUPPORTED_THINGS_BRIDGE.contains(thingTypeUID)) { <line7> resultHandler = createBridgeHandler(thing); <line8> } else if (VeluxBindingConstants.SUPPORTED_THINGS_ITEMS.contains(thingTypeUID)) { <line9> resultHandler = createThingHandler(thing); <line10> } else { <line11> } <line12> updateBindingState(); <line13> return resultHandler; <line14> } <line15> } <line16> 	"<line11>      logger.warn(""createHandler({}) failed: ThingHandler not found for {}."",thingTypeUID,thing.getLabel());"	task4	
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrder updateCommerceOrder( <line1> HttpPrincipal httpPrincipal, <line2> String externalReferenceCode, <line3> long commerceOrderId, <line4> long billingAddressId, <line5> long shippingAddressId, <line6> String commercePaymentMethodKey, <line7> long commerceShippingMethodId, <line8> String shippingOptionName, <line9> String purchaseOrderNumber, <line10> java.math.BigDecimal subtotal, <line11> java.math.BigDecimal shippingAmount, <line12> java.math.BigDecimal total, <line13> java.math.BigDecimal subtotalWithTaxAmount, <line14> java.math.BigDecimal shippingWithTaxAmount, <line15> java.math.BigDecimal totalWithTaxAmount, <line16> String advanceStatus, <line17> com.liferay.commerce.context.CommerceContext commerceContext) <line18> throws com.liferay.portal.kernel.exception.PortalException { <line19> try { <line20> MethodKey methodKey = <line21> new MethodKey( <line22> CommerceOrderServiceUtil.class, <line23> ""updateCommerceOrder"", <line24> _updateCommerceOrderParameterTypes37); <line25> MethodHandler methodHandler = <line26> new MethodHandler( <line27> methodKey, <line28> externalReferenceCode, <line29> commerceOrderId, <line30> billingAddressId, <line31> shippingAddressId, <line32> commercePaymentMethodKey, <line33> commerceShippingMethodId, <line34> shippingOptionName, <line35> purchaseOrderNumber, <line36> subtotal, <line37> shippingAmount, <line38> total, <line39> subtotalWithTaxAmount, <line40> shippingWithTaxAmount, <line41> totalWithTaxAmount, <line42> advanceStatus, <line43> commerceContext); <line44> Object returnObj = null; <line45> try { <line46> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line47> } catch (Exception exception) { <line48> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line49> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line50> } <line51> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line52> } <line53> return (com.liferay.commerce.model.CommerceOrder) returnObj; <line54> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line55> throw systemException; <line56> } <line57> } <line58> } <line59> "	<line55>      log.error(systemException, systemException);	task4	
public class A { <line0> public void putClient(Node node, Client client) { <line1> ClusterNode clusterNode = new ClusterNode(node); <line2> Deque<Client> clientStack = clientCaches.computeIfAbsent(clusterNode, n -> new ArrayDeque<>()); <line3> synchronized (this) { <line4> if (client.getInputProtocol() != null && client.getInputProtocol().getTransport().isOpen()) { <line5> clientStack.push(client); <line6> NodeStatusManager.getINSTANCE().activate(node); <line7> } else { <line8> try { <line9> clientStack.push(syncClientFactory.getSyncClient(node, this)); <line10> NodeStatusManager.getINSTANCE().activate(node); <line11> } catch (TTransportException e) { <line12> nodeClientNumMap.computeIfPresent(clusterNode, (n, oldValue) -> oldValue - 1); <line13> NodeStatusManager.getINSTANCE().deactivate(node); <line14> } <line15> } <line16> this.notifyAll(); <line17> } <line18> } <line19> } <line20> 	"<line12>          logger.error(""Cannot open transport for client {}"", node, e);"	task4	
"public class A { <line0> @Override <line1> public Object call() throws Exception { <line2> RdfReader rdfReader = RdfReaderFactory.createFileOrResourceReader(schemaPath, uri); <line3> SchemaSource schemaSource = <line4> SchemaSourceFactory.createSchemaSourceSimple(prefix, uri, rdfReader); <line5> RDFUnit rdfUnit = RDFUnit.createWithAllGenerators().init(); <line6> Collection<TestGenerator> testGenerators = rdfUnit.getAutoGenerators(); <line7> ImmutableList.Builder<RdfUnitTestGenerator> builder = ImmutableList.builder(); <line8> builder.add(new TagRdfUnitTestGenerator(testGenerators)); <line9> builder.add(new ShaclTestGenerator()); <line10> RdfUnitTestGenerator g; <line11> if (datafolder != null) { <line12> String testFolder = this.datafolder + ""tests/""; <line13> g = <line14> new GenerateAndCacheRdfUnitTestGenerator( <line15> new CompositeTestGenerator(builder.build()), testFolder); <line16> } else { <line17> g = new CompositeTestGenerator(builder.build()); <line18> } <line19> Collection<GenericTestCase> tests = new ArrayList<>(g.generate(schemaSource)); <line20> if (!tests.isEmpty()) { <line21> if (output.trim().equals(""-"")) { <line22> TestUtils.writeTestsToFile(tests, new RdfStreamWriter(System.out), addExplicitWhere); <line23> } else { <line24> File outputFile = new File(output); <line25> outputFile.getParentFile().mkdirs(); <line26> TestUtils.writeTestsToFile(tests, new RdfFileWriter(outputFile.getAbsolutePath())); <line27> } <line28> } <line29> return null; <line30> } <line31> } <line32> "	"<line5>    log.info(""Generating tests"");"	task4	
public class A { <line0> private void checkQueueLength() { <line1> if (connectionExecutor.getQueue().size() > queuewarninglimit) { <line2> } <line3> } <line4> } <line5> 	"<line2>      logger.warn(new IllegalThreadStateException(""connectionordered channel handler `queue size: ""+ connectionExecutor.getQueue().size()+ "" exceed the warning limit number :""+ queuewarninglimit));"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> task.run(); <line4> } catch (Throwable t) { <line5> Throwables.throwIfUnchecked(t); <line6> throw new AssertionError(t); <line7> } <line8> } <line9> } <line10> 	"<line5>      log.error(""Exception while executing runnable "" + task, t);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public T getValue() { <line3> try { <line4> return (T) server.getAttribute(objectName, attributeName); <line5> } catch (MBeanException <line6> | AttributeNotFoundException <line7> | InstanceNotFoundException <line8> | ReflectionException e) { <line9> return errorValue; <line10> } <line11> } <line12> } <line13> "	"<line9>      LOG.warn(""Could not read attribute {}."", attributeName, e);"	task4	
"public class A { <line0> @RequestMapping(value = ""/masstruncate"", method = RequestMethod.GET) <line1> public ResponseEntity<?> doGet(HttpServletRequest req) { <line2> XStream xs = configXStream(new GeoWebCacheXStream()); <line3> StringBuilder sb = new StringBuilder(); <line4> Set<String> result = new HashSet<>(); <line5> sb.append(""<massTruncateRequests href=\"""").append(req.getRequestURL()).append(""\"">""); <line6> for (Class<?> requestType : getRequestTypes()) { <line7> String alias = xs.getMapper().serializedClass(requestType); <line8> sb.append("" <requestType>""); <line9> sb.append(alias); <line10> sb.append(""</requestType>""); <line11> if (!result.add(alias) && log.isWarnEnabled()) { <line12> } <line13> } <line14> sb.append(""</massTruncateRequests>""); <line15> return new ResponseEntity<Object>(sb.toString(), HttpStatus.OK); <line16> } <line17> } <line18> "	"<line12>        log.warn(""Duplicate MassTruncate RestException type: "" + alias);"	task4	
public class A { <line0> public void loadDefaultTests() { <line1> List<MetaData> types = ServiceData.getLocalInstance().getServiceTypes(); <line2> for (int i = 0; i < types.size(); ++i) { <line3> MetaData type = types.get(i); <line4> matrix.servicesToTest.add(type.getSimpleName()); <line5> } <line6> for (String test : tests) { <line7> matrix.testsToRun.add(test); <line8> } <line9> matrix.currentProgress.totalTests = matrix.servicesToTest.size() * matrix.testsToRun.size(); <line10> } <line11> } <line12> 	"<line4>      log.info(""adding {}"", type.getSimpleName());"	task4	
"public class A { <line0> @Override <line1> public void clearCache() throws AiravataSecurityException { <line2> try { <line3> AuthzCache.getInstance().clear(); <line4> } catch (ApplicationSettingsException e) { <line5> throw new AiravataSecurityException(""Error in obtaining the authorization cache instance.""); <line6> } <line7> } <line8> } <line9> "	<line5>      logger.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public void dispose() { <line2> ScheduledFuture<?> job = refreshJob; <line3> if (job != null && !job.isCancelled()) { <line4> job.cancel(true); <line5> } <line6> refreshJob = null; <line7> } <line8> } <line9> 	"<line2>    logger.debug(""WeMoMakerHandler disposed."");"	task4	
public class A { <line0> @Override <line1> public void onToServerRpcResponse(TransportProtos.ToServerRpcResponseMsg msg) { <line2> try { <line3> exchange.respond(coapTransportAdaptor.convertToPublish(isConRequest(), msg)); <line4> } catch (AdaptorException e) { <line5> exchange.respond(CoAP.ResponseCode.INTERNAL_SERVER_ERROR); <line6> } <line7> } <line8> } <line9> 	"<line5>      log.trace(""Failed to reply due to error"", e);"	task4	
public class A { <line0> public void loadSettings(@NotNull InputStream in, @NotNull String systemId) <line1> throws ConfigurationException, IOException { <line2> VaultSettings settings = new VaultSettings(); <line3> settings.load(in); <line4> setSettings(settings); <line5> } <line6> } <line7> 	"<line5>    log.trace(""Loaded settings from {}."", systemId);"	task4	
"public class A { <line0> public void process(final String uri, final String hostAddress, RequestHandler requestHandler) <line1> throws IOException { <line2> HTTPAnnounceRequestMessage announceRequest; <line3> try { <line4> announceRequest = this.parseQuery(uri, hostAddress); <line5> } catch (MessageValidationException mve) { <line6> LoggerUtils.warnAndDebugDetails( <line7> logger, ""Unable to parse request message. Request url is {}"", uri, mve); <line8> serveError(Status.BAD_REQUEST, mve.getMessage(), requestHandler); <line9> return; <line10> } <line11> AnnounceRequestMessage.RequestEvent event = announceRequest.getEvent(); <line12> if (event == null) { <line13> event = AnnounceRequestMessage.RequestEvent.NONE; <line14> } <line15> TrackedTorrent torrent = myTorrentsRepository.getTorrent(announceRequest.getHexInfoHash()); <line16> if (!myAcceptForeignTorrents && torrent == null) { <line17> serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.UNKNOWN_TORRENT, requestHandler); <line18> return; <line19> } <line20> final boolean isSeeder = <line21> (event == AnnounceRequestMessage.RequestEvent.COMPLETED) <line22> || (announceRequest.getLeft() == 0); <line23> if (myAddressChecker.isBadAddress(announceRequest.getIp())) { <line24> if (torrent == null) { <line25> writeEmptyResponse(announceRequest, requestHandler); <line26> } else { <line27> writeAnnounceResponse(torrent, null, isSeeder, requestHandler); <line28> } <line29> return; <line30> } <line31> final Peer peer = new Peer(announceRequest.getIp(), announceRequest.getPort()); <line32> try { <line33> torrent = <line34> myTorrentsRepository.putIfAbsentAndUpdate( <line35> announceRequest.getHexInfoHash(), <line36> new TrackedTorrent(announceRequest.getInfoHash()), <line37> event, <line38> ByteBuffer.wrap(announceRequest.getPeerId()), <line39> announceRequest.getHexPeerId(), <line40> announceRequest.getIp(), <line41> announceRequest.getPort(), <line42> announceRequest.getUploaded(), <line43> announceRequest.getDownloaded(), <line44> announceRequest.getLeft()); <line45> } catch (IllegalArgumentException iae) { <line46> LoggerUtils.warnAndDebugDetails( <line47> logger, ""Unable to update peer torrent. Request url is {}"", uri, iae); <line48> serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.INVALID_EVENT, requestHandler); <line49> return; <line50> } <line51> writeAnnounceResponse(torrent, peer, isSeeder, requestHandler); <line52> } <line53> } <line54> "	"<line17>      logger.warn(""Requested torrent hash was: {}"", announceRequest.getHexInfoHash());"	task4	
"public class A { <line0> public void run() { <line1> try { <line2> this.sleep(2000); <line3> } catch (InterruptedException e) { <line4> return; <line5> } <line6> for (int j = 0; j < nodeNum; j++) { <line7> VcVirtualMachine vm = MockVcCache.getIgnoreMissing(VM_MOB_PREFIX + j); <line8> Map<String, String> map = new HashMap<String, String>(); <line9> switch (settings) { <line10> case 0: <line11> if (flag) { <line12> map.put(Constants.VM_DISK_FORMAT_STATUS_KEY, ""1""); <line13> map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY, ""1""); <line14> } <line15> break; <line16> case 1: <line17> if (flag) { <line18> map.put(Constants.VM_DISK_FORMAT_STATUS_KEY, ""0""); <line19> map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY, ""0""); <line20> map.put( <line21> ""guestinfo.network_info"", <line22> ""{'nics': [{'device': 'eth0', 'ipaddr': '192.168.1.100', 'fqdn':"" <line23> + "" 'vmname.eng.vmware.com', 'portgroup': 'test_portgroup'}]}""); <line24> } else { <line25> map.put(Constants.VM_DISK_FORMAT_STATUS_KEY, ""1""); <line26> map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY, ""1""); <line27> } <line28> break; <line29> default: <line30> break; <line31> } <line32> Mockito.when(vm.getGuestVariables()).thenReturn(map); <line33> } <line34> } <line35> } <line36> "	"<line4>      logger.error(""VM status updator is interrupted."");"	task4	
"public class A { <line0> private static String elemNames( <line1> Class<? extends Enum<?>> enumClass, Map<? extends Enum<?>, QName> map) { <line2> List<String> names = new LinkedList<String>(); <line3> for (Enum<?> e : enumClass.getEnumConstants()) { <line4> QName qname = map.get(e); <line5> if (qname != null) { <line6> names.add(qname.toString()); <line7> } <line8> } <line9> return ArrayUtils.join("", "", names); <line10> } <line11> } <line12> "	<line6>        LOG.debug(qname.toString());	task4	
"public class A { <line0> private void _installConfigs(ClassLoader classLoader) throws Exception { <line1> BundleContext bundleContext = _framework.getBundleContext(); <line2> Class<?> configurationFileInstallerClass = <line3> classLoader.loadClass( <line4> ""com.liferay.portal.file.install.internal.configuration."" <line5> + ""ConfigurationFileInstaller""); <line6> Constructor<?> constructor = <line7> configurationFileInstallerClass.getDeclaredConstructor( <line8> classLoader.loadClass(""org.osgi.service.cm.ConfigurationAdmin""), String.class); <line9> constructor.setAccessible(true); <line10> Method canTransformURLMethod = <line11> configurationFileInstallerClass.getDeclaredMethod(""canTransformURL"", File.class); <line12> Method transformURLMethod = <line13> configurationFileInstallerClass.getDeclaredMethod(""transformURL"", File.class); <line14> String encoding = bundleContext.getProperty(""file.install.configEncoding""); <line15> if (encoding == null) { <line16> encoding = StringPool.UTF8; <line17> } <line18> Object configurationFileInstaller = <line19> constructor.newInstance( <line20> bundleContext.getService( <line21> bundleContext.getServiceReference(""org.osgi.service.cm.ConfigurationAdmin"")), <line22> encoding); <line23> File dir = new File(PropsValues.MODULE_FRAMEWORK_CONFIGS_DIR); <line24> dir = dir.getCanonicalFile(); <line25> for (File file : _listConfigs(dir)) { <line26> if ((boolean) canTransformURLMethod.invoke(configurationFileInstaller, file)) { <line27> try { <line28> transformURLMethod.invoke(configurationFileInstaller, file); <line29> } catch (InvocationTargetException invocationTargetException) { <line30> } <line31> } <line32> } <line33> } <line34> } <line35> "	"<line30>          log.error(""Unable to install "" + file, invocationTargetException);"	task4	
public class A { <line0> public void loginEvent( <line1> final User user, <line2> final String surrogateIdentifier, <line3> final String ip, <line4> final String errorMessage) { <line5> } <line6> } <line7> 	"<line5>    LOGGER.info(""Login statut: {} / user: {} - {} / surrogate: {} / IP: {} / errorMessage: {}"",errorMessage != null ? StatusCode.KO : StatusCode.OK,user.getIdentifier(),user.getEmail(),surrogateIdentifier,ip,errorMessage);"	task4	
public class A { <line0> private Map<String, Action> loadAllReferencedActions(Auth auth) { <line1> Map<String, Action> actionMap = new HashMap<>(); <line2> for (Userprofile userprofile : auth.getUserprofiles().getUserprofile()) { <line3> List<ProfileRef> profileList = userprofile.getProfileRef(); <line4> if (profileList != null) { <line5> for (ProfileRef profileRef : profileList) { <line6> Profile profileWithActions = getProfileMap().get(profileRef.getName()); <line7> if (profileWithActions != null) { <line8> List<Action> actionList = profileWithActions.getAction(); <line9> for (Action action : actionList) { <line10> actionMap.put(action.getId(), action); <line11> } <line12> } else { <line13> } <line14> } <line15> } <line16> } <line17> return actionMap; <line18> } <line19> } <line20> 	"<line13>            log.error(""Could not find profile ""+ profileRef.getName()+ "" of user ""+ getAuthService().getUsername());"	task4	
"public class A { <line0> public static com.liferay.segments.model.SegmentsEntry getSegmentsEntry( <line1> HttpPrincipal httpPrincipal, long segmentsEntryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SegmentsEntryServiceUtil.class, ""getSegmentsEntry"", _getSegmentsEntryParameterTypes8); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, segmentsEntryId); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.segments.model.SegmentsEntry) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public Object methodException(Class claz, String method, Exception e) throws Exception { <line2> if (""format"".equals(method)) { <line3> return null; <line4> } <line5> throw e; <line6> } <line7> } <line8> "	"<line2>    log.debug(""Claz: "" + claz.getName() + "" method: "" + method, e);"	task4	
public class A { <line0> public void fixed(String what, String reason) { <line1> } <line2> } <line3> 	<line1>    LOG.warn(FIXED_REASON, what, reason);	task4	
"public class A { <line0> @BeforeClass <line1> public static void init() throws Exception { <line2> CCConfig ccConfig = new CCConfig(); <line3> ccConfig.setClientListenAddress(""127.0.0.1""); <line4> ccConfig.setClientListenPort(39000); <line5> ccConfig.setClusterListenAddress(""127.0.0.1""); <line6> ccConfig.setClusterListenPort(39001); <line7> ccConfig.setProfileDumpPeriod(10000); <line8> FileUtils.deleteQuietly(new File(""target"" + File.separator + ""data"")); <line9> FileUtils.copyDirectory(new File(""data""), new File(joinPath(""target"", ""data""))); <line10> File outDir = new File(""target"" + File.separator + ""ClusterController""); <line11> outDir.mkdirs(); <line12> File ccRoot = File.createTempFile(AbstractIntegrationTest.class.getName(), "".data"", outDir); <line13> ccRoot.delete(); <line14> ccRoot.mkdir(); <line15> ccConfig.setRootDir(ccRoot.getAbsolutePath()); <line16> cc = new ClusterControllerService(ccConfig); <line17> cc.start(); <line18> NCConfig ncConfig1 = new NCConfig(NC1_ID); <line19> ncConfig1.setClusterAddress(""localhost""); <line20> ncConfig1.setClusterPort(39001); <line21> ncConfig1.setClusterListenAddress(""127.0.0.1""); <line22> ncConfig1.setDataListenAddress(""127.0.0.1""); <line23> ncConfig1.setResultListenAddress(""127.0.0.1""); <line24> ncConfig1.setIODevices( <line25> new String[] {joinPath(System.getProperty(""user.dir""), ""target"", ""data"", ""device0"")}); <line26> nc1 = new NodeControllerService(ncConfig1); <line27> nc1.start(); <line28> NCConfig ncConfig2 = new NCConfig(NC2_ID); <line29> ncConfig2.setClusterAddress(""localhost""); <line30> ncConfig2.setClusterPort(39001); <line31> ncConfig2.setClusterListenAddress(""127.0.0.1""); <line32> ncConfig2.setDataListenAddress(""127.0.0.1""); <line33> ncConfig2.setResultListenAddress(""127.0.0.1""); <line34> ncConfig2.setIODevices( <line35> new String[] {joinPath(System.getProperty(""user.dir""), ""target"", ""data"", ""device1"")}); <line36> nc2 = new NodeControllerService(ncConfig2); <line37> nc2.start(); <line38> hcc = new HyracksConnection(ccConfig.getClientListenAddress(), ccConfig.getClientListenPort()); <line39> if (LOGGER.isInfoEnabled()) { <line40> } <line41> } <line42> } <line43> "	"<line40>      LOGGER.info(""Starting CC in "" + ccRoot.getAbsolutePath());"	task4	
public class A { <line0> public static void forEach(Collection<GlobalSession> sessions, GlobalSessionHandler handler) { <line1> for (GlobalSession globalSession : sessions) { <line2> try { <line3> MDC.put(RootContext.MDC_KEY_XID, globalSession.getXid()); <line4> handler.handle(globalSession); <line5> } catch (Throwable th) { <line6> } finally { <line7> MDC.remove(RootContext.MDC_KEY_XID); <line8> } <line9> } <line10> } <line11> } <line12> 	"<line6>        LOGGER.error(""handle global session failed: {}"", globalSession.getXid(), th);"	task4	
"public class A { <line0> public String pathToKey(Path path) { <line1> Objects.requireNonNull(path, ""Path can't be null!""); <line2> if (!path.isAbsolute()) { <line3> path = new Path(workingDir, path); <line4> } <line5> String key = path.toUri().getPath(); <line6> if (!OzoneFSUtils.isValidName(key)) { <line7> throw new InvalidPathException(""Invalid path Name "" + key); <line8> } <line9> key = key.substring(1); <line10> return key; <line11> } <line12> } <line13> "	"<line10>    LOG.trace(""path for key: {} is: {}"", key, path);"	task4	
"public class A { <line0> @GET <line1> @Path(""/{id}"") <line2> public Response getRepairSchedule(@PathParam(""id"") UUID repairScheduleId) { <line3> Optional<RepairSchedule> repairSchedule = context.storage.getRepairSchedule(repairScheduleId); <line4> if (repairSchedule.isPresent()) { <line5> return Response.ok().entity(getRepairScheduleStatus(repairSchedule.get())).build(); <line6> } else { <line7> return Response.status(404) <line8> .entity(""repair schedule with id "" + repairScheduleId + "" doesn't exist"") <line9> .build(); <line10> } <line11> } <line12> } <line13> "	"<line3>    LOG.debug(""get repair_schedule called with: id = {}"", repairScheduleId);"	task4	
public class A { <line0> public Airport getAirport(String code) { <line1> if (StringUtils.isBlank(code)) { <line2> return null; <line3> } <line4> if (code.length() == 3) { <line5> AirportVo airportVo = airportService.getAirportByThreeLetterCode(code); <line6> if (airportVo != null) { <line7> return AirportServiceImpl.buildAirport(airportVo); <line8> } <line9> } else if (code.length() == 4) { <line10> AirportVo airportVo = airportService.getAirportByThreeLetterCode(code); <line11> if (airportVo != null) { <line12> return AirportServiceImpl.buildAirport(airportVo); <line13> } <line14> } <line15> return null; <line16> } <line17> } <line18> 	"<line15>    logger.warn(""Unknown airport code: "" + code);"	task4	
public class A { <line0> public static void main(String[] args) { <line1> try { <line2> IoTDBConfigCheck.getInstance().checkConfig(); <line3> } catch (IOException e) { <line4> } <line5> IoTDB daemon = IoTDB.getInstance(); <line6> daemon.active(); <line7> } <line8> } <line9> 	"<line4>      logger.error(""meet error when doing start checking"", e);"	task4	
public class A { <line0> @PostConstruct <line1> public void setup() { <line2> if (!_initialized) { <line3> final InitThread initThread = new InitThread(this); <line4> new Thread(initThread).start(); <line5> _initialized = true; <line6> } <line7> } <line8> } <line9> 	"<line3>      log.info(""setting up..."");"	task4	
"public class A { <line0> @Test <line1> public void checkOverlaps() throws IOException { <line2> final StringWriter writer = new StringWriter(); <line3> subject.checkOverlaps(writer); <line4> final String output = writer.getBuffer().toString(); <line5> final List<String> overlaps = Splitter.on(""\n"").splitToList(output); <line6> assertThat(overlaps, hasSize(11)); <line7> assertThat( <line8> overlaps, <line9> containsInAnyOrder( <line10> ""GRS1	GRS2	aut-num     	AS1-AS2"", <line11> ""GRS1	GRS2	inetnum     	10.0.0.0-10.0.0.0"", <line12> ""GRS1	GRS2	inetnum     	192.0.0.1-192.0.0.2"", <line13> ""GRS1	GRS2	inet6num    	::/0"", <line14> ""GRS1	GRS3	aut-num     	AS1-AS1"", <line15> ""GRS1	GRS3	inetnum     	193.0.0.10-193.0.0.11"", <line16> ""GRS1	GRS3	inet6num    	::/0"", <line17> ""GRS2	GRS3	aut-num     	AS10-AS10"", <line18> ""GRS2	GRS3	aut-num     	AS1-AS1"", <line19> ""GRS2	GRS3	inet6num    	::/0"", <line20> """")); <line21> } <line22> } <line23> "	"<line5>    LOGGER.debug(""overlaps:\n{}"", output);"	task4	
public class A { <line0> void debug() { <line1> nodeEquipments.forEach(this::debug); <line2> } <line3> } <line4> 	"<line1>    LOG.debug(""TPnodeEquipments"");"	task4	
public class A { <line0> @Override <line1> public void call(Boolean ignored) { <line2> if (configObservable != null) { <line3> configObservable.onCompleted(); <line4> } <line5> } <line6> } <line7> 	"<line3>      LOGGER.trace(""Completing ConfigObservable for termination."");"	task4	
public class A { <line0> @Override <line1> public Integer getIntegerValue(String property, int defaultValue) { <line2> String strValue = getValue(property); <line3> if (StringUtils.isBlank(strValue)) { <line4> return defaultValue; <line5> } <line6> try { <line7> return Integer.valueOf(strValue.trim()); <line8> } catch (Exception e) { <line9> return defaultValue; <line10> } <line11> } <line12> } <line13> 	<line9>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> @SuppressFBWarnings({""SERVLET_HEADER"", ""SERVLET_QUERY_STRING""}) <line1> private ContainerRequest servletRequestToContainerRequest(ServletRequest request) { <line2> Timer.start(""JERSEY_SERVLET_REQUEST_TO_CONTAINER""); <line3> HttpServletRequest servletRequest = (HttpServletRequest) request; <line4> if (baseUri == null) { <line5> baseUri = getBaseUri(request, ""/""); <line6> } <line7> String requestFullPath = servletRequest.getRequestURI(); <line8> if (LambdaContainerHandler.getContainerConfig().getServiceBasePath() != null <line9> && LambdaContainerHandler.getContainerConfig().isStripBasePath()) { <line10> if (requestFullPath.startsWith( <line11> LambdaContainerHandler.getContainerConfig().getServiceBasePath())) { <line12> requestFullPath = <line13> requestFullPath.replaceFirst( <line14> LambdaContainerHandler.getContainerConfig().getServiceBasePath(), """"); <line15> if (!requestFullPath.startsWith(""/"")) { <line16> requestFullPath = ""/"" + requestFullPath; <line17> } <line18> } <line19> } <line20> UriBuilder uriBuilder = UriBuilder.fromUri(baseUri).path(requestFullPath); <line21> uriBuilder.replaceQuery(servletRequest.getQueryString()); <line22> PropertiesDelegate apiGatewayProperties = new MapPropertiesDelegate(); <line23> apiGatewayProperties.setProperty( <line24> API_GATEWAY_CONTEXT_PROPERTY, servletRequest.getAttribute(API_GATEWAY_CONTEXT_PROPERTY)); <line25> apiGatewayProperties.setProperty( <line26> API_GATEWAY_STAGE_VARS_PROPERTY, <line27> servletRequest.getAttribute(API_GATEWAY_STAGE_VARS_PROPERTY)); <line28> apiGatewayProperties.setProperty( <line29> LAMBDA_CONTEXT_PROPERTY, servletRequest.getAttribute(LAMBDA_CONTEXT_PROPERTY)); <line30> apiGatewayProperties.setProperty(JERSEY_SERVLET_REQUEST_PROPERTY, servletRequest); <line31> ContainerRequest requestContext = <line32> new ContainerRequest( <line33> null, <line34> uriBuilder.build(), <line35> servletRequest.getMethod().toUpperCase(Locale.ENGLISH), <line36> (SecurityContext) servletRequest.getAttribute(JAX_SECURITY_CONTEXT_PROPERTY), <line37> apiGatewayProperties); <line38> InputStream requestInputStream; <line39> try { <line40> requestInputStream = servletRequest.getInputStream(); <line41> if (requestInputStream != null) { <line42> requestContext.setEntityStream(requestInputStream); <line43> } <line44> } catch (IOException e) { <line45> throw new RuntimeException(""Could not read request input stream"", e); <line46> } <line47> Enumeration<String> headerNames = servletRequest.getHeaderNames(); <line48> while (headerNames.hasMoreElements()) { <line49> String headerKey = headerNames.nextElement(); <line50> requestContext <line51> .getHeaders() <line52> .addAll(headerKey, Collections.list(servletRequest.getHeaders(headerKey))); <line53> } <line54> Timer.stop(""JERSEY_SERVLET_REQUEST_TO_CONTAINER""); <line55> return requestContext; <line56> } <line57> } <line58> "	"<line45>      log.error(""Could not read input stream from request"", e);"	task4	
"public class A { <line0> @Override <line1> public void applyInTx() { <line2> iterateWithCommit( <line3> getGraph().getVertices(""@class"", ""NodeImpl""), <line4> vertex -> { <line5> Set<String> parents = new HashSet<>(); <line6> Set<String> branchParents = new HashSet<>(); <line7> for (Edge edge : vertex.getEdges(Direction.OUT, ""HAS_PARENT_NODE"")) { <line8> String parentUuid = edge.getVertex(Direction.IN).getProperty(""uuid""); <line9> String branchUuid = edge.getProperty(""branchUuid""); <line10> if (branchUuid == null) { <line11> continue; <line12> } <line13> parents.add(parentUuid); <line14> branchParents.add(branchParentEntry(branchUuid, parentUuid).encode()); <line15> edge.remove(); <line16> } <line17> vertex.setProperty(PARENTS_KEY_PROPERTY, parents); <line18> vertex.setProperty(BRANCH_PARENTS_KEY_PROPERTY, branchParents); <line19> }); <line20> } <line21> } <line22> "	"<line11>              log.warn(""Parent edge from child {} to parent {} does not have a branch uuid. Skipping""+ "" this edge."",vertex.getProperty(""uuid""),branchUuid);"	task4	
public class A { <line0> public void releaseBrokenClient(Client client) { <line1> try { <line2> clientPool.invalidateObject(client); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.warn(""exception occurred during releasing thrift client"", e);"	task4	
"public class A { <line0> @Override <line1> public void deleteRecord(DataIdentifier identifier) throws DataStoreException { <line2> long start = System.currentTimeMillis(); <line3> String key = getKeyName(identifier); <line4> ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); <line5> try { <line6> Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); <line7> s3service.deleteObject(bucket, key); <line8> } catch (AmazonServiceException e) { <line9> throw new DataStoreException(""Could not delete dataIdentifier "" + identifier, e); <line10> } finally { <line11> if (contextClassLoader != null) { <line12> Thread.currentThread().setContextClassLoader(contextClassLoader); <line13> } <line14> } <line15> } <line16> } <line17> "	"<line8>      LOG.debug(""Identifier [{}] deleted. It took [{}]ms."",new Object[] {identifier, (System.currentTimeMillis() - start)});"	task4	
public class A { <line0> @Override <line1> public void handleDelivery( <line2> String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) <line3> throws IOException { <line4> receivedHeaders.putAll(properties.getHeaders()); <line5> received.add(new String(body)); <line6> } <line7> } <line8> 	"<line4>    LOGGER.info(""AMQP.BasicProperties: {}"", properties);"	task4	
public class A { <line0> protected void processFuture(Future<String> future) { <line1> try { <line2> future.get(DEFAULT_EXTRACTOR_JOB_TIME, TimeUnit.SECONDS); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.error(""Error while waiting for extractor job to be finished"", e);"	task4	
"public class A { <line0> @Override <line1> public void init() { <line2> pythonParameters = <line3> JSONUtils.parseObject(taskExecutionContext.getTaskParams(), PythonParameters.class); <line4> if (!pythonParameters.checkParameters()) { <line5> throw new RuntimeException(""python task params is not valid""); <line6> } <line7> } <line8> } <line9> "	"<line2>    logger.info(""python task params {}"", taskExecutionContext.getTaskParams());"	task4	
"public class A { <line0> @Bean(name = BEAN_NAME_EMBEDDED_MYSQL, destroyMethod = ""stop"") <line1> public MySQLContainer mysql(ConfigurableEnvironment environment, MySQLProperties properties) { <line2> MySQLContainer mysql = <line3> new MySQLContainer<>(properties.dockerImage) <line4> .withEnv(""MYSQL_ALLOW_EMPTY_PASSWORD"", ""yes"") <line5> .withUsername(properties.getUser()) <line6> .withDatabaseName(properties.getDatabase()) <line7> .withPassword(properties.getPassword()) <line8> .withCommand( <line9> ""--character-set-server="" + properties.getEncoding(), <line10> ""--collation-server="" + properties.getCollation()) <line11> .withExposedPorts(properties.port) <line12> .withCreateContainerCmdModifier( <line13> cmd -> cmd.getHostConfig().withCapAdd(Capability.NET_ADMIN)) <line14> .withInitScript(properties.initScriptPath); <line15> mysql = (MySQLContainer) configureCommonsAndStart(mysql, properties, log); <line16> registerMySQLEnvironment(mysql, environment, properties); <line17> return mysql; <line18> } <line19> } <line20> "	"<line2>    log.info(""Starting mysql server. Docker image: {}"", properties.dockerImage);"	task4	
public class A { <line0> @Override <line1> public void dispose() { <line2> ScheduledFuture<?> oldScheduler = pollingScheduler; <line3> if (oldScheduler != null) { <line4> boolean stopped = oldScheduler.cancel(true); <line5> } <line6> pollingScheduler = null; <line7> } <line8> } <line9> 	"<line5>      logger.debug(""Stopped polling: {}"", stopped);"	task4	
public class A { <line0> @Override <line1> public void telegramReceived(P1Telegram telegram) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> final Entry<Collection<DSMRMeterDescriptor>, Map<CosemObjectType, CosemObject>> detectedMeters = <line5> meterDetector.detectMeters(telegram); <line6> verifyUnregisteredCosemObjects(telegram, detectedMeters.getValue()); <line7> validateConfiguredMeters( <line8> dsmrBridgeHandler.getThing().getThings(), <line9> detectedMeters.getKey().stream().map(md -> md.getMeterType()).collect(Collectors.toSet())); <line10> detectedMeters.getKey().forEach(m -> meterDiscovered(m, dsmrBridgeHandler.getThing().getUID())); <line11> } <line12> } <line13> 	"<line3>      logger.debug(""Detect meters from #{} objects"", telegram.getCosemObjects().size());"	task4	
public class A { <line0> @Override <line1> public void initialize() { <line2> try { <line3> CRS_BY_SRS_ID.put(WGS84_SRS_ID, WGS84); <line4> CoordinateReferenceSystem webMercatorCrs = <line5> CRS.decode(SpatialReferenceSystem.WEB_MERCATOR_SRS_ID); <line6> CRS_BY_SRS_ID.put(SpatialReferenceSystem.WEB_MERCATOR_SRS_ID, webMercatorCrs); <line7> getOrCreateTransform( <line8> SpatialReferenceSystem.WGS84_SRS_ID, SpatialReferenceSystem.WEB_MERCATOR_SRS_ID); <line9> getOrCreateTransform( <line10> SpatialReferenceSystem.WEB_MERCATOR_SRS_ID, SpatialReferenceSystem.WGS84_SRS_ID); <line11> } catch (Exception e) { <line12> throw new RuntimeException(e); <line13> } <line14> } <line15> } <line16> 	"<line12>      LOG.error(""Error while initializing CoordinateOperations"", e);"	task4	
"public class A { <line0> @Test <line1> public void testHBaseSaslRpcClientCreation() throws Exception { <line2> assertFalse(assertSuccessCreationKerberosPrincipal(null)); <line3> assertFalse(assertSuccessCreationKerberosPrincipal(""DOMAIN.COM"")); <line4> assertFalse(assertSuccessCreationKerberosPrincipal(""principal/DOMAIN.COM"")); <line5> if (!assertSuccessCreationKerberosPrincipal(""principal/localhost@DOMAIN.COM"")) { <line6> } <line7> assertFalse(assertSuccessCreationDigestPrincipal(null, null)); <line8> assertFalse(assertSuccessCreationDigestPrincipal("""", """")); <line9> assertFalse(assertSuccessCreationDigestPrincipal("""", null)); <line10> assertFalse(assertSuccessCreationDigestPrincipal(null, """")); <line11> assertTrue(assertSuccessCreationDigestPrincipal(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line12> assertFalse(assertSuccessCreationSimplePrincipal("""", """")); <line13> assertFalse(assertSuccessCreationSimplePrincipal(null, null)); <line14> assertFalse(assertSuccessCreationSimplePrincipal(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line15> assertTrue(assertIOExceptionThenSaslClientIsNull(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line16> assertTrue( <line17> assertIOExceptionWhenGetStreamsBeforeConnectCall(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line18> } <line19> } <line20> "	"<line6>      LOG.warn(""Could not create a SASL client with valid Kerberos credential"");"	task4	
public class A { <line0> public void stop() { <line1> try { <line2> server.shutdown().awaitTermination(10L, TimeUnit.SECONDS); <line3> } catch (InterruptedException ex) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.warn(""{} couldn't be stopped gracefully"", getClass().getSimpleName());"	task4	
public class A { <line0> @Override <line1> public CTAutoResolutionInfo remove(Serializable primaryKey) <line2> throws NoSuchAutoResolutionInfoException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> CTAutoResolutionInfo ctAutoResolutionInfo = <line7> (CTAutoResolutionInfo) session.get(CTAutoResolutionInfoImpl.class, primaryKey); <line8> if (ctAutoResolutionInfo == null) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> throw new NoSuchAutoResolutionInfoException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line12> } <line13> return remove(ctAutoResolutionInfo); <line14> } catch (NoSuchAutoResolutionInfoException noSuchEntityException) { <line15> throw noSuchEntityException; <line16> } catch (Exception exception) { <line17> throw processException(exception); <line18> } finally { <line19> closeSession(session); <line20> } <line21> } <line22> } <line23> 	<line10>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> private boolean getBooleanValueFromYaml(String option) { <line1> String stringValue = yamlStringConfigs.get(option); <line2> boolean result = stringValue != null && Boolean.valueOf(stringValue).equals(Boolean.TRUE); <line3> return result; <line4> } <line5> } <line6> 	"<line3>    LOG.debug(""Found config value {} for key {} "" + ""from YAML configuration."", result, option);"	task4	
"public class A { <line0> private void showGenericGitErrorNotificationWithBranch(BranchHelper branch) { <line1> Platform.runLater( <line2> () -> { <line3> notificationPaneController.addNotification( <line4> String.format(""Sorry, there was a git error on branch %s."", branch.getRefName())); <line5> }); <line6> } <line7> } <line8> "	"<line3>          logger.warn(""Git error on branch notification"");"	task4	
"public class A { <line0> public static com.liferay.knowledge.base.model.KBFolder fetchFirstChildKBFolder( <line1> HttpPrincipal httpPrincipal, long groupId, long kbFolderId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KBFolderServiceUtil.class, <line7> ""fetchFirstChildKBFolder"", <line8> _fetchFirstChildKBFolderParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, kbFolderId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.knowledge.base.model.KBFolder) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> public CompletableFuture<byte[]> readCharacteristic(UUID serviceUUID, UUID characteristicUUID) { <line1> var future = executeWithConnection(serviceUUID, characteristicUUID, device::readCharacteristic); <line2> if (logger.isDebugEnabled()) { <line3> future = <line4> future.whenComplete( <line5> (data, t) -> { <line6> if (t == null) { <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> }); <line11> } <line12> return future; <line13> } <line14> } <line15> 	"<line8>                    logger.debug(""Characteristic {} from {} has been read - value {}"",characteristicUUID,address,HexUtils.bytesToHex(data));"	task4	
"public class A { <line0> private String _getViewURL(Locale locale, ThemeDisplay themeDisplay) { <line1> try { <line2> ThemeDisplay clonedThemeDisplay = (ThemeDisplay) themeDisplay.clone(); <line3> clonedThemeDisplay.setScopeGroupId(_journalArticle.getGroupId()); <line4> return Optional.ofNullable( <line5> _assetDisplayPageFriendlyURLProvider.getFriendlyURL( <line6> JournalArticle.class.getName(), <line7> _journalArticle.getResourcePrimKey(), <line8> locale, <line9> clonedThemeDisplay)) <line10> .map( <line11> url -> { <line12> String backURL = ParamUtil.getString(_httpServletRequest, ""backURL""); <line13> if (Validator.isNotNull(backURL)) { <line14> return _http.setParameter(url, ""p_l_back_url"", backURL); <line15> } <line16> return _http.setParameter(url, ""p_l_back_url"", themeDisplay.getURLCurrent()); <line17> }) <line18> .orElse(StringPool.BLANK); <line19> } catch (CloneNotSupportedException | PortalException exception) { <line20> return StringPool.BLANK; <line21> } <line22> } <line23> } <line24> "	<line20>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> cache.clearAllExpired(); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> 	<line5>      LOG.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public void removeAllValues(String table) throws IOException { <line2> final Set<String> keysToRemove = keySet(table); <line3> for (String key : keysToRemove) { <line4> removeValues(table, key); <line5> } <line6> } <line7> } <line8> 	"<line3>    LOG.info(""Removing all values for table {}, keys = {}."", table, keysToRemove);"	task4	
"public class A { <line0> @SuppressWarnings(""resource"") <line1> private FileLock tryLock(File dir) throws IOException { <line2> File lockF = new File(dir, FILE_LOCK); <line3> lockF.deleteOnExit(); <line4> RandomAccessFile file = new RandomAccessFile(lockF, ""rws""); <line5> FileLock res = null; <line6> try { <line7> res = file.getChannel().tryLock(); <line8> } catch (OverlappingFileLockException oe) { <line9> file.close(); <line10> return null; <line11> } catch (IOException e) { <line12> file.close(); <line13> throw e; <line14> } <line15> return res; <line16> } <line17> } <line18> "	"<line12>      LOGGER.error(""Cannot create lock on "" + lockF, e);"	task4	
public class A { <line0> private void genericParseLargeMessage() { <line1> try { <line2> parsingBuffer.position(0); <line3> scanMessageData(parsingBuffer); <line4> lazyDecodeApplicationProperties(parsingBuffer); <line5> parsingBuffer = null; <line6> } catch (RuntimeException expected) { <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.debug(""The buffer for AMQP Large Mesasge was probably not complete, so an exception eventually""+ "" would be expected"",expected);"	task4	
public class A { <line0> @NotNull <line1> public static AstElement copyElementAndCheckReference(@NotNull final AstElement e) { <line2> AstElement clone = checkNotNull(e).copyOf(); <line3> if (clone == e && LOG.isDebugEnabled()) { <line4> } <line5> return clone; <line6> } <line7> } <line8> 	"<line4>      LOG.debug(""Failed to clone the AstElement. Returning same reference; the client may fail. {} - {}"",e.getClass().getName(),e);"	task4	
"public class A { <line0> public String getWarnings(LoggedInInfo loggedInInfo, String demo) { <line1> String ret = dataCache.get(demo); <line2> if (ret == null) { <line3> try { <line4> Prevention prev = <line5> PreventionData.getLocalandRemotePreventions(loggedInInfo, Integer.parseInt(demo)); <line6> pf.getMessages(prev); <line7> @SuppressWarnings(""unchecked"") <line8> Map<String, Object> m = prev.getWarningMsgs(); <line9> @SuppressWarnings(""rawtypes"") <line10> Set set = m.entrySet(); <line11> @SuppressWarnings(""rawtypes"") <line12> Iterator i = set.iterator(); <line13> String k = """"; <line14> if (ret == null || ret.equals(""null"")) { <line15> ret = """"; <line16> } <line17> while (i.hasNext()) { <line18> @SuppressWarnings(""rawtypes"") <line19> Map.Entry me = (Map.Entry) i.next(); <line20> k = ""["" + me.getKey() + ""="" + me.getValue() + ""]""; <line21> boolean prevCheck = PreventionManager.isPrevDisabled(me.getKey().toString()); <line22> if (prevCheck == false) { <line23> ret = ret + k; <line24> } <line25> } <line26> dataCache.put(demo, ret); <line27> } catch (Exception e) { <line28> ret = """"; <line29> } <line30> } <line31> return ret; <line32> } <line33> } <line34> "	"<line29>        logger.error(""Error"", e);"	task4	
public class A { <line0> public static boolean isH2Connection(Settings configuration) { <line1> final String connStr; <line2> try { <line3> connStr = <line4> configuration.getConnectionString( <line5> Settings.KEYS.DB_CONNECTION_STRING, Settings.KEYS.DB_FILE_NAME); <line6> } catch (IOException ex) { <line7> return false; <line8> } <line9> return isH2Connection(connStr); <line10> } <line11> } <line12> 	"<line7>      LOGGER.debug(""Unable to get connectionn string"", ex);"	task4	
public class A { <line0> private void prepareCcsProtocolType(ChangeCipherSpecMessage msg) { <line1> msg.setCcsProtocolType(CCS_PROTOCOL_TYPE); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""CCSProtocollType: "" + msg.getCcsProtocolType().getValue());"	task4	
public class A { <line0> @Override <line1> public boolean deleteDocument(DocumentMetadataType document) { <line2> DeleteDocumentRequestMessageType request = new DeleteDocumentRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setDocument(document); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_DELETEDOCUMENT, request); <line9> logDebug( <line10> AdminWSConstants.ADMIN_LTD_DELETEDOCUMENT, response.isStatus(), response.getMessage()); <line11> return response.isStatus(); <line12> } catch (Exception e) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	"<line13>      LOG.error(""error during delete document: {}"", e.getLocalizedMessage(), e);"	task4	
"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> private void scheduleRenewal(Reactor reactor) { <line2> int sasTokenRenewalPeriod = <line3> this.amqpsSessionHandler <line4> .getDeviceClientConfig() <line5> .getSasTokenAuthentication() <line6> .getMillisecondsBeforeProactiveRenewal(); <line7> reactor.schedule(sasTokenRenewalPeriod, this); <line8> } <line9> } <line10> "	"<line7>    log.trace(""Scheduling proactive sas token renewal for device {} in {} milliseconds"",this.amqpsSessionHandler.getDeviceId(),sasTokenRenewalPeriod);"	task4	
"public class A { <line0> @Override <line1> protected boolean initiateClient() { <line2> for (String host : hosts) { <line3> if (host == null) { <line4> throw new IllegalArgumentException(""Host Name should not be null.""); <line5> } <line6> } <line7> cluster = CouchbaseCluster.create(hosts); <line8> if (userName != null && password != null) { <line9> clusterManager = cluster.clusterManager(userName, password); <line10> } else { <line11> clusterManager = cluster.clusterManager(); <line12> } <line13> return true; <line14> } <line15> } <line16> "	"<line4>        LOGGER.error(""Host Name should not be null."");"	task4	
"public class A { <line0> @Override <line1> public Object getService(Filter filter, long timeout) throws OsgiServiceNotAvailableException { <line2> ServiceTracker t = new ServiceTracker(bundleContext, filter, null); <line3> Object result = waitForServiceFromTracker(t, timeout); <line4> if (result == null) { <line5> throw new OsgiServiceNotAvailableException( <line6> String.format( <line7> ""no service matching filter \""%s\"" available at the time"", filter.toString())); <line8> } <line9> return result; <line10> } <line11> } <line12> "	"<line3>    LOGGER.debug(""getting service for filter {} from tracker"", filter);"	task4	
public class A { <line0> Set<DLockRemoteToken> getLockTokensForRecovery(LockGrantorId newlockGrantorId) { <line1> Set<DLockRemoteToken> heldLockSet = Collections.EMPTY_SET; <line2> LockGrantorId currentLockGrantorId = null; <line3> synchronized (this.lockGrantorIdLock) { <line4> if (isDestroyed()) { <line5> return heldLockSet; <line6> } <line7> currentLockGrantorId = this.lockGrantorId; <line8> } <line9> if (currentLockGrantorId != null <line10> && currentLockGrantorId.hasLockGrantorVersion() <line11> && newlockGrantorId.isNewerThan(currentLockGrantorId)) { <line12> nullLockGrantorId(currentLockGrantorId); <line13> } <line14> final boolean isDebugEnabled_DLS = logger.isTraceEnabled(LogMarker.DLS_VERBOSE); <line15> synchronized (this.lockGrantorIdLock) { <line16> synchronized (this.tokens) { <line17> for (DLockToken token : this.tokens.values()) { <line18> synchronized (token) { <line19> if (token.isLeaseHeld()) { <line20> if (token.ignoreForRecovery()) { <line21> if (isDebugEnabled_DLS) { <line22> } <line23> } else { <line24> if (heldLockSet == Collections.EMPTY_SET) { <line25> heldLockSet = new HashSet<>(); <line26> } <line27> heldLockSet.add(DLockRemoteToken.createFromDLockToken(token)); <line28> } <line29> } <line30> } <line31> } <line32> } <line33> return heldLockSet; <line34> } <line35> } <line36> } <line37> 	"<line22>                  logger.trace(LogMarker.DLS_VERBOSE, ""getLockTokensForRecovery is skipping {}"", token);"	task4	
public class A { <line0> @Override <line1> public void addParentProcedure(String procedure, String parentProcedure) { <line2> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line3> CacheValidation.notNullOrEmpty(PARENT_PROCEDURE, parentProcedure); <line4> this.parentProceduresForProcedures <line5> .computeIfAbsent(procedure, createSynchronizedSet()) <line6> .add(parentProcedure); <line7> this.childProceduresForProcedures <line8> .computeIfAbsent(parentProcedure, createSynchronizedSet()) <line9> .add(procedure); <line10> } <line11> } <line12> 	"<line4>    LOG.trace(""Adding parentProcedure {} to procedure {}"", parentProcedure, procedure);"	task4	
public class A { <line0> private void writeResult(ValidationResult result, PrintWriter output) { <line1> ObjectMapper objectMapper = new ObjectMapper(); <line2> objectMapper.enable(SerializationFeature.INDENT_OUTPUT); <line3> try { <line4> String content = objectMapper.writeValueAsString(result); <line5> output.write(content); <line6> } catch (JsonProcessingException e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOG.error(""Failed to process ValidationResult as JSON"", e);"	task4	
public class A { <line0> public void cleanup() { <line1> long leakedValues = localValue.getAndSet(0); <line2> if (leakedValues == 0) { <line3> return; <line4> } <line5> totalValue.addAndGet(-leakedValues); <line6> } <line7> } <line8> 	"<line5>    log.error(""BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function."",getClass().getName(), taskId, leakedValues, counterName);"	task4	
public class A { <line0> public static <T> T newExtension(Class<T> clazz) { <line1> ServiceLoader<T> serviceLoader = ServiceLoader.load(clazz); <line2> for (T service : serviceLoader) { <line3> return service; <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line5>    logger.warn(""no extension found for class:"" + clazz.getName());"	task4	
"public class A { <line0> public BoxTaskAssignment.Info getTaskAssignmentInfo(String taskAssignmentId) { <line1> try { <line2> if (taskAssignmentId == null) { <line3> throw new IllegalArgumentException(""Parameter 'taskAssignmentId' can not be null""); <line4> } <line5> BoxTaskAssignment taskAssignment = new BoxTaskAssignment(boxConnection, taskAssignmentId); <line6> return taskAssignment.getInfo(); <line7> } catch (BoxAPIException e) { <line8> throw new RuntimeException( <line9> String.format( <line10> ""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), <line11> e); <line12> } <line13> } <line14> } <line15> "	"<line2>      LOG.debug(""Getting info for task(id={})"", taskAssignmentId);"	task4	
"public class A { <line0> private void registerListener() { <line1> clusterConfig.addListener( <line2> new Listener<ClusterConfig>() { <line3> @Override <line4> public void onChanged(ClusterConfig current) { <line5> try { <line6> doSwitch(current); <line7> } catch (Throwable t) { <line8> String msg = ""ClusterConfig changed listener error""; <line9> throw new DalRuntimeException(msg, t); <line10> } <line11> } <line12> }); <line13> } <line14> } <line15> "	<line9>              LOGGER.error(msg, t);	task4	
"public class A { <line0> @Override <line1> @Secured({ServicesData.ROLE_GET_CUSTOMERS}) <line2> @GetMapping(CommonConstants.PATH_ID) <line3> public CustomerDto getOne(final @PathVariable(""id"") String id) { <line4> ParameterChecker.checkParameter(""Identifier is mandatory : "", id); <line5> return customerExternalService.getOne(id); <line6> } <line7> } <line8> "	"<line4>    LOGGER.debug(""Get {}"", id);"	task4	
"public class A { <line0> @RestAccessControl(permission = Permission.MANAGE_USERS) <line1> @RequestMapping( <line2> value = ""/{target:.+}"", <line3> method = RequestMethod.DELETE, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<SimpleRestResponse<Map>> deleteUser( <line6> @ModelAttribute(""user"") UserDetails user, <line7> @PathVariable String target, <line8> BindingResult bindingResult) <line9> throws ApsSystemException { <line10> if (isAdminUser(target)) { <line11> throw new ValidationGenericException(createDeleteAdminError()); <line12> } <line13> if (isUserDeletingHimself(target, user.getUsername())) { <line14> throw new ValidationGenericException(createSelfDeleteUserError(bindingResult)); <line15> } <line16> this.getUserService().removeUser(target); <line17> Map<String, String> result = new HashMap<>(); <line18> result.put(""code"", target); <line19> return new ResponseEntity<>(new SimpleRestResponse<>(result), HttpStatus.OK); <line20> } <line21> } <line22> "	"<line10>    logger.debug(""deleting {}"", target);"	task4	
"public class A { <line0> private void parseAdditionalParameters(Map<String, String> parameters) { <line1> if (Objects.equals(infoRequest, InfoRequest.emptyInfoRequest())) { <line2> throw new IllegalArgumentException(infoParameter + "": "" + infoRequest.helpMessage()); <line3> } <line4> if (infoRequest.hasAdditionalParameters()) { <line5> infoRequest.parseAdditionalParameter(parameters); <line6> } else if (parameters.size() < 1) { <line7> } <line8> if (!infoRequest.isValid()) { <line9> throw new IllegalStateException( <line10> ""The information parameter "" <line11> + infoRequest.getInfoParameter() <line12> + "" you requested does not have all parameters it needs."" <line13> + System.lineSeparator() <line14> + infoRequest.helpMessage()); <line15> } <line16> } <line17> } <line18> "	"<line7>      LOGGER.warn(""You have provided additional parameters that are not necessary for the information""+ "" parameter {}."",infoRequest.getInfoParameter());"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> conn = new Pop3Connection(this, socket); <line4> state = new Pop3State(manager); <line5> quitting = false; <line6> sendGreetings(); <line7> while (!quitting) { <line8> handleCommand(); <line9> } <line10> conn.close(); <line11> } catch (SocketTimeoutException ste) { <line12> conn.println(""421 Service shutting down and closing transmission channel""); <line13> } catch (Exception e) { <line14> if (!quitting) { <line15> throw new IllegalStateException(""Can not handle POP3 connection"", e); <line16> } <line17> } finally { <line18> try { <line19> socket.close(); <line20> } catch (IOException ioe) { <line21> } <line22> } <line23> } <line24> } <line25> "	"<line15>        log.error(""Can not handle POP3 connection"", e);"	task4	
public class A { <line0> @Override <line1> public void open() throws NuvoException { <line2> setConnected(false); <line3> } <line4> } <line5> 	"<line2>    logger.warn(""Nuvo binding incorrectly configured. Please configure for Serial or IP over serial""+ "" connection"");"	task4	
public class A { <line0> public Optional<SipStackProcessor> createSipStackProcessor( <line1> String name, Room r, ISipCallbacks callbacks) throws Exception { <line2> if (factory == null || !isSipEnabled() || !r.isSipEnabled()) { <line3> return Optional.empty(); <line4> } <line5> int port; <line6> synchronized (ports) { <line7> int free = ports.nextClearBit(0); <line8> ports.flip(free); <line9> port = minLocalWsPort + free; <line10> } <line11> return Optional.of(new SipStackProcessor(this, name, port, callbacks)); <line12> } <line13> } <line14> 	"<line3>      log.warn(""Asterisk is not configured or denied in room #{}"", r.getId());"	task4	
"public class A { <line0> private void extractProject(ProjectGenerationResponse entity, String output, boolean overwrite) <line1> throws IOException { <line2> File outputFolder = <line3> (output != null ? new File(output) : new File(System.getProperty(""user.dir""))); <line4> if (!outputFolder.exists()) { <line5> outputFolder.mkdirs(); <line6> } <line7> ZipInputStream zipStream = new ZipInputStream(new ByteArrayInputStream(entity.getContent())); <line8> try { <line9> extractFromStream(zipStream, overwrite, outputFolder); <line10> fixExecutableFlag(outputFolder, ""mvnw""); <line11> fixExecutableFlag(outputFolder, ""gradlew""); <line12> } finally { <line13> zipStream.close(); <line14> } <line15> } <line16> } <line17> "	"<line12>      Log.info(""Project extracted to '"" + outputFolder.getAbsolutePath() + ""'"");"	task4	
"public class A { <line0> @Test <line1> public void testMappedFeature() { <line2> String path = <line3> ""wfs?request=GetFeature&version=1.1.0&typeName=gsml:MappedFeature&featureid=gsml.mappedfeature.195201,gsml.mappedfeature.192654,gsml.mappedfeature.191921,gsml.mappedfeature.179239,gsml.mappedfeature.185969,gsml.mappedfeature.186037,gsml.mappedfeature.185817,gsml.mappedfeature.185911,gsml.mappedfeature.178855,gsml.mappedfeature.185608""; <line4> validateGet(path); <line5> Document doc = getAsDOM(path); <line6> if (printDoc) { <line7> } <line8> assertXpathEvaluatesTo(""10"", ""//wfs:FeatureCollection/@numberOfFeatures"", doc); <line9> assertXpathCount(10, ""//gsml:MappedFeature"", doc); <line10> assertXpathEvaluatesTo( <line11> ""previous mapping"", <line12> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.179239']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value"", <line13> doc); <line14> assertXpathEvaluatesTo( <line15> ""urn:cgi:classifierScheme:GSV:InterpretationMethod"", <line16> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.179239']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value/@codeSpace"", <line17> doc); <line18> assertXpathEvaluatesTo( <line19> ""approximate"", <line20> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185608']/gsml:positionalAccuracy/gsml:CGI_TermValue/gsml:value"", <line21> doc); <line22> assertXpathEvaluatesTo( <line23> ""urn:cgi:classifierScheme:GSV:PositionalAccuracy"", <line24> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185608']/gsml:positionalAccuracy/gsml:CGI_TermValue/gsml:value/@codeSpace"", <line25> doc); <line26> assertXpathEvaluatesTo( <line27> ""urn:cgi:feature:CGI:EarthNaturalSurface"", <line28> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185911']/gsml:samplingFrame/@xlink:href"", <line29> doc); <line30> ArrayList<String> specs = new ArrayList<>(); <line31> for (int i = 1; i <= 10; i++) { <line32> specs.add( <line33> this.evaluate( <line34> ""/wfs:FeatureCollection/gml:featureMember["" <line35> + i <line36> + ""]/gsml:MappedFeature/gsml:specification/@xlink:href"", <line37> doc)); <line38> } <line39> int[] countType = new int[3]; <line40> for (String spec : specs) { <line41> if (spec.contains(""ShearDisplacementStructure"")) { <line42> countType[0]++; <line43> } <line44> if (spec.contains(""GeologicUnit"")) { <line45> countType[1]++; <line46> } <line47> if (spec.contains(""Contact"")) { <line48> countType[2]++; <line49> } <line50> } <line51> assertEquals(5, countType[0]); <line52> assertEquals(3, countType[1]); <line53> assertEquals(2, countType[2]); <line54> String expected = <line55> ""-38.410785700000325 143.86545265833303 -38.40925703333365 143.86857949166634""; <line56> String actual = <line57> evaluate( <line58> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.179239']/gsml:shape/gml:MultiCurve/gml:curveMember/gml:LineString/gml:posList"", <line59> doc); <line60> assertTrue(this.isEqualGeometry(actual, expected, 5)); <line61> expected = ""-38.139133550000324 144.2364237333331 -38.13991570000029 144.2415325499997""; <line62> actual = <line63> evaluate( <line64> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185969']/gsml:shape/gml:MultiCurve/gml:curveMember/gml:LineString/gml:posList"", <line65> doc); <line66> assertTrue(this.isEqualGeometry(actual, expected, 5)); <line67> assertXpathEvaluatesTo( <line68> ""2"", <line69> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.192654']/gsml:shape/gml:MultiSurface/@srsDimension"", <line70> doc); <line71> expected = <line72> ""-37.469102166666666 143.76702998333334 -37.470454841666665 143.76797201666668 -37.4716163"" <line73> + "" 143.76817698333332 -37.472777758333336 143.7679037 -37.473939216666665"" <line74> + "" 143.76776705833333 -37.475100675 143.76797201666668 -37.475715566666665"" <line75> + "" 143.76899683333335 -37.476877025 143.76927011666666 -37.478038483333336"" <line76> + "" 143.76933844166666 -37.4790633 143.76988500833335 -37.480224766666666"" <line77> + "" 143.76974836666668 -37.480293083333336 143.76858690833333 -37.480088125"" <line78> + "" 143.76742545 -37.478516733333336 143.76571741666666 -37.479336591666666"" <line79> + "" 143.76489756666666 -37.47954155 143.76257465 -37.480429725 143.76332618333333"" <line80> + "" -37.481591183333336 143.7633945 -37.482684325 143.76291625 -37.483367533333336"" <line81> + "" 143.760729975 -37.4835725 143.75956851666666 -37.48364083333333 143.75840705833335"" <line82> + "" -37.483504175 143.7572456 -37.482889291666666 143.75622078333333 -37.48213775833334"" <line83> + "" 143.75533260833333 -37.481864475 143.75417114166666 -37.4822744 143.751848225"" <line84> + "" -37.4822744 143.75068676666666 -37.48213775833334 143.74952530833335"" <line85> + "" -37.479814833333336 143.749252025 -37.479609875 143.74809055833333 -37.47954155"" <line86> + "" 143.7469291 -37.47865338333333 143.74617756666666 -37.477560241666666"" <line87> + "" 143.74583596666668 -37.47721863333334 143.744742825 -37.47721863333334"" <line88> + "" 143.74358136666666 -37.47694535 143.74241990833335 -37.476193808333335"" <line89> + "" 143.740233625 -37.476193808333335 143.73907216666666 -37.476398775"" <line90> + "" 143.73791070833335 -37.4774236 143.73579275 -37.476877025 143.73476793333333"" <line91> + "" -37.4764671 143.7336748 -37.475783891666666 143.7327183 -37.474827391666665"" <line92> + "" 143.730532025 -37.474622425 143.72937056666666 -37.474554108333336"" <line93> + "" 143.72820910833335 -37.474622425 143.7265694 -37.473460966666664 143.7265694"" <line94> + "" -37.47236784166667 143.726979325 -37.471547975 143.727799175 -37.470386516666665"" <line95> + "" 143.727799175 -37.469293375 143.72738925 -37.4684052 143.72663771666666"" <line96> + "" -37.468131916666664 143.72547625833334 -37.467312066666665 143.72445143333334"" <line97> + "" -37.466355566666664 143.72410983333333 -37.465262433333336 143.72438313333333"" <line98> + "" -37.464784183333336 143.72547625833334 -37.464647541666665 143.72663771666666"" <line99> + "" -37.464784183333336 143.727799175 -37.465262433333336 143.72889231666667 -37.465809"" <line100> + "" 143.72991713333334 -37.466492208333335 143.73087363333335 -37.467380383333335"" <line101> + "" 143.73169348333334 -37.469498341666664 143.734426325 -37.4703182 143.73531450833335"" <line102> + "" -37.470933083333335 143.736339325 -37.472299508333336 143.73825231666666"" <line103> + "" -37.473051041666665 143.73914049166666 -37.474075858333336 143.74125845"" <line104> + "" -37.474417466666665 143.74235158333335 -37.474485783333336 143.74351304166666"" <line105> + "" -37.474759075 143.74467450833333 -37.47544228333334 143.745631 -37.475783891666666"" <line106> + "" 143.74672414166668 -37.47598885 143.7478856 -37.4764671 143.74897873333333"" <line107> + "" -37.476535425 143.75246311666666 -37.476125491666664 143.75355625833333 -37.4755106"" <line108> + "" 143.754581075 -37.473597608333336 143.75594749166666 -37.472777758333336"" <line109> + "" 143.75676735 -37.472299508333336 143.75786048333333 -37.47236784166667"" <line110> + "" 143.76018340833332 -37.47209455 143.76134486666666 -37.469293375 143.76517085"" <line111> + "" -37.469020091666664 143.76633230833335 -37.469102166666666 143.76702998333334""; <line112> actual = <line113> evaluate( <line114> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.192654']/gsml:shape/gml:MultiSurface/gml:surfaceMember/gml:Polygon/gml:exterior/gml:LinearRing/gml:posList"", <line115> doc); <line116> assertTrue(this.isEqualGeometry(actual, expected, 5)); <line117> } <line118> } <line119> "	<line7>      LOGGER.info(prettyString(doc));	task4	
public class A { <line0> public void run() { <line1> try { <line2> run0(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.error(""Failed to terminate workers"", e);"	task4	
public class A { <line0> public static void printSizeStats(String type, double density, long count, long totalBytes) { <line1> } <line2> } <line3> 	"<line1>    LOG.info(StringUtils.format("" type = %s, density = %06.5f, count = %5d, average byte size = %5d"",type, density, count, totalBytes / count));"	task4	
"public class A { <line0> static void linkUserData(String tempDirName) { <line1> String userDataFilePath = <line2> tempDirName + ConfigDrive.cloudStackConfigDriveName + ""userdata/user_data.txt""; <line3> File file = new File(userDataFilePath); <line4> if (file.exists()) { <line5> Script hardLink = new Script(""ln"", Duration.standardSeconds(300), LOG); <line6> hardLink.add(userDataFilePath); <line7> hardLink.add(tempDirName + ConfigDrive.openStackConfigDriveName + ""user_data""); <line8> String executionResult = hardLink.execute(); <line9> if (StringUtils.isNotBlank(executionResult)) { <line10> throw new CloudRuntimeException( <line11> ""Unable to create user_data link due to "" + executionResult); <line12> } <line13> } <line14> } <line15> } <line16> "	"<line8>      LOG.debug(""execute command: "" + hardLink.toString());"	task4	
public class A { <line0> static void reTryKerberos(boolean enabled) { <line1> if (enabled) { <line2> try { <line3> if (UserGroupInformation.isLoginKeytabBased()) { <line4> UserGroupInformation.getLoginUser().reloginFromKeytab(); <line5> } else if (UserGroupInformation.isLoginTicketBased()) { <line6> UserGroupInformation.getLoginUser().reloginFromTicketCache(); <line7> } <line8> } catch (IOException e) { <line9> throw new RuntimeException(e); <line10> } <line11> } <line12> } <line13> } <line14> 	"<line2>      log.debug(""Try relogin kerberos at first!"");"	task4	
public class A { <line0> @Override <line1> public Uni<SecurityIdentity> authenticate( <line2> TrustedAuthenticationRequest request, AuthenticationRequestContext context) { <line3> return context.runBlocking( <line4> new Supplier<SecurityIdentity>() { <line5> @Override <line6> public SecurityIdentity get() { <line7> EntityManager em = entityManagerFactory.createEntityManager(); <line8> ((org.hibernate.Session) em).setHibernateFlushMode(FlushMode.MANUAL); <line9> ((org.hibernate.Session) em).setDefaultReadOnly(true); <line10> try { <line11> return authenticate(em, request); <line12> } catch (SecurityException e) { <line13> throw new AuthenticationFailedException(); <line14> } finally { <line15> em.close(); <line16> } <line17> } <line18> }); <line19> } <line20> } <line21> 	"<line13>              log.debug(""Authentication failed"", e);"	task4	
public class A { <line0> @Override <line1> public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception { <line2> RoomParticipant user = (RoomParticipant) session.getAttributes().get(USER); <line3> if (user != null && !user.isClosed()) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.warn(""Transport error"", exception);"	task4	
"public class A { <line0> @Override <line1> public ContentStream getContentStream( <line2> final String repositoryId, <line3> final String objectId, <line4> final String streamId, <line5> final BigInteger offset, <line6> final BigInteger length, <line7> final ExtensionsData extension) { <line8> final App app = StructrApp.getInstance(); <line9> ContentStreamImpl result = null; <line10> try (final Tx tx = app.tx()) { <line11> final File file = app.get(File.class, objectId); <line12> if (file != null) { <line13> return new CMISContentStream(file, offset, length); <line14> } <line15> tx.success(); <line16> } catch (Throwable t) { <line17> } <line18> if (result != null) { <line19> return result; <line20> } <line21> throw new CmisObjectNotFoundException(""Object with ID "" + objectId + "" does not exist""); <line22> } <line23> } <line24> "	"<line17>      logger.warn("""", t);"	task4	
"public class A { <line0> public static com.liferay.asset.kernel.model.AssetVocabulary addVocabulary( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String title, <line4> java.util.Map<java.util.Locale, String> titleMap, <line5> java.util.Map<java.util.Locale, String> descriptionMap, <line6> String settings, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey( <line12> AssetVocabularyServiceUtil.class, ""addVocabulary"", _addVocabularyParameterTypes1); <line13> MethodHandler methodHandler = <line14> new MethodHandler( <line15> methodKey, groupId, title, titleMap, descriptionMap, settings, serviceContext); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.asset.kernel.model.AssetVocabulary) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	<line27>      log.error(systemException, systemException);	task4	
"public class A { <line0> private static int toICUCollatorReorderCode(final String reorderCode) { <line1> switch (reorderCode.toLowerCase()) { <line2> case ""default"": <line3> return Collator.ReorderCodes.DEFAULT; <line4> case ""none"": <line5> return Collator.ReorderCodes.NONE; <line6> case ""others"": <line7> return Collator.ReorderCodes.OTHERS; <line8> case ""space"": <line9> return Collator.ReorderCodes.SPACE; <line10> case ""first"": <line11> return Collator.ReorderCodes.FIRST; <line12> case ""punctuation"": <line13> return Collator.ReorderCodes.PUNCTUATION; <line14> case ""symbol"": <line15> return Collator.ReorderCodes.SYMBOL; <line16> case ""currency"": <line17> return Collator.ReorderCodes.CURRENCY; <line18> case ""digit"": <line19> return Collator.ReorderCodes.DIGIT; <line20> default: <line21> return -1; <line22> } <line23> } <line24> } <line25> "	"<line21>        logger.warn(""eXist-db does not support the collation reorderCode: {}"", reorderCode);"	task4	
public class A { <line0> public void addAllSpouts(List<SpoutDef> spouts, boolean override) { <line1> for (SpoutDef spout : spouts) { <line2> String id = spout.getId(); <line3> if (this.spoutMap.get(id) == null || override) { <line4> this.spoutMap.put(spout.getId(), spout); <line5> } else { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        LOG.warn(""Ignoring attempt to create spout '{}' with override == false."", id);"	task4	
"public class A { <line0> @Override <line1> public OpenCGAResult update( <line2> Query query, <line3> ObjectMap parameters, <line4> List<VariableSet> variableSetList, <line5> QueryOptions queryOptions) <line6> throws CatalogDBException, CatalogParameterException, CatalogAuthorizationException { <line7> if (parameters.containsKey(QueryParams.ID.key())) { <line8> if (count(query).getNumMatches() != 1) { <line9> throw new CatalogDBException( <line10> ""Operation not supported: '"" <line11> + QueryParams.ID.key() <line12> + ""' can only be updated for one family""); <line13> } <line14> } <line15> QueryOptions options = <line16> new QueryOptions( <line17> QueryOptions.INCLUDE, <line18> Arrays.asList( <line19> QueryParams.ID.key(), <line20> QueryParams.UID.key(), <line21> QueryParams.VERSION.key(), <line22> QueryParams.STUDY_UID.key())); <line23> DBIterator<Family> iterator = iterator(query, options); <line24> OpenCGAResult<Cohort> result = OpenCGAResult.empty(); <line25> while (iterator.hasNext()) { <line26> Family family = iterator.next(); <line27> try { <line28> result.append( <line29> runTransaction( <line30> clientSession -> <line31> privateUpdate( <line32> clientSession, family, parameters, variableSetList, queryOptions))); <line33> } catch (CatalogDBException | CatalogParameterException | CatalogAuthorizationException e) { <line34> result.getEvents().add(new Event(Event.Type.ERROR, family.getId(), e.getMessage())); <line35> result.setNumMatches(result.getNumMatches() + 1); <line36> } <line37> } <line38> return result; <line39> } <line40> } <line41> "	"<line34>        logger.error(""Could not update family {}: {}"", family.getId(), e.getMessage(), e);"	task4	
public class A { <line0> @Override <line1> public final void onCachePeriodChanged(final long period) { <line2> cacheSchedulerHelper.scheduleWithPeriod(period); <line3> cacheStrategy.clear(); <line4> } <line5> } <line6> 	"<line2>    LOG.info(""onCachePeriodChanged with value {} has been triggered!"", period);"	task4	
public class A { <line0> private synchronized boolean installPackage(final Map<String, Object> config) { <line1> boolean configChanged = false; <line2> Object packageName = config.get(OpenHAB.CFG_PACKAGE); <line3> if (packageName instanceof String) { <line4> currentPackage = (String) packageName; <line5> String fullName = PREFIX + PREFIX_PACKAGE + ((String) packageName).trim(); <line6> if (MINIMAL_PACKAGE.equals(currentPackage)) { <line7> configChanged = false; <line8> } else { <line9> if (installFeature(fullName)) { <line10> configChanged = true; <line11> } <line12> } <line13> try { <line14> for (Feature feature : featuresService.listFeatures()) { <line15> if (feature.getName().startsWith(PREFIX + PREFIX_PACKAGE) <line16> && !feature.getName().equals(fullName)) { <line17> uninstallFeature(feature.getName()); <line18> } <line19> } <line20> } catch (Exception e) { <line21> } <line22> } <line23> return configChanged; <line24> } <line25> } <line26> 	"<line21>        logger.error(""Failed retrieving features: {}"", e.getMessage(), debugException(e));"	task4	
public class A { <line0> @Override <line1> public void write(long cuboidId, GTRecord record) throws IOException { <line2> if (lastCuboidId == null || !lastCuboidId.equals(cuboidId)) { <line3> if (lastCuboidId != null) { <line4> cuboidRowCount = 0; <line5> } <line6> initVariables(cuboidId); <line7> lastCuboidId = cuboidId; <line8> } <line9> cuboidRowCount++; <line10> rowKeyEncoder.encode(record, record.getInfo().getPrimaryKey(), keyBuf); <line11> valueBuf.clear(); <line12> try { <line13> record.exportColumns(measureColumns, valueBuf); <line14> } catch (BufferOverflowException boe) { <line15> valueBuf = ByteBuffer.allocate((int) (record.sizeOf(measureColumns) * 1.5)); <line16> record.exportColumns(measureColumns, valueBuf); <line17> } <line18> outputKey.set(keyBuf, 0, keyBuf.length); <line19> outputValue.set(valueBuf.array(), 0, valueBuf.position()); <line20> writeAsKeyValue(outputKey, outputValue); <line21> } <line22> } <line23> 	"<line4>        logger.info(""Cuboid "" + lastCuboidId + "" has "" + cuboidRowCount + "" rows"");"	task4	
public class A { <line0> @Override <line1> public void releaseAddress(String ip) { <line2> } <line3> } <line4> 	"<line2>    log.warn(""Not implemented: DockerIaas.releaseAddress()"");"	task4	
"public class A { <line0> @ParallelTest <line1> void testMirrorMakerLogSetting(ExtensionContext extensionContext) { <line2> String clusterName = mapWithClusterNames.get(extensionContext.getDisplayName()); <line3> String mirrorMakerName = clusterName + ""-mirror-maker""; <line4> resourceManager.createResource( <line5> extensionContext, <line6> KafkaMirrorMakerTemplates.kafkaMirrorMaker( <line7> mirrorMakerName, <line8> LOG_SETTING_CLUSTER_NAME, <line9> GC_LOGGING_SET_NAME, <line10> ""my-group"", <line11> 1, <line12> false) <line13> .editMetadata() <line14> .withNamespace(NAMESPACE) <line15> .endMetadata() <line16> .editSpec() <line17> .withNewInlineLogging() <line18> .withLoggers(MIRROR_MAKER_LOGGERS) <line19> .endInlineLogging() <line20> .withNewJvmOptions() <line21> .withGcLoggingEnabled(true) <line22> .endJvmOptions() <line23> .endSpec() <line24> .build()); <line25> String mmDepName = KafkaMirrorMakerResources.deploymentName(mirrorMakerName); <line26> Map<String, String> mmPods = DeploymentUtils.depSnapshot(NAMESPACE, mmDepName); <line27> String mirrorMakerMap = KafkaMirrorMakerResources.metricsAndLogConfigMapName(mirrorMakerName); <line28> assertThat( <line29> ""KafkaMirrorMaker's log level is set properly"", <line30> checkLoggersLevel(NAMESPACE, MIRROR_MAKER_LOGGERS, mirrorMakerMap), <line31> is(true)); <line32> assertThat( <line33> ""Mirror-maker GC logging is enabled"", <line34> checkGcLoggingDeployments(NAMESPACE, mmDepName), <line35> is(true)); <line36> KafkaMirrorMakerResource.replaceMirrorMakerResourceInSpecificNamespace( <line37> mirrorMakerName, mm -> mm.getSpec().setJvmOptions(JVM_OPTIONS), NAMESPACE); <line38> DeploymentUtils.waitTillDepHasRolled(NAMESPACE, mmDepName, 1, mmPods); <line39> assertThat( <line40> ""Mirror-maker GC logging is disabled"", <line41> checkGcLoggingDeployments(NAMESPACE, mmDepName), <line42> is(false)); <line43> kubectlGetStrimziUntilOperationIsSuccessful(NAMESPACE, mirrorMakerName); <line44> checkContainersHaveProcessOneAsTini(NAMESPACE, mirrorMakerName); <line45> } <line46> } <line47> "	"<line28>    LOGGER.info(""Checking if MirrorMaker has log level set properly"");"	task4	
public class A { <line0> @Override <line1> public void setAttribute(AlluxioURI path, SetAttributePOptions options) <line2> throws FileDoesNotExistException, IOException, AlluxioException { <line3> checkUri(path); <line4> SetAttributePOptions mergedOptions = <line5> FileSystemOptions.setAttributeClientDefaults(mFsContext.getPathConf(path)).toBuilder() <line6> .mergeFrom(options) <line7> .build(); <line8> rpc( <line9> client -> { <line10> client.setAttribute(path, mergedOptions); <line11> return null; <line12> }); <line13> } <line14> } <line15> 	"<line11>          LOG.debug(""Set attributes for {}, options: {}"", path.getPath(), options);"	task4	
public class A { <line0> @Override <line1> public void add(IRingSet ringSet) { <line2> super.add(ringSet); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Adding ring set: "", ringSet);"	task4	
"public class A { <line0> private ContentItem readContent(URI uri) throws StorageException { <line1> Path path = getContentFilePath(uri); <line2> if (path == null) { <line3> throw new StorageException( <line4> ""Unable to find file for content ID: "" + uri.getSchemeSpecificPart()); <line5> } <line6> String filename = path.getFileName().toString(); <line7> InputStream contentInputStream; <line8> String extension; <line9> try { <line10> if (REF_EXT.equals(FilenameUtils.getExtension(filename))) { <line11> extension = <line12> FilenameUtils.getExtension( <line13> FilenameUtils.removeExtension(path.getFileName().toString())); <line14> contentInputStream = getInputStreamFromReference(path); <line15> } else { <line16> extension = FilenameUtils.getExtension(path.getFileName().toString()); <line17> contentInputStream = getInputStreamFromResource(path); <line18> } <line19> } catch (IOException e) { <line20> throw new StorageException( <line21> String.format(""Unable to resolve InputStream given URI of %s"", uri), e); <line22> } <line23> ByteSource byteSource = decryptStream(contentInputStream); <line24> long size = 0; <line25> try { <line26> size = byteSource.size(); <line27> } catch (IOException e) { <line28> } <line29> String mimeType = determineMimeType(extension, path, byteSource); <line30> return new ContentItemImpl( <line31> uri.getSchemeSpecificPart(), uri.getFragment(), byteSource, mimeType, filename, size, null); <line32> } <line33> } <line34> "	"<line28>      LOGGER.debug(""Problem determining size of resource; defaulting to {}."", size, e);"	task4	
public class A { <line0> private void successJoin(SIPCallImpl call) { <line1> try { <line2> _peer = _call2; <line3> MediaDialect dialect = ((ApplicationContextImpl) _call1.getApplicationContext()).getDialect(); <line4> dialect.setDtmfPassThrough((NetworkConnection) _call1.getMediaObject(), dtmfPassThrough); <line5> dialect.setDtmfPassThrough((NetworkConnection) call.getMediaObject(), dtmfPassThrough); <line6> _call1.linkCall(call, _joinType, _direction); <line7> _call1.setJoiningPeer(null); <line8> call.setJoiningPeer(null); <line9> done(Cause.JOINED, null); <line10> } catch (final Exception e) { <line11> done(Cause.ERROR, e); <line12> failCall(call, e); <line13> if (!candidateCalls.isEmpty()) { <line14> disconnectCalls(candidateCalls); <line15> } <line16> } <line17> } <line18> } <line19> 	"<line11>      LOG.error(""Exception when doing join on delegate "" + this, e);"	task4	
public class A { <line0> @Override <line1> public void concretProcessor(Object expKey, Map expValue, BasicDBObject set) { <line2> Map expressions = (Map) expValue.get(expKey); <line3> Set keys = expressions.keySet(); <line4> Iterator iter = keys.iterator(); <line5> while (iter.hasNext()) { <line6> String key = (String) iter.next(); <line7> Object value = expressions.get(key); <line8> if (value instanceof Map) { <line9> KVStrategy kv = new KVStrategy(); <line10> kv.concretProcessor(key, expressions, set); <line11> } else { <line12> set.append(key, value); <line13> } <line14> } <line15> } <line16> } <line17> 	"<line13>        log.info(this, ""@key: "" + key + ""@value:"" + value);"	task4	
public class A { <line0> private boolean valid(MultiSearchResult.MultiSearchResponse multiSearchResponse) { <line1> if (multiSearchResponse.isError) { <line2> return false; <line3> } <line4> return true; <line5> } <line6> } <line7> 	"<line2>      logger.error(""failed to execute multiSearch: {}"", multiSearchResponse);"	task4	
public class A { <line0> public int getTableColumnViewIndex(IColumn col, int defaultIndex, String configName) { <line1> if (m_prefs == null) { <line2> return defaultIndex; <line3> } <line4> String key = createColumnConfigKey(col, configName, TABLE_COLUMN_UIINDEX); <line5> String value = m_prefs.get(key, null); <line6> if (value != null) { <line7> try { <line8> return Integer.parseInt(value); <line9> } catch (Exception e) { <line10> } <line11> } <line12> return defaultIndex; <line13> } <line14> } <line15> 	"<line10>        LOG.warn(""could not get table column view index for [{}]. Loaded value '{}'"",col.getClass().getName(),value,e);"	task4	
"public class A { <line0> @Override <line1> public Can<IsisBeanMetaData> getAndDrainIntrospectableTypes() { <line2> if (introspectableTypes == null) { <line3> throw _Exceptions.illegalState(""introspectable types had already been drained (one shot)""); <line4> } <line5> val defensiveCopy = Can.ofCollection(introspectableTypes.values()); <line6> if (log.isDebugEnabled()) { <line7> defensiveCopy.forEach( <line8> type -> { <line9> }); <line10> } <line11> introspectableTypes = null; <line12> return defensiveCopy; <line13> } <line14> } <line15> "	"<line9>            log.debug(""to be introspected: {}"", type);"	task4	
"public class A { <line0> public static Set<String> evaluateEL(String expression) { <line1> String regex = ""\\$\\{(\\w+)\\}""; <line2> Set<String> matches = new HashSet<String>(); <line3> Pattern pattern = Pattern.compile(regex); <line4> Matcher matcher = pattern.matcher(expression); <line5> while (matcher.find()) { <line6> String key = matcher.group(1); <line7> matches.add(key); <line8> } <line9> return matches; <line10> } <line11> } <line12> "	<line7>      log.debug(key);	task4	
public class A { <line0> @Override <line1> public void configure(ApplicationContext applicationContext, SpringCamelContext camelContext) { <line2> CamelConfigurationProperties config = <line3> applicationContext.getBean(CamelConfigurationProperties.class); <line4> if (config != null) { <line5> try { <line6> CamelAutoConfiguration.doConfigureCamelContext(applicationContext, camelContext, config); <line7> } catch (Exception e) { <line8> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line6>        LOG.debug(""Merging XML based CamelContext with Spring Boot configuration properties"");"	task4	
"public class A { <line0> @Override <line1> public String createEntityExtractUrl( <line2> DataStore store, String installPath, Storage.ImageFormat format, DataObject dataObject) { <line3> EndPoint ep = _epSelector.select(store); <line4> if (ep == null) { <line5> String errMsg = ""No remote endpoint to send command, check if host or ssvm is down?""; <line6> return null; <line7> } <line8> String path = installPath; <line9> String uuid = UUID.randomUUID().toString() + ""."" + format.getFileExtension(); <line10> return generateCopyUrl(ep.getPublicAddr(), uuid); <line11> } <line12> } <line13> "	<line6>      logger.error(errMsg);	task4	
public class A { <line0> @Override <line1> public boolean statusUpdate(TaskAttemptID taskId, TaskStatus taskStatus) <line2> throws IOException, InterruptedException { <line3> TaskInProgress tip = tasks.get(taskId); <line4> if (tip != null) { <line5> tip.reportProgress(taskStatus); <line6> return true; <line7> } else { <line8> return false; <line9> } <line10> } <line11> } <line12> 	"<line8>      LOG.warn(""Progress from unknown child task: "" + taskId);"	task4	
public class A { <line0> @Override <line1> protected void i_createTables(TableCreatingConnection tcConn, List<TableSpec> tSpecs) <line2> throws SQLException { <line3> Iterator<TableSpec> nii = tSpecs.iterator(); <line4> while (nii.hasNext()) { <line5> TableSpec spec = nii.next(); <line6> if (logger.isInfoEnabled()) { <line7> StringBuilder sqlCmds = new StringBuilder(128); <line8> Iterator<String> iter = tcConn.getDDLConverter().getDDL(spec).iterator(); <line9> while (iter.hasNext()) { <line10> sqlCmds.append('\n'); <line11> sqlCmds.append(iter.next()); <line12> sqlCmds.append(';'); <line13> } <line14> } <line15> tcConn.createTable(spec); <line16> } <line17> } <line18> } <line19> 	"<line14>        logger.info(""Creating new table '{}' with command(s): {}"", spec.getName(), sqlCmds.toString());"	task4	
public class A { <line0> @Override <line1> public void onNext(DiscoveryResponse response) { <line2> XdsSchedulerManager.getInstance().stopAPIDiscoveryScheduling(); <line3> latestReceived = response; <line4> try { <line5> List<Api> apis = handleResponse(response); <line6> apiFactory.addApis(apis); <line7> ack(); <line8> } catch (Exception e) { <line9> onError(e); <line10> } <line11> } <line12> } <line13> 	"<line2>    logger.debug(""Received API discovery response "" + response);"	task4	
public class A { <line0> @Override <line1> public void postProcessContext(DeploymentUnit deploymentUnit, StandardContext webContext) { <line2> if (webContext instanceof SIPWebContext) { <line3> ((SIPWebContext) webContext).postProcessContext(deploymentUnit); <line4> } <line5> } <line6> } <line7> 	"<line2>    logger.debug(""postProcessContext() for "" + deploymentUnit.getName());"	task4	
public class A { <line0> public void sleepUntilNextRetry() throws InterruptedException { <line1> int attempts = getAttemptTimes(); <line2> long sleepTime = getBackoffTime(); <line3> retryConfig.getTimeUnit().sleep(sleepTime); <line4> useRetry(); <line5> } <line6> } <line7> 	"<line3>    LOG.trace(""Sleeping {} ms before retry #{}..."", sleepTime, attempts);"	task4	
public class A { <line0> private static IReflectionFactory initialize() { <line1> final Class<?> factoryClass = <line2> com.gigaspaces.internal.reflection.fast.ASMReflectionFactory.class; <line3> IReflectionFactory reflectionFactory = <line4> (IReflectionFactory) createInstanceWithOptionalDependencies(factoryClass); <line5> if (reflectionFactory == null) { <line6> reflectionFactory = new StandardReflectionFactory(); <line7> } <line8> return reflectionFactory; <line9> } <line10> } <line11> 	"<line6>      logger.warn(""Failed to create reflection factory [""+ factoryClass.getName()+ ""], falling back to standard reflection instead"");"	task4	
public class A { <line0> @Override <line1> public int minHealthyVolumeNum(List<DatanodeDetails> dnList) { <line2> List<Integer> volumeCountList = new ArrayList<>(dnList.size()); <line3> for (DatanodeDetails dn : dnList) { <line4> try { <line5> volumeCountList.add(nodeStateManager.getNode(dn).getHealthyVolumeCount()); <line6> } catch (NodeNotFoundException e) { <line7> } <line8> } <line9> Preconditions.checkArgument(!volumeCountList.isEmpty()); <line10> return Collections.min(volumeCountList); <line11> } <line12> } <line13> 	"<line7>        LOG.warn(""Cannot generate NodeStat, datanode {} not found."", dn.getUuid());"	task4	
public class A { <line0> @Override <line1> public synchronized void stopScan() { <line2> if (bridgeHandler == null) { <line3> return; <line4> } <line5> bridgeHandler.stopDiscovery(); <line6> super.stopScan(); <line7> } <line8> } <line9> 	"<line5>    logger.info(""Stopping EnOcean discovery scan"");"	task4	
public class A { <line0> @Override <line1> public int run(final Path outputDir, final int numReducers) throws Exception { <line2> PrivilegedExceptionAction<Integer> scanAction = <line3> new PrivilegedExceptionAction<Integer>() { <line4> @Override <line5> public Integer run() throws Exception { <line6> return doVerify(outputDir, numReducers); <line7> } <line8> }; <line9> return USER.runAs(scanAction); <line10> } <line11> } <line12> 	"<line2>    LOG.info(""Running Verify with outputDir="" + outputDir + "", numReducers="" + numReducers);"	task4	
"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> private int compare(final T o1, final T o2, final String prop, final boolean asc) { <line2> if (prop == null) { <line3> return 0; <line4> } <line5> try { <line6> final Object value1 = BeanHelper.getNestedProperty(o1, prop); <line7> final Object value2 = BeanHelper.getNestedProperty(o2, prop); <line8> if (value1 == null) { <line9> if (value2 == null) return 0; <line10> else return (asc) ? -1 : 1; <line11> } <line12> if (value2 == null) { <line13> return (asc) ? 1 : -1; <line14> } <line15> if (value1 instanceof String && value2 instanceof String) { <line16> if (checkAnnotation( <line17> BeanHelper.getDeclaredAnnotations(o1.getClass(), prop), <line18> StringAlphanumericSort.class) <line19> && checkAnnotation( <line20> BeanHelper.getDeclaredAnnotations(o2.getClass(), prop), <line21> StringAlphanumericSort.class)) { <line22> AlphanumericComparator alphanumericComparator = <line23> new AlphanumericComparator(ThreadLocalUserContext.getLocale()); <line24> if (asc) { <line25> return alphanumericComparator.compare((String) value2, (String) value1); <line26> } else { <line27> return alphanumericComparator.compare((String) value1, (String) value2); <line28> } <line29> } else { <line30> return StringComparator.compare((String) value1, (String) value2, asc); <line31> } <line32> } <line33> if (ClassUtils.isAssignable(value2.getClass(), value1.getClass())) { <line34> if (asc) { <line35> return ((Comparable) value1).compareTo(value2); <line36> } else { <line37> return -((Comparable) value1).compareTo(value2); <line38> } <line39> } else { <line40> final String sval1 = String.valueOf(value1); <line41> final String sval2 = String.valueOf(value2); <line42> if (asc) { <line43> return sval1.compareTo(sval2); <line44> } else { <line45> return -sval1.compareTo(sval2); <line46> } <line47> } <line48> } catch (final Exception ex) { <line49> return 0; <line50> } <line51> } <line52> } <line53> "	"<line49>      log.error(""Exception while comparing values of property '"" + prop + ""': "" + ex.getMessage());"	task4	
public class A { <line0> private synchronized void sendPingMessage() { <line1> try { <line2> Objects.requireNonNull(session).getRemote().sendPing(ByteBuffer.wrap(PING_PAYLOAD)); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.warn(""Cannot send ping message over web-socket session {}."", session, e);"	task4	
public class A { <line0> public static IActionSet getExampleActionSetService(String name, String version) <line1> throws ActivatorException { <line2> try { <line3> return (IActionSet) <line4> getServiceFromRegistry(context, createFilterExampleActionSet(name, version)); <line5> } catch (InvalidSyntaxException e) { <line6> throw new ActivatorException(e); <line7> } <line8> } <line9> } <line10> 	"<line3>      log.debug(""Calling ExampleActionSetService"");"	task4	
public class A { <line0> private String extractUserRoleCodeSystemName(AssertionType assertion) { <line1> String value = null; <line2> if (assertion != null <line3> && assertion.getUserInfo() != null <line4> && assertion.getUserInfo().getRoleCoded() != null) { <line5> value = assertion.getUserInfo().getRoleCoded().getCodeSystemName(); <line6> } else { <line7> } <line8> return value; <line9> } <line10> } <line11> 	"<line7>      LOG.warn(""Unable to find user role in SAML, will not be included in message to policy engine"");"	task4	
public class A { <line0> @Override <line1> public String getClientID() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> checkClosed(); <line5> if (clientID == null) { <line6> return ((ActiveMQResourceAdapter) mcf.getResourceAdapter()).getProperties().getClientID(); <line7> } <line8> return clientID; <line9> } <line10> } <line11> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""getClientID()"");"	task4	
"public class A { <line0> private void verifyServiceInstances(final Service service) throws Exception { <line1> final Instances instances = <line2> graphql.instances( <line3> new InstancesQuery().serviceId(service.getKey()).start(startTime).end(now())); <line4> load(""expected/profile/instances.yml"").as(InstancesMatcher.class).verify(instances); <line5> } <line6> } <line7> "	"<line4>    LOGGER.info(""instances: {}"", instances);"	task4	
"public class A { <line0> private PipeLine createPipeLineFromPropertiesFile(File propertiesFile) <line1> throws IOException, ConfigurationException { <line2> Properties props = new Properties(); <line3> FileInputStream fis = null; <line4> try { <line5> fis = new FileInputStream(propertiesFile); <line6> props.load(fis); <line7> } finally { <line8> try { <line9> if (fis != null) { <line10> fis.close(); <line11> } <line12> } catch (IOException e) { <line13> } <line14> } <line15> PipeLine pipeLine = new PipeLine(); <line16> String inputXsd = null; <line17> if (props.containsKey(""input.xsd"")) { <line18> inputXsd = props.getProperty(""input.xsd""); <line19> String inputNamespace = props.getProperty(""input.namespace""); <line20> String inputRoot = props.getProperty(""input.root""); <line21> String inputCmhString = props.getProperty(""input.cmh"", ""1""); <line22> int inputCmh = Integer.parseInt(inputCmhString); <line23> File inputXsdFile = new File(propertiesFile.getParent(), inputXsd); <line24> EsbSoapValidator inputValidator = <line25> createValidator(inputXsdFile, inputNamespace, inputRoot, 1, inputCmh); <line26> pipeLine.setInputValidator(inputValidator); <line27> } <line28> if (props.containsKey(""output.xsd"")) { <line29> String outputXsd = props.getProperty(""output.xsd""); <line30> String outputNamespace = props.getProperty(""output.namespace""); <line31> String outputRoot = props.getProperty(""output.root""); <line32> String outputCmhString = props.getProperty(""output.cmh"", ""1""); <line33> int outputCmh = Integer.parseInt(outputCmhString); <line34> File outputXsdFile = new File(propertiesFile.getParent(), outputXsd); <line35> int rootPosition; <line36> if (inputXsd != null && inputXsd.equalsIgnoreCase(outputXsd)) { <line37> rootPosition = 2; <line38> } else { <line39> rootPosition = 1; <line40> } <line41> EsbSoapValidator outputValidator = <line42> createValidator(outputXsdFile, outputNamespace, outputRoot, rootPosition, outputCmh); <line43> pipeLine.setOutputValidator(outputValidator); <line44> } <line45> return pipeLine; <line46> } <line47> } <line48> "	"<line13>        log.warn(""exception closing inputstream"", e);"	task4	
"public class A { <line0> @Test <line1> public void shouldDecodeNRowResponseSmallyChunked() throws Exception { <line2> String response = Resources.read(""chunked.json"", this.getClass()); <line3> String[] chunks = <line4> new String[] { <line5> response.substring(0, 48), <line6> response.substring(48, 84), <line7> response.substring(84, 144), <line8> response.substring(144, 258), <line9> response.substring(258, 438), <line10> response.substring(438, 564), <line11> response.substring(564, 702), <line12> response.substring(702, 740), <line13> response.substring(740) <line14> }; <line15> StringBuilder sb = new StringBuilder(""Chunks:""); <line16> for (String chunk : chunks) { <line17> sb.append(""\n>"").append(chunk); <line18> } <line19> shouldDecodeChunked(true, chunks); <line20> } <line21> } <line22> "	<line19>    LOGGER.info(sb.toString());	task4	
public class A { <line0> private Set<ContainerDto> convertContainersToContainerJson( <line1> Set<EnvironmentContainerHost> containerHosts, String datasource) { <line2> Set<ContainerDto> containerDtos = Sets.newHashSet(); <line3> for (EnvironmentContainerHost containerHost : containerHosts) { <line4> ContainerDto containerDto = <line5> new ContainerDto( <line6> containerHost.getId(), <line7> containerHost.getEnvironmentId().getId(), <line8> containerHost.getHostname(), <line9> containerHost.getIp(), <line10> containerHost.getTemplateName(), <line11> containerHost.getContainerSize(), <line12> containerHost.getArch().toString(), <line13> containerHost.getTags(), <line14> containerHost.getPeerId(), <line15> containerHost.getResourceHostId().getId(), <line16> containerHost.isLocal(), <line17> datasource, <line18> containerHost.getState(), <line19> containerHost.getTemplateId(), <line20> containerHost.getContainerName(), <line21> containerHost.getResourceHostId().getId()); <line22> try { <line23> ContainerQuota containerQuota = containerHost.getQuota(); <line24> if (containerQuota != null) { <line25> containerDto.setQuota(new ContainerQuotaDto(containerQuota)); <line26> } <line27> } catch (Exception e) { <line28> } <line29> containerDtos.add(containerDto); <line30> } <line31> return containerDtos; <line32> } <line33> } <line34> 	"<line28>        LOG.error(""Error getting container quota: {}"", e.getMessage());"	task4	
"public class A { <line0> @Override <line1> public LayoutPageTemplateEntry findByUUID_G(String uuid, long groupId) <line2> throws NoSuchPageTemplateEntryException { <line3> LayoutPageTemplateEntry layoutPageTemplateEntry = fetchByUUID_G(uuid, groupId); <line4> if (layoutPageTemplateEntry == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""uuid=""); <line8> sb.append(uuid); <line9> sb.append("", groupId=""); <line10> sb.append(groupId); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchPageTemplateEntryException(sb.toString()); <line15> } <line16> return layoutPageTemplateEntry; <line17> } <line18> } <line19> "	<line13>        log.debug(sb.toString());	task4	
"public class A { <line0> public Boolean call() throws Exception { <line1> long start = System.currentTimeMillis(); <line2> try { <line3> for (int i = 0; i < numEvents; i++) { <line4> runtime.sendEventBean(new SupportBean(""E"" + Integer.toString(i), 0), ""SupportBean""); <line5> } <line6> } catch (Exception ex) { <line7> return null; <line8> } <line9> long end = System.currentTimeMillis(); <line10> return true; <line11> } <line12> } <line13> "	"<line7>      log.error(""Error in thread "" + Thread.currentThread().getId(), ex);"	task4	
public class A { <line0> private boolean isKubernetesVersionSupportsHA() { <line1> boolean haSupported = false; <line2> KubernetesSupportedVersion version = getKubernetesClusterVersion(); <line3> if (version != null) { <line4> try { <line5> if (KubernetesVersionManagerImpl.compareSemanticVersions( <line6> version.getSemanticVersion(), <line7> KubernetesClusterService.MIN_KUBERNETES_VERSION_HA_SUPPORT) <line8> >= 0) { <line9> haSupported = true; <line10> } <line11> } catch (IllegalArgumentException e) { <line12> } <line13> } <line14> return haSupported; <line15> } <line16> } <line17> 	"<line12>        LOGGER.error(String.format(""Unable to compare Kubernetes version for cluster version : %s with %s"",version.getName(), KubernetesClusterService.MIN_KUBERNETES_VERSION_HA_SUPPORT),e);"	task4	
public class A { <line0> protected synchronized void notifyLostLock() { <line1> if (!isStarted) { <line2> return; <line3> } <line4> lockListeners.forEach( <line5> lockListener -> { <line6> try { <line7> lockListener.lostLock(); <line8> } catch (Exception e) { <line9> } <line10> }); <line11> } <line12> } <line13> 	"<line9>            LOGGER.warn(""On notify lost lock"", e);"	task4	
public class A { <line0> private Object handleDataWriteCommand( <line1> InvocationContext rCtx, <line2> DataWriteCommand writeCommand, <line3> Object rv, <line4> boolean assumeOriginKeptEntryInL1) { <line5> Object key; <line6> Object key1 = (key = writeCommand.getKey()); <line7> if (shouldUpdateOnWriteCommand(writeCommand) <line8> && writeCommand.isSuccessful() <line9> && cdl.getCacheTopology().isWriteOwner(key1)) { <line10> if (log.isTraceEnabled()) { <line11> } <line12> CompletableFuture<?> f = <line13> l1Manager.flushCache( <line14> Collections.singleton(key), rCtx.getOrigin(), assumeOriginKeptEntryInL1); <line15> return asyncReturnValue(f, rv); <line16> } <line17> return rv; <line18> } <line19> } <line20> 	"<line11>        log.trace(""Sending additional invalidation for requestors if necessary."");"	task4	
public class A { <line0> @POST <line1> @Schema(request = Schemas.PASSWORD_RESET_REQUEST) <line2> @Consumes({MediaTypes.JSON}) <line3> public Response get(ResetPasswordRequest resetPassword) throws BadRequestException { <line4> checkRights(getRights().canAccessPasswordReset()); <line5> getUserService().requestPasswordReset(resetPassword.getUser()); <line6> return Response.noContent().build(); <line7> } <line8> } <line9> 	"<line6>    LOG.info(""Successfully processed password reset request for user {}"", resetPassword.getUser());"	task4	
public class A { <line0> @Override <line1> public boolean isVisible(String locator) { <line2> boolean result = false; <line3> try { <line4> result = super.isVisible(locator); <line5> } catch (Throwable t) { <line6> } <line7> return result; <line8> } <line9> } <line10> 	"<line2>    log.info(""Entering: isVisible"");"	task4	
public class A { <line0> private boolean _isVersioningEnabled() { <line1> try { <line2> CProductVersionConfiguration cProductVersionConfiguration = <line3> ConfigurationProviderUtil.getConfiguration( <line4> CProductVersionConfiguration.class, <line5> new SystemSettingsLocator(CProductVersionConfiguration.class.getName())); <line6> if (cProductVersionConfiguration.enabled()) { <line7> return true; <line8> } <line9> } catch (PortalException portalException) { <line10> } <line11> return false; <line12> } <line13> } <line14> 	<line10>      log.error(portalException, portalException);	task4	
"public class A { <line0> @Override <line1> public void completed(HttpClientCallbackResult result) { <line2> String results = result.getReplyDataAsString(); <line3> JSONObject jo = JSON.parseObject(results); <line4> String code = jo.getString(""code""); <line5> String desc = jo.getString(""desc""); <line6> if (log.isDebugEnable()) { <line7> } <line8> } <line9> } <line10> "	"<line7>      log.debug(this, ""Send SMS END: phone="" + phoneNum + "",code="" + code + "",desc="" + desc);"	task4	
public class A { <line0> @OnReturn <line1> public static void onReturn( <line2> @BindReturn @Nullable Object returnValue, <line3> @BindReceiver HttpURLConnection httpURLConnection, <line4> @BindTraveler @Nullable TraceEntryOrTimer entryOrTimer) { <line5> if (httpURLConnection instanceof HasTraceEntryMixin) { <line6> if (returnValue instanceof HasTraceEntryMixin) { <line7> TraceEntry traceEntry = ((HasTraceEntryMixin) httpURLConnection).glowroot$getTraceEntry(); <line8> ((HasTraceEntryMixin) returnValue).glowroot$setTraceEntry(traceEntry); <line9> } else if (returnValue != null && !outputStreamIssueAlreadyLogged.getAndSet(true)) { <line10> } <line11> } <line12> ConnectAdvice.onReturn(entryOrTimer); <line13> } <line14> } <line15> 	"<line10>        logger.info(""found non-instrumented http url connection output stream, please""+ "" report to the Glowroot project: {}"",returnValue.getClass().getName());"	task4	
public class A { <line0> private void executeFinalActions(TestContext context) { <line1> if (!finalActions.isEmpty()) { <line2> for (final TestActionBuilder<?> actionBuilder : finalActions) { <line3> TestAction action = actionBuilder.build(); <line4> if (!action.isDisabled(context)) { <line5> context.getTestActionListeners().onTestActionStart(this, action); <line6> action.execute(context); <line7> context.getTestActionListeners().onTestActionFinish(this, action); <line8> } else { <line9> context.getTestActionListeners().onTestActionSkipped(this, action); <line10> } <line11> } <line12> } <line13> if (testResult.isSuccess() && context.hasExceptions()) { <line14> CitrusRuntimeException contextException = context.getExceptions().remove(0); <line15> testResult = TestResult.failed(getName(), testClass.getName(), contextException); <line16> throw new TestCaseFailedException(contextException); <line17> } <line18> } <line19> } <line20> 	"<line2>      log.debug(""Entering finally block in test case"");"	task4	
"public class A { <line0> private void readDockerConf(File src, Properties properties) { <line1> File dockerConf = new File(src, ""docker.yml""); <line2> if (dockerConf.exists()) { <line3> try { <line4> confs.putAll(Confs.read(dockerConf, properties)); <line5> } catch (IOException e) { <line6> throw new OrchestrationException(e); <line7> } <line8> } <line9> } <line10> } <line11> "	"<line3>      LOG.info(""reading "" + dockerConf);"	task4	
"public class A { <line0> @Override <line1> public URL createAttachmentURL( <line2> String filename, <line3> String spaces, <line4> String name, <line5> String action, <line6> String querystring, <line7> String xwikidb, <line8> XWikiContext context) { <line9> if ((context != null) <line10> && ""viewrev"".equals(context.getAction()) <line11> && context.get(""rev"") != null <line12> && isContextDoc(xwikidb, spaces, name, context)) { <line13> try { <line14> String docRevision = context.get(""rev"").toString(); <line15> XWikiAttachment attachment = <line16> findAttachmentForDocRevision(context.getDoc(), docRevision, filename, context); <line17> if (attachment == null) { <line18> action = ""viewattachrev""; <line19> } else { <line20> long arbId = <line21> findDeletedAttachmentForDocRevision(context.getDoc(), docRevision, filename, context); <line22> return createAttachmentRevisionURL( <line23> filename, <line24> spaces, <line25> name, <line26> attachment.getVersion(), <line27> arbId, <line28> querystring, <line29> xwikidb, <line30> context); <line31> } <line32> } catch (XWikiException e) { <line33> if (LOGGER.isErrorEnabled()) { <line34> } <line35> } <line36> } <line37> StringBuffer newpath = new StringBuffer(this.contextPath); <line38> addServletPath(newpath, xwikidb, context); <line39> EntityReference spaceReference = <line40> this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE); <line41> addAction(newpath, spaceReference, action, context); <line42> addSpaces(newpath, spaceReference, action, context); <line43> addName(newpath, name, action, context); <line44> addFileName(newpath, filename, context); <line45> if (!StringUtils.isEmpty(querystring)) { <line46> newpath.append(""?""); <line47> newpath.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, ""&""), ""&amp;"")); <line48> } <line49> try { <line50> return normalizeURL(new URL(getServerURL(xwikidb, context), newpath.toString()), context); <line51> } catch (Exception e) { <line52> return null; <line53> } <line54> } <line55> } <line56> "	"<line34>          LOGGER.error(""Exception while trying to get attachment version !"", e);"	task4	
"public class A { <line0> @Test(timeout = 60000) <line1> public void testPeriodicCheckWhenLedgerDeleted() throws Exception { <line2> for (AuditorElector e : auditorElectors.values()) { <line3> e.shutdown(); <line4> } <line5> final int numLedgers = 100; <line6> List<Long> ids = new LinkedList<Long>(); <line7> for (int i = 0; i < numLedgers; i++) { <line8> LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, ""passwd"".getBytes()); <line9> ids.add(lh.getId()); <line10> for (int j = 0; j < 10; j++) { <line11> lh.addEntry(""testdata"".getBytes()); <line12> } <line13> lh.close(); <line14> } <line15> final Auditor auditor = <line16> new Auditor(Bookie.getBookieAddress(bsConfs.get(0)).toString(), bsConfs.get(0), zkc); <line17> final AtomicBoolean exceptionCaught = new AtomicBoolean(false); <line18> final CountDownLatch latch = new CountDownLatch(1); <line19> Thread t = <line20> new Thread() { <line21> public void run() { <line22> try { <line23> latch.countDown(); <line24> for (int i = 0; i < numLedgers; i++) { <line25> auditor.checkAllLedgers(); <line26> } <line27> } catch (Exception e) { <line28> exceptionCaught.set(true); <line29> } <line30> } <line31> }; <line32> t.start(); <line33> latch.await(); <line34> for (Long id : ids) { <line35> bkc.deleteLedger(id); <line36> } <line37> t.join(); <line38> assertFalse(""Shouldn't have thrown exception"", exceptionCaught.get()); <line39> } <line40> } <line41> "	"<line28>              LOG.error(""Caught exception while checking all ledgers"", e);"	task4	
public class A { <line0> @Override <line1> public void setHeader(HttpRequest httpRequest, String name, String value) { <line2> final HttpHeaders headers = httpRequest.headers(); <line3> if (headers != null) { <line4> headers.set(name, value); <line5> if (isDebug) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        logger.debug(""Set header {}={}"", name, value);"	task4	
public class A { <line0> private List<GluuAttribute> getAllPersonAtributes( <line1> GluuUserRole gluuUserRole, Collection<GluuAttribute> attributes) { <line2> List<GluuAttribute> attributeList = new ArrayList<GluuAttribute>(); <line3> String[] objectClassTypes = appConfiguration.getPersonObjectClassTypes(); <line4> for (GluuAttribute attribute : attributes) { <line5> if (StringHelper.equalsIgnoreCase( <line6> attribute.getOrigin(), appConfiguration.getPersonCustomObjectClass()) <line7> && (GluuUserRole.ADMIN == gluuUserRole)) { <line8> attribute.setCustom(true); <line9> attributeList.add(attribute); <line10> continue; <line11> } <line12> for (String objectClassType : objectClassTypes) { <line13> if (attribute.getOrigin().equals(objectClassType)) { <line14> attributeList.add(attribute); <line15> break; <line16> } <line17> } <line18> } <line19> return attributeList; <line20> } <line21> } <line22> 	"<line4>    log.debug(""objectClassTypes={}"", Arrays.toString(objectClassTypes));"	task4	
public class A { <line0> @BeforeEach <line1> void logTest(TestInfo testInfo) { <line2> } <line3> } <line4> 	"<line2>    log.info(""Executing: {}"", testInfo.getDisplayName());"	task4	
public class A { <line0> @Override <line1> public void processResult(CuratorFramework client, CuratorEvent event) throws Exception { <line2> try { <line3> if (event.getData() == null || event.getData().length == 0) { <line4> return; <line5> } <line6> bytes.getAndAdd(event.getData().length); <line7> final Q object = transcoder.fromBytes(event.getData()); <line8> if (allPathsMap.get(event.getPath()) != null) { <line9> resultsMap.putIfAbsent(allPathsMap.get(event.getPath()), new ArrayList<Q>()); <line10> resultsMap.get(allPathsMap.get(event.getPath())).add(object); <line11> } <line12> } finally { <line13> latch.countDown(); <line14> } <line15> } <line16> } <line17> 	"<line4>        LOG.trace(""Expected active node {} but it wasn't there"", event.getPath());"	task4	
public class A { <line0> private static List<String> resetCoprocessorOnHTables( <line1> HBaseAdmin hbaseAdmin, Path hdfsCoprocessorJar, List<String> tableNames) throws IOException { <line2> List<String> processed = new ArrayList<String>(); <line3> for (String tableName : tableNames) { <line4> try { <line5> resetCoprocessor(tableName, hbaseAdmin, hdfsCoprocessorJar); <line6> processed.add(tableName); <line7> } catch (IOException ex) { <line8> } <line9> } <line10> return processed; <line11> } <line12> } <line13> 	"<line8>        logger.error(""Error processing "" + tableName, ex);"	task4	
public class A { <line0> public static <SESSION extends ISession> SESSION currentSession(final Class<SESSION> type) { <line1> ISession session = ISession.CURRENT.get(); <line2> if (session == null) { <line3> return null; <line4> } <line5> if (!type.isInstance(session)) { <line6> return null; <line7> } <line8> return type.cast(session); <line9> } <line10> } <line11> 	"<line6>      LOG.debug(""Session not of the expected type [session={}, expectedType={}]"", session, type);"	task4	
"public class A { <line0> @SuppressWarnings(""synthetic-access"") <line1> public InitialImageAdvice adviseInitialImage( <line2> InitialImageAdvice previousAdvice, boolean persistent) { <line3> initializationGate(); <line4> if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_ADVISOR_VERBOSE)) { <line5> dumpProfiles(""AdviseInitialImage""); <line6> } <line7> Profile[] allProfiles = profiles; <line8> if (allProfiles.length == 0) { <line9> return new InitialImageAdvice(); <line10> } <line11> Set<InternalDistributedMember> replicates = new HashSet<>(); <line12> Set<InternalDistributedMember> others = new HashSet<>(); <line13> Set<InternalDistributedMember> preloaded = new HashSet<>(); <line14> Set<InternalDistributedMember> empties = new HashSet<>(); <line15> Set<InternalDistributedMember> uninitialized = new HashSet<>(); <line16> Set<InternalDistributedMember> nonPersistent = new HashSet<>(); <line17> Map<InternalDistributedMember, CacheProfile> memberProfiles = new HashMap<>(); <line18> for (Profile allProfile : allProfiles) { <line19> CacheProfile profile = (CacheProfile) allProfile; <line20> if (previousAdvice != null) { <line21> CacheProfile previousProfile = <line22> previousAdvice.memberProfiles.get(profile.getDistributedMember()); <line23> if (previousProfile != null <line24> && previousProfile.getSerialNumber() == profile.getSerialNumber() <line25> && previousProfile.getVersion() == profile.getVersion()) { <line26> continue; <line27> } <line28> } <line29> if (profile.getInRecovery()) { <line30> uninitialized.add(profile.getDistributedMember()); <line31> continue; <line32> } <line33> if (!profile.regionInitialized) { <line34> uninitialized.add(profile.getDistributedMember()); <line35> continue; <line36> } <line37> if (profile.dataPolicy.withReplication()) { <line38> if (!persistent || profile.dataPolicy.withPersistence()) { <line39> replicates.add(profile.getDistributedMember()); <line40> } else { <line41> nonPersistent.add(profile.getDistributedMember()); <line42> } <line43> memberProfiles.put(profile.getDistributedMember(), profile); <line44> } else if (profile.dataPolicy.isPreloaded()) { <line45> preloaded.add(profile.getDistributedMember()); <line46> memberProfiles.put(profile.getDistributedMember(), profile); <line47> } else if (profile.dataPolicy.withStorage()) { <line48> others.add(profile.getDistributedMember()); <line49> memberProfiles.put(profile.getDistributedMember(), profile); <line50> } else { <line51> empties.add(profile.getDistributedMember()); <line52> } <line53> } <line54> InitialImageAdvice advice = <line55> new InitialImageAdvice( <line56> replicates, others, preloaded, empties, uninitialized, nonPersistent, memberProfiles); <line57> if (logger.isDebugEnabled()) { <line58> } <line59> return advice; <line60> } <line61> } <line62> "	<line58>      logger.debug(advice);	task4	
public class A { <line0> protected void addChildren(RebindContext rebindContext, LocationMemento memento) { <line1> for (String childId : memento.getChildren()) { <line2> Location child = rebindContext.lookup().lookupLocation(childId); <line3> if (child != null) { <line4> location.addChild(child); <line5> } else { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        LOG.warn(""Ignoring child {} of location {}({}), as cannot be found"",new Object[] {childId, memento.getType(), memento.getId()});"	task4	
"public class A { <line0> public static ImageWriter getImageWriterFromImageIOServiceRegistry(ImageWriterParam param) { <line1> Iterator<ImageWriter> iter = ImageIO.getImageWritersByFormatName(param.formatName); <line2> if (!iter.hasNext()) <line3> throw new RuntimeException(""No Writer for format: "" + param.formatName + "" registered""); <line4> ImageWriter writer = iter.next(); <line5> if (param.className != null) { <line6> while (!param.className.equals(writer.getClass().getName())) { <line7> if (iter.hasNext()) writer = iter.next(); <line8> else { <line9> break; <line10> } <line11> } <line12> } <line13> return writer; <line14> } <line15> } <line16> "	"<line9>          LOG.warn(""No preferred Writer {} for format: {} - use {}"",param.className,param.formatName,writer.getClass().getName());"	task4	
"public class A { <line0> @Bean(name = ""domainDistributionAutomationInboundKafkaRequestsMessageListenerContainer"") <line1> public DefaultMessageListenerContainer messageListenerContainer( <line2> @Qualifier(""domainDistributionAutomationInboundKafkaRequestsMessageListener"") <line3> final MessageListener messageListener) { <line4> return this.jmsConfigurationFactory.initMessageListenerContainer(messageListener); <line5> } <line6> } <line7> "	"<line4>    LOGGER.info(""Initializing domainDistributionAutomationInboundKafkaRequestsMessageListenerContainer""+ "" bean."");"	task4	
public class A { <line0> @Override <line1> public void onPendingFailure(ProviderException cause) { <line2> participants.put(envelope.getConsumerId(), envelope.getConsumerId()); <line3> } <line4> } <line5> 	"<line2>    LOG.trace(""TX:{} has failed a acknowledge."", getTransactionId());"	task4	
public class A { <line0> @Override <line1> public KaleoTaskFormInstance fetchByKaleoTaskFormId( <line2> long kaleoTaskFormId, boolean useFinderCache) { <line3> Object[] finderArgs = null; <line4> if (useFinderCache) { <line5> finderArgs = new Object[] {kaleoTaskFormId}; <line6> } <line7> Object result = null; <line8> if (useFinderCache) { <line9> result = finderCache.getResult(_finderPathFetchByKaleoTaskFormId, finderArgs); <line10> } <line11> if (result instanceof KaleoTaskFormInstance) { <line12> KaleoTaskFormInstance kaleoTaskFormInstance = (KaleoTaskFormInstance) result; <line13> if (kaleoTaskFormId != kaleoTaskFormInstance.getKaleoTaskFormId()) { <line14> result = null; <line15> } <line16> } <line17> if (result == null) { <line18> StringBundler sb = new StringBundler(3); <line19> sb.append(_SQL_SELECT_KALEOTASKFORMINSTANCE_WHERE); <line20> sb.append(_FINDER_COLUMN_KALEOTASKFORMID_KALEOTASKFORMID_2); <line21> String sql = sb.toString(); <line22> Session session = null; <line23> try { <line24> session = openSession(); <line25> Query query = session.createQuery(sql); <line26> QueryPos queryPos = QueryPos.getInstance(query); <line27> queryPos.add(kaleoTaskFormId); <line28> List<KaleoTaskFormInstance> list = query.list(); <line29> if (list.isEmpty()) { <line30> if (useFinderCache) { <line31> finderCache.putResult(_finderPathFetchByKaleoTaskFormId, finderArgs, list); <line32> } <line33> } else { <line34> if (list.size() > 1) { <line35> Collections.sort(list, Collections.reverseOrder()); <line36> if (log.isWarnEnabled()) { <line37> if (!useFinderCache) { <line38> finderArgs = new Object[] {kaleoTaskFormId}; <line39> } <line40> } <line41> } <line42> KaleoTaskFormInstance kaleoTaskFormInstance = list.get(0); <line43> result = kaleoTaskFormInstance; <line44> cacheResult(kaleoTaskFormInstance); <line45> } <line46> } catch (Exception exception) { <line47> throw processException(exception); <line48> } finally { <line49> closeSession(session); <line50> } <line51> } <line52> if (result instanceof List<?>) { <line53> return null; <line54> } else { <line55> return (KaleoTaskFormInstance) result; <line56> } <line57> } <line58> } <line59> 	"<line40>              log.warn(""KaleoTaskFormInstancePersistenceImpl.fetchByKaleoTaskFormId(long, boolean) with""+ "" parameters (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
"public class A { <line0> protected void checkAnyPermission(String permissions[], String instanceId) { <line1> if (!isAnyPermitted(permissions, instanceId)) { <line2> throw new ForbiddenException(""Not authorized to access resource id <"" + instanceId + "">""); <line3> } <line4> } <line5> } <line6> "	"<line2>      LOG.info(""Not authorized to access resource id <{}>. User <{}> is missing permissions {} on""+ "" instance <{}>"",instanceId,getSubject().getPrincipal(),Arrays.toString(permissions),instanceId);"	task4	
"public class A { <line0> @Override <line1> public boolean isValid(final PropagationTask task, final ConstraintValidatorContext context) { <line2> boolean isValid; <line3> if (task == null) { <line4> isValid = true; <line5> } else { <line6> isValid = <line7> task.getOperation() != null <line8> && !task.getAttributes().isEmpty() <line9> && task.getResource() != null; <line10> if (isValid) { <line11> List<? extends TaskExec> executions = task.getExecs(); <line12> for (TaskExec execution : executions) { <line13> try { <line14> ExecStatus.valueOf(execution.getStatus()); <line15> } catch (IllegalArgumentException e) { <line16> isValid = false; <line17> } <line18> } <line19> } <line20> if (!isValid) { <line21> context.disableDefaultConstraintViolation(); <line22> context <line23> .buildConstraintViolationWithTemplate( <line24> getTemplate(EntityViolationType.InvalidPropagationTask, ""Invalid task"")) <line25> .addPropertyNode(task.getClass().getSimpleName()) <line26> .addConstraintViolation(); <line27> } <line28> } <line29> return isValid; <line30> } <line31> } <line32> "	"<line16>            LOG.error(""Invalid execution status '"" + execution.getStatus() + '\'', e);"	task4	
"public class A { <line0> private void createClickLogCondition(final SearchLogPager pager, final ClickLogCB cb) { <line1> if (StringUtil.isNotBlank(pager.queryId)) { <line2> cb.query().setQueryId_Term(pager.queryId); <line3> } <line4> if (StringUtil.isNotBlank(pager.userSessionId)) { <line5> cb.query().setUserSessionId_Term(pager.userSessionId); <line6> } <line7> if (StringUtil.isNotBlank(pager.requestedTimeRange)) { <line8> final String[] values = pager.requestedTimeRange.split("" - ""); <line9> final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(YYYY_MM_DD_HH_MM); <line10> try { <line11> if (values.length > 0) { <line12> cb.query().setRequestedAt_GreaterEqual(LocalDateTime.parse(values[0], formatter)); <line13> } <line14> if (values.length > 1) { <line15> cb.query().setRequestedAt_LessEqual(LocalDateTime.parse(values[1], formatter)); <line16> } <line17> } catch (final Exception e) { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	"<line19>          logger.debug(""Failed to parse {}"", pager.requestedTimeRange, e);"	task4	
"public class A { <line0> @Override <line1> public IUS getIUS(int swAccession) { <line2> try { <line3> return ll.findIUS(""/"" + swAccession); <line4> } catch (IOException | JAXBException ex) { <line5> } <line6> return null; <line7> } <line8> } <line9> "	<line5>      Log.error(ex);	task4	
public class A { <line0> public static int getCommerceWishListItemByContainsCProductCount( <line1> long commerceWishListId, long cProductId) throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceWishListItemServiceUtil.getCommerceWishListItemByContainsCProductCount( <line5> commerceWishListId, cProductId); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
public class A { <line0> private Object getResource(final ResourceId resourceId) { <line1> ManagedInterpreterGroup intpGroup = <line2> interpreterSettingManager.getInterpreterGroupById(resourceId.getResourcePoolId()); <line3> if (intpGroup == null) { <line4> return null; <line5> } <line6> RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess(); <line7> ByteBuffer buffer = <line8> remoteInterpreterProcess.callRemoteFunction( <line9> client -> <line10> client.resourceGet( <line11> resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName())); <line12> try { <line13> return Resource.deserializeObject(buffer); <line14> } catch (Exception e) { <line15> } <line16> return null; <line17> } <line18> } <line19> 	<line15>      LOGGER.error(e.getMessage(), e);	task4	
"public class A { <line0> @Override <line1> public CompletableFuture<Acknowledge> sendOperatorEventToTask( <line2> ExecutionAttemptID executionAttemptID, <line3> OperatorID operatorId, <line4> SerializedValue<OperatorEvent> evt) { <line5> final Task task = taskSlotTable.getTask(executionAttemptID); <line6> if (task == null) { <line7> return FutureUtils.completedExceptionally( <line8> new TaskNotRunningException( <line9> ""Task "" + executionAttemptID + "" not running on TaskManager"")); <line10> } <line11> try { <line12> task.deliverOperatorEvent(operatorId, evt); <line13> return CompletableFuture.completedFuture(Acknowledge.get()); <line14> } catch (Throwable t) { <line15> ExceptionUtils.rethrowIfFatalError(t); <line16> return FutureUtils.completedExceptionally(t); <line17> } <line18> } <line19> } <line20> "	"<line5>    log.debug(""Operator event for {} - {}"", executionAttemptID, operatorId);"	task4	
public class A { <line0> static Optional<ConfigSource> findFile(String name, String type) { <line1> Path path = Paths.get(name); <line2> if (Files.exists(path) && Files.isReadable(path) && !Files.isDirectory(path)) { <line3> return Optional.of(ConfigSources.file(path).build()); <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	"<line3>      LOGGER.info(""Found "" + type + "" file: "" + path.toAbsolutePath());"	task4	
public class A { <line0> @Override <line1> public boolean deleteModelFamily(Long modelFamilyID) throws PropertyNotSetException { <line2> ModelFamily modelFamily = getEntityManager().find(ModelFamily.class, modelFamilyID); <line3> if (modelFamily != null) { <line4> try { <line5> getEntityManager().remove(modelFamily); <line6> } catch (HibernateException he) { <line7> return false; <line8> } <line9> return true; <line10> } else { <line11> return false; <line12> } <line13> } <line14> } <line15> 	"<line7>        logger.error(""Hibernate exception on deleting ModelFamily using ID=""+ modelFamilyID+ he.getStackTrace());"	task4	
"public class A { <line0> @Test <line1> public void markers() { <line2> Logger log = LogManager.getLogger(Log4j2NativeApiTest.class); <line3> Marker m1 = MarkerManager.getMarker(""m1""); <line4> m1.addParents(MarkerManager.getMarker(""p1""), MarkerManager.getMarker(""p2"")); <line5> } <line6> } <line7> "	"<line5>    log.info(m1, ""markers - INFO"");"	task4	
"public class A { <line0> @Test <line1> @Retry(3) <line2> public void testCreatePipelineFull() throws IOException { <line3> byte[] content = ""stage('build') { echo 'yes' }"".getBytes(""UTF-8""); <line4> GHContentUpdateResponse updateResponse = <line5> helper.getGithubRepository().createContent(content, ""Jenkinsfile"", ""Jenkinsfile"", ""main""); <line6> helper <line7> .getGithubRepository() <line8> .createRef(""refs/heads/branch1"", updateResponse.getCommit().getSHA1()); <line9> helper.getGithubRepository().createContent(""hi there"", ""newfile"", ""newfile"", ""branch1""); <line10> creationPage.createPipeline( <line11> helper.getAccessToken(), <line12> helper.getOrganizationOrUsername(), <line13> helper.getActualRepositoryName()); <line14> } <line15> } <line16> "	"<line9>    logger.info(""Created master and branch1 branches in "" + helper.getGithubRepository().getFullName());"	task4	
"public class A { <line0> private List<OmObservation> querySeriesObservation(GetObservationRequest request, Session session) <line1> throws OwsExceptionReport, ConverterException { <line2> if (request.isSetResultFilter()) { <line3> throw new NotYetSupportedException(""result filtering""); <line4> } <line5> Locale requestedLocale = getRequestedLocale(request); <line6> String pdf = getProcedureDescriptionFormat(request.getResponseFormat()); <line7> final long start = System.currentTimeMillis(); <line8> List<String> features = request.getFeatureIdentifiers(); <line9> Collection<DataEntity<?>> seriesObservations = Lists.newArrayList(); <line10> AbstractSeriesDAO seriesDAO = daoFactory.getSeriesDAO(); <line11> for (IndeterminateValue sosIndeterminateTime : request.getFirstLatestTemporalFilter()) { <line12> for (DatasetEntity series : <line13> getSeries(seriesDAO, request, features, sosIndeterminateTime, session)) { <line14> if (sosIndeterminateTime.equals(ExtendedIndeterminateTime.FIRST)) { <line15> seriesObservations.add(series.getFirstObservation()); <line16> } else if (sosIndeterminateTime.equals(ExtendedIndeterminateTime.LATEST)) { <line17> seriesObservations.add(series.getLastObservation()); <line18> } <line19> } <line20> } <line21> final List<OmObservation> result = new LinkedList<>(); <line22> if (profileHandler.getActiveProfile().isShowMetadataOfEmptyObservations()) { <line23> Map<Long, DatasetEntity> seriesToCheckMap = Maps.newHashMap(); <line24> for (DatasetEntity series : seriesDAO.getSeries(request, features, session)) { <line25> seriesToCheckMap.put(series.getId(), series); <line26> } <line27> for (DataEntity<?> seriesObs : seriesObservations) { <line28> long seriesId = seriesObs.getDataset().getId(); <line29> if (seriesToCheckMap.containsKey(seriesId)) { <line30> seriesToCheckMap.remove(seriesId); <line31> } <line32> } <line33> for (DatasetEntity series : seriesToCheckMap.values()) { <line34> HibernateObservationUtilities.createSosObservationFromSeries( <line35> series, request, requestedLocale, pdf, observationCreatorContext, session) <line36> .forEachRemaining(result::add); <line37> } <line38> } <line39> toSosObservation( <line40> new ArrayList<>(seriesObservations), <line41> request, <line42> requestedLocale, <line43> pdf, <line44> observationCreatorContext, <line45> session) <line46> .forEachRemaining(result::add); <line47> return result; <line48> } <line49> } <line50> "	<line39>    LOGGER.debug(LOG_TIME_TO_QUERY, System.currentTimeMillis() - start);	task4	
"public class A { <line0> @RequiresPermissions(""environments:delete"") <line1> @Override <line2> public void deleteAll() { <line3> try { <line4> List<EnvironmentLogic> del = new ArrayList<>(environments); <line5> for (EnvironmentLogic el : del) { <line6> delete(el); <line7> } <line8> } catch (Exception e) { <line9> } finally { <line10> environments.clear(); <line11> } <line12> } <line13> } <line14> "	<line9>      LOG.error(Freedomotic.getStackTraceInfo(e));	task4	
public class A { <line0> private CommitLevel getCommitLevel(String commitLevel) { <line1> if (commitLevel == null) return CommitLevel.COMMIT_ALL; <line2> for (CommitLevel commitLevelEnum : CommitLevel.values()) { <line3> if (commitLevel.equalsIgnoreCase(commitLevelEnum.toString())) { <line4> return commitLevelEnum; <line5> } <line6> } <line7> return CommitLevel.COMMIT_ALL; <line8> } <line9> } <line10> 	"<line7>    LOG.warn(""Invalid commit level provided, using the default commit level."");"	task4	
"public class A { <line0> private void registerCustomCodeRunner(HelixManager manager) { <line1> try { <line2> if (manager.getInstanceName().equals(""localhost_12918"")) { <line3> Thread.sleep(2000); <line4> } <line5> HelixCustomCodeRunner customCodeRunner = new HelixCustomCodeRunner(manager, ZK_ADDR); <line6> customCodeRunner <line7> .invoke(_callback) <line8> .on(ChangeType.LIVE_INSTANCE) <line9> .usingLeaderStandbyModel(""TestParticLeader"") <line10> .start(); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> "	"<line12>      LOG.error(""Exception do pre-connect job"", e);"	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Shape""}, <line2> description = ""invalid column shape_dist_traveled"", <line3> priority = 242) <line4> public void verifyTest_2_7() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""shape_7"", GTFS_1_GTFS_Common_16, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""shapes.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(4), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	"<line5>    log.info(Color.GREEN + ""Shape_7 : invalid column shape_dist_traveled"" + Color.NORMAL);"	task4	
public class A { <line0> public static void testAutoSyncHibernateSessionStateOnTxCreation() throws RemoteException { <line1> try { <line2> PortalServiceUtil.testAutoSyncHibernateSessionStateOnTxCreation(); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	<line4>      log.error(exception, exception);	task4	
public class A { <line0> public void setEndTime(long end) { <line1> endTime = end; <line2> if (!START_TIMESTAMP) { <line3> timeStamp = endTime; <line4> } <line5> if (startTime == 0) { <line6> } else { <line7> elapsedTime = endTime - startTime - idleTime; <line8> } <line9> } <line10> } <line11> 	"<line6>      log.error(""setEndTime must be called after setStartTime"", new Throwable(INVALID_CALL_SEQUENCE_MSG));"	task4	
public class A { <line0> private Object parseArray(Object value, Schema schema) throws GoraException { <line1> if (value == null) { <line2> return null; <line3> } <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> Schema elementSchema = schema.getElementType(); <line7> JSONArray jsonArray = new JSONArray(String.valueOf(value)); <line8> List<Object> valueList = new ArrayList<>(); <line9> for (int i = 0; i < jsonArray.length(); i++) { <line10> valueList.add(parseSchema(elementSchema, jsonArray.get(i))); <line11> } <line12> return valueList; <line13> } <line14> } <line15> 	"<line5>      LOG.debug(""Parsing json array : {}"", value);"	task4	
public class A { <line0> @Override <line1> public void cmdExecute( <line2> final Message clientMessage, <line3> final ServerConnection serverConnection, <line4> final SecurityService securityService, <line5> long start) <line6> throws IOException { <line7> writeErrorResponse(clientMessage, MessageType.INVALID, serverConnection); <line8> } <line9> } <line10> 	"<line7>    logger.error(""{}: INVALID message type with tx: {} from {}"",new Object[] {serverConnection.getName(),Integer.valueOf(clientMessage.getTransactionId()),serverConnection.getSocketString()});"	task4	
public class A { <line0> public void closeHandles() { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> if (null != handle) { <line4> closeLedger(handle); <line5> handle = null; <line6> } <line7> if (null != readHandle) { <line8> closeLedger(readHandle); <line9> readHandle = null; <line10> } <line11> } <line12> } <line13> 	"<line2>      logger.debug(""Closing handles for LedgerRange: {}"", range);"	task4	
public class A { <line0> private WireRecord processRecord(WireRecord record) { <line1> final Map<String, TypedValue<?>> inputProperties = record.getProperties(); <line2> final Map<String, TypedValue<?>> outProperties = new HashMap<>(); <line3> if (this.options.shouldEmitReceivedProperties()) { <line4> outProperties.putAll(inputProperties); <line5> } <line6> for (GainOffsetEntry e : this.options.getEntries()) { <line7> final String propertyName = e.getPropertyName(); <line8> final TypedValue<?> typedValue = inputProperties.get(propertyName); <line9> if (typedValue == null) { <line10> continue; <line11> } <line12> final Object value = typedValue.getValue(); <line13> if (value == null || !(value instanceof Number)) { <line14> continue; <line15> } <line16> outProperties.put( <line17> propertyName, <line18> TypedValues.newDoubleValue(((Number) value).doubleValue() * e.getGain() + e.getOffset())); <line19> } <line20> return new WireRecord(outProperties); <line21> } <line22> } <line23> 	"<line14>        logger.warn(""Invalid property value: {}={}"", propertyName, typedValue);"	task4	
public class A { <line0> protected ProjectOverviewDTO getProjectOverview(UIContext uiContext) { <line1> StopWatch watch = new StopWatch(); <line2> ProjectOverviewDTO projectOverview = new ProjectOverviewDTO(); <line3> File rootFolder = getSelectionFolder(uiContext); <line4> if (rootFolder != null) { <line5> List<GetOverviewCommand.FileProcessor> processors = loadFileMatches(); <line6> scanProject(rootFolder, processors, projectOverview, 0, 3); <line7> } <line8> return projectOverview; <line9> } <line10> } <line11> 	"<line8>    log.info(""getProjectOverview took "" + watch.taken());"	task4	
"public class A { <line0> public Option<Request> apply(Tuple2<Session<Delivery>, Delivery> event) { <line1> queue.assertExecuting(); <line2> Session<Delivery> session = event._1(); <line3> final Delivery delivery = event._2(); <line4> session_manager.delivered(session, delivery.size()); <line5> SimpleAddress topic = delivery.sender().head().simple(); <line6> QoS qos = addresses.get(topic); <line7> if (qos == null) { <line8> qos = Scala2Java.<QoS>head(wildcards.get(topic.path())); <line9> } <line10> if (qos == null) { <line11> acked(delivery, Consumed$.MODULE$); <line12> return Scala2Java.none(); <line13> } else { <line14> PUBLISH publish = new PUBLISH(); <line15> publish.topicName( <line16> new UTF8Buffer(destination_parser.encode_destination(delivery.sender().head()))); <line17> if (delivery.redeliveries() > 0) { <line18> publish.dup(true); <line19> } <line20> if (delivery.message().codec() == RawMessageCodec$.MODULE$) { <line21> publish.payload(((RawMessage) delivery.message()).payload()); <line22> } else { <line23> if (publish_body) { <line24> try { <line25> publish.payload(delivery.message().getBodyAs(Buffer.class)); <line26> } catch (FilterException e) { <line27> } <line28> } else { <line29> publish.payload(delivery.message().encoded()); <line30> } <line31> } <line32> handler.messages_sent.incrementAndGet(); <line33> UnitFn1<DeliveryResult> ack = <line34> new UnitFn1<DeliveryResult>() { <line35> @Override <line36> public void call(DeliveryResult result) { <line37> acked(delivery, result); <line38> } <line39> }; <line40> if (delivery.ack() != null && (qos != QoS.AT_MOST_ONCE)) { <line41> publish.qos(qos); <line42> short id = to_message_id(clean_session ? get_next_seq_id() : delivery.seq()); <line43> publish.messageId(id); <line44> Request request = new Request(id, publish, ack); <line45> Request prev = in_flight_publishes.put(id, request); <line46> if (prev != null) { <line47> if (prev.message == null) { <line48> in_flight_publishes.remove(id); <line49> acked(delivery, Consumed$.MODULE$); <line50> } else { <line51> handler.async_die(""Client not acking regularly."", null); <line52> } <line53> } <line54> return Scala2Java.some(request); <line55> } else { <line56> publish.qos(QoS.AT_MOST_ONCE); <line57> return Scala2Java.some(new Request((short) 0, publish, ack)); <line58> } <line59> } <line60> } <line61> } <line62> "	"<line27>            log.error(e, ""Internal Server Error: Could not covert message body to a Buffer"");"	task4	
"public class A { <line0> private static List<URI> resolve( <line1> final String srvName, <line2> final String protocol, <line3> final String domain, <line4> final DnsSrvResolver resolver) { <line5> final String name; <line6> switch (protocol) { <line7> case ""https"": <line8> name = httpsSrv(srvName, domain); <line9> break; <line10> case ""http"": <line11> name = httpSrv(srvName, domain); <line12> break; <line13> default: <line14> throw new IllegalArgumentException( <line15> String.format( <line16> ""Invalid protocol: %s. Helios SRV record can only be https or http."", protocol)); <line17> } <line18> final List<LookupResult> lookupResults = resolver.resolve(name); <line19> final ImmutableList.Builder<URI> endpoints = ImmutableList.builder(); <line20> for (final LookupResult result : lookupResults) { <line21> endpoints.add(protocol(protocol, result.host(), result.port())); <line22> } <line23> final ImmutableList<URI> uris = endpoints.build(); <line24> return uris; <line25> } <line26> } <line27> "	"<line24>    log.info(""Resolved {} to {}"", name, uris);"	task4	
public class A { <line0> void stop(Duration timeout, Duration graceTimeoutForSubsequentOperations) { <line1> synchronized (startStopMutex) { <line2> state = ListenerState.STOPPING; <line3> try { <line4> if (scheduledTask != null) { <line5> CountdownTimer expiry = timeout.countdownTimer(); <line6> try { <line7> scheduledTask.cancel(false); <line8> waitForPendingComplete( <line9> expiry <line10> .getDurationRemaining() <line11> .lowerBound(Duration.ZERO) <line12> .add(graceTimeoutForSubsequentOperations), <line13> true); <line14> } catch (Exception e) { <line15> throw Exceptions.propagate(e); <line16> } <line17> scheduledTask.blockUntilEnded( <line18> expiry <line19> .getDurationRemaining() <line20> .lowerBound(Duration.ZERO) <line21> .add(graceTimeoutForSubsequentOperations)); <line22> scheduledTask.cancel(true); <line23> boolean reallyEnded = <line24> Tasks.blockUntilInternalTasksEnded( <line25> scheduledTask, <line26> expiry <line27> .getDurationRemaining() <line28> .lowerBound(Duration.ZERO) <line29> .add(graceTimeoutForSubsequentOperations)); <line30> if (!reallyEnded) { <line31> } <line32> scheduledTask = null; <line33> } <line34> synchronized (this) { <line35> deltaCollector = new DeltaCollector(); <line36> } <line37> } finally { <line38> state = ListenerState.STOPPED; <line39> } <line40> } <line41> } <line42> } <line43> 	"<line31>            LOG.warn(""Persistence tasks took too long to terminate, when stopping persistence, although""+ "" pending changes were persisted (ignoring): ""+ scheduledTask);"	task4	
public class A { <line0> private void extractCharset(MaximalBodyDescriptor descriptor) { <line1> try { <line2> Optional.ofNullable(descriptor.getCharset()) <line3> .map(Charset::forName) <line4> .ifPresent(currentlyBuildMimePart::charset); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOGGER.info(""Failed parsing charset"", e);"	task4	
public class A { <line0> public Contact getContact(RosterEntry r) { <line1> Contact contact = new Contact(); <line2> contact.name = r.getName(); <line3> contact.user = r.getUser(); <line4> contact.type = r.getType().toString(); <line5> Type presenceType = roster.getPresence(r.getUser()).getType(); <line6> if (presenceType != null) { <line7> contact.presence = presenceType.toString(); <line8> } <line9> ItemStatus status = r.getStatus(); <line10> if (status != null) { <line11> contact.status = status.toString(); <line12> } <line13> return contact; <line14> } <line15> } <line16> 	"<line13>    log.info(""getContact {}"", contact.toString());"	task4	
"public class A { <line0> @VisibleForTesting <line1> void auditAction( <line2> ArchiveOperation.Action action, <line3> List<String> affectedCompIds, <line4> User user, <line5> String containerComponentType) { <line6> String comment = <line7> String.format( <line8> ""All versions of this component were %s"", <line9> action == ArchiveOperation.Action.ARCHIVE ? ""archived"" : ""restored""); <line10> HashSet<String> auditDoneUUIDs = new HashSet<>(); <line11> for (String componentId : affectedCompIds) { <line12> Either<Component, StorageOperationStatus> result = <line13> toscaOperationFacade.getToscaElement(componentId, new ComponentParametersView()); <line14> if (result.isRight()) { <line15> continue; <line16> } <line17> if (auditDoneUUIDs.add(result.left().value().getUUID())) { <line18> AuditingActionEnum auditAction = <line19> action == ArchiveOperation.Action.ARCHIVE <line20> ? AuditingActionEnum.ARCHIVE_COMPONENT <line21> : AuditingActionEnum.RESTORE_COMPONENT; <line22> result <line23> .left() <line24> .foreachDoEffect( <line25> c -> { <line26> c.setVersion(null); <line27> componentUtils.auditComponentAdmin( <line28> componentUtils.getResponseFormat(ActionStatus.OK), <line29> user, <line30> c, <line31> auditAction, <line32> ComponentTypeEnum.findByParamName(containerComponentType), <line33> comment); <line34> }); <line35> } <line36> } <line37> } <line38> } <line39> "	"<line15>        log.error(EcompLoggerErrorCode.DATA_ERROR,null,""GetToscaElement"",result.right().value().name() + ""for component with id {}"",componentId);"	task4	
public class A { <line0> @Override <line1> public void persist(AlertModel alert) { <line2> boolean accepted = _alerts.offer(alert); <line3> if (!accepted) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.error(""Local alert buffer full!  Clearing!  Dropping "" + alert.getId() + "" record"");"	task4	
public class A { <line0> private static int translateCategory(CompilerMessageCategory category) { <line1> if (CompilerMessageCategory.ERROR.equals(category)) { <line2> return MessageCategory.ERROR; <line3> } <line4> if (CompilerMessageCategory.WARNING.equals(category)) { <line5> return MessageCategory.WARNING; <line6> } <line7> if (CompilerMessageCategory.STATISTICS.equals(category)) { <line8> return MessageCategory.STATISTICS; <line9> } <line10> if (CompilerMessageCategory.INFORMATION.equals(category)) { <line11> return MessageCategory.INFORMATION; <line12> } <line13> return 0; <line14> } <line15> } <line16> 	"<line13>    LOG.error(""Unknown message category: "" + category);"	task4	
public class A { <line0> @Override <line1> public void onPing(String ping) { <line2> } <line3> } <line4> 	"<line2>    log.info(""Server: {} - onPing ping={}"", server, ping);"	task4	
public class A { <line0> private static void ensureInjectorCreated(ModuleMaker moduleMaker, Configuration configuration) { <line1> if (injector == null) { <line2> for (LibLoader libLoader : ServiceLoaderUtil.load(LibLoader.class, configuration)) { <line3> libLoader.loadLibs(moduleMaker.getConfiguration()); <line4> } <line5> injector = Guice.createInjector(moduleMaker.createModule(), new ObjectMapperModule()); <line6> } <line7> } <line8> } <line9> 	"<line2>      LOGGER.info(""Loading libs..."");"	task4	
"public class A { <line0> public String run() throws IOException { <line1> Process process = new ProcessBuilder(mCommand).redirectErrorStream(true).start(); <line2> BufferedReader inReader = <line3> new BufferedReader( <line4> new InputStreamReader(process.getInputStream(), Charset.defaultCharset())); <line5> try { <line6> StringBuilder output = new StringBuilder(); <line7> String line = inReader.readLine(); <line8> while (line != null) { <line9> output.append(line); <line10> output.append(""\n""); <line11> line = inReader.readLine(); <line12> } <line13> int exitCode = process.waitFor(); <line14> if (exitCode != 0) { <line15> throw new ShellUtils.ExitCodeException(exitCode, output.toString()); <line16> } <line17> return output.toString(); <line18> } catch (InterruptedException e) { <line19> Thread.currentThread().interrupt(); <line20> throw new IOException(e); <line21> } finally { <line22> try { <line23> InputStream stdout = process.getInputStream(); <line24> synchronized (stdout) { <line25> inReader.close(); <line26> } <line27> } catch (IOException e) { <line28> } <line29> process.destroy(); <line30> } <line31> } <line32> } <line33> "	"<line28>        LOG.warn(String.format(""Error while closing the input stream of process %s: %s"", process, e.getMessage()));"	task4	
"public class A { <line0> @Test <line1> public void testAppend() throws Exception { <line2> context.addRoutes( <line3> new RouteBuilder() { <line4> @Override <line5> public void configure() throws Exception { <line6> from(""direct:start1"") <line7> .toF( <line8> ""hdfs://%s:%d/tmp/test/test-camel-simple-write-file1?append=true&fileSystemType=HDFS"", <line9> service.getHDFSHost(), service.getPort()); <line10> } <line11> }); <line12> startCamelContext(); <line13> for (int i = 0; i < 10; ++i) { <line14> template.sendBody(""direct:start1"", ""PIPPQ""); <line15> } <line16> Configuration conf = new Configuration(); <line17> String path = <line18> String.format( <line19> ""hdfs://%s:%d/tmp/test/test-camel-simple-write-file1"", <line20> service.getHDFSHost(), service.getPort()); <line21> Path file = new Path(path); <line22> FileSystem fs = FileSystem.get(file.toUri(), conf); <line23> FSDataInputStream in = fs.open(file); <line24> byte[] buffer = new byte[5]; <line25> int ret = 0; <line26> for (int i = 0; i < 20; ++i) { <line27> ret = in.read(buffer); <line28> } <line29> ret = in.read(buffer); <line30> assertEquals(-1, ret); <line31> in.close(); <line32> } <line33> } <line34> "	"<line28>      LOG.info(""> {}"", new String(buffer));"	task4	
"public class A { <line0> @POST <line1> @Consumes(""application/activemq.jms.queue+xml"") <line2> public Response createJmsQueue(@Context UriInfo uriInfo, Document document) { <line3> try { <line4> JMSQueueConfiguration queue = <line5> FileJMSConfiguration.parseQueueConfiguration(document.getDocumentElement()); <line6> ActiveMQQueue activeMQQueue = ActiveMQDestination.createQueue(queue.getName()); <line7> String queueName = activeMQQueue.getAddress(); <line8> ClientSession session = manager.getSessionFactory().createSession(false, false, false); <line9> try { <line10> ClientSession.QueueQuery query = session.queueQuery(new SimpleString(queueName)); <line11> if (!query.isExists()) { <line12> if (queue.getSelector() != null) { <line13> session.createQueue( <line14> new QueueConfiguration(queueName) <line15> .setFilterString(queue.getSelector()) <line16> .setDurable(queue.isDurable())); <line17> } else { <line18> session.createQueue(new QueueConfiguration(queueName).setDurable(queue.isDurable())); <line19> } <line20> } else { <line21> throw new WebApplicationException( <line22> Response.status(412).type(""text/plain"").entity(""Queue already exists."").build()); <line23> } <line24> } finally { <line25> try { <line26> session.close(); <line27> } catch (Exception ignored) { <line28> } <line29> } <line30> URI uri = uriInfo.getRequestUriBuilder().path(queueName).build(); <line31> return Response.created(uri).build(); <line32> } catch (Exception e) { <line33> if (e instanceof WebApplicationException) throw (WebApplicationException) e; <line34> throw new WebApplicationException( <line35> e, Response.serverError().type(""text/plain"").entity(""Failed to create queue."").build()); <line36> } <line37> } <line38> } <line39> "	"<line3>    ActiveMQRestLogger.LOGGER.debug(""Handling POST request for \"""" + uriInfo.getPath() + ""\"""");"	task4	
public class A { <line0> @Override <line1> public void warn(String string, Object o) { <line2> } <line3> } <line4> 	<line2>    logger.warn(string, o);	task4	
"public class A { <line0> @Override <line1> public Response toResponse(ContextInferrenceFailedException exception) { <line2> Object entity = Collections.EMPTY_LIST; <line3> if (headers.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XML_TYPE)) { <line4> entity = new EmptyResponse(); <line5> } <line6> return Response.status(Status.NOT_FOUND).entity(entity).header(""TotalCount"", 0).build(); <line7> } <line8> } <line9> "	"<line2>    LOG.warn(""Failed Context Inferrence"");"	task4	
"public class A { <line0> @Override <line1> public void initialize() { <line2> final DSMRDeviceConfiguration deviceConfig = getConfigAs(DSMRDeviceConfiguration.class); <line3> if (smartyMeter <line4> && (deviceConfig.decryptionKey == null || deviceConfig.decryptionKey.length() != 32)) { <line5> updateStatus( <line6> ThingStatus.OFFLINE, <line7> ThingStatusDetail.CONFIGURATION_ERROR, <line8> ""@text/error.configuration.invalidsmartykey""); <line9> return; <line10> } <line11> updateStatus(ThingStatus.UNKNOWN); <line12> receivedTimeoutNanos = TimeUnit.SECONDS.toNanos(deviceConfig.receivedTimeout); <line13> final DSMRDevice dsmrDevice = createDevice(deviceConfig); <line14> resetLastReceivedState(); <line15> this.dsmrDevice = dsmrDevice; <line16> dsmrDeviceRunnable = new DSMRDeviceRunnable(dsmrDevice, this); <line17> dsmrDeviceThread = new Thread(dsmrDeviceRunnable); <line18> dsmrDeviceThread.setName(""OH-binding-"" + getThing().getUID()); <line19> dsmrDeviceThread.setDaemon(true); <line20> dsmrDeviceThread.start(); <line21> watchdog = <line22> scheduler.scheduleWithFixedDelay( <line23> this::alive, receivedTimeoutNanos, receivedTimeoutNanos, TimeUnit.NANOSECONDS); <line24> } <line25> } <line26> "	"<line11>    logger.trace(""Using configuration {}"", deviceConfig);"	task4	
public class A { <line0> @Override <line1> public String convert(Object tuple) { <line2> if (tuple == null) { <line3> return null; <line4> } <line5> try { <line6> return objMapper.writeValueAsString(tuple); <line7> } catch (JsonProcessingException e) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line8>      logger.error(""Error while converting tuple {} {}"", tuple, e);"	task4	
public class A { <line0> private void appendAttrToBeIndexedLater(AttrImpl attr, NodePath path, LuceneIndexConfig conf) { <line1> if (currentElement == null) { <line2> } else { <line3> pendingAttrs.add(new PendingAttr(attr, path, conf)); <line4> } <line5> } <line6> } <line7> 	"<line2>      LOG.error(""currentElement == null"");"	task4	
public class A { <line0> protected String toJSON(Object answer) throws IOException { <line1> try { <line2> StringWriter writer = new StringWriter(); <line3> mapper.writeValue(writer, answer); <line4> return writer.toString(); <line5> } catch (IOException e) { <line6> throw new IOException(e.getMessage()); <line7> } <line8> } <line9> } <line10> 	"<line6>      LOG.warn(""Failed to marshal the events: "" + e, e);"	task4	
"public class A { <line0> private static final String getExtension(String filename, String mappingType, String MIMETYPE) <line1> throws Exception { <line2> String extension = """"; <line3> if (mappingType.equals(""never"")) { <line4> extension = """"; <line5> } else { <line6> if (mappingType.equals(""ifmissing"") && filename.contains(""."")) { <line7> extension = """"; <line8> } else { <line9> if (mappingType.equals(""ifmissing"") || mappingType.equals(""always"")) { <line10> extension = getExtension(MIMETYPE); <line11> if (extension.isEmpty()) extension = m_datastreamDefaultExtension; <line12> } else { <line13> extension = m_datastreamDefaultExtension; <line14> } <line15> } <line16> } <line17> return extension; <line18> } <line19> } <line20> "	"<line13>          logger.warn(""Unknown extension mapping type specified in fedora.fcfg"");"	task4	
public class A { <line0> public void process( <line1> ByteBuffer logsBatch, RemoteLogRecord reusableLog, IReplicationWorker worker) { <line2> while (logsBatch.hasRemaining()) { <line3> logsBatch.getInt(); <line4> reusableLog.readRemoteLog(logsBatch); <line5> reusableLog.setLogSource(LogSource.REMOTE); <line6> switch (reusableLog.getLogType()) { <line7> case LogType.UPDATE: <line8> case LogType.ENTITY_COMMIT: <line9> case LogType.FILTER: <line10> logManager.log(reusableLog); <line11> break; <line12> case LogType.JOB_COMMIT: <line13> case LogType.ABORT: <line14> RemoteLogRecord jobTerminationLog = new RemoteLogRecord(); <line15> TransactionUtil.formJobTerminateLogRecord( <line16> jobTerminationLog, <line17> reusableLog.getTxnId(), <line18> reusableLog.getLogType() == LogType.JOB_COMMIT); <line19> jobTerminationLog.setRequester(this); <line20> jobTerminationLog.setReplicationWorker(worker); <line21> jobTerminationLog.setLogSource(LogSource.REMOTE); <line22> logManager.log(jobTerminationLog); <line23> break; <line24> case LogType.FLUSH: <line25> RemoteLogRecord flushLog = new RemoteLogRecord(); <line26> TransactionUtil.formFlushLogRecord( <line27> flushLog, <line28> reusableLog.getDatasetId(), <line29> reusableLog.getResourcePartition(), <line30> reusableLog.getFlushingComponentMinId(), <line31> reusableLog.getFlushingComponentMaxId(), <line32> null); <line33> flushLog.setRequester(this); <line34> flushLog.setLogSource(LogSource.REMOTE); <line35> flushLog.setMasterLsn(reusableLog.getLSN()); <line36> logManager.log(flushLog); <line37> break; <line38> default: <line39> } <line40> } <line41> } <line42> } <line43> 	"<line39>          LOGGER.error(() -> ""Unsupported LogType: "" + reusableLog.getLogType());"	task4	
public class A { <line0> private void sendResponse(ServiceResponse<?> serviceResponse, HttpServletResponse httpResponse) { <line1> httpResponse.setStatus(serviceResponse.getCode()); <line2> serviceResponse <line3> .getHeaders() <line4> .entrySet() <line5> .forEach(x -> httpResponse.setHeader(x.getKey(), x.getValue())); <line6> try { <line7> if (serviceResponse.getCode() >= 200 <line8> && serviceResponse.getCode() < 300 <line9> && serviceResponse.getResultFormatted() != null <line10> && !serviceResponse.getResultFormatted().isEmpty()) { <line11> httpResponse.setContentType(serviceResponse.getContentType()); <line12> httpResponse.setCharacterEncoding(ENCODING); <line13> httpResponse.getWriter().write(serviceResponse.getResultFormatted()); <line14> } else if (serviceResponse.getMessage() != null && !serviceResponse.getMessage().isEmpty()) { <line15> httpResponse.getWriter().write(serviceResponse.getMessage()); <line16> } <line17> } catch (IOException ex) { <line18> httpResponse.setStatus(500); <line19> } <line20> } <line21> } <line22> 	"<line18>      LOGGER.error(""Error writing HTTP result"", ex);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> while (isLive.get()) { <line3> try { <line4> Thread.sleep(pulsePeriod); <line5> } catch (InterruptedException e) { <line6> break; <line7> } <line8> try { <line9> callback.onTick(System.currentTimeMillis()); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> } <line15> 	"<line11>        LOG.error(""Timer thread caught, ignored an exception"", e);"	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""nls"") <line2> public void listClientVersions( <line3> String organizationId, <line4> String clientId, <line5> int page, <line6> int pageSize, <line7> IAsyncResultHandler<List<String>> handler) { <line8> String query = <line9> ""{"" <line10> + ""  \""query\"": {"" <line11> + ""    \""bool\"": {"" <line12> + ""      \""filter\"": ["" <line13> + ""        {"" <line14> + ""          \""term\"": {"" <line15> + ""            \""organizationId\"": \""{{organizationId}}\"""" <line16> + ""          }"" <line17> + ""        },"" <line18> + ""        {"" <line19> + ""          \""term\"": {"" <line20> + ""            \""clientId\"": \""{{clientId}}\"""" <line21> + ""          }"" <line22> + ""        }"" <line23> + ""      ]"" <line24> + ""    }"" <line25> + ""  },"" <line26> + ""    \""aggs\"": {"" <line27> + ""      \""client_versions\"": {"" <line28> + ""        \""terms\"": {"" <line29> + ""          \""field\"": \""version\"""" <line30> + ""        }"" <line31> + ""      }"" <line32> + ""    }"" <line33> + ""}""; <line34> SearchTemplateRequest searchTemplateRequest = new SearchTemplateRequest(); <line35> searchTemplateRequest.setRequest( <line36> new SearchRequest(getIndexPrefix() + EsConstants.INDEX_CLIENTS)); <line37> searchTemplateRequest.setScriptType(ScriptType.INLINE); <line38> searchTemplateRequest.setScript(query); <line39> Map<String, Object> scriptParams = new HashMap<>(); <line40> scriptParams.put(""organizationId"", organizationId); <line41> scriptParams.put(""clientId"", clientId); <line42> searchTemplateRequest.setScriptParams(scriptParams); <line43> try { <line44> SearchTemplateResponse response = <line45> getClient().searchTemplate(searchTemplateRequest, RequestOptions.DEFAULT); <line46> SearchResponse searchResponse = response.getResponse(); <line47> List terms = <line48> ((ParsedTerms) searchResponse.getAggregations().asMap().get(""client_versions"")) <line49> .getBuckets(); <line50> List<String> results = <line51> (List<String>) <line52> terms.stream() <line53> .map(o -> ((ParsedTerms.ParsedBucket) o).getKey()) <line54> .collect(Collectors.toList()); <line55> handler.handle(AsyncResultImpl.create(results)); <line56> } catch (IOException e) { <line57> } <line58> } <line59> } <line60> "	<line57>      LOGGER.error(e.getMessage(), e);	task4	
public class A { <line0> public void writeMetadataValue(Locator locator, String metaKey, String metaValue) <line1> throws ConnectionException { <line2> Timer.Context ctx = <line3> Instrumentation.getWriteTimerContext(CassandraModel.CF_METRICS_METADATA_NAME); <line4> try { <line5> keyspace <line6> .prepareColumnMutation(CassandraModel.CF_METRICS_METADATA, locator, metaKey) <line7> .putValue(metaValue, StringMetadataSerializer.get(), null) <line8> .execute(); <line9> } catch (ConnectionException e) { <line10> Instrumentation.markWriteError(e); <line11> throw e; <line12> } finally { <line13> ctx.stop(); <line14> } <line15> } <line16> } <line17> 	"<line11>      log.error(""Error writing Metadata Value"", e);"	task4	
"public class A { <line0> @Override <line1> protected void doGet( <line2> HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) <line3> throws ServletException, IOException { <line4> RequestParams params = new RequestParams(httpServletRequest.getParameterMap()); <line5> try { <line6> String request = params.getMandatoryString(""request""); <line7> dispatchWmsRequest(request, params, httpServletRequest, httpServletResponse, catalogue); <line8> } catch (EdalException wmse) { <line9> boolean v130; <line10> try { <line11> v130 = ""1.3.0"".equals(params.getMandatoryWmsVersion()); <line12> } catch (EdalException e) { <line13> v130 = true; <line14> } <line15> handleWmsException(wmse, httpServletResponse, v130); <line16> } catch (SocketException se) { <line17> } catch (IOException ioe) { <line18> if (ioe.getClass().getName().equals(""org.apache.catalina.connector.ClientAbortException"")) { <line19> return; <line20> } <line21> throw ioe; <line22> } catch (Exception e) { <line23> e.printStackTrace(); <line24> throw new IOException(e); <line25> } <line26> } <line27> } <line28> "	"<line23>      log.error(""Problem with GET request"", e);"	task4	
public class A { <line0> @Override <line1> public SchemaIdVersion addSchemaVersion( <line2> SchemaMetadata schemaMetadata, SchemaVersion schemaVersion, boolean disableCanonicalCheck) <line3> throws InvalidSchemaException, IncompatibleSchemaException, SchemaNotFoundException, <line4> SchemaBranchNotFoundException { <line5> return schemaVersionLifecycleManager.addSchemaVersion( <line6> SchemaBranch.MASTER_BRANCH, <line7> schemaMetadata, <line8> schemaVersion, <line9> x -> registerSchemaMetadata(x), <line10> disableCanonicalCheck); <line11> } <line12> } <line13> 	"<line5>    LOG.info(""---------------1 addSchemaVersion {} {}"", schemaMetadata, schemaVersion);"	task4	
public class A { <line0> @Override <line1> public void onSuccess() { <line2> try { <line3> coordinator.declare(txId, request); <line4> } catch (Exception e) { <line5> request.onFailure(e); <line6> } <line7> } <line8> } <line9> 	"<line3>      LOG.info(""Attempting to declare TX:[{}]"", txId);"	task4	
"public class A { <line0> protected CsrfToken getCsrfTokenFromLoginHtml(String loginHtml) throws AuthenticationException { <line1> Pattern pattern = Pattern.compile(""CSRF_TOKEN = '(.*?)';""); <line2> Matcher matcher = pattern.matcher(loginHtml); <line3> if (matcher.find()) { <line4> String csrfTokenString = matcher.group(1); <line5> return new DefaultCsrfToken(CSRF_HEADER_NAME, CSRF_PARAM_NAME, csrfTokenString); <line6> } else { <line7> throw new SessionAuthenticationException(""Could not find CSRF_TOKEN variable on login page""); <line8> } <line9> } <line10> } <line11> "	"<line5>      logger.debug(""CSRF token from login html: {}"", csrfTokenString);"	task4	
public class A { <line0> private void connectionUnreachable(String webSocketServerUrl) { <line1> retryConnection(webSocketServerUrl); <line2> } <line3> } <line4> 	"<line1>    log.warn(""WebSocket server is unreachable. Possible VPN/Network issues, will retry in: ""+ reconnectDelay+ "" milliseconds."");"	task4	
public class A { <line0> public String getSuperQueryAlias(boolean includeQuotes) { <line1> if (_alias != null) { <line2> return _alias; <line3> } else if (_column != null) { <line4> final StringBuilder sb = new StringBuilder(); <line5> if (includeQuotes) { <line6> sb.append(_column.getQuotedName()); <line7> } else { <line8> sb.append(_column.getName()); <line9> } <line10> appendFunctionSql(sb); <line11> return sb.toString(); <line12> } else { <line13> return toStringNoAlias().toString(); <line14> } <line15> } <line16> } <line17> 	"<line13>      logger.debug(""Could not resolve a reasonable super-query alias for SelectItem: {}"", toSql());"	task4	
public class A { <line0> @Override <line1> public void resetExpectations() { <line2> activeThrottles = throttling.activeThrottlesFor(CryptoTransfer); <line3> if (activeThrottles.isEmpty()) { <line4> } <line5> ensureConfigUpToDate(); <line6> rebuildState(); <line7> } <line8> } <line9> 	"<line4>      log.warn(""CryptoTransfer has no throttle buckets, fee multiplier will remain at one!"");"	task4	
public class A { <line0> public LdapContextFactory getLdapContextFactory() { <line1> if (this.ldapContextFactory == null) { <line2> DefaultLdapContextFactory defaultFactory = new DefaultLdapContextFactory(); <line3> defaultFactory.setPrincipalSuffix(this.principalSuffix); <line4> defaultFactory.setSearchBase(this.searchBase); <line5> defaultFactory.setUrl(this.url); <line6> defaultFactory.setSystemUsername(this.systemUsername); <line7> defaultFactory.setSystemPassword(getSystemPassword()); <line8> this.ldapContextFactory = defaultFactory; <line9> } <line10> return this.ldapContextFactory; <line11> } <line12> } <line13> 	"<line2>      LOGGER.debug(""No LdapContextFactory specified - creating a default instance."");"	task4	
"public class A { <line0> private List<Testcase> parseTestCases(DriverTestsuite driverTestsuite) { <line1> List<Testcase> testcases = <line2> testsuiteXml.elements(new QName(""testcase"")).stream() <line3> .map( <line4> testcaseXml -> { <line5> Testcase testcase = <line6> new Testcase( <line7> driverTestsuite, <line8> extractText(testcaseXml, ""name""), <line9> parseDescription(testcaseXml), <line10> parseSteps(testcaseXml, driverTestsuite.driverTestsuiteConfiguration), <line11> synchronizer); <line12> if (testcaseXml instanceof LocationAwareElement) { <line13> testcase.setLocation(((LocationAwareElement) testcaseXml).getLocation()); <line14> } <line15> return testcase; <line16> }) <line17> .collect(Collectors.toList()); <line18> return testcases; <line19> } <line20> } <line21> "	"<line18>    LOGGER.info(""Found {} testcases."", testcases.size());"	task4	
public class A { <line0> @Override <line1> public void onAuthenticationSuccess( <line2> HttpServletRequest request, HttpServletResponse response, Authentication authentication) <line3> throws IOException, ServletException { <line4> String userId = authentication.getName(); <line5> Cookie newCookie = basicLoginService.createNewCookie(userId); <line6> response.addCookie(newCookie); <line7> response.setStatus(HttpStatus.OK.value()); <line8> response.setContentType(MediaType.APPLICATION_JSON_VALUE); <line9> response.sendRedirect(BasicLoginConstants.URI_MAIN); <line10> return; <line11> } <line12> } <line13> 	"<line4>    logger.debug(""onAuthenticationSuccess() started"");"	task4	
"public class A { <line0> @Override <line1> public void processMessage(Chat chat, Message message) { <line2> try { <line3> String uname[] = chat.getParticipant().split(""/""); <line4> if (conn.getRoster().getEntry(uname[0]) != null) { <line5> chat.sendMessage(msg.manageMessage(message.getBody())); <line6> } else { <line7> chat.sendMessage(manageSubscription(chat, message)); <line8> } <line9> } catch (Exception ex) { <line10> LOG.log(Level.SEVERE, null, ex); <line11> } <line12> } <line13> } <line14> "	<line3>      LOG.info(chat.getParticipant());	task4	
"public class A { <line0> @Test <line1> public void testFilterClassifierApp() throws FileNotFoundException, IOException { <line2> Logger logger = LoggerFactory.getLogger(FilterClassifierAppTest.class); <line3> LocalMode lm = LocalMode.newInstance(); <line4> Configuration conf = new Configuration(); <line5> InputStream is = new FileInputStream(""src/site/conf/dt-site-testbench.xml""); <line6> conf.addResource(is); <line7> conf.get(""dt.application.FilterClassifier.operator.hmapOper.keys""); <line8> conf.get(""dt.application.FilterClassifier.operator.hmapOper.numKeys""); <line9> try { <line10> lm.prepareDAG(new FilterClassifierApp(), conf); <line11> LocalMode.Controller lc = lm.getController(); <line12> lc.run(20000); <line13> } catch (Exception ex) { <line14> } <line15> is.close(); <line16> } <line17> } <line18> "	<line14>      logger.info(ex.getMessage());	task4	
"public class A { <line0> public static com.liferay.knowledge.base.model.KBArticle fetchKBArticleByUrlTitle( <line1> HttpPrincipal httpPrincipal, long groupId, long kbFolderId, String urlTitle) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KBArticleServiceUtil.class, <line7> ""fetchKBArticleByUrlTitle"", <line8> _fetchKBArticleByUrlTitleParameterTypes8); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, kbFolderId, urlTitle); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.knowledge.base.model.KBArticle) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> public void exportFileVersion() { <line1> File file = null; <line2> String cookePrefix = Constants.RESPONSE_MONITOR_COOKIE; <line3> String cookieName = cookePrefix + ""_"" + WebStudioUtils.getRequestParameter(cookePrefix); <line4> try { <line5> UserWorkspace userWorkspace = getUserWorkspace(); <line6> RulesProject selectedProject = <line7> userWorkspace.getProject(repositoryId, currentProjectName, false); <line8> AProjectResource projectResource; <line9> if (version == null <line10> || version.equals(VIEWING_VERSION) <line11> || version.equals(IN_EDITING_VERSION)) { <line12> AProjectArtefact artefact = selectedProject.getArtefact(getArtifactName()); <line13> projectResource = (AProjectResource) artefact; <line14> } else { <line15> Repository repository = selectedProject.getDesignRepository(); <line16> String branch = <line17> repository.supports().branches() ? ((BranchRepository) repository).getBranch() : null; <line18> AProject forExport = <line19> userWorkspace <line20> .getDesignTimeRepository() <line21> .getProjectByPath( <line22> repository.getId(), branch, selectedProject.getRealPath(), version); <line23> projectResource = (AProjectResource) forExport.getArtefact(getArtifactName()); <line24> } <line25> file = File.createTempFile(""export-"", ""-file""); <line26> IOUtils.copyAndClose(projectResource.getContent(), new FileOutputStream(file)); <line27> addCookie(cookieName, ""success"", -1); <line28> final FacesContext facesContext = FacesContext.getCurrentInstance(); <line29> HttpServletResponse response = <line30> (HttpServletResponse) WebStudioUtils.getExternalContext().getResponse(); <line31> ExportFile.writeOutContent(response, file, getFileName()); <line32> facesContext.responseComplete(); <line33> } catch (Exception e) { <line34> String msg = ""Failed to export file version. ""; <line35> addCookie(cookieName, msg + e.getMessage(), -1); <line36> } finally { <line37> FileUtils.deleteQuietly(file); <line38> } <line39> } <line40> } <line41> "	<line35>      LOG.error(msg, e);	task4	
public class A { <line0> @Override <line1> public HttpService addingService(ServiceReference<HttpService> serviceRef) { <line2> httpService = super.addingService(serviceRef); <line3> HttpContext httpContext = new CustomHttpContext(context.getBundle()); <line4> registerServlet(httpContext); <line5> registerResources(httpContext); <line6> return httpService; <line7> } <line8> } <line9> 	"<line2>    logger.info(""registering servlet"");"	task4	
public class A { <line0> private void addClientToPoolGently(HClient client) { <line1> try { <line2> availableClientQueue.add(client); <line3> } catch (IllegalStateException ise) { <line4> client.close(); <line5> } <line6> } <line7> } <line8> 	"<line4>      log.warn(""Capacity hit adding client back to queue. Closing extra"");"	task4	
"public class A { <line0> @Override <line1> public DataCell[] getCells(final DataRow row) { <line2> DataCell[] newcells = new DataCell[m_colindices.length]; <line3> for (int i = 0; i < newcells.length; i++) { <line4> DataCell dc = row.getCell(m_colindices[i]); <line5> if (!dc.isMissing()) { <line6> final String s = ((StringValue) dc).getStringValue(); <line7> if (s.trim().length() == 0) { <line8> newcells[i] = DataType.getMissingCell(); <line9> continue; <line10> } <line11> try { <line12> String corrected = s; <line13> if (m_thousandsSep != null && m_thousandsSep.length() > 0) { <line14> corrected = s.replaceAll(Pattern.quote(m_thousandsSep), """"); <line15> } <line16> if (!""."".equals(m_decimalSep)) { <line17> if (corrected.contains(""."")) { <line18> throw new NumberFormatException(""Invalid floating point number""); <line19> } <line20> if (m_decimalSep != null && m_decimalSep.length() > 0) { <line21> corrected = corrected.replaceAll(Pattern.quote(m_decimalSep), "".""); <line22> } <line23> } <line24> if (!m_genericParse) { <line25> corrected = check(corrected); <line26> } <line27> if (m_type.equals(DoubleCell.TYPE)) { <line28> double parsedDouble = Double.parseDouble(corrected); <line29> newcells[i] = new DoubleCell(parsedDouble); <line30> } else if (m_type.equals(IntCell.TYPE)) { <line31> int parsedInteger = Integer.parseInt(corrected); <line32> newcells[i] = new IntCell(parsedInteger); <line33> } else if (m_type.equals(LongCell.TYPE)) { <line34> long parsedLong = Long.parseLong(corrected); <line35> newcells[i] = new LongCell(parsedLong); <line36> } else { <line37> m_error = ""No valid parse type.""; <line38> } <line39> } catch (NumberFormatException e) { <line40> if (m_parseErrorCount == 0) { <line41> m_error = <line42> ""'"" <line43> + s <line44> + ""' (RowKey: "" <line45> + row.getKey().toString() <line46> + "", Position: "" <line47> + m_colindices[i] <line48> + "")""; <line49> } <line50> m_parseErrorCount++; <line51> newcells[i] = DataType.getMissingCell(); <line52> } <line53> } else { <line54> newcells[i] = DataType.getMissingCell(); <line55> } <line56> } <line57> return newcells; <line58> } <line59> } <line60> "	<line49>            LOGGER.debug(e.getMessage());	task4	
"public class A { <line0> public void commitParticipant( <line1> final List<HmilyParticipant> hmilyParticipantList, final Long selfParticipantId) { <line2> if (CollectionUtils.isEmpty(hmilyParticipantList)) { <line3> return; <line4> } <line5> for (HmilyParticipant participant : hmilyParticipantList) { <line6> try { <line7> if (participant.getParticipantId().equals(selfParticipantId)) { <line8> HmilyTacLocalParticipantExecutor.confirm(participant); <line9> } else { <line10> HmilyReflector.executor(HmilyActionEnum.CONFIRMING, ExecutorTypeEnum.RPC, participant); <line11> } <line12> } catch (Throwable throwable) { <line13> throw new HmilyRuntimeException( <line14> "" hmilyParticipant execute confirm exception:"" + participant.toString()); <line15> } finally { <line16> HmilyContextHolder.remove(); <line17> } <line18> } <line19> } <line20> } <line21> "	"<line5>    log.debug(""TAC-participate-commit ::: {}"", hmilyParticipantList);"	task4	
public class A { <line0> protected Optional<Task<?>> findTaskOrSubTask( <line1> Iterable<? extends Task<?>> tasks, Predicate<? super Task<?>> matcher) { <line2> List<String> taskNames = Lists.newArrayList(); <line3> Optional<Task<?>> result = findTaskOrSubTaskImpl(tasks, matcher, taskNames); <line4> if (!result.isPresent() && log.isDebugEnabled()) { <line5> } <line6> return result; <line7> } <line8> } <line9> 	"<line5>      log.debug(""Task not found matching "" + matcher + ""; contender names were "" + taskNames);"	task4	
public class A { <line0> @Override <line1> public Set<String> getSPEntityNames() { <line2> Set<String> result = new HashSet<>(); <line3> for (ExtendedMetadataDelegate delegate : getAvailableProviders()) { <line4> try { <line5> String sp = getSpName(delegate); <line6> if (StringUtils.hasText(sp)) { <line7> result.add(sp); <line8> } <line9> } catch (MetadataProviderException e) { <line10> } <line11> } <line12> return result; <line13> } <line14> } <line15> 	"<line10>        log.error(""Unable to get IDP alias for:"" + delegate, e);"	task4	
public class A { <line0> void handleLoopException(Throwable t) { <line1> try { <line2> Thread.sleep(1000); <line3> } catch (InterruptedException e) { <line4> } <line5> } <line6> } <line7> 	"<line1>    logger.warn(""Unexpected exception in the selector loop."", t);"	task4	
public class A { <line0> private void deleteResource(IndexedRecord record) { <line1> assertNotNull(record); <line2> String id = (String) record.get(0); <line3> assertNotNull(id); <line4> properties.file.setValue(id); <line5> runtime.initialize(container, properties); <line6> runtime.runAtDriver(container); <line7> String fileId = <line8> (String) <line9> container.getComponentData( <line10> container.getCurrentComponentId(), <line11> getStudioName(GoogleDriveDeleteDefinition.RETURN_FILE_ID)); <line12> assertNotNull(fileId); <line13> } <line14> } <line15> 	"<line12>    LOG.debug(""[deleteResource] (record = [{}]). deletedId: {}"", new Object[] {record, fileId});"	task4	
"public class A { <line0> @Override <line1> public Alert findAlertByPrimaryKey(BigInteger id) { <line2> requireNotDisposed(); <line3> requireArgument(id != null && id.compareTo(ZERO) > 0, ""ID must be a positive non-zero value.""); <line4> EntityManager em = _emProvider.get(); <line5> em.getEntityManagerFactory().getCache().evictAll(); <line6> Alert result = Alert.findByPrimaryKey(em, id, Alert.class); <line7> return result; <line8> } <line9> } <line10> "	"<line7>    logger.debug(""Query for alert having id {} resulted in : {}"", id, result);"	task4	
public class A { <line0> public static KylinConfig createInstanceFromUri(String uri) { <line1> UriType uriType = decideUriType(uri); <line2> if (uriType == UriType.LOCAL_FOLDER) { <line3> KylinConfig config = new KylinConfig(); <line4> config.setMetadataUrl(uri); <line5> return config; <line6> } else if (uriType == UriType.PROPERTIES_FILE) { <line7> KylinConfig config; <line8> try { <line9> config = new KylinConfig(); <line10> InputStream is = new FileInputStream(uri); <line11> config.reloadKylinConfig(is); <line12> is.close(); <line13> } catch (IOException e) { <line14> throw new RuntimeException(e); <line15> } <line16> return config; <line17> } else { <line18> try { <line19> KylinConfig config = new KylinConfig(); <line20> RestClient client = new RestClient(uri); <line21> String propertyText = client.getKylinProperties(); <line22> InputStream is = IOUtils.toInputStream(propertyText); <line23> config.reloadKylinConfig(is); <line24> is.close(); <line25> return config; <line26> } catch (IOException e) { <line27> throw new RuntimeException(e); <line28> } <line29> } <line30> } <line31> } <line32> 	"<line2>    logger.info(""The URI "" + uri + "" is recognized as "" + uriType);"	task4	
public class A { <line0> @Override <line1> protected int calculateIndex( <line2> int index, int numPartitions, String tableName, int cutPointArrayLength) { <line3> if (SPLIT_TO_REDUCER_MAP.containsKey(tableName) <line4> && SPLIT_TO_REDUCER_MAP.get(tableName).containsKey(index)) { <line5> return SPLIT_TO_REDUCER_MAP.get(tableName).get(index); <line6> } else { <line7> int i = cutPointArrayLength; <line8> int reducer = numPartitions - 1; <line9> Map<Integer, Integer> tempSplitReducerMap = new HashMap<>(); <line10> tempSplitReducerMap.put(i, reducer); <line11> tempSplitReducerMap.put(-i - 1, reducer); <line12> i--; <line13> reducer--; <line14> while (i >= 0) { <line15> while (reducer >= 0) { <line16> tempSplitReducerMap.put(i, reducer); <line17> tempSplitReducerMap.put(-i - 1, reducer); <line18> i--; <line19> reducer--; <line20> if (i < 0) break; <line21> } <line22> reducer = numPartitions - 1; <line23> } <line24> SPLIT_TO_REDUCER_MAP.put(tableName, tempSplitReducerMap); <line25> if (SPLIT_TO_REDUCER_MAP.containsKey(tableName) <line26> && SPLIT_TO_REDUCER_MAP.get(tableName).containsKey(index)) { <line27> return SPLIT_TO_REDUCER_MAP.get(tableName).get(index); <line28> } <line29> return 0; <line30> } <line31> } <line32> } <line33> 	"<line29>      LOG.trace(""Index was not found after recomputing the reducer map"");"	task4	
public class A { <line0> @Override <line1> protected void onProfileProperty( <line2> String profileName, <line3> String propertyKey, <line4> String propertyValue, <line5> boolean isSupportedProperty, <line6> String line) { <line7> Map<String, String> properties = allProfileProperties.get(profileName); <line8> if (properties.containsKey(propertyKey)) { <line9> } <line10> properties.put(propertyKey, propertyValue); <line11> } <line12> } <line13> 	"<line9>      log.warn(""Duplicate property values for ["" + propertyKey + ""]."");"	task4	
"public class A { <line0> public List<IPage> searchPages() { <line1> List<IPage> result = null; <line2> try { <line3> List<String> allowedGroupCodes = this.getAllowedGroupCodes(); <line4> result = this.getPageManager().searchPages(this.getPageCodeToken(), allowedGroupCodes); <line5> } catch (Throwable t) { <line6> throw new RuntimeException(""Error on searching pages"", t); <line7> } <line8> return result; <line9> } <line10> } <line11> "	"<line6>      logger.error(""Error on searching pages"", t);"	task4	
public class A { <line0> @Override <line1> public boolean isAuthToEdit(UserDetails user, DataObject dataObject) throws ApsSystemException { <line2> if (null == dataObject) { <line3> return false; <line4> } else if (DataObject.STATUS_NEW.equals(dataObject.getStatus()) <line5> && null == dataObject.getMainGroup()) { <line6> return true; <line7> } <line8> String mainGroupName = dataObject.getMainGroup(); <line9> return this.isAuthToEdit(user, mainGroupName); <line10> } <line11> } <line12> 	"<line3>      logger.error(""Null content"");"	task4	
public class A { <line0> private void setApplicationName(String applicationName) { <line1> synchronized (this) { <line2> properties.put(APPLICATION_NAME, applicationName); <line3> } <line4> } <line5> } <line6> 	"<line3>      LOGGER.debug(""ApplicationName of filterFactory had been updated to {}"", applicationName);"	task4	
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrder updateCustomFields( <line1> HttpPrincipal httpPrincipal, <line2> long commerceOrderId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> CommerceOrderServiceUtil.class, <line9> ""updateCustomFields"", <line10> _updateCustomFieldsParameterTypes44); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, commerceOrderId, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.commerce.model.CommerceOrder) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public Optional<ExecutionRequestLabel> get(ExecutionRequestLabelKey executionRequestLabelKey) { <line2> try { <line3> String queryScriptLabel = <line4> ""select ID, REQUEST_ID, NAME, VALUE from "" <line5> + getMetadataRepository().getTableNameByLabel(""ExecutionRequestLabels"") <line6> + "" where ID = "" <line7> + SQLTools.getStringForSQL(executionRequestLabelKey.getId()) <line8> + "";""; <line9> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(queryScriptLabel, ""reader""); <line10> if (cachedRowSet.size() == 0) { <line11> return Optional.empty(); <line12> } else if (cachedRowSet.size() > 1) { <line13> } <line14> cachedRowSet.next(); <line15> return Optional.of( <line16> new ExecutionRequestLabel( <line17> executionRequestLabelKey, <line18> new ExecutionRequestKey(cachedRowSet.getString(""REQUEST_ID"")), <line19> cachedRowSet.getString(""NAME""), <line20> cachedRowSet.getString(""VALUE""))); <line21> } catch (SQLException e) { <line22> throw new RuntimeException(e); <line23> } <line24> } <line25> } <line26> "	"<line13>        log.info(MessageFormat.format(""Found multiple implementations for {0}. Returning first implementation"",executionRequestLabelKey.toString()));"	task4	
public class A { <line0> public Mono<PolicyRetrievalResult> retrievePoliciesCollector( <line1> EvaluationContext subscriptionScopedEvaluationContext) { <line2> if (!consistent) return Mono.just(new PolicyRetrievalResult().withInvalidState()); <line3> var documentsWithMatchingInformation = <line4> Flux.merge( <line5> documentsByName.values().stream() <line6> .map( <line7> document -> <line8> document <line9> .matches(subscriptionScopedEvaluationContext) <line10> .map(val -> Tuples.of(document, val))) <line11> .collect(Collectors.toList())); <line12> return documentsWithMatchingInformation.reduce( <line13> new PolicyRetrievalResult(), <line14> (policyRetrievalResult, documentWithMatchingInformation) -> { <line15> var match = documentWithMatchingInformation.getT2(); <line16> if (match.isError()) return policyRetrievalResult.withError(); <line17> if (!match.isBoolean()) { <line18> return policyRetrievalResult.withError(); <line19> } <line20> if (match.getBoolean()) <line21> return policyRetrievalResult.withMatch(documentWithMatchingInformation.getT1()); <line22> return policyRetrievalResult; <line23> }); <line24> } <line25> } <line26> 	"<line18>            log.error(""matching returned error. (Should never happen): {}"", match.getMessage());"	task4	
public class A { <line0> private void createNetModeTransaction() { <line1> final List<ByteString> argList = new ArrayList<>(); <line2> Lifecycle.InstallChaincodeArgs installChaincodeArgs = <line3> Lifecycle.InstallChaincodeArgs.newBuilder() <line4> .setChaincodeInstallPackage(ByteString.copyFrom(chaincodeBytes)) <line5> .build(); <line6> argList.add(ByteString.copyFromUtf8(action)); <line7> argList.add(ByteString.copyFrom(installChaincodeArgs.toByteArray())); <line8> args(argList); <line9> } <line10> } <line11> 	"<line1>    logger.debug(""createNetModeTransaction"");"	task4	
"public class A { <line0> @Pollable(expectedSubTaskNumber = 3, message = ""Importing file: {fileName}"") <line1> private void importFile( <line2> DropImporter dropImporter, <line3> DropExporter dropExporter, <line4> @MsgArg(name = ""fileName"", accessor = ""getName"") DropFile dropFile, <line5> TMTextUnitVariant.Status importStatus, <line6> @ParentTask PollableTask parentTask, <line7> @InjectCurrentTask PollableTask currentTask) <line8> throws DropImporterException, DropExporterException, ImportDropException { <line9> downloadDropFileContent(dropImporter, dropFile, currentTask); <line10> UpdateTMWithXLIFFResult updateReport = <line11> updateTMWithLocalizedXLIFF(dropFile, importStatus, currentTask); <line12> exportImportedFile( <line13> dropExporter, <line14> dropFile, <line15> updateReport.getXliffContent(), <line16> updateReport.getComment(), <line17> currentTask); <line18> } <line19> } <line20> "	"<line9>    logger.debug(""Import file: {}"", dropFile.getName());"	task4	
"public class A { <line0> static void abort(AppContext context, RepairSegment segment, JmxProxy jmxConnection) { <line1> postpone(context, segment, context.storage.getRepairUnit(segment.getRepairUnitId())); <line2> String metric = <line3> MetricRegistry.name( <line4> SegmentRunner.class, <line5> ""abort"", <line6> Optional.ofNullable(segment.getCoordinatorHost()).orElse(""null"").replace('.', '-')); <line7> context.metricRegistry.counter(metric).inc(); <line8> jmxConnection.cancelAllRepairs(); <line9> } <line10> } <line11> "	"<line2>    LOG.info(""Aborting repair on segment with id {} on coordinator {}"",segment.getId(),segment.getCoordinatorHost());"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> String protocol = url.getProtocol(); <line4> String path = url.getPath(); <line5> if (URL_PROTOCOL_FILE.equals(protocol)) { <line6> findClasses(classList, packageName, path, recursive); <line7> } else if (URL_PROTOCOL_JAR.equals(protocol)) { <line8> findClasses(classList, packageName, url, recursive); <line9> } <line10> } catch (Throwable t) { <line11> } <line12> latch.countDown(); <line13> } <line14> } <line15> 	<line11>      LOGGER.error(t.getMessage(), t);	task4	
public class A { <line0> public static com.liferay.segments.model.SegmentsExperimentRelSoap updateSegmentsExperimentRel( <line1> long segmentsExperimentRelId, double split) throws RemoteException { <line2> try { <line3> com.liferay.segments.model.SegmentsExperimentRel returnValue = <line4> SegmentsExperimentRelServiceUtil.updateSegmentsExperimentRel( <line5> segmentsExperimentRelId, split); <line6> return com.liferay.segments.model.SegmentsExperimentRelSoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
"public class A { <line0> @ProcessElement <line1> public void processElement( <line2> ProcessContext context, <line3> @StateId(""valueState"") ValueState<Integer> intValueState, <line4> @StateId(""bagState"") BagState<Integer> intBagState) { <line5> long value = Objects.requireNonNull(context.element().getValue()); <line6> if (value == 0L) { <line7> intValueState.write(42); <line8> intBagState.add(40); <line9> intBagState.add(1); <line10> intBagState.add(1); <line11> } else if (value >= 1) { <line12> oneShotLatch.countDown(); <line13> } <line14> } <line15> } <line16> "	"<line6>    LOG.debug(""value: {} timestamp: {}"", value, context.timestamp().getMillis());"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> assertFalse(running); <line4> running = true; <line5> try { <line6> doTestTransactional(this); <line7> } finally { <line8> running = false; <line9> } <line10> } catch (Throwable e) { <line11> addException(e); <line12> } <line13> } <line14> } <line15> 	"<line11>      log.error(""Test failed"", e);"	task4	
public class A { <line0> private List<Entitlement> filterByConsumers( <line1> Set<Consumer> consumers, List<Entitlement> entitlements) { <line2> Map<String, List<Entitlement>> entitlementsByConsumerUuid = groupByConsumerUuid(entitlements); <line3> List<Entitlement> filteredEntitlements = new ArrayList<>(consumers.size()); <line4> for (Consumer consumer : consumers) { <line5> if (entitlementsByConsumerUuid.containsKey(consumer.getUuid())) { <line6> final List<Entitlement> foundEntitlements = <line7> entitlementsByConsumerUuid.get(consumer.getUuid()); <line8> filteredEntitlements.addAll(foundEntitlements); <line9> } <line10> } <line11> return filteredEntitlements; <line12> } <line13> } <line14> 	"<line8>        log.debug(""Found {} entitlements for consumer: {}"", foundEntitlements.size(), consumer.getUuid());"	task4	
"public class A { <line0> private List<FloodlightOFAction> parseActions(JsonParser jp) <line1> throws JsonParseException, IOException { <line2> List<FloodlightOFAction> actions = new ArrayList<FloodlightOFAction>(); <line3> if (jp.getCurrentToken() != JsonToken.START_ARRAY) { <line4> throw new IOException(""Expected START_ARRAY and it was "" + jp.getCurrentToken()); <line5> } <line6> while (jp.nextToken() != JsonToken.END_ARRAY) { <line7> if (jp.getCurrentToken() != JsonToken.START_OBJECT) { <line8> throw new IOException(""Expected START_OBJECT and it was "" + jp.getCurrentToken()); <line9> } <line10> Map<String, String> actionMap = new HashMap<String, String>(); <line11> while (jp.nextToken() != JsonToken.END_OBJECT) { <line12> if (jp.getCurrentToken() != JsonToken.FIELD_NAME) { <line13> throw new IOException(""Expected FIELD_NAME and it was "" + jp.getCurrentToken()); <line14> } <line15> String fieldName = jp.getCurrentName(); <line16> jp.nextToken(); <line17> actionMap.put(fieldName.toLowerCase(), jp.getText()); <line18> } <line19> if (actionMap.get(""type"").equalsIgnoreCase(FloodlightOFAction.TYPE_OUTPUT.toLowerCase())) { <line20> FloodlightOFAction action = new FloodlightOFAction(); <line21> action.setType(FloodlightOFAction.TYPE_OUTPUT.toLowerCase()); <line22> action.setValue(actionMap.get(""port"")); <line23> actions.add(action); <line24> } else { <line25> } <line26> } <line27> return actions; <line28> } <line29> } <line30> "	"<line25>        log.info(""Property type unknown: "" + actionMap.get(""type""));"	task4	
"public class A { <line0> public static void info(final Object caller, final String message) { <line1> String id = <line2> (caller == null) <line3> ? Messages.getInstance().getString(""Logger.DEBUG_LOG_UNKNOWN"") <line4> : caller.getClass().getName(); <line5> if (Logger.logLevel <= ILogger.INFO) { <line6> } <line7> } <line8> } <line9> "	"<line6>      Logger.logger.info(Logger.MISC_LOG + id + "": "" + message);"	task4	
public class A { <line0> private static Collection<SpecParameter<?>> resolveParameters( <line1> Collection<? extends SpecParameter<?>> newParams, AbstractBrooklynObjectSpec<?, ?> spec) { <line2> Collection<? extends SpecParameter<?>> existingReferenceParams = spec.getParameters(); <line3> Map<String, SpecParameter<?>> existingToKeep = MutableMap.of(); <line4> if (existingReferenceParams != null) { <line5> for (SpecParameter<?> p : existingReferenceParams) { <line6> if (ConfigInheritances.isKeyReinheritable( <line7> p.getConfigKey(), InheritanceContext.TYPE_DEFINITION)) { <line8> existingToKeep.put(p.getConfigKey().getName(), p); <line9> } <line10> } <line11> } <line12> List<SpecParameter<?>> result = MutableList.<SpecParameter<?>>of(); <line13> if (newParams != null) { <line14> for (SpecParameter<?> p : newParams) { <line15> final SpecParameter<?> existingP = existingToKeep.get(p.getConfigKey().getName()); <line16> if (p instanceof SpecParameterIncludingDefinitionForInheritance) { <line17> p = <line18> ((SpecParameterIncludingDefinitionForInheritance<?>) p) <line19> .resolveWithAncestor(existingP); <line20> } else { <line21> } <line22> if (existingP != null) { <line23> existingToKeep.put(p.getConfigKey().getName(), p); <line24> } else { <line25> result.add(p); <line26> } <line27> } <line28> } <line29> result.addAll(existingToKeep.values()); <line30> return result; <line31> } <line32> } <line33> 	"<line21>          log.warn(""Found non-definitional spec parameter: "" + p + "" adding to "" + spec);"	task4	
public class A { <line0> public void shutdown() { <line1> if (!this.protocolConnector.isEmpty()) { <line2> for (Connector listener : this.protocolConnector.values()) { <line3> listener.shutdown(); <line4> } <line5> this.protocolConnector.clear(); <line6> this.sechmaMapping.clear(); <line7> } <line8> } <line9> } <line10> 	"<line1>    logger.info(""rsfNetManager, shutdownGracefully."");"	task4	
public class A { <line0> @Override <line1> public void draggedImage_movedTo(NSImage image, NSPoint point) { <line2> } <line3> } <line4> 	"<line2>    log.trace(""draggedImage_movedTo"");"	task4	
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command instanceof RefreshType) { <line3> lastRefresh = 0; <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.trace(""scheduled {} for refresh"", this.thing.getUID());"	task4	
public class A { <line0> public void startTimedScheduler() { <line1> Date startTime = DateTimeUtil.now().plusMinutes(START_DELAY_IN_MINUTES).toDate(); <line2> MotechEvent event = new MotechEvent(SUBJECT); <line3> RepeatingSchedulableJob job = <line4> new RepeatingSchedulableJob( <line5> event, startTime, null, REPEAT_INTERVAL_IN_MINUTES * MILLIS_PER_MINUTE); <line6> schedulerService.safeScheduleRepeatingJob(job); <line7> } <line8> } <line9> 	"<line1>    logger.info(""Scheduling report aggregator job..."");"	task4	
public class A { <line0> protected void handleRedirectToRegistrationForm( <line1> HttpServletRequest httpRequest, HttpServletResponse httpResponse, OAuthPrincipal principal) <line2> throws IOException { <line3> if (log.isTraceEnabled()) { <line4> } <line5> OAuthPrincipalProcessor principalProcessor = <line6> principal.getOauthProviderType().getOauthPrincipalProcessor(); <line7> User gateInUser = principalProcessor.convertToGateInUser(principal); <line8> authenticationRegistry.setAttributeOfClient( <line9> httpRequest, OAuthConstants.ATTRIBUTE_AUTHENTICATED_PORTAL_USER, gateInUser); <line10> String registrationRedirectUrl = getRegistrationRedirectURL(httpRequest); <line11> registrationRedirectUrl = httpResponse.encodeRedirectURL(registrationRedirectUrl); <line12> httpResponse.sendRedirect(registrationRedirectUrl); <line13> } <line14> } <line15> 	"<line4>      log.trace(""Not found portalUser with username ""+ principal.getUserName()+ "". Redirecting to registration form"");"	task4	
"public class A { <line0> private void flushInternal() { <line1> try { <line2> if (w != null && readyForCommit) { <line3> w.commit(); <line4> copy(index, FSDirectory.open(getIndexDirectory().toPath())); <line5> readyForCommit = false; <line6> reader = null; <line7> isInitialized = false; <line8> } <line9> } catch (Exception e) { <line10> throw new LuceneIndexingException(""Error while Flushing Lucene Indexes"", e); <line11> } <line12> } <line13> } <line14> "	"<line10>      log.error(""Error while Flushing Lucene Indexes, Caused by: "", e);"	task4	
public class A { <line0> @PostConstruct <line1> public void log() { <line2> if (logger.isDebugEnabled()) { <line3> AnnotationVisitor<Value> visitor = new AnnotationVisitor<>(Value.class); <line4> visitor.visit(this, new LoggingEvent(logger)); <line5> } <line6> } <line7> } <line8> 	"<line2>    logger.info(""{}"", this);"	task4	
public class A { <line0> private void configureXacmlPdp() { <line1> if (xacmlPdp == null) { <line2> try { <line3> xacmlPdp = new XacmlPdp(dirPath, parser, environmentAttributes, securityLogger); <line4> } catch (PdpException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        LOGGER.warn(""Unable to create XACML PDP."", e);"	task4	
public class A { <line0> @Override <line1> public void warning(final String msg) { <line2> } <line3> } <line4> 	<line2>    log.warn(msg);	task4	
public class A { <line0> @Override <line1> public void onError(final String reason) { <line2> PrometheusExporter.instance().increaseTotalPushRequestsFail(); <line3> pushMessageMetricsService.appendError(pushMessageInformation, variant, reason); <line4> } <line5> } <line6> 	"<line2>    logger.warn(""Error on '{}' delivery: {}"", variant.getType().getTypeName(), reason);"	task4	
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void testImageResize(Nd4jBackend backend) { <line3> for (ImageResizeMethod method : ImageResizeMethod.values()) { <line4> if (method == ImageResizeMethod.ResizeLanczos5 <line5> || method == ImageResizeMethod.ResizeArea <line6> || method == ImageResizeMethod.ResizeMitchelcubic) { <line7> continue; <line8> } <line9> Nd4j.getRandom().setSeed(12345); <line10> SameDiff sd = SameDiff.create(); <line11> boolean preserveAspectRatio = true; <line12> boolean antialias = true; <line13> SDVariable inputImage = sd.var(Nd4j.rand(DataType.FLOAT, 1, 5, 5, 3)); <line14> long[] expectedShape = new long[] {1, 3, 3, 3}; <line15> SDVariable requestedSize = sd.constant(Nd4j.createFromArray(new long[] {3, 3})); <line16> Function<INDArray, String> checkFunction = <line17> in -> { <line18> boolean shapeOk = Arrays.equals(expectedShape, in.shape()); <line19> if (shapeOk) return null; <line20> return ""Failed: shape differs - expected "" <line21> + Arrays.toString(expectedShape) <line22> + "" vs "" <line23> + Arrays.toString(in.shape()) <line24> + "" on method "" <line25> + method; <line26> }; <line27> SDVariable out = <line28> new ImageResize(sd, inputImage, requestedSize, preserveAspectRatio, antialias, method) <line29> .outputVariable() <line30> .std(true); <line31> String err = <line32> OpValidation.validate( <line33> new TestCase(sd).gradientCheck(false).expected(""image_resize"", checkFunction)); <line34> assertNull(err); <line35> } <line36> } <line37> } <line38> "	"<line9>      log.info(""Trying {}"", method);"	task4	
public class A { <line0> @Override <line1> public Number getAggregated() { <line2> if (currentValue == null) { <line3> return null; <line4> } <line5> Number result = currentValue - previousValue; <line6> return result; <line7> } <line8> } <line9> 	"<line6>    log.debug(""getAggregated() = {}"", result);"	task4	
"public class A { <line0> private void downloadEnsemblData(Path geneFolder) throws IOException, InterruptedException { <line1> List<String> downloadedUrls = new ArrayList<>(4); <line2> String ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease; <line3> if (!configuration.getSpecies().getVertebrates().contains(speciesConfiguration)) { <line4> ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease + ""/"" + getPhylo(speciesConfiguration); <line5> } <line6> String bacteriaCollectionPath = """"; <line7> if (configuration.getSpecies().getBacteria().contains(speciesConfiguration)) { <line8> bacteriaCollectionPath = <line9> speciesConfiguration.getAssemblies().get(0).getEnsemblCollection() + ""/""; <line10> } <line11> String version = ensemblRelease.split(""-"")[1]; <line12> String url = <line13> ensemblHost <line14> + ""/gtf/"" <line15> + bacteriaCollectionPath <line16> + speciesShortName <line17> + ""/*"" <line18> + version <line19> + "".gtf.gz""; <line20> String fileName = geneFolder.resolve(speciesShortName + "".gtf.gz"").toString(); <line21> downloadFile(url, fileName); <line22> downloadedUrls.add(url); <line23> url = <line24> ensemblHost <line25> + ""/fasta/"" <line26> + bacteriaCollectionPath <line27> + speciesShortName <line28> + ""/pep/*.pep.all.fa.gz""; <line29> fileName = geneFolder.resolve(speciesShortName + "".pep.all.fa.gz"").toString(); <line30> downloadFile(url, fileName); <line31> downloadedUrls.add(url); <line32> url = <line33> ensemblHost <line34> + ""/fasta/"" <line35> + bacteriaCollectionPath <line36> + speciesShortName <line37> + ""/cdna/*.cdna.all.fa.gz""; <line38> fileName = geneFolder.resolve(speciesShortName + "".cdna.all.fa.gz"").toString(); <line39> downloadFile(url, fileName); <line40> downloadedUrls.add(url); <line41> saveVersionData( <line42> EtlCommons.GENE_DATA, <line43> ENSEMBL_NAME, <line44> ensemblVersion, <line45> getTimeStamp(), <line46> downloadedUrls, <line47> buildFolder.resolve(""ensemblCoreVersion.json"")); <line48> } <line49> } <line50> "	"<line1>    logger.info(""Downloading gene Ensembl data (gtf, pep, cdna, motifs) ..."");"	task4	
public class A { <line0> @Override <line1> protected void shutDown() throws Exception { <line2> shuttingDown = true; <line3> offsetFlusherFuture.cancel(false); <line4> logRetentionFuture.cancel(false); <line5> checkpointFlusherFuture.cancel(false); <line6> dirtyLogFlushFuture.cancel(false); <line7> kafkaScheduler.shutdown(); <line8> logManager.shutdown(); <line9> offsetFlusher.run(); <line10> teardownLogMetrics(); <line11> } <line12> } <line13> 	"<line2>    LOG.debug(""Shutting down journal!"");"	task4	
public class A { <line0> @Test <line1> void testWithoutFields() throws Exception { <line2> Logger logger = lc.getLogger(getClass()); <line3> assertThat(GelfTestSender.getMessages()).hasSize(1); <line4> GelfMessage gelfMessage = GelfTestSender.getMessages().get(0); <line5> String myMdc = gelfMessage.getField(MDC_MY_MDC); <line6> assertThat(myMdc).isNull(); <line7> } <line8> } <line9> 	<line3>    logger.info(LOG_MESSAGE);	task4	
public class A { <line0> @Override <line1> public void handleStateChanged(final Watcher.Event.KeeperState keeperState) { <line2> if (Watcher.Event.KeeperState.SyncConnected.equals(keeperState)) { <line3> nodeDataMap.forEach( <line4> (k, v) -> { <line5> if (!zkClient.exists(k)) { <line6> zkClient.createEphemeral(k, v); <line7> } <line8> }); <line9> } <line10> } <line11> } <line12> 	"<line7>              log.info(""zookeeper client register success: {}"", v);"	task4	
"public class A { <line0> protected void printOperationInfo(Logger logger) { <line1> StringBuilder strb = new StringBuilder(35); <line2> strb.append(""["") <line3> .append(dateFormat.format(new Date(getPreExecutionTime()))) <line4> .append("" - "") <line5> .append(dateFormat.format(new Date(getPostExecutionTime()))) <line6> .append("" ("") <line7> .append(getPostExecutionTime() - getPreExecutionTime()) <line8> .append(""ms)]""); <line9> strb.append("" "").append(getOperation().getClass().getSimpleName()).append("" ""); <line10> if (getExecutionId() != null) { <line11> strb.append(""with execution "").append(getExecutionId()); <line12> if (getFlowElementId() != null) { <line13> strb.append("" at flow element "") <line14> .append(getFlowElementId()) <line15> .append("" ("") <line16> .append(getFlowElementClass().getSimpleName()) <line17> .append("")""); <line18> } <line19> } <line20> } <line21> } <line22> "	<line20>    logger.info(strb.toString());	task4	
public class A { <line0> @Override <line1> public Boolean run(final Session<?> session) throws BackgroundException { <line2> final DistributionConfiguration feature = session.getFeature(DistributionConfiguration.class); <line3> if (log.isDebugEnabled()) { <line4> } <line5> final PathContainerService container = session.getFeature(PathContainerService.class); <line6> for (Path file : this.getContainers(container, files)) { <line7> if (this.isCanceled()) { <line8> throw new ConnectionCanceledException(); <line9> } <line10> write(feature, file); <line11> } <line12> return true; <line13> } <line14> } <line15> 	"<line4>      log.debug(String.format(""Run with feature %s"", feature));"	task4	
public class A { <line0> @Override <line1> public void manageTransitions(Coordinator coordinator, RingGroup ringGroup) throws IOException { <line2> DomainGroup domainGroup = ringGroup.getDomainGroup(); <line3> if (domainGroup == null) { <line4> return; <line5> } <line6> Map<Domain, Map<Integer, Set<Host>>> domainToPartitionToHostsFullyServing = <line7> PartitionUtils.domainToPartitionToHostsServing(ringGroup, status); <line8> ThreeNestedMap<Domain, Integer, String, Long> domainPartitionBucketHostCounts = <line9> PartitionUtils.domainToPartitionToHostsServingInBucket( <line10> domainToPartitionToHostsFullyServing, status); <line11> SortedSet<Ring> rings = ringGroup.getRingsSorted(); <line12> int ringCount = rings.size(); <line13> for (Ring ring : rings) { <line14> partitionAssigner.prepare( <line15> ring, domainGroup.getDomainVersions(), ringGroup.getRingGroupConductorMode()); <line16> for (Host host : ring.getHostsSorted()) { <line17> manageTransitions( <line18> ringCount, <line19> host, <line20> domainGroup, <line21> domainToPartitionToHostsFullyServing, <line22> domainPartitionBucketHostCounts); <line23> } <line24> } <line25> } <line26> } <line27> 	"<line4>      LOG.info(""Domain group not found. Nothing to do."");"	task4	
"public class A { <line0> public static String getDepartment(User user) { <line1> String department = """"; <line2> try { <line3> List<Organization> organizations = user.getOrganizations(); <line4> if (!organizations.isEmpty()) { <line5> Organization organization = organizations.get(0); <line6> department = organization.getName(); <line7> } <line8> } catch (PortalException | SystemException e) { <line9> } <line10> return department; <line11> } <line12> } <line13> "	"<line9>      log.error(""Error getting department"", e);"	task4	
public class A { <line0> private void loadExtensions() { <line1> for (InstalledExtension localExtension : this.installedRepository.getInstalledExtensions()) { <line2> if (XarExtensionHandler.TYPE.equalsIgnoreCase(localExtension.getType())) { <line3> try { <line4> XarInstalledExtension xarInstalledExtension = addCacheXarExtension(localExtension); <line5> if (xarInstalledExtension.getNamespaces() == null) { <line6> pagesUpdated(xarInstalledExtension, null, true); <line7> } else { <line8> for (String namespace : localExtension.getNamespaces()) { <line9> pagesUpdated(xarInstalledExtension, namespace, true); <line10> } <line11> } <line12> } catch (Exception e) { <line13> continue; <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	"<line13>          this.logger.error(""Failed to parse extension [{}]"", localExtension.getId(), e);"	task4	
public class A { <line0> protected void setConnectStrategy( <line1> Strategy connectStrategy, int preparedConnectionCount, int maxConnectionCount) { <line2> this.connectStrategy = <line3> ProxyConnectStrategy.newInstance( <line4> connectStrategy, preparedConnectionCount, maxConnectionCount); <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOGGER.debug(""Proxy handler "" + this + "": connect.strategy="" + connectStrategy + ""."");"	task4	
"public class A { <line0> @Override <line1> public UserGroup findByC_N(long companyId, String name) throws NoSuchUserGroupException { <line2> UserGroup userGroup = fetchByC_N(companyId, name); <line3> if (userGroup == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""companyId=""); <line7> sb.append(companyId); <line8> sb.append("", name=""); <line9> sb.append(name); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchUserGroupException(sb.toString()); <line14> } <line15> return userGroup; <line16> } <line17> } <line18> "	<line12>        log.debug(sb.toString());	task4	
public class A { <line0> public boolean finalizeUpdate() { <line1> if (newCigar == null) return false; <line2> if (newStart == -1) newStart = read.getAlignmentStart(); <line3> else if (Math.abs(newStart - read.getAlignmentStart()) > MAX_POS_MOVE_ALLOWED) { <line4> return false; <line5> } <line6> final Cigar oldCigar = read.getCigar(); <line7> final int oldStart = read.getAlignmentStart(); <line8> read.setCigar(newCigar); <line9> read.setAlignmentStart(newStart); <line10> if (realignmentProducesBadAlignment(read)) { <line11> read.setCigar(oldCigar); <line12> read.setAlignmentStart(oldStart); <line13> return false; <line14> } <line15> if (!NO_ORIGINAL_ALIGNMENT_TAGS) { <line16> read.setAttribute(ORIGINAL_CIGAR_TAG, oldCigar.toString()); <line17> if (newStart != oldStart) read.setAttribute(ORIGINAL_POSITION_TAG, oldStart); <line18> } <line19> return true; <line20> } <line21> } <line22> 	"<line4>      logger.debug(String.format(""Attempting to realign read %s at %d more than %d bases to %d."",read.getReadName(), read.getAlignmentStart(), MAX_POS_MOVE_ALLOWED, newStart));"	task4	
"public class A { <line0> public void write(String bucketName, String objectName, String payload) { <line1> byte[] raw = payload.getBytes(StandardCharsets.UTF_8); <line2> ObjectMetadata omd = new ObjectMetadata(); <line3> omd.setContentLength(raw.length); <line4> omd.setContentEncoding(""application/json""); <line5> if (DEBUG) { <line6> try (FileOutputStream fos = new FileOutputStream(objectName)) { <line7> fos.write(raw); <line8> fos.flush(); <line9> } catch (IOException x) { <line10> logger.log(Level.SEVERE, ""Writing "" + objectName, x); <line11> } <line12> } else { <line13> InputStream inputStream = new ByteArrayInputStream(raw); <line14> PutObjectResult result = <line15> client.putObject(new PutObjectRequest(bucketName, objectName, inputStream, omd)); <line16> if (result != null) { <line17> if (logger.isLoggable(Level.FINE)) { <line18> logger.fine(""Wrote ["" + bucketName + ""]/"" + objectName + "", ETag: "" + result.getETag()); <line19> } <line20> } else { <line21> logger.warning( <line22> ""Writing failed for ["" + bucketName + ""]/"" + objectName + "", bytes: "" + raw.length); <line23> throw new RuntimeException(""Write to COS failed""); <line24> } <line25> } <line26> } <line27> } <line28> "	"<line5>    logger.info(""Writing to COS '"" + bucketName + "":"" + objectName + ""', bytes: "" + raw.length);"	task4	
public class A { <line0> @Override <line1> public synchronized V put(K key, V value) { <line2> clearGCCollected(); <line3> map.put(key, new SoftValue<K, V>(value, key, queue)); <line4> return value; <line5> } <line6> } <line7> 	"<line3>    logger.debug(""Putting {} on cache. size: {}"", key, size());"	task4	
"public class A { <line0> public static DeviceManagementProviderService getDeviceManagementService() { <line1> PrivilegedCarbonContext ctx = PrivilegedCarbonContext.getThreadLocalCarbonContext(); <line2> DeviceManagementProviderService deviceManagementProviderService = <line3> (DeviceManagementProviderService) <line4> ctx.getOSGiService(DeviceManagementProviderService.class, null); <line5> if (deviceManagementProviderService == null) { <line6> String msg = ""Device Management service has not initialized.""; <line7> throw new IllegalStateException(msg); <line8> } <line9> return deviceManagementProviderService; <line10> } <line11> } <line12> "	<line7>      log.error(msg);	task4	
"public class A { <line0> @PatchMapping(value = CommonConstants.PATH_ID) <line1> @ApiOperation(value = ""Update partially provider"") <line2> @ResponseStatus(HttpStatus.OK) <line3> public IdentityProviderDto patchProvider( <line4> final @RequestBody Map<String, Object> provider, final @PathVariable String id) { <line5> ParameterChecker.checkParameter(""Parameters are mandatory : "", provider, id); <line6> return service.patch(buildUiHttpContext(), provider, null, null, id, ProviderPatchType.JSON); <line7> } <line8> } <line9> "	"<line5>    LOGGER.debug(""Update partially provider id={} with partialDto={}"", id, provider);"	task4	
public class A { <line0> @Override <line1> public String createSubscription(Subscription subscription) throws InvalidSubscriptionException { <line2> String uuid = UUID.randomUUID().toString(); <line3> try { <line4> createSubscription(subscription, uuid); <line5> } catch (SubscriptionExistsException e) { <line6> throw new InvalidSubscriptionException(e); <line7> } <line8> return uuid; <line9> } <line10> } <line11> 	"<line6>      LOGGER.debug(""UUID matched previously registered subscription."", e);"	task4	
public class A { <line0> public void collectNaive(final double... x) { <line1> double xj, yk, w = 1; <line2> if (x.length == dim + 1) { <line3> w = x[dim]; <line4> } <line5> if (w <= 0) { <line6> return; <line7> } <line8> entries++; <line9> sumW += w; <line10> for (int j = 0; j < dim; j++) { <line11> xj = x[j]; <line12> sumX[j] += w * xj; <line13> minX[j] = min(minX[j], xj); <line14> maxX[j] = max(maxX[j], xj); <line15> for (int k = 0; k < dim; k++) { <line16> yk = x[k]; <line17> sumXY[j][k] += w * xj * yk; <line18> } <line19> means[j] = sumX[j] / sumW; <line20> } <line21> for (int j = 0; j < dim; j++) { <line22> for (int k = 0; k <= j; k++) { <line23> covar[j][k] = sumXY[j][k] / sumW - means[j] * means[k]; <line24> covar[k][j] = covar[j][k]; <line25> } <line26> } <line27> } <line28> } <line29> 	<line6>      logger.error(String.format(NEGATIV_WEIGHT, w));	task4	
"public class A { <line0> public static String getTypeString(Object o) { <line1> String typeValue = null; <line2> try { <line3> Field[] fields = o.getClass().getDeclaredFields(); <line4> for (int i = 0; i < fields.length && typeValue == null; i++) { <line5> Field field = fields[i]; <line6> if (field.getName().equals(""type"")) { <line7> try { <line8> String methodName = <line9> ""get"" <line10> + Character.toUpperCase(field.getName().charAt(0)) <line11> + field.getName().substring(1); <line12> typeValue = <line13> (String) <line14> o.getClass().getMethod(methodName, (Class[]) null).invoke(o, new Object[] {}); <line15> } catch (NoSuchMethodException e) { <line16> typeValue = (String) field.get(o); <line17> } <line18> } <line19> } <line20> } catch (Exception e) { <line21> } <line22> if (typeValue == null) { <line23> typeValue = """"; <line24> } <line25> return typeValue; <line26> } <line27> } <line28> "	<line21>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> public String getApiKey() { <line1> return readyElement(apiKeyLabel).getAttribute(""value""); <line2> } <line3> } <line4> "	"<line1>    log.info(""Query API Key"");"	task4	
"public class A { <line0> public void handleTimerEvent(ActionEvent e) { <line1> if (myPayload.getTimeBudget().isExpired()) { <line2> StringBuilder error = new StringBuilder(150); <line3> error.append(""Timed out waiting for ""); <line4> int numServicesWaiting = 0; <line5> if (myWmsWaiting) { <line6> numServicesWaiting++; <line7> error.append(""WMS ""); <line8> } <line9> if (myWfsWaiting) { <line10> numServicesWaiting++; <line11> error.append(""WFS ""); <line12> } <line13> if (myWpsWaiting) { <line14> numServicesWaiting++; <line15> error.append(""WPS ""); <line16> } <line17> error <line18> .append(numServicesWaiting > 1 ? ""responses"" : ""response"") <line19> .append("" from Server: "") <line20> .append(mySource.getName()); <line21> error.append("".  Consider increasing timeout settings in Edit->Settings->Servers.""); <line22> sendResponseAndCleanup(error.toString()); <line23> } else { <line24> myResponseTimer.setInitialDelay(myPayload.getTimeBudget().getRemainingMilliseconds()); <line25> myResponseTimer.start(); <line26> } <line27> } <line28> } <line29> "	<line22>      LOGGER.warn(error.toString());	task4	
public class A { <line0> @Override <line1> public void delete(ConnectionParameterKey metadataKey) { <line2> if (!exists(metadataKey)) { <line3> throw new MetadataDoesNotExistException(metadataKey); <line4> } <line5> String deleteStatement = deleteStatement(metadataKey); <line6> getMetadataRepository().executeUpdate(deleteStatement); <line7> } <line8> } <line9> 	"<line2>    LOGGER.trace(MessageFormat.format(""Deleting Connection {0}."", metadataKey.toString()));"	task4	
"public class A { <line0> @Override <line1> public void start(Map<String, String> props) { <line2> try { <line3> config = new CosmosDBSourceConfig(props); <line4> } catch (ConfigException e) { <line5> throw new ConnectException( <line6> ""Couldn't start CosmosDBSourceConnector due to configuration error"", e); <line7> } <line8> } <line9> } <line10> "	"<line2>    logger.info(""Starting the Source Connector"");"	task4	
public class A { <line0> @Override <line1> public Long getExperimentCount(List<String> projectIds) { <line2> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line3> Query<?> query = session.createQuery(GET_PROJECT_EXPERIMENTS_COUNT_HQL); <line4> query.setParameterList(ModelDBConstants.PROJECT_IDS, projectIds); <line5> Long count = (Long) query.uniqueResult(); <line6> return count; <line7> } catch (Exception ex) { <line8> if (ModelDBUtils.needToRetry(ex)) { <line9> return getExperimentCount(projectIds); <line10> } else { <line11> throw ex; <line12> } <line13> } <line14> } <line15> } <line16> 	"<line6>      LOGGER.debug(""Experiment Count : {}"", count);"	task4	
"public class A { <line0> @Override <line1> public List<Integer> getActionRecords(IActionLogRecordSearchBean searchBean) <line2> throws ApsSystemException { <line3> List<Integer> records = new ArrayList<>(); <line4> try { <line5> records = this.getActionLogDAO().getActionRecords(searchBean); <line6> } catch (Throwable t) { <line7> throw new ApsSystemException(""Error loading actionlogger records"", t); <line8> } <line9> return records; <line10> } <line11> } <line12> "	"<line7>      logger.error(""Error loading actionlogger records"", t);"	task4	
"public class A { <line0> @Before <line1> public void setUp() { <line2> testPath = <line3> ""file:///tmp/flume-test."" <line4> + Calendar.getInstance().getTimeInMillis() <line5> + ""."" <line6> + Thread.currentThread().getId(); <line7> sink = new HDFSEventSink(); <line8> sink.setName(""HDFSEventSink-"" + UUID.randomUUID().toString()); <line9> dirCleanup(); <line10> } <line11> } <line12> "	"<line2>    LOG.debug(""Starting..."");"	task4	
"public class A { <line0> @ActivityStreamAuditable <line1> @RestAccessControl(permission = Permission.MANAGE_PAGES) <line2> @RequestMapping( <line3> value = ""/pages/{pageCode}"", <line4> method = RequestMethod.DELETE, <line5> produces = MediaType.APPLICATION_JSON_VALUE) <line6> public ResponseEntity<SimpleRestResponse<?>> deletePage( <line7> @ModelAttribute(""user"") UserDetails user, @PathVariable String pageCode) <line8> throws ApsSystemException { <line9> if (!this.getAuthorizationService().isAuth(user, pageCode)) { <line10> return new ResponseEntity<>(new SimpleRestResponse<>(new PageDto()), HttpStatus.UNAUTHORIZED); <line11> } <line12> DataBinder binder = new DataBinder(pageCode); <line13> BindingResult bindingResult = binder.getBindingResult(); <line14> if (bindingResult.hasErrors()) { <line15> throw new ValidationGenericException(bindingResult); <line16> } <line17> getPageValidator().validateOnlinePage(pageCode, bindingResult); <line18> if (bindingResult.hasErrors()) { <line19> throw new ValidationGenericException(bindingResult); <line20> } <line21> getPageValidator().validateChildren(pageCode, bindingResult); <line22> if (bindingResult.hasErrors()) { <line23> throw new ValidationGenericException(bindingResult); <line24> } <line25> this.getPageService().removePage(pageCode); <line26> Map<String, String> payload = new HashMap<>(); <line27> payload.put(""code"", pageCode); <line28> return new ResponseEntity<>(new SimpleRestResponse<>(payload), HttpStatus.OK); <line29> } <line30> } <line31> "	"<line9>    logger.debug(""deleting {}"", pageCode);"	task4	
public class A { <line0> public void renderEditView(RenderRequest request, RenderResponse response) <line1> throws IOException, PortletException { <line2> String id = request.getParameter(MODERATION_ID); <line3> try { <line4> renderEditViewForId(request, response, id); <line5> } catch (TException e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.error(""Thrift error"", e);"	task4	
public class A { <line0> @Override <line1> public void init() { <line2> messageRouter.registerMessageProcessedListener(this); <line3> mqttClient.setMessageListener(this); <line4> mqttClient.start(); <line5> mqttClientFactory.createSender(ownGbid).start(); <line6> subscribe(); <line7> } <line8> } <line9> 	"<line2>    logger.debug(""Initializing MQTT skeleton (ownGbid={}) ..."", ownGbid);"	task4	
"public class A { <line0> @Override <line1> public String startStopAgent(String agentId, String toolName, String osversion, String action) <line2> throws InsightsCustomException { <line3> try { <line4> String agentDaemonQueueName = <line5> ApplicationConfigProvider.getInstance().getAgentDetails().getAgentPkgQueue(); <line6> if (AGENTACTION.START.equals(AGENTACTION.valueOf(action))) { <line7> performAgentAction(agentId, toolName, osversion, action, agentDaemonQueueName); <line8> } else if (AGENTACTION.STOP.equals(AGENTACTION.valueOf(action)) <line9> && ""WINDOWS"".equalsIgnoreCase(osversion)) { <line10> performAgentAction(agentId, toolName, osversion, action, agentDaemonQueueName); <line11> } else { <line12> performAgentAction(agentId, toolName, osversion, action, agentId); <line13> } <line14> agentConfigDAL.updateAgentRunningStatus(agentId, AGENTACTION.valueOf(action)); <line15> } catch (Exception e) { <line16> throw new InsightsCustomException(e.toString()); <line17> } <line18> return AgentCommonConstant.SUCCESS; <line19> } <line20> } <line21> "	"<line16>      log.error(""Error while agent {} "", action, e);"	task4	
"public class A { <line0> private StreamResponse writeNdjsonResponse(final String id, final Consumer<Writer> writeCall) { <line1> return asStream(id) <line2> .header(""Pragma"", ""no-cache"") <line3> .header(""Cache-Control"", ""no-cache"") <line4> .header(""Expires"", ""Thu, 01 Dec 1994 16:00:00 GMT"") <line5> .header(""Content-Type"", ""application/x-ndjson"") <line6> .stream( <line7> out -> { <line8> try (final Writer writer = <line9> new BufferedWriter( <line10> new OutputStreamWriter(out.stream(), Constants.CHARSET_UTF_8))) { <line11> writeCall.accept(writer); <line12> writer.flush(); <line13> } catch (final Exception e) { <line14> } <line15> }); <line16> } <line17> } <line18> "	"<line14>                logger.warn(""Failed to write {} to response."", id, e);"	task4	
public class A { <line0> protected void ignoreRecord( <line1> List<CassandraToSqlColumnData[]> batchData, CassandraToSqlColumnData[] data) { <line2> int index = batchData.indexOf(data); <line3> if (index > 0) { <line4> batchData.remove(index); <line5> } <line6> } <line7> } <line8> 	"<line2>    log.warn(""[{}] Affected data:\n{}"", this.sqlTableName, this.dataToString(data));"	task4	
public class A { <line0> private void createStreamingServer(WPSCapabilitiesType capabilities, ComponentsFactory factory) { <line1> ProcessOfferings offerings = capabilities.getProcessOfferings(); <line2> if (offerings != null) { <line3> Set<String> processNames = New.set(); <line4> for (ProcessBriefType briefType : offerings.getProcess()) { <line5> processNames.add(briefType.getIdentifier().getValue()); <line6> } <line7> boolean serverHasStreaming = <line8> processNames.contains(StreamingConstants.SUBSCRIBE_PROCESS) <line9> && processNames.contains(StreamingConstants.UNSUBSCRIBE_PROCESS); <line10> if (serverHasStreaming) { <line11> myServer = new WPSStreamingServer(factory); <line12> ServerProvider<StreamingServer> provider = <line13> myProviderRegistry.getProvider(StreamingServer.class); <line14> if (provider instanceof ModifiableServerProvider) { <line15> ((ModifiableServerProvider<StreamingServer>) provider).addServer(myServer); <line16> } else { <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	"<line17>          LOGGER.warn(""Could not find a streaming server provider."");"	task4	
"public class A { <line0> @Override <line1> public SimpleFeature apply(final CSVRecord input) { <line2> if (input == null) { <line3> return null; <line4> } <line5> final String entityId = input.get(""entityId""); <line6> final double cloudCover = Double.parseDouble(input.get(""cloudCover"")); <line7> final String processingLevel = input.get(""processingLevel""); <line8> final int path = Integer.parseInt(input.get(""path"")); <line9> final int row = Integer.parseInt(input.get(""row"")); <line10> final String downloadUrl = input.get(""download_url""); <line11> final MultiPolygon shape = wrs2Geometry.getGeometry(path, row); <line12> featureBuilder.add(shape); <line13> featureBuilder.add(entityId); <line14> Date aquisitionDate; <line15> final SimpleDateFormat sdf = new SimpleDateFormat(AQUISITION_DATE_FORMAT); <line16> try { <line17> aquisitionDate = sdf.parse(input.get(""acquisitionDate"")); <line18> featureBuilder.add(aquisitionDate); <line19> } catch (final ParseException e) { <line20> featureBuilder.add(null); <line21> } <line22> featureBuilder.add(cloudCover); <line23> featureBuilder.add(processingLevel); <line24> featureBuilder.add(path); <line25> featureBuilder.add(row); <line26> featureBuilder.add(downloadUrl); <line27> return featureBuilder.buildFeature(entityId); <line28> } <line29> } <line30> "	"<line20>      LOGGER.warn(""Unable to parse aquisition date"", e);"	task4	
public class A { <line0> private void scheduledLogStatus() { <line1> scheduleRunAsync(this::scheduledLogStatus, STATUS_LOG_INTERVAL_MS, TimeUnit.MILLISECONDS); <line2> } <line3> } <line4> 	<line1>    log.debug(printStatus());	task4	
"public class A { <line0> public static void main(String[] args) { <line1> try { <line2> String port = ""COM10""; <line3> LoggingFactory.init(Level.INFO); <line4> MrlComm arduino = (MrlComm) Runtime.start(""arduino"", ""MrlComm""); <line5> Servo servo01 = (Servo) Runtime.start(""servo01"", ""Servo""); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> "	"<line7>      log.error(""main threw"", e);"	task4	
"public class A { <line0> @Override <line1> public void connectionClosed(ConnectionEvent event) { <line2> if (isActive) { <line3> try { <line4> PooledConnection conn = (PooledConnection) event.getSource(); <line5> provider.returnConnection(conn); <line6> } catch (Exception ex) { <line7> String exception = ""GemFireConnPooledDataSource::connectionclosed:Exception ="" + ex; <line8> if (logger.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> } <line13> } <line14> "	<line9>          logger.debug(exception, ex);	task4	
"public class A { <line0> @Test <line1> public void testNonGeolocationEntities() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> List<Map<String, Object>> locations = new ArrayList<Map<String, Object>>(); <line5> locations.add( <line6> new LinkedHashMap<String, Object>() { <line7> { <line8> put(""name"", ""norwest""); <line9> put(""location"", ""texas""); <line10> } <line11> }); <line12> locations.add( <line13> new LinkedHashMap<String, Object>() { <line14> { <line15> put(""type"", ""store""); <line16> put(""name"", ""ashfield""); <line17> put(""location"", ""new jersey""); <line18> } <line19> }); <line20> for (Map<String, Object> location : locations) { <line21> Entity entity = em.create(""store"", location); <line22> assertNotNull(entity); <line23> } <line24> app.waitForQueueDrainAndRefreshIndex(); <line25> Query query = new Query(); <line26> Results listResults = em.searchCollection(em.getApplicationRef(), ""stores"", query); <line27> assertEquals(""total number of 'stores'"", locations.size(), listResults.size()); <line28> for (Entity entity : listResults.entities) { <line29> Object location = entity.getProperty(""location""); <line30> assertNotNull(location); <line31> assertTrue(location instanceof String); <line32> } <line33> query = Query.fromQL(""select * where location='texas'""); <line34> listResults = em.searchCollection(em.getApplicationRef(), ""stores"", query); <line35> assertEquals(""total number of 'stores'"", 1, listResults.size()); <line36> for (Entity entity : listResults.entities) { <line37> Object location = entity.getProperty(""location""); <line38> assertNotNull(location); <line39> assertTrue(location instanceof String); <line40> } <line41> } <line42> } <line43> "	"<line23>      logger.debug(""Entity {} created"", entity.getProperty(""name""));"	task4	
public class A { <line0> private List<Command> performSubstitutionInCommands(List<Command> commands) { <line1> List<Command> tmp = new ArrayList<>(); <line2> try { <line3> for (Command originalCommand : commands) { <line4> Command clonedCmd = resolve(originalCommand); <line5> tmp.add(clonedCmd); <line6> } <line7> } catch (Exception e) { <line8> } <line9> return tmp; <line10> } <line11> } <line12> 	"<line8>      LOG.error(""Error while substituting variables"", e);"	task4	
public class A { <line0> public static void checkOutFileEntry( <line1> long fileEntryId, com.liferay.portal.kernel.service.ServiceContext serviceContext) <line2> throws RemoteException { <line3> try { <line4> DLAppServiceUtil.checkOutFileEntry(fileEntryId, serviceContext); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) <line2> throws Exception { <line3> if (APIUtil.isAnalyticsEnabled()) { <line4> WebSocketUtils.setApiPropertyToChannel( <line5> ctx, <line6> org.wso2.carbon.apimgt.gateway.handlers.analytics.Constants.REQUEST_START_TIME_PROPERTY, <line7> System.currentTimeMillis()); <line8> } <line9> if ((msg instanceof CloseWebSocketFrame) || (msg instanceof PongWebSocketFrame)) { <line10> outboundHandler().write(ctx, msg, promise); <line11> } else if (msg instanceof WebSocketFrame) { <line12> if (isAllowed(ctx, (WebSocketFrame) msg)) { <line13> outboundHandler().write(ctx, msg, promise); <line14> if (APIUtil.isAnalyticsEnabled()) { <line15> inboundHandler().publishSubscribeEvent(ctx); <line16> } <line17> } else { <line18> if (APIUtil.isAnalyticsEnabled()) { <line19> inboundHandler().publishSubscribeThrottledEvent(ctx); <line20> } <line21> if (log.isDebugEnabled()) { <line22> } <line23> } <line24> } else { <line25> outboundHandler().write(ctx, msg, promise); <line26> } <line27> } <line28> } <line29> 	"<line22>          log.debug(""Outbound Websocket frame is throttled. "" + ctx.channel().toString());"	task4	
"public class A { <line0> @Override <line1> protected boolean sendHeartBeat() { <line2> if (clientHeartbeat == null) { <line3> return super.sendHeartBeat(); <line4> } <line5> Session session = getSession(); <line6> try { <line7> boolean withReply = !GenericUtils.isNegativeOrNull(heartbeatReplyMaxWait); <line8> Buffer buf = <line9> session.createBuffer( <line10> SshConstants.SSH_MSG_GLOBAL_REQUEST, heartbeatRequest.length() + Byte.SIZE); <line11> buf.putString(heartbeatRequest); <line12> buf.putBoolean(withReply); <line13> if (withReply) { <line14> Buffer reply = session.request(heartbeatRequest, buf, heartbeatReplyMaxWait); <line15> if (reply != null) { <line16> if (log.isTraceEnabled()) { <line17> } <line18> } <line19> } else { <line20> IoWriteFuture future = session.writePacket(buf); <line21> future.addListener(this::futureDone); <line22> } <line23> heartbeatCount.incrementAndGet(); <line24> return true; <line25> } catch (IOException | RuntimeException | Error e) { <line26> session.exceptionCaught(e); <line27> warn( <line28> ""sendHeartBeat({}) failed ({}) to send heartbeat #{} request={}: {}"", <line29> session, <line30> e.getClass().getSimpleName(), <line31> heartbeatCount, <line32> heartbeatRequest, <line33> e.getMessage(), <line34> e); <line35> return false; <line36> } <line37> } <line38> } <line39> "	"<line17>            log.trace(""sendHeartBeat({}) received reply size={} for request={}"",session,reply.available(),heartbeatRequest);"	task4	
public class A { <line0> @Override <line1> public Map<String, Object> getServiceBindingParameters(UUID guid) { <line2> return delegate.getServiceBindingParameters(guid); <line3> } <line4> } <line5> 	<line2>    logger.debug(Messages.GETTING_PARAMETERS_OF_SERVICE_BINDING_0, guid);	task4	
"public class A { <line0> @Override <line1> public void deleteFile(String name) throws IOException { <line2> if (_readOnly) { <line3> throw new IOException(""Directory is in read only mode.""); <line4> } <line5> Long length = _files.remove(name); <line6> if (length != null) { <line7> long blocks = length / _blockSize; <line8> _store.delete(new BytesRef(name + LENGTH)); <line9> _store.delete(new BytesRef(name + LASTMOD)); <line10> for (long l = 0; l <= blocks; l++) { <line11> _store.delete(new BytesRef(name + ""/"" + l)); <line12> } <line13> writeFileNamesAndSync(); <line14> } <line15> } <line16> } <line17> "	"<line7>      LOG.debug(""Removing file [{0}] with length [{1}]."", name, length);"	task4	
"public class A { <line0> private String _getExpectedSchemaVersion(List<String> fileNames) <line1> throws IOException, ParseException { <line2> Version expectedSchemaVersion = null; <line3> for (String fileName : fileNames) { <line4> fileName = StringUtil.replace(fileName, CharPool.BACK_SLASH, CharPool.SLASH); <line5> File file = new File(fileName); <line6> String content = FileUtil.read(file); <line7> JavaClass javaClass = JavaClassParser.parseJavaClass(fileName, content); <line8> List<String> implementedClassNames = javaClass.getImplementedClassNames(); <line9> if (!implementedClassNames.contains(""UpgradeStepRegistrator"")) { <line10> continue; <line11> } <line12> int x = -1; <line13> while (true) { <line14> x = content.indexOf("".register("", x + 1); <line15> if (x == -1) { <line16> break; <line17> } <line18> List<String> parameterList = JavaSourceUtil.getParameterList(content.substring(x - 1)); <line19> if (parameterList.size() < 3) { <line20> break; <line21> } <line22> for (int i = parameterList.size() - 2; i > 0; i--) { <line23> Version schemaVersion = null; <line24> try { <line25> schemaVersion = <line26> new Version(StringUtil.removeChar(parameterList.get(i), CharPool.QUOTE)); <line27> } catch (IllegalArgumentException illegalArgumentException) { <line28> if (log.isDebugEnabled()) { <line29> } <line30> continue; <line31> } <line32> if ((expectedSchemaVersion == null) <line33> || (expectedSchemaVersion.compareTo(schemaVersion) < 0)) { <line34> expectedSchemaVersion = schemaVersion; <line35> } <line36> break; <line37> } <line38> } <line39> } <line40> if (expectedSchemaVersion != null) { <line41> return expectedSchemaVersion.toString(); <line42> } <line43> return null; <line44> } <line45> } <line46> "	<line29>              log.debug(illegalArgumentException, illegalArgumentException);	task4	
public class A { <line0> public static com.liferay.blogs.model.BlogsEntrySoap[] getGroupEntries( <line1> long groupId, int status, int max) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.blogs.model.BlogsEntry> returnValue = <line4> BlogsEntryServiceUtil.getGroupEntries(groupId, status, max); <line5> return com.liferay.blogs.model.BlogsEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> protected long getBatchTimeout(String sensorType, WriterConfiguration configurations) { <line1> int batchTimeoutSecs = configurations.getBatchTimeout(sensorType); <line2> if (batchTimeoutSecs <= 0 || batchTimeoutSecs > maxBatchTimeout) { <line3> batchTimeoutSecs = maxBatchTimeout; <line4> } <line5> return TimeUnit.SECONDS.toMillis(batchTimeoutSecs); <line6> } <line7> } <line8> 	"<line3>      LOG.debug(""The configured batch timeout '{}' for sensor type '{}' is <=0 or > the maximum allowable""+ "" batch timeout '{}'. Setting the batch timeout to the maximum allowable."",batchTimeoutSecs,sensorType,maxBatchTimeout);"	task4	
public class A { <line0> @Override <line1> public void prepareHandshakeMessageContents() { <line2> msg.prepareComputations(); <line3> msg.getComputations().setPrivateKey(chooser.getConfig().getDefaultServerEcPrivateKey()); <line4> prepareCurveType(msg); <line5> prepareEcDhParams(); <line6> SignatureAndHashAlgorithm signHashAlgo = chooser.getSelectedSigHashAlgorithm(); <line7> prepareSignatureAndHashAlgorithm(msg, signHashAlgo); <line8> byte[] signature = new byte[0]; <line9> try { <line10> signature = generateSignature(msg, signHashAlgo); <line11> } catch (CryptoException E) { <line12> } <line13> prepareSignature(msg, signature); <line14> prepareSignatureLength(msg); <line15> } <line16> } <line17> 	"<line12>      LOGGER.warn(""Could not generate Signature! Using empty one instead!"", E);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private CacheInvokeEntry.Operation applyEntryProcessor( <line2> GridCacheContext cctx, <line3> KeyCacheObject key, <line4> GridCacheVersion ver, <line5> EntryProcessor entryProc, <line6> Object[] invokeArgs, <line7> MvccUpdateDataRow updateRow, <line8> CacheDataRow oldRow, <line9> boolean keepBinary) { <line10> Object procRes = null; <line11> Exception err = null; <line12> CacheObject oldVal = oldRow == null ? null : oldRow.value(); <line13> CacheInvokeEntry invokeEntry = <line14> new CacheInvokeEntry<>( <line15> key, oldVal, ver, keepBinary, new GridDhtDetachedCacheEntry(cctx, key)); <line16> try { <line17> procRes = entryProc.process(invokeEntry, invokeArgs); <line18> if (invokeEntry.modified() && invokeEntry.op() != CacheInvokeEntry.Operation.REMOVE) { <line19> Object val = invokeEntry.getValue(true); <line20> CacheObject val0 = cctx.toCacheObject(val); <line21> val0 = val0.prepareForCache(cctx.cacheObjectContext(), true); <line22> updateRow.value(val0); <line23> } <line24> } catch (Exception e) { <line25> err = e; <line26> } <line27> CacheInvokeResult invokeRes = <line28> err == null ? CacheInvokeResult.fromResult(procRes) : CacheInvokeResult.fromError(err); <line29> updateRow.invokeResult(invokeRes); <line30> return invokeEntry.op(); <line31> } <line32> } <line33> "	"<line25>      log.error(""Exception was thrown during entry processing."", e);"	task4	
"public class A { <line0> public List<DexOrder> getOverdueOrders(int currentTime) { <line1> List<DexOrder> dexOrders = new ArrayList<>(); <line2> try (Connection con = getDatabaseManager().getDataSource().getConnection(); <line3> PreparedStatement pstmt = <line4> con.prepareStatement( <line5> ""SELECT * FROM dex_offer AS offer where latest = true "" <line6> + ""AND offer.status = 0 AND offer.finish_time < ?"")) { <line7> int i = 0; <line8> pstmt.setLong(++i, currentTime); <line9> DbIterator<DexOrder> orders = getManyBy(con, pstmt, true); <line10> return CollectionUtil.toList(orders); <line11> } catch (SQLException ex) { <line12> } <line13> return dexOrders; <line14> } <line15> } <line16> "	<line12>      log.error(ex.getMessage(), ex);	task4	
"public class A { <line0> private RepairRun buildRepairRunFromRow(Row repairRunResult, UUID id) { <line1> Date startTime = repairRunResult.getTimestamp(""start_time""); <line2> Date pauseTime = repairRunResult.getTimestamp(""pause_time""); <line3> Date endTime = repairRunResult.getTimestamp(""end_time""); <line4> return RepairRun.builder( <line5> repairRunResult.getString(""cluster_name""), repairRunResult.getUUID(""repair_unit_id"")) <line6> .creationTime(new DateTime(repairRunResult.getTimestamp(""creation_time""))) <line7> .intensity(repairRunResult.getDouble(""intensity"")) <line8> .segmentCount(repairRunResult.getInt(""segment_count"")) <line9> .repairParallelism( <line10> RepairParallelism.fromName(repairRunResult.getString(""repair_parallelism""))) <line11> .cause(repairRunResult.getString(""cause"")) <line12> .owner(repairRunResult.getString(""owner"")) <line13> .startTime(null != startTime ? new DateTime(startTime) : null) <line14> .pauseTime(null != pauseTime ? new DateTime(pauseTime) : null) <line15> .endTime(null != endTime ? new DateTime(endTime) : null) <line16> .lastEvent(repairRunResult.getString(""last_event"")) <line17> .runState(RunState.valueOf(repairRunResult.getString(""state""))) <line18> .tables(repairRunResult.getSet(""tables"", String.class)) <line19> .build(id); <line20> } <line21> } <line22> "	"<line1>    LOG.trace(""buildRepairRunFromRow {} / {}"", id, repairRunResult);"	task4	
public class A { <line0> @Override <line1> public Folder getParentFolder() throws PortalException { <line2> Folder parentFolder = null; <line3> try { <line4> parentFolder = super.getParentFolder(); <line5> if (parentFolder != null) { <line6> return parentFolder; <line7> } <line8> } catch (Exception exception) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> } <line12> if (_cmisFolder.isRootFolder()) { <line13> Folder folder = DLAppLocalServiceUtil.getMountFolder(getRepositoryId()); <line14> parentFolder = folder.getParentFolder(); <line15> } else { <line16> Session session = _cmisRepository.getSession(); <line17> String path = _cmisFolder.getPath(); <line18> path = path.substring(0, path.lastIndexOf(CharPool.SLASH)); <line19> if (path.length() == 0) { <line20> path = StringPool.SLASH; <line21> } <line22> CmisObject parentCmisFolder = session.getObjectByPath(path); <line23> parentFolder = <line24> _cmisRepository.toFolder( <line25> (org.apache.chemistry.opencmis.client.api.Folder) parentCmisFolder); <line26> } <line27> setParentFolder(parentFolder); <line28> return parentFolder; <line29> } <line30> } <line31> 	<line10>        log.debug(exception, exception);	task4	
"public class A { <line0> @NamespacePermission( <line1> fields = ""#businessObjectDefinitionTagKey.businessObjectDefinitionKey.namespace"", <line2> permissions = { <line3> NamespacePermissionEnum.WRITE_DESCRIPTIVE_CONTENT, <line4> NamespacePermissionEnum.WRITE <line5> }) <line6> @Override <line7> public BusinessObjectDefinitionTag deleteBusinessObjectDefinitionTag( <line8> BusinessObjectDefinitionTagKey businessObjectDefinitionTagKey) { <line9> validateBusinessObjectDefinitionTagKey(businessObjectDefinitionTagKey); <line10> BusinessObjectDefinitionTagEntity businessObjectDefinitionTagEntity = <line11> getBusinessObjectDefinitionTagEntity(businessObjectDefinitionTagKey); <line12> businessObjectDefinitionTagDao.delete(businessObjectDefinitionTagEntity); <line13> BusinessObjectDefinitionEntity businessObjectDefinitionEntity = <line14> businessObjectDefinitionDaoHelper.getBusinessObjectDefinitionEntity( <line15> businessObjectDefinitionTagKey.getBusinessObjectDefinitionKey()); <line16> searchIndexUpdateHelper.modifyBusinessObjectDefinitionInSearchIndex( <line17> businessObjectDefinitionEntity, SEARCH_INDEX_UPDATE_TYPE_UPDATE); <line18> return createBusinessObjectDefinitionTagFromEntity(businessObjectDefinitionTagEntity); <line19> } <line20> } <line21> "	"<line16>    LOGGER.info(""Modify the business object definition in the search index associated with the business""+ "" object definition tag being deleted. tagTypeCode=\""{}\"", tagCode=\""{}\"",""+ "" businessObjectDefinitionId=\""{}\"", searchIndexUpdateType=\""{}\"""",businessObjectDefinitionTagEntity.getTag().getTagType().getCode(),businessObjectDefinitionTagEntity.getTag().getTagCode(),businessObjectDefinitionEntity.getId(),SEARCH_INDEX_UPDATE_TYPE_UPDATE);"	task4	
public class A { <line0> @Override <line1> public ZNRecord computePartitionAssignment( <line2> final List<String> allNodes, <line3> final List<String> liveNodes, <line4> final Map<String, Map<String, String>> currentMapping, <line5> ResourceControllerDataProvider clusterData) { <line6> int numReplicas = countStateReplicas(); <line7> ZNRecord znRecord = new ZNRecord(_resourceName); <line8> if (liveNodes.size() == 0) { <line9> return znRecord; <line10> } <line11> List<String> sortedAllNodes = new ArrayList<String>(allNodes); <line12> Collections.sort(sortedAllNodes); <line13> Comparator<String> currentStateNodeComparator = new CurrentStateNodeComparator(currentMapping); <line14> List<String> sortedLiveNodes = new ArrayList<String>(liveNodes); <line15> Collections.sort(sortedLiveNodes, currentStateNodeComparator); <line16> int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size(); <line17> int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size(); <line18> _nodeMap = new HashMap<String, Node>(); <line19> _liveNodesList = new ArrayList<Node>(); <line20> for (String id : sortedAllNodes) { <line21> Node node = new Node(id); <line22> node.capacity = 0; <line23> node.hasCeilingCapacity = false; <line24> _nodeMap.put(id, node); <line25> } <line26> for (int i = 0; i < sortedLiveNodes.size(); i++) { <line27> boolean usingCeiling = false; <line28> int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor; <line29> if (distRemainder > 0 && targetSize < _maximumPerNode) { <line30> targetSize += 1; <line31> distRemainder = distRemainder - 1; <line32> usingCeiling = true; <line33> } <line34> Node node = _nodeMap.get(sortedLiveNodes.get(i)); <line35> node.isAlive = true; <line36> node.capacity = targetSize; <line37> node.hasCeilingCapacity = usingCeiling; <line38> _liveNodesList.add(node); <line39> } <line40> _stateMap = generateStateMap(); <line41> _preferredAssignment = computePreferredPlacement(sortedAllNodes); <line42> _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping); <line43> _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping); <line44> _orphaned = computeOrphaned(); <line45> if (_orphaned.size() > 0 && logger.isInfoEnabled()) { <line46> } <line47> assignOrphans(); <line48> moveNonPreferredReplicasToPreferred(); <line49> moveExcessReplicas(); <line50> if (_orphaned.size() > 0) { <line51> forceToAssignOrphans(); <line52> } <line53> prepareResult(znRecord); <line54> return znRecord; <line55> } <line56> } <line57> 	"<line46>      logger.info(""orphan = "" + _orphaned);"	task4	
"public class A { <line0> void commit( <line1> final OfHeader messageToCommit, <line2> final FutureCallback<OfHeader> commitCallback, <line3> final Function<OfHeader, Boolean> isCommitCompletedFunction) { <line4> if (this.completed) { <line5> if (commitCallback != null) { <line6> commitCallback.onFailure(new OutboundQueueException(""Can't commit a completed message."")); <line7> } <line8> } else { <line9> this.message = messageToCommit; <line10> this.callback = commitCallback; <line11> this.barrier = messageToCommit instanceof BarrierInput; <line12> this.isCompletedFunction = isCommitCompletedFunction; <line13> this.committed = true; <line14> } <line15> } <line16> } <line17> "	"<line5>      LOG.warn(""Can't commit a completed message."");"	task4	
public class A { <line0> private void refresh() { <line1> List<MigrationEvent> events = Lists.newArrayList(currentWorkingEvents.values()); <line2> for (MigrationEvent migrationEvent : events) { <line3> if (migrationEvent.isDone()) { <line4> continue; <line5> } <line6> try { <line7> MigrationEvent other = <line8> migrationEventDao.buildMigrationEvent(migrationEvent.getMigrationEventId()); <line9> if (other.isDone()) { <line10> currentWorkingEvents.put(other.getMigrationEventId(), other); <line11> } else if (diff(migrationEvent, other)) { <line12> currentWorkingEvents.put(other.getMigrationEventId(), other); <line13> } <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> } <line19> 	"<line15>        logger.error(""[refresh]"", e);"	task4	
public class A { <line0> protected void createOut() { <line1> try { <line2> out = new PrintWriter(new FileWriter(file, true)); <line3> } catch (IOException e) { <line4> out = new PrintWriter(new NullWriter()); <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.error(""Error while creating process log"", e);"	task4	
public class A { <line0> @Override <line1> public T get(int arg0) { <line2> if (serviceMap.values() != null) { <line3> ArrayList<T> list = new ArrayList<T>(serviceMap.values()); <line4> return list.get(arg0); <line5> } <line6> return null; <line7> } <line8> } <line9> 	"<line2>    LOGGER.debug(""GET called on : {}"", arg0);"	task4	
public class A { <line0> public List<DataSourceColumnDto> findAllDataFileColumns(final Long dataFileId) { <line1> final List<DataSourceColumn> result = new ArrayList<>(); <line2> final DataFile dataFile = dataFileService.find(dataFileId); <line3> for (DataFileColumn dataFileColumn : dataFile.getColumns()) { <line4> result.add( <line5> DataSourceColumn.builder() <line6> .details(dataFileColumn.getName()) <line7> .parameters(dataFileColumn.getDataValueType(), dataFileColumn.getPosition()) <line8> .build()); <line9> } <line10> return dataSourceColumnToDataSourceColumnDtoConverter.convertToList(result); <line11> } <line12> } <line13> 	"<line1>    log.debug(""findAllDataFileColumns() - dataFileId: {}"", dataFileId);"	task4	
"public class A { <line0> private ICacheElement<K, V> spoolLastElement() throws Error { <line1> ICacheElement<K, V> toSpool = null; <line2> final MemoryElementDescriptor<K, V> last = list.getLast(); <line3> if (last != null) { <line4> toSpool = last.getCacheElement(); <line5> if (toSpool == null) { <line6> throw new Error(""update: last.ce is null!""); <line7> } <line8> getCompositeCache().spoolToDisk(toSpool); <line9> if (map.remove(toSpool.getKey()) == null) { <line10> if (log.isTraceEnabled()) { <line11> verifyCache(); <line12> } <line13> } <line14> list.remove(last); <line15> } <line16> return toSpool; <line17> } <line18> } <line19> "	"<line10>        log.warn(""update: remove failed for key: {0}"", toSpool.getKey());"	task4	
public class A { <line0> @Override <line1> public DLSyncEvent remove(Serializable primaryKey) throws NoSuchEventException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> DLSyncEvent dlSyncEvent = (DLSyncEvent) session.get(DLSyncEventImpl.class, primaryKey); <line6> if (dlSyncEvent == null) { <line7> if (log.isDebugEnabled()) { <line8> } <line9> throw new NoSuchEventException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return remove(dlSyncEvent); <line12> } catch (NoSuchEventException noSuchEntityException) { <line13> throw noSuchEntityException; <line14> } catch (Exception exception) { <line15> throw processException(exception); <line16> } finally { <line17> closeSession(session); <line18> } <line19> } <line20> } <line21> 	<line8>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @Override <line1> public void status( <line2> WorkloadStatusSnapshot status, <line3> RecentThroughputAndDuration recentThroughputAndDuration, <line4> long completionTimeAsMilli) { <line5> String statusString; <line6> statusString = <line7> (detailedStatus) <line8> ? formatWithCt( <line9> status.operationCount(), <line10> status.runDurationAsMilli(), <line11> status.durationSinceLastMeasurementAsMilli(), <line12> status.throughput(), <line13> recentThroughputAndDuration.throughput(), <line14> recentThroughputAndDuration.duration(), <line15> completionTimeAsMilli) <line16> : formatWithoutCt( <line17> status.operationCount(), <line18> status.runDurationAsMilli(), <line19> status.durationSinceLastMeasurementAsMilli(), <line20> status.throughput(), <line21> recentThroughputAndDuration.throughput(), <line22> recentThroughputAndDuration.duration()); <line23> } <line24> } <line25> 	<line23>    logger.info(statusString);	task4	
public class A { <line0> private void destroySubsystems() throws Exception { <line1> this.cpmContextListener.shutdown(); <line2> this.jobManager.shutdown(); <line3> injector.getInstance(PersistService.class).stop(); <line4> Enumeration<Driver> drivers = DriverManager.getDrivers(); <line5> while (drivers.hasMoreElements()) { <line6> Driver driver = drivers.nextElement(); <line7> try { <line8> DriverManager.deregisterDriver(driver); <line9> } catch (SQLException e) { <line10> } <line11> } <line12> if (config.getBoolean(ACTIVEMQ_ENABLED)) { <line13> activeMQContextListener.contextDestroyed(injector); <line14> } <line15> this.cpmContextListener.destroy(); <line16> this.loggerListener.contextDestroyed(); <line17> } <line18> } <line19> 	"<line10>        log.info(""Failed to de-registering driver {}"", driver);"	task4	
public class A { <line0> public static long getLong(String key, long def) { <line1> String value = get(key); <line2> if (value == null) { <line3> return def; <line4> } <line5> value = value.trim().toLowerCase(); <line6> if (INTEGER_PATTERN.matcher(value).matches()) { <line7> try { <line8> return Long.parseLong(value); <line9> } catch (Exception e) { <line10> } <line11> } <line12> return def; <line13> } <line14> } <line15> 	"<line12>    logger.warn(""Unable to parse the long integer system property '{}':{} - using the default value: {}"",key,value,def);"	task4	
"public class A { <line0> @Path(""/getAllShouldSucceed"") <line1> @POST <line2> public void getAllShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET_ALL); <line4> SwiftContainer[] containers = template.requestBody(uri, null, SwiftContainer[].class); <line5> assertNotNull(containers); <line6> assertEquals(2, containers.length); <line7> assertEquals(100, containers[0].getTotalSize()); <line8> assertEquals(""Test"", containers[0].getName()); <line9> assertEquals(""marktwain"", containers[1].getName()); <line10> } <line11> } <line12> "	"<line3>    LOG.debug(""Calling OpenstackSwiftContainerResource.getAllShouldSucceed()"");"	task4	
public class A { <line0> public List<IndexedRecord> convertLeadRecords( <line1> List<LeadRecord> recordList, Schema schema, Map<String, String> mappings) { <line2> List<IndexedRecord> results = new ArrayList<>(); <line3> for (LeadRecord input : recordList) { <line4> IndexedRecord record = new Record(schema); <line5> for (Field f : schema.getFields()) { <line6> String col = mappings.get(f.name()); <line7> if (col == null) { <line8> continue; <line9> } <line10> switch (col) { <line11> case FIELD_ID: <line12> record.put(f.pos(), input.getId() != null ? input.getId().getValue() : null); <line13> break; <line14> case FIELD_EMAIL: <line15> record.put(f.pos(), input.getEmail() != null ? input.getEmail().getValue() : null); <line16> break; <line17> case FIELD_FOREIGN_SYS_PERSON_ID: <line18> record.put( <line19> f.pos(), <line20> input.getForeignSysPersonId() != null <line21> ? input.getForeignSysPersonId().getValue() <line22> : null); <line23> break; <line24> case FIELD_FOREIGN_SYS_TYPE: <line25> record.put( <line26> f.pos(), <line27> input.getForeignSysType() != null && input.getForeignSysType().getValue() != null <line28> ? input.getForeignSysType().getValue().value() <line29> : null); <line30> break; <line31> default: <line32> if (!input.getLeadAttributeList().isNil()) { <line33> for (Attribute attr : input.getLeadAttributeList().getValue().getAttributes()) { <line34> if (attr.getAttrName().equals(col)) { <line35> record.put(f.pos(), attr.getAttrValue()); <line36> } <line37> } <line38> } <line39> } <line40> } <line41> results.add(record); <line42> } <line43> return results; <line44> } <line45> } <line46> 	"<line8>          LOG.warn(""[converLeadRecord] Couldn't find mapping for column {}."", f.name());"	task4	
"public class A { <line0> public String createQueue(String queueName) { <line1> Map<String, String[]> params = new HashMap<String, String[]>(); <line2> CommunicationUtils.addParam(params, ""Action"", ""CreateQueue""); <line3> CommunicationUtils.addParam(params, ""QueueName"", queueName); <line4> CommunicationUtils.addParam(params, ""AWSAccessKeyId"", user.getAccessKey()); <line5> CommunicationUtils.addParam(params, ""Version"", ""2009-02-01""); <line6> try { <line7> String response = send(params, CMBProperties.getInstance().getCQSServiceUrl()); <line8> return CqsStressTester.deserialize(response, ""QueueUrl"").trim(); <line9> } catch (Exception e) { <line10> return null; <line11> } <line12> } <line13> } <line14> "	"<line10>      logger.error(""Action=CreateQueue status=error exception="", e);"	task4	
"public class A { <line0> @Override <line1> public void insert( <line2> String host, <line3> String bindApplicationName, <line4> short bindServiceType, <line5> String parentApplicationName, <line6> short parentServiceType) { <line7> Objects.requireNonNull(host, ""host""); <line8> Objects.requireNonNull(bindApplicationName, ""bindApplicationName""); <line9> if (logger.isDebugEnabled()) { <line10> } <line11> final long statisticsRowSlot = getSlotTime(); <line12> final CacheKey cacheKey = <line13> new CacheKey( <line14> host, bindApplicationName, bindServiceType, parentApplicationName, parentServiceType); <line15> final boolean needUpdate = updater.update(cacheKey, statisticsRowSlot); <line16> if (needUpdate) { <line17> insertHostVer2( <line18> host, <line19> bindApplicationName, <line20> bindServiceType, <line21> statisticsRowSlot, <line22> parentApplicationName, <line23> parentServiceType); <line24> } <line25> } <line26> } <line27> "	"<line10>      logger.debug(""insert HostApplicationMap, host:{}, app:{},SType:{},parentApp:{},parentAppSType{}"",host,bindApplicationName,bindServiceType,parentApplicationName,parentServiceType);"	task4	
public class A { <line0> @Override <line1> public boolean hasNext() { <line2> if (!complete && results == null) { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> advance(); <line6> } <line7> return results != null; <line8> } <line9> } <line10> 	"<line4>        logger.trace(""Iterator not complete and there are results object is null, advancing"");"	task4	
public class A { <line0> private void getServerProfileTemplateById() { <line1> ServerProfileTemplate template = <line2> this.serverProfileTemplateClient.getByName(SERVER_PROFILE_TEMPLATE_NAME).get(0); <line3> template = serverProfileTemplateClient.getById(template.getResourceId()); <line4> } <line5> } <line6> 	"<line4>    LOGGER.info(""Server Profile Template object returned to client: {}"", template.toJsonString());"	task4	
public class A { <line0> protected void generatePojo(TableDefinition table) { <line1> JavaWriter out = newJavaWriter(getFile(table, Mode.POJO)); <line2> generatePojo(table, out); <line3> closeJavaWriter(out); <line4> } <line5> } <line6> 	"<line2>    log.info(""Generating POJO"", out.file().getName());"	task4	
public class A { <line0> @Override <line1> public Flux<IType> allSubtypesOf(String fqName, boolean includeFocusType, boolean detailed) { <line2> JavaTypeHierarchyParams searchParams = <line3> new JavaTypeHierarchyParams(projectUri.toString(), fqName, includeFocusType, detailed); <line4> try { <line5> CompletableFuture<List<IType>> future = <line6> subtypesCache.get( <line7> searchParams, <line8> () -> <line9> client <line10> .javaSubTypes(searchParams) <line11> .handle( <line12> (results, exception) -> <line13> results.stream() <line14> .map( <line15> e -> <line16> detailed <line17> ? toType(e.getRight()) <line18> : toTypeFromDescriptor(e.getLeft())) <line19> .collect(Collectors.toList()))); <line20> return Mono.fromFuture(future).flatMapMany(results -> Flux.fromIterable(results)); <line21> } catch (ExecutionException e) { <line22> return Flux.empty(); <line23> } <line24> } <line25> } <line26> 	"<line22>      log.error(""{}"", e);"	task4	
"public class A { <line0> @Override <line1> protected void onSubmit(AjaxRequestTarget target, Form<?> form) { <line2> if (createMode) { <line3> Class<?> permissionClass = permissionTypeModel.getObject(); <line4> user.getPermissions().add(new PermissionInput(permissionClass, values, State.NEW)); <line5> } else { <line6> permissionInput.setState(State.UPDATED); <line7> } <line8> editorPanel.replaceWith(new EmptyPanel(""permissionEditor"")); <line9> submitButton.setVisible(false); <line10> target.add(container); <line11> afterSubmit(target, form); <line12> } <line13> } <line14> "	"<line12>    LOGGER.info(""got values {}"", values.toString());"	task4	
public class A { <line0> private void showIfBetterSolutionsFound() { <line1> if (!singleSuggestionMode <line2> && bestEvaluatedDescriptions.getBestAccuracy() > currentHighestAccuracy) { <line3> currentHighestAccuracy = bestEvaluatedDescriptions.getBestAccuracy(); <line4> expressionTestCountLastImprovement = expressionTests; <line5> timeLastImprovement = System.nanoTime(); <line6> long durationInMillis = getCurrentRuntimeInMilliSeconds(); <line7> String durationStr = getDurationAsString(durationInMillis); <line8> } <line9> } <line10> } <line11> 	"<line8>      logger.info(""more accurate (""+ dfPercent.format(currentHighestAccuracy)+ "") class expression found after ""+ durationStr+ "": ""+ descriptionToString(bestEvaluatedDescriptions.getBest().getDescription()));"	task4	
public class A { <line0> @Override <line1> public void onException(ChunkedOutput<OutboundEvent> chunkedOutput, Exception exception) { <line2> super.onException(chunkedOutput, exception); <line3> } <line4> } <line5> 	"<line3>    LOG.debug(""[{}] SSE exception"", this);"	task4	
public class A { <line0> public KeyInfo getKeyInfo(final PublicKey publicKey) throws SAMLComponentBuilderException { <line1> final KeyInfoBean keyInfoBean = new KeyInfoBean(); <line2> KeyInfo keyInfo = null; <line3> keyInfoBean.setPublicKey(publicKey); <line4> try { <line5> keyInfo = SAML1ComponentBuilder.createKeyInfo(keyInfoBean); <line6> } catch (SecurityException | WSSecurityException e) { <line7> throw new SAMLComponentBuilderException(e.getLocalizedMessage(), e); <line8> } <line9> return keyInfo; <line10> } <line11> } <line12> 	<line7>      LOG.error(e.getLocalizedMessage(), e);	task4	
public class A { <line0> public String fire(String event) { <line1> try { <line2> fsm.fire(event); <line3> return event; <line4> } catch (Exception e) { <line5> } <line6> return event; <line7> } <line8> } <line9> 	"<line5>      log.error(""onStatus threw"", e);"	task4	
"public class A { <line0> @POST <line1> @Path(""schedule/{job-name}"") <line2> @Consumes({MediaType.TEXT_XML, MediaType.TEXT_PLAIN}) <line3> @Produces({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON}) <line4> public APIResult schedule( <line5> @PathParam(""job-name"") String jobName, <line6> @Context HttpServletRequest request, <line7> @DefaultValue("""") @QueryParam(""doAs"") String doAsUser) { <line8> throw FalconWebException.newAPIException( <line9> ""schedule is not supported on Server. Please run your operation "" + ""on Prism.""); <line10> } <line11> } <line12> "	"<line8>    LOG.error(""schedule is not supported on Server.Please run your operation on Prism "");"	task4	
"public class A { <line0> @Test <line1> public void should_find_by_id_async() throws Exception { <line2> final long id = RandomUtils.nextLong(0, Long.MAX_VALUE); <line3> scriptExecutor.executeScriptTemplate( <line4> ""SimpleEntity/insert_single_row.cql"", ImmutableMap.of(""id"", id, ""table"", ""simple"")); <line5> final Date date = buildDateKey(); <line6> final CountDownLatch latch = new CountDownLatch(1); <line7> final CassandraLogAsserter logAsserter = new CassandraLogAsserter(); <line8> logAsserter.prepareLogLevel(ASYNC_LOGGER_STRING, ""%msg - [%thread]%n""); <line9> final CompletableFuture<Tuple2<SimpleEntity, ExecutionInfo>> tuple2 = <line10> manager <line11> .crud() <line12> .findById(id, date) <line13> .withResultSetAsyncListener( <line14> rs -> { <line15> latch.countDown(); <line16> return rs; <line17> }) <line18> .getAsyncWithStats(); <line19> latch.await(); <line20> final SimpleEntity actual = tuple2.get()._1(); <line21> final ExecutionInfo executionInfo = tuple2.get()._2(); <line22> assertThat(actual).isNotNull(); <line23> assertThat(actual.getConsistencyList()) <line24> .containsExactly(ConsistencyLevel.QUORUM, ConsistencyLevel.LOCAL_ONE); <line25> assertThat(executionInfo.getQueriedHost().isUp()).isTrue(); <line26> logAsserter.assertContains(""Called - [achilles-default-executor""); <line27> } <line28> } <line29> "	<line15>                  LOGGER.info(CALLED);	task4	
public class A { <line0> public Boolean apply(WebDriver driver) { <line1> driver.manage().window().maximize(); <line2> return true; <line3> } <line4> } <line5> 	"<line2>    LOGGER.debug(""Browser window size was maximized!"");"	task4	
public class A { <line0> private void sendTypeToPool(PdxType type, int id, Pool pool) { <line1> try { <line2> AddPDXTypeOp.execute((ExecutablePool) pool, id, type); <line3> } catch (ServerConnectivityException serverConnectivityException) { <line4> throw serverConnectivityException; <line5> } <line6> } <line7> } <line8> 	"<line4>      logger.debug(""Received an exception sending pdx type to pool {}, {}"",pool,serverConnectivityException.getMessage(),serverConnectivityException);"	task4	
public class A { <line0> @Test <line1> public void testObjectToString() { <line2> Foo arg = new Foo(); <line3> expect(mockLog.isLevelEnabled(Level.TRACE)).andReturn(true); <line4> mockLog.log(Level.TRACE, Foo.TO_STRING); <line5> replay(mockLog); <line6> verify(mockLog); <line7> } <line8> } <line9> 	"<line6>    logger.trace(""{}"", arg);"	task4	
"public class A { <line0> private List<AssetEntry> _search(long companyId, AssetEntryQuery assetEntryQuery) { <line1> SearchContext searchContext = new SearchContext(); <line2> String ddmStructureFieldName = <line3> GetterUtil.getString(assetEntryQuery.getAttribute(""ddmStructureFieldName"")); <line4> Serializable ddmStructureFieldValue = assetEntryQuery.getAttribute(""ddmStructureFieldValue""); <line5> if (Validator.isNotNull(ddmStructureFieldName) && Validator.isNotNull(ddmStructureFieldValue)) { <line6> searchContext.setAttribute(""ddmStructureFieldName"", ddmStructureFieldName); <line7> searchContext.setAttribute(""ddmStructureFieldValue"", ddmStructureFieldValue); <line8> } <line9> searchContext.setClassTypeIds(assetEntryQuery.getClassTypeIds()); <line10> searchContext.setCompanyId(companyId); <line11> searchContext.setEnd(assetEntryQuery.getEnd()); <line12> searchContext.setKeywords(assetEntryQuery.getKeywords()); <line13> searchContext.setStart(assetEntryQuery.getStart()); <line14> try { <line15> Hits hits = <line16> _assetHelper.search( <line17> searchContext, assetEntryQuery, assetEntryQuery.getStart(), assetEntryQuery.getEnd()); <line18> return _assetHelper.getAssetEntries(hits); <line19> } catch (Exception exception) { <line20> } <line21> return Collections.emptyList(); <line22> } <line23> } <line24> "	"<line20>      log.error(""Unable to get asset entries"", exception);"	task4	
public class A { <line0> public void testOpenL() throws SyntaxNodeException { <line1> boolean b; <line2> long t = System.currentTimeMillis(); <line3> b = executeBooleanOpenLExprression(data, OPENL_EXPR); <line4> assertTrue(b); <line5> b = executeBooleanOpenLExprression(data, NEG_OPENL_EXPR); <line6> assertTrue(b); <line7> } <line8> } <line9> 	"<line7>    log.info(""TestOpenL: Elapsed time = {}."", System.currentTimeMillis() - t);"	task4	
public class A { <line0> private KuraGPIOPin getPin( <line1> String resourceName, <line2> KuraGPIODirection resourceDirection, <line3> KuraGPIOMode resourceMode, <line4> KuraGPIOTrigger resourceTrigger) { <line5> KuraGPIOPin pin = null; <line6> for (GPIOService service : this.gpioServices) { <line7> pin = service.getPinByName(resourceName, resourceDirection, resourceMode, resourceTrigger); <line8> if (pin != null) { <line9> if (!pin.isOpen()) { <line10> try { <line11> pin.open(); <line12> } catch (KuraGPIODeviceException | KuraUnavailableDeviceException | IOException e) { <line13> } <line14> } <line15> break; <line16> } <line17> } <line18> return pin; <line19> } <line20> } <line21> 	"<line13>            logger.error(""Unable to open GPIO resource {}"", pin.getName(), e);"	task4	
"public class A { <line0> public boolean login() throws LoginException { <line1> try { <line2> users = readProperties(usersUrl); <line3> } catch (final IOException ioe) { <line4> throw new LoginException(""Unable to load user properties file "" + usersUrl.getFile()); <line5> } <line6> try { <line7> groups = readProperties(groupsUrl); <line8> } catch (final IOException ioe) { <line9> throw new LoginException(""Unable to load group properties file "" + groupsUrl.getFile()); <line10> } <line11> final Callback[] callbacks = new Callback[2]; <line12> callbacks[0] = new NameCallback(""Username: ""); <line13> callbacks[1] = new PasswordCallback(""Password: "", false); <line14> try { <line15> callbackHandler.handle(callbacks); <line16> } catch (final IOException ioe) { <line17> throw new LoginException(ioe.getMessage()); <line18> } catch (final UnsupportedCallbackException uce) { <line19> throw new LoginException(uce.getMessage() + "" not available to obtain information from user""); <line20> } <line21> user = ((NameCallback) callbacks[0]).getName(); <line22> char[] tmpPassword = ((PasswordCallback) callbacks[1]).getPassword(); <line23> if (tmpPassword == null) { <line24> tmpPassword = new char[0]; <line25> } <line26> final String password = users.getProperty(user); <line27> if (password == null) { <line28> throw new FailedLoginException(""User does not exist""); <line29> } <line30> if (!password.equals(new String(tmpPassword))) { <line31> throw new FailedLoginException(""Password does not match""); <line32> } <line33> users.clear(); <line34> if (debug) { <line35> } <line36> return true; <line37> } <line38> } <line39> "	"<line35>      log.debug(""Logged in as '"" + user + ""'"");"	task4	
"public class A { <line0> public void editDomain(ActionEvent event) { <line1> UpdateDomain updateDomain = new UpdateDomain(); <line2> updateDomain.setDomain(selectedDomain); <line3> try { <line4> directService.updateDomain(updateDomain); <line5> selectedDomain = null; <line6> refreshDomains(); <line7> } catch (DomainException domainException) { <line8> FacesContext.getCurrentInstance().validationFailed(); <line9> FacesContext.getCurrentInstance() <line10> .addMessage( <line11> ""domainEditErrors"", <line12> new FacesMessage( <line13> FacesMessage.SEVERITY_ERROR, <line14> ""Cannot update domain: "" + domainException.getLocalizedMessage(), <line15> """")); <line16> } <line17> } <line18> } <line19> "	"<line16>      LOG.error(""Error updating domain: {}"", domainException.getLocalizedMessage(), domainException);"	task4	
"public class A { <line0> protected CommConnection openSerialPort(String port) throws KuraException { <line1> CommConnection connection = null; <line2> if (this.connectionFactory != null) { <line3> String uri = <line4> new CommURI.Builder(port) <line5> .withBaudRate(115200) <line6> .withDataBits(8) <line7> .withStopBits(1) <line8> .withParity(0) <line9> .withTimeout(2000) <line10> .build() <line11> .toString(); <line12> try { <line13> connection = (CommConnection) this.connectionFactory.createConnection(uri, 1, false); <line14> } catch (Exception e) { <line15> throw new KuraException(KuraErrorCode.INTERNAL_ERROR, e, ""Connection Failed""); <line16> } <line17> } <line18> return connection; <line19> } <line20> } <line21> "	"<line15>        logger.debug(""Exception creating connection: "" + e);"	task4	
"public class A { <line0> private void saveResults(Map data, String name, String path) { <line1> try { <line2> Gson gson = new GsonBuilder().setPrettyPrinting().create(); <line3> String json = gson.toJson(data); <line4> Date timestamp = new Date(System.currentTimeMillis()); <line5> Path logPath = Paths.get(path, ""timeMeasuring""); <line6> Files.createDirectories(logPath); <line7> Files.write( <line8> Paths.get( <line9> logPath.toString(), String.format(""%s-%s.json"", name, dateFormat.format(timestamp))), <line10> json.getBytes(Charset.forName(""UTF-8""))); <line11> } catch (Exception ex) { <line12> } <line13> } <line14> } <line15> "	"<line12>      LOGGER.warn(""Cannot save output of time measuring: "" + ex.getMessage());"	task4	
public class A { <line0> @Override <line1> public DocumentInfo findDocumentByDocumentId(int documentId) { <line2> DocumentInfo document = dao.findById(DocumentInfo.class, documentId); <line3> return document; <line4> } <line5> } <line6> 	"<line2>    log.info(""Finding document by id."");"	task4	
public class A { <line0> protected void requestFinalize(String fileName) { <line1> Set<String> filesPerWindow = finalizedFiles.get(currentWindow); <line2> if (filesPerWindow == null) { <line3> filesPerWindow = Sets.newHashSet(); <line4> finalizedFiles.put(currentWindow, filesPerWindow); <line5> } <line6> if (rollingFile) { <line7> MutableInt part = finalizedPart.get(fileName); <line8> if (part == null) { <line9> part = new MutableInt(-1); <line10> finalizedPart.put(fileName, part); <line11> } <line12> MutableInt currentOpenPart = openPart.get(fileName); <line13> for (int x = part.getValue() + 1; x <= currentOpenPart.getValue(); x++) { <line14> String prevPartNotFinalized = getPartFileName(fileName, x); <line15> filesPerWindow.add(prevPartNotFinalized); <line16> } <line17> fileName = getPartFileNamePri(fileName); <line18> part.setValue(currentOpenPart.getValue()); <line19> } <line20> filesPerWindow.add(fileName); <line21> } <line22> } <line23> 	"<line15>        LOG.debug(""request finalize {}"", prevPartNotFinalized);"	task4	
public class A { <line0> @Override <line1> public synchronized void beforePhase(PhaseEvent event) { <line2> if (event.getPhaseId() == PhaseId.RESTORE_VIEW) { <line3> restoreMessages(event.getFacesContext()); <line4> } <line5> } <line6> } <line7> 	"<line2>    LOGGER.trace(event.getPhaseId().toString() + "" - Before Phase"");"	task4	
public class A { <line0> protected Set<DocumentRef> undeleteDocumentList(CoreSession session, List<DocumentModel> docs) { <line1> Set<DocumentRef> undeleted = new HashSet<>(); <line2> for (DocumentModel doc : docs) { <line3> DocumentRef docRef = doc.getRef(); <line4> if (session <line5> .getAllowedStateTransitions(docRef) <line6> .contains(LifeCycleConstants.UNDELETE_TRANSITION)) { <line7> undeleteDocument(session, doc); <line8> undeleted.add(docRef); <line9> } else { <line10> } <line11> } <line12> return undeleted; <line13> } <line14> } <line15> 	"<line10>        log.debug(""Impossible to undelete document ""+ docRef+ "" as it does not support transition ""+ LifeCycleConstants.UNDELETE_TRANSITION);"	task4	
"public class A { <line0> public JobProcessStatus getJobProcessStatus(int processId) { <line1> try { <line2> MapSqlParameterSource params = new MapSqlParameterSource(); <line3> params.addValue(""processId"", processId); <line4> List<JobProcessStatus> jobProcessStatusList = <line5> baseDao.geoApiNamedJbdcTemaplate.query( <line6> JobProcessQuery.GET_JOB_PROCESS_STATUS.getSql(baseDao.getJobSchema()), <line7> params, <line8> statusHandler); <line9> if (jobProcessStatusList != null && jobProcessStatusList.get(0) != null) { <line10> return jobProcessStatusList.get(0); <line11> } <line12> } catch (Exception ex) { <line13> } <line14> return null; <line15> } <line16> } <line17> "	"<line13>      logger.error(""Failed to retrieve job process status for process "" + processId, ex);"	task4	
public class A { <line0> @Override <line1> public void onFailure(final ProviderException result) { <line2> lock.readLock().lock(); <line3> try { <line4> if (closingConnection.get() || closed.get() || failed.get()) { <line5> requests.remove(id); <line6> super.onFailure(result); <line7> } else { <line8> processAlternates(provider.getAlternateURIs()); <line9> handleProviderFailure( <line10> activeProvider, ProviderExceptionSupport.createOrPassthroughFatal(result)); <line11> } <line12> } finally { <line13> lock.readLock().unlock(); <line14> } <line15> } <line16> } <line17> 	"<line8>        LOG.debug(""Request received error: {}"", result.getMessage());"	task4	
public class A { <line0> private HashFullOuterJoinExec createFullOuterHashJoinPlan( <line1> TaskAttemptContext context, JoinNode plan, PhysicalExec leftExec, PhysicalExec rightExec) <line2> throws IOException { <line3> String[] leftLineage = PlannerUtil.getRelationLineage(plan.getLeftChild()); <line4> String[] rightLineage = PlannerUtil.getRelationLineage(plan.getRightChild()); <line5> long outerSize2 = estimateSizeRecursive(context, leftLineage); <line6> long innerSize2 = estimateSizeRecursive(context, rightLineage); <line7> PhysicalExec selectedRight; <line8> PhysicalExec selectedLeft; <line9> if (outerSize2 <= innerSize2) { <line10> selectedLeft = leftExec; <line11> selectedRight = rightExec; <line12> } else { <line13> selectedLeft = rightExec; <line14> selectedRight = leftExec; <line15> } <line16> return new HashFullOuterJoinExec(context, plan, selectedRight, selectedLeft); <line17> } <line18> } <line19> 	"<line16>    LOG.info(""Full Outer Join ("" + plan.getPID() + "") chooses [Hash Join]"");"	task4	
"public class A { <line0> private CSVParser createParser(Reader reader, CSVFormat csvFormat) throws DMPControllerException { <line1> try { <line2> return new CSVParser(reader, csvFormat); <line3> } catch (final IOException e) { <line4> final String message = <line5> ""couldn't process lookup table to JSON, because couldn't read it with the given CSV"" <line6> + "" format configuration""; <line7> throw new DMPControllerException(message, e); <line8> } <line9> } <line10> } <line11> "	<line7>      LookupResource.LOG.error(message);	task4	
public class A { <line0> @Override <line1> public AccessControlPolicyIterator getApplicablePolicies(String absPath) <line2> throws PathNotFoundException, AccessDeniedException, RepositoryException { <line3> checkInitialized(); <line4> checkPermission(absPath, Permission.READ_AC); <line5> if (editor != null) { <line6> try { <line7> AccessControlPolicy[] applicable = editor.editAccessControlPolicies(absPath); <line8> return new AccessControlPolicyIteratorAdapter(Arrays.asList(applicable)); <line9> } catch (AccessControlException e) { <line10> } <line11> } <line12> return AccessControlPolicyIteratorAdapter.EMPTY; <line13> } <line14> } <line15> 	"<line10>        log.debug(""No applicable policy at "" + absPath);"	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.RegionSoap addRegion( <line1> long countryId, <line2> boolean active, <line3> String name, <line4> double position, <line5> String regionCode, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws RemoteException { <line8> try { <line9> com.liferay.portal.kernel.model.Region returnValue = <line10> RegionServiceUtil.addRegion( <line11> countryId, active, name, position, regionCode, serviceContext); <line12> return com.liferay.portal.kernel.model.RegionSoap.toSoapModel(returnValue); <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	<line14>      log.error(exception, exception);	task4	
public class A { <line0> public static List<HoodieRecord> convertMetadataToRecords( <line1> HoodieCleanerPlan cleanerPlan, String instantTime) { <line2> List<HoodieRecord> records = new LinkedList<>(); <line3> int[] fileDeleteCount = {0}; <line4> cleanerPlan <line5> .getFilePathsToBeDeletedPerPartition() <line6> .forEach( <line7> (partition, deletedPathInfo) -> { <line8> fileDeleteCount[0] += deletedPathInfo.size(); <line9> List<String> deletedFilenames = <line10> deletedPathInfo.stream() <line11> .map(p -> new Path(p.getFilePath()).getName()) <line12> .collect(Collectors.toList()); <line13> HoodieRecord record = <line14> HoodieMetadataPayload.createPartitionFilesRecord( <line15> partition, Option.empty(), Option.of(deletedFilenames)); <line16> records.add(record); <line17> }); <line18> return records; <line19> } <line20> } <line21> 	"<line18>    LOG.info(""Found at ""+ instantTime+ "" from CleanerPlan. #partitions_updated=""+ records.size()+ "", #files_deleted=""+ fileDeleteCount[0]);"	task4	
"public class A { <line0> private void addPersistContentIfManagedBundle( <line1> final BrooklynObjectType type, <line2> final String id, <line3> List<ListenableFuture<?>> futures, <line4> final PersistenceExceptionHandler exceptionHandler) { <line5> if (type == BrooklynObjectType.MANAGED_BUNDLE) { <line6> if (mgmt == null) { <line7> throw new IllegalStateException(""Cannot persist bundles without a management context""); <line8> } <line9> final ManagedBundle mb = <line10> ((ManagementContextInternal) mgmt).getOsgiManager().get().getManagedBundles().get(id); <line11> if (mb == null) { <line12> return; <line13> } <line14> if (mb instanceof BasicManagedBundle) { <line15> if (((BasicManagedBundle) mb).getPersistenceNeeded()) { <line16> futures.add( <line17> executor.submit( <line18> new Runnable() { <line19> @Override <line20> public void run() { <line21> if (!((BasicManagedBundle) mb).getPersistenceNeeded()) { <line22> return; <line23> } <line24> persist( <line25> type.getSubPathName(), <line26> type, <line27> id + "".jar"", <line28> com.google.common.io.Files.asByteSource( <line29> ((ManagementContextInternal) mgmt) <line30> .getOsgiManager() <line31> .get() <line32> .getBundleFile(mb)), <line33> exceptionHandler); <line34> ((BasicManagedBundle) mb).setPersistenceNeeded(false); <line35> } <line36> })); <line37> } <line38> } <line39> } <line40> } <line41> } <line42> "	"<line12>        LOG.warn(""Cannot find managed bundle for added bundle "" + id + ""; ignoring"");"	task4	
public class A { <line0> @Override <line1> public void onClose() { <line2> subscriber.onCompleted(); <line3> } <line4> } <line5> 	"<line2>    logger.info(""Connection to Minecraft server stopped"");"	task4	
public class A { <line0> protected static void setInvalid() { <line1> if (JBoss6VFS.valid != null && JBoss6VFS.valid) { <line2> JBoss6VFS.valid = false; <line3> } <line4> } <line5> } <line6> 	"<line2>      log.debug(""JBoss 6 VFS API is not available in this environment."");"	task4	
public class A { <line0> @Override <line1> public void afterApplicationStart(CamelContext camelContext) { <line2> RoutesDefinition routes = new RoutesDefinition(); <line3> routes.setRoutes(camelContext.getRouteDefinitions()); <line4> try { <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> } catch (JAXBException e) { <line8> throw new IllegalArgumentException(e); <line9> } <line10> } <line11> } <line12> 	"<line6>        LOGGER.debug(""Routes: \n{}"", ModelHelper.dumpModelAsXml(camelContext, routes));"	task4	
"public class A { <line0> public Set<CardinalityIntersectionRecord> scanCardinalities( <line1> List<String> fields, <line2> DateAggregationType dateAggregationType, <line3> DatatypeAggregationType datatypeAggregationType) <line4> throws Exception { <line5> Map<CardinalityIntersectionRecord, HyperLogLogPlus> cardinalityMap = new TreeMap<>(); <line6> try (AccumuloClient client = <line7> Accumulo.newClient() <line8> .to(config.getInstanceName(), config.getZookeepers()) <line9> .as(config.getUsername(), config.getPassword()) <line10> .build()) { <line11> Collection<Authorizations> authCollection = <line12> Collections.singleton(new Authorizations(config.getAuths().split("",""))); <line13> if (!client.tableOperations().exists(config.getTableName())) { <line14> throw new IllegalArgumentException(""Table "" + config.getTableName() + "" does not exist""); <line15> } <line16> try (Scanner scanner = <line17> ScannerHelper.createScanner(client, config.getTableName(), authCollection)) { <line18> Range r = new Range(config.getBeginDate(), config.getEndDate() + ""\0""); <line19> scanner.setRange(r); <line20> Iterator<Map.Entry<Key, Value>> itr = scanner.iterator(); <line21> while (itr.hasNext()) { <line22> Map.Entry<Key, Value> nextEntry = itr.next(); <line23> Key key = nextEntry.getKey(); <line24> String field = key.getColumnFamily().toString(); <line25> if (fields != null && !fields.isEmpty() && !fields.contains(field)) { <line26> continue; <line27> } else { <line28> addEntry(cardinalityMap, nextEntry, dateAggregationType, datatypeAggregationType); <line29> } <line30> } <line31> } <line32> } catch (Exception e) { <line33> } <line34> return cardinalityMap.keySet(); <line35> } <line36> } <line37> "	<line33>      log.error(e);	task4	
public class A { <line0> public void initTimer() { <line1> final int delay = 30; <line2> final int interval = DEFAULT_INTERVAL; <line3> timerEvent.fire( <line4> new TimerEvent( <line5> new TimerSchedule(delay, interval), <line6> new MetadataValidationEvent(), <line7> Scheduled.Literal.INSTANCE)); <line8> } <line9> } <line10> 	"<line1>    log.debug(""Initializing Metadata Validation Timer"");"	task4	
public class A { <line0> protected GetStorageStatsAnswer execute(final GetStorageStatsCommand cmd) { <line1> try { <line2> OvmStoragePool.Details d = OvmStoragePool.getDetailsByUuid(_conn, cmd.getStorageId()); <line3> return new GetStorageStatsAnswer(cmd, d.totalSpace, d.usedSpace); <line4> } catch (Exception e) { <line5> return new GetStorageStatsAnswer(cmd, e.getMessage()); <line6> } <line7> } <line8> } <line9> 	"<line5>      logger.debug(""GetStorageStatsCommand on pool "" + cmd.getStorageId() + "" failed"", e);"	task4	
public class A { <line0> public static void writePrimitiveShort(short value, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> out.writeShort(value); <line5> } <line6> } <line7> 	"<line3>      logger.trace(LogMarker.SERIALIZER_VERBOSE, ""Writing Short {}"", value);"	task4	
public class A { <line0> @ShutdownHandler(phase = Phase.INBOUND_EVENT_CONNECTORS) <line1> @Override <line2> public CompletableFuture<Void> shutdownAsync() { <line3> return coordinator.stop(); <line4> } <line5> } <line6> 	"<line3>    logger.info(""Stopping processor [{}]"", name);"	task4	
public class A { <line0> private void prepareKeyShareLength() { <line1> entry.setPublicKeyLength(entry.getPublicKey().getValue().length); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""KeyShareLength: "" + entry.getPublicKeyLength().getValue());"	task4	
"public class A { <line0> @Override <line1> public void evaluate() throws Throwable { <line2> URL composeYml = getClass().getResource(REDIS_COMPOSE_YML); <line3> assertThat(composeYml).as(""Cannot load resource "" + REDIS_COMPOSE_YML).isNotNull(); <line4> redisCluster = new DockerComposeContainer<>(""acceptance"", new File(composeYml.getFile())); <line5> for (int i = 0; i < NODE_COUNT; i++) { <line6> redisCluster.withExposedService(""redis-node-"" + i, REDIS_PORT); <line7> } <line8> redisCluster.withLocalCompose(true); <line9> redisCluster.waitingFor( <line10> ""redis-cluster-init_1"", Wait.forLogMessage("".*Ready to accept connections.*"", 1)); <line11> redisCluster.start(); <line12> int port = redisCluster.getServicePort(""redis-node-0"", REDIS_PORT); <line13> Jedis jedis = new Jedis(""localhost"", port); <line14> List<ClusterNode> nodes = ClusterNodes.parseClusterNodes(jedis.clusterNodes()).getNodes(); <line15> nodes.forEach(logger::info); <line16> assertThat(nodes.stream().mapToInt(x -> x.primary ? 1 : 0).sum()) <line17> .as(""Incorrect primary node count"") <line18> .isEqualTo(3); <line19> Map<HostPort, HostPort> translationMappings = new HashMap<>(); <line20> List<RedisProxy> proxies = new ArrayList<>(); <line21> for (int i = 0; i < NODE_COUNT; i++) { <line22> Map<String, ContainerNetwork> networks = <line23> redisCluster <line24> .getContainerByServiceName(""redis-node-"" + i + ""_1"") <line25> .get() <line26> .getContainerInfo() <line27> .getNetworkSettings() <line28> .getNetworks(); <line29> ContainerNetwork network = networks.values().iterator().next(); <line30> String containerIp = network.getIpAddress(); <line31> int socatPort = redisCluster.getServicePort(""redis-node-"" + i, REDIS_PORT); <line32> RedisProxy proxy = new RedisProxy(socatPort); <line33> Integer exposedPort = proxy.getExposedPort(); <line34> exposedPorts.add(exposedPort); <line35> translationMappings.put( <line36> new HostPort(containerIp, REDIS_PORT), new HostPort(""127.0.0.1"", exposedPort)); <line37> proxies.add(proxy); <line38> } <line39> proxies.forEach(p -> p.configure(translationMappings)); <line40> try { <line41> base.evaluate(); <line42> } finally { <line43> redisCluster.stop(); <line44> proxies.forEach(RedisProxy::stop); <line45> exposedPorts.clear(); <line46> } <line47> } <line48> } <line49> "	"<line40>    logger.info(""Started redis cluster with mapped ports: {}"", translationMappings);"	task4	
public class A { <line0> protected Iterable<? extends Node> execute(Iterable<String> toGet) { <line1> Iterable<? extends Node> nodes = <line2> transform( <line3> toGet, <line4> new Function<String, Node>() { <line5> @Override <line6> public Node apply(final String input) { <line7> return api.getNode(input); <line8> } <line9> }); <line10> return nodes; <line11> } <line12> } <line13> 	"<line10>    logger.trace(String.format(""getting nodes: %s"", Joiner.on(',').join(toGet)));"	task4	
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap[] <line1> getCommerceInventoryWarehouseItems(long companyId, String sku, int start, int end) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItem> <line5> returnValue = <line6> CommerceInventoryWarehouseItemServiceUtil.getCommerceInventoryWarehouseItems( <line7> companyId, sku, start, end); <line8> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap.toSoapModels( <line9> returnValue); <line10> } catch (Exception exception) { <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> } <line14> } <line15> 	<line11>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> protected List<MenuItem> getPortletTitleMenuItems( <line2> PortletRequest portletRequest, PortletResponse portletResponse) { <line3> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line4> Layout layout = themeDisplay.getLayout(); <line5> if (!_hasAddArticlePermission(themeDisplay) || layout.isLayoutPrototypeLinkActive()) { <line6> return Collections.emptyList(); <line7> } <line8> List<MenuItem> menuItems = new ArrayList<>(); <line9> try { <line10> addPortletTitleAddJournalArticleMenuItems(menuItems, themeDisplay, portletRequest); <line11> } catch (Exception exception) { <line12> } <line13> return menuItems; <line14> } <line15> } <line16> 	"<line12>      log.error(""Unable to add folder menu item"", exception);"	task4	
"public class A { <line0> @ExceptionHandler(OAuthProblemException.class) <line1> public ModelAndView handleOAuthProblemException(OAuthProblemException ex) { <line2> ModelAndView modelAndView = new ModelAndView(""oauth_error""); <line3> modelAndView.addObject(""exception"", ex); <line4> return modelAndView; <line5> } <line6> } <line7> "	"<line2>    logger.error(""OAuth exception: "" + ex.getMessage());"	task4	
"public class A { <line0> private <C extends Component> void executeHeaderTest( <line1> final Class<C> componentClass, String expectedFile) throws IOException { <line2> final MockPageWithLinkAndComponent page = new MockPageWithLinkAndComponent(); <line3> page.add(new WebComponent(MockPageWithLinkAndComponent.COMPONENT_ID).setOutputMarkupId(true)); <line4> page.add( <line5> new AjaxLink<Void>(MockPageWithLinkAndComponent.LINK_ID) { <line6> private static final long serialVersionUID = 1L; <line7>  <line8> @Override <line9> public void onClick(AjaxRequestTarget target) { <line10> try { <line11> Constructor<? extends Component> con = <line12> componentClass.getConstructor(new Class[] {String.class}); <line13> Component comp = con.newInstance(MockPageWithLinkAndComponent.COMPONENT_ID); <line14> page.replace(comp); <line15> comp.setOutputMarkupId(true); <line16> target.add(comp); <line17> } catch (Exception e) { <line18> } <line19> } <line20> }); <line21> tester.startPage(page); <line22> tester.debugComponentTrees(); <line23> tester.clickLink(MockPageWithLinkAndComponent.LINK_ID); <line24> String document = tester.getLastResponseAsString(); <line25> String headerContribution = null; <line26> Pattern pat = <line27> Pattern.compile("".*<header-contribution.*?>(.*?)</header-contribution>.*"", Pattern.DOTALL); <line28> Matcher mat = pat.matcher(document); <line29> if (mat.matches()) { <line30> headerContribution = mat.group(1); <line31> } <line32> if (expectedFile == null) { <line33> assertNull( <line34> headerContribution, <line35> ""There was a header contribution on the response "" <line36> + ""(though we didn't expect one): <"" <line37> + headerContribution <line38> + "">""); <line39> } else if (headerContribution == null) { <line40> fail(""Failed to find header contribution: \n"" + document); <line41> } else { <line42> DiffUtil.validatePage(headerContribution, getClass(), expectedFile, true); <line43> } <line44> } <line45> } <line46> "	<line18>              log.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public void onEdgeEventUpdate(TenantId tenantId, EdgeId edgeId) { <line2> EdgeEventUpdateMsg msg = new EdgeEventUpdateMsg(tenantId, edgeId); <line3> byte[] msgBytes = encodingService.encode(msg); <line4> TbQueueProducer<TbProtoQueueMsg<ToCoreNotificationMsg>> toCoreNfProducer = <line5> producerProvider.getTbCoreNotificationsMsgProducer(); <line6> Set<String> tbCoreServices = partitionService.getAllServiceIds(ServiceType.TB_CORE); <line7> for (String serviceId : tbCoreServices) { <line8> TopicPartitionInfo tpi = <line9> partitionService.getNotificationsTopic(ServiceType.TB_CORE, serviceId); <line10> ToCoreNotificationMsg toCoreMsg = <line11> ToCoreNotificationMsg.newBuilder() <line12> .setEdgeEventUpdateMsg(ByteString.copyFrom(msgBytes)) <line13> .build(); <line14> toCoreNfProducer.send(tpi, new TbProtoQueueMsg<>(msg.getEdgeId().getId(), toCoreMsg), null); <line15> toCoreNfs.incrementAndGet(); <line16> } <line17> } <line18> } <line19> 	"<line2>    log.trace(""[{}] Processing edge {} event update "", tenantId, edgeId);"	task4	
public class A { <line0> @Override <line1> public void sendScreenshotMissingMessage(String branchName, String messageId, String username) <line2> throws BranchNotificationMessageSenderException { <line3> try { <line4> differentialRevision.addComment( <line5> branchName, branchNotificationMessageBuilderPhabricator.getScreenshotMissingMessage()); <line6> } catch (PhabricatorException e) { <line7> throw new BranchNotificationMessageSenderException(e); <line8> } <line9> } <line10> } <line11> 	"<line3>    logger.debug(""sendScreenshotMissingMessage to: {}"", username);"	task4	
public class A { <line0> @Override <line1> public Iterator<ENTITY> iterator() { <line2> final RuntimeEngine rte = getRte(); <line3> final AbstractEntityProperty<ENTITY> meta = getMetaInternal(); <line4> final CassandraOptions cassandraOptions = getOptions(); <line5> final StatementWrapper statementWrapper = getInternalBoundStatementWrapper(); <line6> if (LOGGER.isTraceEnabled()) { <line7> } <line8> CompletableFuture<ResultSet> futureRS = rte.execute(statementWrapper); <line9> return new EntityIteratorWrapper<>(futureRS, meta, statementWrapper, cassandraOptions); <line10> } <line11> } <line12> 	"<line7>      LOGGER.trace(format(""Generate iterator for select : %s"",statementWrapper.getBoundStatement().preparedStatement().getQueryString()));"	task4	
public class A { <line0> @Test <line1> public void testScheduler() throws Exception { <line2> FileStoreMonitor storeMonitor = <line3> new FileStoreMonitor( <line4> scheduledExecutorService, executorService, 20, TimeUnit.MILLISECONDS, 0.9, null); <line5> final ReusableLatch latch = new ReusableLatch(5); <line6> storeMonitor.addStore(getTestDirfile()); <line7> storeMonitor.addCallback( <line8> new FileStoreMonitor.Callback() { <line9> @Override <line10> public void tick(long usableSpace, long totalSpace) { <line11> latch.countDown(); <line12> } <line13>  <line14> @Override <line15> public void over(long usableSpace, long totalSpace) {} <line16>  <line17> @Override <line18> public void under(long usableSpace, long totalSpace) {} <line19> }); <line20> storeMonitor.start(); <line21> Assert.assertTrue(latch.await(1, TimeUnit.SECONDS)); <line22> storeMonitor.stop(); <line23> latch.setCount(1); <line24> Assert.assertFalse(latch.await(100, TimeUnit.MILLISECONDS)); <line25> } <line26> } <line27> 	"<line11>            log.debug(""Tick"");"	task4	
"public class A { <line0> private FileSystem initializeFileSystem() { <line1> try { <line2> FileSystem fileSystem = HadoopClientFactory.get().createFalconFileSystem(storePath.toUri()); <line3> if (!fileSystem.exists(storePath)) { <line4> HadoopClientFactory.mkdirs(fileSystem, storePath, STORE_PERMISSION); <line5> } <line6> return fileSystem; <line7> } catch (Exception e) { <line8> throw new RuntimeException(""Unable to bring up config store for path: "" + storePath, e); <line9> } <line10> } <line11> } <line12> "	"<line4>        LOG.info(""Creating configuration store directory: {}"", storePath);"	task4	
"public class A { <line0> @Dependent <line1> @Named(""windowId"") <line2> @Produces <line3> @WindowId <line4> public String getWindowID() { <line5> PortletRequest portletRequest = getPortletRequest(); <line6> if (portletRequest == null) { <line7> return null; <line8> } <line9> return portletRequest.getWindowID(); <line10> } <line11> } <line12> "	<line7>      log.error(new IllegalStateException(_getDependentStringErrorMessage(WindowId.class)));	task4	
"public class A { <line0> @Override <line1> public void onTimeOut() { <line2> _statusUpdateUtil.logError( <line3> _originalMessage, SchedulerAsyncCallback.class, ""Task timeout"", _manager); <line4> addSummary(_resultSummaryMap, _originalMessage, _manager, true); <line5> } <line6> } <line7> "	"<line2>    logger.info(""Scheduler msg timeout ""+ _originalMessage.getMsgId()+ "" timout with ""+ _timeout+ "" Ms"");"	task4	
public class A { <line0> public void createIdpEventInitCustomer(final IdentityProvider sourceEvent) { <line1> create( <line2> getCurrentProofTenantIdentifier(), <line3> sourceEvent.getIdentifier(), <line4> MongoDbCollections.PROVIDERS, <line5> EventType.EXT_VITAMUI_CREATE_IDP, <line6> converters <line7> .getIdpConverter() <line8> .convertToLogbook(converters.getIdpConverter().convertEntityToDto(sourceEvent))); <line9> } <line10> } <line11> 	"<line1>    LOGGER.info(""Create Provider {}"", sourceEvent.toString());"	task4	
"public class A { <line0> @Override <line1> protected void validate(List<TableInfo> tableInfos) { <line2> try { <line3> if (isNamespaceAvailable(databaseName)) { <line4> for (TableInfo tableInfo : tableInfos) { <line5> if (tableInfo != null) { <line6> HTableDescriptor hTableDescriptor = <line7> admin.getTableDescriptor( <line8> (databaseName + "":"" + tableInfo.getTableName()).getBytes()); <line9> boolean columnFamilyFound = false; <line10> Boolean f = false; <line11> for (HColumnDescriptor columnDescriptor : hTableDescriptor.getColumnFamilies()) { <line12> if (!columnFamilyFound <line13> && columnDescriptor <line14> .getNameAsString() <line15> .equalsIgnoreCase(tableInfo.getTableName())) { <line16> columnFamilyFound = true; <line17> } <line18> for (CollectionColumnInfo cci : tableInfo.getCollectionColumnMetadatas()) { <line19> if (columnDescriptor <line20> .getNameAsString() <line21> .equalsIgnoreCase(cci.getCollectionColumnName())) { <line22> f = true; <line23> break; <line24> } <line25> } <line26> if (!(columnFamilyFound || f)) { <line27> throw new SchemaGenerationException( <line28> ""column "" <line29> + tableInfo.getTableName() <line30> + "" does not exist in table "" <line31> + databaseName <line32> + """", <line33> ""Hbase"", <line34> databaseName, <line35> tableInfo.getTableName()); <line36> } <line37> } <line38> } <line39> } <line40> } else { <line41> throw new SchemaGenerationException( <line42> ""Namespace"" + databaseName + ""does not exist"", ""HBase"", databaseName); <line43> } <line44> } catch (TableNotFoundException tnfex) { <line45> throw new SchemaGenerationException( <line46> ""table "" + databaseName + "" does not exist "", tnfex, ""Hbase""); <line47> } catch (IOException ioe) { <line48> throw new SchemaGenerationException(ioe, ""Hbase""); <line49> } <line50> } <line51> } <line52> "	"<line48>      logger.error(""Either check for network connection or table isn't in enabled state, Caused by:"", ioe);"	task4	
public class A { <line0> public void setResourceState( <line1> String resourceName, <line2> ExternalView externalView, <line3> IdealState idealState, <line4> StateModelDefinition stateModelDef) { <line5> try { <line6> ResourceMonitor resourceMonitor = getOrCreateResourceMonitor(resourceName); <line7> if (resourceMonitor != null) { <line8> resourceMonitor.updateResourceState(externalView, idealState, stateModelDef); <line9> } <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	"<line11>      LOG.error(""Fail to set resource status, resource: "" + idealState.getResourceName(), e);"	task4	
public class A { <line0> public static TransactionGetReceiptResponse getReceiptByTransactionId( <line1> CryptoServiceGrpc.CryptoServiceBlockingStub stub, TransactionID transactionId) <line2> throws Exception { <line3> while (true) { <line4> Response response = <line5> querySubmit( <line6> () -> { <line7> try { <line8> return Query.newBuilder() <line9> .setTransactionGetReceipt( <line10> RequestBuilder.getTransactionGetReceiptQuery( <line11> transactionId, ResponseType.ANSWER_ONLY)) <line12> .build(); <line13> } catch (Exception e) { <line14> return null; <line15> } <line16> }, <line17> stub::getTransactionReceipts); <line18> ResponseCodeEnum code = response.getTransactionGetReceipt().getReceipt().getStatus(); <line19> ResponseCodeEnum preCheck = <line20> response.getTransactionGetReceipt().getHeader().getNodeTransactionPrecheckCode(); <line21> if (preCheck == ResponseCodeEnum.RECEIPT_NOT_FOUND) { <line22> return null; <line23> } else if (code == ResponseCodeEnum.UNKNOWN) { <line24> Thread.sleep(200); <line25> } else if (code == ResponseCodeEnum.SUCCESS) { <line26> return response.getTransactionGetReceipt(); <line27> } else { <line28> return response.getTransactionGetReceipt(); <line29> } <line30> } <line31> } <line32> } <line33> 	"<line28>        log.warn(""Unexpected receipt response {} "", response);"	task4	
public class A { <line0> void extractUsageIfMatch(String value) { <line1> if (usagesKeyPattern != null) { <line2> Matcher m = usagesKeyPattern.matcher(currentKeyName); <line3> if (m.matches()) { <line4> if (usagesAnnotation == null || usagesKeepOrReplace) { <line5> usagesAnnotation = new UsagesAnnotation(new HashSet<>()); <line6> } <line7> usagesAnnotation.getUsages().add(value); <line8> } <line9> } <line10> } <line11> } <line12> 	"<line4>        logger.debug(""key matches usagesKeyPattern, add the value as usage"");"	task4	
"public class A { <line0> public List<LoadBalancerUpstream> getUpstreamsForTasks( <line1> List<SingularityTask> tasks, String requestId, Optional<String> loadBalancerUpstreamGroup) { <line2> final List<LoadBalancerUpstream> upstreams = Lists.newArrayListWithCapacity(tasks.size()); <line3> for (SingularityTask task : tasks) { <line4> final Optional<Long> maybeLoadBalancerPort = <line5> MesosUtils.getPortByIndex( <line6> mesosProtosUtils.toResourceList(task.getMesosTask().getResources()), <line7> task.getTaskRequest().getDeploy().getLoadBalancerPortIndex().orElse(0)); <line8> if (maybeLoadBalancerPort.isPresent()) { <line9> String upstream = String.format(""%s:%d"", task.getHostname(), maybeLoadBalancerPort.get()); <line10> Optional<String> group = loadBalancerUpstreamGroup; <line11> if (taskLabelForLoadBalancerUpstreamGroup.isPresent()) { <line12> for (MesosParameter label : task.getMesosTask().getLabels().getLabels()) { <line13> if (label.hasKey() <line14> && label.getKey().equals(taskLabelForLoadBalancerUpstreamGroup.get()) <line15> && label.hasValue()) { <line16> group = Optional.of(label.getValue()); <line17> break; <line18> } <line19> } <line20> } <line21> upstreams.add( <line22> new LoadBalancerUpstream(upstream, group.orElse(""default""), task.getRackId())); <line23> } else { <line24> } <line25> } <line26> return upstreams; <line27> } <line28> } <line29> "	"<line24>        LOG.warn(""Task {} is missing port but is being passed to LB  ({})"", task.getTaskId(), task);"	task4	
"public class A { <line0> @Override <line1> public void run2() throws CacheException { <line2> AttributesFactory factory = new AttributesFactory(); <line3> factory.setScope(Scope.DISTRIBUTED_ACK); <line4> factory.setDataPolicy(DataPolicy.REPLICATE); <line5> EvictionAttributes evictAttrs = <line6> EvictionAttributes.createLRUEntryAttributes( <line7> evictionThreshold, EvictionAction.OVERFLOW_TO_DISK); <line8> factory.setEvictionAttributes(evictAttrs); <line9> for (int i = 0; i < cqDUnitTest.regions.length; i++) { <line10> Region region = createRegion(cqDUnitTest.regions[i], factory.createRegionAttributes()); <line11> region.getAttributesMutator().addCacheListener(new CertifiableTestCacheListener()); <line12> } <line13> Wait.pause(2000); <line14> try { <line15> cqDUnitTest.startBridgeServer(0, true); <line16> } catch (Exception ex) { <line17> Assert.fail(""While starting CacheServer"", ex); <line18> } <line19> Wait.pause(2000); <line20> } <line21> } <line22> "	"<line2>    logger.info(""### Create Cache Server. ###"");"	task4	
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void testExpandDimsGradient(Nd4jBackend backend) { <line3> val origShape = new long[] {3, 4}; <line4> List<String> failed = new ArrayList<>(); <line5> boolean first = true; <line6> for (int i = 0; i < 3; i++) { <line7> long[] expExpandShape; <line8> switch (i) { <line9> case 0: <line10> expExpandShape = new long[] {1, 3, 4}; <line11> break; <line12> case 1: <line13> expExpandShape = new long[] {3, 1, 4}; <line14> break; <line15> case 2: <line16> expExpandShape = new long[] {3, 4, 1}; <line17> break; <line18> default: <line19> throw new RuntimeException(); <line20> } <line21> for (Pair<INDArray, String> p : <line22> NDArrayCreationUtil.getAllTestMatricesWithShape( <line23> origShape[0], origShape[1], 12345, DataType.DOUBLE)) { <line24> INDArray inArr = p.getFirst().muli(100); <line25> SameDiff sd = SameDiff.create(); <line26> SDVariable in = sd.var(""in"", inArr); <line27> SDVariable expand = sd.expandDims(in, i); <line28> SDVariable stdev = sd.standardDeviation(""out"", expand, true); <line29> Map<String, INDArray> m = sd.outputAll(null); <line30> INDArray expOut = in.getArr().std(true); <line31> assertArrayEquals(expExpandShape, m.get(expand.name()).shape()); <line32> INDArray expExpand = inArr.dup('c').reshape(expExpandShape); <line33> String msg = ""expandDim="" + i + "", source="" + p.getSecond(); <line34> TestCase tc = new TestCase(sd); <line35> tc.testName(msg).expectedOutput(""out"", expOut).expectedOutput(expand.name(), expExpand); <line36> String error = OpValidation.validate(tc); <line37> if (error != null) { <line38> failed.add(error); <line39> } <line40> } <line41> } <line42> assertEquals(0, failed.size(), failed.toString()); <line43> } <line44> } <line45> "	"<line34>        log.info(""Starting: "" + msg);"	task4	
public class A { <line0> private static void importDirectory(ZipInputStream zis, ZipEntry entry) throws IOException { <line1> if (entry.isDirectory()) { <line2> File newDir = new File(entry.getName()); <line3> if (!newDir.exists()) { <line4> newDir.mkdirs(); <line5> } <line6> } else { <line7> File newFile = new File(entry.getName()); <line8> boolean overwrite = false; <line9> if (!newFile.exists()) { <line10> overwrite = true; <line11> } else { <line12> if (newFile.lastModified() < entry.getTime()) { <line13> overwrite = true; <line14> } <line15> } <line16> if (overwrite) { <line17> FileOutputStream fos = new FileOutputStream(newFile); <line18> IOUtils.copy(zis, fos); <line19> fos.flush(); <line20> fos.close(); <line21> } <line22> } <line23> } <line24> } <line25> 	"<line13>          logger.info(""Overwriting existing file {} because import file is newer."", entry.getName());"	task4	
public class A { <line0> private void appendBlock(final BlockPeek blockPeek) { <line1> final ByteBuffer rawBuffer = blockPeek.getRawBuffer(); <line2> final int bytes = rawBuffer.remaining(); <line3> final ByteBuffer copiedBuffer = ByteBuffer.allocate(bytes).put(rawBuffer).flip(); <line4> final Tuple<Long, Long> positions = readLowestHighestPosition(copiedBuffer); <line5> appendBackpressureMetrics.newEntryToAppend(); <line6> if (appendEntryLimiter.tryAcquire(positions.getRight())) { <line7> final var listener = new Listener(this, positions.getRight(), ActorClock.currentTimeMillis()); <line8> logStorage.append(positions.getLeft(), positions.getRight(), copiedBuffer, listener); <line9> blockPeek.markCompleted(); <line10> } else { <line11> appendBackpressureMetrics.deferred(); <line12> } <line13> } <line14> } <line15> 	"<line12>      LOG.trace(""Backpressure happens: in flight {} limit {}"",appendEntryLimiter.getInflight(),appendEntryLimiter.getLimit());"	task4	
public class A { <line0> private void trySendBounce(Mail originalMail) throws MessagingException { <line1> MailImpl newMail = MailImpl.duplicate(originalMail); <line2> try { <line3> newMail.setRemoteHost(getRemoteHost()); <line4> newMail.setRemoteAddr(getRemoteAddr()); <line5> newMail.setRecipients(getSenderAsList(originalMail)); <line6> if (getInitParameters().isDebug()) { <line7> } <line8> newMail.setMessage(createBounceMessage(originalMail)); <line9> MailModifier mailModifier = <line10> MailModifier.builder().mailet(this).mail(newMail).dns(dns).build(); <line11> mailModifier.setRecipients(getRecipients(originalMail)); <line12> mailModifier.setTo(getTo(originalMail)); <line13> mailModifier.setSubjectPrefix(originalMail); <line14> mailModifier.setReplyTo(getReplyTo(originalMail)); <line15> mailModifier.setReversePath(getReversePath(originalMail)); <line16> mailModifier.setIsReply(getInitParameters().isReply(), originalMail); <line17> mailModifier.setSender(getSender(originalMail)); <line18> newMail.getMessage().setHeader(RFC2822Headers.DATE, getDateHeader(originalMail)); <line19> newMail.getMessage().saveChanges(); <line20> getMailetContext().sendMail(newMail); <line21> } finally { <line22> newMail.dispose(); <line23> } <line24> } <line25> } <line26> 	"<line7>        LOGGER.debug(""New mail - sender: {}, recipients: {}, name: {}, remoteHost: {}, remoteAddr: {},""+ "" state: {}, lastUpdated: {}, errorMessage: {}"",newMail.getMaybeSender(),newMail.getRecipients(),newMail.getName(),newMail.getRemoteHost(),newMail.getRemoteAddr(),newMail.getState(),newMail.getLastUpdated(),newMail.getErrorMessage());"	task4	
"public class A { <line0> @Test <line1> public void testDenseSearch() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> int numEntities = 25; <line5> float minLatitude = 48.32455f; <line6> float maxLatitude = 48.46481f; <line7> float minLongitude = 9.89561f; <line8> float maxLongitude = 10.0471f; <line9> float latitudeDelta = (maxLatitude - minLatitude) / numEntities; <line10> float longitudeDelta = (maxLongitude - minLongitude) / numEntities; <line11> for (int i = 0; i < numEntities; i++) { <line12> float latitude = minLatitude + latitudeDelta * i; <line13> float longitude = minLongitude + longitudeDelta * i; <line14> Map<String, Float> location = <line15> MapUtils.hashMap(""latitude"", latitude).map(""longitude"", longitude); <line16> Map<String, Object> data = new HashMap<String, Object>(2); <line17> data.put(""name"", String.valueOf(i)); <line18> data.put(""location"", location); <line19> em.create(""store"", data); <line20> } <line21> app.waitForQueueDrainAndRefreshIndex(); <line22> int limit = 8; <line23> long startTime = System.currentTimeMillis(); <line24> Query query = Query.fromQL(""location within 1000 of 48.38626, 9.94175""); <line25> query.setLimit(limit); <line26> Results results = em.searchCollection(em.getApplicationRef(), ""stores"", query); <line27> assertEquals(0, results.size()); <line28> long endTime = System.currentTimeMillis(); <line29> } <line30> } <line31> "	"<line29>    logger.info(""Runtime took {} milliseconds to search"", endTime - startTime);"	task4	
public class A { <line0> @Override <line1> public void iterationDone(Model model, int iteration, int epoch) { <line2> if (printIterations <= 0) printIterations = 1; <line3> if (iteration % printIterations == 0) { <line4> double score = model.score(); <line5> } <line6> } <line7> } <line8> 	"<line5>      log.info(""Score at iteration {} is {}"", iteration, score);"	task4	
"public class A { <line0> static void migrateLastIpColumn( <line1> Statement st, DatabaseMetaData metaData, String tableName, Columns col) throws SQLException { <line2> final boolean isNotNullWithoutDefault = <line3> SqlDataSourceUtils.isNotNullColumn(metaData, tableName, col.LAST_IP) <line4> && SqlDataSourceUtils.getColumnDefaultValue(metaData, tableName, col.LAST_IP) == null; <line5> if (isNotNullWithoutDefault) { <line6> String sql = <line7> String.format( <line8> ""ALTER TABLE %s MODIFY %s VARCHAR(40) CHARACTER SET ascii COLLATE ascii_bin"", <line9> tableName, col.LAST_IP); <line10> st.execute(sql); <line11> } <line12> } <line13> } <line14> "	"<line11>      logger.info(""Changed last login column to allow NULL values. Please verify the registration feature ""+ ""if you are hooking into a forum."");"	task4	
public class A { <line0> @Override <line1> public void error(String format, Object argument) { <line2> if (isErrorEnabled()) { <line3> FormattingTuple formattingTuple = MessageFormatter.format(format, argument); <line4> } <line5> } <line6> } <line7> 	<line4>      log.error(formattingTuple.getMessage(), formattingTuple.getThrowable());	task4	
public class A { <line0> public TaskDefinition getTask(Integer taskId) throws DAOException { <line1> TaskDefinition task = <line2> (TaskDefinition) sessionFactory.getCurrentSession().get(TaskDefinition.class, taskId); <line3> if (task == null) { <line4> throw new ObjectRetrievalFailureException(TaskDefinition.class, taskId); <line5> } <line6> return task; <line7> } <line8> } <line9> 	"<line4>      log.warn(""Task '"" + taskId + ""' not found"");"	task4	
public class A { <line0> private static void CreateCFSet() { <line1> try { <line2> InputStream fin = VocabDefinitions.class.getClassLoader().getResourceAsStream(CF_PARAMETERS); <line3> InputStreamReader freader = new InputStreamReader(fin); <line4> cfSet = new HashSet<String>(); <line5> StringBuilder builder = new StringBuilder(); <line6> char[] buffer = new char[1]; <line7> while (freader.read(buffer) > 0) { <line8> if (buffer[0] == ';') { <line9> cfSet.add(builder.toString()); <line10> builder.setLength(0); <line11> } else { <line12> builder.append(buffer[0]); <line13> } <line14> } <line15> } catch (Exception ex) { <line16> } <line17> } <line18> } <line19> 	<line16>      log.error(ex.toString());	task4	
public class A { <line0> @Override <line1> public int getAssertionLifetime(String entityId) { <line2> long companyId = CompanyThreadLocal.getCompanyId(); <line3> try { <line4> SamlIdpSpConnection samlIdpSpConnection = <line5> _samlIdpSpConnectionLocalService.getSamlIdpSpConnection(companyId, entityId); <line6> return samlIdpSpConnection.getAssertionLifetime(); <line7> } catch (Exception exception) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> } <line11> SamlProviderConfiguration samlProviderConfiguration = <line12> _samlProviderConfigurationHelper.getSamlProviderConfiguration(); <line13> return samlProviderConfiguration.defaultAssertionLifetime(); <line14> } <line15> } <line16> 	<line9>        log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> public synchronized void start() { <line2> executorService = Executors.newFixedThreadPool(threadCount); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Starting Recon Task Controller."");"	task4	
public class A { <line0> @Before <line1> public void set() { <line2> ALAPipelinesConfig alaConfig = new ALAPipelinesConfig(); <line3> alaConfig.setLocationInfoConfig(new LocationInfoConfig(null, null, null)); <line4> try { <line5> countryCentrePoints = CountryCentrePoints.getInstance(alaConfig.getLocationInfoConfig()); <line6> stateProvinceCentrePoints = <line7> StateProvinceCentrePoints.getInstance(alaConfig.getLocationInfoConfig()); <line8> stateProvinceParser = <line9> StateProvinceParser.getInstance( <line10> alaConfig.getLocationInfoConfig().getStateProvinceNamesFile()); <line11> } catch (Exception e) { <line12> throw new RuntimeException(e.getMessage()); <line13> } <line14> } <line15> } <line16> 	<line12>      log.error(e.getMessage(), e);	task4	
public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMTemplateSoap updateTemplate( <line1> long templateId, <line2> long classPK, <line3> String[] nameMapLanguageIds, <line4> String[] nameMapValues, <line5> String[] descriptionMapLanguageIds, <line6> String[] descriptionMapValues, <line7> String type, <line8> String mode, <line9> String language, <line10> String script, <line11> boolean cacheable, <line12> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line13> throws RemoteException { <line14> try { <line15> Map<Locale, String> nameMap = <line16> LocalizationUtil.getLocalizationMap(nameMapLanguageIds, nameMapValues); <line17> Map<Locale, String> descriptionMap = <line18> LocalizationUtil.getLocalizationMap(descriptionMapLanguageIds, descriptionMapValues); <line19> com.liferay.dynamic.data.mapping.model.DDMTemplate returnValue = <line20> DDMTemplateServiceUtil.updateTemplate( <line21> templateId, <line22> classPK, <line23> nameMap, <line24> descriptionMap, <line25> type, <line26> mode, <line27> language, <line28> script, <line29> cacheable, <line30> serviceContext); <line31> return com.liferay.dynamic.data.mapping.model.DDMTemplateSoap.toSoapModel(returnValue); <line32> } catch (Exception exception) { <line33> throw new RemoteException(exception.getMessage()); <line34> } <line35> } <line36> } <line37> 	<line33>      log.error(exception, exception);	task4	
"public class A { <line0> @RequestMapping(value = ""/api/samples/{sampleId}/metadata"", method = RequestMethod.GET) <line1> public ModelMap getSampleMetadata(@PathVariable Long sampleId) { <line2> ModelMap modelMap = new ModelMap(); <line3> Sample s = sampleService.read(sampleId); <line4> Set<MetadataEntry> metadataForSample = sampleService.getMetadataForSample(s); <line5> SampleMetadataResponse response = buildSampleMetadataResponse(s, metadataForSample); <line6> modelMap.addAttribute(RESTGenericController.RESOURCE_NAME, response); <line7> return modelMap; <line8> } <line9> } <line10> "	"<line2>    logger.trace(""Getting sample metadata for "" + sampleId);"	task4	
public class A { <line0> List<EventID> getDispatchedEvents(InternalCache cache) { <line1> LocalRegion region = (LocalRegion) cache.getRegion(regionName); <line2> if (region == null) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> return null; <line6> } <line7> HARegionQueue haRegionQueue = ((HARegion) region).getOwner(); <line8> return haRegionQueue.getDispatchedEvents(eventIds); <line9> } <line10> } <line11> 	"<line4>        logger.debug(""processing QueueSynchronizationMessage region {} does not exist."", regionName);"	task4	
public class A { <line0> private void graphCommit() { <line1> try { <line2> graph.commit(); <line3> } catch (Exception ex) { <line4> graphRollback(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOG.warn(""Graph transaction commit failed: {}; attempting to rollback graph transaction."", ex);"	task4	
public class A { <line0> private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) { <line1> ch.write( <line2> buff, <line3> position, <line4> null, <line5> new java.nio.channels.CompletionHandler<Integer, Object>() { <line6> public void completed(Integer bytesWritten, Object attachment) { <line7> long pos = position; <line8> if (buff.hasRemaining()) { <line9> pos += bytesWritten; <line10> writeInternal(buff, pos, handler); <line11> } else { <line12> context.runOnContext( <line13> (v) -> { <line14> synchronized (AsyncFileImpl.this) { <line15> writesOutstanding -= buff.limit(); <line16> } <line17> handler.handle(Future.succeededFuture()); <line18> }); <line19> } <line20> } <line21>  <line22> public void failed(Throwable exc, Object attachment) { <line23> if (exc instanceof Exception) { <line24> context.runOnContext( <line25> (v) -> { <line26> synchronized (AsyncFileImpl.this) { <line27> writesOutstanding -= buff.limit(); <line28> } <line29> handler.handle(Future.failedFuture(exc)); <line30> }); <line31> } else { <line32> } <line33> } <line34> }); <line35> } <line36> } <line37> 	"<line32>              log.error(""Error occurred"", exc);"	task4	
public class A { <line0> private Optional<Path> getLocalAttachmentPath( <line1> SW360SparseAttachment attachment, Path releasePath) { <line2> Path localPath = releasePath.resolve(attachment.getFilename()); <line3> try { <line4> return Files.exists(localPath) <line5> && calculateLocalAttachmentHash(localPath).equals(attachment.getSha1()) <line6> ? Optional.of(localPath) <line7> : Optional.empty(); <line8> } catch (SW360ClientException e) { <line9> return Optional.empty(); <line10> } <line11> } <line12> } <line13> 	"<line9>      LOG.warn(""Failed to verify local attachment file"", e);"	task4	
public class A { <line0> public void updateConfigGroup(String clusterName, String groupId, ApiConfigGroup configGroup) <line1> throws AmbariApiException { <line2> String confGroup = ApiUtils.objectToJson(configGroup); <line3> Response response = null; <line4> try { <line5> response = <line6> apiResourceRootV1 <line7> .getClustersResource() <line8> .getConfigGroupsResource(clusterName) <line9> .updateConfigGroup(groupId, confGroup); <line10> } catch (Exception e) { <line11> throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e); <line12> } <line13> handleAmbariResponse(response); <line14> } <line15> } <line16> 	"<line3>    logger.debug(""Updating config group: "" + confGroup);"	task4	
"public class A { <line0> @Override <line1> public void loadModule(final RsfApiBinder apiBinder) throws Throwable { <line2> Environment env = apiBinder.getEnvironment(); <line3> WorkMode workMode = <line4> env.getSettings().getEnum(""hasor.land.workAt"", WorkMode.class, WorkMode.None); <line5> if (WorkMode.None == workMode) { <line6> return; <line7> } <line8> apiBinder.bindType(LandContext.class).asEagerSingleton(); <line9> apiBinder.bindType(Server.class).to(ServerNode.class).asEagerSingleton(); <line10> apiBinder.bindType(ElectionService.class).to(ElectionServiceManager.class).asEagerSingleton(); <line11> apiBinder <line12> .rsfService(apiBinder.getBindInfo(ElectionService.class)) <line13> .asAloneThreadPool() <line14> .asShadow() <line15> .register(); <line16> Hasor.addStartListener( <line17> apiBinder.getEnvironment(), <line18> (EventListener<AppContext>) <line19> (event, eventData) -> { <line20> eventData.getInstance(ElectionService.class); <line21> }); <line22> } <line23> } <line24> "	"<line6>      this.logger.warn(""land workAt None mode, so land cannot be started."");"	task4	
public class A { <line0> public void onServiceStartedEvent( <line1> ServiceStartedEvent event, ActivityContextInterface aci, EventContext eventContext) { <line2> ServiceID serviceID = event.getService(); <line3> SbbStates.setSmscRxSmppServerServiceState(true); <line4> } <line5> } <line6> 	"<line3>    this.logger.info(""Rx: onServiceStartedEvent: event="" + event + "", serviceID="" + serviceID);"	task4	
"public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMStructureVersion getStructureVersion( <line1> HttpPrincipal httpPrincipal, long structureVersionId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DDMStructureVersionServiceUtil.class, <line7> ""getStructureVersion"", <line8> _getStructureVersionParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, structureVersionId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.dynamic.data.mapping.model.DDMStructureVersion) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> public void ensureFirstModelSync() { <line1> try { <line2> trackModels(true); <line3> } catch (Throwable t) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.error(""Model tracking failed for core: {}"", coreName, t);"	task4	
"public class A { <line0> public List<AttributeInterface> getAllowedAttributeElementTypes() { <line1> List<AttributeInterface> attributes = new ArrayList<AttributeInterface>(); <line2> try { <line3> IEntityManager entityManager = this.getEntityManager(); <line4> Map<String, AttributeInterface> attributeTypes = entityManager.getEntityAttributePrototypes(); <line5> Iterator<AttributeInterface> attributeIter = attributeTypes.values().iterator(); <line6> while (attributeIter.hasNext()) { <line7> AttributeInterface attribute = attributeIter.next(); <line8> if (attribute.isSimple()) { <line9> attributes.add(attribute); <line10> } <line11> } <line12> Collections.sort(attributes, new BeanComparator(""type"")); <line13> } catch (Throwable t) { <line14> throw new RuntimeException(""Error extracting the allowed types of attribute elements"", t); <line15> } <line16> return attributes; <line17> } <line18> } <line19> "	"<line14>      logger.error(""Error extracting the allowed types of attribute elements"", t);"	task4	
"public class A { <line0> @RequestMapping(method = RequestMethod.DELETE, value = ""/{query}"") <line1> @ApiOperation( <line2> value = ""delete parametrized query"", <line3> notes = ""delete named, parametrized query by ID"") <line4> @ApiResponses({ <line5> @ApiResponse(code = 200, message = ""Deleted successfully.""), <line6> @ApiResponse(code = 401, message = ""Invalid Username or Password.""), <line7> @ApiResponse(code = 403, message = ""Insufficient privileges for operation.""), <line8> @ApiResponse(code = 404, message = ""queryId does not exist.""), <line9> @ApiResponse(code = 500, message = ""GemFire throws an error or exception"") <line10> }) <line11> @PreAuthorize(""@securityService.authorize('DATA', 'WRITE')"") <line12> public ResponseEntity<?> delete(@PathVariable(""query"") final String queryId) { <line13> deleteNamedQuery(PARAMETERIZED_QUERIES_REGION, queryId); <line14> compiledQueries.remove(queryId); <line15> return new ResponseEntity<>(HttpStatus.OK); <line16> } <line17> } <line18> "	"<line13>    logger.debug(""Deleting a named, parametrized Query with ID ({})."", queryId);"	task4	
public class A { <line0> public ApplicationMap selectApplicationMapWithScatterData(FilteredMapServiceOption option) { <line1> StopWatch watch = new StopWatch(); <line2> watch.start(); <line3> final List<List<SpanBo>> filterList = <line4> selectFilteredSpan( <line5> option.getTransactionIdList(), option.getFilter(), option.getColumnGetCount()); <line6> FilteredMapBuilder filteredMapBuilder = <line7> new FilteredMapBuilder( <line8> applicationFactory, registry, option.getOriginalRange(), option.getVersion()); <line9> filteredMapBuilder.serverMapDataFilter(serverMapDataFilter); <line10> filteredMapBuilder.addTransactions(filterList); <line11> FilteredMap filteredMap = filteredMapBuilder.build(); <line12> ApplicationMap map = createMap(option, filteredMap); <line13> Map<Application, ScatterData> applicationScatterData = <line14> filteredMap.getApplicationScatterData( <line15> option.getOriginalRange().getFrom(), <line16> option.getOriginalRange().getTo(), <line17> option.getxGroupUnit(), <line18> option.getyGroupUnit()); <line19> ApplicationMapWithScatterData applicationMapWithScatterData = <line20> new ApplicationMapWithScatterData(map, applicationScatterData); <line21> watch.stop(); <line22> return applicationMapWithScatterData; <line23> } <line24> } <line25> 	"<line22>    logger.debug(""Select filtered application map elapsed. {}ms"", watch.getTotalTimeMillis());"	task4	
"public class A { <line0> @Override <line1> protected void doProcessAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws Exception { <line3> try { <line4> _ddmFormInstanceService.sendEmail( <line5> ParamUtil.getLong(actionRequest, ""formInstanceId""), <line6> ParamUtil.getString(actionRequest, ""message""), <line7> ParamUtil.getString(actionRequest, ""subject""), <line8> ParamUtil.getStringValues(actionRequest, ""addresses"")); <line9> JSONObject jsonObject = <line10> JSONUtil.put( <line11> ""successMessage"", <line12> LanguageUtil.get( <line13> _portal.getHttpServletRequest(actionRequest), ""form-was-shared-via-email"")); <line14> JSONPortletResponseUtil.writeJSON(actionRequest, actionResponse, jsonObject); <line15> } catch (Exception exception) { <line16> if (log.isDebugEnabled()) { <line17> } <line18> HttpServletResponse httpServletResponse = _portal.getHttpServletResponse(actionResponse); <line19> httpServletResponse.setStatus(HttpServletResponse.SC_BAD_REQUEST); <line20> JSONObject jsonObject = <line21> JSONUtil.put( <line22> ""errorMessage"", <line23> LanguageUtil.get( <line24> _portal.getHttpServletRequest(actionRequest), ""your-request-failed-to-complete"")); <line25> JSONPortletResponseUtil.writeJSON(actionRequest, actionResponse, jsonObject); <line26> } <line27> } <line28> } <line29> "	<line17>        log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> public boolean isShow(PortletRequest portletRequest) { <line2> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line3> try { <line4> MBMessage message = ActionUtil.getMessage(portletRequest); <line5> return ModelResourcePermissionUtil.contains( <line6> _categoryModelResourcePermission, <line7> themeDisplay.getPermissionChecker(), <line8> themeDisplay.getScopeGroupId(), <line9> message.getCategoryId(), <line10> ActionKeys.LOCK_THREAD); <line11> } catch (Exception exception) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> } <line15> return false; <line16> } <line17> } <line18> 	<line13>        log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> public void addDocumentListener(@Nonnull DocumentListener listener) { <line2> if (ArrayUtil.contains(listener, getListeners())) { <line3> } <line4> myDocumentListeners.add(listener); <line5> } <line6> } <line7> 	"<line3>      LOG.error(""Already registered: "" + listener);"	task4	
"public class A { <line0> @Override <line1> public StartupCommand[] initialize() { <line2> final KVMHostInfo info = new KVMHostInfo(_dom0MinMem, _dom0OvercommitMem); <line3> String capabilities = String.join("","", info.getCapabilities()); <line4> if (dpdkSupport) { <line5> capabilities += "",dpdk""; <line6> } <line7> final StartupRoutingCommand cmd = <line8> new StartupRoutingCommand( <line9> info.getCpus(), <line10> info.getCpuSpeed(), <line11> info.getTotalMemory(), <line12> info.getReservedMemory(), <line13> capabilities, <line14> _hypervisorType, <line15> RouterPrivateIpStrategy.HostLocal); <line16> cmd.setCpuSockets(info.getCpuSockets()); <line17> fillNetworkInformation(cmd); <line18> _privateIp = cmd.getPrivateIpAddress(); <line19> cmd.getHostDetails().putAll(getVersionStrings()); <line20> cmd.getHostDetails().put(KeyStoreUtils.SECURED, String.valueOf(isHostSecured()).toLowerCase()); <line21> cmd.setPool(_pool); <line22> cmd.setCluster(_clusterId); <line23> cmd.setGatewayIpAddress(_localGateway); <line24> cmd.setIqn(getIqn()); <line25> if (cmd.getHostDetails().containsKey(""Host.OS"")) { <line26> _hostDistro = cmd.getHostDetails().get(""Host.OS""); <line27> } <line28> StartupStorageCommand sscmd = null; <line29> try { <line30> final KVMStoragePool localStoragePool = <line31> _storagePoolMgr.createStoragePool( <line32> _localStorageUUID, <line33> ""localhost"", <line34> -1, <line35> _localStoragePath, <line36> """", <line37> StoragePoolType.Filesystem); <line38> final com.cloud.agent.api.StoragePoolInfo pi = <line39> new com.cloud.agent.api.StoragePoolInfo( <line40> localStoragePool.getUuid(), <line41> cmd.getPrivateIpAddress(), <line42> _localStoragePath, <line43> _localStoragePath, <line44> StoragePoolType.Filesystem, <line45> localStoragePool.getCapacity(), <line46> localStoragePool.getAvailable()); <line47> sscmd = new StartupStorageCommand(); <line48> sscmd.setPoolInfo(pi); <line49> sscmd.setGuid(pi.getUuid()); <line50> sscmd.setDataCenter(_dcId); <line51> sscmd.setResourceType(Storage.StorageResourceType.STORAGE_POOL); <line52> } catch (final CloudRuntimeException e) { <line53> } <line54> if (sscmd != null) { <line55> return new StartupCommand[] {cmd, sscmd}; <line56> } else { <line57> return new StartupCommand[] {cmd}; <line58> } <line59> } <line60> } <line61> "	"<line53>      logger.debug(""Unable to initialize local storage pool: "" + e);"	task4	
"public class A { <line0> public static void unregisterSyncDevice(HttpPrincipal httpPrincipal, String uuid) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> SyncDeviceServiceUtil.class, <line6> ""unregisterSyncDevice"", <line7> _unregisterSyncDeviceParameterTypes1); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, uuid); <line9> try { <line10> TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public Iterable<V> get(ByteString key, W window) { <line2> try (Locker locker = Locker.locked(stateBackendLock)) { <line3> prepareStateBackend(key); <line4> StateNamespace namespace = StateNamespaces.window(windowCoder, window); <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> BagState<V> bagState = <line8> stateInternals.state(namespace, StateTags.bag(userStateId, valueCoder)); <line9> return bagState.read(); <line10> } <line11> } <line12> } <line13> 	"<line6>        LOG.debug(""State get for {} {} {} {}"",pTransformId,userStateId,Arrays.toString(keyedStateBackend.getCurrentKey().array()),window);"	task4	
public class A { <line0> public static void debug(Object msg, Object[] obj) { <line1> Logger logger = LogUtil.getLogger(); <line2> if (logger != null && logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>      logger.debug(LogUtil.getMsg(msg), obj);	task4	
public class A { <line0> @Override <line1> public void rollback() throws TransactionException { <line2> } <line3> } <line4> 	"<line2>    logger.debug(""Rollback Conn Transaction"");"	task4	
public class A { <line0> @Override <line1> public DataTreeNode getOrCreateNode(final TreeMapState state, final String name) { <line2> if (hard) { <line3> DataTreeNode node = state.getLeasedNode(name); <line4> if (node != null) { <line5> return node; <line6> } <line7> } <line8> String[] p = new String[path.length]; <line9> for (int i = 0; i < p.length; i++) { <line10> p[i] = ValueUtil.asNativeString(path[i].getFilteredValue(state)); <line11> } <line12> DataTreeNode alias = null; <line13> if (peer) { <line14> alias = DataTreeUtil.pathLocateFrom(state.current(), p); <line15> } else if (relativeUp > 0) { <line16> alias = DataTreeUtil.pathLocateFrom(state.peek(relativeUp), p); <line17> } else { <line18> alias = DataTreeUtil.pathLocateFrom(state.current().getTreeRoot(), p); <line19> } <line20> if (alias != null) { <line21> final DataTreeNode finalAlias = alias; <line22> DataTreeNodeInitializer init = <line23> new DataTreeNodeInitializer() { <line24> @Override <line25> public void onNewNode(DataTreeNode child) { <line26> child.aliasTo(finalAlias); <line27> state.onNewNode(child); <line28> } <line29> }; <line30> if (debug > 0) { <line31> debug(true); <line32> } <line33> return state.getOrCreateNode(name, init); <line34> } else { <line35> if (debug > 0) { <line36> debug(false); <line37> } <line38> if (log.isDebugEnabled() || debug == 1) { <line39> } <line40> return null; <line41> } <line42> } <line43> } <line44> 	"<line39>        log.warn(""alias fail, missing "" + LessStrings.join(p, "" / ""));"	task4	
public class A { <line0> protected void setStartLoopPoint(long startLoopPoint, boolean generateLoopBuffers) { <line1> this.startLoopPoint = startLoopPoint; <line2> if (generateLoopBuffers) { <line3> generateLoopBuffers(LOOP_POINT_START); <line4> } <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	"<line6>      log.debug(""Set start loop point of Buffer {} to {}"", this.getSystemName(), startLoopPoint);"	task4	
public class A { <line0> public MongoCursor<Document> execute( <line1> MongoTableHandle tableHandle, List<MongoColumnHandle> columns) { <line2> Document output = new Document(); <line3> for (MongoColumnHandle column : columns) { <line4> output.append(column.getName(), 1); <line5> } <line6> MongoCollection<Document> collection = getCollection(tableHandle.getSchemaTableName()); <line7> Document query = buildQuery(tableHandle.getConstraint()); <line8> FindIterable<Document> iterable = collection.find(query).projection(output); <line9> tableHandle.getLimit().ifPresent(iterable::limit); <line10> if (cursorBatchSize != 0) { <line11> iterable.batchSize(cursorBatchSize); <line12> } <line13> return iterable.iterator(); <line14> } <line15> } <line16> 	"<line10>    log.debug(""Find documents: collection: %s, filter: %s, projection: %s"",tableHandle.getSchemaTableName(), query.toJson(), output.toJson());"	task4	
public class A { <line0> @Override <line1> public BigDecimal calcDimValue(Device device) { <line2> BigDecimal dimValue = new BigDecimal(0); <line3> switch (((TellstickDevice) device).getStatus()) { <line4> case JNA.CLibrary.TELLSTICK_TURNON: <line5> dimValue = new BigDecimal(100); <line6> break; <line7> case JNA.CLibrary.TELLSTICK_TURNOFF: <line8> break; <line9> case JNA.CLibrary.TELLSTICK_DIM: <line10> dimValue = new BigDecimal(((TellstickDevice) device).getData()); <line11> dimValue = dimValue.multiply(new BigDecimal(100)); <line12> dimValue = dimValue.divide(new BigDecimal(255), 0, RoundingMode.HALF_UP); <line13> break; <line14> default: <line15> } <line16> return dimValue; <line17> } <line18> } <line19> 	"<line15>        logger.warn(""Could not handle {} for {}"", ((TellstickDevice) device).getStatus(), device);"	task4	
"public class A { <line0> private void initDatabaseDriver(final String dbDrivers) { <line1> if (dbDrivers != null && !dbDrivers.trim().isEmpty()) { <line2> for (String d : dbDrivers.split("";"")) { <line3> try { <line4> DatabaseDriverLoader.loadDriver(new File(d)); <line5> } catch (IOException ioe) { <line6> } <line7> } <line8> } <line9> } <line10> } <line11> "	"<line6>          LOGGER.warn(""Can't load driver file \""""+ d+ ""\""""+ (ioe.getMessage() != null ? "", reason: "" + ioe.getMessage() : "".""));"	task4	
"public class A { <line0> protected Job doLoad(Configuration conf, TableDescriptor tableDescriptor) throws Exception { <line1> Path outputDir = getTestDir(TEST_NAME, ""load-output""); <line2> NMapInputFormat.setNumMapTasks(conf, conf.getInt(NUM_MAP_TASKS_KEY, NUM_MAP_TASKS_DEFAULT)); <line3> conf.set(TABLE_NAME_KEY, tableDescriptor.getTableName().getNameAsString()); <line4> Job job = Job.getInstance(conf); <line5> job.setJobName(TEST_NAME + "" Load for "" + tableDescriptor.getTableName()); <line6> job.setJarByClass(this.getClass()); <line7> setMapperClass(job); <line8> job.setInputFormatClass(NMapInputFormat.class); <line9> job.setNumReduceTasks(0); <line10> setJobScannerConf(job); <line11> FileOutputFormat.setOutputPath(job, outputDir); <line12> TableMapReduceUtil.addDependencyJars(job); <line13> TableMapReduceUtil.addDependencyJarsForClasses(job.getConfiguration(), AbstractHBaseTool.class); <line14> TableMapReduceUtil.initCredentials(job); <line15> assertTrue(job.waitForCompletion(true)); <line16> return job; <line17> } <line18> } <line19> "	"<line2>    LOG.info(""Load output dir: "" + outputDir);"	task4	
"public class A { <line0> public static void getSubfolderIds( <line1> HttpPrincipal httpPrincipal, <line2> java.util.List<Long> folderIds, <line3> long groupId, <line4> long folderId, <line5> boolean recurse) { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> BookmarksFolderServiceUtil.class, <line10> ""getSubfolderIds"", <line11> _getSubfolderIdsParameterTypes16); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, folderIds, groupId, folderId, recurse); <line14> try { <line15> TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	<line20>      log.error(systemException, systemException);	task4	
"public class A { <line0> private void exportData(OutputStream outputStream, int entityDefId) <line1> throws InvalidExpressionException, IOException, RecordPersistenceException { <line2> CSVDataExportColumnProviderGenerator csvDataExportColumnProviderGenerator = <line3> new CSVDataExportColumnProviderGenerator(recordFilter.getSurvey(), configuration); <line4> DataTransformation transform = <line5> csvDataExportColumnProviderGenerator.generateDataTransformation(entityDefId); <line6> @SuppressWarnings(""resource"") <line7> ModelCsvWriter modelWriter = new ModelCsvWriter(outputStream, transform); <line8> modelWriter.printColumnHeadings(); <line9> CollectSurvey survey = recordFilter.getSurvey(); <line10> Step step = recordFilter.getStepGreaterOrEqual(); <line11> List<CollectRecordSummary> summaries = recordManager.loadSummaries(recordFilter); <line12> for (CollectRecordSummary s : summaries) { <line13> if (status.isRunning()) { <line14> try { <line15> CollectRecord record = recordManager.load(survey, s.getId(), step, false); <line16> modelWriter.printData(record); <line17> } catch (Exception e) { <line18> } <line19> status.incrementProcessed(); <line20> } else { <line21> break; <line22> } <line23> } <line24> modelWriter.flush(); <line25> } <line26> } <line27> "	<line18>          LOG.error(e.getMessage(), e);	task4	
"public class A { <line0> @Override <line1> public DepotAppCustomization findByD_E(long depotEntryId, boolean enabled) <line2> throws NoSuchAppCustomizationException { <line3> DepotAppCustomization depotAppCustomization = fetchByD_E(depotEntryId, enabled); <line4> if (depotAppCustomization == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""depotEntryId=""); <line8> sb.append(depotEntryId); <line9> sb.append("", enabled=""); <line10> sb.append(enabled); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchAppCustomizationException(sb.toString()); <line15> } <line16> return depotAppCustomization; <line17> } <line18> } <line19> "	<line13>        log.debug(sb.toString());	task4	
public class A { <line0> @Override <line1> @Transactional <line2> public void disableScheduling() { <line3> requireNotDisposed(); <line4> _schedulingService.disableScheduling(); <line5> } <line6> } <line7> 	"<line4>    logger.info(""Disabling scheduling via the management service."");"	task4	
"public class A { <line0> public GroupDto getGroupById(final ExternalHttpContext context, final String id) { <line1> final HttpEntity<Void> request = new HttpEntity<>(buildHeaders(context)); <line2> final URIBuilder builder = getUriBuilderFromPath(""/groups/"" + id + ""/""); <line3> final ResponseEntity<GroupDto> response = <line4> restTemplate.exchange(buildUriBuilder(builder), HttpMethod.GET, request, GroupDto.class); <line5> checkResponse(response); <line6> return response.getBody(); <line7> } <line8> } <line9> "	"<line1>    LOGGER.debug(""Get {}"", id);"	task4	
"public class A { <line0> protected final void logUpdatedDeliveryState( <line1> final Span currentSpan, final Message message, final ProtonDelivery delivery) { <line2> Objects.requireNonNull(currentSpan); <line3> final String messageId = <line4> message.getMessageId() != null ? message.getMessageId().toString() : """"; <line5> final String messageAddress = getMessageAddress(message); <line6> final DeliveryState remoteState = delivery.getRemoteState(); <line7> if (Accepted.class.isInstance(remoteState)) { <line8> currentSpan.log(""message accepted by peer""); <line9> Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED); <line10> } else { <line11> final Map<String, Object> events = new HashMap<>(); <line12> if (Rejected.class.isInstance(remoteState)) { <line13> final Rejected rejected = (Rejected) delivery.getRemoteState(); <line14> Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_BAD_REQUEST); <line15> if (rejected.getError() == null) { <line16> logMessageSendingError( <line17> ""message [ID: {}, address: {}] rejected by peer"", messageId, messageAddress); <line18> events.put(Fields.MESSAGE, ""message rejected by peer""); <line19> } else { <line20> logMessageSendingError( <line21> ""message [ID: {}, address: {}] rejected by peer: {}, {}"", <line22> messageId, <line23> messageAddress, <line24> rejected.getError().getCondition(), <line25> rejected.getError().getDescription()); <line26> events.put( <line27> Fields.MESSAGE, <line28> String.format( <line29> ""message rejected by peer: %s, %s"", <line30> rejected.getError().getCondition(), rejected.getError().getDescription())); <line31> } <line32> } else if (Released.class.isInstance(remoteState)) { <line33> logMessageSendingError( <line34> ""message [ID: {}, address: {}] not accepted by peer, remote state: {}"", <line35> messageId, <line36> messageAddress, <line37> remoteState.getClass().getSimpleName()); <line38> Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE); <line39> events.put(Fields.MESSAGE, ""message not accepted by peer, remote state: "" + remoteState); <line40> } else if (Modified.class.isInstance(remoteState)) { <line41> final Modified modified = (Modified) delivery.getRemoteState(); <line42> logMessageSendingError( <line43> ""message [ID: {}, address: {}] not accepted by peer, remote state: {}"", <line44> messageId, <line45> messageAddress, <line46> modified); <line47> Tags.HTTP_STATUS.set( <line48> currentSpan, <line49> modified.getUndeliverableHere() <line50> ? HttpURLConnection.HTTP_NOT_FOUND <line51> : HttpURLConnection.HTTP_UNAVAILABLE); <line52> events.put(Fields.MESSAGE, ""message not accepted by peer, remote state: "" + remoteState); <line53> } <line54> TracingHelper.logError(currentSpan, events); <line55> } <line56> } <line57> } <line58> "	"<line8>      log.trace(""message [ID: {}, address: {}] accepted by peer"", messageId, messageAddress);"	task4	
"public class A { <line0> private static void chkOutput() throws Exception { <line1> File file = new File(FILE_PATH); <line2> final int MAX = 60; <line3> for (int i = 0; i < MAX && (!file.exists()); ++i) { <line4> Thread.sleep(1000); <line5> } <line6> if (!file.exists()) { <line7> String msg = String.format(""Error: %s not found after %d seconds%n"", FILE_PATH, MAX); <line8> throw new RuntimeException(msg); <line9> } <line10> } <line11> } <line12> "	"<line4>      LOG.debug(""Sleeping, i = {}"", i);"	task4	
"public class A { <line0> private String createExistingServersDescription( <line1> final String managementMachinePrefix, final MachineDetails[] existingManagementServers) { <line2> final StringBuilder sb = new StringBuilder(); <line3> boolean first = true; <line4> for (final MachineDetails machineDetails : existingManagementServers) { <line5> final String existingManagementServerDescription = <line6> createManagementServerDescription(machineDetails); <line7> if (first) { <line8> first = false; <line9> } else { <line10> sb.append("", ""); <line11> } <line12> sb.append(""["").append(existingManagementServerDescription).append(""]""); <line13> } <line14> final String serverDescriptions = sb.toString(); <line15> return serverDescriptions; <line16> } <line17> } <line18> "	"<line2>    logger.info(""Found existing servers matching the name: "" + managementMachinePrefix);"	task4	
public class A { <line0> private void setXATerminator(final XATerminator terminator) { <line1> this.xaTerminator = terminator; <line2> } <line3> } <line4> 	"<line2>    logger.debug(""XATerminator set."");"	task4	
public class A { <line0> public void redo() { <line1> if (canRedo()) { <line2> try { <line3> typeOfChangeInProgress = ChangeType.REDOING; <line4> List<OWLOntologyChange> redoChanges = redoStack.pop(); <line5> manager.applyChanges(redoChanges); <line6> } catch (Exception e) { <line7> } finally { <line8> typeOfChangeInProgress = ChangeType.NORMAL; <line9> } <line10> } <line11> } <line12> } <line13> 	"<line7>        logger.error(""An error occurred whilst redoing the last set of undone changes."", e);"	task4	
"public class A { <line0> private int getFudgeFactor() { <line1> final String val = agentConfig.getProperty(""agent.dsl.fudge"", ""0""); <line2> try { <line3> return Integer.parseInt(val); <line4> } catch (NumberFormatException e) { <line5> return 0; <line6> } <line7> } <line8> } <line9> "	"<line5>      log.debug(""val="" + val + "" is not a valid number.  Fudge factor will be 0 seconds"");"	task4	
"public class A { <line0> private void _initializeJspServletDependantsMap() { <line1> try { <line2> Class<?> clazz = Class.forName(""org.apache.jasper.servlet.JspServletWrapper""); <line3> Method method = ReflectionUtil.getDeclaredMethod(clazz, ""getDependants""); <line4> _jspServletDependantsMap = Map.class.isAssignableFrom(method.getReturnType()); <line5> } catch (Exception exception) { <line6> } <line7> } <line8> } <line9> "	<line6>      log.error(exception, exception);	task4	
"public class A { <line0> public static void updateState(UUID taskId, TaskState state) { <line1> Connection connection = Persistence.getInstance().getConnection(); <line2> try (CallableStatement query = connection.prepareCall(""{call update_task_state(?, ?)}"")) { <line3> query.setObject(1, taskId); <line4> query.setString(2, state.toString()); <line5> query.executeQuery(); <line6> } catch (SQLException e) { <line7> } <line8> } <line9> } <line10> "	"<line7>      LOG.error(""Unable to set task as running in recovery db: SQLState: {} Error: {}"",e.getSQLState(),e.getMessage());"	task4	
"public class A { <line0> @Test <line1> public void testSequence() throws InterruptedException { <line2> int count = 100; <line3> Queue<Integer> list = new ConcurrentLinkedQueue<>(); <line4> CountDownLatch latch = new CountDownLatch(count); <line5> for (int i = 0; i < count; i++) { <line6> int finalI = i; <line7> oneThreadTaskExecutor.executeCommand( <line8> new AbstractCommand<Object>() { <line9> @Override <line10> protected void doExecute() throws Exception { <line11> try { <line12> list.offer(finalI); <line13> future().setSuccess(); <line14> } finally { <line15> latch.countDown(); <line16> } <line17> } <line18>  <line19> @Override <line20> protected void doReset() {} <line21>  <line22> @Override <line23> public String getName() { <line24> return getTestName() + "":"" + finalI; <line25> } <line26> }); <line27> } <line28> Assert.assertTrue(latch.await(5, TimeUnit.SECONDS)); <line29> Assert.assertEquals(count, list.size()); <line30> int previous = -1; <line31> while (true) { <line32> Integer current = list.poll(); <line33> if (current == null) { <line34> break; <line35> } <line36> Assert.assertTrue(current > previous); <line37> previous = current; <line38> } <line39> } <line40> } <line41> "	"<line12>                logger.debug(""{}"", this);"	task4	
public class A { <line0> @Override <line1> public boolean isAuth(UserDetails user, Content content) throws ApsSystemException { <line2> if (null == content) { <line3> return false; <line4> } else if (Content.STATUS_NEW.equals(content.getStatus()) && null == content.getMainGroup()) { <line5> return true; <line6> } <line7> return this.getAuthorizationManager().isAuth(user, content); <line8> } <line9> } <line10> 	"<line3>      logger.error(""Null content"");"	task4	
"public class A { <line0> @Test <line1> public void wildcardResourcesAreOrderedAlphabetically() { <line2> final WroModel model = new WroModel(); <line3> final String uri = <line4> String.format( <line5> ClasspathUriLocator.PREFIX + ""%s/expander/order/**.js"", <line6> WroUtil.toPackageAsFolder(getClass())); <line7> model.addGroup(new Group(""group"").addResource(Resource.create(uri, ResourceType.JS))); <line8> Mockito.when(decoratedFactory.create()).thenReturn(model); <line9> final WroModel changedModel = transformer.transform(model); <line10> final Group group = new WroModelInspector(changedModel).getGroupByName(""group""); <line11> assertEquals(7, group.getResources().size()); <line12> final List<Resource> resources = group.getResources(); <line13> assertEquals(""01-xyc.js"", FilenameUtils.getName(resources.get(0).getUri())); <line14> assertEquals(""02-xyc.js"", FilenameUtils.getName(resources.get(1).getUri())); <line15> assertEquals(""03-jquery-ui.js"", FilenameUtils.getName(resources.get(2).getUri())); <line16> assertEquals(""04-xyc.js"", FilenameUtils.getName(resources.get(3).getUri())); <line17> assertEquals(""05-xyc.js"", FilenameUtils.getName(resources.get(4).getUri())); <line18> assertEquals(""06-xyc.js"", FilenameUtils.getName(resources.get(5).getUri())); <line19> assertEquals(""07-jquery-impromptu.js"", FilenameUtils.getName(resources.get(6).getUri())); <line20> } <line21> } <line22> "	"<line10>    LOG.debug(""model: {}"", changedModel);"	task4	
public class A { <line0> @Override <line1> public void onStopContainerError(ContainerId containerId, Throwable t) { <line2> containers.remove(containerId); <line3> } <line4> } <line5> 	"<line2>    LOG.error(""Failed to stop Container "" + containerId);"	task4	
public class A { <line0> public Object[] getChildren(Object parentElement) { <line1> try { <line2> IGefaehrdungsBaumElement elmt = (IGefaehrdungsBaumElement) parentElement; <line3> return elmt.getGefaehrdungsBaumChildren().toArray(); <line4> } catch (Exception e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	"<line5>      LOG.error(""Error in getChildren()"", e);"	task4	
public class A { <line0> private void loadTimelinesFromAllPartitions(String storageTableName, String timeLineKey) <line1> throws HiveException, LensException { <line2> Table storageTable = getTable(storageTableName); <line3> List<String> timeParts = getTimePartColNamesOfTable(storageTable); <line4> List<FieldSchema> partCols = storageTable.getPartCols(); <line5> for (Partition partition : getPartitionsByFilter(storageTableName, null)) { <line6> UpdatePeriod period = deduceUpdatePeriod(partition); <line7> List<String> values = partition.getValues(); <line8> if (values.contains(StorageConstants.LATEST_PARTITION_VALUE)) { <line9> getClient().dropPartition(storageTableName, values, false); <line10> continue; <line11> } <line12> for (int i = 0; i < partCols.size(); i++) { <line13> if (timeParts.contains(partCols.get(i).getName())) { <line14> addForBatchAddition( <line15> timeLineKey, storageTableName, period, partCols.get(i).getName(), values.get(i)); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> 	"<line9>        log.info(""dropping latest partition from fact storage table: {}. Spec: {}"",storageTableName,partition.getSpec());"	task4	
"public class A { <line0> @Override <line1> protected String getTemplateDirectory() { <line2> try { <line3> URL url = <line4> FileLocator.find( <line5> Activator.getDefault().getBundle(), <line6> new Path(""/WebContent/WEB-INF/reportDeposit/""), <line7> null); <line8> URL fileUrl = FileLocator.toFileURL(url); <line9> return FileUtils.toFile(fileUrl).getAbsolutePath(); <line10> } catch (IOException ex) { <line11> } <line12> return null; <line13> } <line14> } <line15> "	"<line11>      LOG.error(""jar file with reports not found"", ex);"	task4	
public class A { <line0> private void startUpdateProcessorTimeJob() { <line1> if (updateTimeJob != null) { <line2> updateTimeJob.cancel(false); <line3> updateTimeJob = null; <line4> } <line5> updateTimeJob = <line6> scheduler.scheduleWithFixedDelay(() -> updateProcessorTime(), 0, 1, TimeUnit.DAYS); <line7> } <line8> } <line9> 	"<line2>      logger.debug(""Canceling old scheduled job"");"	task4	
public class A { <line0> @Override <line1> public void remove(PartitionWriteTxn transaction, K key, V value) throws LdapException { <line2> try { <line3> if (key == null) { <line4> return; <line5> } <line6> org.apache.directory.mavibot.btree.Tuple<K, V> tuple = <line7> bt.delete(((MavibotWriteTxn) transaction).getWriteTransaction(), key, value); <line8> if (tuple != null) { <line9> count--; <line10> } <line11> } catch (IOException ioe) { <line12> throw new LdapOtherException(ioe.getMessage(), ioe); <line13> } <line14> } <line15> } <line16> 	<line12>      LOG.error(I18n.err(I18n.ERR_132, key, value, name), ioe);	task4	
"public class A { <line0> @Override <line1> public InterpreterResult interpret(String cypherQuery, InterpreterContext interpreterContext) { <line2> if (StringUtils.isBlank(cypherQuery)) { <line3> return new InterpreterResult(Code.SUCCESS); <line4> } <line5> final List<String> queries = <line6> isMultiStatementEnabled <line7> ? Arrays.asList(cypherQuery.split("";[^'|^\""|^(\\w+`)]"")) <line8> : Arrays.asList(cypherQuery); <line9> if (queries.size() == 1) { <line10> final String query = queries.get(0); <line11> return runQuery(query, interpreterContext); <line12> } else { <line13> final int lastIndex = queries.size() - 1; <line14> final List<String> subQueries = queries.subList(0, lastIndex); <line15> for (String query : subQueries) { <line16> runQuery(query, interpreterContext); <line17> } <line18> return runQuery(queries.get(lastIndex), interpreterContext); <line19> } <line20> } <line21> } <line22> "	"<line2>    LOGGER.info(""Opening session"");"	task4	
"public class A { <line0> public void to(String destination) { <line1> Connection connection = null; <line2> try { <line3> if (transacted) { <line4> connection = xaConnectionFactory.createConnection(); <line5> } else { <line6> connection = connectionFactory.createConnection(); <line7> } <line8> Session session = connection.createSession(transacted, autoAcknowledgeMode); <line9> MessageProducer messageProducer = session.createProducer(session.createQueue(destination)); <line10> connection.start(); <line11> ObjectMessage objectMessage = session.createObjectMessage(message); <line12> for (Entry<String, Object> property : properties.entrySet()) { <line13> final Object value = property.getValue(); <line14> if (value instanceof String) { <line15> objectMessage.setStringProperty(property.getKey(), (String) value); <line16> } else if (value instanceof Long) { <line17> objectMessage.setLongProperty(property.getKey(), (Long) value); <line18> } <line19> } <line20> messageProducer.send(objectMessage); <line21> } catch (JMSException e) { <line22> throw new MessageDeliveryException(""Failed to queue push message for further processing"", e); <line23> } finally { <line24> if (connection != null) { <line25> try { <line26> connection.close(); <line27> } catch (JMSException e) { <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	"<line28>          logger.error(""Failed to close JMS connection: "", e);"	task4	
public class A { <line0> @Override <line1> public void setHeader(Metadata header, String name, String value) { <line2> final Metadata.Key<String> key = Metadata.Key.of(name, Metadata.ASCII_STRING_MARSHALLER); <line3> header.put(key, value); <line4> if (isDebug) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.debug(""Set header {}={}"", name, value);"	task4	
"public class A { <line0> @Test <line1> public void testJacksonJSONParsing() throws Exception { <line2> RepairScheduleStatus data = new RepairScheduleStatus(); <line3> data.setClusterName(""testCluster""); <line4> data.setColumnFamilies(Lists.<String>newArrayList()); <line5> data.setCreationTime(DateTime.now().withMillis(0)); <line6> data.setDaysBetween(2); <line7> data.setId(UUIDs.timeBased()); <line8> data.setIntensity(0.75); <line9> data.setIncrementalRepair(false); <line10> data.setKeyspaceName(""testKeyspace""); <line11> data.setOwner(""testuser""); <line12> data.setRepairParallelism(RepairParallelism.PARALLEL); <line13> data.setState(RepairSchedule.State.ACTIVE); <line14> ObjectMapper mapper = new ObjectMapper(); <line15> String dataAsJson = mapper.writeValueAsString(data); <line16> RepairScheduleStatus dataAfter = SimpleReaperClient.parseRepairScheduleStatusJSON(dataAsJson); <line17> assertEquals(data.getClusterName(), dataAfter.getClusterName()); <line18> assertEquals(data.getColumnFamilies(), dataAfter.getColumnFamilies()); <line19> assertEquals(data.getCreationTime(), dataAfter.getCreationTime()); <line20> assertEquals(data.getDaysBetween(), dataAfter.getDaysBetween()); <line21> assertEquals(data.getId(), dataAfter.getId()); <line22> assertEquals(data.getIntensity(), dataAfter.getIntensity(), 0.0); <line23> assertEquals(data.getIncrementalRepair(), dataAfter.getIncrementalRepair()); <line24> assertEquals(data.getKeyspaceName(), dataAfter.getKeyspaceName()); <line25> assertEquals(data.getRepairParallelism(), dataAfter.getRepairParallelism()); <line26> assertEquals(data.getState(), dataAfter.getState()); <line27> } <line28> } <line29> "	"<line16>    LOG.info(""DATA: "" + dataAsJson);"	task4	
public class A { <line0> private void initialize(ChannelHandlerContext ctx) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> switch (state) { <line4> case 1: <line5> case 2: <line6> return; <line7> } <line8> state = 1; <line9> EventExecutor loop = ctx.executor(); <line10> lastExecutionTime = System.nanoTime(); <line11> resenderTimeout = <line12> loop.schedule(new WriterIdleTimeoutTask(ctx), resenderTimeNanos, TimeUnit.NANOSECONDS); <line13> } <line14> } <line15> 	"<line2>      LOG.debug(""Initializing autoflush handler on channel {}"", ctx.channel());"	task4	
"public class A { <line0> public RetryMessageModel getMessageById(final String topic, final String app, final long id) <line1> throws JoyQueueException { <line2> final long nowTime = SystemClock.now(); <line3> try { <line4> RetryMessageModel retryMessageModel = <line5> DaoUtil.queryObject( <line6> readDataSource, <line7> GET_SQL, <line8> new DaoUtil.QueryCallback<RetryMessageModel>() { <line9> @Override <line10> public void before(PreparedStatement preparedStatement) throws Exception { <line11> preparedStatement.setString(1, topic); <line12> preparedStatement.setString(2, app); <line13> preparedStatement.setTimestamp(3, new Timestamp(nowTime)); <line14> preparedStatement.setLong(4, id); <line15> } <line16>  <line17> @Override <line18> public RetryMessageModel map(ResultSet rs) throws Exception { <line19> RetryMessageModel message = new RetryMessageModel(); <line20> message.setIndex(rs.getInt(1)); <line21> message.setBusinessId(rs.getString(2)); <line22> message.setTopic(rs.getString(3)); <line23> message.setApp(rs.getString(4)); <line24> message.setPartition(Partition.RETRY_PARTITION_ID); <line25> message.setBrokerMessage(rs.getBytes(5)); <line26> message.setException(rs.getBytes(6)); <line27> message.setSendTime(rs.getLong(7)); <line28> return message; <line29> } <line30> }); <line31> return retryMessageModel; <line32> } catch (Exception e) { <line33> throw new JoyQueueException( <line34> String.format( <line35> ""%s topic:%s,app:%s,id:%d"", JoyQueueCode.CN_DB_ERROR.getMessage(), topic, app, id), <line36> e, <line37> JoyQueueCode.CN_DB_ERROR.getCode()); <line38> } <line39> } <line40> } <line41> "	"<line33>      logger.error(""getMessageById error"", e);"	task4	
"public class A { <line0> @Issue(""JENKINS-53311"") <line1> @Test <line2> public void nodeWrongFinishedStatus() throws Exception { <line3> WorkflowJob job = j.jenkins.createProject(WorkflowJob.class, ""p""); <line4> URL resource = Resources.getResource(getClass(), ""JENKINS-53311.jenkinsfile""); <line5> String jenkinsFile = Resources.toString(resource, Charsets.UTF_8); <line6> job.setDefinition(new CpsFlowDefinition(jenkinsFile, true)); <line7> WorkflowRun build = job.scheduleBuild2(0).waitForStart(); <line8> long start = System.currentTimeMillis(); <line9> while (build.isBuilding()) { <line10> List<Map<String, String>> nodes = <line11> get(""/organizations/jenkins/pipelines/p/runs/1/nodes/"", List.class); <line12> if (nodes.size() >= 4) { <line13> Optional<Map<String, String>> optionalMap = findNodeMap(nodes, ""Nested B-1""); <line14> if (optionalMap.isPresent()) { <line15> long now = System.currentTimeMillis(); <line16> if (TimeUnit.SECONDS.convert(now - start, TimeUnit.MILLISECONDS) >= 10) { <line17> continue; <line18> } <line19> assertEquals( <line20> build.isBuilding() <line21> ? BlueRun.BlueRunState.RUNNING.name() <line22> : BlueRun.BlueRunState.FINISHED, <line23> optionalMap.get().get(""state"")); <line24> } <line25> } <line26> Thread.sleep(500); <line27> } <line28> List<Map<String, String>> nodes = <line29> get(""/organizations/jenkins/pipelines/p/runs/1/nodes/"", List.class); <line30> Optional<Map<String, String>> optionalMap = findNodeMap(nodes, ""Nested B-1""); <line31> if (optionalMap.isPresent()) { <line32> assertEquals(BlueRun.BlueRunState.FINISHED.name(), optionalMap.get().get(""state"")); <line33> } <line34> j.assertBuildStatus(Result.SUCCESS, build); <line35> } <line36> } <line37> "	"<line19>          LOGGER.debug(""optionalMap: {}"", optionalMap);"	task4	
public class A { <line0> @Override <line1> public List<Path> run(final Session<?> session) throws BackgroundException { <line2> final Restore feature = session.getFeature(Restore.class); <line3> if (log.isDebugEnabled()) { <line4> } <line5> for (Path file : files) { <line6> if (this.isCanceled()) { <line7> throw new ConnectionCanceledException(); <line8> } <line9> feature.restore(file, prompt); <line10> } <line11> return files; <line12> } <line13> } <line14> 	"<line4>      log.debug(String.format(""Run with feature %s"", feature));"	task4	
"public class A { <line0> @AcceptsPreStepAuth <line1> @GET <line2> @Path(""/consents/{consentId}/status"") <line3> public Response getConsentStatus(@NotEmpty @NotBlank @PathParam(""consentId"") String consentId) <line4> throws BankRequestFailedException { <line5> XS2AFactoryInput xs2AFactoryInput = new XS2AFactoryInput(); <line6> xs2AFactoryInput.setConsentId(consentId); <line7> IOProcessor ioProcessor = new IOProcessor(getXS2AStandard()); <line8> ioProcessor.modifyInput(xs2AFactoryInput); <line9> AISRequest request = <line10> new AISRequestFactory() <line11> .create(getXS2AStandard().getRequestClassProvider().consentStatus(), xs2AFactoryInput); <line12> request.getHeaders().putAll(getAdditionalHeaders()); <line13> ioProcessor.modifyRequest(request, xs2AFactoryInput); <line14> ConsentStatus state = getXS2AStandard().getCs().getStatus(request); <line15> GetConsentStatusResponse response = new GetConsentStatusResponse(state); <line16> return Response.status(ResponseConstant.OK).entity(response).build(); <line17> } <line18> } <line19> "	"<line16>    LOG.info(""Successfully fetched consent status entity for bic={}, consentId={}"",getXS2AStandard().getAspsp().getBic(),consentId);"	task4	
"public class A { <line0> @Override <line1> public void init(FilterConfig filterConfig) throws ServletException { <line2> super.init(filterConfig); <line3> forwardPath = filterConfig.getInitParameter(""forwardPath""); <line4> displayPath = filterConfig.getInitParameter(""displayPath""); <line5> } <line6> } <line7> "	"<line5>    logger.debug(""CatchAllFilter [""+ displayPath+ ""] received provided allowed context paths from NiFi properties: ""+ getAllowedContextPaths());"	task4	
"public class A { <line0> public static Map<String, List<Trip>> getTripsByBlockInSortedOrder(GtfsMutableRelationalDao dao) { <line1> Map<String, List<Trip>> tripsByBlockId = new HashMap<String, List<Trip>>(); <line2> Map<Trip, Integer> averageStopTimeByTrip = new HashMap<Trip, Integer>(); <line3> int totalTrips = 0; <line4> int tripsWithoutStopTimes = 0; <line5> for (Trip trip : dao.getAllTrips()) { <line6> totalTrips++; <line7> String blockId = trip.getBlockId(); <line8> if (blockId == null) blockId = trip.getId() + ""-"" + Math.random(); <line9> List<Trip> trips = tripsByBlockId.get(blockId); <line10> if (trips == null) { <line11> trips = new ArrayList<Trip>(); <line12> tripsByBlockId.put(blockId, trips); <line13> } <line14> trips.add(trip); <line15> List<StopTime> stopTimes = dao.getStopTimesForTrip(trip); <line16> if (stopTimes.isEmpty()) { <line17> tripsWithoutStopTimes++; <line18> } else { <line19> int arrivalTimes = 0; <line20> int arrivalTimeCount = 0; <line21> for (StopTime stopTime : stopTimes) { <line22> if (stopTime.isArrivalTimeSet()) { <line23> arrivalTimes += stopTime.getArrivalTime(); <line24> arrivalTimeCount++; <line25> } <line26> } <line27> if (arrivalTimeCount > 0) { <line28> int averageArrivalTime = arrivalTimes / arrivalTimeCount; <line29> averageStopTimeByTrip.put(trip, averageArrivalTime); <line30> } <line31> } <line32> } <line33> TripComparator c = new TripComparator(averageStopTimeByTrip); <line34> for (List<Trip> tripsInBlock : tripsByBlockId.values()) { <line35> Collections.sort(tripsInBlock, c); <line36> } <line37> return tripsByBlockId; <line38> } <line39> } <line40> "	"<line33>    log.info(""trips="" + totalTrips + "" withoutStopTimes="" + tripsWithoutStopTimes);"	task4	
public class A { <line0> @Test <line1> public void testClientClosure() throws Exception { <line2> for (int i = 0; i < NODES_CNT; i++) { <line3> Ignite ignite = grid(i); <line4> Collection<String> res = <line5> ignite <line6> .compute(ignite.cluster().forClients()) <line7> .broadcast( <line8> new IgniteCallable<String>() { <line9> @IgniteInstanceResource Ignite ignite; <line10>  <line11> @Override <line12> public String call() throws Exception { <line13> assertTrue(ignite.configuration().isClientMode()); <line14> return ignite.name(); <line15> } <line16> }); <line17> assertEquals(1, res.size()); <line18> assertEquals(getTestIgniteInstanceName(CLIENT_IDX), F.first(res)); <line19> } <line20> } <line21> } <line22> 	"<line3>      log.info(""Iteration: "" + i);"	task4	
"public class A { <line0> private Promise<NetconfClientSession> doActivate( <line1> final Channel ch, final NetconfClientSessionListener listener) { <line2> final Promise<NetconfClientSession> activationPromise = newSessionPromise(); <line3> if (activated.compareAndExchange(false, true)) { <line4> return activationPromise.setFailure( <line5> new IllegalStateException(""Session (channel) already activated."")); <line6> } <line7> final NetconfClientSessionNegotiatorFactory negotiatorFactory = <line8> new NetconfClientSessionNegotiatorFactory( <line9> new HashedWheelTimer(), Optional.empty(), TimeUnit.SECONDS.toMillis(5)); <line10> final TlsClientChannelInitializer tlsClientChannelInitializer = <line11> new TlsClientChannelInitializer(sslHandlerFactory, negotiatorFactory, listener); <line12> tlsClientChannelInitializer.initialize(ch, activationPromise); <line13> return activationPromise; <line14> } <line15> } <line16> "	"<line7>    LOG.info(""Activating Netconf channel for {} with {}"", getRemoteAddress(), listener);"	task4	
public class A { <line0> @Override <line1> public ScriptEngineManager call() { <line2> long start = System.currentTimeMillis(); <line3> try { <line4> return new ScriptEngineManager(); <line5> } finally { <line6> long end = System.currentTimeMillis(); <line7> } <line8> } <line9> } <line10> 	"<line7>      LOG.info(ScriptEngineManager.class.getName() + "" initialized in "" + (end - start) + "" ms"");"	task4	
public class A { <line0> @Override <line1> public void audit(String message, Supplier... paramSuppliers) { <line2> StringBuilder messageBuilder = new StringBuilder(); <line3> requestIpAndPortAndUserMessage(PhaseInterceptorChain.getCurrentMessage(), messageBuilder); <line4> } <line5> } <line6> 	<line4>    LOGGER.info(messageBuilder.append(cleanAndEncode(message)).toString(), paramSuppliers);	task4	
public class A { <line0> public int getGIFHeight() { <line1> if (myCustomHeightField.isEnabled()) { <line2> try { <line3> Integer value = (Integer) myFormatter.stringToValue(myCustomHeightField.getText()); <line4> return value.intValue(); <line5> } catch (ParseException e) { <line6> } <line7> } <line8> return myHeight; <line9> } <line10> } <line11> 	"<line6>        LOGGER.error(""Unable to parse custom height value: "" + e.getMessage());"	task4	
public class A { <line0> public void close() { <line1> try { <line2> client.close(); <line3> } catch (IOException ex) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.warn(""Failed to close Kie Server Controller Client due to: "" + ex.getMessage(), ex);"	task4	
"public class A { <line0> public static com.liferay.mobile.device.rules.model.MDRRule addRule( <line1> HttpPrincipal httpPrincipal, <line2> long ruleGroupId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> java.util.Map<java.util.Locale, String> descriptionMap, <line5> String type, <line6> String typeSettings, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(MDRRuleServiceUtil.class, ""addRule"", _addRuleParameterTypes0); <line12> MethodHandler methodHandler = <line13> new MethodHandler( <line14> methodKey, ruleGroupId, nameMap, descriptionMap, type, typeSettings, serviceContext); <line15> Object returnObj = null; <line16> try { <line17> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line18> } catch (Exception exception) { <line19> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line20> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line21> } <line22> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line23> } <line24> return (com.liferay.mobile.device.rules.model.MDRRule) returnObj; <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> throw systemException; <line27> } <line28> } <line29> } <line30> "	<line26>      log.error(systemException, systemException);	task4	
public class A { <line0> private void removePauseQueueMessage(MessageQueue messageQueue, List<MessageExt> messages) { <line1> if (null != messageQueuesStateMap.get(messageQueue)) { <line2> final Iterator<MessageExt> iterator = messages.iterator(); <line3> while (iterator.hasNext()) { <line4> final MessageExt message = iterator.next(); <line5> String msgId = message.getMsgId(); <line6> iterator.remove(); <line7> } <line8> } <line9> } <line10> } <line11> 	"<line6>        log.info(""BrokerName {}, topicName {}, queueId {} is pause, Discard the message {}"",messageQueue.getBrokerName(),messageQueue.getTopic(),message.getQueueId(),msgId);"	task4	
public class A { <line0> public void start() throws Exception { <line1> Objects.nonNull(config); <line2> this.client = <line3> com.basho.riak.client.api.RiakClient.newClient( <line4> config.getPort().intValue(), config.getHosts()); <line5> Objects.nonNull(client); <line6> Objects.nonNull(client.getRiakCluster()); <line7> assert (client.getRiakCluster().getNodes().size() > 0); <line8> } <line9> } <line10> 	"<line2>    LOGGER.info(""RiakHttpClient.start {}"", config);"	task4	
public class A { <line0> @Override <line1> public Double visit(LessThanFilter lessThanFilter) { <line2> int minBound = <line3> 9 <line4> - IntStream.rangeClosed(0, 9) <line5> .filter(i -> percentiles[9 - i] < lessThanFilter.getValue().doubleValue()) <line6> .findFirst() <line7> .orElse(0); <line8> final double result = ((double) minBound + 1.0) / 10.0; <line9> return result; <line10> } <line11> } <line12> 	"<line9>    log.debug(""cacheKey:{} LessThanFilter:{} percentiles[{}] = {} multiplier: {}"",cacheKey,lessThanFilter,minBound,percentiles[minBound],result);"	task4	
"public class A { <line0> @Override <line1> public List<SessionMatchSpec> get() { <line2> checkState(!destroyed.get(), ""provider already destroyed""); <line3> try { <line4> sessionMatchSpecs.set(dao.getSessionMatchSpecs()); <line5> } catch (RuntimeException e) { <line6> } <line7> return ImmutableList.copyOf(this.sessionMatchSpecs.get()); <line8> } <line9> } <line10> "	"<line6>      log.error(e, ""Error reloading configuration"");"	task4	
public class A { <line0> public static <T> T jaxbClone(T jaxbObject, Class<T> target) { <line1> if (jaxbObject != null) { <line2> try { <line3> ByteArrayOutputStream output = new ByteArrayOutputStream(); <line4> writeXMLObject(jaxbObject, output); <line5> return readXMLObject(new ByteArrayInputStream(output.toByteArray()), target); <line6> } catch (JAXBException e) { <line7> } <line8> } <line9> return jaxbObject; <line10> } <line11> } <line12> 	<line7>        LOGGER.error(e, e);	task4	
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap <line1> addCommerceInventoryWarehouse( <line2> String externalReferenceCode, <line3> String name, <line4> String description, <line5> boolean active, <line6> String street1, <line7> String street2, <line8> String street3, <line9> String city, <line10> String zip, <line11> String commerceRegionCode, <line12> String commerceCountryCode, <line13> double latitude, <line14> double longitude, <line15> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line16> throws RemoteException { <line17> try { <line18> com.liferay.commerce.inventory.model.CommerceInventoryWarehouse returnValue = <line19> CommerceInventoryWarehouseServiceUtil.addCommerceInventoryWarehouse( <line20> externalReferenceCode, <line21> name, <line22> description, <line23> active, <line24> street1, <line25> street2, <line26> street3, <line27> city, <line28> zip, <line29> commerceRegionCode, <line30> commerceCountryCode, <line31> latitude, <line32> longitude, <line33> serviceContext); <line34> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap.toSoapModel( <line35> returnValue); <line36> } catch (Exception exception) { <line37> throw new RemoteException(exception.getMessage()); <line38> } <line39> } <line40> } <line41> 	<line37>      log.error(exception, exception);	task4	
"public class A { <line0> private void stop(final boolean sendDisconnect, final TransportError reason) { <line1> if (initialConnectTimer != null) { <line2> initialConnectTimer.cancel(); <line3> } <line4> if (degradeToUnitialized()) { <line5> setState(BusState.UNINITIALIZED); <line6> deferredMessages.clear(); <line7> remotes.clear(); <line8> deferredSubscriptions.clear(); <line9> } else if (state != BusState.LOCAL_ONLY) { <line10> setState(BusState.LOCAL_ONLY, reason); <line11> } <line12> if (sendDisconnect && isRemoteCommunicationEnabled()) { <line13> encodeAndTransmit( <line14> CommandMessage.create() <line15> .toSubject(BuiltInServices.ServerBus.name()) <line16> .command(BusCommand.Disconnect) <line17> .set(MessageParts.PriorityProcessing, ""1"")); <line18> } <line19> deferredMessages.addAll(transportHandler.stop(true)); <line20> } <line21> } <line22> "	"<line1>    logger.info(""stopping bus ..."");"	task4	
"public class A { <line0> private InvitationParam getInvitationFromJson(String jsonInvitation) <line1> throws WrongArgumentException { <line2> ObjectNode invNode = JsonUtil.parse(jsonInvitation); <line3> JsonNode itype = invNode.get(""type""); <line4> InvitationType type = null; <line5> if (itype == null) { <line6> type = InvitationType.REGISTRATION; <line7> } else { <line8> type = InvitationType.valueOf(invNode.get(""type"").asText()); <line9> } <line10> if (type.equals(InvitationType.REGISTRATION)) { <line11> return new RegistrationInvitationParam(invNode); <line12> } else { <line13> return new EnquiryInvitationParam(invNode); <line14> } <line15> } <line16> } <line17> "	"<line7>      log.debug(""Use default invitation type = "" + InvitationType.REGISTRATION.toString());"	task4	
public class A { <line0> private BaseQueryImpl<?> parse(CriteriaBuilderImpl cb) { <line1> final CommonTree tree = this.parse(this.qlString); <line2> return this.construct(cb, tree); <line3> } <line4> } <line5> 	"<line2>    JpqlQuery.LOG.debug(""Parsed query successfully {0}"",JpqlQuery.LOG.lazyBoxed(this.qlString, new Object[] {tree.toStringTree()}));"	task4	
public class A { <line0> void closeInternal(long lastWriteTime, boolean explicit) throws CIFSException { <line1> SmbTreeHandleImpl t = this.tree; <line2> try { <line3> if (t != null && isValid()) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> if (t.isSMB2()) { <line7> Smb2CloseRequest req = new Smb2CloseRequest(this.cfg, this.fileId); <line8> t.send(req, RequestParam.NO_RETRY); <line9> } else { <line10> t.send( <line11> new SmbComClose(this.cfg, this.fid, lastWriteTime), <line12> new SmbComBlankResponse(this.cfg), <line13> RequestParam.NO_RETRY); <line14> } <line15> } <line16> } finally { <line17> this.open = false; <line18> if (t != null) { <line19> t.release(); <line20> } <line21> this.tree = null; <line22> } <line23> } <line24> } <line25> 	"<line5>          log.debug(""Closing file handle "" + this);"	task4	
"public class A { <line0> public FileStatus[] listFileStatus(String filePath) throws Exception { <line1> try { <line2> return fs.listStatus(new Path(filePath)); <line3> } catch (IOException e) { <line4> throw new Exception(""Get file list exception"", e); <line5> } <line6> } <line7> } <line8> "	"<line4>      logger.error(""Get file list exception"", e);"	task4	
"public class A { <line0> @Override <line1> public DDMDataProviderResponse getData(DDMDataProviderRequest ddmDataProviderRequest) { <line2> Optional<Long> dataProviderInstanceIdOptional = <line3> ddmDataProviderRequest.getParameterOptional(""dataProviderInstanceId"", String.class); <line4> long dataProviderInstanceId = 0; <line5> if (dataProviderInstanceIdOptional.isPresent()) { <line6> dataProviderInstanceId = GetterUtil.getLong(dataProviderInstanceIdOptional.get()); <line7> } <line8> DDMDataProviderResponse.Builder builder = DDMDataProviderResponse.Builder.newBuilder(); <line9> List<KeyValuePair> keyValuePairs = new ArrayList<>(); <line10> if (dataProviderInstanceId == 0) { <line11> return builder.withOutput(""outputParameterNames"", keyValuePairs).build(); <line12> } <line13> try { <line14> DDMDataProviderOutputParametersSettings[] ddmDataProviderOutputParametersSettings = <line15> getDDMDataProviderOutputParametersSettings(dataProviderInstanceId); <line16> for (DDMDataProviderOutputParametersSettings ddmDataProviderOutputParametersSetting : <line17> ddmDataProviderOutputParametersSettings) { <line18> keyValuePairs.add( <line19> new KeyValuePair( <line20> ddmDataProviderOutputParametersSetting.outputParameterId(), <line21> ddmDataProviderOutputParametersSetting.outputParameterName())); <line22> } <line23> } catch (Exception exception) { <line24> } <line25> return builder.withOutput(""outputParameterNames"", keyValuePairs).build(); <line26> } <line27> } <line28> "	"<line24>      log.error(String.format(""Unable to get the output parameters for data provider "" + ""instance with id '%d'"",dataProviderInstanceId),exception);"	task4	
public class A { <line0> @Override <line1> public String encryptAsymmetric(final String secret) { <line2> if (isEncrypted(secret)) { <line3> return secret; <line4> } <line5> if (secret.length() > 230) { <line6> return secret; <line7> } <line8> if (kmsKeyArn == null) { <line9> return secret; <line10> } <line11> String tmp = secret; <line12> if (isToBeEncrypted(secret)) { <line13> tmp = secret.substring(2, secret.length() - 2); <line14> } <line15> try { <line16> EncryptRequest req = <line17> new EncryptRequest() <line18> .withKeyId(kmsKeyArn) <line19> .withEncryptionAlgorithm(ASYMMETRIC_ALGORITHM) <line20> .withPlaintext(ByteBuffer.wrap(tmp.getBytes())); <line21> ByteBuffer plainText = kmsClient.encrypt(req).getCiphertextBlob(); <line22> return TO_DECRYPT_PREFIX <line23> + Base64.getEncoder().encodeToString(plainText.array()) <line24> + TO_DECRYPT_POSTFIX; <line25> } catch (RuntimeException e) { <line26> } <line27> return secret; <line28> } <line29> } <line30> 	"<line26>      logger.error(""Error when trying to encrypt using asymmetric key. Please check the following:\n""+ ""\t- Does the application use an IAM role?\n""+ ""\t- Does the application's role have the permission to use the CMK the value was""+ "" encrypted with?\n""+ ""More information on that topic:""+ "" https://confluence.in.here.com/display/CMECMCPDOWS/Encryption+of+secrets"",e);"	task4	
"public class A { <line0> @Override <line1> protected void setUp() throws Exception { <line2> if (broker == null) { <line3> broker = createBroker(bindAddress); <line4> } <line5> factory = createConnectionFactory(bindAddress); <line6> managementConnection = factory.createConnection(); <line7> managementSession = managementConnection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line8> Destination startDestination = createDestination(managementSession, getClass() + "".start""); <line9> Destination endDestination = createDestination(managementSession, getClass() + "".end""); <line10> controller = new LoadController(""Controller"", factory); <line11> controller.setBatchSize(batchSize); <line12> controller.setNumberOfBatches(numberOfBatches); <line13> controller.setDeliveryMode(deliveryMode); <line14> controller.setConnectionPerMessage(connectionPerMessage); <line15> controller.setStartDestination(startDestination); <line16> controller.setNextDestination(endDestination); <line17> controller.setTimeout(timeout); <line18> clients = new LoadClient[numberOfClients]; <line19> for (int i = 0; i < numberOfClients; i++) { <line20> Destination inDestination = null; <line21> if (i == 0) { <line22> inDestination = startDestination; <line23> } else { <line24> inDestination = createDestination(managementSession, getClass() + "".client."" + (i)); <line25> } <line26> Destination outDestination = null; <line27> if (i == (numberOfClients - 1)) { <line28> outDestination = endDestination; <line29> } else { <line30> outDestination = createDestination(managementSession, getClass() + "".client."" + (i + 1)); <line31> } <line32> LoadClient client = new LoadClient(""client("" + i + "")"", factory); <line33> client.setTimeout(timeout); <line34> client.setDeliveryMode(deliveryMode); <line35> client.setConnectionPerMessage(connectionPerMessage); <line36> client.setStartDestination(inDestination); <line37> client.setNextDestination(outDestination); <line38> clients[i] = client; <line39> } <line40> super.setUp(); <line41> } <line42> } <line43> "	"<line10>    LOG.info(""Running with ""+ numberOfClients+ "" clients - sending ""+ numberOfBatches+ "" batches of ""+ batchSize+ "" messages"");"	task4	
public class A { <line0> protected void executeSilently(String sql) { <line1> try { <line2> jdbcTemplate.execute(sql); <line3> } catch (BadSqlGrammarException ex) { <line4> } <line5> } <line6> } <line7> 	<line4>      log.debug(ex.getMessage());	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Thread.sleep(1000); <line4> long timeout = 10000L; <line5> long startTms = System.currentTimeMillis(); <line6> while (System.currentTimeMillis() - startTms < timeout) { <line7> if (receiver.count < testNum * 3) { <line8> Thread.sleep(10); <line9> } else { <line10> break; <line11> } <line12> } <line13> } catch (InterruptedException ex) { <line14> DTThrowable.rethrow(ex); <line15> } finally { <line16> lc.shutdown(); <line17> try { <line18> Thread.sleep(1000); <line19> } catch (InterruptedException e) { <line20> DTThrowable.rethrow(e); <line21> } finally { <line22> t.interrupt(); <line23> receiver.teardown(); <line24> } <line25> } <line26> } <line27> } <line28> 	"<line16>      logger.debug(""done..."");"	task4	
"public class A { <line0> @POST <line1> @Path(""/reports/{report-id}/share"") <line2> public void shareReport( <line3> HttpServiceRequest request, <line4> HttpServiceResponder responder, <line5> @PathParam(""report-id"") String reportId) { <line6> Location reportIdDir; <line7> try { <line8> String userName = getUserName(request.getAllHeaders()); <line9> reportIdDir = <line10> getDatasetBaseLocation(ReportGenerationApp.REPORT_FILESET) <line11> .append(userName) <line12> .append(reportId); <line13> if (!reportIdDir.exists()) { <line14> responder.sendError( <line15> 404, String.format(""Invalid report-id %s, report does not exist"", reportId)); <line16> return; <line17> } <line18> String shareId = encodeShareId(new ReportIdentifier(userName, reportId)); <line19> responder.sendJson(200, new ShareId(shareId), ShareId.class, GSON); <line20> } catch (IOException | GeneralSecurityException e) { <line21> responder.sendError( <line22> 500, <line23> String.format( <line24> ""Failed to read report with id %s because of error: %s"", reportId, e.getMessage())); <line25> return; <line26> } <line27> } <line28> } <line29> "	"<line21>      LOG.error(""Failed to read report with id {}"", reportId, e);"	task4	
"public class A { <line0> public Object evaluateKey(Object object) { <line1> Object value = object; <line2> ExecutionContext newContext = null; <line3> Object key = null; <line4> try { <line5> if (object instanceof RegionEntry) { <line6> RegionEntry regionEntry = (RegionEntry) object; <line7> newContext = createExecutionContext(regionEntry); <line8> value = getTargetObjectForUpdate(regionEntry); <line9> } <line10> List iterators = newContext.getCurrentIterators(); <line11> RuntimeIterator itr = (RuntimeIterator) iterators.get(0); <line12> itr.setCurrent(value); <line13> key = this.indexedExpr.evaluate(newContext); <line14> } catch (Exception e) { <line15> if (logger.isDebugEnabled()) { <line16> } <line17> throw new Error(""Could not reevaluate key for hash index"", e); <line18> } <line19> if (key == null) { <line20> key = IndexManager.NULL; <line21> } <line22> return key; <line23> } <line24> } <line25> "	"<line16>        logger.debug(""Could not reevaluate key for hash index"");"	task4	
"public class A { <line0> public void testInducedFailureOn1pc() throws Exception { <line1> extractInterceptorChain(cache(1)).addInterceptor(new FailInterceptor(), 1); <line2> tm(0).begin(); <line3> cache(0).put(""k"", ""v""); <line4> try { <line5> tm(0).commit(); <line6> assert false : ""Exception expected""; <line7> } catch (Exception e) { <line8> } <line9> fail = false; <line10> assertExpectedState(0); <line11> assertExpectedState(1); <line12> assertExpectedState(2); <line13> } <line14> } <line15> "	"<line8>      log.debug(""Ignoring expected exception during 1-phase prepare"", e);"	task4	
"public class A { <line0> public static void loadBitstreamFormats(Context context, String filename) <line1> throws SQLException, IOException, ParserConfigurationException, SAXException, <line2> TransformerException, AuthorizeException { <line3> Document document = loadXML(filename); <line4> NodeList typeNodes = XPathAPI.selectNodeList(document, ""dspace-bitstream-types/bitstream-type""); <line5> for (int i = 0; i < typeNodes.getLength(); i++) { <line6> Node n = typeNodes.item(i); <line7> loadFormat(context, n); <line8> } <line9> } <line10> } <line11> "	"<line9>    log.info(LogManager.getHeader(context, ""load_bitstream_formats"", ""number_loaded="" + typeNodes.getLength()));"	task4	
public class A { <line0> public ID menuKeyEquivalentTarget_forEvent(NSMenu menu, NSEvent event) { <line1> if (log.isTraceEnabled()) { <line2> } <line3> return this.getTarget(); <line4> } <line5> } <line6> 	"<line2>      log.trace(""menuKeyEquivalentTarget_forEvent:"" + menu);"	task4	
public class A { <line0> @Override <line1> protected void submitWith(HapiApiSpec spec, Transaction payment) throws Throwable { <line2> Query query = getContractRecordsQuery(spec, payment, false); <line3> response = <line4> spec.clients().getScSvcStub(targetNodeFor(spec), useTls).getTxRecordByContractID(query); <line5> List<TransactionRecord> records = response.getContractGetRecordsResponse().getRecordsList(); <line6> if (verboseLoggingOn) { <line7> if (customLog.isPresent()) { <line8> customLog.get().accept(log, records); <line9> } else { <line10> } <line11> } <line12> if (snapshotDirPath.isPresent()) { <line13> saveSnapshots(spec, records); <line14> } <line15> if (saveRecordNum.isPresent()) { <line16> spec.registry().saveIntValue(saveRecordNum.get(), records.size()); <line17> } <line18> if (expectationsDirPath.isPresent()) { <line19> checkExpectations(spec, records); <line20> } <line21> } <line22> } <line23> 	<line10>        log.info(records);	task4	
"public class A { <line0> @Test <line1> public void testReaderRead() throws Exception { <line2> BeanConfig config = new BeanConfig(); <line3> config.setHost(""localhost:8080""); <line4> config.setSchemes(new String[] {""http""}); <line5> config.setBasePath(""/api""); <line6> config.setTitle(""Day""); <line7> config.setLicense(""Apache 2.0""); <line8> config.setLicenseUrl(""http://www.apache.org/licenses/LICENSE-2.0.html""); <line9> config.setVersion(""2.0""); <line10> RestOpenApiReader reader = new RestOpenApiReader(); <line11> OasDocument openApi = <line12> reader.read( <line13> context, <line14> context.getRestDefinitions(), <line15> null, <line16> config, <line17> context.getName(), <line18> new DefaultClassResolver()); <line19> assertNotNull(openApi); <line20> ObjectMapper mapper = new ObjectMapper(); <line21> mapper.enable(SerializationFeature.INDENT_OUTPUT); <line22> mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); <line23> Object dump = Library.writeNode(openApi); <line24> String json = mapper.writeValueAsString(dump); <line25> assertTrue(json.contains(""\""host\"" : \""localhost:8080\"""")); <line26> assertTrue(json.contains(""\""default\"" : \""friday\"""")); <line27> assertTrue( <line28> json.contains( <line29> ""\""enum\"" : [ \""monday\"", \""tuesday\"", \""wednesday\"", \""thursday\"", \""friday\"" ]"")); <line30> assertTrue(json.contains(""\""$ref\"" : \""#/definitions/DayResponse\"""")); <line31> assertTrue(json.contains(""\""format\"" : \""org.apache.camel.openapi.DayResponse\"""")); <line32> assertTrue(json.contains(""\""X-Rate-Limit-Limit\"" : {"")); <line33> assertTrue( <line34> json.contains( <line35> ""\""description\"" : \""The number of allowed requests in the current period\"""")); <line36> context.stop(); <line37> } <line38> } <line39> "	<line25>    log.info(json);	task4	
public class A { <line0> public void testBoundaryValueVar32() { <line1> int boundSize = 0; <line2> for (int i = 0; i < Integer.MAX_VALUE; i++) { <line3> final int size = BytesUtils.computeVar32Size(i); <line4> if (size > boundSize) { <line5> boundSize = size; <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        logger.debug(""bound {}->{}"", boundSize, i);"	task4	
"public class A { <line0> @Override <line1> public Object doInTransaction(TransactionStatus status) { <line2> executorService.submit( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> try { <line7> jdbcTemplate.update(""DELETE FROM auth WHERE auth LIKE 'SSO %' AND object_type=9""); <line8> jobsAdded.incrementAndGet(); <line9> } catch (RuntimeException e) { <line10> } <line11> } <line12> }); <line13> return null; <line14> } <line15> } <line16> "	"<line10>              LOGGER.error(""Failed to delete SSO auth lines from auth index table"", e);"	task4	
public class A { <line0> @Override <line1> public void getUserLists(final long listOwnerUserId) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(USER_LISTS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> ResponseList<UserList> lists = twitter.getUserLists(listOwnerUserId); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotUserLists(lists); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at getUserLists"", e);"	task4	
"public class A { <line0> @Override <line1> public void save(Note note, AuthenticationInfo subject) throws IOException { <line2> if (note == null || !isSubjectValid(subject)) { <line3> throw new IOException(""Zeppelinhub failed to save note""); <line4> } <line5> String jsonNote = GSON.toJson(note); <line6> String token = getUserToken(subject.getUser()); <line7> restApiClient.put(token, jsonNote); <line8> } <line9> } <line10> "	"<line7>    LOG.info(""ZeppelinHub REST API saving note {} "", note.getId());"	task4	
public class A { <line0> private static boolean initLOG4JXml(String homeDir) { <line1> String Log4jURL = homeDir + LOG4J_URL_XML; <line2> try { <line3> URL log4jurl = getURL(Log4jURL); <line4> DOMConfigurator.configure(log4jurl); <line5> } catch (Exception e) { <line6> return false; <line7> } <line8> return true; <line9> } <line10> } <line11> 	"<line6>      logger.info(""Failed to initialize LOG4J with xml file."");"	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.LayoutSoap fetchLayout( <line1> long groupId, boolean privateLayout, long layoutId) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Layout returnValue = <line4> LayoutServiceUtil.fetchLayout(groupId, privateLayout, layoutId); <line5> return com.liferay.portal.kernel.model.LayoutSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
"public class A { <line0> private synchronized void selectReader() throws IOException { <line1> if (lastMarker == null) { <line2> String query = String.format(""?limit=%d"", pagingSize); <line3> final HttpGet request = httpHelper.getRequestFactory().get(formatPath(path) + query); <line4> try { <line5> if (currentResponse != null) { <line6> currentResponse.close(); <line7> } <line8> } catch (IOException e) { <line9> MantaIOException mio = new MantaIOException(e); <line10> HttpHelper.annotateContextedException(mio, request, currentResponse); <line11> throw mio; <line12> } <line13> currentResponse = httpHelper.executeRequest(request, null); <line14> HttpEntity entity = currentResponse.getEntity(); <line15> String contentType; <line16> if (entity.getContentType() != null) { <line17> contentType = entity.getContentType().getValue(); <line18> } else { <line19> contentType = null; <line20> } <line21> if (!DIRECTORY_RESPONSE_CONTENT_TYPE.equals(contentType)) { <line22> String msg = <line23> ""A file was specified as the directory list path. "" <line24> + ""Only the contents of directories can be listed.""; <line25> MantaUnexpectedObjectTypeException e = <line26> new MantaUnexpectedObjectTypeException(msg, ObjectType.DIRECTORY, ObjectType.FILE); <line27> e.setContextValue(""path"", path); <line28> try { <line29> MantaHttpHeaders headers = new MantaHttpHeaders(currentResponse.getAllHeaders()); <line30> e.setResponseHeaders(headers); <line31> } catch (RuntimeException re) { <line32> } <line33> throw e; <line34> } <line35> InputStream contentStream = entity.getContent(); <line36> Objects.requireNonNull( <line37> contentStream, ""A directory listing without "" + ""content is not valid. Content is null.""); <line38> Reader streamReader = <line39> new InputStreamReader(entity.getContent(), StandardCharsets.UTF_8.name()); <line40> br = new BufferedReader(streamReader); <line41> } else { <line42> String query = <line43> String.format(""?limit=%d&marker=%s"", pagingSize, URLEncoder.encode(lastMarker, ""UTF-8"")); <line44> final HttpGet request = httpHelper.getRequestFactory().get(formatPath(path) + query); <line45> closeResources(); <line46> currentResponse = httpHelper.executeRequest(request, null); <line47> HttpEntity entity = currentResponse.getEntity(); <line48> Reader streamReader = <line49> new InputStreamReader(entity.getContent(), StandardCharsets.UTF_8.name()); <line50> br = new BufferedReader(streamReader); <line51> br.readLine(); <line52> } <line53> Header resultsHeader = currentResponse.getFirstHeader(MantaHttpHeaders.RESULT_SET_SIZE); <line54> if (resultsHeader != null) { <line55> String results = resultsHeader.getValue(); <line56> if (results.equals(""0"")) { <line57> finished.set(true); <line58> return; <line59> } <line60> } <line61> nextLine.set(br.readLine()); <line62> lines.incrementAndGet(); <line63> finished.set(nextLine.get() == null); <line64> } <line65> } <line66> "	"<line32>          LOG.warn(""Unable to convert response headers to MantaHttpHeaders"", e);"	task4	
public class A { <line0> @Override <line1> public void removeProcedureForOffering(String offering, String procedure) { <line2> CacheValidation.notNullOrEmpty(OFFERING, offering); <line3> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line4> this.proceduresForOfferings.getOrDefault(offering, Collections.emptySet()).remove(procedure); <line5> } <line6> } <line7> 	"<line4>    LOG.trace(""Removing procedure {} from offering {}"", procedure, offering);"	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Transfer""}, <line2> description = ""missing column min_transfer_time"", <line3> priority = 217) <line4> public void verifyTest_2_4_1() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""transfer_4_1"", GTFS_1_GTFS_Common_15, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 5, ""detail count""); <line10> int i = 2; <line11> for (CheckPointErrorReport detail : getDetails(context, result)) { <line12> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line13> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line14> Assert.assertEquals( <line15> detail.getSource().getFile().getFilename(), <line16> ""transfers.txt"", <line17> ""detail must refer bad file""); <line18> Assert.assertEquals( <line19> detail.getSource().getFile().getLineNumber(), <line20> Integer.valueOf(i++), <line21> ""detail must refer bad line""); <line22> } <line23> } <line24> } <line25> "	"<line5>    log.info(Color.GREEN + ""Transfer_4_1 : missing column min_transfer_time"" + Color.NORMAL);"	task4	
"public class A { <line0> public void addNewTenantPartitions( <line1> Collection<Table> tables, <line2> Map<String, PartitionInfo> partitionInfoMap, <line3> int newTenantId, <line4> String tablespaceName) { <line5> int poolSize = connectionProvider.getPoolSize(); <line6> if (poolSize == -1) { <line7> poolSize = 40; <line8> } <line9> final ExecutorService pool = Executors.newFixedThreadPool(poolSize); <line10> final AtomicInteger taskCount = new AtomicInteger(); <line11> for (Table t : tables) { <line12> String qualifiedName = t.getQualifiedName(); <line13> PartitionInfo pi = partitionInfoMap.get(t.getObjectName()); <line14> if (pi == null) { <line15> throw new DataAccessException(""No partition information found for table: "" + qualifiedName); <line16> } else { <line17> taskCount.incrementAndGet(); <line18> pool.submit( <line19> new Runnable() { <line20> @Override <line21> public void run() { <line22> try { <line23> createTenantPartitionsThr(t, pi, newTenantId, tablespaceName); <line24> } catch (Throwable x) { <line25> logger.log(Level.SEVERE, ""tenant creation failed: "" + t.getName(), x); <line26> } finally { <line27> taskCount.decrementAndGet(); <line28> } <line29> } <line30> }); <line31> } <line32> } <line33> pool.shutdown(); <line34> try { <line35> while (!pool.isTerminated()) { <line36> pool.awaitTermination(5000, TimeUnit.MILLISECONDS); <line37> } <line38> } catch (InterruptedException x) { <line39> throw new DataAccessException(""Tenant partition creation did not complete""); <line40> } <line41> } <line42> } <line43> "	"<line36>        logger.info(""Waiting for partitioning tasks to complete: "" + taskCount.get());"	task4	
"public class A { <line0> @Override <line1> public void gesvd(INDArray A, INDArray S, INDArray U, INDArray VT) { <line2> if (A.rows() > Integer.MAX_VALUE || A.columns() > Integer.MAX_VALUE) <line3> throw new ND4JArraySizeException(); <line4> int m = (int) A.rows(); <line5> int n = (int) A.columns(); <line6> byte jobu = (byte) (U == null ? 'N' : 'A'); <line7> byte jobvt = (byte) (VT == null ? 'N' : 'A'); <line8> INDArray INFO = <line9> Nd4j.createArrayFromShapeBuffer( <line10> Nd4j.getDataBufferFactory().createInt(1), <line11> Nd4j.getShapeInfoProvider() <line12> .createShapeInformation(new long[] {1, 1}, DataType.INT) <line13> .getFirst()); <line14> if (A.data().dataType() == DataType.DOUBLE) dgesvd(jobu, jobvt, m, n, A, S, U, VT, INFO); <line15> else if (A.data().dataType() == DataType.FLOAT) sgesvd(jobu, jobvt, m, n, A, S, U, VT, INFO); <line16> else throw new UnsupportedOperationException(); <line17> if (INFO.getInt(0) < 0) { <line18> throw new Error(""Parameter #"" + INFO.getInt(0) + "" to gesvd() was not valid""); <line19> } else if (INFO.getInt(0) > 0) { <line20> } <line21> } <line22> } <line23> "	"<line20>      log.warn(""The matrix contains singular elements. Check S matrix at row "" + INFO.getInt(0));"	task4	
public class A { <line0> @Override <line1> public void initialize() { <line2> if (getConfig().get(BAUD_RATE) == null) { <line3> baud = 2400; <line4> } else { <line5> baud = (int) getConfig().get(BAUD_RATE); <line6> } <line7> if (getConfig().get(BUFFER_SIZE) == null) { <line8> bufferSize = 1024; <line9> } else { <line10> bufferSize = (int) getConfig().get(BUFFER_SIZE); <line11> } <line12> port = (String) getConfig().get(PORT); <line13> sleep = 250; <line14> interval = 5000; <line15> super.initialize(); <line16> } <line17> } <line18> 	"<line2>    logger.debug(""Initializing RME handler."");"	task4	
"public class A { <line0> @Test <line1> public void testDeserialize_out() throws Exception { <line2> Optional<? extends RpcDefinition> loadRpc = <line3> ConverterUtils.loadRpc(this.effectiveModelContext, SIMPLE_IO_RPC_QNAME); <line4> String loadIoRpcOut = loadResourceAsString(""input-output-rpc-out.json""); <line5> NormalizedNode<?, ?> deserializeRpc = <line6> bindingSerializer.deserialize(loadRpc.get(), new StringReader(loadIoRpcOut)); <line7> Assert.assertNotNull(deserializeRpc); <line8> } <line9> } <line10> "	<line8>    LOG.info(deserializeRpc.toString());	task4	
public class A { <line0> private void closeConnection() { <line1> if (pollingJob != null && !pollingJob.isCancelled()) { <line2> pollingJob.cancel(true); <line3> pollingJob = null; <line4> } <line5> if (connector != null) { <line6> connector.removeEventListener(this); <line7> connector.disconnect(); <line8> } <line9> } <line10> } <line11> 	"<line1>    logger.debug(""Closing connection to the heat pump"");"	task4	
"public class A { <line0> @POST <line1> @Path(value = ""/report-anomaly/{detectionConfigId}"") <line2> @ApiOperation(""Report a missing anomaly for a detection config"") <line3> public Response createUserAnomaly( <line4> @PathParam(""detectionConfigId"") @ApiParam(value = ""detection config id"") <line5> long detectionConfigId, <line6> @QueryParam(""startTime"") @ApiParam(""start time utc (in millis)"") Long startTime, <line7> @QueryParam(""endTime"") @ApiParam(""end time utc (in millis)"") Long endTime, <line8> @QueryParam(""metricUrn"") @ApiParam(""the metric urn of the anomaly"") String metricUrn, <line9> @QueryParam(""feedbackType"") @ApiParam(""the metric urn of the anomaly"") <line10> AnomalyFeedbackType feedbackType, <line11> @QueryParam(""comment"") @ApiParam(""comments"") String comment, <line12> @QueryParam(""baselineValue"") <line13> @ApiParam(""the baseline value for the anomaly"") <line14> @DefaultValue(""NaN"") <line15> double baselineValue) { <line16> DetectionConfigDTO detectionConfigDTO = this.configDAO.findById(detectionConfigId); <line17> if (detectionConfigDTO == null) { <line18> throw new IllegalArgumentException( <line19> String.format(""Could not resolve detection config id %d"", detectionConfigId)); <line20> } <line21> MergedAnomalyResultDTO anomaly = new MergedAnomalyResultDTO(); <line22> anomaly.setStartTime(startTime); <line23> anomaly.setEndTime(endTime); <line24> anomaly.setDetectionConfigId(detectionConfigId); <line25> anomaly.setAnomalyResultSource(AnomalyResultSource.USER_LABELED_ANOMALY); <line26> anomaly.setProperties(Collections.<String, String>emptyMap()); <line27> MetricEntity me = MetricEntity.fromURN(metricUrn); <line28> MetricConfigDTO metric = this.metricDAO.findById(me.getId()); <line29> DatasetConfigDTO dataset = this.datasetDAO.findByDataset(metric.getDataset()); <line30> anomaly.setMetricUrn(metricUrn); <line31> anomaly.setMetric(metric.getName()); <line32> anomaly.setCollection(dataset.getDataset()); <line33> try { <line34> MetricSlice currentSlice = MetricSlice.from(me.getId(), startTime, endTime, me.getFilters()); <line35> DataFrame df = <line36> this.aggregationLoader.loadAggregate(currentSlice, Collections.<String>emptyList(), -1); <line37> anomaly.setAvgCurrentVal(df.getDouble(DataFrame.COL_VALUE, 0)); <line38> } catch (Exception e) { <line39> anomaly.setAvgCurrentVal(Double.NaN); <line40> } <line41> anomaly.setAvgBaselineVal(baselineValue); <line42> if (this.anomalyDAO.save(anomaly) == null) { <line43> throw new IllegalArgumentException( <line44> String.format(""Could not store user reported anomaly: '%s'"", anomaly)); <line45> } <line46> AnomalyFeedbackDTO feedback = new AnomalyFeedbackDTO(); <line47> feedback.setFeedbackType(feedbackType); <line48> feedback.setComment(comment); <line49> anomaly.setFeedback(feedback); <line50> this.anomalyDAO.updateAnomalyFeedback(anomaly); <line51> return Response.ok(anomaly.getId()).build(); <line52> } <line53> } <line54> "	"<line39>      LOG.warn(""Can't get the current value for {}, from {}-{}"", me.getId(), startTime, endTime, e);"	task4	
"public class A { <line0> @Override <line1> protected void map( <line2> Object k, Object v, Mapper<Object, Object, BytesWritable, Text>.Context context) <line3> throws IOException, InterruptedException { <line4> Counter unparseableReport = context.getCounter(""app"", ""unparseable chunks""); <line5> Text t; <line6> BytesWritable bw; <line7> if (k instanceof ChukwaArchiveKey && v instanceof ChunkImpl) { <line8> ChunkImpl value = (ChunkImpl) v; <line9> Report xtrReport = Report.createFromString(new String(value.getData())); <line10> try { <line11> bw = new BytesWritable(xtrReport.getMetadata().getTaskId().get()); <line12> } catch (Exception e) { <line13> unparseableReport.increment(1); <line14> return; <line15> } <line16> t = new Text(value.getData()); <line17> } else if (k instanceof ChukwaRecordKey && v instanceof ChukwaRecord) { <line18> ChukwaRecord value = (ChukwaRecord) v; <line19> Report xtrReport = Report.createFromString(value.getValue(Record.bodyField)); <line20> bw = new BytesWritable(xtrReport.getMetadata().getTaskId().get()); <line21> t = new Text(value.getValue(Record.bodyField)); <line22> } else { <line23> return; <line24> } <line25> context.write(bw, t); <line26> } <line27> } <line28> "	"<line23>      log.error(""unexpected key/value types: ""+ k.getClass().getCanonicalName()+ "" and ""+ v.getClass().getCanonicalName());"	task4	
public class A { <line0> private boolean thereIsWriteAuthorizationFor(Order order) { <line1> String loginName = SecurityUtils.getSessionUserLoginName(); <line2> try { <line3> User user = userDAO.findByLoginName(loginName); <line4> for (OrderAuthorization authorization : <line5> orderAuthorizationDAO.listByOrderUserAndItsProfiles(order, user)) { <line6> if (authorization.getAuthorizationType() == OrderAuthorizationType.WRITE_AUTHORIZATION) { <line7> return true; <line8> } <line9> } <line10> } catch (InstanceNotFoundException e) { <line11> } <line12> return false; <line13> } <line14> } <line15> 	"<line11>      LOG.warn(""there isn't a logged user for:"" + loginName, e);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public void execute(Tuple input) { <line2> List<PacketInfo> packetInfoList = null; <line3> try { <line4> packetInfoList = PcapParser.parse(input.getBinary(0)); <line5> if (packetInfoList != null) { <line6> for (PacketInfo packetInfo : packetInfoList) { <line7> String string_pcap = packetInfo.getJsonIndexDoc(); <line8> Object obj = JSONValue.parse(string_pcap); <line9> JSONObject header = (JSONObject) obj; <line10> JSONObject message = new JSONObject(); <line11> message.put(""message"", header); <line12> collector.emit(""message"", new Values(packetInfo.getKey(), message)); <line13> collector.emit( <line14> ""pcap_header_stream"", new Values(packetInfo.getJsonDoc(), packetInfo.getKey())); <line15> collector.emit( <line16> ""pcap_data_stream"", <line17> new Values( <line18> packetInfo.getKey(), <line19> packetInfo.getPacketTimeInNanos() / timePrecisionDivisor, <line20> input.getBinary(0))); <line21> } <line22> } <line23> } catch (Exception e) { <line24> collector.fail(input); <line25> e.printStackTrace(); <line26> JSONObject error = <line27> ErrorGenerator.generateErrorMessage(""Alerts problem: "" + input.getBinary(0), e); <line28> collector.emit(""error"", new Values(error)); <line29> return; <line30> } <line31> collector.ack(input); <line32> } <line33> } <line34> "	"<line26>      LOG.error(""Exception while processing tuple"", e);"	task4	
public class A { <line0> private void bindMetricsRegistryToHikariDataSource(HikariDataSource hikari) { <line1> if (hikari.getMetricRegistry() == null && hikari.getMetricsTrackerFactory() == null) { <line2> try { <line3> hikari.setMetricsTrackerFactory(new MicrometerMetricsTrackerFactory(this.registry)); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.warn(LogMessage.format(""Failed to bind Hikari metrics: %s"", ex.getMessage()));"	task4	
public class A { <line0> @Override <line1> public Mono<HandlerMethod> getHandlerInternal(ServerWebExchange request) { <line2> String path = request.getRequest().getPath().pathWithinApplication().value(); <line3> if (StringUtils.hasText(this.prefix) && !path.startsWith(this.prefix)) { <line4> return Mono.empty(); <line5> } <line6> Mono<HandlerMethod> handler = super.getHandlerInternal(request); <line7> if (path == null) { <line8> return handler; <line9> } <line10> if (path.startsWith(this.prefix)) { <line11> path = path.substring(this.prefix.length()); <line12> } <line13> Object function = <line14> FunctionWebUtils.findFunction( <line15> request.getRequest().getMethod(), <line16> this.functions, <line17> request.getAttributes(), <line18> path, <line19> new String[] {}); <line20> if (function != null) { <line21> if (this.logger.isDebugEnabled()) { <line22> } <line23> request.getAttributes().put(WebRequestConstants.HANDLER, function); <line24> } <line25> Object actual = function; <line26> return handler.filter(method -> actual != null); <line27> } <line28> } <line29> 	"<line22>        this.logger.debug(""Found function for POST: "" + path);"	task4	
public class A { <line0> void close() { <line1> try { <line2> changeZkState(States.CLOSED); <line3> } catch (IOException e) { <line4> } <line5> clientCnxnSocket.onClosing(); <line6> } <line7> } <line8> 	"<line4>      LOG.warn(""Connection close fails when migrates state from {} to CLOSED"", getZkState());"	task4	
public class A { <line0> @Override <line1> protected void updatePartitionLagFromStream() { <line2> getRecordSupplierLock().lock(); <line3> try { <line4> Set<Integer> partitionIds; <line5> try { <line6> partitionIds = recordSupplier.getPartitionIds(getIoConfig().getStream()); <line7> } catch (Exception e) { <line8> throw new StreamException(e); <line9> } <line10> Set<StreamPartition<Integer>> partitions = <line11> partitionIds.stream() <line12> .map(e -> new StreamPartition<>(getIoConfig().getStream(), e)) <line13> .collect(Collectors.toSet()); <line14> recordSupplier.seekToLatest(partitions); <line15> latestSequenceFromStream = <line16> partitions.stream() <line17> .collect( <line18> Collectors.toMap(StreamPartition::getPartitionId, recordSupplier::getPosition)); <line19> } catch (InterruptedException e) { <line20> throw new StreamException(e); <line21> } finally { <line22> getRecordSupplierLock().unlock(); <line23> } <line24> } <line25> } <line26> 	"<line8>        log.warn(""Could not fetch partitions for topic/stream [%s]"", getIoConfig().getStream());"	task4	
"public class A { <line0> @Override <line1> public void exportTo(Path targetPath) throws IOException { <line2> CsarExporter exporter = new CsarExporter(this.wineryRepo); <line3> Map<String, Object> exportConfiguration = new HashMap<>(); <line4> try (OutputStream out = <line5> Files.newOutputStream( <line6> targetPath, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) { <line7> try { <line8> exporter.writeCsar(entryServiceTemplate.get(), out, exportConfiguration); <line9> } catch (RepositoryCorruptException <line10> | InterruptedException <line11> | AccountabilityException <line12> | ExecutionException e) { <line13> throw new IOException(""Failed to export CSAR"", e); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line13>        LOGGER.warn(""Exporting the csar failed with an exception"", e);"	task4	
public class A { <line0> public void stopForcefully() { <line1> stopRequested.set(true); <line2> runThread.interrupt(); <line3> } <line4> } <line5> 	"<line1>    log.info(""Stopping forcefully (status: [%s])"", status);"	task4	
"public class A { <line0> @Test <line1> public void testBlackListMultiValueIncluded() throws Exception { <line2> String cont = ""'europe'""; <line3> String state = ""'mississippi'""; <line4> for (final TestCities city : TestCities.values()) { <line5> String query = <line6> CityField.CITY.name() <line7> + EQ_OP <line8> + ""'"" <line9> + city.name() <line10> + ""'"" <line11> + AND_OP <line12> + ""("" <line13> + CityField.CONTINENT.name() <line14> + EQ_OP <line15> + cont <line16> + OR_OP <line17> + CityField.STATE.name() <line18> + EQ_OP <line19> + state <line20> + "")""; <line21> final Set<String> fields = CityField.getRandomReturnFields(false); <line22> fields.remove(CityField.CITY.name()); <line23> runTest(query, false, false, fields); <line24> } <line25> } <line26> } <line27> "	"<line2>    log.info(""------  testBlackListMultiValueIncluded  ------"");"	task4	
public class A { <line0> public void invalid(Supplier<String> what, Supplier<String> reason) { <line1> if (LOG.isWarnEnabled()) { <line2> } <line3> } <line4> } <line5> 	<line2>      LOG.warn(INVALID_REASON, what.get(), reason.get());	task4	
"public class A { <line0> protected void setupServer() throws IOException { <line1> com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22); <line2> sshConnection.connect(null, 60000, 60000); <line3> if (!sshConnection.authenticateWithPassword(_username, _password)) { <line4> throw new CloudRuntimeException(""Unable to authenticate""); <line5> } <line6> SCPClient scp = new SCPClient(sshConnection); <line7> String configScriptName = ""scripts/vm/hypervisor/ovm/configureOvm.sh""; <line8> String configScriptPath = Script.findScript("""", configScriptName); <line9> if (configScriptPath == null) { <line10> throw new CloudRuntimeException(""Unable to find "" + configScriptName); <line11> } <line12> scp.put(configScriptPath, ""/usr/bin/"", ""0755""); <line13> if (!SSHCmdHelper.sshExecuteCmd(sshConnection, ""sh /usr/bin/configureOvm.sh preSetup"")) { <line14> throw new CloudRuntimeException(""Execute configureOvm.sh preSetup failed on "" + _ip); <line15> } <line16> File tmp = new File(configScriptPath); <line17> File scriptDir = new File(tmp.getParent()); <line18> File[] scripts = scriptDir.listFiles(); <line19> for (int i = 0; i < scripts.length; i++) { <line20> File script = scripts[i]; <line21> if (script.getName().equals(""configureOvm.sh"")) { <line22> continue; <line23> } <line24> if (logger.isDebugEnabled()) { <line25> } <line26> scp.put(script.getPath(), s_ovsAgentPath, ""0644""); <line27> } <line28> sshConnection = SSHCmdHelper.acquireAuthorizedConnection(_ip, _username, _password); <line29> if (sshConnection == null) { <line30> throw new CloudRuntimeException( <line31> String.format( <line32> ""Cannot connect to ovm host(IP=%1$s, username=%2$s, password=%3$s"", <line33> _ip, _username, _password)); <line34> } <line35> if (!SSHCmdHelper.sshExecuteCmd(sshConnection, ""sh /usr/bin/configureOvm.sh postSetup"")) { <line36> throw new CloudRuntimeException(""Execute configureOvm.sh postSetup failed on "" + _ip); <line37> } <line38> } <line39> } <line40> "	"<line25>        logger.debug(""Copying ""+ script.getPath()+ "" to ""+ s_ovsAgentPath+ "" on ""+ _ip+ "" with permission 0644"");"	task4	
"public class A { <line0> private void rollCurrentFileInTrackerDir(File fileToRoll) throws IOException { <line1> Path path = fileToRoll.toPath(); <line2> Path relToRoll = getRelPathToSpoolDir(path); <line3> File dest = new File(trackerDirectory.getPath(), relToRoll + completedSuffix); <line4> if (dest.exists()) { <line5> String message = <line6> ""File name has been re-used with different"" <line7> + "" files. Spooling assumptions violated for "" <line8> + dest; <line9> throw new IllegalStateException(message); <line10> } <line11> dest.getParentFile().mkdirs(); <line12> if (!dest.createNewFile()) { <line13> throw new IOException(""Could not create tracker file: "" + dest); <line14> } <line15> } <line16> } <line17> "	"<line4>    logger.info(""Preparing to create tracker file for {} at {}"", fileToRoll, dest);"	task4	
public class A { <line0> protected synchronized void stopInternal() { <line1> if (exec == null) return; <line2> for (Monitor m : monitors) { <line3> m.stop(); <line4> } <line5> Utils.shutdownAndWait(exec); <line6> if (!exec.isTerminated()) { <line7> } <line8> this.exec = null; <line9> } <line10> } <line11> 	"<line7>      log.warn(""Failed to terminate monitor executor service."");"	task4	
"public class A { <line0> @Test <line1> public void testHeaderAndTrailer() throws Exception { <line2> results.expectedMessageCount(1); <line3> results.message(0).body().isInstanceOf(Document.class); <line4> results.message(0).header(""camelFlatpackCounter"").isEqualTo(6); <line5> results.assertIsSatisfied(); <line6> Document data = results.getExchanges().get(0).getIn().getBody(Document.class); <line7> Element docElement = data.getDocumentElement(); <line8> assertEquals(""Dataset"", docElement.getTagName()); <line9> Element header = (Element) docElement.getElementsByTagName(""DatasetHeader"").item(0); <line10> NodeList headerNodes = header.getElementsByTagName(""Column""); <line11> for (int i = 0; i < headerNodes.getLength(); i++) { <line12> Element column = (Element) headerNodes.item(i); <line13> if (column.getAttribute(""name"").equals(""INDICATOR"")) { <line14> assertEquals(""HBT"", column.getTextContent()); <line15> } else if (column.getAttribute(""name"").equals(""DATE"")) { <line16> assertEquals(""20080817"", column.getTextContent()); <line17> } else { <line18> fail(""Invalid Header Field""); <line19> } <line20> } <line21> NodeList list = docElement.getElementsByTagName(""DatasetRecord""); <line22> for (int counter = 0; counter < list.getLength(); counter++) { <line23> Element record = (Element) list.item(counter); <line24> NodeList columnNodes = record.getElementsByTagName(""Column""); <line25> boolean firstNameFound = false; <line26> for (int i = 0; i < columnNodes.getLength(); i++) { <line27> Element column = (Element) columnNodes.item(i); <line28> if (column.getAttribute(""name"").equals(""FIRSTNAME"")) { <line29> assertEquals(expectedFirstName[counter], column.getTextContent()); <line30> firstNameFound = true; <line31> } <line32> } <line33> assertTrue(firstNameFound); <line34> } <line35> Element trailer = (Element) docElement.getElementsByTagName(""DatasetTrailer"").item(0); <line36> NodeList trailerNodes = trailer.getElementsByTagName(""Column""); <line37> for (int i = 0; i < trailerNodes.getLength(); i++) { <line38> Element column = (Element) trailerNodes.item(i); <line39> if (column.getAttribute(""name"").equals(""INDICATOR"")) { <line40> assertEquals(""FBT"", column.getTextContent()); <line41> } else if (column.getAttribute(""name"").equals(""STATUS"")) { <line42> assertEquals(""SUCCESS"", column.getTextContent()); <line43> } else { <line44> fail(""Invalid Trailer Field""); <line45> } <line46> } <line47> } <line48> } <line49> "	"<line34>      LOG.info(""Result: "" + counter + "" = "" + record);"	task4	
public class A { <line0> @Override <line1> public void moveTo(final double x, final double y) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> final Path2D subPath = new Path2D.Double(); <line5> final Point2D p = transformation_.transform(new Point2D.Double(x, y), null); <line6> subPath.moveTo(p.getX(), p.getY()); <line7> subPaths_.add(subPath); <line8> } <line9> } <line10> 	"<line3>      LOG.debug(""["" + id_ + ""] moveTo("" + x + "", "" + y + "")"");"	task4	
"public class A { <line0> @RateLimited <line1> @POST <line2> @Consumes(MediaType.APPLICATION_OCTET_STREAM) <line3> @Path(""/"") <line4> public int upload(@QueryParam(""size"") int size, InputStream stream) throws IOException { <line5> if (size > MAX_UPLOAD_SIZE) { <line6> return -1; <line7> } <line8> CLIENT_COUNT.incrementAndGet(); <line9> byte[] b = new byte[1024]; <line10> int totalCount = 0; <line11> int count; <line12> try { <line13> while ((count = stream.read(b)) > -1) { <line14> totalCount += count; <line15> } <line16> } finally { <line17> CLIENT_COUNT.decrementAndGet(); <line18> } <line19> return totalCount; <line20> } <line21> } <line22> "	"<line16>      log.debug(""Total bytes read {}"", totalCount);"	task4	
public class A { <line0> @Override <line1> public void perform(AbstractDevice device, Item item, String value) { <line2> String newValue = null; <line3> for (Entry<String, String> entry : device.getMapping().entrySet()) { <line4> if (Objects.equals(entry.getValue(), value)) { <line5> newValue = entry.getKey(); <line6> break; <line7> } <line8> } <line9> if (newValue == null) { <line10> return; <line11> } <line12> ItemCommandEvent event = <line13> ItemEventFactory.createCommandEvent( <line14> item.getName(), new DecimalType(newValue), COMMAND_SOURCE); <line15> eventPublisher.post(event); <line16> } <line17> } <line18> 	"<line10>      logger.warn(""Could not find selection '{}' in mapping {} of device {}"",value,device.getMapping(),device);"	task4	
"public class A { <line0> public static void main(String[] args) throws MalformedURLException { <line1> Utils.configureLogger(); <line2> System.setProperty(""apple.laf.useScreenMenuBar"", ""true""); <line3> System.setProperty(""com.apple.mrj.application.apple.menu.about.name"", ""RipMe""); <line4> logger = Logger.getLogger(App.class); <line5> if (args.length > 0) { <line6> handleArguments(args); <line7> } else { <line8> MainWindow mw = new MainWindow(); <line9> SwingUtilities.invokeLater(mw); <line10> } <line11> } <line12> } <line13> "	"<line5>    logger.info(""Initialized ripme v"" + UpdateUtils.getThisJarVersion());"	task4	
public class A { <line0> @Override <line1> public void messageArrived(String topic, MqttMessage message) throws Exception { <line2> } <line3> } <line4> 	"<line2>    logger.error(""Message arrived to a PublishMQTT processor { topic:'""+ topic+ ""; payload:""+ Arrays.toString(message.getPayload())+ ""}"");"	task4	
public class A { <line0> public boolean checkPermission(String permission) { <line1> return true; <line2> } <line3> } <line4> 	"<line1>    LOGGER.debug(""Execute MCRAccessBaseImpl checkPermission for permission {}"", permission);"	task4	
public class A { <line0> @Override <line1> public Point doGetLocation() { <line2> Point point = element.getLocation(); <line3> return point; <line4> } <line5> } <line6> 	"<line3>    LOGGER.debug(Messager.ELEMENT_ATTRIBUTE_FOUND.getMessage(""Location"", point.toString(), getName()));"	task4	
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line2> @Path(""{personID}/{resourceID}"") <line3> public Response<Resource> getResourceFromPersonById( <line4> @PathParam(""said"") String said, <line5> @PathParam(""personID"") String personID, <line6> @PathParam(""resourceID"") String resourceID) { <line7> Data<Resource> data; <line8> try { <line9> data = getResource(said, resourceID); <line10> } catch (InfosphereException e) { <line11> return Response.badRequest(e.getMessage(), e); <line12> } catch (Exception e) { <line13> return Response.serverError(e.getMessage(), e); <line14> } <line15> return Response.ok(data); <line16> } <line17> } <line18> "	"<line8>    logger.info(""called API method: GET /dime/rest/"" + said + ""/resource/"" + personID + ""/"" + resourceID);"	task4	
"public class A { <line0> private void onThingWithSerialNumber( <line1> final ThingTypeUID deviceType, <line2> final String deviceTypeName, <line3> final DeviceDTO device, <line4> final String name) { <line5> final String serialNumber = device.getSerialNumber(); <line6> ThingUID localBridgeUID = this.bridgeUID; <line7> if (localBridgeUID != null) { <line8> final Map<String, Object> properties = new HashMap<>(); <line9> DraytonWiserPropertyHelper.setPropertiesWithSerialNumber(device, properties); <line10> final DiscoveryResult discoveryResult = <line11> DiscoveryResultBuilder.create(new ThingUID(deviceType, localBridgeUID, serialNumber)) <line12> .withBridge(localBridgeUID) <line13> .withProperties(properties) <line14> .withRepresentationProperty(PROP_SERIAL_NUMBER) <line15> .withLabel((name.isEmpty() ? """" : (name + "" - "")) + deviceTypeName) <line16> .build(); <line17> thingDiscovered(discoveryResult); <line18> } <line19> } <line20> } <line21> "	"<line6>    logger.debug(""{} discovered, serialnumber: {}"", deviceTypeName, serialNumber);"	task4	
"public class A { <line0> protected void loadDefaultConfigurationFromClasspath(String defaultConfigFile) { <line1> try { <line2> configurationUrl = Config.class.getClassLoader().getResource(defaultConfigFile); <line3> if (configurationUrl == null) { <line4> throw new HazelcastException( <line5> String.format( <line6> ""Could not find '%s' in the classpath! This may be due to a "" <line7> + ""wrong-packaged or corrupted jar file."", <line8> defaultConfigFile)); <line9> } <line10> in = Config.class.getClassLoader().getResourceAsStream(defaultConfigFile); <line11> if (in == null) { <line12> throw new HazelcastException( <line13> String.format(""Could not load '%s' from the classpath"", defaultConfigFile)); <line14> } <line15> } catch (RuntimeException e) { <line16> throw new HazelcastException(e); <line17> } <line18> } <line19> } <line20> "	"<line2>      LOGGER.info(String.format(""Loading '%s' from the classpath."", defaultConfigFile));"	task4	
public class A { <line0> @Override <line1> protected IXtextDocument run() throws Exception { <line2> IWorkbenchPage activePage = workbench.getActiveWorkbenchWindow().getActivePage(); <line3> if (activePage == null) return null; <line4> for (IEditorReference editorReference : activePage.getEditorReferences()) { <line5> try { <line6> IEditorInput editorInput = editorReference.getEditorInput(); <line7> if (editorInput instanceof IStorageEditorInput <line8> && contains(storages, ((IStorageEditorInput) editorInput).getStorage())) { <line9> IEditorPart editor = editorReference.getEditor(true); <line10> if (editor instanceof XtextEditor) { <line11> XtextEditor xtextEditor = (XtextEditor) editor; <line12> return xtextEditor.getDocument(); <line13> } <line14> } <line15> } catch (Exception e) { <line16> } <line17> } <line18> return null; <line19> } <line20> } <line21> 	"<line16>        LOG.error(""Error accessing document"", e);"	task4	
public class A { <line0> private BookieId setBookieInTheEnsemble( <line1> int ensembleSize, <line2> int writeQuorumSize, <line3> List<BookieId> currentEnsemble, <line4> List<BookieId> newEnsemble, <line5> int bookieToReplaceIndex, <line6> int desiredNumZonesPerWriteQuorumForThisEnsemble, <line7> Set<BookieId> excludeBookies) <line8> throws BKNotEnoughBookiesException { <line9> BookieId bookieToReplace = currentEnsemble.get(bookieToReplaceIndex); <line10> Set<String> zonesToExclude = null; <line11> Set<BookieNode> bookiesToConsiderAfterExcludingZonesAndUDs = null; <line12> for (int numberOfNeighborsToConsider = (desiredNumZonesPerWriteQuorumForThisEnsemble - 1); <line13> numberOfNeighborsToConsider >= (minNumZonesPerWriteQuorum - 1); <line14> numberOfNeighborsToConsider--) { <line15> zonesToExclude = <line16> getZonesOfNeighboringNodesInEnsemble( <line17> currentEnsemble, bookieToReplaceIndex, (numberOfNeighborsToConsider)); <line18> bookiesToConsiderAfterExcludingZonesAndUDs = <line19> getBookiesToConsiderAfterExcludingZonesAndUDs( <line20> ensembleSize, <line21> writeQuorumSize, <line22> currentEnsemble, <line23> bookieToReplaceIndex, <line24> excludeBookies, <line25> zonesToExclude); <line26> if (!bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) { <line27> break; <line28> } <line29> } <line30> if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) { <line31> zonesToExclude = <line32> getZonesToExcludeToMaintainMinZones( <line33> currentEnsemble, bookieToReplaceIndex, writeQuorumSize); <line34> bookiesToConsiderAfterExcludingZonesAndUDs = <line35> getBookiesToConsiderAfterExcludingZonesAndUDs( <line36> ensembleSize, <line37> writeQuorumSize, <line38> currentEnsemble, <line39> bookieToReplaceIndex, <line40> excludeBookies, <line41> zonesToExclude); <line42> } <line43> if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) { <line44> throw new BKNotEnoughBookiesException(); <line45> } <line46> BookieId candidateAddr = <line47> selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs).getAddr(); <line48> newEnsemble.set(bookieToReplaceIndex, candidateAddr); <line49> return candidateAddr; <line50> } <line51> } <line52> 	"<line44>      LOG.error(""Not enough bookies are available to replaceBookie : {} in ensemble : {} with""+ "" excludeBookies {}."",bookieToReplace,currentEnsemble,excludeBookies);"	task4	
public class A { <line0> private ObjectValuePair<HashMap<String, Locale>, HashMap<String, Locale>> _createGroupLocales( <line1> long groupId) { <line2> String[] languageIds = PropsValues.LOCALES_ENABLED; <line3> Locale defaultLocale = LocaleUtil.getDefault(); <line4> try { <line5> Group group = GroupLocalServiceUtil.getGroup(groupId); <line6> defaultLocale = PortalUtil.getSiteDefaultLocale(group); <line7> UnicodeProperties typeSettingsUnicodeProperties = group.getTypeSettingsProperties(); <line8> String groupLanguageIds = typeSettingsUnicodeProperties.getProperty(PropsKeys.LOCALES); <line9> if (groupLanguageIds != null) { <line10> languageIds = StringUtil.split(groupLanguageIds); <line11> } <line12> } catch (Exception exception) { <line13> if (log.isDebugEnabled()) { <line14> } <line15> } <line16> HashMap<String, Locale> groupLanguageIdLocalesMap = new LinkedHashMap<>(); <line17> HashMap<String, Locale> groupLanguageCodeLocalesMap = <line18> HashMapBuilder.put(defaultLocale.getLanguage(), defaultLocale).build(); <line19> for (String languageId : languageIds) { <line20> Locale locale = LocaleUtil.fromLanguageId(languageId, false); <line21> String languageCode = languageId; <line22> int pos = languageId.indexOf(CharPool.UNDERLINE); <line23> if (pos > 0) { <line24> languageCode = languageId.substring(0, pos); <line25> } <line26> if (!groupLanguageCodeLocalesMap.containsKey(languageCode)) { <line27> groupLanguageCodeLocalesMap.put(languageCode, locale); <line28> } <line29> groupLanguageIdLocalesMap.put(languageId, locale); <line30> } <line31> _groupLanguageCodeLocalesMapMap.put(groupId, groupLanguageCodeLocalesMap); <line32> _groupLanguageIdLocalesMap.put(groupId, groupLanguageIdLocalesMap); <line33> _updateLastModified(); <line34> return new ObjectValuePair<>(groupLanguageCodeLocalesMap, groupLanguageIdLocalesMap); <line35> } <line36> } <line37> 	<line14>        log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> protected void postParse(CommandLine commandLine) throws CommandLineParseException { <line2> certificateAuthorityHostname = <line3> commandLine.getOptionValue(CERTIFICATE_AUTHORITY_HOSTNAME_ARG, TlsConfig.DEFAULT_HOSTNAME); <line4> days = getIntValue(commandLine, DAYS_ARG, TlsConfig.DEFAULT_DAYS); <line5> keySize = getIntValue(commandLine, KEY_SIZE_ARG, TlsConfig.DEFAULT_KEY_SIZE); <line6> keyAlgorithm = <line7> commandLine.getOptionValue(KEY_ALGORITHM_ARG, TlsConfig.DEFAULT_KEY_PAIR_ALGORITHM); <line8> keyStoreType = commandLine.getOptionValue(KEY_STORE_TYPE_ARG, getKeyStoreTypeDefault()); <line9> if (KeystoreType.PKCS12.toString().equalsIgnoreCase(keyStoreType)) { <line10> } <line11> signingAlgorithm = <line12> commandLine.getOptionValue(SIGNING_ALGORITHM_ARG, TlsConfig.DEFAULT_SIGNING_ALGORITHM); <line13> differentPasswordForKeyAndKeystore = <line14> commandLine.hasOption(DIFFERENT_KEY_AND_KEYSTORE_PASSWORDS_ARG); <line15> } <line16> } <line17> 	"<line10>      logger.info(""Command line argument --""+ KEY_STORE_TYPE_ARG+ ""=""+ keyStoreType+ "" only applies to keystore, recommended truststore type of ""+ KeystoreType.JKS.toString()+ "" unaffected."");"	task4	
public class A { <line0> @Override <line1> public void bindServiceInstance(String applicationName, String serviceInstanceName) { <line2> delegate.bindServiceInstance(applicationName, serviceInstanceName); <line3> } <line4> } <line5> 	<line2>    logger.debug(Messages.BINDING_SERVICE_INSTANCE_0_TO_APPLICATION_1, serviceInstanceName, applicationName);	task4	
public class A { <line0> protected static Semaphore registerAnnotator(Annotator decoratedAnnotator) { <line1> try { <line2> registryMutex.acquire(); <line3> } catch (InterruptedException e) { <line4> return null; <line5> } <line6> Semaphore semaphore = null; <line7> try { <line8> Annotator annotator = decoratedAnnotator; <line9> while (annotator instanceof AnnotatorDecorator) { <line10> annotator = ((AnnotatorDecorator) annotator).getDecoratedAnnotator(); <line11> } <line12> RegistryValue value; <line13> if (annotatorRegistry.containsKey(annotator)) { <line14> value = annotatorRegistry.get(annotator); <line15> } else { <line16> value = new RegistryValue(); <line17> annotatorRegistry.put(annotator, value); <line18> } <line19> ++value.usageCounter; <line20> semaphore = value.semaphore; <line21> } finally { <line22> registryMutex.release(); <line23> } <line24> return semaphore; <line25> } <line26> } <line27> 	"<line4>      LOGGER.error(""Exception while waiting for registry mutex. Returning null."", e);"	task4	
"public class A { <line0> @Override <line1> public void onEvents(Collection<ConfigEvent> events) { <line2> if (!events.isEmpty()) { <line3> StringBuilder sb = new StringBuilder(); <line4> sb.append(""[""); <line5> events.stream() <line6> .sorted(Comparator.comparing(ConfigEvent::getName)) <line7> .forEach( <line8> event -> { <line9> sb.append(""\n""); <line10> sb.append(event.getName()).append(""=[""); <line11> sb.append(propValueAsString(event)); <line12> sb.append(""], ""); <line13> sb.append(""source=""); <line14> sb.append(sourceAsString(event)); <line15> sb.append("", ""); <line16> sb.append(""origin=""); <line17> sb.append(originAsString(event)); <line18> }); <line19> sb.append(""\n"").append(""]""); <line20> } <line21> } <line22> } <line23> "	<line20>      LOGGER.info(sb.toString());	task4	
public class A { <line0> @PreDestroy <line1> public void stop() throws IOException { <line2> super.stop(); <line3> if (_ftpClient != null) _ftpClient.disconnect(); <line4> } <line5> } <line6> 	"<line2>    log.info(""stopping orbcad ftp download client"");"	task4	
"public class A { <line0> protected ActionMapping processMapping( <line1> HttpServletRequest request, HttpServletResponse response, String path) throws IOException { <line2> ActionMapping mapping = (ActionMapping) moduleConfig.findActionConfig(path); <line3> if (mapping != null) { <line4> request.setAttribute(Globals.MAPPING_KEY, mapping); <line5> return (mapping); <line6> } <line7> ActionConfig[] configs = moduleConfig.findActionConfigs(); <line8> for (int i = 0; i < configs.length; i++) { <line9> if (configs[i].getUnknown()) { <line10> mapping = (ActionMapping) configs[i]; <line11> request.setAttribute(Globals.MAPPING_KEY, mapping); <line12> return (mapping); <line13> } <line14> } <line15> String msg = getInternal().getMessage(""processInvalid""); <line16> response.sendError(HttpServletResponse.SC_NOT_FOUND, msg); <line17> return null; <line18> } <line19> } <line20> "	"<line16>    log.error(msg + "" "" + path);"	task4	
public class A { <line0> @Override <line1> public List<String> getExperimentRunTags(String experimentRunId) <line2> throws InvalidProtocolBufferException { <line3> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line4> ExperimentRunEntity experimentRunObj = <line5> session.get(ExperimentRunEntity.class, experimentRunId); <line6> return experimentRunObj.getProtoObject().getTagsList(); <line7> } catch (Exception ex) { <line8> if (ModelDBUtils.needToRetry(ex)) { <line9> return getExperimentRunTags(experimentRunId); <line10> } else { <line11> throw ex; <line12> } <line13> } <line14> } <line15> } <line16> 	"<line6>      LOGGER.debug(""Got ExperimentRun Tags"");"	task4	
public class A { <line0> @Override <line1> public void close() throws Exception { <line2> suspend(); <line3> slotManagerMetricGroup.close(); <line4> } <line5> } <line6> 	"<line2>    LOG.info(""Closing the SlotManager."");"	task4	
"public class A { <line0> private String getValidToken( <line1> String id, <line2> String sourceId, <line3> String clientId, <line4> String clientSecret, <line5> String discoveryUrl, <line6> String grantType, <line7> Map<String, String> queryParameters) { <line8> TokenEntry tokenEntry = tokenStorage.read(id, sourceId); <line9> if (tokenEntry != null <line10> && discoveryUrl.equalsIgnoreCase(tokenEntry.getDiscoveryUrl()) <line11> && !isExpired(tokenEntry.getAccessToken())) { <line12> return tokenEntry.getAccessToken(); <line13> } <line14> OIDCProviderMetadata metadata; <line15> try { <line16> metadata = <line17> OIDCProviderMetadata.parse( <line18> resourceRetriever.retrieveResource(new URL(discoveryUrl)).getContent()); <line19> } catch (IOException | ParseException e) { <line20> return null; <line21> } <line22> if (tokenEntry != null <line23> && discoveryUrl.equalsIgnoreCase(tokenEntry.getDiscoveryUrl()) <line24> && isExpired(tokenEntry.getAccessToken()) <line25> && !isExpired(tokenEntry.getRefreshToken())) { <line26> return refreshToken( <line27> id, <line28> sourceId, <line29> clientId, <line30> clientSecret, <line31> discoveryUrl, <line32> tokenEntry.getRefreshToken(), <line33> metadata); <line34> } <line35> String encodedClientIdSecret = <line36> Base64.getEncoder().encodeToString((clientId + "":"" + clientSecret).getBytes(UTF_8)); <line37> return getNewAccessToken( <line38> id, sourceId, encodedClientIdSecret, discoveryUrl, grantType, queryParameters, metadata); <line39> } <line40> } <line41> "	"<line20>      LOGGER.error(""Unable to retrieve OAuth provider's metadata."", e);"	task4	
"public class A { <line0> protected FilterHolder getCorsFilter() { <line1> CrossOriginFilter filter = new CrossOriginFilter(); <line2> FilterHolder filterHolder = new FilterHolder(filter); <line3> List<String> allowedOrigins = <line4> genericEndpointProperties.getListOfValues(RESTEndpointProperties.ENABLED_CORS_ORIGINS); <line5> StringJoiner originsJoiner = new StringJoiner("",""); <line6> allowedOrigins.forEach(origin -> originsJoiner.add(origin)); <line7> List<String> allowedHeaders = <line8> genericEndpointProperties.getListOfValues(RESTEndpointProperties.ENABLED_CORS_HEADERS); <line9> StringJoiner headersJoiner = new StringJoiner("",""); <line10> allowedHeaders.forEach(origin -> headersJoiner.add(origin)); <line11> String allowedHeadersSpec = allowedHeaders.isEmpty() ? ""*"" : headersJoiner.toString(); <line12> filterHolder.setInitParameter(CrossOriginFilter.ALLOWED_HEADERS_PARAM, allowedHeadersSpec); <line13> filterHolder.setInitParameter( <line14> CrossOriginFilter.ALLOWED_ORIGINS_PARAM, originsJoiner.toString()); <line15> filterHolder.setInitParameter( <line16> CrossOriginFilter.ALLOWED_METHODS_PARAM, ""GET,POST,HEAD,DELETE,PUT,OPTIONS""); <line17> return filterHolder; <line18> } <line19> } <line20> "	"<line17>    log.debug(""Will allow CORS for the following origins: "" + originsJoiner.toString());"	task4	
public class A { <line0> @Override <line1> protected void doClose(int id, String handle) throws IOException { <line2> Handle h = handles.remove(handle); <line3> ServerSession session = getServerSession(); <line4> if (log.isDebugEnabled()) { <line5> } <line6> Handle nodeHandle = validateHandle(handle, h, Handle.class); <line7> SftpEventListener listener = getSftpEventListenerProxy(); <line8> try { <line9> listener.closing(session, handle, nodeHandle); <line10> nodeHandle.close(); <line11> listener.closed(session, handle, nodeHandle, null); <line12> } catch (IOException | RuntimeException | Error e) { <line13> listener.closed(session, handle, nodeHandle, e); <line14> throw e; <line15> } finally { <line16> nodeHandle.clearAttributes(); <line17> } <line18> } <line19> } <line20> 	"<line5>      log.debug(""doClose({})[id={}] SSH_FXP_CLOSE (handle={}[{}])"", session, id, handle, h);"	task4	
public class A { <line0> private KuraPayload createKuraPayloadFromProtoBuf(String topic, byte[] payload) { <line1> KuraPayload kuraPayload; <line2> try { <line3> kuraPayload = new CloudPayloadProtoBufDecoderImpl(payload).buildFromByteArray(); <line4> } catch (Exception e) { <line5> kuraPayload = new KuraPayload(); <line6> kuraPayload.setBody(payload); <line7> } <line8> return kuraPayload; <line9> } <line10> } <line11> 	"<line5>      logger.debug(""Received message on topic {} that could not be decoded. Wrapping it into an""+ "" KuraPayload."",topic);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public final void exceptionOnAction(AllocatableAction action, COMPSsException e) { <line2> removeFromReady(action); <line3> ResourceScheduler<WorkerResourceDescription> resource; <line4> resource = (ResourceScheduler<WorkerResourceDescription>) action.getAssignedResource(); <line5> List<AllocatableAction> resourceFree; <line6> try { <line7> resourceFree = resource.unscheduleAction(action); <line8> } catch (ActionNotFoundException ex) { <line9> resourceFree = new LinkedList<>(); <line10> } <line11> List<AllocatableAction> dataFreeActions = action.exception(e); <line12> for (AllocatableAction dataFreeAction : dataFreeActions) { <line13> addToReady(dataFreeAction); <line14> } <line15> workerLoadUpdate(resource); <line16> List<AllocatableAction> blockedCandidates = new LinkedList<>(); <line17> handleDependencyFreeActions(dataFreeActions, resourceFree, blockedCandidates, resource); <line18> for (AllocatableAction aa : blockedCandidates) { <line19> if (!aa.hasDataPredecessors() && !aa.hasStreamProducers()) { <line20> removeFromReady(aa); <line21> } <line22> addToBlocked(aa); <line23> } <line24> } <line25> } <line26> "	"<line2>    LOGGER.info(""[TaskScheduler] Exception on action "" + action);"	task4	
public class A { <line0> public void onBecomeOfflineFromSlave(Message message, NotificationContext context) { <line1> DummyProcess.sleep(_transDelay); <line2> } <line3> } <line4> 	"<line2>    logger.info(""DummyStateModel.onBecomeOfflineFromSlave()"");"	task4	
public class A { <line0> @Override <line1> public synchronized void mark(final int readlimit) { <line2> byteBuffer.mark(); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""mark at {}"", position());"	task4	
public class A { <line0> private void stepThree(final int i) { <line1> BigInteger n = publicKey.getModulus(); <line2> BigInteger r; <line3> BigInteger upperBound; <line4> BigInteger lowerBound; <line5> BigInteger max; <line6> BigInteger min; <line7> BigInteger[] tmp; <line8> ArrayList<Interval> ms = new ArrayList<>(); <line9> for (Interval interval : m) { <line10> upperBound = step3ComputeUpperBound(si, n, interval.upper); <line11> lowerBound = step3ComputeLowerBound(si, n, interval.lower); <line12> r = lowerBound; <line13> while (r.compareTo(upperBound) < 1) { <line14> max = (BigInteger.valueOf(2).multiply(bigB)).add(r.multiply(n)); <line15> tmp = max.divideAndRemainder(si); <line16> if (BigInteger.ZERO.compareTo(tmp[1]) != 0) { <line17> max = tmp[0].add(BigInteger.ONE); <line18> } else { <line19> max = tmp[0]; <line20> } <line21> min = BigInteger.valueOf(3).multiply(bigB); <line22> min = min.subtract(BigInteger.ONE); <line23> min = min.add(r.multiply(n)); <line24> min = min.divide(si); <line25> if (interval.lower.compareTo(max) > 0) { <line26> max = interval.lower; <line27> } <line28> if (interval.upper.compareTo(min) < 0) { <line29> min = interval.upper; <line30> } <line31> if (max.compareTo(min) <= 0) { <line32> ms.add(new Interval(max, min)); <line33> } <line34> r = r.add(BigInteger.ONE); <line35> } <line36> } <line37> m = ms.toArray(new Interval[ms.size()]); <line38> } <line39> } <line40> 	"<line37>    LOGGER.debug("" # of intervals for M"" + i + "": "" + ms.size());"	task4	
"public class A { <line0> public static KeyProvider validateAndBuildRepositoryKeyProvider( <line1> RepositoryEncryptionConfiguration repositoryEncryptionConfiguration) throws IOException { <line2> try { <line3> SecretKey rootKey = <line4> KeyProviderFactory.requiresRootKey( <line5> repositoryEncryptionConfiguration.getKeyProviderImplementation()) <line6> ? CryptoUtils.getRootKey() <line7> : null; <line8> return buildKeyProviderFromConfig(rootKey, repositoryEncryptionConfiguration); <line9> } catch (KeyManagementException e) { <line10> String msg = ""Encountered an error building the key provider""; <line11> throw new IOException(msg, e); <line12> } <line13> } <line14> } <line15> "	<line11>      logger.error(msg, e);	task4	
public class A { <line0> public static Long addMedicalData( <line1> String providerNo, <line2> MyOscarLoggedInInfo myOscarLoggedInInfo, <line3> MedicalDataTransfer4 medicalDataTransfer, <line4> String oscarDataType, <line5> Object localOscarObjectId, <line6> boolean completed, <line7> boolean active) <line8> throws NotAuthorisedException_Exception, UnsupportedEncodingException_Exception, <line9> InvalidRequestException_Exception { <line10> Long resultId = <line11> MedicalDataManager.addMedicalData( <line12> myOscarLoggedInInfo, medicalDataTransfer, completed, active); <line13> addSendRemoteDataLog( <line14> providerNo, oscarDataType, localOscarObjectId, medicalDataTransfer.getData()); <line15> return (resultId); <line16> } <line17> } <line18> 	"<line13>    logger.debug(""addMedicalData success : resultId="" + resultId);"	task4	
public class A { <line0> @Override <line1> public boolean isSatisified() throws Exception { <line2> return failoverTransport.getCurrentBackups() == 1; <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""Current Backup Count = "" + failoverTransport.getCurrentBackups());"	task4	
public class A { <line0> public static ActivityFilter older() { <line1> return new ActivityFilter() { <line2> @Override <line3> protected void start() { <line4> try { <line5> super.start(); <line6> super.destroy(); <line7> this.with(LAST_UPDATED_ORDERBY.clone()) <line8> .direction(DIRECTION.DESC) <line9> .with(POSTED_TIME_ORDERBY.clone()) <line10> .direction(DIRECTION.DESC); <line11> } catch (Exception ex) { <line12> } <line13> } <line14> }; <line15> } <line16> } <line17> 	<line12>          LOG.warn(ex);	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> WeldRequestScopeAdapter.getInstance().activateContext(); <line3> WeldSessionScopeAdapter.getInstance().activateContext(httpSession); <line4> WeldConversationScopeAdapter.getInstance().activateContext(conversationState); <line5> Assert.assertFalse(conversation.isTransient()); <line6> Assert.assertTrue(conversationState.isLongRunning()); <line7> final ConversationScopeBean conversationScopeBean = getInstance(ConversationScopeBean.class); <line8> Assert.assertEquals( <line9> ""wrong state"", conversationState.getConversationId(), conversationScopeBean.getId()); <line10> WeldConversationScopeAdapter.getInstance().deactivateContext(); <line11> WeldSessionScopeAdapter.getInstance().deactivateContext(); <line12> WeldRequestScopeAdapter.getInstance().deactivateContext(); <line13> final int runner = doneRunnerCount.incrementAndGet(); <line14> } <line15> } <line16> "	"<line14>    LOGGER.info(""conversation {} runner: {} done"", conversationState.getConversationId(), runner);"	task4	
public class A { <line0> public void start() { <line1> if (mongodExecutable == null) { <line2> try { <line3> mongoPort = NetworkUtil.getAvailableLocalPort(); <line4> RuntimeConfig runtimeConfig = <line5> Defaults.runtimeConfigFor(Command.MongoD, LOGGER) <line6> .processOutput(ProcessOutput.getDefaultInstanceSilent()) <line7> .build(); <line8> MongodConfig mongodConfig = <line9> MongodConfig.builder() <line10> .version(Version.V4_0_12) <line11> .net(new Net(DEFAULT_MONGO_HOST, mongoPort, Network.localhostIsIPv6())) <line12> .build(); <line13> MongodStarter runtime = MongodStarter.getInstance(runtimeConfig); <line14> mongodExecutable = runtime.prepare(mongodConfig); <line15> mongodExecutable.start(); <line16> } catch (IOException e) { <line17> } <line18> } <line19> } <line20> } <line21> 	"<line17>        LOGGER.error(""Exception when starting embedded mongo"", e);"	task4	
public class A { <line0> protected static void setInvalid() { <line1> if (JBoss6VFS.valid == Boolean.TRUE) { <line2> JBoss6VFS.valid = Boolean.FALSE; <line3> } <line4> } <line5> } <line6> 	"<line2>      log.debug(""JBoss 6 VFS API is not available in this environment."");"	task4	
public class A { <line0> @Override <line1> public void onError(int errno, String message) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> this.error = true; <line5> this.errorCode = errno; <line6> this.errorMessage = message; <line7> } <line8> } <line9> 	"<line3>      logger.trace(""AIO on error issued. Error(code: "" + errno + "" msg: "" + message + "")"");"	task4	
"public class A { <line0> public void exception(final LdapException e) { <line1> if (e == null) { <line2> throw new IllegalArgumentException(""Exception cannot be null for handle "" + this); <line3> } <line4> if (onException != null) { <line5> try { <line6> onException.accept(e); <line7> } catch (Exception ex) { <line8> } <line9> } <line10> exception = e; <line11> complete(); <line12> } <line13> } <line14> "	"<line8>        logger.warn(""Exception consumer {} in handle {} threw an exception"", onException, this, ex);"	task4	
public class A { <line0> private void throwValidationError(ErrorMessage error) { <line1> throw new IllegalQueryException(error); <line2> } <line3> } <line4> 	"<line1>    log.warn(String.format(""Validation result query failed, code: '%s', message: '%s'"",error.getErrorCode(), error.getMessage()));"	task4	
public class A { <line0> @Override <line1> public IManageablePage convertToPage(Object page) { <line2> if (page instanceof IManageablePage) { <line3> return (IManageablePage) page; <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line5>    logger.warn(""page is not an instance of "" + IManageablePage.class);"	task4	
"public class A { <line0> public void close() { <line1> if (tokenPath != null) { <line2> new File(tokenPath.toUri()).delete(); <line3> String checksumStr = <line4> tokenPath.getParent() + File.separator + ""."" + tokenPath.getName() + "".crc""; <line5> File checksumFile = null; <line6> try { <line7> checksumFile = new File(new URI(checksumStr)); <line8> if (checksumFile.exists()) { <line9> checksumFile.delete(); <line10> } <line11> } catch (URISyntaxException e) { <line12> } <line13> tokenPath = null; <line14> } <line15> } <line16> } <line17> "	"<line12>        LOG.error(""Failed to delete token crc file."", e);"	task4	
public class A { <line0> protected Level setupLogger() { <line1> final Level logLevel; <line2> if (isDebug()) { <line3> logLevel = Level.DEBUG; <line4> InternalLoggerFactory.setDefaultFactory(Slf4JLoggerFactory.INSTANCE); <line5> } else if (onlyLogErrors()) { <line6> logLevel = Level.ERROR; <line7> } else { <line8> logLevel = Level.INFO; <line9> } <line10> initializeLogging(logLevel); <line11> return logLevel; <line12> } <line13> } <line14> 	"<line3>      LOG.info(""Running in Debug mode"");"	task4	
public class A { <line0> @Inject <line1> @Provides <line2> public ConnectorAccessControl getConnectorAccessControl(FileBasedAccessControlConfig config) { <line3> if (config.getRefreshPeriod() != null) { <line4> return ForwardingConnectorAccessControl.of( <line5> memoizeWithExpiration( <line6> () -> { <line7> return new FileBasedAccessControl(config); <line8> }, <line9> config.getRefreshPeriod().toMillis(), <line10> MILLISECONDS)); <line11> } <line12> return new FileBasedAccessControl(config); <line13> } <line14> } <line15> 	"<line7>                log.info(""Refreshing system access control from %s"", config.getConfigFile());"	task4	
public class A { <line0> @Override <line1> public void reset(Long roomId, Long userId) { <line2> if (roomId == null) { <line3> return; <line4> } <line5> try { <line6> if (contains(roomId) && map().tryLock(roomId, 1, TimeUnit.SECONDS)) { <line7> try { <line8> onlineWbs.remove(roomId); <line9> map().delete(roomId); <line10> } finally { <line11> map().unlock(roomId); <line12> } <line13> } <line14> new Thread( <line15> () -> { <line16> ensureApplication(); <line17> User u = new User(); <line18> u.setId(userId); <line19> WebSocketHelper.sendRoom(new RoomMessage(roomId, u, RoomMessage.Type.WB_RELOAD)); <line20> }) <line21> .start(); <line22> } catch (InterruptedException e) { <line23> Thread.currentThread().interrupt(); <line24> } <line25> } <line26> } <line27> 	"<line23>      log.warn(""Unexpected exception while map clean-up"", e);"	task4	
"public class A { <line0> @Bean(name = ""wsDistributionAutomationInboundDomainResponsesMessageListenerContainer"") <line1> public DefaultMessageListenerContainer messageListenerContainer( <line2> @Qualifier(""wsDistributionAutomationInboundDomainResponsesMessageListener"") <line3> final MessageListener messageListener) { <line4> return this.jmsConfigurationFactory.initMessageListenerContainer(messageListener); <line5> } <line6> } <line7> "	"<line4>    LOGGER.info(""Initializing wsDistributionAutomationInboundDomainResponsesMessageListenerContainer""+ "" bean."");"	task4	
"public class A { <line0> @Override <line1> public Object visit(PropertyIsEqualTo filter, Object data) { <line2> ExpressionValueVisitor expressionVisitor = new ExpressionValueVisitor(); <line3> String propertyName = (String) filter.getExpression1().accept(expressionVisitor, data); <line4> Object literalValue = filter.getExpression2().accept(expressionVisitor, data); <line5> String mappedPropertyName = getMappedPropertyName(propertyName); <line6> return new SolrQuery( <line7> mappedPropertyName <line8> + "":"" <line9> + QUOTE <line10> + escapeSpecialCharacters(literalValue.toString()) <line11> + QUOTE); <line12> } <line13> } <line14> "	"<line2>    LOGGER.debug(""ENTERING: PropertyIsEqualTo filter"");"	task4	
"public class A { <line0> protected void deleteWorkGuiConfig(String typeCode, String stepCode, Connection conn) <line1> throws ApsSystemException { <line2> PreparedStatement stat = null; <line3> try { <line4> stat = conn.prepareStatement(DELETE_WORK_GUI); <line5> stat.setString(1, typeCode); <line6> stat.setString(2, stepCode); <line7> stat.executeUpdate(); <line8> } catch (Throwable t) { <line9> throw new RuntimeException( <line10> ""Error deleting work gui - typeCode "" + typeCode + "" - stepCode "" + stepCode, t); <line11> } finally { <line12> closeDaoResources(null, stat); <line13> } <line14> } <line15> } <line16> "	"<line9>      logger.error(""Error deleting work gui - typeCode {} - stepCode {}"", typeCode, stepCode, t);"	task4	
"public class A { <line0> @GetMapping(CommonConstants.PATH_ID) <line1> public LogbookOperationDto getAllPaginated(@PathVariable(""id"") String id) { <line2> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line3> final VitamContext vitamContext = <line4> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line5> return ingestInternalService.getOne(vitamContext, id); <line6> } <line7> } <line8> "	"<line2>    LOGGER.debug(""get Ingest Entities for id={} "", id);"	task4	
"public class A { <line0> public Object retrieve(DiskCacheReference dcr, DiskCacheFetchType ft) { <line1> if (myIsClosed) { <line2> return null; <line3> } <line4> Object result = null; <line5> myRetrieveLock.lock(); <line6> try { <line7> RandomAccessFile raf = myInsertToRAFMap.get(Integer.valueOf(dcr.getInsertNum())); <line8> if (raf == null) { <line9> File cacheFile = <line10> DiskCacheAssistant.getCacheFile( <line11> myDiskCacheAssistant.getDiskCacheLocation(), myTypeId, dcr.getInsertNum()); <line12> raf = new RandomAccessFile(cacheFile, ""r""); <line13> myInsertToRAFMap.put(Integer.valueOf(dcr.getInsertNum()), raf); <line14> } <line15> if (ft == DiskCacheFetchType.META_DATA) { <line16> result = decodeMetaData(raf, dcr); <line17> } else if (ft == DiskCacheFetchType.MAP_GEOMETRY_SUPPORT) { <line18> result = decodeMGS(raf, dcr); <line19> } else if (ft == DiskCacheFetchType.ORIGIN_ID) { <line20> result = decodeOriginId(raf, dcr); <line21> } <line22> } catch (IOException <line23> | BadPaddingException <line24> | IllegalBlockSizeException <line25> | ShortBufferException e) { <line26> } finally { <line27> myRetrieveLock.unlock(); <line28> } <line29> return result; <line30> } <line31> } <line32> "	<line26>      LOG.error(e);	task4	
public class A { <line0> @Override <line1> public void onSubscribe(Subscription s) { <line2> subscription = s; <line3> subscriber.onSubscribe(this); <line4> } <line5> } <line6> 	"<line3>    log.trace(""Calling onSubscribe of subscriber"");"	task4	
public class A { <line0> @Override <line1> public void info(String msg) { <line2> if (logger.isInfoEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>      logger.info(msg);	task4	
public class A { <line0> @Override <line1> public void nodeFinished(CnATreeElement node, int depth) { <line2> } <line3> } <line4> 	"<line2>    LOG.info(""finished node: "" + node + "" depth: "" + depth);"	task4	
public class A { <line0> @Override <line1> public void exists() { <line2> status = Status.EXIST; <line3> signalChildren(); <line4> } <line5> } <line6> 	"<line2>    logger.debug(String.format(""Skipped '%s' because idempotent and exists in the machine."", id));"	task4	
public class A { <line0> @Override <line1> public COREEnvelopeRealTimeResponse realTimeTransaction( <line2> COREEnvelopeRealTimeRequest msg, AssertionType assertion) { <line3> return new COREEnvelopeRealTimeResponse(); <line4> } <line5> } <line6> 	"<line3>    LOG.trace(""Using NoOp Implementation for Adapter CORE X12 Doc Submission Service"");"	task4	
"public class A { <line0> @SuppressFBWarnings( <line1> justification = ""try with resource will clenaup the resources"", <line2> value = {""OBL_UNSATISFIED_OBLIGATION""}) <line3> public List<SuppressionRule> parseSuppressionRules(File file) throws SuppressionParseException { <line4> try (FileInputStream fis = new FileInputStream(file)) { <line5> return parseSuppressionRules(fis); <line6> } catch (SAXException | IOException ex) { <line7> throw new SuppressionParseException(ex); <line8> } <line9> } <line10> } <line11> "	"<line7>      LOGGER.debug("""", ex);"	task4	
"public class A { <line0> @Override <line1> protected void doJmxRegistration(MBeanServerConnection connection) { <line2> ObjectName objName = null; <line3> try { <line4> objName = <line5> new ObjectName( <line6> service.jmxDomain <line7> + "":type=RemoteQuery,name="" <line8> + ObjectName.quote(service.clusterName) <line9> + "",component="" <line10> + ProtobufMetadataManager.OBJECT_NAME); <line11> } catch (MalformedObjectNameException e) { <line12> throw new IllegalStateException(""Failed to register protofiles"", e); <line13> } <line14> for (String protofile : service.protofiles) { <line15> byte[] descriptor; <line16> try (InputStream inputStream = getClass().getResourceAsStream(protofile)) { <line17> descriptor = Utils.readAsBytes(inputStream); <line18> } catch (IOException e) { <line19> throw new IllegalStateException(""Failed to read protofile "" + protofile, e); <line20> } <line21> try { <line22> connection.invoke( <line23> objName, <line24> ""registerProtofile"", <line25> new Object[] {protofile, new String(descriptor)}, <line26> new String[] {String.class.getName(), String.class.getName()}); <line27> } catch (Exception e) { <line28> throw new IllegalStateException(""Failed to register protofile "" + protofile, e); <line29> } <line30> } <line31> } <line32> } <line33> "	"<line27>        log.info(""Protofile "" + protofile + "" registered."");"	task4	
public class A { <line0> @Override <line1> public void printColumns(Collection<String> col) { <line2> if (col == null) { <line3> return; <line4> } <line5> if (log.isInfoEnabled()) { <line6> } <line7> String columns = null; <line8> if (!SILENT) { <line9> if (console != null) { <line10> columns = console.formatColumns(col); <line11> } <line12> } <line13> if (columns == null) { <line14> for (String s : col) { <line15> print(s, true, true); <line16> } <line17> } else { <line18> print(columns, false, true); <line19> } <line20> } <line21> } <line22> 	<line6>      log.info(col);	task4	
"public class A { <line0> @Override <line1> public StreamObserver<PingRequest> pingAsyncAsync(StreamObserver<PongResponse> responseObserver) { <line2> StreamObserver<PingRequest> requestObserver = <line3> new StreamObserver<PingRequest>() { <line4> private List<PingRequest> streamRequests = new LinkedList<>(); <line5>  <line6> @Override <line7> public void onNext(PingRequest request) { <line8> streamRequests.add(request); <line9> if (""error"".equals(request.getPingName())) { <line10> PingPongImpl.this.streamRequests.add(streamRequests); <line11> responseObserver.onError(new RuntimeException(""Requested error"")); <line12> } else { <line13> PongResponse response = <line14> PongResponse.newBuilder().setPongName(""Hello "" + request.getPingName()).build(); <line15> responseObserver.onNext(response); <line16> } <line17> } <line18>  <line19> @Override <line20> public void onError(Throwable t) { <line21> PingPongImpl.this.streamRequests.add(streamRequests); <line22> } <line23>  <line24> @Override <line25> public void onCompleted() { <line26> PingPongImpl.this.streamRequests.add(streamRequests); <line27> responseObserver.onCompleted(); <line28> } <line29> }; <line30> return requestObserver; <line31> } <line32> } <line33> "	"<line22>            LOG.info(""Error in pingAsyncAsync() {}"", t.getMessage());"	task4	
"public class A { <line0> public void testExampleFunctionsYamlMatch() throws IOException { <line1> Reader input = <line2> Streams.reader(new ResourceUtils(this).getResourceFromUrl(""example-with-function.yaml"")); <line3> DeploymentPlan plan = platform.pdp().parseDeploymentPlan(input); <line4> Map<?, ?> cfg1 = <line5> (Map<?, ?>) <line6> plan.getServices() <line7> .get(0) <line8> .getCustomAttributes() <line9> .get(BrooklynCampReservedKeys.BROOKLYN_CONFIG); <line10> Map<?, ?> cfg = MutableMap.copyOf(cfg1); <line11> Assert.assertEquals(cfg.remove(""literalValue1""), ""$brooklyn: is a fun place""); <line12> Assert.assertEquals(cfg.remove(""literalValue2""), ""$brooklyn: is a fun place""); <line13> Assert.assertEquals(cfg.remove(""literalValue3""), ""$brooklyn: is a fun place""); <line14> Assert.assertEquals(cfg.remove(""literalValue4""), ""$brooklyn: is a fun place""); <line15> Assert.assertEquals(cfg.remove(""$brooklyn:1""), ""key to the city""); <line16> Assert.assertTrue(cfg.isEmpty(), """" + cfg); <line17> Assert.assertEquals(plan.getName(), ""example-with-function""); <line18> Assert.assertEquals(plan.getCustomAttributes().get(""location""), ""localhost""); <line19> AssemblyTemplate at = platform.pdp().registerDeploymentPlan(plan); <line20> Assert.assertEquals(at.getName(), ""example-with-function""); <line21> Assert.assertEquals(at.getCustomAttributes().get(""location""), ""localhost""); <line22> PlatformComponentTemplate pct = <line23> at.getPlatformComponentTemplates().links().iterator().next().resolve(); <line24> Object cfg2 = pct.getCustomAttributes().get(BrooklynCampReservedKeys.BROOKLYN_CONFIG); <line25> Assert.assertEquals(cfg2, cfg1); <line26> } <line27> } <line28> "	"<line4>    log.info(""DP is:\n"" + plan.toString());"	task4	
"public class A { <line0> private void formatJSONResponse(JSONObject json) { <line1> try { <line2> JSONObject form = json.getJSONObject(""form""); <line3> putPropertyArrayToObject(form); <line4> Object fields = form.get(""field""); <line5> if (fields instanceof JSONArray) { <line6> for (int i = 0; i < ((JSONArray) fields).length(); ++i) { <line7> JSONObject field = ((JSONArray) fields).getJSONObject(i); <line8> putPropertyArrayToObject(field); <line9> } <line10> } else { <line11> putPropertyArrayToObject((JSONObject) fields); <line12> } <line13> } catch (JSONException e) { <line14> } <line15> } <line16> } <line17> "	"<line14>      logger.debug(""exception while formatting :: {}"", e.getMessage(), e);"	task4	
"public class A { <line0> @RequestMapping( <line1> value = ""lists/experiment-optional-parameters/edit.html"", <line2> method = RequestMethod.GET) <line3> protected String showEditForm( <line4> @RequestParam(""id"") String idString, <line5> @RequestParam(""groupid"") String idString2, <line6> ModelMap model, <line7> HttpServletRequest request) { <line8> AddExperimentOptParamDefCommand data = new AddExperimentOptParamDefCommand(); <line9> if (auth.userIsExperimenter() || auth.isAdmin()) { <line10> model.addAttribute(""userIsExperimenter"", true); <line11> if (idString2 != null) { <line12> int id = Integer.parseInt(idString2); <line13> data.setResearchGroupId(id); <line14> if (id != DEFAULT_ID) { <line15> String title = researchGroupDao.getResearchGroupTitle(id); <line16> data.setResearchGroupTitle(title); <line17> } else { <line18> String defaultExperimentOptParamDef = <line19> messageSource.getMessage( <line20> ""label.defaultExperimentOptParamDef"", <line21> null, <line22> RequestContextUtils.getLocale(request)); <line23> data.setResearchGroupTitle(defaultExperimentOptParamDef); <line24> } <line25> } <line26> if (idString != null) { <line27> int id = Integer.parseInt(idString); <line28> ExperimentOptParamDef experimentOptParamDef = experimentOptParamDefDao.read(id); <line29> data.setId(id); <line30> data.setParamName(experimentOptParamDef.getParamName()); <line31> data.setParamDataType(experimentOptParamDef.getParamDataType()); <line32> } <line33> model.addAttribute(""addExperimentOptParamDef"", data); <line34> return ""lists/measurationAdditionalParams/addItemForm""; <line35> } else { <line36> return ""lists/userNotExperimenter""; <line37> } <line38> } <line39> } <line40> "	"<line28>        log.debug(""Loading experimentOptParamDef to the command object for editing."");"	task4	
"public class A { <line0> @Override <line1> protected void doReceive(Message message) throws Exception { <line2> long backgroundTaskId = (Long) message.get(BackgroundTaskConstants.BACKGROUND_TASK_ID); <line3> BackgroundTask backgroundTask = _backgroundTaskManager.fetchBackgroundTask(backgroundTaskId); <line4> if (backgroundTask == null) { <line5> return; <line6> } <line7> Map<String, Serializable> taskContextMap = backgroundTask.getTaskContextMap(); <line8> boolean deleteOnCompetion = <line9> GetterUtil.getBoolean( <line10> taskContextMap.get(BackgroundTaskContextMapConstants.DELETE_ON_SUCCESS)); <line11> if (!deleteOnCompetion) { <line12> return; <line13> } <line14> int status = GetterUtil.getInteger(message.get(""status""), -1); <line15> if (status == -1) { <line16> return; <line17> } <line18> if (status == BackgroundTaskConstants.STATUS_SUCCESSFUL) { <line19> if (log.isInfoEnabled()) { <line20> } <line21> _backgroundTaskManager.deleteBackgroundTask(backgroundTaskId); <line22> } <line23> } <line24> } <line25> "	"<line20>        log.info(""Deleting background task "" + backgroundTask.toString());"	task4	
"public class A { <line0> @Override <line1> public RollbackVfModuleResponse rollbackVfModule( <line2> String aaiVnfId, String aaiVfModuleId, RollbackVfModuleRequest req) <line3> throws VnfAdapterClientException { <line4> try { <line5> return new AdapterRestClient( <line6> this.props, <line7> this.getUri(""/"" + aaiVnfId + VF_MODULES + aaiVfModuleId + ""/rollback"").build()) <line8> .delete(req, RollbackVfModuleResponse.class); <line9> } catch (InternalServerErrorException e) { <line10> throw new VnfAdapterClientException(e.getMessage()); <line11> } <line12> } <line13> } <line14> "	"<line10>      logger.error(""InternalServerErrorException in rollbackVfModule"", e);"	task4	
"public class A { <line0> public void setValueAsString(String s) throws ParseException { <line1> if (getConcept() != null && !StringUtils.isBlank(s)) { <line2> String abbrev = getConcept().getDatatype().getHl7Abbreviation(); <line3> if (""BIT"".equals(abbrev)) { <line4> setValueBoolean(Boolean.valueOf(s)); <line5> } else if (""CWE"".equals(abbrev)) { <line6> throw new RuntimeException(""Not Yet Implemented""); <line7> } else if (""NM"".equals(abbrev) || ""SN"".equals(abbrev)) { <line8> setValueNumeric(Double.valueOf(s)); <line9> } else if (""DT"".equals(abbrev)) { <line10> DateFormat dateFormat = new SimpleDateFormat(DATE_PATTERN); <line11> setValueDatetime(dateFormat.parse(s)); <line12> } else if (""TM"".equals(abbrev)) { <line13> DateFormat timeFormat = new SimpleDateFormat(TIME_PATTERN); <line14> setValueDatetime(timeFormat.parse(s)); <line15> } else if (""TS"".equals(abbrev)) { <line16> DateFormat datetimeFormat = new SimpleDateFormat(DATE_TIME_PATTERN); <line17> setValueDatetime(datetimeFormat.parse(s)); <line18> } else if (""ST"".equals(abbrev)) { <line19> setValueText(s); <line20> } else { <line21> throw new RuntimeException(""Don't know how to handle "" + abbrev); <line22> } <line23> } else { <line24> throw new RuntimeException(""concept is null for "" + this); <line25> } <line26> } <line27> } <line28> "	"<line1>    log.debug(""getConcept() == {}"", getConcept());"	task4	
public class A { <line0> @Override <line1> public boolean init(JVSTMConfig jvstmConfig) { <line2> try { <line3> initConcreteDataGrid((JvstmDataGridConfig) jvstmConfig); <line4> } catch (Exception e) { <line5> throw new RuntimeException(e); <line6> } <line7> return bootstrapIfNeeded(); <line8> } <line9> } <line10> 	"<line5>      logger.error(""Failed to initialize data grid: {}"", e);"	task4	
public class A { <line0> private void initFile(File writeOnlyFile) throws IOException { <line1> if (writeOnlyFile.exists()) { <line2> writeOnlyFile.delete(); <line3> } <line4> if (!writeOnlyFile.getParentFile().exists()) { <line5> writeOnlyFile.getParentFile().mkdir(); <line6> } <line7> writeOnlyFile.createNewFile(); <line8> writeOnlyFile.deleteOnExit(); <line9> addShutDownHook(); <line10> } <line11> } <line12> 	"<line8>    LOG.info(""Spilling to file location ""+ writeOnlyFile.getAbsolutePath()+ "" in host (""+ InetAddress.getLocalHost().getHostAddress()+ "") with hostname (""+ InetAddress.getLocalHost().getHostName()+ "")"");"	task4	
public class A { <line0> @Override <line1> protected void doGet(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> if (!httpAuth.isAllowed(req, resp)) { <line4> return; <line5> } <line6> final long start = System.currentTimeMillis(); <line7> final CollectorController collectorController = new CollectorController(collectorServer); <line8> final String application = collectorController.getApplication(req, resp); <line9> I18N.bindLocale(req.getLocale()); <line10> try { <line11> if (application == null) { <line12> CollectorController.writeOnlyAddApplication(resp); <line13> return; <line14> } <line15> if (!collectorServer.isApplicationDataAvailable(application) <line16> && HttpParameter.ACTION.getParameterFrom(req) == null) { <line17> CollectorController.writeDataUnavailableForApplication(application, resp); <line18> return; <line19> } <line20> collectorController.doMonitoring(req, resp, application); <line21> } finally { <line22> I18N.unbindLocale(); <line23> if (LOGGER.isDebugEnabled()) { <line24> } <line25> } <line26> } <line27> } <line28> 	"<line24>        LOGGER.debug(""monitoring from ""+ req.getRemoteAddr()+ "", request=""+ req.getRequestURI()+ (req.getQueryString() != null ? '?' + req.getQueryString() : """")+ "", application=""+ application+ "" in ""+ (System.currentTimeMillis() - start)+ ""ms"");"	task4	
public class A { <line0> private Either<GroupDefinition, ResponseFormat> buildGroupDefinition( <line1> List<ArtifactDefinition> createdArtifacts, <line2> List<GroupDefinition> heatGroups, <line3> ArtifactTemplateInfo groupTemplateInfo, <line4> String groupName, <line5> Set<String> artifactsGroup, <line6> Set<String> artifactsUUIDGroup) { <line7> Map<String, String> members = new HashMap<>(); <line8> associateMembersToArtifacts(createdArtifacts, null, heatGroups, artifactsGroup, members); <line9> List<String> artifactsList = new ArrayList<>(artifactsGroup); <line10> List<String> artifactsUUIDList = new ArrayList<>(artifactsUUIDGroup); <line11> GroupDefinition groupDefinition = new GroupDefinition(); <line12> groupDefinition.setName(groupName); <line13> groupDefinition.setType(Constants.DEFAULT_GROUP_VF_MODULE); <line14> groupDefinition.setArtifacts(artifactsList); <line15> groupDefinition.setArtifactsUuid(artifactsUUIDList); <line16> if (!members.isEmpty()) { <line17> groupDefinition.setMembers(members); <line18> } <line19> List<GroupProperty> properties = new ArrayList<>(); <line20> GroupProperty prop = new GroupProperty(); <line21> prop.setName(Constants.IS_BASE); <line22> prop.setValue(Boolean.toString(groupTemplateInfo.isBase())); <line23> properties.add(prop); <line24> Either<GroupTypeDefinition, StorageOperationStatus> getLatestGroupTypeRes = <line25> groupTypeOperation.getLatestGroupTypeByType(Constants.DEFAULT_GROUP_VF_MODULE, true); <line26> if (getLatestGroupTypeRes.isRight()) { <line27> return Either.right( <line28> componentsUtils.getResponseFormat( <line29> componentsUtils.convertFromStorageResponse(getLatestGroupTypeRes.right().value()))); <line30> } <line31> properties = <line32> createVfModuleAdditionalProperties( <line33> groupTemplateInfo.isBase(), <line34> groupName, <line35> properties, <line36> createdArtifacts, <line37> artifactsList, <line38> getLatestGroupTypeRes.left().value()); <line39> groupDefinition.convertFromGroupProperties(properties); <line40> return Either.left(groupDefinition); <line41> } <line42> } <line43> 	"<line40>    log.debug(""createGroup start"");"	task4	
public class A { <line0> public Signature invokeSigning() throws SignatureTokenMissingException { <line1> if (signatureToken == null) { <line2> throw new SignatureTokenMissingException(); <line3> } <line4> return invokeSigningProcess(); <line5> } <line6> } <line7> 	"<line2>      logger.error(""Cannot invoke signing without signature token. Add 'withSignatureToken()' method call or""+ "" call 'buildDataToSign() instead.'"");"	task4	
public class A { <line0> @Override <line1> public void onComplete(final Exchange exchange) { <line2> try { <line3> executor.submit(new RunCommand(successCommand, exchange)).get(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.error(""Could not run completion of exchange {}"", exchange, e);"	task4	
public class A { <line0> public static Type[] getGenericTypes(Field f) { <line1> if (f != null) { <line2> try { <line3> ParameterizedType pt = (ParameterizedType) f.getGenericType(); <line4> return (Type[]) pt.getActualTypeArguments(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> return null; <line9> } <line10> } <line11> 	"<line6>        log.debug(""Unable to retrieve generic type of field: "" + f, e);"	task4	
"public class A { <line0> public static String getVarValue( <line1> String varName, <line2> Field field, <line3> Validator validator, <line4> HttpServletRequest request, <line5> boolean required) { <line6> Var var = field.getVar(varName); <line7> if (var == null) { <line8> String msg = sysmsgs.getMessage(""variable.missing"", varName); <line9> if (required) { <line10> throw new IllegalArgumentException(msg); <line11> } <line12> if (log.isDebugEnabled()) { <line13> } <line14> return null; <line15> } <line16> ServletContext application = <line17> (ServletContext) validator.getParameterValue(SERVLET_CONTEXT_PARAM); <line18> return getVarValue(var, application, request, required); <line19> } <line20> } <line21> "	"<line13>        log.debug(field.getProperty() + "": "" + msg);"	task4	
"public class A { <line0> public List<String> listTables() throws SQLException { <line1> List<String> ret = new ArrayList<>(); <line2> if (tablesCache.size() == 0) { <line3> try (Connection conn = getConnection(); <line4> ResultSet rs = conn.getMetaData().getTables(null, null, null, null)) { <line5> while (rs.next()) { <line6> String name = rs.getString(TABLE_NAME); <line7> String database = <line8> rs.getString(TABLE_SCHEM) != null <line9> ? rs.getString(TABLE_SCHEM) <line10> : rs.getString(""TABLE_CAT""); <line11> String cacheKey = joiner.join(config.datasourceId, config.url, database, ""tables""); <line12> List<String> cachedTables = tablesCache.getIfPresent(cacheKey); <line13> if (cachedTables == null) { <line14> cachedTables = new ArrayList<>(); <line15> tablesCache.put(cacheKey, cachedTables); <line16> } <line17> if (!cachedTables.contains(name)) { <line18> cachedTables.add(name); <line19> } <line20> ret.add(name); <line21> } <line22> } <line23> } else { <line24> for (Map.Entry<String, List<String>> entry : tablesCache.asMap().entrySet()) { <line25> ret.addAll(entry.getValue()); <line26> } <line27> } <line28> return ret; <line29> } <line30> } <line31> "	"<line16>            logger.debug(""Add table cache for database {}"", database);"	task4	
"public class A { <line0> protected void processRequest( <line1> HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) <line2> throws ServletException, IOException { <line3> try { <line4> ApplicationContext appContext = <line5> WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); <line6> testcaseService = appContext.getBean(ITestCaseService.class); <line7> applicationService = appContext.getBean(IApplicationService.class); <line8> PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS); <line9> String test = policy.sanitize(httpServletRequest.getParameter(""test"")); <line10> String testcase = policy.sanitize(httpServletRequest.getParameter(""testcase"")); <line11> JSONObject export = new JSONObject(); <line12> export.put(""version"", Infos.getInstance().getProjectVersion()); <line13> export.put(""user"", httpServletRequest.getUserPrincipal()); <line14> SimpleDateFormat formatter = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSSXXX""); <line15> export.put(""date"", formatter.format(new Date())); <line16> TestCase tcInfo = testcaseService.findTestCaseByKeyWithDependency(test, testcase); <line17> ObjectMapper mapper = new ObjectMapper(); <line18> JSONObject tcInfoJSON = new JSONObject(mapper.writeValueAsString(tcInfo)); <line19> tcInfoJSON.remove(""bugs""); <line20> tcInfoJSON.put(""bugs"", tcInfo.getBugs()); <line21> tcInfoJSON.remove(""conditionOptions""); <line22> tcInfoJSON.put(""conditionOptions"", tcInfo.getConditionOptions()); <line23> JSONArray tcJA = new JSONArray(); <line24> tcJA.add(tcInfoJSON); <line25> export.put(""testcases"", tcJA); <line26> Application appInfo = <line27> applicationService.convert(applicationService.readByKey(tcInfo.getApplication())); <line28> JSONObject app = new JSONObject(mapper.writeValueAsString(appInfo)); <line29> export.put(""application"", app); <line30> export.put(""invariants"", new JSONArray()); <line31> export.put(""applicationsObjects"", new JSONArray()); <line32> export.put(""datalibs"", new JSONArray()); <line33> export.put(""services"", new JSONArray()); <line34> export.put(""libraryTestcases"", new JSONArray()); <line35> httpServletResponse.setContentType(""application/json""); <line36> httpServletResponse.setHeader( <line37> ""Content-Disposition"", <line38> ""attachment; filename=\"""" + getFilename(test, testcase) + "".json\""""); <line39> httpServletResponse.getOutputStream().print(export.toString(1)); <line40> } catch (CerberusException | JSONException ex) { <line41> } <line42> } <line43> } <line44> "	<line41>      LOG.warn(ex);	task4	
public class A { <line0> public static void skipSubTree(Logger log, XmlPullParser xpp) <line1> throws XmlPullParserException, IOException { <line2> if (log.isDebugEnabled()) { <line3> } <line4> XmlPullUtil.skipSubTree(xpp); <line5> } <line6> } <line7> 	"<line3>      log.debug(""[DSU] skip "" + xpp.getName());"	task4	
public class A { <line0> protected void addSensor(Map<String, CoIotDescrSen> sensorMap, String key, String json) { <line1> try { <line2> if (!sensorMap.containsKey(key)) { <line3> CoIotDescrSen sen = gson.fromJson(json, CoIotDescrSen.class); <line4> if (sen != null) { <line5> sensorMap.put(key, sen); <line6> } <line7> } <line8> } catch (JsonSyntaxException e) { <line9> } <line10> } <line11> } <line12> 	"<line9>      logger.trace(""Unable to parse sensor definition: {}"", json, e);"	task4	
public class A { <line0> private void initializeRegistryRoot() { <line1> try { <line2> registryRoot = registryHelper.ensureDirectory(PIPELINE_EXECUTOR_REGISTRY_PATH); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.error(""An error was produced during ""+ VFSPipelineExecutorRegistry.class.getName()+ "" directories initialization."",e);"	task4	
public class A { <line0> public void setFilter(WorkspaceFilter filter, boolean autoSave) { <line1> try { <line2> JcrWorkspaceFilter.saveFilter(filter, defNode, autoSave); <line3> } catch (RepositoryException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.error(""Error while saving filter."", e);"	task4	
public class A { <line0> @Override <line1> public String extract(FileEntry fileEntry, Locale locale) { <line2> try { <line3> FileVersion fileVersion = fileEntry.getFileVersion(); <line4> try (InputStream inputStream = fileVersion.getContentStream(false)) { <line5> return FileUtil.extractText(inputStream, fileVersion.getFileName()); <line6> } <line7> } catch (Exception exception) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
"public class A { <line0> @Test <line1> public void testResponseUp() { <line2> WebTarget target = target().path(""logs""); <line3> String s = target.request().get(String.class); <line4> assertEquals(""Logs resource is up!"", s); <line5> } <line6> } <line7> "	"<line2>    log.info(""Testing log resource"");"	task4	
public class A { <line0> public static void removeLogFilesFromMining(OracleConnection conn) throws SQLException { <line1> try (PreparedStatement ps = conn.connection(false).prepareStatement(SqlUtils.FILES_FOR_MINING); <line2> ResultSet result = ps.executeQuery()) { <line3> Set<String> files = new LinkedHashSet<>(); <line4> while (result.next()) { <line5> files.add(result.getString(1)); <line6> } <line7> for (String fileName : files) { <line8> executeCallableStatement(conn, SqlUtils.deleteLogFileStatement(fileName)); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line9>        LOGGER.debug(""File {} was removed from mining"", fileName);"	task4	
"public class A { <line0> @Override <line1> public Authentication authenticate(Authentication authentication) throws AuthenticationException { <line2> try { <line3> if (null == authentication <line4> || null == authentication.getPrincipal() <line5> || null == authentication.getCredentials()) { <line6> throw new UsernameNotFoundException(""Invalid principal and/or credentials""); <line7> } <line8> UserDetails user = <line9> this.extractUser( <line10> authentication.getPrincipal().toString(), <line11> authentication.getCredentials().toString(), <line12> false); <line13> if (null != user) { <line14> Authentication newAuth = <line15> new UsernamePasswordAuthenticationToken( <line16> authentication.getPrincipal(), <line17> authentication.getCredentials(), <line18> user.getAuthorizations()); <line19> return newAuth; <line20> } else { <line21> throw new UsernameNotFoundException(""Invalid username/password""); <line22> } <line23> } catch (AuthenticationException e) { <line24> throw e; <line25> } catch (Exception e) { <line26> throw new AuthenticationServiceException(""Error detected during user authentication"", e); <line27> } <line28> } <line29> } <line30> "	"<line26>      logger.error(""Error detected during user authentication"", e);"	task4	
public class A { <line0> private static String getCnd(NodeTypeDefinition def) { <line1> StringWriter out = new StringWriter(); <line2> CompactNodeTypeDefWriter cndWriter = <line3> new CompactNodeTypeDefWriter( <line4> out, <line5> new CompactNodeTypeDefWriter.NamespaceMapping() { <line6> @Override <line7> public String getNamespaceURI(String s) { <line8> return s; <line9> } <line10> }, <line11> false); <line12> try { <line13> cndWriter.write(def); <line14> } catch (IOException e) { <line15> throw new IllegalStateException(e); <line16> } <line17> return out.toString(); <line18> } <line19> } <line20> 	"<line15>      log.error(""Error generating CND of "" + def, e);"	task4	
public class A { <line0> @Override <line1> public Plugin<T> cloneMe() { <line2> SiegfriedPlugin<T> siegfriedPlugin = new SiegfriedPlugin<>(); <line3> try { <line4> siegfriedPlugin.init(); <line5> } catch (PluginException e) { <line6> } <line7> return siegfriedPlugin; <line8> } <line9> } <line10> 	"<line6>      LOGGER.error(""Error doing {} init"", SiegfriedPlugin.class.getName(), e);"	task4	
"public class A { <line0> private IdentifierNode cutTypeIdentifier(IdentifierNode typeIdentifierNode) { <line1> try { <line2> IdentifierNode[] variableAndType = <line3> Tokenizer.tokenize( <line4> typeIdentifierNode.getModule(), SpreadsheetSymbols.TYPE_DELIMITER.toString()); <line5> if (variableAndType.length > 1) { <line6> IdentifierNode[] nodes = <line7> Tokenizer.tokenize( <line8> typeIdentifierNode.getModule(), "" []\n\r"", variableAndType[1].getLocation()); <line9> if (nodes.length > 0) { <line10> return nodes[0]; <line11> } <line12> } <line13> } catch (OpenLCompilationException e) { <line14> SyntaxNodeException error = <line15> SyntaxNodeExceptionUtils.createError(""Cannot parse header."", typeIdentifierNode); <line16> getBindingContext().addError(error); <line17> } <line18> return null; <line19> } <line20> } <line21> "	"<line17>      LOG.debug(""Error occurred: "", e);"	task4	
public class A { <line0> public void fatal(Object message, Throwable t, Object... args) { <line1> if (log.isFatalEnabled()) { <line2> } <line3> } <line4> } <line5> 	<line2>      log.fatal(MessageFormat.format(message.toString(), args), t);	task4	
public class A { <line0> @Override <line1> protected void updateOutput() { <line2> if (!mLit) { <line3> highTurnout.getBean().setCommandedState(Turnout.CLOSED); <line4> } else if (!mFlashOn <line5> && ((mAppearance == FLASHGREEN) <line6> || (mAppearance == FLASHYELLOW) <line7> || (mAppearance == FLASHRED))) { <line8> highTurnout.getBean().setCommandedState(Turnout.CLOSED); <line9> } else { <line10> switch (mAppearance) { <line11> case FLASHRED: <line12> case RED: <line13> lowTurnout.getBean().setCommandedState(Turnout.THROWN); <line14> break; <line15> case FLASHYELLOW: <line16> case YELLOW: <line17> highTurnout.getBean().setCommandedState(Turnout.THROWN); <line18> break; <line19> case FLASHGREEN: <line20> case GREEN: <line21> lowTurnout.getBean().setCommandedState(Turnout.CLOSED); <line22> break; <line23> case DARK: <line24> highTurnout.getBean().setCommandedState(Turnout.CLOSED); <line25> break; <line26> default: <line27> } <line28> } <line29> } <line30> } <line31> 	"<line27>          log.error(""Invalid state request: {}"", mAppearance);"	task4	
public class A { <line0> @Override <line1> public void ping() { <line2> invocationCount++; <line3> } <line4> } <line5> 	"<line3>    LOG.info(""call for oneway ping"");"	task4	
public class A { <line0> protected void tryTransform(MachineLocation machine, AttributeSensor<?> sensor) { <line1> Object sensorVal = entity.sensors().get(sensor); <line2> if (sensorVal == null) { <line3> return; <line4> } <line5> Maybe<String> newVal = transformVal(machine, sensor, sensorVal); <line6> if (newVal.isAbsent()) { <line7> return; <line8> } <line9> AttributeSensor<String> mappedSensor = <line10> Sensors.newStringSensor(sensorNameConverter.apply(sensor.getName())); <line11> if (newVal.get().equals(entity.sensors().get(mappedSensor))) { <line12> return; <line13> } <line14> entity.sensors().set(mappedSensor, newVal.get()); <line15> } <line16> } <line17> 	"<line14>    LOG.debug(""{} publishing value {} (original sensor value {}) for mapped sensor {}, of entity {}"",new Object[] {this, newVal.get(), sensorVal, mappedSensor, entity});"	task4	
"public class A { <line0> private void createHealthNodes( <line1> GraphDBHandler dbHandler, <line2> String routingKey, <line3> List<JsonObject> dataList, <line4> String agentId, <line5> String nodeLabels, <line6> int nodeCount, <line7> String latestLabel) <line8> throws InsightsCustomException { <line9> String healthQuery; <line10> if (!agentId.equalsIgnoreCase("""")) { <line11> healthQuery = ""Match""; <line12> healthQuery = healthQuery + "" (old"" + nodeLabels + "")""; <line13> healthQuery = healthQuery + "" where old.agentId='"" + agentId + ""' or old.agentId is null""; <line14> healthQuery = <line15> healthQuery <line16> + "" OPTIONAL MATCH (old) <-[:UPDATED_TO*"" <line17> + nodeCount <line18> + ""]-(purge)  where old.agentId='"" <line19> + agentId <line20> + ""'""; <line21> healthQuery = healthQuery + CREATE + nodeLabels + "" {props}) ""; <line22> healthQuery = healthQuery + "" MERGE  (new)<-[r:UPDATED_TO]-(old)""; <line23> healthQuery = healthQuery + "" REMOVE old:"" + latestLabel; <line24> healthQuery = healthQuery + "" detach delete purge ""; <line25> healthQuery = healthQuery + "" return old,new""; <line26> } else { <line27> healthQuery = ""Match (old"" + nodeLabels + "")""; <line28> healthQuery = <line29> healthQuery + "" OPTIONAL MATCH (old) <-[:UPDATED_TO*"" + nodeCount + ""]-(purge) ""; <line30> healthQuery = healthQuery + CREATE + nodeLabels + "" {props})""; <line31> healthQuery = healthQuery + "" MERGE  (new)<-[r:UPDATED_TO]-(old)""; <line32> healthQuery = healthQuery + "" REMOVE old:"" + latestLabel; <line33> healthQuery = healthQuery + "" detach delete purge ""; <line34> healthQuery = healthQuery + "" return old,new""; <line35> } <line36> JsonObject graphResponse = dbHandler.executeQueryWithData(healthQuery, dataList); <line37> if (graphResponse <line38> .get(""response"") <line39> .getAsJsonObject() <line40> .get(""results"") <line41> .getAsJsonArray() <line42> .get(0) <line43> .getAsJsonObject() <line44> .get(""data"") <line45> .getAsJsonArray() <line46> .size() <line47> == 0) { <line48> healthQuery = """"; <line49> healthQuery = healthQuery + CREATE + nodeLabels + "" {props})""; <line50> JsonObject graphResponse1 = dbHandler.executeQueryWithData(healthQuery, dataList); <line51> parseGraphResponseForError(graphResponse1, routingKey); <line52> } <line53> parseGraphResponseForError(graphResponse, routingKey); <line54> } <line55> } <line56> "	"<line48>      log.debug(""Another Health query {} "", healthQuery);"	task4	
"public class A { <line0> public void recordImportFailure(Owner owner, Throwable error, String filename) { <line1> ImportRecord record = new ImportRecord(owner); <line2> if (error instanceof ImporterException) { <line3> Meta meta = (Meta) ((ImporterException) error).getCollectedData().get(""meta""); <line4> if (meta != null) { <line5> record.setGeneratedBy(meta.getPrincipalName()); <line6> record.setGeneratedDate(meta.getCreated()); <line7> } <line8> } <line9> record.setUpstreamConsumer(createImportUpstreamConsumer(owner, null)); <line10> record.setFileName(filename); <line11> record.recordStatus(ImportRecord.Status.FAILURE, error.getMessage()); <line12> this.importRecordCurator.create(record); <line13> } <line14> } <line15> "	"<line2>    log.error(""Recording import failure"", error);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> if (log.isDebugEnabled()) { <line3> } <line4> ApplicationsEventPublisher.sendCompleteApplicationsEvent(ApplicationHolder.getApplications()); <line5> } <line6> } <line7> 	"<line3>      log.debug(""Executing applications synchronization task"");"	task4	
"public class A { <line0> @Test <line1> public void test_apply_variant_01() { <line2> Variant variant = new Variant(transcript.getParent(), 290, ""TTT"", ""AAA""); <line3> checkApplyMnp(variant, transcript.cds(), transcript.protein(), 1, 300, 399); <line4> } <line5> } <line6> "	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> public boolean clientExistsThenEvict(Integer demographicNo) { <line1> boolean exists = false; <line2> Demographic existingDemo = this.getClientByDemographicNo(demographicNo); <line3> exists = (existingDemo != null); <line4> if (exists) this.getHibernateTemplate().evict(existingDemo); <line5> return exists; <line6> } <line7> } <line8> 	"<line5>    log.debug(""exists (then evict): "" + exists);"	task4	
public class A { <line0> public static com.liferay.dynamic.data.lists.model.DDLRecordVersionSoap[] getRecordVersions( <line1> long recordId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.dynamic.data.lists.model.DDLRecordVersion> returnValue = <line4> DDLRecordVersionServiceUtil.getRecordVersions(recordId); <line5> return com.liferay.dynamic.data.lists.model.DDLRecordVersionSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> void attachDeploymentErrors( <line1> @NotNull ServiceSingleNodeDeploymentResult depRes, @Nullable Collection<Throwable> errors) { <line2> if (F.isEmpty(errors)) return; <line3> Collection<byte[]> errorsBytes = new ArrayList<>(); <line4> for (Throwable th : errors) { <line5> try { <line6> byte[] arr = U.marshal(ctx, th); <line7> errorsBytes.add(arr); <line8> } catch (IgniteCheckedException e) { <line9> } <line10> } <line11> depRes.errors(errorsBytes); <line12> } <line13> } <line14> 	"<line9>        log.error(""Failed to marshal deployment error, err="" + th, e);"	task4	
"public class A { <line0> public void testType3Message() throws Exception { <line1> try { <line2> MessageDigest.getInstance(""MD4""); <line3> } catch (NoSuchAlgorithmException ex) { <line4> return; <line5> } <line6> int flags = 0x00000001 | 0x00000200 | 0x00010000 | 0x00800000; <line7> String msg = <line8> ""4e544c4d53535000020000000c000c003000000001028100"" <line9> + ""0123456789abcdef0000000000000000620062003c000000"" <line10> + ""44004f004d00410049004e0002000c0044004f004d004100"" <line11> + ""49004e0001000c0053004500520056004500520004001400"" <line12> + ""64006f006d00610069006e002e0063006f006d0003002200"" <line13> + ""7300650072007600650072002e0064006f006d0061006900"" <line14> + ""6e002e0063006f006d0000000000""; <line15> byte[] challengePacket = ByteUtilities.asByteArray(msg); <line16> int serverFlags = NTLMUtilities.extractFlagsFromType2Message(challengePacket); <line17> assertEquals(flags, serverFlags); <line18> NTLMUtilities.printTargetInformationBlockFromType2Message( <line19> challengePacket, serverFlags, new PrintWriter(System.out, true)); <line20> byte[] osVer = new byte[8]; <line21> NTLMUtilities.writeOSVersion((byte) 5, (byte) 0, (short) 2195, osVer, 0); <line22> byte[] challenge = NTLMUtilities.extractChallengeFromType2Message(challengePacket); <line23> assertEquals(""0123456789abcdef"", asHex(challenge)); <line24> String expectedTargetInfoBlock = <line25> ""02000c0044004f004d00410049004e00"" <line26> + ""01000c00530045005200560045005200"" <line27> + ""0400140064006f006d00610069006e00"" <line28> + ""2e0063006f006d000300220073006500"" <line29> + ""72007600650072002e0064006f006d00"" <line30> + ""610069006e002e0063006f006d000000"" <line31> + ""0000""; <line32> byte[] targetInfo = NTLMUtilities.extractTargetInfoFromType2Message(challengePacket, null); <line33> assertEquals(expectedTargetInfoBlock, asHex(targetInfo)); <line34> assertEquals( <line35> ""DOMAIN"", NTLMUtilities.extractTargetNameFromType2Message(challengePacket, serverFlags)); <line36> serverFlags = 0x00000001 | 0x00000200; <line37> String msgType3 = <line38> asHex( <line39> NTLMUtilities.createType3Message( <line40> ""user"", ""SecREt01"", challenge, ""DOMAIN"", ""WORKSTATION"", serverFlags, null)); <line41> String expected = <line42> ""4e544c4d5353500003000000180018006a00000018001800"" <line43> + ""820000000c000c0040000000080008004c00000016001600"" <line44> + ""54000000000000009a0000000102000044004f004d004100"" <line45> + ""49004e00750073006500720057004f0052004b0053005400"" <line46> + ""4100540049004f004e00c337cd5cbd44fc9782a667af6d42"" <line47> + ""7c6de67c20c2d3e77c5625a98c1c31e81847466b29b2df46"" <line48> + ""80f39958fb8c213a9cc6""; <line49> assertEquals(expected, msgType3); <line50> } <line51> } <line52> "	"<line4>      logger.warn(""No MD4 digest provider found !"");"	task4	
public class A { <line0> @Override <line1> public void memberAttributeChanged(MemberAttributeEvent memberAttributeEvent) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	"<line3>      log.debug(""Member attribute changed: [""+ memberAttributeEvent.getKey()+ ""] ""+ memberAttributeEvent.getValue());"	task4	
"public class A { <line0> private String getFirstSchemaValueFromJson(JSONObject jsonObject) throws CharonException { <line1> String value = null; <line2> try { <line3> JSONArray schemas = jsonObject.getJSONArray(ResponseCodeConstants.SCHEMAS); <line4> value = schemas.getString(0); <line5> } catch (JSONException e) { <line6> value = getStringValueFromJson(jsonObject, ResponseCodeConstants.SCHEMAS); <line7> if (value == null) { <line8> throw new CharonException( <line9> ""could not retrieve the 'schemas' field from the given json resource""); <line10> } <line11> } <line12> return value; <line13> } <line14> } <line15> "	"<line6>      logger.debug(""could not get '{}' value from scim resource as an array"", ResponseCodeConstants.SCHEMAS);"	task4	
"public class A { <line0> @Override <line1> public void updateDomain(User actor, String uuid, String domain) throws BusinessException { <line2> checkPermissions(actor); <line3> if (!actor.hasSuperAdminRole()) { <line4> throw new BusinessException( <line5> BusinessErrorCode.CANNOT_UPDATE_USER, <line6> ""Only superadmins can update an inconsistent user.""); <line7> } <line8> User u = userRepository.findByLsUuid(uuid); <line9> AbstractDomain d = abstractDomainService.retrieveDomain(domain); <line10> if (u == null) { <line11> throw new BusinessException( <line12> BusinessErrorCode.USER_NOT_FOUND, <line13> ""Attempt to update an user entity failed : User not found.""); <line14> } else if (d == null) { <line15> throw new BusinessException( <line16> BusinessErrorCode.DOMAIN_DO_NOT_EXIST, <line17> ""Attempt to update an user entity failed : Domain does not exist.""); <line18> } <line19> User userInTargetDomain = userRepository.findByMailAndDomain(domain, u.getMail()); <line20> if (userInTargetDomain != null) { <line21> throw new BusinessException( <line22> BusinessErrorCode.USER_ALREADY_EXISTS_IN_DOMAIN_TARGET, <line23> ""Attempt to update an user entity failed : The user : "" <line24> + u.getFullName() <line25> + "" is already in the Domain : "" <line26> + domain); <line27> } <line28> u.setDomain(d); <line29> userRepository.update(u); <line30> } <line31> } <line32> "	"<line10>    logger.info(""Trying to set inconsistent user '"" + u + ""' domain to '"" + d + ""'."");"	task4	
"public class A { <line0> @Test <line1> public void testLedgerDeleteWithExistingEntryLogs() throws Exception { <line2> LedgerHandle[] lhs = writeLedgerEntries(3, 1024, 1024); <line3> restartBookies(); <line4> for (LedgerHandle lh : lhs) { <line5> bkc.deleteLedger(lh.getId()); <line6> } <line7> Thread.sleep(2 * baseConf.getGcWaitTime()); <line8> for (File ledgerDirectory : tmpDirs) { <line9> assertFalse( <line10> ""Found the entry log file ([0,1].log) that should have been deleted in ledgerDirectory: "" <line11> + ledgerDirectory, <line12> TestUtils.hasLogFiles(ledgerDirectory, true, 0, 1)); <line13> } <line14> } <line15> } <line16> "	"<line7>    LOG.info(""Finished deleting all ledgers so waiting for the GC thread to clean up the entryLogs"");"	task4	
public class A { <line0> @Override <line1> public void instantiateServiceInstance() { <line2> endpointRpcRegistry = new EndpointRpcRegistry(dataBroker); <line3> serviceRpcRegistration = rpcProviderRegistry.addRpcImplementation(EndpointService.class, this); <line4> } <line5> } <line6> 	"<line2>    LOG.info(""Instantiating {}"", this.getClass().getSimpleName());"	task4	
public class A { <line0> @Override <line1> public void onInboundMessage(JmsInboundMessageDispatch envelope) { <line2> envelope.setConsumerInfo(consumerInfo); <line3> stateLock.lock(); <line4> try { <line5> if (envelope.isEnqueueFirst()) { <line6> this.messageQueue.enqueueFirst(envelope); <line7> } else { <line8> this.messageQueue.enqueue(envelope); <line9> } <line10> if (messageQueue.isRunning()) { <line11> try { <line12> dispatcher.execute(() -> deliverNextPending()); <line13> } catch (RejectedExecutionException rje) { <line14> } <line15> } <line16> } finally { <line17> stateLock.unlock(); <line18> } <line19> } <line20> } <line21> 	"<line14>          LOG.debug(""Rejected on attempt to queue message dispatch"", rje);"	task4	
"public class A { <line0> void insertNewAttachmentOnTaskUpdate(TaskImpl newTaskImpl, Attachment attachment) <line1> throws AttachmentPersistenceException { <line2> AttachmentImpl attachmentImpl = (AttachmentImpl) attachment; <line3> initAttachment(attachmentImpl, newTaskImpl); <line4> try { <line5> attachmentMapper.insert(attachmentImpl); <line6> if (LOGGER.isDebugEnabled()) { <line7> } <line8> } catch (PersistenceException e) { <line9> throw new AttachmentPersistenceException( <line10> String.format( <line11> ""Cannot insert the Attachement %s for Task %s  because it already exists."", <line12> attachmentImpl.getId(), newTaskImpl.getId()), <line13> e.getCause()); <line14> } <line15> } <line16> } <line17> "	"<line7>        LOGGER.debug(""TaskService.updateTask() for TaskId={} INSERTED an Attachment={}."",newTaskImpl.getId(),attachmentImpl);"	task4	
"public class A { <line0> private void showGenericErrorNotification(NotificationController nc) { <line1> Platform.runLater( <line2> () -> { <line3> nc.addNotification(""Sorry, there was an error.""); <line4> }); <line5> } <line6> } <line7> "	"<line3>          logger.warn(""Generic error warning."");"	task4	
"public class A { <line0> private String getServicePrincipalName( <line1> final HttpRequest request, final HttpClientContext clientContext) { <line2> String spn = null; <line3> if (this.servicePrincipalName != null) { <line4> spn = this.servicePrincipalName; <line5> } else if (challengeType == ChallengeType.PROXY) { <line6> final RouteInfo route = clientContext.getHttpRoute(); <line7> if (route != null) { <line8> spn = ""HTTP/"" + route.getProxyHost().getHostName(); <line9> } else { <line10> spn = null; <line11> } <line12> } else { <line13> final URIAuthority authority = request.getAuthority(); <line14> if (authority != null) { <line15> spn = ""HTTP/"" + authority.getHostName(); <line16> } else { <line17> final RouteInfo route = clientContext.getHttpRoute(); <line18> if (route != null) { <line19> spn = ""HTTP/"" + route.getTargetHost().getHostName(); <line20> } else { <line21> spn = null; <line22> } <line23> } <line24> } <line25> if (LOG.isDebugEnabled()) { <line26> } <line27> return spn; <line28> } <line29> } <line30> "	"<line26>      LOG.debug(""Using SPN: {}"", spn);"	task4	
public class A { <line0> @Override <line1> public void start() throws Exception { <line2> TestConfig tc = TestConfig.getInstance(); <line3> Executor exec = Executor.getInstance(); <line4> Set<Class<? extends IPerfTest>> scenarios = exec.getScenarios(tc.getTestPackage()); <line5> if (scenarios.size() == 1) { <line6> IPerfTest scenario = scenarios.iterator().next().newInstance(); <line7> exec.initMetrics(scenario); <line8> scenario.init(); <line9> if (tc.isWarmUp()) { <line10> exec.performWarmUp(scenario); <line11> } <line12> CPUUsageHistogramSet cpuusage = null; <line13> boolean cpuusageEnabled = tc.getMeasure().contains(Measure.CPUUSAGE); <line14> if (cpuusageEnabled) { <line15> cpuusage = CPUUsageHistogramSet.getInstance(scenario.getClass()); <line16> cpuusage.start(); <line17> } <line18> startScenario(scenario.getClass()); <line19> if (cpuusageEnabled) { <line20> cpuusage.stop(); <line21> } <line22> exec.getReporter().report(); <line23> } else { <line24> for (Class<? extends IPerfTest> c : scenarios) { <line25> KPKConstraint constraint = exec.checkScenarioConstraints(c); <line26> if (constraint != null) { <line27> } else { <line28> exec.forkScenario(c.getSimpleName()); <line29> } <line30> } <line31> } <line32> } <line33> } <line34> 	"<line27>          log.info(""Scenario '""+ tc.getScenario()+ ""' skipped due to constraints ""+ Arrays.toString(constraint.value()));"	task4	
"public class A { <line0> public static java.util.List<com.liferay.wiki.model.WikiPage> getRecentChanges( <line1> HttpPrincipal httpPrincipal, long groupId, long nodeId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> WikiPageServiceUtil.class, ""getRecentChanges"", _getRecentChangesParameterTypes35); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, nodeId, start, end); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (java.util.List<com.liferay.wiki.model.WikiPage>) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
"public class A { <line0> public LanguagePage addLanguageAndJoin(String localeId) { <line1> addLanguage(localeId); <line2> LanguagePage languagePage = <line3> goToHome().goToLanguages().gotoLanguagePage(localeId).gotoMembersTab(); <line4> if (languagePage.getMemberUsernames().contains(""admin"")) { <line5> return languagePage; <line6> } <line7> return languagePage.joinLanguageTeam(); <line8> } <line9> } <line10> "	"<line5>      log.warn(""admin has already joined the language [{}]"", localeId);"	task4	
"public class A { <line0> public void updateVfModule( <line1> String cloudSiteId, <line2> String cloudOwner, <line3> String tenantId, <line4> String vnfType, <line5> String vnfVersion, <line6> String vnfName, <line7> String requestType, <line8> String volumeGroupHeatStackId, <line9> String baseVfHeatStackId, <line10> String vfModuleStackId, <line11> String modelCustomizationUuid, <line12> Map<String, Object> inputs, <line13> MsoRequest msoRequest, <line14> Holder<Map<String, String>> outputs, <line15> Holder<VnfRollback> rollback) <line16> throws VnfException { <line17> throw new VnfException(""UpdateVfModule:  Unsupported command"", MsoExceptionCategory.USERDATA); <line18> } <line19> } <line20> "	"<line17>    logger.debug(""Update VF Module command attempted but not supported"");"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private Object buildNameStep(NameStep nameStep, String value, Parent parent) <line2> throws JaxenException { <line3> String name = nameStep.getLocalName(); <line4> String prefix = nameStep.getPrefix(); <line5> Namespace ns = <line6> prefix.isEmpty() ? Namespace.NO_NAMESPACE : MCRConstants.getStandardNamespace(prefix); <line7> if (nameStep.getAxis() == Axis.CHILD) { <line8> if (parent instanceof Document) { <line9> return buildPredicates(nameStep.getPredicates(), ((Document) parent).getRootElement()); <line10> } else { <line11> return buildPredicates( <line12> nameStep.getPredicates(), buildElement(ns, name, value, (Element) parent)); <line13> } <line14> } else if (nameStep.getAxis() == Axis.ATTRIBUTE) { <line15> return buildAttribute(ns, name, value, (Element) parent); <line16> } else { <line17> if (LOGGER.isDebugEnabled()) { <line18> } <line19> return null; <line20> } <line21> } <line22> } <line23> "	"<line18>        LOGGER.debug(""ignoring axis, can not be built: {} {}{}"",nameStep.getAxis(),prefix.isEmpty() ? """" : prefix + "":"",name);"	task4	
public class A { <line0> private void shrinkIfBelowCapacity() { <line1> int currentLoad = maxTotalInFlight.getAndSet(totalInFlight.get()); <line2> int maxRequestsPerConnection = options().getMaxRequestsPerConnection(hostDistance); <line3> int needed = currentLoad / maxRequestsPerConnection + 1; <line4> if (currentLoad % maxRequestsPerConnection > options().getNewConnectionThreshold(hostDistance)) <line5> needed += 1; <line6> needed = Math.max(needed, options().getCoreConnectionsPerHost(hostDistance)); <line7> int actual = open.get(); <line8> int toTrash = Math.max(0, actual - needed); <line9> if (toTrash <= 0) return; <line10> for (Connection connection : connections) <line11> if (trashConnection(connection)) { <line12> toTrash -= 1; <line13> if (toTrash == 0) return; <line14> } <line15> } <line16> } <line17> 	"<line9>    logger.trace(""Current inFlight = {}, {} connections needed, {} connections available, trashing {}"",currentLoad,needed,actual,toTrash);"	task4	
"public class A { <line0> @After <line1> public void tearDown() throws IOException, StorageEngineException { <line2> ClusterDescriptor.getInstance().getConfig().setReplicationNum(prevReplicaNum); <line3> if (mManager != null) { <line4> for (MManager manager : mManager) { <line5> manager.clear(); <line6> } <line7> } <line8> EnvironmentUtils.cleanEnv(); <line9> File[] files = new File(""target/schemas"").listFiles(); <line10> if (files != null) { <line11> for (File file : files) { <line12> try { <line13> Files.delete(file.toPath()); <line14> } catch (IOException e) { <line15> } <line16> } <line17> } <line18> StorageEngine.setEnablePartition(prevEnablePartition); <line19> StorageEngine.setTimePartitionInterval(prevPartitionInterval); <line20> } <line21> } <line22> "	"<line15>          logger.error(""{} can not be deleted."", file, e);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public List<ComprehensionTestQuestionBo> getComprehensionTestQuestionList(Integer studyId) { <line3> logger.entry(""begin getComprehensionTestQuestionList()""); <line4> Session session = null; <line5> List<ComprehensionTestQuestionBo> comprehensionTestQuestionList = null; <line6> try { <line7> session = hibernateTemplate.getSessionFactory().openSession(); <line8> query = <line9> session.createQuery( <line10> ""From ComprehensionTestQuestionBo CTQBO where CTQBO.studyId=:studyId"" <line11> + "" and CTQBO.active=1 order by CTQBO.sequenceNo asc""); <line12> query.setInteger(""studyId"", studyId); <line13> comprehensionTestQuestionList = query.list(); <line14> } catch (Exception e) { <line15> } finally { <line16> if ((null != session) && session.isOpen()) { <line17> session.close(); <line18> } <line19> } <line20> logger.exit(""getComprehensionTestQuestionList() - Ends""); <line21> return comprehensionTestQuestionList; <line22> } <line23> } <line24> "	"<line15>      logger.error(""StudyDAOImpl - getComprehensionTestQuestionList() - Error"", e);"	task4	
public class A { <line0> @Override <line1> public void start(Map<String, String> configProps) { <line2> this.configProps = configProps; <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Connector config keys: {}"", String.join("", "", configProps.keySet()));"	task4	
public class A { <line0> public static void main(String[] args) throws Exception { <line1> StorageCleanupJob cli = new StorageCleanupJob(); <line2> cli.execute(args); <line3> } <line4> } <line5> 	"<line1>    logger.warn(""org.apache.kylin.storage.hbase.util.StorageCleanupJob is deprecated, use""+ "" org.apache.kylin.tool.StorageCleanupJob instead"");"	task4	
public class A { <line0> private void reAttemptDelivery(Mail mail, int retries) throws MailQueue.MailQueueException { <line1> DeliveryRetriesHelper.incrementRetries(mail); <line2> mail.setLastUpdated(dateSupplier.get()); <line3> Duration delay = getNextDelay(DeliveryRetriesHelper.retrieveRetries(mail)); <line4> if (configuration.isUsePriority()) { <line5> mail.setAttribute(MailPrioritySupport.LOW_PRIORITY_ATTRIBUTE); <line6> } <line7> queue.enQueue(mail, delay); <line8> } <line9> } <line10> 	"<line1>    LOGGER.debug(""Storing message {} into outgoing after {} retries"", mail.getName(), retries);"	task4	
public class A { <line0> protected void onInPacketAdded(final String networkId, final InPacketAdded msg) { <line1> if (onInPacketAddedPre(networkId, msg)) { <line2> HashMap<String, Response> respList = conversion(networkId, msg); <line3> onInPacketAddedPost(networkId, msg, respList); <line4> } <line5> } <line6> } <line7> 	"<line1>    log.debug("""");"	task4	
public class A { <line0> @PreDestroy <line1> public void destroyDataSources() { <line2> for (final SourceConfiguration sourceConfig : sourceConfigurations.values()) { <line3> try { <line4> DataSources.destroy(sourceConfig.getDataSource()); <line5> } catch (SQLException e) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        LOGGER.error(""Destroying datasource"", e);"	task4	
"public class A { <line0> @Override <line1> public void saveAccounts(List<AccountVO> accounts) { <line2> TransactionLegacy txn = TransactionLegacy.currentTxn(); <line3> try { <line4> txn.start(); <line5> String sql = INSERT_ACCOUNT; <line6> PreparedStatement pstmt = null; <line7> pstmt = txn.prepareAutoCloseStatement(sql); <line8> for (AccountVO acct : accounts) { <line9> pstmt.setLong(1, acct.getId()); <line10> pstmt.setString(2, acct.getAccountName()); <line11> pstmt.setShort(3, acct.getType()); <line12> if (acct.getRoleId() == null) { <line13> pstmt.setLong(4, RoleType.User.getId()); <line14> } else { <line15> pstmt.setLong(4, acct.getRoleId()); <line16> } <line17> pstmt.setLong(5, acct.getDomainId()); <line18> Date removed = acct.getRemoved(); <line19> if (removed == null) { <line20> pstmt.setString(6, null); <line21> } else { <line22> pstmt.setString( <line23> 6, DateUtil.getDateDisplayString(TimeZone.getTimeZone(""GMT""), acct.getRemoved())); <line24> } <line25> pstmt.setBoolean(7, acct.getNeedsCleanup()); <line26> pstmt.addBatch(); <line27> } <line28> pstmt.executeBatch(); <line29> txn.commit(); <line30> } catch (Exception ex) { <line31> txn.rollback(); <line32> throw new CloudRuntimeException(ex.getMessage()); <line33> } <line34> } <line35> } <line36> "	"<line32>      logger.error(""error saving account to cloud_usage db"", ex);"	task4	
public class A { <line0> @Override <line1> public BulkWriterResponse write( <line2> String sensorType, <line3> WriterConfiguration configurations, <line4> List<BulkMessage<JSONObject>> messages) { <line5> BulkWriterResponse writerResponse = new BulkWriterResponse(); <line6> List<Map.Entry<MessageId, Future>> results = new ArrayList<>(); <line7> for (BulkMessage<JSONObject> bulkWriterMessage : messages) { <line8> MessageId messageId = bulkWriterMessage.getId(); <line9> JSONObject message = bulkWriterMessage.getMessage(); <line10> String jsonMessage; <line11> try { <line12> jsonMessage = message.toJSONString(); <line13> } catch (Throwable t) { <line14> writerResponse.addError(t, messageId); <line15> continue; <line16> } <line17> Optional<String> topic = getKafkaTopic(message); <line18> if (topic.isPresent()) { <line19> Future future = <line20> kafkaProducer.send(new ProducerRecord<String, String>(topic.get(), jsonMessage)); <line21> results.add(new AbstractMap.SimpleEntry<>(messageId, future)); <line22> } else { <line23> } <line24> } <line25> Collection<MessageId> ids = <line26> messages.stream().map(BulkMessage::getId).collect(Collectors.toList()); <line27> try { <line28> kafkaProducer.flush(); <line29> } catch (InterruptException e) { <line30> writerResponse.addAllErrors(e, ids); <line31> return writerResponse; <line32> } <line33> for (Map.Entry<MessageId, Future> kv : results) { <line34> try { <line35> kv.getValue().get(); <line36> writerResponse.addSuccess(kv.getKey()); <line37> } catch (Exception e) { <line38> writerResponse.addError(e, kv.getKey()); <line39> } <line40> } <line41> return writerResponse; <line42> } <line43> } <line44> 	"<line23>        LOG.debug(""Dropping {} because no topic is specified."", jsonMessage);"	task4	
"public class A { <line0> @PayloadRoot(localPart = ""SendNotificationRequest"", namespace = MICROGRIDS_NOTIFICATION_NAMESPACE) <line1> @ResponsePayload <line2> public SendNotificationResponse sendNotification( <line3> @OrganisationIdentification final String organisationIdentification, <line4> @RequestPayload final SendNotificationRequest request) <line5> throws WebServiceException { <line6> this.notificationService.handleNotification( <line7> request.getNotification(), organisationIdentification); <line8> return new SendNotificationResponse(); <line9> } <line10> } <line11> "	"<line6>    LOGGER.info(""Incoming SendNotificationRequest for organisation: {} device: {}."",organisationIdentification,request.getNotification().getDeviceIdentification());"	task4	
public class A { <line0> protected <C, R> void handle( <line1> CommandMessage<C> command, <line2> MessageHandler<? super CommandMessage<?>> handler, <line3> CommandCallback<? super C, ? super R> callback) { <line4> if (logger.isDebugEnabled()) { <line5> } <line6> UnitOfWork<CommandMessage<?>> unitOfWork = DefaultUnitOfWork.startAndGet(command); <line7> unitOfWork.attachTransaction(transactionManager); <line8> InterceptorChain chain = <line9> new DefaultInterceptorChain<>(unitOfWork, handlerInterceptors, handler); <line10> CommandResultMessage<R> resultMessage = <line11> asCommandResultMessage(unitOfWork.executeWithResult(chain::proceed, rollbackConfiguration)); <line12> callback.onResult(command, resultMessage); <line13> } <line14> } <line15> 	"<line5>      logger.debug(""Handling command [{}]"", command.getCommandName());"	task4	
"public class A { <line0> @Override <line1> public boolean registerSlotRequest(SlotRequest slotRequest) throws ResourceManagerException { <line2> checkInit(); <line3> if (checkDuplicateRequest(slotRequest.getAllocationId())) { <line4> return false; <line5> } else { <line6> PendingSlotRequest pendingSlotRequest = new PendingSlotRequest(slotRequest); <line7> pendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest); <line8> try { <line9> internalRequestSlot(pendingSlotRequest); <line10> } catch (ResourceManagerException e) { <line11> pendingSlotRequests.remove(slotRequest.getAllocationId()); <line12> throw new ResourceManagerException( <line13> ""Could not fulfill slot request "" + slotRequest.getAllocationId() + '.', e); <line14> } <line15> return true; <line16> } <line17> } <line18> } <line19> "	"<line4>      LOG.debug(""Ignoring a duplicate slot request with allocation id {}."",slotRequest.getAllocationId());"	task4	
"public class A { <line0> @DELETE <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/groups/{groupName}"") <line3> @RolesAllowed({ADMIN_ROLE}) <line4> public Response deleteGroup(@PathParam(""groupName"") String groupName) { <line5> assertObjectExists(groupManagerService.get(groupName), ""group"", groupName); <line6> UberfireRestResponse response = resourceHelper.removeGroup(groupName); <line7> return createResponse(response); <line8> } <line9> } <line10> "	"<line5>    logger.debug(""-----deleteGroup--- , Group Name: {}"", groupName);"	task4	
public class A { <line0> @Override <line1> public void accept(String value) { <line2> try { <line3> realConsumer.accept(objectMapper.readValue(value, clazz)); <line4> } catch (JsonProcessingException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.info(""Invalid payload {}"", value, e);"	task4	
"public class A { <line0> @Value(""${maintenance:FULL,FULL}"") <line1> public void set(String mode) { <line2> AccessType world = null, trusted = null; <line3> try { <line4> String[] modes = StringUtils.split(mode, ','); <line5> world = AccessType.valueOf(modes[0].trim()); <line6> trusted = AccessType.valueOf(modes[1].trim()); <line7> } catch (RuntimeException e) { <line8> } <line9> if (world != null && trusted != null) { <line10> set(world, trusted); <line11> } <line12> } <line13> } <line14> "	<line8>      LOGGER.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public Object get(final Context context) throws FlowException { <line2> final Map<String, Object> result = new LinkedHashMap<>(); <line3> for (final FlowKeyValue _keySource : getProperty(keyValueSources)) { <line4> final Object item = _keySource.get(context); <line5> if (item != null && item instanceof KeyValue) { <line6> final KeyValue keyValue = (KeyValue) item; <line7> result.put(keyValue.getKey(), keyValue.getValue()); <line8> } else { <line9> } <line10> } <line11> return result; <line12> } <line13> } <line14> 	"<line9>        logger.warn(""KeyValue source {} of {} returned invalid value {}"",_keySource.getUuid(),getUuid(),item);"	task4	
"public class A { <line0> private JsonObject doRawHttpRequest( <line1> String path, String method, JsonObject body, boolean errorOk) { <line2> OkHttpClient httpClient = client.adapt(OkHttpClient.class); <line3> HttpUrl url = HttpUrl.get(client.getMasterUrl()).resolve(path); <line4> Request.Builder requestBuilder = <line5> new Request.Builder() <line6> .url(url) <line7> .addHeader(""Content-Type"", ""application/json"") <line8> .addHeader(""Authorization"", ""Bearer "" + apiToken) <line9> .method( <line10> method, <line11> body != null <line12> ? RequestBody.create(MediaType.parse(""application/json""), body.encode()) <line13> : null); <line14> try (Response response = httpClient.newCall(requestBuilder.build()).execute()) { <line15> try (ResponseBody responseBody = response.body()) { <line16> String responseString = responseBody != null ? responseBody.string() : ""{}""; <line17> if (response.isSuccessful()) { <line18> return new JsonObject(responseString); <line19> } else { <line20> if (errorOk) { <line21> return null; <line22> } else { <line23> String errorMessage = <line24> String.format( <line25> ""Error performing %s on %s: %d, %s"", <line26> method, path, response.code(), responseString); <line27> throw new RuntimeException(errorMessage); <line28> } <line29> } <line30> } <line31> } catch (IOException e) { <line32> throw new UncheckedIOException(e); <line33> } <line34> } <line35> } <line36> "	<line27>            log.warn(errorMessage);	task4	
public class A { <line0> public Renderable getRenderable(Image image, ImageTypeEnum imageType, OnErrorTypeEnum onErrorType) <line1> throws JRException { <line2> byte[] data = null; <line3> try { <line4> data = <line5> JRImageLoader.getInstance(context.getJasperReportsContext()) <line6> .loadBytesFromAwtImage(image, imageType); <line7> } catch (Exception e) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> return handleImageError(e, onErrorType); <line11> } <line12> return SimpleDataRenderer.getInstance(data); <line13> } <line14> } <line15> 	"<line9>        log.debug(""handled image error with type "" + onErrorType, e);"	task4	
public class A { <line0> private void takeSnapshot(OutputStream out) throws IOException { <line1> ObjectOutputStream stream = new ObjectOutputStream(out); <line2> stream.writeUTF(getClass().getName()); <line3> stream.writeInt(LOG_VERSION); <line4> stream.writeObject(myServiceID); <line5> stream.writeLong(eventID); <line6> stream.writeInt(unicastPort); <line7> stream.writeObject(memberGroups); <line8> stream.writeObject(lookupGroups); <line9> stream.writeLong(announcementSeqNo); <line10> marshalAttributes(lookupAttrs, stream); <line11> marshalLocators(lookupLocators, stream); <line12> for (Iterator iter = serviceByID.entrySet().iterator(); iter.hasNext(); ) { <line13> Map.Entry entry = (Map.Entry) iter.next(); <line14> if (myServiceID != entry.getKey()) stream.writeObject(entry.getValue()); <line15> } <line16> stream.writeObject(null); <line17> for (Iterator iter = eventByID.values().iterator(); iter.hasNext(); ) { <line18> stream.writeObject(iter.next()); <line19> } <line20> stream.writeObject(null); <line21> stream.flush(); <line22> } <line23> } <line24> 	"<line22>    logger.debug(""wrote state snapshot"");"	task4	
public class A { <line0> private void save(Tuple tuple) { <line1> byte[] rowKey = mapper.rowKey(tuple); <line2> ColumnList cols = mapper.columns(tuple); <line3> Durability durability = writeToWAL ? Durability.SYNC_WAL : Durability.SKIP_WAL; <line4> Optional<Long> ttl = mapper.getTTL(tuple); <line5> if (ttl.isPresent()) { <line6> hbaseClient.addMutation(rowKey, cols, durability, ttl.get()); <line7> } else { <line8> hbaseClient.addMutation(rowKey, cols, durability); <line9> } <line10> batchHelper.addBatch(tuple); <line11> } <line12> } <line13> 	"<line11>    LOG.debug(""Added mutation to the batch; size={}"", batchHelper.getBatchSize());"	task4	
"public class A { <line0> private List<WebElement> findElementsByLocator( <line1> LocatorHandler handler, WebDriver driver, Locator ploc, List<Locator> selectedFrameLocators) { <line2> List<WebElement> result = handler.handle(driver, ploc.arg); <line3> if (!result.isEmpty()) return result; <line4> if (ploc.frameIndexList.size() >= MAX_FRAME_DEPTH) { <line5> return null; <line6> } <line7> int iframeCount = driver.findElements(By.tagName(""iframe"")).size(); <line8> for (int index = 0; index < iframeCount; index++) { <line9> pushFrame(driver, ploc, index); <line10> result = findElementsByLocator(handler, driver, ploc, selectedFrameLocators); <line11> if (result != null) return result; <line12> popFrame(driver, ploc, selectedFrameLocators); <line13> } <line14> int frameCount = driver.findElements(By.tagName(""frame"")).size(); <line15> for (int index = 0; index < frameCount; index++) { <line16> pushFrame(driver, ploc, index); <line17> result = findElementsByLocator(handler, driver, ploc, selectedFrameLocators); <line18> if (result != null) return result; <line19> popFrame(driver, ploc, selectedFrameLocators); <line20> } <line21> return null; <line22> } <line23> } <line24> "	"<line5>      log.warn(""Nested (i)frame depth exceeded limit: "" + MAX_FRAME_DEPTH);"	task4	
"public class A { <line0> @Override <line1> public void connectionLost(Throwable throwable) { <line2> String message = getLogPrefix() + ""connection lost""; <line3> receiver.getAdapter().getMessageKeeper().add(message); <line4> ibisExceptionListener.exceptionThrown(this, throwable); <line5> } <line6> } <line7> "	<line4>    log.debug(message);	task4	
"public class A { <line0> public static void writeToken(String token, String tokenCacheFile) throws IOException { <line1> File cacheFile = new File(tokenCacheFile); <line2> try (Writer writer = new FileWriterWithEncoding(cacheFile, StandardCharsets.UTF_8)) { <line3> writer.write(token); <line4> writer.flush(); <line5> cacheFile.setReadable(false, false); <line6> cacheFile.setReadable(true, true); <line7> if (!cacheFile.setWritable(true, true)) { <line8> throw new KrbException(""Cache file is not readable.""); <line9> } <line10> } catch (IOException ioe) { <line11> if (cacheFile.delete()) { <line12> System.err.println(""Cache file is deleted.""); <line13> } <line14> } catch (KrbException e) { <line15> } <line16> } <line17> } <line18> "	"<line15>      LOG.error(""Failed to write token to cache File. "" + e.toString());"	task4	
"public class A { <line0> private void checkAndHandleEndOfNonCircularTrajectory(EpisimPerson person, DayOfWeek day) { <line1> Id<ActivityFacility> firstFacilityId = person.getFirstFacilityId(day); <line2> double now = EpisimUtils.getCorrectedTime(episimConfig.getStartOffset(), 0, iteration + 1); <line3> if (person.isInContainer()) { <line4> EpisimContainer<?> container = person.getCurrentContainer(); <line5> Id<?> lastFacilityId = container.getContainerId(); <line6> if (container instanceof EpisimFacility <line7> && this.pseudoFacilityMap.containsKey(lastFacilityId) <line8> && !firstFacilityId.equals(lastFacilityId)) { <line9> EpisimFacility lastFacility = this.pseudoFacilityMap.get(lastFacilityId); <line10> int index = person.getEndOfDay(day.minus(1)); <line11> String actType = person.getTrajectory().get(index).actType; <line12> contactModel.infectionDynamicsFacility(person, lastFacility, now, actType); <line13> double timeSpent = now - lastFacility.getContainerEnteringTime(person.getPersonId()); <line14> person.addSpentTime(actType, timeSpent); <line15> if (iteration > 1 && timeSpent > 86400 && !actType.equals(""home"")) { <line16> } <line17> lastFacility.removePerson(person); <line18> EpisimFacility firstFacility = this.pseudoFacilityMap.get(firstFacilityId); <line19> firstFacility.addPerson(person, now); <line20> contactModel.notifyEnterFacility(person, firstFacility, now); <line21> } else if (container instanceof EpisimVehicle <line22> && this.vehicleMap.containsKey(lastFacilityId)) { <line23> EpisimVehicle lastVehicle = this.vehicleMap.get(lastFacilityId); <line24> contactModel.infectionDynamicsVehicle(person, lastVehicle, now); <line25> person.addSpentTime(""pt"", now - lastVehicle.getContainerEnteringTime(person.getPersonId())); <line26> lastVehicle.removePerson(person); <line27> EpisimFacility firstFacility = this.pseudoFacilityMap.get(firstFacilityId); <line28> firstFacility.addPerson(person, now); <line29> contactModel.notifyEnterFacility(person, firstFacility, now); <line30> } <line31> } else { <line32> EpisimFacility firstFacility = this.pseudoFacilityMap.get(firstFacilityId); <line33> firstFacility.addPerson(person, now); <line34> contactModel.notifyEnterFacility(person, firstFacility, now); <line35> } <line36> } <line37> } <line38> "	"<line16>          log.trace(""{} spent {} outside home"", person, timeSpent);"	task4	
public class A { <line0> @Test(groups = {JDBC, SIMBA_JDBC}) <line1> @Requires(MutableAllTypesTable.class) <line2> public void preparedInsertVarbinaryApi() { <line3> if (usingTeradataJdbcDriver(connection())) { <line4> String tableNameInDatabase = mutableTablesState().get(TABLE_NAME_MUTABLE).getNameInDatabase(); <line5> String insertSqlWithTable = String.format(INSERT_SQL, tableNameInDatabase); <line6> String selectSqlWithTable = String.format(SELECT_STAR_SQL, tableNameInDatabase); <line7> defaultQueryExecutor() <line8> .executeQuery( <line9> insertSqlWithTable, <line10> param(TINYINT, null), <line11> param(SMALLINT, null), <line12> param(INTEGER, null), <line13> param(BIGINT, null), <line14> param(FLOAT, null), <line15> param(DOUBLE, null), <line16> param(DECIMAL, null), <line17> param(DECIMAL, null), <line18> param(TIMESTAMP, null), <line19> param(DATE, null), <line20> param(VARCHAR, null), <line21> param(VARCHAR, null), <line22> param(CHAR, null), <line23> param(BOOLEAN, null), <line24> param(VARBINARY, new byte[] {0, 1, 2, 3, 0, 42, -7})); <line25> QueryResult result = defaultQueryExecutor().executeQuery(selectSqlWithTable); <line26> assertColumnTypes(result); <line27> assertThat(result) <line28> .containsOnly( <line29> row( <line30> null, <line31> null, <line32> null, <line33> null, <line34> null, <line35> null, <line36> null, <line37> null, <line38> null, <line39> null, <line40> null, <line41> null, <line42> null, <line43> null, <line44> new byte[] {0, 1, 2, 3, 0, 42, -7})); <line45> } else { <line46> } <line47> } <line48> } <line49> 	"<line46>      LOGGER.warn(""preparedInsertVarbinaryApi() only applies to TeradataJdbcDriver"");"	task4	
"public class A { <line0> public static java.util.List<com.liferay.dynamic.data.mapping.model.DDMStructure> <line1> getDDMStructures( <line2> HttpPrincipal httpPrincipal, <line3> long[] groupIds, <line4> long folderId, <line5> int restrictionType, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.dynamic.data.mapping.model.DDMStructure> <line8> orderByComparator) <line9> throws com.liferay.portal.kernel.exception.PortalException { <line10> try { <line11> MethodKey methodKey = <line12> new MethodKey( <line13> JournalFolderServiceUtil.class, ""getDDMStructures"", _getDDMStructuresParameterTypes5); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupIds, folderId, restrictionType, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (java.util.List<com.liferay.dynamic.data.mapping.model.DDMStructure>) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	<line27>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static WikiPage getPage(PortletRequest portletRequest) throws Exception { <line1> HttpServletRequest httpServletRequest = PortalUtil.getHttpServletRequest(portletRequest); <line2> long nodeId = ParamUtil.getLong(httpServletRequest, ""nodeId""); <line3> String title = ParamUtil.getString(httpServletRequest, ""title""); <line4> double version = ParamUtil.getDouble(httpServletRequest, ""version""); <line5> WikiNode node = null; <line6> try { <line7> if (nodeId > 0) { <line8> node = WikiNodeServiceUtil.getNode(nodeId); <line9> } <line10> } catch (NoSuchNodeException noSuchNodeException) { <line11> if (log.isDebugEnabled()) { <line12> } <line13> } <line14> if (node == null) { <line15> node = (WikiNode) httpServletRequest.getAttribute(WikiWebKeys.WIKI_NODE); <line16> if (node != null) { <line17> nodeId = node.getNodeId(); <line18> } <line19> } <line20> WikiWebComponentProvider wikiWebComponentProvider = <line21> WikiWebComponentProvider.getWikiWebComponentProvider(); <line22> WikiGroupServiceConfiguration wikiGroupServiceConfiguration = <line23> wikiWebComponentProvider.getWikiGroupServiceConfiguration(); <line24> if (Validator.isNull(title)) { <line25> title = wikiGroupServiceConfiguration.frontPageName(); <line26> } <line27> try { <line28> return WikiPageServiceUtil.getPage(nodeId, title, version); <line29> } catch (NoSuchPageException noSuchPageException) { <line30> if (title.equals(wikiGroupServiceConfiguration.frontPageName()) && (version == 0)) { <line31> return getFirstVisiblePage(nodeId, portletRequest); <line32> } <line33> throw noSuchPageException; <line34> } <line35> } <line36> } <line37> "	<line12>        log.debug(noSuchNodeException, noSuchNodeException);	task4	
public class A { <line0> public void abort() { <line1> cancel(false); <line2> if (logger.isDebugEnabled()) { <line3> } <line4> aborted = true; <line5> responseText = null; <line6> getRequest().getHeaders().clear(); <line7> if (readyState == ReadyState.HEADERS_RECEIVED || readyState == ReadyState.LOADING) { <line8> readyState = ReadyState.DONE; <line9> if (isAsynchronous()) { <line10> notifyReadyStateChange(false); <line11> notifyAbort(); <line12> } <line13> } else { <line14> readyState = ReadyState.UNSENT; <line15> } <line16> } <line17> } <line18> 	"<line3>      logger.debug(""Aborted {}"", this);"	task4	
"public class A { <line0> @RuleAction(label = ""initiateAutoArm"", description = ""Initiate auto arm"") <line1> public void initiateAutoArm( <line2> @ActionInput(name = ""pin"", label = ""pin"", description = ""The pin 4 or 6 digit pin"") @Nullable <line3> String pin) { <line4> ThingHandlerPartition handler = this.handler; <line5> if (handler == null) { <line6> return; <line7> } <line8> String adjustedPin = adjustPin(pin); <line9> if (adjustedPin == null) { <line10> return; <line11> } <line12> handler.initiateAutoArm(adjustedPin); <line13> } <line14> } <line15> "	<line6>      logger.debug(HANDLER_IS_NULL);	task4	
"public class A { <line0> void getTrigger(RoutingContext routing, boolean isFullTrigger) { <line1> routing <line2> .vertx() <line3> .executeBlocking( <line4> future -> { <line5> String tenantId = checkTenant(routing); <line6> String triggerId = routing.request().getParam(""triggerId""); <line7> Object found = null; <line8> try { <line9> found = <line10> isFullTrigger <line11> ? definitionsService.getFullTrigger(tenantId, triggerId) <line12> : definitionsService.getTrigger(tenantId, triggerId); <line13> } catch (NotFoundException e) { <line14> } catch (IllegalArgumentException e) { <line15> throw new BadRequestException(""Bad arguments: "" + e.getMessage()); <line16> } catch (Exception e) { <line17> throw new InternalServerException(e.toString()); <line18> } <line19> if (found == null) { <line20> throw new ResponseUtil.NotFoundException(""triggerId: "" + triggerId + "" not found""); <line21> } <line22> log.debugf(""Trigger: %s"", found); <line23> future.complete(found); <line24> }, <line25> res -> result(routing, res)); <line26> } <line27> } <line28> "	<line17>                log.debug(e.getMessage(), e);	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.Group updateGroup( <line1> HttpPrincipal httpPrincipal, long groupId, String typeSettings) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(GroupServiceUtil.class, ""updateGroup"", _updateGroupParameterTypes38); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, typeSettings); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.portal.kernel.model.Group) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Calendar""}, <line2> description = ""empty column sunday"", <line3> priority = 149) <line4> public void verifyTest_2_3_8() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""calendar_3_8"", GTFS_1_GTFS_Common_12, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""calendar.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(2), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	"<line5>    log.info(Color.GREEN + ""Calendar_3_8 : empty column sunday"" + Color.NORMAL);"	task4	
public class A { <line0> protected List<?> execute() { <line1> if (getQuery().isEmpty()) { <line2> return null; <line3> } <line4> return execute(getQuery()); <line5> } <line6> } <line7> 	"<line2>      logger.error(""Failed to execute query."");"	task4	
public class A { <line0> public void MethodWithClassDbAnnotated() { <line1> _dummy.sayHello(); <line2> } <line3> } <line4> 	"<line1>    logger.info(""called"");"	task4	
"public class A { <line0> void detach() { <line1> StringBuilder sql = new StringBuilder(); <line2> sql.append(""ALTER TABLE ""); <line3> sql.append( <line4> this.sqlgGraph <line5> .getSqlDialect() <line6> .maybeWrapInQoutes(this.abstractLabel.getPrefix() + this.abstractLabel.getName())); <line7> sql.append("" DETACH PARTITION ""); <line8> sql.append( <line9> this.sqlgGraph <line10> .getSqlDialect() <line11> .maybeWrapInQoutes(this.getAbstractLabel().getSchema().getName())); <line12> sql.append("".""); <line13> sql.append(this.sqlgGraph.getSqlDialect().maybeWrapInQoutes(this.name)); <line14> if (this.sqlgGraph.getSqlDialect().needsSemicolon()) { <line15> sql.append("";""); <line16> } <line17> if (logger.isDebugEnabled()) { <line18> } <line19> Connection conn = this.sqlgGraph.tx().getConnection(); <line20> try (Statement stmt = conn.createStatement()) { <line21> stmt.execute(sql.toString()); <line22> } catch (SQLException e) { <line23> throw new RuntimeException(e); <line24> } <line25> } <line26> } <line27> "	<line18>      logger.debug(sql.toString());	task4	
"public class A { <line0> @Test <line1> public void parseEofError() { <line2> String rac = <line3> ""jdbc:oracle:thin:@(DESCRIPTION=(LOAD_BALANCE = off )"" <line4> + ""(ADDRESS  =  ( PROTOCOL = TCP)(HOST = 1.2.3.4 ) (PORT = 1521 ))"" <line5> + "" ( CONNECT_DATA = ( SID = sid ) ) ""; <line6> OracleNetConnectionDescriptorParser parser = new OracleNetConnectionDescriptorParser(rac); <line7> try { <line8> KeyValue keyValue = parser.parse(); <line9> Assert.fail(); <line10> } catch (OracleConnectionStringException e) { <line11> } <line12> } <line13> } <line14> "	"<line11>      logger.info(""Expected error"", e);"	task4	
"public class A { <line0> public static void main(String[] args) throws Exception { <line1> Preconditions.checkArgument( <line2> args.length == 5, ""Illegal number of arguments. Expected: 5, Actual: "" + args.length); <line3> String stormId = args[0]; <line4> String assignmentId = args[1]; <line5> String supervisorPort = args[2]; <line6> String portStr = args[3]; <line7> String workerId = args[4]; <line8> Map<String, Object> conf = ConfigUtils.readStormConfig(); <line9> Utils.setupWorkerUncaughtExceptionHandler(); <line10> StormCommon.validateDistributedMode(conf); <line11> int supervisorPortInt = Integer.parseInt(supervisorPort); <line12> Worker worker = <line13> new Worker( <line14> conf, <line15> null, <line16> stormId, <line17> assignmentId, <line18> supervisorPortInt, <line19> Integer.parseInt(portStr), <line20> workerId); <line21> int workerShutdownSleepSecs = <line22> ObjectReader.getInt(conf.get(Config.SUPERVISOR_WORKER_SHUTDOWN_SLEEP_SECS)); <line23> Utils.addShutdownHookWithDelayedForceKill(worker::shutdown, workerShutdownSleepSecs); <line24> worker.start(); <line25> } <line26> } <line27> "	"<line23>    LOG.info(""Adding shutdown hook with kill in {} secs"", workerShutdownSleepSecs);"	task4	
public class A { <line0> @Override <line1> protected void runPhase(IParadoxInitialLoginCommunicator communicator, Object... args) { <line2> String password = communicator.getPassword(); <line3> if (communicator.isEncrypted()) { <line4> EncryptionHandler.getInstance().updateKey(ParadoxUtil.getBytesFromString(password)); <line5> } <line6> ParadoxIPPacket packet = <line7> new ParadoxIPPacket(ParadoxUtil.getBytesFromString(password), false) <line8> .setCommand(HeaderCommand.CONNECT_TO_IP_MODULE); <line9> sendLogonPhasePacket(communicator, packet); <line10> } <line11> } <line12> 	"<line3>    logger.debug(""Phase {}"", this);"	task4	
public class A { <line0> public String cache(final Path file, final String id) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> if (null == id) { <line4> cache.remove(new SimplePathPredicate(file)); <line5> file.attributes().setVersionId(null); <line6> } else { <line7> cache.put(new SimplePathPredicate(file), id); <line8> file.attributes().setVersionId(id); <line9> } <line10> return id; <line11> } <line12> } <line13> 	"<line2>      log.debug(String.format(""Cache %s for file %s"", id, file));"	task4	
public class A { <line0> private void applyColumnOverrides( <line1> TableConfiguration tc, Map<ActualTableName, List<IntrospectedColumn>> columns) { <line2> for (Map.Entry<ActualTableName, List<IntrospectedColumn>> entry : columns.entrySet()) { <line3> for (IntrospectedColumn introspectedColumn : entry.getValue()) { <line4> ColumnOverride columnOverride = <line5> tc.getColumnOverride(introspectedColumn.getActualColumnName()); <line6> if (columnOverride != null) { <line7> if (logger.isDebugEnabled()) { <line8> } <line9> if (stringHasValue(columnOverride.getJavaProperty())) { <line10> introspectedColumn.setJavaProperty(columnOverride.getJavaProperty()); <line11> } <line12> if (stringHasValue(columnOverride.getJavaType())) { <line13> introspectedColumn.setFullyQualifiedJavaType( <line14> new FullyQualifiedJavaType(columnOverride.getJavaType())); <line15> } <line16> if (stringHasValue(columnOverride.getJdbcType())) { <line17> introspectedColumn.setJdbcTypeName(columnOverride.getJdbcType()); <line18> } <line19> if (stringHasValue(columnOverride.getTypeHandler())) { <line20> introspectedColumn.setTypeHandler(columnOverride.getTypeHandler()); <line21> } <line22> if (columnOverride.isColumnNameDelimited()) { <line23> introspectedColumn.setColumnNameDelimited(true); <line24> } <line25> introspectedColumn.setGeneratedAlways(columnOverride.isGeneratedAlways()); <line26> introspectedColumn.setProperties(columnOverride.getProperties()); <line27> } <line28> } <line29> } <line30> } <line31> } <line32> 	"<line8>            logger.debug(getString(""Tracing.4"",introspectedColumn.getActualColumnName(),entry.getKey().toString()));"	task4	
public class A { <line0> public static synchronized Cipher getCipher(String transformation) <line1> throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException { <line2> Cipher result = Cipher.getInstance(transformation); <line3> return result; <line4> } <line5> } <line6> 	"<line3>    LOG.trace(""getCipher({}) -> {}"", transformation, safeClassname(result));"	task4	
"public class A { <line0> @ExpectedLog( <line1> expectedClass = ElasticsearchIndexWriter.class, <line2> expectedLevel = ExpectedLog.Level.WARNING, <line3> expectedLog = ""Bulk delete failed"") <line4> @Test <line5> public void testDeleteDocuments() { <line6> SearchContext searchContext = new SearchContext(); <line7> searchContext.setCompanyId(1); <line8> List<String> uids = new ArrayList<>(); <line9> uids.add(""1""); <line10> IndexWriter indexWriter = getIndexWriter(); <line11> try { <line12> indexWriter.deleteDocuments(searchContext, uids); <line13> } catch (SearchException searchException) { <line14> if (log.isDebugEnabled()) { <line15> } <line16> } <line17> } <line18> } <line19> "	<line15>        log.debug(searchException, searchException);	task4	
"public class A { <line0> private boolean isUnindexed(JexlNode node) { <line1> List<ASTIdentifier> identifiers = JexlASTHelper.getIdentifiers(node); <line2> for (ASTIdentifier identifier : identifiers) { <line3> if (!(identifier.image.equals(Constants.ANY_FIELD) <line4> || identifier.image.equals(Constants.NO_FIELD))) { <line5> if (this.indexedFields == null) { <line6> if (config.getIndexedFields() != null && !config.getIndexedFields().isEmpty()) { <line7> this.indexedFields = config.getIndexedFields(); <line8> } else { <line9> try { <line10> this.indexedFields = this.helper.getIndexedFields(config.getDatatypeFilter()); <line11> } catch (Exception ex) { <line12> throw new RuntimeException( <line13> ""got exception when using MetadataHelper to get indexed fields "", ex); <line14> } <line15> } <line16> } <line17> if (this.indexedFields.contains(JexlASTHelper.deconstructIdentifier(identifier)) == false) { <line18> return true; <line19> } <line20> } <line21> } <line22> return false; <line23> } <line24> } <line25> "	"<line12>              log.error(""Could not determine whether a field is indexed"", ex);"	task4	
public class A { <line0> @Override <line1> public void clearCompositePhenomenonsForObservableProperty(String observableProperty) { <line2> this.compositePhenomenonsForObservableProperty.remove(observableProperty); <line3> } <line4> } <line5> 	"<line2>    LOG.trace(""Clearing composite phenomenon for observable property {}"", observableProperty);"	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.GroupSoap getUserGroup(long companyId, long userId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Group returnValue = <line4> GroupServiceUtil.getUserGroup(companyId, userId); <line5> return com.liferay.portal.kernel.model.GroupSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> private void removePrincipals(final Collection<Principal> principals) { <line1> for (final Principal principal : principals) { <line2> if (m_subject.getPrincipals().contains(principal)) { <line3> m_subject.getPrincipals().remove(principal); <line4> if (log.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> } <line10> 	"<line5>          log.debug(""Removed Principal "" + principal.getName());"	task4	
public class A { <line0> @PostConstruct <line1> public void start() { <line2> try { <line3> for (Service svc : services) { <line4> if (!isServiceUsed(svc)) { <line5> continue; <line6> } <line7> svc.start(); <line8> } <line9> } catch (Exception e) { <line10> throw new RuntimeException(e); <line11> } <line12> } <line13> } <line14> 	"<line7>        LOG.info(""Starting service {}"", svc.getClass().getName());"	task4	
"public class A { <line0> public void onXAEvent(Xid xid, String state) throws TransactionJournalingException { <line1> XidImpl xidImpl = null; <line2> if (""start"".equals(state)) { <line3> createXid(xid); <line4> } else { <line5> xidImpl = resolveXid(xid); <line6> if (xidImpl == null) { <line7> throw new TransactionJournalingException( <line8> ""Could not resolve XidImpl for ["" + xid + ""]"", null); <line9> } <line10> xidImpl.setState(state); <line11> long now = System.currentTimeMillis(); <line12> xidImpl.setLastUpdatedDateTime(now); <line13> try { <line14> dao.save(xidImpl); <line15> } catch (TransactionalResourceCommandPersistenceException e) { <line16> throw new TransactionJournalingException(""Exception persisting Xid"", e); <line17> } <line18> } <line19> } <line20> } <line21> "	"<line1>    logger.debug(""xid = ["" + xid + ""] state = ["" + state + ""]"");"	task4	
public class A { <line0> @Override <line1> public void onThrowable(Throwable t) { <line2> if (shouldDeleteUpdateOnFailure) { <line3> deleteWebhookUpdate(); <line4> } <line5> if (completableFuture != null) { <line6> completableFuture.completeExceptionally(t); <line7> } <line8> } <line9> } <line10> 	"<line2>    LOG.trace(""Webhook {} for {} failed after {}"",webhook.getUri(),update,JavaUtils.duration(start),t);"	task4	
public class A { <line0> private void shutdownDroplet(Exchange exchange) throws Exception { <line1> Action action = getEndpoint().getDigitalOceanClient().shutdownDroplet(dropletId); <line2> exchange.getMessage().setBody(action); <line3> } <line4> } <line5> 	"<line2>    LOG.trace(""Shutdown Droplet {} : [{}] "", dropletId, action);"	task4	
"public class A { <line0> private void prepareGetResourceConfigurations() throws Exception { <line1> final String complexResourceJSONString = <line2> DMPPersistenceUtil.getResourceAsString(""complex_resource.json""); <line3> final Resource expectedComplexResource = <line4> objectMapper.readValue(complexResourceJSONString, Resource.class); <line5> Assert.assertNotNull(""the complex resource shouldn't be null"", expectedComplexResource); <line6> Assert.assertNotNull( <line7> ""the name of the complex resource shouldn't be null"", expectedComplexResource.getName()); <line8> Assert.assertNotNull( <line9> ""the description of the complex resource shouldn't be null"", <line10> expectedComplexResource.getDescription()); <line11> Assert.assertNotNull( <line12> ""the type of the complex resource shouldn't be null"", expectedComplexResource.getType()); <line13> Assert.assertNotNull( <line14> ""the attributes of the complex resource shouldn't be null"", <line15> expectedComplexResource.getAttributes()); <line16> Assert.assertNotNull( <line17> ""the configurations of the complex resource shouldn't be null"", <line18> expectedComplexResource.getConfigurations()); <line19> Assert.assertFalse( <line20> ""the configurations of the complex resource shouldn't be empty"", <line21> expectedComplexResource.getConfigurations().isEmpty()); <line22> final ResourceServiceTestUtils resourceServiceTestUtils = <line23> resourcesResourceTestUtils.getPersistenceServiceTestUtils(); <line24> Resource complexResource = <line25> resourceServiceTestUtils.getJpaService().createObjectTransactional().getObject(); <line26> final Set<Configuration> createdConfigurations = Sets.newLinkedHashSet(); <line27> final ConfigurationServiceTestUtils configurationServiceTestUtils = <line28> resourceServiceTestUtils.getConfigurationsServiceTestUtils(); <line29> for (final Configuration expectedConfiguration : expectedComplexResource.getConfigurations()) { <line30> final String configurationUuid = UUIDService.getUUID(Configuration.class.getSimpleName()); <line31> final Configuration configuration = new Configuration(configurationUuid); <line32> configuration.setParameters(expectedConfiguration.getParameters()); <line33> final Configuration createdConfiguration = <line34> configurationServiceTestUtils.createAndCompareObject(configuration, configuration); <line35> complexResource.addConfiguration(createdConfiguration); <line36> createdConfigurations.add(createdConfiguration); <line37> complexResource = <line38> resourceServiceTestUtils.updateAndCompareObject(complexResource, complexResource); <line39> complexResource = resourceServiceTestUtils.getObject(complexResource); <line40> } <line41> complexResource.setName(expectedComplexResource.getName()); <line42> complexResource.setDescription(expectedComplexResource.getDescription()); <line43> complexResource.setType(expectedComplexResource.getType()); <line44> complexResource.setAttributes(expectedComplexResource.getAttributes()); <line45> final Resource updatedComplexResource = <line46> resourceServiceTestUtils.updateAndCompareObject(complexResource, complexResource); <line47> Assert.assertNotNull(""updated resource shouldn't be null"", updatedComplexResource); <line48> Assert.assertNotNull(""updated resource id shouldn't be null"", updatedComplexResource.getUuid()); <line49> actualResource = updatedComplexResource; <line50> expectedResource = actualResource; <line51> exceptedConfigurations = createdConfigurations; <line52> } <line53> } <line54> "	"<line49>    ResourcesResourceTest.LOG.debug(""try to retrieve configurations of resource '{}'"", updatedComplexResource.getUuid());"	task4	
public class A { <line0> public BufferedInputStream getBufferedInputStream(String filePath) { <line1> try { <line2> return new BufferedInputStream(fs.open(new Path(filePath))); <line3> } catch (IOException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	"<line4>      logger.error(""Failed to get buffered input stream for {}. "", filePath, e);"	task4	
public class A { <line0> synchronized void reset() throws Exception { <line1> instanceIndex.incrementAndGet(); <line2> isConnected.set(false); <line3> connectionStartMs = System.currentTimeMillis(); <line4> handleHolder.closeAndReset(); <line5> handleHolder.getZooKeeper(); <line6> } <line7> } <line8> 	"<line1>    log.debug(""reset"");"	task4	
public class A { <line0> @Bean <line1> public IamExternalRestClientFactory iamRestClientFactory() { <line2> return new IamExternalRestClientFactory(iamClientProperties, restTemplateBuilder); <line3> } <line4> } <line5> 	"<line2>    LOGGER.debug(""Iam client factory: {}"", iamClientProperties);"	task4	
"public class A { <line0> @Test(description = ""This test case tests the Group Management APIs"") <line1> public void GroupManagementTest() throws AutomationFrameworkException { <line2> URL url = <line3> Thread.currentThread() <line4> .getContextClassLoader() <line5> .getResource(""jmeter-scripts"" + File.separator + ""GroupManagementAPI.jmx""); <line6> JMeterTest script = new JMeterTest(new File(url.getPath())); <line7> JMeterTestManager manager = new JMeterTestManager(); <line8> manager.runTest(script); <line9> } <line10> } <line11> "	"<line8>    log.info(""Running group management api test cases using jmeter scripts"");"	task4	
"public class A { <line0> @Override <line1> public Object call(Job<Object> job, Map<String, Object> parameters) { <line2> this.checkAndCollectParameters(parameters); <line3> try { <line4> this.initializeConfig((ComputerJob) job); <line5> } catch (Exception e) { <line6> throw new HugeException(""Failed to initialize computer config file"", e); <line7> } <line8> Map<String, Object> configs = new HashMap<>(); <line9> configs.putAll(this.commonConfig); <line10> configs.putAll(this.checkAndCollectParameters(parameters)); <line11> String[] command = this.constructShellCommands(configs); <line12> try { <line13> ProcessBuilder builder = new ProcessBuilder(command); <line14> builder.redirectErrorStream(true); <line15> builder.directory(new File(executeDir())); <line16> Process process = builder.start(); <line17> StringBuilder output = new StringBuilder(); <line18> try (LineNumberReader reader = <line19> new LineNumberReader(new InputStreamReader(process.getInputStream()))) { <line20> String line; <line21> while ((line = reader.readLine()) != null) { <line22> output.append(line).append(""\n""); <line23> } <line24> } <line25> int exitCode = process.waitFor(); <line26> if (exitCode == 0) { <line27> return 0; <line28> } <line29> throw new HugeException(""The computer job exit with code %s: %s"", exitCode, output); <line30> } catch (HugeException e) { <line31> throw e; <line32> } catch (Throwable e) { <line33> throw new HugeException(""Failed to execute computer job"", e); <line34> } <line35> } <line36> } <line37> "	"<line12>    LOG.info(""Execute computer job: {}"", String.join(SPACE, command));"	task4	
public class A { <line0> private <T> void forwardIfValidLeader( <line1> UUID expectedLeaderId, <line2> CompletableFuture<? extends T> source, <line3> CompletableFuture<T> target, <line4> String forwardDescription) { <line5> source.whenComplete( <line6> (t, throwable) -> { <line7> synchronized (lock) { <line8> if (isValidLeader(expectedLeaderId)) { <line9> if (throwable != null) { <line10> target.completeExceptionally(throwable); <line11> } else { <line12> target.complete(t); <line13> } <line14> } else { <line15> } <line16> } <line17> }); <line18> } <line19> } <line20> 	"<line15>              LOG.trace(""Ignore forwarding '{}' because the leadership runner is no longer the valid""+ "" leader for {}."",forwardDescription,expectedLeaderId);"	task4	
public class A { <line0> protected void concurrentExecution() { <line1> List<Future<JexlNode>> futures; <line2> try { <line3> futures = executor.invokeAll(todo); <line4> for (Future<JexlNode> future : futures) { <line5> Exception sawException = null; <line6> try { <line7> if (future.get() != null) {} <line8> } catch (InterruptedException e) { <line9> sawException = (Exception) e.getCause(); <line10> } catch (ExecutionException e) { <line11> sawException = (Exception) e.getCause(); <line12> } catch (Exception e) { <line13> sawException = e; <line14> } <line15> if (null != sawException) { <line16> throw new CannotExpandUnfieldedTermFatalException(sawException); <line17> } <line18> } <line19> } catch (InterruptedException e) { <line20> throw new CannotExpandUnfieldedTermFatalException(e.getMessage()); <line21> } finally { <line22> todo.clear(); <line23> } <line24> } <line25> } <line26> 	<line16>          log.error(sawException.getMessage(), sawException);	task4	
public class A { <line0> protected void closeEntityManagerFactory() { <line1> if (emf != null) { <line2> emf.close(); <line3> emf = null; <line4> } <line5> } <line6> } <line7> 	"<line5>    logger.debug(""Closing down entity objects...done"");"	task4	
"public class A { <line0> @ApiOperation( <line1> value = <line2> ""Migrates a specified process instance to a process definition in another KIE container."") <line3> @ApiResponses( <line4> value = { <line5> @ApiResponse(code = 500, message = ""Unexpected error""), <line6> @ApiResponse(code = 404, message = ""Process instance or Container Id not found""), <line7> @ApiResponse(code = 404, message = ""Container Id not found""), <line8> @ApiResponse( <line9> code = 201, <line10> response = MigrationReportInstance.class, <line11> message = ""Successfull response"", <line12> examples = <line13> @Example( <line14> value = { <line15> @ExampleProperty(mediaType = JSON, value = GET_MIGRATION_REPORT_RESPONSE_JSON) <line16> })) <line17> }) <line18> @PUT <line19> @Path(MIGRATE_PROCESS_INST_PUT_URI) <line20> @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line21> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line22> public Response migrateProcessInstance( <line23> @javax.ws.rs.core.Context HttpHeaders headers, <line24> @ApiParam( <line25> value = ""container id that process instance belongs to"", <line26> required = true, <line27> example = ""evaluation_1.0.0-SNAPSHOT"") <line28> @PathParam(CONTAINER_ID) <line29> String containerId, <line30> @ApiParam( <line31> value = ""identifier of process instance to be migrated"", <line32> required = true, <line33> example = ""123"") <line34> @PathParam(PROCESS_INST_ID) <line35> Long processInstanceId, <line36> @ApiParam(value = ""container id that new process definition belongs to"", required = true) <line37> @QueryParam(""targetContainerId"") <line38> String targetContainerId, <line39> @ApiParam( <line40> value = ""process definition that process instance should be migrated to"", <line41> required = true) <line42> @QueryParam(""targetProcessId"") <line43> String targetProcessId, <line44> @ApiParam( <line45> value = ""node mapping - unique ids of old definition to new definition given as Map"", <line46> required = false, <line47> examples = <line48> @Example( <line49> value = { <line50> @ExampleProperty(mediaType = JSON, value = SIMPLE_VAR_MAP_JSON), <line51> @ExampleProperty(mediaType = XML, value = SIMPLE_VAR_MAP_XML) <line52> })) <line53> String payload) { <line54> Variant v = getVariant(headers); <line55> String type = getContentType(headers); <line56> Header conversationIdHeader = buildConversationIdHeader(containerId, context, headers); <line57> try { <line58> MigrationReportInstance reportInstance = <line59> processAdminServiceBase.migrateProcessInstance( <line60> containerId, processInstanceId, targetContainerId, targetProcessId, payload, type); <line61> return createCorrectVariant( <line62> reportInstance, headers, Response.Status.CREATED, conversationIdHeader); <line63> } catch (ProcessInstanceNotFoundException e) { <line64> return notFound( <line65> MessageFormat.format(PROCESS_INSTANCE_NOT_FOUND, processInstanceId), <line66> v, <line67> conversationIdHeader); <line68> } catch (DeploymentNotFoundException e) { <line69> return notFound( <line70> MessageFormat.format(CONTAINER_NOT_FOUND, containerId), v, conversationIdHeader); <line71> } catch (Exception e) { <line72> return internalServerError(errorMessage(e), v, conversationIdHeader); <line73> } <line74> } <line75> } <line76> "	"<line72>      logger.error(""Unexpected error during processing {}"", e.getMessage(), e);"	task4	
"public class A { <line0> protected String getInProgressKBCommentsLabel() { <line1> int inProgressKBCommentsCount = 0; <line2> try { <line3> inProgressKBCommentsCount = _kbSuggestionListDisplayContext.getInProgressKBCommentsCount(); <line4> } catch (PortalException portalException) { <line5> } <line6> return String.format( <line7> ""%s (%s)"", LanguageUtil.get(_resourceBundle, ""in-progress""), inProgressKBCommentsCount); <line8> } <line9> } <line10> "	"<line5>      log.error(""Unable to obtain in progress knowledge base comments count ""+ ""for  group ""+ _kbSuggestionListDisplayContext.getGroupId(),portalException);"	task4	
public class A { <line0> public UnitDefinition removeUnitDefinition(String id) { <line1> UnitDefinition unit = findUnitDefinition(id); <line2> if ((unit != null) && unit.removeFromParent()) { <line3> return unit; <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line5>    logger.warn(MessageFormat.format(""Could not find any {0} for the given id \""{1}\""."",UnitDefinition.class.getSimpleName(), id));"	task4	
public class A { <line0> private static void pre() { <line1> PropertyUtils.init(); <line2> } <line3> } <line4> 	<line1>    log.info(TIPS);	task4	
public class A { <line0> void close() { <line1> try { <line2> writeFileHandle.close(); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.warn(""Unable to close "" + file, e);"	task4	
public class A { <line0> @Override <line1> public JournalArticle remove(Serializable primaryKey) throws NoSuchArticleException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> JournalArticle journalArticle = <line6> (JournalArticle) session.get(JournalArticleImpl.class, primaryKey); <line7> if (journalArticle == null) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> throw new NoSuchArticleException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(journalArticle); <line13> } catch (NoSuchArticleException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	<line9>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @OnMessage <line1> public void echo(Session session, String message) throws Exception { <line2> session.getBasicRemote().sendObject(message); <line3> verifyRunningThread(session, LOGGER); <line4> } <line5> } <line6> 	"<line2>    LOGGER.info(""OnMessage called '"" + message + ""'"");"	task4	
public class A { <line0> private static void logIndentOptions( <line1> @Nonnull PsiFile file, <line2> @Nonnull FileIndentOptionsProvider provider, <line3> @Nonnull IndentOptions options) { <line4> } <line5> } <line6> 	"<line4>    LOG.debug(""Indent options returned by ""+ provider.getClass().getName()+ "" for ""+ file.getName()+ "": indent size=""+ options.INDENT_SIZE+ "", use tabs=""+ options.USE_TAB_CHARACTER+ "", tab size=""+ options.TAB_SIZE);"	task4	
"public class A { <line0> @Override <line1> public WikiPageResource findByUUID_G(String uuid, long groupId) <line2> throws NoSuchPageResourceException { <line3> WikiPageResource wikiPageResource = fetchByUUID_G(uuid, groupId); <line4> if (wikiPageResource == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""uuid=""); <line8> sb.append(uuid); <line9> sb.append("", groupId=""); <line10> sb.append(groupId); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchPageResourceException(sb.toString()); <line15> } <line16> return wikiPageResource; <line17> } <line18> } <line19> "	<line13>        log.debug(sb.toString());	task4	
public class A { <line0> public static com.liferay.segments.model.SegmentsEntrySoap getSegmentsEntry(long segmentsEntryId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.segments.model.SegmentsEntry returnValue = <line4> SegmentsEntryServiceUtil.getSegmentsEntry(segmentsEntryId); <line5> return com.liferay.segments.model.SegmentsEntrySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
"public class A { <line0> @SuppressWarnings(""serial"") <line1> @Override <line2> protected void init() { <line3> personalAddressMap = personalAddressDao.getPersonalAddressByAddressId(); <line4> addressCampaignValueMap = new HashMap<>(); <line5> { <line6> final SubmitLink excelExportLink = <line7> new SubmitLink(ContentMenuEntryPanel.LINK_ID, form) { <line8> @Override <line9> public void onSubmit() { <line10> final List<AddressDO> list = getList(); <line11> final byte[] xls = <line12> addressCampaignValueExport.export( <line13> list, <line14> personalAddressMap, <line15> addressCampaignValueMap, <line16> form.getSearchFilter().getAddressCampaign() != null <line17> ? form.getSearchFilter().getAddressCampaign().getTitle() <line18> : """"); <line19> if (xls == null || xls.length == 0) { <line20> form.addError(""address.book.hasNoVCards""); <line21> return; <line22> } <line23> final String filename = <line24> ""ProjectForge-AddressCampaignValueExport_"" <line25> + DateHelper.getDateAsFilenameSuffix(new Date()) <line26> + "".xlsx""; <line27> DownloadUtils.setDownloadTarget(xls, filename); <line28> } <line29> }; <line30> final ContentMenuEntryPanel excelExportButton = <line31> new ContentMenuEntryPanel( <line32> getNewContentMenuChildId(), excelExportLink, getString(""address.book.export"")) <line33> .setTooltip(getString(""address.book.export.tooltip"")); <line34> addContentMenuEntry(excelExportButton); <line35> } <line36> } <line37> } <line38> "	"<line10>              log.info(""Exporting address list."");"	task4	
"public class A { <line0> public Set<VEvent> getEvents(Interval interval, SyndFeed feed) { <line1> Set<VEvent> events = new HashSet<VEvent>(); <line2> try { <line3> @SuppressWarnings(""unchecked"") <line4> List<SyndEntry> entries = (List<SyndEntry>) feed.getEntries(); <line5> for (SyndEntry entry : entries) { <line6> PropertyList props = new PropertyList(); <line7> Date start = null; <line8> if (entry.getPublishedDate() != null) { <line9> start = entry.getPublishedDate(); <line10> } <line11> if (start != null && interval.contains(start.getTime())) { <line12> props.add(new DtStart(new DateTime(start), true)); <line13> props.add(new Summary(entry.getTitle())); <line14> props.add(new Description(entry.getDescription().getValue())); <line15> String guid = null; <line16> if (entry instanceof Item && ((Item) entry).getGuid() != null) { <line17> guid = ((Item) entry).getGuid().getValue(); <line18> props.add(new Uid(guid)); <line19> } <line20> if (entry.getLink() != null) { <line21> try { <line22> props.add(new Url(new URI(entry.getLink()))); <line23> } catch (URISyntaxException e1) { <line24> } <line25> } <line26> VEvent event = new VEvent(props); <line27> events.add(event); <line28> } <line29> } <line30> } catch (IllegalArgumentException e) { <line31> } <line32> return events; <line33> } <line34> } <line35> "	<line31>      log.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public Integer getSerial() { <line2> return super.getSerial(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting Serial: "", super.getSerial());"	task4	
public class A { <line0> private List<BigQuerySplit> readFromBigQuery( <line1> TableId tableId, <line2> Optional<List<ColumnHandle>> projectedColumns, <line3> int actualParallelism, <line4> Optional<String> filter) { <line5> List<ColumnHandle> columns = projectedColumns.orElse(ImmutableList.of()); <line6> List<String> projectedColumnsNames = <line7> columns.stream() <line8> .map(column -> ((BigQueryColumnHandle) column).getName()) <line9> .collect(toImmutableList()); <line10> ReadSession readSession = <line11> new ReadSessionCreator( <line12> readSessionCreatorConfig, bigQueryClient, bigQueryStorageClientFactory) <line13> .create(tableId, projectedColumnsNames, filter, actualParallelism); <line14> return readSession.getStreamsList().stream() <line15> .map( <line16> stream -> <line17> BigQuerySplit.forStream( <line18> stream.getName(), readSession.getAvroSchema().getSchema(), columns)) <line19> .collect(toImmutableList()); <line20> } <line21> } <line22> 	"<line5>    log.debug(""readFromBigQuery(tableId=%s, projectedColumns=%s, actualParallelism=%s, filter=[%s])"",tableId, projectedColumns, actualParallelism, filter);"	task4	
"public class A { <line0> static LogFile.RandomReader getRandomReader( <line1> File file, @Nullable KeyProvider encryptionKeyProvider, boolean fsyncPerTransaction) <line2> throws IOException { <line3> RandomAccessFile logFile = new RandomAccessFile(file, ""r""); <line4> try { <line5> File metaDataFile = Serialization.getMetaDataFile(file); <line6> if (logFile.length() == 0L || metaDataFile.exists()) { <line7> return new LogFileV3.RandomReader(file, encryptionKeyProvider, fsyncPerTransaction); <line8> } <line9> int version = logFile.readInt(); <line10> if (Serialization.VERSION_2 == version) { <line11> return new LogFileV2.RandomReader(file); <line12> } <line13> throw new IOException(""File "" + file + "" has bad version "" + Integer.toHexString(version)); <line14> } finally { <line15> if (logFile != null) { <line16> try { <line17> logFile.close(); <line18> } catch (IOException e) { <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	"<line19>          LOGGER.warn(""Unable to close "" + file, e);"	task4	
public class A { <line0> public void uninstallBundle(Bundle bundle) { <line1> try { <line2> bundle.uninstall(); <line3> } catch (BundleException bundleException) { <line4> } <line5> } <line6> } <line7> 	<line4>      log.error(bundleException, bundleException);	task4	
public class A { <line0> @Override <line1> public byte[] serializeHandshakeMessageContent() { <line2> if (hasExtensionLengthField()) { <line3> writeExtensionLength(); <line4> if (hasExtensions()) { <line5> writeExtensionBytes(); <line6> } <line7> } <line8> return getAlreadySerialized(); <line9> } <line10> } <line11> 	"<line2>    LOGGER.debug(""Serializing EncryptedExtensionsMessage"");"	task4	
"public class A { <line0> @Override <line1> public void applyInTx() { <line2> try { <line3> FileUtils.moveDirectory(dataTargetFolder(), dataSourceFolder()); <line4> } catch (Exception e) { <line5> throw new RuntimeException( <line6> ""Could not move data folder to backup location {"" <line7> + dataTargetFolder().getAbsolutePath() <line8> + ""}. Maybe the permissions not allowing this?""); <line9> } <line10> Vertex meshRoot = getMeshRootVertex(); <line11> Vertex binaryRoot = getGraph().addVertex(""class:BinaryRootImpl""); <line12> binaryRoot.setProperty(""ferma_type"", ""BinaryRootImpl""); <line13> binaryRoot.setProperty(""uuid"", randomUUID()); <line14> meshRoot.addEdge(""HAS_BINARY_ROOT"", binaryRoot).setProperty(""uuid"", randomUUID()); <line15> Iterable<Vertex> it = getGraph().getVertices(""@class"", ""BinaryGraphFieldImpl""); <line16> for (Vertex binaryField : it) { <line17> migrateField(binaryField, binaryRoot); <line18> } <line19> } <line20> } <line21> "	"<line3>      log.info(""Moving current data directory away to {"" + dataSourceFolder().getAbsolutePath() + ""}"");"	task4	
public class A { <line0> @Override <line1> protected void start() { <line2> try { <line3> super.start(); <line4> super.destroy(); <line5> this.with(LAST_UPDATED_ORDERBY.clone()) <line6> .direction(DIRECTION.DESC) <line7> .with(POSTED_TIME_ORDERBY.clone()) <line8> .direction(DIRECTION.DESC); <line9> } catch (Exception ex) { <line10> } <line11> } <line12> } <line13> 	<line10>      LOG.warn(ex);	task4	
public class A { <line0> @Override <line1> public void timeout(long timeoutMs) { <line2> this.timeoutMs = timeoutMs; <line3> } <line4> } <line5> 	"<line2>    log.debug(""{} Setting timeout to {} ms"", this, timeoutMs);"	task4	
public class A { <line0> private int buildPreprocess(Resource root) { <line1> StmtIterator solnIter = root.listProperties(ResultSetGraphVocab.solution); <line2> int rows = 0; <line3> int indexed = 0; <line4> for (; solnIter.hasNext(); ) { <line5> Resource soln = solnIter.nextStatement().getResource(); <line6> rows++; <line7> if (soln.hasProperty(ResultSetGraphVocab.index)) indexed++; <line8> } <line9> solnIter.close(); <line10> if (indexed > 0 && rows != indexed) { <line11> return rows; <line12> } <line13> return rows; <line14> } <line15> } <line16> 	"<line11>      Log.warn(this, ""Rows = "" + rows + "" but only "" + indexed + "" indexes"");"	task4	
"public class A { <line0> protected @Nullable T getAppliance(OndusService ondusService) { <line1> try { <line2> BaseAppliance appliance = <line3> ondusService.getAppliance(getRoom(), config.applianceId).orElse(null); <line4> if (appliance.getType() != getType()) { <line5> updateStatus( <line6> ThingStatus.OFFLINE, <line7> ThingStatusDetail.CONFIGURATION_ERROR, <line8> ""Thing is not a GROHE SENSE Guard device.""); <line9> return null; <line10> } <line11> return (T) appliance; <line12> } catch (IOException e) { <line13> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line14> } <line15> return null; <line16> } <line17> } <line18> "	"<line14>      logger.debug(""Could not load appliance"", e);"	task4	
"public class A { <line0> private void executeQueryOnBuckets( <line1> Collection<Collection> resultCollector, ExecutionContext context) <line2> throws ForceReattemptException, QueryInvocationTargetException, QueryException { <line3> QueryMonitor queryMonitor = null; <line4> if (GemFireCacheImpl.getInstance() != null) { <line5> queryMonitor = GemFireCacheImpl.getInstance().getQueryMonitor(); <line6> } <line7> try { <line8> if (queryMonitor != null) { <line9> queryMonitor.monitorQueryExecution(context); <line10> } <line11> Object results = query.executeUsingContext(context); <line12> synchronized (resultCollector) { <line13> this.resultType = ((SelectResults) results).getCollectionType().getElementType(); <line14> resultCollector.add((Collection) results); <line15> } <line16> isIndexUsedForLocalQuery = ((QueryExecutionContext) context).isIndexUsed(); <line17> } catch (BucketMovedException bme) { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> throw new ForceReattemptException( <line21> ""Query targeted local bucket not found."" + bme.getMessage(), bme); <line22> } catch (RegionDestroyedException rde) { <line23> throw new QueryInvocationTargetException( <line24> ""The Region on which query is executed may have been destroyed."" + rde.getMessage(), rde); <line25> } catch (QueryException qe) { <line26> if (pr.isLocallyDestroyed || pr.isClosed) { <line27> throw new ForceReattemptException( <line28> ""Local Partition Region or the targeted bucket has been moved""); <line29> } <line30> throw qe; <line31> } finally { <line32> if (queryMonitor != null) { <line33> queryMonitor.stopMonitoringQueryExecution(context); <line34> } <line35> } <line36> } <line37> } <line38> "	"<line19>        logger.debug(""Query targeted local bucket not found. {}"", bme.getMessage(), bme);"	task4	
public class A { <line0> void logActionWithMarker( <line1> final EntityIdentification entity, final Marker marker, final Operation operation) { <line2> if (logger.isInfoEnabled()) { <line3> final Instant now = Instant.now(); <line4> final String entityName = entity.getClass().getSimpleName(); <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.info(marker,""{} {} {} of [{}] at [{}], unix [{}]"",operation.toString().toLowerCase(Locale.ENGLISH),entityName,marker.getName().toLowerCase(),entity.getUuid(),now,now.getEpochSecond());"	task4	
public class A { <line0> private void onWatcherClosed(Exception cause) { <line1> if (closeCalled) { <line2> return; <line3> } <line4> int currentRetries = retries.addAndGet(1); <line5> if (currentRetries >= MAX_RETRIES) { <line6> giveUp.run(); <line7> } else { <line8> try { <line9> watcher = watcherCreator.apply(listener); <line10> retries.set(0); <line11> } catch (Exception ex) { <line12> ex.addSuppressed(cause); <line13> onWatcherClosed(ex); <line14> } <line15> } <line16> } <line17> } <line18> 	"<line6>      LOGGER.error(""Giving up on retrying watcher"", cause);"	task4	
public class A { <line0> void remove(final String id) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> try { <line3> daoManager.startTransaction(em); <line4> UserDelegateEntity item = em.find(UserDelegateEntity.class, id); <line5> em.remove(item); <line6> daoManager.commitTransaction(em); <line7> } catch (Exception e) { <line8> daoManager.rollBackTransaction(em); <line9> } finally { <line10> daoManager.closeEntityManager(em); <line11> } <line12> } <line13> } <line14> 	<line9>      LOG.error(e.getMessage());	task4	
public class A { <line0> @Override <line1> @Transactional <line2> public void updateSessionActivity(String id) { <line3> Long lastWrite = recentUsageUpdates.get(id); <line4> if (lastWrite != null) { <line5> if (System.currentTimeMillis() < lastWrite + DB_ACTIVITY_WRITE_DELAY) return; <line6> } <line7> if (!updateSession(id, session -> session.setLastUsed(new Date()))) <line8> throw new SessionExpiredException(); <line9> recentUsageUpdates.put(id, System.currentTimeMillis()); <line10> } <line11> } <line12> 	"<line9>    log.trace(""Updated in db session activity timestamp for "" + id);"	task4	
"public class A { <line0> @Override <line1> public int doStartTag() throws JspException { <line2> try { <line3> String currentCounter = this.getCurrentIndex(); <line4> this.pageContext.getOut().print(currentCounter); <line5> } catch (Throwable t) { <line6> throw new JspException(""error creating (or modifying) counter"", t); <line7> } <line8> return super.doStartTag(); <line9> } <line10> } <line11> "	"<line6>      logger.error(""error creating (or modifying) counter"", t);"	task4	
"public class A { <line0> Session createSession(User user) throws SecurityException { <line1> Session session = null; <line2> LdapConnection ld = null; <line3> try { <line4> ld = getAdminConnection(); <line5> ld.setTimeOut(0); <line6> RbacCreateSessionRequest rbacCreateSessionRequest = new RbacCreateSessionRequestImpl(); <line7> rbacCreateSessionRequest.setTenantId(user.getContextId()); <line8> rbacCreateSessionRequest.setUserIdentity(user.getUserId()); <line9> rbacCreateSessionRequest.setPassword(new String(user.getPassword())); <line10> if (CollectionUtils.isNotEmpty(user.getRoles())) { <line11> for (UserRole userRole : user.getRoles()) { <line12> rbacCreateSessionRequest.addRole(userRole.getName()); <line13> } <line14> } <line15> RbacCreateSessionResponse rbacCreateSessionResponse = <line16> (RbacCreateSessionResponse) ld.extended(rbacCreateSessionRequest); <line17> session = new Session(user, rbacCreateSessionResponse.getSessionId()); <line18> if (rbacCreateSessionResponse.getLdapResult().getResultCode() == ResultCodeEnum.SUCCESS) { <line19> session.setAuthenticated(true); <line20> } else { <line21> session.setAuthenticated(false); <line22> String info = <line23> ""createSession UserId ["" <line24> + user.getUserId() <line25> + ""] failed: "" <line26> + rbacCreateSessionResponse.getLdapResult() <line27> + "" , resultCode: "" <line28> + rbacCreateSessionResponse.getLdapResult().getResultCode().getResultCode(); <line29> throw new SecurityException(GlobalErrIds.USER_PW_INVLD, info); <line30> } <line31> } catch (LdapException e) { <line32> String error = <line33> ""createSession userId ["" <line34> + user.getUserId() <line35> + ""] caught LDAPException="" <line36> + "" msg="" <line37> + e.getMessage(); <line38> throw new SecurityException(GlobalErrIds.ACEL_CREATE_SESSION_ERR, error, e); <line39> } finally { <line40> closeAdminConnection(ld); <line41> } <line42> return session; <line43> } <line44> } <line45> "	"<line17>      LOG.debug(""createSession userId: {}, sessionId: {}, resultCode: {}"",user.getUserId(),rbacCreateSessionResponse.getSessionId(),rbacCreateSessionResponse.getLdapResult().getResultCode());"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> serviceCenterTaskMonitor.beginCycle(interval); <line4> microserviceServiceCenterTask.run(); <line5> serviceCenterTaskMonitor.endCycle(); <line6> } catch (Throwable e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOGGER.error(""unexpected exception caught from service center task. "", e);"	task4	
public class A { <line0> @Override <line1> public void appendToComment(String st) { <line2> } <line3> } <line4> 	"<line2>    log.warn(""Can't append '{}' to comment. SessionInfoService is not supported in {}"", st, jaggerPlace);"	task4	
"public class A { <line0> private DataCell[] readSparseRow() { <line1> DataCell[] rowCells = new DataCell[m_tSpec.getNumColumns()]; <line2> String token; <line3> token = m_tokenizer.nextToken().substring(1); <line4> boolean foundending = false; <line5> while ((token != null) && !token.isEmpty() && (!token.equals(""\n""))) { <line6> if (token.charAt(token.length() - 1) == '}') { <line7> foundending = true; <line8> token = token.substring(0, token.length() - 1); <line9> } <line10> String[] fields = token.split("" ""); <line11> if (fields.length != 2) { <line12> throw new IllegalStateException(""Malformatted sparse data entry: '"" + token + ""'""); <line13> } <line14> int col; <line15> try { <line16> col = Integer.parseInt(fields[0].trim()); <line17> } catch (NumberFormatException e) { <line18> throw new IllegalStateException( <line19> ""Malformatted column index in sparse data entry: '"" + fields[0].trim() + ""'""); <line20> } <line21> String data = fields[1]; <line22> if (!m_tokenizer.lastTokenWasQuoted()) { <line23> data = data.trim(); <line24> } <line25> boolean missCell = data.equals(""?"") && !m_tokenizer.lastTokenWasQuoted(); <line26> rowCells[col] = createNewDataCellOfType(m_tSpec.getColumnSpec(col).getType(), data, missCell); <line27> token = m_tokenizer.nextToken(); <line28> } <line29> if (!foundending) { <line30> int line = m_tokenizer.getLineNumber(); <line31> if (token != null && token.equals(""\n"")) { <line32> line--; <line33> } <line34> } <line35> for (int c = 0; c < rowCells.length; c++) { <line36> if (rowCells[c] == null) { <line37> rowCells[c] = createNewDataCellOfType(m_tSpec.getColumnSpec(c).getType(), ""0"", false); <line38> } <line39> } <line40> return rowCells; <line41> } <line42> } <line43> "	"<line34>      LOGGER.error(""Malformatted sparse row in line "" + line + "" (closing bracket not found)."");"	task4	
public class A { <line0> @Override <line1> public void onMessageReceived(String from, ClusterMessage message) { <line2> if (getClusterMessageKey().equalsIgnoreCase(message.getType())) { <line3> CacheBackedProviderClusterMessage content = <line4> (CacheBackedProviderClusterMessage) message.getMessage(); <line5> if (CacheBackedProviderClusterMessage.Type.REMOVED == content.getType()) { <line6> removeItems(content.getItems()); <line7> } <line8> if (CacheBackedProviderClusterMessage.Type.REFRESHED == content.getType()) { <line9> if (canRefresh()) { <line10> removeAll(); <line11> populateCache(); <line12> } else { <line13> } <line14> } else if (CacheBackedProviderClusterMessage.Type.ADDED == content.getType()) { <line15> addItems(content.getItems()); <line16> } <line17> } <line18> } <line19> } <line20> 	"<line13>          log.info(""Cluster message received to Refresh the cache, but uanble to as it is still being""+ "" populated."");"	task4	
"public class A { <line0> @Override <line1> public void addRole(Role role) throws ApsSystemException { <line2> try { <line3> this.getRoleDAO().addRole(role); <line4> this.getRoleCacheWrapper().addRole(role); <line5> } catch (Throwable t) { <line6> throw new ApsSystemException(""Error while adding a role"", t); <line7> } <line8> } <line9> } <line10> "	"<line6>      logger.error(""Error while adding a role"", t);"	task4	
public class A { <line0> private void logAvailableInstances(Logger logger, Instance<MessageSender> instances) { <line1> List<String> names = new ArrayList<>(); <line2> for (MessageSender instance : instances) { <line3> names.add(instance.getMessageSenderId()); <line4> } <line5> } <line6> } <line7> 	"<line5>    logger.info(""Found multiple message senders: {}."", names.stream().collect(Collectors.joining("", "")));"	task4	
public class A { <line0> private int addPattern(OWLAxiom axiom) { <line1> String axiomString = render(axiom); <line2> Integer patternID = getPatternID(axiom); <line3> if (patternID != null) { <line4> return patternID; <line5> } <line6> try { <line7> insertPatternIdPs.setString(1, axiomString); <line8> insertPatternIdPs.setString(2, axiomRenderer.render(axiom)); <line9> insertPatternIdPs.setString(3, getAxiomType(axiom)); <line10> insertPatternIdPs.execute(); <line11> } catch (SQLException e) { <line12> } <line13> return getPatternID(axiom); <line14> } <line15> } <line16> 	"<line12>      LOGGER.error(""Failed to insert pattern. Maybe too long with a length of "" + axiomString.length() + ""?"",e);"	task4	
"public class A { <line0> public void await(long timeoutMillis) throws InterruptedException { <line1> if (latch.await(timeoutMillis, TimeUnit.MILLISECONDS)) { <line2> return; <line3> } <line4> long c = latch.getCount(); <line5> Preconditions.checkState(0 < c); <line6> String msg = <line7> ""Did not read expected number of messages before timeout was reached (latch count is "" <line8> + c <line9> + "")""; <line10> throw new AssertionError(msg); <line11> } <line12> } <line13> "	<line10>    log.error(msg);	task4	
public class A { <line0> private void handleAlreadyInvalidEntry(EntryEventImpl event, LocalRegion owner, RegionEntry re) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> processVersionTag(re, event); <line4> if (owner.getConcurrencyChecksEnabled() && event.hasValidVersionTag()) { <line5> event.invokeCallbacks(owner, true, true); <line6> } <line7> } <line8> } <line9> 	"<line2>      logger.debug(""Invalidate: Entry already invalid: '{}'"", event.getKey());"	task4	
public class A { <line0> @Override <line1> protected void initInternal(final FilterConfig filterConfig) throws ServletException { <line2> setExceptionOnValidationFailure(getBoolean(ConfigurationKeys.EXCEPTION_ON_VALIDATION_FAILURE)); <line3> setRedirectAfterValidation(getBoolean(ConfigurationKeys.REDIRECT_AFTER_VALIDATION)); <line4> setUseSession(getBoolean(ConfigurationKeys.USE_SESSION)); <line5> if (!this.useSession && this.redirectAfterValidation) { <line6> setRedirectAfterValidation(false); <line7> } <line8> setTicketValidator(getTicketValidator(filterConfig)); <line9> super.initInternal(filterConfig); <line10> } <line11> } <line12> 	"<line6>      logger.warn(""redirectAfterValidation parameter may not be true when useSession parameter is false.""+ "" Resetting it to false in order to prevent infinite redirects."");"	task4	
"public class A { <line0> private List<String> installLinux(List<String> urls, String saveAs) { <line1> String apt = <line2> chainGroup( <line3> installPackage(MutableMap.of(""apt"", ""python-httplib2 libssl0.9.8""), null), <line4> sudo(format(""dpkg -i %s"", saveAs))); <line5> String yum = <line6> chainGroup( <line7> ""which yum"", <line8> ok( <line9> sudo( <line10> ""sed -i.bk s/^enabled=1$/enabled=0/"" <line11> + "" /etc/yum/pluginconf.d/subscription-manager.conf"")), <line12> ok(sudo(""yum check-update"")), <line13> sudo(""yum install -y pkgconfig""), <line14> sudo( <line15> ""[ -f /etc/redhat-release ] && (grep -i \""red hat\"" /etc/redhat-release && sudo yum"" <line16> + "" install -y openssl098e) || :""), <line17> sudo(format(""rpm --install %s"", saveAs))); <line18> String link = <line19> new DownloadProducerFromUrlAttribute() <line20> .apply(new BasicDownloadRequirement(this)) <line21> .getPrimaryLocations() <line22> .iterator() <line23> .next(); <line24> return ImmutableList.<String>builder() <line25> .add(INSTALL_CURL) <line26> .addAll( <line27> Arrays.asList( <line28> INSTALL_CURL, <line29> BashCommands.require( <line30> BashCommands.alternatives( <line31> BashCommands.simpleDownloadUrlAs(urls, saveAs), <line32> ""curl -f -L -k "" <line33> + BashStringEscapes.wrapBash(link) <line34> + "" -H 'Referer: http://www.couchbase.com/downloads'"" <line35> + "" -o "" <line36> + saveAs), <line37> ""Could not retrieve "" + saveAs + "" (from "" + urls.size() + "" sites)"", <line38> 9))) <line39> .add(alternatives(apt, yum)) <line40> .build(); <line41> } <line42> } <line43> "	"<line1>    log.info(""Installing "" + getEntity() + "" using couchbase-server-{} {}"",getCommunityOrEnterprise(),getVersion());"	task4	
"public class A { <line0> SwaggerResource swaggerResource(String name, String location) { <line1> SwaggerResource swaggerResource = new SwaggerResource(); <line2> swaggerResource.setName(name); <line3> swaggerResource.setLocation(location); <line4> swaggerResource.setSwaggerVersion(""3.0""); <line5> return swaggerResource; <line6> } <line7> } <line8> "	"<line1>    log.info(""name:{},location:{}"", name, location);"	task4	
"public class A { <line0> public B addExtra(String key, Number value) { <line1> Preconditions.checkArgument(!(null == key), ""Key should not be null.""); <line2> if (null == value) { <line3> return theBuilder; <line4> } <line5> if (null == numberExtrasBuilder) { <line6> numberExtrasBuilder = new HashMap<String, Number>(); <line7> } <line8> numberExtrasBuilder.put(key, value); <line9> return theBuilder; <line10> } <line11> } <line12> "	"<line3>      LOG.debug(""Extra value is null, throw away it."");"	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Calendar""}, <line2> description = ""missing column friday"", <line3> priority = 137) <line4> public void verifyTest_2_2_6() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""calendar_2_6"", GTFS_1_GTFS_Common_9, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""calendar.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(1), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	"<line5>    log.info(Color.GREEN + ""Calendar_2_6 : missing column friday"" + Color.NORMAL);"	task4	
"public class A { <line0> private Pair<String, Integer> getPeerInfo(Channel channel) { <line1> try { <line2> String[] peerInfo = channel.remoteAddress().toString().replace(""/"", """").split("":""); <line3> return new Pair<>(peerInfo[0], Integer.parseInt(peerInfo[1])); <line4> } catch (Exception e) { <line5> } <line6> return new Pair<>(null, 0); <line7> } <line8> } <line9> "	"<line5>      logger.debug(""Failed to parse peer info for SSL engine initialization"", e);"	task4	
"public class A { <line0> protected String filterQueryString(String queryString) { <line1> String query = queryString.replaceAll(COMMENT_BLOCK_PATTERN, """"); <line2> String[] lines = query.split(""\\n""); <line3> StringBuilder stringBuilder = new StringBuilder(""""); <line4> for (String line : lines) { <line5> line = line.trim(); <line6> if (!line.startsWith(""--"") && !line.isEmpty() && !line.startsWith(""#"")) { <line7> line = line.replaceAll(""\\?"", """"); <line8> line = line.replaceAll(""\\:"", """"); <line9> stringBuilder.append(line); <line10> stringBuilder.append("" ""); <line11> } <line12> } <line13> stringBuilder.deleteCharAt(stringBuilder.length() - 1); <line14> return stringBuilder.toString(); <line15> } <line16> } <line17> "	"<line9>        logger.debug(""Query line: "" + line);"	task4	
"public class A { <line0> @Test <line1> public void testNumericAndRange() throws Exception { <line2> String query = <line3> ""("" <line4> + CityField.NUM.name() <line5> + GTE_OP <line6> + ""30)"" <line7> + AND_OP <line8> + ""("" <line9> + CityField.NUM.name() <line10> + LTE_OP <line11> + ""105)""; <line12> runTest(""((_Bounded_ = true) && ("" + query + ""))"", query); <line13> } <line14> } <line15> "	"<line2>    log.info(""------  testNumericAndRange  ------"");"	task4	
public class A { <line0> private PartitionData add(final PartitionData pd, final ByteArray itemId) { <line1> PartitionData singleton = uniqueSetOfPartitions.get(pd); <line2> if (singleton == null) { <line3> uniqueSetOfPartitions.put(pd, pd); <line4> singleton = pd; <line5> } <line6> Set<ByteArray> idsSet = partitionsToIds.get(singleton); <line7> if (idsSet == null) { <line8> idsSet = new HashSet<>(); <line9> partitionsToIds.put(singleton, idsSet); <line10> } <line11> if (idsSet.size() > upperBoundPerPartition) { <line12> return null; <line13> } <line14> if (idsSet.size() == upperBoundPerPartition) { <line15> } <line16> idsSet.add(itemId); <line17> Set<PartitionData> partitionSet = idsToPartition.get(itemId); <line18> if (partitionSet == null) { <line19> partitionSet = new HashSet<>(); <line20> idsToPartition.put(itemId, partitionSet); <line21> } <line22> partitionSet.add(singleton); <line23> return singleton; <line24> } <line25> } <line26> 	"<line15>      LOGGER.warn(""At upper bound on partition.  Increase the bounds or condense the data."");"	task4	
public class A { <line0> public void delete(String reponame) { <line1> RepoEntry repoEntry = entriesRepository.findFirstByName(reponame); <line2> if (repoEntry != null) { <line3> entriesRepository.delete(repoEntry); <line4> } <line5> } <line6> } <line7> 	"<line4>      LOG.info(""Deleted {} repository {}."", repoEntry.getType(), reponame);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> RadioStation oldStation = currentStation; <line3> currentStationIndex++; <line4> currentStationIndex = currentStationIndex % stationsList.size(); <line5> currentStation = stationsList.get(currentStationIndex); <line6> currentStationChanged(currentStation); <line7> deferred.resolve(); <line8> } <line9> } <line10> 	"<line7>    logger.info(PRINT_BORDER + ""shuffleStations: "" + oldStation + "" -> "" + currentStation + PRINT_BORDER);"	task4	
"public class A { <line0> @Test <line1> public void dropImport() throws Exception { <line2> Repository repository = createTestRepoUsingRepoService(); <line3> getL10nJCommander() <line4> .run( <line5> ""push"", <line6> ""-r"", <line7> repository.getName(), <line8> ""-s"", <line9> getInputResourcesTestDir(""source"").getAbsolutePath()); <line10> Asset asset = <line11> assetClient.getAssetByPathAndRepositoryId(""source-xliff.xliff"", repository.getId()); <line12> importTranslations(asset.getId(), ""source-xliff_"", ""fr-FR""); <line13> importTranslations(asset.getId(), ""source-xliff_"", ""ja-JP""); <line14> Asset asset2 = <line15> assetClient.getAssetByPathAndRepositoryId(""source2-xliff.xliff"", repository.getId()); <line16> importTranslations(asset2.getId(), ""source2-xliff_"", ""fr-FR""); <line17> importTranslations(asset2.getId(), ""source2-xliff_"", ""ja-JP""); <line18> waitForRepositoryToHaveStringsForTranslations(repository.getId()); <line19> getL10nJCommander().run(""drop-export"", ""-r"", repository.getName()); <line20> final Long dropId = getLastDropIdFromOutput(outputCapture); <line21> Console mockConsole = mock(Console.class); <line22> when(mockConsole.readLine(Long.class)) <line23> .thenAnswer( <line24> new Answer<Long>() { <line25> @Override <line26> public Long answer(InvocationOnMock invocation) throws Throwable { <line27> return getAvailableDropNumberForDropIdFromOutput(dropId); <line28> } <line29> }); <line30> L10nJCommander l10nJCommander = getL10nJCommander(); <line31> DropImportCommand dropImportCommand = l10nJCommander.getCommand(DropImportCommand.class); <line32> dropImportCommand.console = mockConsole; <line33> int numberOfFrenchTranslationsBefore = getNumberOfFrenchTranslations(repository); <line34> localizeDropFiles(dropRepository.findById(dropId).orElse(null)); <line35> l10nJCommander.run( <line36> new String[] {""drop-import"", ""-r"", repository.getName(), ""--number-drop-fetched"", ""1000""}); <line37> int numberOfFrenchTranslationsAfter = getNumberOfFrenchTranslations(repository); <line38> assertEquals( <line39> ""2 new french translations must be added"", <line40> numberOfFrenchTranslationsBefore + 2, <line41> numberOfFrenchTranslationsAfter); <line42> getL10nJCommander() <line43> .run( <line44> ""tm-export"", <line45> ""-r"", <line46> repository.getName(), <line47> ""-t"", <line48> targetTestDir.getAbsolutePath(), <line49> ""--target-basename"", <line50> ""fortest""); <line51> modifyFilesInTargetTestDirectory(XliffUtils.replaceCreatedDateFunction()); <line52> checkExpectedGeneratedResources(); <line53> } <line54> } <line55> "	"<line21>    logger.debug(""Mocking the console input for drop id: {}"", dropId);"	task4	
"public class A { <line0> public CompletableFuture<StatefulRedisConnection<K, V>> getConnectionAsync(Intent intent) { <line1> if (debugEnabled) { <line2> } <line3> if (readFrom != null && intent == Intent.READ) { <line4> List<RedisNodeDescription> selection = <line5> readFrom.select( <line6> new ReadFrom.Nodes() { <line7> @Override <line8> public List<RedisNodeDescription> getNodes() { <line9> return knownNodes; <line10> } <line11>  <line12> @Override <line13> public Iterator<RedisNodeDescription> iterator() { <line14> return knownNodes.iterator(); <line15> } <line16> }); <line17> if (selection.isEmpty()) { <line18> throw new RedisException( <line19> String.format( <line20> ""Cannot determine a node to read (Known nodes: %s) with setting %s"", <line21> knownNodes, readFrom)); <line22> } <line23> try { <line24> Flux<StatefulRedisConnection<K, V>> connections = Flux.empty(); <line25> for (RedisNodeDescription node : selection) { <line26> connections = connections.concatWith(Mono.fromFuture(getConnection(node))); <line27> } <line28> if (OrderingReadFromAccessor.isOrderSensitive(readFrom) || selection.size() == 1) { <line29> return connections <line30> .filter(StatefulConnection::isOpen) <line31> .next() <line32> .switchIfEmpty(connections.next()) <line33> .toFuture(); <line34> } <line35> return connections <line36> .filter(StatefulConnection::isOpen) <line37> .collectList() <line38> .map( <line39> it -> { <line40> int index = ThreadLocalRandom.current().nextInt(it.size()); <line41> return it.get(index); <line42> }) <line43> .switchIfEmpty(connections.next()) <line44> .toFuture(); <line45> } catch (RuntimeException e) { <line46> throw Exceptions.bubble(e); <line47> } <line48> } <line49> return getConnection(getMaster()); <line50> } <line51> } <line52> "	"<line2>      logger.debug(""getConnectionAsync("" + intent + "")"");"	task4	
public class A { <line0> public void debug(Object msg, Throwable thr) { <line1> } <line2> } <line3> 	<line1>    logger.debug(msg, thr);	task4	
"public class A { <line0> @Override <line1> public Long getDatasetCount(Dataset dataset, Endpoint endpoint) throws MetadataException { <line2> try { <line3> DigirMetadata metadata = getDigirMetadata(endpoint); <line4> String code = MachineTagUtils.firstTag(dataset, TagName.DIGIR_CODE).getValue(); <line5> int numberOfRecords = <line6> metadata.getResources().stream() <line7> .filter((r) -> code.equals(r.getCode())) <line8> .findFirst() <line9> .map(DigirResource::getNumberOfRecords) <line10> .orElse(0); <line11> if (numberOfRecords != 0) { <line12> return (long) numberOfRecords; <line13> } <line14> return null; <line15> } catch (Exception e) { <line16> throw new MetadataException( <line17> ""Unable to retrieve count of DiGIR dataset ["" + dataset.getKey() + ""]"", <line18> e, <line19> ErrorCode.OTHER_ERROR); <line20> } <line21> } <line22> } <line23> "	"<line11>      LOG.info(""Retrieved count of {}"", numberOfRecords);"	task4	
public class A { <line0> @Override <line1> public ProbeResult executeTest() { <line2> try { <line3> ecdsaPkGroupsStatic = new LinkedList<>(); <line4> ecdsaPkGroupsEphemeral = new LinkedList<>(); <line5> ecdsaPkGroupsTls13 = new LinkedList<>(); <line6> ecdsaCertSigGroupsStatic = new LinkedList<>(); <line7> ecdsaCertSigGroupsEphemeral = new LinkedList<>(); <line8> ecdsaCertSigGroupsTls13 = new LinkedList<>(); <line9> Set<CertificateChain> certificates = new HashSet<>(); <line10> if (scanForRsaCert) { <line11> certificates.addAll(getRsaCerts()); <line12> } <line13> if (scanForDssCert) { <line14> certificates.addAll(getDssCerts()); <line15> } <line16> if (scanForEcdsaCert) { <line17> certificates.addAll(getEcdsaCerts()); <line18> } <line19> if (scanForGostCert) { <line20> certificates.addAll(getGostCert()); <line21> } <line22> if (scanForTls13) { <line23> certificates.addAll(getTls13Certs()); <line24> } <line25> if (certificates.isEmpty()) { <line26> return getCouldNotExecuteResult(); <line27> } else { <line28> return new CertificateResult( <line29> certificates, <line30> ecdsaPkGroupsStatic, <line31> ecdsaPkGroupsEphemeral, <line32> ecdsaCertSigGroupsStatic, <line33> ecdsaCertSigGroupsEphemeral, <line34> ecdsaPkGroupsTls13, <line35> ecdsaCertSigGroupsTls13); <line36> } <line37> } catch (Exception E) { <line38> return getCouldNotExecuteResult(); <line39> } <line40> } <line41> } <line42> 	"<line38>      LOGGER.error(""Could not scan for "" + getProbeName(), E);"	task4	
public class A { <line0> public static void catchAndLog(final Logger log, final CheckedRunnable r) { <line1> try { <line2> r.run(); <line3> } catch (final Exception e) { <line4> } <line5> } <line6> } <line7> 	<line4>      log.error(e.getMessage(), e);	task4	
public class A { <line0> private void killOozieJob(String jobId) { <line1> String out = sshOozieClient.killJob(jobId); <line2> } <line3> } <line4> 	"<line2>    log.info(""Killing job {}. {}"", jobId, out);"	task4	
public class A { <line0> @Verify(global = true) <line1> public void globalVerify() { <line2> ICacheListenerOperationCounter total = new ICacheListenerOperationCounter(); <line3> for (ICacheListenerOperationCounter i : results) { <line4> total.add(i); <line5> } <line6> } <line7> } <line8> 	"<line6>    logger.info(name + "": "" + total + "" from "" + results.size() + "" worker threads"");"	task4	
public class A { <line0> private static int getPositiveIntProperty( <line1> Configuration configSource, int defaultValue, String... keys) { <line2> configSource = guardConfigSource(configSource); <line3> if (configSource == null) { <line4> return defaultValue; <line5> } <line6> for (String key : keys) { <line7> Integer val = configSource.getInteger(key, null); <line8> if (val != null && val <= 0) { <line9> continue; <line10> } <line11> if (val != null) { <line12> return val; <line13> } <line14> } <line15> return defaultValue; <line16> } <line17> } <line18> 	"<line9>        LOGGER.warn(""Address resover key:{}'s value:{} is not positive, please check!"", key, val);"	task4	
"public class A { <line0> public static com.liferay.commerce.price.list.model.CommercePriceEntry upsertCommercePriceEntry( <line1> HttpPrincipal httpPrincipal, <line2> long commercePriceEntryId, <line3> long cProductId, <line4> String cpInstanceUuid, <line5> long commercePriceListId, <line6> String externalReferenceCode, <line7> java.math.BigDecimal price, <line8> boolean discountDiscovery, <line9> java.math.BigDecimal discountLevel1, <line10> java.math.BigDecimal discountLevel2, <line11> java.math.BigDecimal discountLevel3, <line12> java.math.BigDecimal discountLevel4, <line13> int displayDateMonth, <line14> int displayDateDay, <line15> int displayDateYear, <line16> int displayDateHour, <line17> int displayDateMinute, <line18> int expirationDateMonth, <line19> int expirationDateDay, <line20> int expirationDateYear, <line21> int expirationDateHour, <line22> int expirationDateMinute, <line23> boolean neverExpire, <line24> String skuExternalReferenceCode, <line25> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line26> throws com.liferay.portal.kernel.exception.PortalException { <line27> try { <line28> MethodKey methodKey = <line29> new MethodKey( <line30> CommercePriceEntryServiceUtil.class, <line31> ""upsertCommercePriceEntry"", <line32> _upsertCommercePriceEntryParameterTypes27); <line33> MethodHandler methodHandler = <line34> new MethodHandler( <line35> methodKey, <line36> commercePriceEntryId, <line37> cProductId, <line38> cpInstanceUuid, <line39> commercePriceListId, <line40> externalReferenceCode, <line41> price, <line42> discountDiscovery, <line43> discountLevel1, <line44> discountLevel2, <line45> discountLevel3, <line46> discountLevel4, <line47> displayDateMonth, <line48> displayDateDay, <line49> displayDateYear, <line50> displayDateHour, <line51> displayDateMinute, <line52> expirationDateMonth, <line53> expirationDateDay, <line54> expirationDateYear, <line55> expirationDateHour, <line56> expirationDateMinute, <line57> neverExpire, <line58> skuExternalReferenceCode, <line59> serviceContext); <line60> Object returnObj = null; <line61> try { <line62> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line63> } catch (Exception exception) { <line64> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line65> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line66> } <line67> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line68> } <line69> return (com.liferay.commerce.price.list.model.CommercePriceEntry) returnObj; <line70> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line71> throw systemException; <line72> } <line73> } <line74> } <line75> "	<line71>      log.error(systemException, systemException);	task4	
public class A { <line0> private void getAllLogicalSwitches() { <line1> ResourceCollection<LogicalSwitch> logicalSwitches = client.getAll(); <line2> } <line3> } <line4> 	"<line2>    LOGGER.info(""Logical switches returned to client: {}"", logicalSwitches.toJsonString());"	task4	
public class A { <line0> public static void sendCallback(String callbackURL, String executeStatus, long id) { <line1> if (Validator.isBlank(callbackURL)) { <line2> return; <line3> } <line4> HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); <line5> try (CloseableHttpClient closeableHttpClient = <line6> httpClientBuilder.useSystemProperties().build()) { <line7> HttpPost httpPost = new HttpPost(callbackURL); <line8> httpPost.setEntity( <line9> new StringEntity( <line10> _objectMapper.writeValueAsString(Collections.singletonMap(id, executeStatus)), <line11> ContentType.APPLICATION_JSON)); <line12> closeableHttpClient.execute(httpPost); <line13> } catch (Exception exception) { <line14> } <line15> } <line16> } <line17> 	<line14>      log.error(exception, exception);	task4	
public class A { <line0> @Activate <line1> protected void activate(ComponentContext componentContext) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	"<line3>      log.debug(""HostObjectComponent activated"");"	task4	
public class A { <line0> @Override <line1> public void run(TransformContext context, GtfsMutableRelationalDao dao) { <line2> int removedStopTimeCount = 0; <line3> int totalStopTimeCount = 0; <line4> for (Trip trip : dao.getAllTrips()) { <line5> List<StopTime> stopTimes = dao.getStopTimesForTrip(trip); <line6> for (int i = 0; i < stopTimes.size(); i++) { <line7> totalStopTimeCount++; <line8> StopTime stopTime = stopTimes.get(i); <line9> if (isNonRevenue(stopTime)) { <line10> dao.removeEntity(stopTime); <line11> removedStopTimeCount++; <line12> } <line13> } <line14> } <line15> UpdateLibrary.clearDaoCache(dao); <line16> } <line17> } <line18> 	"<line15>    log.info(""removed="" + removedStopTimeCount + "" total="" + totalStopTimeCount);"	task4	
public class A { <line0> @Override <line1> public void add(Policy policy) { <line2> Policy old = findApparentlyEqualAndWarnIfNotSameUniqueTag(policiesInternal, policy); <line3> if (old != null) { <line4> remove(old); <line5> } <line6> CatalogUtils.setCatalogItemIdOnAddition(AbstractEntity.this, policy); <line7> policiesInternal.add((AbstractPolicy) policy); <line8> ((AbstractPolicy) policy).setEntity(AbstractEntity.this); <line9> ConfigConstraints.assertValid(policy); <line10> getManagementSupport().getEntityChangeListener().onPolicyAdded(policy); <line11> sensors().emit(AbstractEntity.POLICY_ADDED, new PolicyDescriptor(policy)); <line12> } <line13> } <line14> 	"<line4>      LOG.debug(""Removing "" + old + "" when adding "" + policy + "" to "" + AbstractEntity.this);"	task4	
public class A { <line0> public static DocumentFragment createDocumentFragment(final Page thisPage) { <line1> final App app = StructrApp.getInstance(thisPage.getSecurityContext()); <line2> try { <line3> org.structr.web.entity.dom.DocumentFragment fragment = <line4> app.create(org.structr.web.entity.dom.DocumentFragment.class); <line5> fragment.setOwnerDocument(thisPage); <line6> return fragment; <line7> } catch (FrameworkException fex) { <line8> final Logger logger = LoggerFactory.getLogger(Page.class); <line9> } <line10> return null; <line11> } <line12> } <line13> 	"<line9>      logger.warn("""", fex);"	task4	
"public class A { <line0> @Override <line1> public WorkflowDocument loadWorkflowDocument(String documentId, Person user) { <line2> if (documentId == null) { <line3> throw new IllegalArgumentException(""invalid (null) documentHeaderId""); <line4> } <line5> if (user == null) { <line6> throw new IllegalArgumentException(""invalid (null) workflowUser""); <line7> } else if (StringUtils.isEmpty(user.getPrincipalName())) { <line8> throw new IllegalArgumentException(""invalid (empty) workflowUser""); <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> try { <line13> return WorkflowDocumentFactory.loadDocument(user.getPrincipalId(), documentId); <line14> } catch (IllegalArgumentException e) { <line15> throw new UnknownDocumentIdException( <line16> ""unable to locate document with documentHeaderId '"" + documentId + ""'""); <line17> } <line18> } <line19> } <line20> "	"<line11>      LOG.debug(""retrieving document("" + documentId + "","" + user.getPrincipalName() + "")"");"	task4	
public class A { <line0> @Override <line1> public void bsp(BSPPeer<LongWritable, Text, NullWritable, NullWritable, NullWritable> peer) <line2> throws IOException, SyncException, InterruptedException { <line3> long numOfPairs = 0; <line4> KeyValuePair<LongWritable, Text> readNext = null; <line5> while ((readNext = peer.readNext()) != null) { <line6> numOfPairs++; <line7> } <line8> assertTrue(numOfPairs > 2 || numOfPairs == 0); <line9> } <line10> } <line11> 	"<line6>      LOG.debug(readNext.getKey().get() + "" / "" + readNext.getValue().toString());"	task4	
"public class A { <line0> @Override <line1> public AssetLink findByE_E_T(long entryId1, long entryId2, int type) throws NoSuchLinkException { <line2> AssetLink assetLink = fetchByE_E_T(entryId1, entryId2, type); <line3> if (assetLink == null) { <line4> StringBundler sb = new StringBundler(8); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""entryId1=""); <line7> sb.append(entryId1); <line8> sb.append("", entryId2=""); <line9> sb.append(entryId2); <line10> sb.append("", type=""); <line11> sb.append(type); <line12> sb.append(""}""); <line13> if (log.isDebugEnabled()) { <line14> } <line15> throw new NoSuchLinkException(sb.toString()); <line16> } <line17> return assetLink; <line18> } <line19> } <line20> "	<line14>        log.debug(sb.toString());	task4	
public class A { <line0> private GrpcTransportConfig loadGrpcTransportConfig() { <line1> GrpcTransportConfig grpcTransportConfig = new GrpcTransportConfig(); <line2> grpcTransportConfig.read(profilerConfig.getProperties()); <line3> return grpcTransportConfig; <line4> } <line5> } <line6> 	"<line3>    logger.info(""{}"", grpcTransportConfig);"	task4	
public class A { <line0> private static void addMetricsRegistryRegistrationListener( <line1> MetricsRegistryRegistrationListener listener) { <line2> synchronized (PinotMetricUtils.class) { <line3> metricsRegistryRegistrationListenersMap.put(listener, Boolean.TRUE); <line4> Set<PinotMetricsRegistry> metricsRegistries = metricsRegistryMap.keySet(); <line5> for (PinotMetricsRegistry metricsRegistry : metricsRegistries) { <line6> listener.onMetricsRegistryRegistered(metricsRegistry); <line7> } <line8> } <line9> } <line10> } <line11> 	"<line5>      LOGGER.info(""Number of metrics registry: {}"", metricsRegistries.size());"	task4	
public class A { <line0> @Verify <line1> public void globalVerify() { <line2> MapOperationCounter total = new MapOperationCounter(); <line3> for (MapOperationCounter operationCounter : operationCounterList) { <line4> total.add(operationCounter); <line5> } <line6> } <line7> } <line8> 	"<line6>    logger.info(name + "": "" + total + "" from "" + operationCounterList.size() + "" worker threads"");"	task4	
"public class A { <line0> public static void unzip(final File zipFile, final File destination, final boolean noparent) { <line1> Files.assertDir(destination); <line2> Files.writable(destination); <line3> Files.assertFile(zipFile); <line4> Files.readable(zipFile); <line5> try { <line6> final ZipInputStream in = IO.unzip(zipFile); <line7> ZipEntry entry; <line8> while ((entry = in.getNextEntry()) != null) { <line9> String path = entry.getName(); <line10> if (noparent) { <line11> path = path.replaceFirst(""^[^/]+/"", """"); <line12> } <line13> final File file = new File(destination, path); <line14> if (entry.isDirectory()) { <line15> Files.mkdir(file); <line16> continue; <line17> } <line18> Files.mkdir(file.getParentFile()); <line19> IO.copy(in, file); <line20> final long lastModified = entry.getTime(); <line21> if (lastModified > 0) { <line22> file.setLastModified(lastModified); <line23> } <line24> } <line25> in.close(); <line26> } catch (final Exception e) { <line27> logger.log(Level.SEVERE, ""Unable to unzip "" + zipFile.getAbsolutePath(), e); <line28> throw new IllegalStateException(""Unable to unzip "" + zipFile.getAbsolutePath(), e); <line29> } <line30> } <line31> } <line32> "	"<line1>    logger.info(String.format(""Extracting '%s' to '%s'"", zipFile.getAbsolutePath(), destination.getAbsolutePath()));"	task4	
"public class A { <line0> private Object deserializeEventMessage(AgentEventBo agentEventBo) { <line1> try { <line2> if (agentEventBo.getVersion() == 0) { <line3> return this.agentEventMessageDeserializer.deserialize( <line4> agentEventBo.getEventType(), agentEventBo.getEventBody()); <line5> } else if (agentEventBo.getVersion() == AgentEventBo.CURRENT_VERSION) { <line6> return this.agentEventMessageDeserializerV1.deserialize( <line7> agentEventBo.getEventType(), agentEventBo.getEventBody()); <line8> } else { <line9> throw new UnsupportedEncodingException(""invalid version "" + agentEventBo.getVersion()); <line10> } <line11> } catch (UnsupportedEncodingException e) { <line12> return null; <line13> } <line14> } <line15> } <line16> "	"<line12>      logger.warn(""error deserializing event message"", e);"	task4	
public class A { <line0> public void addUnAckedMessages( <line1> PersistentDispatcherMultipleConsumers dispatcher, int numberOfMessages) { <line2> if (maxUnackedMessages > 0) { <line3> totalUnackedMessages.add(numberOfMessages); <line4> if (blockedDispatcherOnHighUnackedMsgs.get() <line5> && !dispatcher.isBlockedDispatcherOnUnackedMsgs() <line6> && dispatcher.getTotalUnackedMessages() > maxUnackedMsgsPerDispatcher) { <line7> lock.readLock().lock(); <line8> try { <line9> dispatcher.blockDispatcherOnUnackedMsgs(); <line10> blockedDispatchers.add(dispatcher); <line11> } finally { <line12> lock.readLock().unlock(); <line13> } <line14> } <line15> } <line16> } <line17> } <line18> 	"<line9>          log.info(""[{}] dispatcher reached to max unack msg limit on blocked-broker {}"",dispatcher.getName(),dispatcher.getTotalUnackedMessages());"	task4	
public class A { <line0> @Override <line1> public OutputStream createOutputStream(long arg0) throws IOException { <line2> file = new MyOutputStream(); <line3> return file; <line4> } <line5> } <line6> 	"<line2>    logger.trace(""createOutputStream: {}"", arg0);"	task4	
public class A { <line0> private void cancelSuspicionTimeoutTask(String memberId) { <line1> Disposable future = suspicionTimeoutTasks.remove(memberId); <line2> if (future != null && !future.isDisposed()) { <line3> future.dispose(); <line4> } <line5> } <line6> } <line7> 	"<line3>      LOGGER.debug(""[{}] Cancelled SuspicionTimeoutTask for {}"", localMember, memberId);"	task4	
"public class A { <line0> @Override <line1> public Object execute(CommandLine commandLine) throws Exception { <line2> String settings = commandLine.getValue(Options.SETTINGS_OPTION); <line3> Preferences preferences = getPreferences(); <line4> File file = new File(settings); <line5> List<Error> errors; <line6> try { <line7> errors = preferences.setValues(file); <line8> } finally { <line9> try { <line10> file.delete(); <line11> } catch (Exception e) { <line12> } <line13> } <line14> if (errors.size() > 0) { <line15> return errors; <line16> } <line17> return Services.getMessage(""settings.updated""); <line18> } <line19> } <line20> "	"<line12>        logger.warn(""Error deleting settings temp file: "" + file, e);"	task4	
public class A { <line0> @Override <line1> public ReturnWithExceptions<Void, ModelObserver> representationCreated( <line2> Representation representation) { <line3> ReturnWithExceptions<Void, ModelObserver> ret = new ReturnWithExceptions<>(this); <line4> try { <line5> AIP aip = model.retrieveAIP(representation.getAipId()); <line6> List<String> ancestors = SolrUtils.getAncestors(aip.getParentId(), model); <line7> indexRepresentation(aip, representation, ancestors).addTo(ret); <line8> if (ret.isEmpty()) { <line9> indexPreservationsEvents(aip.getId(), representation.getId()).addTo(ret); <line10> if (aip.getRepresentations().size() == 1) { <line11> SolrUtils.update( <line12> index, <line13> IndexedAIP.class, <line14> aip.getId(), <line15> Collections.singletonMap(RodaConstants.AIP_HAS_REPRESENTATIONS, true), <line16> (ModelObserver) this) <line17> .addTo(ret); <line18> } <line19> } <line20> } catch (RequestNotValidException <line21> | NotFoundException <line22> | GenericException <line23> | AuthorizationDeniedException e) { <line24> ret.add(e); <line25> } <line26> return ret; <line27> } <line28> } <line29> 	"<line24>      LOGGER.error(""Cannot index representation: {}"", representation, e);"	task4	
"public class A { <line0> private static String nuxeoLongValueToString(Object value) { <line1> Long longVal; <line2> try { <line3> longVal = (Long) value; <line4> } catch (ClassCastException cce) { <line5> return """"; <line6> } <line7> return longVal.toString(); <line8> } <line9> } <line10> "	"<line5>      logger.warn(""Could not convert a Nuxeo integer value to its string equivalent: "" + cce.getMessage());"	task4	
"public class A { <line0> private void testNodeFailBeforeSendGridNearTxFinishResponse() throws Exception { <line1> IgniteEx grid0 = startGrids(2); <line2> grid0.cluster().state(ClusterState.ACTIVE); <line3> IgniteEx grid1 = grid(1); <line4> int key0 = primaryKey(grid0.cache(DEFAULT_CACHE_NAME)); <line5> int key1 = primaryKey(grid1.cache(DEFAULT_CACHE_NAME)); <line6> Affinity<Object> aff = grid1.affinity(DEFAULT_CACHE_NAME); <line7> assertFalse( <line8> ""Keys have the same mapping [key0="" + key0 + "", key1="" + key1 + ']', <line9> aff.mapKeyToNode(key0).equals(aff.mapKeyToNode(key1))); <line10> spi(grid0).blockMessages(GridNearTxFinishResponse.class, getTestIgniteInstanceName(1)); <line11> IgniteInternalFuture stopNodeFut = <line12> GridTestUtils.runAsync( <line13> () -> { <line14> try { <line15> spi(grid0).waitForBlocked(); <line16> } catch (InterruptedException e) { <line17> } <line18> info(""Stopping node: ["" + grid0.name() + ']'); <line19> grid0.close(); <line20> }, <line21> ""node-stopper""); <line22> try (Transaction tx = grid1.transactions().txStart()) { <line23> grid1.cache(DEFAULT_CACHE_NAME).put(key0, 100); <line24> grid1.cache(DEFAULT_CACHE_NAME).put(key1, 200); <line25> tx.commit(); <line26> fail(""Transaction passed, but no one partition is alive.""); <line27> } catch (Exception e) { <line28> assertTrue(X.hasCause(e, CacheInvalidStateException.class)); <line29> String msg = e.getMessage(); <line30> assertTrue(msg.contains(ALL_PARTITION_OWNERS_LEFT_GRID_MSG)); <line31> if (!mvccEnabled(grid1.context())) { <line32> Pattern msgPtrn; <line33> if (S.getSensitiveDataLogging() == PLAIN) { <line34> msgPtrn = <line35> Pattern.compile( <line36> "" \\[cacheName="" <line37> + DEFAULT_CACHE_NAME <line38> + "", partition=\\d+, "" <line39> + ""key=KeyCacheObjectImpl \\[part=\\d+, val="" <line40> + key0 <line41> + "", hasValBytes=true\\]\\]""); <line42> } else if (S.getSensitiveDataLogging() == HASH) { <line43> msgPtrn = <line44> Pattern.compile( <line45> "" \\[cacheName="" <line46> + DEFAULT_CACHE_NAME <line47> + "", partition=\\d+, "" <line48> + ""key="" <line49> + IgniteUtils.hash(key0) <line50> + ""\\]""); <line51> } else { <line52> msgPtrn = <line53> Pattern.compile( <line54> "" \\[cacheName="" <line55> + DEFAULT_CACHE_NAME <line56> + "", partition=\\d+, "" <line57> + ""key=KeyCacheObject\\]""); <line58> } <line59> Matcher matcher = msgPtrn.matcher(msg); <line60> assertTrue(""Message does not match: [msg="" + msg + ']', matcher.find()); <line61> } <line62> } <line63> stopNodeFut.get(10_000); <line64> } <line65> } <line66> "	"<line17>                log.error(""Waiting is interrupted."", e);"	task4	
public class A { <line0> @Override <line1> public void exceptionCaught(Throwable cause) { <line2> if (cause instanceof Error) { <line3> throw (Error) cause; <line4> } <line5> } <line6> } <line7> 	"<line5>    LOGGER.warn(""Unexpected exception."", cause);"	task4	
public class A { <line0> public synchronized void cleanup(boolean deleteTemporary) { <line1> if (deleteTemporary && tempDirectory != null && tempDirectory.exists()) { <line2> FileUtils.delete(tempDirectory); <line3> tempDirectory = null; <line4> } <line5> } <line6> } <line7> 	"<line2>      LOGGER.debug(""Deleting ALL temporary files from `{}`"", tempDirectory.toString());"	task4	
public class A { <line0> private void successMessage(String msg) { <line1> messages.add(msg); <line2> } <line3> } <line4> 	<line2>    log.trace(msg);	task4	
public class A { <line0> protected Properties getDefaultPackageSelection() { <line1> File desc = new File(getDownloadDirectory(), PACKAGES_DEFAULT_SELECTION); <line2> if (desc.exists()) { <line3> try { <line4> Properties props = new Properties(); <line5> props.load(new FileReader(desc)); <line6> return props; <line7> } catch (IOException e) { <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> 	"<line8>        log.warn(""Unable to load presets"", e);"	task4	
public class A { <line0> @Override <line1> public void unload(Consumer<EntityPlayer> playerConsumer) { <line2> super.unload(playerConsumer); <line3> if (!this.worldDir.delete()) { <line4> } <line5> } <line6> } <line7> 	"<line4>      this.logger.warn(""Could not delete temp directory"");"	task4	
public class A { <line0> public void init() { <line1> if (disableGlobalTransaction) { <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> return; <line5> } <line6> initClient(); <line7> } <line8> } <line9> 	"<line3>        LOGGER.info(""Global transaction is disabled."");"	task4	
"public class A { <line0> protected void updateProcessDefinitionJsonWorkerGroup() { <line1> WorkerGroupDao workerGroupDao = new WorkerGroupDao(); <line2> ProcessDefinitionDao processDefinitionDao = new ProcessDefinitionDao(); <line3> Map<Integer, String> replaceProcessDefinitionMap = new HashMap<>(); <line4> try { <line5> Map<Integer, String> oldWorkerGroupMap = <line6> workerGroupDao.queryAllOldWorkerGroup(dataSource.getConnection()); <line7> Map<Integer, String> processDefinitionJsonMap = <line8> processDefinitionDao.queryAllProcessDefinition(dataSource.getConnection()); <line9> for (Map.Entry<Integer, String> entry : processDefinitionJsonMap.entrySet()) { <line10> ObjectNode jsonObject = JSONUtils.parseObject(entry.getValue()); <line11> ArrayNode tasks = JSONUtils.parseArray(jsonObject.get(""tasks"").toString()); <line12> for (int i = 0; i < tasks.size(); i++) { <line13> ObjectNode task = (ObjectNode) tasks.path(i); <line14> ObjectNode workerGroupNode = (ObjectNode) task.path(""workerGroupId""); <line15> Integer workerGroupId = -1; <line16> if (workerGroupNode != null && workerGroupNode.canConvertToInt()) { <line17> workerGroupId = workerGroupNode.asInt(-1); <line18> } <line19> if (workerGroupId == -1) { <line20> task.put(""workerGroup"", ""default""); <line21> } else { <line22> task.put(""workerGroup"", oldWorkerGroupMap.get(workerGroupId)); <line23> } <line24> } <line25> jsonObject.remove(""task""); <line26> jsonObject.put(""tasks"", tasks); <line27> replaceProcessDefinitionMap.put(entry.getKey(), jsonObject.toString()); <line28> } <line29> if (replaceProcessDefinitionMap.size() > 0) { <line30> processDefinitionDao.updateProcessDefinitionJson( <line31> dataSource.getConnection(), replaceProcessDefinitionMap); <line32> } <line33> } catch (Exception e) { <line34> } <line35> } <line36> } <line37> "	"<line34>      logger.error(""update process definition json workergroup error"", e);"	task4	
public class A { <line0> private void doTest() throws Exception { <line1> final AtomicBoolean failed = new AtomicBoolean(); <line2> for (int i = 0; i < GRID_CNT; i++) { <line3> final int idx = i; <line4> final Ignite grid = concurrent ? null : startGrid(idx); <line5> IgniteInternalFuture<?> fut = <line6> multithreadedAsync( <line7> new Runnable() { <line8> @Override <line9> public void run() { <line10> Random rnd = new Random(); <line11> try { <line12> Ignite ignite = grid == null ? startGrid(idx) : grid; <line13> IgniteCache<Object, Object> cache = getCache(ignite); <line14> cache.put(ignite.cluster().localNode().id(), UUID.randomUUID()); <line15> while (!stopped) { <line16> int val = Math.abs(rnd.nextInt(100)); <line17> if (val >= 0 && val < 40) <line18> cache.containsKey(ignite.cluster().localNode().id()); <line19> else if (val >= 40 && val < 80) cache.get(ignite.cluster().localNode().id()); <line20> else cache.put(ignite.cluster().localNode().id(), UUID.randomUUID()); <line21> Thread.sleep(50); <line22> } <line23> } catch (Exception e) { <line24> failed.set(true); <line25> } <line26> } <line27> }, <line28> 1); <line29> futs.add(fut); <line30> } <line31> Thread.sleep(10_000); <line32> stopped = true; <line33> for (IgniteInternalFuture<?> fut : futs) fut.get(); <line34> assertFalse(failed.get()); <line35> } <line36> } <line37> 	"<line24>                    log.error(""Unexpected error: "" + e, e);"	task4	
public class A { <line0> @Override <line1> protected final WriteMessage wrapMessage(Object msg, Future<Boolean> writeFuture) { <line2> ((Command) msg).encode(); <line3> ((Command) msg).setWriteFuture((FutureImpl<Boolean>) writeFuture); <line4> if (log.isDebugEnabled()) { <line5> } <line6> return (WriteMessage) msg; <line7> } <line8> } <line9> 	"<line5>      log.debug(""After encoding"" + ((Command) msg).toString());"	task4	
public class A { <line0> public static <CT extends TServiceClient, RT> RT executeRaw( <line1> ClientContext context, TServiceClientFactory<CT> factory, ClientExecReturn<RT, CT> exec) <line2> throws Exception { <line3> while (true) { <line4> CT client = null; <line5> String server = null; <line6> try { <line7> Pair<String, CT> pair = ServerClient.getConnection(context, factory, true); <line8> server = pair.getFirst(); <line9> client = pair.getSecond(); <line10> return exec.execute(client); <line11> } catch (TApplicationException tae) { <line12> throw new AccumuloServerException(server, tae); <line13> } catch (TTransportException tte) { <line14> sleepUninterruptibly(100, TimeUnit.MILLISECONDS); <line15> } finally { <line16> if (client != null) ServerClient.close(client); <line17> } <line18> } <line19> } <line20> } <line21> 	"<line14>        log.debug(""ClientService request failed "" + server + "", retrying ... "", tte);"	task4	
"public class A { <line0> @ResponseMetered(name = HttpConstants.WRITE_REQUEST) <line1> @Timed(name = HttpConstants.WRITE_REQUEST) <line2> @DELETE <line3> @Path(""{clusterId}/customized-state-config"") <line4> public Response removeCustomizedStateConfig(@PathParam(""clusterId"") String clusterId) { <line5> if (!doesClusterExist(clusterId)) { <line6> return notFound(String.format(""Cluster %s does not exist"", clusterId)); <line7> } <line8> HelixAdmin admin = getHelixAdmin(); <line9> try { <line10> admin.removeCustomizedStateConfig(clusterId); <line11> } catch (Exception ex) { <line12> return serverError(ex); <line13> } <line14> return OK(); <line15> } <line16> } <line17> "	"<line12>      LOG.error(""Cannot remove CustomizedStateConfig from cluster: {}, Exception: {}"", clusterId, ex);"	task4	
public class A { <line0> public void addCurrentContentItemToPresetContainer(DecimalType command) { <line1> if (command.intValue() > 6) { <line2> addContentItemToPresetContainer(command.intValue(), currentContentItem); <line3> } else { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.warn(""{}: Only PresetID >6 is allowed"", handler.getDeviceName());"	task4	
public class A { <line0> private CdiContainer doCreateContainer(Bundle bundle) { <line1> Set<Bundle> extensions = new HashSet<>(); <line2> findExtensions(bundle, extensions); <line3> return factory.createContainer(bundle, extensions); <line4> } <line5> } <line6> 	"<line3>    log.info(""creating CDI container for bean bundle {} with extension bundles {}"", bundle, extensions);"	task4	
public class A { <line0> private MapGeometrySupport loadPolylineRecord(PolyLineRecord shapeRec) { <line1> Point2D.Double[] pointList = shapeRec.getPoints(); <line2> int[] partsList = shapeRec.getParts(); <line3> boolean isBad = <line4> pointList == null || pointList.length == 0 || isBadPolylineOrPolygon(shapeRec.getPoints()); <line5> if (!isBad) { <line6> return processPolylineOrPolygonData(false, pointList, partsList); <line7> } else { <line8> return null; <line9> } <line10> } <line11> } <line12> 	"<line8>      LOGGER.warn(""Bad PolyLineRecord Detected and Discarded."");"	task4	
public class A { <line0> public static ResourceRequirements getResourceRequirements( <line1> ResourceRequirements resourceRequirements, <line2> int mem, <line3> double cpu, <line4> Map<String, ExternalResource> externalResources, <line5> Map<String, String> externalResourceConfigKeys) { <line6> final Quantity cpuQuantity = new Quantity(String.valueOf(cpu)); <line7> final Quantity memQuantity = new Quantity(mem + Constants.RESOURCE_UNIT_MB); <line8> ResourceRequirementsBuilder resourceRequirementsBuilder = <line9> new ResourceRequirementsBuilder(resourceRequirements) <line10> .addToRequests(Constants.RESOURCE_NAME_MEMORY, memQuantity) <line11> .addToRequests(Constants.RESOURCE_NAME_CPU, cpuQuantity) <line12> .addToLimits(Constants.RESOURCE_NAME_MEMORY, memQuantity) <line13> .addToLimits(Constants.RESOURCE_NAME_CPU, cpuQuantity); <line14> for (Map.Entry<String, ExternalResource> externalResource : externalResources.entrySet()) { <line15> final String configKey = externalResourceConfigKeys.get(externalResource.getKey()); <line16> if (!StringUtils.isNullOrWhitespaceOnly(configKey)) { <line17> final Quantity resourceQuantity = <line18> new Quantity(String.valueOf(externalResource.getValue().getValue().longValue())); <line19> resourceRequirementsBuilder <line20> .addToRequests(configKey, resourceQuantity) <line21> .addToLimits(configKey, resourceQuantity); <line22> } <line23> } <line24> return resourceRequirementsBuilder.build(); <line25> } <line26> } <line27> 	"<line22>        LOG.info(""Request external resource {} with config key {}."",resourceQuantity.getAmount(),configKey);"	task4	
public class A { <line0> public void cleanupContext() { <line1> WebContainer wc = getWebContainer(); <line2> if (wc == null || httpContext == null) { <line3> return; <line4> } <line5> wc.end(httpContext); <line6> httpContext = null; <line7> } <line8> } <line9> 	"<line1>    LOG.info(""{}: Restoring WebContainer for bundle {}/{}"", this, symbolicName, version);"	task4	
public class A { <line0> @AfterAll <line1> static void cdiContainerDown() { <line2> KafkaConnector factory = getInstance(KafkaConnector.class, KAFKA_CONNECTOR_LITERAL).get(); <line3> Collection<KafkaPublisher<?, ?>> resources = factory.resources(); <line4> assertFalse(resources.isEmpty()); <line5> cdiContainer.close(); <line6> assertTrue(resources.isEmpty()); <line7> } <line8> } <line9> 	"<line7>    LOGGER.info(""Container destroyed"");"	task4	
public class A { <line0> private void processPath(Bundle bundle, PathElement[] path) { <line1> try { <line2> TreeMapState ps = new TreeMapState(this, tree, path, bundle); <line3> ps.process(); <line4> processNodes.addAndGet(ps.touched()); <line5> } catch (RuntimeException ex) { <line6> throw ex; <line7> } catch (Exception ex) { <line8> } <line9> bench.addEvents(BENCH.RULES, 1); <line10> } <line11> } <line12> 	"<line8>      log.warn("""", ex);"	task4	
public class A { <line0> @Override <line1> public User addUserWithWorkflow( <line2> long companyId, <line3> boolean autoPassword, <line4> String password1, <line5> String password2, <line6> boolean autoScreenName, <line7> String screenName, <line8> String emailAddress, <line9> Locale locale, <line10> String firstName, <line11> String middleName, <line12> String lastName, <line13> long prefixId, <line14> long suffixId, <line15> boolean male, <line16> int birthdayMonth, <line17> int birthdayDay, <line18> int birthdayYear, <line19> String jobTitle, <line20> long[] groupIds, <line21> long[] organizationIds, <line22> long[] roleIds, <line23> long[] userGroupIds, <line24> boolean sendEmail, <line25> ServiceContext serviceContext) <line26> throws PortalException { <line27> long creatorUserId = 0; <line28> try { <line29> creatorUserId = getGuestOrUserId(); <line30> } catch (PrincipalException principalException) { <line31> if (log.isWarnEnabled()) { <line32> } <line33> } <line34> checkAddUserPermission( <line35> creatorUserId, <line36> companyId, <line37> emailAddress, <line38> groupIds, <line39> organizationIds, <line40> roleIds, <line41> userGroupIds, <line42> serviceContext); <line43> User user = <line44> userLocalService.addUserWithWorkflow( <line45> creatorUserId, <line46> companyId, <line47> autoPassword, <line48> password1, <line49> password2, <line50> autoScreenName, <line51> screenName, <line52> emailAddress, <line53> locale, <line54> firstName, <line55> middleName, <line56> lastName, <line57> prefixId, <line58> suffixId, <line59> male, <line60> birthdayMonth, <line61> birthdayDay, <line62> birthdayYear, <line63> jobTitle, <line64> groupIds, <line65> organizationIds, <line66> roleIds, <line67> userGroupIds, <line68> sendEmail, <line69> serviceContext); <line70> checkMembership( <line71> new long[] {user.getUserId()}, groupIds, organizationIds, roleIds, userGroupIds); <line72> propagateMembership( <line73> new long[] {user.getUserId()}, groupIds, organizationIds, roleIds, userGroupIds); <line74> return user; <line75> } <line76> } <line77> 	"<line32>        log.warn(""Unable to get guest or current user ID"", principalException);"	task4	
public class A { <line0> protected DashboardRenderer getDashboardRenderer(String layout) { <line1> try { <line2> return this.componentManager.getInstance(DashboardRenderer.class, layout); <line3> } catch (ComponentLookupException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	"<line4>      this.logger.warn(""Could not find the Dashboard renderer for layout \"""" + layout + ""\"""");"	task4	
public class A { <line0> public void add(OWLEntity entity, String name) { <line1> if (entity == null) { <line2> return; <line3> } <line4> Map<String, IRI> map = pickMap(entity); <line5> if (map == null) { <line6> return; <line7> } <line8> labels.put(entity.getIRI(), name); <line9> iris.put(name, entity.getIRI()); <line10> map.put(name, entity.getIRI()); <line11> } <line12> } <line13> 	"<line6>      logger.info(""Unknown OWL entity type for: "" + entity);"	task4	
public class A { <line0> @Subscribe <line1> public void lifecycleStateChange(Lifecycle lifecycle) { <line2> switch (lifecycle) { <line3> case RUNNING: <line4> paused = false; <line5> break; <line6> default: <line7> paused = true; <line8> } <line9> } <line10> } <line11> 	"<line2>    LOG.debug(""Lifecycle changed to {}"", lifecycle);"	task4	
public class A { <line0> @Override <line1> protected void recordEventStateFromImageProvider(InternalDistributedMember provider) { <line2> if (createRegionReplyProcessor != null) { <line3> Map<ThreadIdentifier, EventSequenceNumberHolder> providerEventStates = <line4> createRegionReplyProcessor.getEventState(provider); <line5> if (providerEventStates != null) { <line6> recordEventState(provider, providerEventStates); <line7> } else { <line8> } <line9> createRegionReplyProcessor = null; <line10> } <line11> } <line12> } <line13> 	"<line8>        logger.info(""Could not initiate event tracker from GII provider {}"", provider);"	task4	
public class A { <line0> @Override <line1> public void fillText(final String text, final double x, final double y) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> final AffineTransform savedTransform = graphics2D_.getTransform(); <line5> try { <line6> graphics2D_.setTransform(transformation_); <line7> graphics2D_.setColor(fillColor_); <line8> graphics2D_.drawString(text, (int) x, (int) y); <line9> } finally { <line10> graphics2D_.setTransform(savedTransform); <line11> } <line12> } <line13> } <line14> 	"<line3>      LOG.debug(""["" + id_ + ""] fillText('"" + text + ""', "" + x + "", "" + y + "")"");"	task4	
public class A { <line0> private void logPluginPathConfigProviderWarning(Map<String, String> rawOriginals) { <line1> String rawPluginPath = rawOriginals.get(PLUGIN_PATH_CONFIG); <line2> String transformedPluginPath = Objects.toString(originals().get(PLUGIN_PATH_CONFIG)); <line3> if (!Objects.equals(rawPluginPath, transformedPluginPath)) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.warn(""Variables cannot be used in the 'plugin.path' property, since the property is ""+ ""used by plugin scanning before the config providers that replace the ""+ ""variables are initialized. The raw value '{}' was used for plugin scanning, as ""+ ""opposed to the transformed value '{}', and this may cause unexpected results."",rawPluginPath,transformedPluginPath);"	task4	
"public class A { <line0> private static void matchSubElements( <line1> ModelNode descriptionModel, List<Lookup> fieldNames, List<FieldDesc> fields) { <line2> if (descriptionModel.hasDefined(RESULT)) <line3> descriptionModel = descriptionModel.get(RESULT).asObject(); <line4> try { <line5> if (descriptionModel.hasDefined(ATTRIBUTES)) { <line6> List<Property> elements = descriptionModel.get(ATTRIBUTES).asPropertyList(); <line7> for (Property element : elements) { <line8> String childName = element.getName(); <line9> ModelNode value = element.getValue(); <line10> for (Lookup lookup : fieldNames) { <line11> if (lookup.getDetypedName().equals(childName)) { <line12> FieldDesc desc = <line13> new FieldDesc(lookup.getJavaName(), value.get(""description"").asString()); <line14> if (value.hasDefined(""expressions-allowed"")) { <line15> desc.setSupportExpressions(value.get(""expressions-allowed"").asBoolean()); <line16> } <line17> if (!fields.contains(desc)) fields.add(desc); <line18> } <line19> } <line20> } <line21> } <line22> if (fieldNames.isEmpty()) return; <line23> if (descriptionModel.hasDefined(""children"")) { <line24> List<Property> children = descriptionModel.get(""children"").asPropertyList(); <line25> for (Property child : children) { <line26> ModelNode childDesc = child.getValue(); <line27> ModelNode desc = childDesc.get(MODEL_DESCRIPTION); <line28> if (desc.isDefined()) { <line29> for (Property modDescProp : desc.asPropertyList()) { <line30> matchSubElements( <line31> childDesc.get(MODEL_DESCRIPTION, modDescProp.getName()), fieldNames, fields); <line32> if (fieldNames.isEmpty()) return; <line33> } <line34> } <line35> } <line36> } <line37> } catch (IllegalArgumentException e) { <line38> } <line39> } <line40> } <line41> "	"<line38>      Log.error(""Failed to read help descriptionModel"", e);"	task4	
public class A { <line0> @Override <line1> public void dispose() { <line2> try { <line3> closeProducer(producer); <line4> closeSession(session); <line5> connection.close(); <line6> } catch (JMSException e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOGGER.error(""Error while closing session"", e);"	task4	
public class A { <line0> public void failedToCapture(SnapshotStateId componentId) { <line1> updateCapture(componentId, SnapshotComponentCounter.ComponentState.FAILED); <line2> } <line3> } <line4> 	"<line1>    LOG.debug(""Failed to capture snapshot %d for component %s"", componentId.getSnapshotId(), componentId);"	task4	
"public class A { <line0> private void writeProperties() { <line1> try { <line2> File file = P2Cache.getCacheFile(indexUrl); <line3> try (FileOutputStream stream = new FileOutputStream(file)) { <line4> indexProperties.store(stream, ""generated by pax exam""); <line5> file.setLastModified(0); <line6> } <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	"<line8>      LOG.trace(""writing index file to cache failed"", e);"	task4	
public class A { <line0> private void createZones() { <line1> MGRSConverter parser = new MGRSConverter(); <line2> List<LatitudeBandData> latitudeData = parser.getLatitudeBands(); <line3> final double lonSpacing = 6.; <line4> for (LatitudeBandData latData : latitudeData) { <line5> int index = 1; <line6> double lon; <line7> for (lon = -MAX_LON; lon < MAX_LON; lon += lonSpacing) { <line8> double lonAddRight = 0.; <line9> double lonAddLeft = 0.; <line10> if (latData.getLatitudeBand() == 'X' && index == 31) { <line11> lonAddRight = 3; <line12> } <line13> if (latData.getLatitudeBand() == 'X' && (index == 33 || index == 35)) { <line14> lonAddRight = 3; <line15> lonAddLeft = -3; <line16> } <line17> if (latData.getLatitudeBand() == 'X' && index == 37) { <line18> lonAddLeft = -3; <line19> } <line20> if (latData.getLatitudeBand() == 'X' && (index == 32 || index == 34 || index == 36)) { <line21> if (LOGGER.isDebugEnabled()) { <line22> } <line23> index++; <line24> continue; <line25> } <line26> if (latData.getLatitudeBand() == 'V' && index == 31) { <line27> lonAddRight = -3; <line28> } <line29> if (latData.getLatitudeBand() == 'V' && index == 32) { <line30> lonAddLeft = -3; <line31> } <line32> String zoneNumber = constructZone(index++); <line33> UTMZone zone = <line34> new UTMZone(latData, zoneNumber, lon + lonAddLeft, lon + lonSpacing + lonAddRight); <line35> myZones.put(zoneNumber + latData.getLatitudeBand(), zone); <line36> } <line37> } <line38> } <line39> } <line40> 	"<line22>            LOGGER.debug("" Continuing for "" + latData.getLatitudeBand() + index);"	task4	
"public class A { <line0> @GET <line1> @Timed <line2> @Produces(MediaType.APPLICATION_JSON) <line3> public Map<String, String> naturalDateTester(@QueryParam(""string"") @NotEmpty String string) { <line4> try { <line5> return new NaturalDateParser().parse(string).asMap(); <line6> } catch (NaturalDateParser.DateNotParsableException e) { <line7> throw new WebApplicationException(e, 422); <line8> } <line9> } <line10> } <line11> "	"<line7>      LOG.debug(""Could not parse from natural date: "" + string, e);"	task4	
"public class A { <line0> public Collection<PFUserDO> getSortedUsers(final String userIds) { <line1> if (StringUtils.isEmpty(userIds)) { <line2> return null; <line3> } <line4> TreeSet<PFUserDO> sortedUsers = new TreeSet<>(usersComparator); <line5> final int[] ids = StringHelper.splitToInts(userIds, "","", false); <line6> for (final int id : ids) { <line7> final PFUserDO user = userGroupCache.getUser(id); <line8> if (user != null) { <line9> sortedUsers.add(user); <line10> } else { <line11> } <line12> } <line13> return sortedUsers; <line14> } <line15> } <line16> "	"<line11>        log.warn(""Group with id '""+ id+ ""' not found in UserGroupCache. groupIds string was: ""+ userIds);"	task4	
public class A { <line0> @Override <line1> public void onLinkRemoteOpen(Event event) { <line2> this.linkStateCallback.onReceiverLinkRemoteOpen(); <line3> } <line4> } <line5> 	"<line2>    log.debug(""{} receiver link with link correlation id {} was successfully opened"",getLinkInstanceType(),this.linkCorrelationId);"	task4	
"public class A { <line0> public boolean setSubnetworks(final byte[] subnetworks, final int subnetworkId) { <line1> if (subnetworkId > 127) throw new IllegalStateException(""Too many subnetworks "" + subnetworkId); <line2> final AtomicBoolean failed = new AtomicBoolean(false); <line3> IntObjectMap<SPTEntry> map = fromMode ? bestWeightMapFrom : bestWeightMapTo; <line4> map.forEach( <line5> (IntObjectPredicate<SPTEntry>) <line6> (nodeId, value) -> { <line7> int sn = subnetworks[coreNodeIdMap.get(nodeId)]; <line8> if (sn != subnetworkId) { <line9> if (sn != UNSET_SUBNETWORK && sn != UNCLEAR_SUBNETWORK) { <line10> failed.set(true); <line11> return false; <line12> } <line13> subnetworks[coreNodeIdMap.get(nodeId)] = (byte) subnetworkId; <line14> } <line15> return true; <line16> }); <line17> return failed.get(); <line18> } <line19> } <line20> "	"<line10>                  LOGGER.error(""subnetworkId for node ""+ nodeId+ "" (""+ createPoint(graph, nodeId)+ "") already set (""+ sn+ ""). ""+ ""Cannot change to ""+ subnetworkId);"	task4	
public class A { <line0> @Override <line1> byte[] execute() throws KeeperException, InterruptedException { <line2> return ZooKeeperClient.super.getData(path, watch, stat); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""ZK Call - getData [{0}] [{1}] [{2}]"", path, watch, stat);"	task4	
public class A { <line0> public void stop() { <line1> if (selectorThread.isRunning()) { <line2> selectorThread.stopEndpoint(); <line3> } <line4> } <line5> } <line6> 	"<line2>      LOGGER.info(""Stopping low level grizzly container"");"	task4	
"public class A { <line0> @RequestMapping(""/resetStudy.do"") <line1> public ModelAndView resetStudy(HttpServletRequest request) { <line2> logger.entry(""resetStudy()""); <line3> ModelAndView mav = new ModelAndView(""redirect:login.do""); <line4> boolean flag = false; <line5> try { <line6> String cusId = <line7> FdahpStudyDesignerUtil.isEmpty(request.getParameter(""cusId"")) <line8> ? """" <line9> : request.getParameter(""cusId""); <line10> if (!cusId.isEmpty()) { <line11> flag = studyService.resetDraftStudyByCustomStudyId(cusId); <line12> if (flag) { <line13> request.getSession(false).setAttribute(""sucMsg"", ""Reset successfully""); <line14> } else { <line15> request.getSession(false).setAttribute(""errMsg"", ""DB issue or study does not exist""); <line16> } <line17> } <line18> } catch (Exception e) { <line19> } <line20> logger.exit(""resetStudy() - Ends""); <line21> return mav; <line22> } <line23> } <line24> "	"<line19>      logger.error(""StudyController - resetStudy - ERROR"", e);"	task4	
"public class A { <line0> private Properties readPropertyFile(String file) throws IOException { <line1> String fileName = file.startsWith(""/"") ? file : ""/"" + file; <line2> return Util.readProperties(fileName); <line3> } <line4> } <line5> "	"<line2>    LOGGER.info(""Reading properties from: "" + fileName + "". Will try classpath, then file system."");"	task4	
public class A { <line0> public RiskIncidence createRiskIncidence(RiskIncidence riskIncidence, boolean commit) <line1> throws AlreadyExistsException, NotFoundException, AuthorizationDeniedException, <line2> GenericException { <line3> RodaCoreFactory.checkIfWriteIsAllowedAndIfFalseThrowException(nodeType); <line4> try { <line5> riskIncidence.setId(IdUtils.createUUID()); <line6> riskIncidence.setDetectedOn(new Date()); <line7> String riskIncidenceAsJson = JsonUtils.getJsonFromObject(riskIncidence); <line8> StoragePath riskIncidencePath = ModelUtils.getRiskIncidenceStoragePath(riskIncidence.getId()); <line9> storage.createBinary(riskIncidencePath, new StringContentPayload(riskIncidenceAsJson), false); <line10> } catch (GenericException <line11> | RequestNotValidException <line12> | AuthorizationDeniedException <line13> | NotFoundException <line14> | AlreadyExistsException e) { <line15> } <line16> notifyRiskIncidenceCreatedOrUpdated(riskIncidence, commit).failOnError(); <line17> return riskIncidence; <line18> } <line19> } <line20> 	"<line15>      LOGGER.error(""Error creating risk incidence in storage"", e);"	task4	
"public class A { <line0> private void predictTest() throws Exception { <line1> try { <line2> String inputPath = ""../../data/census/census_148d_test.dummy""; <line3> String loadPath = LOCAL_FS + TMP_PATH + ""/model/deepFM""; <line4> String predictPath = LOCAL_FS + TMP_PATH + ""/predict""; <line5> conf.set(AngelConf.ANGEL_PREDICT_DATA_PATH, inputPath); <line6> conf.set(AngelConf.ANGEL_LOAD_MODEL_PATH, loadPath); <line7> conf.set(AngelConf.ANGEL_PREDICT_PATH, predictPath); <line8> conf.set(AngelConf.ANGEL_ACTION_TYPE, MLConf.ANGEL_ML_PREDICT()); <line9> GraphRunner runner = new GraphRunner(); <line10> runner.predict(conf); <line11> } catch (Exception x) { <line12> throw x; <line13> } <line14> } <line15> } <line16> "	"<line12>      LOG.error(""run predictTest failed "", x);"	task4	
public class A { <line0> private void reloadPage() { <line1> try { <line2> redirect(getUserPageUrl()); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.error(""Error reloading user page"", e);"	task4	
"public class A { <line0> public double solve( <line1> final double x0, final double y0, final double x1, final Function f, final double eps) { <line2> double y, e = eps / 10; <line3> if (e < EPS_MIN) { <line4> String msg = String.format(""epsilon:%.2g less than esp_min=%.2g"", eps, EPS_MIN); <line5> e = max(eps, EPS_MIN); <line6> } <line7> y = rungeKuttaFehlberg(x0, y0, x1, f, e); <line8> return y; <line9> } <line10> } <line11> "	<line5>      logger.warn(msg);	task4	
"public class A { <line0> @Override <line1> public String getUserName( <line2> long userId, <line3> String defaultUserName, <line4> String userAttribute, <line5> HttpServletRequest httpServletRequest) { <line6> String userName = defaultUserName; <line7> try { <line8> User user = UserLocalServiceUtil.getUserById(userId); <line9> if (userAttribute.equals(UserAttributes.USER_NAME_FULL)) { <line10> userName = user.getFullName(); <line11> } else { <line12> userName = user.getScreenName(); <line13> } <line14> if (httpServletRequest != null) { <line15> Layout layout = (Layout) httpServletRequest.getAttribute(WebKeys.LAYOUT); <line16> userName = <line17> StringBundler.concat( <line18> ""<a href=\"""", <line19> PortletURLBuilder.create( <line20> PortletURLFactoryUtil.create( <line21> httpServletRequest, <line22> PortletKeys.DIRECTORY, <line23> layout, <line24> PortletRequest.RENDER_PHASE)) <line25> .setParameter(""struts_action"", ""/directory/view_user"") <line26> .setParameter(""p_u_i_d"", user.getUserId()) <line27> .setPortletMode(PortletMode.VIEW) <line28> .setWindowState(WindowState.MAXIMIZED) <line29> .buildString(), <line30> ""\"">"", <line31> HtmlUtil.escape(userName), <line32> ""</a>""); <line33> } <line34> } catch (Exception exception) { <line35> if (log.isDebugEnabled()) { <line36> } <line37> } <line38> return userName; <line39> } <line40> } <line41> "	<line36>        log.debug(exception, exception);	task4	
"public class A { <line0> public String pom() { <line1> String requestUrl = this.base + ""/pom.xml""; <line2> return this.restTemplate <line3> .exchange( <line4> RequestEntity.get(URI.create(requestUrl)).accept(mediaTypes()).build(), String.class) <line5> .getBody(); <line6> } <line7> } <line8> "	"<line2>    log.info(""Will send a request to ["" + requestUrl + ""]"");"	task4	
public class A { <line0> @Override <line1> public void onPathWatchEvents(List<PathWatchEvent> events) { <line2> if (!Objects.isNull(scanner)) { <line3> try { <line4> scanner.stop(); <line5> if (!Objects.isNull(jetty.getWebApp())) { <line6> jetty.getWebApp().stop(); <line7> jetty.setWebAppProperties(loadWebAppProps()); <line8> jetty.setWebApp(jetty.getWebApp()); <line9> jetty.redeployWebApp(); <line10> scanner.start(); <line11> } <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> } <line17> 	"<line13>        LOG.warn(""Error restarting webapp"", e);"	task4	
public class A { <line0> @Override <line1> public ListenableFuture<? extends DOMRpcResult> create( <line2> final LogicalDatastoreType store, <line3> final YangInstanceIdentifier path, <line4> final NormalizedNode<?, ?> data, <line5> final Optional<ModifyAction> defaultOperation) { <line6> masterActor.tell( <line7> new CreateEditConfigRequest( <line8> store, new NormalizedNodeMessage(path, data), defaultOperation.orElse(null)), <line9> ActorRef.noSender()); <line10> return createResult(); <line11> } <line12> } <line13> 	"<line6>    LOG.debug(""{}: Create {} {} via actor {}"", id, store, path, masterActor);"	task4	
"public class A { <line0> @Override <line1> public void generateJson(String prefix, PrintWriter pw, VWorkspace vWorkspace) { <line2> JSONObject obj = new JSONObject(); <line3> JSONArray resultArray = new JSONArray(); <line4> try { <line5> obj.put(JsonKeys.updateType.name(), ""PropertyList""); <line6> for (LabeledLink link : finalProperties) { <line7> Label linkLabel = link.getLabel(); <line8> String edgeLabelStr = linkLabel.getDisplayName(); <line9> JSONObject edgeObj = new JSONObject(); <line10> if (linkLabel.getUri() != null <line11> && linkLabel.getNs() != null <line12> && linkLabel.getUri().equalsIgnoreCase(linkLabel.getNs())) { <line13> edgeLabelStr = linkLabel.getUri(); <line14> } <line15> edgeObj.put(JsonKeys.label.name(), edgeLabelStr); <line16> edgeObj.put(JsonKeys.rdfsLabel.name(), linkLabel.getRdfsLabel()); <line17> edgeObj.put(JsonKeys.uri.name(), linkLabel.getUri()); <line18> edgeObj.put(JsonKeys.id.name(), link.getId()); <line19> if (link instanceof ObjectPropertyLink) edgeObj.put(JsonKeys.type.name(), ""objectProperty""); <line20> else edgeObj.put(JsonKeys.type.name(), ""dataProperty""); <line21> resultArray.put(edgeObj); <line22> } <line23> obj.put(JsonKeys.properties.name(), resultArray); <line24> pw.println(obj.toString()); <line25> } catch (Exception e) { <line26> e.printStackTrace(); <line27> } <line28> } <line29> } <line30> "	"<line26>      logger.error(""Exception:"", e);"	task4	
public class A { <line0> @Override <line1> protected void doSync() throws IOException { <line2> this.writer.hsync(); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""Attempting to sync all data to filesystem"");"	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public void put(Object tuple) { <line3> inputPort.process((T) tuple); <line4> } <line5> } <line6> "	"<line3>    LOG.debug(""processing tuple"");"	task4	
public class A { <line0> @Override <line1> public ObjectLayoutBox remove(Serializable primaryKey) throws NoSuchLayoutBoxException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> ObjectLayoutBox objectLayoutBox = <line6> (ObjectLayoutBox) session.get(ObjectLayoutBoxImpl.class, primaryKey); <line7> if (objectLayoutBox == null) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> throw new NoSuchLayoutBoxException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(objectLayoutBox); <line13> } catch (NoSuchLayoutBoxException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	<line9>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> doMergeFragments(fragmentsToMerge); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.error(""error happens when merge fragments:"" + fragmentsToMerge, e);"	task4	
public class A { <line0> public Object getValue(Field property) { <line1> try { <line2> return property.get(this); <line3> } catch (IllegalAccessException e) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line4>      log.error("""", e);"	task4	
"public class A { <line0> @Test <line1> public void importFetched() throws Exception { <line2> Repository repository = createTestRepoUsingRepoService(); <line3> getL10nJCommander() <line4> .run( <line5> ""push"", <line6> ""-r"", <line7> repository.getName(), <line8> ""-s"", <line9> getInputResourcesTestDir(""source"").getAbsolutePath()); <line10> Asset asset = <line11> assetClient.getAssetByPathAndRepositoryId(""source-xliff.xliff"", repository.getId()); <line12> importTranslations(asset.getId(), ""source-xliff_"", ""fr-FR""); <line13> importTranslations(asset.getId(), ""source-xliff_"", ""ja-JP""); <line14> Asset asset2 = <line15> assetClient.getAssetByPathAndRepositoryId(""source2-xliff.xliff"", repository.getId()); <line16> importTranslations(asset2.getId(), ""source2-xliff_"", ""fr-FR""); <line17> importTranslations(asset2.getId(), ""source2-xliff_"", ""ja-JP""); <line18> waitForRepositoryToHaveStringsForTranslations(repository.getId()); <line19> getL10nJCommander().run(""drop-export"", ""-r"", repository.getName()); <line20> final Long dropId = getLastDropIdFromOutput(outputCapture); <line21> Console mockConsole = mock(Console.class); <line22> verify(mockConsole, never()).readLine(Long.class); <line23> L10nJCommander l10nJCommander = getL10nJCommander(); <line24> DropImportCommand dropImportCommand = l10nJCommander.getCommand(DropImportCommand.class); <line25> dropImportCommand.console = mockConsole; <line26> int numberOfFrenchTranslationsBefore = getNumberOfFrenchTranslations(repository); <line27> localizeDropFiles(dropRepository.findById(dropId).orElse(null)); <line28> l10nJCommander.run( <line29> new String[] {""drop-import"", ""-r"", repository.getName(), ""--import-fetched""}); <line30> int numberOfFrenchTranslationsAfter = getNumberOfFrenchTranslations(repository); <line31> assertEquals( <line32> ""2 new french translations must be added"", <line33> numberOfFrenchTranslationsBefore + 2, <line34> numberOfFrenchTranslationsAfter); <line35> getL10nJCommander() <line36> .run( <line37> ""tm-export"", <line38> ""-r"", <line39> repository.getName(), <line40> ""-t"", <line41> targetTestDir.getAbsolutePath(), <line42> ""--target-basename"", <line43> ""fortest""); <line44> modifyFilesInTargetTestDirectory(XliffUtils.replaceCreatedDateFunction()); <line45> checkExpectedGeneratedResources(); <line46> } <line47> } <line48> "	"<line21>    logger.debug(""Mocking the console input"");"	task4	
"public class A { <line0> public Answer execute(NetworkUsageCommand cmd) { <line1> if (cmd.isForVpc()) { <line2> return vpcNetworkUsage(cmd); <line3> } <line4> if (LOGGER.isInfoEnabled()) { <line5> } <line6> if (cmd.getOption() != null && CREATE.equals(cmd.getOption())) { <line7> String result = networkUsage(cmd.getPrivateIP(), CREATE, null); <line8> return new NetworkUsageAnswer(cmd, result, 0L, 0L); <line9> } <line10> long[] stats = getNetworkStats(cmd.getPrivateIP()); <line11> return new NetworkUsageAnswer(cmd, """", stats[0], stats[1]); <line12> } <line13> } <line14> "	"<line5>      LOGGER.info(""Executing resource NetworkUsageCommand "" + cmd);"	task4	
public class A { <line0> public String enqueueGetConfigurationRequest( <line1> @Identification final String organisationIdentification, <line2> @Identification final String deviceIdentification, <line3> final int messagePriority) <line4> throws FunctionalException { <line5> final Organisation organisation = <line6> this.domainHelperService.findOrganisation(organisationIdentification); <line7> final Device device = this.domainHelperService.findActiveDevice(deviceIdentification); <line8> this.domainHelperService.isAllowed(organisation, device, DeviceFunction.GET_CONFIGURATION); <line9> this.domainHelperService.isInMaintenance(device); <line10> final String correlationUid = <line11> this.correlationIdProviderService.getCorrelationId( <line12> organisationIdentification, deviceIdentification); <line13> final DeviceMessageMetadata deviceMessageMetadata = <line14> new DeviceMessageMetadata( <line15> deviceIdentification, <line16> organisationIdentification, <line17> correlationUid, <line18> MessageType.GET_CONFIGURATION.name(), <line19> messagePriority); <line20> final CommonRequestMessage message = <line21> new CommonRequestMessage.Builder().deviceMessageMetadata(deviceMessageMetadata).build(); <line22> this.commonRequestMessageSender.send(message); <line23> return correlationUid; <line24> } <line25> } <line26> 	"<line10>    LOGGER.debug(""enqueueGetConfigurationRequest called with organisation {} and device {}"",organisationIdentification,deviceIdentification);"	task4	
"public class A { <line0> public static com.liferay.journal.model.JournalArticle addArticleDefaultValues( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> long classNameId, <line4> long classPK, <line5> java.util.Map<java.util.Locale, String> titleMap, <line6> java.util.Map<java.util.Locale, String> descriptionMap, <line7> String content, <line8> String ddmStructureKey, <line9> String ddmTemplateKey, <line10> String layoutUuid, <line11> boolean indexable, <line12> boolean smallImage, <line13> String smallImageURL, <line14> java.io.File smallImageFile, <line15> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line16> throws com.liferay.portal.kernel.exception.PortalException { <line17> try { <line18> MethodKey methodKey = <line19> new MethodKey( <line20> JournalArticleServiceUtil.class, <line21> ""addArticleDefaultValues"", <line22> _addArticleDefaultValuesParameterTypes4); <line23> MethodHandler methodHandler = <line24> new MethodHandler( <line25> methodKey, <line26> groupId, <line27> classNameId, <line28> classPK, <line29> titleMap, <line30> descriptionMap, <line31> content, <line32> ddmStructureKey, <line33> ddmTemplateKey, <line34> layoutUuid, <line35> indexable, <line36> smallImage, <line37> smallImageURL, <line38> smallImageFile, <line39> serviceContext); <line40> Object returnObj = null; <line41> try { <line42> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line43> } catch (Exception exception) { <line44> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line45> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line46> } <line47> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line48> } <line49> return (com.liferay.journal.model.JournalArticle) returnObj; <line50> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line51> throw systemException; <line52> } <line53> } <line54> } <line55> "	<line51>      log.error(systemException, systemException);	task4	
public class A { <line0> private void doStart(boolean sync) { <line1> accept(); <line2> if (sync) { <line3> ThreadUtil.sync(this); <line4> } <line5> } <line6> } <line7> 	"<line1>    log.debug(""Aio Server started, waiting for accept."");"	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public List<ProjectSampleAnalysisOutputInfo> getAllAnalysisOutputInfoSharedWithProject( <line3> Long projectId, Set<UUID> workflowIds) { <line4> final String query = <line5> ""SELECT\n"" <line6> + ""  s.id AS sampleId,\n"" <line7> + ""  s.sampleName AS sampleName,\n"" <line8> + ""  a.id AS analysisId,\n"" <line9> + ""  aofmap.analysis_output_file_key AS analysisOutputFileKey,\n"" <line10> + ""  aof.file_path AS filePath,\n"" <line11> + ""  aof.id AS analysisOutputFileId,\n"" <line12> + ""  a.analysis_type AS analysisType,\n"" <line13> + ""  asub.workflow_id AS workflowId,\n"" <line14> + ""  aof.created_date AS createdDate,\n"" <line15> + ""  asub.name AS analysisSubmissionName,\n"" <line16> + ""  asub.id AS analysisSubmissionId,\n"" <line17> + ""  u.id AS userId,\n"" <line18> + ""  u.firstName AS userFirstName,\n"" <line19> + ""  u.lastName AS userLastName\n"" <line20> + ""FROM analysis_output_file aof\n"" <line21> + ""  INNER JOIN analysis_output_file_map aofmap ON aof.id ="" <line22> + "" aofmap.analysisOutputFilesMap_id\n"" <line23> + ""  INNER JOIN analysis a ON aofmap.analysis_id = a.id\n"" <line24> + ""  INNER JOIN analysis_submission asub ON a.id = asub.analysis_id\n"" <line25> + ""  INNER JOIN analysis_submission_sequencing_object o ON asub.id ="" <line26> + "" o.analysis_submission_id\n"" <line27> + ""  INNER JOIN sample_sequencingobject sso ON sso.sequencingobject_id ="" <line28> + "" o.sequencing_object_id\n"" <line29> + ""  INNER JOIN sample s ON sso.sample_id = s.id\n"" <line30> + ""  INNER JOIN project_sample psample ON s.id = psample.sample_id\n"" <line31> + ""  INNER JOIN user u ON asub.submitter = u.id\n"" <line32> + ""  INNER JOIN project_analysis_submission pasub ON asub.id ="" <line33> + "" pasub.analysis_submission_id\n"" <line34> + ""WHERE\n"" <line35> + ""  psample.project_id = :projectId\n"" <line36> + ""  AND asub.workflow_id IN (:workflowIds)\n""; <line37> MapSqlParameterSource parameters = new MapSqlParameterSource(); <line38> final List<String> workflowUUIDStrings = <line39> workflowIds.stream().map(UUID::toString).collect(Collectors.toList()); <line40> parameters.addValue(""projectId"", projectId); <line41> parameters.addValue(""workflowIds"", workflowUUIDStrings); <line42> NamedParameterJdbcTemplate tmpl = new NamedParameterJdbcTemplate(dataSource); <line43> return tmpl.query( <line44> query, parameters, new BeanPropertyRowMapper(ProjectSampleAnalysisOutputInfo.class)); <line45> } <line46> } <line47> "	"<line42>    logger.trace(""Getting all shared analysis output file info for project id="" + projectId);"	task4	
public class A { <line0> private void getExtraUnmanagedStorageVolumes() { <line1> ResourceCollection<ExtraStorageVolume> extraStorageVolumes = <line2> this.storageVolumeAttachmentClient.getExtraUnmanagedStorageVolumes(); <line3> } <line4> } <line5> 	"<line3>    LOGGER.info(""Extra unmanaged storage volume attachments returned to client: {}"",JsonPrettyPrinter.print(extraStorageVolumes));"	task4	
"public class A { <line0> public AssetDto editAsset( <line1> String resourceId, <line2> MultipartFile file, <line3> String description, <line4> List<String> categories, <line5> String folderPath) { <line6> try { <line7> ResourceInterface resource = loadResource(resourceId); <line8> BaseResourceDataBean resourceFile = new BaseResourceDataBean(); <line9> resourceFile.setResourceType(resource.getType()); <line10> resourceFile.setResourceId(resourceId); <line11> resourceFile.setMetadata(resource.getMetadata()); <line12> resourceFile.setOwner(resource.getOwner()); <line13> resourceFile.setFolderPath(resource.getFolderPath()); <line14> if (file != null) { <line15> validateMimeType(unconvertResourceType(resource.getType()), file.getContentType()); <line16> resourceFile.setInputStream(file.getInputStream()); <line17> resourceFile.setFileSize(file.getBytes().length / 1000); <line18> resourceFile.setFileName(file.getOriginalFilename()); <line19> resourceFile.setMimeType(file.getContentType()); <line20> resourceFile.setDescr(file.getOriginalFilename()); <line21> if ((description == null || description.trim().length() == 0) <line22> && resource.getDescription().equals(resource.getMasterFileName())) { <line23> description = resourceFile.getFileName(); <line24> } <line25> } <line26> if (description != null && !description.trim().isEmpty()) { <line27> resourceFile.setDescr(description.trim()); <line28> } else { <line29> resourceFile.setDescr(resource.getDescription()); <line30> } <line31> if (folderPath != null) { <line32> resourceFile.setFolderPath(folderPath); <line33> } <line34> resourceFile.setMainGroup(resource.getMainGroup()); <line35> resourceFile.setCategories(convertCategories(categories)); <line36> resourceManager.updateResource(resourceFile); <line37> return convertResourceToDto(resourceManager.loadResource(resourceId)); <line38> } catch (ApsSystemException e) { <line39> throw new RestServerError(""plugins.jacms.resources.resourceManager.error.persistence"", e); <line40> } catch (IOException e) { <line41> throw new RestServerError(""plugins.jacms.resources.image.errorReadingStream"", e); <line42> } <line43> } <line44> } <line45> "	"<line41>      log.error(""Error reading file input stream"", e);"	task4	
public class A { <line0> @Override <line1> public MutableAcl updateAcl(MutableAcl mutableAcl) throws NotFoundException { <line2> try (AutoLock l = lock.lockForWrite()) { <line3> AclRecord record = ((MutableAclRecord) mutableAcl).getAclRecord(); <line4> crud.save(record); <line5> } catch (IOException e) { <line6> throw new InternalErrorException(e); <line7> } <line8> return mutableAcl; <line9> } <line10> } <line11> 	"<line5>      logger.debug(""ACL of "" + mutableAcl.getObjectIdentity() + "" updated successfully."");"	task4	
"public class A { <line0> private void syncSnapshotToRegionStore(long snapshotId, DataStore store) { <line1> SnapshotInfo snapOnStore = _snapshotFactory.getSnapshot(snapshotId, store); <line2> if (snapOnStore == null) { <line3> throw new CloudRuntimeException( <line4> ""Cannot find an entry in snapshot_store_ref for snapshot "" <line5> + snapshotId <line6> + "" on region store: "" <line7> + store.getName()); <line8> } <line9> if (snapOnStore.getPath() == null || snapOnStore.getPath().length() == 0) { <line10> if (logger.isDebugEnabled()) { <line11> } <line12> SnapshotInfo srcSnapshot = _snapshotFactory.getReadySnapshotOnCache(snapshotId); <line13> if (srcSnapshot == null) { <line14> throw new CloudRuntimeException(""Cannot find snapshot "" + snapshotId + ""  on cache store""); <line15> } <line16> AsyncCallFuture<SnapshotResult> future = syncToRegionStoreAsync(srcSnapshot, store); <line17> try { <line18> SnapshotResult result = future.get(); <line19> if (result.isFailed()) { <line20> throw new CloudRuntimeException( <line21> ""sync snapshot from cache to region wide store failed for image store "" <line22> + store.getName() <line23> + "":"" <line24> + result.getResult()); <line25> } <line26> _cacheMgr.releaseCacheObject(srcSnapshot); <line27> } catch (Exception ex) { <line28> throw new CloudRuntimeException( <line29> ""sync snapshot from cache to region wide store failed for image store "" <line30> + store.getName()); <line31> } <line32> } <line33> } <line34> } <line35> "	"<line11>        logger.debug(""sync snapshot "" + snapshotId + "" from cache to object store..."");"	task4	
public class A { <line0> @Secured(ServicesData.ROLE_CREATE_CONTEXTS) <line1> @ResponseStatus(HttpStatus.CREATED) <line2> @PostMapping <line3> public ContextDto create(final @Valid @RequestBody ContextDto contextDto) { <line4> return contextExternalService.create(contextDto); <line5> } <line6> } <line7> 	"<line4>    LOGGER.debug(""Create {}"", contextDto);"	task4	
"public class A { <line0> public static void waitForTaskCountToBecome( <line1> final ManagementContext mgmt, final int allowedMax, final boolean skipKnownBackgroundTasks) { <line2> Repeater.create() <line3> .every(Duration.millis(20)) <line4> .limitTimeTo(Duration.TEN_SECONDS) <line5> .until( <line6> new Callable<Boolean>() { <line7> @Override <line8> public Boolean call() throws Exception { <line9> ((LocalManagementContext) mgmt).getGarbageCollector().gcIteration(); <line10> long taskCountAfterAtOld = <line11> ((BasicExecutionManager) mgmt.getExecutionManager()).getNumIncompleteTasks(); <line12> List<Task<?>> tasks = <line13> ((BasicExecutionManager) mgmt.getExecutionManager()).getAllTasks(); <line14> int unendedTasks = 0, extraAllowedMax = 0; <line15> for (Task<?> t : tasks) { <line16> if (!t.isDone()) { <line17> if (skipKnownBackgroundTasks) { <line18> if (t.toString().indexOf(""ssh-location cache cleaner"") >= 0) { <line19> extraAllowedMax++; <line20> } <line21> } <line22> unendedTasks++; <line23> } <line24> } <line25> return taskCountAfterAtOld <= allowedMax + extraAllowedMax; <line26> } <line27> }) <line28> .runRequiringTrue(); <line29> } <line30> } <line31> "	"<line25>                LOG.info(""Count of incomplete tasks now ""+ taskCountAfterAtOld+ "", ""+ unendedTasks+ "" unended""+ (extraAllowedMax > 0 ? "" ("" + extraAllowedMax + "" allowed)"" : """")+ ""; tasks remembered are: ""+ tasks);"	task4	
public class A { <line0> private void commitCheckpointMark(KafkaCheckpointMark checkpointMark) { <line1> consumer.commitSync( <line2> checkpointMark.getPartitions().stream() <line3> .filter(p -> p.getNextOffset() != UNINITIALIZED_OFFSET) <line4> .collect( <line5> Collectors.toMap( <line6> p -> new TopicPartition(p.getTopic(), p.getPartition()), <line7> p -> new OffsetAndMetadata(p.getNextOffset())))); <line8> } <line9> } <line10> 	"<line1>    LOG.debug(""{}: Committing finalized checkpoint {}"", this, checkpointMark);"	task4	
public class A { <line0> @Override <line1> public void collect(JVMMetricCollection request, StreamObserver<Commands> responseObserver) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> final JVMMetricCollection.Builder builder = request.toBuilder(); <line5> builder.setService(namingControl.formatServiceName(builder.getService())); <line6> builder.setServiceInstance(namingControl.formatInstanceName(builder.getServiceInstance())); <line7> builder <line8> .getMetricsList() <line9> .forEach( <line10> jvmMetric -> { <line11> jvmSourceDispatcher.sendMetric( <line12> builder.getService(), builder.getServiceInstance(), jvmMetric); <line13> }); <line14> responseObserver.onNext(Commands.newBuilder().build()); <line15> responseObserver.onCompleted(); <line16> } <line17> } <line18> 	"<line3>      log.debug(""receive the jvm metrics from service instance, name: {}, instance: {}"",request.getService(),request.getServiceInstance());"	task4	
public class A { <line0> public void registerTask(Long taskId, String stateMachineId, long redriveDelay) { <line1> try { <line2> LoggingUtils.registerStateMachineIdForLogging(stateMachineId.toString()); <line3> redriverMessageService.saveMessage( <line4> new ScheduledMessage(taskId, stateMachineId, System.currentTimeMillis() + redriveDelay)); <line5> } finally { <line6> LoggingUtils.deRegisterStateMachineIdForLogging(); <line7> } <line8> } <line9> } <line10> 	"<line3>      logger.info(""Register task : {} for redriver with time : {}"", taskId, redriveDelay);"	task4	
"public class A { <line0> @Override <line1> public void applyInTx() { <line2> Vertex meshRoot = MeshGraphHelper.getMeshRootVertex(getGraph()); <line3> Vertex projectRoot = meshRoot.getVertices(Direction.OUT, ""HAS_PROJECT_ROOT"").iterator().next(); <line4> Vertex admin = findAdmin(); <line5> for (Vertex project : projectRoot.getVertices(Direction.OUT, ""HAS_PROJECT"")) { <line6> Vertex releaseRoot = getGraph().addVertex(""class:ReleaseRootImpl""); <line7> releaseRoot.setProperty(""ferma_type"", ""ReleaseRootImpl""); <line8> releaseRoot.setProperty(""uuid"", randomUUID()); <line9> project.addEdge(""HAS_RELEASE_ROOT"", releaseRoot); <line10> String branchUuid = randomUUID(); <line11> Vertex release = getGraph().addVertex(""class:ReleaseImpl""); <line12> release.setProperty(""ferma_type"", ""ReleaseImpl""); <line13> release.setProperty(""uuid"", branchUuid); <line14> release.setProperty(""name"", project.getProperty(""name"")); <line15> release.setProperty(""active"", true); <line16> releaseRoot.addEdge(""HAS_LATEST_RELEASE"", release); <line17> releaseRoot.addEdge(""HAS_INITIAL_RELEASE"", release); <line18> releaseRoot.addEdge(""HAS_RELEASE"", release); <line19> Vertex schemaRoot = project.getVertices(Direction.OUT, ""HAS_ROOT_SCHEMA"").iterator().next(); <line20> for (Vertex schemaContainer : <line21> schemaRoot.getVertices(Direction.OUT, ""HAS_SCHEMA_CONTAINER_ITEM"")) { <line22> Vertex latestSchemaVersion = <line23> schemaContainer.getVertices(Direction.OUT, ""HAS_LATEST_VERSION"").iterator().next(); <line24> release.addEdge(""HAS_SCHEMA_VERSION"", latestSchemaVersion); <line25> } <line26> getOrFixUserReference(project, ""HAS_EDITOR""); <line27> getOrFixUserReference(project, ""HAS_CREATOR""); <line28> Vertex baseNode = project.getVertices(Direction.OUT, ""HAS_ROOT_NODE"").iterator().next(); <line29> migrateBaseNode(baseNode, admin); <line30> migrateNode(baseNode, branchUuid); <line31> } <line32> migrateTags(meshRoot); <line33> migrateUsers(meshRoot); <line34> for (Vertex vertex : getGraph().getVertices()) { <line35> migrateType(vertex); <line36> } <line37> for (Edge edge : getGraph().getEdges()) { <line38> migrateType(edge); <line39> } <line40> for (Edge edge : getGraph().getEdges(""ferma_type"", ""TranslatedImpl"")) { <line41> edge.setProperty(""ferma_type"", ""GraphFieldContainerEdgeImpl""); <line42> } <line43> } <line44> } <line45> "	"<line24>        log.info(""Assigning schema version {""+ latestSchemaVersion.getId()+ "" / ""+ latestSchemaVersion.getProperty(""uuid"")+ ""} to release"");"	task4	
public class A { <line0> void logTextUnitSearcherError(TextUnitSearcherError textUnitSearcherError) <line1> throws TextUnitSearcherError { <line2> } <line3> } <line4> 	"<line2>    logger.error(""TextUnitSearcher couldn't recover for \""call\"": {}\n{}"",textUnitSearcherError.getMessage(),textUnitSearcherError.nativeCriteria.getQueryInfo().toString());"	task4	
public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final GroupTO ignore) { <line2> try { <line3> GroupRestClient.provisionMembers(model.getObject().getKey(), ProvisionAction.DEPROVISION); <line4> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line5> target.add(container); <line6> } catch (SyncopeClientException e) { <line7> SyncopeConsoleSession.get().onException(e); <line8> } <line9> ((BasePage) pageRef.getPage()).getNotificationPanel().refresh(target); <line10> } <line11> } <line12> 	"<line7>      LOG.error(""While provisioning members of group {}"", model.getObject().getKey(), e);"	task4	
"public class A { <line0> @DisplayName(""Test Serialization Comp Graph"") <line1> @ParameterizedTest <line2> @MethodSource(""org.deeplearning4j.nn.layers.recurrent.BidirectionalTest#params"") <line3> void testSerializationCompGraph(RNNFormat rnnDataFormat, Nd4jBackend backend) throws Exception { <line4> for (WorkspaceMode wsm : WorkspaceMode.values()) { <line5> Nd4j.getRandom().setSeed(12345); <line6> ComputationGraphConfiguration conf1 = <line7> new NeuralNetConfiguration.Builder() <line8> .activation(Activation.TANH) <line9> .weightInit(WeightInit.XAVIER) <line10> .trainingWorkspaceMode(wsm) <line11> .inferenceWorkspaceMode(wsm) <line12> .updater(new Adam()) <line13> .graphBuilder() <line14> .addInputs(""in"") <line15> .layer( <line16> ""0"", <line17> new Bidirectional( <line18> Bidirectional.Mode.ADD, <line19> new GravesLSTM.Builder().nIn(10).nOut(10).dataFormat(rnnDataFormat).build()), <line20> ""in"") <line21> .layer( <line22> ""1"", <line23> new Bidirectional( <line24> Bidirectional.Mode.ADD, <line25> new GravesLSTM.Builder().nIn(10).nOut(10).dataFormat(rnnDataFormat).build()), <line26> ""0"") <line27> .layer( <line28> ""2"", <line29> new RnnOutputLayer.Builder() <line30> .lossFunction(LossFunctions.LossFunction.MSE) <line31> .dataFormat(rnnDataFormat) <line32> .nIn(10) <line33> .nOut(10) <line34> .build(), <line35> ""1"") <line36> .setOutputs(""2"") <line37> .build(); <line38> ComputationGraph net1 = new ComputationGraph(conf1); <line39> net1.init(); <line40> long[] inshape = (rnnDataFormat == NCW) ? new long[] {3, 10, 5} : new long[] {3, 5, 10}; <line41> INDArray in = Nd4j.rand(inshape); <line42> INDArray labels = Nd4j.rand(inshape); <line43> net1.fit(new DataSet(in, labels)); <line44> byte[] bytes; <line45> try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) { <line46> ModelSerializer.writeModel(net1, baos, true); <line47> bytes = baos.toByteArray(); <line48> } <line49> ComputationGraph net2 = <line50> ModelSerializer.restoreComputationGraph(new ByteArrayInputStream(bytes), true); <line51> in = Nd4j.rand(inshape); <line52> labels = Nd4j.rand(inshape); <line53> INDArray out1 = net1.outputSingle(in); <line54> INDArray out2 = net2.outputSingle(in); <line55> assertEquals(out1, out2); <line56> net1.setInput(0, in); <line57> net2.setInput(0, in); <line58> net1.setLabels(labels); <line59> net2.setLabels(labels); <line60> net1.computeGradientAndScore(); <line61> net2.computeGradientAndScore(); <line62> assertEquals(net1.score(), net2.score(), 1e-6); <line63> assertEquals(net1.gradient().gradient(), net2.gradient().gradient()); <line64> } <line65> } <line66> } <line67> "	"<line5>      log.info(""*** Starting workspace mode: "" + wsm);"	task4	
"public class A { <line0> private String getVersion( <line1> String namespace, CuratorRepository.CuratorFrameworkOp curatorFrameworkOp) { <line2> try { <line3> List<String> versionList = new ArrayList<>(); <line4> String executorsPath = ""/"" + namespace + ExecutorNodePath.getExecutorNodePath(); <line5> if (!curatorFrameworkOp.checkExists(executorsPath)) { <line6> return getVersionStrFromList(versionList); <line7> } <line8> List<String> executors = curatorFrameworkOp.getChildren(executorsPath); <line9> if (executors == null || executors.isEmpty()) { <line10> return getVersionStrFromList(versionList); <line11> } <line12> for (String exe : executors) { <line13> String versionPath = executorsPath + ""/"" + exe + ""/version""; <line14> if (!curatorFrameworkOp.checkExists(versionPath)) { <line15> continue; <line16> } <line17> String version = curatorFrameworkOp.getData(versionPath); <line18> if (StringUtils.isBlank(version)) { <line19> continue; <line20> } <line21> String tmp = version.trim(); <line22> if (!versionList.contains(tmp)) { <line23> versionList.add(tmp); <line24> } <line25> } <line26> return getVersionStrFromList(versionList); <line27> } catch (Exception e) { <line28> return """"; <line29> } <line30> } <line31> } <line32> "	<line28>      log.error(e.getMessage(), e);	task4	
public class A { <line0> private Cipher getCipherForDecryption() <line1> throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException { <line2> final PrivateKey privateKey = this.keyPair.getPrivate(); <line3> if (privateKey == null) { <line4> throw new EncrypterException(PRIVATE_KEY_MUST_BE_CONFIGURED_FOR_DECRYPTION); <line5> } <line6> final Cipher cipher = Cipher.getInstance(TRANSFORMATION); <line7> cipher.init(Cipher.DECRYPT_MODE, privateKey); <line8> return cipher; <line9> } <line10> } <line11> 	<line4>      LOGGER.error(PRIVATE_KEY_MUST_BE_CONFIGURED_FOR_DECRYPTION);	task4	
public class A { <line0> public void onSessionInit(@Observes @Initialized(SessionScoped.class) Object payload) { <line1> } <line2> } <line3> 	"<line1>    log.info(""SessionContext got started. Init Object: "" + payload.toString());"	task4	
public class A { <line0> public static void deleteCommerceAccountGroupRels(String className, long classPK) <line1> throws RemoteException { <line2> try { <line3> CommerceAccountGroupRelServiceUtil.deleteCommerceAccountGroupRels(className, classPK); <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>      log.error(exception, exception);	task4	
"public class A { <line0> @ParallelNamespaceTest <line1> @Tag(INTERNAL_CLIENTS_USED) <line2> void testSendMessagesPlainAnonymous(ExtensionContext extensionContext) { <line3> final String namespaceName = <line4> extensionContext <line5> .getStore(ExtensionContext.Namespace.GLOBAL) <line6> .get(Constants.NAMESPACE_KEY) <line7> .toString(); <line8> final String clusterName = mapWithClusterNames.get(extensionContext.getDisplayName()); <line9> final String topicName = mapWithTestTopics.get(extensionContext.getDisplayName()); <line10> final String clientsName = mapWithKafkaClientNames.get(extensionContext.getDisplayName()); <line11> resourceManager.createResource( <line12> extensionContext, KafkaTemplates.kafkaEphemeral(clusterName, 3).build()); <line13> resourceManager.createResource( <line14> extensionContext, KafkaTopicTemplates.topic(clusterName, topicName).build()); <line15> resourceManager.createResource( <line16> extensionContext, <line17> KafkaClientsTemplates.kafkaClients(false, clusterName + ""-"" + Constants.KAFKA_CLIENTS) <line18> .build()); <line19> final String defaultKafkaClientsPodName = <line20> kubeClient(namespaceName) <line21> .listPodsByPrefixInName(namespaceName, clusterName + ""-"" + Constants.KAFKA_CLIENTS) <line22> .get(0) <line23> .getMetadata() <line24> .getName(); <line25> InternalKafkaClient internalKafkaClient = <line26> new InternalKafkaClient.Builder() <line27> .withUsingPodName(defaultKafkaClientsPodName) <line28> .withTopicName(topicName) <line29> .withNamespaceName(namespaceName) <line30> .withClusterName(clusterName) <line31> .withMessageCount(MESSAGE_COUNT) <line32> .withListenerName(Constants.PLAIN_LISTENER_DEFAULT_NAME) <line33> .build(); <line34> internalKafkaClient.checkProducedAndConsumedMessages( <line35> internalKafkaClient.sendMessagesPlain(), internalKafkaClient.receiveMessagesPlain()); <line36> Service kafkaService = <line37> kubeClient(namespaceName) <line38> .getService(namespaceName, KafkaResources.bootstrapServiceName(clusterName)); <line39> String kafkaServiceDiscoveryAnnotation = <line40> kafkaService.getMetadata().getAnnotations().get(""strimzi.io/discovery""); <line41> JsonArray serviceDiscoveryArray = new JsonArray(kafkaServiceDiscoveryAnnotation); <line42> assertThat( <line43> StUtils.expectedServiceDiscoveryInfo(""none"", ""none"", false, true), <line44> is(serviceDiscoveryArray)); <line45> } <line46> } <line47> "	"<line34>    LOGGER.info(""Checking produced and consumed messages to pod:{}"", defaultKafkaClientsPodName);"	task4	
"public class A { <line0> public void attachSpeechRecognizer(SpeechRecognizer recognizer) { <line1> if (recognizer == null) { <line2> return; <line3> } <line4> addListener(""publishStartSpeaking"", recognizer.getName(), ""onStartSpeaking""); <line5> addListener(""publishEndSpeaking"", recognizer.getName(), ""onEndSpeaking""); <line6> } <line7> } <line8> "	"<line2>      log.warn(""{}.attachSpeechRecognizer(null)"", getName());"	task4	
public class A { <line0> public void refreshCurrentMasterHealthStatus() { <line1> long currentTime = System.currentTimeMillis(); <line2> Set<String> toDeleteTargetDcIds = new HashSet<>(); <line3> Set<String> unhealthyTargetDcIds = new HashSet<>(); <line4> for (String targetDcId : remoteMasterLastHealthDelayTimes.keySet()) { <line5> if (!isDcClusterShardExist(targetDcId, clusterId, shardId)) { <line6> toDeleteTargetDcIds.add(targetDcId); <line7> continue; <line8> } <line9> Long lastHealthDelay = remoteMasterLastHealthDelayTimes.get(targetDcId); <line10> if (null != lastHealthDelay <line11> && currentTime - lastHealthDelay <line12> > remoteMasterInstances <line13> .get(targetDcId) <line14> .getHealthCheckConfig() <line15> .delayDownAfterMilli()) { <line16> unhealthyTargetDcIds.add(targetDcId); <line17> } <line18> } <line19> toDeleteTargetDcIds.forEach(remoteMasterLastHealthDelayTimes::remove); <line20> toDeleteTargetDcIds.forEach(remoteMasterInstances::remove); <line21> updateCurrentMasterHealthStatus(clusterId, shardId, unhealthyTargetDcIds); <line22> } <line23> } <line24> 	"<line19>    logger.debug(""[refreshCurrentMasterHealthStatus] cluster {}, shard {} remove not exist targetDcId {}"",clusterId,shardId,toDeleteTargetDcIds);"	task4	
public class A { <line0> private static void checkOrcVersion(OrcDataSource orcDataSource, List<Integer> version) { <line1> if (version.size() >= 1) { <line2> int major = version.get(0); <line3> int minor = 0; <line4> if (version.size() > 1) { <line5> minor = version.get(1); <line6> } <line7> if (major > CURRENT_MAJOR_VERSION <line8> || (major == CURRENT_MAJOR_VERSION && minor > CURRENT_MINOR_VERSION)) { <line9> } <line10> } <line11> } <line12> } <line13> 	"<line9>        log.warn(""ORC file %s was written by a newer Hive version %s. This file may not be readable by""+ "" this version of Hive (%s.%s)."",orcDataSource,Joiner.on('.').join(version),CURRENT_MAJOR_VERSION,CURRENT_MINOR_VERSION);"	task4	
"public class A { <line0> @Override <line1> public boolean checkForDatabase(String connectionUrl) { <line2> boolean exist = false; <line3> JdbcUrl jdbcUrl = prepareConnectionUri(connectionUrl); <line4> String dbName = jdbcUrl.getDbName(); <line5> String serverUrl = jdbcUrl.getUrlForDbServer(); <line6> loadSQLDriverClass(); <line7> try (Connection conn = buildConnection(serverUrl); <line8> Statement stmt = conn.createStatement()) { <line9> StringBuilder sb = new StringBuilder(); <line10> if (MYSQL_DRIVER_CLASSNAME.equalsIgnoreCase(getChosenSQLDriver())) { <line11> sb = <line12> sb.append(""SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '"") <line13> .append(dbName) <line14> .append(""'""); <line15> } else { <line16> sb = <line17> sb.append(""SELECT datname FROM pg_catalog.pg_database WHERE datname = '"") <line18> .append(dbName) <line19> .append(""'""); <line20> } <line21> ResultSet rs = stmt.executeQuery(sb.toString()); <line22> while (rs.next()) { <line23> exist = true; <line24> } <line25> } catch (SQLException e) { <line26> } <line27> return exist; <line28> } <line29> } <line30> "	"<line26>      LOGGER.error(""Error while checking for database"", e);"	task4	
"public class A { <line0> @Test <line1> public void testEmptyStructuredConfig() throws Exception { <line2> Entity app = <line3> createAndStartApplication( <line4> loadYaml( <line5> ""test-entity-basic-template.yaml"", <line6> ""  brooklyn.config:"", <line7> ""    test.confName: \""\"""", <line8> ""    test.confListThing: !!seq []"", <line9> ""    test.confSetThing: !!set {}"", <line10> ""    test.confMapThing: !!map {}"")); <line11> waitForApplicationTasks(app); <line12> Assert.assertEquals(app.getDisplayName(), ""test-entity-basic-template""); <line13> Dumper.dumpInfo(app); <line14> Entity entity = app.getChildren().iterator().next(); <line15> Assert.assertNotNull(entity, ""Expected app to have child entity""); <line16> Assert.assertTrue( <line17> entity instanceof TestEntity, ""Expected TestEntity, found "" + entity.getClass()); <line18> TestEntity testEntity = (TestEntity) entity; <line19> List<String> thingList = (List<String>) testEntity.getConfig(TestEntity.CONF_LIST_THING); <line20> Set<String> thingSet = (Set<String>) testEntity.getConfig(TestEntity.CONF_SET_THING); <line21> Map<String, String> thingMap = testEntity.getConfig(TestEntity.CONF_MAP_THING); <line22> Assert.assertEquals(thingList, Lists.newArrayList()); <line23> Assert.assertEquals(thingSet, ImmutableSet.of()); <line24> Assert.assertEquals(thingMap, ImmutableMap.of()); <line25> } <line26> } <line27> "	"<line13>    log.info(""App started:"");"	task4	
"public class A { <line0> protected void handleError( <line1> final Exception e, <line2> final String correlationUid, <line3> final String organisationIdentification, <line4> final String deviceIdentification, <line5> final String messageType, <line6> final int messagePriority) { <line7> OsgpException osgpException = null; <line8> if (e instanceof OsgpException) { <line9> osgpException = (OsgpException) e; <line10> } else { <line11> osgpException = <line12> new TechnicalException( <line13> this.componentType, <line14> String.format(""An unknown error of type %s occurred."", e.getClass().getName()), <line15> e); <line16> } <line17> final ResponseMessage responseMessage = <line18> ResponseMessage.newResponseMessageBuilder() <line19> .withCorrelationUid(correlationUid) <line20> .withOrganisationIdentification(organisationIdentification) <line21> .withDeviceIdentification(deviceIdentification) <line22> .withResult(ResponseMessageResultType.NOT_OK) <line23> .withOsgpException(osgpException) <line24> .withMessagePriority(messagePriority) <line25> .build(); <line26> this.responseMessageSender.send(responseMessage, messageType); <line27> } <line28> } <line29> "	"<line7>    LOGGER.error(""handling error: {} for message type: {}"", e.getMessage(), messageType, e);"	task4	
"public class A { <line0> @JsxFunction <line1> public void setRequestHeader(final String name, final String value) { <line2> if (!isAuthorizedHeader(name)) { <line3> if (LOG.isWarnEnabled()) { <line4> } <line5> return; <line6> } <line7> if (webRequest_ != null) { <line8> webRequest_.setAdditionalHeader(name, value); <line9> } else { <line10> throw Context.reportRuntimeError( <line11> ""The open() method must be called before setRequestHeader().""); <line12> } <line13> } <line14> } <line15> "	"<line4>        LOG.warn(""Ignoring XMLHttpRequest.setRequestHeader for "" + name + "": it is a restricted header"");"	task4	
public class A { <line0> Point createPointFromWkt(String wkt) { <line1> try { <line2> JtsSpatialContextFactory contextFactory = new JtsSpatialContextFactory(); <line3> contextFactory.allowMultiOverlap = true; <line4> SpatialContext spatialContext = contextFactory.newSpatialContext(); <line5> Shape shape = (Shape) spatialContext.readShapeFromWkt(wkt); <line6> Point center = shape.getCenter(); <line7> return center; <line8> } catch (java.text.ParseException parseException) { <line9> } <line10> return null; <line11> } <line12> } <line13> 	<line9>      LOGGER.debug(parseException.getMessage(), parseException);	task4	
public class A { <line0> public synchronized Iterator<ScheduledMeasurement> getMeasurementList() throws IOException { <line1> Collection<String> records = new ArrayList<String>(); <line2> try { <line3> readRecordsFromStorage(records); <line4> } catch (Exception e) { <line5> store.convertListToCurrentRecordSize(MeasurementSchedule.PROP_MSCHED); <line6> readRecordsFromStorage(records); <line7> } <line8> return createMeasurementList(records); <line9> } <line10> } <line11> 	"<line5>      log.warn(""Error reading measurement list from storage = '""+ e+ ""' ,""+ "" trying to convert the list records size"");"	task4	
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> User user = twitter.showUserListMembership(listId, userId); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.checkedUserListMembership(user); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.warn(""Exception at showUserListMembership"", e);"	task4	
"public class A { <line0> public LensResultSet execute(QueryContext ctx) throws LensException { <line1> OperationHandle op = null; <line2> LensResultSet result = null; <line3> try { <line4> addPersistentPath(ctx); <line5> Configuration qdconf = ctx.getDriverConf(this); <line6> qdconf.set(""mapred.job.name"", ctx.getQueryHandle().toString()); <line7> SessionHandle sessionHandle = getSession(ctx); <line8> op = <line9> getClient() <line10> .executeStatement( <line11> sessionHandle, ctx.getSelectedDriverQuery(), qdconf.getValByRegex("".*"")); <line12> ctx.setDriverOpHandle(op.toString()); <line13> hiveHandles.put(ctx.getQueryHandle(), op); <line14> opHandleToSession.put(op, sessionHandle); <line15> updateStatus(ctx); <line16> OperationStatus status = getClient().getOperationStatus(op); <line17> if (status.getState() == OperationState.ERROR) { <line18> throw new LensException(""Unknown error while running query "" + ctx.getUserQuery()); <line19> } <line20> result = createResultSet(ctx, true); <line21> if (result == null || !(result instanceof InMemoryResultSet)) { <line22> closeQuery(ctx.getQueryHandle()); <line23> } <line24> hiveHandles.remove(ctx.getQueryHandle()); <line25> } catch (IOException e) { <line26> throw new LensException(""Error adding persistent path"", e); <line27> } catch (HiveSQLException hiveErr) { <line28> handleHiveServerError(ctx, hiveErr); <line29> handleHiveSQLException(hiveErr); <line30> } finally { <line31> if (null != op) { <line32> opHandleToSession.remove(op); <line33> } <line34> } <line35> return result; <line36> } <line37> } <line38> "	"<line12>      log.info(""The hive operation handle: {}"", op);"	task4	
public class A { <line0> public final void setType(final String name) { <line1> if (name.equals(OrganizationIdentityProvider.NAME)) { <line2> setType(Type.USER); <line3> } else if (name.equals(SpaceIdentityProvider.NAME)) { <line4> setType(Type.SPACE); <line5> } else { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.warn(""Failed to set activity stream type with type:"" + name);"	task4	
"public class A { <line0> private void asyncError(AsyncContext asyncContext, Message message) { <line1> try { <line2> Map<String, Object> result = new HashMap<>(); <line3> result.put(""status"", -1); <line4> result.put(""error"", message.getMessageId()); <line5> ServletResponse response = asyncContext.getResponse(); <line6> response.setContentType(""application/json""); <line7> MAPPER.writeValue(response.getWriter(), result); <line8> } catch (Exception e) { <line9> } finally { <line10> asyncContext.complete(); <line11> } <line12> } <line13> } <line14> "	"<line9>      logger.error(""return message error {} - {}"", message.getSubject(), message.getMessageId());"	task4	
public class A { <line0> public void init() { <line1> if (workers == null || workers.length == 0) { <line2> workers = new DistPoolThread[threads]; <line3> for (int i = 0; i < workers.length; i++) { <line4> workers[i] = new DistPoolThread(this, ec, i); <line5> workers[i].start(); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.info(""init: "" + this.toString());"	task4	
public class A { <line0> @Override <line1> protected void doCleanup(Context context) throws IOException, InterruptedException { <line2> while (!future.isDone()) { <line3> if (queue.offer(inputConverterUnit.getEndRow(), 1, TimeUnit.SECONDS)) { <line4> break; <line5> } <line6> } <line7> futureGet(context); <line8> queue.clear(); <line9> } <line10> } <line11> 	"<line2>    logger.info(""Totally handled "" + mapCounter + "" records!"");"	task4	
public class A { <line0> private static boolean copyNodeState( <line1> @NotNull final NodeState source, <line2> @NotNull final NodeBuilder target, <line3> @NotNull final String currentPath, <line4> @NotNull final Set<String> mergePaths) { <line5> boolean hasChanges = false; <line6> for (final String childName : target.getChildNodeNames()) { <line7> if (!source.hasChildNode(childName) <line8> && !isMerge(PathUtils.concat(currentPath, childName), mergePaths)) { <line9> target.setChildNode(childName, EmptyNodeState.MISSING_NODE); <line10> hasChanges = true; <line11> } <line12> } <line13> for (ChildNodeEntry child : source.getChildNodeEntries()) { <line14> final String childName = child.getName(); <line15> final NodeState childSource = child.getNodeState(); <line16> if (!target.hasChildNode(childName)) { <line17> target.setChildNode(childName, childSource); <line18> hasChanges = true; <line19> } else { <line20> final NodeBuilder childTarget = target.getChildNode(childName); <line21> final String childPath = PathUtils.concat(currentPath, childName); <line22> hasChanges = copyNodeState(childSource, childTarget, childPath, mergePaths) || hasChanges; <line23> } <line24> } <line25> hasChanges = copyProperties(source, target) || hasChanges; <line26> if (hasChanges) { <line27> } <line28> return hasChanges; <line29> } <line30> } <line31> 	"<line27>      LOG.trace(""Node {} has changes"", target);"	task4	
public class A { <line0> public void addMappingFile(final String file) { <line1> if (new File(file).exists()) { <line2> entityManagerFactoryCallable.getUnitInfo().addMappingFileName(file); <line3> } else { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.error(""file "" + file + "" doesn't exists"");"	task4	
public class A { <line0> @Override <line1> protected PaymentTransactionInfoPlugin doCallSpecificOperationCallback() <line2> throws PaymentPluginApiException { <line3> return new DefaultNoOpPaymentInfoPlugin( <line4> paymentStateContext.getPaymentId(), <line5> paymentStateContext.getTransactionId(), <line6> TransactionType.CHARGEBACK, <line7> paymentStateContext.getAmount(), <line8> paymentStateContext.getCurrency(), <line9> null, <line10> null, <line11> PaymentPluginStatus.PROCESSED, <line12> null, <line13> null); <line14> } <line15> } <line16> 	"<line3>    logger.debug(""Starting CHARGEBACK for payment {} ({} {})"",paymentStateContext.getPaymentId(),paymentStateContext.getAmount(),paymentStateContext.getCurrency());"	task4	
public class A { <line0> protected String getJSONObjectLocalizedPropertyFromRequest(String propertyName) { <line1> String propertyValue = ParamUtil.getString(formAdminRequestHelper.getRequest(), propertyName); <line2> if (Validator.isNull(propertyValue)) { <line3> return StringPool.BLANK; <line4> } <line5> ThemeDisplay themeDisplay = formAdminRequestHelper.getThemeDisplay(); <line6> try { <line7> JSONObject jsonObject = jsonFactory.createJSONObject(propertyValue); <line8> String languageId = themeDisplay.getLanguageId(); <line9> if (jsonObject.has(languageId)) { <line10> return jsonObject.getString(languageId); <line11> } <line12> return jsonObject.getString(getDefaultLanguageId()); <line13> } catch (JSONException jsonException) { <line14> } <line15> return StringPool.BLANK; <line16> } <line17> } <line18> 	"<line14>      log.error(String.format(""Unable to deserialize JSON localized property \""%s\"" "" + ""from request"",propertyName),jsonException);"	task4	
public class A { <line0> public void requestReadAlarmRegister( <line1> final DeviceMessageMetadata deviceMessageMetadata, <line2> final ReadAlarmRegisterRequest readAlarmRegisterRequestValueObject) <line3> throws FunctionalException { <line4> final SmartMeter smartMeteringDevice = <line5> this.domainHelperService.findSmartMeter(deviceMessageMetadata.getDeviceIdentification()); <line6> final ReadAlarmRegisterRequestDto readAlarmRegisterRequestDto = <line7> this.monitoringMapper.map( <line8> readAlarmRegisterRequestValueObject, ReadAlarmRegisterRequestDto.class); <line9> this.osgpCoreRequestMessageSender.send( <line10> new RequestMessage( <line11> deviceMessageMetadata.getCorrelationUid(), <line12> deviceMessageMetadata.getOrganisationIdentification(), <line13> deviceMessageMetadata.getDeviceIdentification(), <line14> smartMeteringDevice.getIpAddress(), <line15> readAlarmRegisterRequestDto), <line16> deviceMessageMetadata.getMessageType(), <line17> deviceMessageMetadata.getMessagePriority(), <line18> deviceMessageMetadata.getScheduleTime(), <line19> deviceMessageMetadata.bypassRetry()); <line20> } <line21> } <line22> 	"<line4>    LOGGER.info(""requestReadAlarmRegister for organisationIdentification: {} for deviceIdentification: {}"",deviceMessageMetadata.getOrganisationIdentification(),deviceMessageMetadata.getDeviceIdentification());"	task4	
public class A { <line0> @Override <line1> public Map<String, IMonomer> getMonomers() { <line2> return super.getMonomers(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting monomers as hashtable"");"	task4	
public class A { <line0> @Override <line1> public void close() throws HiveException { <line2> if (model != null) { <line3> if (count == 0) { <line4> this.model = null; <line5> return; <line6> } <line7> if (iterations > 1) { <line8> runIterativeTraining(iterations); <line9> } <line10> final IntWritable idx = new IntWritable(); <line11> final FloatWritable[] Pu = HiveUtils.newFloatArray(factor, 0.f); <line12> final FloatWritable[] Qi = HiveUtils.newFloatArray(factor, 0.f); <line13> final FloatWritable Bi = useBiasClause ? new FloatWritable() : null; <line14> final Object[] forwardObj = new Object[] {idx, Pu, Qi, Bi}; <line15> int numForwarded = 0; <line16> for (int i = model.getMinIndex(), maxIdx = model.getMaxIndex(); i <= maxIdx; i++) { <line17> idx.set(i); <line18> Rating[] userRatings = model.getUserVector(i); <line19> if (userRatings == null) { <line20> forwardObj[1] = null; <line21> } else { <line22> forwardObj[1] = Pu; <line23> copyTo(userRatings, Pu); <line24> } <line25> Rating[] itemRatings = model.getItemVector(i); <line26> if (itemRatings == null) { <line27> forwardObj[2] = null; <line28> } else { <line29> forwardObj[2] = Qi; <line30> copyTo(itemRatings, Qi); <line31> } <line32> if (useBiasClause) { <line33> Bi.set(model.getItemBias(i)); <line34> } <line35> forward(forwardObj); <line36> numForwarded++; <line37> } <line38> this.model = null; <line39> } <line40> } <line41> } <line42> 	"<line39>      LOG.info(""Forwarded the prediction model of ""+ numForwarded+ "" rows. [lastLosses=""+ cvState.getCumulativeLoss()+ "", #trainingExamples=""+ count+ ""]"");"	task4	
public class A { <line0> @Override <line1> public void validationError(Throwable throwable) { <line2> wbNotification.fire( <line3> new NotificationEvent(i18n.validationError(), NotificationEvent.NotificationType.ERROR)); <line4> } <line5> } <line6> 	<line2>    LOGGER.error(throwable.getMessage(), throwable);	task4	
public class A { <line0> @Override <line1> public void shutdown() { <line2> if (started) { <line3> started = false; <line4> Enumeration<String> keys = allocatedLimiters.keys(); <line5> Collections.asList(keys) <line6> .forEach(name -> Tasks.shutdownExecutor(name, allocatedLimiters.get(name).executor, 5)); <line7> } else { <line8> } <line9> } <line10> } <line11> 	"<line8>      log.warn(""The service is already shut down."");"	task4	
"public class A { <line0> private static <T> T runExternalAttach( <line1> long pid, <line2> String methodName, <line3> InputStreamProcessor<T> processor, <line4> @Nullable File glowrootJarFile) <line5> throws Exception { <line6> List<String> command = buildCommand(pid, methodName, glowrootJarFile); <line7> ProcessBuilder processBuilder = new ProcessBuilder(command); <line8> Process process = processBuilder.start(); <line9> Closer closer = Closer.create(); <line10> ErrorStreamReader errorStreamReader; <line11> T result = null; <line12> Exception processingException = null; <line13> try { <line14> InputStream in = closer.register(process.getInputStream()); <line15> InputStream err = closer.register(process.getErrorStream()); <line16> errorStreamReader = new ErrorStreamReader(err); <line17> Thread errorStreamReaderThread = new Thread(errorStreamReader); <line18> errorStreamReaderThread.setName(""Glowroot-JVM-Tool-Error-Stream-Reader""); <line19> errorStreamReaderThread.setDaemon(true); <line20> errorStreamReaderThread.start(); <line21> try { <line22> result = processAndClose(in, processor); <line23> } catch (Exception e) { <line24> processingException = e; <line25> } catch (Throwable t) { <line26> processingException = new RuntimeException(t); <line27> } <line28> errorStreamReaderThread.join(); <line29> } catch (Throwable t) { <line30> throw closer.rethrow(t); <line31> } finally { <line32> closer.close(); <line33> } <line34> int status = process.waitFor(); <line35> if (status == UNAVAILABLE_DUE_TO_RUNNING_IN_JRE_STATUS) { <line36> throw new UnavailableDueToRunningInJreException(); <line37> } else if (status == UNAVAILABLE_PROBABLY_DUE_TO_DOCKER_PID_ONE_STATUS) { <line38> throw new UnavailableDueToDockerAlpinePidOneException(); <line39> } else if (status != 0) { <line40> throw new IllegalStateException(""Error occurred while trying to run jvm tool""); <line41> } <line42> if (result == null) { <line43> throw checkNotNull(processingException); <line44> } <line45> return result; <line46> } <line47> } <line48> "	"<line40>      logger.error(""error occurred while trying to run jvm tool:\n{}\n{}"",Joiner.on(' ').join(command),errorStreamReader.getOutput().trim());"	task4	
public class A { <line0> @ExceptionHandler(UaaException.class) <line1> public ResponseEntity<UaaException> handleException(UaaException e) { <line2> if (e instanceof InternalUserManagementDisabledException) { <line3> throw e; <line4> } <line5> return new ResponseEntity<>(e, HttpStatus.valueOf(e.getHttpStatus())); <line6> } <line7> } <line8> 	"<line2>    logger.info(""Handling error: "" + e.getClass().getSimpleName() + "", "" + e.getMessage());"	task4	
public class A { <line0> @Override <line1> public void getCurrentConfigFailed( <line2> VehicleState.GetCurrentConfigErrorEnum error, ReplyContext replyContext) { <line3> } <line4> } <line5> 	"<line3>    logger.error(""Unable to get config {} / {}"", replyContext, error);"	task4	
public class A { <line0> public Entry newEntry(String ldif, String dn) { <line1> try { <line2> Entry entry = readEntry(ldif); <line3> Dn newDn = getDnFactory().create(dn); <line4> entry.setDn(newDn); <line5> return new DefaultEntry(schemaManager, entry); <line6> } catch (Exception e) { <line7> return null; <line8> } <line9> } <line10> } <line11> 	<line7>      LOG.error(I18n.err(I18n.ERR_78, ldif, dn));	task4	
public class A { <line0> private static void createShuntCompensator( <line1> MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) { <line2> if (mBus.getShuntSusceptance() != 0) { <line3> String busId = getId(BUS_PREFIX, mBus.getNumber()); <line4> String shuntId = getId(SHUNT_PREFIX, mBus.getNumber()); <line5> double zb = <line6> voltageLevel.getNominalV() * voltageLevel.getNominalV() / perUnitContext.getBaseMva(); <line7> ShuntCompensatorAdder adder = <line8> voltageLevel <line9> .newShuntCompensator() <line10> .setId(shuntId) <line11> .setConnectableBus(busId) <line12> .setBus(busId) <line13> .setSectionCount(1); <line14> adder <line15> .newLinearModel() <line16> .setBPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb) <line17> .setMaximumSectionCount(1) <line18> .add(); <line19> ShuntCompensator newShunt = adder.add(); <line20> } <line21> } <line22> } <line23> 	"<line20>      LOGGER.debug(""Created shunt {}"", newShunt.getId());"	task4	
public class A { <line0> @Override <line1> public void sendCommfaultTag(long tagID, String tagName, boolean value, String pDescription) { <line2> long timestamp = System.currentTimeMillis(); <line3> SourceDataTagValue commfaultTagValue = <line4> SourceDataTagValue.builder() <line5> .id(tagID) <line6> .name(tagName) <line7> .controlTag(true) <line8> .value(value) <line9> .quality(new SourceDataTagQuality()) <line10> .timestamp(new Timestamp(timestamp)) <line11> .daqTimestamp(new Timestamp(timestamp)) <line12> .priority(JmsMessagePriority.PRIORITY_HIGHEST.getPriority()) <line13> .timeToLive(DataTagConstants.TTL_FOREVER) <line14> .valueDescription(pDescription) <line15> .build(); <line16> distributeValue(commfaultTagValue); <line17> } <line18> } <line19> 	"<line2>    log.debug(""Sending CommfaultTag tag {} (#{})"", tagName, tagID);"	task4	
public class A { <line0> private SenseiProtos.ErrorType convert(ErrorType errorType) { <line1> switch (errorType) { <line2> case BoboExecutionError: <line3> return SenseiProtos.ErrorType.BoboExecutionError; <line4> case BQLParsingError: <line5> return SenseiProtos.ErrorType.BQLParsingError; <line6> case BrokerGatherError: <line7> return SenseiProtos.ErrorType.BrokerGatherError; <line8> case BrokerTimeout: <line9> return SenseiProtos.ErrorType.BrokerTimeout; <line10> case ExecutionTimeout: <line11> return SenseiProtos.ErrorType.ExecutionTimeout; <line12> case FederatedBrokerUnavailable: <line13> return SenseiProtos.ErrorType.FederatedBrokerUnavailable; <line14> case InternalError: <line15> return SenseiProtos.ErrorType.InternalError; <line16> case JsonCompilationError: <line17> return SenseiProtos.ErrorType.JsonCompilationError; <line18> case JsonParsingError: <line19> return SenseiProtos.ErrorType.JsonParsingError; <line20> case MergePartitionError: <line21> return SenseiProtos.ErrorType.MergePartitionError; <line22> case PartitionCallError: <line23> return SenseiProtos.ErrorType.PartitionCallError; <line24> case UnknownError: <line25> return SenseiProtos.ErrorType.UnknownError; <line26> default: <line27> { <line28> return SenseiProtos.ErrorType.UnknownError; <line29> } <line30> } <line31> } <line32> } <line33> 	"<line28>          logger.warn(""Unknown error type in proto serialization, setting unknown "" + errorType);"	task4	
public class A { <line0> @Override <line1> protected void sendMcastDiscoveryRequest(Message msg) { <line2> try { <line3> if (msg.getSrc() == null) msg.setSrc(local_addr); <line4> ByteArrayDataOutputStream out = new ByteArrayDataOutputStream(msg.size()); <line5> msg.writeTo(out); <line6> for (int i = bind_port; i <= bind_port + port_range; i++) { <line7> DatagramPacket packet = new DatagramPacket(out.buffer(), 0, out.position(), dest_addr, i); <line8> sock.send(packet); <line9> } <line10> } catch (Exception ex) { <line11> } <line12> } <line13> } <line14> 	"<line11>      log.error(String.format(""%s: failed sending discovery request"", local_addr), ex);"	task4	
public class A { <line0> @Override <line1> public String getName() { <line2> return super.getName(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting Name: "", super.getName());"	task4	
"public class A { <line0> private void validateInMemoryResultSet(InMemoryQueryResult result) { <line1> int size = result.getRows().size(); <line2> for (int i = 0; i < size; i++) { <line3> } <line4> Assert.assertEquals(size, 2, ""Wrong result""); <line5> Assert.assertEquals(result.getRows().get(0).getValues().get(0), 2, ""Wrong result""); <line6> Assert.assertEquals(result.getRows().get(0).getValues().get(1), ""second"", ""Wrong result""); <line7> Assert.assertEquals(result.getRows().get(1).getValues().get(0), 3, ""Wrong result""); <line8> Assert.assertEquals(result.getRows().get(1).getValues().get(1), ""third"", ""Wrong result""); <line9> } <line10> } <line11> "	"<line3>      logger.info(result.getRows().get(i).getValues().get(0)+ "" ""+ result.getRows().get(i).getValues().get(1));"	task4	
public class A { <line0> @Override <line1> protected void doit() throws WollMuxFehlerException { <line2> if (model == null) { <line3> return; <line4> } <line5> model.getDocumentCommands().update(); <line6> DocumentCommandInterpreter dci = <line7> new DocumentCommandInterpreter(documentController, WollMuxFiles.isDebugMode()); <line8> try { <line9> dci.executeTemplateCommands(); <line10> dci.scanGlobalDocumentCommands(); <line11> dci.scanInsertFormValueCommands(); <line12> } catch (WMCommandsFailedException e) { <line13> } <line14> } <line15> } <line16> 	"<line13>      LOGGER.debug("""", e);"	task4	
"public class A { <line0> @Override <line1> public void save(FqlStore fqlStore) { <line2> fqlStore.setId(UUID.randomUUID().toString()); <line3> try { <line4> elasticsearchConnection <line5> .getClient() <line6> .prepareIndex() <line7> .setIndex(FQL_STORE_INDEX) <line8> .setType(DOCUMENT_TYPE_NAME) <line9> .setId(fqlStore.getId()) <line10> .setSource(objectMapper.writeValueAsBytes(fqlStore), XContentType.JSON) <line11> .execute() <line12> .get(); <line13> } catch (Exception e) { <line14> throw new FqlPersistenceException( <line15> ""Couldn't save FQL query: "" + fqlStore.getQuery() + "" Error Message: "" + e.getMessage(), <line16> e); <line17> } <line18> } <line19> } <line20> "	"<line13>      logger.info(""Saved FQL Query : {}"", fqlStore.getQuery());"	task4	
public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMTemplateSoap getTemplate( <line1> long groupId, long classNameId, String templateKey, boolean includeAncestorTemplates) <line2> throws RemoteException { <line3> try { <line4> com.liferay.dynamic.data.mapping.model.DDMTemplate returnValue = <line5> DDMTemplateServiceUtil.getTemplate( <line6> groupId, classNameId, templateKey, includeAncestorTemplates); <line7> return com.liferay.dynamic.data.mapping.model.DDMTemplateSoap.toSoapModel(returnValue); <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>      log.error(exception, exception);	task4	
"public class A { <line0> @GetMapping(RestApi.ARCHIVE_UNIT_INFO + CommonConstants.PATH_ID) <line1> @Secured(ServicesData.ROLE_GET_ARCHIVE) <line2> public ResponseEntity<ResultsDto> findUnitById(final @PathVariable(""id"") String id) { <line3> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line4> return archivesSearchExternalService.findUnitById(id); <line5> } <line6> } <line7> "	"<line3>    LOGGER.info(""the UA by id {} "", id);"	task4	
public class A { <line0> @Override <line1> public void doDisable() { <line2> if (tmSocket != null) { <line3> try { <line4> tmSocket.close(); <line5> } catch (IOException e) { <line6> } <line7> tmSocket = null; <line8> } <line9> if (thread != null) { <line10> thread.interrupt(); <line11> } <line12> } <line13> } <line14> 	"<line6>        log.warn(""Exception got when closing the tm socket:"", e);"	task4	
"public class A { <line0> @SuppressWarnings({""null"", ""unused""}) <line1> @Override <line2> public void processMessage(String topic, byte[] payload) { <line3> final ScheduledFuture<?> scheduledFuture = this.scheduledFuture; <line4> if (scheduledFuture != null) { <line5> scheduledFuture.cancel(false); <line6> this.scheduledFuture = null; <line7> } <line8> if (payload.length == 0) { <line9> return; <line10> } <line11> String valueStr = new String(payload, StandardCharsets.UTF_8); <line12> final MQTTvalueTransform transform = field.getAnnotation(MQTTvalueTransform.class); <line13> Object value; <line14> if (transform != null) { <line15> valueStr = transform.prefix() + valueStr + transform.suffix(); <line16> value = <line17> field.getType().isArray() <line18> ? valueStr.split(transform.splitCharacter()) <line19> : numberConvert(valueStr, field.getType()); <line20> } else if (field.getType().isArray()) { <line21> throw new IllegalArgumentException(""No split character defined!""); <line22> } else { <line23> value = numberConvert(valueStr, field.getType()); <line24> } <line25> receivedValue = true; <line26> changeConsumer.fieldChanged(field, value); <line27> future.complete(null); <line28> } <line29> } <line30> "	"<line9>      logger.debug(""NULL payload on topic: {}"", topic);"	task4	
"public class A { <line0> @Override <line1> public void removeConsumedToken(String token) { <line2> Connection conn = null; <line3> PreparedStatement stat = null; <line4> try { <line5> conn = this.getConnection(); <line6> conn.setAutoCommit(false); <line7> stat = conn.prepareStatement(DELETE_USED_TOKEN); <line8> stat.setString(1, token); <line9> stat.executeUpdate(); <line10> conn.commit(); <line11> } catch (Throwable t) { <line12> this.executeRollback(conn); <line13> throw new RuntimeException(""Error removing consumed Token"", t); <line14> } finally { <line15> closeDaoResources(null, stat, conn); <line16> } <line17> } <line18> } <line19> "	"<line13>      logger.error(""Error removing consumed Token"", t);"	task4	
"public class A { <line0> protected void init() throws MojoExecutionException, MojoFailureException { <line1> super.init(); <line2> if (moduleId != null) { <line3> ModuleConfig moduleConfig = createModuleConfigFromId(moduleId); <line4> if (modules == null) { <line5> modules = new ModuleConfig[] {moduleConfig}; <line6> } else { <line7> List list = Arrays.asList(modules); <line8> ArrayList aList = new ArrayList(list); <line9> aList.add(moduleConfig); <line10> modules = (ModuleConfig[]) aList.toArray(new ModuleConfig[list.size()]); <line11> } <line12> } else if (modules == null || modules.length == 0) { <line13> throw new MojoExecutionException( <line14> ""At least one module configuration (or moduleId) must be specified""); <line15> } <line16> } <line17> } <line18> "	"<line3>      log.info(""Using non-artifact based module id: "" + moduleId);"	task4	
public class A { <line0> public KaleoDefinition getKaleoDefinition(KaleoDefinitionVersion kaleoDefinitionVersion) { <line1> try { <line2> if (kaleoDefinitionVersion != null) { <line3> return kaleoDefinitionVersion.getKaleoDefinition(); <line4> } <line5> } catch (PortalException portalException) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line7>        log.debug(portalException, portalException);	task4	
public class A { <line0> public static void deleteCPDefinitionSpecificationOptionValues(long cpDefinitionId) <line1> throws RemoteException { <line2> try { <line3> CPDefinitionSpecificationOptionValueServiceUtil.deleteCPDefinitionSpecificationOptionValues( <line4> cpDefinitionId); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      log.error(exception, exception);	task4	
"public class A { <line0> protected InputStream getInputStream(String profileId) throws IOException { <line1> final String profileUrl = registryBaseURl + profileId + ""/xml""; <line2> return new URL(profileUrl).openStream(); <line3> } <line4> } <line5> "	"<line2>    LOG.debug(""Opening input stream at {}"", profileUrl);"	task4	
public class A { <line0> @OnWebSocketConnect <line1> public void onConnect(Session session) { <line2> this.session = session; <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Connect [{}]"", session);"	task4	
public class A { <line0> private VloReport getPreviousReport() throws JAXBException { <line1> final VloReportMarshaller marshaller = new VloReportMarshaller(); <line2> final VloReport previousReport; <line3> if (reportHistoryFile.exists() && reportHistoryFile.canRead()) { <line4> previousReport = marshaller.unmarshall(new StreamSource(this.reportHistoryFile)); <line5> } else { <line6> previousReport = null; <line7> } <line8> return previousReport; <line9> } <line10> } <line11> 	"<line6>      logger.warn(""No report history found (normal on first run), existing values will not be reset"");"	task4	
public class A { <line0> private boolean isDatabaseAvailable() <line1> throws ParserConfigurationException, SAXException, IOException, ClassNotFoundException { <line2> final PersistenceXmlHandler configuration = parsePersistenceXml(); <line3> Class.forName(configuration.getDriverClass()); <line4> boolean available; <line5> try { <line6> final Connection testConnection = <line7> DriverManager.getConnection( <line8> configuration.getConnectionUrl(), <line9> configuration.getUsername(), <line10> configuration.getPassword()); <line11> testConnection.close(); <line12> available = true; <line13> } catch (SQLException ex) { <line14> available = false; <line15> } <line16> return available; <line17> } <line18> } <line19> 	"<line14>      LOGGER.trace(""Unable to open a connection to the test database."", ex);"	task4	
public class A { <line0> public WebSocketAPI getMatchedAPI(WebSocketFrameRequest webSocketFrameRequest) { <line1> Map<String, String> extAuthMetadata = <line2> webSocketFrameRequest.getMetadata().getExtAuthzMetadataMap(); <line3> String vHost = extAuthMetadata.get(APIConstants.GW_VHOST_PARAM); <line4> String basePath = extAuthMetadata.get(APIConstants.GW_BASE_PATH_PARAM); <line5> String version = extAuthMetadata.get(APIConstants.GW_VERSION_PARAM); <line6> String apiKey = getApiKey(vHost, basePath, version); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> return (WebSocketAPI) apis.get(apiKey); <line10> } <line11> } <line12> 	"<line8>      logger.debug(""Looking for matching API with basepath: {} and version: {}"", basePath, version);"	task4	
public class A { <line0> @Deprecated <line1> public static com.liferay.portal.kernel.model.UserSoap updateUser( <line2> long userId, <line3> String oldPassword, <line4> String newPassword1, <line5> String newPassword2, <line6> boolean passwordReset, <line7> String reminderQueryQuestion, <line8> String reminderQueryAnswer, <line9> String screenName, <line10> String emailAddress, <line11> long facebookId, <line12> String openId, <line13> boolean hasPortrait, <line14> byte[] portraitBytes, <line15> String languageId, <line16> String timeZoneId, <line17> String greeting, <line18> String comments, <line19> String firstName, <line20> String middleName, <line21> String lastName, <line22> long prefixId, <line23> long suffixId, <line24> boolean male, <line25> int birthdayMonth, <line26> int birthdayDay, <line27> int birthdayYear, <line28> String smsSn, <line29> String facebookSn, <line30> String jabberSn, <line31> String skypeSn, <line32> String twitterSn, <line33> String jobTitle, <line34> long[] groupIds, <line35> long[] organizationIds, <line36> long[] roleIds, <line37> com.liferay.portal.kernel.model.UserGroupRoleSoap[] userGroupRoles, <line38> long[] userGroupIds, <line39> com.liferay.portal.kernel.model.AddressSoap[] addresses, <line40> com.liferay.portal.kernel.model.EmailAddressSoap[] emailAddresses, <line41> com.liferay.portal.kernel.model.PhoneSoap[] phones, <line42> com.liferay.portal.kernel.model.WebsiteSoap[] websites, <line43> com.liferay.announcements.kernel.model.AnnouncementsDeliverySoap[] announcementsDelivers, <line44> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line45> throws RemoteException { <line46> try { <line47> com.liferay.portal.kernel.model.User returnValue = <line48> UserServiceUtil.updateUser( <line49> userId, <line50> oldPassword, <line51> newPassword1, <line52> newPassword2, <line53> passwordReset, <line54> reminderQueryQuestion, <line55> reminderQueryAnswer, <line56> screenName, <line57> emailAddress, <line58> facebookId, <line59> openId, <line60> hasPortrait, <line61> portraitBytes, <line62> languageId, <line63> timeZoneId, <line64> greeting, <line65> comments, <line66> firstName, <line67> middleName, <line68> lastName, <line69> prefixId, <line70> suffixId, <line71> male, <line72> birthdayMonth, <line73> birthdayDay, <line74> birthdayYear, <line75> smsSn, <line76> facebookSn, <line77> jabberSn, <line78> skypeSn, <line79> twitterSn, <line80> jobTitle, <line81> groupIds, <line82> organizationIds, <line83> roleIds, <line84> com.liferay.portal.model.impl.UserGroupRoleModelImpl.toModels(userGroupRoles), <line85> userGroupIds, <line86> com.liferay.portal.model.impl.AddressModelImpl.toModels(addresses), <line87> com.liferay.portal.model.impl.EmailAddressModelImpl.toModels(emailAddresses), <line88> com.liferay.portal.model.impl.PhoneModelImpl.toModels(phones), <line89> com.liferay.portal.model.impl.WebsiteModelImpl.toModels(websites), <line90> com.liferay.portlet.announcements.model.impl.AnnouncementsDeliveryModelImpl.toModels( <line91> announcementsDelivers), <line92> serviceContext); <line93> return com.liferay.portal.kernel.model.UserSoap.toSoapModel(returnValue); <line94> } catch (Exception exception) { <line95> throw new RemoteException(exception.getMessage()); <line96> } <line97> } <line98> } <line99> 	<line95>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void handleMessage(String message, KaleidescapeHandler handler) { <line2> Matcher matcher = p.matcher(message); <line3> if (matcher.find()) { <line4> handler.updateChannel( <line5> PLAY_MODE, new StringType(KaleidescapeStatusCodes.PLAY_MODE.get(matcher.group(1)))); <line6> handler.updateChannel(PLAY_SPEED, new StringType(matcher.group(2))); <line7> handler.updateChannel(TITLE_NUM, new DecimalType(Integer.parseInt(matcher.group(3)))); <line8> handler.updateChannel( <line9> TITLE_LENGTH, <line10> new QuantityType<Time>(Integer.parseInt(matcher.group(4)), handler.apiSecondUnit)); <line11> handler.updateChannel( <line12> TITLE_LOC, <line13> new QuantityType<Time>(Integer.parseInt(matcher.group(5)), handler.apiSecondUnit)); <line14> handler.updateChannel(CHAPTER_NUM, new DecimalType(Integer.parseInt(matcher.group(6)))); <line15> handler.updateChannel( <line16> CHAPTER_LENGTH, <line17> new QuantityType<Time>(Integer.parseInt(matcher.group(7)), handler.apiSecondUnit)); <line18> handler.updateChannel( <line19> CHAPTER_LOC, <line20> new QuantityType<Time>(Integer.parseInt(matcher.group(8)), handler.apiSecondUnit)); <line21> } else { <line22> } <line23> } <line24> } <line25> 	"<line22>      logger.debug(""PLAY_STATUS - no match on message: {}"", message);"	task4	
"public class A { <line0> public static String getHostname(SocketAddress socketAddress) { <line1> try { <line2> InetSocketAddress inetSocketAddress = (InetSocketAddress) socketAddress; <line3> String hostname = inetSocketAddress.getHostName(); <line4> if (hostname != null) { <line5> return hostname; <line6> } else { <line7> throw new NullPointerException(""The returned hostname is null""); <line8> } <line9> } catch (Exception e) { <line10> } <line11> return """"; <line12> } <line13> } <line14> "	"<line10>      logger.warn(""Unable to retrieve client hostname"", e);"	task4	
public class A { <line0> @Override <line1> public Boolean updateWebHook(JsonObject registerWebhookjson) throws InsightsCustomException { <line2> Boolean status = false; <line3> try { <line4> WebHookConfig webHookConfig = populateWebHookConfiguration(registerWebhookjson); <line5> status = webhookConfigurationDAL.updateWebHookConfiguration(webHookConfig); <line6> } catch (Exception e) { <line7> throw new InsightsCustomException(e.toString()); <line8> } <line9> return status; <line10> } <line11> } <line12> 	"<line7>      log.error(""Error in updating the webhook.. "", e);"	task4	
public class A { <line0> @Override <line1> public Single<PartitionKeyRange> tryGetPartitionKeyRangeByIdAsync( <line2> String collectionResourceId, <line3> String partitionKeyRangeId, <line4> boolean forceRefresh, <line5> Map<String, Object> properties) { <line6> Single<CollectionRoutingMap> routingMapObs = <line7> tryLookupAsync(collectionResourceId, null, properties); <line8> return routingMapObs <line9> .flatMap( <line10> routingMap -> { <line11> if (forceRefresh && routingMap != null) { <line12> return tryLookupAsync(collectionResourceId, routingMap, properties); <line13> } <line14> return Single.just(routingMap); <line15> }) <line16> .map( <line17> routingMap -> { <line18> if (routingMap != null) { <line19> return routingMap.getRangeByPartitionKeyRangeId(partitionKeyRangeId); <line20> } else { <line21> return null; <line22> } <line23> }); <line24> } <line25> } <line26> 	"<line21>                logger.debug(""Routing Map Null for collection: {}, PartitionKeyRangeId: {}, forceRefresh:{}"",collectionResourceId,partitionKeyRangeId,forceRefresh);"	task4	
public class A { <line0> @Override <line1> public WikiPage findByPrimaryKey(Serializable primaryKey) throws NoSuchPageException { <line2> WikiPage wikiPage = fetchByPrimaryKey(primaryKey); <line3> if (wikiPage == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchPageException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return wikiPage; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
"public class A { <line0> public BucketRegion getInitializedBucketForId(Object key, Integer bucketId) <line1> throws ForceReattemptException { <line2> final BucketRegion bucketRegion = this.localBucket2RegionMap.get(bucketId); <line3> if (null == bucketRegion) { <line4> this.partitionedRegion.checkReadiness(); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> ForceReattemptException fre = <line8> new BucketNotFoundException( <line9> String.format( <line10> ""Bucket id %s not found on VM %s"", <line11> new Object[] { <line12> this.partitionedRegion.bucketStringForLogs(bucketId.intValue()), <line13> this.partitionedRegion.getMyId() <line14> })); <line15> if (key != null) { <line16> fre.setHash(key.hashCode()); <line17> } <line18> throw fre; <line19> } <line20> bucketRegion.waitForData(); <line21> return bucketRegion; <line22> } <line23> } <line24> "	"<line6>        logger.debug(""Got null bucket region for bucketId={}{}{} for PartitionedRegion = {}"",this.partitionedRegion.getPRId(),PartitionedRegion.BUCKET_ID_SEPARATOR,bucketId,this.partitionedRegion);"	task4	
public class A { <line0> public boolean updateDocument() { <line1> try { <line2> XNamed textSection = UNO.XNamed(textSections.get(sectionNameComplete)); <line3> String nameBase = generateCompleteName(); <line4> String name = nameBase; <line5> int count = 1; <line6> while (textSections.containsKey(name)) { <line7> if (name.equals(sectionNameComplete)) return true; <line8> name = nameBase + (count++); <line9> } <line10> textSection.setName(name); <line11> sectionNameComplete = name; <line12> return true; <line13> } catch (Exception x) { <line14> return false; <line15> } <line16> } <line17> } <line18> 	"<line14>      LOGGER.error(L.m(""Fehler beim Versuch, Bereich zu updaten: \""%1\"""", sectionNameComplete), x);"	task4	
"public class A { <line0> private void processLicenseSolution(ServiceInstance serviceInstance, JSONArray licenseSolutions) { <line1> List<GenericVnf> vnfs = serviceInstance.getVnfs(); <line2> for (int i = 0; i < licenseSolutions.length(); i++) { <line3> JSONObject licenseSolution = licenseSolutions.getJSONObject(i); <line4> for (GenericVnf vnf : vnfs) { <line5> if (licenseSolution.getString(SERVICE_RESOURCE_ID).equals(vnf.getVnfId())) { <line6> License license = new License(); <line7> JSONArray entitlementPools = licenseSolution.getJSONArray(""entitlementPoolUUID""); <line8> List<String> entitlementPoolsList = jsonUtils.StringArrayToList(entitlementPools); <line9> license.setEntitlementPoolUuids(entitlementPoolsList); <line10> JSONArray licenseKeys = licenseSolution.getJSONArray(""licenseKeyGroupUUID""); <line11> List<String> licenseKeysList = jsonUtils.StringArrayToList(licenseKeys); <line12> license.setLicenseKeyGroupUuids(licenseKeysList); <line13> vnf.setLicense(license); <line14> } <line15> } <line16> } <line17> } <line18> } <line19> "	"<line2>    logger.debug(""Processing the license solution"");"	task4	
public class A { <line0> public void executeJob(String processInstanceId) { <line1> List<String> deadLetterJobsIds = getDeadLetterJobsDistinctIds(processInstanceId); <line2> if (deadLetterJobsIds.isEmpty()) { <line3> return; <line4> } <line5> moveDeadLetterJobsToExecutableJobs(deadLetterJobsIds); <line6> } <line7> } <line8> 	"<line3>      LOGGER.info(MessageFormat.format(""No dead letter jobs found for process with id {0}"", processInstanceId));"	task4	
public class A { <line0> private void reportFailure( <line1> Collection<SpringBootExceptionReporter> exceptionReporters, Throwable failure) { <line2> try { <line3> for (SpringBootExceptionReporter reporter : exceptionReporters) { <line4> if (reporter.reportException(failure)) { <line5> registerLoggedException(failure); <line6> return; <line7> } <line8> } <line9> } catch (Throwable ex) { <line10> } <line11> if (logger.isErrorEnabled()) { <line12> registerLoggedException(failure); <line13> } <line14> } <line15> } <line16> 	"<line12>      logger.error(""Application run failed"", failure);"	task4	
public class A { <line0> @Override <line1> public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { <line2> return this.methodMap <line3> .computeIfAbsent( <line4> method.getName().toLowerCase(), <line5> (key) -> { <line6> try { <line7> return this.eventData.getClass().getMethod(method.getName()); <line8> } catch (NoSuchMethodException exception) { <line9> throw new RuntimeException(exception); <line10> } <line11> }) <line12> .invoke(this.eventData); <line13> } <line14> } <line15> 	<line9>                LOG.error(exception.getMessage(), exception);	task4	
public class A { <line0> @Override <line1> public void after(Object target, Object[] args, Object result, Throwable throwable) { <line2> if (isDebug) { <line3> logger.afterInterceptor(target, args, result, throwable); <line4> } <line5> final Trace trace = traceContext.currentTraceObject(); <line6> if (trace == null) { <line7> return; <line8> } <line9> try { <line10> final SpanEventRecorder recorder = trace.currentSpanEventRecorder(); <line11> recorder.recordApi(this.descriptor); <line12> recorder.recordServiceType(AgentSdkAsyncConstants.AGENT_SDK_ASYNC); <line13> recorder.recordException(throwable); <line14> boolean r = validate(result); <line15> if (r) { <line16> final AsyncContext asyncContext = recorder.recordNextAsyncContext(); <line17> ((AsyncContextAccessor) result)._$PINPOINT$_setAsyncContext(asyncContext); <line18> if (isDebug) { <line19> } <line20> } <line21> } finally { <line22> trace.traceBlockEnd(); <line23> } <line24> } <line25> } <line26> 	"<line19>          logger.debug(""Set asyncContext {}"", asyncContext);"	task4	
"public class A { <line0> @BeforeMethod <line1> public void setUp(final Method testMethod) throws Throwable { <line2> couchbaseProvided = Boolean.parseBoolean(System.getProperty(""couchbase.provided"", ""false"")); <line3> final int couchbasePort = Integer.parseInt(System.getProperty(""couchbase.port"", ""18091"")); <line4> if (!couchbaseProvided) { <line5> cluster.add(setupCouchbase(couchbasePort)); <line6> } <line7> try { <line8> System.setProperty(""org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"", ""true""); <line9> _tomcat1 = <line10> getTestUtils() <line11> .tomcatBuilder() <line12> .port(_portTomcat1) <line13> .memcachedNodes(""http://localhost:"" + couchbasePort + ""/pools"") <line14> .sticky(true) <line15> .memcachedProtocol(""binary"") <line16> .username(""default"") <line17> .buildAndStart(); <line18> } catch (final Throwable e) { <line19> throw e; <line20> } <line21> setupCouchbaseClient(); <line22> transcoderService = <line23> new TranscoderService(new JavaSerializationTranscoder(_tomcat1.getManager())); <line24> } <line25> } <line26> "	"<line19>      LOG.error(""could not start tomcat."", e);"	task4	
public class A { <line0> public void send(final RequestMessage requestMessage, final String messageType) { <line1> this.jmsTemplate.send( <line2> session -> { <line3> final ObjectMessage objectMessage = session.createObjectMessage(requestMessage); <line4> objectMessage.setJMSType(messageType); <line5> objectMessage.setStringProperty( <line6> Constants.ORGANISATION_IDENTIFICATION, <line7> requestMessage.getOrganisationIdentification()); <line8> objectMessage.setStringProperty( <line9> Constants.DEVICE_IDENTIFICATION, requestMessage.getDeviceIdentification()); <line10> return objectMessage; <line11> }); <line12> } <line13> } <line14> 	"<line1>    LOGGER.info(""Sending request message to OSGP."");"	task4	
public class A { <line0> private Optional<String> getAmiIdFromEC2Api(final EC2InstanceContext context) { <line1> final String instanceId = context.getInstanceId(); <line2> try { <line3> return context <line4> .getClient(AmazonEC2Client.class) <line5> .describeInstances(new DescribeInstancesRequest().withInstanceIds(instanceId)) <line6> .getReservations() <line7> .stream() <line8> .map(Reservation::getInstances) <line9> .flatMap(Collection::stream) <line10> .filter(i -> i.getInstanceId().equals(instanceId)) <line11> .map(Instance::getImageId) <line12> .findFirst(); <line13> } catch (final AmazonClientException e) { <line14> return empty(); <line15> } <line16> } <line17> } <line18> 	"<line14>      log.warn(""Could not describe instance "" + instanceId, e);"	task4	
"public class A { <line0> private Object findEjb( <line1> Map<String, CacheEntry> map, <line2> String className, <line3> String sessionId, <line4> String jndiName, <line5> int warnLimit) { <line6> CacheEntry entry = map.get(getMapKey(className, sessionId)); <line7> if (entry == null && jndiName != null) { <line8> synchronized (this) { <line9> entry = map.get(getMapKey(className, sessionId)); <line10> if (entry == null) { <line11> Object ejb = lookupInJndi(jndiName); <line12> if (ejb != null) { <line13> map.put(getMapKey(className, sessionId), entry = new CacheEntry(ejb)); <line14> int size = map.size(); <line15> if (size > warnLimit) { <line16> String type = sessionId == null ? ""stateless"" : ""stateful""; <line17> } <line18> } <line19> } <line20> } <line21> } <line22> if (entry == null) { <line23> return null; <line24> } else { <line25> entry.setLastAccessTime(System.currentTimeMillis()); <line26> return entry.getBean(); <line27> } <line28> } <line29> } <line30> "	"<line17>              log.warn(""Warn limit reached for ""+ type+ "" beans. Currently there ""+ ""are ""+ size+ "" ""+ type+ "" EJB stubs cached in '""+ name+ ""' ""+ ""beanstalk."");"	task4	
public class A { <line0> @Override <line1> public String onScript( <line2> String script, Document document, String languageId, Map<String, String> tokens) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> return replace(script); <line6> } <line7> } <line8> 	"<line4>      log.debug(""onScript"");"	task4	
public class A { <line0> @Override <line1> public ObjectLayout findByPrimaryKey(Serializable primaryKey) throws NoSuchLayoutException { <line2> ObjectLayout objectLayout = fetchByPrimaryKey(primaryKey); <line3> if (objectLayout == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchLayoutException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return objectLayout; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @Override <line1> public void register(EhcacheXAResource resource, boolean forRecovery) { <line2> } <line3> } <line4> 	"<line2>    log.info(""register XA resource"");"	task4	
public class A { <line0> @Override <line1> public void warn(Throwable throwable) { <line2> try { <line3> } catch (Exception exception) { <line4> printMsg(throwable.getMessage()); <line5> } <line6> } <line7> } <line8> 	<line3>      log.warn(throwable);	task4	
public class A { <line0> @Override <line1> public Object visit(Id filter, Object userData) { <line2> String idName; <line3> try { <line4> idName = featureModel.getEntityMetadata().getIdentifierPropertyName(); <line5> } catch (LayerException e) { <line6> idName = HIBERNATE_ID; <line7> } <line8> Collection<?> c = (Collection<?>) castLiteral(filter.getIdentifiers(), idName); <line9> return Restrictions.in(idName, c); <line10> } <line11> } <line12> 	"<line6>      log.warn(""Cannot read idName, defaulting to 'id'"", e);"	task4	
"public class A { <line0> public String decodeSAMLPostResponse(String encodedReponse) { <line1> String trimmed = encodedReponse.replaceAll(""\r\n"", """"); <line2> String base64DecodedResponse = new String(Base64.decodeBase64(trimmed)); <line3> return base64DecodedResponse; <line4> } <line5> } <line6> "	"<line3>    LOG.debug(""Decoded SAML: \n{}\n"", base64DecodedResponse);"	task4	
public class A { <line0> void initValue() { <line1> String effectiveKey = doUpdateFinalValue(); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""config inited, \""{}\"" set to {}, effective key is \""{}\""."",joinedPriorityKeys,finalValue,effectiveKey);"	task4	
"public class A { <line0> @Override <line1> public LayoutPageTemplateEntry findByG_LPTEK(long groupId, String layoutPageTemplateEntryKey) <line2> throws NoSuchPageTemplateEntryException { <line3> LayoutPageTemplateEntry layoutPageTemplateEntry = <line4> fetchByG_LPTEK(groupId, layoutPageTemplateEntryKey); <line5> if (layoutPageTemplateEntry == null) { <line6> StringBundler sb = new StringBundler(6); <line7> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line8> sb.append(""groupId=""); <line9> sb.append(groupId); <line10> sb.append("", layoutPageTemplateEntryKey=""); <line11> sb.append(layoutPageTemplateEntryKey); <line12> sb.append(""}""); <line13> if (log.isDebugEnabled()) { <line14> } <line15> throw new NoSuchPageTemplateEntryException(sb.toString()); <line16> } <line17> return layoutPageTemplateEntry; <line18> } <line19> } <line20> "	<line14>        log.debug(sb.toString());	task4	
public class A { <line0> @Override <line1> public Operator run() { <line2> long start = System.currentTimeMillis(); <line3> UResultOperator uResultOperator = new UResultOperator(_planNode.run()); <line4> long end = System.currentTimeMillis(); <line5> return uResultOperator; <line6> } <line7> } <line8> 	"<line5>    LOGGER.info(""InstanceResponsePlanNode.run took: "" + (end - start));"	task4	
public class A { <line0> @Override <line1> public IRingSet getConnectedRings(IRing ring) { <line2> return super.getConnectedRings(ring); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting connected rings for ring: "", ring);"	task4	
public class A { <line0> @Override <line1> public void onInterceptorConfig(Interceptors interceptors) { <line2> for (JbootAppListener listener : listeners) { <line3> try { <line4> listener.onInterceptorConfig(interceptors); <line5> } catch (Throwable ex) { <line6> } <line7> } <line8> } <line9> } <line10> 	<line6>        log.error(ex.toString(), ex);	task4	
"public class A { <line0> @RestAccessControl(permission = Permission.SUPERUSER) <line1> @RequestMapping( <line2> value = ""/profileTypeAttributes"", <line3> method = RequestMethod.GET, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<PagedRestResponse<String>> getUserProfileAttributeTypes( <line6> RestListRequest requestList) throws JsonProcessingException { <line7> this.getProfileTypeValidator().validateRestListRequest(requestList, AttributeTypeDto.class); <line8> PagedMetadata<String> result = this.getUserProfileTypeService().getAttributeTypes(requestList); <line9> this.getProfileTypeValidator().validateRestListResult(requestList, result); <line10> return new ResponseEntity<>(new PagedRestResponse<>(result), HttpStatus.OK); <line11> } <line12> } <line13> "	"<line9>    logger.debug(""Main Response -> {}"", result);"	task4	
public class A { <line0> @Override <line1> public List<String> getPrimarySpringFiles() { <line2> final List<String> springFileLocations = new ArrayList<String>(); <line3> springFileLocations.add(KRAD_SPRING_BEANS_PATH); <line4> if (isIncludeKnsSpringBeans()) { <line5> springFileLocations.add(KNS_SPRING_BEANS_PATH); <line6> } <line7> return springFileLocations; <line8> } <line9> } <line10> 	"<line2>    LOG.info(""KRADConfigurer:getPrimarySpringFiles: getRunMode => "" + getRunMode());"	task4	
"public class A { <line0> @Override <line1> public void add(Entry entry) throws LdapException { <line2> if (entry == null) { <line3> String msg = ""Cannot add an empty entry""; <line4> throw new IllegalArgumentException(msg); <line5> } <line6> AddRequest addRequest = new AddRequestImpl(); <line7> addRequest.setEntry(entry); <line8> addRequest.setEntryDn(entry.getDn()); <line9> AddResponse addResponse = add(addRequest); <line10> processResponse(addResponse); <line11> } <line12> } <line13> "	<line4>      LOG.debug(msg);	task4	
public class A { <line0> private void denyListSlowReceiver(CacheClientProxy clientProxy) { <line1> final CacheClientProxy proxy = clientProxy; <line2> if (proxy.getHARegionQueue() != null <line3> && proxy.getHARegionQueue().isClientSlowReceiver() <line4> && !denyListedClients.contains(proxy.getProxyID())) { <line5> addToDenylistedClient(proxy.getProxyID()); <line6> InternalDistributedSystem ids = (InternalDistributedSystem) getCache().getDistributedSystem(); <line7> final DistributionManager dm = ids.getDistributionManager(); <line8> dm.getExecutors() <line9> .getWaitingThreadPool() <line10> .execute( <line11> () -> { <line12> CacheDistributionAdvisor advisor = <line13> proxy.getHARegionQueue().getRegion().getCacheDistributionAdvisor(); <line14> Set<InternalDistributedMember> members = advisor.adviseCacheOp(); <line15> ClientDenylistProcessor.sendDenylistedClient(proxy.getProxyID(), dm, members); <line16> proxy.close(false, false); <line17> removeClientProxy(proxy); <line18> if (PoolImpl.AFTER_QUEUE_DESTROY_MESSAGE_FLAG) { <line19> ClientServerObserver bo = ClientServerObserverHolder.getInstance(); <line20> bo.afterQueueDestroyMessage(); <line21> } <line22> RemoveClientFromDenylistMessage rcm = new RemoveClientFromDenylistMessage(); <line23> rcm.setProxyID(proxy.getProxyID()); <line24> dm.putOutgoing(rcm); <line25> denyListedClients.remove(proxy.getProxyID()); <line26> }); <line27> } <line28> } <line29> } <line30> 	"<line5>      logger.warn(""Client {} is a slow receiver."", new Object[] {proxy.getProxyID()});"	task4	
public class A { <line0> public static void main(String[] args) { <line1> pre(); <line2> AkkaStarter.init(); <line3> VertXStarter.init(); <line4> try { <line5> SpringApplication.run(PowerJobServerApplication.class, args); <line6> } catch (Throwable t) { <line7> throw t; <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(TIPS);	task4	
"public class A { <line0> @Override <line1> @NotNull <line2> public Response executeOperation(@NotNull final AbstractFacet facet) throws Exception { <line3> if (LOG.isInfoEnabled()) { <line4> } <line5> final FacetMetadataModifier facetMetadataModifier = <line6> new FacetMetadataModifier(uid, facetId, comment, tags); <line7> final AbstractFacet modifiedFacet = <line8> apiDataService.createOrReadModifyWrite( <line9> facet.getClass(), <line10> facetMetadataModifier.getFacetFinderQuery(), <line11> facetMetadataModifier, <line12> facet.apiKeyId); <line13> if (modifiedFacet != null) { <line14> return jsonResponseHelper.ok( <line15> ""Metadata updated successfully!"", new FacetMetadata(modifiedFacet)); <line16> } <line17> return jsonResponseHelper.forbidden( <line18> ""User ["" <line19> + uid <line20> + ""] is not allowed to set metadata for facet ["" <line21> + facetId <line22> + ""] for connector ["" <line23> + connectorName <line24> + ""] and object type ["" <line25> + objectTypeName <line26> + ""]""); <line27> } <line28> } <line29> "	"<line4>      LOG.info(""BodyTrackController.setFacetMetadata(): Attempting to set metadata for facet [""+ facetId+ ""] for connector [""+ connectorName+ ""] and object type [""+ objectTypeName+ ""]"");"	task4	
public class A { <line0> public void setLevel(@Nonnull Level level) { <line1> this.level = level; <line2> parent.setLevel(level); <line3> } <line4> } <line5> 	"<line3>    log.info(""Level changed to "" + level.getName());"	task4	
public class A { <line0> public void setLimit(int l) { <line1> if (limit != Integer.MAX_VALUE) { <line2> } else { <line3> limit = l; <line4> } <line5> } <line6> } <line7> 	"<line2>      logger.warn(""Setting limit to {} but in current olap context, the limit is already {}, won't apply"",l,limit);"	task4	
"public class A { <line0> @Override <line1> public Document getNextPage(Document doc) throws IOException { <line2> String nextUrl = """"; <line3> Element elem = doc.select(""li.next > a"").first(); <line4> nextUrl = elem.attr(""href""); <line5> if (nextUrl == """") { <line6> throw new IOException(""No more pages""); <line7> } <line8> return Http.url(""https://eroshare.com"" + nextUrl).get(); <line9> } <line10> } <line11> "	<line4>    logger.info(elem);	task4	
"public class A { <line0> @BeforeClass <line1> public static void prepareMariaDB() throws IllegalStateException { <line2> boolean initDbSuccess = false; <line3> int i = 0; <line4> while (i < INITIALIZE_DB_MAX_RETRY) { <line5> try { <line6> db = DB.newEmbeddedDB(DBConfigurationBuilder.newBuilder().build()); <line7> db.start(); <line8> dbUrl = db.getConfiguration().getURL(DEFAULT_DB_NAME); <line9> connection = DriverManager.getConnection(dbUrl); <line10> try (Statement statement = connection.createStatement()) { <line11> statement.execute(""CREATE DATABASE IF NOT EXISTS `"" + DEFAULT_DB_NAME + ""`;""); <line12> ResultSet resultSet = <line13> statement.executeQuery( <line14> ""SELECT SCHEMA_NAME FROM "" <line15> + ""INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '"" <line16> + DEFAULT_DB_NAME <line17> + ""';""); <line18> if (resultSet.next()) { <line19> String dbName = resultSet.getString(1); <line20> initDbSuccess = DEFAULT_DB_NAME.equalsIgnoreCase(dbName); <line21> } <line22> } <line23> } catch (Exception e) { <line24> stopDb(); <line25> } <line26> if (initDbSuccess) { <line27> break; <line28> } <line29> i++; <line30> } <line31> if (!initDbSuccess) { <line32> throw new IllegalStateException( <line33> String.format( <line34> ""Initialize MySQL database instance failed after %d attempts,"" <line35> + "" please open an issue."", <line36> INITIALIZE_DB_MAX_RETRY)); <line37> } <line38> } <line39> } <line40> "	"<line24>        logger.warn(""Initialize DB failed."", e);"	task4	
public class A { <line0> protected void resotreSessionIfRequired(final LensSessionHandle sessionHandle) { <line1> try { <line2> verifySessionInMemory(sessionHandle); <line3> } catch (LensException e) { <line4> try { <line5> restoreFromDb(sessionHandle); <line6> } catch (LensException le) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        log.warn(""Session  "" + sessionHandle.getPublicId() + "" is invalid."");"	task4	
public class A { <line0> @Override <line1> public PermissionOverwrite run(final Session<?> session) throws BackgroundException { <line2> final UnixPermission feature = session.getFeature(UnixPermission.class); <line3> if (log.isDebugEnabled()) { <line4> } <line5> final List<Permission> permissions = new ArrayList<>(); <line6> for (Path next : files) { <line7> if (this.isCanceled()) { <line8> throw new ConnectionCanceledException(); <line9> } <line10> if (Permission.EMPTY == next.attributes().getPermission()) { <line11> next.attributes().setPermission(feature.getUnixPermission(next)); <line12> } <line13> permissions.add(next.attributes().getPermission()); <line14> } <line15> final PermissionOverwrite overwrite = new PermissionOverwrite(); <line16> final Supplier<Stream<Permission>> supplier = permissions::stream; <line17> overwrite.user.read = <line18> resolveOverwrite(map(supplier, Permission::getUser, Permission.Action.read)); <line19> overwrite.user.write = <line20> resolveOverwrite(map(supplier, Permission::getUser, Permission.Action.write)); <line21> overwrite.user.execute = <line22> resolveOverwrite(map(supplier, Permission::getUser, Permission.Action.execute)); <line23> overwrite.group.read = <line24> resolveOverwrite(map(supplier, Permission::getGroup, Permission.Action.read)); <line25> overwrite.group.write = <line26> resolveOverwrite(map(supplier, Permission::getGroup, Permission.Action.write)); <line27> overwrite.group.execute = <line28> resolveOverwrite(map(supplier, Permission::getGroup, Permission.Action.execute)); <line29> overwrite.other.read = <line30> resolveOverwrite(map(supplier, Permission::getOther, Permission.Action.read)); <line31> overwrite.other.write = <line32> resolveOverwrite(map(supplier, Permission::getOther, Permission.Action.write)); <line33> overwrite.other.execute = <line34> resolveOverwrite(map(supplier, Permission::getOther, Permission.Action.execute)); <line35> return overwrite; <line36> } <line37> } <line38> 	"<line4>      log.debug(String.format(""Run with feature %s"", feature));"	task4	
public class A { <line0> private void encryptRepositoryPasswords( <line1> ApplicationSignUp applicationSignUp, String applicationKey) { <line2> if (applicationSignUp.getArtifactRepositories() != null) { <line3> for (ArtifactRepository artifactRepository : applicationSignUp.getArtifactRepositories()) { <line4> String repoPassword = artifactRepository.getRepoPassword(); <line5> if ((artifactRepository != null) && (StringUtils.isNotBlank(repoPassword))) { <line6> String encryptedRepoPassword = CommonUtil.encryptPassword(repoPassword, applicationKey); <line7> artifactRepository.setRepoPassword(encryptedRepoPassword); <line8> if (log.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	"<line9>            log.debug(String.format(""Artifact repository password encrypted: [application-id] %s ""+ ""[tenant-id] %d [repo-url] %s"",applicationSignUp.getApplicationId(),applicationSignUp.getTenantId(),artifactRepository.getRepoUrl()));"	task4	
public class A { <line0> public void registerOwnedBundles() { <line1> List<OwnedBundle> ownedBundles = new ArrayList<>(ownershipCache.getOwnedBundles().values()); <line2> ownershipCache.invalidateLocalOwnerCache(); <line3> ownedBundles.forEach( <line4> ownedBundle -> { <line5> String path = ServiceUnitUtils.path(ownedBundle.getNamespaceBundle()); <line6> try { <line7> if (!pulsar.getLocalZkCache().checkRegNodeAndWaitExpired(path)) { <line8> ownershipCache.tryAcquiringOwnership(ownedBundle.getNamespaceBundle()); <line9> } <line10> } catch (Exception e) { <line11> try { <line12> ownedBundle.handleUnloadRequest(pulsar, 5, TimeUnit.MINUTES); <line13> } catch (IllegalStateException ex) { <line14> } catch (Exception ex) { <line15> pulsar.getShutdownService().shutdown(-1); <line16> } <line17> } <line18> }); <line19> } <line20> } <line21> 	"<line15>              LOG.error(""Unexpected exception occur when register owned bundle {}. Shutdown broker now""+ "" !!!"",ownedBundle.getNamespaceBundle(),ex);"	task4	
public class A { <line0> public final void start(BundleContext context) throws Exception { <line1> serviceRegistration = <line2> context.registerService( <line3> ProxyTargetLocatorFactory.class, new SpringDMProxyTargetLocatorFactory(), null); <line4> } <line5> } <line6> 	"<line4>    LOGGER.info(""registered Spring DM injection SPI for PAX Wicket."");"	task4	
public class A { <line0> protected final void extractAssertion(Object... arguments) { <line1> if (arguments != null) { <line2> AssertionType assertObj = getAssertion(arguments); <line3> if (assertObj != null) { <line4> assertion = Optional.of(assertObj); <line5> return; <line6> } <line7> } <line8> try { <line9> if (assertion == null || !assertion.isPresent()) { <line10> AssertionType contextAssertion = <line11> SAML2AssertionExtractor.getInstance().extractSamlAssertion(getContext()); <line12> if (contextAssertion != null) { <line13> assertion = Optional.of(contextAssertion); <line14> return; <line15> } <line16> } <line17> } catch (Exception e) { <line18> } <line19> assertion = Optional.absent(); <line20> } <line21> } <line22> 	"<line18>      LOG.warn(""Unable to extract assertion from context."", e);"	task4	
public class A { <line0> private List<ModuleType> getAllModuleTypesFallback(Throwable e) { <line1> e.printStackTrace(); <line2> return null; <line3> } <line4> } <line5> 	"<line1>    log.error(""getAllModuleTypesFallback()"");"	task4	
public class A { <line0> public void registerMBean(final Object object) { <line1> if (MBEAN_SERVER == null || objectName == null) { <line2> return; <line3> } <line4> try { <line5> MBEAN_SERVER.registerMBean(object, objectName); <line6> } catch (LinkageError | Exception e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      log.warn(""Failed to complete JMX registration for "" + objectName, e);"	task4	
public class A { <line0> private ArtistBio getArtistBio(String artistName, Locale locale) { <line1> if (artistName == null) { <line2> return null; <line3> } <line4> Artist info; <line5> try { <line6> info = Artist.getInfo(artistName, locale, null, LAST_FM_KEY); <line7> } catch (CallException e) { <line8> if (LOG.isWarnEnabled()) { <line9> } <line10> return null; <line11> } <line12> if (info == null) { <line13> return null; <line14> } <line15> return new ArtistBio( <line16> processWikiText(info.getWikiSummary()), <line17> info.getMbid(), <line18> info.getUrl(), <line19> info.getImageURL(ImageSize.MEDIUM), <line20> info.getImageURL(ImageSize.LARGE), <line21> info.getImageURL(ImageSize.MEGA)); <line22> } <line23> } <line24> 	"<line9>        LOG.warn(""Failed to find artist bio for "" + artistName, e);"	task4	
"public class A { <line0> protected void loadConf(Configuration conf) { <line1> this.slop = normalizeSlop(conf.getFloat(""hbase.regions.slop"", getDefaultSlop())); <line2> this.rackManager = new RackManager(conf); <line3> useRegionFinder = conf.getBoolean(""hbase.master.balancer.uselocality"", true); <line4> if (useRegionFinder) { <line5> regionFinder = createRegionLocationFinder(conf); <line6> } else { <line7> regionFinder = null; <line8> } <line9> this.isByTable = conf.getBoolean(HConstants.HBASE_MASTER_LOADBALANCE_BYTABLE, isByTable); <line10> } <line11> } <line12> "	"<line10>    LOG.info(""slop={}"", this.slop);"	task4	
public class A { <line0> @Override <line1> protected void sendProxyRequest( <line2> HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Request proxyRequest) { <line3> proxyRequest.timeout(httpClientConfig.getReadTimeout().getMillis(), TimeUnit.MILLISECONDS); <line4> proxyRequest.idleTimeout(httpClientConfig.getReadTimeout().getMillis(), TimeUnit.MILLISECONDS); <line5> byte[] avaticaQuery = (byte[]) clientRequest.getAttribute(AVATICA_QUERY_ATTRIBUTE); <line6> if (avaticaQuery != null) { <line7> proxyRequest.content(new BytesContentProvider(avaticaQuery)); <line8> } <line9> final Query query = (Query) clientRequest.getAttribute(QUERY_ATTRIBUTE); <line10> if (query != null) { <line11> final ObjectMapper objectMapper = <line12> (ObjectMapper) clientRequest.getAttribute(OBJECTMAPPER_ATTRIBUTE); <line13> try { <line14> byte[] bytes = objectMapper.writeValueAsBytes(query); <line15> proxyRequest.content(new BytesContentProvider(bytes)); <line16> proxyRequest.getHeaders().put(HttpHeader.CONTENT_LENGTH, String.valueOf(bytes.length)); <line17> } catch (JsonProcessingException e) { <line18> throw new RuntimeException(e); <line19> } <line20> } <line21> clientRequest.setAttribute(AuthConfig.DRUID_AUTHORIZATION_CHECKED, true); <line22> AuthenticationResult authenticationResult = <line23> (AuthenticationResult) clientRequest.getAttribute(AuthConfig.DRUID_AUTHENTICATION_RESULT); <line24> if (authenticationResult != null && authenticationResult.getAuthenticatedBy() != null) { <line25> Authenticator authenticator = <line26> authenticatorMapper.getAuthenticatorMap().get(authenticationResult.getAuthenticatedBy()); <line27> if (authenticator != null) { <line28> authenticator.decorateProxyRequest(clientRequest, proxyResponse, proxyRequest); <line29> } else { <line30> } <line31> } <line32> super.sendProxyRequest(clientRequest, proxyResponse, proxyRequest); <line33> } <line34> } <line35> 	"<line30>        log.error(""Can not find Authenticator with Name [%s]"", authenticationResult.getAuthenticatedBy());"	task4	
"public class A { <line0> @ExceptionHandler(HttpMessageNotReadableException.class) <line1> @ResponseStatus(HttpStatus.BAD_REQUEST) <line2> @ResponseBody <line3> public ValidationErrorResponse handleHttpMessageNotReadableException( <line4> HttpMessageNotReadableException e) { <line5> ValidationErrorResponse error = new ValidationErrorResponse(); <line6> error.getViolations().add(new Violation("""", ""request body is required"")); <line7> return error; <line8> } <line9> } <line10> "	"<line5>    logger.error(""request failed with HttpMessageNotReadableException"", e);"	task4	
"public class A { <line0> @RequestMapping(""/adminDashboard/updateUserDetails.do"") <line1> public ModelAndView updateProfileDetails(HttpServletRequest request, UserBO userBO) { <line2> logger.entry(""begin updateProfileDetails()""); <line3> ModelAndView mav = new ModelAndView(); <line4> Integer userId = null; <line5> String message = FdahpStudyDesignerConstants.FAILURE; <line6> Map<String, String> propMap = FdahpStudyDesignerUtil.getAppProperties(); <line7> try { <line8> HttpSession session = request.getSession(); <line9> SessionObject userSession = <line10> (SessionObject) session.getAttribute(FdahpStudyDesignerConstants.SESSION_OBJECT); <line11> userBO.setModifiedBy(userSession.getUserId()); <line12> userBO.setModifiedOn(FdahpStudyDesignerUtil.getCurrentDateTime()); <line13> userId = userSession.getUserId(); <line14> message = dashBoardAndProfileService.updateProfileDetails(userBO, userId, userSession); <line15> if (message.equals(FdahpStudyDesignerConstants.SUCCESS)) { <line16> userSession.setFirstName( <line17> FdahpStudyDesignerUtil.isEmpty(userBO.getFirstName()) <line18> ? userSession.getFirstName() <line19> : userBO.getFirstName()); <line20> userSession.setLastName( <line21> FdahpStudyDesignerUtil.isEmpty(userBO.getLastName()) <line22> ? userSession.getLastName() <line23> : userBO.getLastName()); <line24> userSession.setEmail( <line25> FdahpStudyDesignerUtil.isEmpty(userBO.getUserEmail()) <line26> ? userSession.getEmail() <line27> : userBO.getUserEmail()); <line28> request.setAttribute(FdahpStudyDesignerConstants.SESSION_OBJECT, userSession); <line29> } <line30> if (FdahpStudyDesignerConstants.SUCCESS.equals(message)) { <line31> request <line32> .getSession() <line33> .setAttribute( <line34> FdahpStudyDesignerConstants.SUC_MSG, propMap.get(""update.profile.success.message"")); <line35> } else { <line36> request <line37> .getSession() <line38> .setAttribute( <line39> FdahpStudyDesignerConstants.ERR_MSG, propMap.get(""update.profile.error.message"")); <line40> } <line41> mav = new ModelAndView(""redirect:/adminDashboard/viewUserDetails.do""); <line42> } catch (Exception e) { <line43> } <line44> logger.exit(""Exit Point: updateProfileDetails()""); <line45> return mav; <line46> } <line47> } <line48> "	"<line43>      logger.error(""DashBoardAndProfileController:  updateProfileDetails()' = "", e);"	task4	
public class A { <line0> @Test <line1> public void pausedDoesNotAppend() { <line2> alertAppender.pause(); <line3> assertThat(alertAppender.getLogEvents()).isEmpty(); <line4> } <line5> } <line6> 	<line3>    logger.warn(logMessage);	task4	
public class A { <line0> public void addAll( <line1> final String index, <line2> final List<Map<String, Object>> docList, <line3> final BiConsumer<Map<String, Object>, IndexRequestBuilder> options) { <line4> final FessConfig fessConfig = ComponentUtil.getFessConfig(); <line5> final BulkRequestBuilder bulkRequestBuilder = client.prepareBulk(); <line6> for (final Map<String, Object> doc : docList) { <line7> final Object id = doc.remove(fessConfig.getIndexFieldId()); <line8> final IndexRequestBuilder builder = <line9> client.prepareIndex().setIndex(index).setId(id.toString()).setSource(new DocMap(doc)); <line10> options.accept(doc, builder); <line11> bulkRequestBuilder.add(builder); <line12> } <line13> final BulkResponse response = <line14> bulkRequestBuilder.execute().actionGet(ComponentUtil.getFessConfig().getIndexBulkTimeout()); <line15> if (response.hasFailures()) { <line16> if (logger.isDebugEnabled()) { <line17> final List<DocWriteRequest<?>> requests = bulkRequestBuilder.request().requests(); <line18> final BulkItemResponse[] items = response.getItems(); <line19> if (requests.size() == items.length) { <line20> for (int i = 0; i < requests.size(); i++) { <line21> final BulkItemResponse resp = items[i]; <line22> if (resp.isFailed() && resp.getFailure() != null) { <line23> final DocWriteRequest<?> req = requests.get(i); <line24> final Failure failure = resp.getFailure(); <line25> } <line26> } <line27> } <line28> } <line29> throw new SearchEngineClientException(response.buildFailureMessage()); <line30> } <line31> } <line32> } <line33> 	"<line25>              logger.debug(""Failed Request: {}\n=>{}"", req, failure.getMessage());"	task4	
public class A { <line0> private static void runCommandServer() throws Exception { <line1> ServerSocket ss = null; <line2> boolean listening = true; <line3> try { <line4> ss = new ServerSocket(port); <line5> } catch (IOException e) { <line6> System.exit(-1); <line7> } <line8> while (listening) new CommandThread<Object>(prevayler, ss.accept()).start(); <line9> ss.close(); <line10> } <line11> } <line12> 	"<line6>      Log.error(e, ""Couldn't open command server port: "" + port);"	task4	
"public class A { <line0> public boolean isConnected(final IPushNode<?> node) { <line1> Args.notNull(node, ""node""); <line2> if (node instanceof TimerPushNode) { <line3> final PushNodeState<?> state = _nodeStates.get(node); <line4> if (state == null) return false; <line5> synchronized (state) { <line6> if (state.isTimedOut()) { <line7> onDisconnect(state.node); <line8> return false; <line9> } <line10> } <line11> return true; <line12> } <line13> return false; <line14> } <line15> } <line16> "	"<line13>    LOG.warn(""Unsupported push node type {}"", node);"	task4	
public class A { <line0> private Collection<TestCaseResult> evaluateTestCaseGroup( <line1> TestSource testSource, TestCaseGroup testCase) { <line2> Collection<TestCaseResult> internalResults = <line3> testCase.getTestCases().stream() <line4> .flatMap(gt -> executeGenericTest(testSource, gt).stream()) <line5> .collect(Collectors.toList()); <line6> if (testCase.getLogicalOperator() != SHACL.LogicalConstraint.atomic <line7> && this.getExecutionType() != TestCaseExecutionType.shaclLiteTestCaseResult <line8> && this.getExecutionType() != TestCaseExecutionType.shaclTestCaseResult) { <line9> return Collections.emptyList(); <line10> } else { <line11> return testCase.evaluateInternalResults(internalResults); <line12> } <line13> } <line14> } <line15> 	"<line9>      log.warn(""Logical constraints evaluation is not supported by the current execution type: ""+ this.getExecutionType());"	task4	
"public class A { <line0> @Override <line1> public List<Integer> loadBpmWidgetInfos() { <line2> List<Integer> bpmWidgetInfosId = new ArrayList<Integer>(); <line3> Connection conn = null; <line4> PreparedStatement stat = null; <line5> ResultSet res = null; <line6> try { <line7> conn = this.getConnection(); <line8> stat = conn.prepareStatement(LOAD_BPMWIDGETINFOS_ID); <line9> res = stat.executeQuery(); <line10> while (res.next()) { <line11> int id = res.getInt(""id""); <line12> bpmWidgetInfosId.add(id); <line13> } <line14> } catch (Throwable t) { <line15> throw new RuntimeException(""Error loading BpmWidgetInfo list"", t); <line16> } finally { <line17> closeDaoResources(res, stat, conn); <line18> } <line19> return bpmWidgetInfosId; <line20> } <line21> } <line22> "	"<line15>      logger.error(""Error loading BpmWidgetInfo list"", t);"	task4	
"public class A { <line0> @DELETE <line1> @Path(""/acl/{aclId}"") <line2> @RestQuery( <line3> name = ""deleteacl"", <line4> description = ""Delete an ACL"", <line5> returnDescription = ""Delete an ACL"", <line6> pathParameters = { <line7> @RestParameter( <line8> name = ""aclId"", <line9> isRequired = true, <line10> description = ""The ACL identifier"", <line11> type = INTEGER) <line12> }, <line13> responses = { <line14> @RestResponse(responseCode = SC_OK, description = ""The ACL has successfully been deleted""), <line15> @RestResponse(responseCode = SC_NOT_FOUND, description = ""The ACL has not been found""), <line16> @RestResponse( <line17> responseCode = SC_CONFLICT, <line18> description = ""The ACL could not be deleted, there are still references on it""), <line19> @RestResponse( <line20> responseCode = SC_INTERNAL_SERVER_ERROR, <line21> description = ""Error during deleting the ACL"") <line22> }) <line23> public Response deleteAcl(@PathParam(""aclId"") long aclId) throws NotFoundException { <line24> try { <line25> if (!aclService().deleteAcl(aclId)) { <line26> return conflict(); <line27> } <line28> } catch (AclServiceException e) { <line29> throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR); <line30> } <line31> return noContent(); <line32> } <line33> } <line34> "	"<line29>      logger.warn(""Error deleting manged acl with id '{}': {}"", aclId, e);"	task4	
public class A { <line0> @Override <line1> public synchronized void start() { <line2> for (TableDataManager tableDataManager : _tableDataManagerMap.values()) { <line3> tableDataManager.start(); <line4> } <line5> _isStarted = true; <line6> } <line7> } <line8> 	"<line6>    LOGGER.info(""InstanceDataManager is started! "" + getServerInfo());"	task4	
public class A { <line0> @Override <line1> protected double getCurrentRate() { <line2> CollectionProperty data = arrivalsTG.getData(); <line3> PropertyIterator it = data.iterator(); <line4> int offset = 0; <line5> while (it.hasNext()) { <line6> CollectionProperty record = (CollectionProperty) it.next(); <line7> double chunkLen = record.get(2).getDoubleValue() * arrivalsTG.getUnitFactor(); <line8> double timeProgress = this.rollingTime / 1000.0 - startTime; <line9> double chunkProgress = (timeProgress - offset) / chunkLen; <line10> offset += chunkLen; <line11> if (timeProgress <= offset) { <line12> double chunkStart = record.get(0).getDoubleValue() / arrivalsTG.getUnitFactor(); <line13> double chunkEnd = record.get(1).getDoubleValue() / arrivalsTG.getUnitFactor(); <line14> double chunkHeight = chunkEnd - chunkStart; <line15> return chunkStart + chunkProgress * chunkHeight; <line16> } <line17> } <line18> return -1; <line19> } <line20> } <line21> 	"<line18>    log.info(""Got no further schedule, can stop now"");"	task4	
public class A { <line0> public int send(@NotNull RawMercuryRequest request, @NotNull Callback callback) <line1> throws IOException { <line2> ByteArrayOutputStream bytesOut = new ByteArrayOutputStream(); <line3> DataOutputStream out = new DataOutputStream(bytesOut); <line4> int seq; <line5> synchronized (seqHolder) { <line6> seq = seqHolder.getAndIncrement(); <line7> } <line8> out.writeShort((short) 4); <line9> out.writeInt(seq); <line10> out.writeByte(1); <line11> out.writeShort(1 + request.payload.length); <line12> byte[] headerBytes = request.header.toByteArray(); <line13> out.writeShort(headerBytes.length); <line14> out.write(headerBytes); <line15> for (byte[] part : request.payload) { <line16> out.writeShort(part.length); <line17> out.write(part); <line18> } <line19> Packet.Type cmd = Packet.Type.forMethod(request.header.getMethod()); <line20> session.send(cmd, bytesOut.toByteArray()); <line21> callbacks.put((long) seq, callback); <line22> return seq; <line23> } <line24> } <line25> 	"<line8>    LOGGER.trace(""Send Mercury request, seq: {}, uri: {}, method: {}"",seq,request.header.getUri(),request.header.getMethod());"	task4	
public class A { <line0> public synchronized boolean remove(K key) throws IOException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> boolean removed = false; <line4> if (key instanceof String && ((String) key).endsWith(CacheConstants.NAME_COMPONENT_DELIMITER)) { <line5> synchronized (map) { <line6> for (Iterator itr = map.entrySet().iterator(); itr.hasNext(); ) { <line7> Map.Entry entry = (Map.Entry) itr.next(); <line8> Object k = entry.getKey(); <line9> if (k instanceof String && ((String) k).startsWith(key.toString())) { <line10> itr.remove(); <line11> removed = true; <line12> } <line13> } <line14> } <line15> } else if (key instanceof GroupId) { <line16> synchronized (map) { <line17> for (Iterator itr = map.entrySet().iterator(); itr.hasNext(); ) { <line18> Map.Entry entry = (Map.Entry) itr.next(); <line19> Object k = entry.getKey(); <line20> if (k instanceof GroupAttrName && ((GroupAttrName) k).groupId.equals(key)) { <line21> itr.remove(); <line22> removed = true; <line23> } <line24> } <line25> } <line26> } else { <line27> ICacheElement<K, V> ce = (ICacheElement) map.remove(key); <line28> removed = true; <line29> } <line30> return removed; <line31> } <line32> } <line33> 	"<line2>      log.debug(""removing item for key: "" + key);"	task4	
"public class A { <line0> @Override <line1> public void createOrReplaceFunction( <line2> String schemaName, String functionName, Supplier<String> supplier) { <line3> final String objectName = DataDefinitionUtil.getQualifiedName(schemaName, functionName); <line4> final StringBuilder ddl = <line5> new StringBuilder() <line6> .append(""CREATE OR REPLACE FUNCTION "") <line7> .append(objectName) <line8> .append(System.lineSeparator()) <line9> .append(supplier.get()); <line10> final String ddlString = ddl.toString(); <line11> if (logger.isLoggable(Level.FINE)) { <line12> logger.fine(ddlString); <line13> } <line14> runStatement(ddlString); <line15> } <line16> } <line17> "	"<line4>    logger.info(""Create or replace function "" + objectName);"	task4	
"public class A { <line0> public void set(Position newPosition) throws SQLException, DuplicateProcessException { <line1> if (newPosition == null) return; <line2> Long heartbeat = newPosition.getLastHeartbeatRead(); <line3> String sql = <line4> ""INSERT INTO `positions` set "" <line5> + ""server_id = ?, "" <line6> + ""gtid_set = ?, "" <line7> + ""binlog_file = ?, "" <line8> + ""binlog_position = ?, "" <line9> + ""last_heartbeat_read = ?, "" <line10> + ""client_id = ? "" <line11> + ""ON DUPLICATE KEY UPDATE "" <line12> + ""last_heartbeat_read = ?, "" <line13> + ""gtid_set = ?, binlog_file = ?, binlog_position=?""; <line14> BinlogPosition binlogPosition = newPosition.getBinlogPosition(); <line15> connectionPool.withSQLRetry( <line16> 1, <line17> (c) -> { <line18> PreparedStatement s = c.prepareStatement(sql); <line19> s.setLong(1, serverID); <line20> s.setString(2, binlogPosition.getGtidSetStr()); <line21> s.setString(3, binlogPosition.getFile()); <line22> s.setLong(4, binlogPosition.getOffset()); <line23> s.setLong(5, heartbeat); <line24> s.setString(6, clientID); <line25> s.setLong(7, heartbeat); <line26> s.setString(8, binlogPosition.getGtidSetStr()); <line27> s.setString(9, binlogPosition.getFile()); <line28> s.setLong(10, binlogPosition.getOffset()); <line29> s.execute(); <line30> }); <line31> } <line32> } <line33> "	"<line19>          LOGGER.debug(""Writing binlog position to {}.positions: {}, last heartbeat read: {}"",c.getCatalog(),newPosition,heartbeat);"	task4	
"public class A { <line0> public static com.liferay.bookmarks.model.BookmarksEntry addEntry( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> long folderId, <line4> String name, <line5> String url, <line6> String description, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(BookmarksEntryServiceUtil.class, ""addEntry"", _addEntryParameterTypes0); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, groupId, folderId, name, url, description, serviceContext); <line14> Object returnObj = null; <line15> try { <line16> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line17> } catch (Exception exception) { <line18> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line19> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line20> } <line21> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line22> } <line23> return (com.liferay.bookmarks.model.BookmarksEntry) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line25> throw systemException; <line26> } <line27> } <line28> } <line29> "	<line25>      log.error(systemException, systemException);	task4	
"public class A { <line0> public String createMessage(Command c) { <line1> String message = null; <line2> String page = null; <line3> String behavior = null; <line4> String relay = null; <line5> if (c.getProperty(""command"").equals(""RELAY"")) { <line6> relay = HexIntConverter.convert(Integer.parseInt(address[2]) - 1); <line7> if (c.getProperty(""behavior"").equals(""on"")) { <line8> behavior = ""1""; <line9> } <line10> if (c.getProperty(""behavior"").equals(""off"")) { <line11> behavior = ""0""; <line12> } <line13> page = ""forms.htm?led"" + relay + ""="" + behavior; <line14> } <line15> if (c.getProperty(""command"").equals(""TOGGLE"")) { <line16> relay = address[2]; <line17> int time = Integer.parseInt(c.getProperty(""time-in-ms"")); <line18> int seconds = time / 1000; <line19> String relayLine = configuration.getProperty(""TOGGLE"" + seconds + ""S"" + relay); <line20> page = ""toggle.cgi?toggle="" + relayLine; <line21> } <line22> message = ""GET /"" + page + "" HTTP 1.1\r\n\r\n""; <line23> return (message); <line24> } <line25> } <line26> "	"<line23>    Freedomotic.logger.info(""Sending 'GET /"" + page + "" HTTP 1.1' to relay board"");"	task4	
"public class A { <line0> public CloudWithRelaysResponseDTO getCloudsWithExclusiveGatewayAndPublicRelays( <line1> final String operator, final String name) { <line2> Assert.isTrue(!Utilities.isEmpty(operator), ""operator is null or empty""); <line3> Assert.isTrue(!Utilities.isEmpty(name), ""name is null or empty""); <line4> final UriComponents uri = getGatekeeperGetCloudUri(operator, name); <line5> final ResponseEntity<CloudWithRelaysResponseDTO> response = <line6> httpService.sendRequest(uri, HttpMethod.GET, CloudWithRelaysResponseDTO.class); <line7> return response.getBody(); <line8> } <line9> } <line10> "	"<line2>    logger.debug(""getCloudsWithGatewayAndPublicRelays started..."");"	task4	
public class A { <line0> @Override <line1> public int read(final byte b[], final int off, final int len) throws IOException { <line2> int temp; <line3> try { <line4> temp = fileIOOperations.fileRead(fd, b, off, len); <line5> } catch (JargonException e) { <line6> throw new IOException(e); <line7> } <line8> if (temp > 0) { <line9> filePointer += temp; <line10> } <line11> return temp; <line12> } <line13> } <line14> 	"<line6>      log.error(""JargonException in read is converted to IOException for method contract"", e);"	task4	
public class A { <line0> protected void addContribution(RepositoryDescriptor cdesc) { <line1> RepositoryDescriptor descriptor = getRepositoryDescriptor(cdesc); <line2> SQLRepositoryService sqlRepositoryService = <line3> Framework.getLocalService(SQLRepositoryService.class); <line4> sqlRepositoryService.addContribution(descriptor); <line5> } <line6> } <line7> 	"<line1>    log.warn(""Using old-style extension point""+ "" org.nuxeo.ecm.core.repository.RepositoryService""+ "" for repository \""""+ cdesc.name+ ""\"", use org.nuxeo.ecm.core.storage.sql.RepositoryService instead"");"	task4	
"public class A { <line0> public String getDeviceIpAddressFromSessionProvider(final DlmsDevice dlmsDevice) <line1> throws OsgpException { <line2> final SessionProvider sessionProvider = <line3> this.sessionProviderService.getSessionProvider(dlmsDevice.getCommunicationProvider()); <line4> String deviceIpAddress; <line5> try { <line6> deviceIpAddress = sessionProvider.getIpAddress(dlmsDevice.getIccId()); <line7> if (deviceIpAddress != null) { <line8> return deviceIpAddress; <line9> } <line10> this.jasperWirelessSmsClient.sendWakeUpSMS(dlmsDevice.getIccId()); <line11> deviceIpAddress = this.pollForSession(sessionProvider, dlmsDevice); <line12> } catch (final SessionProviderException e) { <line13> throw new FunctionalException( <line14> FunctionalExceptionType.INVALID_ICCID, ComponentType.PROTOCOL_DLMS, e); <line15> } <line16> if ((deviceIpAddress == null) || """".equals(deviceIpAddress)) { <line17> throw new ProtocolAdapterException( <line18> ""Session provider: "" <line19> + dlmsDevice.getCommunicationProvider() <line20> + "" did not return an IP address for device: "" <line21> + dlmsDevice.getDeviceIdentification() <line22> + ""and iccId: "" <line23> + dlmsDevice.getIccId()); <line24> } <line25> return deviceIpAddress; <line26> } <line27> } <line28> "	"<line13>      LOGGER.error(""IccId is probably not supported in this session provider"", e);"	task4	
"public class A { <line0> @Override <line1> public Runnable prepareFlush() { <line2> if (activityFieldStore == null) { <line3> return new Runnable() { <line4> public void run() {} <line5> }; <line6> } <line7> if (activityFieldStore.isClosed()) { <line8> throw new IllegalStateException(""The activityFile is closed""); <line9> } <line10> final UpdateBatch<AtomicFieldUpdate> oldBatch = updateBatch; <line11> updateBatch = new UpdateBatch<AtomicFieldUpdate>(activityConfig); <line12> return new Runnable() { <line13> public void run() { <line14> try { <line15> if (activityFieldStore.isClosed()) { <line16> throw new IllegalStateException(""The activityFile is closed""); <line17> } <line18> activityFieldStore.flush(oldBatch.getUpdates()); <line19> } catch (Exception ex) { <line20> } <line21> } <line22> }; <line23> } <line24> } <line25> "	"<line20>          logger.error(""Failure to store the field values to file"" + oldBatch.getUpdates(), ex);"	task4	
public class A { <line0> public synchronized void setParameter(final String name, final Object value) { <line1> if (this.parameters == null) { <line2> this.parameters = new HashMap(); <line3> } <line4> this.parameters.put(name, value); <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.debug(""Set parameter "" + name + "" = "" + value);"	task4	
public class A { <line0> public String getLogicalName(AProject project) { <line1> ProjectDescriptor pd = null; <line2> try { <line3> pd = getProjectDescriptor(project); <line4> } catch (Exception e) { <line5> } <line6> if (pd != null) { <line7> return pd.getName(); <line8> } <line9> String actualPath = project.getRealPath(); <line10> return actualPath.substring(actualPath.lastIndexOf('/') + 1); <line11> } <line12> } <line13> 	"<line5>      log.warn(""Cannot get project descriptor for project '{}'. Physical project name will be used.""+ "" Cause: {}"",project.getName(),e.getMessage(),e);"	task4	
public class A { <line0> @Override <line1> public void completed(HttpClientCallbackResult result) { <line2> if (checkResultIsEmpty(result)) { <line3> initApp(id, appName); <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.info(this, ""AppHubInit CHECK APP done :uavapp_"" + appName + "" EXIST"");"	task4	
"public class A { <line0> public UserId getRandomBuyerId(Histogram<UserId> previousBidders, UserId... exclude) { <line1> tmp_userIdHistogram.clear(); <line2> tmp_userIdHistogram.putHistogram(previousBidders); <line3> for (UserId ex : exclude) tmp_userIdHistogram.removeAll(ex); <line4> tmp_userIdHistogram.put(this.getRandomBuyerId(exclude)); <line5> try { <line6> } catch (NullPointerException ex) { <line7> for (UserId user_id : tmp_userIdHistogram.values()) { <line8> System.err.println( <line9> String.format( <line10> ""%s => NEW:%s / ORIG:%s"", <line11> user_id, tmp_userIdHistogram.get(user_id), previousBidders.get(user_id))); <line12> } <line13> throw ex; <line14> } <line15> FlatHistogram<UserId> rand_h = new FlatHistogram<UserId>(rng, tmp_userIdHistogram); <line16> return (rand_h.nextValue()); <line17> } <line18> } <line19> "	"<line6>      LOG.trace(""New Histogram:\n"" + tmp_userIdHistogram);"	task4	
public class A { <line0> @Override <line1> @NonNullByDefault({}) <line2> public void handleStandaloneElement( <line3> final @Nullable String elementName, <line4> final @Nullable Map<String, String> attributes, <line5> final boolean minimized, <line6> final int line, <line7> final int col) <line8> throws ParseException { <line9> } <line10> } <line11> 	"<line9>    logger.debug(""Unexpected StandaloneElement in {}:{}: {} [{}]"", line, col, elementName, attributes);"	task4	
public class A { <line0> protected final Connection allocateConnection(ConnectionRequestInfo connRequestInfo) <line1> throws ResourceException { <line2> Connection connection = <line3> (Connection) <line4> this.connectionManager.allocateConnection( <line5> this.managedConnectionFactory, connRequestInfo); <line6> return connection; <line7> } <line8> } <line9> 	"<line2>    logger.debug(""allocateConnection(connRequestInfo)..."");"	task4	
"public class A { <line0> @Override <line1> public Set<MetricNameDto> getMetricNames(List<TaskDataDto> tests) { <line2> Set<Long> taskIds = new HashSet<>(); <line3> Set<String> sessionIds = new HashSet<>(); <line4> for (TaskDataDto tdd : tests) { <line5> taskIds.addAll(tdd.getIds()); <line6> sessionIds.addAll(tdd.getSessionIds()); <line7> } <line8> long temp = System.currentTimeMillis(); <line9> Set<MetricNameDto> validators = getValidatorsNamesNewModel(tests); <line10> if (validators == null) { <line11> List<Object[]> validatorNames = <line12> entityManager <line13> .createNativeQuery( <line14> ""SELECT v.validator, selected.taskdataID FROM ValidationResultEntity v JOIN ( "" <line15> + "" SELECT wd.workloaddataID, td.taskdataID FROM     (       SELECT wd.id AS"" <line16> + "" workloaddataID, wd.taskId, wd.sessionId FROM WorkloadData wd WHERE"" <line17> + "" wd.sessionId IN (:sessionIds)    ) AS wd JOIN       (       SELECT td.id"" <line18> + "" AS taskdataID, td.taskId, td.sessionId FROM TaskData td WHERE td.id IN"" <line19> + "" (:taskIds)    ) AS td ON wd.taskId=td.taskId AND"" <line20> + "" wd.sessionId=td.sessionId) AS selected ON"" <line21> + "" v.workloadData_id=selected.workloaddataID"") <line22> .setParameter(""taskIds"", taskIds) <line23> .setParameter(""sessionIds"", sessionIds) <line24> .getResultList(); <line25> validators = new HashSet<>(validatorNames.size()); <line26> for (Object[] name : validatorNames) { <line27> if (name == null || name[0] == null) continue; <line28> for (TaskDataDto td : tests) { <line29> if (td.getIds().contains(((BigInteger) name[1]).longValue())) { <line30> MetricNameDto metric = new MetricNameDto(); <line31> metric.setTest(td); <line32> metric.setMetricName((String) name[0]); <line33> metric.setOrigin(MetricNameDto.Origin.VALIDATOR); <line34> validators.add(metric); <line35> break; <line36> } <line37> } <line38> } <line39> } <line40> return validators; <line41> } <line42> } <line43> "	"<line25>      log.debug(""{} ms spent for fetching {} validators"",System.currentTimeMillis() - temp,validatorNames.size());"	task4	
public class A { <line0> @Override <line1> public XDRAcknowledgementType provideAndRegisterDocumentSetBAsyncResponse( <line2> RegistryResponseType request, AssertionType assertion, NhinTargetCommunitiesType targets) { <line3> XDRAcknowledgementType ack = new XDRAcknowledgementType(); <line4> RegistryResponseType regResp = new RegistryResponseType(); <line5> regResp.setStatus(NhincConstants.XDR_RESP_ACK_STATUS_MSG); <line6> ack.setMessage(regResp); <line7> return ack; <line8> } <line9> } <line10> 	"<line3>    LOG.trace(""Using NoOp Implementation for Entity Doc Submission Deferred Response Service"");"	task4	
public class A { <line0> @Override <line1> public void onSuccess(TbQueueMsgMetadata metadata) { <line2> } <line3> } <line4> 	"<line2>    log.debug(""Successfully send ENTITY_CREATED EVENT to rule engine [{}]"", device);"	task4	
public class A { <line0> @Override <line1> public String getExternalUrlForResources( <line2> String resourceId, List<String> resourcePaths, Locale locale) { <line3> LocaleProvider localeProvider = new LocaleProviderImpl(locale); <line4> Resource resource = getResourceForPaths(resourceId, resourcePaths, localeProvider); <line5> if (resource == null) { <line6> return null; <line7> } <line8> if (_debug) refreshResource(resource); <line9> return resource.getExternalUrl(); <line10> } <line11> } <line12> 	"<line6>      log.warn(""resource not found: "" + resourceId);"	task4	
"public class A { <line0> @Override <line1> public WikiPage findByG_ERC_V(long groupId, String externalReferenceCode, double version) <line2> throws NoSuchPageException { <line3> WikiPage wikiPage = fetchByG_ERC_V(groupId, externalReferenceCode, version); <line4> if (wikiPage == null) { <line5> StringBundler sb = new StringBundler(8); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""groupId=""); <line8> sb.append(groupId); <line9> sb.append("", externalReferenceCode=""); <line10> sb.append(externalReferenceCode); <line11> sb.append("", version=""); <line12> sb.append(version); <line13> sb.append(""}""); <line14> if (log.isDebugEnabled()) { <line15> } <line16> throw new NoSuchPageException(sb.toString()); <line17> } <line18> return wikiPage; <line19> } <line20> } <line21> "	<line15>        log.debug(sb.toString());	task4	
public class A { <line0> protected void renderRequestStatus( <line1> PortletRequest request, MimeResponse response, RequestStatus requestStatus) { <line2> JSONObject jsonObject = JSONFactoryUtil.createJSONObject(); <line3> jsonObject.put(PortalConstants.RESULT, requestStatus.toString()); <line4> try { <line5> writeJSON(request, response, jsonObject); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      log.error(""Problem rendering RequestStatus"", e);"	task4	
public class A { <line0> @Override <line1> public ResultSubpartitionView createSubpartitionView( <line2> ResultPartitionID partitionId, <line3> int subpartitionIndex, <line4> BufferAvailabilityListener availabilityListener) <line5> throws IOException { <line6> final ResultSubpartitionView subpartitionView; <line7> synchronized (registeredPartitions) { <line8> final ResultPartition partition = registeredPartitions.get(partitionId); <line9> if (partition == null) { <line10> throw new PartitionNotFoundException(partitionId); <line11> } <line12> subpartitionView = partition.createSubpartitionView(subpartitionIndex, availabilityListener); <line13> } <line14> return subpartitionView; <line15> } <line16> } <line17> 	"<line12>      LOG.debug(""Requesting subpartition {} of {}."", subpartitionIndex, partition);"	task4	
"public class A { <line0> private void validateSidRequestParameter(String sid, String postLogoutRedirectUri) { <line1> if (StringUtils.isNotBlank(sid)) { <line2> SessionId sessionIdObject = sessionIdService.getSessionBySid(sid); <line3> if (sessionIdObject == null) { <line4> final String reason = <line5> ""sid parameter in request is not valid. Logout is rejected. sid parameter in request"" <line6> + "" can be skipped or otherwise valid value must be provided.""; <line7> throw new WebApplicationException( <line8> createErrorResponse( <line9> postLogoutRedirectUri, <line10> EndSessionErrorResponseType.INVALID_GRANT_AND_SESSION, <line11> reason)); <line12> } <line13> } <line14> } <line15> } <line16> "	<line7>        log.error(reason);	task4	
public class A { <line0> public static void getEndpointProperties( <line1> CamelContext camelContext, <line2> FacebookEndpointConfiguration configuration, <line3> Map<String, Object> properties) { <line4> BeanIntrospection beanIntrospection = <line5> camelContext.adapt(ExtendedCamelContext.class).getBeanIntrospection(); <line6> if (beanIntrospection.getProperties(configuration, properties, null, false)) { <line7> final Set<String> names = properties.keySet(); <line8> names.removeAll(COMPONENT_CONFIG_FIELDS); <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> final Set<String> names = properties.keySet(); <line12> } <line13> } <line14> } <line15> 	"<line12>      LOG.debug(""Found endpoint properties {}"", names.retainAll(ENDPOINT_CONFIG_FIELDS));"	task4	
"public class A { <line0> protected List<String> extractElementList(String ext, File baseDir) { <line1> final String extSuffix = ""."" + ext; <line2> final String[] elementList = <line3> baseDir.list( <line4> new FilenameFilter() { <line5> public boolean accept(File dir, String name) { <line6> return Srl.endsWith(name, extSuffix); <line7> } <line8> }); <line9> if (elementList == null) { <line10> return DfCollectionUtil.emptyList(); <line11> } <line12> return DfCollectionUtil.newArrayList(elementList); <line13> } <line14> } <line15> "	"<line10>      log.info(""*Not found the file in the copy src directory: "" + baseDir.getPath());"	task4	
"public class A { <line0> @GET <line1> @Timed <line2> @Path(""{id}"") <line3> @Produces(APPLICATION_JSON_WITH_CHARSET) <line4> public String get( <line5> @Context GraphManager manager, @PathParam(""graph"") String graph, @PathParam(""id"") String id) { <line6> HugeGraph g = graph(manager, graph); <line7> HugeUser user = manager.authManager().getUser(IdGenerator.of(id)); <line8> return manager.serializer(g).writeAuthElement(user); <line9> } <line10> } <line11> "	"<line6>    LOG.debug(""Graph [{}] get user: {}"", graph, id);"	task4	
public class A { <line0> private boolean isBeyondRange(Key lastSeenKey, Key endKey) { <line1> if (lastSeenKey.compareTo(endKey) >= 0) { <line2> return true; <line3> } else { <line4> String cf = lastSeenKey.getColumnQualifier().toString(); <line5> String endCf = endKey.getColumnQualifier().toString(); <line6> if (log.isTraceEnabled()) { <line7> } <line8> if (dateCfLength == cf.length()) { <line9> endCf = endCf.substring(0, dateCfLength); <line10> if (cf.compareTo(endCf) >= 0) { <line11> return true; <line12> } <line13> } <line14> return false; <line15> } <line16> } <line17> } <line18> 	"<line7>        log.trace(cf + "" "" + endCf);"	task4	
"public class A { <line0> public void testRelevanceHashMapInt2StringArrayWay() throws Exception { <line1> String req = <line2> ""{\""sort\"":[\""_score\""],\""query\"":{\""query_string\"":{\""query\"":\""\"",\""relevance\"":{\""model\"":{\""function_params\"":[\""_INNER_SCORE\"",\""thisYear\"",\""year\"",\""goodYear\"",\""mileageWeight\"",\""mileage\"",\""color\"",\""yearcolor\"",\""colorweight\"",\""category\"",\""categorycolor\""],\""facets\"":{\""int\"":[\""year\"",\""mileage\""],\""string\"":[\""color\"",\""category\""],\""long\"":[\""groupid\""]},\""function\"":\""if(yearcolor.containsKey(year)"" <line3> + "" && yearcolor.get(year).equals(color)) return 100000f; if(goodYear.contains(year))"" <line4> + "" return (float)Math.exp(2d);   if(year==thisYear) return 87f   ; return "" <line5> + "" _INNER_SCORE;\"",\""variables\"":{\""map_int_float\"":[\""mileageWeight\""],\""map_int_string\"":[\""yearcolor\""],\""set_int\"":[\""goodYear\""],\""int\"":[\""thisYear\""],\""map_string_float\"":[\""colorweight\""],\""map_string_string\"":[\""categorycolor\""]}},\""values\"":{\""thisYear\"":2001,\""yearcolor\"":{\""value\"":[\""red\""],\""key\"":[1998]},\""mileageWeight\"":{\""value\"":[777.9,10.2],\""key\"":[11400,11000]},\""colorweight\"":{\""value\"":[335.5],\""key\"":[\""red\""]},\""goodYear\"":[1996,1997],\""categorycolor\"":{\""value\"":[\""red\""],\""key\"":[\""compact\""]}}}}},\""fetchStored\"":false,\""from\"":0,\""explain\"":false,\""size\"":6}""; <line6> JSONObject res = search(new JSONObject(req)); <line7> assertEquals(""numhits is wrong"", 15000, res.getInt(""numhits"")); <line8> JSONArray hits = res.getJSONArray(""hits""); <line9> JSONObject firstHit = hits.getJSONObject(0); <line10> JSONObject secondHit = hits.getJSONObject(1); <line11> double firstScore = firstHit.getDouble(""_score""); <line12> double secondScore = secondHit.getDouble(""_score""); <line13> String firstYear = firstHit.getJSONArray(""year"").getString(0); <line14> String secondYear = secondHit.getJSONArray(""year"").getString(0); <line15> String firstColor = firstHit.getJSONArray(""color"").getString(0); <line16> String secondColor = secondHit.getJSONArray(""color"").getString(0); <line17> assertEquals(""inner score for first is not correct."", true, Math.abs(firstScore - 100000) < 1); <line18> assertEquals( <line19> ""inner score for second is not correct."", true, Math.abs(secondScore - 100000) < 1); <line20> assertEquals(""year for first is not correct."", true, Integer.parseInt(firstYear) == 1998); <line21> assertEquals(""year for second is not correct."", true, Integer.parseInt(secondYear) == 1998); <line22> assertEquals(""color for first is not correct."", true, firstColor.equals(""red"")); <line23> assertEquals(""color for second is not correct."", true, secondColor.equals(""red"")); <line24> } <line25> } <line26> "	"<line1>    logger.info(""executing test case testRelevanceHashMapInt2StringArrayWay"");"	task4	
public class A { <line0> @Override <line1> public List<LwM2mObject> findLwM2mObjectPage( <line2> TenantId tenantId, String sortProperty, String sortOrder, PageLink pageLink) { <line3> validateId(tenantId, INCORRECT_TENANT_ID + tenantId); <line4> PageData<TbResource> resourcePageData = <line5> resourceService.findTenantResourcesByResourceTypeAndPageLink( <line6> tenantId, ResourceType.LWM2M_MODEL, pageLink); <line7> return resourcePageData.getData().stream() <line8> .flatMap(s -> Stream.ofNullable(toLwM2mObject(s, false))) <line9> .sorted(getComparator(sortProperty, sortOrder)) <line10> .collect(Collectors.toList()); <line11> } <line12> } <line13> 	"<line3>    log.trace(""Executing findByTenantId [{}]"", tenantId);"	task4	
public class A { <line0> private static void runNonCompileAssertion( <line1> int assertionNumber, <line2> EventType eventType, <line3> Map<String, ExprEvaluator> nodes, <line4> SupportEvalAssertionPair assertion, <line5> RegressionEnvironment env, <line6> SupportEvalBuilder builder) { <line7> EventBean event; <line8> if (assertion.getUnderlying() instanceof Map) { <line9> event = new MapEventBean((Map<String, Object>) assertion.getUnderlying(), eventType); <line10> } else { <line11> if (eventType.getUnderlyingType() != assertion.getUnderlying()) { <line12> eventType = getSubtype(assertion.getUnderlying(), env); <line13> } <line14> event = new BeanEventBean(assertion.getUnderlying(), eventType); <line15> } <line16> EventBean[] eventsPerStream = new EventBean[] {event}; <line17> for (Map.Entry<String, SupportEvalExpected> expected : <line18> assertion.getBuilder().getResults().entrySet()) { <line19> if (builder.getExludeNamesExcept() != null <line20> && !builder.getExludeNamesExcept().equals(expected.getKey())) { <line21> continue; <line22> } <line23> ExprEvaluator eval = nodes.get(expected.getKey()); <line24> Object result = null; <line25> try { <line26> result = eval.evaluate(eventsPerStream, true, null); <line27> } catch (Throwable t) { <line28> fail(); <line29> } <line30> doAssert(false, assertionNumber, expected.getKey(), expected.getValue(), result); <line31> } <line32> } <line33> } <line34> 	"<line28>        log.error(""Failed at expression "" + expected.getKey() + "" at event #"" + assertionNumber, t);"	task4	
public class A { <line0> private void onSetGcGrace(CfDef cfDef, Properties cfProperties, StringBuilder builder) { <line1> String gcGraceSeconds = cfProperties.getProperty(CassandraConstants.GC_GRACE_SECONDS); <line2> if (gcGraceSeconds != null) { <line3> try { <line4> if (builder != null) { <line5> appendPropertyToBuilder(builder, gcGraceSeconds, CassandraConstants.GC_GRACE_SECONDS); <line6> } else { <line7> cfDef.setGc_grace_seconds(Integer.parseInt(gcGraceSeconds)); <line8> } <line9> } catch (NumberFormatException nfe) { <line10> throw new SchemaGenerationException(nfe); <line11> } <line12> } <line13> } <line14> } <line15> 	"<line10>        log.error(""GC_GRACE_SECONDS should be numeric type, Caused by: ."", nfe);"	task4	
public class A { <line0> private Response getSamlpPostLogoutRequest( <line1> String relayState, LogoutWrapper<LogoutRequest> logoutRequest) <line2> throws SignatureException, WSSecurityException { <line3> String encodedSamlRequest = encodeSaml(logoutRequest); <line4> String singleLogoutLocation = idpMetadata.getSingleLogoutLocation(); <line5> String submitFormUpdated = <line6> String.format( <line7> submitForm, singleLogoutLocation, SAML_REQUEST, encodedSamlRequest, relayState); <line8> Response.ResponseBuilder ok = Response.ok(submitFormUpdated); <line9> return ok.build(); <line10> } <line11> } <line12> 	"<line3>    LOGGER.debug(""Configuring SAML LogoutRequest for POST."");"	task4	
"public class A { <line0> public void createTable(final Table table) throws HiveMetaStoreException { <line1> ClientAction<Void> create = <line2> new ClientAction<Void>() { <line3> @Override <line4> public Void call() throws TException { <line5> try { <line6> client.createTable(table.getTTable()); <line7> } catch (NoSuchObjectException e) { <line8> throw new HiveMetaStoreException( <line9> ""Hive table not found: "" + table.getDbName() + ""."" + table.getTableName()); <line10> } catch (AlreadyExistsException e) { <line11> } catch (InvalidObjectException e) { <line12> throw new HiveMetaStoreException(""Invalid table"", e); <line13> } <line14> return null; <line15> } <line16> }; <line17> createDatabase(table.getDbName()); <line18> doAction(create); <line19> } <line20> } <line21> "	"<line11>              log.warn(""Hive table already exists: {}.{}"", table.getDbName(), table.getTableName());"	task4	
public class A { <line0> public static void deleteMessage(String relativeQueueUrl, String receiptHandle) throws Exception { <line1> long ts1 = System.currentTimeMillis(); <line2> if (useInlineApiCalls) { <line3> CQSAPI.deleteMessage(cnsInternal.getUserId(), relativeQueueUrl, receiptHandle); <line4> } else { <line5> String absoluteQueueUrl = Util.getAbsoluteQueueUrlForRelativeUrl(relativeQueueUrl); <line6> sqs.deleteMessage(new DeleteMessageRequest(absoluteQueueUrl, receiptHandle)); <line7> } <line8> long ts2 = System.currentTimeMillis(); <line9> CMBControllerServlet.valueAccumulator.addToCounter(AccumulatorName.CNSCQSTime, ts2 - ts1); <line10> } <line11> } <line12> 	"<line10>    logger.debug(""event=delete_message receipt_handle="" + receiptHandle);"	task4	
public class A { <line0> private void processLENGTH(final byte b) { <line1> if (b == RELPFrame.SEPARATOR || (currBytes.size() > 0 && b == RELPFrame.DELIMITER)) { <line2> final int dataLength = Integer.parseInt(new String(currBytes.toByteArray(), charset)); <line3> frameBuilder.dataLength(dataLength); <line4> currBytes.reset(); <line5> if (b == RELPFrame.SEPARATOR) { <line6> currState = RELPState.DATA; <line7> } else { <line8> frameBuilder.data(new byte[0]); <line9> currState = RELPState.TRAILER; <line10> } <line11> } else { <line12> currBytes.write(b); <line13> } <line14> } <line15> } <line16> 	"<line4>      logger.debug(""Length is {}"", new Object[] {dataLength});"	task4	
"public class A { <line0> public static void flushAuthenticationUserCache(String userName) { <line1> ApplicationContext ctx = <line2> WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); <line3> try { <line4> UserCache userCache = (UserCache) ctx.getBean(""userCache""); <line5> if (userCache != null) { <line6> userCache.removeUserFromCache(userName); <line7> } <line8> } catch (NoSuchBeanDefinitionException exc) { <line9> } <line10> } <line11> } <line12> "	"<line9>      log.debug(""No userCache bean in context"", exc);"	task4	
public class A { <line0> @Override <line1> public synchronized boolean stop() { <line2> try { <line3> if (canalStater.isRunning()) { <line4> canalStater.stop(true); <line5> return true; <line6> } <line7> } catch (Throwable e) { <line8> } <line9> return false; <line10> } <line11> } <line12> 	<line8>      logger.error(e.getMessage(), e);	task4	
public class A { <line0> public void remove(T element) { <line1> List<T> parentNodes = getModel().getParents(element); <line2> try { <line3> getModel().removeNode(element); <line4> } catch (NullPointerException e) { <line5> } <line6> getRenderer().refreshHoursValueForNodes(parentNodes); <line7> getRenderer().refreshBudgetValueForNodes(parentNodes); <line8> } <line9> } <line10> 	"<line5>      LOG.error(""Trying to delete an already removed node"", e);"	task4	
public class A { <line0> private Job runJob(ExtensionIndexRequest request) { <line1> this.currentRequest = request; <line2> try { <line3> Job job = this.jobs.execute(ExtensionIndexJob.JOB_TYPE, request); <line4> job.join(); <line5> return job; <line6> } catch (Exception e) { <line7> if (!this.disposed) { <line8> } <line9> } finally { <line10> this.currentRequest = null; <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line8>        this.logger.error(""Failed to execute job"", e);"	task4	
public class A { <line0> private static String checkHexKey(String input) { <line1> if (input == null || input.trim().isEmpty()) { <line2> return CryptoKeyProvider.EMPTY_KEY; <line3> } <line4> return input; <line5> } <line6> } <line7> 	"<line2>      logger.debug(""Checking the hex key value that was loaded determined the key is empty."");"	task4	
public class A { <line0> @Override <line1> public void onPartitionsAssigned(Collection<TopicPartition> partitions) { <line2> partitions.forEach( <line3> partition -> { <line4> }); <line5> } <line6> } <line7> 	"<line4>          log.info(""Rebalance happened "" + partition.topic() + "":"" + partition.partition());"	task4	
public class A { <line0> private Set<String> getBeanPropertyNames(final Class<?> clazz) { <line1> try { <line2> Set<String> beanProps = new HashSet<String>(); <line3> PropertyDescriptor[] propDescriptors = getBeanInfo(clazz).getPropertyDescriptors(); <line4> for (PropertyDescriptor propDescriptor : propDescriptors) { <line5> if (propDescriptor.getReadMethod() != null) { <line6> beanProps.add(propDescriptor.getName()); <line7> } <line8> } <line9> return beanProps; <line10> } catch (IntrospectionException e) { <line11> } <line12> return newHashSet(); <line13> } <line14> } <line15> 	"<line11>      LOG.warn(""Failed to get bean properties on ({})"", clazz, e);"	task4	
public class A { <line0> @Override <line1> public String getTitle(long classPK, Locale locale) { <line2> try { <line3> AssetRenderer<?> assetRenderer = getAssetRenderer(classPK); <line4> if (assetRenderer != null) { <line5> return assetRenderer.getTitle(locale); <line6> } <line7> } catch (Exception exception) { <line8> if (log.isWarnEnabled()) { <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line9>        log.warn(exception, exception);	task4	
"public class A { <line0> @AfterClass <line1> public static void destroy() throws IOException { <line2> embeddedNode.stop(); <line3> FileUtils.deleteDirectory(new File("".\\data"")); <line4> } <line5> } <line6> "	"<line2>    logger.debug(""Closing embedded node"");"	task4	
public class A { <line0> @Override <line1> public Response toResponse(JobRunningException jobRunningException) { <line2> return Response.status(Status.INTERNAL_SERVER_ERROR) <line3> .entity(new JobRunningExceptionInfo(jobRunningException)) <line4> .build(); <line5> } <line6> } <line7> 	"<line2>    LOG.error(""Job Running"", jobRunningException);"	task4	
public class A { <line0> @Override <line1> public boolean isSatisfiedBy(Project project) { <line2> TaskContainer taskContainer = project.getTasks(); <line3> Task jarTask = taskContainer.findByName(JavaPlugin.JAR_TASK_NAME); <line4> if (!(jarTask instanceof Jar)) { <line5> if (logger.isInfoEnabled()) { <line6> } <line7> return false; <line8> } <line9> return true; <line10> } <line11> } <line12> 	"<line6>        logger.info(""Excluding {} because it is not a valid Java "" + ""project"", project);"	task4	
public class A { <line0> public String setNamespace(String futureNamespace) { <line1> String previousNamespace = namespace; <line2> namespace = futureNamespace; <line3> return previousNamespace; <line4> } <line5> } <line6> 	"<line2>    LOGGER.info(""Changing to {} namespace"", futureNamespace);"	task4	
"public class A { <line0> @Around(value = ""mQAdminMethodPointCut() || multiMQAdminMethodPointCut()"") <line1> public Object aroundMQAdminMethod(ProceedingJoinPoint joinPoint) throws Throwable { <line2> long start = System.currentTimeMillis(); <line3> Object obj = null; <line4> try { <line5> MethodSignature signature = (MethodSignature) joinPoint.getSignature(); <line6> Method method = signature.getMethod(); <line7> MultiMQAdminCmdMethod multiMQAdminCmdMethod = <line8> method.getAnnotation(MultiMQAdminCmdMethod.class); <line9> if (multiMQAdminCmdMethod != null && multiMQAdminCmdMethod.timeoutMillis() > 0) { <line10> MQAdminInstance.initMQAdminInstance( <line11> multiMQAdminCmdMethod.timeoutMillis(), <line12> rmqConfigure.getAccessKey(), <line13> rmqConfigure.getSecretKey()); <line14> } else { <line15> MQAdminInstance.initMQAdminInstance( <line16> 0, rmqConfigure.getAccessKey(), rmqConfigure.getSecretKey()); <line17> } <line18> obj = joinPoint.proceed(); <line19> } finally { <line20> MQAdminInstance.destroyMQAdminInstance(); <line21> } <line22> return obj; <line23> } <line24> } <line25> "	"<line21>      logger.debug(""op=look method={} cost={}"",joinPoint.getSignature().getName(),System.currentTimeMillis() - start);"	task4	
public class A { <line0> @Override <line1> public void commitTask(TaskAttemptContext taskContext) throws IOException { <line2> for (String alias : outputCommitters.keySet()) { <line3> BaseOutputCommitterContainer outputContainer = outputCommitters.get(alias); <line4> OutputCommitter baseCommitter = outputContainer.getBaseCommitter(); <line5> TaskAttemptContext committerContext = outputContainer.getContext(); <line6> if (baseCommitter.needsTaskCommit(committerContext)) { <line7> baseCommitter.commitTask(committerContext); <line8> } <line9> } <line10> } <line11> } <line12> 	"<line7>        LOGGER.info(""Calling commitTask for alias: "" + alias);"	task4	
"public class A { <line0> private HashMap<String, String> getNamespacesFromConfig() { <line1> HashMap<String, String> nss = new HashMap<>(); <line2> try { <line3> File file = new File(ConfigCore.getKitodoConfigDirectory() + ""kitodo_exportXml.xml""); <line4> if (file.exists() && file.canRead()) { <line5> XMLConfiguration config = new XMLConfiguration(file); <line6> config.setListDelimiter('&'); <line7> config.setReloadingStrategy(new FileChangedReloadingStrategy()); <line8> int count = config.getMaxIndex(""namespace""); <line9> for (int i = 0; i <= count; i++) { <line10> String name = config.getString(""namespace("" + i + "")[@name]""); <line11> String value = config.getString(""namespace("" + i + "")[@value]""); <line12> nss.put(name, value); <line13> } <line14> } <line15> } catch (ConfigurationException | RuntimeException e) { <line16> nss = new HashMap<>(); <line17> } <line18> return nss; <line19> } <line20> } <line21> "	<line16>      logger.debug(e.getMessage(), e);	task4	
public class A { <line0> public void onDeviceConnected(final NodeId nodeId) { <line1> final DeviceMastership mastership = <line2> new DeviceMastership(nodeId, reconciliationRegistry, clusterSingletonService); <line3> deviceMasterships.put(nodeId, mastership); <line4> } <line5> } <line6> 	"<line1>    LOG.debug(""FRS service registered for: {}"", nodeId.getValue());"	task4	
"public class A { <line0> private void doParse(String test, Object bean, int index, String property, boolean expected) { <line1> boolean result = false; <line2> try { <line3> result = doParse(test, bean, index, property); <line4> } catch (Exception ex) { <line5> fail(""Parsing "" + test + "" threw "" + ex); <line6> } <line7> if (expected) { <line8> assertTrue(test + "" didn't return TRUE for "" + property, result); <line9> } else { <line10> assertFalse(test + "" didn't return FALSE for "" + property, result); <line11> } <line12> } <line13> } <line14> "	"<line5>      log.error(""Parsing "" + test + "" for property '"" + property + ""'"", ex);"	task4	
public class A { <line0> public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception { <line1> } <line2> } <line3> 	<line1>    logger.error(e.getCause().getMessage());	task4	
public class A { <line0> protected void processForDocumentListPresenter(HistoryToken token) { <line1> if (!equal(token.getDocFilterExact(), currentHistoryState.getDocFilterExact()) <line2> || !equal(token.getDocFilterText(), currentHistoryState.getDocFilterText()) <line3> || !equal( <line4> token.isDocFilterCaseSensitive(), currentHistoryState.isDocFilterCaseSensitive())) { <line5> documentListPresenter.updateFilterAndRun( <line6> token.getDocFilterText(), token.getDocFilterExact(), token.isDocFilterCaseSensitive()); <line7> } <line8> } <line9> } <line10> 	"<line5>      Log.info(""[gwt-history] document list filter has changed"");"	task4	
"public class A { <line0> private void getPOM(JarFile jarFile) { <line1> List<JarEntry> entryList = Collections.list(jarFile.entries()); <line2> for (JarEntry jarEntry : entryList) { <line3> if (jarEntry.getName().contains(""pom.xml"")) { <line4> try (InputStream inputStream = jarFile.getInputStream(jarEntry)) { <line5> pomInformation.parsePom(inputStream); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> } <line11> } <line12> "	"<line7>          LOGGER.error(""Error while opening POM file"", e);"	task4	
public class A { <line0> private AclImpl convert( <line1> AclObjectIdentity aclObjectIdentity, Set<AclEntry> aclEntries, Acl parentAcl) { <line2> AclImpl acl = <line3> new AclImpl( <line4> aclObjectIdentity.toObjectIdentity(), <line5> aclObjectIdentity.getId(), <line6> aclAuthorizationStrategy, <line7> grantingStrategy, <line8> parentAcl, <line9> null, <line10> aclObjectIdentity.isEntriesInheriting(), <line11> aclObjectIdentity.getOwnerSid()); <line12> List<AccessControlEntry> aces = new ArrayList<>(aclEntries.size()); <line13> for (AclEntry entry : aclEntries) { <line14> AccessControlEntry ace = <line15> new AccessControlEntryImpl( <line16> entry.getId(), <line17> acl, <line18> entry.getSidObject(), <line19> permissionFactory.buildFromMask(entry.getMask()), <line20> entry.isGranting(), <line21> entry.isAuditSuccess(), <line22> entry.isAuditFailure()); <line23> aces.add(entry.getOrder(), ace); <line24> } <line25> try { <line26> fieldAces.set(acl, aces); <line27> } catch (Exception e) { <line28> } <line29> return acl; <line30> } <line31> } <line32> 	"<line28>      LOG.error(""Could not set AccessControlEntries in the ACL"", e);"	task4	
public class A { <line0> @Override <line1> public void closeConnection(Connection connection) throws SQLException { <line2> if (connection != null) { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> connection.close(); <line6> } <line7> } <line8> } <line9> 	"<line4>        logger.trace(""Closing connection"");"	task4	
"public class A { <line0> public static com.liferay.depot.model.DepotEntryGroupRel updateDDMStructuresAvailable( <line1> HttpPrincipal httpPrincipal, long depotEntryGroupRelId, boolean ddmStructuresAvailable) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DepotEntryGroupRelServiceUtil.class, <line7> ""updateDDMStructuresAvailable"", <line8> _updateDDMStructuresAvailableParameterTypes5); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, depotEntryGroupRelId, ddmStructuresAvailable); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (com.liferay.depot.model.DepotEntryGroupRel) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>      log.error(systemException, systemException);	task4	
"public class A { <line0> public long getMaxDataTime(String dataset) throws Exception { <line1> DatasetConfigDTO datasetConfig = ThirdEyeUtils.getDatasetConfigFromName(dataset); <line2> TimeSpec timeSpec = ThirdEyeUtils.getTimestampTimeSpecFromDatasetConfig(datasetConfig); <line3> DateTimeZone timeZone = Utils.getDataTimeZone(dataset); <line4> long maxTime = 0; <line5> String sourceName = dataset.split(""\\."")[0]; <line6> String tableName = SqlUtils.computeSqlTableName(dataset); <line7> DataSource dataSource = getDataSourceFromDataset(dataset); <line8> try (Connection conn = dataSource.getConnection(); <line9> Statement stmt = conn.createStatement(); <line10> ResultSet rs = <line11> stmt.executeQuery( <line12> SqlUtils.getMaxDataTimeSQL(timeSpec.getColumnName(), tableName, sourceName))) { <line13> if (rs.next()) { <line14> String maxTimeString = rs.getString(1); <line15> if (maxTimeString.indexOf('.') >= 0) { <line16> maxTimeString = maxTimeString.substring(0, maxTimeString.indexOf('.')); <line17> } <line18> String timeFormat = timeSpec.getFormat(); <line19> if (StringUtils.isBlank(timeFormat) || TimeSpec.SINCE_EPOCH_FORMAT.equals(timeFormat)) { <line20> maxTime = <line21> timeSpec.getDataGranularity().toMillis(Long.valueOf(maxTimeString) - 1, timeZone); <line22> } else { <line23> DateTimeFormatter inputDataDateTimeFormatter = <line24> DateTimeFormat.forPattern(timeFormat).withZone(timeZone); <line25> DateTime endDateTime = DateTime.parse(maxTimeString, inputDataDateTimeFormatter); <line26> Period oneBucket = datasetConfig.bucketTimeGranularity().toPeriod(); <line27> maxTime = endDateTime.plus(oneBucket).getMillis() - 1; <line28> } <line29> } <line30> } catch (Exception e) { <line31> throw e; <line32> } <line33> return maxTime; <line34> } <line35> } <line36> "	"<line1>    LOG.info(""Getting max data time for "" + dataset);"	task4	
"public class A { <line0> @Override <line1> @AdapterDelegationEvent( <line2> beforeBuilder = PRPAIN201305UV02EventDescriptionBuilder.class, <line3> afterReturningBuilder = PRPAIN201305UV02AdapterEventDescBuilder.class, <line4> serviceType = ""Patient Discovery MPI"", <line5> version = ""1.0"") <line6> public PRPAIN201306UV02 findCandidates( <line7> PRPAIN201305UV02 findCandidatesRequest, AssertionType assertion) { <line8> return findCandidatesMpi(findCandidatesRequest, assertion); <line9> } <line10> } <line11> "	"<line8>    LOG.trace(""Entering AdapterMpiProxyJavaImpl.findCandidates"");"	task4	
"public class A { <line0> private Date _parseDate(String dateString) { <line1> try { <line2> return DateUtil.parseDate(""yyyyMMddHHmmss"", dateString, LocaleUtil.getDefault()); <line3> } catch (Exception exception) { <line4> if (log.isWarnEnabled()) { <line5> } <line6> return new Date(); <line7> } <line8> } <line9> } <line10> "	<line5>        log.warn(exception, exception);	task4	
"public class A { <line0> public static com.liferay.commerce.product.model.CPDefinition updateSubscriptionInfo( <line1> HttpPrincipal httpPrincipal, <line2> long cpDefinitionId, <line3> boolean subscriptionEnabled, <line4> int subscriptionLength, <line5> String subscriptionType, <line6> com.liferay.portal.kernel.util.UnicodeProperties subscriptionTypeSettingsUnicodeProperties, <line7> long maxSubscriptionCycles, <line8> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line9> throws com.liferay.portal.kernel.exception.PortalException { <line10> try { <line11> MethodKey methodKey = <line12> new MethodKey( <line13> CPDefinitionServiceUtil.class, <line14> ""updateSubscriptionInfo"", <line15> _updateSubscriptionInfoParameterTypes25); <line16> MethodHandler methodHandler = <line17> new MethodHandler( <line18> methodKey, <line19> cpDefinitionId, <line20> subscriptionEnabled, <line21> subscriptionLength, <line22> subscriptionType, <line23> subscriptionTypeSettingsUnicodeProperties, <line24> maxSubscriptionCycles, <line25> serviceContext); <line26> Object returnObj = null; <line27> try { <line28> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line29> } catch (Exception exception) { <line30> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line31> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line32> } <line33> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line34> } <line35> return (com.liferay.commerce.product.model.CPDefinition) returnObj; <line36> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line37> throw systemException; <line38> } <line39> } <line40> } <line41> "	<line37>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public Template resolve(String input, ExecutionRuntime executionRuntime) { <line2> input = executionRuntime.resolveVariables(input); <line3> List<String> splittedArguments = DataTypeHandler.getInstance().splitInstructionArguments(input); <line4> if (splittedArguments.size() == 2) { <line5> DataType templateName = <line6> DataTypeHandler.getInstance().resolve(splittedArguments.get(0), executionRuntime); <line7> DataType templateVersion = <line8> DataTypeHandler.getInstance().resolve(splittedArguments.get(1), executionRuntime); <line9> if (templateName instanceof Text && templateVersion instanceof Text) { <line10> return TemplateConfiguration.getInstance() <line11> .getByNameAndVersion( <line12> ((Text) templateName).getString(), <line13> Long.parseLong(((Text) templateVersion).getString())) <line14> .orElseThrow( <line15> () -> <line16> new RuntimeException( <line17> ""Cannot find template with name "" + ((Text) templateName).getString())); <line18> } else { <line19> throw new IllegalArgumentException(""Cannot fetch template when given "" + templateName); <line20> } <line21> } else { <line22> throw new IllegalArgumentException(""Cannot fetch template with parameters "" + input); <line23> } <line24> } <line25> } <line26> "	"<line2>    log.trace(MessageFormat.format(""resolving {0} for Template"", input));"	task4	
"public class A { <line0> public static void main(String[] args) { <line1> String path = Paths.get(""."").toAbsolutePath().normalize().toString(); <line2> } <line3> } <line4> "	"<line2>    LOG.info(""path: {}"", path);"	task4	
"public class A { <line0> public static int getGroupEntriesCount(HttpPrincipal httpPrincipal, long groupId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> BookmarksEntryServiceUtil.class, <line6> ""getGroupEntriesCount"", <line7> _getGroupEntriesCountParameterTypes11); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> return ((Integer) returnObj).intValue(); <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	<line20>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public void deleteIndex(String indexName, List<String> partitionsToDelete) throws IOException { <line2> IndexRecord indexRecord = indexRecordManager.lookUpIndexRecord(indexName); <line3> Path tablePath = root.resolve(indexRecord.qualifiedTable); <line4> Path columnPath = tablePath.resolve(String.join("","", indexRecord.columns)); <line5> Path indexLevelPath = columnPath.resolve(indexRecord.indexType); <line6> if (!fs.exists(indexLevelPath)) { <line7> indexRecordManager.deleteIndexRecord(indexName, partitionsToDelete); <line8> return; <line9> } <line10> Lock lock = new FileBasedLock(fs, indexLevelPath.getParent()); <line11> try { <line12> Runtime.getRuntime() <line13> .addShutdownHook( <line14> new Thread( <line15> () -> { <line16> lock.unlock(); <line17> try { <line18> fs.close(); <line19> } catch (IOException e) { <line20> throw new UncheckedIOException( <line21> ""Error closing FileSystem Client: "" + fs.getClass().getName(), e); <line22> } <line23> })); <line24> lock.lock(); <line25> if (partitionsToDelete.isEmpty()) { <line26> fs.deleteRecursively(indexLevelPath); <line27> } else { <line28> List<Path> toDeletePartitions = <line29> fs.walk(indexLevelPath) <line30> .filter(fs::isDirectory) <line31> .filter(path -> partitionsToDelete.contains(path.getFileName().toString())) <line32> .collect(Collectors.toList()); <line33> for (Path path : toDeletePartitions) { <line34> fs.deleteRecursively(path); <line35> } <line36> if (fs.walk(indexLevelPath).allMatch(fs::isDirectory)) { <line37> fs.deleteRecursively(indexLevelPath); <line38> } <line39> } <line40> try { <line41> if (fs.list(columnPath).allMatch(FileBasedLock::isLockUtilFile)) { <line42> fs.deleteRecursively(columnPath); <line43> } <line44> if (fs.list(tablePath).allMatch(FileBasedLock::isLockUtilFile)) { <line45> fs.deleteRecursively(tablePath); <line46> } <line47> } catch (Exception e) { <line48> } <line49> } finally { <line50> lock.unlock(); <line51> } <line52> indexRecordManager.deleteIndexRecord(indexName, partitionsToDelete); <line53> } <line54> } <line55> "	"<line48>        LOG.debug(""failed to clean empty index directory"", e);"	task4	
"public class A { <line0> public void syncSequenceFilePair(SequenceFilePair pair, Sample sample) { <line1> RemoteStatus fileStatus = pair.getRemoteStatus(); <line2> fileStatus.setSyncStatus(SyncStatus.UPDATING); <line3> try { <line4> pair = pairRemoteService.mirrorSequencingObject(pair); <line5> syncSequencingObject(pair, sample, fileStatus); <line6> } catch (Exception e) { <line7> throw new ProjectSynchronizationException( <line8> ""Could not synchronize pair "" + pair.getRemoteStatus().getURL(), e); <line9> } <line10> } <line11> } <line12> "	"<line7>      logger.error(""Error transferring file: "" + pair.getRemoteStatus().getURL(), e);"	task4	
public class A { <line0> @Override <line1> public void disconnect() { <line2> this.kafkaSourceState = null; <line3> if (consumerKafkaGroup != null) { <line4> consumerKafkaGroup.setKafkaSourceState(null); <line5> consumerKafkaGroup.shutdown(); <line6> } <line7> } <line8> } <line9> 	"<line6>      LOG.info(""Kafka Adapter disconnected for topic(s): ""+ optionHolder.validateAndGetStaticValue(ADAPTOR_SUBSCRIBER_TOPIC));"	task4	
public class A { <line0> public void deleteData(List<String> paths, long time) <line1> throws IoTDBConnectionException, StatementExecutionException { <line2> for (int i = 0; i < RETRY; i++) { <line3> Session session = getSession(); <line4> try { <line5> session.deleteData(paths, time); <line6> putBack(session); <line7> return; <line8> } catch (IoTDBConnectionException e) { <line9> cleanSessionAndMayThrowConnectionException(session, i, e); <line10> } catch (StatementExecutionException | RuntimeException e) { <line11> putBack(session); <line12> throw e; <line13> } <line14> } <line15> } <line16> } <line17> 	"<line9>        logger.warn(""deleteData failed"", e);"	task4	
public class A { <line0> public Collection<CachedFacility> getAllFacilitiesToDisplay(LoggedInInfo loggedInInfo) { <line1> try { <line2> if (previousConsentToView == null) return (getAllRemoteFacilities()); <line3> else return (getPreviousConsentFacilities(loggedInInfo)); <line4> } catch (Exception e) { <line5> integratorServerError = true; <line6> return (null); <line7> } <line8> } <line9> } <line10> 	"<line6>      logger.error(""unexpected error"", e);"	task4	
"public class A { <line0> public void validate( <line1> final String host, int port, final String path, boolean secure, final Cookie cookie) <line2> throws MalformedCookieException { <line3> if (cookie instanceof Cookie2) { <line4> if (cookie.getName().indexOf(' ') != -1) { <line5> throw new MalformedCookieException(""Cookie name may not contain blanks""); <line6> } <line7> if (cookie.getName().startsWith(""$"")) { <line8> throw new MalformedCookieException(""Cookie name may not start with $""); <line9> } <line10> CookieOrigin origin = new CookieOrigin(getEffectiveHost(host), port, path, secure); <line11> for (Iterator i = getAttribHandlerIterator(); i.hasNext(); ) { <line12> CookieAttributeHandler handler = (CookieAttributeHandler) i.next(); <line13> handler.validate(cookie, origin); <line14> } <line15> } else { <line16> this.rfc2109.validate(host, port, path, secure, cookie); <line17> } <line18> } <line19> } <line20> "	"<line3>    LOG.trace(""enter RFC2965Spec.validate(String, int, String, "" + ""boolean, Cookie)"");"	task4	
"public class A { <line0> private LateralTCPDiscoveryListener getDiscoveryListener( <line1> final ITCPLateralCacheAttributes ilca, <line2> final ICompositeCacheManager cacheManager, <line3> final ICacheEventLogger cacheEventLogger, <line4> final IElementSerializer elementSerializer) { <line5> final String key = ilca.getUdpDiscoveryAddr() + "":"" + ilca.getUdpDiscoveryPort(); <line6> return lTCPDLInstances.computeIfAbsent( <line7> key, <line8> key1 -> { <line9> return new LateralTCPDiscoveryListener( <line10> this.getName(), <line11> (CompositeCacheManager) cacheManager, <line12> cacheEventLogger, <line13> elementSerializer); <line14> }); <line15> } <line16> } <line17> "	"<line9>          log.info(""Created new discovery listener for cacheName {0} and request {1}"",ilca.getCacheName(), key1);"	task4	
public class A { <line0> public void warn(Throwable e) { <line1> try { <line2> } catch (Throwable ignored) { <line3> } <line4> } <line5> } <line6> 	<line2>      logger.warn(e);	task4	
public class A { <line0> @Override <line1> public void insertRollups(List<SingleRollupWriteContext> writeContexts) { <line2> if (writeContexts.size() == 0) { <line3> return; <line4> } <line5> Timer.Context ctx = <line6> Instrumentation.getWriteTimerContext(writeContexts.get(0).getDestinationCF().getName()); <line7> try { <line8> BatchStatement batch = new BatchStatement(BatchStatement.Type.UNLOGGED); <line9> for (SingleRollupWriteContext writeContext : writeContexts) { <line10> Rollup rollup = writeContext.getRollup(); <line11> Locator locator = writeContext.getLocator(); <line12> Granularity granularity = writeContext.getGranularity(); <line13> int ttl = getTtl(locator, rollup.getRollupType(), granularity); <line14> RollupType rollupType = writeContext.getRollup().getRollupType(); <line15> DAbstractMetricIO io = getIO(rollupType.name().toLowerCase(), granularity); <line16> Statement statement = <line17> io.createStatement( <line18> locator, writeContext.getTimestamp(), rollup, writeContext.getGranularity(), ttl); <line19> batch.add(statement); <line20> } <line21> Session session = DatastaxIO.getSession(); <line22> session.execute(batch); <line23> } catch (Exception ex) { <line24> Instrumentation.markWriteError(); <line25> } finally { <line26> ctx.stop(); <line27> } <line28> } <line29> } <line30> 	"<line25>      LOG.error(String.format(""error writing locator batch of size %s, granularity %s"",writeContexts.size(), writeContexts.get(0).getGranularity()),ex);"	task4	
public class A { <line0> protected synchronized void abort() { <line1> if (open) { <line2> disk.unwatch(uri, this); <line3> open = false; <line4> changed = false; <line5> deleted = false; <line6> try { <line7> deleteWriteFile(); <line8> } catch (IOException e) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>        logger.error(e.toString(), e);	task4	
public class A { <line0> @Override <line1> public void initialize( <line2> StartupContext startupContext, UserStore userStore, Map<String, String> properties) { <line3> try { <line4> persistDefaultAuthResources(); <line5> } catch (AuthServerException e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOGGER.error(""Error occurred while persisting auth resources."", e);"	task4	
"public class A { <line0> private List<QueryHandle> getPersistedQueryHandles( <line1> String userName, <line2> String driver, <line3> String queryName, <line4> long fromTime, <line5> long toTime, <line6> Set<Status> statuses) <line7> throws LensException { <line8> List<Status> finishedStatusesQueried = finishedStatuses(statuses); <line9> if (finishedStatusesQueried == null || !finishedStatusesQueried.isEmpty()) { <line10> if (""all"".equalsIgnoreCase(userName)) { <line11> userName = null; <line12> } <line13> List<QueryHandle> persistedQueries = <line14> lensServerDao.findFinishedQueries( <line15> finishedStatusesQueried, userName, driver, queryName, fromTime, toTime); <line16> if (persistedQueries != null && !persistedQueries.isEmpty()) { <line17> return persistedQueries; <line18> } <line19> } <line20> return Collections.emptyList(); <line21> } <line22> } <line23> "	"<line17>        log.info(""Adding persisted queries {}"", persistedQueries.size());"	task4	
"public class A { <line0> @Override <line1> public Job retract(MediaPackage mediaPackage) throws PublicationException { <line2> List<BasicNameValuePair> params = new ArrayList<BasicNameValuePair>(); <line3> params.add(new BasicNameValuePair(""mediapackage"", MediaPackageParser.getAsXml(mediaPackage))); <line4> HttpPost post = new HttpPost(""/retract""); <line5> HttpResponse response = null; <line6> try { <line7> post.setEntity(new UrlEncodedFormEntity(params, ""UTF-8"")); <line8> response = getResponse(post); <line9> if (response != null) { <line10> return JobParser.parseJob(response.getEntity().getContent()); <line11> } <line12> } catch (Exception e) { <line13> throw new PublicationException( <line14> ""Unable to retract mediapackage "" <line15> + mediaPackage <line16> + "" using a remote youtube publication service"", <line17> e); <line18> } finally { <line19> closeConnection(response); <line20> } <line21> throw new PublicationException( <line22> ""Unable to retract mediapackage "" <line23> + mediaPackage <line24> + "" using a remote youtube publication service""); <line25> } <line26> } <line27> "	"<line10>        logger.info(""Retracting {} from youtube"", mediaPackage);"	task4	
"public class A { <line0> @Override <line1> public synchronized void sendMessage(byte[] message) throws KuraException, IOException { <line2> checkIfClosed(); <line3> if (message == null) { <line4> throw new NullPointerException(""Message must not be null""); <line5> } <line6> if (this.outputStream == null) { <line7> openOutputStream(); <line8> } <line9> this.outputStream.write(message, 0, message.length); <line10> this.outputStream.flush(); <line11> } <line12> } <line13> "	<line6>    logger.debug(SEND_MESSAGE, () -> getBytesAsString(message));	task4	
"public class A { <line0> public boolean isServiceSettingTrue(String serviceparameter) { <line1> String value = getServiceSetting(serviceparameter); <line2> boolean isTrue = (value != null ? value.equalsIgnoreCase(""true"") : false); <line3> return isTrue; <line4> } <line5> } <line6> "	"<line3>    logger.debug(serviceparameter + "": "" + isTrue);"	task4	
"public class A { <line0> protected void check(String xPathString) { <line1> if (this.xmlAsserterConfiguration.ignoreXPathException) { <line2> return; <line3> } <line4> ResultSequence expr = resultSequence(xPathString); <line5> boolean xpathMatched = !expr.empty(); <line6> if (!xpathMatched) { <line7> throw new IllegalStateException( <line8> ""Parsed XML ["" <line9> + this.cachedObjects.xmlAsString <line10> + ""] doesn't match the XPath <"" <line11> + xPathString <line12> + "">""); <line13> } <line14> } <line15> } <line16> "	"<line2>      log.trace(""WARNING!!! Overriding verification of the XPath. Your tests may pass even though they""+ "" shouldn't"");"	task4	
public class A { <line0> public static Dialect getDialect(SessionFactory sessionFactory) { <line1> if (dialect != null) { <line2> return dialect; <line3> } <line4> SessionFactoryImplementor implementor = (SessionFactoryImplementor) sessionFactory; <line5> dialect = implementor.getDialect(); <line6> if (log.isDebugEnabled()) { <line7> } <line8> return dialect; <line9> } <line10> } <line11> 	"<line7>      log.debug(""Getting dialect for session: "" + dialect);"	task4	
public class A { <line0> public void unbind(SourceAttributeRestriction sourceAttributeRestriction) { <line1> if (sourceAttributeRestriction != null) { <line2> String sourceId = sourceAttributeRestriction.getSource().getId(); <line3> sourceIdToSupportedAttributesMap.remove(sourceId); <line4> } <line5> } <line6> } <line7> 	"<line3>      LOGGER.trace(""Unbinding SourceAttributeRestriction instance with id {}"", sourceId);"	task4	
public class A { <line0> @Override <line1> public void punsubscribeAll() { <line2> } <line3> } <line4> 	"<line2>    log.warn(""unsupported"");"	task4	
public class A { <line0> public void addSecondary(BrooklynClassLoadingContext target) { <line1> if (!(target instanceof JavaBrooklynClassLoadingContext)) { <line2> } <line3> this.secondaries.add(target); <line4> } <line5> } <line6> 	"<line2>      log.warn(""Only Java classloaders should be secondary"");"	task4	
public class A { <line0> @Override <line1> public Response setCollaborators( <line2> CollaboratorsRepresentation collaborators, String entityId, String entityType) { <line3> return this.setCollaborators(collaborators.getCollaborators(), entityId, entityType, true); <line4> } <line5> } <line6> 	"<line3>    this.logger.debug(""Setting {} collaborators to entity record [{}] via REST"",collaborators.getCollaborators().size(),entityId);"	task4	
public class A { <line0> @Override <line1> public void sendNCBIUploadExceptionEmail( <line2> String adminEmailAddress, Exception rootCause, Long submissionId) throws MailSendException { <line3> } <line4> } <line5> 	"<line3>    logger.info(""TestEmailController#sendNCBIUploadExceptionEmail called."");"	task4	
"public class A { <line0> @Test <line1> public void runFromDriver() { <line2> try { <line3> String matrixPath = """"; <line4> String vectorPath = """"; <line5> String outputPath = """"; <line6> if (matrixPath.isEmpty() || vectorPath.isEmpty() || outputPath.isEmpty()) { <line7> return; <line8> } <line9> ExampleDriver.main(new String[] {""spmv"", matrixPath, vectorPath, outputPath, ""4""}); <line10> } catch (Exception e) { <line11> e.printStackTrace(); <line12> fail(e.getLocalizedMessage()); <line13> } <line14> } <line15> } <line16> "	"<line7>        LOG.info(""Please setup input path for vector and matrix and output path for result."");"	task4	
"public class A { <line0> @Override <line1> public long size() throws IOException { <line2> try { <line3> return getConvertedPropertyValue(securityContext, graphObject, key) <line4> .getBytes(Charset.forName(""utf-8"")) <line5> .length; <line6> } catch (FrameworkException fex) { <line7> } <line8> return 0L; <line9> } <line10> } <line11> "	"<line7>      logger.warn("""", fex);"	task4	
"public class A { <line0> public static void main(String[] args) throws Exception { <line1> @SuppressWarnings(""resource"") <line2> ClassPathXmlApplicationContext ac = <line3> new ClassPathXmlApplicationContext( <line4> ""/META-INF/spring/integration/gmail-imap-idle-config.xml""); <line5> DirectChannel inputChannel = ac.getBean(""receiveChannel"", DirectChannel.class); <line6> inputChannel.subscribe( <line7> new MessageHandler() { <line8> @Override <line9> public void handleMessage(Message<?> message) throws MessagingException { <line10> } <line11> }); <line12> } <line13> } <line14> "	"<line10>            logger.info(""Message: "" + message);"	task4	
public class A { <line0> private static int launch(Configuration conf, Tool tool, String[] args) throws Exception { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> ClassLoader contextClassLoader = switchContextClassLoader(conf.getClassLoader()); <line4> try { <line5> return ToolRunner.run(conf, tool, args); <line6> } finally { <line7> switchContextClassLoader(contextClassLoader); <line8> } <line9> } <line10> } <line11> 	"<line2>      LOG.debug(MessageFormat.format(""Launching application: {0}{1}"", tool.getClass().getName(), Arrays.toString(args)));"	task4	
public class A { <line0> @UnitOfWork <line1> @Override <line2> public Optional<User> authenticate(String credentials) { <line3> final Token token = dao.findByContent(credentials); <line4> if (token != null) { <line5> User byId = userDAO.findById(token.getUserId()); <line6> if (byId.isBanned()) { <line7> return Optional.empty(); <line8> } <line9> initializeUserProfiles(byId); <line10> return Optional.of(byId); <line11> } else { <line12> return userinfoPlusFromToken(credentials) <line13> .map( <line14> userinfoPlus -> { <line15> final String email = userinfoPlus.getEmail(); <line16> User user = userDAO.findByGoogleEmail(email); <line17> if (user == null) { <line18> user = createUser(userinfoPlus); <line19> } <line20> user.setTemporaryCredential(credentials); <line21> initializeUserProfiles(user); <line22> return Optional.of(user); <line23> }) <line24> .filter(user -> !user.get().isBanned()) <line25> .orElse(Optional.empty()); <line26> } <line27> } <line28> } <line29> 	"<line3>    LOG.debug(""SimpleAuthenticator called with {}"", credentials);"	task4	
"public class A { <line0> String getMessageIdLocalPart(final Message message) throws MessagingException { <line1> final String[] headers = message.getHeader(""Message-Id""); <line2> if (headers != null && headers.length > 0) { <line3> Matcher matcher = MESSAGE_ID_PATTERN.matcher(headers[0]); <line4> if (matcher.matches()) { <line5> return matcher.group(1); <line6> } <line7> } <line8> return ""No-Message-Id."" + dateTimeProvider.getElapsedTime(); <line9> } <line10> } <line11> "	"<line7>      LOGGER.debug(""Unable to parse Message-Id: {}"", headers[0]);"	task4	
public class A { <line0> private void _localize(JSONObject jsonObject, Locale locale) { <line1> if (locale == null) { <line2> return; <line3> } <line4> ResourceBundle resourceBundle = _resourceBundleLoader.loadResourceBundle(locale); <line5> if (resourceBundle == null) { <line6> return; <line7> } <line8> Map<String, String> map = new HashMap<>(); <line9> for (String key : jsonObject.keySet()) { <line10> if (_localizableKeys.contains(key)) { <line11> String value = jsonObject.getString(key); <line12> if (Validator.isNotNull(value)) { <line13> try { <line14> map.put(key, ResourceBundleUtil.getString(resourceBundle, value)); <line15> } catch (MissingResourceException missingResourceException) { <line16> if (log.isWarnEnabled()) { <line17> } <line18> } <line19> } <line20> } else { <line21> Object object = jsonObject.get(key); <line22> if (object instanceof JSONObject) { <line23> _localize((JSONObject) object, locale); <line24> } else if (object instanceof JSONArray) { <line25> JSONArray jsonArray = (JSONArray) object; <line26> for (int i = 0; i < jsonArray.length(); i++) { <line27> Object currentObject = jsonArray.get(i); <line28> if (currentObject instanceof JSONObject) { <line29> _localize((JSONObject) currentObject, locale); <line30> } <line31> } <line32> } <line33> } <line34> } <line35> for (Map.Entry<String, String> entry : map.entrySet()) { <line36> jsonObject.put(entry.getKey(), entry.getValue()); <line37> } <line38> } <line39> } <line40> 	"<line17>              log.warn(StringBundler.concat(""Unable to find key "", key, "" in theme "", _themeId),missingResourceException);"	task4	
public class A { <line0> public static void log(String s) { <line1> } <line2> } <line3> 	<line1>    logger.info(s);	task4	
"public class A { <line0> protected String readOutsideFileFirstLine(File dispatchFile, String defaultValue) { <line1> BufferedReader br = null; <line2> try { <line3> br = new BufferedReader(new InputStreamReader(new FileInputStream(dispatchFile), ""UTF-8"")); <line4> final String line = br.readLine(); <line5> return line; <line6> } catch (Exception continued) { <line7> return defaultValue; <line8> } finally { <line9> if (br != null) { <line10> try { <line11> br.close(); <line12> } catch (IOException ignored) { <line13> } <line14> } <line15> } <line16> } <line17> } <line18> "	"<line7>      log.info(""Failed to read the dispatch file: "" + dispatchFile);"	task4	
public class A { <line0> private void handleAgentStatBatch(TAgentStatBatch tAgentStatBatch) { <line1> final List<AgentEventBo> agentEventBoList = this.agentEventBatchMapper.map(tAgentStatBatch); <line2> if (CollectionUtils.isEmpty(agentEventBoList)) { <line3> return; <line4> } <line5> try { <line6> for (AgentEventBo agentEventBo : agentEventBoList) { <line7> insert(agentEventBo); <line8> } <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> 	"<line10>      logger.warn(""Failed to handle AgentStatBatch={}"", tAgentStatBatch, e);"	task4	
public class A { <line0> @Override <line1> public void rollback() { <line2> try { <line3> m_transactedSession.rollback(); <line4> } catch (final JMSException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.error(""Failed to rollback transacted session [session={}]"", m_transactedSession, e);"	task4	
public class A { <line0> private boolean isFullyExpired(ZonedDateTime beginningOfRetentionPeriod, BucketName bucketName) { <line1> Optional<ZonedDateTime> maybeEndDate = nameGenerator.bucketEndTime(bucketName); <line2> if (!maybeEndDate.isPresent()) { <line3> } <line4> return maybeEndDate.map(endDate -> endDate.isBefore(beginningOfRetentionPeriod)).orElse(false); <line5> } <line6> } <line7> 	"<line3>      LOGGER.error(""Pattern used for bucketName used in deletedMessageVault is invalid and end date cannot""+ "" be parsed {}"",bucketName);"	task4	
public class A { <line0> private InterpreterResult runQuery(String cypherQuery, InterpreterContext interpreterContext) { <line1> if (StringUtils.isBlank(cypherQuery)) { <line2> return new InterpreterResult(Code.SUCCESS); <line3> } <line4> try { <line5> Iterator<Record> result = <line6> this.neo4jConnectionManager.execute(cypherQuery, interpreterContext).iterator(); <line7> Set<Node> nodes = new HashSet<>(); <line8> Set<Relationship> relationships = new HashSet<>(); <line9> List<String> columns = new ArrayList<>(); <line10> List<List<String>> lines = new ArrayList<List<String>>(); <line11> while (result.hasNext()) { <line12> Record record = result.next(); <line13> List<Pair<String, Value>> fields = record.fields(); <line14> List<String> line = new ArrayList<>(); <line15> for (Pair<String, Value> field : fields) { <line16> if (field.value().hasType(InternalTypeSystem.TYPE_SYSTEM.NODE())) { <line17> nodes.add(field.value().asNode()); <line18> } else if (field.value().hasType(InternalTypeSystem.TYPE_SYSTEM.RELATIONSHIP())) { <line19> relationships.add(field.value().asRelationship()); <line20> } else if (field.value().hasType(InternalTypeSystem.TYPE_SYSTEM.PATH())) { <line21> nodes.addAll(Iterables.asList(field.value().asPath().nodes())); <line22> relationships.addAll(Iterables.asList(field.value().asPath().relationships())); <line23> } else { <line24> setTabularResult( <line25> field.key(), field.value(), columns, line, InternalTypeSystem.TYPE_SYSTEM); <line26> } <line27> } <line28> if (!line.isEmpty()) { <line29> lines.add(line); <line30> } <line31> } <line32> if (!nodes.isEmpty()) { <line33> return renderGraph(nodes, relationships); <line34> } else { <line35> return renderTable(columns, lines); <line36> } <line37> } catch (Exception e) { <line38> return new InterpreterResult(Code.ERROR, e.getMessage()); <line39> } <line40> } <line41> } <line42> 	"<line38>      LOGGER.error(""Exception while interpreting cypher query"", e);"	task4	
public class A { <line0> public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) { <line1> this.setPageFromDynaProperty(); <line2> ServletContext application = getServlet().getServletContext(); <line3> ActionErrors errors = new ActionErrors(); <line4> String validationKey = getValidationKey(mapping, request); <line5> Validator validator = <line6> Resources.initValidator(validationKey, this, application, request, errors, page); <line7> try { <line8> validatorResults = validator.validate(); <line9> } catch (ValidatorException e) { <line10> } <line11> return errors; <line12> } <line13> } <line14> 	<line10>      log.error(e.getMessage(), e);	task4	
public class A { <line0> public synchronized void close() { <line1> key.cancel(); <line2> try { <line3> channel.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOGGER.error(() -> ""Error closing channel at: "" + remoteAddress, e);"	task4	
public class A { <line0> public void waitSensorActive(@Nonnull Sensor[] mSensors) { <line1> waitSensorState(mSensors, Sensor.ACTIVE); <line2> } <line3> } <line4> 	"<line1>    log.debug(""waitSensorActive[] starts"");"	task4	
public class A { <line0> private DatabaseConcept getDatabaseConcept(Map<String, Object> settings) { <line1> String concept = (String) settings.get(this.databaseConceptDefinition.getKey()); <line2> if (concept == null || concept.isEmpty()) { <line3> String hibernateDirectories = <line4> (String) settings.get(HibernateDatasourceConstants.HIBERNATE_DIRECTORY); <line5> concept = DatabaseConcept.SIMPLE.name(); <line6> if (hibernateDirectories.contains(HIBERNATE_MAPPING_EREPORTING_CONCEPT_PATH)) { <line7> concept = DatabaseConcept.EREPORTING.name(); <line8> } else if (hibernateDirectories.contains(HIBERNATE_MAPPING_TRANSACTIONAL_CONCEPT_PATH)) { <line9> concept = DatabaseConcept.TRANSACTIONAL.name(); <line10> } <line11> } <line12> return DatabaseConcept.valueOf(concept); <line13> } <line14> } <line15> 	<line11>      LOG.error(SETTING_NOT_FOUND_TEMPLATE,databaseConceptDefinition.getKey(),HibernateDatasourceConstants.HIBERNATE_DIRECTORY,concept,databaseConceptDefinition.getKey(),concept);	task4	
"public class A { <line0> public void createView(String name, String tableName, String... columnNames) throws SQLException { <line1> if (columnNames.length == 0) { <line2> throw new IllegalArgumentException(""Must specify at least one column when creating a view""); <line3> } <line4> StringBuilder statement = new StringBuilder(); <line5> statement.append(""CREATE VIEW ""); <line6> statement.append(quoteCaseSensitive(name)); <line7> statement.append("" (""); <line8> statement.append(Arrays.stream(columnNames).collect(Collectors.joining(""\"", \"""", ""\"""", ""\""""))); <line9> statement.append("") AS SELECT ""); <line10> statement.append(Arrays.stream(columnNames).collect(Collectors.joining(""\"", \"""", ""\"""", ""\""""))); <line11> statement.append("" FROM ""); <line12> statement.append(quoteCaseSensitive(tableName)); <line13> Statement stmt = conn.createStatement(); <line14> String statementStr = statement.toString(); <line15> stmt.execute(statementStr); <line16> } <line17> } <line18> "	"<line15>    log.debug(""Creating view {} in {} with statement {}"", name, this.name, statementStr);"	task4	
public class A { <line0> public boolean keyExists(String keyName) throws IOException { <line1> try { <line2> iam.projects().serviceAccounts().keys().get(keyName).execute(); <line3> return true; <line4> } catch (GoogleJsonResponseException e) { <line5> if (e.getStatusCode() == 403 || e.getStatusCode() == 404) { <line6> return false; <line7> } <line8> throw e; <line9> } <line10> } <line11> } <line12> 	"<line5>      LOG.info(""Couldn't check existence of key {} {} {}"",keyName,e.getStatusCode(),e.getDetails().toPrettyString(),e);"	task4	
public class A { <line0> @Test <line1> public void testCopyFormSize() { <line2> for (String bcp47tag : PoPluralRule.mappingForNonDefault.keySet()) { <line3> PluralRules cldrPluralRule = PluralRules.forLocale(Locale.forLanguageTag(bcp47tag)); <line4> int cldrSize = cldrPluralRule.getKeywords().size(); <line5> int poSize = PoPluralRule.fromBcp47Tag(bcp47tag).getCldrForms().size(); <line6> int copySize = <line7> PoPluralRule.fromBcp47Tag(bcp47tag).getFormsToCopyOnImport().getFormMap().values().size(); <line8> Assert.assertEquals(copySize, cldrSize - poSize); <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.debug(""{} --> cldr size: {}, po size: {}, copy size: {}"", bcp47tag, cldrSize, poSize, copySize);"	task4	
"public class A { <line0> public Settings getEffectiveSettings() throws BootstrapMavenException { <line1> if (settings != null) { <line2> return settings; <line3> } <line4> final DefaultSettingsBuildingRequest settingsRequest = <line5> new DefaultSettingsBuildingRequest() <line6> .setSystemProperties(System.getProperties()) <line7> .setUserSettingsFile(getUserSettings()) <line8> .setGlobalSettingsFile(getGlobalSettings()); <line9> final Properties cmdLineProps = getCliOptions().getSystemProperties(); <line10> if (cmdLineProps != null) { <line11> settingsRequest.setUserProperties(cmdLineProps); <line12> } <line13> final Settings effectiveSettings; <line14> try { <line15> final SettingsBuildingResult result = <line16> new DefaultSettingsBuilderFactory().newInstance().build(settingsRequest); <line17> final List<SettingsProblem> problems = result.getProblems(); <line18> if (!problems.isEmpty()) { <line19> for (SettingsProblem problem : problems) { <line20> switch (problem.getSeverity()) { <line21> case ERROR: <line22> case FATAL: <line23> throw new BootstrapMavenException( <line24> ""Settings problem encountered at "" + problem.getLocation(), <line25> problem.getException()); <line26> default: <line27> } <line28> } <line29> } <line30> effectiveSettings = result.getEffectiveSettings(); <line31> } catch (SettingsBuildingException e) { <line32> throw new BootstrapMavenException(""Failed to initialize Maven repository settings"", e); <line33> } <line34> return settings = effectiveSettings; <line35> } <line36> } <line37> "	"<line27>              log.warn(""Settings problem encountered at "" + problem.getLocation(),problem.getException());"	task4	
public class A { <line0> @Override <line1> public <K, V> Map<K, V> createLRUWeakCache(int maximumCacheSize) { <line2> return new SimpleLRUCache<>(maximumCacheSize); <line3> } <line4> } <line5> 	"<line2>    LOG.trace(""Creating LRUWeakCache with maximumCacheSize: {}"", maximumCacheSize);"	task4	
"public class A { <line0> @RuleAction(label = ""disarm"", description = ""Dis-arm"") <line1> public void disarm( <line2> @ActionInput(name = ""pin"", label = ""pin"", description = ""The pin 4 or 6 digit pin"") @Nullable <line3> String pin) { <line4> ThingHandlerPartition handler = this.handler; <line5> if (handler == null) { <line6> return; <line7> } <line8> String adjustedPin = adjustPin(pin); <line9> if (adjustedPin == null) { <line10> return; <line11> } <line12> handler.disarm(adjustedPin); <line13> } <line14> } <line15> "	<line6>      logger.debug(HANDLER_IS_NULL);	task4	
"public class A { <line0> @Test(groups = {""Integration"", ""Broken""}) <line1> public void testRetryBackoffs() { <line2> final Stopwatch stopwatch = Stopwatch.createStarted(); <line3> final List<Duration> timestamps = Lists.newArrayList(); <line4> final Supplier<Object> supplier = <line5> new Supplier<Object>() { <line6> @Override <line7> public Object get() { <line8> timestamps.add(Duration.of(stopwatch)); <line9> return ""myActualVal""; <line10> } <line11> }; <line12> try { <line13> TestFrameworkAssertions.checkAssertionsEventually( <line14> new AssertionOptions(""myTarget"", supplier) <line15> .timeout(Duration.seconds(1)) <line16> .backoffToPeriod(Duration.millis(100)) <line17> .assertions(Arrays.asList(ImmutableMap.of(""isEqualTo"", ""myExpectedVal"")))); <line18> Asserts.shouldHaveFailedPreviously(); <line19> } catch (AssertionError e) { <line20> Asserts.expectedFailureContains( <line21> e, ""myTarget expected isEqualTo myExpectedVal but found myActualVal""); <line22> } <line23> List<Duration> timestampDiffs = getDiffsBetweenTimes(timestamps); <line24> Duration initialDelay = Duration.millis(10); <line25> Duration finalDelay = Duration.millis(100); <line26> Duration earlyTollerance = Duration.millis(10); <line27> Duration lateTollerance = Duration.millis(50); <line28> Duration firstLateTollerance = Duration.millis(250); <line29> double multiplier = 1.2; <line30> for (int iteration = 1; iteration < timestampDiffs.size(); iteration++) { <line31> Duration actualDelay = timestampDiffs.get(iteration); <line32> Duration expectedDelay = initialDelay; <line33> for (int i = 0; i < iteration; i++) { <line34> expectedDelay = expectedDelay.multiply(multiplier); <line35> if (finalDelay != null && expectedDelay.compareTo(finalDelay) > 0) { <line36> expectedDelay = finalDelay; <line37> break; <line38> } <line39> } <line40> Duration min = Duration.max(expectedDelay.subtract(earlyTollerance), Duration.ZERO); <line41> Duration max = expectedDelay.add((iteration == 0) ? firstLateTollerance : lateTollerance); <line42> String errMsg = ""invalid time-diff at "" + iteration + "": "" + timestampDiffs; <line43> assertOrdered(ImmutableList.of(min, actualDelay, max), errMsg); <line44> } <line45> } <line46> } <line47> "	"<line24>    LOG.info(""timestampDiffs="" + timestampDiffs + ""; timestamps="" + timestamps);"	task4	
"public class A { <line0> @Override <line1> public List<AccountReport> listReports(String accountId, String report) throws IOException { <line2> if (StringUtils.isBlank(report)) { <line3> throw new IllegalArgumentException(""You must specify the report you want to run.""); <line4> } <line5> String url = <line6> buildCanvasUrl(""accounts/"" + accountId + ""/reports/"" + report, Collections.emptyMap()); <line7> return getListFromCanvas(url); <line8> } <line9> } <line10> "	"<line5>    LOG.debug(""Retrieving information about all "" + report + "" reports for account "" + accountId);"	task4	
public class A { <line0> private static String[] getColumnNames(CassandraMapping mapping, List<String> fields) { <line1> ArrayList<String> columnNames = new ArrayList<>(); <line2> for (String field : fields) { <line3> Field fieldBean = mapping.getFieldFromFieldName(field); <line4> CassandraKey cassandraKey = mapping.getCassandraKey(); <line5> Field keyBean = null; <line6> if (cassandraKey != null) { <line7> keyBean = cassandraKey.getFieldFromFieldName(field); <line8> } <line9> if (fieldBean != null) { <line10> columnNames.add(fieldBean.getColumnName()); <line11> } else if (keyBean != null) { <line12> columnNames.add(keyBean.getColumnName()); <line13> } else { <line14> } <line15> } <line16> return columnNames.toArray(new String[0]); <line17> } <line18> } <line19> 	"<line14>        LOG.warn(""{} field is ignored, couldn't find relevant field in the persistent mapping"", field);"	task4	
public class A { <line0> public void setProtocolManagerFactoryStr(final String protocolManagerFactoryStr) { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> raProperties.setProtocolManagerFactoryStr(protocolManagerFactoryStr); <line4> } <line5> } <line6> 	"<line2>      logger.trace(""setProtocolManagerFactoryStr("" + protocolManagerFactoryStr + "")"");"	task4	
"public class A { <line0> public static boolean hasTokenExpired(EmailConfig emailConfig, Token token) <line1> throws NoSuchAlgorithmException { <line2> boolean result = false; <line3> int maxConfigSeconds = <line4> emailConfig.getPasswordResetConfig().getTokenExpirationSeconds().intValue(); <line5> int maxTokenSeconds = token.getExpireSeconds().intValue(); <line6> long createdTime = token.getCreatedAtItem().getTime(); <line7> long configExpirationTime = createdTime + maxConfigSeconds * 1000; <line8> long tokenDefinedExirationTime = createdTime + maxTokenSeconds * 1000; <line9> if (configExpirationTime != tokenDefinedExirationTime) { <line10> String msg = <line11> String.format( <line12> ""The configured expiration time for the token = '%s' changed from when the token was"" <line13> + "" created."", <line14> token.getId()); <line15> } <line16> if (System.currentTimeMillis() >= configExpirationTime) { <line17> result = true; <line18> } <line19> return result; <line20> } <line21> } <line22> "	<line15>      logger.warn(msg);	task4	
public class A { <line0> private void grantAllWithoutLock(KijiUser user) throws IOException { <line1> KijiPermissions newPermissions = getPermissions(user); <line2> for (KijiPermissions.Action action : KijiPermissions.Action.values()) { <line3> newPermissions = newPermissions.addAction(action); <line4> } <line5> grantInstancePermissions(user, newPermissions); <line6> } <line7> } <line8> 	"<line1>    LOG.debug(""Granting all permissions to user {} on instance '{}'."",user.getName(),mInstanceUri.toOrderedString());"	task4	
public class A { <line0> public static MemcachedCache create( <line1> final MemcachedCacheConfig config, String memcachedPrefix, int timeToLive) { <line2> try { <line3> SerializingTranscoder transcoder = new SerializingTranscoder(config.getMaxObjectSize()); <line4> transcoder.setCompressionThreshold(Integer.MAX_VALUE); <line5> OperationQueueFactory opQueueFactory; <line6> int maxQueueSize = config.getMaxOperationQueueSize(); <line7> if (maxQueueSize > 0) { <line8> opQueueFactory = new ArrayOperationQueueFactory(maxQueueSize); <line9> } else { <line10> opQueueFactory = new LinkedOperationQueueFactory(); <line11> } <line12> String hostsStr = config.getHosts(); <line13> ConnectionFactory connectionFactory = <line14> new MemcachedConnectionFactoryBuilder() <line15> .setProtocol(ConnectionFactoryBuilder.Protocol.BINARY) <line16> .setHashAlg(DefaultHashAlgorithm.FNV1A_64_HASH) <line17> .setLocatorType(ConnectionFactoryBuilder.Locator.CONSISTENT) <line18> .setDaemon(true) <line19> .setFailureMode(FailureMode.Redistribute) <line20> .setTranscoder(transcoder) <line21> .setShouldOptimize(true) <line22> .setOpQueueMaxBlockTime(config.getTimeout()) <line23> .setOpTimeout(config.getTimeout()) <line24> .setReadBufferSize(config.getReadBufferSize()) <line25> .setOpQueueFactory(opQueueFactory) <line26> .build(); <line27> return new MemcachedCache( <line28> new MemcachedClient( <line29> new MemcachedConnectionFactory(connectionFactory), getResolvedAddrList(hostsStr)), <line30> config, <line31> memcachedPrefix, <line32> timeToLive); <line33> } catch (IOException e) { <line34> throw Throwables.propagate(e); <line35> } <line36> } <line37> } <line38> 	"<line34>      logger.error(""Unable to create MemcachedCache instance."", e);"	task4	
"public class A { <line0> protected NodeList select(DocumentSet docs) <line1> throws PermissionDeniedException, EXistException, XPathException { <line2> final XQuery xquery = broker.getBrokerPool().getXQueryService(); <line3> final XQueryPool pool = broker.getBrokerPool().getXQueryPool(); <line4> final Source source = new StringSource(selectStmt); <line5> CompiledXQuery compiled = pool.borrowCompiledXQuery(broker, source); <line6> XQueryContext context; <line7> if (compiled == null) { <line8> context = new XQueryContext(broker.getBrokerPool()); <line9> } else { <line10> context = compiled.getContext(); <line11> context.prepareForReuse(); <line12> } <line13> context.setStaticallyKnownDocuments(docs); <line14> declareNamespaces(context); <line15> declareVariables(context); <line16> if (compiled == null) <line17> try { <line18> compiled = xquery.compile(broker, context, source); <line19> } catch (final IOException e) { <line20> throw new EXistException( <line21> ""An exception occurred while compiling the query: "" + e.getMessage()); <line22> } <line23> Sequence resultSeq = null; <line24> try { <line25> resultSeq = xquery.execute(broker, compiled, null); <line26> } finally { <line27> context.runCleanupTasks(); <line28> pool.returnCompiledXQuery(source, compiled); <line29> } <line30> if (!(resultSeq.isEmpty() || Type.subTypeOf(resultSeq.getItemType(), Type.NODE))) { <line31> throw new EXistException( <line32> ""select expression should evaluate to a node-set; got "" <line33> + Type.getTypeName(resultSeq.getItemType())); <line34> } <line35> if (LOG.isDebugEnabled()) { <line36> } <line37> return resultSeq.toNodeSet(); <line38> } <line39> } <line40> "	"<line36>      LOG.debug(""found {} for select: {}"", resultSeq.getItemCount(), selectStmt);"	task4	
"public class A { <line0> private void validateCloud(final Cloud cloud) { <line1> if (cloud == null) { <line2> throw new InvalidParameterException(""Cloud"" + NULL_ERROR_MESSAGE); <line3> } <line4> if (Utilities.isEmpty(cloud.getName())) { <line5> throw new InvalidParameterException(""Cloud name"" + EMPTY_OR_NULL_ERROR_MESSAGE); <line6> } <line7> if (Utilities.isEmpty(cloud.getOperator())) { <line8> throw new InvalidParameterException(""Cloud operator"" + EMPTY_OR_NULL_ERROR_MESSAGE); <line9> } <line10> } <line11> } <line12> "	"<line1>    logger.debug(""validateCloudResponseDTO started..."");"	task4	
public class A { <line0> @Override <line1> public boolean isMovable(long classPK) throws PortalException { <line2> DLFileShortcut dlFileShortcut = getDLFileShortcut(classPK); <line3> try { <line4> DLFolder parentFolder = dlFileShortcut.getDLFolder(); <line5> return parentFolder.isInTrash(); <line6> } catch (NoSuchFolderException noSuchFolderException) { <line7> if (log.isDebugEnabled()) { <line8> } <line9> return true; <line10> } <line11> } <line12> } <line13> 	<line8>        log.debug(noSuchFolderException, noSuchFolderException);	task4	
public class A { <line0> public void addPreFilter(String filter) { <line1> if (!Arrays.asList(OpenCV.getPossibleFilters()).contains(filter)) { <line2> return; <line3> } <line4> preFilters.add(filter); <line5> if (instance.opencv != null && (instance.opencv.getFilter(filter) == null)) { <line6> instance.opencv.addFilter(filter).enable(); <line7> } <line8> } <line9> } <line10> 	"<line2>      log.error(""Sorry, {} is an unknown filter."", filter);"	task4	
public class A { <line0> public Set<AbstractPlugin> getPlugins(final String viewName) { <line1> if (pluginCache.isEmpty()) { <line2> load(); <line3> } <line4> return pluginCache.getOrDefault(viewName, Collections.emptySet()); <line5> } <line6> } <line7> 	"<line2>      LOGGER.info(""Plugin cache miss, reload"");"	task4	
public class A { <line0> @Override <line1> public void stsRevocationRegistryInstantiationError() { <line2> } <line3> } <line4> 	"<line2>    logger.warn(""Error instantiating revocation registry class - using default registry"");"	task4	
"public class A { <line0> void writeSpdxLicenseInfoIntoRelease(ResourceRequest request, ResourceResponse response) { <line1> User user = UserCacheHolder.getUserFromRequest(request); <line2> String releaseId = request.getParameter(PortalConstants.RELEASE_ID); <line3> ComponentService.Iface componentClient = thriftClients.makeComponentClient(); <line4> RequestStatus result = null; <line5> try { <line6> Release release = componentClient.getReleaseById(releaseId, user); <line7> JsonNode input = <line8> OBJECT_MAPPER.readValue(request.getParameter(SPDX_LICENSE_INFO), JsonNode.class); <line9> JsonNode licenesIdsNode = input.get(LICENSE_IDS); <line10> if (null != licenesIdsNode) { <line11> if (licenesIdsNode.isArray()) { <line12> for (JsonNode objNode : licenesIdsNode) { <line13> release.addToMainLicenseIds(objNode.asText()); <line14> } <line15> } else { <line16> release.addToMainLicenseIds(licenesIdsNode.asText()); <line17> } <line18> } <line19> licenesIdsNode = input.get(""otherLicenseIds""); <line20> if (null != licenesIdsNode) { <line21> if (licenesIdsNode.isArray()) { <line22> for (JsonNode objNode : licenesIdsNode) { <line23> release.addToOtherLicenseIds(objNode.asText()); <line24> } <line25> } else { <line26> release.addToOtherLicenseIds(licenesIdsNode.asText()); <line27> } <line28> } <line29> result = componentClient.updateRelease(release, user); <line30> } catch (TException | IOException e) { <line31> response.setProperty(ResourceResponse.HTTP_STATUS_CODE, ""500""); <line32> } <line33> serveRequestStatus( <line34> request, response, result, ""Cannot write license info into release "" + releaseId, log); <line35> } <line36> } <line37> "	"<line31>      log.error(""Cannot write license info into release "" + releaseId + ""."", e);"	task4	
"public class A { <line0> @RequestMapping(path = ""/v1/faqs"", method = RequestMethod.GET) <line1> public ResponseEntity<Object> getFAQSByWidget( <line2> @RequestParam(""widgetId"") String widgetId, <line3> @RequestParam(name = ""domainId"", required = false) String domainId) { <line4> if (Strings.isNullOrEmpty(widgetId)) { <line5> return ResponseUtils.buildFailureResponse(new Exception(""WidgetId is Mandatory"")); <line6> } <line7> ResponseDTO response = null; <line8> try { <line9> response = new ResponseDTO(faqService.getFAQSByWidget(widgetId, domainId)); <line10> } catch (ServiceException e) { <line11> return complianceService.formatException(e); <line12> } <line13> return ResponseUtils.buildSucessResponse(response); <line14> } <line15> } <line16> "	<line11>      LOGGER.error(e.getMessage());	task4	
public class A { <line0> @Override <line1> public void addDoubleField(String fieldName, double value) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> fieldList.add(new JSONFieldHolder(fieldName, value, FieldType.DOUBLE)); <line5> } <line6> } <line7> 	"<line3>      logger.trace(""addDoubleField fieldName: {}; value: {}"", fieldName, value);"	task4	
public class A { <line0> @Override <line1> public ILSMComponentId getId() throws HyracksDataException { <line2> if (componentId != null) { <line3> return componentId; <line4> } <line5> synchronized (this) { <line6> if (componentId == null) { <line7> componentId = LSMComponentIdUtils.readFrom(metadata, buffer); <line8> } <line9> } <line10> if (componentId.missing()) { <line11> } <line12> return componentId; <line13> } <line14> } <line15> 	"<line11>      LOGGER.warn(""Component Id not found from disk component metadata"");"	task4	
public class A { <line0> private void resetDatabase(MeshTestSetting settings) throws Exception { <line1> meshDagger.boot().clearReferences(); <line2> long start = System.currentTimeMillis(); <line3> if (settings.inMemoryDB()) { <line4> meshDagger.database().clear(); <line5> } else if (settings.clusterMode()) { <line6> meshDagger.database().clear(); <line7> } else { <line8> meshDagger.database().stop(); <line9> String dir = mesh.getOptions().getStorageOptions().getDirectory(); <line10> File dbDir = new File(dir); <line11> FileUtils.deleteDirectory(dbDir); <line12> meshDagger.database().setupConnectionPool(); <line13> } <line14> long duration = System.currentTimeMillis() - start; <line15> if (trackingSearchProvider != null) { <line16> trackingSearchProvider.reset(); <line17> } <line18> } <line19> } <line20> 	"<line15>    log.info(""Clearing DB took {"" + duration + ""} ms."");"	task4	
"public class A { <line0> private Argument readArgument(SpaceSystem spaceSystem) <line1> throws IllegalStateException, XMLStreamException { <line2> checkStartElementPreconditions(); <line3> Argument arg = null; <line4> StartElement element = xmlEvent.asStartElement(); <line5> String name = readMandatoryAttribute(""name"", element); <line6> arg = new Argument(name); <line7> String initialValue = readAttribute(""initialValue"", element, null); <line8> String argumentTypeRef = readMandatoryAttribute(""argumentTypeRef"", element); <line9> ArgumentType atype = spaceSystem.getArgumentType(argumentTypeRef); <line10> if (atype != null) { <line11> arg.setArgumentType(atype); <line12> if (initialValue != null) { <line13> arg.setInitialValue(atype.parseString(initialValue)); <line14> } <line15> } else { <line16> final Argument arg1 = arg; <line17> NameReference nr = <line18> new NameReference(argumentTypeRef, Type.ARGUMENT_TYPE) <line19> .addResolvedAction( <line20> nd -> { <line21> ArgumentType atype1 = (ArgumentType) nd; <line22> if (initialValue != null) { <line23> arg1.setInitialValue(atype1.parseString(initialValue)); <line24> } <line25> arg1.setArgumentType(atype1); <line26> }); <line27> spaceSystem.addUnresolvedReference(nr); <line28> } <line29> arg.setShortDescription(readAttribute(""shortDescription"", element, null)); <line30> while (true) { <line31> xmlEvent = xmlEventReader.nextEvent(); <line32> if (isNamedItemProperty()) { <line33> readNamedItemProperty(arg); <line34> } else if (isEndElementWithName(XTCE_ARGUMENT)) { <line35> return arg; <line36> } else { <line37> logUnknown(); <line38> } <line39> } <line40> } <line41> } <line42> "	<line2>    log.trace(XTCE_ARGUMENT);	task4	
public class A { <line0> private void removePropertyMapping(ExtensionMapping extensionMapping, String qualifiedName) { <line1> PropertyMapping pm = extensionMapping.getField(qualifiedName); <line2> Set<PropertyMapping> propertyMappings = extensionMapping.getFields(); <line3> if (pm != null && propertyMappings.contains(pm)) { <line4> propertyMappings.remove(pm); <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.debug(""Removed mapping to term "" + pm.getTerm().qualifiedName());"	task4	
public class A { <line0> @Nullable <line1> public String getInvocationType(final Node propNode) { <line2> final NodeList appProps = propNode.getChildNodes(); <line3> for (int i = 0; i < appProps.getLength(); i++) { <line4> final Node addProp = appProps.item(i); <line5> if (addProp.getNodeType() == Node.ELEMENT_NODE) { <line6> if (addProp.getLocalName().equals(INVOCATION_TYPE)) { <line7> final String invocationType = addProp.getTextContent().trim(); <line8> return invocationType; <line9> } <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line8>          LOG.debug(""InvocationType property: {}"", invocationType);"	task4	
"public class A { <line0> private void checkSystemRequestDTO(final SystemRequestDTO system, final String origin) { <line1> if (system == null) { <line2> throw new BadPayloadException( <line3> ""System"" + NULL_PARAMETER_ERROR_MESSAGE, HttpStatus.SC_BAD_REQUEST, origin); <line4> } <line5> if (Utilities.isEmpty(system.getSystemName())) { <line6> throw new BadPayloadException( <line7> ""System name"" + NULL_OR_BLANK_PARAMETER_ERROR_MESSAGE, HttpStatus.SC_BAD_REQUEST, origin); <line8> } <line9> if (Utilities.isEmpty(system.getAddress())) { <line10> throw new BadPayloadException( <line11> ""System address"" + NULL_OR_BLANK_PARAMETER_ERROR_MESSAGE, <line12> HttpStatus.SC_BAD_REQUEST, <line13> origin); <line14> } <line15> if (system.getPort() == null) { <line16> throw new BadPayloadException( <line17> ""System port"" + NULL_PARAMETER_ERROR_MESSAGE, HttpStatus.SC_BAD_REQUEST, origin); <line18> } <line19> final int validatedPort = system.getPort().intValue(); <line20> if (validatedPort < CommonConstants.SYSTEM_PORT_RANGE_MIN <line21> || validatedPort > CommonConstants.SYSTEM_PORT_RANGE_MAX) { <line22> throw new BadPayloadException( <line23> ""System port must be between "" <line24> + CommonConstants.SYSTEM_PORT_RANGE_MIN <line25> + "" and "" <line26> + CommonConstants.SYSTEM_PORT_RANGE_MAX <line27> + ""."", <line28> HttpStatus.SC_BAD_REQUEST, <line29> origin); <line30> } <line31> } <line32> } <line33> "	"<line1>    logger.debug(""checkSystemRequestDTO started..."");"	task4	
public class A { <line0> private void adjustDhModulus(DHEServerKeyExchangeMessage message) { <line1> tlsContext.setServerDhModulus(new BigInteger(1, message.getModulus().getValue())); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""Dh Modulus: "" + tlsContext.getServerDhModulus());"	task4	
"public class A { <line0> private JsonObject getVersionDetails(String fileName, String hostEndPoint, String type) <line1> throws IOException { <line2> String version = """"; <line3> String strResponse = """"; <line4> if (version.equalsIgnoreCase("""")) { <line5> version = ServicesHealthStatus.class.getPackage().getSpecificationVersion(); <line6> strResponse = ""Version captured as "" + version; <line7> return buildSuccessResponse(strResponse, hostEndPoint, type, version); <line8> } else { <line9> strResponse = <line10> ""Error while capturing PlatformService (version "" <line11> + version <line12> + "") health check at "" <line13> + hostEndPoint; <line14> return buildFailureResponse(strResponse, hostEndPoint, type, version); <line15> } <line16> } <line17> } <line18> "	"<line6>      log.info(""message version {} =================== "", version);"	task4	
"public class A { <line0> @Override <line1> public Node getContentAsDOM() throws XMLDBException { <line2> final InputSource is; <line3> InputStream cis = null; <line4> try { <line5> if (content != null) { <line6> is = new InputSource(new StringReader(content)); <line7> } else { <line8> cis = getStreamContent(); <line9> is = new InputSource(cis); <line10> } <line11> final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); <line12> factory.setNamespaceAware(true); <line13> factory.setValidating(false); <line14> final DocumentBuilder builder = factory.newDocumentBuilder(); <line15> final Document doc = builder.parse(is); <line16> final boolean isDocumentNode = type.map(t -> t.equals(""document-node()"")).orElse(true); <line17> if (isDocumentNode) { <line18> return doc; <line19> } else { <line20> return doc.getFirstChild(); <line21> } <line22> } catch (final SAXException | IOException | ParserConfigurationException e) { <line23> throw new XMLDBException(ErrorCodes.VENDOR_ERROR, e.getMessage(), e); <line24> } finally { <line25> if (cis != null) { <line26> try { <line27> cis.close(); <line28> } catch (final IOException ioe) { <line29> } <line30> } <line31> } <line32> } <line33> } <line34> "	<line29>          LOG.warn(ioe.getMessage(), ioe);	task4	
public class A { <line0> @Override <line1> public Boolean isDuplicateFile(String filepath) { <line2> return false; <line3> } <line4> } <line5> 	"<line2>    logger.info(""No metadata connection"");"	task4	
"public class A { <line0> @Override <line1> protected BindingSet getNextElement() throws QueryEvaluationException { <line2> if (error != null) { <line3> if (error instanceof QueryEvaluationException) { <line4> throw (QueryEvaluationException) error; <line5> } <line6> throw new QueryEvaluationException(error); <line7> } <line8> if (rightIter == null) { <line9> try { <line10> boolean completed = <line11> latch.await(getQueryInfo().getMaxRemainingTimeMS(), TimeUnit.MILLISECONDS); <line12> if (!completed) { <line13> throw new QueryInterruptedException(""Timeout during service evaluation""); <line14> } <line15> } catch (InterruptedException e) { <line16> error = e; <line17> } <line18> } <line19> if (error != null) { <line20> if (error instanceof QueryEvaluationException) { <line21> throw (QueryEvaluationException) error; <line22> } <line23> throw new QueryEvaluationException(error); <line24> } <line25> if (rightIter.hasNext()) { <line26> return rightIter.next(); <line27> } <line28> return null; <line29> } <line30> } <line31> "	"<line16>        log.debug(""Error while evaluating service expression. Thread got interrupted."");"	task4	
public class A { <line0> private void tearDownSharedResources() throws Exception { <line1> if (testInfo.isAddressSpaceDeleteable() <line2> || testInfo.getActualTest().getExecutionException().isPresent()) { <line3> sharedResourcesManager.tearDown(testInfo.getActualTest()); <line4> } else if (sharedResourcesManager.getSharedAddressSpace() != null) { <line5> sharedResourcesManager.tearDownShared(); <line6> } <line7> } <line8> } <line9> 	"<line3>      LOGGER.info(""Teardown shared!"");"	task4	
public class A { <line0> private void removeConflictingNodeIds(final NodeIdentifier nodeIdentifier) { <line1> final Set<NodeIdentifier> conflictingNodeIds = findConflictingNodeIds(nodeIdentifier); <line2> if (!conflictingNodeIds.isEmpty()) { <line3> final Set<String> fullNodeIdDescriptions = <line4> conflictingNodeIds.stream() <line5> .map(NodeIdentifier::getFullDescription) <line6> .collect(Collectors.toSet()); <line7> conflictingNodeIds.forEach(uuid -> removeNode(uuid)); <line8> } <line9> } <line10> } <line11> 	"<line7>      logger.warn(""New Node {} was registered for this cluster, but this Node Identifier conflicts with {}""+ "" others: {}; each of these conflicting Node Identifiers will be removed from the""+ "" cluster"",nodeIdentifier.getFullDescription(),fullNodeIdDescriptions.size(),fullNodeIdDescriptions);"	task4	
"public class A { <line0> @Override <line1> public CPOptionValue fetchByC_ERC( <line2> long companyId, String externalReferenceCode, boolean useFinderCache) { <line3> externalReferenceCode = Objects.toString(externalReferenceCode, """"); <line4> Object[] finderArgs = null; <line5> if (useFinderCache) { <line6> finderArgs = new Object[] {companyId, externalReferenceCode}; <line7> } <line8> Object result = null; <line9> if (useFinderCache) { <line10> result = finderCache.getResult(_finderPathFetchByC_ERC, finderArgs); <line11> } <line12> if (result instanceof CPOptionValue) { <line13> CPOptionValue cpOptionValue = (CPOptionValue) result; <line14> if ((companyId != cpOptionValue.getCompanyId()) <line15> || !Objects.equals(externalReferenceCode, cpOptionValue.getExternalReferenceCode())) { <line16> result = null; <line17> } <line18> } <line19> if (result == null) { <line20> StringBundler sb = new StringBundler(4); <line21> sb.append(_SQL_SELECT_CPOPTIONVALUE_WHERE); <line22> sb.append(_FINDER_COLUMN_C_ERC_COMPANYID_2); <line23> boolean bindExternalReferenceCode = false; <line24> if (externalReferenceCode.isEmpty()) { <line25> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_3); <line26> } else { <line27> bindExternalReferenceCode = true; <line28> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_2); <line29> } <line30> String sql = sb.toString(); <line31> Session session = null; <line32> try { <line33> session = openSession(); <line34> Query query = session.createQuery(sql); <line35> QueryPos queryPos = QueryPos.getInstance(query); <line36> queryPos.add(companyId); <line37> if (bindExternalReferenceCode) { <line38> queryPos.add(externalReferenceCode); <line39> } <line40> List<CPOptionValue> list = query.list(); <line41> if (list.isEmpty()) { <line42> if (useFinderCache) { <line43> finderCache.putResult(_finderPathFetchByC_ERC, finderArgs, list); <line44> } <line45> } else { <line46> if (list.size() > 1) { <line47> Collections.sort(list, Collections.reverseOrder()); <line48> if (log.isWarnEnabled()) { <line49> if (!useFinderCache) { <line50> finderArgs = new Object[] {companyId, externalReferenceCode}; <line51> } <line52> } <line53> } <line54> CPOptionValue cpOptionValue = list.get(0); <line55> result = cpOptionValue; <line56> cacheResult(cpOptionValue); <line57> } <line58> } catch (Exception exception) { <line59> throw processException(exception); <line60> } finally { <line61> closeSession(session); <line62> } <line63> } <line64> if (result instanceof List<?>) { <line65> return null; <line66> } else { <line67> return (CPOptionValue) result; <line68> } <line69> } <line70> } <line71> "	"<line52>              log.warn(""CPOptionValuePersistenceImpl.fetchByC_ERC(long, String, boolean) with parameters""+ "" (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
public class A { <line0> public static void registerMBean(Object bean, ObjectName objectName) { <line1> MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer(); <line2> if (mBeanServer != null) { <line3> try { <line4> registerMBean(bean, mBeanServer, objectName); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        LOG.error(""Failed to register in JMX bean "" + bean + "" at "" + objectName + "". "" + e, e);"	task4	
"public class A { <line0> public static com.liferay.asset.kernel.model.AssetCategoryDisplay getVocabularyCategoriesDisplay( <line1> HttpPrincipal httpPrincipal, <line2> long vocabularyId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.asset.kernel.model.AssetCategory> <line6> orderByComparator) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> AssetCategoryServiceUtil.class, <line12> ""getVocabularyCategoriesDisplay"", <line13> _getVocabularyCategoriesDisplayParameterTypes20); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, vocabularyId, start, end, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.asset.kernel.model.AssetCategoryDisplay) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	<line27>      log.error(systemException, systemException);	task4	
"public class A { <line0> private void readTimeWindowedDepotAndCustomers() throws IOException { <line1> String line = bufferedReader.readLine(); <line2> int locationListSizeEstimation = 25; <line3> List<Location> locationList = new ArrayList<>(locationListSizeEstimation); <line4> depotList = new ArrayList<>(1); <line5> TimeWindowedDepot depot = null; <line6> List<Customer> customerList = new ArrayList<>(locationListSizeEstimation); <line7> boolean first = true; <line8> while (line != null && !line.trim().isEmpty()) { <line9> String[] lineTokens = splitBySpacesOrTabs(line.trim(), 7); <line10> long id = Long.parseLong(lineTokens[0]); <line11> AirLocation location = new AirLocation(); <line12> location.setId(id); <line13> location.setLatitude(Double.parseDouble(lineTokens[1])); <line14> location.setLongitude(Double.parseDouble(lineTokens[2])); <line15> locationList.add(location); <line16> int demand = Integer.parseInt(lineTokens[3]); <line17> long readyTime = Long.parseLong(lineTokens[4]) * 1000L; <line18> long dueTime = Long.parseLong(lineTokens[5]) * 1000L; <line19> long serviceDuration = Long.parseLong(lineTokens[6]) * 1000L; <line20> if (first) { <line21> depot = new TimeWindowedDepot(); <line22> depot.setId(id); <line23> depot.setLocation(location); <line24> if (demand != 0) { <line25> throw new IllegalArgumentException( <line26> ""The depot with id ("" + id + "") has a demand ("" + demand + "").""); <line27> } <line28> depot.setReadyTime(readyTime); <line29> depot.setDueTime(dueTime); <line30> if (serviceDuration != 0) { <line31> throw new IllegalArgumentException( <line32> ""The depot with id ("" + id + "") has a serviceDuration ("" + serviceDuration + "").""); <line33> } <line34> depotList.add(depot); <line35> first = false; <line36> } else { <line37> TimeWindowedCustomer customer = new TimeWindowedCustomer(); <line38> customer.setId(id); <line39> customer.setLocation(location); <line40> customer.setDemand(demand); <line41> customer.setReadyTime(readyTime); <line42> long maximumDueTime = <line43> depot.getDueTime() - serviceDuration - location.getDistanceTo(depot.getLocation()); <line44> if (dueTime > maximumDueTime) { <line45> dueTime = maximumDueTime; <line46> } <line47> customer.setDueTime(dueTime); <line48> customer.setServiceDuration(serviceDuration); <line49> if (demand != 0) { <line50> customerList.add(customer); <line51> } <line52> } <line53> line = bufferedReader.readLine(); <line54> } <line55> solution.setLocationList(locationList); <line56> solution.setDepotList(depotList); <line57> solution.setCustomerList(customerList); <line58> customerListSize = locationList.size(); <line59> } <line60> } <line61> "	"<line45>          logger.warn(""The customer ({})'s dueTime ({}) was automatically reduced""+ "" to maximumDueTime ({}) because of the depot's dueTime ({})."",customer,dueTime,maximumDueTime,depot.getDueTime());"	task4	
public class A { <line0> private Object castCollection(Object literal, String propertyName) { <line1> try { <line2> Collection<?> c = (Collection) literal; <line3> Iterator iterator = c.iterator(); <line4> List<Object> cast = new ArrayList<Object>(); <line5> while (iterator.hasNext()) { <line6> cast.add(castLiteral(iterator.next(), propertyName)); <line7> } <line8> return cast; <line9> } catch (Exception e) { <line10> } <line11> return literal; <line12> } <line13> } <line14> 	<line10>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> @Test(groups = {""Live""}) <line1> protected void testAwsEc2Addresses() throws Exception { <line2> jcloudsLocation = <line3> (JcloudsLocation) <line4> managementContext.getLocationRegistry().getLocationManaged(AWS_EC2_LOCATION_SPEC); <line5> machine = createEc2Machine(ImmutableMap.<String, Object>of()); <line6> assertSshable(machine); <line7> String locationAddress = machine.getAddress().getHostName(); <line8> InetAddress address = machine.getAddress(); <line9> Set<String> publicAddresses = machine.getPublicAddresses(); <line10> Set<String> privateAddresses = machine.getPrivateAddresses(); <line11> String subnetIp = machine.getSubnetIp(); <line12> String subnetHostname = machine.getSubnetHostname(); <line13> String hostname = machine.getHostname(); <line14> String msg = <line15> ""locationAddress="" <line16> + locationAddress <line17> + ""; address="" <line18> + address <line19> + ""; publicAddrs="" <line20> + publicAddresses <line21> + ""; privateAddrs="" <line22> + privateAddresses <line23> + ""; subnetIp="" <line24> + subnetIp <line25> + ""; hostname="" <line26> + hostname <line27> + ""; subnetHostname="" <line28> + subnetHostname; <line29> assertReachable(machine, locationAddress, msg); <line30> assertReachableFromMachine(machine, locationAddress, msg); <line31> assertReachable(machine, address, msg); <line32> assertTrue(publicAddresses.size() > 0, msg); <line33> for (String publicAddress : publicAddresses) { <line34> assertReachable(machine, publicAddress, msg); <line35> } <line36> assertTrue(privateAddresses.size() > 0, msg); <line37> for (String privateAddress : privateAddresses) { <line38> assertReachableFromMachine(machine, privateAddress, msg); <line39> assertNotReachable(machine, privateAddress, msg); <line40> } <line41> assertNotNull(subnetIp, msg); <line42> assertReachableFromMachine(machine, subnetIp, msg); <line43> assertNotNull(hostname, msg); <line44> assertReachableFromMachine(machine, hostname, msg); <line45> assertNotNull(subnetHostname, msg); <line46> assertReachable(machine, subnetHostname, msg); <line47> assertReachableFromMachine(machine, subnetHostname, msg); <line48> } <line49> } <line50> "	"<line29>    LOG.info(""node: "" + msg);"	task4	
"public class A { <line0> protected LockedDocumentMap beginProtected( <line1> final DBBroker broker, final Map<String, Object> parameters) <line2> throws EXistException, PermissionDeniedException { <line3> final String protectColl = (String) parameters.get(RpcAPI.PROTECTED_MODE); <line4> if (protectColl == null) { <line5> return null; <line6> } <line7> int retries = <line8> BEGIN_PROTECTED_MAX_LOCKING_RETRIES == -1 ? -1 : BEGIN_PROTECTED_MAX_LOCKING_RETRIES - 2; <line9> do { <line10> MutableDocumentSet docs = null; <line11> final LockedDocumentMap lockedDocuments = new LockedDocumentMap(); <line12> final LockMode documentLockMode = LockMode.WRITE_LOCK; <line13> final LockMode collectionLockMode = <line14> broker <line15> .getBrokerPool() <line16> .getLockManager() <line17> .relativeCollectionLockMode(LockMode.READ_LOCK, documentLockMode); <line18> try (final Collection coll = <line19> broker.openCollection(XmldbURI.createInternal(protectColl), collectionLockMode)) { <line20> docs = new DefaultDocumentSet(); <line21> coll.allDocs(broker, docs, true, lockedDocuments, documentLockMode); <line22> return lockedDocuments; <line23> } catch (final LockException e) { <line24> lockedDocuments.unlock(); <line25> } <line26> retries--; <line27> } while (retries >= -1); <line28> throw new EXistException( <line29> ""Unable to beginProtected after "" + BEGIN_PROTECTED_MAX_LOCKING_RETRIES + "" retries""); <line30> } <line31> } <line32> "	"<line24>        LOG.warn(""Deadlock detected. Starting over again. Docs: {}; locked: {}. Cause: {}"",docs.getDocumentCount(),lockedDocuments.size(),e.getMessage());"	task4	
"public class A { <line0> public boolean isValidToken(String token) throws DAOException { <line1> LOGGER.entry(""begin isValidToken()""); <line2> Session session = null; <line3> boolean isValidStudy = false; <line4> EnrollmentTokenDto tokenDto = null; <line5> try { <line6> session = sessionFactory.openSession(); <line7> tokenDto = <line8> (EnrollmentTokenDto) <line9> session <line10> .createQuery( <line11> ""from EnrollmentTokenDto "" <line12> + "" where enrollmentToken= :enrollmentToken"" <line13> + "" ORDER BY id DESC"") <line14> .setString(""enrollmentToken"", token) <line15> .setMaxResults(1) <line16> .uniqueResult(); <line17> if (null != tokenDto) { <line18> isValidStudy = true; <line19> } <line20> } catch (Exception e) { <line21> } finally { <line22> if (session != null) { <line23> session.close(); <line24> } <line25> } <line26> LOGGER.exit(""isValidToken() :: Ends""); <line27> return isValidStudy; <line28> } <line29> } <line30> "	"<line21>      LOGGER.error(""StudyMetaDataDao - isValidToken() :: ERROR"", e);"	task4	
public class A { <line0> protected EditableDataValidationResult validateParameter( <line1> final ValidationContext validationContext, <line2> final UIInput inputComponent, <line3> final String contentType, <line4> final String paramName, <line5> final String paramValue) { <line6> FacesContext context = validationContext.getFacesContext(); <line7> validationContext.acceptParameter(paramName, paramValue); <line8> EditableDataValidationResult result = <line9> validateContent(context, paramName, paramValue, contentType); <line10> if (!result.isValid()) { <line11> FacesMessage msg = createFacesMessage(context, inputComponent); <line12> context.addMessage(paramName, msg); <line13> if (log.isDebugEnabled()) { <line14> } <line15> validationContext.rejectParameter( <line16> paramName, <line17> paramValue, <line18> HDIVErrorCodes.INVALID_EDITABLE_VALUE, <line19> result.getValidationId(), <line20> inputComponent); <line21> } <line22> return result; <line23> } <line24> } <line25> 	"<line14>        log.debug(""Parameter '""+ paramName+ ""' rejected in component '""+ inputComponent.getClientId()+ ""' in ComponentValidator '""+ this.getClass()+ ""'"");"	task4	
"public class A { <line0> public Structure update(final Structure structure) { <line1> if (!structure.getContent().equals(structure.getContent()) <line2> || !structure.getTemplate().getId().equals(structure.getTemplate().getId())) { <line3> boolean templateUsed = structureRepository.isStructureUsed(structure); <line4> if (templateUsed) { <line5> throw new PlatformRuntimeException( <line6> ""You can not edit this structure because the structure is assigned to at least a one"" <line7> + "" advanced web content.""); <line8> } <line9> } <line10> validateStructure(structure); <line11> return structureRepository.save(structure); <line12> } <line13> } <line14> "	"<line1>    log.debug(""update() - structure: {}"", structure);"	task4	
public class A { <line0> @Override <line1> public void init() { <line2> super.init(); <line3> Integer portStartingPoint; <line4> Object rawPort = getAllConfigBag().getStringKey(PORT_FORWARD_MANAGER_STARTING_PORT.getName()); <line5> if (rawPort != null) { <line6> portStartingPoint = getConfig(PORT_FORWARD_MANAGER_STARTING_PORT); <line7> } else { <line8> portStartingPoint = <line9> getManagementContext().getConfig().getConfig(PORT_FORWARD_MANAGER_STARTING_PORT); <line10> } <line11> portReserved.set(portStartingPoint); <line12> } <line13> } <line14> 	"<line12>    log.debug(this + "" set initial port to "" + portStartingPoint);"	task4	
"public class A { <line0> private static Protocol getProtocol(String protocol) { <line1> if (protocol.equals(""HTTP"")) { <line2> return Protocol.HTTP; <line3> } else if (protocol.equals(""HTTPS"")) { <line4> return Protocol.HTTPS; <line5> } else { <line6> } <line7> return null; <line8> } <line9> } <line10> "	"<line6>      LOG.warn(""Invalid protocol type {}."" + ""Avaiable proxy protocol type HTTP and HTTPS."", protocol);"	task4	
"public class A { <line0> @Override <line1> public FileUploadJob createJob( <line2> String filename, <line3> long filesize, <line4> int chunksize, <line5> MediaPackage mp, <line6> MediaPackageElementFlavor flavor) <line7> throws FileUploadException { <line8> FileUploadJob job = new FileUploadJob(filename, filesize, chunksize, mp, flavor); <line9> try { <line10> File jobDir = getJobDir(job.getId()); <line11> FileUtils.forceMkdir(jobDir); <line12> ensureExists(getPayloadFile(job.getId())); <line13> storeJob(job); <line14> } catch (FileUploadException e) { <line15> deleteJob(job.getId()); <line16> throw fileUploadException( <line17> Severity.error, ""Could not create job file in "" + workRoot.getAbsolutePath(), e); <line18> } catch (IOException e) { <line19> deleteJob(job.getId()); <line20> throw fileUploadException( <line21> Severity.error, <line22> ""Could not create upload job directory in "" + workRoot.getAbsolutePath(), <line23> e); <line24> } <line25> return job; <line26> } <line27> } <line28> "	"<line9>    logger.info(""Creating new upload job: {}"", job);"	task4	
public class A { <line0> @Override <line1> public void readNonExistent(String testName) throws Exception { <line2> setupReadNonExistent(); <line3> OsteologyClient client = new OsteologyClient(); <line4> Response res = client.read(NON_EXISTENT_ID); <line5> try { <line6> int statusCode = res.getStatus(); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> Assert.assertTrue( <line10> testRequestType.isValidStatusCode(statusCode), <line11> invalidStatusCodeMessage(testRequestType, statusCode)); <line12> Assert.assertEquals(statusCode, testExpectedStatusCode); <line13> } finally { <line14> res.close(); <line15> } <line16> } <line17> } <line18> 	"<line8>        logger.debug(testName + "": status = "" + statusCode);"	task4	
"public class A { <line0> @ApiOperation(value = ""get history by owner's id"") <line1> @GetMapping(CommonConstants.PATH_LOGBOOK) <line2> public LogbookOperationsResponseDto findHistoryById(final @PathVariable String id) { <line3> ParameterChecker.checkParameter(""Identifier is mandatory : "", id); <line4> return service.findHistoryById(buildUiHttpContext(), id); <line5> } <line6> } <line7> "	"<line3>    LOGGER.debug(""get logbook for owner with id :{}"", id);"	task4	
"public class A { <line0> @RequestMapping(value = ""/{id}"", method = RequestMethod.GET) <line1> public RoleDto find(@PathVariable Long id) { <line2> return roleManagementService.findRole(id); <line3> } <line4> } <line5> "	"<line2>    log.debug(""find() - id: {}"", id);"	task4	
"public class A { <line0> protected void scheduleWithLock() throws IOException { <line1> if (!LAUNCH_CATALOG.get()) { <line2> return; <line3> } <line4> Map<String, String> catalogs = null; <line5> while (true) { <line6> try { <line7> catalogs = catalogService.latestInfraTemplates(); <line8> break; <line9> } catch (IOException e) { <line10> try { <line11> Thread.sleep(2000); <line12> } catch (InterruptedException e1) { <line13> throw new IllegalStateException(e1); <line14> } <line15> } <line16> } <line17> if (catalogs.size() == 0) { <line18> return; <line19> } <line20> List<? extends Stack> stacks = Collections.emptyList(); <line21> if (""true"".equalsIgnoreCase(UPGRADE_MANAGER.get()) <line22> || ""all"".equalsIgnoreCase(UPGRADE_MANAGER.get())) { <line23> stacks = stackDao.getStacksToUpgrade(catalogs.values()); <line24> } else if (""mandatory"".equalsIgnoreCase(UPGRADE_MANAGER.get())) { <line25> stacks = stackDao.getStacksThatMatch(OLD_METADATAS); <line26> } <line27> for (Stack stack : stacks) { <line28> String templateId = catalogService.getTemplateIdFromExternalId(stack.getExternalId()); <line29> if (StringUtils.isBlank(templateId)) { <line30> continue; <line31> } <line32> if (catalogs.containsKey(templateId)) { <line33> resourceDao.createAndSchedule( <line34> ScheduledUpgrade.class, <line35> SCHEDULED_UPGRADE.ACCOUNT_ID, <line36> stack.getAccountId(), <line37> SCHEDULED_UPGRADE.STACK_ID, <line38> stack.getId()); <line39> } <line40> } <line41> } <line42> } <line43> "	"<line10>        log.info(""Waiting for catalog service"");"	task4	
public class A { <line0> public KeyPair generateKeyPair(String alg, int keySize) { <line1> try { <line2> KeyPairGenerator keyPairGenerator = null; <line3> keyPairGenerator = KeyPairGenerator.getInstance(alg); <line4> keyPairGenerator.initialize(keySize); <line5> return keyPairGenerator.generateKeyPair(); <line6> } catch (NoSuchAlgorithmException e) { <line7> } <line8> return null; <line9> } <line10> } <line11> 	"<line7>      log.error(""The provided algorithm is not found "", e);"	task4	
public class A { <line0> private Document parse(DocumentBuilder builder, URL url) throws IOException, SAXException { <line1> if (url == null) { <line2> return null; <line3> } <line4> URLConnection connection = url.openConnection(); <line5> if (connection instanceof JarURLConnection) { <line6> connection.setUseCaches(false); <line7> } <line8> return parse(builder, connection.getInputStream(), url.toString()); <line9> } <line10> } <line11> 	"<line1>    LOG.debug(""parsing URL "" + url);"	task4	
public class A { <line0> @Override <line1> public FeeData usageGiven(TransactionBody txn, SigValueObj sigUsage, StateView view) <line2> throws InvalidTxBodyException { <line3> try { <line4> MerkleEntityId id = fromContractId(txn.getContractUpdateInstance().getContractID()); <line5> Timestamp expiry = lookupAccountExpiry(id, view.accounts()); <line6> return usageEstimator.getContractUpdateTxFeeMatrices(txn, expiry, sigUsage); <line7> } catch (Exception e) { <line8> return FeeData.getDefaultInstance(); <line9> } <line10> } <line11> } <line12> 	"<line8>      log.debug(""Unable to deduce ContractUpdate usage for {}, using defaults"",txn.getTransactionID(),e);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (!Services.getInstance().isShuttingDown() && !Services.getInstance().isShutdownDone()) <line4> info.messageCallback(topic, message); <line5> } catch (FrameworkException e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      logger.error(""Error during MQTT message callback: "" + e.getMessage());"	task4	
public class A { <line0> private ProtocolInitializer createExternalProtocolInitializer( <line1> BoltProtocolFactory boltProtocolFactory, TransportThrottleGroup throttleGroup, Log log) { <line2> SslContext sslCtx; <line3> boolean requireEncryption; <line4> BoltConnector.EncryptionLevel encryptionLevel = config.get(BoltConnector.encryption_level); <line5> SslPolicyLoader sslPolicyLoader = dependencyResolver.resolveDependency(SslPolicyLoader.class); <line6> switch (encryptionLevel) { <line7> case REQUIRED: <line8> requireEncryption = true; <line9> sslCtx = createSslContext(sslPolicyLoader); <line10> break; <line11> case OPTIONAL: <line12> requireEncryption = false; <line13> sslCtx = createSslContext(sslPolicyLoader); <line14> break; <line15> case DISABLED: <line16> requireEncryption = false; <line17> sslCtx = null; <line18> break; <line19> default: <line20> requireEncryption = false; <line21> sslCtx = null; <line22> break; <line23> } <line24> SocketAddress listenAddress = config.get(BoltConnector.listen_address); <line25> Duration channelTimeout = <line26> config.get(BoltConnectorInternalSettings.unsupported_bolt_unauth_connection_timeout); <line27> long maxMessageSize = <line28> config.get( <line29> BoltConnectorInternalSettings.unsupported_bolt_unauth_connection_max_inbound_bytes); <line30> return new SocketTransport( <line31> BoltConnector.NAME, <line32> listenAddress, <line33> sslCtx, <line34> requireEncryption, <line35> logService.getInternalLogProvider(), <line36> throttleGroup, <line37> boltProtocolFactory, <line38> connectionTracker, <line39> channelTimeout, <line40> maxMessageSize, <line41> BoltServer.NETTY_BUF_ALLOCATOR); <line42> } <line43> } <line44> 	"<line20>        log.warn(""Unhandled encryption level %s - assuming DISABLED."", encryptionLevel.name());"	task4	
public class A { <line0> public static com.liferay.commerce.model.CommerceOrderSoap updateCustomFields( <line1> long commerceOrderId, com.liferay.portal.kernel.service.ServiceContext serviceContext) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.model.CommerceOrder returnValue = <line5> CommerceOrderServiceUtil.updateCustomFields(commerceOrderId, serviceContext); <line6> return com.liferay.commerce.model.CommerceOrderSoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
"public class A { <line0> public static int getSegmentsEntryRelsCount( <line1> HttpPrincipal httpPrincipal, long groupId, long classNameId, long classPK) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SegmentsEntryRelServiceUtil.class, <line7> ""getSegmentsEntryRelsCount"", <line8> _getSegmentsEntryRelsCountParameterTypes7); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, classNameId, classPK); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> public void moveHeadBlocking( <line1> Double neck, Double rothead, Double eyeX, Double eyeY, Double jaw, Double rollNeck) { <line2> if (head != null) { <line3> head.moveToBlocking(neck, rothead, eyeX, eyeY, jaw, rollNeck); <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.error(""I have a null head"");"	task4	
public class A { <line0> private static List<File> initNativeLibDirList( <line1> Set<File> narNativeLibDirs, Set<URL> additionalResourceUrls) { <line2> List<File> nativeLibDirList = new ArrayList<>(narNativeLibDirs); <line3> Set<File> additionalNativeLibDirs = new HashSet<>(); <line4> if (additionalResourceUrls != null) { <line5> for (URL url : additionalResourceUrls) { <line6> File file; <line7> try { <line8> file = new File(url.toURI()); <line9> } catch (URISyntaxException e) { <line10> file = new File(url.getPath()); <line11> } catch (Exception e) { <line12> file = null; <line13> } <line14> File dir = toDir(file); <line15> if (dir != null) { <line16> additionalNativeLibDirs.add(dir); <line17> } <line18> } <line19> } <line20> nativeLibDirList.addAll(additionalNativeLibDirs); <line21> return nativeLibDirList; <line22> } <line23> } <line24> 	"<line12>          logger.error(""Couldn't convert url '"" + url + ""' to a file"");"	task4	
"public class A { <line0> private AuthorizationProvider createAuthProvider() throws Exception { <line1> String authProviderName = <line2> authConf.get( <line3> AuthzConfVars.AUTHZ_PROVIDER.getVar(), AuthzConfVars.AUTHZ_PROVIDER.getDefault()); <line4> String resourceName = <line5> authConf.get( <line6> AuthzConfVars.AUTHZ_PROVIDER_RESOURCE.getVar(), <line7> AuthzConfVars.AUTHZ_PROVIDER_RESOURCE.getDefault()); <line8> String providerBackendName = <line9> authConf.get( <line10> AuthzConfVars.AUTHZ_PROVIDER_BACKEND.getVar(), <line11> AuthzConfVars.AUTHZ_PROVIDER_BACKEND.getDefault()); <line12> String policyEngineName = <line13> authConf.get( <line14> AuthzConfVars.AUTHZ_POLICY_ENGINE.getVar(), <line15> AuthzConfVars.AUTHZ_POLICY_ENGINE.getDefault()); <line16> if (resourceName != null && resourceName.startsWith(""classpath:"")) { <line17> String resourceFileName = resourceName.substring(""classpath:"".length()); <line18> resourceName = <line19> AuthorizationProvider.class.getClassLoader().getResource(resourceFileName).getPath(); <line20> } <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> Constructor<?> providerBackendConstructor = <line24> Class.forName(providerBackendName) <line25> .getDeclaredConstructor(Configuration.class, String.class); <line26> providerBackendConstructor.setAccessible(true); <line27> providerBackend = <line28> (ProviderBackend) <line29> providerBackendConstructor.newInstance(new Object[] {authConf, resourceName}); <line30> if (providerBackend instanceof SentryGenericProviderBackend) { <line31> ((SentryGenericProviderBackend) providerBackend).setComponentType(COMPONENT_TYPE); <line32> ((SentryGenericProviderBackend) providerBackend).setServiceName(instanceName); <line33> } <line34> Constructor<?> policyConstructor = <line35> Class.forName(policyEngineName).getDeclaredConstructor(ProviderBackend.class); <line36> policyConstructor.setAccessible(true); <line37> PolicyEngine policyEngine = <line38> (PolicyEngine) policyConstructor.newInstance(new Object[] {providerBackend}); <line39> Constructor<?> constructor = <line40> Class.forName(authProviderName) <line41> .getDeclaredConstructor(Configuration.class, String.class, PolicyEngine.class); <line42> constructor.setAccessible(true); <line43> return (AuthorizationProvider) <line44> constructor.newInstance(new Object[] {authConf, resourceName, policyEngine}); <line45> } <line46> } <line47> "	"<line22>      LOG.debug(""Using authorization provider ""+ authProviderName+ "" with resource ""+ resourceName+ "", policy engine ""+ policyEngineName+ "", provider backend ""+ providerBackendName);"	task4	
"public class A { <line0> @Test <line1> public void copyAllTranslationsWithMD5MatchBetweenRepositoriesNameRegex() <line2> throws InterruptedException, ExecutionException, RepositoryNameAlreadyUsedException, <line3> AssetWithIdNotFoundException, RepositoryWithIdNotFoundException { <line4> TMTestData tmTestDataSource = new TMTestData(testIdWatcher); <line5> Repository sourceRepository = tmTestDataSource.repository; <line6> Repository targetRepository = <line7> repositoryService.createRepository(testIdWatcher.getEntityName(""targetRepository"")); <line8> TM tm = targetRepository.getTm(); <line9> Asset asset = <line10> assetService.createAssetWithContent( <line11> targetRepository.getId(), ""fake_for_test"", ""fake for test""); <line12> Long assetId = asset.getId(); <line13> tmService.addTMTextUnit( <line14> tm.getId(), <line15> assetId, <line16> ""zuora_error_message_verify_state_province"", <line17> ""Please enter a valid state, region or province"", <line18> ""Comment1""); <line19> tmService.addTMTextUnit(tm.getId(), assetId, ""TEST2"", ""Content2"", ""Comment2""); <line20> tmService.addTMTextUnit(tm.getId(), assetId, ""TEST3"", ""Content3"", ""Comment3""); <line21> CopyTmConfig copyTmConfig = new CopyTmConfig(); <line22> copyTmConfig.setSourceRepositoryId(sourceRepository.getId()); <line23> copyTmConfig.setTargetRepositoryId(targetRepository.getId()); <line24> copyTmConfig.setNameRegex(""TEST.*""); <line25> leveragingService.copyTm(copyTmConfig).get(); <line26> List<TMTextUnitVariant> sourceTranslations = <line27> tmTextUnitVariantRepository <line28> .findByTmTextUnitTmRepositoriesAndLocale_Bcp47TagNotOrderByContent( <line29> sourceRepository, ""en""); <line30> List<TMTextUnitVariant> targetTranslations = <line31> tmTextUnitVariantRepository <line32> .findByTmTextUnitTmRepositoriesAndLocale_Bcp47TagNotOrderByContent( <line33> targetRepository, ""en""); <line34> Predicate<TMTextUnitVariant> filterZuora = <line35> new Predicate<TMTextUnitVariant>() { <line36> @Override <line37> public boolean apply(TMTextUnitVariant tmtuv) { <line38> return !""zuora_error_message_verify_state_province"" <line39> .equals(tmtuv.getTmTextUnit().getName()); <line40> } <line41> }; <line42> Iterator<TMTextUnitVariant> itSource = <line43> Iterables.filter(sourceTranslations, filterZuora).iterator(); <line44> Iterator<TMTextUnitVariant> itTarget = targetTranslations.iterator(); <line45> while (itTarget.hasNext()) { <line46> TMTextUnitVariant next = itTarget.next(); <line47> Assert.assertEquals( <line48> ""translation in source and target must be the same"", <line49> itSource.next().getContent(), <line50> next.getContent()); <line51> } <line52> Assert.assertFalse(itSource.hasNext()); <line53> } <line54> } <line55> "	"<line6>    logger.debug(""Create the target repository"");"	task4	
public class A { <line0> public void close() throws IOException { <line1> if (!isClosed) { <line2> try { <line3> this.addFile(); <line4> this.outputStream.close(); <line5> this.outputStream = null; <line6> } catch (Exception ex) { <line7> ex.printStackTrace(); <line8> } finally { <line9> this.isClosed = true; <line10> } <line11> } <line12> } <line13> } <line14> 	"<line8>        LOGGER.warn(""There was an error adding the temporaryFile to S3"");"	task4	
"public class A { <line0> @Override <line1> protected UserDetails processAutoLoginCookie( <line2> final String[] cookieTokens, <line3> final HttpServletRequest request, <line4> final HttpServletResponse response) <line5> throws RememberMeAuthenticationException, UsernameNotFoundException { <line6> if (cookieTokens.length != 2) { <line7> throw new InvalidCookieException( <line8> ""Cookie token did not contain 2 tokens, but contained '"" <line9> + Arrays.asList(cookieTokens) <line10> + ""'""); <line11> } <line12> final String presentedId = cookieTokens[0]; <line13> final String presentedToken = cookieTokens[1]; <line14> try { <line15> PersistentLogin persistentLogin = authenticationService.getPersistentLogin(presentedId); <line16> if (persistentLogin == null) { <line17> throw new RememberMeAuthenticationException( <line18> ""No persistent token found for id: "" + presentedId); <line19> } <line20> if (!presentedToken.equals(persistentLogin.getToken())) { <line21> authenticationService.deletePersistentLogin(presentedId); <line22> throw new CookieTheftException( <line23> ""Invalid remember-me token (id/token) mismatch. Implies previous cookie theft attack.""); <line24> } <line25> if (persistentLogin.getTimestamp().getTime() + getTokenValiditySeconds() * 1000L <line26> < currentTimeMillis()) { <line27> throw new RememberMeAuthenticationException(""Remember-me login has expired""); <line28> } <line29> if (logger.isDebugEnabled()) { <line30> } <line31> persistentLogin = authenticationService.refreshPersistentLoginToken(presentedId); <line32> setCookie( <line33> new String[] {persistentLogin.getId(), persistentLogin.getToken()}, <line34> getTokenValiditySeconds(), <line35> request, <line36> response); <line37> return ((ProfileUserDetailsService) getUserDetailsService()) <line38> .loadUserById(persistentLogin.getProfileId()); <line39> } catch (ProfileException e) { <line40> throw new RememberMeAuthenticationException( <line41> ""Error validating persistent login "" + presentedId, e); <line42> } <line43> } <line44> } <line45> "	"<line30>        logger.debug(""Refreshing persistent login token for profile '""+ persistentLogin.getProfileId()+ ""', id '""+ persistentLogin.getId()+ ""'"");"	task4	
public class A { <line0> @Override <line1> public void feedback( <line2> String username, String title, String type, String message, String email, String host) { <line3> Calendar cal = Calendar.getInstance(); <line4> try { <line5> EntityManager.instance.insertFeedback( <line6> username, title, type, message, email, host, cal.getTime()); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	<line8>      log.fatal(e);	task4	
"public class A { <line0> @SuppressWarnings({""unchecked""}) <line1> public Object doSendCommandStart(Object[] args) { <line2> Command cmd = (Command) args[0]; <line3> String host = (String) args[2]; <line4> Integer port = (Integer) args[3]; <line5> String targetURL = ""redis://"" + host + "":"" + port; <line6> String redisAction = cmd.name(); <line7> if (logger.isDebugable()) { <line8> } <line9> Map<String, Object> params = new HashMap<String, Object>(); <line10> params.put(CaptureConstants.INFO_CLIENT_REQUEST_URL, targetURL); <line11> params.put(CaptureConstants.INFO_CLIENT_REQUEST_ACTION, redisAction); <line12> params.put(CaptureConstants.INFO_CLIENT_APPID, appid); <line13> params.put(CaptureConstants.INFO_CLIENT_TYPE, ""redis.client.Jedis""); <line14> UAVServer.instance() <line15> .runMonitorCaptureOnServerCapPoint( <line16> CaptureConstants.CAPPOINT_APP_CLIENT, Monitor.CapturePhase.PRECAP, params); <line17> UAVServer.instance() <line18> .runSupporter( <line19> ""com.creditease.uav.apm.supporters.InvokeChainSupporter"", <line20> ""registerAdapter"", <line21> JedisClientAdapter.class); <line22> ivcContextParams = <line23> (Map<String, Object>) <line24> UAVServer.instance() <line25> .runSupporter( <line26> ""com.creditease.uav.apm.supporters.InvokeChainSupporter"", <line27> ""runCap"", <line28> InvokeChainConstants.CHAIN_APP_CLIENT, <line29> InvokeChainConstants.CapturePhase.PRECAP, <line30> params, <line31> JedisClientAdapter.class, <line32> args); <line33> return null; <line34> } <line35> } <line36> "	"<line8>      logger.debug(""REDIS INVOKE START: "" + targetURL + "" action: "" + redisAction, null);"	task4	
public class A { <line0> public static LateralCacheManager getInstance( <line1> ILateralCacheAttributes lca, ICompositeCacheManager cacheMgr) { <line2> LateralCacheManager ins = (LateralCacheManager) instances.get(lca.toString()); <line3> synchronized (instances) { <line4> if (ins == null) { <line5> ins = (LateralCacheManager) instances.get(lca.toString()); <line6> if (ins == null) { <line7> ins = new LateralCacheManager(lca, cacheMgr); <line8> instances.put(lca.toString(), ins); <line9> } <line10> } <line11> } <line12> ins.clients++; <line13> if (monitor == null) { <line14> monitor = new LateralCacheMonitor(ins); <line15> if (monitor != null) { <line16> Thread t = new Thread(monitor); <line17> t.setDaemon(true); <line18> t.start(); <line19> } <line20> } <line21> return ins; <line22> } <line23> } <line24> 	"<line5>        log.info(""Instance for ["" + lca.toString() + ""] is null, creating"");"	task4	
public class A { <line0> @Override <line1> public void close() throws SQLException { <line2> if (connection != null) { <line3> resetAutoCommit(); <line4> if (log.isDebugEnabled()) { <line5> } <line6> connection.close(); <line7> } <line8> } <line9> } <line10> 	"<line5>        log.debug(""Closing JDBC Connection ["" + connection + ""]"");"	task4	
public class A { <line0> @Override <line1> public long getChangeNumber(String segmentName) { <line2> SegmentImp segmentImp = _segments.get(segmentName); <line3> if (segmentImp == null) { <line4> return DEFAULT_CHANGE_NUMBER; <line5> } <line6> return segmentImp.getChangeNumber(); <line7> } <line8> } <line9> 	"<line4>      log.error(""Segment "" + segmentName + ""Not found."");"	task4	
public class A { <line0> @Override <line1> public Status delete(String table, String key) { <line2> key = createQualifiedKey(table, key); <line3> try { <line4> OperationFuture<Boolean> future = memcachedClient().delete(key); <line5> return getReturnCode(future); <line6> } catch (Exception e) { <line7> return Status.ERROR; <line8> } <line9> } <line10> } <line11> 	"<line7>      logger.error(""Error deleting value"", e);"	task4	
"public class A { <line0> private void logLevels(MessagingException me) { <line1> Exception ne; <line2> while ((ne = me.getNextException()) != null && ne instanceof MessagingException) { <line3> me = (MessagingException) ne; <line4> EnhancedMessagingException enhancedMessagingException = new EnhancedMessagingException(me); <line5> if (me.getClass().getName().endsWith("".SMTPAddressFailedException"") <line6> || me.getClass().getName().endsWith("".SMTPAddressSucceededException"")) { <line7> } <line8> } <line9> } <line10> } <line11> "	"<line7>        LOGGER.debug(""ADDRESS :[{}] Address:[{}] Command : [{}] RetCode[{}] Response [{}]"",enhancedMessagingException.computeAction(),me,enhancedMessagingException.computeAddress(),enhancedMessagingException.computeCommand(),enhancedMessagingException.getReturnCode());"	task4	
public class A { <line0> protected Ini getServletContextIniResource(String servletContextPath) { <line1> String path = WebUtils.normalize(servletContextPath); <line2> if (getServletContext() != null) { <line3> InputStream is = getServletContext().getResourceAsStream(path); <line4> if (is != null) { <line5> Ini ini = new Ini(); <line6> ini.load(is); <line7> if (CollectionUtils.isEmpty(ini)) { <line8> } <line9> return ini; <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line8>          log.warn(""ServletContext INI resource '""+ servletContextPath+ ""' exists, but it did not contain ""+ ""any data."");"	task4	
public class A { <line0> public void run() { <line1> try { <line2> Thread.sleep(getMaxTestTime()); <line3> } catch (InterruptedException e) { <line4> } finally { <line5> if (!isTestSuccess.get()) { <line6> dumpAllThreads(getName()); <line7> System.exit(EXIT_ERROR); <line8> } <line9> } <line10> } <line11> } <line12> 	"<line6>        LOG.error(""Test case has exceeded the maximum allotted time to run of: ""+ getMaxTestTime()+ "" ms."");"	task4	
public class A { <line0> @BeforeAll <line1> public static void setUp() throws SQLException { <line2> Config config = ConfigProvider.getConfig(); <line3> Optional<String> jdbcUrl = config.getOptionalValue(PROPERTY_JDBC, String.class); <line4> if (jdbcUrl.isPresent()) { <line5> connection = DriverManager.getConnection(jdbcUrl.get()); <line6> } else { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOG.warn(""Container is not running. Connection is not created."");"	task4	
"public class A { <line0> public MediaPackage getCurrentRecording(String agentId) <line1> throws NotFoundException, UnauthorizedException, SchedulerException { <line2> Opt<MediaPackage> current = schedulerService.getCurrentRecording(agentId); <line3> if (current.isNone()) { <line4> throw new NotFoundException(""No current recording found for agent '"" + agentId + ""'""); <line5> } <line6> return current.get(); <line7> } <line8> } <line9> "	"<line4>      logger.warn(""Unable to load the current recording for agent '{}': no recording found"", agentId);"	task4	
"public class A { <line0> @Before <line1> public void setup() throws Exception { <line2> File agentDir = StagedInstall.getInstance().getStageDir(); <line3> File testDir = new File(agentDir, TestSpooldirSource.class.getName()); <line4> assertTrue(testDir.mkdirs()); <line5> File spoolParentDir = new File(testDir, ""spools""); <line6> assertTrue( <line7> ""Unable to create sink output dir: "" + spoolParentDir.getPath(), spoolParentDir.mkdir()); <line8> final int NUM_SOURCES = 100; <line9> agentProps = new Properties(); <line10> List<String> spooldirSrcNames = Lists.newArrayList(); <line11> String channelName = ""mem-01""; <line12> for (int i = 0; i < NUM_SOURCES; i++) { <line13> String srcName = String.format(""spooldir-%03d"", i); <line14> File spoolDir = new File(spoolParentDir, srcName); <line15> assertTrue(spoolDir.mkdir()); <line16> spooldirSrcNames.add(srcName); <line17> spoolDirs.add(spoolDir); <line18> agentProps.put(String.format(""agent.sources.%s.type"", srcName), ""SPOOLDIR""); <line19> agentProps.put(String.format(""agent.sources.%s.spoolDir"", srcName), spoolDir.getPath()); <line20> agentProps.put(String.format(""agent.sources.%s.channels"", srcName), channelName); <line21> } <line22> agentProps.put(""agent.channels.mem-01.type"", ""MEMORY""); <line23> agentProps.put(""agent.channels.mem-01.capacity"", String.valueOf(100000)); <line24> sinkOutputDir = new File(testDir, ""out""); <line25> assertTrue( <line26> ""Unable to create sink output dir: "" + sinkOutputDir.getPath(), sinkOutputDir.mkdir()); <line27> agentProps.put(""agent.sinks.roll-01.channel"", channelName); <line28> agentProps.put(""agent.sinks.roll-01.type"", ""FILE_ROLL""); <line29> agentProps.put(""agent.sinks.roll-01.sink.directory"", sinkOutputDir.getPath()); <line30> agentProps.put(""agent.sinks.roll-01.sink.rollInterval"", ""0""); <line31> agentProps.put(""agent.sources"", Joiner.on("" "").join(spooldirSrcNames)); <line32> agentProps.put(""agent.channels"", channelName); <line33> agentProps.put(""agent.sinks"", ""roll-01""); <line34> } <line35> } <line36> "	"<line3>    LOGGER.debug(""Using agent stage dir: {}"", agentDir);"	task4	
public class A { <line0> public static com.liferay.expando.kernel.model.ExpandoValueSoap addValue( <line1> long companyId, <line2> String className, <line3> String tableName, <line4> String columnName, <line5> long classPK, <line6> Object data) <line7> throws RemoteException { <line8> try { <line9> com.liferay.expando.kernel.model.ExpandoValue returnValue = <line10> ExpandoValueServiceUtil.addValue( <line11> companyId, className, tableName, columnName, classPK, data); <line12> return com.liferay.expando.kernel.model.ExpandoValueSoap.toSoapModel(returnValue); <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	<line14>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public List<String> findAccessible(Entity entity) { <line2> List<String> securityEventIds = Collections.emptyList(); <line3> List<NeutralQuery> filters = buildQualifyingFilters(); <line4> if (filters.size() > 0) { <line5> NeutralQuery query = new NeutralQuery(); <line6> for (NeutralQuery filter : filters) { <line7> query.addOrQuery(filter); <line8> } <line9> securityEventIds = Lists.newArrayList((repository.findAllIds(RESOURCE_NAME, query))); <line10> } else { <line11> } <line12> return securityEventIds; <line13> } <line14> } <line15> 	"<line11>      LOG.info(""Cannot access SecurityEvents!"");"	task4	
"public class A { <line0> protected Class resolveClassInternal( <line1> String className, <line2> boolean requireAnnotation, <line3> boolean forAnnotationUse, <line4> ClasspathExtensionClass classpathExtension) <line5> throws ClassNotFoundException { <line6> if (forAnnotationUse) { <line7> String lowercase = className.toLowerCase(Locale.ENGLISH); <line8> if (lowercase.equals(""private"")) { <line9> return Private.class; <line10> } <line11> if (lowercase.equals(""protected"")) { <line12> return Protected.class; <line13> } <line14> if (lowercase.equals(""public"")) { <line15> return Public.class; <line16> } <line17> if (lowercase.equals(""buseventtype"")) { <line18> return BusEventType.class; <line19> } <line20> } <line21> Class clazzExtension = classpathExtension.findClassByName(className); <line22> if (clazzExtension != null) { <line23> return clazzExtension; <line24> } <line25> try { <line26> return getClassForNameProvider().classForName(className); <line27> } catch (ClassNotFoundException e) { <line28> if (log.isDebugEnabled()) { <line29> } <line30> } <line31> if (forAnnotationUse) { <line32> Class clazz = checkImports(annotationImports, requireAnnotation, className); <line33> if (clazz != null) { <line34> return clazz; <line35> } <line36> } <line37> Class clazz = checkImports(imports, requireAnnotation, className); <line38> if (clazz != null) { <line39> return clazz; <line40> } <line41> throw new ClassNotFoundException(""Unknown class "" + className); <line42> } <line43> } <line44> "	"<line29>        log.debug(""Class not found for resolving from name as-is '"" + className + ""'"");"	task4	
"public class A { <line0> private void configureCaches(Path pluginDir, String pluginName) { <line1> Path cacheConfig = pluginDir.resolve(""cache-config.xml""); <line2> if (Files.exists(cacheConfig)) { <line3> PluginCacheConfigurator configurator = new PluginCacheConfigurator(); <line4> try { <line5> configurator.setInputStream(new BufferedInputStream(Files.newInputStream(cacheConfig))); <line6> configurator.configure(pluginName); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> } <line12> "	"<line8>        Log.error(""An exception occurred while trying to configure caches for plugin '{}':"",pluginName,e);"	task4	
"public class A { <line0> private Long findSchemaForPositionSHA(Connection c, String sha) throws SQLException { <line1> PreparedStatement p = c.prepareStatement(""SELECT * from `schemas` where position_sha = ?""); <line2> p.setString(1, sha); <line3> ResultSet rs = p.executeQuery(); <line4> if (rs.next()) { <line5> Long id = rs.getLong(""id""); <line6> return id; <line7> } else { <line8> return null; <line9> } <line10> } <line11> } <line12> "	"<line6>      LOGGER.debug(""findSchemaForPositionSHA: found schema_id: {} for sha: {}"", id, sha);"	task4	
"public class A { <line0> @Override <line1> public void generate(Model model, MolgenisOptions options) throws Exception { <line2> Template template = createTemplate(""/"" + getClass().getSimpleName() + "".java.ftl""); <line3> Map<String, Object> templateArgs = createTemplateArguments(options); <line4> File target = new File(this.getDocumentationPath(options) + ""/tabledoc.html""); <line5> boolean created = target.getParentFile().mkdirs(); <line6> if (!created && !target.getParentFile().exists()) { <line7> throw new IOException(""could not create "" + target.getParentFile()); <line8> } <line9> templateArgs.put(""model"", model); <line10> OutputStream targetOut = new FileOutputStream(target); <line11> template.process(templateArgs, new OutputStreamWriter(targetOut, Charset.forName(""UTF-8""))); <line12> targetOut.close(); <line13> } <line14> } <line15> "	"<line13>    logger.info(""generated "" + target);"	task4	
"public class A { <line0> public static void initialize( <line1> DistributionConfig distributionConfig, Collection<DistributedSystemService> services) { <line2> if (distributionConfig.getValidateSerializableObjects()) { <line3> if (!ClassUtils.isClassAvailable(""sun.misc.ObjectInputFilter"") <line4> && !ClassUtils.isClassAvailable(""java.io.ObjectInputFilter"")) { <line5> throw new GemFireConfigException( <line6> ""A serialization filter has been specified but this version of Java does not support"" <line7> + "" serialization filters - ObjectInputFilter is not available""); <line8> } <line9> serializationFilter = <line10> new ObjectInputStreamFilterWrapper( <line11> SANCTIONED_SERIALIZABLES_DEPENDENCIES_PATTERN <line12> + distributionConfig.getSerializableObjectFilter() <line13> + "";!*"", <line14> services); <line15> } else { <line16> clearSerializationFilter(); <line17> } <line18> } <line19> } <line20> "	"<line2>    logger.info(""initializing InternalDataSerializer with {} services"", services.size());"	task4	
"public class A { <line0> @Override <line1> public byte[] doInTransform( <line2> Instrumentor instrumentor, <line3> ClassLoader classLoader, <line4> String className, <line5> Class<?> classBeingRedefined, <line6> ProtectionDomain protectionDomain, <line7> byte[] classfileBuffer) <line8> throws InstrumentException { <line9> final InstrumentClass target = <line10> instrumentor.getInstrumentClass(classLoader, className, classfileBuffer); <line11> target.addField(AsyncContextAccessor.class); <line12> target.addField(PinpointTraceAccessor.class); <line13> final MethodFilter applyMethodFilter = MethodFilters.chain(MethodFilters.name(""copy"")); <line14> for (InstrumentMethod method : target.getDeclaredMethods(applyMethodFilter)) { <line15> try { <line16> method.addInterceptor(StartMarkerCopyInterceptor.class); <line17> break; <line18> } catch (Exception e) { <line19> final PLogger logger = PLoggerFactory.getLogger(this.getClass()); <line20> if (logger.isWarnEnabled()) { <line21> } <line22> } <line23> } <line24> return target.toBytecode(); <line25> } <line26> } <line27> "	"<line21>          logger.warn(""Unsupported method "" + method, e);"	task4	
public class A { <line0> protected void persistPeriodChanges(NodeRef dispositionActionDef, DispositionAction nextAction) { <line1> NodeRef dispositionedNode = <line2> getNodeService().getPrimaryParent(nextAction.getNodeRef()).getParentRef(); <line3> DispositionActionDefinition definition = nextAction.getDispositionActionDefinition(); <line4> Date newAsOfDate = getDispositionService().calculateAsOfDate(dispositionedNode, definition); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> getNodeService().setProperty(nextAction.getNodeRef(), PROP_DISPOSITION_AS_OF, newAsOfDate); <line8> } <line9> } <line10> 	"<line6>      logger.debug(""Set disposition as of date for next action '""+ nextAction.getName()+ ""' (""+ nextAction.getNodeRef()+ "") to: ""+ newAsOfDate);"	task4	
public class A { <line0> @Test <line1> public void testDebugShortCircuit() { <line2> inner.setLevel(Level.OFF); <line3> assertTrue(handler.isEmpty()); <line4> } <line5> } <line6> 	"<line3>    logger.debug(""hello"");"	task4	
public class A { <line0> private void processInitialStatusUpdates(WarningsPrinter warningsPrinter) { <line1> while (client.isRunning() && (client.currentData().getData() == null)) { <line2> warningsPrinter.print(client.currentStatusInfo().getWarnings(), true, false); <line3> try { <line4> client.advance(); <line5> } catch (RuntimeException e) { <line6> } <line7> } <line8> List<Warning> warnings; <line9> if (client.isRunning()) { <line10> warnings = client.currentStatusInfo().getWarnings(); <line11> } else { <line12> warnings = client.finalStatusInfo().getWarnings(); <line13> } <line14> warningsPrinter.print(warnings, false, true); <line15> } <line16> } <line17> 	"<line6>        log.debug(e, ""error printing status"");"	task4	
public class A { <line0> @Override <line1> public void handle( <line2> PacketBlockPickRequest packet, long currentTimeMillis, PlayerConnection connection) { <line3> EntityPlayer player = connection.entity(); <line4> float dist = player.location().distance(packet.getLocation().toVector()); <line5> if (dist > 100) { <line6> return; <line7> } <line8> Block block = player.world().blockAt(packet.getLocation()); <line9> switch (player.gamemode()) { <line10> case CREATIVE: <line11> for (io.gomint.inventory.item.ItemStack<?> drop : block.drops(null)) { <line12> player.inventory().addItem(drop); <line13> } <line14> break; <line15> case SURVIVAL: <line16> byte freeSlot = -1; <line17> ItemStack<?>[] items = player.inventory().contents(); <line18> for (byte i = 0; i < items.length; i++) { <line19> ItemStack<?> itemStack = items[i]; <line20> if (freeSlot == -1 && i < 9) { <line21> if (itemStack instanceof ItemAir) { <line22> freeSlot = i; <line23> } <line24> } <line25> if (block <line26> .blockId() <line27> .equals(((io.gomint.server.inventory.item.ItemStack<?>) itemStack).material())) { <line28> if (i < 9) { <line29> player.inventory().setItemInHand(i); <line30> return; <line31> } else if (freeSlot > -1) { <line32> player.inventory().item(freeSlot, itemStack); <line33> player.inventory().item(i, ItemAir.create(1)); <line34> player.inventory().setItemInHand(freeSlot); <line35> return; <line36> } <line37> } <line38> } <line39> } <line40> } <line41> } <line42> 	"<line6>      LOGGER.warn(""Player {} tried to reach {} blocks wide"", player.name(), dist);"	task4	
public class A { <line0> public ConnectionBuilder db(String dbName) { <line1> this.dbName = dbName; <line2> return this; <line3> } <line4> } <line5> 	"<line2>    LOGGER.info(""Using database name: "" + dbName);"	task4	
public class A { <line0> @Override <line1> public DeploymentPolicy getDeploymentPolicy(String deploymentPolicyID) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> return PolicyManager.getInstance().getDeploymentPolicy(deploymentPolicyID); <line5> } <line6> } <line7> 	"<line3>      log.debug(""Getting deployment policy: [deployment-policy_id] "" + deploymentPolicyID);"	task4	
public class A { <line0> public static void cancelCheckOut(long fileEntryId) throws RemoteException { <line1> try { <line2> DLAppServiceUtil.cancelCheckOut(fileEntryId); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	<line4>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> protected void shutDown() { <line2> } <line3> } <line4> 	"<line2>    log.info(""Elastic Job: Stop {}"", serviceName());"	task4	
"public class A { <line0> private void startXML() { <line1> try { <line2> writer.writeStartElement(ADD_IDENTIFIER); <line3> } catch (final XMLStreamException e) { <line4> final String message = ""couldn't finish Solr Update XML export successfully""; <line5> final DMPConverterException converterException = new DMPConverterException(message, e); <line6> throw DMPConverterError.wrap(converterException); <line7> } <line8> } <line9> } <line10> "	"<line2>      LOG.debug(""start writing Solr Update XML for export"");"	task4	
"public class A { <line0> @Override <line1> public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) <line2> throws IOException, InterruptedException { <line3> if (!(inputSplit instanceof KafkaInputSplit)) { <line4> throw new CrunchRuntimeException(""InputSplit for RecordReader is not valid split type.""); <line5> } <line6> kafkaConnectionProperties = <line7> filterConnectionProperties( <line8> getKafkaConnectionProperties(taskAttemptContext.getConfiguration())); <line9> consumer = buildConsumer(kafkaConnectionProperties); <line10> KafkaInputSplit split = (KafkaInputSplit) inputSplit; <line11> topicPartition = split.getTopicPartition(); <line12> consumer.assign(Collections.singletonList(topicPartition)); <line13> consumer.poll(0); <line14> startingOffset = split.getStartingOffset(); <line15> consumer.seek(topicPartition, startingOffset); <line16> currentOffset = startingOffset - 1; <line17> endingOffset = split.getEndingOffset(); <line18> maxNumberOfRecords = endingOffset - startingOffset; <line19> if (LOG.isInfoEnabled()) { <line20> } <line21> Configuration config = taskAttemptContext.getConfiguration(); <line22> consumerPollTimeout = config.getLong(CONSUMER_POLL_TIMEOUT_KEY, CONSUMER_POLL_TIMEOUT_DEFAULT); <line23> maxNumberAttempts = config.getInt(KAFKA_RETRY_ATTEMPTS_KEY, KAFKA_RETRY_ATTEMPTS_DEFAULT); <line24> } <line25> } <line26> "	"<line20>      LOG.info(""Reading data from {} between {} and {}"",new Object[] {topicPartition, startingOffset, endingOffset});"	task4	
"public class A { <line0> @Override <line1> public void registerSchema(List<DeviceSchema> schemaList) throws TsdbException { <line2> if (!config.getOPERATION_PROPORTION().split("":"")[0].equals(""0"")) { <line3> try { <line4> Set<String> groups = new HashSet<>(); <line5> for (DeviceSchema schema : schemaList) { <line6> groups.add(schema.getGroup()); <line7> } <line8> setStorageGroup(groups, connection1); <line9> setStorageGroup(groups, connection2); <line10> } catch (SQLException e) { <line11> if (!e.getMessage().contains(ALREADY_KEYWORD)) { <line12> throw new TsdbException(e); <line13> } <line14> } <line15> CreateTimeSeries(connection1, schemaList); <line16> CreateTimeSeries(connection2, schemaList); <line17> } <line18> } <line19> } <line20> "	"<line12>          LOGGER.error(""Register IoTDB schema failed because "", e);"	task4	
"public class A { <line0> protected void savePageMetadata( <line1> String pageCode, PageMetadata pageMetadata, boolean isAdd, String tableName, Connection conn) <line2> throws ApsSystemException { <line3> if (pageMetadata != null) { <line4> PreparedStatement stat = null; <line5> try { <line6> StringBuilder query = <line7> new StringBuilder(isAdd ? ADD_PAGE_METADATA_START : UPDATE_PAGE_METADATA_START); <line8> query.append(tableName).append(isAdd ? ADD_PAGE_METADATA_END : UPDATE_PAGE_METADATA_END); <line9> stat = conn.prepareStatement(query.toString()); <line10> int index = 1; <line11> if (isAdd) { <line12> stat.setString(index++, pageCode); <line13> } <line14> stat.setString(index++, pageMetadata.getGroup()); <line15> stat.setString(index++, pageMetadata.getTitles().toXml()); <line16> stat.setString(index++, pageMetadata.getModel().getCode()); <line17> if (pageMetadata.isShowable()) { <line18> stat.setInt(index++, 1); <line19> } else { <line20> stat.setInt(index++, 0); <line21> } <line22> String extraConfig = this.getExtraConfig(pageMetadata); <line23> stat.setString(index++, extraConfig); <line24> Date updatedAt = <line25> pageMetadata.getUpdatedAt() != null ? pageMetadata.getUpdatedAt() : new Date(); <line26> stat.setTimestamp( <line27> index++, updatedAt != null ? new java.sql.Timestamp(updatedAt.getTime()) : null); <line28> if (!isAdd) { <line29> stat.setString(index++, pageCode); <line30> } <line31> stat.executeUpdate(); <line32> } catch (Throwable t) { <line33> throw new RuntimeException( <line34> ""Error while saving the page metadata record for table "" + tableName, t); <line35> } finally { <line36> closeDaoResources(null, stat); <line37> } <line38> } <line39> } <line40> } <line41> "	"<line33>        logger.error(""Error while saving the page metadata record for table {}"", tableName, t);"	task4	
public class A { <line0> private void doUnsubscribe(String topic, Handler<AsyncResult<Void>> handler) { <line1> if (this.subscriptions.remove(topic) == null) { <line2> handler.handle(Future.succeededFuture()); <line3> return; <line4> } <line5> if (handler != null) { <line6> this.notifyUnsubscribed.computeIfAbsent(topic, x -> new LinkedList<>()).add(handler); <line7> } <line8> if (log.isDebugEnabled()) { <line9> } <line10> requestUnsubscribe(Collections.singletonList(topic)); <line11> } <line12> } <line13> 	"<line9>      log.debug(""Requesting unsubscribe: "" + topic);"	task4	
public class A { <line0> @Override <line1> public void debug(String format, Object... arguments) { <line2> for (Logger logger : this.loggers) { <line3> } <line4> } <line5> } <line6> 	<line3>      logger.debug(format, arguments);	task4	
public class A { <line0> @Override <line1> public void run() { <line2> String iterator = prepareIterator(); <line3> while (isAlive) { <line4> iterator = processNextIterator(iterator); <line5> try { <line6> Thread.sleep(1000); <line7> } catch (Exception e) { <line8> throw new RuntimeException(e); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line11>    logger.debug(""DONE consuming"");"	task4	
public class A { <line0> public void setConnectTimeout(final Optional<Integer> value) { <line1> value.ifPresent( <line2> s -> { <line3> super.setConnectTimeout(s); <line4> }); <line5> } <line6> } <line7> 	"<line3>          LOG.trace(""setting connectTimeout: {}"", s);"	task4	
public class A { <line0> @Override <line1> public void recordEvent(Event e) { <line2> } <line3> } <line4> 	<line2>    logger.info(e.toString());	task4	
"public class A { <line0> public List<String> getAddressbookNames(final String abIds) { <line1> if (StringUtils.isEmpty(abIds) == true) { <line2> return null; <line3> } <line4> final int[] ids = StringHelper.splitToInts(abIds, "","", false); <line5> final List<String> list = new ArrayList<String>(); <line6> for (final int id : ids) { <line7> final AddressbookDO ab = addressbookDao.internalGetById(id); <line8> if (ab != null) { <line9> list.add(ab.getTitle()); <line10> } else { <line11> } <line12> } <line13> return list; <line14> } <line15> } <line16> "	"<line11>        log.warn(""AddressbookDO with id '"" + id + ""' not found. abIds string was: "" + abIds);"	task4	
"public class A { <line0> @Override <line1> public UserGroupRole findByU_G_R(long userId, long groupId, long roleId) <line2> throws NoSuchUserGroupRoleException { <line3> UserGroupRole userGroupRole = fetchByU_G_R(userId, groupId, roleId); <line4> if (userGroupRole == null) { <line5> StringBundler sb = new StringBundler(8); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""userId=""); <line8> sb.append(userId); <line9> sb.append("", groupId=""); <line10> sb.append(groupId); <line11> sb.append("", roleId=""); <line12> sb.append(roleId); <line13> sb.append(""}""); <line14> if (log.isDebugEnabled()) { <line15> } <line16> throw new NoSuchUserGroupRoleException(sb.toString()); <line17> } <line18> return userGroupRole; <line19> } <line20> } <line21> "	<line15>        log.debug(sb.toString());	task4	
public class A { <line0> @Override <line1> public boolean connect() { <line2> InfluxDBClientOptions.Builder optionsBuilder = <line3> InfluxDBClientOptions.builder() <line4> .url(configuration.getUrl()) <line5> .org(configuration.getDatabaseName()) <line6> .bucket(configuration.getRetentionPolicy()); <line7> char[] token = configuration.getTokenAsCharArray(); <line8> if (token.length > 0) { <line9> optionsBuilder.authenticateToken(token); <line10> } else { <line11> optionsBuilder.authenticate( <line12> configuration.getUser(), configuration.getPassword().toCharArray()); <line13> } <line14> InfluxDBClientOptions clientOptions = optionsBuilder.build(); <line15> final InfluxDBClient createdClient = InfluxDBClientFactory.create(clientOptions); <line16> this.client = createdClient; <line17> queryAPI = createdClient.getQueryApi(); <line18> writeAPI = createdClient.getWriteApi(); <line19> return checkConnectionStatus(); <line20> } <line21> } <line22> 	"<line17>    logger.debug(""Succesfully connected to InfluxDB. Instance ready={}"", createdClient.ready());"	task4	
public class A { <line0> private void handleException(FailureReason aReason, String aMessage) { <line1> myURLDataSource.setFailureReason(aReason); <line2> myURLDataSource.setErrorMessage(aMessage); <line3> } <line4> } <line5> 	<line3>    LOGGER.warn(aMessage);	task4	
"public class A { <line0> @Override <line1> public void init( <line2> SortedKeyValueIterator<Key, Value> source, <line3> Map<String, String> options, <line4> IteratorEnvironment env) <line5> throws IOException { <line6> super.init(source, options, env); <line7> final String compFields = options.get(COMPONENT_FIELDS); <line8> if (compFields != null) this.fieldNames = Arrays.asList(compFields.split("","")); <line9> for (String fieldName : fieldNames) { <line10> DiscreteIndexType type = null; <line11> String typeClass = options.get(fieldName + DISCRETE_INDEX_TYPE); <line12> if (typeClass != null) { <line13> try { <line14> type = Class.forName(typeClass).asSubclass(DiscreteIndexType.class).newInstance(); <line15> } catch (Exception e) { <line16> } <line17> } <line18> if (type != null) fieldToDiscreteIndexType.put(fieldName, type); <line19> } <line20> this.separator = options.get(SEPARATOR); <line21> this.seekThreshold = Integer.parseInt(options.getOrDefault(SEEK_THRESHOLD, ""10"")); <line22> compositeSeeker = <line23> new ShardIndexCompositeSeeker(fieldNames, separator, fieldToDiscreteIndexType); <line24> } <line25> } <line26> "	"<line16>          log.warn(""Unable to create DiscreteIndexType for class name: "" + typeClass);"	task4	
"public class A { <line0> @Nullable <line1> public <V> V execute(String path, ConnectionHandler<V> connectionHandler) throws Exception { <line2> final List<URL> prioritizedUrlList = getPrioritizedUrlList(); <line3> if (prioritizedUrlList.isEmpty()) { <line4> return null; <line5> } <line6> int expectedErrorCount = errorCount.get(); <line7> Exception previousException = null; <line8> for (URL serverUrl : prioritizedUrlList) { <line9> HttpURLConnection connection = null; <line10> try { <line11> connection = startRequestToUrl(appendPath(serverUrl, path)); <line12> return connectionHandler.withConnection(connection); <line13> } catch (Exception e) { <line14> expectedErrorCount = incrementAndGetErrorCount(expectedErrorCount); <line15> if (previousException != null) { <line16> e.addSuppressed(previousException); <line17> } <line18> previousException = e; <line19> } finally { <line20> HttpUtils.consumeAndClose(connection); <line21> } <line22> } <line23> if (previousException == null) { <line24> throw new IllegalStateException(""Expected previousException not to be null""); <line25> } <line26> throw previousException; <line27> } <line28> } <line29> "	"<line15>        logger.debug(""Exception while interacting with APM Server, trying next one."");"	task4	
"public class A { <line0> private Result doCheck() { <line1> Config config = ConfigProvider.getConfig(); <line2> if (!config.getOptionalValue(DEPLOY, Boolean.class).orElse(false)) { <line3> return Result.notConfigured(); <line4> } <line5> if (serverFound) { <line6> return Result.enabled(); <line7> } <line8> KubernetesClient client = KubernetesClientUtils.createClient(); <line9> String masterURL = client.getConfiguration().getMasterUrl(); <line10> try { <line11> VersionInfo version = client.getVersion(); <line12> if (version == null) { <line13> return Result.exceptional( <line14> new RuntimeException( <line15> ""Although a Kubernetes deployment was requested, it however cannot take place"" <line16> + "" because the version of the API Server at '"" <line17> + masterURL <line18> + ""' could not be determined. Please ensure that a valid token is being"" <line19> + "" used."")); <line20> } <line21> log.debugf(""Kubernetes Version: %s.%s"", version.getMajor(), version.getMinor()); <line22> serverFound = true; <line23> return Result.enabled(); <line24> } catch (Exception e) { <line25> if (e.getCause() instanceof SSLHandshakeException) { <line26> return Result.exceptional( <line27> new RuntimeException( <line28> ""Although a Kubernetes deployment was requested, it however cannot take place"" <line29> + "" because the API Server (at '"" <line30> + masterURL <line31> + ""') certificates are not trusted. The certificates can be configured using"" <line32> + "" the relevant configuration propertiers under the"" <line33> + "" 'quarkus.kubernetes-client' config root, or"" <line34> + "" \""quarkus.kubernetes-client.trust-certs=true\"" can be set to explicitly"" <line35> + "" trust the certificates (not recommended)"", <line36> e)); <line37> } else { <line38> return Result.exceptional( <line39> new RuntimeException( <line40> ""Although a Kubernetes deployment was requested, it however cannot take place"" <line41> + "" because there was an error during communication with the API Server at '"" <line42> + masterURL <line43> + ""'"", <line44> e)); <line45> } <line46> } finally { <line47> client.close(); <line48> } <line49> } <line50> } <line51> "	"<line21>      log.info(""Kubernetes API Server at '"" + masterURL + ""' successfully contacted."");"	task4	
public class A { <line0> public void removeVideoDisplayPanel(String source) { <line1> if (!displays.containsKey(source)) { <line2> return; <line3> } <line4> VideoDisplayPanel vdp = displays.remove(source); <line5> display.remove(vdp.myDisplay); <line6> display.invalidate(); <line7> swingGui.pack(); <line8> } <line9> } <line10> 	"<line2>      log.error(""cannot remove VideoDisplayPanel "" + source);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> if (canceled.get()) { <line3> return; <line4> } <line5> try { <line6> continuallyRunTask.invoke(); <line7> } catch (final RuntimeException re) { <line8> throw re; <line9> } catch (final Exception e) { <line10> throw new ProcessException(e); <line11> } <line12> if (canceled.get()) { <line13> return; <line14> } <line15> nextSchedule = getNextSchedule(nextSchedule, cronExpression); <line16> final long delay = getDelay(nextSchedule); <line17> flowEngine.schedule(this, delay, TimeUnit.MILLISECONDS); <line18> } <line19> } <line20> 	"<line17>    logger.debug(""Finished task for {}; next scheduled time is at {} after a delay of {} milliseconds"",connectable,nextSchedule,delay);"	task4	
public class A { <line0> @Override <line1> public FeeData usageGiven(TransactionBody txn, SigValueObj sigUsage, StateView view) <line2> throws InvalidTxBodyException { <line3> try { <line4> MerkleTopic merkleTopic = <line5> view.topics().get(MerkleEntityId.fromTopicId(txn.getConsensusUpdateTopic().getTopicID())); <line6> long rbsIncrease = <line7> getUpdateTopicRbsIncrease( <line8> txn.getTransactionID().getTransactionValidStart(), <line9> JKey.mapJKey(merkleTopic.getAdminKey()), <line10> JKey.mapJKey(merkleTopic.getSubmitKey()), <line11> merkleTopic.getMemo(), <line12> merkleTopic.hasAutoRenewAccountId(), <line13> lookupExpiry(merkleTopic), <line14> txn.getConsensusUpdateTopic()); <line15> return getConsensusUpdateTopicFee(txn, rbsIncrease, sigUsage); <line16> } catch (Exception illegal) { <line17> throw new InvalidTxBodyException(illegal); <line18> } <line19> } <line20> } <line21> 	"<line17>      log.warn(""Usage estimation unexpectedly failed for {}!"", txn, illegal);"	task4	
"public class A { <line0> @Override <line1> public void addCustomizedStateConfig( <line2> String clusterName, CustomizedStateConfig customizedStateConfig) { <line3> if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) { <line4> throw new HelixException(""cluster "" + clusterName + "" is not setup yet""); <line5> } <line6> CustomizedStateConfig.Builder builder = <line7> new CustomizedStateConfig.Builder(customizedStateConfig); <line8> CustomizedStateConfig customizedStateConfigFromBuilder = builder.build(); <line9> ZKHelixDataAccessor accessor = <line10> new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient)); <line11> PropertyKey.Builder keyBuilder = accessor.keyBuilder(); <line12> accessor.setProperty(keyBuilder.customizedStateConfig(), customizedStateConfigFromBuilder); <line13> } <line14> } <line15> "	"<line3>    logger.info(""Add CustomizedStateConfig to cluster {}, CustomizedStateConfig is {}"",clusterName,customizedStateConfig.toString());"	task4	
"public class A { <line0> private void checkUnauthArea(AreaKeys area, String type, String... users) throws OmException { <line1> for (String user : users) { <line2> testArea( <line3> user, <line4> p -> { <line5> tester.getRequest().setParameter(area.name(), type); <line6> try { <line7> tester.executeBehavior((AbstractAjaxBehavior) p.getBehaviorById(0)); <line8> fail(""Not authorized""); <line9> } catch (UnauthorizedInstantiationException e) { <line10> assertTrue(true, ""Exception is expected""); <line11> } <line12> }); <line13> } <line14> } <line15> } <line16> "	"<line2>      log.debug(""Positive test:: area: {}, type: {} for user: {}"", area, type, user);"	task4	
"public class A { <line0> private Driver loadDriver() throws SQLException { <line1> try { <line2> if (jdbcDriver != null && jdbcDriver.length() > 0) { <line3> return loadDriverUsingClassName(); <line4> } else { <line5> return loadDriverUsingURL(); <line6> } <line7> } catch (Exception ex) { <line8> String msg = ""An Exception was caught while trying to load the driver. %s""; <line9> String msgArg = ex.getLocalizedMessage(); <line10> throw new SQLException(String.format(msg, msgArg)); <line11> } <line12> } <line13> } <line14> "	<line10>      logger.error(String.format(msg, msgArg), ex);	task4	
public class A { <line0> private void shutdownManagedChannel() { <line1> if (managedChannel == null) { <line2> return; <line3> } <line4> try { <line5> managedChannel.shutdownNow(); <line6> managedChannel.awaitTermination(1000L, TimeUnit.MILLISECONDS); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	"<line8>      LOG.info(""Shutting down ManagedChannel failed."", e);"	task4	
public class A { <line0> @Override <line1> public void onFailure(Throwable t) { <line2> try { <line3> logTimeseriesDeleted(user, entityId, keys, t); <line4> } catch (ThingsboardException e) { <line5> } <line6> resultFuture.setException(t); <line7> } <line8> } <line9> 	"<line5>      log.error(""Failed to log timeseries delete"", e);"	task4	
public class A { <line0> private void logRequestSize(Item item) { <line1> if (logRequestSizeLimit == null) { <line2> return; <line3> } <line4> int sizeInBytes = item.getSize(); <line5> if (sizeInBytes > logRequestSizeLimit) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOGGER.warn(""Large document detected (id: %s). Size in bytes: %d"",item.getVertexiumObjectId(), sizeInBytes);"	task4	
public class A { <line0> @Override <line1> public void lifeCycleStopping(@Nullable LifeCycle arg0) { <line2> } <line3> } <line4> 	"<line2>    logger.trace(""WebSocketClient stopping"");"	task4	
public class A { <line0> @Override <line1> public void runEx(RunnableEx runnable) throws Exception { <line2> startTransactionIfNeeded(); <line3> runnable.run(); <line4> flushAndClear(); <line5> } <line6> } <line7> 	"<line2>    log.debug(""running in TestTransactionUtil"");"	task4	
public class A { <line0> @Override <line1> public void onNext(final TaskStop event) { <line2> NoopTask.this.stopTask(); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""NoopTask.TaskStopHandler.send() invoked."");"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> checkNotNull(embeddedAgentModule); <line4> embeddedAgentModule.waitForSimpleRepoModule(); <line5> embeddedAgentModule.initEmbeddedServer(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	<line7>      logger.error(e.getMessage(), e);	task4	
public class A { <line0> private ClassSpace createClassSpace() { <line1> URLClassSpace space; <line2> if (plugin.classLoader instanceof PluginClassLoader) { <line3> PluginClassLoader cl = (PluginClassLoader) plugin.classLoader; <line4> space = new URLClassSpace(cl, cl.getURLs()); <line5> } else { <line6> space = new URLClassSpace(plugin.classLoader); <line7> } <line8> return space; <line9> } <line10> } <line11> 	"<line6>      log.warn(""Expected plugin to have PluginClassLoader; instead found: {}"",plugin.classLoader.getClass().getName());"	task4	
"public class A { <line0> public void sendOutbind(String systemId, String password) throws IOException { <line1> if (sessionContext().getSessionState().equals(SessionState.CLOSED)) { <line2> throw new IOException(""Session "" + sessionId + "" is closed""); <line3> } <line4> OutbindCommandTask task = new OutbindCommandTask(pduSender, systemId, password); <line5> try { <line6> executeSendCommandWithNoResponse(task); <line7> } catch (PDUException e) { <line8> } <line9> } <line10> } <line11> "	"<line8>      logger.warn(""PDU String should be always valid"", e);"	task4	
public class A { <line0> private static void logAndPrint(String s) { <line1> System.out.println(s); <line2> } <line3> } <line4> 	<line2>    log.info(s);	task4	
"public class A { <line0> @Bean <line1> @ConditionalOnProperty(""sap.security.services.xsuaa.uaadomain"") <line2> public JwtDecoder hybridJwtDecoder( <line3> XsuaaServiceConfiguration xsuaaConfig, IdentityServiceConfiguration identityConfig) { <line4> return new JwtDecoderBuilder() <line5> .withIasServiceConfiguration(identityConfig) <line6> .withXsuaaServiceConfiguration(xsuaaConfig) <line7> .build(); <line8> } <line9> } <line10> "	"<line4>    LOGGER.debug(""auto-configures HybridJwtDecoder."");"	task4	
"public class A { <line0> private static IoBufferEx encodeClose( <line1> IoBufferAllocatorEx<?> allocator, int flags, AmqpCloseMessage message) <line2> throws IllegalStateException { <line3> String replyText = message.getReplyText(); <line4> int size = 1 + 2 + 4 + 2 + 2 + 2 + 1 + replyText.length() + 2 + 2 + 1; <line5> ByteBuffer allocated = allocator.allocate(size, flags); <line6> int offset = allocated.position(); <line7> int payloadSize = size - 8; <line8> putUnsigned(allocated, AmqpFrame.METHOD.type()); <line9> putUnsignedShort(allocated, (short) message.getChannelId()); <line10> putUnsignedInt(allocated, payloadSize); <line11> putUnsignedShort(allocated, message.getClassKind().classId()); <line12> putUnsignedShort(allocated, message.getMethodKind().methodId()); <line13> putUnsignedShort(allocated, message.getReplyCode()); <line14> putShortString(allocated, replyText); <line15> putUnsignedShort(allocated, message.getReasonClassId()); <line16> putUnsignedShort(allocated, message.getReasonMethodId()); <line17> putUnsigned(allocated, AmqpClassMessage.FRAME_END); <line18> allocated.position(offset); <line19> Logger logger = LoggerFactory.getLogger(SERVICE_AMQP_PROXY_LOGGER); <line20> if (logger.isDebugEnabled()) { <line21> String s = "".encodeClose(): Raw Bytes - "" + getHexDump(allocated); <line22> } <line23> return allocator.wrap(allocated, flags); <line24> } <line25> } <line26> "	<line22>      logger.debug(CLASS_NAME + s);	task4	
"public class A { <line0> private void trainTest() throws Exception { <line1> try { <line2> String inputPath = ""../../data/a9a/a9a_123d_train.libsvm""; <line3> String savePath = LOCAL_FS + TMP_PATH + ""/FMmodel""; <line4> String logPath = LOCAL_FS + TMP_PATH + ""/FMlog""; <line5> conf.setInt(AngelConf.ANGEL_PS_NUMBER, 4); <line6> conf.set(AngelConf.ANGEL_TRAIN_DATA_PATH, inputPath); <line7> conf.set(AngelConf.ANGEL_SAVE_MODEL_PATH, savePath); <line8> conf.set(AngelConf.ANGEL_LOG_PATH, logPath); <line9> conf.set(AngelConf.ANGEL_ACTION_TYPE, MLConf.ANGEL_ML_TRAIN()); <line10> GraphRunner runner = new GraphRunner(); <line11> runner.train(conf); <line12> } catch (Exception x) { <line13> throw x; <line14> } <line15> } <line16> } <line17> "	"<line13>      LOG.error(""run trainOnLocalClusterTest failed "", x);"	task4	
"public class A { <line0> @Override <line1> @SuppressFBWarnings(value = ""OS_OPEN_STREAM"", justification = ""Testing only"") <line2> public void run() { <line3> BufferedReader input = <line4> new BufferedReader(new InputStreamReader(p1.getErrorStream(), StandardCharsets.UTF_8)); <line5> String line; <line6> try { <line7> while ((line = input.readLine()) != null) { <line8> System.out.println(line); <line9> } <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> "	"<line11>      LOG.error(""Failed to execute the command due the exception "" + e);"	task4	
public class A { <line0> private static Optional<LogLevelOverrideExtension> getLogLevelOverrideExtension( <line1> ApplicationContext context) { <line2> try { <line3> var extension = context.getBean(LogLevelOverrideExtension.class); <line4> return Optional.of(extension); <line5> } catch (NoSuchBeanDefinitionException e) { <line6> return Optional.empty(); <line7> } <line8> } <line9> } <line10> 	"<line4>      LOGGER.info(""{} activated"", LogLevelOverrideExtension.class.getSimpleName());"	task4	
public class A { <line0> @Override <line1> public boolean interrupt() { <line2> if (savedSock != null && savedSock.isOpen()) { <line3> try { <line4> savedSock.close(); <line5> } catch (IOException ex) { <line6> return false; <line7> } <line8> } <line9> return true; <line10> } <line11> } <line12> 	"<line6>        log.warn(""Exception while interrupting channel: "", ex);"	task4	
"public class A { <line0> @Override <line1> public void setStat(Handle handle, Attributes attributes) throws IOException { <line2> if (!isOpen()) { <line3> throw new IOException(""setStat("" + handle + "")["" + attributes + ""] client is closed""); <line4> } <line5> if (log.isDebugEnabled()) { <line6> } <line7> byte[] id = Objects.requireNonNull(handle, ""No handle"").getIdentifier(); <line8> Buffer buffer = new ByteArrayBuffer(id.length + (2 * Long.SIZE), false); <line9> buffer.putBytes(id); <line10> buffer = writeAttributes(SftpConstants.SSH_FXP_FSETSTAT, buffer, attributes); <line11> checkCommandStatus(SftpConstants.SSH_FXP_FSETSTAT, buffer); <line12> } <line13> } <line14> "	"<line6>      log.debug(""setStat({})[{}]: {}"", getClientChannel(), handle, attributes);"	task4	
public class A { <line0> @Override <line1> public void commit() throws SailException { <line2> super.commit(); <line3> resetDedupBuffer(); <line4> } <line5> } <line6> 	"<line3>    logger.debug(""Added {} unique statements, deduped {}"", addedStmts.size(), dedupCount);"	task4	
public class A { <line0> public static com.liferay.journal.model.JournalArticleSoap[] getArticlesByLayoutUuid( <line1> long groupId, String layoutUuid, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.journal.model.JournalArticle> returnValue = <line4> JournalArticleServiceUtil.getArticlesByLayoutUuid(groupId, layoutUuid, start, end); <line5> return com.liferay.journal.model.JournalArticleSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> private void appendToMailbox( <line1> Content message, <line2> Date datetime, <line3> Flags flagsToBeSet, <line4> ImapSession session, <line5> AppendRequest request, <line6> MessageManager mailbox, <line7> Responder responder, <line8> MailboxPath mailboxPath) { <line9> try { <line10> final MailboxSession mailboxSession = session.getMailboxSession(); <line11> final SelectedMailbox selectedMailbox = session.getSelected(); <line12> final boolean isSelectedMailbox = <line13> selectedMailbox != null && selectedMailbox.getMailboxId().equals(mailbox.getId()); <line14> final ComposedMessageId messageId = <line15> mailbox <line16> .appendMessage( <line17> MessageManager.AppendCommand.builder() <line18> .withInternalDate(datetime) <line19> .withFlags(flagsToBeSet) <line20> .isRecent(!isSelectedMailbox) <line21> .build(message), <line22> mailboxSession) <line23> .getId(); <line24> if (isSelectedMailbox) { <line25> selectedMailbox.addRecent(messageId.getUid()); <line26> } <line27> UidValidity uidValidity = mailbox.getMailboxEntity().getUidValidity(); <line28> unsolicitedResponses(session, responder, false); <line29> okComplete( <line30> request, <line31> ResponseCode.appendUid(uidValidity, new UidRange[] {new UidRange(messageId.getUid())}), <line32> responder); <line33> } catch (MailboxNotFoundException e) { <line34> tryCreate(request, responder, e); <line35> } catch (MailboxException e) { <line36> no(request, responder, HumanReadableText.SAVE_FAILED); <line37> } <line38> } <line39> } <line40> 	"<line36>      LOGGER.error(""Unable to append message to mailbox {}"", mailboxPath, e);"	task4	
"public class A { <line0> @Override <line1> @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = ""DB_DUPLICATE_BRANCHES"") <line2> public Page<T> success(HttpResponse hr) throws Exception { <line3> parser.parseResult(hr.getContent()); <line4> List<T> rows = parser.getRows(); <line5> int rowsSize = rows.size(); <line6> if (pageRequest.isBack()) { <line7> Collections.reverse(rows); <line8> } <line9> int offset = pageRequest.isBack() ? 1 : 1; <line10> String nextId = parser.getLastId(); <line11> JsonNode nextKey = parser.getLastKey(); <line12> PageRequest.Builder b = pageRequest.nextRequest(nextKey, nextId); <line13> int currentPage = b.getPageNo(); <line14> PageRequest nextRequest = b.page(currentPage + 1).build(); <line15> PageRequest previousRequest = <line16> currentPage == 1 <line17> ? PageRequest.firstPage(pageRequest.getPageSize()) <line18> : b.back(true).page(currentPage - 1).build(); <line19> boolean hasMore = rowsSize == pageRequest.getPageSize() + offset; <line20> if (hasMore) { <line21> rows.remove(rows.size() - 1); <line22> } else if (!pageRequest.isBack()) { <line23> nextRequest = null; <line24> } <line25> if (currentPage == 0) { <line26> previousRequest = null; <line27> } <line28> return new Page<T>( <line29> rows, parser.getTotalRows(), pageRequest.getPageSize(), previousRequest, nextRequest); <line30> } <line31> } <line32> "	"<line6>    LOG.debug(""got {} rows"", rowsSize);"	task4	
public class A { <line0> @Override <line1> public void delete(String key) { <line2> File file = new File(getMapStorePath() + key + PERSISTED_FILE_SUFFIX); <line3> if (file.exists()) { <line4> if (!file.delete()) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        LOGGER.debug(""File was unable to be deleted: {}"", file.getAbsolutePath());"	task4	
"public class A { <line0> @Then(""^the \""([^\""]*)\"" meter reads gas result should be returned$"") <line1> public void theMeterReadsGasResultShouldBeReturned( <line2> final String periodType, final Map<String, String> settings) throws Throwable { <line3> final PeriodicMeterReadsGasAsyncRequest asyncRequest = <line4> PeriodicMeterReadsGasRequestFactory.fromScenarioContext(); <line5> final PeriodicMeterReadsGasResponse response = this.responseClient.getResponse(asyncRequest); <line6> assertThat(response).as(""PeriodicMeterReadsGasResponse should not be null"").isNotNull(); <line7> assertThat(response.getPeriodType()) <line8> .as(""PeriodType should match"") <line9> .isEqualTo(PeriodType.fromValue(periodType)); <line10> assertThat(response.getPeriodicMeterReadsGas()) <line11> .as(""Expected periodic meter reads gas"") <line12> .isNotNull(); <line13> } <line14> } <line15> "	"<line5>    LOGGER.warn(""Asyncrequest: {} "", asyncRequest);"	task4	
public class A { <line0> @Override <line1> public void addQueryToCache(String statement, Query query) { <line2> if (approximateSize.getAndIncrement() >= upperBound) { <line3> synchronized (clearLock) { <line4> if (approximateSize.get() >= upperBound) { <line5> if (warnWhenFull) { <line6> } <line7> clear(); <line8> approximateSize.set(1); <line9> } <line10> } <line11> } <line12> _map.putIfAbsent(statement, new SoftReference<>(query)); <line13> } <line14> } <line15> 	"<line6>            logger.warn(""Cache is being evicted because it exceeded max capacity {}. Consider increasing""+ "" cache size with the {} system property, or using an unbound cache with the""+ "" {} system property"",upperBound,SystemProperties.BOUNDED_QUERY_CACHE_SIZE,SystemProperties.ENABLE_BOUNDED_QUERY_CACHE);"	task4	
"public class A { <line0> public static com.liferay.message.boards.model.MBMessage addMessage( <line1> HttpPrincipal httpPrincipal, <line2> long categoryId, <line3> String subject, <line4> String body, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey(MBMessageServiceUtil.class, ""addMessage"", _addMessageParameterTypes3); <line10> MethodHandler methodHandler = <line11> new MethodHandler(methodKey, categoryId, subject, body, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.message.boards.model.MBMessage) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> protected void createClient() { <line2> boolean browseOnly = false; <line3> try { <line4> if (!session.queueQuery(queueName).isExists() && autoCreateQueue) { <line5> session.createAddress(queueName, RoutingType.MULTICAST, true); <line6> session.createQueue(new QueueConfiguration(queueName)); <line7> } <line8> consumer = session.createConsumer(queueName, browseOnly); <line9> } catch (ActiveMQException amqEx) { <line10> throw new ActiveMQClientResourceException( <line11> String.format(""Error creating consumer for queueName %s"", queueName.toString()), amqEx); <line12> } <line13> } <line14> } <line15> "	"<line5>        log.warn(""{}: queue does not exist - creating queue: address = {}, name = {}"",this.getClass().getSimpleName(),queueName.toString(),queueName.toString());"	task4	
"public class A { <line0> private HttpURLConnection connect(URL url) throws IOException { <line1> final URLConnectionFactory factory = new URLConnectionFactory(settings); <line2> final HttpURLConnection conn = factory.createHttpURLConnection(url, useProxy); <line3> conn.setDoOutput(true); <line4> conn.addRequestProperty(""X-Result-Detail"", ""info""); <line5> final String username = settings.getString(Settings.KEYS.ANALYZER_ARTIFACTORY_API_USERNAME); <line6> final String apiToken = settings.getString(Settings.KEYS.ANALYZER_ARTIFACTORY_API_TOKEN); <line7> if (username != null && apiToken != null) { <line8> final String userpassword = username + "":"" + apiToken; <line9> final String encodedAuthorization = <line10> Base64.getEncoder().encodeToString(userpassword.getBytes(StandardCharsets.UTF_8)); <line11> conn.addRequestProperty(""Authorization"", ""Basic "" + encodedAuthorization); <line12> } else { <line13> final String bearerToken = <line14> settings.getString(Settings.KEYS.ANALYZER_ARTIFACTORY_BEARER_TOKEN); <line15> if (bearerToken != null) { <line16> conn.addRequestProperty(""Authorization"", ""Bearer "" + bearerToken); <line17> } <line18> } <line19> conn.connect(); <line20> return conn; <line21> } <line22> } <line23> "	"<line1>    LOGGER.debug(""Searching Artifactory url {}"", url);"	task4	
"public class A { <line0> static List<Protocol> parseProtocols(String protocols) { <line1> if (StringUtils.isEmpty(protocols)) { <line2> return null; <line3> } <line4> List<Protocol> protocolList = new ArrayList<>(); <line5> try { <line6> List<String> protocolStrings = <line7> objectMapper.readValue(protocols, new TypeReference<List<String>>() {}); <line8> for (String protocol : protocolStrings) { <line9> protocolList.add( <line10> Protocol.valueOf(CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, protocol))); <line11> } <line12> return protocolList; <line13> } catch (Exception e) { <line14> throw new IllegalStateException(""INVALID configured test protocols "" + protocols); <line15> } <line16> } <line17> } <line18> "	"<line14>      logger.error(""INVALID configured test protocols [{}]."", protocols);"	task4	
public class A { <line0> @Override <line1> public void process(@Nullable AudioStream audioStream) <line2> throws UnsupportedAudioFormatException, UnsupportedAudioStreamException { <line3> Coordinator localCoordinator = coordinator; <line4> if (localCoordinator != null) { <line5> localCoordinator.audioSink.process(audioStream); <line6> } else { <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.debug(""Cannot process audioStream. No coordinator has been initialized."");"	task4	
public class A { <line0> public String compressStringifiedRules() { <line1> final String stringified = stringifyRules(); <line2> final ByteArrayOutputStream out = new ByteArrayOutputStream(); <line3> String encodedResult = null; <line4> try { <line5> final DeflaterOutputStream dzip = new DeflaterOutputStream(out); <line6> dzip.write(stringified.getBytes()); <line7> dzip.close(); <line8> encodedResult = Base64.encodeBase64String(out.toByteArray()); <line9> } catch (final IOException e) { <line10> } <line11> return encodedResult; <line12> } <line13> } <line14> 	"<line10>      LOGGER.warn(""Exception while compressing security group rules"");"	task4	
"public class A { <line0> @Test <line1> public void testLoginButton() { <line2> tester.startPage(GeoServerHomePage.class); <line3> String html = tester.getLastResponseAsString(); <line4> assertTrue( <line5> html.contains( <line6> ""<form style=\""display: inline-block;\"" method=\""post\"""" <line7> + "" action=\""../web/j_spring_oauth2_geonode_login\"">"")); <line8> assertTrue( <line9> html.contains( <line10> ""<img src=\""./wicket/resource/org.geoserver.web.security.oauth2.GeoNodeOAuth2AuthProviderPanel/geonode"")); <line11> } <line12> } <line13> "	"<line4>    LOGGER.info(""Last page HTML:\n"" + html);"	task4	
"public class A { <line0> @SuppressWarnings(""squid:S3776"") <line1> public static void recoverUpgrade() { <line2> if (FSFactoryProducer.getFSFactory().getFile(UpgradeLog.getUpgradeLogPath()).exists()) { <line3> try (BufferedReader upgradeLogReader = <line4> new BufferedReader( <line5> new FileReader( <line6> FSFactoryProducer.getFSFactory().getFile(UpgradeLog.getUpgradeLogPath())))) { <line7> String line = null; <line8> while ((line = upgradeLogReader.readLine()) != null) { <line9> String oldFilePath = line.split(COMMA_SEPERATOR)[0]; <line10> String oldFileName = new File(oldFilePath).getName(); <line11> if (upgradeRecoverMap.containsKey(oldFileName)) { <line12> upgradeRecoverMap.put(oldFileName, upgradeRecoverMap.get(oldFileName) + 1); <line13> } else { <line14> upgradeRecoverMap.put(oldFileName, 1); <line15> } <line16> } <line17> } catch (IOException e) { <line18> } finally { <line19> FSFactoryProducer.getFSFactory().getFile(UpgradeLog.getUpgradeLogPath()).delete(); <line20> } <line21> } <line22> } <line23> } <line24> "	"<line18>        logger.error(""meet error when recover upgrade process, file path:{}"",UpgradeLog.getUpgradeLogPath(),e);"	task4	
public class A { <line0> public String getClientID() { <line1> return this.clientID; <line2> } <line3> } <line4> 	"<line1>    logger.debug(""Getting clientID ["" + this.clientID + ""]"");"	task4	
public class A { <line0> private static InetAddress getLocalAddress() { <line1> Enumeration<NetworkInterface> ifaces = null; <line2> try { <line3> ifaces = NetworkInterface.getNetworkInterfaces(); <line4> } catch (SocketException e) { <line5> } <line6> if (ifaces != null) { <line7> while (ifaces.hasMoreElements()) { <line8> NetworkInterface iface = ifaces.nextElement(); <line9> Enumeration<InetAddress> addresses = iface.getInetAddresses(); <line10> while (addresses.hasMoreElements()) { <line11> InetAddress addr = addresses.nextElement(); <line12> if (addr instanceof Inet4Address && !addr.isLoopbackAddress()) { <line13> return addr; <line14> } <line15> } <line16> } <line17> } <line18> return null; <line19> } <line20> } <line21> 	"<line5>      log.error(""Failed to get host address"", e);"	task4	
public class A { <line0> public boolean accept(String[] query) { <line1> if (solrQuery == null) { <line2> return false; <line3> } <line4> return super.accept(query); <line5> } <line6> } <line7> 	"<line2>      logger.warn(""{} denies to handle request for {} since query is still undefined"", this, query);"	task4	
public class A { <line0> @Override <line1> public void onBeforeRemove(Group group) throws ModelListenerException { <line2> ChangesetCollection changesetCollection = <line3> _changesetCollectionLocalService.fetchChangesetCollection( <line4> group.getGroupId(), StagingConstants.RANGE_FROM_LAST_PUBLISH_DATE_CHANGESET_NAME); <line5> if (changesetCollection == null) { <line6> return; <line7> } <line8> try { <line9> _changesetCollectionLocalService.deleteChangesetCollection( <line10> changesetCollection.getChangesetCollectionId()); <line11> } catch (PortalException portalException) { <line12> } <line13> } <line14> } <line15> 	<line12>      log.error(portalException, portalException);	task4	
public class A { <line0> private void initiatingAuthentication( <line1> HttpServletRequest request, <line2> HttpServletResponse response, <line3> HttpSession session, <line4> OAuthService service) <line5> throws IOException { <line6> session.setAttribute(ENTRY_URL, request.getRequestURL()); <line7> String authUrl = service.getAuthorizationUrl(null); <line8> response.sendRedirect(authUrl); <line9> } <line10> } <line11> 	<line6>    LOG.info(LOG_MESSAGE_AUTH_INITIATING, new Object[] {request.getRemoteAddr()});	task4	
public class A { <line0> @Override <line1> public void onSuccess(@Nullable final Collection<SgtInfo> result) { <line2> final Integer counter = Optional.ofNullable(result).map(Collection::size).orElse(0); <line3> storeOutcome(true, counter, null); <line4> } <line5> } <line6> 	"<line3>    LOG.debug(""ise harvest finished, outcome: {}"", counter);"	task4	
"public class A { <line0> private String formatDateTime(String value, String dpt) { <line1> Date date = null; <line2> try { <line3> if (DPTXlatorDate.DPT_DATE.getID().equals(dpt)) { <line4> date = new SimpleDateFormat(DATE_FORMAT).parse(value); <line5> } else if (DPTXlatorTime.DPT_TIMEOFDAY.getID().equals(dpt)) { <line6> if (value.contains(""no-day"")) { <line7> StringBuffer stb = new StringBuffer(value); <line8> int start = stb.indexOf(""no-day""); <line9> int end = start + ""no-day"".length(); <line10> stb.replace(start, end, String.format(Locale.US, ""%1$ta"", Calendar.getInstance())); <line11> value = stb.toString(); <line12> } <line13> date = new SimpleDateFormat(TIME_DAY_FORMAT, Locale.US).parse(value); <line14> } <line15> } catch (ParseException pe) { <line16> } <line17> return date != null ? new SimpleDateFormat(DateTimeType.DATE_PATTERN).format(date) : """"; <line18> } <line19> } <line20> "	"<line16>      logger.warn(""Could not parse '{}' to a valid date"", value);"	task4	
public class A { <line0> @Test <line1> public void testSlowAppendWithoutTimeout() <line2> throws InterruptedException, LifecycleException, EventDeliveryException, IOException { <line3> slowAppendTestHelper(0); <line4> } <line5> } <line6> 	"<line3>    LOG.debug(""Starting..."");"	task4	
public class A { <line0> public BufferedWriter getBufferedWriter(String filePath, boolean append) { <line1> try { <line2> return new BufferedWriter(new OutputStreamWriter(fs.create(new Path(filePath)))); <line3> } catch (IOException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	"<line4>      logger.error(""Failed to get buffered writer for {}. "", filePath, e);"	task4	
"public class A { <line0> private void waitUntilServiceIsReady() throws Exception { <line1> getProvisionedServiceItem().expandServiceItem(); <line2> selenium.takeScreenShot(); <line3> selenium <line4> .getDriverWait() <line5> .withTimeout(Duration.ofMinutes(5)) <line6> .until(ExpectedConditions.numberOfElementsToBe(By.className(""alert-info""), 0)); <line7> selenium.takeScreenShot(); <line8> } <line9> } <line10> "	"<line2>    log.info(""Waiting until provisioned service will be completed"");"	task4	
public class A { <line0> @Override <line1> public void debug(String message, Throwable e) { <line2> if (isEnabled(LogLevel.DEBUG)) { <line3> } <line4> } <line5> } <line6> 	<line3>      this.logger.debug(buildMessage(message), e);	task4	
public class A { <line0> @Override <line1> protected Map<Path, Distribution> operate(final PasswordCallback callback, final Path file) <line2> throws BackgroundException { <line3> final DistributionConfiguration feature = session.getFeature(DistributionConfiguration.class); <line4> if (null == feature) { <line5> return Collections.emptyMap(); <line6> } <line7> final AttributedList<Path> containers = <line8> new SwiftContainerListService( <line9> session, new SwiftLocationFeature.SwiftRegion(session.getHost().getRegion())) <line10> .list(file, new DisabledListProgressListener()); <line11> final Map<Path, Distribution> distributions = new ConcurrentHashMap<>(); <line12> for (Path container : containers) { <line13> for (Distribution.Method method : feature.getMethods(container)) { <line14> final Distribution distribution = <line15> feature.read(container, method, new DisabledLoginCallback()); <line16> if (log.isInfoEnabled()) { <line17> } <line18> distributions.put(container, distribution); <line19> } <line20> } <line21> return distributions; <line22> } <line23> } <line24> 	"<line17>          log.info(String.format(""Cache distribution %s"", distribution));"	task4	
"public class A { <line0> private Long toLong(final Object possibleLong) { <line1> if (possibleLong instanceof Date) { <line2> return ((Date) possibleLong).getTime(); <line3> } else if (possibleLong instanceof Number) { <line4> return ((Number) possibleLong).longValue(); <line5> } else { <line6> try { <line7> return (new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"").parse(possibleLong.toString())) <line8> .getTime(); <line9> } catch (ParseException ignore) { <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> "	"<line12>    logger.warn(""Cannot convert object to long: {}"", possibleLong);"	task4	
"public class A { <line0> @RequestMapping(value = Constants.UDR_GET_BY_AUTHOR_TITLE, method = RequestMethod.GET) <line1> public JsonServiceResponse getUDR(@PathVariable String authorId, @PathVariable String title) { <line2> UdrSpecification resp = udrService.fetchUdr(authorId, title); <line3> return new JsonServiceResponse(Status.SUCCESS, ""GET UDR was successful"", resp); <line4> } <line5> } <line6> "	"<line2>    logger.debug(""getUDR() user ="" + authorId + "", title="" + title);"	task4	
"public class A { <line0> @Test <line1> @Order(2) <line2> void testWhenCaptured() { <line3> assertEquals(""captured error"", logCapture.getMessage(3)); <line4> } <line5> } <line6> "	"<line3>    LOGGER.error(""captured error"");"	task4	
public class A { <line0> public void shutdown() { <line1> try { <line2> if (agent != null) { <line3> agent.die(); <line4> agent.cleanup(); <line5> } <line6> } catch (Throwable e) { <line7> } <line8> } <line9> } <line10> 	<line7>      logger.error(e, e);	task4	
public class A { <line0> public static DataSources fromDataSourcesUrl(URL dataSourcesUrl) { <line1> DataSources dataSources = null; <line2> try { <line3> dataSources = OBJECT_MAPPER.readValue(dataSourcesUrl, DataSources.class); <line4> } catch (IOException e) { <line5> } <line6> return dataSources; <line7> } <line8> } <line9> 	"<line5>      LOG.error(""Exception in reading data sources file {}"", dataSourcesUrl, e);"	task4	
"public class A { <line0> @Override <line1> public void blockUntilReady() throws TimeoutException, InterruptedException { <line2> long startTime = System.currentTimeMillis(); <line3> if (_config.blockUntilReady() <= 0) { <line4> throw new IllegalArgumentException( <line5> ""setBlockUntilReadyTimeout must be positive but in config was: "" <line6> + _config.blockUntilReady()); <line7> } <line8> if (!_gates.isSDKReady(_config.blockUntilReady())) { <line9> throw new TimeoutException( <line10> ""SDK was not ready in "" + _config.blockUntilReady() + "" milliseconds""); <line11> } <line12> } <line13> } <line14> "	"<line12>    log.debug(String.format(""Split SDK ready in %d ms"", (System.currentTimeMillis() - startTime)));"	task4	
"public class A { <line0> @GetMapping(""/list.json"") <line1> @AuthAction(AuthService.PrivilegeType.READ_RULE) <line2> public Result<List<ApiDefinitionEntity>> queryApis(String app, String ip, Integer port) { <line3> if (StringUtil.isEmpty(app)) { <line4> return Result.ofFail(-1, ""app can't be null or empty""); <line5> } <line6> if (StringUtil.isEmpty(ip)) { <line7> return Result.ofFail(-1, ""ip can't be null or empty""); <line8> } <line9> if (port == null) { <line10> return Result.ofFail(-1, ""port can't be null""); <line11> } <line12> try { <line13> List<ApiDefinitionEntity> apis = sentinelApiClient.fetchApis(app, ip, port).get(); <line14> repository.saveAll(apis); <line15> return Result.ofSuccess(apis); <line16> } catch (Throwable throwable) { <line17> return Result.ofThrowable(-1, throwable); <line18> } <line19> } <line20> } <line21> "	"<line17>      logger.error(""queryApis error:"", throwable);"	task4	
public class A { <line0> private void collectExtensions(Enumeration<URL> urls, Set<String> bucket) throws IOException { <line1> while (urls.hasMoreElements()) { <line2> URL url = urls.nextElement(); <line3> collectExtensions(url.openStream(), bucket); <line4> } <line5> } <line6> } <line7> 	"<line3>      log.debug(""Read '{}'"", url.getFile());"	task4	
public class A { <line0> public static Integer getPrecisionValue(IdentifierNode fieldNameNode) { <line1> try { <line2> String fieldName = fieldNameNode.getIdentifier(); <line3> String txtIndex = fieldName.substring(fieldName.indexOf('(') + 1, fieldName.indexOf(')')); <line4> return Integer.parseInt(txtIndex); <line5> } catch (Exception e) { <line6> return null; <line7> } <line8> } <line9> } <line10> 	"<line6>      LOG.debug(""Ignored error: "", e);"	task4	
"public class A { <line0> @Test <line1> public void testSendTextMessage() throws Exception { <line2> String expectedBody = ""Hello there!""; <line3> template.sendBodyAndHeader(startEndpointUri, expectedBody, ""cheese"", 123); <line4> listener.assertMessagesArrived(1, 5000); <line5> List<Message> list = listener.flushMessages(); <line6> assertFalse(list.isEmpty(), ""Should have received some messages!""); <line7> Message message = list.get(0); <line8> TextMessage textMessage = assertIsInstanceOf(TextMessage.class, message); <line9> assertEquals(expectedBody, textMessage.getText(), ""Text message body: "" + textMessage); <line10> } <line11> } <line12> "	"<line8>    LOG.debug(""Received: {}"", message);"	task4	
"public class A { <line0> @Test <line1> public void willWriteSrcDirIncludesExcludesToConfigFile() throws Exception { <line2> File configFile = new File(tempFolder.getRoot(), ""zanata.xml""); <line3> configFile.createNewFile(); <line4> FileUtils.write( <line5> configFile, readFromClasspath(""serverresponse/projectConfig.xml""), Charsets.UTF_8); <line6> command.writeToConfig(new File(""pot""), null, """", new File(""po""), configFile); <line7> List<String> lines = FileUtils.readLines(configFile, Charsets.UTF_8); <line8> StringBuilder content = new StringBuilder(); <line9> for (String line : lines) { <line10> content.append(line.trim()); <line11> } <line12> assertThat(content.toString()).contains(""<src-dir>pot</src-dir><trans-dir>po</trans-dir>""); <line13> } <line14> } <line15> "	<line10>      log.debug(line);	task4	
"public class A { <line0> public void endDispatch() { <line1> DispatchElement oldde = null; <line2> if (dispatches.size() > 0) { <line3> oldde = dispatches.remove(dispatches.size() - 1); <line4> } <line5> reqctx.endDispatch(); <line6> if (dispatches.size() > 0) { <line7> DispatchElement de = dispatches.get(dispatches.size() - 1); <line8> if ((de.type == Type.INC) || (de.type == Type.FWD)) { <line9> reqctx.startDispatch(this, de.qparms, phase); <line10> } <line11> } else { <line12> isClosed = true; <line13> } <line14> if (isTrace) { <line15> StringBuilder txt = new StringBuilder(); <line16> txt.append(""Ending dispatch.""); <line17> txt.append("" dispatched type: "").append(oldde.type); <line18> txt.append("",  # remaining nesting levels: "").append(dispatches.size()); <line19> if (!dispatches.isEmpty()) { <line20> txt.append("",  active dispatch type: ""); <line21> txt.append(dispatches.get(dispatches.size() - 1).type); <line22> } <line23> } <line24> } <line25> } <line26> "	<line23>      LOG.debug(txt.toString());	task4	
public class A { <line0> public static Set<String> getHadoopClusterQueueNames(String rmBaseUrlStr) throws FalconException { <line1> String jsonResult = getHadoopClusterSchedulerInfo(rmBaseUrlStr); <line2> Set<String> qNames = new HashSet<>(); <line3> try { <line4> return getHadoopClusterQueueNamesHelper(jsonResult, qNames); <line5> } catch (JSONException jex) { <line6> throw new FalconException(jex); <line7> } <line8> } <line9> } <line10> 	"<line2>    LOG.debug(""Scheduler Info Result : {} "", jsonResult);"	task4	
public class A { <line0> @Override <line1> public SessionData load(String id) throws Exception { <line2> SessionData d = null; <line3> try { <line4> d = _cache.load(id); <line5> } catch (Exception e) { <line6> } <line7> if (d != null) return d; <line8> d = _store.load(id); <line9> return d; <line10> } <line11> } <line12> 	"<line6>      LOG.warn(""Unable to load id {}"", id, e);"	task4	
public class A { <line0> public void executeSplit(KeyExtent tablet, Runnable splitTask) { <line1> if (tablet.isMeta()) { <line2> if (tablet.isRootTablet()) { <line3> return; <line4> } <line5> defaultSplitThreadPool.execute(splitTask); <line6> } else { <line7> splitThreadPool.execute(splitTask); <line8> } <line9> } <line10> } <line11> 	"<line3>        log.warn(""Saw request to split root tablet, ignoring"");"	task4	
public class A { <line0> public File getRollbackTarget(RollbackOptions opt) { <line1> String entryKey = opt.getKey(); <line2> Match<File> m = findInstalledJar(entryKey); <line3> if (m != null) { <line4> return m.object; <line5> } else { <line6> return null; <line7> } <line8> } <line9> } <line10> 	"<line6>      log.trace(""Could not find jar with key: "" + entryKey);"	task4	
"public class A { <line0> @Override <line1> public PagedMetadata<WidgetDto> getWidgets(RestListRequest restListReq) { <line2> try { <line3> List<WidgetType> types = this.getWidgetManager().getWidgetTypes(); <line4> List<WidgetDto> dtoList = dtoBuilder.convert(types); <line5> List<WidgetDto> resultList = <line6> new WidgetTypeListProcessor(restListReq, dtoList).filterAndSort().toList(); <line7> List<WidgetDto> sublist = restListReq.getSublist(resultList); <line8> SearcherDaoPaginatedResult<WidgetDto> paginatedResult = <line9> new SearcherDaoPaginatedResult<>(resultList.size(), sublist); <line10> PagedMetadata<WidgetDto> pagedMetadata = new PagedMetadata<>(restListReq, paginatedResult); <line11> pagedMetadata.setBody(sublist); <line12> return pagedMetadata; <line13> } catch (Throwable t) { <line14> throw new RestServerError(""error in get widgets"", t); <line15> } <line16> } <line17> } <line18> "	"<line14>      logger.error(""error in get widgets"", t);"	task4	
public class A { <line0> public static void updateComponentSecret(String subdomain, String secret) <line1> throws ModificationNotAllowedException { <line2> for (ExternalComponentManagerListener listener : listeners) { <line3> try { <line4> listener.componentSecretUpdated(subdomain, secret); <line5> } catch (Exception e) { <line6> } <line7> } <line8> ExternalComponentConfiguration configuration = getConfiguration(subdomain, false); <line9> if (configuration != null) { <line10> configuration.setPermission(Permission.allowed); <line11> configuration.setSecret(secret); <line12> deleteConfigurationFromDB(configuration); <line13> } else { <line14> configuration = <line15> new ExternalComponentConfiguration(subdomain, false, Permission.allowed, secret); <line16> } <line17> addConfiguration(configuration); <line18> } <line19> } <line20> 	"<line6>        Log.warn(""An exception occurred while dispatching a 'componentSecretUpdated' event!"", e);"	task4	
public class A { <line0> public void onPageUnload() { <line1> if (StringUtils.isNotEmpty(requestId)) { <line2> Explanator.remove(requestId); <line3> ParameterRegistry.remove(requestId); <line4> TableBean.tryUnlock(requestId); <line5> } <line6> } <line7> } <line8> 	"<line2>      log.debug(""Page unload for request id: {}"", requestId);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> while (running) { <line3> try { <line4> while (!outputQueue.isEmpty()) { <line5> final Envelope envelope = outputQueue.poll(); <line6> if (envelope != null) { <line7> final AbstractMessage message = envelope.getMessage(); <line8> final PeerInfo recipient = envelope.getPeer(); <line9> message.setSenderTimestamp(System.currentTimeMillis() + timeOffset); <line10> message.onSend(Peer.this); <line11> serverSocket.send(AbstractMessage.forSending(Peer.this.getUuid(), recipient, message)); <line12> sent++; <line13> } <line14> } <line15> Thread.sleep(10L); <line16> } catch (IOException ignore1) { <line17> } catch (InterruptedException ignore2) { <line18> } catch (Throwable t) { <line19> } <line20> } <line21> } <line22> } <line23> 	"<line19>        logger.warn("""", t);"	task4	
public class A { <line0> public static com.liferay.blogs.model.BlogsEntrySoap getEntry(long entryId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.blogs.model.BlogsEntry returnValue = BlogsEntryServiceUtil.getEntry(entryId); <line4> return com.liferay.blogs.model.BlogsEntrySoap.toSoapModel(returnValue); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      log.error(exception, exception);	task4	
public class A { <line0> public static void reload() { <line1> for (ReconfigurableBean bean : reconfigurableBeans) { <line2> try { <line3> bean.reloadConfiguration(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.warn(""while reloading configuration of "" + bean, e);"	task4	
"public class A { <line0> private List<ScheduleEntry> getScheduleEntryListFromParameter( <line1> HttpServletRequest request, ApplicationContext appContext, String campaign, JSONArray json) <line2> throws JSONException { <line3> List<ScheduleEntry> scheList = new ArrayList<>(); <line4> IScheduleEntryService scheService = appContext.getBean(IScheduleEntryService.class); <line5> IFactoryScheduleEntry scheFactory = appContext.getBean(IFactoryScheduleEntry.class); <line6> PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS); <line7> String charset = <line8> request.getCharacterEncoding() == null ? ""UTF-8"" : request.getCharacterEncoding(); <line9> for (int i = 0; i < json.length(); i++) { <line10> JSONObject tcsaJson = json.getJSONObject(i); <line11> boolean delete = tcsaJson.getBoolean(""toDelete""); <line12> String cronExpression = policy.sanitize(tcsaJson.getString(""cronDefinition"")); <line13> String active = policy.sanitize(tcsaJson.getString(""active"")); <line14> String strId = tcsaJson.getString(""ID""); <line15> String desc = tcsaJson.getString(""description""); <line16> String type = ""CAMPAIGN""; <line17> String name = campaign; <line18> int id; <line19> if (strId.isEmpty()) { <line20> id = 0; <line21> } else { <line22> try { <line23> id = Integer.parseInt(strId); <line24> } catch (NumberFormatException e) { <line25> id = 0; <line26> } <line27> } <line28> Timestamp timestampfactice = new Timestamp(System.currentTimeMillis()); <line29> if (!delete) { <line30> ScheduleEntry sch = <line31> scheFactory.create( <line32> id, <line33> type, <line34> name, <line35> cronExpression, <line36> timestampfactice, <line37> active, <line38> desc, <line39> request.getRemoteUser(), <line40> timestampfactice, <line41> request.getRemoteUser(), <line42> timestampfactice); <line43> scheList.add(sch); <line44> } <line45> } <line46> return scheList; <line47> } <line48> } <line49> "	"<line25>          LOG.warn(""Unable to parse pool size: "" + strId + "". Applying default value"");"	task4	
"public class A { <line0> public List<Long> doInHibernate(final Session session) throws HibernateException { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(""SELECT DISTINCT child.id AS child_id FROM quota AS father""); <line3> sb.append("" JOIN quota AS child""); <line4> sb.append("" ON child.domain_parent_id = father.domain_id""); <line5> sb.append("" AND child.quota_type = :domainType ""); <line6> sb.append("" AND father.domain_parent_id = :domainId ""); <line7> sb.append("" AND father.default_max_file_size_override = false""); <line8> sb.append("" WHERE father.quota_type = :domainType""); <line9> if (containerType != null) { <line10> sb.append("" AND child.container_type = :containerType""); <line11> } <line12> sb.append("" AND child.default_max_file_size_override = false""); <line13> sb.append("";""); <line14> @SuppressWarnings(""unchecked"") <line15> final NativeQuery<Long> query = session.createNativeQuery(sb.toString()); <line16> query.setParameter(""domainId"", domain.getPersistenceId()); <line17> query.addScalar(""child_id"", LongType.INSTANCE); <line18> query.setParameter(""domainType"", type.name()); <line19> if (containerType != null) { <line20> query.setParameter(""containerType"", containerType.name()); <line21> } <line22> List<Long> res = query.list(); <line23> return res; <line24> } <line25> } <line26> "	"<line23>    logger.debug(""child_ids :"" + res);"	task4	
public class A { <line0> @Override <line1> public void showUser(final String screenName) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(SHOW_USER, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> User user = twitter.showUser(screenName); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotUserDetail(user); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at showUser"", e);"	task4	
public class A { <line0> @Override <line1> public void ping(TCredentials credentials) { <line2> } <line3> } <line4> 	"<line2>    log.info(""Manager reports: I just got pinged!"");"	task4	
public class A { <line0> @Override <line1> public byte[] requestToBytes(RequestType request) { <line2> byte[] uncompressedBytes = _inner.requestToBytes(request); <line3> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line4> try { <line5> SnappyOutputStream snappyOutputStream = new SnappyOutputStream(baos); <line6> snappyOutputStream.write(uncompressedBytes); <line7> snappyOutputStream.close(); <line8> baos.close(); <line9> } catch (IOException e) { <line10> } <line11> return baos.toByteArray(); <line12> } <line13> } <line14> 	"<line10>      logger.error(""Could not compress sensei request "", e);"	task4	
public class A { <line0> private AbstractAction createCheckoutActionForBranch(String branchName) { <line1> return new AbstractAction(branchName) { <line2> @Override <line3> public void actionPerformed(ActionEvent e) { <line4> GitOperationScheduler.getInstance() <line5> .schedule( <line6> () -> { <line7> try { <line8> GitAccess.getInstance().setBranch(branchName); <line9> } catch (CheckoutConflictException ex) { <line10> restoreCurrentBranchSelectionInMenu(); <line11> BranchesUtil.showBranchSwitchErrorMessage(); <line12> } catch (GitAPIException | JGitInternalException ex) { <line13> restoreCurrentBranchSelectionInMenu(); <line14> PluginWorkspaceProvider.getPluginWorkspace() <line15> .showErrorMessage(ex.getMessage(), ex); <line16> } <line17> }); <line18> } <line19>  <line20> private void restoreCurrentBranchSelectionInMenu() { <line21> String currentBranchName = GitAccess.getInstance().getBranchInfo().getBranchName(); <line22> Component[] menuComponents = branchesSplitMenuButton.getMenuComponents(); <line23> for (Component component : menuComponents) { <line24> JRadioButtonMenuItem menuItem = (JRadioButtonMenuItem) component; <line25> if (menuItem.getText().equals(currentBranchName)) { <line26> menuItem.setSelected(true); <line27> break; <line28> } <line29> } <line30> } <line31> }; <line32> } <line33> } <line34> 	<line10>                    logger.debug(ex, ex);	task4	
"public class A { <line0> public static org.docx4j.xmlPackage.Part createRawBinaryPart(Part part) throws Docx4JException { <line1> String resolvedPartUri = part.getPartName().getName(); <line2> org.docx4j.xmlPackage.Part partResult = factory.createPart(); <line3> partResult.setName(resolvedPartUri); <line4> partResult.setContentType(part.getContentType()); <line5> try { <line6> partResult.setCompression(""store""); <line7> partResult.setBinaryData(((BinaryPart) part).getBytes()); <line8> } catch (Exception e) { <line9> throw new Docx4JException(""Failed to put binary part"", e); <line10> } <line11> return partResult; <line12> } <line13> } <line14> "	"<line11>    log.debug(""PUT SUCCESS: "" + resolvedPartUri);"	task4	
public class A { <line0> private void executeStatement(String sql, Statement stmt) throws SQLException { <line1> stmt.execute(sql); <line2> } <line3> } <line4> 	"<line1>    LOG.info(""Executing: "" + sql);"	task4	
public class A { <line0> @Override <line1> public void onStatusChanged(final UaSubscription subscription, final StatusCode status) { <line2> } <line3> } <line4> 	"<line2>    LOG.info(""Subscription status changed {} : {}"", subscription.getSubscriptionId(), status);"	task4	
"public class A { <line0> private void parseProcessOutput(Process process) { <line1> String threadLoggerInfoName = <line2> String.format( <line3> LoggerUtils.TASK_LOGGER_THREAD_NAME + ""-%s"", taskExecutionContext.getTaskAppId()); <line4> ExecutorService getOutputLogService = <line5> ThreadUtils.newDaemonSingleThreadExecutor( <line6> threadLoggerInfoName + ""-"" + ""getOutputLogService""); <line7> getOutputLogService.submit( <line8> () -> { <line9> BufferedReader inReader = null; <line10> try { <line11> inReader = new BufferedReader(new InputStreamReader(process.getInputStream())); <line12> String line; <line13> logBuffer.add(""welcome to use bigdata scheduling system...""); <line14> while ((line = inReader.readLine()) != null) { <line15> if (line.startsWith(""${setValue("")) { <line16> varPool.append(line.substring(""${setValue("".length(), line.length() - 2)); <line17> varPool.append(""$VarPool$""); <line18> } else { <line19> logBuffer.add(line); <line20> taskResultString = line; <line21> } <line22> } <line23> } catch (Exception e) { <line24> logger.error(e.getMessage(), e); <line25> } finally { <line26> logOutputIsScuccess = true; <line27> close(inReader); <line28> } <line29> }); <line30> getOutputLogService.shutdown(); <line31> ExecutorService parseProcessOutputExecutorService = <line32> ThreadUtils.newDaemonSingleThreadExecutor(threadLoggerInfoName); <line33> parseProcessOutputExecutorService.submit( <line34> () -> { <line35> try { <line36> long lastFlushTime = System.currentTimeMillis(); <line37> while (logBuffer.size() > 0 || !logOutputIsScuccess) { <line38> if (logBuffer.size() > 0) { <line39> lastFlushTime = flush(lastFlushTime); <line40> } else { <line41> Thread.sleep(Constants.DEFAULT_LOG_FLUSH_INTERVAL); <line42> } <line43> } <line44> } catch (Exception e) { <line45> } finally { <line46> clear(); <line47> } <line48> }); <line49> parseProcessOutputExecutorService.shutdown(); <line50> } <line51> } <line52> "	<line45>            logger.error(e.getMessage(), e);	task4	
"public class A { <line0> @Override <line1> public int compare(String[] item1, String[] item2) { <line2> String dateString1 = item1[5]; <line3> String dateString2 = item2[5]; <line4> SimpleDateFormat format = new SimpleDateFormat(""MM/dd/yyyy HH:mm:ss""); <line5> Date date1 = null; <line6> Date date2 = null; <line7> if (dateString1 == ""NA"") dateString1 = ""00/00/0000 00:00:00""; <line8> if (dateString2 == ""NA"") dateString2 = ""00/00/0000 00:00:00""; <line9> try { <line10> date1 = format.parse(dateString1); <line11> date2 = format.parse(dateString2); <line12> } catch (ParseException e) { <line13> return 0; <line14> } <line15> return date2.compareTo(date1); <line16> } <line17> } <line18> "	<line13>      log.error(e);	task4	
public class A { <line0> protected void leaked(LeakDetector.LeakInfo leakInfo) { <line1> } <line2> } <line3> 	"<line1>    LOG.info(""Connection {} leaked at:"", leakInfo.getResourceDescription(), leakInfo.getStackFrames());"	task4	
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { <line2> if (ctx.channel().isActive()) { <line3> sendError(ctx, INTERNAL_SERVER_ERROR); <line4> } <line5> } <line6> } <line7> 	"<line2>    log.warn(""Exception caught while serving static files"", cause);"	task4	
public class A { <line0> @Provides <line1> @Named(RABBITMQ_CONFIGURATION_NAME) <line2> @Singleton <line3> private org.apache.commons.configuration2.Configuration getConfiguration( <line4> PropertiesProvider propertiesProvider) throws ConfigurationException { <line5> try { <line6> return propertiesProvider.getConfiguration(RABBITMQ_CONFIGURATION_NAME); <line7> } catch (FileNotFoundException e) { <line8> throw new RuntimeException(e); <line9> } <line10> } <line11> } <line12> 	"<line8>      LOGGER.error(""Could not find "" + RABBITMQ_CONFIGURATION_NAME + "" configuration file."");"	task4	
public class A { <line0> private void sendMessage( <line1> final String ipAddress, <line2> final OslpEnvelope oslpRequest, <line3> final OslpResponseHandler oslpResponseHandler, <line4> final DeviceRequest deviceRequest) <line5> throws IOException { <line6> try { <line7> this.oslpChannelHandler.send( <line8> this.createAddress(ipAddress), <line9> oslpRequest, <line10> oslpResponseHandler, <line11> deviceRequest.getDeviceIdentification()); <line12> } catch (final RuntimeException e) { <line13> throw new IOException(e.getMessage()); <line14> } <line15> } <line16> } <line17> 	"<line13>      LOGGER.error(""Exception during sendMessage()"", e);"	task4	
"public class A { <line0> public static byte[] getServiceIcon(String serviceType) { <line1> try { <line2> String path = getResourceRoot() + fs + serviceType + "".png""; <line3> return Files.readAllBytes(Paths.get(path)); <line4> } catch (Exception e) { <line5> } <line6> return null; <line7> } <line8> } <line9> "	"<line5>      log.warn(""getServiceIcon threw"", e);"	task4	
public class A { <line0> public void deactivate() { <line1> httpService.unregister(path); <line2> this.bridgeHandler = null; <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Netatmo webhook servlet stopped"");"	task4	
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> protected void setResponseFuture(ArgScheme argScheme, Response response) { <line2> switch (argScheme) { <line3> case RAW: <line4> ((TFuture<RawResponse>) future).set((RawResponse) response); <line5> break; <line6> case JSON: <line7> ((TFuture<JsonResponse>) future).set((JsonResponse) response); <line8> break; <line9> case THRIFT: <line10> ((TFuture<ThriftResponse>) future).set((ThriftResponse) response); <line11> break; <line12> default: <line13> ((TFuture<RawResponse>) future).set((RawResponse) response); <line14> break; <line15> } <line16> } <line17> } <line18> "	"<line13>        logger.error(""unsupported arg scheme: {}"", argScheme);"	task4	
public class A { <line0> protected static int[] randomAttributes(Random rng, boolean[] selected, int m) { <line1> int nbNonSelected = 0; <line2> for (boolean sel : selected) { <line3> if (!sel) { <line4> nbNonSelected++; <line5> } <line6> } <line7> if (nbNonSelected == 0) { <line8> return NO_ATTRIBUTES; <line9> } <line10> int[] result; <line11> if (nbNonSelected <= m) { <line12> result = new int[nbNonSelected]; <line13> int index = 0; <line14> for (int attr = 0; attr < selected.length; attr++) { <line15> if (!selected[attr]) { <line16> result[index++] = attr; <line17> } <line18> } <line19> } else { <line20> result = new int[m]; <line21> for (int index = 0; index < m; index++) { <line22> int rind; <line23> do { <line24> rind = rng.nextInt(selected.length); <line25> } while (selected[rind]); <line26> result[index] = rind; <line27> selected[rind] = true; <line28> } <line29> for (int attr : result) { <line30> selected[attr] = false; <line31> } <line32> } <line33> return result; <line34> } <line35> } <line36> 	"<line8>      log.warn(""All attributes are selected !"");"	task4	
public class A { <line0> @Override <line1> public void service(final WebdavRequest request, final WebdavResponse response) <line2> throws WebdavException, IOException { <line3> requestInfo.setRequest(request); <line4> super.service(request, response); <line5> } <line6> } <line7> 	"<line3>    logger.debug(""Setting request in RequestInfo: {}"", requestInfo);"	task4	
public class A { <line0> public org.springframework.data.domain.Page<ModuleDto> findAllModules( <line1> final Pageable pageable, final ModuleSearchForm moduleSearchForm) { <line2> final PlatformUser platformAuthorizedUser = securityService.getAuthorizedUser(); <line3> final User authorizedUser = userService.find(platformAuthorizedUser.getId()); <line4> final org.springframework.data.domain.Page<Module> modules = <line5> moduleService.findAll(pageable, moduleSearchForm, authorizedUser); <line6> return moduleToModuleDtoConverter.convertToPage(modules); <line7> } <line8> } <line9> 	"<line2>    log.debug(""findAllModules() - pageable: {}, moduleSearchForm: {}"", pageable, moduleSearchForm);"	task4	
public class A { <line0> private void getDropletActions(Exchange exchange) throws Exception { <line1> Actions actions = <line2> getEndpoint() <line3> .getDigitalOceanClient() <line4> .getAvailableDropletActions( <line5> dropletId, configuration.getPage(), configuration.getPerPage()); <line6> exchange.getMessage().setBody(actions.getActions()); <line7> } <line8> } <line9> 	"<line6>    LOG.trace(""Actions for Droplet {} : page {} / {} per page [{}] "",dropletId,configuration.getPage(),configuration.getPerPage(),actions.getActions());"	task4	
"public class A { <line0> @Override <line1> public void sendMessage(SlackMessage message) { <line2> if (slackApi == null) { <line3> throw new IllegalStateException(""slackApi is null!""); <line4> } <line5> try { <line6> slackApi.call(message); <line7> } catch (SlackChannelNotFoundException ex) { <line8> } <line9> } <line10> } <line11> "	"<line8>      logger.warn(""Attempt to post slack message to invalid channel: "" + ex.getChannelName());"	task4	
"public class A { <line0> @Test <line1> public void testTimedFlush() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> UUID user1 = UUID.randomUUID(); <line5> UUID user2 = UUID.randomUUID(); <line6> Event event; <line7> for (int i = 0; i < 100; i++) { <line8> event = new Event(); <line9> event.setTimestamp(ts + (i * 60 * 1000)); <line10> event.addCounter(""visits"", 1); <line11> event.setUser(user1); <line12> em.create(event); <line13> event = new Event(); <line14> event.setTimestamp(ts + (i * 60 * 1000)); <line15> event.addCounter(""visits"", 1); <line16> event.setUser(user2); <line17> em.create(event); <line18> } <line19> Thread.sleep(30000); <line20> final long totalCount = returnCounts(em, ""visits""); <line21> assertEquals(200, totalCount); <line22> } <line23> } <line24> "	"<line2>    logger.info(""CounterIT.testCounters"");"	task4	
public class A { <line0> private void addToPollQueue(InsteonDevice d, long time) { <line1> long texp = findNextExpirationTime(d, time); <line2> PQEntry ne = new PQEntry(d, texp); <line3> pollQueue.add(ne); <line4> } <line5> } <line6> 	"<line3>    logger.trace(""added entry {} originally aimed at time {}"", ne, String.format(""%tc"", new Date(time)));"	task4	
"public class A { <line0> private void handleOnCompleted(PinpointGrpcServer pinpointGrpcServer, AgentInfo agentInfo) { <line1> Objects.requireNonNull(pinpointGrpcServer, ""pinpointGrpcServer""); <line2> Objects.requireNonNull(agentInfo, ""agentInfo""); <line3> pinpointGrpcServer.disconnected(); <line4> } <line5> } <line6> "	"<line3>    logger.info(""{} => local. onCompleted"", getAgentInfo().getAgentKey());"	task4	
public class A { <line0> public void load() { <line1> String item = localStorage.getItem(documentsKey()); <line2> if (item != null) { <line3> idCounter = Long.parseLong(item); <line4> } <line5> try { <line6> loadInternal(indexKey()); <line7> if (indexRef == null) { <line8> reset(); <line9> } else { <line10> } <line11> } catch (JavaScriptException e) { <line12> reset(); <line13> } <line14> } <line15> } <line16> 	"<line10>        Log.info(""Loaded "" + idCounter + "" documents from index at "" + indexKey());"	task4	
"public class A { <line0> public static com.liferay.journal.model.JournalArticle getLatestArticle( <line1> HttpPrincipal httpPrincipal, long groupId, String className, long classPK) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> JournalArticleServiceUtil.class, <line7> ""getLatestArticle"", <line8> _getLatestArticleParameterTypes47); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, className, classPK); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.journal.model.JournalArticle) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Deprecated <line1> private Path getWorkspace(long studyId, String sessionId) throws CatalogException, IOException { <line2> QueryOptions studyOptions = <line3> new QueryOptions(QueryOptions.INCLUDE, FileDBAdaptor.QueryParams.URI.key()); <line4> OpenCGAResult<Study> studyResult = <line5> catalogManager <line6> .getStudyManager() <line7> .get(String.valueOf((Long) studyId), studyOptions, sessionId); <line8> if (studyResult.getNumResults() != 1) { <line9> throw new CatalogException(""Critical error: Study "" + studyId + "" not found in catalog""); <line10> } <line11> Path workspace = <line12> Paths.get(studyResult.first().getUri().getRawPath()) <line13> .resolve("".opencga"") <line14> .resolve(""alignments""); <line15> if (!workspace.toFile().exists()) { <line16> Files.createDirectories(workspace); <line17> } <line18> return workspace; <line19> } <line20> } <line21> "	"<line9>      logger.error(""Critical error: Study {} not found in catalog."", studyId);"	task4	
public class A { <line0> public void spellCheck(File file) throws IOException { <line1> Files.asCharSource(file, Charsets.UTF_8) <line2> .readLines( <line3> new LineProcessor<Void>() { <line4> @Override <line5> public boolean processLine(String line) throws IOException { <line6> for (String word : Splitter.on(CharMatcher.whitespace()).split(line)) { <line7> word = LETTER.retainFrom(word); <line8> if (!word.isEmpty()) { <line9> spellCheck(word); <line10> } <line11> } <line12> return true; <line13> } <line14>  <line15> @Override <line16> public Void getResult() { <line17> return null; <line18> } <line19> }); <line20> } <line21> } <line22> 	"<line1>    LOG.info(""Spell checking file: {}"", file);"	task4	
public class A { <line0> public ArrayList<FileMatch> getTargetFileMatches( <line1> CommandDirectories commandDirectories, <line2> FileType fileType, <line3> String sourceLocale, <line4> String sourcePathFilterRegex) <line5> throws CommandException { <line6> FileFinder fileFinder = <line7> getFileFinder(commandDirectories, fileType, sourceLocale, sourcePathFilterRegex); <line8> return fileFinder.getTargets(); <line9> } <line10> } <line11> 	"<line6>    logger.debug(""Search for target assets that are already localized"");"	task4	
"public class A { <line0> public Long cascadeDefaultAccountQuotaToSubDomainsAccountQuota( <line1> AbstractDomain domain, Long accountQuota, List<Long> quotaIdList) { <line2> if (quotaIdList == null || quotaIdList.isEmpty()) { <line3> return 0L; <line4> } <line5> HibernateCallback<Long> action = <line6> new HibernateCallback<Long>() { <line7> public Long doInHibernate(final Session session) throws HibernateException { <line8> StringBuilder sb = new StringBuilder(); <line9> sb.append( <line10> ""UPDATE Quota SET account_quota = :accountQuota WHERE id IN :list_quota_id ;""); <line11> final Query<?> query = session.createNativeQuery(sb.toString()); <line12> query.setParameter(""accountQuota"", accountQuota); <line13> query.setParameterList(""list_quota_id"", quotaIdList); <line14> return (long) query.executeUpdate(); <line15> } <line16> }; <line17> long updatedCounter = getHibernateTemplate().execute(action); <line18> return updatedCounter; <line19> } <line20> } <line21> "	"<line18>    logger.debug("" {} account_quota of ContainerQuota have been updated."", updatedCounter);"	task4	
public class A { <line0> @Override <line1> public PartitionContext getNextScaleUpPartitionContext(PartitionContext[] partitionContexts) { <line2> for (PartitionContext partitionContext : partitionContexts) { <line3> if (partitionContext.getNonTerminatedMemberCount() < partitionContext.getMax() <line4> && !partitionContext.isObsoletePartition()) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> return partitionContext; <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> 	"<line6>          log.debug(String.format(""[one-after-another algorithm] [scale-up] [partition] %s has space to create ""+ ""members. [non terminated count] %s [max] %s"",partitionContext.getPartitionId(),partitionContext.getNonTerminatedMemberCount(),partitionContext.getMax()));"	task4	
public class A { <line0> private boolean hasPermission( <line1> Authentication authentication, <line2> Region region, <line3> Permission permission, <line4> boolean trustedDomainObject) { <line5> List<Region> trustedRegionContainer = new ArrayList<Region>(); <line6> if (super.hasPermission(authentication, region, permission)) { <line7> return true; <line8> } <line9> boolean hasPermission = false; <line10> switch (permission) { <line11> case ADMINISTER: <line12> break; <line13> case CREATE: <line14> case DELETE: <line15> case UPDATE: <line16> hasPermission = <line17> isRegionOwner(authentication, region, trustedRegionContainer, trustedDomainObject) <line18> || isRegionMember( <line19> authentication, region, trustedRegionContainer, trustedDomainObject, true); <line20> break; <line21> case READ: <line22> hasPermission = <line23> isRegionOwner(authentication, region, trustedRegionContainer, trustedDomainObject) <line24> || isRegionMember( <line25> authentication, region, trustedRegionContainer, trustedDomainObject, false); <line26> default: <line27> break; <line28> } <line29> return hasPermission; <line30> } <line31> } <line32> 	"<line27>        log.warn(""unknown permission: "" + permission);"	task4	
"public class A { <line0> @Override <line1> public String toString(AbstractWmlConversionContext context, FldSimpleModel model) <line2> throws TransformerException { <line3> DocPropertyResolver dpr = new DocPropertyResolver(context.getWmlPackage()); <line4> String key = model.getFldArgument(); <line5> try { <line6> String value = dpr.getValue(key).toString(); <line7> return FormattingSwitchHelper.applyFormattingSwitch(context.getWmlPackage(), model, value); <line8> } catch (FieldValueException e) { <line9> if (e.getMessage().contains(""No value found for DOCPROPERTY PAGES"")) {} <line10> throw new TransformerException(e); <line11> } catch (Docx4JException e) { <line12> throw new TransformerException(e); <line13> } <line14> } <line15> } <line16> "	"<line7>      log.debug(""= "" + value);"	task4	
public class A { <line0> @Test <line1> public void testInterruptedException() throws Exception { <line2> Blocker blocker0; <line3> try (Blocker blocker = sbcb.acquire()) { <line4> blocker0 = blocker; <line5> Thread.currentThread().interrupt(); <line6> try { <line7> blocker.block(); <line8> fail(); <line9> } catch (InterruptedIOException ignored) { <line10> } <line11> } <line12> blocker0.succeeded(); <line13> try (Blocker blocker = sbcb.acquire()) { <line14> assertThat(blocker, not(sameInstance(blocker0))); <line15> blocker.succeeded(); <line16> } <line17> } <line18> } <line19> 	"<line12>    LOG.info(""Succeeded after ... warning is expected..."");"	task4	
public class A { <line0> public boolean start(NodeImpl protectedParent) throws RepositoryException { <line1> String repMembers = resolver.getJCRName(UserConstants.NT_REP_MEMBERS); <line2> if (repMembers.equals(protectedParent.getPrimaryNodeType().getName())) { <line3> NodeImpl groupNode = protectedParent; <line4> while (groupNode.getDepth() != 0 <line5> && repMembers.equals(groupNode.getPrimaryNodeType().getName())) { <line6> groupNode = (NodeImpl) groupNode.getParent(); <line7> } <line8> Authorizable auth = userManager.getAuthorizable(groupNode); <line9> if (auth == null) { <line10> return false; <line11> } else { <line12> currentMembership = new Membership(auth.getID()); <line13> return true; <line14> } <line15> } else { <line16> return false; <line17> } <line18> } <line19> } <line20> 	"<line10>        log.debug(""Cannot handle protected node ""+ protectedParent+ "". It nor one of its parents represent a valid Authorizable."");"	task4	
public class A { <line0> @Override <line1> protected ResourceResponse newResourceResponse(Attributes attr) { <line2> r = getFileItem(attr); <line3> if (r != null) { <line4> file = getFile(r, attr); <line5> } <line6> if (file != null && file.exists()) { <line7> ResourceResponse rr = createResourceResponse(attr, file.toPath()); <line8> rr.setFileName(getFileName(r)); <line9> return rr; <line10> } else { <line11> ResourceResponse rr = new ResourceResponse(); <line12> rr.setError(HttpServletResponse.SC_NOT_FOUND); <line13> return rr; <line14> } <line15> } <line16> } <line17> 	"<line11>      log.debug(""No file item was found"");"	task4	
"public class A { <line0> @Test <line1> public void testSet() { <line2> Set<String> set = new HashSet<>(); <line3> set.add(""1""); <line4> } <line5> } <line6> "	"<line4>    logger.info(""{}"", JsonCodec.INSTANCE.encode(set));"	task4	
public class A { <line0> private void checkAndCreateSaveDirectory() throws IOException { <line1> if (!Files.exists(SAVE_DIRECTORY_PATH)) { <line2> Files.createDirectories(SAVE_DIRECTORY_PATH); <line3> } <line4> } <line5> } <line6> 	"<line2>      LOGGER.info(""Creating directory {}"", SAVE_DIRECTORY_PATH.toAbsolutePath());"	task4	
public class A { <line0> @Override <line1> protected void shutDown() { <line2> publisher.close(); <line3> listener.close(); <line4> curator.close(); <line5> } <line6> } <line7> 	"<line5>    log.info(""Stopping pipelines-to-avro-from-dwca service"");"	task4	
"public class A { <line0> public synchronized void initServerInfo(Id server, NodeRole role) { <line1> E.checkArgument(server != null && role != null, ""The server id or role can't be null""); <line2> this.selfServerId = server; <line3> this.selfServerRole = role; <line4> HugeServerInfo existed = this.serverInfo(server); <line5> E.checkArgument( <line6> existed == null || !existed.alive(), <line7> ""The server with name '%s' already in cluster"", <line8> server); <line9> if (role.master()) { <line10> String page = this.supportsPaging() ? PageInfo.PAGE_NONE : null; <line11> do { <line12> Iterator<HugeServerInfo> servers = this.serverInfos(PAGE_SIZE, page); <line13> while (servers.hasNext()) { <line14> existed = servers.next(); <line15> E.checkArgument( <line16> !existed.role().master() || !existed.alive(), <line17> ""Already existed master '%s' in current "" + ""cluster"", <line18> existed.id()); <line19> } <line20> if (page != null) { <line21> page = PageInfo.pageInfo(servers); <line22> } <line23> } while (page != null); <line24> } <line25> HugeServerInfo serverInfo = new HugeServerInfo(server, role); <line26> serverInfo.maxLoad(this.calcMaxLoad()); <line27> this.save(serverInfo); <line28> } <line29> } <line30> "	"<line28>    LOG.info(""Init server info: {}"", serverInfo);"	task4	
"public class A { <line0> @Override <line1> public boolean insert(final SpanBo spanBo) { <line2> Objects.requireNonNull(spanBo, ""spanBo""); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> CollectorUtils.checkAgentId(spanBo.getAgentId()); <line6> CollectorUtils.checkApplicationName(spanBo.getApplicationId()); <line7> long acceptedTime = spanBo.getCollectorAcceptTime(); <line8> TransactionId transactionId = spanBo.getTransactionId(); <line9> final byte[] rowKey = this.rowKeyEncoder.encodeRowKey(transactionId); <line10> final Put put = new Put(rowKey, acceptedTime); <line11> this.spanSerializer.serialize(spanBo, put, null); <line12> TableName traceTableName = descriptor.getTableName(); <line13> return hbaseTemplate.asyncPut(traceTableName, put); <line14> } <line15> } <line16> "	"<line4>      logger.debug(""insert trace: {}"", spanBo);"	task4	
public class A { <line0> @Override <line1> public List<Tuple2<Integer, BitSet>> snapshotState(long checkpointId, long timestamp) <line2> throws Exception { <line3> return Collections.singletonList(new Tuple2<>(numElements, duplicateChecker)); <line4> } <line5> } <line6> 	"<line3>    LOG.info(""Snapshot of counter "" + numElements + "" at checkpoint "" + checkpointId);"	task4	
public class A { <line0> public void abandon(final LdapException cause) { <line1> if (sentTime == null) { <line2> } <line3> if (!(request instanceof BindRequest <line4> || request instanceof UnbindRequest <line5> || request instanceof StartTLSRequest <line6> || request instanceof CancelRequest)) { <line7> if (receivedTime == null) { <line8> try { <line9> connection.operation(new AbandonRequest(messageID)); <line10> } finally { <line11> exception(cause); <line12> } <line13> } else { <line14> exception(cause); <line15> } <line16> } else { <line17> exception(cause); <line18> } <line19> } <line20> } <line21> 	"<line2>      logger.warn(""Request has not been sent for {}."", this);"	task4	
public class A { <line0> @Override <line1> public void update(Object args, Observable observable) { <line2> this.currentState.refresh(); <line3> } <line4> } <line5> 	"<line2>    logger.info(""[update]{}"", args);"	task4	
public class A { <line0> @ExceptionHandler(InvalidTokenException.class) <line1> public ResponseEntity<OAuth2Exception> handleException(Exception e) throws Exception { <line2> InvalidTokenException e400 = <line3> new InvalidTokenException(e.getMessage()) { <line4> @Override <line5> public int getHttpErrorCode() { <line6> return 400; <line7> } <line8> }; <line9> return exceptionTranslator.translate(e400); <line10> } <line11> } <line12> 	"<line2>    logger.info(""Handling error: "" + e.getClass().getSimpleName() + "", "" + e.getMessage());"	task4	
"public class A { <line0> @Test <line1> public void runBothDates() throws IOException { <line2> File createTempDir = Files.createTempDir(); <line3> String randomString = UUID.randomUUID().toString(); <line4> File testOutFile = new File(createTempDir, randomString + "".txt""); <line5> String listCommand = <line6> ""-p net.sourceforge.seqware.pipeline.plugins.WorkflowRunReporter "" <line7> + ""-- --output-filename "" <line8> + testOutFile.getName() <line9> + "" --workflow-accession 2861 --time-period 2012-01-01:2012-01-15 ""; <line10> String listOutput = ITUtility.runSeqWareJar(listCommand, ReturnValue.SUCCESS, createTempDir); <line11> File retrievedFile = new File(createTempDir, testOutFile.getName()); <line12> Assert.assertTrue(""output file does not exist"", retrievedFile.exists()); <line13> List<String> readLines = FileUtils.readLines(testOutFile, StandardCharsets.UTF_8); <line14> Assert.assertTrue(""incorrect number of lines "", readLines.size() == 4); <line15> long checksumCRC32 = FileUtils.checksumCRC32(testOutFile); <line16> Assert.assertTrue( <line17> ""incorrect output checksum "" <line18> + checksumCRC32 <line19> + "" "" <line20> + FileUtils.readFileToString(retrievedFile, StandardCharsets.UTF_8), <line21> checksumCRC32 == 562223107L || checksumCRC32 == 4072825873L); <line22> } <line23> } <line24> "	<line11>    Log.info(listOutput);	task4	
public class A { <line0> @Override <line1> public void setup(PortContext context) { <line2> if (Boolean.getBoolean(THREAD_AFFINITY_DISABLE_CHECK) == false) { <line3> operatorThread = Thread.currentThread(); <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.debug(""Enforcing emit on {}"", operatorThread.getName());"	task4	
public class A { <line0> @Override <line1> public void stop() { <line2> _registry.unregisterRESTEasyResources(_alias, _classes); <line3> OsgiRESTEasyServletWrapper servlet = _registry.getRegisteredRESTEasyServlet(_alias); <line4> if (servlet != null && servlet.getDispatcher().getRegistry().getSize() == 0) { <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> _registry.unregisterRESTEasyServlet(_alias); <line8> } <line9> } <line10> } <line11> 	"<line6>        LOGGER.debug(""Unregistering RESTEasy servlet with an alias '"" + _alias + ""'"");"	task4	
"public class A { <line0> protected boolean exists(String bucketKey) { <line1> try { <line2> logTrace(""-->"", ""getObjectMetadata""); <line3> logTrace(""hnote right: "" + bucketKey); <line4> ObjectMetadata metadata = amazonS3.getObjectMetadata(bucketName, bucketKey); <line5> if (log.isDebugEnabled()) { <line6> } <line7> logTrace(""<--"", ""exists ("" + metadata.getContentLength() + "" bytes)""); <line8> return true; <line9> } catch (AmazonServiceException e) { <line10> if (isMissingKey(e)) { <line11> logTrace(""<--"", ""missing""); <line12> return false; <line13> } <line14> throw e; <line15> } <line16> } <line17> } <line18> "	"<line6>        log.debug(""Blob s3://"" + bucketName + ""/"" + bucketKey + "" already exists"");"	task4	
public class A { <line0> protected void processContributions(BiConsumer<String, LiferayDocumentTypeFactory> biConsumer) { <line1> if (Validator.isNotNull(_elasticsearchConfigurationWrapper.overrideTypeMappings())) { <line2> return; <line3> } <line4> RestHighLevelClient restHighLevelClient = null; <line5> try { <line6> restHighLevelClient = _elasticsearchConnectionManager.getRestHighLevelClient(); <line7> } catch ( <line8> ElasticsearchConnectionNotInitializedException <line9> elasticsearchConnectionNotInitializedException) { <line10> if (log.isInfoEnabled()) { <line11> } <line12> return; <line13> } <line14> LiferayDocumentTypeFactory liferayDocumentTypeFactory = <line15> new LiferayDocumentTypeFactory(restHighLevelClient.indices(), _jsonFactory); <line16> for (Long companyId : _companyIds) { <line17> biConsumer.accept(getIndexName(companyId), liferayDocumentTypeFactory); <line18> } <line19> } <line20> } <line21> 	"<line11>        log.info(""Skipping index settings contributor"");"	task4	
public class A { <line0> @Override <line1> public void createDirectory(AlluxioURI path, CreateDirectoryPOptions options) <line2> throws FileAlreadyExistsException, InvalidPathException, IOException, AlluxioException { <line3> checkUri(path); <line4> rpc( <line5> client -> { <line6> CreateDirectoryPOptions mergedOptions = <line7> FileSystemOptions.createDirectoryDefaults(mFsContext.getPathConf(path)).toBuilder() <line8> .mergeFrom(options) <line9> .build(); <line10> client.createDirectory(path, mergedOptions); <line11> return null; <line12> }); <line13> } <line14> } <line15> 	"<line11>          LOG.debug(""Created directory {}, options: {}"", path.getPath(), mergedOptions);"	task4	
public class A { <line0> @Test <line1> public void testGenerateJson() { <line2> BandInfoParameters object = new BandInfoParameters(); <line3> List<BandInfoParameters> objects = new ArrayList<BandInfoParameters>(); <line4> objects.add(object); <line5> } <line6> } <line7> 	<line5>    LOGGER.info(new JsonUtils().convertBandInfos(objects));	task4	
"public class A { <line0> @Override <line1> public int getInfoListCount(InfoListProviderContext infoListProviderContext) { <line2> AssetEntryQuery assetEntryQuery = <line3> getAssetEntryQuery(infoListProviderContext, ""ratings"", ""DESC"", null); <line4> try { <line5> return _assetEntryService.getEntriesCount(assetEntryQuery); <line6> } catch (Exception exception) { <line7> } <line8> return 0; <line9> } <line10> } <line11> "	"<line7>      log.error(""Unable to get asset entries count"", exception);"	task4	
public class A { <line0> public SupportedVersion getSupportedVersion(File projectFolder) { <line1> SupportedVersion version = null; <line2> File file = new File(projectFolder, OPENL_PROJECT_PROPERTIES_FILE); <line3> if (projectFolder.isDirectory() && file.isFile()) { <line4> Properties properties = new Properties(); <line5> InputStream is = null; <line6> try { <line7> is = new FileInputStream(file); <line8> properties.load(is); <line9> String compatibility = properties.getProperty(OPENL_COMPATIBILITY_VERSION); <line10> if (compatibility != null) { <line11> version = SupportedVersion.getByVersion(compatibility); <line12> } <line13> } catch (Exception e) { <line14> if (log.isErrorEnabled()) { <line15> } <line16> } finally { <line17> IOUtils.closeQuietly(is); <line18> } <line19> } <line20> return version == null ? defaultVersion : version; <line21> } <line22> } <line23> 	<line15>          log.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public boolean terminateEarly() { <line2> boolean terminationEarlySuccessful = basicPlumbingTermination.terminateEarly(); <line3> if (terminationEarlySuccessful) { <line4> } <line5> return terminationEarlySuccessful; <line6> } <line7> } <line8> 	"<line4>      logger.info(""Terminating solver early."");"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> PhaseWorkerCall call = new PhaseWorkerCall(); <line4> do { <line5> if (PENDING_PHASE_QUEUE.isEmpty()) { <line6> synchronized (PENDING_PHASE_QUEUE) { <line7> PENDING_PHASE_QUEUE.wait(15000L); <line8> } <line9> } else if (ViewLifecycle.isTrace()) { <line10> ProcessLogger.follow(""view-lifecycle"", ""KRAD lifecycle worker"", call); <line11> } else { <line12> call.call(); <line13> } <line14> } while (LIFECYCLE_EXECUTOR.getActiveCount() <= getMinThreads()); <line15> } catch (Throwable t) { <line16> } <line17> } <line18> } <line19> "	"<line16>      LOG.fatal(""Fatal error in View Lifecycle worker"", t);"	task4	
public class A { <line0> public void nextComma() throws IOException { <line1> int tt; <line2> if (tok.ttype == ',') { <line3> tt = tok.nextToken(); <line4> if (debug) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.debug(""after comma: "" + tt);"	task4	
"public class A { <line0> private Map<String, Value> prepareAndRunPythonAction( <line1> Collection<String> dependencies, <line2> String pythonScript, <line3> Map<String, Value> callArguments, <line4> boolean useJython) { <line5> if (StringUtils.isNotBlank(pythonScript)) { <line6> final Map<String, Value> returnedMap = <line7> scriptExecutor.executeScript( <line8> normalizePythonDependencies(dependencies), pythonScript, callArguments, useJython); <line9> final Value ex = returnedMap.get(EXCEPTION); <line10> if (ex != null) { <line11> } <line12> return returnedMap; <line13> } <line14> throw new RuntimeException(""Python script not found in action data""); <line15> } <line16> } <line17> "	"<line11>        logger.error(""Python operation encountered an exception: "" + ex.toString());"	task4	
public class A { <line0> @Override <line1> public ListIterator<Object> listIterator() { <line2> Collections.shuffle(cachedEntityList, workingRandom); <line3> return cachedEntityList.listIterator(); <line4> } <line5> } <line6> 	"<line3>    logger.trace(""    Shuffled cachedEntityList with size ({}) in entitySelector({})."",cachedEntityList.size(),this);"	task4	
"public class A { <line0> @Override <line1> public ERCGroupEntry findByG_ERC(long groupId, String externalReferenceCode) <line2> throws NoSuchERCGroupEntryException { <line3> ERCGroupEntry ercGroupEntry = fetchByG_ERC(groupId, externalReferenceCode); <line4> if (ercGroupEntry == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""groupId=""); <line8> sb.append(groupId); <line9> sb.append("", externalReferenceCode=""); <line10> sb.append(externalReferenceCode); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchERCGroupEntryException(sb.toString()); <line15> } <line16> return ercGroupEntry; <line17> } <line18> } <line19> "	<line13>        log.debug(sb.toString());	task4	
"public class A { <line0> @POST <line1> @JacksonSerialized <line2> @Produces(MediaType.APPLICATION_JSON) <line3> public Response addWorkerContainer(ConnectWorkerContainer connectWorkerContainer) { <line4> this.workerAdministrationManagement.register(connectWorkerContainer); <line5> return ok(Notifications.success(""Worker Container sucessfully added"")); <line6> } <line7> } <line8> "	"<line4>    LOG.info(""Worker container: "" + connectWorkerContainer.getEndpointUrl() + "" was detected"");"	task4	
"public class A { <line0> public EnqueueBean enqueueController( <line1> String user, Map<String, Object> userArgs, String callback, List<String> args) <line2> throws NotAuthorizedException, BusyException, ExecuteException, IOException, QueueException { <line3> try { <line4> UserGroupInformation ugi = UgiFactory.getUgi(user); <line5> final long startTime = System.nanoTime(); <line6> String id = queueAsUser(ugi, args); <line7> long elapsed = ((System.nanoTime() - startTime) / ((int) 1e6)); <line8> if (id == null) throw new QueueException(""Unable to get job id""); <line9> registerJob(id, user, callback, userArgs); <line10> return new EnqueueBean(id); <line11> } catch (InterruptedException e) { <line12> throw new QueueException(""Unable to launch job "" + e); <line13> } <line14> } <line15> } <line16> "	"<line8>      LOG.debug(""queued job "" + id + "" in "" + elapsed + "" ms"");"	task4	
"public class A { <line0> @PUT <line1> public Response put(@PathParam(""path"") final String externalPath) throws Exception { <line2> final FedoraId id = identifierConverter().pathToInternalId(externalPath); <line3> return doRequest(id); <line4> } <line5> } <line6> "	"<line3>    LOGGER.trace(""PUT: {}"", id.getFullIdPath());"	task4	
"public class A { <line0> @SuppressWarnings({""cast"", ""unchecked""}) <line1> public List<Rectangle<C>> complexRoots(GenPolynomial<Complex<C>> a) { <line2> List<Rectangle<C>> roots = new ArrayList<Rectangle<C>>(); <line3> if (a.isConstant() || a.isZERO()) { <line4> return roots; <line5> } <line6> ComplexRing<C> cr = (ComplexRing<C>) a.ring.coFac; <line7> GenPolynomial<Complex<C>> sp = engine.squarefreePart(a); <line8> SortedMap<GenPolynomial<Complex<C>>, Long> sa = new TreeMap<GenPolynomial<Complex<C>>, Long>(); <line9> sa.put(sp, 1L); <line10> for (Map.Entry<GenPolynomial<Complex<C>>, Long> me : sa.entrySet()) { <line11> GenPolynomial<Complex<C>> p = me.getKey(); <line12> Complex<C> Mb = rootBound(p); <line13> C M = Mb.getRe(); <line14> C M1 = M.sum(M.factory().fromInteger(1)); <line15> if (debug) { <line16> } <line17> Complex<C>[] corner = (Complex<C>[]) new Complex[4]; <line18> corner[0] = new Complex<C>(cr, M1.negate(), M); <line19> corner[1] = new Complex<C>(cr, M1.negate(), M1.negate()); <line20> corner[2] = new Complex<C>(cr, M, M1.negate()); <line21> corner[3] = new Complex<C>(cr, M, M); <line22> Rectangle<C> rect = new Rectangle<C>(corner); <line23> try { <line24> List<Rectangle<C>> rs = complexRoots(rect, p); <line25> long e = me.getValue(); <line26> for (int i = 0; i < e; i++) { <line27> roots.addAll(rs); <line28> } <line29> } catch (InvalidBoundaryException e) { <line30> throw new RuntimeException(""this should never happen "" + e); <line31> } <line32> } <line33> return roots; <line34> } <line35> } <line36> "	"<line16>        logger.info(""rootBound = "" + M);"	task4	
public class A { <line0> @Override <line1> public void save(Device profile) { <line2> deviceService.save(profile); <line3> Audit.logSave(profile); <line4> } <line5> } <line6> 	"<line2>    LOGGER.info(""Save: "" + profile);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> task.run(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.error(""Failed to execute shutdown hook"", e);"	task4	
public class A { <line0> public void setConfigFile(String file) { <line1> configFile = file; <line2> } <line3> } <line4> 	"<line1>    log.info(""config service override of configFile="" + file);"	task4	
public class A { <line0> void errorOut(final CompletionKey key, final int rc) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> CompletionValue completion = completionObjects.remove(key); <line4> if (completion != null) { <line5> completion.errorOut(rc); <line6> } else { <line7> completionObjectsV2Conflicts.removeAny(key).ifPresent(c -> c.errorOut(rc)); <line8> } <line9> } <line10> } <line11> 	"<line2>      LOG.debug(""Removing completion key: {}"", key);"	task4	
public class A { <line0> public String getNotificationEvents( <line1> long companyId, long userId, JSONObject pollerResponseHeaderJSONObject, long timeout) <line2> throws ChannelException { <line3> try { <line4> _countDownLatch.await(timeout, TimeUnit.MILLISECONDS); <line5> } catch (InterruptedException interruptedException) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> List<NotificationEvent> notificationEvents = <line10> ChannelHubManagerUtil.fetchNotificationEvents(companyId, userId, true); <line11> JSONArray jsonArray = JSONUtil.put(pollerResponseHeaderJSONObject); <line12> for (NotificationEvent notificationEvent : notificationEvents) { <line13> jsonArray.put(notificationEvent.toJSONObject()); <line14> } <line15> return jsonArray.toString(); <line16> } <line17> } <line18> 	<line7>        log.debug(interruptedException, interruptedException);	task4	
"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> @Nullable OpenThermGatewayConnector conn = connector; <line3> if (!(command instanceof RefreshType)) { <line4> String channel = channelUID.getId(); <line5> String code = getGatewayCodeFromChannel(channel); <line6> GatewayCommand gatewayCommand = null; <line7> if (command instanceof OnOffType) { <line8> OnOffType onOff = (OnOffType) command; <line9> gatewayCommand = GatewayCommand.parse(code, onOff == OnOffType.ON ? ""1"" : ""0""); <line10> } <line11> if (command instanceof QuantityType<?>) { <line12> QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS); <line13> if (quantityType != null) { <line14> double value = quantityType.doubleValue(); <line15> gatewayCommand = GatewayCommand.parse(code, Double.toString(value)); <line16> } <line17> } <line18> if (gatewayCommand == null) { <line19> gatewayCommand = GatewayCommand.parse(code, command.toFullString()); <line20> } <line21> if (conn != null && conn.isConnected()) { <line22> conn.sendCommand(gatewayCommand); <line23> if (code == GatewayCommandCode.ControlSetpoint) { <line24> if (gatewayCommand.getMessage().equals(""0.0"")) { <line25> updateState( <line26> OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_CENTRAL_HEATING_WATER_SETPOINT, <line27> UnDefType.UNDEF); <line28> } <line29> updateState( <line30> OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_CENTRAL_HEATING_ENABLED, <line31> OnOffType.from(!gatewayCommand.getMessage().equals(""0.0""))); <line32> } else if (code == GatewayCommandCode.ControlSetpoint2) { <line33> if (gatewayCommand.getMessage().equals(""0.0"")) { <line34> updateState( <line35> OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_CENTRAL_HEATING2_WATER_SETPOINT, <line36> UnDefType.UNDEF); <line37> } <line38> updateState( <line39> OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_CENTRAL_HEATING2_ENABLED, <line40> OnOffType.from(!gatewayCommand.getMessage().equals(""0.0""))); <line41> } <line42> } else { <line43> connect(); <line44> } <line45> } <line46> } <line47> } <line48> "	"<line3>    logger.debug(""Received channel: {}, command: {}"", channelUID, command);"	task4	
public class A { <line0> private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) { <line1> if (!log.isTraceEnabled()) { <line2> return; <line3> } <line4> } <line5> } <line6> 	"<line4>    log.trace(""{} {} {} {}"", isEnter ? "">>>>"" : ""<<<<"", description, method, transaction);"	task4	
"public class A { <line0> public void setPublicCert() { <line1> try { <line2> KeyStoreManager keyStoreManager = <line3> KeyStoreManager.getInstance(MultitenantConstants.SUPER_TENANT_ID); <line4> this.publicCert = keyStoreManager.getDefaultPrimaryCertificate(); <line5> } catch (Exception e) { <line6> String error = ""Error in obtaining keystore""; <line7> } <line8> } <line9> } <line10> "	<line7>      log.debug(error, e);	task4	
"public class A { <line0> @Test <line1> public void TestCreateVfModuleFailure_5000() { <line2> new MockAAIGenericVnfSearch(wireMockServer); <line3> MockAAICreateGenericVnf(wireMockServer); <line4> MockAAIVfModulePUT(wireMockServer, true); <line5> Map<String, Object> variables = new HashMap<>(); <line6> variables.put(""isDebugLogEnabled"", ""true""); <line7> variables.put(""isVidRequest"", ""false""); <line8> variables.put(""vnfId"", ""a27ce5a9-29c4-4c22-a017-6615ac73c721""); <line9> variables.put(""serviceId"", ""99999999-9999-9999-9999-999999999999""); <line10> variables.put(""personaModelId"", ""973ed047-d251-4fb9-bf1a-65b8949e0a73""); <line11> variables.put(""personaModelVersion"", ""1.0""); <line12> variables.put(""vfModuleName"", ""STMTN5MMSC21-PCRF::module-1-0""); <line13> variables.put(""vfModuleModelName"", ""STMTN5MMSC21-PCRF::model-1-0""); <line14> variables.put(""mso-request-id"", UUID.randomUUID().toString()); <line15> String processId = invokeSubProcess(""CreateAAIVfModule"", variables); <line16> WorkflowException exception = <line17> BPMNUtil.getRawVariable(processEngine, ""CreateAAIVfModule"", ""WorkflowException"", processId); <line18> Assert.assertEquals(5000, exception.getErrorCode()); <line19> Assert.assertEquals( <line20> true, exception.getErrorMessage().contains(""<messageId>SVC3002</messageId>"")); <line21> } <line22> } <line23> "	<line21>    logger.debug(exception.getErrorMessage());	task4	
"public class A { <line0> @Test <line1> public void testQuery003() throws Exception { <line2> Set<String> expected = new HashSet<>(); <line3> String query = <line4> CarField.COLOR.name() + "" =~ 'bl.*s.*' and "" + CarField.WHEELS.name() + "" == '4'""; <line5> runTest(query, expected); <line6> } <line7> } <line8> "	"<line2>    log.info(""------ Test a*.* AND b ------"");"	task4	
public class A { <line0> @Override <line1> public boolean isPageComplete() { <line2> boolean complete = super.isPageComplete(); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> return complete; <line6> } <line7> } <line8> 	"<line4>      logger.debug(""page complete: "" + complete);"	task4	
public class A { <line0> @Override <line1> public void prepareStaticStatements( <line2> InternalCassandraVersion cassandraVersion, Session session, StatementsCache cache) { <line3> if (LOGGER.isDebugEnabled()) { <line4> } <line5> generateStaticSelectQuery(session, cache, this); <line6> } <line7> } <line8> 	"<line4>      LOGGER.debug(format(""Preparing static statements for entity of type %s"", entityClass.getCanonicalName()));"	task4	
public class A { <line0> @Benchmark <line1> @BenchmarkMode(SingleShotTime) <line2> public int nestedForeach() { <line3> AtomicInteger counter = new AtomicInteger(); <line4> try { <line5> Foreach internalForeach = createForeach(); <line6> Processor nestedEventProcessor = <line7> event -> { <line8> counter.incrementAndGet(); <line9> return event; <line10> }; <line11> internalForeach.setMessageProcessors(singletonList(nestedEventProcessor)); <line12> Foreach nestedForeach = createForeach(); <line13> nestedForeach.setMessageProcessors(singletonList(internalForeach)); <line14> initialiseIfNeeded(nestedForeach, muleContext); <line15> nestedForeach.process(nestedForeachEvent); <line16> } catch (Throwable t) { <line17> } <line18> return counter.get(); <line19> } <line20> } <line21> 	"<line17>      LOGGER.error(""Unexpected error on nestedForeach"", t);"	task4	
"public class A { <line0> public <T> T getFromApplicationContext( <line1> String referenceName, String className, Class<T> expectedClass) { <line2> T resolvedReference = null; <line3> if (!StringUtils.isBlank(referenceName)) { <line4> resolvedReference = adapterGetter.getByName(referenceName, expectedClass); <line5> } <line6> if (resolvedReference == null && !StringUtils.isBlank(className)) { <line7> try { <line8> resolvedReference = <line9> adapterGetter.getByClassDefinition(Class.forName(className), expectedClass); <line10> } catch (ClassNotFoundException cnfe) { <line11> throw new ConfigurationException( <line12> ""Unable to find specified default adapter class: "" + className, cnfe); <line13> } <line14> } <line15> return resolvedReference; <line16> } <line17> } <line18> "	"<line11>        LOG.error(""Unable to find specified default adapter class: "" + className, cnfe);"	task4	
"public class A { <line0> @Test( <line1> groups = {""network""}, <line2> description = ""4-Network-1 pattern lowercase"", <line3> priority = 6) <line4> public void verifyTest4_1_pattern_lower() throws Exception { <line5> Context context = initValidatorContext(); <line6> Assert.assertNotNull(fullparameters, ""no parameters for test""); <line7> context.put(VALIDATION_REPORT, new ValidationReport()); <line8> bean1.setRegistrationNumber(""azerty""); <line9> bean2.setRegistrationNumber(""az234ZDER""); <line10> fullparameters <line11> .getNetwork() <line12> .getRegistrationNumber() <line13> .setPattern(AbstractValidation.PATTERN_OPTION.lower.ordinal()); <line14> context.put(VALIDATION, fullparameters); <line15> ValidationData data = new ValidationData(); <line16> data.getNetworks().addAll(beansFor4); <line17> context.put(VALIDATION_DATA, data); <line18> checkPoint.validate(context, null); <line19> ValidationReport report = (ValidationReport) context.get(VALIDATION_REPORT); <line20> checkReportForTest(report, ""4-Network-1"", 1); <line21> } <line22> } <line23> "	"<line5>    log.info(Color.BLUE + ""4-Network-1 pattern lowercase"" + Color.NORMAL);"	task4	
public class A { <line0> private void flush() throws HCatException { <line1> if (hCatRecordsBatch.isEmpty()) { <line2> return; <line3> } <line4> try { <line5> slaveWriter.write(hCatRecordsBatch.iterator()); <line6> masterWriter.commit(writerContext); <line7> } catch (HCatException e) { <line8> masterWriter.abort(writerContext); <line9> throw e; <line10> } finally { <line11> hCatRecordsBatch.clear(); <line12> } <line13> } <line14> } <line15> 	"<line8>      LOG.error(""Exception in flush - write/commit data to Hive"", e);"	task4	
public class A { <line0> private <OutType> Yielder<OutType> makeYielder( <line1> OutType initValue, final YieldingAccumulator<OutType, T> accumulator, final IterType iter) { <line2> OutType retVal = initValue; <line3> while (!accumulator.yielded() && iter.hasNext()) { <line4> retVal = accumulator.accumulate(retVal, iter.next()); <line5> } <line6> if (!accumulator.yielded()) { <line7> return Yielders.done( <line8> retVal, <line9> new Closeable() { <line10> @Override <line11> public void close() throws IOException { <line12> maker.cleanup(iter); <line13> } <line14> }); <line15> } <line16> final OutType finalRetVal = retVal; <line17> return new Yielder<OutType>() { <line18> @Override <line19> public OutType get() { <line20> return finalRetVal; <line21> } <line22>  <line23> @Override <line24> public Yielder<OutType> next(OutType initValue) { <line25> accumulator.reset(); <line26> try { <line27> return makeYielder(initValue, accumulator, iter); <line28> } catch (Exception e) { <line29> try { <line30> maker.cleanup(iter); <line31> } catch (RuntimeException e1) { <line32> } <line33> throw Throwables.propagate(e); <line34> } <line35> } <line36>  <line37> @Override <line38> public boolean isDone() { <line39> return false; <line40> } <line41>  <line42> @Override <line43> public void close() throws IOException { <line44> maker.cleanup(iter); <line45> } <line46> }; <line47> } <line48> } <line49> 	"<line32>            log.error(e1, ""Exception thrown when closing maker.  Logging and ignoring."");"	task4	
public class A { <line0> public void migrate() { <line1> propertiesEncryption.encryptAndSave( <line2> input, <line3> propertyNames, <line4> s -> { <line5> try { <line6> return migration.migrate(s); <line7> } catch (Exception e) { <line8> return s; <line9> } <line10> }); <line11> } <line12> } <line13> 	"<line8>            LOGGER.error(""Unable to migrate input '{}' (keep previous value)."", s);"	task4	
"public class A { <line0> public void newMappedRWFile() { <line1> try { <line2> if (rwFileChannel != null) rwFileChannel.close(); <line3> rwFileChannel = null; <line4> if (rwRaf != null) rwRaf.close(); <line5> rwRaf = null; <line6> rwFile = null; <line7> File parent = new File(baseDir); <line8> if (!parent.exists()) { <line9> parent.mkdirs(); <line10> } <line11> rwFile = FileUtils.getFile(baseDir, SystemClock.now() + """"); <line12> rwRaf = new RandomAccessFile(rwFile, ""rw""); <line13> rwFileChannel = rwRaf.getChannel(); <line14> rwMap = rwFileChannel.map(FileChannel.MapMode.READ_WRITE, 0, pageSize); <line15> } catch (Exception ex) { <line16> } <line17> } <line18> } <line19> "	"<line16>      logger.error(""create and mapped file error."", ex);"	task4	
"public class A { <line0> @Test <line1> public void wildcardResourcesAreOrderedAlphabetically() { <line2> final WroModel model = new WroModel(); <line3> final String uri = <line4> String.format( <line5> ClasspathUriLocator.PREFIX + ""%s/expander/order/**.js"", <line6> WroUtil.toPackageAsFolder(getClass())); <line7> model.addGroup(new Group(""group"").addResource(Resource.create(uri, ResourceType.JS))); <line8> Mockito.when(decoratedFactory.create()).thenReturn(model); <line9> final WroModel changedModel = transformer.transform(model); <line10> Assert.assertEquals(7, changedModel.getGroupByName(""group"").getResources().size()); <line11> final List<Resource> resources = changedModel.getGroupByName(""group"").getResources(); <line12> Assert.assertEquals(""01-xyc.js"", FilenameUtils.getName(resources.get(0).getUri())); <line13> Assert.assertEquals(""02-xyc.js"", FilenameUtils.getName(resources.get(1).getUri())); <line14> Assert.assertEquals(""03-jquery-ui.js"", FilenameUtils.getName(resources.get(2).getUri())); <line15> Assert.assertEquals(""04-xyc.js"", FilenameUtils.getName(resources.get(3).getUri())); <line16> Assert.assertEquals(""05-xyc.js"", FilenameUtils.getName(resources.get(4).getUri())); <line17> Assert.assertEquals(""06-xyc.js"", FilenameUtils.getName(resources.get(5).getUri())); <line18> Assert.assertEquals(""07-jquery-impromptu.js"", FilenameUtils.getName(resources.get(6).getUri())); <line19> } <line20> } <line21> "	"<line10>    LOG.debug(""model: {}"", changedModel);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> ExponentialBackoffRetry retry = new ExponentialBackoffRetry(1000, 30000, Integer.MAX_VALUE); <line3> long start = System.currentTimeMillis(); <line4> final OptionalLong finalSN = UfsJournalReader.getLastSN(mJournal); <line5> Thread t = <line6> new Thread( <line7> () -> { <line8> UfsJournalProgressLogger progressLogger = <line9> new UfsJournalProgressLogger(mJournal, finalSN, () -> mLastAppliedSN); <line10> while (!Thread.currentThread().isInterrupted() && retry.attempt()) { <line11> progressLogger.logProgress(); <line12> } <line13> }); <line14> try { <line15> t.start(); <line16> runInternal(); <line17> } catch (Throwable e) { <line18> t.interrupt(); <line19> ProcessUtils.fatalError( <line20> LOG, e, ""%s: Failed to run journal checkpoint thread, crashing."", mMaster.getName()); <line21> System.exit(-1); <line22> } finally { <line23> t.interrupt(); <line24> try { <line25> t.join(); <line26> } catch (InterruptedException e) { <line27> Thread.currentThread().interrupt(); <line28> } <line29> } <line30> } <line31> } <line32> "	"<line28>        LOG.warn(""interrupted while waiting for journal stats thread to shut down."");"	task4	
"public class A { <line0> @Override <line1> public void contextDestroyed(ServletContextEvent servletContextEvent) { <line2> WebApplicationContext ac = <line3> WebApplicationContextUtils.getRequiredWebApplicationContext( <line4> servletContextEvent.getServletContext()); <line5> ConfigurableApplicationContext gwac = (ConfigurableApplicationContext) ac; <line6> gwac.close(); <line7> LOGGER.log(Level.FINE, ""Web application destroyed""); <line8> } <line9> } <line10> "	"<line2>    LOGGER.info(""Destroying Web application"");"	task4	
"public class A { <line0> public static MultipartBody buildIdsMultipartMessage(final Message header, final Object payload) <line1> throws MessageBuilderException { <line2> try { <line3> return InfomodelMessageBuilder.messageWithString(header, String.valueOf(payload)); <line4> } catch (IOException e) { <line5> if (log.isWarnEnabled()) { <line6> } <line7> throw new MessageBuilderException(""Message could not be built."", e); <line8> } <line9> } <line10> } <line11> "	"<line6>        log.warn(""Message could not be built. [exception=({})]"", e.getMessage(), e);"	task4	
public class A { <line0> @Override <line1> protected void afterExecute(Runnable r, Throwable t) { <line2> Utils.clearContexts(); <line3> if (t != null) { <line4> } <line5> super.afterExecute(r, t); <line6> } <line7> } <line8> 	"<line4>      LOG.error(""Exception when executing "" + r, t);"	task4	
public class A { <line0> private void setPropertiesByEnv(final Properties prop) { <line1> for (EnvironmentArgument each : EnvironmentArgument.values()) { <line2> String key = each.getKey(); <line3> String value = System.getenv(key); <line4> if (!Strings.isNullOrEmpty(value)) { <line5> prop.setProperty(each.getKey(), value); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line5>        log.info(""Load property {} with value {} from ENV."", key, value);"	task4	
public class A { <line0> @Override <line1> public void exitLegacy_change_substitution(Legacy_change_substitutionContext ctx) { <line2> LegacyLocation location = (LegacyLocation) getValue(ctx.legacy_point_location()); <line3> String from = ctx.NT_STRING(0).getText(); <line4> String to = ctx.NT_STRING(1).getText(); <line5> setValue(ctx, new LegacySubstitution(location, from, to)); <line6> } <line7> } <line8> 	"<line2>    LOGGER.debug(""Leaving legacy_change_substitution"");"	task4	
public class A { <line0> public void setUseWorkflowPessimisticLocking(boolean useWorkflowPessimisticLocking) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> this.useWorkflowPessimisticLocking = useWorkflowPessimisticLocking; <line4> } <line5> } <line6> 	"<line2>      LOG.debug(""calling setuseWorkflowPessimisticLocking '"" + useWorkflowPessimisticLocking + ""'"");"	task4	
"public class A { <line0> protected Admin adminClient(List<Integer> bootstrapPods, boolean ceShouldBeFatal) <line1> throws ForceableProblem, FatalProblem { <line2> List<String> podNames = <line3> bootstrapPods.stream().map(podId -> podName(podId)).collect(Collectors.toList()); <line4> try { <line5> String bootstrapHostnames = <line6> podNames.stream() <line7> .map( <line8> podName -> <line9> KafkaCluster.podDnsName(this.namespace, this.cluster, podName) <line10> + "":"" <line11> + KafkaCluster.REPLICATION_PORT) <line12> .collect(Collectors.joining("","")); <line13> return adminClientProvider.createAdminClient( <line14> bootstrapHostnames, this.clusterCaCertSecret, this.coKeySecret, ""cluster-operator""); <line15> } catch (KafkaException e) { <line16> if (ceShouldBeFatal <line17> && (e instanceof ConfigException || e.getCause() instanceof ConfigException)) { <line18> throw new FatalProblem( <line19> ""An error while try to create an admin client with bootstrap brokers "" + podNames, e); <line20> } else { <line21> throw new ForceableProblem( <line22> ""An error while try to create an admin client with bootstrap brokers "" + podNames, e); <line23> } <line24> } catch (RuntimeException e) { <line25> throw new ForceableProblem( <line26> ""An error while try to create an admin client with bootstrap brokers "" + podNames, e); <line27> } <line28> } <line29> } <line30> "	"<line13>      log.debug(""{}: Creating AdminClient for {}"", reconciliation, bootstrapHostnames);"	task4	
public class A { <line0> private void addConfigDescription(@Nullable ConfigDescription configDescription) { <line1> if (configDescription != null) { <line2> try { <line3> configDescriptionProvider.add(bundle, configDescription); <line4> } catch (RuntimeException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.error(""Could not register ConfigDescription: {}"", configDescription.getUID(), e);"	task4	
"public class A { <line0> public void replay(RemoveTopicRecord record) { <line1> TopicControlInfo topic = topics.remove(record.topicId()); <line2> if (topic == null) { <line3> throw new UnknownTopicIdException( <line4> ""Can't find topic with ID "" + record.topicId() + "" to remove.""); <line5> } <line6> topicsByName.remove(topic.name); <line7> configurationControl.deleteTopicConfigs(topic.name); <line8> for (PartitionControlInfo partition : topic.parts.values()) { <line9> for (int i = 0; i < partition.isr.length; i++) { <line10> brokersToIsrs.removeTopicEntryForBroker(topic.id, partition.isr[i]); <line11> } <line12> if (partition.leader != partition.preferredReplica()) { <line13> preferredReplicaImbalanceCount.decrement(); <line14> } <line15> globalPartitionCount.decrement(); <line16> } <line17> brokersToIsrs.removeTopicEntryForBroker(topic.id, NO_LEADER); <line18> controllerMetrics.setGlobalTopicsCount(topics.size()); <line19> controllerMetrics.setGlobalPartitionCount(globalPartitionCount.get()); <line20> controllerMetrics.setOfflinePartitionCount(brokersToIsrs.offlinePartitionCount()); <line21> controllerMetrics.setPreferredReplicaImbalanceCount(preferredReplicaImbalanceCount.get()); <line22> } <line23> } <line24> "	"<line22>    log.info(""Removed topic {} with ID {}."", topic.name, record.topicId());"	task4	
"public class A { <line0> private void attachShutDownHook() { <line1> Runtime.getRuntime() <line2> .addShutdownHook( <line3> new Thread(""benchmark-cleaner"") { <line4> @Override <line5> public void run() { <line6> if (!isCleaningDone) { <line7> close(); <line8> } <line9> } <line10> }); <line11> } <line12> } <line13> "	"<line11>    LOG.info(""Shutdown Hook Attached"");"	task4	
public class A { <line0> @Override <line1> public void onFailedConnection(Address address) { <line2> } <line3> } <line4> 	"<line2>    logger.info(""Failed connection: "" + address);"	task4	
public class A { <line0> @Override <line1> public void release() { <line2> try { <line3> if (hook != null) { <line4> Runtime.getRuntime().removeShutdownHook(hook); <line5> hook = null; <line6> } <line7> } catch (IllegalStateException e) { <line8> } catch (AccessControlException e) { <line9> } <line10> delete(); <line11> } <line12> } <line13> 	<line9>      logger.warn(e.toString(), e);	task4	
"public class A { <line0> public List<EnrichmentBase> enrichByEquivalenceValues(ReferenceValue referenceValue) { <line1> try { <line2> final ReferenceTerm referenceTerm = <line3> new ReferenceTermImpl( <line4> new URL(referenceValue.getReference()), Set.copyOf(referenceValue.getEntityTypes())); <line5> return persistentEntityResolver <line6> .resolveByUri(Set.of(referenceTerm)) <line7> .getOrDefault(referenceTerm, Collections.emptyList()); <line8> } catch (MalformedURLException e) { <line9> throw new IllegalArgumentException(""The input values are invalid"", e); <line10> } <line11> } <line12> } <line13> "	"<line9>      LOGGER.debug(""There was a problem converting the input to ReferenceTermType"");"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> NonNamespaceOperation<Node, NodeList, Resource<Node>> w = <line3> getEndpoint().getKubernetesClient().nodes(); <line4> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getLabelKey()) <line5> && ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getLabelValue())) { <line6> w.withLabel( <line7> getEndpoint().getKubernetesConfiguration().getLabelKey(), <line8> getEndpoint().getKubernetesConfiguration().getLabelValue()); <line9> } <line10> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getResourceName())) { <line11> w.withName(getEndpoint().getKubernetesConfiguration().getResourceName()); <line12> } <line13> watch = <line14> w.watch( <line15> new Watcher<Node>() { <line16> @Override <line17> public void eventReceived( <line18> io.fabric8.kubernetes.client.Watcher.Action action, Node resource) { <line19> NodeEvent ne = new NodeEvent(action, resource); <line20> Exchange exchange = createExchange(false); <line21> exchange.getIn().setBody(ne.getNode()); <line22> exchange <line23> .getIn() <line24> .setHeader(KubernetesConstants.KUBERNETES_EVENT_ACTION, ne.getAction()); <line25> exchange <line26> .getIn() <line27> .setHeader( <line28> KubernetesConstants.KUBERNETES_EVENT_TIMESTAMP, System.currentTimeMillis()); <line29> try { <line30> processor.process(exchange); <line31> } catch (Exception e) { <line32> getExceptionHandler().handleException(""Error during processing"", exchange, e); <line33> } finally { <line34> releaseExchange(exchange, false); <line35> } <line36> } <line37>  <line38> @Override <line39> public void onClose(WatcherException cause) { <line40> if (cause != null) { <line41> } <line42> } <line43> }); <line44> } <line45> } <line46> "	<line41>                  LOG.error(cause.getMessage(), cause);	task4	
"public class A { <line0> private void incTrainTest() throws Exception { <line1> try { <line2> String inputPath = ""../../data/census/census_148d_train.dummy""; <line3> conf.set(AngelConf.ANGEL_TRAIN_DATA_PATH, inputPath); <line4> conf.set(AngelConf.ANGEL_ACTION_TYPE, MLConf.ANGEL_ML_TRAIN()); <line5> conf.set(AngelConf.ANGEL_LOAD_MODEL_PATH, LOCAL_FS + TMP_PATH + ""/model/deepFM""); <line6> conf.set(AngelConf.ANGEL_SAVE_MODEL_PATH, LOCAL_FS + TMP_PATH + ""/model/deepFM_new""); <line7> GraphRunner runner = new GraphRunner(); <line8> runner.train(conf); <line9> } catch (Exception x) { <line10> throw x; <line11> } <line12> } <line13> } <line14> "	"<line10>      LOG.error(""run trainOnLocalClusterTest failed "", x);"	task4	
public class A { <line0> @Override <line1> public void destroy() { <line2> if (this.deregisterJDBCDriver) { <line3> cleanupDrivers(this.providedDrivers); <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOGGER.debug(""Deregistering of JDBC driver(s) is disabled!"");"	task4	
public class A { <line0> public void setSourceHelper(WMSSourceHelper source) { <line1> this.sourceHelper = source; <line2> if (concurrency != null) { <line3> this.sourceHelper.setConcurrency(concurrency); <line4> } else { <line5> this.sourceHelper.setConcurrency(32); <line6> } <line7> if (backendTimeout != null) { <line8> this.sourceHelper.setBackendTimeout(backendTimeout); <line9> } else { <line10> this.sourceHelper.setBackendTimeout(120); <line11> } <line12> } <line13> } <line14> 	"<line1>    log.debug(""Setting sourceHelper on "" + this.name);"	task4	
"public class A { <line0> @Override <line1> public FSDataInputStream open(final Path f, final int bufferSize) throws IOException { <line2> final FileStatus fileStatus = getFileStatus(f); <line3> if (fileStatus.isDirectory()) { <line4> throw new FileNotFoundException(""Can't open "" + f + "" because it is a directory""); <line5> } <line6> return new FSDataInputStream( <line7> new OBSInputStream( <line8> bucket, <line9> OBSCommonUtils.pathToKey(this, f), <line10> fileStatus.getLen(), <line11> obs, <line12> statistics, <line13> readAheadRange, <line14> this)); <line15> } <line16> } <line17> "	"<line2>    LOG.debug(""Opening '{}' for reading."", f);"	task4	
public class A { <line0> private LoadingCache<String, Map<String, Integer>> initCache(CapacityLimitDB limitDB) { <line1> return CacheBuilder.newBuilder() <line2> .expireAfterAccess(120, TimeUnit.SECONDS) <line3> .build( <line4> new CacheLoader<String, Map<String, Integer>>() { <line5> public Map<String, Integer> load(String name) { <line6> return limitDB.getAll().stream() <line7> .collect(Collectors.toMap(CapacityLimit::getName, CapacityLimit::getValue)); <line8> } <line9> }); <line10> } <line11> } <line12> 	"<line6>                log.trace(""Get fresh values of capacity limits"");"	task4	
"public class A { <line0> private void restoreAccessPoliciesSnapshot(List<AccessPolicy> accessPoliciesSnapshot) { <line1> List<AccessPolicy> currentAccessPolicies = createAccessPoliciesSnapshot(); <line2> Set<String> policiesToRestore = <line3> accessPoliciesSnapshot.stream() <line4> .map(AccessPolicy::getIdentifier) <line5> .collect(Collectors.toSet()); <line6> Set<AccessPolicy> policiesToDelete = <line7> currentAccessPolicies.stream() <line8> .filter(p -> !policiesToRestore.contains(p.getIdentifier())) <line9> .collect(Collectors.toSet()); <line10> for (AccessPolicy originalPolicy : accessPoliciesSnapshot) { <line11> Response getCurrentPolicy = <line12> client <line13> .target(createURL(""policies/"" + originalPolicy.getIdentifier())) <line14> .request() <line15> .header(""Authorization"", ""Bearer "" + adminAuthToken) <line16> .get(Response.class); <line17> if (getCurrentPolicy.getStatus() == 200) { <line18> client <line19> .target(createURL(""policies/"" + originalPolicy.getIdentifier())) <line20> .request() <line21> .header(""Authorization"", ""Bearer "" + adminAuthToken) <line22> .put(Entity.entity(originalPolicy, MediaType.APPLICATION_JSON)); <line23> } else { <line24> client <line25> .target(createURL(""policies"")) <line26> .request() <line27> .header(""Authorization"", ""Bearer "" + adminAuthToken) <line28> .post(Entity.entity(originalPolicy, MediaType.APPLICATION_JSON)); <line29> } <line30> } <line31> for (AccessPolicy policyToDelete : policiesToDelete) { <line32> try { <line33> final RevisionInfo revisionInfo = policyToDelete.getRevision(); <line34> final Long version = revisionInfo == null ? 0 : revisionInfo.getVersion(); <line35> client <line36> .target(createURL(""policies/"" + policyToDelete.getIdentifier())) <line37> .queryParam(""version"", version.longValue()) <line38> .request() <line39> .header(""Authorization"", ""Bearer "" + adminAuthToken) <line40> .delete(); <line41> } catch (Exception e) { <line42> } <line43> } <line44> } <line45> } <line46> "	"<line42>        LOGGER.error(""Error cleaning up policies after test due to: "" + e.getMessage(), e);"	task4	
"public class A { <line0> private void negotiatePeek() throws SocketException, IOException { <line1> try { <line2> this.socket.setSoTimeout(this.transportContext.getConfig().getConnTimeout()); <line3> if (peekKey() == null) throw new IOException(""transport closed in negotiate""); <line4> } finally { <line5> this.socket.setSoTimeout(this.transportContext.getConfig().getSoTimeout()); <line6> } <line7> int size = Encdec.dec_uint16be(this.sbuf, 2) & 0xFFFF; <line8> if (size < 33 || (4 + size) > this.sbuf.length) { <line9> throw new IOException(""Invalid payload size: "" + size); <line10> } <line11> int hdrSize = this.smb2 ? Smb2Constants.SMB2_HEADER_LENGTH : SMB1_HEADER_LENGTH; <line12> readn(this.in, this.sbuf, 4 + hdrSize, size - hdrSize); <line13> } <line14> } <line15> "	"<line13>    log.trace(""Read negotiate response"");"	task4	
public class A { <line0> private void forwardRpcRequestToDeviceActor( <line1> ToDeviceRpcRequest request, Consumer<FromDeviceRpcResponse> responseConsumer) { <line2> UUID requestId = request.getId(); <line3> toDeviceRpcRequests.put(requestId, responseConsumer); <line4> sendRpcRequestToDevice(request); <line5> scheduleTimeout(request, requestId); <line6> } <line7> } <line8> 	"<line2>    log.trace(""[{}][{}] Processing local rpc call to device actor [{}]"",request.getTenantId(),request.getId(),request.getDeviceId());"	task4	
public class A { <line0> @Override <line1> public Class<?> getInterfaceClass() <line2> throws RulesInstantiationException, ProjectResolvingException, ClassNotFoundException { <line3> if (interfaceClass != null) { <line4> return interfaceClass; <line5> } <line6> if (generatedInterfaceClass != null) { <line7> return generatedInterfaceClass; <line8> } <line9> generatedInterfaceClass = getRulesInstantiationStrategy().getInstanceClass(); <line10> return generatedInterfaceClass; <line11> } <line12> } <line13> 	"<line9>    log.info(""Interface class is undefined for the factory. Generated interface is used."");"	task4	
"public class A { <line0> protected String getDbScriptLocation(String databaseType) { <line1> String scriptName = databaseType + "".sql""; <line2> if (log.isDebugEnabled()) { <line3> } <line4> return setupSQLScriptBaseLocation.replaceFirst(""DBTYPE"", databaseType) + scriptName; <line5> } <line6> } <line7> "	"<line3>      log.debug(""Loading database script from :"" + scriptName);"	task4	
"public class A { <line0> public SessionId generateAuthenticatedSessionId( <line1> HttpServletRequest httpRequest, String userDn, Map<String, String> sessionIdAttributes) <line2> throws InvalidSessionStateException { <line3> SessionId sessionId = <line4> generateSessionId( <line5> userDn, new Date(), SessionIdState.AUTHENTICATED, sessionIdAttributes, true); <line6> if (externalApplicationSessionService.isEnabled()) { <line7> String userName = sessionId.getSessionAttributes().get(Constants.AUTHENTICATED_USER); <line8> boolean externalResult = <line9> externalApplicationSessionService.executeExternalStartSessionMethods( <line10> httpRequest, sessionId); <line11> if (!externalResult) { <line12> reinitLogin(sessionId, true); <line13> throw new InvalidSessionStateException( <line14> ""Session creation is prohibited by external session script!""); <line15> } <line16> externalEvent( <line17> new SessionEvent(SessionEventType.AUTHENTICATED, sessionId).setHttpRequest(httpRequest)); <line18> } <line19> return sessionId; <line20> } <line21> } <line22> "	"<line11>      log.info(""Start session result for '{}': '{}'"", userName, ""start"", externalResult);"	task4	
public class A { <line0> public org.talend.mdm.webservice.WSViewPK putView(org.talend.mdm.webservice.WSPutView arg0) { <line1> System.out.println(arg0); <line2> try { <line3> org.talend.mdm.webservice.WSViewPK _return = null; <line4> return _return; <line5> } catch (java.lang.Exception ex) { <line6> ex.printStackTrace(); <line7> throw new RuntimeException(ex); <line8> } <line9> } <line10> } <line11> 	"<line1>    LOG.info(""Executing operation putView"");"	task4	
public class A { <line0> public static Set<String> getJcrRepositoryNames() { <line1> try { <line2> return repositoriesContainer.getRepositoryNames(Collections.unmodifiableMap(factoryParams)); <line3> } catch (RepositoryException e) { <line4> return Collections.emptySet(); <line5> } <line6> } <line7> } <line8> 	<line4>      LOGGER.error(e, WebJcrI18n.cannotLoadRepositoryNames.text());	task4	
public class A { <line0> @Override <line1> public boolean handleRequest(MessageContext messageContext, Object endpoint) <line2> throws IOException, SAXException, TransformerException { <line3> if (validateRequest) { <line4> Source requestSource = getValidationRequestSource(messageContext.getRequest()); <line5> if (requestSource != null) { <line6> SAXParseException[] errors = validator.validate(requestSource, errorHandler); <line7> if (!ObjectUtils.isEmpty(errors)) { <line8> return handleRequestValidationErrors(messageContext, errors); <line9> } else if (logger.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> return true; <line14> } <line15> } <line16> 	"<line10>          logger.debug(""Request message validated"");"	task4	
public class A { <line0> private void endTransaction() { <line1> if (currentTransaction != null) { <line2> try { <line3> currentTransaction.success(); <line4> currentTransaction.close(); <line5> } catch (Throwable t) { <line6> } finally { <line7> currentTransaction = null; <line8> } <line9> } <line10> } <line11> } <line12> 	"<line6>        logger.warn("""", t);"	task4	
public class A { <line0> @Override <line1> protected void finalize() throws Throwable { <line2> try { <line3> tryDestroy(); <line4> } catch (Exception e) { <line5> } <line6> super.finalize(); <line7> } <line8> } <line9> 	<line5>      logger.error(e);	task4	
public class A { <line0> public <OUTPUT, THROWABLE extends Throwable> CompletableFuture<OUTPUT> submit( <line1> CheckedSupplier<OUTPUT, THROWABLE> task, <line2> ExecutorService executor, <line3> Function<Throwable, Throwable> newThrowable) { <line4> final CompletableFuture<OUTPUT> f = new CompletableFuture<>(); <line5> final Runnable runnable = <line6> LogUtils.newRunnable( <line7> LOG, <line8> () -> { <line9> try { <line10> f.complete(task.get()); <line11> } catch (Throwable e) { <line12> f.completeExceptionally(newThrowable.apply(e)); <line13> } <line14> pollAndSubmit(executor); <line15> }, <line16> task::toString); <line17> offerAndSubmit(runnable, executor); <line18> return f; <line19> } <line20> } <line21> 	"<line9>              LOG.trace(""{}: running {}"", this, task);"	task4	
"public class A { <line0> protected String post(URL url, Map<String, String> headers, String data) throws IOException { <line1> HttpURLConnection connection = (HttpURLConnection) url.openConnection(); <line2> if (headers != null) { <line3> for (Map.Entry<String, String> entry : headers.entrySet()) { <line4> connection.addRequestProperty(entry.getKey(), entry.getValue()); <line5> } <line6> } <line7> connection.addRequestProperty(""Accept-Encoding"", ""gzip""); <line8> connection.setRequestMethod(""POST""); <line9> connection.setDoOutput(true); <line10> connection.connect(); <line11> OutputStream out = null; <line12> try { <line13> out = connection.getOutputStream(); <line14> out.write(data.getBytes()); <line15> out.flush(); <line16> int statusCode = connection.getResponseCode(); <line17> if (statusCode != HttpURLConnection.HTTP_OK) { <line18> } <line19> } finally { <line20> if (out != null) { <line21> out.close(); <line22> } <line23> } <line24> String responseEncoding = connection.getHeaderField(""Content-Encoding""); <line25> responseEncoding = (responseEncoding == null ? """" : responseEncoding.trim()); <line26> ByteArrayOutputStream bos = new ByteArrayOutputStream(); <line27> InputStream in = connection.getInputStream(); <line28> try { <line29> in = connection.getInputStream(); <line30> if (""gzip"".equalsIgnoreCase(responseEncoding)) { <line31> in = new GZIPInputStream(in); <line32> } <line33> in = new BufferedInputStream(in); <line34> byte[] buff = new byte[1024]; <line35> int n; <line36> while ((n = in.read(buff)) > 0) { <line37> bos.write(buff, 0, n); <line38> } <line39> bos.flush(); <line40> bos.close(); <line41> } finally { <line42> if (in != null) { <line43> in.close(); <line44> } <line45> } <line46> return bos.toString(); <line47> } <line48> } <line49> "	"<line18>        logger.debug(""An unexpected status code was returned: '{}'"", statusCode);"	task4	
public class A { <line0> @Override <line1> public IApsEntity extractEntityType( <line2> String typeCode, <line3> Class entityClass, <line4> String configItemName, <line5> IEntityTypeDOM entityTypeDom, <line6> String entityManagerName, <line7> IApsEntityDOM entityDom) <line8> throws ApsSystemException { <line9> String xml = this.getConfigManager().getConfigItem(configItemName); <line10> return entityTypeDom.extractEntityType( <line11> typeCode, xml, entityClass, entityDom, entityManagerName); <line12> } <line13> } <line14> 	"<line10>    logger.debug(""{} : {}"", configItemName, xml);"	task4	
public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> xceiverClientManager.close(); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.error(""Can't close "" + this.getClass().getSimpleName(), ex);"	task4	
public class A { <line0> @Override <line1> public CommerceWishListItem findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchWishListItemException { <line3> CommerceWishListItem commerceWishListItem = fetchByPrimaryKey(primaryKey); <line4> if (commerceWishListItem == null) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchWishListItemException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return commerceWishListItem; <line10> } <line11> } <line12> 	<line6>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> public void configureResources() throws Exception { <line1> if (!conf.isConfigureResources()) { <line2> return; <line3> } <line4> String tableName = conf.getTableName(); <line5> configureTable(tableName); <line6> } <line7> } <line8> 	"<line2>      LOGGER.info(""Skipping configure resources step"");"	task4	
"public class A { <line0> protected void multiAllelicKnockouts( <line1> String sample, <line2> Map<String, KnockoutGene> knockoutGenes, <line3> Query query, <line4> Predicate<String> ctFilter, <line5> Predicate<String> biotypeFilter, <line6> Predicate<String> geneFilter) <line7> throws Exception { <line8> query = <line9> new Query(query) <line10> .append(VariantQueryParam.INCLUDE_SAMPLE_DATA.key(), includeSampleData) <line11> .append(VariantQueryParam.GENOTYPE.key(), sample + IS + ""1/2""); <line12> Map<String, KnockoutVariant> variants = new HashMap<>(); <line13> int numVariants = <line14> iterate( <line15> query, <line16> ""Read "" + KnockoutVariant.KnockoutType.HET_ALT + "" variants: "", <line17> variant -> { <line18> Variant secVar = getSecondaryVariant(variant); <line19> StudyEntry studyEntry = variant.getStudies().get(0); <line20> SampleEntry sampleEntry = studyEntry.getSample(0); <line21> FileEntry fileEntry = studyEntry.getFiles().get(sampleEntry.getFileIndex()); <line22> KnockoutVariant knockoutVariant = <line23> new KnockoutVariant( <line24> variant, <line25> variant.getAnnotation().getId(), <line26> sampleEntry.getData().get(0), <line27> KnockoutVariant.getDepth(studyEntry, fileEntry, sampleEntry), <line28> fileEntry.getData().get(StudyEntry.FILTER), <line29> fileEntry.getData().get(StudyEntry.QUAL), <line30> studyEntry.getStats(StudyEntry.DEFAULT_COHORT), <line31> KnockoutVariant.KnockoutType.HET_ALT, <line32> null, <line33> variant.getAnnotation().getPopulationFrequencies(), <line34> KnockoutVariant.getClinicalSignificance(variant.getAnnotation())); <line35> if (variants.put(variant.toString(), knockoutVariant) == null) { <line36> if (variant.overlapWith(secVar, true)) { <line37> variants.put(secVar.toString(), new KnockoutVariant()); <line38> } <line39> } else { <line40> KnockoutVariant secKnockoutVar = variants.get(secVar.toString()); <line41> for (ConsequenceType consequenceType : <line42> variant.getAnnotation().getConsequenceTypes()) { <line43> if (validCt(consequenceType, ctFilter, biotypeFilter, geneFilter)) { <line44> addGene( <line45> variant, <line46> knockoutVariant.getGenotype(), <line47> knockoutVariant.getDepth(), <line48> knockoutVariant.getFilter(), <line49> knockoutVariant.getQual(), <line50> consequenceType, <line51> knockoutGenes, <line52> KnockoutVariant.KnockoutType.HET_ALT, <line53> knockoutVariant.getDbSnp(), <line54> knockoutVariant.getPopulationFrequencies(), <line55> knockoutVariant.getClinicalSignificance(), <line56> knockoutVariant.getStats()); <line57> addGene( <line58> secVar, <line59> secKnockoutVar.getGenotype(), <line60> secKnockoutVar.getDepth(), <line61> secKnockoutVar.getFilter(), <line62> secKnockoutVar.getQual(), <line63> consequenceType, <line64> knockoutGenes, <line65> KnockoutVariant.KnockoutType.HET_ALT, <line66> secKnockoutVar.getDbSnp(), <line67> secKnockoutVar.getPopulationFrequencies(), <line68> secKnockoutVar.getClinicalSignificance(), <line69> secKnockoutVar.getStats()); <line70> } <line71> } <line72> } <line73> }); <line74> } <line75> } <line76> "	"<line74>    logger.info(""Read {} HET_ALT variants from sample {}"", numVariants, sample);"	task4	
"public class A { <line0> @Override <line1> public boolean handle(ApiRequest request) throws IOException { <line2> String id = request.getId(); <line3> if (!FILENAME.equals(id)) { <line4> return false; <line5> } <line6> String pem = null; <line7> for (Map.Entry<String, PublicKey> entry : hostApiService.getPublicKeys().entrySet()) { <line8> try { <line9> pem = SshKeyGen.writePublicKey(entry.getValue()); <line10> break; <line11> } catch (Exception e) { <line12> } <line13> } <line14> if (pem == null) { <line15> return false; <line16> } <line17> byte[] content = pem.getBytes(""UTF-8""); <line18> HttpServletResponse response = request.getServletContext().getResponse(); <line19> response.getOutputStream().write(pem.getBytes(""UTF-8"")); <line20> response.setContentLength(content.length); <line21> response.setContentType(""application/octet-stream""); <line22> response.setHeader(""Content-Disposition"", ""attachment; filename="" + FILENAME); <line23> response.setHeader(""Cache-Control"", ""private""); <line24> response.setHeader(""Pragma"", ""private""); <line25> response.setHeader(""Expires"", ""Wed 24 Feb 1982 18:42:00 GMT""); <line26> response.getOutputStream().write(content); <line27> return true; <line28> } <line29> } <line30> "	"<line12>        log.error(""Failed to write PEM"", e);"	task4	
public class A { <line0> @Override <line1> public void operationFinished(Object ctx, Void resultOfOperation) { <line2> rl.offer(); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> long latencyMillis = MathUtils.now() - startTimeMillis; <line6> stat.requestComplete(TimeUnit.MILLISECONDS.toMicros(latencyMillis)); <line7> } <line8> } <line9> 	"<line4>      logger.debug(""Successfully published message for token:"" + token);"	task4	
"public class A { <line0> @Override <line1> public Object apply(final ActionContext ctx, final Object caller, final Object[] sources) <line2> throws FrameworkException { <line3> try { <line4> assertArrayHasMinLengthAndAllElementsNotNull(sources, 2); <line5> Date date = null; <line6> if (sources[0] instanceof Date) { <line7> date = (Date) sources[0]; <line8> } else if (sources[0] instanceof Number) { <line9> date = new Date(((Number) sources[0]).longValue()); <line10> } else { <line11> try { <line12> date = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"").parse(sources[0].toString()); <line13> } catch (ParseException ex) { <line14> return """"; <line15> } <line16> } <line17> final Calendar givenDate = Calendar.getInstance(); <line18> givenDate.setTime(date); <line19> givenDate.add(Calendar.YEAR, getIntParameter(sources, 1, ""year"")); <line20> givenDate.add(Calendar.MONTH, getIntParameter(sources, 2, ""month"")); <line21> givenDate.add(Calendar.DAY_OF_YEAR, getIntParameter(sources, 3, ""day"")); <line22> givenDate.add(Calendar.HOUR_OF_DAY, getIntParameter(sources, 4, ""hour"")); <line23> givenDate.add(Calendar.MINUTE, getIntParameter(sources, 5, ""minute"")); <line24> givenDate.add(Calendar.SECOND, getIntParameter(sources, 6, ""second"")); <line25> return givenDate.getTime(); <line26> } catch (ArgumentNullException pe) { <line27> return """"; <line28> } catch (ArgumentCountException pe) { <line29> logParameterError(caller, sources, pe.getMessage(), ctx.isJavaScriptContext()); <line30> return usage(ctx.isJavaScriptContext()); <line31> } <line32> } <line33> } <line34> "	"<line14>          logger.warn(""{}: Could not parse string \""{}\"" with pattern {} in element \""{}\"". Parameters: {}"",new Object[] {getReplacement(),sources[0].toString(),""yyyy-MM-dd'T'HH:mm:ssZ"",caller,getParametersAsString(sources)});"	task4	
public class A { <line0> public void removeMapping(T key, WebSocketSession session) { <line1> synchronized (this) { <line2> Set<WebSocketSession> sessions = mapping.get(key); <line3> if (sessions != null) { <line4> sessions.remove(session); <line5> if (sessions.isEmpty()) mapping.remove(sessions); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line1>    logger.debug(""removing mapping from key {} to websocket session {}"", key, session.getId());"	task4	
public class A { <line0> @Override <line1> public void save(Note note, AuthenticationInfo subject) throws IOException { <line2> String[] pathArray = toPathArray(note.getPath(), false); <line3> try (AutoLock autoLock = lock.lockForWrite()) { <line4> String pId = completeFolder(pathArray); <line5> saveNote(note); <line6> saveNotePath(note.getId(), note.getName(), pId); <line7> } <line8> } <line9> } <line10> 	"<line2>    LOG.debug(""save note, note: {}"", note);"	task4	
public class A { <line0> protected void doDependency( <line1> Index index, <line2> final EntryStatistics es[], <line3> final IterablePosting ips[], <line4> ResultSet rs, <line5> final double[] phraseTermWeights, <line6> boolean SD) <line7> throws IOException { <line8> final int numPhraseTerms = phraseTerms.length; <line9> final boolean[] postingListFinished = new boolean[numPhraseTerms]; <line10> for (int i = 0; i < numPhraseTerms; i++) { <line11> postingListFinished[i] = ips[i].next() == IterablePosting.EOL; <line12> } <line13> this.setCollectionStatistics(index.getCollectionStatistics(), index); <line14> determineGlobalStatistics(phraseTerms, es, SD); <line15> final int[] docids = rs.getDocids(); <line16> final double[] scores = rs.getScores(); <line17> final short[] occurrences = rs.getOccurrences(); <line18> int altered = 0; <line19> MultiSort.ascendingHeapSort(docids, scores, occurrences, docids.length); <line20> final int docidsLength = docids.length; <line21> boolean allZero = true; <line22> for (int i = 0; i < docidsLength; i++) { <line23> if (scores[i] != 0.0d) allZero = false; <line24> scores[i] = w_t * scores[i]; <line25> } <line26> DOC: <line27> for (int k = 0; k < docidsLength; k++) { <line28> int i = -1; <line29> int targetDocId = docids[k]; <line30> if (!allZero && scores[k] <= 0.0d) continue DOC; <line31> boolean[] okToUse = new boolean[numPhraseTerms]; <line32> TERM: <line33> for (IterablePosting ip : ips) { <line34> i++; <line35> if (postingListFinished[i]) { <line36> okToUse[i] = false; <line37> continue TERM; <line38> } <line39> okToUse[i] = true; <line40> if (ip == null) { <line41> okToUse[i] = false; <line42> continue TERM; <line43> } <line44> while (ip.getId() < targetDocId) { <line45> if (ip.next() == IterablePosting.EOL) { <line46> okToUse[i] = false; <line47> postingListFinished[i] = true; <line48> continue TERM; <line49> } <line50> } <line51> if (ip.getId() > targetDocId) { <line52> okToUse[i] = false; <line53> continue TERM; <line54> } <line55> okToUse[i] = true; <line56> } <line57> if (countTrue(okToUse) < 2) { <line58> continue DOC; <line59> } <line60> altered++; <line61> scores[k] += calculateDependence(ips, okToUse, phraseTermWeights, SD); <line62> } <line63> for (IterablePosting ip : ips) { <line64> if (ip != null) ip.close(); <line65> } <line66> } <line67> } <line68> 	"<line66>    logger.info(this.getClass().getSimpleName() + "" altered scores for "" + altered + "" documents"");"	task4	
public class A { <line0> private void parseSaltLength(PasswordSaltExtensionMessage msg) { <line1> msg.setSaltLength(parseIntField(ExtensionByteLength.PASSWORD_SALT)); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""SaltLength: "" + msg.getSaltLength().getValue());"	task4	
public class A { <line0> public static void prepareLogContext() { <line1> Map<String, String> registered = new TreeMap<>(); <line2> Properties properties = System.getProperties(); <line3> for (Map.Entry<Object, Object> entry : properties.entrySet()) { <line4> if ((entry.getKey() instanceof String) == false <line5> || (entry.getValue() instanceof String) == false) { <line6> continue; <line7> } <line8> String key = (String) entry.getKey(); <line9> if (key.startsWith(LOG_CONTEXT_PREFIX) == false) { <line10> continue; <line11> } <line12> String value = (String) entry.getValue(); <line13> String name = key.substring(LOG_CONTEXT_PREFIX.length()); <line14> MDC.put(name, value); <line15> registered.put(name, value); <line16> } <line17> } <line18> } <line19> 	"<line17>    LOG.debug(""Log context is prepared: {}"", registered);"	task4	
public class A { <line0> public void setHireDate(NSTimestamp value) { <line1> if (_Employee.LOG.isDebugEnabled()) { <line2> } <line3> takeStoredValueForKey(value, _Employee.HIRE_DATE_KEY); <line4> } <line5> } <line6> 	"<line2>      _Employee.LOG.debug(""updating hireDate from "" + hireDate() + "" to "" + value);"	task4	
"public class A { <line0> private boolean isContentOverflow(byte[] content, String resPath) throws SQLException { <line1> if (kylinConfig.isJsonAlwaysSmallCell() && isJsonMetadata(resPath)) { <line2> int smallCellMetadataWarningThreshold = kylinConfig.getSmallCellMetadataWarningThreshold(); <line3> int smallCellMetadataErrorThreshold = kylinConfig.getSmallCellMetadataErrorThreshold(); <line4> if (content.length > smallCellMetadataWarningThreshold) { <line5> } <line6> if (content.length > smallCellMetadataErrorThreshold) { <line7> throw new SQLException( <line8> new IllegalArgumentException( <line9> ""A JSON metadata entry's size is not supposed to exceed"" <line10> + "" kylin.metadata.jdbc.small-cell-meta-size-error-threshold("" <line11> + smallCellMetadataErrorThreshold <line12> + ""), resPath: "" <line13> + resPath <line14> + "", actual size: "" <line15> + content.length)); <line16> } <line17> return false; <line18> } <line19> int maxSize = kylinConfig.getJdbcResourceStoreMaxCellSize(); <line20> if (content.length > maxSize) return true; <line21> else return false; <line22> } <line23> } <line24> "	"<line5>        logger.warn(""A JSON metadata entry's size is not supposed to exceed""+ "" kylin.metadata.jdbc.small-cell-meta-size-warning-threshold({}), resPath: {},""+ "" actual size: {}"",smallCellMetadataWarningThreshold,resPath,content.length);"	task4	
"public class A { <line0> public static Mat loadMat(String infile) { <line1> String tryfile = infile; <line2> if (tryfile.startsWith(""http"")) { <line3> tryfile = getImageFromUrl(tryfile); <line4> } <line5> File f = new File(tryfile); <line6> if (f.exists()) { <line7> return read(tryfile); <line8> } <line9> tryfile = Service.getResourceDir(OpenCV.class, infile); <line10> f = new File(tryfile); <line11> if (f.exists()) { <line12> return read(tryfile); <line13> } <line14> tryfile = <line15> ""src"" <line16> + File.separator <line17> + ""main"" <line18> + File.separator <line19> + ""resources"" <line20> + File.separator <line21> + ""resource"" <line22> + File.separator <line23> + OpenCV.class.getSimpleName() <line24> + File.separator <line25> + infile; <line26> f = new File(tryfile); <line27> if (f.exists()) { <line28> return read(tryfile); <line29> } <line30> tryfile = <line31> ""src"" <line32> + File.separator <line33> + ""test"" <line34> + File.separator <line35> + ""resources"" <line36> + File.separator <line37> + OpenCV.class.getSimpleName() <line38> + File.separator <line39> + infile; <line40> f = new File(tryfile); <line41> if (f.exists()) { <line42> return read(tryfile); <line43> } <line44> return null; <line45> } <line46> } <line47> "	"<line44>    log.error(""could not load Mat {}"", infile);"	task4	
public class A { <line0> protected void determineHighestAssignedHueID() { <line1> for (Metadata metadata : metadataRegistry.getAll()) { <line2> if (!metadata.getUID().getNamespace().equals(METAKEY)) { <line3> continue; <line4> } <line5> try { <line6> int hueId = Integer.parseInt(metadata.getValue()); <line7> if (hueId > highestAssignedHueID) { <line8> highestAssignedHueID = hueId; <line9> } <line10> } catch (NumberFormatException e) { <line11> } <line12> } <line13> } <line14> } <line15> 	"<line11>        logger.warn(""A non numeric hue ID '{}' was assigned. Ignoring!"", metadata.getValue());"	task4	
public class A { <line0> public synchronized IndexRecord getFirstWriteInProgressRecord() { <line1> IndexRecord ret = null; <line2> IndexRecords records = loadRecords(indexFile); <line3> if (records != null) { <line4> for (IndexRecord record : records.getRecords().values()) { <line5> if (record.isStatusWriteInProgress()) { <line6> ret = record; <line7> break; <line8> } <line9> } <line10> } <line11> return ret; <line12> } <line13> } <line14> 	"<line6>          LOG.info(""IndexFileManager.getFirstWriteInProgressRecord(source={}): current file={}"",this.source,record.getPath());"	task4	
"public class A { <line0> private void dumpStackTraceForWatchable() { <line1> if (!log.isDebugEnabled()) { <line2> return; <line3> } <line4> final Map<Thread, StackTraceElement[]> stackTraces = Thread.getAllStackTraces(); <line5> final Set<Thread> threads = stackTraces.keySet(); <line6> final Iterator<Thread> threadIterator = threads.iterator(); <line7> final StringBuilder stacktrace = new StringBuilder(); <line8> while (threadIterator.hasNext()) { <line9> final Thread t = threadIterator.next(); <line10> if (t.getName().equals(m_watchable.getName())) { <line11> if (t.getName().equals(m_watchable.getName())) { <line12> stacktrace.append(""dumping stacktrace for too long running thread : "").append(t); <line13> } else { <line14> stacktrace.append(""dumping stacktrace for other running thread : "").append(t); <line15> } <line16> final StackTraceElement[] ste = stackTraces.get(t); <line17> for (final StackTraceElement stackTraceElement : ste) { <line18> stacktrace.append(""\n"").append(stackTraceElement); <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	<line22>    log.debug(stacktrace.toString());	task4	
public class A { <line0> @Override <line1> public void unRegisterService(String serviceType, String baseUrl) <line2> throws ServiceRegistryException { <line3> setOnlineStatus(serviceType, baseUrl, null, false, null); <line4> cleanRunningJobs(serviceType, baseUrl); <line5> } <line6> } <line7> 	"<line3>    logger.info(""Unregistering Service {}@{} and cleaning its running jobs"", serviceType, baseUrl);"	task4	
public class A { <line0> public synchronized void producersConnected(final Wire[] wires) { <line1> this.wireSupport.producersConnected(wires); <line2> } <line3> } <line4> 	"<line1>    logger.info(""Producers connected - {}"", (Object) wires);"	task4	
"public class A { <line0> private void logCallInfo(URI _uri, Map<String, String> _params) { <line1> final StringBuilder b = new StringBuilder(); <line2> b.append(""Calling ["").append(_uri.toString()).append(""]""); <line3> if (_params != null && _params.size() > 0) { <line4> b.append("" with params [""); <line5> int i = 0; <line6> for (Map.Entry<String, String> e : _params.entrySet()) { <line7> if (i++ > 0) b.append("", ""); <line8> b.append(e.getKey()).append(""="").append(e.getValue()); <line9> } <line10> } <line11> } <line12> } <line13> "	"<line11>    log.info(b.toString() + ""]"");"	task4	
public class A { <line0> @Override <line1> public Reader loadResource(String relativePath) { <line2> InputStream is = this.classLoader.getResourceAsStream(relativePath); <line3> return is != null ? new InputStreamReader(is) : null; <line4> } <line5> } <line6> 	"<line2>    LOG.info(""Loading resource. RelativePath = {}."", relativePath);"	task4	
public class A { <line0> public List<String> lookupAssigningAuthorities(String homeCommunityId) { <line1> return mappingDao.getAssigningAuthoritiesByHomeCommunity(homeCommunityId); <line2> } <line3> } <line4> 	"<line1>    LOG.trace(""converting homeCommunityId ["" + homeCommunityId + ""] to assigning authority"");"	task4	
public class A { <line0> public As createAs( <line1> String asName, <line2> Functionality functionality, <line3> ExchangeType exchangeType, <line4> IPSPType ipspType, <line5> RoutingContext rc, <line6> TrafficModeType trafficMode, <line7> int minAspActiveForLoadbalance, <line8> NetworkAppearance na) <line9> throws Exception { <line10> As as = this.getAs(asName); <line11> if (as != null) { <line12> throw new Exception(String.format(M3UAOAMMessages.CREATE_AS_FAIL_NAME_EXIST, asName)); <line13> } <line14> if (exchangeType == null) { <line15> exchangeType = ExchangeType.SE; <line16> } <line17> if (functionality == Functionality.IPSP && ipspType == null) { <line18> ipspType = IPSPType.CLIENT; <line19> } <line20> as = <line21> new AsImpl( <line22> asName, <line23> rc, <line24> trafficMode, <line25> minAspActiveForLoadbalance, <line26> functionality, <line27> exchangeType, <line28> ipspType, <line29> na); <line30> ((AsImpl) as).setM3UAManagement(this); <line31> FSM localFSM = ((AsImpl) as).getLocalFSM(); <line32> this.m3uaScheduler.execute(localFSM); <line33> FSM peerFSM = ((AsImpl) as).getPeerFSM(); <line34> this.m3uaScheduler.execute(peerFSM); <line35> appServers.add(as); <line36> this.store(); <line37> for (FastList.Node<M3UAManagementEventListener> n = this.managementEventListeners.head(), <line38> end = this.managementEventListeners.tail(); <line39> (n = n.getNext()) != end; ) { <line40> M3UAManagementEventListener m3uaManagementEventListener = n.getValue(); <line41> try { <line42> m3uaManagementEventListener.onAsCreated(as); <line43> } catch (Throwable ee) { <line44> } <line45> } <line46> return as; <line47> } <line48> } <line49> 	"<line44>        logger.error(""Exception while invoking onAsCreated"", ee);"	task4	
public class A { <line0> @Test <line1> public void deleteNotExistingUserExpectError() throws Exception { <line2> assertEquals( <line3> deleteUser(adminConnectionCorrect, NEW_USER_SDN).getStatus(), HttpStatus.NOT_FOUND_404); <line4> } <line5> } <line6> 	"<line2>    LOG.info(""delete specific not existing user"");"	task4	
public class A { <line0> public static MessageResourcesFactory createFactory() { <line1> try { <line2> if (clazz == null) { <line3> clazz = RequestUtils.applicationClass(factoryClass); <line4> } <line5> MessageResourcesFactory factory = (MessageResourcesFactory) clazz.newInstance(); <line6> return (factory); <line7> } catch (Throwable t) { <line8> return (null); <line9> } <line10> } <line11> } <line12> 	"<line8>      LOG.error(""MessageResourcesFactory.createFactory"", t);"	task4	
public class A { <line0> public void removeFromChannelsAndClose(long logId) { <line1> FileChannel fileChannel = logid2filechannel.remove(logId); <line2> if (null != fileChannel) { <line3> try { <line4> fileChannel.close(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        LOG.warn(""Exception while closing channel for log file:"" + logId);"	task4	
public class A { <line0> @Override <line1> protected void refresh(final List<MetaData> data) { <line2> if (CollectionUtils.isEmpty(data)) { <line3> metaDataSubscribers.forEach(MetaDataSubscriber::refresh); <line4> } else { <line5> data.forEach( <line6> metaData -> metaDataSubscribers.forEach(subscriber -> subscriber.onSubscribe(metaData))); <line7> } <line8> } <line9> } <line10> 	"<line3>      log.info(""clear all metaData cache"");"	task4	
public class A { <line0> @Dependent <line1> @PortletParam <line2> @Produces <line3> public Date getDateParam( <line4> ClientDataRequest clientDataRequest, <line5> PortletResponse portletResponse, <line6> InjectionPoint injectionPoint) { <line7> String value = getStringParam(clientDataRequest, portletResponse, injectionPoint); <line8> if (value == null) { <line9> return null; <line10> } <line11> Annotated field = injectionPoint.getAnnotated(); <line12> Annotation[] fieldAnnotations = _getFieldAnnotations(field); <line13> ParamConverter<Date> paramConverter = <line14> _getParamConverter(Date.class, field.getBaseType(), fieldAnnotations); <line15> if (paramConverter != null) { <line16> try { <line17> return paramConverter.fromString(value); <line18> } catch (IllegalArgumentException iae) { <line19> _addBindingError(fieldAnnotations, iae.getMessage(), value); <line20> return null; <line21> } <line22> } <line23> if (LOG.isWarnEnabled()) { <line24> } <line25> return null; <line26> } <line27> } <line28> 	"<line24>      LOG.warn(""Unable to find a ParamConverterProvider for type Date"");"	task4	
public class A { <line0> @Override <line1> public void applySchemaChange(SchemaChangeEvent schemaChange) { <line2> switch (schemaChange.getType()) { <line3> case CREATE: <line4> case ALTER: <line5> schemaChange.getTableChanges().forEach(x -> buildAndRegisterSchema(x.getTable())); <line6> break; <line7> case DROP: <line8> schemaChange.getTableChanges().forEach(x -> removeSchema(x.getId())); <line9> break; <line10> default: <line11> } <line12> if (!databaseHistory.storeOnlyCapturedTables() <line13> || isGlobalSetVariableStatement(schemaChange.getDdl(), schemaChange.getDatabase()) <line14> || schemaChange.getTables().stream() <line15> .map(Table::id) <line16> .anyMatch(filters.dataCollectionFilter()::isIncluded)) { <line17> record(schemaChange, schemaChange.getTableChanges()); <line18> } <line19> } <line20> } <line21> 	"<line17>      LOGGER.debug(""Recorded DDL statements for database '{}': {}"",schemaChange.getDatabase(),schemaChange.getDdl());"	task4	
public class A { <line0> @Override <line1> public long getGroupId() { <line2> try { <line3> Group group = GroupLocalServiceUtil.getCompanyGroup(_entry.getCompanyId()); <line4> return group.getGroupId(); <line5> } catch (Exception exception) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> return 0; <line10> } <line11> } <line12> 	<line7>        log.debug(exception, exception);	task4	
"public class A { <line0> public static short parseSBMLShortStrict(String value) { <line1> short v = 0; <line2> try { <line3> v = Short.parseShort(value.trim()); <line4> } catch (NumberFormatException e) { <line5> Logger logger = Logger.getLogger(StringTools.class); <line6> throw new IllegalArgumentException(""Must be of type short!"", e); <line7> } <line8> return v; <line9> } <line10> } <line11> "	"<line6>      logger.warn(""Could not create a short from the string "" + value);"	task4	
"public class A { <line0> @RequestMapping( <line1> value = ""/{userName:.+}"", <line2> method = {RequestMethod.PUT}, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN) <line6> public ManagedUser save( <line7> @PathVariable(""userName"") String userName, @RequestBody ManagedUser user) { <line8> checkProfileEditAllowed(); <line9> if (StringUtils.equals(getPrincipal(), user.getUsername()) && user.isDisabled()) { <line10> throw new ForbiddenException(""Action not allowed!""); <line11> } <line12> checkUserName(userName); <line13> user.setUsername(userName); <line14> try { <line15> ManagedUser existing = get(userName); <line16> if (existing != null) { <line17> if (user.getPassword() == null) user.setPassword(existing.getPassword()); <line18> if (user.getAuthorities() == null || user.getAuthorities().isEmpty()) <line19> user.setGrantedAuthorities(existing.getAuthorities()); <line20> } <line21> } catch (UsernameNotFoundException ex) { <line22> } <line23> user.setPassword(pwdEncode(user.getPassword())); <line24> completeAuthorities(user); <line25> userService.updateUser(user); <line26> return get(userName); <line27> } <line28> } <line29> "	"<line23>    logger.info(""Saving {}"", user);"	task4	
public class A { <line0> @Override <line1> public void lifeCycleStarted(LifeCycle event) { <line2> final Set<SslReload> reloaders = new HashSet<>(); <line3> reloaders.addAll(getReloaders(environment.getApplicationContext())); <line4> reloaders.addAll(getReloaders(environment.getAdminContext())); <line5> reloadTask.setReloaders(reloaders); <line6> } <line7> } <line8> 	"<line5>    LOGGER.info(""{} ssl reloaders registered"", reloaders.size());"	task4	
public class A { <line0> @Override <line1> public FtpFile getHomeDirectory() throws FtpException { <line2> return new SimpleFtpFile(); <line3> } <line4> } <line5> 	"<line2>    logger.trace(""getHomeDirectory"");"	task4	
public class A { <line0> @Override <line1> public void onConnectGPRSRequest(ConnectGPRSRequest ind) { <line2> TestEvent te = TestEvent.createReceivedEvent(EventType.ConnectGPRSRequest, ind, sequence++); <line3> this.observerdEvents.add(te); <line4> } <line5> } <line6> 	"<line2>    this.logger.debug(""ConnectGPRSRequest"");"	task4	
"public class A { <line0> @Test <line1> public void multipleThreads() throws Exception { <line2> Helpers.updateLoggingConfig( <line3> context, <line4> cm, <line5> Helpers.LoggingLibrary.LOG4J1, <line6> ""threads"", <line7> d -> { <line8> d.put(""irrelevant"", UUID.randomUUID().toString()); <line9> }); <line10> final Logger log = LoggerFactory.getLogger(""my.logger""); <line11> final CountDownLatch latch = new CountDownLatch(41); <line12> Runnable r1 = <line13> () -> { <line14> Thread.currentThread().setName(""Thread "" + UUID.randomUUID().toString()); <line15> for (int i = 0; i < 100; i++) { <line16> try { <line17> Thread.sleep(30); <line18> } catch (InterruptedException e) { <line19> throw new RuntimeException(e.getMessage(), e); <line20> } <line21> } <line22> latch.countDown(); <line23> }; <line24> Runnable r2 = <line25> () -> { <line26> Thread.currentThread().setName(""Config Updater Thread""); <line27> for (int i = 0; i < 30; i++) { <line28> Helpers.updateLoggingConfig( <line29> context, <line30> cm, <line31> Helpers.LoggingLibrary.LOG4J1, <line32> ""threads"", <line33> d -> { <line34> d.put(""irrelevant"", UUID.randomUUID().toString()); <line35> }); <line36> try { <line37> Thread.sleep(85); <line38> } catch (InterruptedException e) { <line39> throw new RuntimeException(e.getMessage(), e); <line40> } <line41> } <line42> latch.countDown(); <line43> }; <line44> new Thread(r2).start(); <line45> for (int t = 0; t < 40; t++) { <line46> new Thread(r1).start(); <line47> } <line48> latch.await(); <line49> } <line50> } <line51> "	"<line16>            log.info(""Message {}"", i);"	task4	
public class A { <line0> @Override <line1> public void onError(final Task task, final Throwable throwable) { <line2> errorReference.compareAndSet(null, throwable); <line3> } <line4> } <line5> 	"<line2>    logger.error(""Exception thrown while initializing consumers."", throwable);"	task4	
public class A { <line0> public static URL convertFileToURL(File file) { <line1> if (file == null || !file.exists()) return null; <line2> if (!file.isAbsolute()) file = file.getAbsoluteFile(); <line3> try { <line4> return file.toURI().toURL(); <line5> } catch (MalformedURLException e) { <line6> return null; <line7> } <line8> } <line9> } <line10> 	"<line6>      LOG.debug(String.format(""File '%s' can't be converted to URL"", file), e);"	task4	
"public class A { <line0> @RequestMapping( <line1> value = ""/replicaSet/{replicaSetID}/{nodeID:.+}"", <line2> method = {RequestMethod.PUT}) <line3> @ResponseBody <line4> public void addNodeToReplicaSet(@PathVariable Integer replicaSetID, @PathVariable String nodeID) { <line5> final String user = SecurityContextHolder.getContext().getAuthentication().getName(); <line6> streamingService.addNodeToReplicaSet(replicaSetID, nodeID); <line7> } <line8> } <line9> "	"<line6>    logger.info(""{} try to add Node {} To ReplicaSet {}"", user, nodeID, replicaSetID);"	task4	
public class A { <line0> public static void transferCollectionContributors( <line1> List<PersonTO> persons, ContainerMetadata metadata, User u, TRANSFER_MODE mode) { <line2> for (PersonTO pTO : persons) { <line3> Person person = new Person(); <line4> person.setFamilyName(pTO.getFamilyName()); <line5> person.setGivenName(pTO.getGivenName()); <line6> person.setCompleteName(pTO.getCompleteName()); <line7> person.setAlternativeName(pTO.getAlternativeName()); <line8> person.setRole(URI.create(pTO.getRole())); <line9> if (pTO.getIdentifiers().size() == 1) { <line10> IdentifierTO ito = new IdentifierTO(); <line11> ito.setValue(pTO.getIdentifiers().get(0).getValue()); <line12> person.setIdentifier(ito.getValue()); <line13> } else if (pTO.getIdentifiers().size() > 1) { <line14> } <line15> transferContributorOrganizations(pTO.getOrganizations(), person, mode); <line16> metadata.getPersons().add(person); <line17> } <line18> if (metadata.getPersons().size() == 0 && TRANSFER_MODE.CREATE.equals(mode) && u != null) { <line19> Person personU = new Person(); <line20> PersonTO pTo = new PersonTO(); <line21> personU.setFamilyName(u.getPerson().getFamilyName()); <line22> personU.setGivenName(u.getPerson().getGivenName()); <line23> personU.setCompleteName(u.getPerson().getCompleteName()); <line24> personU.setAlternativeName(u.getPerson().getAlternativeName()); <line25> if (!isNullOrEmpty(u.getPerson().getIdentifier())) { <line26> IdentifierTO ito = new IdentifierTO(); <line27> ito.setValue(u.getPerson().getIdentifier()); <line28> personU.setIdentifier(ito.getValue()); <line29> } <line30> personU.setOrganizations(u.getPerson().getOrganizations()); <line31> personU.setRole(URI.create(pTo.getRole())); <line32> metadata.getPersons().add(personU); <line33> } <line34> } <line35> } <line36> 	"<line14>        LOGGER.warn(""Multiple identifiers found for Person: "" + pTO.getId());"	task4	
public class A { <line0> static LanguageDetector langDetector() { <line1> if (detector == null) { <line2> try { <line3> detector = getDefaultLanguageDetector(); <line4> detector.loadModels(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> return detector; <line9> } <line10> } <line11> 	"<line6>        logger.warn(""Can not load lang detector models"", e);"	task4	
public class A { <line0> @Override <line1> protected void tearDown() throws Exception { <line2> connection.close(); <line3> service.stop(); <line4> context.close(); <line5> super.tearDown(); <line6> } <line7> } <line8> 	"<line6>    LOG.info(""### closed down the test case: "" + getName());"	task4	
public class A { <line0> protected final void initOutput( <line1> BatchSinkContext context, <line2> BigQuery bigQuery, <line3> String outputName, <line4> String tableName, <line5> @Nullable Schema tableSchema, <line6> String bucket, <line7> FailureCollector collector) <line8> throws IOException { <line9> List<BigQueryTableFieldSchema> fields = <line10> getBigQueryTableFields( <line11> bigQuery, tableName, tableSchema, getConfig().isAllowSchemaRelaxation(), collector); <line12> Configuration configuration = new Configuration(baseConfiguration); <line13> String temporaryGcsPath = <line14> BigQuerySinkUtils.getTemporaryGcsPath(bucket, runUUID.toString(), tableName); <line15> BigQuerySinkUtils.configureOutput( <line16> configuration, <line17> getConfig().getDatasetProject(), <line18> getConfig().getDataset(), <line19> tableName, <line20> temporaryGcsPath, <line21> fields); <line22> List<String> fieldNames = <line23> fields.stream().map(BigQueryTableFieldSchema::getName).collect(Collectors.toList()); <line24> recordLineage(context, outputName, tableSchema, fieldNames); <line25> context.addOutput( <line26> Output.of(outputName, getOutputFormatProvider(configuration, tableName, tableSchema))); <line27> } <line28> } <line29> 	"<line9>    LOG.debug(""Init output for table '{}' with schema: {}"", tableName, tableSchema);"	task4	
"public class A { <line0> @Override <line1> public void updateBundle(long bundleId, InputStream inputStream) throws PortalException { <line2> _checkPermission(); <line3> Bundle bundle = getBundle(bundleId); <line4> if (bundle == null) { <line5> throw new PortalException(""No bundle with ID "" + bundleId); <line6> } <line7> try { <line8> bundle.update(inputStream); <line9> } catch (BundleException bundleException) { <line10> throw new PortalException(bundleException); <line11> } <line12> } <line13> } <line14> "	<line10>      log.error(bundleException, bundleException);	task4	
"public class A { <line0> private static AuthorizationResponse acceptAuthorization(WebDriver driver) { <line1> String authorizationResponseStr = driver.getCurrentUrl(); <line2> AuthorizationResponse authorizationResponse = null; <line3> if (!authorizationResponseStr.contains(""#"")) { <line4> Wait<WebDriver> wait = <line5> new FluentWait<WebDriver>(driver) <line6> .withTimeout(Duration.ofSeconds(WAIT_OPERATION_TIMEOUT)) <line7> .pollingEvery(Duration.ofMillis(500)) <line8> .ignoring(NoSuchElementException.class); <line9> WebElement allowButton = <line10> wait.until( <line11> new Function<WebDriver, WebElement>() { <line12> public WebElement apply(WebDriver d) { <line13> return d.findElement(By.id(""authorizeForm:allowButton"")); <line14> } <line15> }); <line16> JavascriptExecutor jse = (JavascriptExecutor) driver; <line17> jse.executeScript(""scroll(0, 1000)""); <line18> String previousURL = driver.getCurrentUrl(); <line19> Actions actions = new Actions(driver); <line20> actions.click(allowButton).perform(); <line21> authorizationResponseStr = driver.getCurrentUrl(); <line22> authorizationResponse = new AuthorizationResponse(authorizationResponseStr); <line23> } else { <line24> fail(""The authorization form was expected to be shown.""); <line25> } <line26> return authorizationResponse; <line27> } <line28> } <line29> "	"<line23>      LOG.info(""Authorization Response url is: "" + driver.getCurrentUrl());"	task4	
"public class A { <line0> public static void filterTypesDef(AtlasTypesDefFilterRequest request) { <line1> MetricRecorder metric = RequestContext.get().startMetricRecord(""filterTypesDef""); <line2> String userName = getCurrentUserName(); <line3> if (StringUtils.isNotEmpty(userName) && !RequestContext.get().isImportInProgress()) { <line4> try { <line5> AtlasAuthorizer authorizer = AtlasAuthorizerFactory.getAtlasAuthorizer(); <line6> request.setUser(getCurrentUserName(), getCurrentUserGroups()); <line7> request.setClientIPAddress(RequestContext.get().getClientIPAddress()); <line8> request.setForwardedAddresses(RequestContext.get().getForwardedAddresses()); <line9> request.setRemoteIPAddress(RequestContext.get().getClientIPAddress()); <line10> authorizer.filterTypesDef(request); <line11> } catch (AtlasAuthorizationException e) { <line12> } <line13> } <line14> RequestContext.get().endMetricRecord(metric); <line15> } <line16> } <line17> "	"<line12>        LOG.error(""Unable to obtain AtlasAuthorizer"", e);"	task4	
"public class A { <line0> @SuppressWarnings(""synthetic-access"") <line1> protected void onChannelOpened(OpenFuture future) { <line2> Buffer buffer = new ByteArrayBuffer(Long.SIZE, false); <line3> buffer.putByte((byte) 0x00); <line4> Throwable t = future.getException(); <line5> if (t != null) { <line6> service.unregisterChannel(channel); <line7> channel.close(true); <line8> buffer.putByte((byte) 0x5b); <line9> } else { <line10> buffer.putByte((byte) 0x5a); <line11> } <line12> buffer.putByte((byte) 0x00); <line13> buffer.putByte((byte) 0x00); <line14> buffer.putByte((byte) 0x00); <line15> buffer.putByte((byte) 0x00); <line16> buffer.putByte((byte) 0x00); <line17> buffer.putByte((byte) 0x00); <line18> try { <line19> session.writeBuffer(buffer); <line20> } catch (IOException e) { <line21> throw new IllegalStateException(""Failed to send packet"", e); <line22> } <line23> } <line24> } <line25> "	"<line21>      log.error(""Failed ({}) to send channel open packet for {}: {}"",e.getClass().getSimpleName(),channel,e.getMessage());"	task4	
"public class A { <line0> @Override <line1> public synchronized void generateNewVersionType(String formTypeCode) throws ApsSystemException { <line2> try { <line3> Message prototype = (Message) super.getEntityPrototype(formTypeCode); <line4> Integer version = 1; <line5> if (null != prototype) { <line6> version = prototype.getVersionType() + 1; <line7> } <line8> prototype.setVersionType(version); <line9> String modelXml = new FormTypeDOM().getXml(prototype); <line10> StepsConfig stepsConfig = this.getStepsConfig(formTypeCode); <line11> String stepsXml = new StepConfigsDOM().createConfigXml(stepsConfig); <line12> TypeVersionGuiConfig versionConfig = new TypeVersionGuiConfig(); <line13> versionConfig.setFormTypeCode(formTypeCode); <line14> versionConfig.setPrototypeXml(modelXml); <line15> versionConfig.setPrototype(prototype); <line16> versionConfig.setStepsConfigXml(stepsXml); <line17> versionConfig.setStepsConfig(stepsConfig); <line18> Map<String, StepGuiConfig> workGuiConfigs = <line19> this.getFormTypeGuiDAO().getWorkGuiConfigs(formTypeCode); <line20> List<StepGuiConfig> guiConfigs = new ArrayList<StepGuiConfig>(); <line21> guiConfigs.addAll(workGuiConfigs.values()); <line22> versionConfig.setGuiConfigs(guiConfigs); <line23> versionConfig.setVersion(prototype.getVersionType()); <line24> this.generateLabels(versionConfig); <line25> this.getFormTypeGuiDAO().addTypeVersionGui(versionConfig); <line26> this.getLastVersionConfigs().put(formTypeCode, versionConfig); <line27> this.updateEntityPrototype(prototype); <line28> } catch (Throwable t) { <line29> throw new ApsSystemException(""Error generating new version type - "" + formTypeCode, t); <line30> } <line31> } <line32> } <line33> "	"<line29>      logger.error(""Error generating new version type - {}"", formTypeCode, t);"	task4	
"public class A { <line0> public void openDatabase(boolean readOnly, boolean lockRequired) throws DatabaseException { <line1> if (mode.isDatabaseRequired() && database == null) { <line2> try (WriteLock dblock = <line3> new WriteLock(getSettings(), lockRequired && DatabaseManager.isH2Connection(settings))) { <line4> if (readOnly <line5> && DatabaseManager.isH2Connection(settings) <line6> && settings.getString(Settings.KEYS.DB_CONNECTION_STRING).contains(""file:%s"")) { <line7> final File db = DatabaseManager.getH2DataFile(settings); <line8> if (db.isFile()) { <line9> final File temp = settings.getTempDirectory(); <line10> final File tempDB = new File(temp, db.getName()); <line11> Files.copy(db.toPath(), tempDB.toPath()); <line12> settings.setString(Settings.KEYS.H2_DATA_DIRECTORY, temp.getPath()); <line13> final String connStr = settings.getString(Settings.KEYS.DB_CONNECTION_STRING); <line14> if (!connStr.contains(""ACCESS_MODE_DATA"")) { <line15> settings.setString( <line16> Settings.KEYS.DB_CONNECTION_STRING, connStr + ""ACCESS_MODE_DATA=r""); <line17> } <line18> database = new CveDB(settings); <line19> } else { <line20> throw new DatabaseException( <line21> ""Unable to open database - configured database file does not exist: "" <line22> + db.toString()); <line23> } <line24> } else { <line25> database = new CveDB(settings); <line26> } <line27> } catch (IOException ex) { <line28> throw new DatabaseException(""Unable to open database in read only mode"", ex); <line29> } catch (WriteLockException ex) { <line30> throw new DatabaseException(""Failed to obtain lock - unable to open database"", ex); <line31> } <line32> database.open(); <line33> } <line34> } <line35> } <line36> "	"<line11>            LOGGER.debug(""copying database {} to {}"", db.toPath(), temp.toPath());"	task4	
public class A { <line0> public synchronized <Key, SourceState, OutputState> <line1> GenericCompilerCache<Key, SourceState, OutputState> getGenericCompilerCache( <line2> final GenericCompiler<Key, SourceState, OutputState> compiler) throws IOException { <line3> GenericCompilerCache<?, ?, ?> cache = myGenericCachesMap.get(compiler); <line4> if (cache == null) { <line5> final GenericCompilerCache<?, ?, ?> genericCache = <line6> new GenericCompilerCache<Key, SourceState, OutputState>( <line7> compiler, GenericCompilerRunner.getGenericCompilerCacheDir(myProject, compiler)); <line8> myGenericCachesMap.put(compiler, genericCache); <line9> myCacheDisposables.add( <line10> () -> { <line11> if (LOG.isDebugEnabled()) { <line12> } <line13> genericCache.close(); <line14> }); <line15> cache = genericCache; <line16> } <line17> return (GenericCompilerCache<Key, SourceState, OutputState>) cache; <line18> } <line19> } <line20> 	"<line12>              LOG.debug(""Closing cache for feneric compiler "" + compiler.getId());"	task4	
public class A { <line0> private void spawnProgessLogger(Set<StateTuple> state) { <line1> Thread progressLogger = <line2> new Thread( <line3> () -> { <line4> while (true) { <line5> int done = 0; <line6> int cancelled = 0; <line7> for (StateTuple stateTuple : state) { <line8> if (stateTuple.future().isCancelled()) { <line9> cancelled++; <line10> } else if (stateTuple.future().isDone()) { <line11> done++; <line12> } <line13> } <line14> try { <line15> Thread.sleep(TimeUnit.SECONDS.toMillis(30)); <line16> } catch (InterruptedException e) { <line17> Thread.currentThread().interrupt(); <line18> } <line19> } <line20> }); <line21> progressLogger.setDaemon(true); <line22> progressLogger.start(); <line23> } <line24> } <line25> 	"<line14>                LOGGER.info(""Job stats: {} pending, {} finished, {} cancelled"",state.size() - done - cancelled,done,cancelled);"	task4	
public class A { <line0> @Override <line1> protected void doRun() { <line2> try { <line3> lock.lock(); <line4> if (unRecoveredAlerts.isEmpty()) { <line5> return; <line6> } <line7> reportRecovered(); <line8> } finally { <line9> lock.unlock(); <line10> } <line11> } <line12> } <line13> 	"<line2>    logger.debug(""[scheduledRecoverAlertReport] unRecoveredAlerts: {}"", unRecoveredAlerts);"	task4	
public class A { <line0> @Override <line1> protected void finalize() throws Throwable { <line2> if (this.logger.isDebugEnabled()) { <line3> } <line4> super.finalize(); <line5> } <line6> } <line7> 	"<line3>      this.logger.debug(""Finalized classloader "" + toString());"	task4	
public class A { <line0> @Override <line1> public ComponentCSVRecord apply(CSVRecord input) { <line2> ComponentCSVRecord componentCSVRecord = null; <line3> try { <line4> componentCSVRecord = new ComponentCSVRecordBuilder(input).build(); <line5> } catch (Exception e) { <line6> } <line7> return componentCSVRecord; <line8> } <line9> } <line10> 	"<line6>      log.error(""Bad record "" + input, e);"	task4	
"public class A { <line0> public static int getKBCommentsCount(HttpPrincipal httpPrincipal, long groupId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> KBCommentServiceUtil.class, ""getKBCommentsCount"", _getKBCommentsCountParameterTypes9); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return ((Integer) returnObj).intValue(); <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> void btnPrintActionPerformed(java.awt.event.ActionEvent evt) { <line1> Thread thread = <line2> new Thread( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> try { <line7> btnPrint.setEnabled(false); <line8> JasperPrintManager.getInstance(viewerContext.getJasperReportsContext()) <line9> .print(viewerContext.getJasperPrint(), true); <line10> } catch (Exception ex) { <line11> if (log.isErrorEnabled()) { <line12> } <line13> JOptionPane.showMessageDialog( <line14> JRViewerToolbar.this, viewerContext.getBundleString(""error.printing"")); <line15> } finally { <line16> btnPrint.setEnabled(true); <line17> } <line18> } <line19> }); <line20> thread.start(); <line21> } <line22> } <line23> "	"<line12>                    log.error(""Print error."", ex);"	task4	
"public class A { <line0> @Test <line1> public void testGetAllAuthorities1() { <line2> SearchControls con1 = new SearchControls(); <line3> con1.setReturningAttributes(new String[] {""cn""}); <line4> LdapSearchParamsFactory paramsFactory = <line5> new LdapSearchParamsFactoryImpl(""ou=roles"", ""(objectClass=organizationalRole)"", con1); <line6> Transformer one = new SearchResultToAttrValueList(""cn""); <line7> Transformer two = new StringToGrantedAuthority(); <line8> Transformer[] transformers = {one, two}; <line9> Transformer transformer = new ChainedTransformer(transformers); <line10> LdapSearch rolesSearch = new GenericLdapSearch(getContextSource(), paramsFactory, transformer); <line11> DefaultLdapUserRoleListService userRoleListService = getDefaultLdapUserRoleListService(); <line12> userRoleListService.setAllAuthoritiesSearch(rolesSearch); <line13> List res = userRoleListService.getAllRoles(); <line14> assertTrue(res.contains(""ROLE_CTO"")); <line15> assertTrue(res.contains(""ROLE_CEO"")); <line16> if (logger.isDebugEnabled()) { <line17> } <line18> } <line19> } <line20> "	"<line17>      logger.debug(""results of getAllAuthorities1(): "" + res);"	task4	
public class A { <line0> private static boolean isFieldQueried(Path field, ValueComparisonExpression q, Path context) { <line1> return isFieldQueried(field, q.getField(), context); <line2> } <line3> } <line4> 	"<line1>    LOGGER.debug(""Checking if field {} is queried by value comparison {}"", field, q);"	task4	
public class A { <line0> public void stop() { <line1> if (!mStarted) { <line2> return; <line3> } <line4> mStarted = false; <line5> for (AlluxioURI syncPoint : mSyncPathList) { <line6> try { <line7> stopSyncInternal(syncPoint); <line8> } catch (InvalidPathException e) { <line9> return; <line10> } <line11> } <line12> } <line13> } <line14> 	"<line9>        LOG.warn(""stop: InvalidPathException resolving syncPoint {}, exception {}"", syncPoint, e);"	task4	
"public class A { <line0> public void setUserDnTemplate(String template) throws IllegalArgumentException { <line1> if (!StringUtils.hasText(template)) { <line2> String msg = ""User DN template cannot be null or empty.""; <line3> throw new IllegalArgumentException(msg); <line4> } <line5> int index = template.indexOf(USERDN_SUBSTITUTION_TOKEN); <line6> if (index < 0) { <line7> String msg = <line8> ""User DN template must contain the '"" <line9> + USERDN_SUBSTITUTION_TOKEN <line10> + ""' replacement token to understand where to "" <line11> + ""insert the runtime authentication principal.""; <line12> throw new IllegalArgumentException(msg); <line13> } <line14> String prefix = template.substring(0, index); <line15> String suffix = template.substring(prefix.length() + USERDN_SUBSTITUTION_TOKEN.length()); <line16> if (log.isDebugEnabled()) { <line17> } <line18> this.userDnPrefix = prefix; <line19> this.userDnSuffix = suffix; <line20> } <line21> } <line22> "	"<line17>      log.debug(""Determined user DN prefix [{}] and suffix [{}]"", prefix, suffix);"	task4	
public class A { <line0> public static long getDeliveryTag( <line1> String experimentID, <line2> CuratorFramework curatorClient, <line3> String experimentNode, <line4> String pickedChild) <line5> throws Exception { <line6> String deliveryTagPath = <line7> experimentNode <line8> + File.separator <line9> + pickedChild <line10> + File.separator <line11> + experimentID <line12> + DELIVERY_TAG_POSTFIX; <line13> Stat exists = curatorClient.checkExists().forPath(deliveryTagPath); <line14> if (exists == null) { <line15> return -1; <line16> } <line17> return bytesToLong(curatorClient.getData().storingStatIn(exists).forPath(deliveryTagPath)); <line18> } <line19> } <line20> 	"<line15>      logger.error(""Cannot find delivery Tag in path:"" + deliveryTagPath + "" for this experiment"");"	task4	
public class A { <line0> private void cancelAllJobs() { <line1> JOBS.keySet().forEach(this::cancelJob); <line2> } <line3> } <line4> 	"<line1>    logger.debug(""Cancel all jobs."");"	task4	
"public class A { <line0> @Secured(ServicesData.ROLE_GET_AGENCIES) <line1> @GetMapping(path = RestApi.PATH_REFERENTIAL_ID) <line2> public AgencyDto getOne(final @PathVariable(""identifier"") String identifier) { <line3> ParameterChecker.checkParameter(""Identifier is mandatory : "", identifier); <line4> return agencyExternalService.getOne(identifier); <line5> } <line6> } <line7> "	"<line3>    LOGGER.debug(""get agency identifier={}"");"	task4	
"public class A { <line0> private void pushNodeDropDirURLsOntoStack(final FlowObjectStack st) { <line1> ReferencedFile refDir = getNodeContainerDirectory(); <line2> ReferencedFile dropFolder = refDir == null ? null : new ReferencedFile(refDir, DROP_DIR_NAME); <line3> if (dropFolder == null) { <line4> return; <line5> } <line6> dropFolder.lock(); <line7> try { <line8> File directory = dropFolder.getFile(); <line9> if (!directory.exists()) { <line10> return; <line11> } <line12> String[] files = directory.list(); <line13> if (files != null) { <line14> StringBuilder debug = <line15> new StringBuilder( <line16> ""Found "" + files.length + "" node local file(s) to "" + getNameWithID() + "": ""); <line17> debug.append(Arrays.toString(Arrays.copyOf(files, Math.max(3, files.length)))); <line18> for (String f : files) { <line19> File child = new File(directory, f); <line20> try { <line21> st.push( <line22> new FlowVariable( <line23> Scope.Local.getPrefix() + ""(drop) "" + f, <line24> child.toURI().toURL().toString(), <line25> Scope.Local)); <line26> } catch (MalformedURLException mue) { <line27> } <line28> } <line29> } <line30> } finally { <line31> dropFolder.unlock(); <line32> } <line33> } <line34> } <line35> "	"<line27>            LOGGER.warn(""Unable to process drop file"", mue);"	task4	
"public class A { <line0> public AuthorizationPolicy loadPolicyFromVfs() { <line1> Path authzPath = getAuthzPath(); <line2> if (!ioService.exists(authzPath)) { <line3> return null; <line4> } <line5> AuthorizationPolicyBuilder builder = permissionManager.newAuthorizationPolicy(); <line6> AuthorizationPolicyMarshaller marshaller = new AuthorizationPolicyMarshaller(); <line7> walkFileTree( <line8> authzPath, <line9> new SimpleFileVisitor<Path>() { <line10> @Override <line11> public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) <line12> throws IOException { <line13> try { <line14> checkNotNull(""file"", file); <line15> checkNotNull(""attrs"", attrs); <line16> if (isPolicyFile(file)) { <line17> String content = ioService.readAllString(file); <line18> NonEscapedProperties props = new NonEscapedProperties(); <line19> props.load(new StringReader(content)); <line20> marshaller.read(builder, props); <line21> } <line22> } catch (final Exception e) { <line23> return FileVisitResult.TERMINATE; <line24> } <line25> return FileVisitResult.CONTINUE; <line26> } <line27> }); <line28> return builder.build(); <line29> } <line30> } <line31> "	"<line23>              logger.error(""Authz policy file VFS read error: "" + file.getFileName(), e);"	task4	
public class A { <line0> private static void print(String content) { <line1> } <line2> } <line3> 	<line1>    LOG.info(content);	task4	
public class A { <line0> private void updateBrokerState(final BrokerState newState) { <line1> brokerState = newState.getCode(); <line2> heartbeat(); <line3> } <line4> } <line5> 	"<line1>    LOG.info(""update broker state from {} to {}"", BrokerState.codeOf(brokerState), newState);"	task4	
"public class A { <line0> public Map<String, Object> getCommit(String commitId) { <line1> try (PreparedStatement query = <line2> prepareStatement( <line3> ""SELECT commits.id, commits.elasticId, commits.refid, commits.timestamp,"" <line4> + "" committype.name, creator FROM commits JOIN committype ON commits.committype ="" <line5> + "" committype.id WHERE elasticId = ?"")) { <line6> query.setString(1, commitId); <line7> try (ResultSet rs = query.executeQuery()) { <line8> if (rs.next()) { <line9> Map<String, Object> result = new HashMap<>(); <line10> String refId = <line11> rs.getString(3).isEmpty() || rs.getString(3).equals("""") ? ""master"" : rs.getString(3); <line12> result.put(Sjm.SYSMLID, rs.getInt(1)); <line13> result.put(Sjm.ELASTICID, rs.getString(2)); <line14> result.put(Sjm.REFID, refId); <line15> result.put(Sjm.TIMESTAMP, rs.getTimestamp(4)); <line16> result.put(""commitType"", rs.getString(5)); <line17> result.put(Sjm.CREATOR, rs.getString(6)); <line18> return result; <line19> } <line20> } <line21> } catch (Exception e) { <line22> } finally { <line23> close(); <line24> } <line25> return null; <line26> } <line27> } <line28> "	"<line22>      logger.warn(String.format(""%s"", LogUtil.getStackTrace(e)));"	task4	
"public class A { <line0> @Override <line1> public long purge() throws DatabaseException { <line2> try { <line3> DeleteResult response = collection.deleteMany(new BasicDBObject()); <line4> return response.getDeletedCount(); <line5> } catch (MongoException e) { <line6> throw new DatabaseException(""Error while delete documents"", e); <line7> } <line8> } <line9> } <line10> "	"<line6>      LOGGER.error(""Error while delete documents"", e);"	task4	
"public class A { <line0> private String bratRenderLaterCommand() { <line1> return ""Wicket.$('"" <line2> + vis.getMarkupId() <line3> + ""').dispatcher.post('current', "" <line4> + ""["" <line5> + toJson(getCollection()) <line6> + "", '1234', {}, true]);""; <line7> } <line8> } <line9> "	"<line1>    LOG.trace(""[{}][{}] bratRenderLaterCommand"", getMarkupId(), vis.getMarkupId());"	task4	
"public class A { <line0> private DatanodeDetails initializeDatanodeDetails() throws IOException { <line1> String idFilePath = HddsServerUtil.getDatanodeIdFilePath(conf); <line2> if (idFilePath == null || idFilePath.isEmpty()) { <line3> throw new IllegalArgumentException( <line4> ScmConfigKeys.OZONE_SCM_DATANODE_ID_DIR <line5> + "" must be defined. See"" <line6> + "" https://wiki.apache.org/hadoop/Ozone#Configuration"" <line7> + "" for details on configuring Ozone.""); <line8> } <line9> Preconditions.checkNotNull(idFilePath); <line10> File idFile = new File(idFilePath); <line11> if (idFile.exists()) { <line12> return ContainerUtils.readDatanodeDetailsFrom(idFile); <line13> } else { <line14> DatanodeDetails details = DatanodeDetails.newBuilder().setUuid(UUID.randomUUID()).build(); <line15> details.setInitialVersion(DatanodeVersions.CURRENT_VERSION); <line16> details.setCurrentVersion(DatanodeVersions.CURRENT_VERSION); <line17> return details; <line18> } <line19> } <line20> } <line21> "	"<line3>      LOG.error(""A valid path is needed for config setting {}"", ScmConfigKeys.OZONE_SCM_DATANODE_ID_DIR);"	task4	
public class A { <line0> public void skip(String containerId, Number taskId, String userId) { <line1> containerId = <line2> context.getContainerId(containerId, new ByTaskIdContainerLocator(taskId.longValue())); <line3> userId = getUser(userId); <line4> userTaskService.skip(containerId, taskId.longValue(), userId); <line5> } <line6> } <line7> 	"<line4>    logger.debug(""About to skip task with id '{}' as user '{}'"", taskId, userId);"	task4	
"public class A { <line0> private Object getObjectOfCorrespondingPrimitiveType(String s, PrimitiveObjectInspector oi) <line1> throws IOException { <line2> PrimitiveTypeInfo typeInfo = oi.getTypeInfo(); <line3> if (writeablePrimitives) { <line4> Converter c = <line5> ObjectInspectorConverters.getConverter( <line6> PrimitiveObjectInspectorFactory.javaStringObjectInspector, oi); <line7> return c.convert(s); <line8> } <line9> switch (typeInfo.getPrimitiveCategory()) { <line10> case INT: <line11> return Integer.valueOf(s); <line12> case BYTE: <line13> return Byte.valueOf(s); <line14> case SHORT: <line15> return Short.valueOf(s); <line16> case LONG: <line17> return Long.valueOf(s); <line18> case BOOLEAN: <line19> return (s.equalsIgnoreCase(""true"")); <line20> case FLOAT: <line21> return Float.valueOf(s); <line22> case DOUBLE: <line23> return Double.valueOf(s); <line24> case STRING: <line25> return s; <line26> case BINARY: <line27> try { <line28> String t = Text.decode(s.getBytes(), 0, s.getBytes().length); <line29> return t.getBytes(); <line30> } catch (CharacterCodingException e) { <line31> return null; <line32> } <line33> case DATE: <line34> return Date.valueOf(s); <line35> case TIMESTAMP: <line36> return Timestamp.valueOf(s); <line37> case DECIMAL: <line38> return HiveDecimal.create(s); <line39> case VARCHAR: <line40> return new HiveVarchar(s, ((BaseCharTypeInfo) typeInfo).getLength()); <line41> case CHAR: <line42> return new HiveChar(s, ((BaseCharTypeInfo) typeInfo).getLength()); <line43> default: <line44> throw new IOException( <line45> ""Could not convert from string to "" + typeInfo.getPrimitiveCategory()); <line46> } <line47> } <line48> } <line49> "	"<line31>          LOG.warn(""Error generating json binary type from object."", e);"	task4	
public class A { <line0> @Override <line1> public void progress(float percent) { <line2> synchronized (this) { <line3> try { <line4> this.wait(3000); <line5> } catch (InterruptedException e) { <line6> throw new RuntimeException(e); <line7> } <line8> } <line9> assertTrue(percent >= 0); <line10> assertTrue(percent <= 100); <line11> adaptee.progress(percent); <line12> } <line13> } <line14> 	"<line12>    LOGGER.info(""progress:"" + percent);"	task4	
public class A { <line0> private List<RunHook> loadHooks(String subdir) { <line1> try { <line2> File hookDir = Controller.HOOKS_DIR.resolve(subdir).toFile(); <line3> if (hookDir.exists() && hookDir.isDirectory()) { <line4> return Files.list(hookDir.toPath()) <line5> .map(Path::toFile) <line6> .filter(file -> !file.isDirectory() && !file.isHidden()) <line7> .map(file -> new ExecRunHook(file.getName(), file.getAbsolutePath())) <line8> .collect(Collectors.toList()); <line9> } <line10> } catch (IOException e) { <line11> } <line12> return Collections.emptyList(); <line13> } <line14> } <line15> 	"<line11>      log.error(""Failed to list hooks."", e);"	task4	
public class A { <line0> public static com.liferay.commerce.product.model.CPDefinitionLinkSoap[] getCPDefinitionLinks( <line1> long cpDefinitionId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.commerce.product.model.CPDefinitionLink> returnValue = <line4> CPDefinitionLinkServiceUtil.getCPDefinitionLinks(cpDefinitionId); <line5> return com.liferay.commerce.product.model.CPDefinitionLinkSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
"public class A { <line0> private synchronized void closeConnectionAndChannel() throws IOException { <line1> if (channelPool != null) { <line2> try { <line3> channelPool.close(); <line4> channelPool = null; <line5> } catch (Exception e) { <line6> throw new IOException(""Error closing channelPool"", e); <line7> } <line8> } <line9> if (conn != null) { <line10> conn.close(closeTimeout); <line11> conn = null; <line12> } <line13> } <line14> } <line15> "	"<line10>      LOG.debug(""Closing connection: {} with timeout: {} ms."", conn, closeTimeout);"	task4	
"public class A { <line0> public static void updateExchangeRate( <line1> HttpPrincipal httpPrincipal, long commerceCurrencyId, String exchangeRateProviderKey) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceCurrencyServiceUtil.class, <line7> ""updateExchangeRate"", <line8> _updateExchangeRateParameterTypes12); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, commerceCurrencyId, exchangeRateProviderKey); <line11> try { <line12> TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	<line20>      log.error(systemException, systemException);	task4	
public class A { <line0> private GroupDefinition createGroup(Map.Entry<String, Object> groupNameValue) { <line1> GroupDefinition group = new GroupDefinition(); <line2> group.setName(groupNameValue.getKey()); <line3> try { <line4> if (groupNameValue.getValue() instanceof Map) { <line5> Map<String, Object> groupTemplateJsonMap = (Map<String, Object>) groupNameValue.getValue(); <line6> validateAndFillGroup(group, groupTemplateJsonMap); <line7> validateUpdateGroupProperties(group, groupTemplateJsonMap); <line8> validateUpdateGroupCapabilities(group, groupTemplateJsonMap); <line9> } else { <line10> rollbackWithException(ActionStatus.NOT_TOPOLOGY_TOSCA_TEMPLATE); <line11> } <line12> } catch (ClassCastException e) { <line13> rollbackWithException(ActionStatus.INVALID_YAML); <line14> } <line15> return group; <line16> } <line17> } <line18> 	"<line13>      log.debug(""#createGroup - Failed to create the group {}. The exception occure"",groupNameValue.getKey(),e);"	task4	
public class A { <line0> @Test <line1> public void testSetupWorked() throws IOException { <line2> Path[] inputFiles = <line3> FileUtil.stat2Paths(getFileSystem().listStatus(input, new OutputLogFilter())); <line4> Assert.assertEquals(testWarcs.length, inputFiles.length); <line5> } <line6> } <line7> 	"<line2>    log.info(""Checking input file(s) is/are present..."");"	task4	
public class A { <line0> private void executeOperation(Message in) throws Exception { <line1> switch (operation) { <line2> case ASSIGN_CONTENT: <line3> assignContent(in); <line4> break; <line5> case ASSIGN_EXPRESSION: <line6> assignExpression(in); <line7> break; <line8> case EVAL: <line9> eval(in); <line10> break; <line11> case VOID_EVAL: <line12> voidEval(in); <line13> break; <line14> case PARSE_AND_EVAL: <line15> parseAndEval(in); <line16> break; <line17> default: <line18> break; <line19> } <line20> } <line21> } <line22> 	"<line18>        LOGGER.info(""Nothing to do since operation has not been configured yet"");"	task4	
"public class A { <line0> private static void addAttachIfNecessary(Config config, Log log) { <line1> String srcName = null, trgName = null; <line2> String archBits = (SystemUtil.getJREArch() == SystemUtil.ARCH_64) ? ""64"" : ""32""; <line3> if (SystemUtil.isWindows()) { <line4> trgName = ""attach.dll""; <line5> srcName = ""windows"" + archBits + ""/"" + trgName; <line6> } else if (SystemUtil.isLinux()) { <line7> trgName = ""libattach.so""; <line8> srcName = ""linux"" + archBits + ""/"" + trgName; <line9> } else if (SystemUtil.isSolaris()) { <line10> trgName = ""libattach.so""; <line11> srcName = ""solaris"" + archBits + ""/"" + trgName; <line12> } else if (SystemUtil.isMacOSX()) { <line13> trgName = ""libattach.dylib""; <line14> srcName = ""macosx"" + archBits + ""/"" + trgName; <line15> } <line16> if (srcName != null) { <line17> Resource binDir = getBinDirectory(config); <line18> Resource trg = binDir.getRealResource(trgName); <line19> if (!trg.exists() || trg.length() == 0) { <line20> InputStream src = InfoImpl.class.getResourceAsStream(""/resource/bin/"" + srcName); <line21> try { <line22> IOUtil.copy(src, trg, true); <line23> } catch (IOException e) { <line24> log.log(Log.LEVEL_INFO, ""Instrumentation"", e); <line25> } <line26> } <line27> SystemUtil.addLibraryPathIfNoExist(binDir, log); <line28> } <line29> } <line30> } <line31> "	"<line20>        log.info(""Instrumentation"", ""deploy /resource/bin/"" + srcName + "" to "" + trg);"	task4	
public class A { <line0> private void prepareServerNameListLength(ClientEsniInner msg) { <line1> msg.setServerNameListLength(msg.getServerNameListBytes().getValue().length); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""ServerNameListLength: "" + msg.getServerNameListLength().getValue());"	task4	
public class A { <line0> @Override <line1> public Integer call() { <line2> final AtomicInteger lockCount = new AtomicInteger(0); <line3> try { <line4> DistributedLockService service = DistributedLockService.getServiceNamed(serviceName); <line5> while (!stop_testFairness) { <line6> assertThat(service.lock(lock, -1, -1)).isTrue(); <line7> lockCount.incrementAndGet(); <line8> service.unlock(lock); <line9> } <line10> } catch (VirtualMachineError e) { <line11> SystemFailure.initiateFailure(e); <line12> throw e; <line13> } catch (Throwable t) { <line14> fail(t.getMessage()); <line15> } finally { <line16> return lockCount.get(); <line17> } <line18> } <line19> } <line20> 	<line14>      logger.warn(t);	task4	
"public class A { <line0> @Override <line1> protected void assertExpectationsGiven(HapiApiSpec spec) throws Throwable { <line2> if (expectations.isPresent()) { <line3> ContractFunctionResult actual = response.getContractCallLocal().getFunctionResult(); <line4> if (!loggingOff) { <line5> } <line6> ErroringAsserts<ContractFunctionResult> asserts = expectations.get().assertsFor(spec); <line7> List<Throwable> errors = asserts.errorsIn(actual); <line8> rethrowSummaryError(log, ""Bad local call result!"", errors); <line9> } <line10> } <line11> } <line12> "	<line5>        log.info(Hex.toHexString(actual.getContractCallResult().toByteArray()));	task4	
public class A { <line0> @Override <line1> public void accept(String propertyName, Object value) { <line2> var stateCommand = typeConverter.toStateCommand(value); <line3> channelHandler.updateItemState(channel.getUID(), stateCommand); <line4> } <line5> } <line6> 	"<line4>    logger.debug(""channel {} updated with {} ({})"",channel.getUID().getAsString(),value,channel.getAcceptedItemType());"	task4	
public class A { <line0> @Override <line1> public void saveKeyStore(KeyStore keyStore) throws Exception { <line2> File samlKeyStoreFile = new File(getSamlKeyStorePath()); <line3> samlKeyStoreFile = samlKeyStoreFile.getAbsoluteFile(); <line4> if (!samlKeyStoreFile.exists()) { <line5> if (log.isInfoEnabled()) { <line6> } <line7> File parentDir = samlKeyStoreFile.getParentFile(); <line8> if (!parentDir.exists()) { <line9> parentDir.mkdirs(); <line10> } <line11> } <line12> monitorFile(samlKeyStoreFile); <line13> String samlKeyStorePassword = getSamlKeyStorePassword(); <line14> try (FileOutputStream fileOutputStream = new FileOutputStream(samlKeyStoreFile)) { <line15> _keyStore.store(fileOutputStream, samlKeyStorePassword.toCharArray()); <line16> } <line17> } <line18> } <line19> 	"<line6>        log.info(""Creating a new SAML keystore at "" + samlKeyStoreFile);"	task4	
public class A { <line0> public boolean teamExists(Integer teamId) { <line1> boolean exists = getHibernateTemplate().get(ProgramTeam.class, teamId) != null; <line2> return exists; <line3> } <line4> } <line5> 	"<line2>    log.debug(""teamExists: "" + exists);"	task4	
"public class A { <line0> public Cookie[] parse(String host, int port, String path, boolean secure, final Header header) <line1> throws MalformedCookieException { <line2> if (header == null) { <line3> throw new IllegalArgumentException(""Header may not be null.""); <line4> } <line5> return parse(host, port, path, secure, header.getValue()); <line6> } <line7> } <line8> "	"<line2>    LOG.trace(""enter CookieSpecBase.parse("" + ""String, port, path, boolean, String)"");"	task4	
"public class A { <line0> @Override <line1> public void initialize() { <line2> config = getConfigAs(LocalFolderWatcherConfiguration.class); <line3> updateStatus(ThingStatus.UNKNOWN); <line4> if (!Files.isDirectory(Paths.get(config.localDir))) { <line5> updateStatus( <line6> ThingStatus.OFFLINE, <line7> ThingStatusDetail.CONFIGURATION_ERROR, <line8> ""Local directory is not valid""); <line9> return; <line10> } <line11> try { <line12> previousLocalListing = WatcherCommon.initStorage(currentLocalListingFile, config.localDir); <line13> } catch (IOException e) { <line14> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage()); <line15> return; <line16> } <line17> if (config.pollIntervalLocal > 0) { <line18> updateStatus(ThingStatus.ONLINE); <line19> executionJob = <line20> scheduler.scheduleWithFixedDelay( <line21> this::refreshFolderInformation, <line22> config.pollIntervalLocal, <line23> config.pollIntervalLocal, <line24> TimeUnit.SECONDS); <line25> } else { <line26> updateStatus( <line27> ThingStatus.OFFLINE, <line28> ThingStatusDetail.CONFIGURATION_ERROR, <line29> ""Polling interval can't be null or negative""); <line30> return; <line31> } <line32> } <line33> } <line34> "	"<line15>      logger.debug(""Can't write file {}: {}"", currentLocalListingFile, e.getMessage());"	task4	
"public class A { <line0> @Override <line1> @Deprecated <line2> public void visit(Iterable<? extends Element> elements, GraphVisitor visitor) { <line3> int i = 0; <line4> for (Element element : elements) { <line5> if (i % 1000000 == 0) { <line6> } <line7> visitor.visitElement(element); <line8> if (element instanceof Vertex) { <line9> visitor.visitVertex((Vertex) element); <line10> } else if (element instanceof Edge) { <line11> visitor.visitEdge((Edge) element); <line12> } else { <line13> throw new VertexiumException( <line14> ""Invalid element type to visit: "" + element.getClass().getName()); <line15> } <line16> for (Property property : element.getProperties()) { <line17> visitor.visitProperty(element, property); <line18> } <line19> for (String tableName : element.getExtendedDataTableNames()) { <line20> for (ExtendedDataRow extendedDataRow : element.getExtendedData(tableName)) { <line21> visitor.visitExtendedDataRow(element, tableName, extendedDataRow); <line22> for (Property property : extendedDataRow.getProperties()) { <line23> visitor.visitProperty(element, tableName, extendedDataRow, property); <line24> } <line25> } <line26> } <line27> i++; <line28> } <line29> } <line30> } <line31> "	"<line6>        LOGGER.debug(""checking: %s"", element.getId());"	task4	
public class A { <line0> private void recordAudit(HttpServletRequest httpRequest, String whenISO9601) { <line1> final String who = getUserFromRequest(httpRequest); <line2> final String fromHost = httpRequest.getRemoteHost(); <line3> final String fromAddress = httpRequest.getRemoteAddr(); <line4> final String whatURL = Servlets.getRequestURL(httpRequest); <line5> final String whatAddrs = httpRequest.getLocalAddr(); <line6> GenericAlert.audit(who, fromAddress, fromHost, whatURL, whatAddrs, whenISO9601); <line7> } <line8> } <line9> 	"<line6>    LOG.debug(""Audit: {}/{} performed request {} ({}) at time {}"",who,fromAddress,whatURL,whatAddrs,whenISO9601);"	task4	
"public class A { <line0> @Path(""/getMetadataShouldSucceed"") <line1> @POST <line2> public void getMetadataShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, SwiftConstants.GET_METADATA); <line4> Map<?, ?> metadata = <line5> template.requestBodyAndHeader( <line6> uri, null, SwiftConstants.CONTAINER_NAME, CONTAINER_NAME, Map.class); <line7> assertNotNull(metadata); <line8> assertEquals(""2000"", metadata.get(NAME_YEAR)); <line9> assertEquals(""TestBook"", metadata.get(NAME_BOOK)); <line10> } <line11> } <line12> "	"<line3>    LOG.debug(""Calling OpenstackSwiftContainerResource.getMetadataShouldSucceed()"");"	task4	
public class A { <line0> @Override <line1> public void deserialize(ByteBuffer buffer) { <line2> String pathString = readString(buffer); <line3> try { <line4> path = new PartialPath(pathString); <line5> } catch (IllegalPathException e) { <line6> } <line7> index = buffer.getLong(); <line8> } <line9> } <line10> 	"<line6>      logger.error(""Failed to deserialize device {} from buffer"", pathString);"	task4	
public class A { <line0> @Override <line1> public boolean isActive() { <line2> try { <line3> Mongo mongo = this.createNewMongo(getProperties()); <line4> return mongo != null; <line5> } catch (Exception e) { <line6> return false; <line7> } <line8> } <line9> } <line10> 	"<line6>      log.error(""Error in checking Mongo config availability"", e);"	task4	
"public class A { <line0> public void testGetFile() throws Exception { <line1> ByteArrayContainerResponseWriter writer = new ByteArrayContainerResponseWriter(); <line2> String requestPath = SERVICE_URI + ""item/"" + fileId; <line3> ContainerResponse response = <line4> launcher.service(HttpMethod.GET, requestPath, BASE_URI, null, null, writer, null); <line5> assertEquals(""Error: "" + response.getEntity(), 200, response.getStatus()); <line6> Item item = (Item) response.getEntity(); <line7> assertEquals(ItemType.FILE, item.getItemType()); <line8> assertEquals(fileId, item.getId()); <line9> assertEquals(filePath, item.getPath()); <line10> validateLinks(item); <line11> } <line12> } <line13> "	<line5>    log.info(new String(writer.getBody()));	task4	
public class A { <line0> @Override <line1> public Map<String, SctId> register(final Set<String> componentIds) { <line2> if (CompareUtils.isEmpty(componentIds)) { <line3> return Collections.emptyMap(); <line4> } <line5> final Map<String, SctId> sctIds = getSctIds(componentIds); <line6> final Map<String, SctId> availableOrReservedSctIds = <line7> ImmutableMap.copyOf( <line8> Maps.filterValues(sctIds, Predicates.or(SctId::isAvailable, SctId::isReserved))); <line9> for (final SctId sctId : availableOrReservedSctIds.values()) { <line10> sctId.setStatus(IdentifierStatus.ASSIGNED.getSerializedName()); <line11> } <line12> putSctIds(availableOrReservedSctIds); <line13> return ImmutableMap.copyOf(sctIds); <line14> } <line15> } <line16> 	"<line5>    LOGGER.debug(""Registering {} component IDs."", componentIds.size());"	task4	
"public class A { <line0> public void setMatchAllMappings(List<String> list) { <line1> String[] values; <line2> matchAllMap.clear(); <line3> if (list != null) { <line4> for (String mapping : list) { <line5> values = mapping.split(""=""); <line6> if (values.length == 2) { <line7> securityLogger.audit( <line8> ""Adding mapping: {} = {} to matchAllMap."", values[1].trim(), values[0].trim()); <line9> matchAllMap.put(values[1].trim(), values[0].trim()); <line10> } else { <line11> } <line12> } <line13> } <line14> } <line15> } <line16> "	"<line11>          LOGGER.warn(""Match all mapping ignored: {} doesn't match expected format of""+ "" metacardAttribute=userAttribute"",mapping);"	task4	
"public class A { <line0> private void processOrderByClause( <line1> TermsBuilder termsBuilder, <line2> Expression orderByExpression, <line3> Expression groupByClause, <line4> EntityMetadata entityMetadata) { <line5> Expression orderByClause = (OrderByClause) orderByExpression; <line6> OrderByItem orderByItems = (OrderByItem) ((OrderByClause) orderByClause).getOrderByItems(); <line7> if (orderByClause instanceof CollectionExpression <line8> || !(orderByItems <line9> .getExpression() <line10> .toParsedText() <line11> .equalsIgnoreCase(groupByClause.toParsedText()))) { <line12> throw new UnsupportedOperationException( <line13> ""Order by and group by on different field are not supported simultaneously""); <line14> } <line15> String ordering = orderByItems.getOrdering().toString(); <line16> termsBuilder.order(Terms.Order.term(!ordering.equalsIgnoreCase(Expression.DESC))); <line17> } <line18> } <line19> "	"<line12>      logger.error(""Order by and group by on different field are not supported simultaneously"");"	task4	
"public class A { <line0> @WithMockUser(username = USERNAME) <line1> @SuppressWarnings({""OptionalGetWithoutIsPresent""}) <line2> @Test <line3> void testCopyEntityType() { <line4> String targetPackageId = ""target2""; <line5> addTargetPackage(targetPackageId); <line6> ResourceIdentifier id = ResourceIdentifier.create(ResourceType.ENTITY_TYPE, ENTITY_TYPE_A); <line7> TestProgress progress = new TestProgress(); <line8> copyService.copy(singletonList(id), targetPackageId, progress); <line9> await().atMost(5, TimeUnit.SECONDS).until(copyJobFinished(progress)); <line10> waitForWorkToBeFinished(indexService, LOG); <line11> Package targetPackage = metadataService.getPackage(targetPackageId).get(); <line12> List<Package> packages = newArrayList(targetPackage.getChildren()); <line13> List<EntityType> entityTypes = newArrayList(targetPackage.getEntityTypes()); <line14> assertEquals(0, packages.size()); <line15> assertEquals(1, entityTypes.size()); <line16> EntityType entityTypeACopy = entityTypes.get(0); <line17> assertEquals(""EntityType A"", entityTypeACopy.getLabel()); <line18> assertEquals(ENTITY_TYPE_B, entityTypeA.getAttribute(""xref_attr"").getRefEntity().getId()); <line19> assertEquals(ENTITY_TYPE_B, entityTypeACopy.getAttribute(""xref_attr"").getRefEntity().getId()); <line20> assertEquals(1, progress.getProgress()); <line21> List<Object> entitiesOfA = <line22> dataService.findAll(entityTypeACopy.getId()).map(Entity::getIdValue).collect(toList()); <line23> assertEquals(asList(""0"", ""1"", ""2""), entitiesOfA); <line24> cleanupTargetPackage(targetPackageId); <line25> } <line26> } <line27> "	"<line10>    LOG.info(""Copy job progress: {}/{}"", progress.getProgress(), progress.getProgressMax());"	task4	
public class A { <line0> @Override <line1> public void destroyFavorite(final long id) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(DESTROY_FAVORITE, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> Status status = twitter.destroyFavorite(id); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.destroyedFavorite(status); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at destroyFavorite"", e);"	task4	
public class A { <line0> @Override <line1> public void run(ExternalContext externalContext) { <line2> Thread.setDefaultUncaughtExceptionHandler( <line3> new SamzaUncaughtExceptionHandler( <line4> () -> { <line5> System.exit(1); <line6> })); <line7> ContainerLaunchUtil.run( <line8> appDesc, System.getenv(ShellCommandConfig.ENV_CONTAINER_ID), ContainerCfgLoader.jobModel); <line9> } <line10> } <line11> 	"<line5>              LOG.info(""Exiting process now."");"	task4	
public class A { <line0> public void agentLost(Protos.AgentID agentId) { <line1> agentAndRackManager.agentLost(agentId); <line2> } <line3> } <line4> 	"<line1>    LOG.warn(""Lost a agent {}"", agentId);"	task4	
"public class A { <line0> @Override <line1> public synchronized void registerChannelListener( <line2> final String channelName, final ChannelListener channelListener) throws KuraException { <line3> requireNonNull(channelName, ""Channel name cannot be null""); <line4> requireNonNull(channelListener, ""Asset Listener cannot be null""); <line5> final Map<String, Channel> channels = this.config.getAssetConfiguration().getAssetChannels(); <line6> final Channel channel = channels.get(channelName); <line7> if (channel == null) { <line8> throw new IllegalArgumentException(""Channel not found""); <line9> } <line10> final ChannelListenerRegistration reg = <line11> new ChannelListenerRegistration(channelName, channelListener); <line12> if (this.channelListeners.contains(reg)) { <line13> return; <line14> } <line15> this.channelListeners.add(reg); <line16> final DriverState state = this.driverState.get(); <line17> if (state == null) { <line18> return; <line19> } <line20> this.executor.runConfig(() -> state.syncChannelListeners(this.channelListeners, channels)); <line21> } <line22> } <line23> "	"<line5>    logger.debug(""Registering Channel Listener for monitoring..."");"	task4	
public class A { <line0> @Override <line1> public void process(WatchedEvent watchedEvent) { <line2> synchronized (this) { <line3> this.watchedEvent = watchedEvent; <line4> } <line5> } <line6> } <line7> 	"<line3>      LOGGER.info(""process() event:{}"", watchedEvent);"	task4	
"public class A { <line0> private User getUserBySSO(String token) throws ServletException { <line1> try { <line2> String response = <line3> HttpJsonHelper.requestString( <line4> apiEndPoint + ""/internal/sso/server/"" + token, <line5> ""GET"", <line6> null, <line7> Pair.of(""clienturl"", URLEncoder.encode(apiEndPoint, ""UTF-8""))); <line8> JsonValue value = JsonHelper.parseJson(response); <line9> return new UserImpl( <line10> value.getElement(""name"").getStringValue(), <line11> value.getElement(""id"").getStringValue(), <line12> value.getElement(""token"").getStringValue(), <line13> Collections.<String>emptySet(), <line14> value.getElement(""temporary"").getBooleanValue()); <line15> } catch (ForbiddenException | UnauthorizedException | ServerException un) { <line16> return null; <line17> } catch (ConflictException | NotFoundException | IOException | JsonParseException e) { <line18> throw new ServletException(e.getMessage(), e); <line19> } <line20> } <line21> } <line22> "	<line18>      LOG.warn(e.getLocalizedMessage());	task4	
"public class A { <line0> @ApiOperation(value = ""get history by profile's id"") <line1> @GetMapping(CommonConstants.PATH_LOGBOOK) <line2> public LogbookOperationsResponseDto findHistoryById(final @PathVariable String id) { <line3> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line4> return service.findHistoryById(buildUiHttpContext(), id); <line5> } <line6> } <line7> "	"<line3>    LOGGER.debug(""get logbook for profile with id :{}"", id);"	task4	
"public class A { <line0> protected Future<Message> processRegisterCommandConsumer( <line1> final Message request, <line2> final ResourceIdentifier targetAddress, <line3> final SpanContext spanContext) { <line4> final String tenantId = targetAddress.getTenantId(); <line5> final String deviceId = MessageHelper.getDeviceId(request); <line6> final String adapterInstanceId = <line7> MessageHelper.getApplicationProperty( <line8> request.getApplicationProperties(), <line9> MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, <line10> String.class); <line11> final Integer lifespanSecondsOrNull = <line12> MessageHelper.getApplicationProperty( <line13> request.getApplicationProperties(), MessageHelper.APP_PROPERTY_LIFESPAN, Integer.class); <line14> final Span span = <line15> TracingHelper.buildServerChildSpan( <line16> tracer, <line17> spanContext, <line18> SPAN_NAME_REGISTER_COMMAND_CONSUMER, <line19> getClass().getSimpleName()) <line20> .start(); <line21> final Future<Message> resultFuture; <line22> if (tenantId == null || deviceId == null || adapterInstanceId == null) { <line23> TracingHelper.logError(span, ""missing tenant, device and/or adapter instance id""); <line24> resultFuture = <line25> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST)); <line26> } else { <line27> final Duration lifespan = <line28> lifespanSecondsOrNull != null <line29> ? Duration.ofSeconds(lifespanSecondsOrNull) <line30> : Duration.ofSeconds(-1); <line31> TracingHelper.TAG_TENANT_ID.set(span, tenantId); <line32> TracingHelper.TAG_DEVICE_ID.set(span, deviceId); <line33> span.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId); <line34> span.setTag(MessageHelper.APP_PROPERTY_LIFESPAN, lifespan.getSeconds()); <line35> resultFuture = <line36> getService() <line37> .registerCommandConsumer(tenantId, deviceId, adapterInstanceId, lifespan, span) <line38> .map( <line39> res -> <line40> CommandRouterConstants.getAmqpReply( <line41> CommandRouterConstants.COMMAND_ROUTER_ENDPOINT, tenantId, request, res)); <line42> } <line43> return finishSpanOnFutureCompletion(span, resultFuture); <line44> } <line45> } <line46> "	"<line35>      logger.debug(""register command consumer [tenant-id: {}, device-id: {}, adapter-instance-id {},""+ "" lifespan: {}s]"",tenantId,deviceId,adapterInstanceId,lifespan.getSeconds());"	task4	
public class A { <line0> @Override <line1> public Set<String> queryNames() { <line2> long start = System.currentTimeMillis(); <line3> Set<String> names = <line4> withAllReams( <line5> realm -> { <line6> try { <line7> return realm <line8> .getDirectory() <line9> .query(type, null, null, TypeMapping.SearchScope.SUBTREE) <line10> .stream(); <line11> } catch (DirectoryException e) { <line12> throw new RuntimeException(e); <line13> } <line14> }) <line15> .collect(Collectors.toSet()); <line16> return names; <line17> } <line18> } <line19> 	"<line16>    LOGGER.debug(type.getSimpleName() + ""-queryNames took "" + (System.currentTimeMillis() - start) + ""ms"");"	task4	
public class A { <line0> private void createOrUpdateIndexerSearchEnties(SearchCacheEntry searchCacheEntry) { <line1> Stopwatch stopwatch = Stopwatch.createStarted(); <line2> int countEntities = 0; <line3> for (IndexerSearchCacheEntry indexerSearchCacheEntry : <line4> searchCacheEntry.getIndexerCacheEntries().values()) { <line5> for (IndexerSearchResult indexerSearchResult : <line6> indexerSearchCacheEntry.getIndexerSearchResults()) { <line7> IndexerSearchEntity entity = indexerSearchCacheEntry.getIndexerSearchEntity(); <line8> if (entity == null) { <line9> entity = new IndexerSearchEntity(); <line10> entity.setIndexerEntity(indexerSearchResult.getIndexer().getIndexerEntity()); <line11> entity.setSearchEntity(searchCacheEntry.getSearchEntity()); <line12> entity.setResultsCount(indexerSearchResult.getTotalResults()); <line13> entity.setSuccessful(indexerSearchResult.isWasSuccessful()); <line14> indexerSearchCacheEntry.setIndexerSearchEntity(entity); <line15> } <line16> if (configProvider.getBaseConfig().getMain().isKeepHistory()) { <line17> entity = indexerSearchRepository.save(entity); <line18> for (SearchResultEntity x : indexerSearchResult.getSearchResultEntities()) { <line19> x.setIndexerSearchEntity(entity); <line20> } <line21> } <line22> searchResultRepository.saveAll(indexerSearchResult.getSearchResultEntities()); <line23> searchCacheEntry <line24> .getIndexerCacheEntries() <line25> .get(indexerSearchResult.getIndexer()) <line26> .setIndexerSearchEntity(entity); <line27> countEntities++; <line28> } <line29> } <line30> } <line31> } <line32> 	"<line30>    logger.debug(LoggingMarkers.PERFORMANCE,""Saving {} indexer search entities took {}ms"",countEntities,stopwatch.elapsed(TimeUnit.MILLISECONDS));"	task4	
"public class A { <line0> @Override <line1> protected Collection<ValidationResult> customValidate(final ValidationContext context) { <line2> Collection<ValidationResult> commonValidationResults = super.customValidate(context); <line3> if (!commonValidationResults.isEmpty()) { <line4> return commonValidationResults; <line5> } <line6> scriptingComponentHelper.setScriptEngineName( <line7> context.getProperty(scriptingComponentHelper.SCRIPT_ENGINE).getValue()); <line8> scriptingComponentHelper.setScriptPath( <line9> context <line10> .getProperty(ScriptingComponentUtils.SCRIPT_FILE) <line11> .evaluateAttributeExpressions() <line12> .getValue()); <line13> scriptingComponentHelper.setScriptBody( <line14> context.getProperty(ScriptingComponentUtils.SCRIPT_BODY).getValue()); <line15> String modulePath = context.getProperty(ScriptingComponentUtils.MODULES).getValue(); <line16> if (!StringUtils.isEmpty(modulePath)) { <line17> scriptingComponentHelper.setModules(modulePath.split("","")); <line18> } else { <line19> scriptingComponentHelper.setModules(new String[0]); <line20> } <line21> setup(); <line22> final Processor instance = processor.get(); <line23> final Collection<ValidationResult> currentValidationResults = validationResults.get(); <line24> if (currentValidationResults.isEmpty() && instance != null) { <line25> try { <line26> final Collection<ValidationResult> instanceResults = instance.validate(context); <line27> if (instanceResults != null && instanceResults.size() > 0) { <line28> return instanceResults; <line29> } <line30> } catch (final Exception e) { <line31> final ComponentLog logger = getLogger(); <line32> final String message = ""Unable to validate the script Processor: "" + e; <line33> final Collection<ValidationResult> results = new HashSet<>(); <line34> results.add( <line35> new ValidationResult.Builder() <line36> .subject(""Validation"") <line37> .valid(false) <line38> .explanation( <line39> ""An error occurred calling validate in the configured script Processor."") <line40> .input(context.getProperty(ScriptingComponentUtils.SCRIPT_FILE).getValue()) <line41> .build()); <line42> return results; <line43> } <line44> } <line45> return currentValidationResults; <line46> } <line47> } <line48> "	<line33>        logger.error(message, e);	task4	
"public class A { <line0> private void checkLengthConsistency() { <line1> Document document = getCachedDocument(); <line2> if (document instanceof DocumentWindow) { <line3> return; <line4> } <line5> if (document != null <line6> && ((PsiDocumentManagerBase) PsiDocumentManager.getInstance(myManager.getProject())) <line7> .getSynchronizer() <line8> .isInSynchronization(document)) { <line9> return; <line10> } <line11> List<FileElement> knownTreeRoots = getKnownTreeRoots(); <line12> if (knownTreeRoots.isEmpty()) return; <line13> int fileLength = myContent.getTextLength(); <line14> for (FileElement fileElement : knownTreeRoots) { <line15> int nodeLength = fileElement.getTextLength(); <line16> if (!isDocumentConsistentWithPsi(fileLength, fileElement, nodeLength)) { <line17> PsiUtilCore.ensureValid(fileElement.getPsi()); <line18> List<Attachment> attachments = <line19> ContainerUtil.newArrayList( <line20> new Attachment(myVirtualFile.getName(), myContent.getText().toString()), <line21> new Attachment( <line22> myVirtualFile.getNameWithoutExtension() + "".tree.txt"", fileElement.getText())); <line23> if (document != null) { <line24> attachments.add( <line25> new Attachment( <line26> myVirtualFile.getNameWithoutExtension() + "".document.txt"", document.getText())); <line27> } <line28> } <line29> } <line30> } <line31> } <line32> "	"<line28>        LOG.error(""Inconsistent ""+ fileElement.getElementType()+ "" tree in ""+ this+ ""; nodeLength=""+ nodeLength+ ""; fileLength=""+ fileLength,attachments.toArray(Attachment.EMPTY_ARRAY));"	task4	
public class A { <line0> private static String resolveLocalHostname() { <line1> String localhost; <line2> try { <line3> localhost = InetAddress.getLocalHost().getCanonicalHostName(); <line4> } catch (UnknownHostException e) { <line5> localhost = LOCALHOST; <line6> } <line7> return localhost; <line8> } <line9> } <line10> 	"<line5>      LOG.warn(""Unable to determine local hostname "" + ""-falling back to \"""" + LOCALHOST + ""\"""", e);"	task4	
public class A { <line0> private void setClientRecordCipher(Tls13KeySetType keySetType) { <line1> tlsContext.setActiveClientKeySetType(keySetType); <line2> KeySet clientKeySet = getKeySet(tlsContext, tlsContext.getActiveClientKeySetType()); <line3> RecordCipher recordCipherClient = <line4> RecordCipherFactory.getRecordCipher( <line5> tlsContext, clientKeySet, tlsContext.getChooser().getSelectedCipherSuite()); <line6> tlsContext.getRecordLayer().setRecordCipher(recordCipherClient); <line7> if (tlsContext.getChooser().getConnectionEndType() == ConnectionEndType.SERVER) { <line8> tlsContext.setReadSequenceNumber(0); <line9> tlsContext.getRecordLayer().updateDecryptionCipher(); <line10> } else { <line11> tlsContext.setWriteSequenceNumber(0); <line12> tlsContext.getRecordLayer().updateEncryptionCipher(); <line13> } <line14> } <line15> } <line16> 	"<line2>    LOGGER.debug(""Setting cipher for client to use "" + keySetType);"	task4	
public class A { <line0> private void writeSessionIdHit(SSL2ServerHelloMessage message) { <line1> appendByte(message.getSessionIdHit().getValue()); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""SessionIdHit: "" + message.getSessionIdHit().getValue());"	task4	
"public class A { <line0> private void sendNotification(long entityId, String templateId) { <line1> if (templateId == null) return; <line2> try { <line3> EntityParam recipient = new EntityParam(entityId); <line4> String entityName = getEntityLabel(recipient); <line5> Map<String, String> params = new HashMap<>(); <line6> params.put(UserNotificationTemplateDef.USER, entityName == null ? """" : entityName); <line7> notificationProducer.sendNotification( <line8> recipient, templateId, params, cfg.getDefaultLocale().toString(), null, false); <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> "	"<line10>      log.warn(""Unable to send notification using template "" + templateId + "" to entity "" + entityId, e);"	task4	
"public class A { <line0> @Override <line1> public List<String> searchIdeas( <line2> String instanceCode, Integer status, String text, String category, Integer order) <line3> throws ApsSystemException { <line4> List<String> list = new ArrayList<String>(); <line5> try { <line6> list = this.getIdeaDAO().searchIdea(instanceCode, status, text, category, order); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error in searchIdeas"", t); <line9> } <line10> return list; <line11> } <line12> } <line13> "	"<line8>      logger.error(""Error in searchIdeas"", t);"	task4	
"public class A { <line0> static Optional<EndpointBuilder> lookup(String builder) { <line1> try { <line2> EndpointBuilder instance; <line3> if (builder.contains(""."")) { <line4> int separatorIndex = builder.lastIndexOf('.'); <line5> instance = <line6> TYPE_RESOLVER.resolve( <line7> builder.substring(0, separatorIndex), builder.substring(separatorIndex + 1)); <line8> } else { <line9> instance = TYPE_RESOLVER.resolve(builder); <line10> } <line11> return Optional.of(instance); <line12> } catch (CitrusRuntimeException e) { <line13> } <line14> return Optional.empty(); <line15> } <line16> } <line17> "	"<line13>      LOG.warn(String.format(""Failed to resolve endpoint builder from resource '%s/%s'"", RESOURCE_PATH, builder));"	task4	
"public class A { <line0> private static String loadFromSftp(Map<String, Object> config, String fileName) { <line1> String remoteDir = MapUtils.getString(config, KEY_REMOTE_DIR); <line2> String filePathOnSftp = remoteDir + ""/"" + fileName; <line3> String localDirName = Md5Util.getMd5(remoteDir); <line4> String localDir = LOCAL_CACHE_DIR + SP + localDirName; <line5> localDir = createDir(localDir); <line6> String fileLocalPath = localDir + SP + fileName; <line7> if (fileExists(fileLocalPath)) { <line8> delectFile(fileLocalPath); <line9> } <line10> SftpHandler handler = null; <line11> try { <line12> handler = SftpHandler.getInstanceWithRetry(MapUtils.getMap(config, KEY_SFTP_CONF)); <line13> if (handler.isFileExist(filePathOnSftp)) { <line14> handler.downloadFileWithRetry(filePathOnSftp, fileLocalPath); <line15> return fileLocalPath; <line16> } <line17> } catch (Exception e) { <line18> throw new RuntimeException(e); <line19> } finally { <line20> if (handler != null) { <line21> handler.close(); <line22> } <line23> } <line24> throw new RuntimeException(""File["" + filePathOnSftp + ""] not exist on sftp""); <line25> } <line26> } <line27> "	"<line15>        LOG.info(""download file:{} to local:{}"", filePathOnSftp, fileLocalPath);"	task4	
public class A { <line0> @Override <line1> public String getCanonicalURL(Layout layout, Locale locale) { <line2> Optional<ThemeDisplay> themeDisplayOptional = _getThemeDisplayOptional(); <line3> return themeDisplayOptional <line4> .map( <line5> themeDisplay -> { <line6> try { <line7> String canonicalURL = <line8> _portal.getCanonicalURL( <line9> _getCompleteURL(themeDisplay), themeDisplay, layout, false, false); <line10> LayoutSEOLink layoutSEOLink = <line11> _layoutSEOLinkManager.getCanonicalLayoutSEOLink( <line12> layout, <line13> locale, <line14> canonicalURL, <line15> _portal.getAlternateURLs(canonicalURL, themeDisplay, layout)); <line16> return layoutSEOLink.getHref(); <line17> } catch (PortalException portalException) { <line18> return StringPool.BLANK; <line19> } <line20> }) <line21> .orElse(StringPool.BLANK); <line22> } <line23> } <line24> 	<line18>                log.error(portalException, portalException);	task4	
public class A { <line0> @Override <line1> public boolean isFull() { <line2> if (offHeapQueue == null) { <line3> int remaining = inMemoryQueue.remainingCapacity(); <line4> return remaining <= 0; <line5> } <line6> return fileCapacityLatch.isFull(); <line7> } <line8> } <line9> 	"<line4>      LOG.trace(""Checked if full and remaining capacity is {}"", remaining);"	task4	
"public class A { <line0> @Override <line1> public ConnectionTestResult runTests(final List<TestType> testTypes) throws JargonException { <line2> if (testTypes == null || testTypes.isEmpty()) { <line3> throw new IllegalArgumentException(""null or empty testTypes""); <line4> } <line5> ConnectionTestResult testResult = new ConnectionTestResult(); <line6> testResult.setConfiguration(connectionTesterConfiguration); <line7> testResult.setIrodsAccount(getIrodsAccount()); <line8> for (TestType testType : testTypes) { <line9> List<TestResultEntry> individualTestResults = processTest(testType); <line10> testResult.getTestResults().addAll(individualTestResults); <line11> } <line12> return testResult; <line13> } <line14> } <line15> "	"<line2>    log.info(""runTests{}"");"	task4	
public class A { <line0> protected void createUser(String username) { <line1> UserManager userManager = UserManager.getInstance(); <line2> try { <line3> userManager.getUser(username); <line4> } catch (UserNotFoundException unfe) { <line5> try { <line6> UserManager.getUserProvider().createUser(username, StringUtils.randomString(8), null, null); <line7> } catch (UserAlreadyExistsException uaee) { <line8> } <line9> } <line10> } <line11> } <line12> 	"<line6>        Log.debug(""JDBCAuthProvider: Automatically creating new user account for "" + username);"	task4	
public class A { <line0> public void initScannerCommons() { <line1> kuduConsumerExecutor = Executors.newFixedThreadPool(threadPoolExecutorSize); <line2> List<KuduPartitionScanAssignmentMeta> allPartitionsThatNeedScan = <line3> parentOperator.getPartitionPieAssignment(); <line4> Collections.sort( <line5> allPartitionsThatNeedScan, <line6> new Comparator<KuduPartitionScanAssignmentMeta>() { <line7> @Override <line8> public int compare( <line9> KuduPartitionScanAssignmentMeta left, KuduPartitionScanAssignmentMeta right) { <line10> return left.getOrdinal() - right.getOrdinal(); <line11> } <line12> }); <line13> for (int i = 0; i < threadPoolExecutorSize; i++) { <line14> connectionPoolForThreads.put(i, apexKuduConnectionInfo.build()); <line15> } <line16> } <line17> } <line18> 	"<line16>    LOG.info(""Scanner running with "" + connectionPoolForThreads.size() + "" kudu connections"");"	task4	
"public class A { <line0> @Transactional <line1> public void createVoucherfromPreApprovedVoucher(final long vouhcerheaderid) <line2> throws ApplicationRuntimeException { <line3> String voucherStatus = null; <line4> try { <line5> final List vStatusList = <line6> appConfigValuesService.getConfigValuesByModuleAndKey(""EGF"", ""APPROVEDVOUCHERSTATUS""); <line7> if (!vStatusList.isEmpty() && vStatusList.size() == 1) { <line8> final AppConfigValues appVal = (AppConfigValues) vStatusList.get(0); <line9> voucherStatus = appVal.getValue(); <line10> } else throw new ApplicationRuntimeException(""APPROVEDVOUCHERSTATUS"" + MISSINGMSG); <line11> createVoucher.createVoucherFromPreApprovedVoucher(vouhcerheaderid, voucherStatus); <line12> } catch (final ApplicationRuntimeException e) { <line13> throw new ApplicationRuntimeException(e.getMessage()); <line14> } <line15> } <line16> } <line17> "	<line13>      LOGGER.error(e.getMessage());	task4	
"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> int nodeIdx = restartNodeIdx.getAndIncrement(); <line3> Thread.currentThread().setName(""restart-thread-"" + nodeIdx); <line4> boolean clientMode = clientNode.compareAndSet(false, true); <line5> while (U.currentTimeMillis() < stopTime) { <line6> if (clientMode) client.set(true); <line7> try { <line8> Ignite ignite = startGrid(nodeIdx); <line9> IgniteCache<Object, Object> cache; <line10> if (clientMode && ccfg.getNearConfiguration() != null) <line11> cache = ignite.createNearCache(ccfg.getName(), new NearCacheConfiguration<>()); <line12> else cache = ignite.cache(ccfg.getName()); <line13> checkGet(cache); <line14> IgniteInternalFuture<?> syncFut = <line15> ((IgniteCacheProxy) cache).context().preloader().syncFuture(); <line16> while (!syncFut.isDone() && U.currentTimeMillis() < stopTime) checkGet(cache); <line17> checkGet(cache); <line18> } finally { <line19> stopGrid(nodeIdx); <line20> } <line21> } <line22> return null; <line23> } <line24> } <line25> "	"<line7>      log.info(""Restart node [node="" + nodeIdx + "", client="" + clientMode + ']');"	task4	
public class A { <line0> @Override <line1> public ZeebeDb openDb() { <line2> if (db == null) { <line3> db = zeebeDbFactory.createDb(runtimeDirectory.toFile()); <line4> } <line5> return db; <line6> } <line7> } <line8> 	"<line4>      LOG.debug(""Opened database from '{}'."", runtimeDirectory);"	task4	
public class A { <line0> @Override <line1> protected void doFilterInternal( <line2> HttpServletRequest req, HttpServletResponse resp, FilterChain chain) <line3> throws IOException, ServletException { <line4> String token = CSRFToken.getToken(req); <line5> if (token == null) { <line6> token = UUID.randomUUID().toString(); <line7> CSRFToken.setToken(req, token); <line8> } <line9> resp.setHeader(CSRF_TOKEN_HEADER, token); <line10> if (mustCheckCSRF(req)) { <line11> ImmutablePair<Boolean, ImmutablePair<Integer, String>> res = checkCSRF(req); <line12> if (!res.left) { <line13> resp.sendError(res.right.left, res.right.right); <line14> return; <line15> } <line16> } <line17> chain.doFilter(req, resp); <line18> } <line19> } <line20> 	"<line13>        LOG.info(""wrong csrf"");"	task4	
"public class A { <line0> public static void main(final String[] args) { <line1> EnvironmentInformation.logEnvironmentInfo(LOG, ""Command Line Client"", args); <line2> final String configurationDirectory = getConfigurationDirectoryFromEnv(); <line3> final Configuration configuration = <line4> GlobalConfiguration.loadConfiguration(configurationDirectory); <line5> final List<CustomCommandLine> customCommandLines = <line6> loadCustomCommandLines(configuration, configurationDirectory); <line7> int retCode = 31; <line8> try { <line9> final CliFrontend cli = new CliFrontend(configuration, customCommandLines); <line10> SecurityUtils.install(new SecurityConfiguration(cli.configuration)); <line11> retCode = SecurityUtils.getInstalledContext().runSecured(() -> cli.parseAndRun(args)); <line12> } catch (Throwable t) { <line13> final Throwable strippedThrowable = <line14> ExceptionUtils.stripException(t, UndeclaredThrowableException.class); <line15> strippedThrowable.printStackTrace(); <line16> } finally { <line17> System.exit(retCode); <line18> } <line19> } <line20> } <line21> "	"<line15>      LOG.error(""Fatal error while running command line interface."", strippedThrowable);"	task4	
public class A { <line0> private static boolean isPassthrough(String hcid) { <line1> String propertyName; <line2> NhincConstants.UDDI_SPEC_VERSION specVersion = getOrganizationSpecVersion(hcid); <line3> if (specVersion.equals(NhincConstants.UDDI_SPEC_VERSION.SPEC_2_0)) { <line4> propertyName = DOC_QUERY_20_MODE_OUT_PROPNAME; <line5> } else { <line6> propertyName = DOC_QUERY_30_MODE_OUT_PROPNAME; <line7> } <line8> String propValue = null; <line9> try { <line10> propValue = getPropAccessor().getProperty(NhincConstants.GATEWAY_PROPERTY_FILE, propertyName); <line11> } catch (PropertyAccessException ex) { <line12> } <line13> return NullChecker.isNotNullish(propValue); <line14> } <line15> } <line16> 	"<line12>      LOG.warn(""Unable to read property: {})"", propertyName, ex);"	task4	
"public class A { <line0> private Object convertAvroUnionToOrientDBField( <line1> final String docf, <line2> final Schema fieldSchema, <line3> final OrientDBMapping.DocumentFieldType storeType, <line4> final Object value) { <line5> Object result; <line6> Schema.Type type0 = fieldSchema.getTypes().get(0).getType(); <line7> Schema.Type type1 = fieldSchema.getTypes().get(1).getType(); <line8> if (!type0.equals(type1) <line9> && (type0.equals(Schema.Type.NULL) || type1.equals(Schema.Type.NULL))) { <line10> Schema innerSchema = null; <line11> if (type0.equals(Schema.Type.NULL)) { <line12> innerSchema = fieldSchema.getTypes().get(1); <line13> } else { <line14> innerSchema = fieldSchema.getTypes().get(0); <line15> } <line16> result = <line17> convertAvroFieldToOrientField(docf, innerSchema, innerSchema.getType(), storeType, value); <line18> } else { <line19> throw new IllegalStateException(""OrientDBStore only supports Union of two types field.""); <line20> } <line21> return result; <line22> } <line23> } <line24> "	"<line16>      LOG.debug(""Transform value to ODocument (UNION), type:{}, storeType:{}"",new Object[] {innerSchema.getType(), type1, storeType});"	task4	
public class A { <line0> @Override <line1> public org.fcrepo.server.types.gen.FieldSearchResult findObjects( <line2> org.fcrepo.server.types.gen.ArrayOfString resultFields, <line3> java.math.BigInteger maxResults, <line4> org.fcrepo.server.types.gen.FieldSearchQuery query) { <line5> MessageContext ctx = context.getMessageContext(); <line6> Context context = ReadOnlyContext.getSoapContext(ctx); <line7> assertInitialized(); <line8> try { <line9> String[] resultFieldsArray = resultFields.getItem().toArray(EMPTY_STRING_ARRAY); <line10> org.fcrepo.server.search.FieldSearchResult result = <line11> m_access.findObjects( <line12> context, <line13> resultFieldsArray, <line14> maxResults.intValue(), <line15> TypeUtility.convertGenFieldSearchQueryToFieldSearchQuery(query)); <line16> return TypeUtility.convertFieldSearchResultToGenFieldSearchResult(result); <line17> } catch (Throwable th) { <line18> throw CXFUtility.getFault(th); <line19> } <line20> } <line21> } <line22> 	"<line18>      LOG.error(""Error finding objects"", th);"	task4	
public class A { <line0> @Override <line1> public boolean moveNext() { <line2> if (fetchMetrics) { <line3> currentRow = filterColumns(virtualMachineMetrics); <line4> fetchMetrics = false; <line5> return true; <line6> } else { <line7> close(); <line8> try { <line9> onFinish(); <line10> } catch (final Exception e) { <line11> } <line12> fetchMetrics = true; <line13> return false; <line14> } <line15> } <line16> } <line17> 	"<line11>        logger.error(""Failed to perform tasks when enumerator was finished"", e);"	task4	
"public class A { <line0> private Charset getEncodingParameter(String type, MinaConfiguration configuration) { <line1> String encoding = configuration.getEncoding(); <line2> if (encoding == null) { <line3> encoding = Charset.defaultCharset().name(); <line4> configuration.setEncoding(encoding); <line5> } <line6> if (!Charset.isSupported(encoding)) { <line7> throw new IllegalArgumentException(""The encoding: "" + encoding + "" is not supported""); <line8> } <line9> return Charset.forName(encoding); <line10> } <line11> } <line12> "	"<line5>      LOG.debug(""{}: No encoding parameter using default charset: {}"", type, encoding);"	task4	
"public class A { <line0> void setRedundancyZone(InternalDistributedMember member, String redundancyZone) { <line1> if (redundancyZone != null && !redundancyZone.equals("""")) { <line2> redundancyZones.put(member, redundancyZone); <line3> } <line4> if (member != getDistributionManagerId()) { <line5> String relationship = areInSameZone(getDistributionManagerId(), member) ? """" : ""not ""; <line6> } <line7> } <line8> } <line9> "	"<line6>      logger.info(""Member {} is {}equivalent or in the same redundancy zone."", member, relationship);"	task4	
public class A { <line0> @Test <line1> public void testContainerCreateDiskFull() throws Exception { <line2> long containerSize = (long) StorageUnit.MB.toBytes(100); <line3> for (HddsVolume volume : volumeSet.getVolumesList()) { <line4> volume.format(UUID.randomUUID().toString()); <line5> volume.incCommittedBytes(volume.getAvailable() - containerSize); <line6> volume.incCommittedBytes(10); <line7> } <line8> keyValueContainerData = <line9> new KeyValueContainerData( <line10> 99, <line11> layout, <line12> containerSize, <line13> UUID.randomUUID().toString(), <line14> datanodeDetails.getUuidString()); <line15> keyValueContainer = new KeyValueContainer(keyValueContainerData, conf); <line16> StorageContainerException e = <line17> LambdaTestUtils.intercept( <line18> StorageContainerException.class, <line19> () -> keyValueContainer.create(volumeSet, volumeChoosingPolicy, clusterId)); <line20> if (!DISK_OUT_OF_SPACE.equals(e.getResult())) { <line21> } <line22> assertEquals(DISK_OUT_OF_SPACE, e.getResult()); <line23> } <line24> } <line25> 	"<line21>      LOG.info(""Unexpected error during container creation"", e);"	task4	
"public class A { <line0> @Override <line1> public List<CommunicationChannel> getCommunicationChannelsForUser(String userId) <line2> throws IOException { <line3> String url = <line4> buildCanvasUrl(String.format(""users/%s/communication_channels"", userId), emptyMap()); <line5> return getListFromCanvas(url); <line6> } <line7> } <line8> "	"<line3>    LOG.debug(""Retrieving communication channels for user id "" + userId);"	task4	
"public class A { <line0> @Test <line1> public void testConfiguration() throws Exception { <line2> Method[] methods = ActiveMQResourceAdapter.class.getMethods(); <line3> Map<String, Method> methodList = new HashMap<>(); <line4> for (Method method : methods) { <line5> if (method.getName().startsWith(""set"")) { <line6> methodList.put(method.getName(), method); <line7> } <line8> } <line9> DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); <line10> DocumentBuilder db = dbf.newDocumentBuilder(); <line11> InputStream io = new ByteArrayInputStream(rootConfig.getBytes()); <line12> Document dom = db.parse(new InputSource(io)); <line13> Element docEle = dom.getDocumentElement(); <line14> NodeList nl = docEle.getElementsByTagName(""config-property""); <line15> for (int i = 0; i < nl.getLength(); i++) { <line16> Element el = (Element) nl.item(i); <line17> NodeList elementsByTagName = el.getElementsByTagName(""config-property-name""); <line18> assertEquals(el.toString(), elementsByTagName.getLength(), 1); <line19> Node configPropertyNameNode = elementsByTagName.item(0); <line20> String configPropertyName = configPropertyNameNode.getTextContent(); <line21> Method setter = methodList.remove(""set"" + configPropertyName); <line22> assertNotNull(""setter "" + configPropertyName + "" does not exist"", setter); <line23> Class c = lookupType(setter); <line24> elementsByTagName = el.getElementsByTagName(""config-property-type""); <line25> assertEquals( <line26> ""setter "" + configPropertyName + "" has no type set"", elementsByTagName.getLength(), 1); <line27> Node configPropertyTypeNode = elementsByTagName.item(0); <line28> String configPropertyTypeName = configPropertyTypeNode.getTextContent(); <line29> assertEquals(configPropertyTypeName, c.getName()); <line30> } <line31> if (!methodList.isEmpty()) { <line32> StringBuffer newConfig = new StringBuffer(commentedOutConfigs); <line33> newConfig.append(""\n""); <line34> for (Method method : methodList.values()) { <line35> newConfig.append(""         \""      <config-property>\"" + \n""); <line36> newConfig.append(""         \""         <description>***add***</description>\"" + \n""); <line37> newConfig <line38> .append(""         \""         <config-property-name>"") <line39> .append(method.getName().substring(3)) <line40> .append(""</config-property-name>\"" + \n""); <line41> newConfig <line42> .append(""         \""         <config-property-type>"") <line43> .append(lookupType(method).getName()) <line44> .append(""</config-property-type>\"" + \n""); <line45> newConfig.append( <line46> ""         \""         <config-property-value></config-property-value>\"" + \n""); <line47> newConfig.append(""         \""      </config-property>\"" + \n""); <line48> } <line49> fail(""methods not shown please see previous and add""); <line50> } <line51> } <line52> } <line53> "	<line49>      log.debug(newConfig);	task4	
"public class A { <line0> private String getDateBeforeDays(int numberOfDays) { <line1> ZonedDateTime dateBeforeTwoDays = ZonedDateTime.now().minus(Duration.ofDays(numberOfDays)); <line2> String result = DateTimeFormatter.ofPattern(""yyyy-MM-dd"").format(dateBeforeTwoDays); <line3> return result; <line4> } <line5> } <line6> "	<line3>    LOGGER.info(MessageFormat.format(Messages.PURGE_DELETE_REQUEST_SPACE_FROM_CONFIGURATION_TABLES, result));	task4	
public class A { <line0> protected void onUnexpectedStatusCode( <line1> String urlStr, int statusCode, String contentType, String description) { <line2> } <line3> } <line4> 	"<line2>    logger.warn(""Skipping URL: {}, StatusCode: {}, {}, {}"", urlStr, statusCode, contentType, description);"	task4	
public class A { <line0> private void addKeyFile(String username, String keyPairName, String filePath) { <line1> ProviderParams params = providerParamsDao.getByUser(username); <line2> params.getKeys().put(keyPairName, filePath); <line3> save(params); <line4> } <line5> } <line6> 	"<line2>    LOG.info(""{}"", params);"	task4	
public class A { <line0> private void updateMasterClock(FlushRequest request) { <line1> if (request.isUpdateClock()) { <line2> try { <line3> PSAgentContext.get() <line4> .getMasterClient() <line5> .updateClock(request.getTaskIndex(), request.getMatrixId(), request.getClock()); <line6> } catch (ServiceException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        LOG.warn(""update clock to master failed. task=""+ request.getTaskIndex()+ "", matrix=""+ request.getMatrixId()+ "", clock=""+ request.getClock());"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public Module parse(final Element root) { <line2> Namespace myNamespace = Namespace.getNamespace(ActivityStreamsModule.URI); <line3> ActivityStreamsModule myModule = new ActivityStreamsModuleImpl(); <line4> SyndEntryImpl atomEntry = new SyndEntryImpl(); <line5> Element objElement = root.getChild(""object"", myNamespace); <line6> List<Element> children = (List<Element>) objElement.getChildren(); <line7> for (Element child : children) { <line8> if (child.getName().equals(""title"")) { <line9> atomEntry.setTitle(child.getTextTrim()); <line10> } else if (child.getName().equals(""content"")) { <line11> List<SyndContent> contents = new LinkedList<SyndContent>(); <line12> SyndContent content = new SyndContentImpl(); <line13> content.setValue(child.getTextTrim()); <line14> contents.add(content); <line15> atomEntry.setContents(contents); <line16> } else if (child.getName().equals(""link"")) { <line17> atomEntry.setLink(child.getAttributeValue(""href"")); <line18> } else if (child.getName().equals(""summary"")) { <line19> SyndContent content = new SyndContentImpl(); <line20> content.setValue(child.getTextTrim()); <line21> atomEntry.setDescription(content); <line22> } else if (child.getName().equals(""object-type"")) { <line23> try { <line24> String[] objArr = child.getTextTrim().split(""/""); <line25> String objStr = objArr[objArr.length - 1].toUpperCase(); <line26> BaseObjectType.valueOf(objStr); <line27> myModule.setObjectType(objStr); <line28> } catch (IllegalArgumentException ex) { <line29> myModule.setObjectType(""NOTE""); <line30> } <line31> } <line32> } <line33> myModule.setAtomEntry(atomEntry); <line34> return myModule; <line35> } <line36> } <line37> "	"<line29>          logger.debug(""ActivityObject not valid"");"	task4	
"public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent event) { <line2> String[] options = <line3> new String[] { <line4> ""   "" + translator.getTranslation(Tags.YES) + ""   "", <line5> ""   "" + translator.getTranslation(Tags.NO) + ""   "" <line6> }; <line7> int[] optonsId = new int[] {0, 1}; <line8> StandalonePluginWorkspace wsAccess = <line9> (StandalonePluginWorkspace) PluginWorkspaceProvider.getPluginWorkspace(); <line10> int response = <line11> wsAccess.showConfirmDialog( <line12> translator.getTranslation(Tags.DISCARD), <line13> translator.getTranslation(Tags.DISCARD_CONFIRMATION_MESSAGE), <line14> options, <line15> optonsId); <line16> if (response == 0) { <line17> Set<File> foldersToRefresh = new HashSet<>(); <line18> Set<File> deletedFilesParentDirs = new HashSet<>(); <line19> String selectedRepository = OptionsManager.getInstance().getSelectedRepository(); <line20> List<FileStatus> allSelectedResources = selResProvider.getAllSelectedResources(); <line21> for (FileStatus file : allSelectedResources) { <line22> if (file.getChangeType() == GitChangeType.ADD <line23> || file.getChangeType() == GitChangeType.UNTRACKED) { <line24> try { <line25> File fileToDiscard = new File(selectedRepository, file.getFileLocation()); <line26> FileUtils.forceDelete(fileToDiscard); <line27> deletedFilesParentDirs.add(fileToDiscard.getParentFile()); <line28> } catch (IOException e1) { <line29> } <line30> } else if (file.getChangeType() == GitChangeType.SUBMODULE) { <line31> discardSubmodule(file, foldersToRefresh, selectedRepository); <line32> } <line33> } <line34> if (!deletedFilesParentDirs.isEmpty()) { <line35> foldersToRefresh.add(FileHelper.getCommonDir(deletedFilesParentDirs)); <line36> } <line37> gitController.asyncDiscard(allSelectedResources); <line38> wsAccess.getProjectManager().refreshFolders(foldersToRefresh.toArray(new File[0])); <line39> } <line40> } <line41> } <line42> "	<line29>            logger.error(e1, e1);	task4	
public class A { <line0> @Override <line1> public String getTitle() { <line2> try { <line3> return HtmlUtil.escape(_group.getDescriptiveName(_themeDisplay.getLocale())); <line4> } catch (Exception exception) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> return _group.getName(_themeDisplay.getLocale()); <line9> } <line10> } <line11> 	<line6>        log.debug(exception, exception);	task4	
public class A { <line0> public void migrate() { <line1> File migrationFolderFile = getMigrationFolderFile(); <line2> if (migrationFolderFile == null) { <line3> return; <line4> } <line5> migrateChildren(migrationFolderFile); <line6> } <line7> } <line8> 	"<line3>      LOG.debug(""Skip migration because migration source folder is not specified or otherwise invalid."");"	task4	
public class A { <line0> public void activateVfModule(BuildingBlockExecution execution) { <line1> GeneralBuildingBlock gBBInput = execution.getGeneralBuildingBlock(); <line2> RequestContext requestContext = gBBInput.getRequestContext(); <line3> ServiceInstance serviceInstance = null; <line4> GenericVnf vnf = null; <line5> VfModule vfModule = null; <line6> try { <line7> serviceInstance = extractPojosForBB.extractByKey(execution, ResourceKey.SERVICE_INSTANCE_ID); <line8> vnf = extractPojosForBB.extractByKey(execution, ResourceKey.GENERIC_VNF_ID); <line9> vfModule = extractPojosForBB.extractByKey(execution, ResourceKey.VF_MODULE_ID); <line10> Customer customer = gBBInput.getCustomer(); <line11> CloudRegion cloudRegion = gBBInput.getCloudRegion(); <line12> SDNCRequest sdncRequest = new SDNCRequest(); <line13> GenericResourceApiVfModuleOperationInformation req = <line14> sdncVfModuleResources.activateVfModule( <line15> vfModule, <line16> vnf, <line17> serviceInstance, <line18> customer, <line19> cloudRegion, <line20> requestContext, <line21> buildCallbackURI(sdncRequest)); <line22> sdncRequest.setSDNCPayload(req); <line23> sdncRequest.setTopology(SDNCTopology.VFMODULE); <line24> execution.setVariable(SDNC_REQUEST, sdncRequest); <line25> } catch (Exception ex) { <line26> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, ex); <line27> } <line28> } <line29> } <line30> 	"<line26>      logger.error(""Exception occurred in SDNCActivateTasks activateVfModule process"", ex);"	task4	
public class A { <line0> @Override <line1> public boolean accept(String randomValue) { <line2> if ((randomValue == null) || randomValue.isEmpty()) { <line3> return false; <line4> } <line5> if (randomValue.charAt(0) != CharPool.SLASH) { <line6> randomValue = StringPool.SLASH.concat(randomValue); <line7> } <line8> if (LayoutImpl.validateFriendlyURL(randomValue) != -1) { <line9> return false; <line10> } <line11> try { <line12> LayoutImpl.validateFriendlyURLKeyword(randomValue); <line13> return true; <line14> } catch (LayoutFriendlyURLException layoutFriendlyURLException) { <line15> if (log.isDebugEnabled()) { <line16> } <line17> return false; <line18> } <line19> } <line20> } <line21> 	<line16>        log.debug(layoutFriendlyURLException, layoutFriendlyURLException);	task4	
"public class A { <line0> public void writeElement(String name) throws IOException { <line1> Integer mapping = stringTable.get(name); <line2> if (mapping == null) { <line3> throw new IOException(""no mapping for '"" + name + ""'""); <line4> } <line5> writeInt(buf, stringTable.get(name) + 64); <line6> } <line7> } <line8> "	"<line3>      logger.warn(""no mapping for '"" + name + ""'"");"	task4	
"public class A { <line0> @Override <line1> public String getWorkflowRunReport(int workflowRunSWID) { <line2> return """"; <line3> } <line4> } <line5> "	"<line2>    logger.info(""No metadata connection"");"	task4	
"public class A { <line0> @Override <line1> public IResourceStream locate(Class<?> clazz, String path) { <line2> String location; <line3> if (clazz == AlternativePageFromWebContext.class) { <line4> String extension = path.substring(path.lastIndexOf('.') + 1); <line5> String simpleFileName = Strings.lastPathComponent(clazz.getName(), '.'); <line6> location = ""/WEB-INF/templates/"" + simpleFileName + ""."" + extension; <line7> } else { <line8> location = ""/WEB-INF/templates/"" + path; <line9> } <line10> URL url; <line11> try { <line12> url = getServletContext().getResource(location); <line13> if (url != null) { <line14> return new UrlResourceStream(url); <line15> } <line16> } catch (MalformedURLException e) { <line17> throw new WicketRuntimeException(e); <line18> } <line19> return super.locate(clazz, path); <line20> } <line21> } <line22> "	"<line2>    log.debug(""Attempting to locate resource '{}' using classloader the servlet context"", path);"	task4	
public class A { <line0> public void addLifeCycle(ComponentPlugin plugin) { <line1> ChromatticLifeCycle lifeCycle = (ChromatticLifeCycle) plugin; <line2> try { <line3> lifeCycle.manager = this; <line4> lifeCycle.start(); <line5> lifeCycles.put(lifeCycle.getDomainName(), lifeCycle); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	<line7>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> public String getSerialNumber() throws KuraException { <line1> synchronized (this.atLock) { <line2> if (this.serialNumber == null) { <line3> byte[] reply; <line4> CommConnection commAtConnection = openSerialPort(getAtPort()); <line5> if (!isAtReachable(commAtConnection)) { <line6> closeSerialPort(commAtConnection); <line7> throw new KuraException( <line8> KuraErrorCode.NOT_CONNECTED, <line9> MODEM_NOT_AVAILABLE_FOR_AT_CMDS_MSG + TelitHe910.class.getName()); <line10> } <line11> try { <line12> reply = <line13> commAtConnection.sendCommand( <line14> TelitModemAtCommands.getSerialNumber.getCommand().getBytes(), 1000, 100); <line15> } catch (IOException e) { <line16> closeSerialPort(commAtConnection); <line17> throw new KuraException(KuraErrorCode.INTERNAL_ERROR, e); <line18> } <line19> closeSerialPort(commAtConnection); <line20> if (reply != null) { <line21> String serialNum = getResponseString(reply); <line22> if (serialNum != null && !serialNum.isEmpty()) { <line23> if (serialNum.startsWith(""#CGSN:"")) { <line24> serialNum = serialNum.substring(""#CGSN:"".length()).trim(); <line25> } <line26> this.serialNumber = serialNum; <line27> } <line28> } <line29> } <line30> } <line31> return this.serialNumber; <line32> } <line33> } <line34> "	"<line3>        logger.debug(""sendCommand getSerialNumber :: {}"", TelitModemAtCommands.getSerialNumber.getCommand());"	task4	
"public class A { <line0> public void processChallenge(final String challenge) throws MalformedChallengeException { <line1> super.processChallenge(challenge); <line2> if (getParameter(""realm"") == null) { <line3> throw new MalformedChallengeException(""missing realm in challange""); <line4> } <line5> if (getParameter(""nonce"") == null) { <line6> throw new MalformedChallengeException(""missing nonce in challange""); <line7> } <line8> boolean unsupportedQop = false; <line9> String qop = getParameter(""qop""); <line10> if (qop != null) { <line11> StringTokenizer tok = new StringTokenizer(qop, "",""); <line12> while (tok.hasMoreTokens()) { <line13> String variant = tok.nextToken().trim(); <line14> if (variant.equals(""auth"")) { <line15> qopVariant = QOP_AUTH; <line16> break; <line17> } else if (variant.equals(""auth-int"")) { <line18> qopVariant = QOP_AUTH_INT; <line19> } else { <line20> unsupportedQop = true; <line21> } <line22> } <line23> } <line24> if (unsupportedQop && (qopVariant == QOP_MISSING)) { <line25> throw new MalformedChallengeException(""None of the qop methods is supported""); <line26> } <line27> cnonce = createCnonce(); <line28> this.complete = true; <line29> } <line30> } <line31> "	"<line21>          LOG.warn(""Unsupported qop detected: "" + variant);"	task4	
"public class A { <line0> void putStart(final String workId) { <line1> final WebTarget remoteWebResource = locatorClient.target(serverUrl + ""/event/start/"" + workId); <line2> try { <line3> final Response response = <line4> remoteWebResource.request(MediaType.TEXT_PLAIN).post(Entity.text("""")); <line5> checkResponseStatus(response); <line6> } catch (final Exception c) { <line7> } <line8> } <line9> } <line10> "	"<line7>      LOG.warn(""[onStart] Erreur de connexion au serveur {} ({})"",remoteWebResource.getUri(),c.getMessage());"	task4	
public class A { <line0> @Override <line1> public void start(StartContext context) throws StartException { <line2> Class<?> componentClass; <line3> String className = _model.get(CommonAttributes.IMPLCLASS).asString(); <line4> try { <line5> componentClass = <line6> Module.loadClassFromCallerModuleLoader(ModuleIdentifier.fromString(_moduleId), className); <line7> try { <line8> _component = (Component) componentClass.newInstance(); <line9> ModelNode properties = <line10> _model.hasDefined(CommonAttributes.PROPERTIES) <line11> ? _model.get(CommonAttributes.PROPERTIES) <line12> : null; <line13> _component.init(createEnvironmentConfig(properties)); <line14> _component.addResourceDependency(_resourceAdapterRepository.getValue()); <line15> } catch (InstantiationException ie) { <line16> ExtensionLogger.ROOTlogger.unableToInstantiateClass(className, ie); <line17> } catch (IllegalAccessException iae) { <line18> ExtensionLogger.ROOTlogger.unableToAccessConstructor(className, iae); <line19> } <line20> } catch (ClassNotFoundException cnfe) { <line21> ExtensionLogger.ROOTlogger.unableToLoadClass(className, cnfe); <line22> } catch (ModuleLoadException mle) { <line23> ExtensionLogger.ROOTlogger.unableToLoadModule(_moduleId, mle); <line24> } <line25> } <line26> } <line27> 	"<line14>        LOG.debug(""Initialized component "" + _component);"	task4	
public class A { <line0> @Override <line1> public void find(PackageScanFilter test, String packageName, Set<Class<?>> classes) { <line2> packageName = packageName.replace('.', '/'); <line3> int classesSize = classes.size(); <line4> loadImplementationsInBundle(test, packageName, classes); <line5> if (classes.size() == classesSize) { <line6> for (ClassLoader classLoader : super.getClassLoaders()) { <line7> if (!isOsgiClassloader(classLoader)) { <line8> find(test, packageName, classLoader, classes); <line9> } <line10> } <line11> } <line12> } <line13> } <line14> 	"<line6>      log.trace(""Cannot find any classes in bundles, not trying regular classloaders scanning: {}"",packageName);"	task4	
public class A { <line0> public static com.liferay.commerce.price.list.model.CommercePriceListChannelRelSoap <line1> addCommercePriceListChannelRel( <line2> long commercePriceListId, <line3> long commerceChannelId, <line4> int order, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws RemoteException { <line7> try { <line8> com.liferay.commerce.price.list.model.CommercePriceListChannelRel returnValue = <line9> CommercePriceListChannelRelServiceUtil.addCommercePriceListChannelRel( <line10> commercePriceListId, commerceChannelId, order, serviceContext); <line11> return com.liferay.commerce.price.list.model.CommercePriceListChannelRelSoap.toSoapModel( <line12> returnValue); <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	<line14>      log.error(exception, exception);	task4	
"public class A { <line0> public int saveContentDefinition(JsonObject contentJson) throws InsightsCustomException { <line1> InsightsContentConfig contentConfig = new InsightsContentConfig(); <line2> Gson gson = new Gson(); <line3> int kpiId = contentJson.get(""kpiId"").getAsInt(); <line4> int contentId = contentJson.get(""contentId"").getAsInt(); <line5> try { <line6> InsightsContentConfig existingContentConfig = reportConfigDAL.getContentConfig(contentId); <line7> if (existingContentConfig == null) { <line8> boolean contentisActive = contentJson.get(""isActive"").getAsBoolean(); <line9> String contentName = contentJson.get(""contentName"").getAsString(); <line10> String contentString = gson.toJson(contentJson); <line11> contentConfig.setContentId(contentId); <line12> InsightsKPIConfig kpiConfig = reportConfigDAL.getKPIConfig(kpiId); <line13> String contentCategory = kpiConfig.getCategory(); <line14> contentConfig.setKpiConfig(kpiConfig); <line15> contentConfig.setActive(contentisActive); <line16> contentConfig.setContentJson(contentString); <line17> contentConfig.setContentName(contentName); <line18> contentConfig.setCategory(contentCategory); <line19> reportConfigDAL.saveContentConfig(contentConfig); <line20> } <line21> } catch (Exception e) { <line22> } <line23> return contentId; <line24> } <line25> } <line26> "	<line22>      log.error(e);	task4	
public class A { <line0> @Override <line1> public void run() { <line2> eventHandler.handleEvent(new TimerEvent(customResourceUid, TimerEventSource.this)); <line3> } <line4> } <line5> 	"<line2>    log.debug(""Producing event for custom resource id: {}"", customResourceUid);"	task4	
"public class A { <line0> private Future<WriteSummary> writeData(final DataWriter writer, final long length) <line1> throws Exception { <line2> return EXECUTOR.submit( <line3> new Callable<WriteSummary>() { <line4> @Override <line5> public WriteSummary call() throws IOException { <line6> try { <line7> long checksum = 0; <line8> long remaining = length; <line9> while (remaining > 0) { <line10> int bytesToWrite = (int) Math.min(remaining, CHUNK_SIZE); <line11> byte[] data = new byte[bytesToWrite]; <line12> RANDOM.nextBytes(data); <line13> ByteBuf buf = Unpooled.wrappedBuffer(data); <line14> try { <line15> writer.writeChunk(buf); <line16> } catch (Exception e) { <line17> fail(e.getMessage()); <line18> throw e; <line19> } <line20> remaining -= bytesToWrite; <line21> for (int i = 0; i < data.length; i++) { <line22> checksum += BufferUtils.byteToInt(data[i]); <line23> } <line24> } <line25> return new WriteSummary(length, checksum); <line26> } catch (Throwable throwable) { <line27> fail(""Failed to write file."" + throwable.getMessage()); <line28> throw throwable; <line29> } <line30> } <line31> }); <line32> } <line33> } <line34> "	"<line27>              LOG.error(""Failed to write file."", throwable);"	task4	
"public class A { <line0> public ProjectInstance createProject( <line1> String projectName, <line2> String owner, <line3> String description, <line4> LinkedHashMap<String, String> overrideProps) <line5> throws IOException { <line6> try (AutoLock lock = prjMapLock.lockForWrite()) { <line7> ProjectInstance currentProject = getProject(projectName); <line8> if (currentProject == null) { <line9> currentProject = <line10> ProjectInstance.create(projectName, owner, description, overrideProps, null, null); <line11> } else { <line12> throw new IllegalStateException(""The project named "" + projectName + ""already exists""); <line13> } <line14> checkOverrideProps(currentProject); <line15> return save(currentProject); <line16> } <line17> } <line18> } <line19> "	"<line7>      logger.info(""Creating project "" + projectName);"	task4	
public class A { <line0> private List<SyndEntry> getEntries( <line1> List<String> contentsId, <line2> String lang, <line3> String feedLink, <line4> HttpServletRequest req, <line5> HttpServletResponse resp) <line6> throws ApsSystemException { <line7> List<SyndEntry> entries = new ArrayList<SyndEntry>(); <line8> Iterator<String> idIterator = contentsId.iterator(); <line9> while (idIterator.hasNext()) { <line10> String id = (String) idIterator.next(); <line11> ContentRecordVO currentContent = this.getContentManager().loadContentVO(id); <line12> RssContentMapping mapping = <line13> (RssContentMapping) this.getContentMapping().get(currentContent.getTypeCode()); <line14> if (null == mapping) { <line15> continue; <line16> } <line17> entries.add(this.createEntry(currentContent, lang, feedLink, req, resp)); <line18> } <line19> return entries; <line20> } <line21> } <line22> 	"<line15>        logger.error(""Null content mapping by existed channel for content type {}"",currentContent.getTypeCode());"	task4	
"public class A { <line0> @Test <line1> public void testUserHostAndPortSerialization() throws Exception { <line2> String result = <line3> checkSerializesAs(UserAndHostAndPort.fromParts(""testHostUser"", ""1.2.3.4"", 22), null); <line4> Assert.assertFalse( <line5> result.contains(""error""), ""Shouldn't have had an error, instead got: "" + result); <line6> Assert.assertEquals( <line7> Strings.collapseWhitespace(result, """"), <line8> ""{\""user\"":\""testHostUser\"",\""hostAndPort\"":{\""host\"":\""1.2.3.4\"",\""port\"":22,\""hasBracketlessColons\"":false}}""); <line9> } <line10> } <line11> "	"<line4>    log.info(""UserHostAndPort serialized as: "" + result);"	task4	
"public class A { <line0> @Override <line1> public Buffer receive(int id) throws IOException { <line2> Session session = getClientSession(); <line3> Duration idleTimeout = CoreModuleProperties.IDLE_TIMEOUT.getRequired(session); <line4> if (GenericUtils.isNegativeOrNull(idleTimeout)) { <line5> idleTimeout = CoreModuleProperties.IDLE_TIMEOUT.getRequiredDefault(); <line6> } <line7> Instant now = Instant.now(); <line8> Instant waitEnd = now.plus(idleTimeout); <line9> boolean traceEnabled = log.isTraceEnabled(); <line10> for (int count = 1; ; count++) { <line11> if (isClosing() || (!isOpen())) { <line12> throw new SshException(""Channel is being closed""); <line13> } <line14> if (now.compareTo(waitEnd) > 0) { <line15> throw new SshException(""Timeout expired while waiting for id="" + id); <line16> } <line17> Buffer buffer = receive(id, Duration.between(now, waitEnd)); <line18> if (buffer != null) { <line19> return buffer; <line20> } <line21> now = Instant.now(); <line22> if (traceEnabled) { <line23> } <line24> } <line25> } <line26> } <line27> "	"<line23>        log.trace(""receive({}) check iteration #{} for id={} remain time={}"",this,count,id,idleTimeout);"	task4	
public class A { <line0> private void pauseJob(String group, String name) throws SchedulerException { <line1> if (StringUtils.isEmpty(group) || StringUtils.isEmpty(name)) { <line2> return; <line3> } <line4> Scheduler scheduler = factory.getScheduler(); <line5> JobKey jobKey = new JobKey(name, group); <line6> if (!scheduler.checkExists(jobKey)) { <line7> throw new GriffinException.NotFoundException(JOB_KEY_DOES_NOT_EXIST); <line8> } <line9> scheduler.pauseJob(jobKey); <line10> } <line11> } <line12> 	"<line7>      LOGGER.warn(""Job({},{}) does not exist."", jobKey.getGroup(), jobKey.getName());"	task4	
"public class A { <line0> private void generateCaKeyAndCert( <line1> Subject subject, Map<String, String> keyData, Map<String, String> certData) { <line2> try { <line3> File keyFile = File.createTempFile(""tls"", subject.commonName() + ""-key""); <line4> try { <line5> File certFile = File.createTempFile(""tls"", subject.commonName() + ""-cert""); <line6> try { <line7> File trustStoreFile = File.createTempFile(""tls"", subject.commonName() + ""-truststore""); <line8> String trustStorePassword; <line9> if (certData.containsKey(CA_STORE)) { <line10> Files.write( <line11> trustStoreFile.toPath(), Base64.getDecoder().decode(certData.get(CA_STORE))); <line12> trustStorePassword = <line13> new String( <line14> Base64.getDecoder().decode(certData.get(CA_STORE_PASSWORD)), <line15> StandardCharsets.US_ASCII); <line16> } else { <line17> trustStorePassword = passwordGenerator.generate(); <line18> } <line19> try { <line20> certManager.generateSelfSignedCert(keyFile, certFile, subject, validityDays); <line21> certManager.addCertToTrustStore(certFile, CA_CRT, trustStoreFile, trustStorePassword); <line22> CertAndKey ca = <line23> new CertAndKey( <line24> Files.readAllBytes(keyFile.toPath()), <line25> Files.readAllBytes(certFile.toPath()), <line26> Files.readAllBytes(trustStoreFile.toPath()), <line27> null, <line28> trustStorePassword); <line29> certData.put(CA_CRT, ca.certAsBase64String()); <line30> keyData.put(CA_KEY, ca.keyAsBase64String()); <line31> certData.put(CA_STORE, ca.trustStoreAsBase64String()); <line32> certData.put(CA_STORE_PASSWORD, ca.storePasswordAsBase64String()); <line33> } finally { <line34> delete(trustStoreFile); <line35> } <line36> } finally { <line37> delete(certFile); <line38> } <line39> } finally { <line40> delete(keyFile); <line41> } <line42> } catch (IOException | CertificateException | KeyStoreException | NoSuchAlgorithmException e) { <line43> throw new RuntimeException(e); <line44> } <line45> } <line46> } <line47> "	"<line3>      log.debug(""Generating CA with subject={}"", subject);"	task4	
public class A { <line0> @Override <line1> public void close() { <line2> if (conn != null) { <line3> try { <line4> conn.close(); <line5> } catch (SQLException e) { <line6> } finally { <line7> conn = null; <line8> } <line9> } <line10> } <line11> } <line12> 	<line6>        logger.error(e.getMessage(), e);	task4	
"public class A { <line0> public static void main(String[] args) { <line1> LoggingFactory.init(Level.INFO); <line2> try { <line3> Webcam webcamx = (Webcam) Runtime.start(""webcam"", ""Webcam""); <line4> webcamx.capture(""/dev/video0"", ""jpg"", 30, 640, 480, 0.5); <line5> WebGui webgui = (WebGui) Runtime.create(""webgui"", ""WebGui""); <line6> webgui.autoStartBrowser(false); <line7> webgui.startService(); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> "	"<line9>      log.error(""main threw"", e);"	task4	
public class A { <line0> @Override <line1> public void setWorkingDirectory(Path path) { <line2> if (path.isAbsolute()) { <line3> mWorkingDir = path; <line4> } else { <line5> mWorkingDir = new Path(mWorkingDir, path); <line6> } <line7> } <line8> } <line9> 	"<line2>    LOG.debug(""setWorkingDirectory({})"", path);"	task4	
"public class A { <line0> @Test <line1> public void testMultiMapSerialization() throws Exception { <line2> Multimap<String, Integer> m = MultimapBuilder.hashKeys().arrayListValues().build(); <line3> m.put(""bob"", 24); <line4> m.put(""bob"", 25); <line5> String result = checkSerializesAs(m, null); <line6> Assert.assertFalse( <line7> result.contains(""error""), ""Shouldn't have had an error, instead got: "" + result); <line8> Assert.assertEquals(Strings.collapseWhitespace(result, """"), ""{\""bob\"":[24,25]}""); <line9> } <line10> } <line11> "	"<line6>    log.info(""multimap serialized as: "" + result);"	task4	
public class A { <line0> private void login(Configuration configuration) throws IOException { <line1> if (configuration.get(STORM_KEYTAB_FILE_KEY) == null) { <line2> configuration.set(STORM_KEYTAB_FILE_KEY, hdfsKeyTab); <line3> } <line4> if (configuration.get(STORM_USER_NAME_KEY) == null) { <line5> configuration.set(STORM_USER_NAME_KEY, hdfsPrincipal); <line6> } <line7> SecurityUtil.login(configuration, STORM_KEYTAB_FILE_KEY, STORM_USER_NAME_KEY); <line8> } <line9> } <line10> 	"<line8>    LOG.info(""Logged into hdfs with principal {}"", configuration.get(STORM_USER_NAME_KEY));"	task4	
public class A { <line0> public void remove() { <line1> ALL_LOADERS.remove(this); <line2> try { <line3> super.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOGGER.warn(""Could not close plugin classloader"", e);"	task4	
public class A { <line0> public ManagedConnectionFactory getManagedConnectionFactory() { <line1> return this.managedConnectionFactory; <line2> } <line3> } <line4> 	"<line1>    logger.debug(""getManagedConnectionFactory()..."");"	task4	
public class A { <line0> private void sentOfflineMessage( <line1> ChannelHandlerContext ctx, Session session, DashBoard dashBoard, Device device) { <line2> boolean isHardwareConnected = session.isHardwareConnected(dashBoard.id, device.id); <line3> if (!isHardwareConnected) { <line4> device.disconnected(); <line5> } <line6> if (!dashBoard.isActive) { <line7> return; <line8> } <line9> Notification notification = dashBoard.getNotificationWidget(); <line10> if (notification != null && notification.notifyWhenOffline) { <line11> sendPushNotification(ctx, session, notification, dashBoard, device); <line12> } else if (!dashBoard.isNotificationsOff) { <line13> session.sendOfflineMessageToApps(dashBoard.id, device.id); <line14> } <line15> } <line16> } <line17> 	"<line4>      log.trace(""Changing device status. DeviceId {}, dashId {}"", device.id, dashBoard.id);"	task4	
public class A { <line0> public ClientResponse run() { <line1> String relativeURL = <line2> RangerRESTUtils.REST_URL_GET_SECURE_SERVICE_TAGS_IF_UPDATED + serviceNameUrlParam; <line3> ClientResponse clientResp = null; <line4> try { <line5> clientResp = restClient.get(relativeURL, queryParams); <line6> } catch (Exception e) { <line7> } <line8> return clientResp; <line9> } <line10> } <line11> 	"<line7>      LOG.error(""Failed to get response, Error is : "" + e.getMessage());"	task4	
"public class A { <line0> @Transactional(propagation = Propagation.REQUIRES_NEW) <line1> @Override <line2> @SuppressWarnings(""unchecked"") <line3> public Pair<UserUR, List<PropagationStatus>> update( <line4> final UserUR userUR, <line5> final ProvisioningReport result, <line6> final Boolean enabled, <line7> final Set<String> excludedResources, <line8> final boolean nullPriorityAsync, <line9> final String updater, <line10> final String context) { <line11> PollingConsumer pollingConsumer = getConsumer(""direct:updateInPullPort""); <line12> Map<String, Object> props = new HashMap<>(); <line13> props.put(""key"", userUR.getKey()); <line14> props.put(""result"", result); <line15> props.put(""enabled"", enabled); <line16> props.put(""excludedResources"", excludedResources); <line17> props.put(""nullPriorityAsync"", nullPriorityAsync); <line18> props.put(""updater"", updater); <line19> props.put(""context"", context); <line20> sendMessage(""direct:updateUserInPull"", userUR, props); <line21> Exchange exchange = pollingConsumer.receive(); <line22> Exception ex = (Exception) exchange.getProperty(Exchange.EXCEPTION_CAUGHT); <line23> if (ex != null) { <line24> result.setStatus(ProvisioningReport.Status.FAILURE); <line25> result.setMessage( <line26> ""Update failed, trying to pull status anyway (if configured)\n"" + ex.getMessage()); <line27> UserWorkflowResult<Pair<UserUR, Boolean>> updated = <line28> new UserWorkflowResult<>( <line29> Pair.of(userUR, false), <line30> new PropagationByResource<>(), <line31> new PropagationByResource<>(), <line32> new HashSet<>()); <line33> sendMessage(""direct:userInPull"", updated, props); <line34> exchange = pollingConsumer.receive(); <line35> } <line36> return exchange.getIn().getBody(Pair.class); <line37> } <line38> } <line39> "	"<line24>      LOG.error(""Update of user {} failed, trying to pull its status anyway (if configured)"",userUR.getKey(),ex);"	task4	
public class A { <line0> private void doInsertInstances( <line1> String role, <line2> String dcId, <line3> String clusterId, <line4> String shardId, <line5> List<Pair<String, Integer>> redisAddresses) <line6> throws ResourceNotFoundException, DalException { <line7> DcClusterShardTbl dcClusterShardTbl = dcClusterShardService.find(dcId, clusterId, shardId); <line8> if (dcClusterShardTbl == null) { <line9> throw new ResourceNotFoundException(dcId, clusterId, shardId); <line10> } <line11> List<RedisTbl> redisTbls = <line12> doFindAllByDcClusterShardId( <line13> dcClusterShardTbl.getDcClusterShardId(), XPipeConsoleConstant.ROLE_REDIS); <line14> List<Pair<String, Integer>> toAdd = sub(redisAddresses, redisTbls); <line15> insertInstancesToDb(dcClusterShardTbl.getDcClusterShardId(), role, toAdd.toArray(new Pair[0])); <line16> } <line17> } <line18> 	"<line15>    logger.info(""[doInsertInstances]{}"", toAdd);"	task4	
public class A { <line0> protected void setBypass(boolean from, int day, int month) throws InterruptedException { <line1> BypassDate bypassDate = new BypassDate(day, month); <line2> try { <line3> this.writeValue( <line4> from <line5> ? HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY <line6> : HeliosEasyControlsBindingConstants.BYPASS_TO_DAY, <line7> Integer.toString(bypassDate.getDay())); <line8> this.writeValue( <line9> from <line10> ? HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH <line11> : HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH, <line12> Integer.toString(bypassDate.getMonth())); <line13> } catch (HeliosException e) { <line14> } <line15> } <line16> } <line17> 	"<line14>      logger.warn(""{} encountered Exception when trying to set bypass period: {}"",HeliosEasyControlsHandler.class.getSimpleName(),e.getMessage());"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> io(); <line4> } catch (IOException e) { <line5> throw Throwables.propagate(e); <line6> } <line7> } <line8> } <line9> 	"<line7>    LOG.info(mMsg + mWorkerId + "" just finished."");"	task4	
public class A { <line0> @Override <line1> protected void sendWriteBuffer( <line2> int commandId, SocketAddress address, ByteBuffer writeBuffer, boolean redelivery) <line3> throws IOException { <line4> if (dropCommandStrategy.shouldDropCommand(commandId, address, redelivery)) { <line5> writeBuffer.flip(); <line6> getReplayBuffer().addBuffer(commandId, writeBuffer); <line7> } else { <line8> super.sendWriteBuffer(commandId, address, writeBuffer, redelivery); <line9> } <line10> } <line11> } <line12> 	"<line6>      LOG.info(""Dropping datagram with command: "" + commandId);"	task4	
public class A { <line0> @Transactional(readOnly = false) <line1> public int undoSoftDeleteOnCascade(int id, Set<CardType> types, Set<EventType> filteredEvents) { <line2> return queries.undoSoftDeleteOnCascade(id, toStringList(types), toStringList(filteredEvents)); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""undoSoftDeleteOnCascade: {id: {}}"", id);"	task4	
"public class A { <line0> @Override <line1> public long next() { <line2> SB sb = new SB(); <line3> sb.a(""[op=next"" + "", grpId="" + grp.groupId() + "", partId="" + partId + "", before="" + toString()); <line4> try { <line5> return delegate.next(); <line6> } finally { <line7> } <line8> } <line9> } <line10> "	"<line7>      log.debug(sb.a("", after="" + toString() + ']').toString());"	task4	
"public class A { <line0> @Test <line1> public void testUpdateParagraphConfig() throws IOException { <line2> Note note = null; <line3> try { <line4> note = TestUtils.getInstance(Notebook.class).createNote(""note1"", anonymous); <line5> String noteId = note.getId(); <line6> Paragraph p = note.addNewParagraph(AuthenticationInfo.ANONYMOUS); <line7> assertNull(p.getConfig().get(""colWidth"")); <line8> String paragraphId = p.getId(); <line9> String jsonRequest = ""{\""colWidth\"": 6.0}""; <line10> CloseableHttpResponse put = <line11> httpPut(""/notebook/"" + noteId + ""/paragraph/"" + paragraphId + ""/config"", jsonRequest); <line12> assertThat(""test testUpdateParagraphConfig:"", put, isAllowed()); <line13> Map<String, Object> resp = <line14> gson.fromJson( <line15> EntityUtils.toString(put.getEntity(), StandardCharsets.UTF_8), <line16> new TypeToken<Map<String, Object>>() {}.getType()); <line17> Map<String, Object> respBody = (Map<String, Object>) resp.get(""body""); <line18> Map<String, Object> config = (Map<String, Object>) respBody.get(""config""); <line19> put.close(); <line20> assertEquals(config.get(""colWidth""), 6.0); <line21> note = TestUtils.getInstance(Notebook.class).getNote(noteId); <line22> assertEquals(note.getParagraph(paragraphId).getConfig().get(""colWidth""), 6.0); <line23> } finally { <line24> if (null != note) { <line25> TestUtils.getInstance(Notebook.class).removeNote(note, anonymous); <line26> } <line27> } <line28> } <line29> } <line30> "	"<line2>    LOG.info(""Running testUpdateParagraphConfig"");"	task4	
"public class A { <line0> private void cleanupTemporaryFile(String temporaryFile) { <line1> Script.runSimpleBashScript(""rm -f "" + temporaryFile); <line2> } <line3> } <line4> "	"<line1>    logger.debug(""Cleaning up temporary certificate file"");"	task4	
"public class A { <line0> @Override <line1> public TransactionalDataSource createOrUpdateShard(Long shardId, DbVersion dbVersion) { <line2> Objects.requireNonNull(dbVersion, ""dbVersion is null""); <line3> long start = System.currentTimeMillis(); <line4> waitAvailability(); <line5> if (connectedShardDataSourceMap.containsKey(shardId)) { <line6> TransactionalDataSource dataSource = connectedShardDataSourceMap.get(shardId); <line7> dataSource.update(dbVersion); <line8> return dataSource; <line9> } else { <line10> return createShardDatasource(shardId, dbVersion); <line11> } <line12> } <line13> } <line14> "	"<line8>      log.debug(""Init existing SHARD using db version'{}' in {} ms"",dbVersion,System.currentTimeMillis() - start);"	task4	
public class A { <line0> @Test <line1> public void replicationOverflowTest() throws Exception { <line2> int repeatCount = 20; <line3> long index = 0L; <line4> List<ByteBuffer> messages = MessageUtils.build(10240, 1024); <line5> ByteBuffer replicationMessages = <line6> ByteBuffer.allocate(messages.stream().mapToInt(Buffer::remaining).sum()); <line7> for (int i = 0; i < repeatCount; i++) { <line8> replicationMessages.clear(); <line9> for (ByteBuffer byteBuffer : messages) { <line10> MessageParser.setShort(byteBuffer, MessageParser.PARTITION, partitions[0]); <line11> MessageParser.setInt(byteBuffer, MessageParser.TERM, 0); <line12> MessageParser.setInt( <line13> byteBuffer, <line14> MessageParser.STORAGE_TIMESTAMP, <line15> (int) <line16> (SystemClock.now() <line17> - MessageParser.getLong(byteBuffer, MessageParser.CLIENT_TIMESTAMP))); <line18> MessageParser.setLong(byteBuffer, MessageParser.INDEX, index++); <line19> replicationMessages.put(byteBuffer); <line20> byteBuffer.clear(); <line21> } <line22> replicationMessages.flip(); <line23> store.disable(); <line24> boolean repeat = true; <line25> while (repeat) <line26> try { <line27> store.appendEntryBuffer(replicationMessages); <line28> repeat = false; <line29> } catch (TimeoutException ignored) { <line30> } <line31> } <line32> } <line33> } <line34> 	"<line31>      logger.info(""Index: {}, {}..."", index, Format.formatSize(index * 1024));"	task4	
public class A { <line0> @Override <line1> public void assign(byte[] regionName) <line2> throws MasterNotRunningException, ZooKeeperConnectionException, IOException { <line3> } <line4> } <line5> 	"<line3>    LOG.info(""assign is a no-op"");"	task4	
"public class A { <line0> @POST(path = ""/backend/admin/users/update"", permission = ""admin:edit:user"") <line1> String updateUser(@BindRequest UserConfigDto userConfigDto) throws Exception { <line2> UserConfig existingUserConfig = configRepository.getUserConfig(userConfigDto.username()); <line3> if (existingUserConfig == null) { <line4> throw new UserNotFoundException(); <line5> } <line6> UserConfig userConfig = userConfigDto.convert(existingUserConfig); <line7> String version = userConfigDto.version().get(); <line8> try { <line9> configRepository.updateUserConfig(userConfig, version); <line10> } catch (DuplicateUsernameException e) { <line11> throw new JsonServiceException(CONFLICT, ""username""); <line12> } <line13> return getUserConfigInternal(userConfig.username()); <line14> } <line15> } <line16> "	<line11>      logger.debug(e.getMessage(), e);	task4	
"public class A { <line0> public final void openModule(WorkbenchModule module) { <line1> if (!modules.contains(module)) { <line2> throw new IllegalArgumentException(""Module has not been loaded yet""); <line3> } <line4> activeModule.setValue(module); <line5> } <line6> } <line7> "	"<line4>    LOGGER.trace(""openModule - set active module to "" + module);"	task4	
public class A { <line0> @Override <line1> public boolean addConditional(String systemName, Conditional conditional) { <line2> Conditional chkDuplicate = _conditionalMap.putIfAbsent(systemName, conditional); <line3> if (chkDuplicate == null) { <line4> return (true); <line5> } <line6> return (false); <line7> } <line8> } <line9> 	"<line6>    log.error(""Conditional '{}' has already been added to Logix '{}'"", systemName, getSystemName());"	task4	
public class A { <line0> @Override <line1> public void entryAdded(EntryEvent<Long, Whiteboards> event) { <line2> onlineWbs.put(event.getKey(), event.getValue()); <line3> } <line4> } <line5> 	"<line2>    log.trace(""WbListener::Add"");"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> new ExtGithub(this.farm).value().repos().get(new Coordinates.Simple(""zerocracy/farm"")).json(); <line4> this.output.set(""OK""); <line5> } catch (final IOException err) { <line6> this.output.set(err.getMessage()); <line7> } <line8> } <line9> } <line10> "	"<line6>      Logger.error(this, ""Failed to find farm repo: %[exception]s"", err);"	task4	
public class A { <line0> public Struct keyFromColumnData(Object[] columnData) { <line1> if (LOGGER.isTraceEnabled()) { <line2> } <line3> return columnData == null ? null : keyGenerator.generateValue(columnData); <line4> } <line5> } <line6> 	"<line2>      LOGGER.trace(""columnData from current stack: {}"", Arrays.toString(columnData));"	task4	
"public class A { <line0> @Test <line1> public void testFindUsersByBadHeaderValueThenReturnBadRequest() { <line2> final HttpHeaders headers = new HttpHeaders(); <line3> headers.add(CommonConstants.X_TENANT_ID_HEADER, ""%ds#</><!-sdq""); <line4> super.performGet( <line5> ""/archive"", <line6> ImmutableMap.of(""page"", 1, ""size"", 20, ""orderBy"", ""id""), <line7> headers, <line8> status().isBadRequest()); <line9> } <line10> } <line11> "	"<line2>    LOGGER.debug(""testFindUsersByBadHeaderValueThenReturnBadRequest"");"	task4	
"public class A { <line0> protected void stop() { <line1> new Thread( <line2> () -> { <line3> for (; ; ) { <line4> SCBEngine.getInstance().destroy(); <line5> if (ITBootListener.isDone() <line6> && SCBStatus.DOWN.equals(SCBEngine.getInstance().getStatus())) { <line7> break; <line8> } <line9> ITUtils.forceWait(TimeUnit.SECONDS, 1); <line10> } <line11> System.exit(0); <line12> }, <line13> ""it-stop"") <line14> .start(); <line15> } <line16> } <line17> "	"<line7>                  LOGGER.info(""succeed to close ""+ RegistrationManager.INSTANCE.getMicroservice().getServiceName());"	task4	
public class A { <line0> @Override <line1> @After <line2> public void after() { <line3> try { <line4> runTestAsSubject( <line5> new TestOperation() { <line6> @Override <line7> public void runTestAsSubject() throws Exception { <line8> Set<TSentryRole> tRoles = client.listAllRoles(ADMIN_USER, COMPONENT); <line9> for (TSentryRole tRole : tRoles) { <line10> client.dropRole(ADMIN_USER, tRole.getRoleName(), COMPONENT); <line11> } <line12> if (client != null) { <line13> client.close(); <line14> } <line15> } <line16> }); <line17> } catch (Exception e) { <line18> } finally { <line19> policyFilePath.delete(); <line20> } <line21> } <line22> } <line23> 	"<line18>      LOGGER.warn(""Exception happened after test case."", e);"	task4	
public class A { <line0> public static Process exec(String... cmd) throws IOException { <line1> Process p = java.lang.Runtime.getRuntime().exec(cmd); <line2> return p; <line3> } <line4> } <line5> 	"<line1>    log.info(""Runtime exec {}"", Arrays.toString(cmd));"	task4	
public class A { <line0> private void removeEventServiceSubscription() { <line1> if (filterlessSubscriptionId != null && subscribeClientFactory != null) { <line2> CswSubscribe cswSubscribe = <line3> subscribeClientFactory.getClientForSystemSubject(getSystemSubject()); <line4> try { <line5> cswSubscribe.deleteRecordsSubscription(filterlessSubscriptionId); <line6> } catch (CswException e) { <line7> } <line8> filterlessSubscriptionId = null; <line9> } <line10> } <line11> } <line12> 	"<line7>        LOGGER.info(""Failed to remove filterless subscription registered for id {} for csw source with id""+ "" of {}"",filterlessSubscriptionId,this.getId());"	task4	
"public class A { <line0> @Override <line1> public List<String> searchIdeaInstances(Collection<String> groupNames, String code) { <line2> List<String> ideainstancesId = new ArrayList<String>(); <line3> Connection conn = null; <line4> PreparedStatement stat = null; <line5> ResultSet res = null; <line6> if ((null == groupNames || groupNames.isEmpty()) && StringUtils.isBlank(code)) { <line7> ideainstancesId = this.loadIdeaInstances(); <line8> return ideainstancesId; <line9> } <line10> try { <line11> conn = this.getConnection(); <line12> StringBuffer sbBuffer = new StringBuffer(); <line13> Iterator<String> it = groupNames.iterator(); <line14> boolean appendWhere = true; <line15> String q = SEARCH_IDEAINSTANCES_ID; <line16> if (!groupNames.isEmpty()) { <line17> q = <line18> q.replace( <line19> ""#JOIN_GROUP#"", ""INNER JOIN jpcollaboration_ideainstance_group g ON i.code=g.code""); <line20> sbBuffer.append(appendWhere ? "" WHERE "" : "" AND ""); <line21> appendWhere = false; <line22> sbBuffer.append(""(""); <line23> boolean appendOr = false; <line24> while (it.hasNext()) { <line25> String gname = it.next(); <line26> if (appendOr) sbBuffer.append("" OR ""); <line27> sbBuffer.append(""g.groupname=?"").append("" ""); <line28> appendOr = true; <line29> } <line30> sbBuffer.append("")""); <line31> q = q.replace(""#GROUP_CODES#"", sbBuffer.toString()); <line32> } else { <line33> q = q.replace(""#GROUP_CODES#"", "" ""); <line34> q = q.replace(""#JOIN_GROUP#"", "" ""); <line35> } <line36> if (StringUtils.isNotBlank(code)) { <line37> sbBuffer = new StringBuffer(); <line38> sbBuffer.append(appendWhere ? "" WHERE "" : "" AND ""); <line39> appendWhere = false; <line40> sbBuffer.append(""i.code like ? ""); <line41> q = q.replace(""#CODE_NAME#"", sbBuffer.toString()); <line42> } else { <line43> q = q.replace(""#CODE_NAME#"", "" ""); <line44> } <line45> stat = conn.prepareStatement(q); <line46> int index = 1; <line47> if (!groupNames.isEmpty()) { <line48> it = groupNames.iterator(); <line49> while (it.hasNext()) { <line50> String group = it.next(); <line51> stat.setString(index++, group); <line52> } <line53> } <line54> if (StringUtils.isNotBlank(code)) { <line55> stat.setString(index++, ""%"" + code + ""%""); <line56> } <line57> res = stat.executeQuery(); <line58> while (res.next()) { <line59> String codeValue = res.getString(""code""); <line60> ideainstancesId.add(codeValue); <line61> } <line62> } catch (Throwable t) { <line63> throw new RuntimeException(""error in searchIdeaInstances"", t); <line64> } finally { <line65> closeDaoResources(res, stat, conn); <line66> } <line67> return ideainstancesId; <line68> } <line69> } <line70> "	"<line63>      logger.error(""error in searchIdeaInstances"", t);"	task4	
"public class A { <line0> @Test <line1> public void testAggregateProcessInstancesEmpty() throws Exception { <line2> String xml1 = read(this.getClass().getResourceAsStream(""/jaxb/process-instance-empty.xml"")); <line3> String xml2 = read(this.getClass().getResourceAsStream(""/jaxb/process-instance-empty.xml"")); <line4> JaxbXMLResponseAggregator aggregate = new JaxbXMLResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(xml1); <line7> data.add(xml2); <line8> String result = aggregate.aggregate(data); <line9> Document xml = toXml(result); <line10> assertNotNull(xml); <line11> NodeList processes = xml.getElementsByTagName(""process-instance-list""); <line12> assertNotNull(processes); <line13> assertEquals(1, processes.getLength()); <line14> NodeList processInstances = xml.getElementsByTagName(""process-instance""); <line15> assertNotNull(processInstances); <line16> assertEquals(0, processInstances.getLength()); <line17> } <line18> } <line19> "	<line9>    logger.debug(result);	task4	
"public class A { <line0> public void doSendServiceCheck( <line1> String serviceCheckName, String status, String message, String[] tags) { <line2> String tagString = """"; <line3> if (tags != null && tags.length > 0) { <line4> tagString = ""["" + StringUtils.join("","", tags) + ""]""; <line5> } <line6> Map<String, Object> sc = new HashMap<String, Object>(); <line7> sc.put(""name"", serviceCheckName); <line8> sc.put(""status"", status); <line9> sc.put(""message"", message); <line10> sc.put(""tags"", tags); <line11> serviceChecks.add(sc); <line12> } <line13> } <line14> "	"<line6>    log.info(serviceCheckName + tagString + "" - "" + System.currentTimeMillis() / 1000 + "" = "" + status);"	task4	
"public class A { <line0> public static com.liferay.commerce.product.model.CPTaxCategory getCPTaxCategory( <line1> HttpPrincipal httpPrincipal, long cpTaxCategoryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CPTaxCategoryServiceUtil.class, ""getCPTaxCategory"", _getCPTaxCategoryParameterTypes8); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, cpTaxCategoryId); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.commerce.product.model.CPTaxCategory) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
public class A { <line0> public void onClusterChange() { <line1> ILogger logger = loggingService.getLogger(HazelcastInstance.class); <line2> dispose(onClusterChangeDisposables); <line3> clusterService.reset(); <line4> partitionService.reset(); <line5> connectionManager.reset(); <line6> } <line7> } <line8> 	"<line2>    logger.info(""Resetting local state of the client, because of a cluster change."");"	task4	
"public class A { <line0> public static com.liferay.commerce.product.model.CommerceChannel fetchCommerceChannel( <line1> HttpPrincipal httpPrincipal, long commerceChannelId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceChannelServiceUtil.class, <line7> ""fetchCommerceChannel"", <line8> _fetchCommerceChannelParameterTypes3); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceChannelId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.product.model.CommerceChannel) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> public void setAttributeMappings(List<String> attributeMappingsList) { <line1> if (attributeMappingsList != null) { <line2> mappingEntries.clear(); <line3> attributeMappingsList.stream() <line4> .filter(StringUtils::isNotEmpty) <line5> .map(this::jsonToMap) <line6> .filter(this::validAttributeMapping) <line7> .forEach( <line8> map -> <line9> addAttributeMapping( <line10> (String) map.get(ATTRIBUTE_NAME), <line11> (String) map.get(FEATURE_NAME), <line12> (String) map.get(TEMPLATE))); <line13> } <line14> } <line15> } <line16> 	"<line1>    LOGGER.trace(""Setting attribute mappings to: {}"", attributeMappingsList);"	task4	
public class A { <line0> @Override <line1> public void operationComplete(int rc, AuthToken newam) { <line2> if (rc != BKException.Code.OK) { <line3> channel.close(); <line4> return; <line5> } <line6> AuthMessage message = <line7> AuthMessage.newBuilder() <line8> .setAuthPluginName(req.authMessage.getAuthPluginName()) <line9> .setPayload(ByteString.copyFrom(newam.getData())) <line10> .build(); <line11> channel.writeAndFlush(new BookieProtocol.AuthResponse(req.getProtocolVersion(), message)); <line12> } <line13> } <line14> 	"<line3>      LOG.error(""Error processing auth message, closing connection"");"	task4	
public class A { <line0> @Override <line1> public long push() throws IOException { <line2> try { <line3> final FileSystem fileSystem = zip.getFileSystem(configuration); <line4> long size = 0L; <line5> final byte[] buffer = new byte[1 << 13]; <line6> progressable.progress(); <line7> try (ZipInputStream in = new ZipInputStream(fileSystem.open(zip, 1 << 13))) { <line8> for (ZipEntry entry = in.getNextEntry(); entry != null; entry = in.getNextEntry()) { <line9> final String fileName = entry.getName(); <line10> final String outputPath = new File(outDir, fileName).getAbsolutePath(); <line11> CompressionUtils.validateZipOutputFile(zip.getName(), new File(outputPath), outDir); <line12> try (final OutputStream out = <line13> new BufferedOutputStream(new FileOutputStream(outputPath))) { <line14> for (int len = in.read(buffer); len >= 0; len = in.read(buffer)) { <line15> progressable.progress(); <line16> if (len == 0) { <line17> continue; <line18> } <line19> size += len; <line20> out.write(buffer, 0, len); <line21> } <line22> out.flush(); <line23> } <line24> } <line25> } <line26> progressable.progress(); <line27> return size; <line28> } catch (IOException | RuntimeException exception) { <line29> throw exception; <line30> } <line31> } <line32> } <line33> 	"<line29>      log.error(exception, ""Exception in unzip retry loop"");"	task4	
public class A { <line0> @Override <line1> public void release() { <line2> try { <line3> autoPingManager.release(); <line4> bookmarkManager.release(); <line5> mediaFileManager.release(); <line6> fileContentManager.release(); <line7> pingTargetManager.release(); <line8> pingQueueManager.release(); <line9> pluginManager.release(); <line10> threadManager.release(); <line11> userManager.release(); <line12> weblogManager.release(); <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> 	"<line14>      log.error(""Error calling Roller.release()"", e);"	task4	
public class A { <line0> @Override <line1> public boolean isSatisified() throws Exception { <line2> boolean result = false; <line3> BrokerView view = broker.getAdminView(); <line4> if (view != null) { <line5> ObjectName[] subs = broker.getAdminView().getInactiveDurableTopicSubscribers(); <line6> if (subs != null) { <line7> if (expectedCount == subs.length) { <line8> result = true; <line9> } <line10> } <line11> } <line12> return result; <line13> } <line14> } <line15> 	"<line7>        LOG.info(""inactive durable subs on "" + broker + "" : "" + Arrays.asList(subs));"	task4	
public class A { <line0> @ExceptionHandler(InvalidSearchParamException.class) <line1> @ResponseStatus(value = HttpStatus.BAD_REQUEST) <line2> public ViewObjectErrorResponse invalidSearchParamExceptionHandler( <line3> InvalidSearchParamException ex) { <line4> return new ViewObjectErrorResponse(ErrorCode.SEARCH_ERROR, ex.getMessage()); <line5> } <line6> } <line7> 	"<line4>    logger.debug(""Invalid Search Param Exception: "", ex);"	task4	
"public class A { <line0> @Override <line1> public MigrationPublishResult doMigrationPublish( <line2> String clusterName, String shardName, String primaryDcName, InetSocketAddress newMaster) <line3> throws OuterClientException { <line4> String startTime = DateTimeUtils.currentTimeAsString(); <line5> MigrationPublishResult res = <line6> new MigrationPublishResult( <line7> ""default-addr"", clusterName, primaryDcName, Arrays.asList(newMaster)); <line8> String endTime = DateTimeUtils.currentTimeAsString(); <line9> res.setSuccess(true); <line10> res.setMessage(""default-success""); <line11> res.setStartTime(startTime); <line12> res.setEndTime(endTime); <line13> return res; <line14> } <line15> } <line16> "	"<line4>    logger.info(""[doMigrationPublish]Cluster:{}, Shard:{}, NewPrimaryDc:{}, NewMaster:{}"",clusterName,shardName,primaryDcName,newMaster);"	task4	
"public class A { <line0> public String toJsonString() { <line1> try { <line2> return mapper.writeValueAsString(mapper.createObjectNode().put(""message"", getMessage())); <line3> } catch (JsonProcessingException e) { <line4> throw new RuntimeException(e); <line5> } <line6> } <line7> } <line8> "	"<line4>      log.warn(""Failed to serialize exception "", e);"	task4	
public class A { <line0> private void writePSKIdentityHintLength(PskEcDheServerKeyExchangeMessage msg) { <line1> appendInt(msg.getIdentityHintLength().getValue(), HandshakeByteLength.PSK_IDENTITY_LENGTH); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""SerializedPSKIdentityLength: "" + msg.getIdentityHintLength().getValue());"	task4	
public class A { <line0> public GenericEntity getSession(String token, String id) { <line1> try { <line2> return this.createEntityFromAPI(getApiUrl() + SESSION_URL + id, token); <line3> } catch (JsonSyntaxException e) { <line4> return new GenericEntity(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.warn(""Error occured while getting session"", e);"	task4	
"public class A { <line0> @ApiOperation(value = ""get history by user's id"") <line1> @GetMapping(CommonConstants.PATH_LOGBOOK) <line2> public LogbookOperationsResponseDto findHistoryById(final @PathVariable String id) { <line3> SanityChecker.check(id); <line4> return service.findHistoryById(buildUiHttpContext(), id); <line5> } <line6> } <line7> "	"<line3>    LOGGER.debug(""get logbook for users with id :{}"", id);"	task4	
"public class A { <line0> private void processRestMethodReturnValue( <line1> Class<?> returnType, Operation operation, String returnDescription) <line2> throws MojoExecutionException { <line3> exampleClassNames.add(returnType.getSimpleName()); <line4> operation.response( <line5> 200, <line6> new Response() <line7> .description(returnDescription == null ? ""Success"" : returnDescription) <line8> .schema(new RefProperty(getXmlType(returnType).name().trim()))); <line9> if (modelErrorClass != null) { <line10> operation.defaultResponse( <line11> new Response() <line12> .description(""General Error"") <line13> .schema(new RefProperty(getXmlType(modelErrorClass).name().trim()))); <line14> } <line15> } <line16> } <line17> "	"<line3>    log.debug(""Processing REST method return value \"""" + returnType.getName() + ""\""."");"	task4	
public class A { <line0> private String getHostForIp(String ip) { <line1> try { <line2> return InetAddress.getByName(ip).getCanonicalHostName(); <line3> } catch (UnknownHostException ex) { <line4> return ip; <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.warn(""Could not perform reverse DNS for \"""" + ip + ""\"""", ex);"	task4	
"public class A { <line0> public synchronized void destroy(NodeState state) throws ItemStateException { <line1> if (!initialized) { <line2> throw new IllegalStateException(""not initialized""); <line3> } <line4> try { <line5> executeStmt(nodeStateDeleteSQL, new Object[] {state.getNodeId().toString()}); <line6> } catch (Exception e) { <line7> String msg = ""failed to delete node state: "" + state.getNodeId(); <line8> throw new ItemStateException(msg, e); <line9> } <line10> } <line11> } <line12> "	<line8>      log.error(msg, e);	task4	
"public class A { <line0> @Override <line1> public String toParamName(String name) { <line2> name = camelize(toVarName(name), true); <line3> if (isReservedWord(name)) { <line4> name = name + ""_""; <line5> } <line6> return name; <line7> } <line8> } <line9> "	"<line4>      LOGGER.warn(name + "" (reserved word) cannot be used as parameter name. Renamed to "" + name + ""_"");"	task4	
"public class A { <line0> @Override <line1> public List<String> getDescriptionsFromPage(Document page) { <line2> List<String> urls = new ArrayList<>(); <line3> Elements urlElements = page.select(""figure.t-image > b > u > a""); <line4> for (Element e : urlElements) { <line5> urls.add(urlBase + e.select(""a"").first().attr(""href"")); <line6> } <line7> return urls; <line8> } <line9> } <line10> "	"<line6>      LOGGER.debug(""Desc2 "" + urlBase + e.select(""a"").first().attr(""href""));"	task4	
public class A { <line0> private Set<ProtectionSystem> getProtectionSystemsForStoragePool( <line1> StoragePool storagePool, VirtualArray vArray, boolean isRpVplex) { <line2> Set<ProtectionSystem> protectionSystems = <line3> ConnectivityUtil.getProtectionSystemsForStoragePool( <line4> dbClient, storagePool, vArray.getId(), isRpVplex); <line5> if (protectionSystems.isEmpty()) { <line6> } <line7> return protectionSystems; <line8> } <line9> } <line10> 	"<line6>      log.info(String.format(""RP Placement: Storage pool %s does not have connectivity to a protection system."",storagePool.getLabel()));"	task4	
"public class A { <line0> private Transcoding getTranscoding( <line1> MediaFile mediaFile, Player player, String preferredTargetFormat, boolean hls) { <line2> if (hls) { <line3> return new Transcoding( <line4> null, <line5> ""hls"", <line6> mediaFile.getFormat(), <line7> ""ts"", <line8> settingsService.getHlsCommand(), <line9> null, <line10> null, <line11> true); <line12> } <line13> if (FORMAT_RAW.equals(preferredTargetFormat)) { <line14> return null; <line15> } <line16> List<Transcoding> applicableTranscodings = new LinkedList<>(); <line17> String suffix = mediaFile.getFormat(); <line18> List<Transcoding> transcodingsForPlayer = getTranscodingsForPlayer(player); <line19> for (Transcoding transcoding : transcodingsForPlayer) { <line20> if (mediaFile.isVideo() <line21> && StringUtils.equalsIgnoreCase(preferredTargetFormat, transcoding.getTargetFormat())) { <line22> if (LOG.isDebugEnabled()) { <line23> } <line24> return transcoding; <line25> } <line26> Arrays.stream(transcoding.getSourceFormatsAsArray()) <line27> .filter(sourceFormat -> sourceFormat.equalsIgnoreCase(suffix)) <line28> .filter(sourceFormat -> isTranscodingInstalled(transcoding)) <line29> .forEach(s -> applicableTranscodings.add(transcoding)); <line30> } <line31> if (applicableTranscodings.isEmpty()) { <line32> return null; <line33> } <line34> for (Transcoding transcoding : applicableTranscodings) { <line35> if (transcoding.getTargetFormat().equalsIgnoreCase(preferredTargetFormat)) { <line36> return transcoding; <line37> } <line38> } <line39> return applicableTranscodings.get(0); <line40> } <line41> } <line42> "	"<line23>          LOG.debug(""Detected source to target format match for video"");"	task4	
public class A { <line0> @Override <line1> public void updateServerURI(String uri) { <line2> if (!runsAsApplication) { <line3> ClientPropertyPlaceholderConfigurer.setRemoteServerMode(uri); <line4> try { <line5> ServiceFactory.openCommandService(); <line6> } catch (MalformedURLException e) { <line7> throw new IllegalStateException(e); <line8> } <line9> state = ServiceFactory.getClientWorkObjects(); <line10> VeriniceContext.setState(state); <line11> context.registerService( <line12> ICommandService.class.getName(), <line13> VeriniceContext.get(VeriniceContext.COMMAND_SERVICE), <line14> null); <line15> context.registerService( <line16> IObjectModelService.class.getName(), <line17> VeriniceContext.get(VeriniceContext.OBJECT_MODEL_SERVICE), <line18> null); <line19> } <line20> } <line21> } <line22> 	"<line3>      LOG.info(""verinice runs in designer mode - retrieving server configuration from ODA driver."");"	task4	
"public class A { <line0> @Override <line1> public CompletableFuture<Tuple2<List<String>, ExecutionInfo>> getListJSONAsyncWithStats() { <line2> final RuntimeEngine rte = getRte(); <line3> final CassandraOptions options = getOptions(); <line4> final StatementWrapper statementWrapper = getInternalBoundStatementWrapper(); <line5> if (LOGGER.isTraceEnabled()) { <line6> } <line7> CompletableFuture<ResultSet> futureRS = rte.execute(statementWrapper); <line8> return futureRS <line9> .thenApply(options::resultSetAsyncListener) <line10> .thenApply( <line11> x -> <line12> statementWrapper.logReturnResults( <line13> x, options.computeMaxDisplayedResults(rte.configContext))) <line14> .thenApply(statementWrapper::logTrace) <line15> .thenApply( <line16> resultSet -> <line17> Tuple2.of( <line18> IntStream.range(0, resultSet.getAvailableWithoutFetching()) <line19> .mapToObj(index -> resultSet.one().getString(""[json]"")) <line20> .collect(Collectors.toList()), <line21> resultSet.getExecutionInfo())); <line22> } <line23> } <line24> "	"<line6>      LOGGER.trace(format(""Select async with execution info : %s"",statementWrapper.getBoundStatement().preparedStatement().getQueryString()));"	task4	
"public class A { <line0> @Test <line1> public void testQuery() throws Exception { <line2> com.google.api.services.calendar.model.FreeBusyRequest request = new FreeBusyRequest(); <line3> List<FreeBusyRequestItem> items = new ArrayList<>(); <line4> items.add(new FreeBusyRequestItem().setId(getCalendar().getId())); <line5> request.setItems(items); <line6> request.setTimeMin(DateTime.parseRfc3339(""2014-11-10T20:45:30-00:00"")); <line7> request.setTimeMax(DateTime.parseRfc3339(""2014-11-10T21:45:30-00:00"")); <line8> final com.google.api.services.calendar.model.FreeBusyResponse result = <line9> requestBody(""direct://QUERY"", request); <line10> assertNotNull(result, ""query result""); <line11> } <line12> } <line13> "	"<line11>    LOG.debug(""query: "" + result);"	task4	
public class A { <line0> protected void processAffinityGroup( <line1> AffinityGroupVMMapVO vmGroupMapping, DeploymentPlan plan, VirtualMachine vm) { <line2> AffinityGroupVO group = _affinityGroupDao.findById(vmGroupMapping.getAffinityGroupId()); <line3> List<Long> groupVMIds = _affinityGroupVMMapDao.listVmIdsByAffinityGroup(group.getId()); <line4> groupVMIds.remove(vm.getId()); <line5> List<Long> preferredHosts = getPreferredHostsFromGroupVMIds(groupVMIds); <line6> plan.setPreferredHosts(preferredHosts); <line7> } <line8> } <line9> 	"<line3>    logger.debug(""Processing affinity group "" + group.getName() + "" for VM Id: "" + vm.getId());"	task4	
public class A { <line0> @Override <line1> public void execute() <line2> throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, <line3> ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException { <line4> try { <line5> BaremetalRctResponse rsp = vlanMgr.addRct(this); <line6> this.setResponseObject(rsp); <line7> } catch (Exception e) { <line8> throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, e.getMessage()); <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.warn(String.format(""unable to add baremetal RCT[%s]"", getRctUrl()), e);"	task4	
public class A { <line0> public void stop() { <line1> setShuttingDownStatus(true); <line2> try { <line3> Thread.sleep(5000); <line4> } catch (Exception e) { <line5> } <line6> _helixManager.disconnect(); <line7> _serverInstance.shutDown(); <line8> } <line9> } <line10> 	"<line5>      LOGGER.error(""error trying to sleep waiting for external view to change : "", e);"	task4	
public class A { <line0> private static void verifyDirsForNewEnvironment(List<File> missedCookieDirs) <line1> throws InvalidCookieException { <line2> List<File> nonEmptyDirs = new ArrayList<>(); <line3> for (File dir : missedCookieDirs) { <line4> String[] content = dir.list(); <line5> if (content != null && content.length != 0) { <line6> nonEmptyDirs.add(dir); <line7> } <line8> } <line9> if (!nonEmptyDirs.isEmpty()) { <line10> throw new InvalidCookieException(); <line11> } <line12> } <line13> } <line14> 	"<line10>      LOG.error(""Not all the new directories are empty. New directories that are not empty are: ""+ nonEmptyDirs);"	task4	
"public class A { <line0> public static void copyInputStreamToOutputStream(InputStream in, OutputStream out) { <line1> ArgumentNotValid.checkNotNull(in, ""InputStream in""); <line2> ArgumentNotValid.checkNotNull(out, ""OutputStream out""); <line3> try { <line4> try { <line5> if (in instanceof FileInputStream && out instanceof FileOutputStream) { <line6> FileChannel inChannel = ((FileInputStream) in).getChannel(); <line7> FileChannel outChannel = ((FileOutputStream) out).getChannel(); <line8> long transferred = 0; <line9> final long fileLength = inChannel.size(); <line10> do { <line11> transferred += <line12> inChannel.transferTo( <line13> transferred, <line14> Math.min(Constants.IO_CHUNK_SIZE, fileLength - transferred), <line15> outChannel); <line16> } while (transferred < fileLength); <line17> } else { <line18> byte[] buf = new byte[Constants.IO_BUFFER_SIZE]; <line19> int bytesRead; <line20> while ((bytesRead = in.read(buf)) != -1) { <line21> out.write(buf, 0, bytesRead); <line22> } <line23> } <line24> out.flush(); <line25> } finally { <line26> in.close(); <line27> } <line28> } catch (IOException e) { <line29> String errMsg = ""Trouble copying inputstream "" + in + "" to outputstream "" + out; <line30> throw new IOFailure(errMsg, e); <line31> } <line32> } <line33> } <line34> "	<line30>      log.warn(errMsg, e);	task4	
"public class A { <line0> @Override <line1> public void setContent(InputStream inputStream) throws IOException { <line2> ObjectUtil.checkNotNull(inputStream, ""inputStream""); <line3> if (file != null) { <line4> delete(); <line5> } <line6> file = tempFile(); <line7> RandomAccessFile accessFile = new RandomAccessFile(file, ""rw""); <line8> int written = 0; <line9> try { <line10> accessFile.setLength(0); <line11> FileChannel localfileChannel = accessFile.getChannel(); <line12> byte[] bytes = new byte[4096 * 4]; <line13> ByteBuffer byteBuffer = ByteBuffer.wrap(bytes); <line14> int read = inputStream.read(bytes); <line15> while (read > 0) { <line16> byteBuffer.position(read).flip(); <line17> written += localfileChannel.write(byteBuffer); <line18> checkSize(written); <line19> read = inputStream.read(bytes); <line20> } <line21> localfileChannel.force(false); <line22> } finally { <line23> accessFile.close(); <line24> } <line25> size = written; <line26> if (definedSize > 0 && definedSize < size) { <line27> if (!file.delete()) { <line28> } <line29> file = null; <line30> throw new IOException(""Out of size: "" + size + "" > "" + definedSize); <line31> } <line32> isRenamed = true; <line33> setCompleted(); <line34> } <line35> } <line36> "	"<line28>        logger.warn(""Failed to delete: {}"", file);"	task4	
"public class A { <line0> @Override <line1> public void loadFromXml(Element x) { <line2> super.loadFromXml(x); <line3> try { <line4> VALUE value = <line5> TypeCastUtility.castValue(XmlUtility.getObjectAttribute(x, ""value""), getHolderType()); <line6> setValue(value); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	"<line8>      LOG.warn(""Could not load form XML [{}]"", getClass().getName(), e);"	task4	
"public class A { <line0> @BeforeEach <line1> public void setUp() throws Exception { <line2> TestUtils.setupWeblogger(); <line3> try { <line4> testUser = TestUtils.setupUser(""wtTestUser""); <line5> testWeblog = TestUtils.setupWeblog(""wtTestWeblog"", testUser); <line6> TestUtils.endSession(true); <line7> } catch (Exception ex) { <line8> throw new Exception(""Test setup failed"", ex); <line9> } <line10> testCommonPing = new PingTarget(); <line11> testCommonPing.setName(""testCommonPing""); <line12> testCommonPing.setPingUrl(""http://localhost/testCommonPing""); <line13> } <line14> } <line15> "	<line8>      log.error(ex);	task4	
public class A { <line0> @Override <line1> public Optional<MetacardValidationReport> validateMetacard(Metacard metacard) { <line2> try { <line3> return Optional.of(generateReport(metacard)); <line4> } catch (ValidationExceptionImpl e) { <line5> return Optional.empty(); <line6> } <line7> } <line8> } <line9> 	"<line5>      LOGGER.warn(""Exception validating metacard ID {}"", metacard.getId(), e);"	task4	
public class A { <line0> void removedEmptyNestedGroups(NavGroup navGroup, List<String> itemsToRemove) { <line1> filteringGroups(navGroup.getChildren()) <line2> .forEach(group -> removedEmptyNestedGroups(group, itemsToRemove)); <line3> if (navGroup.getChildren().isEmpty()) { <line4> itemsToRemove.add(navGroup.getId()); <line5> } <line6> } <line7> } <line8> 	"<line4>      logger.info(""Removing groups {}"", navGroup.getName());"	task4	
"public class A { <line0> private void showCheckoutConflictsNotification(List<String> conflictingPaths) { <line1> Platform.runLater( <line2> () -> { <line3> EventHandler handler = event -> quickStashSave(); <line4> this.notificationPaneController.addNotification( <line5> ""You can't switch to that branch because there would be a merge conflict. "" <line6> + ""Stash your changes or resolve conflicts first."", <line7> ""stash"", <line8> handler); <line9> }); <line10> } <line11> } <line12> "	"<line3>          logger.warn(""Checkout conflicts warning"");"	task4	
"public class A { <line0> @Override <line1> public void processRecord(ARCRecord sar, OutputStream os) { <line2> Map<String, String> fieldsread = new HashMap<String, String>(); <line3> fieldsread.put(""A"", sar.getMetaData().getUrl()); <line4> fieldsread.put(""e"", sar.getMetaData().getIp()); <line5> fieldsread.put(""b"", sar.getMetaData().getDate()); <line6> fieldsread.put(""m"", sar.getMetaData().getMimetype()); <line7> fieldsread.put(""n"", Long.toString(sar.getMetaData().getLength())); <line8> fieldsread.put(""v"", Long.toString(sar.getMetaData().getOffset())); <line9> fieldsread.put(""g"", sar.getMetaData().getArcFile().getName()); <line10> if (includeChecksum) { <line11> InputStream instream = sar; <line12> fieldsread.put(""c"", ChecksumCalculator.calculateMd5(instream)); <line13> } <line14> printFields(fieldsread, os); <line15> } <line16> } <line17> "	"<line2>    log.trace(""Processing ARCRecord with offset: {}"", sar.getMetaData().getOffset());"	task4	
"public class A { <line0> protected Integer resolveMoveThreadCount(String moveThreadCount) { <line1> int availableProcessorCount = getAvailableProcessors(); <line2> Integer resolvedMoveThreadCount; <line3> if (moveThreadCount == null || moveThreadCount.equals(SolverConfig.MOVE_THREAD_COUNT_NONE)) { <line4> return null; <line5> } else if (moveThreadCount.equals(SolverConfig.MOVE_THREAD_COUNT_AUTO)) { <line6> resolvedMoveThreadCount = (availableProcessorCount - 2); <line7> if (resolvedMoveThreadCount <= 1) { <line8> return null; <line9> } <line10> } else { <line11> resolvedMoveThreadCount = <line12> ConfigUtils.resolvePoolSize( <line13> ""moveThreadCount"", <line14> moveThreadCount, <line15> SolverConfig.MOVE_THREAD_COUNT_NONE, <line16> SolverConfig.MOVE_THREAD_COUNT_AUTO); <line17> } <line18> if (resolvedMoveThreadCount < 1) { <line19> throw new IllegalArgumentException( <line20> ""The moveThreadCount ("" <line21> + moveThreadCount <line22> + "") resulted in a resolvedMoveThreadCount ("" <line23> + resolvedMoveThreadCount <line24> + "") that is lower than 1.""); <line25> } <line26> if (resolvedMoveThreadCount > availableProcessorCount) { <line27> } <line28> return resolvedMoveThreadCount; <line29> } <line30> } <line31> "	"<line27>      LOGGER.warn(""The resolvedMoveThreadCount ({}) is higher ""+ ""than the availableProcessorCount ({}), which is counter-efficient."",resolvedMoveThreadCount,availableProcessorCount);"	task4	
public class A { <line0> @Override <line1> public void processMessage(Chat chat, Message message) { <line2> try { <line3> String body = message.getBody(); <line4> if (Validator.isNull(body)) { <line5> return; <line6> } <line7> String from = message.getFrom(); <line8> if (StringUtil.equalsIgnoreCase( <line9> JabberUtil.getResource(from), _chatGroupServiceConfiguration.jabberResource())) { <line10> return; <line11> } <line12> long fromUserId = <line13> UserLocalServiceUtil.getUserIdByScreenName(_companyId, JabberUtil.getScreenName(from)); <line14> EntryLocalServiceUtil.addEntry(fromUserId, _userId, body); <line15> } catch (Exception exception) { <line16> } <line17> } <line18> } <line19> 	<line16>      log.error(exception, exception);	task4	
"public class A { <line0> public LensRDDResult getRDD(QueryHandle queryHandle) throws LensException { <line1> QueryStatus status = getClient().getQueryStatus(queryHandle); <line2> if (!status.finished() && !status.isResultSetAvailable()) { <line3> throw new LensException( <line4> queryHandle.getHandleId() + "" query not finished or result unavailable""); <line5> } <line6> LensClient.LensClientResultSetWithStats result = getClient().getAsyncResults(queryHandle); <line7> if (result.getResultSet() == null) { <line8> throw new LensException(""Result set not available for query "" + queryHandle.getHandleId()); <line9> } <line10> LensClientResultSet resultSet = result.getResultSet(); <line11> QueryResultSetMetadata metadata = result.getResultSet().getResultSetMetadata(); <line12> if (!(resultSet.getResult() instanceof PersistentQueryResult)) { <line13> throw new LensException(""RDDs only supported for persistent result sets""); <line14> } <line15> PersistentQueryResult persistentQueryResult = (PersistentQueryResult) resultSet.getResult(); <line16> String tempTableName; <line17> try { <line18> tempTableName = createTempMetastoreTable(persistentQueryResult.getPersistedURI(), metadata); <line19> } catch (HiveException e) { <line20> throw new LensException(""Error creating temp table from result set"", e); <line21> } <line22> JavaPairRDD<WritableComparable, HCatRecord> rdd = null; <line23> try { <line24> rdd = <line25> HiveTableRDD.createHiveTableRDD( <line26> sparkContext, <line27> HIVE_CONF, <line28> ""default"", <line29> tempTableName, <line30> TEMP_TABLE_PART_COL + ""='"" + TEMP_TABLE_PART_VAL + ""'""); <line31> } catch (IOException e) { <line32> throw new LensException(""Error creating RDD for table "" + tempTableName, e); <line33> } <line34> return new LensRDDResult( <line35> rdd.map(new HCatRecordToObjectListMapper()).rdd(), queryHandle, tempTableName); <line36> } <line37> } <line38> "	"<line31>      log.info(""Created RDD {} for table {}"", rdd.name(), tempTableName);"	task4	
public class A { <line0> @Override <line1> public Optional<ConfigTable> readConfig(Set<String> keys) { <line2> ConfigTable table = new ConfigTable(); <line3> try { <line4> ConfigurationRequest.Builder builder = <line5> ConfigurationRequest.newBuilder().setClusterName(settings.getClusterName()); <line6> if (uuid != null) { <line7> builder.setUuid(uuid); <line8> } <line9> ConfigurationResponse response = stub.call(builder.build()); <line10> String responseUuid = response.getUuid(); <line11> if (responseUuid != null && Objects.equals(uuid, responseUuid)) { <line12> return Optional.empty(); <line13> } <line14> response <line15> .getConfigTableList() <line16> .forEach( <line17> config -> { <line18> final String name = config.getName(); <line19> if (keys.contains(name)) { <line20> table.add(new ConfigTable.ConfigItem(name, config.getValue())); <line21> } <line22> }); <line23> this.uuid = responseUuid; <line24> } catch (Exception e) { <line25> } <line26> return Optional.of(table); <line27> } <line28> } <line29> 	"<line25>      LOGGER.error(""Remote config center ["" + settings + ""] is not available."", e);"	task4	
"public class A { <line0> @Test <line1> public void testRangeOpsInDiffSubTree() throws Exception { <line2> String city = TestCities.rome.name(); <line3> String query = <line4> ""("" <line5> + CityField.NUM.name() <line6> + LTE_OP <line7> + ""100"" <line8> + AND_OP <line9> + CityField.CITY.name() <line10> + EQ_OP <line11> + ""'"" <line12> + city <line13> + ""')"" <line14> + AND_OP <line15> + CityField.NUM.name() <line16> + GTE_OP <line17> + ""100""; <line18> String expected = <line19> CityField.NUM.name() <line20> + LTE_OP <line21> + ""'+cE1'"" <line22> + JEXL_AND_OP <line23> + CityField.CITY.name() <line24> + EQ_OP <line25> + ""'"" <line26> + city <line27> + ""'"" <line28> + JEXL_AND_OP <line29> + CityField.NUM.name() <line30> + GTE_OP <line31> + ""'+cE1'""; <line32> String plan = getPlan(query, true, true); <line33> assertPlanEquals(expected, plan); <line34> expected = <line35> CityField.NUM.name() <line36> + LTE_OP <line37> + ""'+cE1'"" <line38> + JEXL_AND_OP <line39> + CityField.CITY.name() <line40> + EQ_OP <line41> + ""'"" <line42> + city <line43> + ""'"" <line44> + JEXL_AND_OP <line45> + CityField.NUM.name() <line46> + GTE_OP <line47> + ""'+cE1'""; <line48> plan = getPlan(query, true, false); <line49> assertPlanEquals(expected, plan); <line50> expected = <line51> CityField.NUM.name() <line52> + LTE_OP <line53> + ""'+cE1'"" <line54> + JEXL_AND_OP <line55> + CityField.CITY.name() <line56> + EQ_OP <line57> + ""'"" <line58> + city <line59> + ""'"" <line60> + JEXL_AND_OP <line61> + CityField.NUM.name() <line62> + GTE_OP <line63> + ""'+cE1'""; <line64> plan = getPlan(query, false, true); <line65> assertPlanEquals(expected, plan); <line66> expected = query; <line67> runTest(query, expected); <line68> } <line69> } <line70> "	"<line2>    log.info(""------  testRangeOpsInDiffSubTree  ------"");"	task4	
public class A { <line0> public static boolean isUpdateStatement(Statement statement) { <line1> if (LOGGER.isTraceEnabled()) { <line2> } <line3> if (isSimpleStatement(statement)) { <line4> return UPDATE_PATTERN.matcher(maybeGetNormalizedQueryString(statement)).matches(); <line5> } else { <line6> return statement instanceof Update.Where || statement instanceof Update.Options; <line7> } <line8> } <line9> } <line10> 	"<line2>      LOGGER.trace(String.format(""Is '%s' Update statement ? "", statement.toString()));"	task4	
public class A { <line0> public String resetMethodStatus() { <line1> try { <line2> String result = this.checkMethod(); <line3> if (null != result) return result; <line4> this.resetMethodStatus(this.extractMethod()); <line5> } catch (Throwable t) { <line6> return FAILURE; <line7> } <line8> return SUCCESS; <line9> } <line10> } <line11> 	"<line6>      logger.error(""Error resetting method status"", t);"	task4	
public class A { <line0> private AsyncJobDispatcher findWakeupDispatcher(AsyncJob job) { <line1> if (_jobDispatchers != null) { <line2> List<AsyncJobJoinMapVO> joinRecords = _joinMapDao.listJoinRecords(job.getId()); <line3> if (joinRecords.size() > 0) { <line4> AsyncJobJoinMapVO joinRecord = joinRecords.get(0); <line5> for (AsyncJobDispatcher dispatcher : _jobDispatchers) { <line6> if (dispatcher.getName().equals(joinRecord.getWakeupDispatcher())) return dispatcher; <line7> } <line8> } else { <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	"<line9>        logger.warn(""job-""+ job.getId()+ "" is scheduled for wakeup run, but there is no joining info anymore"");"	task4	
public class A { <line0> @Override <line1> public void setPlan(AnimationPlan plan) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> setPlan(plan, null); <line5> } <line6> } <line7> 	"<line3>      LOGGER.debug(""Animation plan set to "" + plan);"	task4	
public class A { <line0> public void shutdown() { <line1> shutdownLatch.countDown(); <line2> } <line3> } <line4> 	"<line1>    log.info(""Shutting down thread monitoring tables."");"	task4	
"public class A { <line0> public static void destroyInstance() { <line1> checkState(instance != null, ""createInstance() must be called prior to destroyInstance()""); <line2> instance.stop(); <line3> instance = null; <line4> } <line5> } <line6> "	"<line4>    LOG.info(""Destroyed WebSocketServer."");"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private void invokePartitionChangeListener() { <line2> if (!triggerListeners.isEmpty()) { <line3> Map<PartitionEntry, Integer> current = <line4> (Map<PartitionEntry, Integer>) partitionCache.get(CURRENT); <line5> Map<PartitionEntry, Integer> previous = <line6> (Map<PartitionEntry, Integer>) partitionCache.get(PREVIOUS); <line7> Map<String, List<String>> partition = getNodePartition(current, currentNode); <line8> Map<String, Map<String, List<String>>> addedRemoved = <line9> getAddedRemovedPartition(previous, current, currentNode); <line10> if (log.isDebugEnabled()) { <line11> log.debugf(""Previous: %s"", previous); <line12> log.debugf(""Current: %s"", current); <line13> log.debugf(""Partition: %s"", partition); <line14> log.debugf(""Added: %s"", addedRemoved.get(""added"")); <line15> log.debugf(""Removed: %s"", addedRemoved.get(""removed"")); <line16> } <line17> triggerListeners.stream() <line18> .forEach( <line19> triggerListener -> { <line20> triggerListener.onPartitionChange( <line21> partition, addedRemoved.get(""removed""), addedRemoved.get(""added"")); <line22> }); <line23> } <line24> } <line25> } <line26> "	"<line11>        log.debug(""Invoke a Change Listener"");"	task4	
"public class A { <line0> @Override <line1> public SocialRequest findByUUID_G(String uuid, long groupId) throws NoSuchRequestException { <line2> SocialRequest socialRequest = fetchByUUID_G(uuid, groupId); <line3> if (socialRequest == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchRequestException(sb.toString()); <line14> } <line15> return socialRequest; <line16> } <line17> } <line18> "	<line12>        log.debug(sb.toString());	task4	
"public class A { <line0> @Override <line1> public void send(Bundle bundle) throws DataChannelError { <line2> try { <line3> AbstractOutputWriter writer = getWriter(); <line4> if (filter != null && !filter.filter(bundle)) { <line5> return; <line6> } <line7> String[] tok = new String[fileToken.length]; <line8> for (int i = 0; i < tok.length; i++) { <line9> tok[i] = fileToken[i]; <line10> } <line11> for (int i = 0; i < varToken.length; i++) { <line12> TokenIndex t = varToken[i]; <line13> ValueObject vo = bundle.getValue(bundle.getFormat().getField(t.field.getName())); <line14> if (vo == null) { <line15> throw new NullPointerException(""Null value in output path: "" + t.field.getName()); <line16> } <line17> tok[t.index] = ValueUtil.asNativeString(vo); <line18> } <line19> StringBuilder sb = new StringBuilder(); <line20> for (int i = 0; i < tok.length; i++) { <line21> sb.append(tok[i]); <line22> } <line23> writer.writeLine(sb.toString(), bundle); <line24> } catch (Exception ex) { <line25> throw DataChannelError.promote(ex); <line26> } <line27> } <line28> } <line29> "	"<line23>      log.debug(""send {} to {}"", bundle, sb);"	task4	
"public class A { <line0> @Override <line1> public PageDto updatePageStatus(String pageCode, String status) { <line2> IPage currentPage = this.getPageManager().getDraftPage(pageCode); <line3> BeanPropertyBindingResult bindingResult = new BeanPropertyBindingResult(pageCode, ""page""); <line4> if (null == currentPage) { <line5> throw new ResourceNotFoundException(ERRCODE_PAGE_NOT_FOUND, ""page"", pageCode); <line6> } <line7> if (status.equals(STATUS_DRAFT) && null == this.getPageManager().getOnlinePage(pageCode)) { <line8> return this.getDtoBuilder().convert(currentPage); <line9> } <line10> try { <line11> IPage newPage = null; <line12> if (status.equals(STATUS_ONLINE)) { <line13> IPage publicParent = this.getPageManager().getOnlinePage(currentPage.getParentCode()); <line14> if (null == publicParent) { <line15> bindingResult.reject( <line16> PageValidator.ERRCODE_PAGE_WITH_NO_PUBLIC_PARENT, <line17> new String[] {pageCode, currentPage.getParentCode()}, <line18> ""page.status.parent.unpublished""); <line19> throw new ValidationGenericException(bindingResult); <line20> } <line21> this.getPageManager().setPageOnline(pageCode); <line22> newPage = this.getPageManager().getOnlinePage(pageCode); <line23> } else if (status.equals(STATUS_DRAFT)) { <line24> String[] childCodes = currentPage.getChildrenCodes(); <line25> for (String childCode : childCodes) { <line26> IPage publicChild = this.getPageManager().getOnlinePage(childCode); <line27> if (null != publicChild) { <line28> bindingResult.reject( <line29> PageValidator.ERRCODE_PAGE_WITH_PUBLIC_CHILD, <line30> new String[] {pageCode}, <line31> ""page.status.publicChild""); <line32> throw new ValidationGenericException(bindingResult); <line33> } <line34> } <line35> Map<String, PageServiceUtilizer> beans = <line36> applicationContext.getBeansOfType(PageServiceUtilizer.class); <line37> if (null != beans) { <line38> Iterator<PageServiceUtilizer> iter = beans.values().iterator(); <line39> while (iter.hasNext()) { <line40> PageServiceUtilizer serviceUtilizer = iter.next(); <line41> List utilizer = serviceUtilizer.getPageUtilizer(pageCode); <line42> if (null != utilizer && utilizer.size() > 0) { <line43> bindingResult.reject( <line44> PageValidator.ERRCODE_REFERENCED_ONLINE_PAGE, <line45> new String[] {pageCode}, <line46> ""page.status.invalid.online.ref""); <line47> throw new ValidationGenericException(bindingResult); <line48> } <line49> } <line50> } <line51> this.getPageManager().setPageOffline(pageCode); <line52> newPage = this.getPageManager().getDraftPage(pageCode); <line53> } <line54> return this.getDtoBuilder().convert(newPage); <line55> } catch (ValidationGenericException e) { <line56> throw e; <line57> } catch (ApsSystemException e) { <line58> throw new RestServerError(""error in update page status"", e); <line59> } <line60> } <line61> } <line62> "	"<line58>      logger.error(""Error updating page {} status"", pageCode, e);"	task4	
"public class A { <line0> @Override <line1> public Optional<ScriptParameterDesignTrace> get( <line2> ScriptParameterDesignTraceKey scriptParameterDesignTraceKey) { <line3> try { <line4> String query = <line5> ""SELECT SCRIPT_PAR_VAL FROM "" <line6> + getMetadataRepository().getTableNameByLabel(""ScriptParameterDesignTraces"") <line7> + "" WHERE "" <line8> + "" RUN_ID = "" <line9> + SQLTools.getStringForSQL(scriptParameterDesignTraceKey.getRunId()) <line10> + "" AND "" <line11> + "" PRC_ID = "" <line12> + SQLTools.getStringForSQL(scriptParameterDesignTraceKey.getProcessId()) <line13> + "";""; <line14> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(query, ""reader""); <line15> if (cachedRowSet.size() == 0) { <line16> return Optional.empty(); <line17> } else if (cachedRowSet.size() > 1) { <line18> } <line19> cachedRowSet.next(); <line20> return Optional.of( <line21> new ScriptParameterDesignTrace( <line22> scriptParameterDesignTraceKey, cachedRowSet.getString(""SCRIPT_PAR_VAL""))); <line23> } catch (SQLException e) { <line24> throw new RuntimeException(e); <line25> } <line26> } <line27> } <line28> "	"<line18>        LOGGER.warn(MessageFormat.format(""Found multiple implementations for ActionTrace {0}. Returning first""+ "" implementation"",scriptParameterDesignTraceKey.toString()));"	task4	
"public class A { <line0> private Map<Class<? extends IdentifiableObject>, List<IdentifiableObject>> parseClassListMap( <line1> String metadataVersionSnapshot) { <line2> ByteArrayInputStream byteArrayInputStream = <line3> new ByteArrayInputStream(metadataVersionSnapshot.getBytes(StandardCharsets.UTF_8)); <line4> try { <line5> return renderService.fromMetadata(byteArrayInputStream, RenderFormat.JSON); <line6> } catch (IOException ex) { <line7> String message = <line8> ""Exception occurred while trying to do JSON conversion while parsing class list map""; <line9> throw new MetadataSyncServiceException(message, ex); <line10> } catch (Exception ex) { <line11> throw new MetadataSyncServiceException(ex.getMessage(), ex); <line12> } <line13> } <line14> } <line15> "	<line9>      log.error(message);	task4	
"public class A { <line0> @XContent(""uninstall"") <line1> public void setUninstallCommands(DocumentFragment df) { <line2> try { <line3> uninstall = DOMCommandsParser.parse(df); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> "	"<line5>      log.error(""Failed to set uninstall commands"");"	task4	
"public class A { <line0> public InsightsContentConfig getContentConfig(int contentId) { <line1> try { <line2> Map<String, Object> parameters = new HashMap<>(); <line3> parameters.put(""contentId"", contentId); <line4> return getUniqueResult( <line5> ""FROM InsightsContentConfig CC WHERE CC.contentId = :contentId "", <line6> InsightsContentConfig.class, <line7> parameters); <line8> } catch (Exception e) { <line9> throw e; <line10> } <line11> } <line12> } <line13> "	<line9>      log.error(e);	task4	
public class A { <line0> public void stop() { <line1> try { <line2> try { <line3> for (final Counter counter : counters) { <line4> counter.writeToFile(); <line5> } <line6> } finally { <line7> storageLock.release(); <line8> } <line9> } catch (final IOException e) { <line10> } finally { <line11> try { <line12> for (final Counter counter : counters) { <line13> counter.clear(); <line14> } <line15> } finally { <line16> if (metricsPublishers != null) { <line17> for (final MetricsPublisher metricsPublisher : metricsPublishers) { <line18> metricsPublisher.stop(); <line19> } <line20> } <line21> } <line22> stopped = true; <line23> } <line24> } <line25> } <line26> 	"<line10>      LOG.warn(""exception while writing counters data to files"", e);"	task4	
public class A { <line0> @Override <line1> public void getUserListMemberships(final long cursor) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(USER_LIST_MEMBERSHIPS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> PagableResponseList<UserList> lists = twitter.getUserListMemberships(cursor); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotUserListMemberships(lists); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at getUserListMemberships"", e);"	task4	
public class A { <line0> @Override <line1> public boolean matches(final ConditionContext context, final AnnotatedTypeMetadata metadata) { <line2> final boolean enabled = SQS.equals(RpcStrategy.getRpcStrategy()); <line3> return enabled; <line4> } <line5> } <line6> 	"<line3>    LOG.debug(""Enable SQS RPC: {}"", enabled);"	task4	
"public class A { <line0> static Index wrapIndexWithOptions(final Index index, final IndexPluginOptions options) { <line1> Index retVal = index; <line2> if ((options.basicIndexOptions.getNumPartitions() > 1) <line3> && options.basicIndexOptions.getPartitionStrategy().equals(PartitionStrategy.ROUND_ROBIN)) { <line4> retVal = <line5> new CustomNameIndex( <line6> new CompoundIndexStrategy( <line7> new RoundRobinKeyIndexStrategy(options.basicIndexOptions.getNumPartitions()), <line8> index.getIndexStrategy()), <line9> index.getIndexModel(), <line10> index.getName() <line11> + ""_"" <line12> + PartitionStrategy.ROUND_ROBIN.name() <line13> + ""_"" <line14> + options.basicIndexOptions.getNumPartitions()); <line15> } else if (options.basicIndexOptions.getNumPartitions() > 1) { <line16> if (options.basicIndexOptions.getPartitionStrategy().equals(PartitionStrategy.NONE)) { <line17> } <line18> retVal = <line19> new CustomNameIndex( <line20> new CompoundIndexStrategy( <line21> new HashKeyIndexStrategy(options.basicIndexOptions.getNumPartitions()), <line22> index.getIndexStrategy()), <line23> index.getIndexModel(), <line24> index.getName() <line25> + ""_"" <line26> + PartitionStrategy.HASH.name() <line27> + ""_"" <line28> + options.basicIndexOptions.getNumPartitions()); <line29> } <line30> if ((options.getName() != null) && (options.getName().length() > 0)) { <line31> retVal = <line32> new CustomNameIndex(retVal.getIndexStrategy(), retVal.getIndexModel(), options.getName()); <line33> } <line34> return retVal; <line35> } <line36> } <line37> "	"<line17>        LOGGER.warn(""Partition strategy is necessary when using more than 1 partition, defaulting to 'hash'""+ "" partitioning."");"	task4	
public class A { <line0> private Calibrator readPolynomialCalibrator() throws XMLStreamException { <line1> checkStartElementPreconditions(); <line2> int maxExponent = 0; <line3> HashMap<Integer, Double> polynome = new HashMap<>(); <line4> while (true) { <line5> xmlEvent = xmlEventReader.nextEvent(); <line6> if (isStartElementWithName(XTCE_TERM)) { <line7> XtceTerm term = readTerm(); <line8> if (term.getExponent() > maxExponent) { <line9> maxExponent = term.getExponent(); <line10> } <line11> polynome.put(term.getExponent(), term.getCoefficient()); <line12> } else if (isEndElementWithName(XTCE_POLYNOMIAL_CALIBRATOR)) { <line13> double[] coefficients = new double[maxExponent + 1]; <line14> for (Map.Entry<Integer, Double> entry : polynome.entrySet()) { <line15> coefficients[entry.getKey()] = entry.getValue(); <line16> } <line17> return new PolynomialCalibrator(coefficients); <line18> } else { <line19> logUnknown(); <line20> } <line21> } <line22> } <line23> } <line24> 	<line1>    log.trace(XTCE_POLYNOMIAL_CALIBRATOR);	task4	
public class A { <line0> public SearchResult getByQuery(String query, int limit, int offset) throws SearchException { <line1> try { <line2> return solrRequester.getByQuery(query, limit, offset); <line3> } catch (SolrServerException e) { <line4> throw new SearchException(e); <line5> } <line6> } <line7> } <line8> 	"<line2>      logger.debug(""Searching index using custom query '"" + query + ""'"");"	task4	
"public class A { <line0> @Override <line1> public void endRead() { <line2> queryProfile.incScanRows(scanCnt); <line3> queryProfile.incFilterRows(filterCnt); <line4> if (queryProfile.isDetailProfileEnable()) { <line5> String stepName = getQueryStepName(); <line6> StreamingQueryProfile.ProfileStep profileStep = queryProfile.finishStep(stepName); <line7> profileStep <line8> .stepInfo(""scan_count"", String.valueOf(scanCnt)) <line9> .stepInfo(""filter_count"", String.valueOf(filterCnt)); <line10> } <line11> } <line12> } <line13> "	"<line10>      logger.info(""query-{}: segment-{} memory store scan finished, take {} ms"",queryProfile.getQueryId(),segmentName,profileStep.getDuration());"	task4	
"public class A { <line0> public InstancesResult getRunningInstances( <line1> String type, <line2> String entity, <line3> String colo, <line4> List<LifeCycle> lifeCycles, <line5> String filterBy, <line6> String orderBy, <line7> String sortOrder, <line8> Integer offset, <line9> Integer numResults) { <line10> checkColo(colo); <line11> checkType(type); <line12> try { <line13> lifeCycles = checkAndUpdateLifeCycle(lifeCycles, type); <line14> validateNotEmpty(""entityName"", entity); <line15> validateInstanceFilterByClause(filterBy); <line16> Entity entityObject = EntityUtil.getEntity(type, entity); <line17> AbstractWorkflowEngine wfEngine = getWorkflowEngine(entityObject); <line18> return getInstanceResultSubset( <line19> wfEngine.getRunningInstances(entityObject, lifeCycles), <line20> filterBy, <line21> orderBy, <line22> sortOrder, <line23> offset, <line24> numResults, <line25> """"); <line26> } catch (Throwable e) { <line27> throw FalconWebException.newAPIException(e); <line28> } <line29> } <line30> } <line31> "	"<line27>      LOG.error(""Failed to get running instances"", e);"	task4	
"public class A { <line0> public static void deleteCommerceApplicationBrand( <line1> HttpPrincipal httpPrincipal, long commerceApplicationBrandId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceApplicationBrandServiceUtil.class, <line7> ""deleteCommerceApplicationBrand"", <line8> _deleteCommerceApplicationBrandParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceApplicationBrandId); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public boolean getBooleanProperty(final String name) throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> return message.getBooleanProperty(name); <line5> } <line6> } <line7> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""getBooleanProperty("" + name + "")"");"	task4	
"public class A { <line0> @Override <line1> public void render(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) <line2> throws IOException { <line3> try { <line4> RenderRequest renderRequest = <line5> (RenderRequest) httpServletRequest.getAttribute(JavaConstants.JAVAX_PORTLET_REQUEST); <line6> CommerceVirtualOrderItemEditDisplayContext commerceVirtualOrderItemEditDisplayContext = <line7> new CommerceVirtualOrderItemEditDisplayContext( <line8> _commerceOrderService, <line9> _commerceOrderItemService, <line10> getCommerceVirtualOrderItem(httpServletRequest), <line11> _dlAppService, <line12> _itemSelector, <line13> renderRequest); <line14> httpServletRequest.setAttribute( <line15> WebKeys.PORTLET_DISPLAY_CONTEXT, commerceVirtualOrderItemEditDisplayContext); <line16> } catch (PortalException portalException) { <line17> } <line18> _jspRenderer.renderJSP( <line19> _servletContext, <line20> httpServletRequest, <line21> httpServletResponse, <line22> ""/order_item/virtual_settings.jsp""); <line23> } <line24> } <line25> "	<line17>      log.error(portalException, portalException);	task4	
public class A { <line0> private String convertIterationCondition(DataType iterationCondition) { <line1> if (iterationCondition == null) { <line2> return null; <line3> } else if (iterationCondition instanceof Text) { <line4> return iterationCondition.toString(); <line5> } else { <line6> return iterationCondition.toString(); <line7> } <line8> } <line9> } <line10> 	"<line6>      LOGGER.warn(MessageFormat.format(this.getActionExecution().getAction().getType()+ "" does not accept {0} as type for iterationCondition"",iterationCondition.getClass()));"	task4	
"public class A { <line0> public static boolean isProcessRunning(int pid) throws IOException { <line1> boolean isRunning = false; <line2> SafeProcess proc = null; <line3> BufferedReader br = null; <line4> try { <line5> if (isUsingBusyBox()) { <line6> proc = ProcessUtil.exec(""ps""); <line7> } else { <line8> proc = ProcessUtil.exec(PS_COMMAND); <line9> } <line10> proc.waitFor(); <line11> br = new BufferedReader(new InputStreamReader(proc.getInputStream())); <line12> String line = br.readLine(); <line13> while ((line = br.readLine()) != null) { <line14> if (parsePid(line) == pid) { <line15> isRunning = true; <line16> break; <line17> } <line18> } <line19> return isRunning; <line20> } catch (InterruptedException e) { <line21> Thread.currentThread().interrupt(); <line22> throw new IOException(e); <line23> } finally { <line24> if (br != null) { <line25> br.close(); <line26> } <line27> if (proc != null) { <line28> ProcessUtil.destroy(proc); <line29> } <line30> } <line31> } <line32> } <line33> "	"<line5>      logger.trace(""searching process list for pid{}"", pid);"	task4	
public class A { <line0> private void prepareCompleteResultingMessage(UnknownMessage msg) { <line1> if (msg.getDataConfig() != null) { <line2> msg.setCompleteResultingMessage(msg.getDataConfig()); <line3> } else { <line4> msg.setCompleteResultingMessage(new byte[0]); <line5> } <line6> } <line7> } <line8> 	"<line6>    LOGGER.debug(""CompleteResultinMessage: ""+ ArrayConverter.bytesToHexString(msg.getCompleteResultingMessage().getValue()));"	task4	
"public class A { <line0> public static java.util.List<com.liferay.commerce.discount.model.CommerceDiscountRel> <line1> getCPDefinitionsByCommerceDiscountId( <line2> HttpPrincipal httpPrincipal, <line3> long commerceDiscountId, <line4> String name, <line5> String languageId, <line6> int start, <line7> int end) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> CommerceDiscountRelServiceUtil.class, <line12> ""getCPDefinitionsByCommerceDiscountId"", <line13> _getCPDefinitionsByCommerceDiscountIdParameterTypes12); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, commerceDiscountId, name, languageId, start, end); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.commerce.discount.model.CommerceDiscountRel>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line24>      log.error(systemException, systemException);	task4	
public class A { <line0> public boolean isPublishKaleoDefinitionVersionButtonVisible( <line1> PermissionChecker permissionChecker, KaleoDefinitionVersion kaleoDefinitionVersion) { <line2> if (!canPublishWorkflowDefinition()) { <line3> return false; <line4> } <line5> if (kaleoDefinitionVersion != null) { <line6> try { <line7> return KaleoDefinitionVersionPermission.contains( <line8> permissionChecker, kaleoDefinitionVersion, ActionKeys.UPDATE); <line9> } catch (PortalException portalException) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> return KaleoDesignerPermission.contains( <line15> permissionChecker, <line16> _themeDisplay.getCompanyGroupId(), <line17> KaleoDesignerActionKeys.ADD_NEW_WORKFLOW); <line18> } <line19> } <line20> 	<line11>          log.debug(portalException, portalException);	task4	
"public class A { <line0> @Override <line1> public int read(final ByteBuffer dst) throws IOException { <line2> try { <line3> final String stringValue = getConvertedPropertyValue(securityContext, graphObject, key); <line4> final byte[] bytes = stringValue.getBytes(Charset.forName(""utf-8"")); <line5> dst.put(bytes); <line6> return bytes.length; <line7> } catch (FrameworkException fex) { <line8> } <line9> return 0; <line10> } <line11> } <line12> "	"<line8>      logger.warn("""", fex);"	task4	
"public class A { <line0> @Test <line1> public void testMovingTarget() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> Map<String, Object> properties = <line5> new LinkedHashMap<String, Object>() { <line6> { <line7> put(""username"", ""edanuff""); <line8> put(""email"", ""ed@anuff.com""); <line9> put( <line10> ""location"", <line11> new LinkedHashMap<String, Object>() { <line12> { <line13> put(""latitude"", 37.776753); <line14> put(""longitude"", -122.407846); <line15> } <line16> }); <line17> } <line18> }; <line19> Entity user = em.create(""user"", properties); <line20> assertNotNull(user); <line21> app.waitForQueueDrainAndRefreshIndex(); <line22> final double lat = 37.776753; <line23> final double lon = -122.407846; <line24> Query query = Query.fromQL(""select * where location within 100 of "" + lat + "","" + lon); <line25> Results listResults = em.searchCollection(em.getApplicationRef(), ""users"", query); <line26> assertEquals(1, listResults.size()); <line27> updatePos(em, user, 37.428526, -122.140916); <line28> listResults = em.searchCollection(em.getApplicationRef(), ""users"", query); <line29> assertEquals(0, listResults.size()); <line30> em.delete(user); <line31> } <line32> } <line33> "	"<line2>    logger.info(""GeoIT.testMovingTarget"");"	task4	
public class A { <line0> public void handle(PortletContainerException e) { <line1> } <line2> } <line3> 	"<line1>    log.error(""The portlet could not be loaded. Check if properly deployed."",ExceptionUtil.getRootCause(e));"	task4	
public class A { <line0> @Override <line1> protected void decode( <line2> final ChannelHandlerContext context, final ByteBuf in, final List<Object> out) { <line3> if (RntbdFramer.canDecodeHead(in)) { <line4> final RntbdResponse response = RntbdResponse.decode(in); <line5> if (response != null) { <line6> in.discardReadBytes(); <line7> out.add(response.retain()); <line8> } <line9> } <line10> } <line11> } <line12> 	"<line6>        logger.debug(""{} DECODE COMPLETE: {}"", context.channel(), response);"	task4	
"public class A { <line0> @Override <line1> public List<CatalogEntity> getCatalogs() { <line2> try { <line3> return catalogsCache.get( <line4> """", <line5> () -> { <line6> return delegate.getCatalogs(); <line7> }); <line8> } catch (ExecutionException executionException) { <line9> return delegate.getCatalogs(); <line10> } <line11> } <line12> } <line13> "	"<line9>      log.debug(executionException.getCause(),""Error while caching all catalogs metadata. Falling back to default flow"");"	task4	
"public class A { <line0> public static int getPendingCommerceOrdersCount( <line1> HttpPrincipal httpPrincipal, long groupId, long commerceAccountId, String keywords) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceOrderServiceUtil.class, <line7> ""getPendingCommerceOrdersCount"", <line8> _getPendingCommerceOrdersCountParameterTypes21); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, groupId, commerceAccountId, keywords); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> protected void doProcessAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws Exception { <line3> try { <line4> long layoutPrototypeId = ParamUtil.getLong(actionRequest, ""layoutPrototypeId""); <line5> Map<Locale, String> nameMap = <line6> HashMapBuilder.put(actionRequest.getLocale(), ParamUtil.getString(actionRequest, ""name"")) <line7> .build(); <line8> ServiceContext serviceContext = <line9> ServiceContextFactory.getInstance(LayoutPrototype.class.getName(), actionRequest); <line10> _layoutPrototypeService.updateLayoutPrototype( <line11> layoutPrototypeId, nameMap, new HashMap<>(), true, serviceContext); <line12> String redirect = ParamUtil.getString(actionRequest, ""redirect""); <line13> JSONPortletResponseUtil.writeJSON( <line14> actionRequest, actionResponse, JSONUtil.put(""redirectURL"", redirect)); <line15> } catch (Throwable throwable) { <line16> if (log.isDebugEnabled()) { <line17> } <line18> if (throwable instanceof LayoutPageTemplateEntryNameException) { <line19> LayoutPageTemplateEntryNameException layoutPageTemplateEntryNameException = <line20> (LayoutPageTemplateEntryNameException) throwable; <line21> _layoutPageTemplateEntryExceptionRequestHandler.handlePortalException( <line22> actionRequest, actionResponse, layoutPageTemplateEntryNameException); <line23> } else { <line24> ThemeDisplay themeDisplay = <line25> (ThemeDisplay) actionRequest.getAttribute(WebKeys.THEME_DISPLAY); <line26> JSONPortletResponseUtil.writeJSON( <line27> actionRequest, <line28> actionResponse, <line29> JSONUtil.put( <line30> ""error"", <line31> LanguageUtil.get(themeDisplay.getRequest(), ""an-unexpected-error-occurred""))); <line32> } <line33> } <line34> } <line35> } <line36> "	<line17>        log.debug(throwable, throwable);	task4	
public class A { <line0> @Override <line1> public boolean hasTgpp2MEID() { <line2> Avp terminalInfoAvp = super.message.getAvps().getAvp(Avp.TERMINAL_INFORMATION); <line3> if (terminalInfoAvp != null) { <line4> try { <line5> return terminalInfoAvp.getGrouped().getAvp(Avp.TGPP2_MEID) != null; <line6> } catch (AvpDataException ex) { <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> 	"<line7>        logger.debug(""Failure trying to obtain (Terminal-Information) MEID AVP value"", ex);"	task4	
public class A { <line0> private String getConfigAttributeValue(Element element, String attributeName) { <line1> String value = null; <line2> if (element != null && attributeName != null) { <line3> final String property = getAttributeSystemPropertyName(element, attributeName); <line4> value = System.getProperty(property); <line5> if (value != null) { <line6> } else { <line7> value = element.getAttribute(attributeName); <line8> } <line9> } <line10> return (value); <line11> } <line12> } <line13> 	"<line6>        LOG.warn(""Configuration value overridden by system property: {}, with value: {}"",property,value);"	task4	
public class A { <line0> @Override <line1> public void synchronize() throws PortalException { <line2> if (log.isDebugEnabled()) { <line3> } <line4> updateFolders(); <line5> String key = AccountLock.getKey(user.getUserId(), account.getAccountId()); <line6> if (AccountLock.acquireLock(key)) { <line7> List<Folder> folders = FolderLocalServiceUtil.getFolders(account.getAccountId()); <line8> try { <line9> for (Folder folder : folders) { <line10> _imapAccessor.storeEnvelopes(folder.getFolderId(), true); <line11> } <line12> } finally { <line13> AccountLock.releaseLock(key); <line14> } <line15> } <line16> } <line17> } <line18> 	"<line3>      log.debug(""Synchronizing all folders for accountId "" + account.getAccountId());"	task4	
"public class A { <line0> private ReportResult generateReport(Path userCsvFolder, Profile profile, DashBoard dash, long now) <line1> throws Exception { <line2> int fetchCount = (int) report.reportType.getFetchCount(report.granularityType); <line3> long startFrom = now - TimeUnit.DAYS.toMillis(report.reportType.getDuration()); <line4> startFrom = (startFrom / report.granularityType.period) * report.granularityType.period; <line5> Path output = Paths.get(userCsvFolder.toString() + "".zip""); <line6> boolean hasData = generateReport(output, profile, dash, fetchCount, startFrom); <line7> if (hasData) { <line8> sendEmail(output); <line9> return ReportResult.OK; <line10> } <line11> return ReportResult.NO_DATA; <line12> } <line13> } <line14> "	"<line11>    log.info(""No data for report for user {} and reportId {}."", key.user.email, report.id);"	task4	
"public class A { <line0> private static String[] expandFileNames(String fileName) throws IOException { <line1> if (fileName.matches(""^[a-zA-Z]+:.*"")) { <line2> return new String[] {fileName}; <line3> } <line4> if (fileName.startsWith(""~"" + File.separator)) { <line5> fileName = System.getProperty(""user.home"") + fileName.substring(1); <line6> } <line7> fileName = new File(fileName).getCanonicalPath(); <line8> DirectoryScanner scanner = new DirectoryScanner(); <line9> scanner.setIncludes(new String[] {fileName}); <line10> scanner.scan(); <line11> return scanner.getIncludedFiles(); <line12> } <line13> } <line14> "	"<line8>    LOG.debug(""Canonical path: {}"", fileName);"	task4	
"public class A { <line0> public void testOrFilter2() throws Exception { <line1> String req = <line2> ""{\""filter\"":{\""or\"":[{\""term\"":{\""color\"":\""blue\"",\""_noOptimize\"":false}},{\""term\"":{\""color\"":\""red\"",\""_noOptimize\"":false}}]}}""; <line3> JSONObject res = search(new JSONObject(req)); <line4> assertEquals(""numhits is wrong"", 3264, res.getInt(""numhits"")); <line5> } <line6> } <line7> "	"<line1>    logger.info(""executing test case testOrFilter2"");"	task4	
"public class A { <line0> @Override <line1> public void rip() throws IOException { <line2> Document doc = Http.url(url).get(); <line3> Element iframe = doc.select(""iframe"").first(); <line4> String iframeSrc = iframe.attr(""src""); <line5> if (iframeSrc != null) { <line6> doc = Http.url(""http://www.yuvutu.com"" + iframeSrc).get(); <line7> } else { <line8> throw new IOException(""Could not find iframe code at "" + url); <line9> } <line10> Elements script = doc.select(""script""); <line11> if (script.isEmpty()) { <line12> throw new IOException(""Could not find script code at "" + url); <line13> } <line14> Pattern p = Pattern.compile(""file: \""(.*?)\""""); <line15> for (Element element : script) { <line16> Matcher m = p.matcher(element.data()); <line17> if (m.find()) { <line18> String vidUrl = m.group(1); <line19> addURLToDownload(new URL(vidUrl), HOST + ""_"" + getGID(this.url)); <line20> } <line21> } <line22> waitForThreads(); <line23> } <line24> } <line25> "	"<line2>    LOGGER.info(""Retrieving "" + this.url);"	task4	
"public class A { <line0> protected boolean skip() { <line1> List<CompilationUnit> cUnits = tcCtx.getTestCase().getCompilationUnit(); <line2> for (CompilationUnit cUnit : cUnits) { <line3> List<TestFileContext> testFileCtxs = tcCtx.getTestFiles(cUnit); <line4> for (TestFileContext ctx : testFileCtxs) { <line5> if (ctx.getType().equals(EXTERNAL_LIBRARY_TEST_GROUP)) { <line6> return true; <line7> } <line8> } <line9> } <line10> for (TestGroup group : tcCtx.getTestGroups()) { <line11> if (group != null && ""api"".equals(group.getName())) { <line12> return true; <line13> } <line14> } <line15> return false; <line16> } <line17> } <line18> "	"<line12>        LOGGER.info(""Skipping test: "" + tcCtx.toString());"	task4	
public class A { <line0> @Override <line1> public void dataGroupsChanged() { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> rebuildTree(); <line5> } <line6> } <line7> 	"<line3>      LOGGER.debug(""Data Groups Changed: Request Tree Rebuild"");"	task4	
public class A { <line0> private void checkNodes0(final int expCnt) throws Exception { <line1> boolean wait = <line2> GridTestUtils.waitForCondition( <line3> new GridAbsPredicate() { <line4> @Override <line5> public boolean apply() { <line6> try { <line7> checkNodes(expCnt); <line8> return true; <line9> } catch (AssertionError e) { <line10> } <line11> return false; <line12> } <line13> }, <line14> 10_000); <line15> if (!wait) checkNodes(expCnt); <line16> } <line17> } <line18> 	"<line10>                  log.info(""Check failed, will retry: "" + e);"	task4	
"public class A { <line0> public static void deleteFileEntry(HttpPrincipal httpPrincipal, long fileEntryId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> DLFileEntryServiceUtil.class, ""deleteFileEntry"", _deleteFileEntryParameterTypes8); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, fileEntryId); <line7> try { <line8> TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line11> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line12> } <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>      log.error(systemException, systemException);	task4	
public class A { <line0> @Test <line1> public void testClientService() throws Exception { <line2> UUID clientNodeId = grid(CLIENT_IDX).cluster().localNode().id(); <line3> for (int i = 0; i < NODES_CNT; i++) { <line4> final Ignite ignite = grid(i); <line5> ignite <line6> .services(ignite.cluster().forClients()) <line7> .deployNodeSingleton(SINGLETON_NAME, new TestService()); <line8> final ClusterGroup grp = ignite.cluster(); <line9> assertEquals(NODES_CNT, grp.nodes().size()); <line10> GridTestUtils.waitForCondition( <line11> new GridAbsPredicate() { <line12> @Override <line13> public boolean apply() { <line14> return ignite.services(grp).serviceDescriptors().size() == 1; <line15> } <line16> }, <line17> 5000); <line18> Collection<ServiceDescriptor> srvDscs = ignite.services(grp).serviceDescriptors(); <line19> assertEquals(1, srvDscs.size()); <line20> Map<UUID, Integer> nodesMap = F.first(srvDscs).topologySnapshot(); <line21> assertEquals(1, nodesMap.size()); <line22> for (Map.Entry<UUID, Integer> nodeInfo : nodesMap.entrySet()) { <line23> assertEquals(clientNodeId, nodeInfo.getKey()); <line24> assertEquals(1, nodeInfo.getValue().intValue()); <line25> } <line26> ignite.services().cancelAll(); <line27> } <line28> } <line29> } <line30> 	"<line4>      log.info(""Iteration: "" + i);"	task4	
public class A { <line0> @Override <line1> public void stop() { <line2> try { <line3> server.stop(); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.warn(""Failed to stop web server"", ex);"	task4	
public class A { <line0> @Override <line1> public Option<String> apply(InputStream is) { <line2> try { <line3> return some(IOUtils.toString(is)); <line4> } catch (Exception e) { <line5> return none(); <line6> } <line7> } <line8> } <line9> 	"<line5>      logger.warn(""Cannot load resource "" + resource + "" from classpath"");"	task4	
"public class A { <line0> private Publisher getOrCreatePublisher(String topic) { <line1> if (publisherMap.containsKey(topic)) { <line2> return publisherMap.get(topic); <line3> } else { <line4> try { <line5> admin.createTopicIfNotExists(topic); <line6> ProjectTopicName topicName = ProjectTopicName.of(pubSubSettings.getProjectId(), topic); <line7> Publisher publisher = <line8> Publisher.newBuilder(topicName) <line9> .setCredentialsProvider(pubSubSettings.getCredentialsProvider()) <line10> .build(); <line11> publisherMap.put(topic, publisher); <line12> return publisher; <line13> } catch (IOException e) { <line14> throw new RuntimeException(""Failed to create Publisher for the topic."", e); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line14>        log.error(""Failed to create Publisher for the topic [{}]."", topic, e);"	task4	
public class A { <line0> @Override <line1> public void start() { <line2> try { <line3> if (configuration.isUseJTA()) { <line4> jtaTransactionLifecycleService.registerListener( <line5> new IDMTransactionSyncListener(idmService_)); <line6> } <line7> acceptComponentRequestCall = true; <line8> RequestLifeCycle.begin(this); <line9> super.start(); <line10> } catch (Exception e) { <line11> } finally { <line12> RequestLifeCycle.end(); <line13> } <line14> } <line15> } <line16> 	<line11>      log.error(e.getMessage(), e);	task4	
public class A { <line0> private void shutdownGracefully() { <line1> if (Boolean.TRUE.equals(getAttribute(BrooklynNode.WEB_CONSOLE_ACCESSIBLE))) { <line2> queueShutdownTask(); <line3> queueWaitExitTask(); <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.info(""Skipping graceful shutdown call, because web-console not up for {}"", this);"	task4	
public class A { <line0> public void method(String string) { <line1> } <line2> } <line3> 	"<line1>    LOGGER.debug(""Do something thing by Sub Generic Controller"");"	task4	
public class A { <line0> @Override <line1> public void elementOpened(OpenAction action) { <line2> } <line3> } <line4> 	"<line2>    log.info(""HANDLE: OpenAction for element: "" + action.getElementId());"	task4	
public class A { <line0> private void doAck(final ClientMessageInternal message) throws ActiveMQException { <line1> ackBytes = 0; <line2> lastAckedMessage = null; <line3> if (logger.isTraceEnabled()) { <line4> } <line5> session.acknowledge(this, message); <line6> } <line7> } <line8> 	"<line4>      logger.trace(this + ""::Acking message "" + message);"	task4	
public class A { <line0> @Override <line1> public InputStream getResourceAsStream(String name) { <line2> for (ClassLoader delegate : delegates) { <line3> InputStream is = delegate.getResourceAsStream(name); <line4> if (is != null) { <line5> return is; <line6> } <line7> if (log.isTraceEnabled()) { <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> 	"<line8>        log.trace(""Resource ""+ name+ "" not found with classloader: ""+ delegate+ "". Trying other delegates"");"	task4	
public class A { <line0> private Sizeof getSizeof(Class<?> type, Type genericType) { <line1> Sizeof sizeof = sizeofByType.get(type); <line2> if (sizeof != null) { <line3> if (sizeof == SIZE_RECURSIVE_MARKER) { <line4> return Sizeof.constant(objectHeaderSize); <line5> } <line6> return sizeof; <line7> } <line8> try { <line9> sizeofByType.putIfAbsent(genericType, SIZE_RECURSIVE_MARKER); <line10> Sizeof newSizeof = computeSizeof(type, genericType); <line11> return sizeofByType.compute( <line12> genericType, <line13> (key, value) -> value == null || value == SIZE_RECURSIVE_MARKER ? newSizeof : value); <line14> } catch (Exception | StackOverflowError t) { <line15> return Sizeof.constant(objectHeaderSize); <line16> } <line17> } <line18> } <line19> 	"<line15>      log.error(""sizeof: Failed to compute function for "" + type + "": "", t);"	task4	
public class A { <line0> private OrgDisambiguatedEntity createDisambiguatedOrg(RDFOrganization organization) { <line1> String orgType = getOrgType(organization); <line2> Iso3166Country country = <line3> StringUtils.isNotBlank(organization.country) <line4> ? Iso3166Country.fromValue(organization.country) <line5> : null; <line6> OrgDisambiguatedEntity orgDisambiguatedEntity = new OrgDisambiguatedEntity(); <line7> orgDisambiguatedEntity.setName(organization.name); <line8> orgDisambiguatedEntity.setCountry(country == null ? null : country.name()); <line9> orgDisambiguatedEntity.setCity(organization.city); <line10> orgDisambiguatedEntity.setRegion(organization.stateCode); <line11> orgDisambiguatedEntity.setOrgType(orgType); <line12> orgDisambiguatedEntity.setSourceId(organization.doi); <line13> orgDisambiguatedEntity.setSourceUrl(organization.doi); <line14> if (!PojoUtil.isEmpty(organization.status)) { <line15> orgDisambiguatedEntity.setStatus(OrganizationStatus.DEPRECATED.name()); <line16> } <line17> if (!PojoUtil.isEmpty(organization.isReplacedBy)) { <line18> orgDisambiguatedEntity.setSourceParentId(organization.isReplacedBy); <line19> orgDisambiguatedEntity.setStatus(OrganizationStatus.DEPRECATED.name()); <line20> } <line21> orgDisambiguatedEntity.setSourceType(OrgDisambiguatedSourceType.FUNDREF.name()); <line22> orgDisambiguatedManager.createOrgDisambiguated(orgDisambiguatedEntity); <line23> return orgDisambiguatedEntity; <line24> } <line25> } <line26> 	"<line1>    LOGGER.info(""Creating disambiguated org {}"", organization.name);"	task4	
public class A { <line0> @Override <line1> public void addLongField(String fieldName, long value) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> fieldList.add(new JSONFieldHolder(fieldName, value, FieldType.LONG)); <line5> } <line6> } <line7> 	"<line3>      logger.trace(""addLongField fieldName: {}; value: {}"", fieldName, value);"	task4	
public class A { <line0> private ClassLoader getPluginClassLoader() { <line1> Properties props = getEPDProperties(); <line2> String pathsValue = props.getProperty(CLASSPATH_PROPERTY); <line3> if (pathsValue == null || pathsValue.isEmpty()) { <line4> return null; <line5> } <line6> String[] pathNames = pathsValue.split(File.pathSeparator); <line7> List<URL> paths = new ArrayList<>(); <line8> for (String pathName : pathNames) { <line9> File pathElement = new File(pathName); <line10> if (!pathElement.isAbsolute()) { <line11> pathElement = getHomePath().resolve(pathName).toFile(); <line12> } <line13> if (!pathElement.exists()) { <line14> continue; <line15> } <line16> try { <line17> paths.add(pathElement.toURI().toURL()); <line18> } catch (MalformedURLException e) { <line19> } <line20> } <line21> return new URLClassLoader( <line22> paths.toArray(new URL[paths.size()]), PluginLoader.class.getClassLoader()); <line23> } <line24> } <line25> 	"<line19>        LOG.debug(""Malformed URL from "" + pathName, e);"	task4	
public class A { <line0> private void stopConnectionCheck() { <line1> if (connectionCheckTask != null) { <line2> connectionCheckTask.cancel(true); <line3> connectionCheckTask = null; <line4> } <line5> } <line6> } <line7> 	"<line2>      logger.debug(""Stop periodic connection check"");"	task4	
"public class A { <line0> @Override <line1> public void process(Channel channel, Command command) { <line2> Preconditions.checkArgument( <line3> CommandType.TASK_EXECUTE_ACK == command.getType(), <line4> String.format(""invalid command type : %s"", command.getType())); <line5> TaskExecuteAckCommand taskAckCommand = <line6> JSONUtils.parseObject(command.getBody(), TaskExecuteAckCommand.class); <line7> taskInstanceCacheManager.cacheTaskInstance(taskAckCommand); <line8> String workerAddress = ChannelUtils.toAddress(channel).getAddress(); <line9> ExecutionStatus ackStatus = ExecutionStatus.of(taskAckCommand.getStatus()); <line10> TaskResponseEvent taskResponseEvent = <line11> TaskResponseEvent.newAck( <line12> ackStatus, <line13> taskAckCommand.getStartTime(), <line14> workerAddress, <line15> taskAckCommand.getExecutePath(), <line16> taskAckCommand.getLogPath(), <line17> taskAckCommand.getTaskInstanceId(), <line18> channel); <line19> taskResponseService.addResponse(taskResponseEvent); <line20> } <line21> } <line22> "	"<line7>    logger.info(""taskAckCommand : {}"", taskAckCommand);"	task4	
"public class A { <line0> @Override <line1> @SecurityCheck <line2> public boolean isUserExist(AuthzToken authzToken, String username) <line3> throws IamAdminServicesException, AuthorizationException, TException { <line4> TenantManagementKeycloakImpl keycloakclient = new TenantManagementKeycloakImpl(); <line5> String gatewayId = authzToken.getClaimsMap().get(Constants.GATEWAY_ID); <line6> try { <line7> return keycloakclient.isUserExist(authzToken.getAccessToken(), gatewayId, username); <line8> } catch (Exception ex) { <line9> String msg = ""Error while checking if user account exists, reason: "" + ex.getMessage(); <line10> throw new IamAdminServicesException(msg); <line11> } <line12> } <line13> } <line14> "	<line10>      logger.error(msg, ex);	task4	
"public class A { <line0> public void setTargetFramework(String dotnetFramework) { <line1> if (!frameworks.containsKey(dotnetFramework)) { <line2> throw new IllegalArgumentException( <line3> ""Invalid .NET framework version: "" <line4> + dotnetFramework <line5> + "". List of supported versions: "" <line6> + frameworkStrategies.stream().map(p -> p.name).collect(Collectors.joining("", ""))); <line7> } else { <line8> this.targetFramework = dotnetFramework; <line9> } <line10> } <line11> } <line12> "	"<line10>    LOGGER.info(""Generating code for .NET Framework "" + this.targetFramework);"	task4	
public class A { <line0> @Override <line1> public void connectionClosed(final IOException e) { <line2> this.iec60870ConnectionRegistry.unregisterConnection(this.connection); <line3> } <line4> } <line5> 	"<line2>    LOGGER.info(""Connection ({}) closed."", this.connection, e);"	task4	
public class A { <line0> public void addPermission(UmaPermission permission, String clientDn) { <line1> try { <line2> addBranchIfNeeded(clientDn); <line3> permission.setDn(getDn(clientDn, permission.getTicket())); <line4> ldapEntryManager.persist(permission); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>      log.error(e.getMessage(), e);	task4	
public class A { <line0> public boolean processResponse(Response response, MessageChannel messageChannel) { <line1> try { <line2> SipProvider p = null; <line3> Boolean isIpv6 = false; <line4> InetAddress address = InetAddress.getByName(messageChannel.getHost()); <line5> if (address instanceof Inet6Address) { <line6> isIpv6 = true; <line7> p = balancerRunner.balancerContext.externalIpv6SipProvider; <line8> if (messageChannel.getPort() <line9> != balancerRunner.balancerContext.getExternalPortByTransport( <line10> messageChannel.getTransport(), isIpv6)) { <line11> if (balancerRunner.balancerContext.isTwoEntrypoints()) <line12> p = balancerRunner.balancerContext.internalIpv6SipProvider; <line13> } <line14> } else { <line15> p = balancerRunner.balancerContext.externalSipProvider; <line16> if (messageChannel.getPort() <line17> != balancerRunner.balancerContext.getExternalPortByTransport( <line18> messageChannel.getTransport(), isIpv6)) { <line19> if (balancerRunner.balancerContext.isTwoEntrypoints()) <line20> p = balancerRunner.balancerContext.internalSipProvider; <line21> } <line22> } <line23> ResponseEvent event = <line24> new ResponseEvent(new BalancerAppContent(p, isIpv6), null, null, response); <line25> balancerRunner.balancerContext.forwarder.processResponse(event); <line26> } catch (Exception e) { <line27> return false; <line28> } <line29> return false; <line30> } <line31> } <line32> 	"<line27>      logger.error(""A Problem happened in the BalancerValve on response "" + response, e);"	task4	
public class A { <line0> public void enforce(IAgreement agreement, Date since, boolean isLastExecution) { <line1> final Date now = new Date(); <line2> checkInitialized(true); <line3> Map<IGuaranteeTerm, IMetricsRetrieverV2.RetrievalItem> retrievalItems = <line4> buildRetrievalItems(agreement, since, now, isLastExecution); <line5> Map<IGuaranteeTerm, List<IMonitoringMetric>> metricsMap; <line6> if (retriever instanceof IMetricsRetrieverV2) { <line7> metricsMap = getMetrics((IMetricsRetrieverV2) retriever, agreement, retrievalItems); <line8> } else { <line9> metricsMap = getMetrics(retriever, agreement, retrievalItems); <line10> } <line11> enforce(agreement, metricsMap); <line12> } <line13> } <line14> 	"<line1>    logger.debug(""enforce(agreement={},since={})"", agreement.getAgreementId(), since);"	task4	
"public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntry checkOutFileEntry( <line1> HttpPrincipal httpPrincipal, <line2> long fileEntryId, <line3> String owner, <line4> long expirationTime, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> DLAppServiceUtil.class, ""checkOutFileEntry"", _checkOutFileEntryParameterTypes14); <line11> MethodHandler methodHandler = <line12> new MethodHandler(methodKey, fileEntryId, owner, expirationTime, serviceContext); <line13> Object returnObj = null; <line14> try { <line15> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (com.liferay.portal.kernel.repository.model.FileEntry) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line24>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public void disposeModel() { <line2> model = null; <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""Disposing Model on CamelContext"");"	task4	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> protected String determineSelector( <line2> boolean legacyMapping, <line3> String legacyId, <line4> String selector, <line5> ServiceReference<S> serviceReference) { <line6> if (selector != null && legacyId != null) { <line7> legacyId = null; <line8> } <line9> if (!legacyMapping && selector == null && legacyId != null) { <line10> selector = <line11> String.format(""(%s=%s)"", HttpWhiteboardConstants.HTTP_SERVICE_CONTEXT_PROPERTY, legacyId); <line12> } <line13> if (!legacyMapping && selector == null) { <line14> selector = <line15> String.format( <line16> ""(%s=%s)"", <line17> HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_NAME, <line18> HttpWhiteboardConstants.HTTP_WHITEBOARD_DEFAULT_CONTEXT_NAME); <line19> } <line20> return selector; <line21> } <line22> } <line23> "	"<line7>      log.warn(""Both legacy {} and R7 {} properties are specified. Using R7 property: {}."",PaxWebConstants.SERVICE_PROPERTY_HTTP_CONTEXT_ID,HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT,selector);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> processor.processTimeout(entry); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOGGER.error(""process sync timeout request error"", e);"	task4	
public class A { <line0> public Set<String> getTargetNodes( <line1> Collection<String> allowedGroups, ITreeNodeBaseActionHelper helper) { <line2> Set<String> targets = this.convertCollection(this.getTreeNodesToOpen()); <line3> try { <line4> String targetNode = this.getTargetNode(); <line5> Boolean open = this.getOpen(); <line6> if (open != null && !open) { <line7> targets = helper.checkTargetNodesOnClosing(targetNode, targets, allowedGroups); <line8> } else { <line9> targets = helper.checkTargetNodes(targetNode, targets, allowedGroups); <line10> } <line11> } catch (Throwable t) { <line12> } <line13> return targets; <line14> } <line15> } <line16> 	"<line12>      logger.error(""error in buildTree"", t);"	task4	
"public class A { <line0> @Deprecated <line1> public void remove(ConfigScope scope, List<String> keys) { <line2> if (scope == null || scope.getScope() == null) { <line3> return; <line4> } <line5> String clusterName = scope.getClusterName(); <line6> if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) { <line7> throw new HelixException(""cluster "" + clusterName + "" is not setup yet""); <line8> } <line9> String scopeStr = scope.getScopeStr(); <line10> String[] splits = scopeStr.split(""\\|""); <line11> String id = splits[0].substring(splits[0].lastIndexOf('/') + 1); <line12> ZNRecord update = new ZNRecord(id); <line13> if (splits.length == 1) { <line14> for (String key : keys) { <line15> update.setSimpleField(key, """"); <line16> } <line17> } else if (splits.length == 2) { <line18> if (update.getMapField(splits[1]) == null) { <line19> update.setMapField(splits[1], new TreeMap<String, String>()); <line20> } <line21> for (String key : keys) { <line22> update.getMapField(splits[1]).put(key, """"); <line23> } <line24> } <line25> ZKUtil.subtract(_zkClient, splits[0], update); <line26> } <line27> } <line28> "	"<line3>      LOG.error(""Scope can't be null."");"	task4	
public class A { <line0> public static void inoutdemo(int in1, int[] inout1, int[] out1) { <line1> inout1[0] = 1; <line2> out1[0] = 2; <line3> } <line4> } <line5> 	"<line1>    LOG.info(""calling inoutdemo: {}, {}"", inout1[0], out1[0]);"	task4	
"public class A { <line0> @Test <line1> public void testInsertEmptyWhere() throws Exception { <line2> StringBuilder update = new StringBuilder(); <line3> update.append(getNamespaceDeclarations()); <line4> update.append(""INSERT { <"" + bob + ""> rdfs:label \""Bob\"" . } WHERE { }""); <line5> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update.toString()); <line6> assertFalse(con.hasStatement(bob, RDFS.LABEL, f.createLiteral(""Bob""), true)); <line7> operation.execute(); <line8> assertTrue(con.hasStatement(bob, RDFS.LABEL, f.createLiteral(""Bob""), true)); <line9> } <line10> } <line11> "	"<line2>    logger.debug(""executing test testInsertEmptyWhere"");"	task4	
"public class A { <line0> @Test <line1> @Atomic <line2> public void test09() { <line3> TxIntrospector txIntrospector = FenixFramework.getTransaction().getTxIntrospector(); <line4> printTest( <line5> ""Create a new book and modify its 1-* relation with '"" <line6> + LITTLE <line7> + ""' twice\n\t"" <line8> + ""(New: [ '"" <line9> + ECLIPSE <line10> + ""']; DM: []; M: ['"" <line11> + LITTLE <line12> + ""']; RCL: ['PublisherWithBooks'])""); <line13> VampireBook eclipse = createEclipse(txIntrospector); <line14> Publisher little = getPublisherByName(LITTLE); <line15> eclipse.setPublisher(little); <line16> little.addPublishedBook(eclipse); <line17> assertFalse(txIntrospector.getModifiedObjects().contains(eclipse)); <line18> assertFalse(txIntrospector.getDirectlyModifiedObjects().contains(eclipse)); <line19> assertTrue(txIntrospector.getModifiedObjects().contains(little)); <line20> assertFalse(txIntrospector.getDirectlyModifiedObjects().contains(little)); <line21> } <line22> } <line23> "	<line21>    logger.trace(txIntrospector.toString());	task4	
public class A { <line0> @Override <line1> public void setAllHealthy() { <line2> enabledPorts.forEach( <line3> x -> { <line4> setHealthy(x); <line5> }); <line6> } <line7> } <line8> 	"<line5>          log.info(""Port "" + x + "" was marked as healthy"");"	task4	
"public class A { <line0> @Test(groups = {""multiCluster""}) <line1> public void scheduleProcessParallel() throws Exception { <line2> bundles[0].submitBundle(prism); <line3> for (int i = 1; i <= brothers.length; i++) { <line4> brothers[i - 1] = <line5> new Brother( <line6> ""brother"" + i, <line7> ""schedule"", <line8> EntityType.PROCESS, <line9> brotherGrimm, <line10> bundles[0], <line11> prism, <line12> URLS.SCHEDULE_URL); <line13> } <line14> for (Brother brother : brothers) { <line15> brother.start(); <line16> } <line17> for (Brother brother : brothers) { <line18> brother.join(); <line19> } <line20> for (Brother brother : brothers) { <line21> AssertUtil.assertSucceeded(brother.getOutput()); <line22> } <line23> } <line24> } <line25> "	"<line21>      LOGGER.info(brother.getName()+ "" output: \n""+ Util.prettyPrintXml(brother.getOutput().getMessage()));"	task4	
public class A { <line0> @Override <line1> public void afterSecondary(int bucketId) { <line2> dm.getExecutors() <line3> .getWaitingThreadPool() <line4> .execute( <line5> () -> { <line6> try { <line7> lucenePartitionRepositoryManager.computeRepository(bucketId); <line8> } catch (PrimaryBucketException | AlreadyClosedException e) { <line9> } <line10> }); <line11> } <line12> } <line13> 	"<line9>                logger.debug(""Exception while cleaning up Lucene Index Repository"", e);"	task4	
"public class A { <line0> @ModelAttribute(""researchGroupTitle"") <line1> private String fillResearchGroupTitleForExperiment( <line2> @RequestParam(""experimentId"") String idString) { <line3> int experimentId = Integer.parseInt(idString); <line4> Experiment experiment = (Experiment) experimentDao.read(experimentId); <line5> return experiment.getResearchGroup().getTitle(); <line6> } <line7> } <line8> "	"<line3>    log.debug(""Loading experiment info"");"	task4	
"public class A { <line0> @Override <line1> public Entry findByU_EA(long userId, String emailAddress) throws NoSuchEntryException { <line2> Entry entry = fetchByU_EA(userId, emailAddress); <line3> if (entry == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""userId=""); <line7> sb.append(userId); <line8> sb.append("", emailAddress=""); <line9> sb.append(emailAddress); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchEntryException(sb.toString()); <line14> } <line15> return entry; <line16> } <line17> } <line18> "	<line12>        log.debug(sb.toString());	task4	
"public class A { <line0> public static com.liferay.commerce.currency.model.CommerceCurrency setActive( <line1> HttpPrincipal httpPrincipal, long commerceCurrencyId, boolean active) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(CommerceCurrencyServiceUtil.class, ""setActive"", _setActiveParameterTypes9); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, commerceCurrencyId, active); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.commerce.currency.model.CommerceCurrency) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> @ResponseStatus(HttpStatus.OK) <line1> @RequestMapping(value = ""/bundles/{bundleId}/uninstallconfig"", method = RequestMethod.POST) <line2> public void uninstallBundleWithConfig(@PathVariable long bundleId) throws BundleException { <line3> moduleAdminService.uninstallBundle(bundleId, true); <line4> } <line5> } <line6> "	"<line4>    LOGGER.info(""Bundle [{}] removed successfully"");"	task4	
"public class A { <line0> private Map<String, ConfigProvider> instantiateConfigProviders( <line1> Map<String, String> indirectConfigs, Map<String, ?> providerConfigProperties) { <line2> final String configProviders = indirectConfigs.get(CONFIG_PROVIDERS_CONFIG); <line3> if (configProviders == null || configProviders.isEmpty()) { <line4> return Collections.emptyMap(); <line5> } <line6> Map<String, String> providerMap = new HashMap<>(); <line7> for (String provider : configProviders.split("","")) { <line8> String providerClass = CONFIG_PROVIDERS_CONFIG + ""."" + provider + "".class""; <line9> if (indirectConfigs.containsKey(providerClass)) <line10> providerMap.put(provider, indirectConfigs.get(providerClass)); <line11> } <line12> Map<String, ConfigProvider> configProviderInstances = new HashMap<>(); <line13> for (Map.Entry<String, String> entry : providerMap.entrySet()) { <line14> try { <line15> String prefix = CONFIG_PROVIDERS_CONFIG + ""."" + entry.getKey() + CONFIG_PROVIDERS_PARAM; <line16> Map<String, ?> configProperties = <line17> configProviderProperties(prefix, providerConfigProperties); <line18> ConfigProvider provider = Utils.newInstance(entry.getValue(), ConfigProvider.class); <line19> provider.configure(configProperties); <line20> configProviderInstances.put(entry.getKey(), provider); <line21> } catch (ClassNotFoundException e) { <line22> throw new ConfigException( <line23> ""Invalid config:"" + entry.getValue() + "" ClassNotFoundException exception occurred"", e); <line24> } <line25> } <line26> return configProviderInstances; <line27> } <line28> } <line29> "	"<line22>        log.error(""ClassNotFoundException exception occurred: "" + entry.getValue());"	task4	
public class A { <line0> public static void reset() { <line1> freemarkerConfig = null; <line2> freemarkerConfig = new Configuration(); <line3> freemarkerConfig.setObjectWrapper(new DefaultObjectWrapper()); <line4> freemarkerConfig.clearTemplateCache(); <line5> } <line6> } <line7> 	"<line5>    logger.debug(""Created new freemarker template processor for DocUtils"");"	task4	
"public class A { <line0> @Test(expected = FullTableScansDisallowedException.class) <line1> public void testSingleValueAndMultiFieldNoParens() throws Exception { <line2> for (final TestCities city : TestCities.values()) { <line3> String query = <line4> CityField.CITY.name() <line5> + LTE_OP <line6> + ""'"" <line7> + city.name() <line8> + ""'"" <line9> + AND_OP <line10> + CityField.CITY.name() <line11> + GTE_OP <line12> + ""'"" <line13> + city.name() <line14> + ""'"" <line15> + AND_OP <line16> + CityField.NUM.name() <line17> + LTE_OP <line18> + ""20"" <line19> + AND_OP <line20> + CityField.NUM.name() <line21> + GTE_OP <line22> + ""20""; <line23> try { <line24> String plan = getPlan(query, true, true); <line25> Assert.fail(""Expected FullTableScansDisallowedException but got "" + plan); <line26> } catch (FullTableScansDisallowedException e) { <line27> } <line28> String expected = <line29> CityField.CITY.name() <line30> + LTE_OP <line31> + ""'"" <line32> + city.name() <line33> + ""'"" <line34> + AND_OP <line35> + CityField.CITY.name() <line36> + GTE_OP <line37> + ""'"" <line38> + city.name() <line39> + ""'"" <line40> + AND_OP <line41> + CityField.NUM.name() <line42> + LTE_OP <line43> + ""'+bE2'"" <line44> + AND_OP <line45> + CityField.NUM.name() <line46> + GTE_OP <line47> + ""'+bE2'""; <line48> String plan = getPlan(query, true, false); <line49> assertPlanEquals(expected, plan); <line50> plan = getPlan(query, false, true); <line51> assertPlanEquals(expected, plan); <line52> expected = query; <line53> runTest(query, expected); <line54> } <line55> } <line56> } <line57> "	"<line2>    log.info(""------  testSingleValueAndMultiFieldNoParens  ------"");"	task4	
public class A { <line0> private void updateServiceContexts(Object propertyMap) { <line1> if (propertyMap instanceof Map) { <line2> String excludePrefix = ServiceHelper.getContext().getPrefix(); <line3> Map<String, Object> properties = (Map<String, Object>) propertyMap; <line4> Map<String, Object> filtered = <line5> properties.entrySet().stream() <line6> .filter(p -> !(p == null || p.getKey().startsWith(excludePrefix))) <line7> .collect(Collectors.toMap(p -> p.getKey(), p -> p.getValue())); <line8> ServiceHelper.getContext().addProperties((Map) propertyMap); <line9> } else { <line10> } <line11> } <line12> } <line13> 	"<line10>      log.warn(""Unable to update service context properties."");"	task4	
"public class A { <line0> private void performDbCleanup(Connection conn) { <line1> try { <line2> PreparedStatement pstmt = conn.prepareStatement(""SELECT domain_id FROM account_vlan_map""); <line3> try { <line4> pstmt.executeQuery(); <line5> } catch (SQLException e) { <line6> return; <line7> } <line8> pstmt = <line9> conn.prepareStatement( <line10> ""ALTER TABLE `cloud`.`account_vlan_map` DROP FOREIGN KEY"" <line11> + "" `fk_account_vlan_map__domain_id`""); <line12> pstmt.executeUpdate(); <line13> pstmt = <line14> conn.prepareStatement(""ALTER TABLE `cloud`.`account_vlan_map` DROP COLUMN `domain_id`""); <line15> pstmt.executeUpdate(); <line16> pstmt = <line17> conn.prepareStatement(""DELETE FROM `cloud`.`account_vlan_map` WHERE account_id IS NULL""); <line18> pstmt.executeUpdate(); <line19> pstmt.close(); <line20> } catch (SQLException e) { <line21> throw new CloudRuntimeException( <line22> ""Unable to delete domain_id field from account_vlan_map table due to:"", e); <line23> } <line24> } <line25> } <line26> "	"<line6>        logger.debug(""Assuming that domain_id field doesn't exist in account_vlan_map table, no need to""+ "" upgrade"");"	task4	
public class A { <line0> private void prepareDistinguishedNames(CertificateRequestMessage msg) { <line1> msg.setDistinguishedNames(chooser.getConfig().getDistinguishedNames()); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""DistinguishedNames: ""+ ArrayConverter.bytesToHexString(msg.getDistinguishedNames().getValue()));"	task4	
"public class A { <line0> @Produces <line1> @ServerPath <line2> public String getServerPath() { <line3> String configuredValue = databaseBackedConfig.getServerHost(); <line4> if (configuredValue != null) { <line5> return configuredValue; <line6> } else { <line7> String defaultServerPath = HttpRequestAndSessionHolder.getDefaultServerPath(); <line8> if (defaultServerPath == null) { <line9> return """"; <line10> } <line11> return defaultServerPath; <line12> } <line13> } <line14> } <line15> "	"<line9>        log.error(""server path is not configured in database and not yet generated from Http request!!!.""+ "" Admin need to configure it in database"");"	task4	
public class A { <line0> @PostConstruct <line1> public void init() { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> fessConfig = ComponentUtil.getFessConfig(); <line5> } <line6> } <line7> 	"<line3>      logger.debug(""Initialize {}"", this.getClass().getSimpleName());"	task4	
"public class A { <line0> @AfterGroups(groups = ""sharedHBase"") <line1> public void afterGroups(ITestContext context) throws Exception { <line2> if (hbaseCluster != null) { <line3> hBaseUtils.shutdownMiniCluster(); <line4> } <line5> getClient(context).close().get(); <line6> getTSO(context).stopAndWait(); <line7> TestUtils.waitForSocketNotListening(""localhost"", 1234, 1000); <line8> } <line9> } <line10> "	"<line2>    LOG.info(""Tearing down OmidTestBase..."");"	task4	
public class A { <line0> public void dataSource(DataSource dataSource) { <line1> ConnectionDataSourceConfig connectionConfig = new ConnectionDataSourceConfig(dataSource); <line2> connectionConfig.setDbName(dbName); <line3> connectionConfig.setEnvironment(environment); <line4> connectionConfig.setTesting(testing); <line5> DBConfiguration.addConnectionConfig(connectionConfig); <line6> } <line7> } <line8> 	"<line6>    LOGGER.info(""Configuring JDBC connection using data source: {}"", dataSource.toString());"	task4	
public class A { <line0> private void startReader(ConnectionTable connTable) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> Assert.assertTrue(!isRunning); <line4> stopped = false; <line5> isRunning = true; <line6> connTable.executeCommand(this); <line7> } <line8> } <line9> 	"<line2>      logger.debug(""Starting thread for "" + p2pReaderName());"	task4	
"public class A { <line0> @ApiOperation(value = ""Starts a new case instance for a specified case definition."") <line1> @ApiResponses( <line2> value = { <line3> @ApiResponse(code = 500, message = ""Unexpected error""), <line4> @ApiResponse(code = 404, message = ""Case definition or Container Id not found""), <line5> @ApiResponse( <line6> code = 201, <line7> response = String.class, <line8> message = ""Successful response"", <line9> examples = @Example(value = {@ExampleProperty(mediaType = JSON, value = CASE_ID_JSON)})) <line10> }) <line11> @POST <line12> @Path(START_CASE_POST_URI) <line13> @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line14> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line15> public Response startCase( <line16> @javax.ws.rs.core.Context HttpHeaders headers, <line17> @ApiParam( <line18> value = ""container id where the case definition resides"", <line19> required = true, <line20> example = ""evaluation_1.0.0-SNAPSHOT"") <line21> @PathParam(CONTAINER_ID) <line22> String containerId, <line23> @ApiParam( <line24> value = ""case definition id that new instance should be created from"", <line25> required = true, <line26> example = ""CASE-0000000001"") <line27> @PathParam(CASE_DEF_ID) <line28> String caseDefId, <line29> @ApiParam( <line30> value = ""optional CaseFile with variables and/or case role assignments"", <line31> required = false, <line32> examples = <line33> @Example( <line34> value = { <line35> @ExampleProperty(mediaType = JSON, value = CASE_FILE_JSON), <line36> @ExampleProperty(mediaType = XML, value = CASE_FILE_XML) <line37> })) <line38> String payload) { <line39> return invokeCaseOperation( <line40> headers, <line41> containerId, <line42> null, <line43> (Variant v, String type, Header... customHeaders) -> { <line44> try { <line45> String response = <line46> caseManagementServiceBase.startCase(containerId, caseDefId, payload, type); <line47> return createResponse(response, v, Response.Status.CREATED, customHeaders); <line48> } catch (CaseDefinitionNotFoundException e) { <line49> return notFound( <line50> MessageFormat.format(CASE_DEFINITION_NOT_FOUND, caseDefId, containerId), <line51> v, <line52> customHeaders); <line53> } <line54> }); <line55> } <line56> } <line57> "	"<line47>            logger.debug(""Returning CREATED response for start case with content '{}'"", response);"	task4	
public class A { <line0> private static synchronized MarshallerBuilder getMarshallerBuilder() { <line1> ServiceLoader<MarshallerBuilder> builders = ServiceLoader.load(MarshallerBuilder.class); <line2> Iterator<MarshallerBuilder> it = builders.iterator(); <line3> if (it.hasNext()) { <line4> MarshallerBuilder marshallerBuilder = it.next(); <line5> return marshallerBuilder; <line6> } <line7> return new BaseMarshallerBuilder(); <line8> } <line9> } <line10> 	"<line5>      logger.debug(""Found custom marshaller builder {} that is going to be used instead of the default"",marshallerBuilder);"	task4	
public class A { <line0> @Override <line1> public Position addEntry(byte[] data, int offset, int length) <line2> throws InterruptedException, ManagedLedgerException { <line3> final CountDownLatch counter = new CountDownLatch(1); <line4> class Result { <line5> ManagedLedgerException status = null; <line6> Position position = null; <line7> } <line8> final Result result = new Result(); <line9> asyncAddEntry( <line10> data, <line11> offset, <line12> length, <line13> new AddEntryCallback() { <line14> @Override <line15> public void addComplete(Position position, ByteBuf entryData, Object ctx) { <line16> result.position = position; <line17> counter.countDown(); <line18> } <line19>  <line20> @Override <line21> public void addFailed(ManagedLedgerException exception, Object ctx) { <line22> result.status = exception; <line23> counter.countDown(); <line24> } <line25> }, <line26> null); <line27> counter.await(); <line28> if (result.status != null) { <line29> throw result.status; <line30> } <line31> return result.position; <line32> } <line33> } <line34> 	"<line29>      log.error(""[{}] Error adding entry"", name, result.status);"	task4	
"public class A { <line0> @Test <line1> public void testTokenToConfFromUser() throws Exception { <line2> UserGroupInformation ugi = Mockito.mock(UserGroupInformation.class); <line3> JobConf jobConf = new JobConf(); <line4> ArrayList<Token<?>> tokens = new ArrayList<>(); <line5> Text service = new Text(""service""); <line6> Token<?> token = Mockito.mock(Token.class); <line7> tokens.add(token); <line8> Mockito.when(ugi.getTokens()).thenReturn(tokens); <line9> Mockito.when(token.getKind()).thenReturn(HiveAccumuloHelper.ACCUMULO_SERVICE); <line10> Mockito.when(token.getService()).thenReturn(service); <line11> try { <line12> helper.addTokenFromUserToJobConf(ugi, jobConf); <line13> } catch (IOException e) { <line14> return; <line15> } <line16> Collection<Token<?>> credTokens = jobConf.getCredentials().getAllTokens(); <line17> assertEquals(1, credTokens.size()); <line18> assertEquals(service, credTokens.iterator().next().getService()); <line19> } <line20> } <line21> "	"<line14>      log.info(""Ignoring exception, likely coming from Hadoop 1"", e);"	task4	
public class A { <line0> @Override <line1> public void onSuccess(@Nullable Collection<String> keys) { <line2> try { <line3> logTimeseriesDeleted(user, entityId, new ArrayList<>(keys), null); <line4> } catch (ThingsboardException e) { <line5> } <line6> resultFuture.set(null); <line7> } <line8> } <line9> 	"<line5>      log.error(""Failed to log timeseries delete"", e);"	task4	
public class A { <line0> public void setCardinalityConfiguration(CardinalityConfiguration cardinalityConfiguration) { <line1> this.cardinalityConfiguration = cardinalityConfiguration; <line2> try { <line3> if (cardinalityConfiguration != null) { <line4> resultCardinalityDocumentDate = <line5> new CardinalityRecord( <line6> cardinalityConfiguration.getCardinalityFields(), <line7> CardinalityRecord.DateType.DOCUMENT); <line8> resultCardinalityQueryDate = <line9> new CardinalityRecord( <line10> cardinalityConfiguration.getCardinalityFields(), <line11> CardinalityRecord.DateType.CURRENT); <line12> } <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> 	<line14>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> private String getNextFileName() throws IOException { <line1> try { <line2> String filePath = <line3> base <line4> + ""_"" <line5> + WorkerContext.get().getWorkerAttemptId() <line6> + ""_"" <line7> + taskIndex <line8> + ""_"" <line9> + currentWriteFileIndex++; <line10> Path newPath = <line11> lDirAlloc.getLocalPathForWrite(filePath, maxSizePerFile, WorkerContext.get().getConf()); <line12> return newPath.toUri().toString(); <line13> } catch (Exception e) { <line14> throw new IOException(""task UnInitializtionException"", e); <line15> } <line16> } <line17> } <line18> "	"<line12>      LOG.info(""KVDiskStorage create a new file, filePath = "" + newPath);"	task4	
"public class A { <line0> @Test <line1> public void testStringResult() throws ServiceFailureException { <line2> ObservationDao doa = service.observations(); <line3> Observation b1 = new Observation(""fourty two"", DATASTREAMS.get(0)); <line4> doa.create(b1); <line5> OBSERVATIONS.add(b1); <line6> Observation found; <line7> found = doa.find(b1.getId()); <line8> String message = ""Expected result to be a String.""; <line9> Assert.assertEquals(message, b1.getResult(), found.getResult()); <line10> } <line11> } <line12> "	"<line2>    LOGGER.info(""  testStringResult"");"	task4	
"public class A { <line0> protected int maxNumPartitions(final Cluster metadata, final Set<String> topics) { <line1> int maxNumPartitions = 0; <line2> for (final String topic : topics) { <line3> final List<PartitionInfo> partitions = metadata.partitionsForTopic(topic); <line4> if (partitions.isEmpty()) { <line5> throw new RuntimeException(""Empty partitions for topic "" + topic); <line6> } <line7> final int numPartitions = partitions.size(); <line8> if (numPartitions > maxNumPartitions) { <line9> maxNumPartitions = numPartitions; <line10> } <line11> } <line12> return maxNumPartitions; <line13> } <line14> } <line15> "	"<line5>        log.error(""Empty partitions for topic {}"", topic);"	task4	
"public class A { <line0> public static ValidationReport validatePreservationBinary(Binary binary, boolean failIfNoSchema) { <line1> ValidationReport report = new ValidationReport(); <line2> Optional<Schema> xmlSchema = RodaCoreFactory.getRodaSchema(""premis-v2-0"", null); <line3> if (xmlSchema.isPresent()) { <line4> try (InputStream inputStream = binary.getContent().createInputStream()) { <line5> Source xmlFile = new StreamSource(inputStream); <line6> Validator validator = xmlSchema.get().newValidator(); <line7> RodaErrorHandler errorHandler = new RodaErrorHandler(); <line8> validator.setErrorHandler(errorHandler); <line9> try { <line10> validator.validate(xmlFile); <line11> report.setValid(errorHandler.getErrors().isEmpty()); <line12> for (SAXParseException saxParseException : errorHandler.getErrors()) { <line13> report.addIssue(convertSAXParseException(saxParseException)); <line14> } <line15> } catch (SAXException e) { <line16> report.setValid(false); <line17> for (SAXParseException saxParseException : errorHandler.getErrors()) { <line18> report.addIssue(convertSAXParseException(saxParseException)); <line19> } <line20> } <line21> } catch (IOException e) { <line22> report.setValid(false); <line23> report.setMessage(e.getMessage()); <line24> } <line25> } else if (failIfNoSchema) { <line26> report.setValid(false); <line27> report.setMessage(""No schema to validate PREMIS""); <line28> } <line29> return report; <line30> } <line31> } <line32> "	"<line16>          LOGGER.error(""Error validating preservation binary "" + binary.getStoragePath(), e);"	task4	
public class A { <line0> @JsonIgnore <line1> @Override <line2> public List<JsonNode> getObjectMetadataList() { <line3> String objectList = mapParameters.get(WorkerParameterName.objectMetadataList); <line4> if (objectList == null) { <line5> return null; <line6> } <line7> try { <line8> return JsonHandler.getFromString(objectList, List.class, JsonNode.class); <line9> } catch (InvalidParseOperationException e) { <line10> throw new IllegalArgumentException(e); <line11> } <line12> } <line13> } <line14> 	<line10>      LOGGER.error(e);	task4	
"public class A { <line0> @Override <line1> public <ClusterID> ClusterClientFactory<ClusterID> getClusterClientFactory( <line2> final Configuration configuration) { <line3> checkNotNull(configuration); <line4> final ServiceLoader<ClusterClientFactory> loader = <line5> ServiceLoader.load(ClusterClientFactory.class); <line6> final List<ClusterClientFactory> compatibleFactories = new ArrayList<>(); <line7> final Iterator<ClusterClientFactory> factories = loader.iterator(); <line8> while (factories.hasNext()) { <line9> try { <line10> final ClusterClientFactory factory = factories.next(); <line11> if (factory != null && factory.isCompatibleWith(configuration)) { <line12> compatibleFactories.add(factory); <line13> } <line14> } catch (Throwable e) { <line15> if (e.getCause() instanceof NoClassDefFoundError) { <line16> } else { <line17> throw e; <line18> } <line19> } <line20> } <line21> if (compatibleFactories.size() > 1) { <line22> final List<String> configStr = <line23> configuration.toMap().entrySet().stream() <line24> .map(e -> e.getKey() + ""="" + e.getValue()) <line25> .collect(Collectors.toList()); <line26> throw new IllegalStateException( <line27> ""Multiple compatible client factories found for:\n"" + String.join(""\n"", configStr) + "".""); <line28> } <line29> if (compatibleFactories.isEmpty()) { <line30> throw new IllegalStateException( <line31> ""No ClusterClientFactory found. If you were targeting a Yarn cluster, please make sure to"" <line32> + "" export the HADOOP_CLASSPATH environment variable or have hadoop in your"" <line33> + "" classpath. For more information refer to the \""Deployment\"" section of the"" <line34> + "" official Apache Flink documentation.""); <line35> } <line36> return (ClusterClientFactory<ClusterID>) compatibleFactories.get(0); <line37> } <line38> } <line39> "	"<line16>          LOG.info(""Could not load factory due to missing dependencies."");"	task4	
"public class A { <line0> @Override <line1> public void flush() throws IOException, JournalClosedException { <line2> if (mClosed) { <line3> throw new JournalClosedException(""Cannot flush. Journal writer has been closed""); <line4> } <line5> if (mJournalEntryBuilder != null) { <line6> long flushSN = mNextSequenceNumberToWrite.get() - 1; <line7> try { <line8> JournalEntry entry = mJournalEntryBuilder.build(); <line9> Message message = RaftJournalSystem.toRaftMessage(entry); <line10> mLastSubmittedSequenceNumber.set(flushSN); <line11> RaftClientReply reply = <line12> mClient <line13> .sendAsync(message, TimeDuration.valueOf(mWriteTimeoutMs, TimeUnit.MILLISECONDS)) <line14> .get(mWriteTimeoutMs, TimeUnit.MILLISECONDS); <line15> mLastCommittedSequenceNumber.set(flushSN); <line16> if (reply.getException() != null) { <line17> throw reply.getException(); <line18> } <line19> } catch (InterruptedException e) { <line20> Thread.currentThread().interrupt(); <line21> throw new IOException(e); <line22> } catch (ExecutionException e) { <line23> throw new IOException(e.getCause()); <line24> } catch (TimeoutException e) { <line25> throw new IOException( <line26> String.format( <line27> ""Timed out after waiting %s milliseconds for journal entries to be processed"", <line28> mWriteTimeoutMs), <line29> e); <line30> } <line31> mJournalEntryBuilder = null; <line32> } <line33> } <line34> } <line35> "	"<line11>        LOG.trace(""Flushing entry {} ({})"", entry, message);"	task4	
public class A { <line0> @Override <line1> public TryResult call() { <line2> TryResult r; <line3> try { <line4> j.outputObject.started(); <line5> String code = j.codeToBeExecuted; <line6> r = <line7> symjaEvaluator.executeTask( <line8> new SymjaMMACodeRunner(symjaEvaluator, code, j.outputObject), <line9> j.getExecutionOptions()); <line10> } catch (Throwable e) { <line11> if (e instanceof SymjaMMANotFoundException) { <line12> r = TryResult.createError(e.getLocalizedMessage()); <line13> } else { <line14> e.printStackTrace(); <line15> r = TryResult.createError(e.getLocalizedMessage()); <line16> } <line17> } <line18> return r; <line19> } <line20> } <line21> 	<line12>        logger.warn(e.getLocalizedMessage());	task4	
public class A { <line0> @Override <line1> public boolean open(String offset) { <line2> try { <line3> if ((offset == null || offset.equals(FieldConstants.DefaultStartingOffset)) <line4> && spoutConfig.getEnqueueTimeFilter() != 0) { <line5> receiver.open(new EventHubFilter(Instant.ofEpochMilli(spoutConfig.getEnqueueTimeFilter()))); <line6> } else { <line7> receiver.open(new EventHubFilter(offset)); <line8> } <line9> lastOffset = offset; <line10> return true; <line11> } catch (EventHubException ex) { <line12> return false; <line13> } <line14> } <line15> } <line16> 	"<line12>      logger.error(""failed to open eventhub receiver: "" + ex.getMessage());"	task4	
public class A { <line0> protected static void bdd_default_reshandler(int oldsize, int newsize) { <line1> int verbose = 1; <line2> if (verbose > 0) { <line3> } <line4> } <line5> } <line6> 	"<line3>      LOGGER.info(""Resizing node table from {} to {}"", oldsize, newsize);"	task4	
public class A { <line0> private boolean updateWebrootPathInfo( <line1> Node node, <line2> GraphFieldContainerEdge edge, <line3> String languageTag, <line4> String branchUuid, <line5> String segmentFieldName, <line6> String conflictI18n, <line7> ContainerType type) { <line8> NodeDaoWrapper nodeDao = Tx.get().nodeDao(); <line9> ContentDaoWrapper contentDao = Tx.get().contentDao(); <line10> String segment = contentDao.getPathSegment(node, branchUuid, type, getLanguageTag()); <line11> if (segment != null) { <line12> HibNode parentNode = nodeDao.getParentNode(node, branchUuid); <line13> String segmentInfo = GraphFieldContainerEdgeImpl.composeSegmentInfo(parentNode, segment); <line14> Object webRootIndexKey = <line15> GraphFieldContainerEdgeImpl.composeWebrootIndexKey(db(), segmentInfo, branchUuid, type); <line16> GraphFieldContainerEdge conflictingEdge = <line17> db().index().checkIndexUniqueness(WEBROOT_INDEX_NAME, edge, webRootIndexKey); <line18> if (conflictingEdge != null) { <line19> Node conflictingNode = conflictingEdge.getNode(); <line20> NodeGraphFieldContainer conflictingContainer = conflictingEdge.getNodeContainer(); <line21> if (log.isDebugEnabled()) { <line22> } <line23> throw nodeConflict( <line24> conflictingNode.getUuid(), <line25> conflictingContainer.getDisplayFieldValue(), <line26> conflictingContainer.getLanguageTag(), <line27> conflictI18n, <line28> segmentFieldName, <line29> segment); <line30> } else { <line31> edge.setSegmentInfo(segmentInfo); <line32> return true; <line33> } <line34> } else { <line35> edge.setSegmentInfo(null); <line36> return true; <line37> } <line38> } <line39> } <line40> 	"<line22>          log.debug(""Found conflicting container with uuid {""+ conflictingContainer.getUuid()+ ""} of node {""+ conflictingNode.getUuid()+ ""}"");"	task4	
"public class A { <line0> @GET <line1> @Timed <line2> @Produces(APPLICATION_JSON_WITH_CHARSET) <line3> public String get( <line4> @Context GraphManager manager, <line5> @PathParam(""graph"") String graph, <line6> @QueryParam(""source"") String sourceV, <line7> @QueryParam(""direction"") String direction, <line8> @QueryParam(""label"") String edgeLabel, <line9> @QueryParam(""max_depth"") int depth, <line10> @QueryParam(""max_degree"") @DefaultValue(DEFAULT_MAX_DEGREE) long maxDegree, <line11> @QueryParam(""capacity"") @DefaultValue(DEFAULT_CAPACITY) long capacity, <line12> @QueryParam(""limit"") @DefaultValue(DEFAULT_PATHS_LIMIT) long limit) { <line13> Id source = VertexAPI.checkAndParseVertexId(sourceV); <line14> Directions dir = Directions.convert(EdgeAPI.parseDirection(direction)); <line15> HugeGraph g = graph(manager, graph); <line16> SubGraphTraverser traverser = new SubGraphTraverser(g); <line17> HugeTraverser.PathSet paths = <line18> traverser.rays(source, dir, edgeLabel, depth, maxDegree, capacity, limit); <line19> return manager.serializer(g).writePaths(""rays"", paths, false); <line20> } <line21> } <line22> "	"<line13>    LOG.debug(""Graph [{}] get rays paths from '{}' with ""+ ""direction '{}', edge label '{}', max depth '{}', ""+ ""max degree '{}', capacity '{}' and limit '{}'"",graph,sourceV,direction,edgeLabel,depth,maxDegree,capacity,limit);"	task4	
"public class A { <line0> public static com.liferay.mobile.device.rules.model.MDRAction updateAction( <line1> HttpPrincipal httpPrincipal, <line2> long actionId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> java.util.Map<java.util.Locale, String> descriptionMap, <line5> String type, <line6> com.liferay.portal.kernel.util.UnicodeProperties typeSettingsUnicodeProperties, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(MDRActionServiceUtil.class, ""updateAction"", _updateActionParameterTypes6); <line12> MethodHandler methodHandler = <line13> new MethodHandler( <line14> methodKey, <line15> actionId, <line16> nameMap, <line17> descriptionMap, <line18> type, <line19> typeSettingsUnicodeProperties, <line20> serviceContext); <line21> Object returnObj = null; <line22> try { <line23> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line24> } catch (Exception exception) { <line25> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line26> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line27> } <line28> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line29> } <line30> return (com.liferay.mobile.device.rules.model.MDRAction) returnObj; <line31> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line32> throw systemException; <line33> } <line34> } <line35> } <line36> "	<line32>      log.error(systemException, systemException);	task4	
public class A { <line0> private void deployQueuesFromListQueueConfiguration(List<QueueConfiguration> queues) <line1> throws Exception { <line2> for (QueueConfiguration config : queues) { <line3> try { <line4> QueueConfigurationUtils.applyDynamicQueueDefaults( <line5> config, addressSettingsRepository.getMatch(config.getAddress().toString())); <line6> config.setAutoCreateAddress(true); <line7> ActiveMQServerLogger.LOGGER.deployQueue( <line8> config.getName().toString(), <line9> config.getAddress().toString(), <line10> config.getRoutingType().toString()); <line11> if (locateQueue(config.getName()) != null <line12> && locateQueue(config.getName()).getAddress().equals(config.getAddress())) { <line13> config.setConfigurationManaged(true); <line14> setUnsetQueueParamsToDefaults(config); <line15> updateQueue(config, true); <line16> } else { <line17> try { <line18> createQueue( <line19> config <line20> .setTemporary(false) <line21> .setTransient(false) <line22> .setAutoCreated(false) <line23> .setConfigurationManaged(true) <line24> .setAutoCreateAddress(true), <line25> false); <line26> } catch (ActiveMQQueueExistsException e) { <line27> } <line28> } <line29> } catch (Exception e) { <line30> ActiveMQServerLogger.LOGGER.problemDeployingQueue( <line31> config.getName().toString(), e.getMessage()); <line32> } <line33> } <line34> } <line35> } <line36> 	<line27>            ActiveMQServerLogger.LOGGER.warn(e.getMessage());	task4	
"public class A { <line0> @Test <line1> public void testSendEndReceive() throws Exception { <line2> int nbMessages = 50; <line3> int failedMessages = 0; <line4> for (int i = 0; i < nbMessages; i++) { <line5> try { <line6> directProducer.sendBodyAndHeader(""Message #"" + i, RabbitMQConstants.ROUTING_KEY, ""rk3""); <line7> } catch (CamelExecutionException e) { <line8> failedMessages++; <line9> } <line10> Thread.sleep(500L); <line11> } <line12> producingMockEndpoint.expectedMessageCount(nbMessages - failedMessages); <line13> consumingMockEndpoint.expectedMessageCount(nbMessages - failedMessages); <line14> assertMockEndpointsSatisfied(5, TimeUnit.SECONDS); <line15> } <line16> } <line17> "	"<line8>        log.debug(""Can not send message"", e);"	task4	
public class A { <line0> public void lock() { <line1> if (_locked) { <line2> return; <line3> } <line4> if (log.isInfoEnabled()) { <line5> } <line6> _locked = true; <line7> } <line8> } <line9> 	"<line5>      log.info(""...Locking the singleton world of the DB definition!"");"	task4	
public class A { <line0> List<Address> getAddressesFromOSMId(String url) { <line1> List<Address> addresses; <line2> try { <line3> addresses = <line4> singletonList( <line5> nominatimRestClient.exchange(url, GET, getHttpEntity(), Address.class).getBody()); <line6> } catch (RestClientException e) { <line7> addresses = null; <line8> } <line9> return addresses; <line10> } <line11> } <line12> 	"<line6>      LOG.debug(""{} search result(s) found for URL {}"", addresses.size(), url);"	task4	
"public class A { <line0> @Override <line1> public void insertIdeaInstance(IdeaInstance ideainstance) { <line2> PreparedStatement stat = null; <line3> Connection conn = null; <line4> try { <line5> conn = this.getConnection(); <line6> conn.setAutoCommit(false); <line7> this.insertIdeaInstance(ideainstance, conn); <line8> this.insertIdeaInstanceGroups(ideainstance.getCode(), ideainstance.getGroups(), conn); <line9> conn.commit(); <line10> } catch (Throwable t) { <line11> this.executeRollback(conn); <line12> throw new RuntimeException(""Error creating ideainstance"", t); <line13> } finally { <line14> this.closeDaoResources(null, stat, conn); <line15> } <line16> } <line17> } <line18> "	"<line12>      logger.error(""Error creating ideainstance"", t);"	task4	
public class A { <line0> @Override <line1> public int getAcknowledgeMode() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> getSessionInternal(); <line5> return cri.getAcknowledgeMode(); <line6> } <line7> } <line8> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""getAcknowledgeMode()"");"	task4	
"public class A { <line0> public static com.liferay.bookmarks.model.BookmarksEntry getEntry( <line1> HttpPrincipal httpPrincipal, long entryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(BookmarksEntryServiceUtil.class, ""getEntry"", _getEntryParameterTypes6); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, entryId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.bookmarks.model.BookmarksEntry) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> private void postUnbindVirtLimit( <line1> PoolManager poolManager, <line2> Entitlement entitlement, <line3> Pool pool, <line4> Consumer consumer, <line5> Map<String, String> attributes) { <line6> ConsumerType ctype = this.consumerTypeCurator.getConsumerType(consumer); <line7> boolean hostLimited = ""true"".equals(attributes.get(Product.Attributes.HOST_LIMITED)); <line8> if (!config.getBoolean(ConfigProperties.STANDALONE) && !hostLimited && ctype.isManifest()) { <line9> String virtLimit = attributes.get(Product.Attributes.VIRT_LIMIT); <line10> if (!""unlimited"".equals(virtLimit)) { <line11> int virtQuantity = Integer.parseInt(virtLimit) * entitlement.getQuantity(); <line12> if (virtQuantity > 0) { <line13> List<Pool> pools = <line14> poolManager.getBySubscriptionId(pool.getOwner(), pool.getSubscriptionId()); <line15> for (int idex = 0; idex < pools.size(); idex++) { <line16> Pool derivedPool = pools.get(idex); <line17> if (derivedPool.getAttributeValue(Pool.Attributes.DERIVED_POOL) != null) { <line18> poolManager.setPoolQuantity(derivedPool, derivedPool.adjustQuantity(virtQuantity)); <line19> } <line20> } <line21> } <line22> } else { <line23> List<Pool> pools = <line24> poolManager.getBySubscriptionId(pool.getOwner(), pool.getSubscriptionId()); <line25> for (int idex = 0; idex < pools.size(); idex++) { <line26> Pool derivedPool = pools.get(idex); <line27> if (derivedPool.getAttributeValue(Pool.Attributes.DERIVED_POOL) != null <line28> && derivedPool.getQuantity() == 0) { <line29> poolManager.setPoolQuantity(derivedPool, -1); <line30> } <line31> } <line32> } <line33> } <line34> } <line35> } <line36> "	"<line6>    log.debug(""Running virt_limit post unbind."");"	task4	
"public class A { <line0> private ITupleIterator transformToTupleIterator( <line1> final StreamingTupleConverter tupleConverter, <line2> final IStreamingSearchResult searchResult, <line3> final TupleInfo returnTupleInfo) { <line4> final Tuple tuple = new Tuple(returnTupleInfo); <line5> final Iterator<Record> recordIterator = searchResult.iterator(); <line6> return new ITupleIterator() { <line7> @Override <line8> public void close() { <line9> try { <line10> searchResult.close(); <line11> } catch (IOException e) { <line12> } <line13> } <line14>  <line15> @Override <line16> public boolean hasNext() { <line17> return recordIterator.hasNext(); <line18> } <line19>  <line20> @Override <line21> public ITuple next() { <line22> tupleConverter.translateResult(recordIterator.next(), tuple); <line23> return tuple; <line24> } <line25>  <line26> @Override <line27> public void remove() { <line28> throw new UnsupportedOperationException(""not support""); <line29> } <line30> }; <line31> } <line32> } <line33> "	"<line12>          logger.warn(""exception when close gtscanner"", e);"	task4	
"public class A { <line0> @Test <line1> public void testApiHTML() throws Exception { <line2> MockHttpServletResponse response = <line3> getAsMockHttpServletResponse(""ogc/images/api?f=text/html"", 200); <line4> assertEquals(""text/html"", response.getContentType()); <line5> String html = response.getContentAsString(); <line6> assertThat( <line7> html, <line8> containsString( <line9> ""<link rel=\""icon\"" type=\""image/png\"""" <line10> + "" href=\""http://localhost:8080/geoserver/swagger-ui/favicon-32x32.png\"""" <line11> + "" sizes=\""32x32\"" />"")); <line12> assertThat( <line13> html, <line14> containsString( <line15> ""<link rel=\""icon\"" type=\""image/png\"""" <line16> + "" href=\""http://localhost:8080/geoserver/swagger-ui/favicon-16x16.png\"""" <line17> + "" sizes=\""16x16\"" />"")); <line18> assertThat( <line19> html, <line20> containsString( <line21> ""<script src=\""http://localhost:8080/geoserver/swagger-ui/swagger-ui-bundle.js\"">"")); <line22> assertThat( <line23> html, <line24> containsString( <line25> ""<script"" <line26> + "" src=\""http://localhost:8080/geoserver/swagger-ui/swagger-ui-standalone-preset.js\"">"")); <line27> assertThat( <line28> html, <line29> containsString( <line30> ""url: \""http://localhost:8080/geoserver/ogc/images/api?f=application%2Fvnd.oai.openapi%2Bjson%3Bversion%3D3.0\"""")); <line31> } <line32> } <line33> "	<line6>    LOGGER.info(html);	task4	
public class A { <line0> private <T> int removeByFilter( <line1> final String key, <line2> final Class<T> deserializeClass, <line3> final Filter<T> filter, <line4> final Object... params) { <line5> try { <line6> Map<byte[], byte[]> dataAll = jedisClient.hgetAll(key.getBytes()); <line7> if (Objects.isNull(dataAll)) { <line8> return HmilyRepository.FAIL_ROWS; <line9> } <line10> int count = 0; <line11> for (Entry<byte[], byte[]> entry : dataAll.entrySet()) { <line12> byte[] data = entry.getValue(); <line13> if (data == null) { <line14> continue; <line15> } <line16> T t = hmilySerializer.deSerialize(data, deserializeClass); <line17> if (filter.filter(t, params)) { <line18> jedisClient.hdel(rootPathPrefix, key); <line19> count++; <line20> } <line21> return count; <line22> } <line23> } catch (JedisException e) { <line24> } <line25> return HmilyRepository.FAIL_ROWS; <line26> } <line27> } <line28> 	"<line24>      LOGGER.error(""removeByFilter occur a exception"", e);"	task4	
public class A { <line0> protected MetacardMapper lookupMetacardAttributeToFeaturePropertyMapper( <line1> QName featureType, List<MetacardMapper> metacardMapperList) { <line2> final Predicate<MetacardMapper> matchesFeatureType = <line3> mapper -> mapper.getFeatureType().equals(featureType.toString()); <line4> return metacardMapperList.stream() <line5> .filter(matchesFeatureType) <line6> .findAny() <line7> .orElseGet( <line8> () -> { <line9> return null; <line10> }); <line11> } <line12> } <line13> 	"<line9>              LOGGER.debug(""Could not find a MetacardMapper for featureType {}."", featureType);"	task4	
public class A { <line0> private boolean allVolumeSizesMatch(List<Long> currentVolumeSizes) { <line1> List<Long> currentVolumeSizesCopy = new ArrayList<Long>(); <line2> currentVolumeSizesCopy.addAll(currentVolumeSizes); <line3> for (Long currentSize : currentVolumeSizes) { <line4> for (Long compareSize : currentVolumeSizesCopy) { <line5> if (currentSize.longValue() != compareSize.longValue()) { <line6> return false; <line7> } <line8> } <line9> } <line10> return true; <line11> } <line12> } <line13> 	"<line10>    log.info(""All volumes are of the same size. No need for capacity calculations."");"	task4	
public class A { <line0> @Override <line1> public void onParentStatusEvent(final MonitorStatusEvent statusEvent) { <line2> Runnable monitoringRunnable = <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> String instanceId = statusEvent.getInstanceId(); <line7> if (statusEvent.getStatus() == GroupStatus.Terminating <line8> || statusEvent.getStatus() == ApplicationStatus.Terminating) { <line9> if (log.isInfoEnabled()) { <line10> } <line11> ClusterStatusEventPublisher.sendClusterStatusClusterTerminatingEvent( <line12> getAppId(), getServiceId(), getClusterId(), instanceId); <line13> } <line14> } <line15> }; <line16> executorService.execute(monitoringRunnable); <line17> } <line18> } <line19> 	"<line10>                log.info(""Publishing Cluster terminating event for [application] ""+ appId+ "" [cluster] ""+ getClusterId()+ "" [instance] ""+ instanceId);"	task4	
"public class A { <line0> protected void sendSubscribe(String destination) { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(STOMP.ClientVerb.SUBSCRIBE.name()) <line3> .append(""\n"") <line4> .append(""destination: "") <line5> .append(destination) <line6> .append(""\n\n""); <line7> try { <line8> synchronized (this) { <line9> out.write(sb.toString().getBytes()); <line10> out.write(STOMP.NULL_BYTE); <line11> out.flush(); <line12> } <line13> } catch (IOException ex) { <line14> } <line15> } <line16> } <line17> "	"<line14>      log.error(Util.getMessage(""FailedSubscribingTo"") + destination + "": "", ex);"	task4	
"public class A { <line0> @Override <line1> public synchronized BlobSupportDataRow next() { <line2> if (!hasNext()) { <line3> throw new NoSuchElementException(""Iterator at end""); <line4> } <line5> final BlockableDCObjectInputVersion2 inStream = m_inStream; <line6> int colCount = m_tableFormatReader.getTableSpec().getNumColumns(); <line7> if (inStream == null) { <line8> if (m_missingCellsForClosedTable == null) { <line9> m_missingCellsForClosedTable = new DataCell[colCount]; <line10> Arrays.fill(m_missingCellsForClosedTable, DataType.getMissingCell()); <line11> } <line12> RowKey key = new RowKey(""INVALID_ROW (table is closed) - (Row "" + m_pointer + "")""); <line13> m_pointer++; <line14> return new BlobSupportDataRow(key, m_missingCellsForClosedTable); <line15> } <line16> RowKey key; <line17> try { <line18> key = readRowKeyAndEndBlock(inStream); <line19> } catch (Exception throwable) { <line20> handleReadThrowable(throwable); <line21> String keyS = ""Read_failed__auto_generated_key_"" + m_pointer; <line22> key = new RowKey(keyS); <line23> } <line24> DataCell[] cells = new DataCell[colCount]; <line25> for (int i = 0; i < colCount; i++) { <line26> DataCell nextCell; <line27> try { <line28> try { <line29> nextCell = m_dataCellStreamReader.readDataCell(m_inStream); <line30> } finally { <line31> m_inStream.endBlock(); <line32> } <line33> } catch (final Exception e) { <line34> handleReadThrowable(e); <line35> nextCell = DataType.getMissingCell(); <line36> } <line37> cells[i] = nextCell; <line38> } <line39> try { <line40> byte eoRow = inStream.readControlByte(); <line41> if (eoRow != BYTE_ROW_SEPARATOR) { <line42> throw new IOException( <line43> ""Expected end of row byte, got '"" + eoRow + ""', (byte "" + (int) eoRow + "")""); <line44> } <line45> } catch (IOException ioe) { <line46> handleReadThrowable(ioe); <line47> } finally { <line48> m_pointer++; <line49> } <line50> return new BlobSupportDataRow(key, cells); <line51> } <line52> } <line53> "	"<line11>        LOGGER.warn(""Invalid access on table, iterator has been closed"");"	task4	
"public class A { <line0> @Override <line1> public String getURL(PortletRequest portletRequest, PortletResponse portletResponse) { <line2> try { <line3> LiferayPortletURL portletURL = <line4> PortletURLFactoryUtil.create( <line5> portletRequest, <line6> PortletConfigurationSharingPortletKeys.PORTLET_CONFIGURATION_SHARING, <line7> PortletRequest.RENDER_PHASE); <line8> portletURL.setParameter(""netvibesURL"", getWidgetURL(portletRequest)); <line9> portletURL.setWindowState(LiferayWindowState.POP_UP); <line10> return portletURL.toString(); <line11> } catch (Exception exception) { <line12> return StringPool.BLANK; <line13> } <line14> } <line15> } <line16> "	<line12>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void frameworkMessage(ExecutorDriver executorDriver, byte[] bytes) { <line2> try { <line3> messageHandler.handleMessage(bytes); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> 	"<line5>      LOG.warn(""Unexpected exception while handling framework message"", t);"	task4	
"public class A { <line0> protected final int getStreamPortFromAnswer(String answer) throws ConnectException { <line1> int port = -1; <line2> if (answer != null && answer.startsWith(STREAM_PORT_STRING)) { <line3> String portSubstring = answer.substring(STREAM_PORT_STRING.length()); <line4> try { <line5> port = Integer.parseInt(portSubstring); <line6> } catch (NumberFormatException nfe) { <line7> } <line8> } <line9> if (port <= 0) { <line10> throw new ConnectException(""\""PORT nn\"" expected - unable to parse: "" + ""\"""" + answer + ""\""""); <line11> } <line12> return port; <line13> } <line14> } <line15> "	"<line7>        LOGGER.error(""Can not parse port from substring {}"", portSubstring);"	task4	
"public class A { <line0> @SuppressWarnings(""squid:S1126"") <line1> private boolean checkSystemIfUniqueValidationNeeded( <line2> final System system, <line3> final String validatedSystemName, <line4> final String validatedAddress, <line5> final Integer validatedPort) { <line6> final String actualSystemName = system.getSystemName(); <line7> final String actualAddress = system.getAddress(); <line8> final int actualPort = system.getPort(); <line9> if (validatedSystemName != null && !actualSystemName.equalsIgnoreCase(validatedSystemName)) { <line10> return true; <line11> } else if (validatedAddress != null && !actualAddress.equalsIgnoreCase(validatedAddress)) { <line12> return true; <line13> } else { <line14> return validatedPort != null && actualPort != validatedPort; <line15> } <line16> } <line17> } <line18> "	"<line6>    logger.debug(""checkSystemIfUniqueValidationNeeded started..."");"	task4	
public class A { <line0> private void postProcessRemoveRec( <line1> ITreeNode node, ITree formerTree, boolean includeSubtree, boolean dispose) { <line2> if (includeSubtree) { <line3> for (ITreeNode ch : node.getChildNodes()) { <line4> postProcessRemoveRec(ch, formerTree, includeSubtree, dispose); <line5> } <line6> } <line7> if (formerTree != null) { <line8> try { <line9> node.nodeRemovedNotify(); <line10> if (dispose) { <line11> node.dispose(); <line12> } <line13> } catch (Exception t) { <line14> } <line15> } <line16> } <line17> } <line18> 	"<line14>        LOG.error(""Error removing node"", t);"	task4	
"public class A { <line0> @GET <line1> @Timed <line2> @Compress <line3> @Produces(APPLICATION_JSON_WITH_CHARSET) <line4> @RolesAllowed({""admin"", ""$owner=$graph $action=vertex_read""}) <line5> public String list( <line6> @Context GraphManager manager, <line7> @PathParam(""graph"") String graph, <line8> @QueryParam(""label"") String label, <line9> @QueryParam(""properties"") String properties, <line10> @QueryParam(""keep_start_p"") @DefaultValue(""false"") boolean keepStartP, <line11> @QueryParam(""offset"") @DefaultValue(""0"") long offset, <line12> @QueryParam(""page"") String page, <line13> @QueryParam(""limit"") @DefaultValue(""100"") long limit) { <line14> Map<String, Object> props = parseProperties(properties); <line15> if (page != null) { <line16> E.checkArgument( <line17> offset == 0, ""Not support querying vertices based on paging "" + ""and offset together""); <line18> } <line19> HugeGraph g = graph(manager, graph); <line20> GraphTraversal<Vertex, Vertex> traversal = g.traversal().V(); <line21> if (label != null) { <line22> traversal = traversal.hasLabel(label); <line23> } <line24> for (Map.Entry<String, Object> prop : props.entrySet()) { <line25> Object value = prop.getValue(); <line26> if (!keepStartP <line27> && value instanceof String <line28> && ((String) value).startsWith(TraversalUtil.P_CALL)) { <line29> prop.setValue(TraversalUtil.parsePredicate((String) value)); <line30> } <line31> } <line32> for (Map.Entry<String, Object> entry : props.entrySet()) { <line33> traversal = traversal.has(entry.getKey(), entry.getValue()); <line34> } <line35> if (page == null) { <line36> traversal = traversal.range(offset, offset + limit); <line37> } else { <line38> traversal = traversal.has(QueryHolder.SYSPROP_PAGE, page).limit(limit); <line39> } <line40> try { <line41> return manager.serializer(g).writeVertices(traversal, page != null); <line42> } finally { <line43> if (g.tx().isOpen()) { <line44> g.tx().close(); <line45> } <line46> } <line47> } <line48> } <line49> "	"<line14>    LOG.debug(""Graph [{}] query vertices by label: {}, properties: {}, ""+ ""offset: {}, page: {}, limit: {}"",graph,label,properties,offset,page,limit);"	task4	
public class A { <line0> public void initializeSession() { <line1> SessionId sessionId = sessionIdService.getSessionId(); <line2> Map<String, String> sessionAttributes = new HashMap<>(); <line3> if (StringUtils.isNotBlank(userCode)) { <line4> sessionAttributes.put(SESSION_USER_CODE, userCode); <line5> } <line6> if (sessionId == null) { <line7> SessionId deviceAuthzSession = <line8> sessionIdService.generateUnauthenticatedSessionId( <line9> null, new Date(), SessionIdState.UNAUTHENTICATED, sessionAttributes, false); <line10> sessionIdService.persistSessionId(deviceAuthzSession); <line11> cookieService.createSessionIdCookie(deviceAuthzSession, false); <line12> } else { <line13> if (StringUtils.isNotBlank(sessionId.getSessionAttributes().get(SESSION_LAST_ATTEMPT)) <line14> && StringUtils.isNotBlank(sessionId.getSessionAttributes().get(SESSION_ATTEMPTS))) { <line15> lastAttempt = Long.parseLong(sessionId.getSessionAttributes().get(SESSION_LAST_ATTEMPT)); <line16> attempts = Byte.parseByte(sessionId.getSessionAttributes().get(SESSION_ATTEMPTS)); <line17> } <line18> sessionAttributes.put(SESSION_LAST_ATTEMPT, String.valueOf(lastAttempt)); <line19> sessionAttributes.put(SESSION_ATTEMPTS, String.valueOf(attempts)); <line20> sessionId.setSessionAttributes(sessionAttributes); <line21> sessionIdService.updateSessionId(sessionId); <line22> } <line23> } <line24> } <line25> 	"<line12>      log.debug(""Created session for device authorization grant page, sessionId: {}"",deviceAuthzSession.getId());"	task4	
"public class A { <line0> private boolean isArtifactOnlyResourceInstanceArtifact( <line1> ArtifactDefinition foundArtifact, Component parent, String instanceId) { <line2> Optional<ComponentInstance> componentInstanceOpt = parent.getComponentInstanceById(instanceId); <line3> if (!componentInstanceOpt.isPresent()) { <line4> throw new ByActionStatusComponentException( <line5> ActionStatus.COMPONENT_INSTANCE_NOT_FOUND_ON_CONTAINER, <line6> instanceId, <line7> """", <line8> """", <line9> parent.getName()); <line10> } <line11> ComponentInstance foundInstance = componentInstanceOpt.get(); <line12> String componentUid = foundInstance.getComponentUid(); <line13> Either<Component, StorageOperationStatus> getContainerRes = <line14> toscaOperationFacade.getToscaElement(componentUid); <line15> if (getContainerRes.isRight()) { <line16> throw new StorageException(getContainerRes.right().value()); <line17> } <line18> Component origComponent = getContainerRes.left().value(); <line19> Map<String, ArtifactDefinition> deploymentArtifacts = origComponent.getDeploymentArtifacts(); <line20> if (MapUtils.isNotEmpty(deploymentArtifacts)) { <line21> Optional<String> op = <line22> deploymentArtifacts.keySet().stream() <line23> .filter(a -> a.equals(foundArtifact.getArtifactLabel())) <line24> .findAny(); <line25> if (op.isPresent()) { <line26> return false; <line27> } <line28> } <line29> Map<String, ArtifactDefinition> artifacts = origComponent.getArtifacts(); <line30> if (MapUtils.isNotEmpty(artifacts)) { <line31> Optional<String> op = <line32> artifacts.keySet().stream() <line33> .filter(a -> a.equals(foundArtifact.getArtifactLabel())) <line34> .findAny(); <line35> if (op.isPresent()) { <line36> return false; <line37> } <line38> } <line39> return true; <line40> } <line41> } <line42> "	"<line16>      log.debug(""Failed to fetch the container component {}. "", componentUid);"	task4	
public class A { <line0> public static TestSuite getInstance() { <line1> if (instance == null) { <line2> instance = new TestSuite(); <line3> try { <line4> setUpClass(); <line5> } catch (RuntimeException | IOException | InterruptedException ex) { <line6> } <line7> } <line8> return instance; <line9> } <line10> } <line11> 	"<line6>        LOGGER.error(""Failed to initialise."", ex);"	task4	
"public class A { <line0> @Override <line1> public String execute(final String command) { <line2> final ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); <line3> final PrintStream out = new PrintStream(outputStream); <line4> try { <line5> zigBeeGateway.processInputLine(command, out); <line6> } catch (final Exception e) { <line7> out.println(""Error: "" + e.getMessage()); <line8> } <line9> return outputStream.toString(); <line10> } <line11> } <line12> "	"<line7>      LOGGER.error(""Error in ZigBeeConsole API execute command."", e);"	task4	
public class A { <line0> public void close(Socket s) { <line1> SafeClose.close(s); <line2> } <line3> } <line4> 	"<line1>    LOG.info(""Close connection {}"", s);"	task4	
public class A { <line0> @Nullable <line1> public static BranchType unbindBranchType() { <line2> BranchType unbindBranchType = (BranchType) CONTEXT_HOLDER.remove(KEY_BRANCH_TYPE); <line3> if (LOGGER.isDebugEnabled()) { <line4> } <line5> return unbindBranchType; <line6> } <line7> } <line8> 	"<line4>      LOGGER.debug(""unbind branch type {}"", unbindBranchType);"	task4	
public class A { <line0> private synchronized void stopTask() { <line1> this.isRunning = false; <line2> this.notify(); <line3> } <line4> } <line5> 	"<line1>    LOG.info(""NoopTask.stopTask() invoked."");"	task4	
public class A { <line0> @Override <line1> public QueryResult execute(String query, String language) throws RepositoryException { <line2> final Query jcrQuery = <line3> getLocalSession() <line4> .getSession() <line5> .getWorkspace() <line6> .getQueryManager() <line7> .createQuery(query, language); <line8> return jcrQuery.execute(); <line9> } <line10> } <line11> 	"<line2>    logger.trace(""Executing query: {0}"", query);"	task4	
"public class A { <line0> private void setupSpringSecurity() { <line1> ClassPathXmlApplicationContext appContext = <line2> new ClassPathXmlApplicationContext(new String[] {SPRING_SECURITY_METADATA}); <line3> System.setProperty(""spring-beans-config"", SPRING_SECURITY_METADATA); <line4> AuthZ authZ = AuthZ.get(); <line5> txManager = <line6> (org.springframework.jdbc.datasource.DataSourceTransactionManager) <line7> appContext.getBean(""transactionManager""); <line8> if (logger.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> "	"<line9>      logger.debug(""Spring Security setup complete."");"	task4	
"public class A { <line0> @POST <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/spaces/{spaceName}/projects/{projectName}/branches/{branchName}/maven/install"") <line3> @RolesAllowed({REST_ROLE, REST_PROJECT_ROLE}) <line4> public Response installProject( <line5> @PathParam(""spaceName"") String spaceName, <line6> @PathParam(""projectName"") String projectName, <line7> @PathParam(""branchName"") String branchName) { <line8> PortablePreconditions.checkNotNull(""spaceName"", spaceName); <line9> PortablePreconditions.checkNotNull(""projectName"", projectName); <line10> final String id = newId(); <line11> final InstallProjectRequest jobRequest = new InstallProjectRequest(); <line12> jobRequest.setStatus(JobStatus.ACCEPTED); <line13> jobRequest.setJobId(id); <line14> jobRequest.setSpaceName(spaceName); <line15> jobRequest.setProjectName(projectName); <line16> jobRequest.setBranchName(branchName); <line17> addAcceptedJobResult(id); <line18> jobRequestObserver.installProjectRequest(jobRequest); <line19> return createAcceptedStatusResponse(jobRequest); <line20> } <line21> } <line22> "	"<line8>    logger.debug(""-----installProject--- , project name: {}, branch name: {}"", projectName, branchName);"	task4	
public class A { <line0> private void report() { <line1> final long deviceConnectionDuration = <line2> noOfDeviceConnections.get() <line3> * Duration.between(startInstant.getAndSet(Instant.now()), Instant.now()).toMillis(); <line4> recorder.accept(deviceConnectionDuration); <line5> } <line6> } <line7> 	"<line5>    log.trace(""Reported device connection duration [tenant : {}, noOfDeviceConnections: {},""+ "" connectionDurationInMs: {}]."",tenantId,noOfDeviceConnections.get(),deviceConnectionDuration);"	task4	
public class A { <line0> public ProvenanceEventJmsWriter getProvenanceEventActiveMqWriter() { <line1> ProvenanceEventJmsWriter provenanceEventJmsWriter = <line2> SpringApplicationContext.getInstance().getBean(ProvenanceEventJmsWriter.class); <line3> if (provenanceEventJmsWriter == null) { <line4> } <line5> return provenanceEventJmsWriter; <line6> } <line7> } <line8> 	"<line4>      log.error(""!!!!!!!ProvenanceEventJmsWriter is NULL !!!!!!"");"	task4	
public class A { <line0> protected void deployDefaultDefinitionLink( <line1> User defaultUser, <line2> long companyId, <line3> Group companyGroup, <line4> String assetClassName, <line5> String workflowDefinitionName) <line6> throws PortalException { <line7> WorkflowDefinitionLink workflowDefinitionLink = <line8> workflowDefinitionLinkLocalService.fetchDefaultWorkflowDefinitionLink( <line9> companyId, assetClassName, 0, 0); <line10> if (workflowDefinitionLink != null) { <line11> return; <line12> } <line13> List<WorkflowDefinition> workflowDefinitions = <line14> _workflowDefinitionManager.getActiveWorkflowDefinitions( <line15> companyId, <line16> workflowDefinitionName, <line17> 0, <line18> 20, <line19> workflowComparatorFactory.getDefinitionNameComparator(false)); <line20> if (workflowDefinitions.isEmpty()) { <line21> if (log.isWarnEnabled()) { <line22> } <line23> return; <line24> } <line25> WorkflowDefinition workflowDefinition = workflowDefinitions.get(0); <line26> workflowDefinitionLinkLocalService.addWorkflowDefinitionLink( <line27> defaultUser.getUserId(), <line28> companyId, <line29> companyGroup.getGroupId(), <line30> assetClassName, <line31> 0, <line32> 0, <line33> workflowDefinition.getName(), <line34> workflowDefinition.getVersion()); <line35> } <line36> } <line37> 	"<line22>        log.warn(""No workflow definitions found for "" + workflowDefinitionName);"	task4	
"public class A { <line0> @Override <line1> public void destroy(KieServerImpl kieServer, KieServerRegistry registry) { <line2> ServiceRegistry.get().remove(""GlobalCamelService""); <line3> if (this.managedCamel && this.camelContext != null) { <line4> try { <line5> this.camelContext.stop(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> "	"<line7>        LOGGER.error(""Failed at stopping KIE Server extension {}"", EXTENSION_NAME);"	task4	
public class A { <line0> public void start() { <line1> if (isActive) { <line2> return; <line3> } <line4> if (timerJobRunnable == null) { <line5> timerJobRunnable = <line6> new AcquireTimerJobsRunnable(this, processEngineConfiguration.getJobManager()); <line7> } <line8> if (resetExpiredJobsRunnable == null) { <line9> resetExpiredJobsRunnable = new ResetExpiredJobsRunnable(this); <line10> } <line11> if (!isMessageQueueMode && asyncJobsDueRunnable == null) { <line12> asyncJobsDueRunnable = new AcquireAsyncJobsDueRunnable(this); <line13> } <line14> if (!isMessageQueueMode) { <line15> initAsyncJobExecutionThreadPool(); <line16> startJobAcquisitionThread(); <line17> } <line18> startTimerAcquisitionThread(); <line19> startResetExpiredJobsThread(); <line20> isActive = true; <line21> executeTemporaryJobs(); <line22> } <line23> } <line24> 	"<line4>    log.info(""Starting up the default async job executor [{}]."", getClass().getName());"	task4	
"public class A { <line0> public String checkDataSubTag(Element datasubtag) { <line1> Element[] children = datasubtag.getChildren(""text"").toArray(Element[]::new); <line2> int textCount = children.length; <line3> for (int i = 0; i < children.length; i++) { <line4> Element child = children[i]; <line5> String text = child.getTextTrim(); <line6> if (text == null || text.length() == 0) { <line7> child.detach(); <line8> textCount--; <line9> continue; <line10> } <line11> if (child.getAttribute(""lang"") != null) { <line12> child.getAttribute(""lang"").setNamespace(XML_NAMESPACE); <line13> } <line14> } <line15> if (textCount == 0) { <line16> return ""history date is empty""; <line17> } <line18> return checkMetaObjectWithLang(datasubtag, MCRMetaHistoryDate.class); <line19> } <line20> } <line21> "	"<line13>        LOGGER.warn(""namespace add for xml:lang attribute in {}"", datasubtag.getName());"	task4	
"public class A { <line0> @Override <line1> public DDMTemplateVersion findByT_V(long templateId, String version) <line2> throws NoSuchTemplateVersionException { <line3> DDMTemplateVersion ddmTemplateVersion = fetchByT_V(templateId, version); <line4> if (ddmTemplateVersion == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""templateId=""); <line8> sb.append(templateId); <line9> sb.append("", version=""); <line10> sb.append(version); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchTemplateVersionException(sb.toString()); <line15> } <line16> return ddmTemplateVersion; <line17> } <line18> } <line19> "	<line13>        log.debug(sb.toString());	task4	
public class A { <line0> public static String readAnyLayout(final String roleKey) { <line1> try { <line2> return IOUtils.toString( <line3> InputStream.class.cast(getService(RoleService.class).getAnyLayout(roleKey).getEntity()), <line4> StandardCharsets.UTF_8); <line5> } catch (Exception e) { <line6> return StringUtils.EMPTY; <line7> } <line8> } <line9> } <line10> 	"<line6>      LOG.error(""Error retrieving console layout info for role {}"", roleKey, e);"	task4	
"public class A { <line0> public String deleteElement() { <line1> AProjectArtefact artefact = repositoryTreeState.getSelectedNode().getData(); <line2> String childName = WebStudioUtils.getRequestParameter(""element""); <line3> AProjectArtefact childArtefact = <line4> ((TreeNode) <line5> repositoryTreeState <line6> .getSelectedNode() <line7> .getChild( <line8> RepositoryUtils.getTreeNodeId(artefact.getRepository().getId(), childName))) <line9> .getData(); <line10> try { <line11> studio.getModel().clearModuleInfo(); <line12> unregisterArtifactInProjectDescriptor(childArtefact); <line13> childArtefact.delete(); <line14> repositoryTreeState.refreshSelectedNode(); <line15> resetStudioModel(); <line16> WebStudioUtils.addInfoMessage(""Element was deleted successfully.""); <line17> } catch (Exception e) { <line18> WebStudioUtils.addErrorMessage(""Error deleting."", e.getMessage()); <line19> } <line20> return null; <line21> } <line22> } <line23> "	"<line18>      log.error(""Error deleting element."", e);"	task4	
public class A { <line0> @Override <line1> public void prepareHandshakeMessageContents() { <line2> setDheParams(); <line3> preparePublicKey(msg); <line4> prepareDheParams(); <line5> selectedSignatureHashAlgo = chooser.getSelectedSigHashAlgorithm(); <line6> prepareSignatureAndHashAlgorithm(msg); <line7> signature = new byte[0]; <line8> try { <line9> signature = generateSignature(selectedSignatureHashAlgo); <line10> } catch (CryptoException E) { <line11> } <line12> prepareSignature(msg); <line13> prepareSignatureLength(msg); <line14> } <line15> } <line16> 	"<line11>      LOGGER.warn(""Could not generate Signature! Using empty one instead!"", E);"	task4	
public class A { <line0> @GraphTransaction <line1> public List<AtlasClassification> retrieveClassifications(String guid) throws AtlasBaseException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> AtlasEntityHeader entityHeader = entityRetriever.toAtlasEntityHeaderWithClassifications(guid); <line5> return entityHeader.getClassifications(); <line6> } <line7> } <line8> 	"<line3>      LOG.debug(""Retriving classifications for entity={}"", guid);"	task4	
"public class A { <line0> private void emitTaskExitState() { <line1> if (emitTaskState) { <line2> try { <line3> TaskExitState exitState = new TaskExitState(); <line4> exitState.setInput(inputMeter.count()); <line5> exitState.setTotalEmitted(outputMeter.count()); <line6> exitState.setMeanRate(outputMeter.meanRate()); <line7> Files.write(CodecJSON.INSTANCE.encode(exitState), new File(""job.exit"")); <line8> } catch (Exception ex) { <line9> } <line10> } <line11> } <line12> } <line13> "	"<line9>        log.error("""", ex);"	task4	
"public class A { <line0> @Override <line1> public Optional<ScriptVersionTrace> get(ScriptVersionTraceKey scriptVersionTraceKey) { <line2> try { <line3> String query = <line4> ""SELECT SCRIPT_VRS_NB, SCRIPT_VRS_DSC FROM "" <line5> + getMetadataRepository().getTableNameByLabel(""ScriptVersionTraces"") <line6> + "" WHERE "" <line7> + "" RUN_ID = "" <line8> + SQLTools.getStringForSQL(scriptVersionTraceKey.getRunId()) <line9> + "" AND "" <line10> + "" PRC_ID = "" <line11> + SQLTools.getStringForSQL(scriptVersionTraceKey.getProcessId()) <line12> + "";""; <line13> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(query, ""reader""); <line14> if (cachedRowSet.size() == 0) { <line15> return Optional.empty(); <line16> } else if (cachedRowSet.size() > 1) { <line17> } <line18> cachedRowSet.next(); <line19> return Optional.of( <line20> new ScriptVersionTrace( <line21> scriptVersionTraceKey, <line22> cachedRowSet.getLong(""SCRIPT_VRS_NB""), <line23> cachedRowSet.getString(""SCRIPT_VRS_DSC""))); <line24> } catch (SQLException e) { <line25> throw new RuntimeException(e); <line26> } <line27> } <line28> } <line29> "	"<line17>        LOGGER.info(MessageFormat.format(""Found multiple implementations for ScriptVersionTrace {0}. Returning first""+ "" implementation"",scriptVersionTraceKey.toString()));"	task4	
public class A { <line0> Optional<Identities> resolveUsername(final Long entityId, final String username) <line1> throws FidoException { <line2> List<Identity> identities; <line3> if (nonNull(entityId)) { <line4> try { <line5> identities = identityResolver.getIdentitiesForEntity(new EntityParam(entityId)); <line6> } catch (IllegalIdentityValueException e) { <line7> return Optional.empty(); <line8> } <line9> } else { <line10> identities = getIdentitiesByUsername(username); <line11> } <line12> if (identities.isEmpty()) return Optional.empty(); <line13> try { <line14> return Optional.of(Identities.builder().identities(identities).build()); <line15> } catch (IllegalArgumentException | NoSuchElementException e) { <line16> return Optional.empty(); <line17> } <line18> } <line19> } <line20> 	"<line16>      log.warn(""Got exception: "", e);"	task4	
"public class A { <line0> @Override <line1> public WorkflowRun getWorkflowRunWithWorkflow(String workflowRunAccession) { <line2> try { <line3> WorkflowRun wr = ll.findWorkflowRun(""/"" + workflowRunAccession); <line4> Workflow w = ll.findWorkflowByWorkflowRun(workflowRunAccession); <line5> wr.setWorkflow(w); <line6> return (wr); <line7> } catch (IOException | JAXBException ex) { <line8> } <line9> return null; <line10> } <line11> } <line12> "	"<line8>      Log.error("""", ex);"	task4	
public class A { <line0> protected Layout getProductLayout(long groupId, boolean privateLayout, long cpDefinitionId) <line1> throws PortalException { <line2> String layoutUuid = _cpDefinitionLocalService.getLayoutUuid(groupId, cpDefinitionId); <line3> if (Validator.isNotNull(layoutUuid)) { <line4> return _layoutLocalService.getLayoutByUuidAndGroupId(layoutUuid, groupId, privateLayout); <line5> } <line6> long plid = _getPlidFromPortletId(groupId, privateLayout, CPPortletKeys.CP_CONTENT_WEB); <line7> try { <line8> return _layoutLocalService.getLayout(plid); <line9> } catch (PortalException portalException) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> throw portalException; <line13> } <line14> } <line15> } <line16> 	<line11>        log.debug(portalException, portalException);	task4	
public class A { <line0> protected int throttlingQueueSize() { <line1> RequestThrottler requestThrottler = context.getRequestThrottler(); <line2> if (requestThrottler instanceof ConcurrencyLimitingRequestThrottler) { <line3> return ((ConcurrencyLimitingRequestThrottler) requestThrottler).getQueueSize(); <line4> } <line5> if (requestThrottler instanceof RateLimitingRequestThrottler) { <line6> return ((RateLimitingRequestThrottler) requestThrottler).getQueueSize(); <line7> } <line8> return 0; <line9> } <line10> } <line11> 	"<line8>    LOG.warn(""[{}] Metric {} does not support {}, it will always return 0"",context.getSessionName(),DefaultSessionMetric.THROTTLING_QUEUE_SIZE.getPath(),requestThrottler.getClass().getName());"	task4	
"public class A { <line0> @Test <line1> public void test1() throws Exception { <line2> myTestExecution(DatesPage1.class, ""DatesPage1_ExpectedResult.html""); <line3> } <line4> } <line5> "	"<line2>    log.debug(""=========== test1() ================="");"	task4	
"public class A { <line0> public List<SmallCategory> getIdeaTags(boolean completeTitle) { <line1> List<SmallCategory> categories = new ArrayList<SmallCategory>(); <line2> try { <line3> String langCode = this.getCurrentLang().getCode(); <line4> String nodeRootCode = this.getIdeaManager().getCategoryRoot(); <line5> categories = this.getCategoryLeaf(nodeRootCode, langCode, completeTitle); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Error loading categories""); <line8> } <line9> return categories; <line10> } <line11> } <line12> "	"<line7>      logger.error(""Errore loading categories"", t);"	task4	
public class A { <line0> public boolean verify(DefaultAuthToken token) { <line1> try { <line2> return token != null <line3> && verifyUser(token) <line4> && verifyValidUntil(token) <line5> && verifySignature(token); <line6> } catch (RuntimeException e) { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> return false; <line10> } <line11> } <line12> } <line13> 	"<line8>        LOG.debug(""Failed verifying signature of token {}"", token, e);"	task4	
"public class A { <line0> public static void showCheckoutConflictsAlert(List<String> conflictingPaths) { <line1> String conflictList = """"; <line2> for (String pathName : conflictingPaths) { <line3> conflictList += ""\n"" + pathName; <line4> } <line5> Alert alert = new Alert(Alert.AlertType.ERROR); <line6> alert.setTitle(""Conflicting files""); <line7> alert.setHeaderText(""Can't checkout that branch""); <line8> alert.setContentText( <line9> ""You can't switch to that branch because of the following conflicting files between that"" <line10> + "" branch and your current branch: "" <line11> + conflictList); <line12> alert.showAndWait(); <line13> } <line14> } <line15> "	"<line1>    logger.warn(""Checkout conflicts warning"");"	task4	
public class A { <line0> @Override <line1> public Address findByPrimaryKey(Serializable primaryKey) throws NoSuchAddressException { <line2> Address address = fetchByPrimaryKey(primaryKey); <line3> if (address == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchAddressException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return address; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> private void setConfAndGetFS() { <line1> Configuration conf = HDFSConfUtil.setConf(new Configuration()); <line2> try { <line3> fs = hdfsPath.getFileSystem(conf); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.error(""Fail to get HDFS! "", e);"	task4	
"public class A { <line0> @Test <line1> public void testDateFolderDistributor() throws Exception { <line2> File f = setUpFlagDir(); <line3> createTestFiles(5, 5); <line4> createBogusTestFiles(5, 5); <line5> createCopyingTestFiles(5, 5); <line6> fmc.setDistributorType(""folderdate""); <line7> FlagMaker instance = new TestWrappedFlagMaker(fmc); <line8> instance.processFlags(); <line9> File[] flags = f.listFiles(pathname -> pathname.toString().endsWith(""flag"")); <line10> assertEquals(""Incorrect number of flags: "" + Arrays.toString(flags), 5, flags.length); <line11> HashSet<Long> buckets = new HashSet<>(); <line12> DateUtils du = new DateUtils(); <line13> for (File file : flags) { <line14> try (BufferedReader r = new BufferedReader(new FileReader(file))) { <line15> String[] files = r.readLine().split("" "")[1].split("",""); <line16> assertEquals(""Incorrect number of files: "" + Arrays.toString(files), 10, files.length); <line17> Map<String, Integer> folderCounts = new HashMap<>(); <line18> Map<String, Integer> dateCounts = new HashMap<>(); <line19> for (String string : files) { <line20> assertTrue(string.startsWith(""target/test/BulkIngest/flagged"")); <line21> String folder = string.substring(31, 34); <line22> folderCounts.put( <line23> folder, (folderCounts.containsKey(folder) ? folderCounts.get(folder) : 0) + 1); <line24> String date = string.substring(35, 45); <line25> dateCounts.put(date, (dateCounts.containsKey(date) ? dateCounts.get(date) : 0) + 1); <line26> buckets.add(DateUtils.getBucket(""day"", string)); <line27> } <line28> assertEquals(2, folderCounts.size()); <line29> for (String folder : folderCounts.keySet()) { <line30> assertEquals(5, folderCounts.get(folder).intValue()); <line31> } <line32> assertEquals(5, dateCounts.size()); <line33> for (String date : dateCounts.keySet()) { <line34> assertEquals(2, dateCounts.get(date).intValue()); <line35> } <line36> assertEquals(""Incorrect number of buckets: "" + buckets, 5, buckets.size()); <line37> buckets.clear(); <line38> } <line39> } <line40> } <line41> } <line42> "	"<line2>    log.info(""-----  testDateFolderDistributor  -----"");"	task4	
"public class A { <line0> @RequestMapping(path = ""/v1/vulnerabilities/summarybyapplication"", method = RequestMethod.GET) <line1> public ResponseEntity<Object> getVulnerabilityByApplications( <line2> @RequestParam(""ag"") String assetGroup) { <line3> if (Strings.isNullOrEmpty(assetGroup)) { <line4> return ResponseUtils.buildFailureResponse(new Exception(ASSET_MANDATORY)); <line5> } <line6> ResponseData response; <line7> try { <line8> response = <line9> new ResponseData( <line10> vulnerabilityService.getVulnerabilityByAppAndEnv( <line11> assetGroup, ""tags.Application.keyword"", """")); <line12> } catch (Exception e) { <line13> return ResponseUtils.buildFailureResponse(e); <line14> } <line15> return ResponseUtils.buildSucessResponse(response); <line16> } <line17> } <line18> "	"<line13>      LOGGER.error(""Exception in vulnerabilitybyapplications "", e);"	task4	
"public class A { <line0> public void testNotValuesForSimpleFacetHandler() throws Exception { <line1> BrowseRequest br = new BrowseRequest(); <line2> br.setCount(20); <line3> br.setOffset(0); <line4> BrowseSelection colorSel = new BrowseSelection(""color""); <line5> colorSel.addValue(""red""); <line6> br.addSelection(colorSel); <line7> BrowseSelection idSel = new BrowseSelection(""id""); <line8> idSel.addNotValue(""0""); <line9> br.addSelection(idSel); <line10> BrowseResult result = null; <line11> BoboBrowser boboBrowser = null; <line12> int expectedHitNum = (_documentSize / 2) - 1; <line13> try { <line14> Directory ramIndexDir = createIndex(); <line15> DirectoryReader srcReader = DirectoryReader.open(ramIndexDir); <line16> boboBrowser = new BoboBrowser(BoboMultiReader.getInstance(srcReader, _facetHandlers)); <line17> result = boboBrowser.browse(br); <line18> assertEquals(expectedHitNum, result.getNumHits()); <line19> StringBuilder buffer = new StringBuilder(); <line20> BrowseHit[] hits = result.getHits(); <line21> for (int i = 0; i < hits.length; ++i) { <line22> int expectedID = (i + 1) * 2; <line23> assertEquals(expectedID, Integer.parseInt(hits[i].getField(""id""))); <line24> if (i != 0) { <line25> buffer.append('\n'); <line26> } <line27> buffer.append(""id="" + hits[i].getField(""id"") + "","" + ""color="" + hits[i].getField(""color"")); <line28> } <line29> } catch (BrowseException e) { <line30> e.printStackTrace(); <line31> fail(e.getMessage()); <line32> } catch (IOException ioe) { <line33> fail(ioe.getMessage()); <line34> } finally { <line35> if (boboBrowser != null) { <line36> try { <line37> if (result != null) result.close(); <line38> boboBrowser.close(); <line39> } catch (IOException e) { <line40> fail(e.getMessage()); <line41> } <line42> } <line43> } <line44> } <line45> } <line46> "	<line29>      log.info(buffer.toString());	task4	
public class A { <line0> protected boolean isAuth(UserDetails user, Set<String> groupCodes) throws ApsSystemException { <line1> if (null == user) { <line2> return false; <line3> } <line4> return this.getAuthorizationManager().isAuth(user, groupCodes); <line5> } <line6> } <line7> 	"<line2>      logger.error(""Null user"");"	task4	
"public class A { <line0> public boolean isGCSAvailable() { <line1> if (gcsAvailable == null) { <line2> gcsAvailable = ClassUtils.isPresent(""com.google.cloud.storage.Storage"", classLoader); <line3> } <line4> return gcsAvailable; <line5> } <line6> } <line7> "	"<line3>      LOG.debug(""Google Cloud Storage available: "" + gcsAvailable);"	task4	
"public class A { <line0> @Produces <line1> @ApplicationScoped <line2> public AbstractCryptoProvider getCryptoProvider() throws Exception { <line3> WebKeyStorage webKeyStorage = appConfiguration.getWebKeysStorage(); <line4> if (webKeyStorage == null) { <line5> throw new RuntimeException( <line6> ""Failed to initialize cryptoProvider, cryptoProviderType is not specified!""); <line7> } <line8> AbstractCryptoProvider cryptoProvider = <line9> org.gluu.oxauth.model.crypto.CryptoProviderFactory.getCryptoProvider(appConfiguration); <line10> if (cryptoProvider == null) { <line11> throw new RuntimeException( <line12> ""Failed to initialize cryptoProvider, cryptoProviderType is unsupported: "" <line13> + webKeyStorage); <line14> } <line15> return cryptoProvider; <line16> } <line17> } <line18> "	"<line3>    log.debug(""Started to create crypto provider"");"	task4	
public class A { <line0> @Override <line1> public void createPages() { <line2> Stopwatch stopwatch = Stopwatch.createStarted(); <line3> createModel(); <line4> Display display = getSite().getShell().getDisplay(); <line5> if (!getEditingDomain().getResourceSet().getResources().isEmpty()) { <line6> createTree(); <line7> display.asyncExec(() -> setActivePage(0)); <line8> } <line9> getContainer() <line10> .addControlListener( <line11> new ControlAdapter() { <line12> boolean guard = false; <line13>  <line14> @Override <line15> public void controlResized(ControlEvent event) { <line16> if (!guard) { <line17> guard = true; <line18> hideTabs(); <line19> guard = false; <line20> } <line21> } <line22> }); <line23> display.asyncExec(this::updateProblemIndication); <line24> } <line25> } <line26> 	"<line24>    Log.debug(""NeoEMF Editor opened in {0}"", stopwatch.stop().elapsed());"	task4	
public class A { <line0> @Override <line1> public void executeUnit(Person unit) { <line2> executed.add(unit.getId()); <line3> } <line4> } <line5> 	"<line2>    LOGGER.warn(""Executing: "" + unit);"	task4	
public class A { <line0> public static int getCategoriesByCommerceDiscountIdCount(long commerceDiscountId, String name) <line1> throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceDiscountRelServiceUtil.getCategoriesByCommerceDiscountIdCount( <line5> commerceDiscountId, name); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
public class A { <line0> public static String toCanonicalPath(File file) { <line1> try { <line2> return file.getCanonicalPath(); <line3> } catch (IOException e) { <line4> return file.getAbsolutePath(); <line5> } <line6> } <line7> } <line8> 	"<line4>      logger.warn(file.getPath() + "" getCanonicalPath() error. Error:"" + e.getMessage(), e);"	task4	
public class A { <line0> @Override <line1> public void run(SourceContext<WindowedValue<byte[]>> ctx) { <line2> int subtaskCount = messageCount / getRuntimeContext().getNumberOfParallelSubtasks(); <line3> if (getRuntimeContext().getIndexOfThisSubtask() <line4> < (messageCount % getRuntimeContext().getNumberOfParallelSubtasks())) { <line5> subtaskCount++; <line6> } <line7> while (running && (messageCount == 0 || count < subtaskCount)) { <line8> synchronized (ctx.getCheckpointLock()) { <line9> ctx.collect( <line10> WindowedValue.valueInGlobalWindow(String.valueOf(count).getBytes(Charsets.UTF_8))); <line11> count++; <line12> } <line13> try { <line14> if (intervalMillis > 0) { <line15> Thread.sleep(intervalMillis); <line16> } <line17> } catch (InterruptedException e) { <line18> } <line19> } <line20> } <line21> } <line22> 	"<line18>        LOG.warn(""Interrupted while sleeping"", e);"	task4	
"public class A { <line0> public static ResponseEntity<Object> respondIdsMessageFailed(final Exception exception) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> return new ResponseEntity<>( <line4> ""Ids message handling failed. "" + exception.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); <line5> } <line6> } <line7> "	"<line2>      log.debug(""Ids message handling failed. [exception=({})]"", exception.getMessage(), exception);"	task4	
"public class A { <line0> public void joinTournament(String engineEndpoint, int numOfPlayers) { <line1> this.getStatus().setState(PlayerStatus.State.Requesting); <line2> Client client = ClientBuilder.newClient(new ClientConfig().register(LoggingFeature.class)); <line3> WebTarget webTarget = client.target(engineEndpoint).path(""api/v0.1/tournament/join""); <line4> Invocation.Builder invocationBuilder = webTarget.request(MediaType.APPLICATION_JSON); <line5> GameTicket ticket = new GameTicket(this, numOfPlayers); <line6> Response response = invocationBuilder.put(Entity.entity(ticket, MediaType.APPLICATION_JSON)); <line7> GameStatusResponse status = response.readEntity(GameStatusResponse.class); <line8> if (status.getState() == GameStatus.State.WaitingForPlayers <line9> || status.getState() == GameStatus.State.Starting) { <line10> this.getStatus().setState(PlayerStatus.State.Waiting); <line11> } <line12> } <line13> } <line14> "	"<line12>    logger.debug(""Request to join tournament - response (status "" + response.getStatus() + ""): "" + status);"	task4	
"public class A { <line0> @Override <line1> public ListenableFuture<Boolean> executeFilterAsync(TbMsg msg) { <line2> ListenableFuture<JsonNode> result = executeScriptAsync(msg); <line3> return Futures.transformAsync( <line4> result, <line5> json -> { <line6> if (!json.isBoolean()) { <line7> return Futures.immediateFailedFuture( <line8> new ScriptException(""Wrong result type: "" + json.getNodeType())); <line9> } else { <line10> return Futures.immediateFuture(json.asBoolean()); <line11> } <line12> }, <line13> MoreExecutors.directExecutor()); <line14> } <line15> } <line16> "	"<line7>            log.warn(""Wrong result type: {}"", json.getNodeType());"	task4	
public class A { <line0> public static void close(ResultSet x) { <line1> if (x == null) { <line2> return; <line3> } <line4> try { <line5> x.close(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOG.debug(""close result set error"", e);"	task4	
"public class A { <line0> @Override <line1> public String renderHTML(FileVersion fileVersion, HttpServletRequest httpServletRequest) { <line2> DLVideoExternalShortcut dlVideoExternalShortcut = <line3> _dlVideoExternalShortcutResolver.resolve(fileVersion); <line4> if (dlVideoExternalShortcut != null) { <line5> return dlVideoExternalShortcut.renderHTML(httpServletRequest); <line6> } <line7> try { <line8> ThemeDisplay themeDisplay = <line9> (ThemeDisplay) httpServletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line10> return StringBundler.concat( <line11> ""<iframe data-video-liferay height=\""315\"" frameborder=\""0\"" "", <line12> ""src=\"""", <line13> _dlURLHelper.getPreviewURL( <line14> fileVersion.getFileEntry(), <line15> fileVersion, <line16> themeDisplay, <line17> ""&videoEmbed=true"", <line18> true, <line19> false), <line20> ""\"" width=\""560\""></iframe>""); <line21> } catch (PortalException portalException) { <line22> return null; <line23> } <line24> } <line25> } <line26> "	<line22>      log.error(portalException, portalException);	task4	
public class A { <line0> public static int getSiteNavigationMenusCount(long[] groupIds) throws RemoteException { <line1> try { <line2> int returnValue = SiteNavigationMenuServiceUtil.getSiteNavigationMenusCount(groupIds); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>      log.error(exception, exception);	task4	
"public class A { <line0> protected void addDefaultVRProvider(Connection conn, long physicalNetworkId, long zoneId) { <line1> PreparedStatement pstmtUpdate = null, pstmt2 = null; <line2> try { <line3> String insertPNSP = <line4> ""INSERT INTO `cloud`.`physical_network_service_providers` (`uuid`, `physical_network_id`"" <line5> + "" , `provider_name`, `state` ,`destination_physical_network_id`,"" <line6> + "" `vpn_service_provided`, `dhcp_service_provided`, `dns_service_provided`,"" <line7> + "" `gateway_service_provided`,`firewall_service_provided`,"" <line8> + "" `source_nat_service_provided`, `load_balance_service_provided`,"" <line9> + "" `static_nat_service_provided`,`port_forwarding_service_provided`,"" <line10> + "" `user_data_service_provided`, `security_group_service_provided`) VALUES"" <line11> + "" (?,?,?,?,0,1,1,1,1,1,1,1,1,1,1,0)""; <line12> String routerUUID = UUID.randomUUID().toString(); <line13> pstmtUpdate = conn.prepareStatement(insertPNSP); <line14> pstmtUpdate.setString(1, routerUUID); <line15> pstmtUpdate.setLong(2, physicalNetworkId); <line16> pstmtUpdate.setString(3, ""VirtualRouter""); <line17> pstmtUpdate.setString(4, ""Enabled""); <line18> pstmtUpdate.executeUpdate(); <line19> pstmtUpdate.close(); <line20> String fetchNSPid = <line21> ""SELECT id from `cloud`.`physical_network_service_providers` where physical_network_id="" <line22> + physicalNetworkId <line23> + "" AND provider_name = 'VirtualRouter' AND uuid = ?""; <line24> pstmt2 = conn.prepareStatement(fetchNSPid); <line25> pstmt2.setString(1, routerUUID); <line26> ResultSet rsNSPid = pstmt2.executeQuery(); <line27> rsNSPid.next(); <line28> long nspId = rsNSPid.getLong(1); <line29> pstmt2.close(); <line30> String insertRouter = <line31> ""INSERT INTO `cloud`.`virtual_router_providers` (`nsp_id`, `uuid` , `type` , `enabled`) "" <line32> + ""VALUES (?,?,?,?)""; <line33> pstmtUpdate = conn.prepareStatement(insertRouter); <line34> pstmtUpdate.setLong(1, nspId); <line35> pstmtUpdate.setString(2, UUID.randomUUID().toString()); <line36> pstmtUpdate.setString(3, ""VirtualRouter""); <line37> pstmtUpdate.setInt(4, 1); <line38> pstmtUpdate.executeUpdate(); <line39> pstmtUpdate.close(); <line40> } catch (SQLException e) { <line41> throw new CloudRuntimeException(""Exception while adding PhysicalNetworks"", e); <line42> } finally { <line43> closeAutoCloseable(pstmt2); <line44> closeAutoCloseable(pstmtUpdate); <line45> } <line46> } <line47> } <line48> "	"<line3>      logger.debug(""Adding PhysicalNetworkServiceProvider VirtualRouter"");"	task4	
"public class A { <line0> @Override <line1> public List<String> getSupportedTypes() { <line2> final List<String> types = new ArrayList<>(); <line3> for (final String type : ManagementBusInvocationPluginRest.TYPES.split(""[,;]"")) { <line4> types.add(type.trim()); <line5> } <line6> return types; <line7> } <line8> } <line9> "	"<line2>    LOG.debug(""Getting Types: {}."", ManagementBusInvocationPluginRest.TYPES);"	task4	
"public class A { <line0> @Override <line1> public List<ConfidenceData> getDataByCrisisAttributeLabelGranularity( <line2> String crisisCode, String attributeCode, String labelCode, Long granularity) { <line3> Criteria criteria = getCurrentSession().createCriteria(ConfidenceData.class); <line4> Criterion criterion = <line5> Restrictions.conjunction() <line6> .add(Restrictions.eq(""crisisCode"", crisisCode)) <line7> .add(Restrictions.eq(""attributeCode"", attributeCode)) <line8> .add(Restrictions.eq(""labelCode"", labelCode)) <line9> .add(Restrictions.eq(""granularity"", granularity)); <line10> criteria.add(criterion); <line11> try { <line12> List<ConfidenceData> objList = (List<ConfidenceData>) criteria.list(); <line13> return objList; <line14> } catch (HibernateException e) { <line15> e.printStackTrace(); <line16> } <line17> return null; <line18> } <line19> } <line20> "	"<line15>      logger.error(""exception"", e);"	task4	
public class A { <line0> @Override <line1> protected Map<String, String> modifyIniFile( <line2> String commaSeparatedFilePaths, String commaSeparatedParentAccessions) { <line3> Map<String, String> iniFileMap = new TreeMap<>(); <line4> iniFileMap.put(ReservedIniKeys.INPUT_FILE.getKey(), commaSeparatedFilePaths); <line5> return iniFileMap; <line6> } <line7> } <line8> 	"<line3>    Log.debug(""INI FILE:"" + commaSeparatedFilePaths);"	task4	
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> try { <line3> handleCommandInternal(channelUID, command); <line4> updateModuleStatus(); <line5> } catch (SmartherIllegalPropertyValueException e) { <line6> } catch (SmartherGatewayException e) { <line7> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line8> } <line9> } <line10> } <line11> 	"<line6>      logger.warn(""Module[{}] Received command {} with illegal value {} on channel {}"",thing.getUID(),command,e.getMessage(),channelUID.getId());"	task4	
"public class A { <line0> public void scp(String origFile, String targetFile) { <line1> OverthereFile motd = connection.getFile(targetFile); <line2> OutputStream w = motd.getOutputStream(); <line3> try { <line4> byte[] origBytes = Files.readAllBytes(Paths.get(origFile)); <line5> w.write(origBytes); <line6> w.close(); <line7> } catch (IOException e) { <line8> throw new KurentoException(""Exception in SCP "" + origFile + "" "" + targetFile, e); <line9> } <line10> } <line11> } <line12> "	"<line1>    log.debug(""Copying local file: {} to remote file: {} (in host {})"", origFile, targetFile, host);"	task4	
public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceInventoryWarehouse commerceInventoryWarehouse) { <line2> boolean hasCustomAttributesAvailable = false; <line3> try { <line4> long classPK = 0; <line5> if (commerceInventoryWarehouse != null) { <line6> classPK = commerceInventoryWarehouse.getCommerceInventoryWarehouseId(); <line7> } <line8> hasCustomAttributesAvailable = <line9> CustomAttributesUtil.hasCustomAttributes( <line10> user.getCompanyId(), CommerceInventoryWarehouse.class.getName(), classPK, null); <line11> } catch (Exception exception) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> } <line15> return hasCustomAttributesAvailable; <line16> } <line17> } <line18> 	<line13>        log.debug(exception, exception);	task4	
public class A { <line0> private void closeAllConnections() { <line1> try { <line2> executors.execute( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> for (RedisSession session : sessions.values()) { <line7> session.closeConnection(); <line8> } <line9> } <line10> }); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> 	"<line12>      logger.error(""[closeAllConnections] {}"", e);"	task4	
"public class A { <line0> @Test <line1> public void testSearchWithOwnerAndEnum() { <line2> final Class testUserType = createTestUserType(); <line3> try { <line4> final List<Principal> users = createTestNodes(testUserType, 3); <line5> final List<TestThree> testThrees = new LinkedList<>(); <line6> final Random random = new Random(); <line7> String uuid = null; <line8> int count = 0; <line9> try (final Tx tx = app.tx()) { <line10> for (final Principal user : users) { <line11> for (int i = 0; i < 20; i++) { <line12> testThrees.add( <line13> app.create( <line14> TestThree.class, <line15> new NodeAttribute(AbstractNode.name, ""test"" + count++), <line16> new NodeAttribute(AbstractNode.owner, user), <line17> new NodeAttribute( <line18> TestThree.enumProperty, <line19> TestEnum.values()[random.nextInt(TestEnum.values().length)]))); <line20> } <line21> } <line22> uuid = users.get(0).getUuid(); <line23> tx.success(); <line24> } <line25> try (final Tx tx = app.tx()) { <line26> for (final Principal user : users) { <line27> for (final TestThree test : <line28> app.nodeQuery(TestThree.class) <line29> .and(AbstractNode.owner, user) <line30> .and(TestThree.enumProperty, TestEnum.Status1) <line31> .getAsList()) { <line32> assertEquals( <line33> ""Invalid enum query result"", <line34> TestEnum.Status1, <line35> test.getProperty(TestThree.enumProperty)); <line36> } <line37> } <line38> tx.success(); <line39> } <line40> RestAssured.given() <line41> .contentType(""application/json; charset=UTF-8"") <line42> .filter(ResponseLoggingFilter.logResponseIfStatusCodeIs(500)) <line43> .expect() <line44> .statusCode(200) <line45> .when() <line46> .get( <line47> concat( <line48> ""/test_threes?sort=createdDate&owner="" <line49> + uuid <line50> + ""&enumProperty="" <line51> + TestEnum.Status1)); <line52> } catch (FrameworkException ex) { <line53> ex.printStackTrace(); <line54> fail(""Unexpected exception""); <line55> } <line56> } <line57> } <line58> "	"<line54>      logger.warn("""", ex);"	task4	
"public class A { <line0> protected void setupClientMatrix(WebClient client, Exchange exchange) throws Exception { <line1> org.apache.cxf.message.Message cxfMessage = <line2> (org.apache.cxf.message.Message) exchange.getIn().getHeader(""CamelCxfMessage""); <line3> if (cxfMessage != null) { <line4> String requestURL = (String) cxfMessage.get(""org.apache.cxf.request.uri""); <line5> String matrixParam = null; <line6> int matrixStart = requestURL.indexOf(';'); <line7> int matrixEnd = requestURL.indexOf('?') > -1 ? requestURL.indexOf('?') : requestURL.length(); <line8> Map<String, String> maps = null; <line9> if (requestURL != null && matrixStart > 0) { <line10> matrixParam = requestURL.substring(matrixStart + 1, matrixEnd); <line11> if (matrixParam != null) { <line12> maps = <line13> getMatrixParametersFromMatrixString( <line14> matrixParam, ExchangeHelper.getCharsetName(exchange)); <line15> } <line16> } <line17> if (maps != null) { <line18> for (Map.Entry<String, String> entry : maps.entrySet()) { <line19> client.matrix(entry.getKey(), entry.getValue()); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> "	"<line20>          LOG.debug(""Matrix param {} :: {}"", entry.getKey(), entry.getValue());"	task4	
"public class A { <line0> public synchronized void restartSearch() { <line1> if (!started) { <line2> throw new IllegalStateException(""Runner is stopped""); <line3> } <line4> try { <line5> if (!syncReplClient.isComplete()) { <line6> syncReplClient.cancel(); <line7> } <line8> } catch (Exception e) { <line9> } <line10> try { <line11> syncReplClient.send(searchRequest, cookieManager); <line12> } catch (LdapException e) { <line13> throw new IllegalStateException(""Could not send sync repl request"", e); <line14> } <line15> } <line16> } <line17> "	"<line9>      LOGGER.warn(""Could not cancel sync repl request"", e);"	task4	
"public class A { <line0> public void runGenomeInfo() throws IOException, InterruptedException { <line1> String outputFolder = <line2> downloadFolder.getParent().toAbsolutePath().toString() + ""/generated_json/""; <line3> if (""true"".equals(System.getenv(""CELLBASE_BUILD_DOCKER""))) { <line4> String outputLog = downloadLogFolder + ""/genome_info.log""; <line5> EtlCommons.runCommandLineProcess( <line6> null, ""/opt/cellbase/genome_info.pl"", Arrays.asList(""--outdir"", outputFolder), outputLog); <line7> } else { <line8> String dockerImage = ""opencb/cellbase-builder:"" + configuration.getApiVersion(); <line9> AbstractMap.SimpleEntry<String, String> outputBinding = <line10> new AbstractMap.SimpleEntry(outputFolder, ""/ensembl-data""); <line11> String ensemblScriptParams = ""/opt/cellbase/genome_info.pl""; <line12> DockerUtils.run(dockerImage, null, outputBinding, ensemblScriptParams, null); <line13> } <line14> } <line15> } <line16> "	"<line1>    logger.info(""Downloading genome info ..."");"	task4	
"public class A { <line0> @Test <line1> public void resolveOfEmailWithTagsReturnsEntity() throws Exception { <line2> idsMan.addEntity( <line3> new IdentityParam(EmailIdentity.ID, ""a+zzz@ex.com""), ""cr-pass"", EntityState.valid); <line4> HttpClient client = getClient(); <line5> HttpHost host = new HttpHost(""localhost"", 53456, ""https""); <line6> HttpContext localcontext = getClientContext(host); <line7> HttpGet resolve = new HttpGet(""/restadm/v1/resolve/email/a+foo@ex.com""); <line8> HttpResponse response = client.execute(host, resolve, localcontext); <line9> String contents = EntityUtils.toString(response.getEntity()); <line10> assertEquals(contents, Status.OK.getStatusCode(), response.getStatusLine().getStatusCode()); <line11> } <line12> } <line13> "	"<line11>    log.info(""User's info:\n"" + formatJson(contents));"	task4	
public class A { <line0> public void disconnect() { <line1> if (client != null) { <line2> try { <line3> client.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.error(""{}"", e.getLocalizedMessage(), e);"	task4	
public class A { <line0> public static void deleteCalendarBookingInstance( <line1> long calendarBookingId, long startTime, boolean allFollowing) throws RemoteException { <line2> try { <line3> CalendarBookingServiceUtil.deleteCalendarBookingInstance( <line4> calendarBookingId, startTime, allFollowing); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      log.error(exception, exception);	task4	
"public class A { <line0> @Test <line1> public void testRedefineTerms() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> Map<String, Object> properties = new LinkedHashMap<String, Object>(); <line5> properties.put(""username"", ""edanuff""); <line6> properties.put(""email"", ""ed@anuff.com""); <line7> em.create(""user"", properties); <line8> app.waitForQueueDrainAndRefreshIndex(); <line9> String s = ""select {name: username, email: email} where username = 'edanuff'""; <line10> Query query = Query.fromQL(s); <line11> Results r = em.searchCollection(em.getApplicationRef(), ""users"", query); <line12> assertTrue(r.size() == 1); <line13> } <line14> } <line15> "	"<line2>    logger.debug(""testRedefineTerms"");"	task4	
public class A { <line0> public org.talend.mdm.webservice.WSBoolean isItemModifiedByOther( <line1> org.talend.mdm.webservice.WSIsItemModifiedByOther arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSBoolean _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	"<line2>    LOG.info(""Executing operation isItemModifiedByOther"");"	task4	
public class A { <line0> @Override <line1> public int getNumberOfResources() { <line2> return ResourceManager.getTotalNumberOfWorkers(); <line3> } <line4> } <line5> 	"<line2>    LOGGER.info(""Received request for number of active resources"");"	task4	
public class A { <line0> private void checkSeedNodesStatus() <line1> throws ConfigInconsistentException, StartUpCheckFailureException { <line2> if (getAllNodes().size() == 1) { <line3> return; <line4> } <line5> boolean canEstablishCluster = false; <line6> long startTime = System.currentTimeMillis(); <line7> AtomicInteger consistentNum = new AtomicInteger(1); <line8> AtomicInteger inconsistentNum = new AtomicInteger(0); <line9> while (!canEstablishCluster) { <line10> consistentNum.set(1); <line11> inconsistentNum.set(0); <line12> checkSeedNodesStatusOnce(consistentNum, inconsistentNum); <line13> canEstablishCluster = <line14> analyseStartUpCheckResult( <line15> consistentNum.get(), inconsistentNum.get(), getAllNodes().size()); <line16> if (System.currentTimeMillis() - startTime > ClusterUtils.START_UP_TIME_THRESHOLD_MS) { <line17> throw new StartUpCheckFailureException(); <line18> } else if (!canEstablishCluster) { <line19> try { <line20> Thread.sleep(ClusterUtils.START_UP_CHECK_TIME_INTERVAL_MS); <line21> } catch (InterruptedException e) { <line22> Thread.currentThread().interrupt(); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> 	"<line23>          logger.error(""Unexpected interruption when waiting for next start up check"", e);"	task4	
public class A { <line0> @PostConstruct <line1> public void start() { <line2> if (!isSlave) { <line3> cleanupUnusedSlavesExecutorService.scheduleWithFixedDelay( <line4> this::cleanupUnusedSlaves, 0, CLEANUP_SLAVES_INTERVAL_IN_MINUTES, TimeUnit.MINUTES); <line5> } <line6> if (isSlave && isStarted.compareAndSet(false, true)) { <line7> claimSlaveEnvironments(); <line8> keepaliveExecutorService.scheduleWithFixedDelay( <line9> this::keepAlive, <line10> 0, <line11> apolloConfiguration.getSlave().getKeepaliveIntervalSeconds(), <line12> TimeUnit.SECONDS); <line13> } <line14> } <line15> } <line16> 	"<line2>    logger.info(""Starting slave.. slaveId - {}, environmentIds - {}"",slaveId,apolloConfiguration.getSlave().getSlaveCsvEnvironments());"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> report.lastReportAt = generateReport(); <line4> if (ctx.channel().isWritable()) { <line5> ctx.writeAndFlush( <line6> makeUTF8StringMessage(EXPORT_REPORT, message.id, report.toString()), ctx.voidPromise()); <line7> } <line8> } catch (Exception e) { <line9> ctx.writeAndFlush(illegalCommand(message.id), ctx.voidPromise()); <line10> } <line11> } <line12> } <line13> 	"<line9>      log.debug(""Error generating export report {} for {}."", report, key.user.email, e);"	task4	
public class A { <line0> @Override <line1> public List<String> findAllGroupMembers(final String groupName) { <line2> final String name = escapeSearchAttribute(ensureCase(groupName)); <line3> final List<String> groupMembers = new ArrayList<>(); <line4> if (!checkGroupRestrictionList(name)) { <line5> return groupMembers; <line6> } <line7> LdapContext ctx = null; <line8> try { <line9> ctx = getContext(getSecurityManager().getCurrentSubject()); <line10> SearchResult searchResult = findGroupByGroupName(ctx, removeDomainPostfix(name)); <line11> if (searchResult == null) { <line12> return groupMembers; <line13> } <line14> final LDAPSearchContext search = ensureContextFactory().getSearch(); <line15> final String dnGroup = <line16> (String) <line17> searchResult <line18> .getAttributes() <line19> .get(search.getSearchGroup().getSearchAttribute(LDAPSearchAttributeKey.DN)) <line20> .get(); <line21> final SearchAttribute sa = <line22> new SearchAttribute( <line23> search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.MEMBER_OF), <line24> escapeSearchAttribute(dnGroup)); <line25> final String searchFilter = <line26> buildSearchFilter(search.getSearchAccount().getSearchFilterPrefix(), sa); <line27> final SearchControls searchControls = new SearchControls(); <line28> searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE); <line29> searchControls.setReturningAttributes( <line30> new String[] {search.getSearchAccount().getSearchAttribute(LDAPSearchAttributeKey.NAME)}); <line31> final NamingEnumeration<SearchResult> results = <line32> ctx.search(search.getBase(), searchFilter, searchControls); <line33> while (results.hasMoreElements()) { <line34> searchResult = results.nextElement(); <line35> final String member = <line36> ensureCase( <line37> addDomainPostfix( <line38> (String) <line39> searchResult <line40> .getAttributes() <line41> .get( <line42> search <line43> .getSearchAccount() <line44> .getSearchAttribute(LDAPSearchAttributeKey.NAME)) <line45> .get())); <line46> if (checkAccountRestrictionList(member)) { <line47> groupMembers.add(member); <line48> } <line49> } <line50> } catch (final NamingException ne) { <line51> } finally { <line52> if (ctx != null) { <line53> LdapUtils.closeContext(ctx); <line54> } <line55> } <line56> return groupMembers; <line57> } <line58> } <line59> 	<line51>      LOG.error(new AuthenticationException(AuthenticationException.UNNOWN_EXCEPTION, ne.getMessage()));	task4	
public class A { <line0> public static void createTopic(String topic, String addr) { <line1> TopicConfig topicConfig = new TopicConfig(); <line2> topicConfig.setTopicName(topic); <line3> topicConfig.setReadQueueNums(4); <line4> topicConfig.setWriteQueueNums(4); <line5> try { <line6> defaultMQAdminExt.createAndUpdateTopicConfig(addr, topicConfig); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	"<line8>      logger.error(""Create topic:{} addr:{} failed"", addr, topic);"	task4	
public class A { <line0> @Override <line1> public void onJointAngles(Map<String, Double> angleMap) { <line2> for (String name : angleMap.keySet()) { <line3> ServiceInterface si = Runtime.getService(name); <line4> if (si instanceof Servo) { <line5> ((Servo) si).moveTo(angleMap.get(name)); <line6> } <line7> } <line8> } <line9> } <line10> 	"<line2>    log.info(""onJointAngles {}"", angleMap);"	task4	
"public class A { <line0> private com.liferay.portal.kernel.model.User _fetchOrCreateBuyerUser(User user, long groupId) <line1> throws Exception { <line2> if (Validator.isBlank(user.getEmail())) { <line3> throw new BadRequestException(""Buyer user email is required""); <line4> } <line5> com.liferay.portal.kernel.model.User liferayUser = <line6> _userLocalService.fetchUserByEmailAddress(contextCompany.getCompanyId(), user.getEmail()); <line7> if (liferayUser != null) { <line8> return liferayUser; <line9> } <line10> return _addBuyerUser( <line11> contextCompany.getCompanyId(), <line12> groupId, <line13> user.getEmail(), <line14> user.getFirstName(), <line15> user.getMiddleName(), <line16> user.getLastName()); <line17> } <line18> } <line19> "	"<line3>      log.error(""Buyer user email is required"");"	task4	
"public class A { <line0> public boolean matches(IAtomContainer atomContainer, boolean initializeTarget) <line1> throws CDKException { <line2> if (!GeometryUtil.has3DCoordinates(atomContainer)) <line3> throw new CDKException(""Molecule must have 3D coordinates""); <line4> if (pharmacophoreQuery == null) <line5> throw new CDKException(""Must set the query pharmacophore before matching""); <line6> if (!checkQuery(pharmacophoreQuery)) <line7> throw new CDKException( <line8> ""A problem in the query. Make sure all pharmacophore groups of the same symbol have the"" <line9> + "" same same SMARTS""); <line10> String title = (String) atomContainer.getTitle(); <line11> if (initializeTarget) pharmacophoreMolecule = getPharmacophoreMolecule(atomContainer); <line12> else { <line13> for (IAtom iAtom : pharmacophoreMolecule.atoms()) { <line14> PharmacophoreAtom patom = PharmacophoreAtom.get(iAtom); <line15> List<Integer> tmpList = new ArrayList<Integer>(); <line16> for (int idx : patom.getMatchingAtoms()) tmpList.add(idx); <line17> Point3d coords = getEffectiveCoordinates(atomContainer, tmpList); <line18> patom.setPoint3d(coords); <line19> } <line20> } <line21> if (pharmacophoreMolecule.getAtomCount() < pharmacophoreQuery.getAtomCount()) { <line22> return false; <line23> } <line24> mappings = Pattern.findSubstructure(pharmacophoreQuery).matchAll(pharmacophoreMolecule); <line25> return mappings.atLeast(1); <line26> } <line27> } <line28> "	"<line22>      logger.debug(""Target ["" + title + ""] did not match the query SMARTS. Skipping constraints"");"	task4	
public class A { <line0> public static String[] getStringPropertyArray( <line1> ResourceBundle bundle, String key, String[] defaultValue) { <line2> try { <line3> bundle.getString(key); <line4> return getStringPropertyArray(bundle, key); <line5> } catch (MissingResourceException e) { <line6> printOutArrayProperty(key, defaultValue, true); <line7> return defaultValue; <line8> } <line9> } <line10> } <line11> 	"<line6>      logger.info(""Using default value of "" + Arrays.toString(defaultValue) + "" for property "" + key);"	task4	
"public class A { <line0> public HTTPRequest filterLogAndConvertRe(HttpRequest request) { <line1> for (HttpRequestFilter filter : request.getFilters()) { <line2> request = filter.filter(request); <line3> } <line4> checkRequestHasContentLengthOrChunkedEncoding( <line5> request, <line6> ""After filtering, the request has neither chunked encoding nor content length: "" + request); <line7> wirePayloadIfEnabled(wire, request); <line8> HTTPRequest nativeRequest = convertToGaeRequest.apply(request); <line9> utils.logRequest(headerLog, request, "">>""); <line10> return nativeRequest; <line11> } <line12> } <line13> "	"<line7>    logger.debug(""Sending request %s: %s"", request.hashCode(), request.getRequestLine());"	task4	
"public class A { <line0> public String asString() throws FacebookException { <line1> if (null == responseAsString) { <line2> BufferedReader br = null; <line3> InputStream stream = null; <line4> try { <line5> stream = asStream(); <line6> if (null == stream) { <line7> return null; <line8> } <line9> br = new BufferedReader(new InputStreamReader(stream, ""UTF-8"")); <line10> StringBuilder buf = new StringBuilder(); <line11> String line; <line12> while ((line = br.readLine()) != null) { <line13> buf.append(line).append(""\n""); <line14> } <line15> this.responseAsString = buf.toString(); <line16> stream.close(); <line17> streamConsumed = true; <line18> } catch (IOException ioe) { <line19> throw new FacebookException(ioe.getMessage(), ioe); <line20> } finally { <line21> if (stream != null) { <line22> try { <line23> stream.close(); <line24> } catch (IOException ignore) { <line25> } <line26> } <line27> if (br != null) { <line28> try { <line29> br.close(); <line30> } catch (IOException ignore) { <line31> } <line32> } <line33> disconnectForcibly(); <line34> } <line35> } <line36> return responseAsString; <line37> } <line38> } <line39> "	<line16>        logger.debug(responseAsString);	task4	
public class A { <line0> private VisualizationStyle maybeInstall( <line1> Class<? extends VisualizationStyle> cl, VisualizationStyle vs, Object src) { <line2> if (vs != null) { <line3> return vs; <line4> } <line5> if (myStyleRegistry.installStyle(cl, src)) { <line6> return myStyleRegistry.getDefaultStyleInstanceForStyleClass(cl); <line7> } <line8> return null; <line9> } <line10> } <line11> 	"<line8>    LOGGER.error(""Failed to install style class : "" + cl.getName());"	task4	
public class A { <line0> public TLSRecord readFromClient() throws IOException { <line1> TLSRecord record = read(client); <line2> return record; <line3> } <line4> } <line5> 	"<line2>    logger.debug(""C --> P {}"", record);"	task4	
public class A { <line0> public static final boolean existsInBackend(Application _app) { <line1> boolean exists = false; <line2> try { <line3> exists = <line4> BackendConnector.getInstance() <line5> .isAppExisting(CoreConfiguration.buildGoalContextFromGlobalConfiguration(), _app); <line6> } catch (BackendConnectionException e) { <line7> } <line8> return exists; <line9> } <line10> } <line11> 	"<line7>      log.error(""Error while checking whether "" + _app + "" exists in backend: "" + e.getMessage());"	task4	
public class A { <line0> public static BiConsumer<ExtendedRecord, LocationRecord> verifyLocationInfo( <line1> CentrePoints countryCentrePoints, <line2> CentrePoints stateProvinceCentrePoints, <line3> StateProvinceParser stateProvinceParser) { <line4> return (er, lr) -> { <line5> if (lr.getDecimalLongitude() != null && lr.getDecimalLatitude() != null) { <line6> if (!Strings.isNullOrEmpty(lr.getCountryCode()) <line7> && countryCentrePoints.coordinatesMatchCentre( <line8> lr.getCountry(), lr.getDecimalLatitude(), lr.getDecimalLongitude())) { <line9> addIssue(lr, ALAOccurrenceIssue.COORDINATES_CENTRE_OF_COUNTRY.name()); <line10> } <line11> if (!Strings.isNullOrEmpty(lr.getStateProvince())) { <line12> ParseResult<String> formalStateName = stateProvinceParser.parse(lr.getStateProvince()); <line13> lr.setStateProvince(formalStateName.getPayload()); <line14> String suppliedStateProvince = extractNullAwareValue(er, DwcTerm.stateProvince); <line15> if (!Strings.isNullOrEmpty(suppliedStateProvince)) { <line16> ParseResult<String> formalSuppliedName = <line17> stateProvinceParser.parse(suppliedStateProvince); <line18> if (formalSuppliedName.getPayload() != null) { <line19> suppliedStateProvince = formalSuppliedName.getPayload(); <line20> } <line21> if (!suppliedStateProvince.equalsIgnoreCase(lr.getStateProvince())) <line22> addIssue(lr, ALAOccurrenceIssue.STATE_COORDINATE_MISMATCH.name()); <line23> } <line24> if (lr.getStateProvince() != null <line25> && stateProvinceCentrePoints.coordinatesMatchCentre( <line26> lr.getStateProvince(), lr.getDecimalLatitude(), lr.getDecimalLongitude())) { <line27> addIssue(lr, ALAOccurrenceIssue.COORDINATES_CENTRE_OF_STATEPROVINCE.name()); <line28> } else if (log.isTraceEnabled()) { <line29> } <line30> } <line31> } <line32> }; <line33> } <line34> } <line35> 	"<line29>            log.trace(""{},{} is not at the centre of {}!"",lr.getDecimalLatitude(),lr.getDecimalLongitude(),lr.getStateProvince());"	task4	
public class A { <line0> @Override <line1> public void onPSubscribe(String pattern, int subscribedChannels) { <line2> subscribedLatch.countDown(); <line3> if (log.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.debug(""Subscribed to: "" + pattern);"	task4	
"public class A { <line0> @Override <line1> public CypressTestResults gatherTestResults() throws IOException { <line2> CypressTestResults results = new CypressTestResults(); <line3> objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); <line4> try (DirectoryStream<Path> paths = Files.newDirectoryStream(jsonReportsPath, ""*.json"")) { <line5> for (Path path : paths) { <line6> try { <line7> MochawesomeSpecRunReport specRunReport = <line8> objectMapper.readValue(path.toFile(), MochawesomeSpecRunReport.class); <line9> specRunReport.fillInTestResults(results); <line10> } catch (JsonMappingException e) { <line11> } <line12> } <line13> return results; <line14> } <line15> } <line16> } <line17> "	"<line11>          LOG.warn(""No test results were found in the report file:"" + "" "" + path);"	task4	
public class A { <line0> public void setBaud(int baudRate) throws Exception { <line1> state = STATE_SINGLE_SCAN; <line2> LIDARbaudRate = baudRate; <line3> index = 0; <line4> buffer.reset(); <line5> if (baudRate == 9600) { <line6> serial.write(new byte[] {0x02, 0x00, 0x02, 0x00, 0x20, 0x42, 0x52, 0x08}); <line7> } else if (baudRate == 19200) { <line8> serial.write(new byte[] {0x02, 0x00, 0x02, 0x00, 0x20, 0x41, 0x52, 0x08}); <line9> } else if (baudRate == 38400) { <line10> serial.write(new byte[] {0x02, 0x00, 0x02, 0x00, 0x20, 0x40, 0x52, 0x08}); <line11> } else { <line12> } <line13> } <line14> } <line15> 	"<line12>      log.error(""You've specified an unsupported baud rate"");"	task4	
"public class A { <line0> @Nullable <line1> private OnOffType getValveOpenType(Appliance appliance) { <line2> OndusService service = getOndusService(); <line3> if (service == null) { <line4> return null; <line5> } <line6> Optional<BaseApplianceCommand> commandOptional; <line7> try { <line8> commandOptional = service.applianceCommand(appliance); <line9> } catch (IOException e) { <line10> return null; <line11> } <line12> if (!commandOptional.isPresent()) { <line13> return null; <line14> } <line15> if (commandOptional.get().getType() != Appliance.TYPE) { <line16> updateStatus( <line17> ThingStatus.OFFLINE, <line18> ThingStatusDetail.CONFIGURATION_ERROR, <line19> ""Thing is not a GROHE SENSE Guard device.""); <line20> return null; <line21> } <line22> return ((ApplianceCommand) commandOptional.get()).getCommand().getValveOpen() <line23> ? OnOffType.ON <line24> : OnOffType.OFF; <line25> } <line26> } <line27> "	"<line10>      logger.debug(""Could not get appliance command"", e);"	task4	
"public class A { <line0> public static com.liferay.redirect.model.RedirectEntry deleteRedirectEntry( <line1> HttpPrincipal httpPrincipal, long redirectEntryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> RedirectEntryServiceUtil.class, <line7> ""deleteRedirectEntry"", <line8> _deleteRedirectEntryParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, redirectEntryId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.redirect.model.RedirectEntry) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> public MarketoRecordResult executeGetRequest(Schema schema) throws MarketoException { <line1> try { <line2> URL url = new URL(current_uri.toString()); <line3> HttpsURLConnection urlConn = (HttpsURLConnection) url.openConnection(); <line4> urlConn.setRequestMethod(""GET""); <line5> urlConn.setDoOutput(true); <line6> urlConn.setRequestProperty(REQUEST_PROPERTY_ACCEPT, REQUEST_VALUE_TEXT_JSON); <line7> return fillMarketoRecordResultFromReader(getReaderFromHttpResponse(urlConn), schema); <line8> } catch (IOException e) { <line9> throw new MarketoException(REST, e.getMessage()); <line10> } <line11> } <line12> } <line13> "	"<line9>      LOG.error(""Request failed: {}."", e.getMessage());"	task4	
"public class A { <line0> @Override <line1> public void setAccessPermissionReadInAdminMode( <line2> final String zone, final String absolutePath, final String userName) throws JargonException { <line3> if (zone == null) { <line4> throw new IllegalArgumentException(""null zone""); <line5> } <line6> if (absolutePath == null || absolutePath.isEmpty()) { <line7> throw new IllegalArgumentException(""null or empty absolutePath""); <line8> } <line9> if (userName == null || userName.isEmpty()) { <line10> throw new IllegalArgumentException(""null or empty userName""); <line11> } <line12> ObjStat objStat = this.retrieveObjStat(absolutePath); <line13> if (objStat.getSpecColType() == SpecColType.MOUNTED_COLL) { <line14> throw new OperationNotSupportedForCollectionTypeException( <line15> ""The special collection type does not support this operation""); <line16> } <line17> String absPath = resolveAbsolutePathGivenObjStat(objStat); <line18> ModAccessControlInp modAccessControlInp = <line19> ModAccessControlInp.instanceForSetPermissionInAdminMode( <line20> false, zone, absPath, userName, ModAccessControlInp.READ_PERMISSION); <line21> getIRODSProtocol().irodsFunction(modAccessControlInp); <line22> } <line23> } <line24> "	"<line14>      log.info(""objStat indicates collection type that does not support this operation:{}"", objStat);"	task4	
public class A { <line0> private void updateRuleLastCheckTime(List<AlertRule> validAlertRuleList) { <line1> try { <line2> List<Integer> ruleIdList = <line3> validAlertRuleList.stream().map(AlertRule::getRuleId).collect(Collectors.toList()); <line4> alertRuleService.updateAlertRuleLastCheckTime(ruleIdList); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      logger.error(""Update alert rule last check time, "" + validAlertRuleList, e);"	task4	
public class A { <line0> @Override <line1> public void fireDisconnected() { <line2> channelHandlerContext.pipeline().fireUserEventTriggered(new DisconnectedEvent()); <line3> } <line4> } <line5> 	"<line2>    logger.trace(""Firing Disconnected!"");"	task4	
public class A { <line0> @Override <line1> public String getSiteName(HttpServletRequest request) { <line2> String siteName = request.getParameter(paramOrCookieName); <line3> if (StringUtils.isEmpty(siteName)) { <line4> siteName = HttpUtils.getCookieValue(paramOrCookieName, request); <line5> if (StringUtils.isEmpty(siteName) && logger.isDebugEnabled()) { <line6> } <line7> } <line8> return siteName; <line9> } <line10> } <line11> 	"<line6>        logger.debug(""No '"" + paramOrCookieName + ""' request param or cookie found"");"	task4	
public class A { <line0> private void mainMenuPerformed(MainMenuItem menu) { <line1> if (menu.getParams() == null) { <line2> setResponsePage(menu.getPageClass()); <line3> } else { <line4> setResponsePage(menu.getPageClass(), menu.getParams()); <line5> } <line6> } <line7> } <line8> 	"<line1>    LOGGER.trace(""mainMenuPerformed: {}"", menu);"	task4	
"public class A { <line0> protected TypedQuery<ENTITY> typedQueryForSelectInternal( <line1> RegularStatement regularStatement, Object... encodedBoundValues) { <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> validateTrue( <line5> isSelectStatement(regularStatement), <line6> ""Statement provided for typed query should be an SELECT statement""); <line7> final PreparedStatement preparedStatement = rte.prepareDynamicQuery(regularStatement); <line8> final BoundStatement boundStatement = <line9> ArrayUtils.isEmpty(encodedBoundValues) <line10> ? preparedStatement.bind() <line11> : preparedStatement.bind(encodedBoundValues); <line12> if (regularStatement.getConsistencyLevel() != null) <line13> boundStatement.setConsistencyLevel(regularStatement.getConsistencyLevel()); <line14> if (regularStatement.getSerialConsistencyLevel() != null) <line15> boundStatement.setSerialConsistencyLevel(regularStatement.getSerialConsistencyLevel()); <line16> if (regularStatement.isTracing()) boundStatement.enableTracing(); <line17> if (regularStatement.getRetryPolicy() != null) <line18> boundStatement.setRetryPolicy(regularStatement.getRetryPolicy()); <line19> if (regularStatement.getOutgoingPayload() != null) <line20> boundStatement.setOutgoingPayload(regularStatement.getOutgoingPayload()); <line21> if (regularStatement.isIdempotent() != null) { <line22> boundStatement.setIdempotent(regularStatement.isIdempotent()); <line23> } <line24> boundStatement.setFetchSize(regularStatement.getFetchSize()); <line25> return new TypedQuery<>(rte, meta_internal, boundStatement, encodedBoundValues); <line26> } <line27> } <line28> "	"<line3>      LOGGER.trace(format(""Create typed query for SELECT : %s"", regularStatement.getQueryString()));"	task4	
public class A { <line0> @Override <line1> public void logTransactionSwallowException(String type, String name, Task task) { <line2> Transaction transaction = Cat.newTransaction(type, name); <line3> try { <line4> task.go(); <line5> transaction.setStatus(Transaction.SUCCESS); <line6> } catch (Throwable th) { <line7> transaction.setStatus(th); <line8> } finally { <line9> transaction.complete(); <line10> } <line11> } <line12> } <line13> 	"<line8>      logger.error(""[logTransaction]"" + type + "","" + name + "","" + task, th);"	task4	
public class A { <line0> @Override <line1> protected void doProcessRequest( <line2> UnsubscribeRequest request, ImapSession session, Responder responder) { <line3> final String mailboxName = request.getMailboxName(); <line4> final MailboxSession mailboxSession = session.getMailboxSession(); <line5> try { <line6> getSubscriptionManager().unsubscribe(mailboxSession, mailboxName); <line7> unsolicitedResponses(session, responder, false); <line8> okComplete(request, responder); <line9> } catch (SubscriptionException e) { <line10> unsolicitedResponses(session, responder, false); <line11> no(request, responder, HumanReadableText.GENERIC_SUBSCRIPTION_FAILURE); <line12> } <line13> } <line14> } <line15> 	"<line10>      LOGGER.info(""Unsubscribe failed for mailbox {}"", mailboxName, e);"	task4	
"public class A { <line0> public static DataSource initDataSource(Config config) throws Exception { <line1> DruidDataSource dataSource = new DruidDataSource(); <line2> dataSource.setDriverClassName(""com.mysql.cj.jdbc.Driver""); <line3> dataSource.setUrl( <line4> ""jdbc:mysql://"" <line5> + config.getDbUrl() <line6> + "":"" <line7> + config.getDbPort() <line8> + ""?useSSL=true&verifyServerCertificate=false&serverTimezone=GMT%2B8&characterEncoding=utf8""); <line9> dataSource.setUsername(config.getDbUsername()); <line10> dataSource.setPassword(config.getDbPassword()); <line11> dataSource.setInitialSize(1); <line12> dataSource.setMaxActive(2); <line13> dataSource.setMaxWait(60000); <line14> dataSource.setTimeBetweenEvictionRunsMillis(60000); <line15> dataSource.setConnectionErrorRetryAttempts(2); <line16> dataSource.setBreakAfterAcquireFailure(true); <line17> dataSource.setMinEvictableIdleTimeMillis(300000); <line18> dataSource.setValidationQuery(""SELECT 1 FROM DUAL""); <line19> dataSource.setTestWhileIdle(true); <line20> return dataSource; <line21> } <line22> } <line23> "	"<line20>    log.info(""init data source success"");"	task4	
"public class A { <line0> @GetMapping(path = ""/testvoidInRPC"") <line1> public void testvoidInRPC() { <line2> testvoidInRPCSuccess = true; <line3> } <line4> } <line5> "	"<line2>    LOGGER.info(""testvoidInRPC() is called!"");"	task4	
"public class A { <line0> @POST <line1> @Path(""/{dashboardId}/widgets/reorder"") <line2> @ApiOperation( <line3> value = ""Change the order of widgets in a dashboard"", <line4> response = DashboardModel.class, <line5> responseContainer = ""Array"") <line6> @Produces({MediaType.APPLICATION_JSON}) <line7> public Response setWidgetsOrder( <line8> @PathParam(""dashboardId"") long dashboardId, @FormParam(""widgetNames"") String widgetNames) <line9> throws UnsupportedEncodingException { <line10> long guestId = AuthHelper.getGuestId(); <line11> try { <line12> final String[] wNames = StringUtils.split(widgetNames, "",""); <line13> dashboardsService.setWidgetsOrder(guestId, dashboardId, wNames); <line14> return getDashboards(); <line15> } catch (Exception e) { <line16> StringBuilder sb = <line17> new StringBuilder(""module=API component=dashboardStore action=setWidgetOrder"") <line18> .append("" guestId="") <line19> .append(guestId) <line20> .append("" stackTrace=<![CDATA["") <line21> .append(Utils.stackTrace(e)) <line22> .append(""]]>""); <line23> return Response.serverError().entity(""Failed to set widget order: "" + e.getMessage()).build(); <line24> } <line25> } <line26> } <line27> "	<line23>      logger.warn(sb.toString());	task4	
public class A { <line0> private RestResponse<User> create() throws ClientException { <line1> UserCommandOptions.CreateCommandOptions c = usersCommandOptions.createCommandOptions; <line2> UserCreateParams createParams = <line3> new UserCreateParams() <line4> .setId(c.user) <line5> .setName(c.name) <line6> .setEmail(c.email) <line7> .setOrganization(c.organization) <line8> .setPassword(c.password); <line9> return openCGAClient.getUserClient().create(createParams); <line10> } <line11> } <line12> 	"<line1>    logger.debug(""Creating user..."");"	task4	
"public class A { <line0> @Post(subscribeToken = ""csrf"") <line1> public Boundary save() { <line2> String expires = getParam(""expires""); <line3> if (StringUtils.isEmpty(expires)) { <line4> expires = ""9999-12-31""; <line5> } <line6> Date date; <line7> try { <line8> date = gateDayFormat().parse(expires); <line9> } catch (ParseException e) { <line10> return sendError(HttpStatus.SC_400_BAD_REQUEST, ""BAD_REQUEST""); <line11> } <line12> TokensEntity entity = TokensDao.get().selectOnUserId(getLoginUserId()); <line13> if (entity == null) { <line14> entity = new TokensEntity(); <line15> entity.setToken(RandomUtil.randamGen(64)); <line16> entity.setUserId(getLoginUserId()); <line17> } <line18> entity.setExpires(new Timestamp(date.getTime())); <line19> TokensDao.get().save(entity); <line20> addMsgSuccess(""message.success.save""); <line21> return index(); <line22> } <line23> } <line24> "	"<line2>    LOG.trace(""access to save"");"	task4	
public class A { <line0> static void initPlatformMBeanServer() { <line1> try { <line2> ManagementFactory.getPlatformMBeanServer(); <line3> } catch (Throwable t) { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.error(""could not create platform mbean server: {}"", t.getMessage(), t);"	task4	
public class A { <line0> public int executeUpdate(String s) throws SQLException { <line1> return getSql().executeUpdate(s); <line2> } <line3> } <line4> 	"<line1>    logger.debug(""MetadataDB executeUpdate:"" + s);"	task4	
public class A { <line0> @Override <line1> public void lockInterruptibly() throws InterruptedException { <line2> while (!this.tryLock(PgLock.DEFAULT_WAIT_SEC, TimeUnit.SECONDS)) { <line3> if (Logger.isDebugEnabled(this)) { <line4> } <line5> } <line6> } <line7> } <line8> 	"<line4>        Logger.debug(this, ""attempting to lock"");"	task4	
public class A { <line0> private Model initSubModels(CompModelPlugin compModelPlugin) { <line1> ListOf<Submodel> subModelListOf = compModelPlugin.getListOfSubmodels().clone(); <line2> replaceElementsInModelDefinition(compModelPlugin, null); <line3> ListOf<Port> listOfPorts = compModelPlugin.getListOfPorts(); <line4> handlePorts(compModelPlugin, listOfPorts); <line5> for (Submodel submodel : subModelListOf) { <line6> this.listOfSubmodelsToFlatten.add(submodel); <line7> ModelDefinition modelDefinition = this.modelDefinitionListOf.get(submodel.getModelRef()); <line8> if (modelDefinition == null) { <line9> ExternalModelDefinition externalModelDefinition = <line10> this.externalModelDefinitionListOf.get(submodel.getModelRef()); <line11> try { <line12> SBMLDocument externalDocument = <line13> SBMLReader.read(new File(externalModelDefinition.getSource())); <line14> Model flattendExternalModel = flatten(externalDocument).getModel(); <line15> this.flattenedModel = mergeModels(this.flattenedModel, flattendExternalModel); <line16> } catch (XMLStreamException | IOException e) { <line17> e.printStackTrace(); <line18> } <line19> } <line20> if (modelDefinition != null <line21> && modelDefinition.getExtension(CompConstants.shortLabel) != null) { <line22> initSubModels((CompModelPlugin) modelDefinition.getExtension(CompConstants.shortLabel)); <line23> } else { <line24> } <line25> } <line26> return flattenAndMergeModels(this.listOfSubmodelsToFlatten); <line27> } <line28> } <line29> 	"<line24>        LOGGER.info(""No model definition found in "" + submodel.getId() + ""."");"	task4	
"public class A { <line0> @ApiOperation(value = ""Patch entity"") <line1> @PatchMapping(CommonConstants.PATH_ID) <line2> @ResponseStatus(HttpStatus.OK) <line3> public SecurityProfileDto patch( <line4> final @PathVariable(""id"") String id, @RequestBody final Map<String, Object> partialDto) { <line5> ParameterChecker.checkParameter( <line6> ""The Identifier, the partialEntity are mandatory parameters: "", id, partialDto); <line7> Assert.isTrue( <line8> StringUtils.equals(id, (String) partialDto.get(""id"")), <line9> ""Unable to patch securityProfile : the DTO id must match the path id.""); <line10> return service.patch(buildUiHttpContext(), partialDto, id); <line11> } <line12> } <line13> "	"<line5>    LOGGER.debug(""Patch User {} with {}"", id, partialDto);"	task4	
"public class A { <line0> @Test <line1> public void testOneGroupMessage() throws Exception { <line2> String message = <line3> ""8=FIX 4.19=2034=135=049=INVMGR56=BRKR"" <line4> + ""1=BE.CHM.00111=CHM0001-0158=this is a camel - bindy test"" <line5> + ""22=448=BE000124567854=1"" <line6> + ""10=220"" <line7> + ""777=22-06-2013 12:21:11""; <line8> List<String> data = Arrays.asList(message.split(""\\u0001"")); <line9> CamelContext camelContext = new DefaultCamelContext(); <line10> factory.bind(camelContext, data, model, counter); <line11> assertNotNull(model); <line12> } <line13> } <line14> "	"<line11>    LOG.info("">>> Model : "" + model.toString());"	task4	
public class A { <line0> public T convertOrientDocToAvroBean(final ODocument obj, final String[] fields) <line1> throws GoraException { <line2> T persistent = newPersistent(); <line3> String[] dbFields = getFieldsToQuery(fields); <line4> for (String f : dbFields) { <line5> String docf = orientDBMapping.getDocumentField(f); <line6> if (docf == null || !obj.containsField(docf)) continue; <line7> OrientDBMapping.DocumentFieldType storeType = orientDBMapping.getDocumentFieldType(docf); <line8> Schema.Field field = fieldMap.get(f); <line9> Schema fieldSchema = field.schema(); <line10> Object result = convertDocFieldToAvroField(fieldSchema, storeType, field, docf, obj); <line11> persistent.put(field.pos(), result); <line12> } <line13> persistent.clearDirty(); <line14> return persistent; <line15> } <line16> } <line17> 	"<line10>      LOG.debug(""Load from ODocument, field:{}, schemaType:{}, docField:{}, storeType:{}"",new Object[] {field.name(), fieldSchema.getType(), docf, storeType});"	task4	
public class A { <line0> private static URL correctLocalUrl(String hostname, String tmpUrl) throws MalformedURLException { <line1> URL tmp = new URL(tmpUrl); <line2> if (hostname != null && hostname.length() > 0 && localAddresses.contains(tmp.getHost())) { <line3> URL endpointUrl = null; <line4> try { <line5> endpointUrl = new URL(tmp.getProtocol(), hostname, tmp.getPort(), tmp.getFile()); <line6> } catch (MalformedURLException e) { <line7> return tmp; <line8> } <line9> return endpointUrl; <line10> } <line11> return tmp; <line12> } <line13> } <line14> 	"<line7>        LOG.error(""Unable to process "" + hostname + "" as a valid hostname"", e);"	task4	
public class A { <line0> public void execute() { <line1> final long[] resendDelays = this.calculateResendDelays(this.resendNotificationMaximum); <line2> for (int notificationsResent = this.resendNotificationMaximum - 1; <line3> notificationsResent > -1; <line4> notificationsResent--) { <line5> final long delay = resendDelays[notificationsResent]; <line6> final DateTime createdBefore = DateTime.now(DateTimeZone.UTC).minus(delay); <line7> try { <line8> this.resendNotifications((short) notificationsResent, createdBefore); <line9> } catch (final CircuitBreakerOpenException exc) { <line10> break; <line11> } <line12> } <line13> } <line14> } <line15> 	"<line10>        LOGGER.warn(""Processing notifications for this run will be stopped, because the circuit breaker is""+ "" open."",exc);"	task4	
public class A { <line0> List<T> errorAndReturnEmpty() { <line1> return emptyList(); <line2> } <line3> } <line4> 	"<line1>    log.error(""poll invoked but consumer stopped for topic"" + topic, new RuntimeException(""stacktrace""));"	task4	
public class A { <line0> static int parseParamIdx(String paramNodeValue) { <line1> if (!StringUtils.isEmpty(paramNodeValue)) { <line2> try { <line3> Matcher m = PARAM_PATTERN.matcher(paramNodeValue); <line4> if (m.matches()) { <line5> return Integer.parseInt(m.group(1)); <line6> } <line7> } catch (Throwable e) { <line8> } <line9> } <line10> return -1; <line11> } <line12> } <line13> 	"<line8>        logger.error(""Failed to parse the value to get the parameter id."", e);"	task4	
public class A { <line0> @Initialize <line1> public void init() { <line2> final ClassLoader parent = getClass().getClassLoader(); <line3> _groovyClassLoader = new GroovyClassLoader(parent); <line4> final Class<?> groovyClass = _groovyClassLoader.parseClass(code); <line5> _groovyObject = (GroovyObject) ReflectionUtils.newInstance(groovyClass); <line6> } <line7> } <line8> 	"<line4>    logger.debug(""Compiling Groovy code:\n{}"", code);"	task4	
public class A { <line0> @Override <line1> public void onRegistrationSuccess( <line2> ServerIdentity server, RegisterRequest request, String registrationID) { <line3> } <line4> } <line5> 	"<line3>    log.info(""ClientObserver -> onRegistrationSuccess...  EndpointName [{}] [{}]"",request.getEndpointName(),registrationID);"	task4	
public class A { <line0> @Override <line1> public void onNodeJoined(String nodeName) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> if (isVertxReady()) { <line5> getEventBus().publish(CLUSTER_NODE_JOINED.address, nodeName); <line6> } <line7> } <line8> } <line9> 	"<line3>      log.debug(""Node {"" + nodeName + ""} joined the cluster."");"	task4	
public class A { <line0> protected BookieNode replaceFromRack( <line1> BookieNode bookieNodeToReplace, <line2> Set<Node> excludeBookies, <line3> Predicate<BookieNode> predicate, <line4> Ensemble<BookieNode> ensemble, <line5> boolean enforceDurability) <line6> throws BKException.BKNotEnoughBookiesException { <line7> Set<String> availableRegions = new HashSet<String>(); <line8> for (String region : perRegionPlacement.keySet()) { <line9> if ((null == disallowBookiePlacementInRegionFeatureName) <line10> || !featureProvider <line11> .scope(region) <line12> .getFeature(disallowBookiePlacementInRegionFeatureName) <line13> .isAvailable()) { <line14> availableRegions.add(region); <line15> } <line16> } <line17> String regionForBookieToReplace = getLocalRegion(bookieNodeToReplace); <line18> if (availableRegions.contains(regionForBookieToReplace)) { <line19> TopologyAwareEnsemblePlacementPolicy regionPolicy = <line20> perRegionPlacement.get(regionForBookieToReplace); <line21> if (null != regionPolicy) { <line22> try { <line23> return regionPolicy.selectFromNetworkLocation( <line24> bookieNodeToReplace.getNetworkLocation(), <line25> excludeBookies, <line26> TruePredicate.INSTANCE, <line27> EnsembleForReplacementWithNoConstraints.INSTANCE, <line28> true); <line29> } catch (BKException.BKNotEnoughBookiesException e) { <line30> } <line31> } <line32> } <line33> return selectRandomFromRegions( <line34> availableRegions, <line35> 1, <line36> excludeBookies, <line37> enforceDurability ? predicate : TruePredicate.INSTANCE, <line38> enforceDurability ? ensemble : EnsembleForReplacementWithNoConstraints.INSTANCE) <line39> .get(0); <line40> } <line41> } <line42> 	"<line30>          LOG.warn(""Failed to choose a bookie from {} : ""+ ""excluded {}, fallback to choose bookie randomly from the cluster."",bookieNodeToReplace.getNetworkLocation(),excludeBookies);"	task4	
"public class A { <line0> public void update(UpnpControlBindingConfiguration newConfig) { <line1> String newPath = newConfig.path; <line2> if (newPath.isEmpty()) { <line3> path = DEFAULT_PATH; <line4> } else { <line5> File file = new File(newPath); <line6> if (!file.isDirectory()) { <line7> file = file.getParentFile(); <line8> } <line9> if (file.exists()) { <line10> if (!(newPath.endsWith(File.separator) || newPath.endsWith(""/""))) { <line11> newPath = newPath + File.separator; <line12> } <line13> path = newPath; <line14> } else { <line15> path = DEFAULT_PATH; <line16> } <line17> } <line18> UpnpControlUtil.bindingConfigurationChanged(path); <line19> } <line20> } <line21> "	"<line18>    logger.debug(""Storage path updated to {}"", path);"	task4	
public class A { <line0> VertexStatus getVertexStatusViaAM(String vertexName, Set<StatusGetOpts> statusOptions) <line1> throws TezException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> GetVertexStatusRequestProto.Builder requestProtoBuilder = <line5> GetVertexStatusRequestProto.newBuilder().setDagId(dagId).setVertexName(vertexName); <line6> if (statusOptions != null) { <line7> requestProtoBuilder.addAllStatusOptions( <line8> DagTypeConverters.convertStatusGetOptsToProto(statusOptions)); <line9> } <line10> try { <line11> return new VertexStatus( <line12> proxy.getVertexStatus(null, requestProtoBuilder.build()).getVertexStatus()); <line13> } catch (ServiceException e) { <line14> throw new TezException(e); <line15> } <line16> } <line17> } <line18> 	"<line3>      LOG.debug(""GetVertexStatus via AM for app: "" + appId + "" dag: "" + dagId + "" vertex: "" + vertexName);"	task4	
public class A { <line0> private void collectPointX(JSONSaxPrimitiveValue value) { <line1> myCurrentLon = value.getDouble(); <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> myState = ArcSaxState.SEEK_POINT_Y_TAG; <line5> } <line6> } <line7> 	"<line3>      LOGGER.trace(""->COLLECTED POINT X VALUE(LON): "" + myCurrentLon);"	task4	
public class A { <line0> public void warn(Throwable t, String message, Object... formatArgs) { <line1> } <line2> } <line3> 	<line1>    log.warn(StringUtils.safeFormat(message, formatArgs), t);	task4	
"public class A { <line0> @Test <line1> public void shouldNotStartWithInvalidConfiguration() { <line2> config = <line3> Configuration.create() <line4> .with(MySqlConnectorConfig.SERVER_NAME, ""myserver"") <line5> .with(KafkaDatabaseHistory.TOPIC, ""myserver"") <line6> .with(MySqlConnectorConfig.DATABASE_HISTORY, FileDatabaseHistory.class) <line7> .with(FileDatabaseHistory.FILE_PATH, DB_HISTORY_PATH) <line8> .build(); <line9> start( <line10> MySqlConnector.class, <line11> config, <line12> (success, msg, error) -> { <line13> assertThat(success).isFalse(); <line14> assertThat(error).isNotNull(); <line15> }); <line16> assertConnectorNotRunning(); <line17> } <line18> } <line19> "	"<line9>    logger.info(""Attempting to start the connector with an INVALID configuration, so MULTIPLE error""+ "" messages and exceptions will appear in the log"");"	task4	
public class A { <line0> public Templates getStylesheet(Source stylesheet) { <line1> try { <line2> return saxFactory.newTemplates(stylesheet); <line3> } catch (TransformerConfigurationException tcx) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	<line4>      LOGGER.fatal(tcx.getMessageAndLocation());	task4	
public class A { <line0> public void writeConfiguration(SolrConfig solrConfig) throws ApsSystemException { <line1> try { <line2> String marshalInfo = SolrConfigDOM.marshalConfig(solrConfig); <line3> this.getConfigManager() <line4> .updateConfigItem( <line5> SolrConnectorSystemConstants.JPSOLRCLIENT_SYSTEM_CONFIG_NAME, marshalInfo); <line6> } catch (ApsSystemException e) { <line7> throw e; <line8> } <line9> } <line10> } <line11> 	"<line7>      logger.error(""Error updating configuration"", e);"	task4	
"public class A { <line0> protected Entity addCluster(Location location) { <line1> String locationName = elvis(location.getDisplayName(), location.getDisplayName(), null); <line2> Map creation = Maps.newLinkedHashMap(); <line3> creation.putAll(getCustomChildFlags()); <line4> if (groovyTruth(getDisplayNamePrefix()) || groovyTruth(getDisplayNameSuffix())) { <line5> String displayName = <line6> """" <line7> + elvis(getDisplayNamePrefix(), """") <line8> + elvis(locationName, ""unnamed"") <line9> + elvis(getDisplayNameSuffix(), """"); <line10> creation.put(""displayName"", displayName); <line11> } <line12> Entity entity = createCluster(location, creation); <line13> if (locationName != null) { <line14> if (entity.getDisplayName() == null) <line15> entity.setDisplayName(entity.getEntityType().getSimpleName() + "" ("" + locationName + "")""); <line16> else if (!entity.getDisplayName().contains(locationName)) <line17> entity.setDisplayName(entity.getDisplayName() + "" ("" + locationName + "")""); <line18> } <line19> if (entity.getParent() == null) entity.setParent(this); <line20> Entities.manage(entity); <line21> addMember(entity); <line22> return entity; <line23> } <line24> } <line25> "	"<line12>    logger.info(""Creating entity in fabric {} at {}{}"",new Object[] {this,location,(creation != null && !creation.isEmpty() ? "", properties "" + creation : """")});"	task4	
public class A { <line0> public void useOrderManager(OrderManager manager) { <line1> if (myOrderManager != null && !Utilities.sameInstance(myOrderManager, manager)) { <line2> myOrderManager.removeParticipantChangeListener(myOrderListener); <line3> } <line4> myOrderManager = manager; <line5> myOrderManager.addParticipantChangeListener(myOrderListener); <line6> } <line7> } <line8> 	"<line2>      LOGGER.warn(""Switching the order manager used by the ElevationManager."");"	task4	
"public class A { <line0> public static java.util.List<com.liferay.commerce.inventory.model.CommerceInventoryWarehouse> <line1> getCommerceInventoryWarehouses( <line2> HttpPrincipal httpPrincipal, long companyId, long groupId, boolean active) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceInventoryWarehouseServiceUtil.class, <line8> ""getCommerceInventoryWarehouses"", <line9> _getCommerceInventoryWarehousesParameterTypes10); <line10> MethodHandler methodHandler = new MethodHandler(methodKey, companyId, groupId, active); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<com.liferay.commerce.inventory.model.CommerceInventoryWarehouse>) <line21> returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static void updateStatus( <line1> HttpPrincipal httpPrincipal, <line2> long membershipRequestId, <line3> String reviewComments, <line4> long statusId, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> MembershipRequestServiceUtil.class, ""updateStatus"", _updateStatusParameterTypes3); <line11> MethodHandler methodHandler = <line12> new MethodHandler( <line13> methodKey, membershipRequestId, reviewComments, statusId, serviceContext); <line14> try { <line15> TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>      log.error(systemException, systemException);	task4	
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void testGradientAutoBroadcast1(Nd4jBackend backend) { <line3> Nd4j.getRandom().setSeed(12345); <line4> List<String> failed = new ArrayList<>(); <line5> for (int dim_sz1 : new int[] {0, 1, 2}) { <line6> int[] in2Shape = {3, 4, 5}; <line7> in2Shape[dim_sz1] = 1; <line8> for (int i = 0; i < 8; i++) { <line9> SameDiff sd = SameDiff.create(); <line10> SDVariable in3 = sd.var(""in3"", Nd4j.rand(new int[] {3, 4, 5})); <line11> SDVariable in2 = sd.var(""in2"", in2Shape); <line12> SDVariable bcOp; <line13> String name; <line14> switch (i) { <line15> case 0: <line16> bcOp = in3.add(in2); <line17> name = ""add""; <line18> break; <line19> case 1: <line20> bcOp = in3.sub(in2); <line21> name = ""sub""; <line22> break; <line23> case 2: <line24> bcOp = in3.mul(in2); <line25> name = ""mul""; <line26> break; <line27> case 3: <line28> bcOp = in3.div(in2); <line29> name = ""div""; <line30> break; <line31> case 4: <line32> bcOp = in3.rsub(in2); <line33> name = ""rsub""; <line34> break; <line35> case 5: <line36> bcOp = in3.rdiv(in2); <line37> name = ""rdiv""; <line38> break; <line39> case 6: <line40> bcOp = new FloorDivOp(sd, in3, in2).outputVariable(); <line41> name = ""floordiv""; <line42> break; <line43> case 7: <line44> bcOp = new FloorModOp(sd, in3, in2).outputVariable(); <line45> name = ""floormod""; <line46> if (OpValidationSuite.IGNORE_FAILING) { <line47> continue; <line48> } <line49> break; <line50> default: <line51> throw new RuntimeException(); <line52> } <line53> SDVariable outVar = sd.sum(bcOp); <line54> String msg = ""(test "" + i + "": "" + name + "", dimension="" + dim_sz1 + "")""; <line55> INDArray in3Arr = Nd4j.randn(new int[] {3, 4, 5}).muli(100); <line56> INDArray in2Arr = Nd4j.randn(in2Shape).muli(100); <line57> sd.associateArrayWithVariable(in3Arr, in3); <line58> sd.associateArrayWithVariable(in2Arr, in2); <line59> TestCase tc = new TestCase(sd); <line60> String error = OpValidation.validate(tc); <line61> if (error != null) { <line62> failed.add(name); <line63> } <line64> } <line65> } <line66> assertEquals(0, failed.size(), ""Failed: "" + failed); <line67> } <line68> } <line69> "	"<line55>        log.info(""*** Starting test: "" + msg);"	task4	
public class A { <line0> private static boolean defineActivePowerControl( <line1> Network network, <line2> String id, <line3> PsseTransformerWinding winding, <line4> PhaseTapChanger ptc, <line5> boolean regulatingForcedToOff) { <line6> if (Math.abs(winding.getCod()) != 3) { <line7> return false; <line8> } <line9> Terminal regulatingTerminal = defineRegulatingTerminal(network, id, winding); <line10> if (regulatingTerminal == null) { <line11> return false; <line12> } <line13> double activePowerMin = winding.getVmi(); <line14> double activePowerMax = winding.getVma(); <line15> double targetValue = 0.5 * (activePowerMin + activePowerMax); <line16> double targetDeadBand = activePowerMax - activePowerMin; <line17> boolean regulating = true; <line18> if (targetDeadBand < 0.0) { <line19> regulating = false; <line20> } <line21> if (regulating && regulatingForcedToOff) { <line22> regulating = false; <line23> } <line24> ptc.setRegulationValue(targetValue) <line25> .setTargetDeadband(targetDeadBand) <line26> .setRegulationTerminal(regulatingTerminal) <line27> .setRegulationMode(PhaseTapChanger.RegulationMode.ACTIVE_POWER_CONTROL) <line28> .setRegulating(regulating); <line29> return regulating; <line30> } <line31> } <line32> 	"<line22>      LOGGER.warn(""Transformer {}. Regulating control forced to off. Only one control is supported"", id);"	task4	
public class A { <line0> public void startService(String serviceName) throws ServiceAdminException, RemoteException { <line1> serviceAdminStub.startService(serviceName); <line2> } <line3> } <line4> 	"<line2>    log.info(""Service Started"");"	task4	
"public class A { <line0> @Override <line1> public void beforeRuntimeStop(ComponentManager mgr, boolean isStandby) { <line2> List<WorkQueueDescriptor> descriptors = getRegistryContributions(QUEUES_EP); <line3> for (WorkQueueDescriptor descriptor : descriptors) { <line4> deactivateQueue(descriptor); <line5> } <line6> try { <line7> if (!shutdown(10, TimeUnit.SECONDS)) { <line8> } <line9> } catch (InterruptedException e) { <line10> Thread.currentThread().interrupt(); <line11> throw new NuxeoException(""Interrupted while stopping work manager thread pools"", e); <line12> } <line13> } <line14> } <line15> "	"<line8>        log.error(""Some processors are still active"");"	task4	
public class A { <line0> public void failJob(String message, String details) { <line1> throw new JobFailedException(message, details); <line2> } <line3> } <line4> 	"<line1>    log.debug(""failed deposit: {}"", message);"	task4	
public class A { <line0> public void attachCellEditors() { <line1> String[] properties = new String[columns.size()]; <line2> CellEditor[] cellEditors = new CellEditor[columns.size()]; <line3> int size = columns.size(); <line4> for (int i = 0; i < size; i++) { <line5> TableViewerCreatorColumnNotModifiable column = columns.get(i); <line6> properties[i] = column.getId(); <line7> cellEditors[i] = column.getCellEditor(); <line8> if (column.getCellEditor() != null && column.getBeanPropertyAccessors() == null) { <line9> } <line10> } <line11> tableViewer.setColumnProperties(properties); <line12> tableViewer.setCellEditors(cellEditors); <line13> } <line14> } <line15> 	"<line9>        log.warn(Messages.getString(""TableViewerCreator.columnNoIBeanProperty"", column.getId(), column.getTitle()));"	task4	
public class A { <line0> @Override <line1> public int getProductCount() { <line2> return super.getProductCount(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting product count: "", super.getProductCount());"	task4	
public class A { <line0> @Override <line1> public Aggregation<P, R, T> createAggregation( <line2> final DataTypeAdapter<T> adapter, final Index index) { <line3> GeotoolsFeatureDataAdapter gtAdapter; <line4> if (adapter instanceof GeotoolsFeatureDataAdapter) { <line5> gtAdapter = (GeotoolsFeatureDataAdapter) adapter; <line6> } else if ((adapter instanceof InternalDataAdapter) <line7> && (((InternalDataAdapter) adapter).getAdapter() instanceof GeotoolsFeatureDataAdapter)) { <line8> gtAdapter = (GeotoolsFeatureDataAdapter) ((InternalDataAdapter) adapter).getAdapter(); <line9> } else { <line10> return null; <line11> } <line12> if ((fieldNameParam == null) || isCommonIndex(index, gtAdapter)) { <line13> return createCommonIndexAggregation(); <line14> } <line15> return createAggregation(); <line16> } <line17> } <line18> 	"<line10>      LOGGER.error(""Unable to perform aggregation on non-geotools feature adapter '""+ adapter.getTypeName()+ ""'"");"	task4	
"public class A { <line0> private void loadPlugin(URLClassLoader pluginClassLoader) { <line1> ServiceLoader<DolphinSchedulerPlugin> serviceLoader = <line2> ServiceLoader.load(DolphinSchedulerPlugin.class, pluginClassLoader); <line3> List<DolphinSchedulerPlugin> plugins = ImmutableList.copyOf(serviceLoader); <line4> Preconditions.checkState( <line5> !plugins.isEmpty(), <line6> ""No service providers the plugin {}"", <line7> DolphinSchedulerPlugin.class.getName()); <line8> for (DolphinSchedulerPlugin plugin : plugins) { <line9> for (AbstractDolphinPluginManager dolphinPluginManager : dolphinPluginManagerList) { <line10> dolphinPluginManager.installPlugin(plugin); <line11> } <line12> } <line13> } <line14> } <line15> "	"<line9>      logger.info(""Installing {}"", plugin.getClass().getName());"	task4	
"public class A { <line0> @Override <line1> public void deleteByQuery(TypeDescriptor typeDescriptor, Object query) throws ClientException { <line2> JsonNode queryJsonNode = getModelConverter().convertQuery(query); <line3> String json = writeRequestFromJsonNode(queryJsonNode); <line4> Response deleteResponse = <line5> restCallTimeoutHandler( <line6> () -> <line7> getClient() <line8> .performRequest( <line9> ElasticsearchKeywords.ACTION_POST, <line10> ElasticsearchResourcePaths.deleteByQuery(typeDescriptor), <line11> Collections.emptyMap(), <line12> ApplicationJsonEntityBuilder.buildFrom(json), <line13> new ContentTypeApplicationJsonHeader()), <line14> typeDescriptor.getIndex(), <line15> ""DELETE BY QUERY""); <line16> if (!isRequestSuccessful(deleteResponse) <line17> && !isRequestNotFound(deleteResponse) <line18> && !isRequestBadRequest(deleteResponse)) { <line19> throw buildExceptionFromUnsuccessfulResponse(""Delete by query"", deleteResponse); <line20> } <line21> } <line22> } <line23> "	<line3>    LOG.debug(QUERY_CONVERTED_QUERY, queryJsonNode);	task4	
"public class A { <line0> private static X509Certificate generateCert(ZonedDateTime now, X509CertificateHolder certHolder) <line1> throws Exception { <line2> final X509Certificate certificate = <line3> new JcaX509CertificateConverter().getCertificate(certHolder); <line4> certificate.checkValidity(Date.from(now.toInstant())); <line5> certificate.verify(certificate.getPublicKey()); <line6> final String fingerprint = <line7> BaseEncoding.base16() <line8> .withSeparator("":"", 2) <line9> .encode(MessageDigest.getInstance(""SHA-256"").digest(certificate.getEncoded())); <line10> return certificate; <line11> } <line12> } <line13> "	"<line10>    LOGGER.info(""Certificate created (SHA-256 fingerprint: {})"", fingerprint);"	task4	
public class A { <line0> @Override <line1> public boolean checkParameters( <line2> AbstractParameter abstractParameter, ValidationParameters validationParameters) { <line3> if (!(abstractParameter instanceof NeptuneValidateParameters)) { <line4> return false; <line5> } <line6> return super.checkParameters(abstractParameter, validationParameters); <line7> } <line8> } <line9> 	"<line4>      log.error(""invalid parameters for validator "" + abstractParameter.getClass().getName());"	task4	
public class A { <line0> public void updateContents( <line1> OmUrlFragment f, IPartialPageRequestHandler handler, boolean updateFragment) { <line2> BasePanel npanel = getPanel(f.getArea(), f.getType()); <line3> if (npanel != null) { <line4> if (getClient() != null) { <line5> updateContents(npanel, handler); <line6> } else { <line7> this.panel = npanel; <line8> } <line9> if (updateFragment) { <line10> UrlFragment uf = new UrlFragment(handler); <line11> uf.set(f.getArea().name(), f.getType()); <line12> } <line13> } <line14> } <line15> } <line16> 	"<line3>    log.debug(""updateContents:: npanels IS null ? {}, client IS null ? {}"",npanel == null,getClient() == null);"	task4	
"public class A { <line0> @Override <line1> public AsyncJobStatusDTO exportDataAsync( <line2> @Verify(Consumer.class) String consumerUuid, <line3> String cdnLabel, <line4> String webAppPrefix, <line5> String apiUrl) { <line6> HttpServletResponse response = ResteasyContext.getContextData(HttpServletResponse.class); <line7> Consumer consumer = consumerCurator.verifyAndLookupConsumer(consumerUuid); <line8> ConsumerType ctype = this.consumerTypeCurator.getConsumerType(consumer); <line9> Owner owner = ownerCurator.findOwnerById(consumer.getOwnerId()); <line10> JobConfig config = <line11> manifestManager.generateManifestAsync(consumerUuid, owner, cdnLabel, webAppPrefix, apiUrl); <line12> AsyncJobStatus job = null; <line13> try { <line14> job = this.jobManager.queueJob(config); <line15> } catch (JobException e) { <line16> String errmsg = <line17> this.i18n.tr( <line18> ""An unexpected exception occurred "" + ""while scheduling job \""{0}\"""", <line19> config.getJobKey()); <line20> throw new IseException(errmsg, e); <line21> } <line22> return this.translator.translate(job, AsyncJobStatusDTO.class); <line23> } <line24> } <line25> "	<line20>      log.error(errmsg, e);	task4	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public PackageId getId() { <line2> String group = get(PN_GROUP); <line3> String name = get(PN_NAME); <line4> String version = get(PN_VERSION); <line5> if (group == null || name == null || name.length() == 0) { <line6> String path = getInstallationPath(); <line7> if (path == null) { <line8> path = ""unknown""; <line9> } <line10> return new PackageId(path, version); <line11> } else { <line12> return new PackageId(group, name, version); <line13> } <line14> } <line15> } <line16> "	"<line8>        log.warn(""Unable to calculate installation path. setting to 'unknown'"");"	task4	
"public class A { <line0> public static void assertVerticesPresenceMinOccur( <line1> final VerticesResult verticesResult, <line2> final Vertex.VERTEX_TYPE vertexType, <line3> final int minOccurrence) { <line4> int occurrence = 0; <line5> for (Vertex vertex : verticesResult.getResults()) { <line6> if (vertex.getType() == vertexType) { <line7> occurrence++; <line8> if (occurrence >= minOccurrence) { <line9> return; <line10> } <line11> } <line12> } <line13> Assert.fail( <line14> String.format( <line15> ""Expected at least %d vertices of type %s. But found only %d"", <line16> minOccurrence, vertexType, occurrence)); <line17> } <line18> } <line19> "	"<line7>        LOGGER.info(""Found vertex: "" + vertex);"	task4	
public class A { <line0> @Override <line1> protected long convert(Path inputPath, SyncDataFileWriter<ExtendedRecord> dataFileWriter) <line2> throws IOException { <line3> DwcaReader reader = DwcaReader.fromLocation(inputPath.toString()); <line4> while (reader.advance()) { <line5> ExtendedRecord record = reader.getCurrent(); <line6> if (!record.getId().equals(ExtendedRecordConverter.getRecordIdError())) { <line7> dataFileWriter.append(record); <line8> } <line9> } <line10> reader.close(); <line11> return reader.getRecordsReturned(); <line12> } <line13> } <line14> 	"<line4>    log.info(""Exporting the DwC Archive to Avro started {}"", inputPath);"	task4	
public class A { <line0> @Override <line1> public void registerContribution( <line2> Object contribution, String extensionPoint, ComponentInstance contributor) throws Exception { <line3> if (CONVERTER_EP.equals(extensionPoint)) { <line4> ConverterDescriptor desc = (ConverterDescriptor) contribution; <line5> registerConverter(desc); <line6> } else if (CONFIG_EP.equals(extensionPoint)) { <line7> GlobalConfigDescriptor desc = (GlobalConfigDescriptor) contribution; <line8> config.update(desc); <line9> } else { <line10> } <line11> } <line12> } <line13> 	"<line10>      log.error(""Unable to handle unknown extensionPoint "" + extensionPoint);"	task4	
public class A { <line0> private TextMessage createWebSocketTextMessage(AgentActiveThreadCountList activeThreadCountList) { <line1> Map<String, Object> resultMap = <line2> createResultMap(activeThreadCountList, System.currentTimeMillis()); <line3> try { <line4> String response = <line5> messageConverter.getResponseTextMessage( <line6> ActiveThreadCountHandler.API_ACTIVE_THREAD_COUNT, resultMap); <line7> TextMessage responseTextMessage = new TextMessage(response); <line8> return responseTextMessage; <line9> } catch (JsonProcessingException e) { <line10> } <line11> return null; <line12> } <line13> } <line14> 	"<line10>      logger.warn(""failed while to convert message. applicationName:{}, original:{}, message:{}."",applicationName,resultMap,e.getMessage(),e);"	task4	
public class A { <line0> private void configureTablesIfNecessary( <line1> String[] tableNames, TableOperations tops, Configuration conf, Logger log) <line2> throws AccumuloSecurityException, AccumuloException, TableNotFoundException { <line3> Map<String, TableConfigHelper> tableConfigs = getTableConfigs(log, conf, tableNames); <line4> for (String table : tableNames) { <line5> TableConfigHelper tableHelper = tableConfigs.get(table); <line6> if (tableHelper != null) { <line7> tableHelper.configure(tops); <line8> } else { <line9> } <line10> } <line11> } <line12> } <line13> 	"<line9>        log.info(""No configuration supplied for table "" + table);"	task4	
public class A { <line0> public void setRetryInterval(final Long retryInterval) { <line1> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line2> } <line3> hasBeenUpdated = true; <line4> this.retryInterval = retryInterval; <line5> } <line6> } <line7> 	"<line2>      ActiveMQRALogger.LOGGER.trace(""setRetryInterval("" + retryInterval + "")"");"	task4	
public class A { <line0> private void checkRelations(MassnahmenUmsetzung massnahme) { <line1> Set<CnALink> linkedPersons = new HashSet<CnALink>(); <line2> try { <line3> List<Person> personenUmsetzungDurch = getPersonsbyProperty(massnahme); <line4> Set<Property> rolesToSearch = findRole(massnahme); <line5> if (personenUmsetzungDurch != null && !personenUmsetzungDurch.isEmpty()) { <line6> for (Person person : personenUmsetzungDurch) { <line7> controlExistsLinks(massnahme, linkedPersons, rolesToSearch, person); <line8> } <line9> } else { <line10> Set<Person> linkedPersonsWithRole = new HashSet<Person>(); <line11> findLinkedPersonsUpTree(massnahme, linkedPersonsWithRole, rolesToSearch); <line12> if (!linkedPersonsWithRole.isEmpty() && linkedPersonsWithRole != null) { <line13> for (Person person : linkedPersonsWithRole) { <line14> createLinkCommand(massnahme, person, MassnahmenUmsetzung.MNUMS_RELATION_ID); <line15> } <line16> } <line17> } <line18> } catch (CommandException ce) { <line19> } <line20> } <line21> } <line22> 	"<line19>      log.error(""Error while creating relation"", ce);"	task4	
public class A { <line0> @Override <line1> public ListType findByPrimaryKey(Serializable primaryKey) throws NoSuchListTypeException { <line2> ListType listType = fetchByPrimaryKey(primaryKey); <line3> if (listType == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchListTypeException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return listType; <line9> } <line10> } <line11> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
public class A { <line0> @Override <line1> public ApiRequest deleteHost(String clusterName, String fqdn) throws AmbariApiException { <line2> Response response = null; <line3> try { <line4> response = <line5> apiResourceRootV1.getClustersResource().getHostsResource(clusterName).deleteHost(fqdn); <line6> } catch (Exception e) { <line7> throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e); <line8> } <line9> String deleteHostJson = handleAmbariResponse(response); <line10> return ApiUtils.jsonToObject(ApiRequest.class, deleteHostJson); <line11> } <line12> } <line13> 	"<line2>    logger.info(""Deleting host "" + fqdn + "" in cluster "" + clusterName);"	task4	
"public class A { <line0> private MCRDerivate createDerivate( <line1> MCRObjectID objectID, List<MCRMetaClassification> classifications) <line2> throws MCRPersistenceException, MCRAccessException { <line3> MCRObjectID derivateID = getNewCreateDerivateID(objectID); <line4> MCRDerivate derivate = new MCRDerivate(); <line5> derivate.setId(derivateID); <line6> derivate.getDerivate().getClassifications().addAll(classifications); <line7> String schema = <line8> MCRConfiguration2.getString(""MCR.Metadata.Config.derivate"") <line9> .orElse(""datamodel-derivate.xml"") <line10> .replaceAll("".xml"", "".xsd""); <line11> derivate.setSchema(schema); <line12> MCRMetaLinkID linkId = new MCRMetaLinkID(); <line13> linkId.setSubTag(""linkmeta""); <line14> linkId.setReference(objectID, null, null); <line15> derivate.getDerivate().setLinkMeta(linkId); <line16> MCRMetaIFS ifs = new MCRMetaIFS(); <line17> ifs.setSubTag(""internal""); <line18> ifs.setSourcePath(null); <line19> derivate.getDerivate().setInternals(ifs); <line20> MCRMetadataManager.create(derivate); <line21> setDefaultPermissions(derivateID); <line22> return derivate; <line23> } <line24> } <line25> "	"<line20>    LOGGER.debug(""Creating new derivate with ID {}"", derivateID);"	task4	
public class A { <line0> @Override <line1> @Transactional <line2> public boolean pruneData(OrganisationUnit organisationUnit) { <line3> User user = currentUserService.getCurrentUser(); <line4> if (user == null || !user.isSuper()) { <line5> return false; <line6> } <line7> dataApprovalService.deleteDataApprovals(organisationUnit); <line8> dataApprovalAuditService.deleteDataApprovalAudits(organisationUnit); <line9> completeRegistrationService.deleteCompleteDataSetRegistrations(organisationUnit); <line10> dataValueAuditService.deleteDataValueAudits(organisationUnit); <line11> dataValueService.deleteDataValues(organisationUnit); <line12> return true; <line13> } <line14> } <line15> 	"<line12>    log.info(""Pruned data for organisation unit: "" + organisationUnit);"	task4	
public class A { <line0> protected void deleteFinishedUnreleasedSqlFile(List<File> unreleasedSqlFileList) { <line1> for (File unreleasedSqlFile : unreleasedSqlFileList) { <line2> if (unreleasedSqlFile.exists()) { <line3> unreleasedSqlFile.delete(); <line4> } <line5> } <line6> } <line7> } <line8> 	"<line1>    log.info(""...Deleting already-released AlterDDL in unreleased directory: ""+ unreleasedSqlFileList.size());"	task4	
public class A { <line0> @Override <line1> public UUID fromBytes(Class targetClass, byte[] bytes) throws PropertyAccessException { <line2> try { <line3> if (bytes == null) { <line4> return null; <line5> } <line6> long msb = 0; <line7> long lsb = 0; <line8> for (int i = 0; i < 8; i++) msb = (msb << 8) | (bytes[i] & 0xff); <line9> for (int i = 8; i < 16; i++) lsb = (lsb << 8) | (bytes[i] & 0xff); <line10> return new UUID(msb, lsb); <line11> } catch (Exception e) { <line12> throw new PropertyAccessException(e); <line13> } <line14> } <line15> } <line16> 	"<line12>      log.error(""Error occured, Caused by {}."", e);"	task4	
"public class A { <line0> public DataSource getTargetDataSource( <line1> AugmentedRow augmentedRow, Put put, String table, List<String> updatedColumns) { <line2> Object targetDataSource = <line3> configuration.getOrDefault( <line4> ValidationService.Configuration.VALIDATION_TARGET_DATA_SOURCE, null); <line5> String row = null; <line6> String cf = null; <line7> try { <line8> row = URLEncoder.encode(Bytes.toStringBinary(put.getRow()), UTF8); <line9> cf = URLEncoder.encode(Bytes.toString(CF), UTF8); <line10> } catch (UnsupportedEncodingException e) { <line11> } <line12> return targetDataSource == null <line13> || row == null <line14> || cf == null <line15> || put.has(CF, Bytes.toBytes(""row_status""), Bytes.toBytes(""D"")) <line16> || updatedColumns.isEmpty() <line17> ? null <line18> : new DataSource( <line19> (String) targetDataSource, <line20> new BigtableQueryOptions(table, row, cf, getTargetTransformations(updatedColumns))); <line21> } <line22> } <line23> "	"<line11>      LOGGER.error(""UTF-8 not supported?"", e);"	task4	
public class A { <line0> private SyntheticRunResult runJavaInternal( <line1> Constructor<?> defaultConstructor, Method testMethod, Object testArg, long startTick) <line2> throws Exception { <line3> long captureTime; <line4> long durationNanos; <line5> try { <line6> testMethod.invoke(defaultConstructor.newInstance(), testArg); <line7> captureTime = clock.currentTimeMillis(); <line8> durationNanos = ticker.read() - startTick; <line9> } catch (InvocationTargetException e) { <line10> Throwable throwable = e.getTargetException(); <line11> if (throwable instanceof InterruptedException) { <line12> throw (InterruptedException) throwable; <line13> } <line14> return ImmutableSyntheticRunResult.builder() <line15> .captureTime(clock.currentTimeMillis()) <line16> .durationNanos(ticker.read() - startTick) <line17> .throwable(throwable) <line18> .build(); <line19> } finally { <line20> if (testArg instanceof JBrowserDriver) { <line21> ((JBrowserDriver) testArg).kill(); <line22> } <line23> } <line24> return ImmutableSyntheticRunResult.builder() <line25> .captureTime(captureTime) <line26> .durationNanos(durationNanos) <line27> .build(); <line28> } <line29> } <line30> 	<line10>      logger.debug(e.getMessage(), e);	task4	
public class A { <line0> protected synchronized boolean channelExist(String channel) { <line1> connect(redisServerAddress.getHost(), redisServerAddress.getPort()); <line2> pubsubNumsub(channel.getBytes()); <line3> boolean exist = false; <line4> try { <line5> exist = (readPubsubNumsubReply(channel) > 0) ? true : false; <line6> } catch (ProtocolException e) { <line7> } <line8> return exist; <line9> } <line10> } <line11> 	"<line7>      log.error(""Redis protocol error"", e);"	task4	
"public class A { <line0> protected Document createDocument(Account owner, Document srcDocument, String fileName) <line1> throws BusinessException { <line2> boolean createIt = false; <line3> Document document = null; <line4> List<Document> documents = documentRepository.findBySha256Sum(srcDocument.getSha256sum()); <line5> if (documents.isEmpty() || !deduplication) { <line6> createIt = true; <line7> } else { <line8> document = documents.get(0); <line9> if (!fileDataStore.exists(new FileMetaData(FileMetaDataKind.DATA, document))) { <line10> createIt = true; <line11> } <line12> } <line13> if (createIt) { <line14> FileMetaData metadataSrc = new FileMetaData(FileMetaDataKind.DATA, srcDocument); <line15> FileMetaData metadata = <line16> new FileMetaData( <line17> FileMetaDataKind.DATA, srcDocument.getType(), srcDocument.getSize(), fileName); <line18> ByteSource byteSource = fileDataStore.get(metadataSrc); <line19> try { <line20> metadata = fileDataStore.add(byteSource, metadata); <line21> } catch (IOException e1) { <line22> throw new BusinessException(""Can not create a copy of existing document.""); <line23> } <line24> Map<ThumbnailType, FileMetaData> fileMetaDataThumbnail = <line25> copyThumbnail(srcDocument, owner, metadata); <line26> try { <line27> document = new Document(metadata); <line28> document.setSha256sum(srcDocument.getSha256sum()); <line29> document.setSha1sum(srcDocument.getSha1sum()); <line30> document.setHasThumbnail(false); <line31> Map<ThumbnailType, Thumbnail> fileThumbnails = <line32> toFileThumbnail(document, fileMetaDataThumbnail); <line33> if (!fileThumbnails.isEmpty()) { <line34> document.setHasThumbnail(true); <line35> document.setThumbnails(fileThumbnails); <line36> } <line37> document = documentRepository.create(document); <line38> } catch (BusinessException e) { <line39> if (metadata != null) fileDataStore.remove(metadata); <line40> if (!fileMetaDataThumbnail.isEmpty()) { <line41> for (Map.Entry<ThumbnailType, FileMetaData> entry : fileMetaDataThumbnail.entrySet()) { <line42> if (entry.getValue() != null) { <line43> removeMetadata(entry.getValue()); <line44> } <line45> } <line46> } <line47> } <line48> } <line49> return document; <line50> } <line51> } <line52> "	<line22>        logger.error(e1.getMessage(), e1);	task4	
public class A { <line0> private void log( <line1> final LogMessage.Stream stream, <line2> final String containerId, <line3> final JobId jobId, <line4> final StringBuilder stringBuilder) { <line5> stringBuilder.setLength(0); <line6> } <line7> } <line8> 	"<line5>    log.info(""[{}] [{}] {} {}"",jobId.getName(),containerId.substring(0, Math.min(7, containerId.length())),stream.id(),stringBuilder.toString());"	task4	
public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceBOMFolder commerceBOMFolder) { <line2> PermissionChecker permissionChecker = PermissionThreadLocal.getPermissionChecker(); <line3> try { <line4> if (commerceBOMFolder == null) { <line5> PortletResourcePermission portletResourcePermission = <line6> _commerceBOMFolderModelResourcePermission.getPortletResourcePermission(); <line7> return portletResourcePermission.contains( <line8> permissionChecker, null, CommerceBOMActionKeys.ADD_COMMERCE_BOM_FOLDER); <line9> } <line10> return _commerceBOMFolderModelResourcePermission.contains( <line11> permissionChecker, commerceBOMFolder, ActionKeys.UPDATE); <line12> } catch (PortalException portalException) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	<line13>      log.error(portalException, portalException);	task4	
public class A { <line0> public void moveTo(double topStom, double midStom, double lowStom) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> this.topStom.moveTo(topStom); <line4> this.midStom.moveTo(midStom); <line5> this.lowStom.moveTo(lowStom); <line6> } <line7> } <line8> 	"<line2>      log.debug(""{} moveTo {} {} {}"", getName(), topStom, midStom, lowStom);"	task4	
public class A { <line0> private void warnFragmented( <line1> ByteBuffer buffer, int iterations, AtomicInteger counter, String operation) { <line2> int total = counter.incrementAndGet(); <line3> } <line4> } <line5> 	"<line3>    logger.warn(""{} for buffer with length {} was fragmented {} times (total fragmented operations: {})"",operation,buffer.limit(),iterations,total);"	task4	
public class A { <line0> public PreparedCommand buildCommand( <line1> MetaCommand mc, List<ArgumentAssignment> argAssignmentList, String origin, int seq, User user) <line2> throws ErrorInCommand, YamcsException { <line3> CommandBuildResult cbr = metaCommandProcessor.buildCommand(mc, argAssignmentList); <line4> CommandId cmdId = <line5> CommandId.newBuilder() <line6> .setCommandName(mc.getQualifiedName()) <line7> .setOrigin(origin) <line8> .setSequenceNumber(seq) <line9> .setGenerationTime(processor.getCurrentTime()) <line10> .build(); <line11> PreparedCommand pc = new PreparedCommand(cmdId); <line12> pc.setMetaCommand(mc); <line13> pc.setBinary(cbr.getCmdPacket()); <line14> pc.setUsername(user.getName()); <line15> Set<String> userAssignedArgumentNames = <line16> argAssignmentList.stream().map(a -> a.getArgumentName()).collect(Collectors.toSet()); <line17> pc.setArgAssignment(cbr.getArgs(), userAssignedArgumentNames); <line18> return pc; <line19> } <line20> } <line21> 	"<line3>    log.debug(""Building command {} with arguments {}"", mc.getName(), argAssignmentList);"	task4	
"public class A { <line0> @Override <line1> public List<WeatherInfo> getWeatherInfo(double latitude, double longitude, String date) { <line2> City closestCity = getClosestCity(latitude, longitude); <line3> List<WeatherInfo> weather = <line4> JPAUtils.find( <line5> em, WeatherInfo.class, ""weather.byDateAndCity.between"", closestCity.geo_name, date); <line6> if (weather != null && weather.size() > 0) { <line7> addIcons(weather); <line8> return weather; <line9> } else { <line10> try { <line11> fetchWeatherInfo(latitude, longitude, closestCity.geo_name, date); <line12> } catch (Exception e) { <line13> } <line14> weather = <line15> JPAUtils.find( <line16> em, WeatherInfo.class, ""weather.byDateAndCity.between"", closestCity.geo_name, date); <line17> addIcons(weather); <line18> } <line19> return weather; <line20> } <line21> } <line22> "	"<line13>        logger.warn(""action=fetchWeather error date=""+ date+ "", lat=""+ latitude+ "", lon=""+ longitude+ "", city=""+ closestCity.geo_name);"	task4	
public class A { <line0> @Override <line1> protected void onEvent(org.apache.stratos.messaging.event.Event event) { <line2> AverageMemoryConsumptionEvent averageMemoryConsumptionEvent = <line3> (AverageMemoryConsumptionEvent) event; <line4> String clusterId = averageMemoryConsumptionEvent.getClusterId(); <line5> AutoscalerContext asCtx = AutoscalerContext.getInstance(); <line6> ClusterMonitor monitor; <line7> monitor = asCtx.getClusterMonitor(clusterId); <line8> if (null == monitor) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> return; <line12> } <line13> monitor.handleAverageMemoryConsumptionEvent(averageMemoryConsumptionEvent); <line14> } <line15> } <line16> 	"<line10>        log.debug(String.format(""A cluster monitor is not found in autoscaler context "" + ""[cluster] %s"",clusterId));"	task4	
"public class A { <line0> protected Response getPort(String nodeId, String portId) { <line1> Port port = topology.getPort(nodeId, portId); <line2> if (port == null) { <line3> return createErrorResponse(Response.NOT_FOUND, null, ""node_id not found""); <line4> } <line5> return new Response(Response.OK, port); <line6> } <line7> } <line8> "	"<line1>    log.debug("""");"	task4	
public class A { <line0> public static <T> String asId(String prefix, Class<T> clazz, String suffix) { <line1> String id; <line2> if (clazz == null) { <line3> id = DOM.createUniqueId(); <line4> return id; <line5> } else { <line6> id = clazz.getName(); <line7> int lastDot = id.lastIndexOf('.'); <line8> if (lastDot != -1 && lastDot != id.length() - 1) { <line9> id = id.substring(lastDot + 1); <line10> } <line11> id = id.replace('$', '_'); <line12> } <line13> id = prefix != null ? prefix + id : id; <line14> return suffix != null ? id + suffix : id; <line15> } <line16> } <line17> 	"<line4>      Log.error(""Cannot create stable ID: No class specified! Will return generated ID: "" + id);"	task4	
"public class A { <line0> private boolean isRequiredTimeZone(String actualTZ, String expextedTZ) { <line1> boolean res = actualTZ.equals(expextedTZ); <line2> if (!res) { <line3> String[] actTZ = actualTZ.split(""/""); <line4> String lastActTZ = actTZ[actTZ.length - 1]; <line5> String[] timeZoneTZ = expextedTZ.split(""/""); <line6> String lastTimeZoneTZ = timeZoneTZ[timeZoneTZ.length - 1]; <line7> res = lastActTZ.equals(lastTimeZoneTZ); <line8> } <line9> return res; <line10> } <line11> } <line12> "	"<line7>      LOGGER.debug(""Comparing '"" + lastActTZ + ""' with '"" + lastTimeZoneTZ + ""'."");"	task4	
public class A { <line0> @Override <line1> public boolean removeRepository(String repositoryID) <line2> throws RepositoryException, RepositoryConfigException { <line3> boolean existingRepo = hasRepositoryConfig(repositoryID); <line4> if (existingRepo) { <line5> try (RDF4JProtocolSession protocolSession = <line6> getSharedHttpClientSessionManager().createRDF4JProtocolSession(serverURL)) { <line7> protocolSession.setUsernameAndPassword(username, password); <line8> protocolSession.deleteRepository(repositoryID); <line9> } catch (IOException e) { <line10> throw new RepositoryConfigException(e); <line11> } <line12> } <line13> return existingRepo; <line14> } <line15> } <line16> 	"<line10>        logger.warn(""error while deleting remote repository"", e);"	task4	
"public class A { <line0> @Override <line1> public List<AssetEntry> getInfoList( <line2> InfoListProviderContext infoListProviderContext, Pagination pagination, Sort sort) { <line3> long assetEntryId = _getLayoutAssetEntryId(); <line4> if (assetEntryId == 0) { <line5> return Collections.emptyList(); <line6> } <line7> AssetEntryQuery assetEntryQuery = <line8> getAssetEntryQuery(infoListProviderContext, Field.MODIFIED_DATE, ""DESC"", pagination); <line9> assetEntryQuery.setLinkedAssetEntryId(assetEntryId); <line10> try { <line11> return _assetEntryService.getEntries(assetEntryQuery); <line12> } catch (Exception exception) { <line13> } <line14> return Collections.emptyList(); <line15> } <line16> } <line17> "	"<line13>      log.error(""Unable to get asset entries"", exception);"	task4	
"public class A { <line0> @Override <line1> public Optional<Page> getGroupPage(String groupId, String pageUrl) throws IOException { <line2> String encodedUrl = URLEncoder.encode(pageUrl, CanvasConstants.URLENCODING_TYPE); <line3> String url = <line4> buildCanvasUrl(""groups/"" + groupId + ""/pages/"" + encodedUrl, Collections.emptyMap()); <line5> Response response = canvasMessenger.getSingleResponseFromCanvas(oauthToken, url); <line6> return responseParser.parseToObject(Page.class, response); <line7> } <line8> } <line9> "	"<line2>    LOG.debug(""retrieving page "" + pageUrl + "" for group "" + groupId);"	task4	
public class A { <line0> private SendStatus sendMessage(DatagramPacket msg) <line1> throws IncompatibleConnectionException, GeneralSecurityException, IOException { <line2> if (getNumberOfQueuedMessages() > 0) { <line3> spoolMessage(msg); <line4> scheduleRetry(); <line5> } else { <line6> try { <line7> activeConnection().sendMessage(msg); <line8> lastSentTimeInMillis = System.currentTimeMillis(); <line9> return SendStatus.SENT; <line10> } catch (IOException e) { <line11> lastException = e; <line12> if (retryInterval > 0) { <line13> spoolMessage(msg); <line14> scheduleRetry(); <line15> } else { <line16> throw e; <line17> } <line18> } <line19> } <line20> return SendStatus.QUEUED; <line21> } <line22> } <line23> 	"<line13>          LOG.info(""Failed to send audit message:"", e);"	task4	
public class A { <line0> @Override <line1> public synchronized void init(HiveConf hiveConf) { <line2> ml = new LensMLImpl(hiveConf); <line3> ml.init(hiveConf); <line4> super.init(hiveConf); <line5> serviceProviderFactory = getServiceProviderFactory(hiveConf); <line6> } <line7> } <line8> 	"<line6>    log.info(""Inited ML service"");"	task4	
public class A { <line0> @Override <line1> public ClientCQ[] getCqs() { <line2> preOp(); <line3> ClientCQ[] cqs = null; <line4> try { <line5> ArrayList<InternalCqQuery> cqList = new ArrayList<InternalCqQuery>(); <line6> for (String name : this.cqNames) { <line7> cqList.add(((DefaultQueryService) realQueryService).getCqService().getCq(name)); <line8> } <line9> cqs = new ClientCQ[cqList.size()]; <line10> cqList.toArray(cqs); <line11> } catch (CqException cqe) { <line12> if (logger.isDebugEnabled()) { <line13> } <line14> } <line15> return cqs; <line16> } <line17> } <line18> 	"<line13>        logger.debug(""Unable to get Cqs. Error: {}"", cqe.getMessage(), cqe);"	task4	
"public class A { <line0> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line1> throws IOException, ServletException { <line2> HttpSession session = ((HttpServletRequest) request).getSession(true); <line3> if (session != null) { <line4> session.setAttribute(""user"", ""999998""); <line5> } else { <line6> } <line7> chain.doFilter(request, response); <line8> } <line9> } <line10> "	"<line6>      log.error(""session was null"");"	task4	
public class A { <line0> @Nonnull <line1> private List<StdArrangementMatchRule> deserializeRules( <line2> @Nonnull Element element, @Nullable final Set<StdArrangementRuleAliasToken> aliases) { <line3> if (aliases != null && myMixin instanceof MutableMixin) { <line4> ((MutableMixin) myMixin).setMyRuleAliases(aliases); <line5> } <line6> final List<StdArrangementMatchRule> rules = new ArrayList<StdArrangementMatchRule>(); <line7> for (Object o : element.getChildren(RULE_ELEMENT_NAME)) { <line8> Element ruleElement = (Element) o; <line9> Element matcherElement = ruleElement.getChild(MATCHER_ELEMENT_NAME); <line10> if (matcherElement == null) { <line11> continue; <line12> } <line13> StdArrangementEntryMatcher matcher = null; <line14> for (Object c : matcherElement.getChildren()) { <line15> matcher = myMatcherSerializer.deserialize((Element) c); <line16> if (matcher != null) { <line17> break; <line18> } <line19> } <line20> if (matcher == null) { <line21> return ContainerUtil.newSmartList(); <line22> } <line23> Element orderTypeElement = ruleElement.getChild(ORDER_TYPE_ELEMENT_NAME); <line24> ArrangementSettingsToken orderType = null; <line25> if (orderTypeElement != null) { <line26> String orderTypeId = orderTypeElement.getText(); <line27> orderType = StdArrangementTokens.byId(orderTypeId); <line28> if (orderType == null) { <line29> orderType = myMixin.deserializeToken(orderTypeId); <line30> } <line31> if (orderType == null) { <line32> } <line33> } <line34> if (orderType == null) { <line35> orderType = ArrangementMatchRule.DEFAULT_ORDER_TYPE; <line36> } <line37> rules.add(new StdArrangementMatchRule(matcher, orderType)); <line38> } <line39> return rules; <line40> } <line41> } <line42> 	"<line32>          LOG.warn(String.format(""Can't deserialize matching rule order type for id '%s'. Falling back to default""+ "" (%s)"",orderTypeId, ArrangementMatchRule.DEFAULT_ORDER_TYPE.getId()));"	task4	
public class A { <line0> public void requestHostsUpdate() { <line1> try { <line2> spawnMQ.sendControlMessage(new HostState(HostMessage.ALL_HOSTS)); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.warn(""unable to request host state update: "", e);"	task4	
"public class A { <line0> private void initiateLocalAbortForTest(final DistributionManager dm) { <line1> if (!dm.getSystem().isDisconnecting()) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> Thread disconnectThread = <line5> new LoggingThread( <line6> ""InitialImageOperation abortTest Thread"", () -> dm.getSystem().disconnect()); <line7> disconnectThread.start(); <line8> } <line9> } <line10> } <line11> "	"<line3>        logger.debug(""abortTest: Disconnecting from distributed system and sending null chunk to abort"");"	task4	
public class A { <line0> private void complete( <line1> TableName tableName, LocateRequest req, RegionLocations locs, Throwable error) { <line2> if (error != null) { <line3> } <line4> Optional<LocateRequest> toSend = Optional.empty(); <line5> TableCache tableCache = getTableCache(tableName); <line6> if (locs != null) { <line7> RegionLocations addedLocs = addToCache(tableCache, locs); <line8> synchronized (tableCache) { <line9> tableCache.pendingRequests.remove(req); <line10> tableCache.clearCompletedRequests(addedLocs); <line11> toSend = tableCache.getCandidate(); <line12> toSend.ifPresent(r -> tableCache.send(r)); <line13> } <line14> toSend.ifPresent(r -> locateInMeta(tableName, r)); <line15> } else { <line16> assert error != null; <line17> synchronized (tableCache) { <line18> tableCache.pendingRequests.remove(req); <line19> CompletableFuture<?> future = tableCache.allRequests.remove(req); <line20> if (future != null) { <line21> future.completeExceptionally(error); <line22> } <line23> tableCache.clearCompletedRequests(null); <line24> toSend = tableCache.getCandidate(); <line25> toSend.ifPresent(r -> tableCache.send(r)); <line26> } <line27> toSend.ifPresent(r -> locateInMeta(tableName, r)); <line28> } <line29> } <line30> } <line31> 	"<line3>      LOG.warn(""Failed to locate region in '""+ tableName+ ""', row='""+ Bytes.toStringBinary(req.row)+ ""', locateType=""+ req.locateType,error);"	task4	
public class A { <line0> public static int getCommerceNotificationQueueEntriesCount(long groupId) throws RemoteException { <line1> try { <line2> int returnValue = <line3> CommerceNotificationQueueEntryServiceUtil.getCommerceNotificationQueueEntriesCount( <line4> groupId); <line5> return returnValue; <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
"public class A { <line0> public String search() { <line1> if (this.oldSearchPattern != null <line2> && StringUtils.equals(this.searchPattern, this.oldSearchPattern)) <line3> return OxTrustConstants.RESULT_SUCCESS; <line4> try { <line5> List<RadiusClient> radiusclients = null; <line6> if (searchPattern == null || searchPattern.isEmpty()) { <line7> radiusclients = gluuRadiusClientService.getAllClients(100); <line8> } else { <line9> radiusclients = gluuRadiusClientService.searchClients(searchPattern, 100); <line10> } <line11> radiusclients.sort(Comparator.comparing(RadiusClient::getName)); <line12> this.results.clear(); <line13> for (RadiusClient radiusclient : radiusclients) { <line14> this.results.add(new SelectableEntity<RadiusClient>(radiusclient)); <line15> } <line16> this.oldSearchPattern = this.searchPattern; <line17> this.searchPattern = """"; <line18> } catch (Exception e) { <line19> facesMessages.add(FacesMessage.SEVERITY_ERROR, ""#{msgs['radius.clients.search.error']}""); <line20> conversationService.endConversation(); <line21> return OxTrustConstants.RESULT_FAILURE; <line22> } <line23> return OxTrustConstants.RESULT_SUCCESS; <line24> } <line25> } <line26> "	"<line19>      log.debug(""Failed to find radius clients"", e);"	task4	
public class A { <line0> @Override <line1> public void getOAuthAccessTokenAsync(final String screenName, final String password) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(OAUTH_ACCESS_TOKEN, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> AccessToken token = twitter.getOAuthAccessToken(screenName, password); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotOAuthAccessToken(token); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at getOAuthAccessTokenAsync"", e);"	task4	
public class A { <line0> @Override <line1> public boolean isSupportedMethod(IMethodContext dataObject) { <line2> IModel<?> model = dataObject.getDisplayObjectModel(); <line3> try { <line4> if (model != null && model.getObject() != null && model.getObject() instanceof ODocument) { <line5> OClass schemaClass = ((ODocument) (model.getObject())).getSchemaClass(); <line6> return schemaClass != null ? schemaClass.isSubClassOf(this.filterData) : false; <line7> } <line8> } catch (Exception e) { <line9> } <line10> return false; <line11> } <line12> } <line13> 	"<line9>      LOG.error(""Error for model: {} and context: {}"", model, dataObject, e);"	task4	
public class A { <line0> private WifiMode getWifiInterfaceMode(WifiInterfaceConfigImpl wifiInterfaceConfig) { <line1> WifiMode wifiMode = WifiMode.UNKNOWN; <line2> WifiInterfaceAddressConfig wifiInterfaceAddressConfig; <line3> try { <line4> wifiInterfaceAddressConfig = <line5> (WifiInterfaceAddressConfig) <line6> ((AbstractNetInterface<?>) wifiInterfaceConfig).getNetInterfaceAddressConfig(); <line7> wifiMode = wifiInterfaceAddressConfig.getMode(); <line8> } catch (KuraException e) { <line9> } <line10> return wifiMode; <line11> } <line12> } <line13> 	"<line9>      logger.error(""Failed to obtain WifiInterfaceMode"", e);"	task4	
"public class A { <line0> public static EDLController createEDLController( <line1> EDocLiteAssociation edlAssociation, EDLGlobalConfig edlGlobalConfig) { <line2> EDLController edlController = new EDLController(); <line3> edlController.setEdocLiteAssociation(edlAssociation); <line4> edlController.setEdlContext(getPreEDLContext(edlController)); <line5> try { <line6> edlController.setEdlGlobalConfig(edlGlobalConfig); <line7> edlController.setDefaultDOM(getDefaultDOM(edlAssociation)); <line8> loadConfigProcessors(edlController, edlGlobalConfig); <line9> loadPreProcessors(edlController, edlGlobalConfig); <line10> loadPostProcessor(edlController, edlGlobalConfig); <line11> loadStateComponents(edlController, edlGlobalConfig); <line12> loadStyle(edlController); <line13> } catch (Exception e) { <line14> String edl = null; <line15> if (edlAssociation != null) { <line16> edl = edlAssociation.getEdlName(); <line17> } <line18> String message = ""Error creating controller for EDL"" + (edl == null ? """" : "": "" + edl); <line19> throw new WorkflowRuntimeException(""Problems creating controller for EDL: "" + edl, e); <line20> } <line21> return edlController; <line22> } <line23> } <line24> "	<line19>      LOG.error(message, e);	task4	
public class A { <line0> public void setPassivator(final ConnectionPassivator p) { <line1> passivator = p; <line2> } <line3> } <line4> 	"<line1>    logger.trace(""setting passivator: {}"", p);"	task4	
public class A { <line0> public static void writePrimitiveBoolean(boolean value, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> out.writeBoolean(value); <line5> } <line6> } <line7> 	"<line3>      logger.trace(LogMarker.SERIALIZER_VERBOSE, ""Writing Boolean {}"", value);"	task4	
public class A { <line0> @Override <line1> public List<TrustBundle> getTrustBundles(boolean fetchAnchors) { <line2> List<TrustBundle> listTB = null; <line3> try { <line4> listTB = getDirectConfigProxy().getTrustBundles(fetchAnchors); <line5> } catch (Exception ex) { <line6> } <line7> return listTB; <line8> } <line9> } <line10> 	"<line6>      LOG.error(""Unable to get List of Trust Bundles: "", ex);"	task4	
public class A { <line0> public static String decryptCloudConfigPassword(String message) { <line1> try { <line2> return CryptoUtils.decrypt(message, CLOUD_KEY); <line3> } catch (GeneralSecurityException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	"<line4>      logger.error(LoggingAnchor.THREE,MessageEnum.RA_GENERAL_EXCEPTION.toString(),ErrorCode.BusinessProcessError.getValue(),""Exception in encryptPassword "",e);"	task4	
"public class A { <line0> @NamespacePermission( <line1> fields = ""#emrClusterDefinitionKey?.namespace"", <line2> permissions = NamespacePermissionEnum.WRITE) <line3> @Override <line4> public EmrClusterDefinitionInformation deleteEmrClusterDefinition( <line5> EmrClusterDefinitionKey emrClusterDefinitionKey) throws Exception { <line6> emrClusterDefinitionHelper.validateEmrClusterDefinitionKey(emrClusterDefinitionKey); <line7> EmrClusterDefinitionEntity emrClusterDefinitionEntity = <line8> emrClusterDefinitionDaoHelper.getEmrClusterDefinitionEntity(emrClusterDefinitionKey); <line9> emrClusterDefinitionDao.delete(emrClusterDefinitionEntity); <line10> return createEmrClusterDefinitionFromEntity(emrClusterDefinitionEntity); <line11> } <line12> } <line13> "	"<line9>    LOGGER.info(""Logging EMR cluster definition being deleted. emrClusterDefinition={}"",xmlHelper.objectToXml(createEmrClusterDefinitionFromEntity(emrClusterDefinitionEntity), true));"	task4	
public class A { <line0> @After <line1> public void tearDown() throws Exception { <line2> try { <line3> wireGraphService.delete(); <line4> } catch (KuraException e) { <line5> throw e; <line6> } <line7> } <line8> } <line9> 	"<line5>      logger.error(""Test error"", e);"	task4	
"public class A { <line0> public static com.liferay.layout.page.template.model.LayoutPageTemplateEntry <line1> addLayoutPageTemplateEntry( <line2> HttpPrincipal httpPrincipal, <line3> long groupId, <line4> long layoutPageTemplateCollectionId, <line5> long classNameId, <line6> long classTypeId, <line7> String name, <line8> int status, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> LayoutPageTemplateEntryServiceUtil.class, <line15> ""addLayoutPageTemplateEntry"", <line16> _addLayoutPageTemplateEntryParameterTypes0); <line17> MethodHandler methodHandler = <line18> new MethodHandler( <line19> methodKey, <line20> groupId, <line21> layoutPageTemplateCollectionId, <line22> classNameId, <line23> classTypeId, <line24> name, <line25> status, <line26> serviceContext); <line27> Object returnObj = null; <line28> try { <line29> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line30> } catch (Exception exception) { <line31> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line32> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line33> } <line34> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line35> } <line36> return (com.liferay.layout.page.template.model.LayoutPageTemplateEntry) returnObj; <line37> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line38> throw systemException; <line39> } <line40> } <line41> } <line42> "	<line38>      log.error(systemException, systemException);	task4	
public class A { <line0> protected void deactivate(ComponentContext componentContext) { <line1> if (this.conn != null) { <line2> try { <line3> this.conn.close(); <line4> } catch (IOException e) { <line5> e.printStackTrace(); <line6> } <line7> this.conn = null; <line8> } <line9> } <line10> } <line11> 	"<line1>    logger.debug(""Deactivating ExampleComponent"");"	task4	
public class A { <line0> public static void invokeInFxThreadAndWait(final Runnable run) { <line1> if (Platform.isFxApplicationThread()) { <line2> run.run(); <line3> return; <line4> } <line5> try { <line6> FutureTask<Void> future = new FutureTask<>(run, null); <line7> Platform.runLater(future); <line8> future.get(); <line9> } catch (ExecutionException | InterruptedException e) { <line10> } <line11> } <line12> } <line13> 	"<line10>      logger.error(""invokeInFxThreadAndWait() failed"", e);"	task4	
"public class A { <line0> @WithMockUser(username = USERNAME) <line1> @SuppressWarnings({""OptionalGetWithoutIsPresent""}) <line2> @Test <line3> void testCopyPackage() { <line4> String targetPackageId = ""target1""; <line5> addTargetPackage(targetPackageId); <line6> ResourceIdentifier id = ResourceIdentifier.create(ResourceType.PACKAGE, PACKAGE_A); <line7> TestProgress progress = new TestProgress(); <line8> copyService.copy(singletonList(id), targetPackageId, progress); <line9> await().atMost(5, TimeUnit.SECONDS).until(copyJobFinished(progress)); <line10> waitForWorkToBeFinished(indexService, LOG); <line11> Package targetPackage = metadataService.getPackage(targetPackageId).get(); <line12> List<Package> packages = newArrayList(targetPackage.getChildren()); <line13> assertEquals(1, packages.size()); <line14> Package packageACopy = packages.get(0); <line15> assertEquals(""Package A"", packageACopy.getLabel()); <line16> List<EntityType> entityTypesInACopy = newArrayList(packageACopy.getEntityTypes()); <line17> List<Package> packagesInACopy = newArrayList(packageACopy.getChildren()); <line18> assertEquals(1, entityTypesInACopy.size()); <line19> assertEquals(1, packagesInACopy.size()); <line20> Package packageBCopy = packagesInACopy.get(0); <line21> assertEquals(""Package B (child of A)"", packageBCopy.getLabel()); <line22> List<EntityType> entityTypesInBCopy = newArrayList(packageBCopy.getEntityTypes()); <line23> List<Package> packagesInBCopy = newArrayList(packageBCopy.getChildren()); <line24> assertEquals(1, entityTypesInBCopy.size()); <line25> assertEquals(0, packagesInBCopy.size()); <line26> EntityType entityTypeACopy = entityTypesInACopy.get(0); <line27> EntityType entityTypeBCopy = entityTypesInBCopy.get(0); <line28> assertEquals(""EntityType A"", entityTypeACopy.getLabel()); <line29> assertEquals(""EntityType B (referenced by A)"", entityTypeBCopy.getLabel()); <line30> assertEquals(ENTITY_TYPE_B, entityTypeA.getAttribute(""xref_attr"").getRefEntity().getId()); <line31> assertEquals( <line32> entityTypeBCopy.getId(), entityTypeACopy.getAttribute(""xref_attr"").getRefEntity().getId()); <line33> assertEquals(4, progress.getProgress()); <line34> List<Object> entitiesOfA = <line35> dataService.findAll(entityTypeACopy.getId()).map(Entity::getIdValue).collect(toList()); <line36> assertEquals(asList(""0"", ""1"", ""2""), entitiesOfA); <line37> List<Object> entitiesOfB = <line38> dataService.findAll(entityTypeBCopy.getId()).map(Entity::getIdValue).collect(toList()); <line39> assertEquals(asList(""0"", ""1"", ""2""), entitiesOfB); <line40> cleanupTargetPackage(targetPackageId); <line41> } <line42> } <line43> "	"<line10>    LOG.info(""Copy job progress: {}/{}"", progress.getProgress(), progress.getProgressMax());"	task4	
"public class A { <line0> public static Specifier getSpecifier(String identifier, String method, String op) <line1> throws CSWebApplicationException { <line2> Specifier result = null; <line3> if (identifier != null) { <line4> if (!identifier.startsWith(URN_PREFIX)) { <line5> result = new Specifier(SpecifierForm.CSID, identifier); <line6> } else { <line7> if (identifier.startsWith(URN_PREFIX_NAME, URN_PREFIX_LEN)) { <line8> int closeParen = identifier.indexOf(')', URN_NAME_PREFIX_LEN); <line9> if (closeParen >= 0) { <line10> result = <line11> new Specifier( <line12> SpecifierForm.URN_NAME, identifier.substring(URN_NAME_PREFIX_LEN, closeParen)); <line13> } <line14> } else if (identifier.startsWith(URN_PREFIX_ID, URN_PREFIX_LEN)) { <line15> int closeParen = identifier.indexOf(')', URN_ID_PREFIX_LEN); <line16> if (closeParen >= 0) { <line17> result = <line18> new Specifier( <line19> SpecifierForm.CSID, identifier.substring(URN_ID_PREFIX_LEN, closeParen)); <line20> } <line21> } else { <line22> Response response = <line23> Response.status(Response.Status.BAD_REQUEST) <line24> .entity(op + "" failed on bad or missing Authority specifier"") <line25> .type(""text/plain"") <line26> .build(); <line27> throw new CSWebApplicationException(response); <line28> } <line29> } <line30> } <line31> return result; <line32> } <line33> } <line34> "	"<line22>          logger.error(method + "": bad or missing specifier!"");"	task4	
public class A { <line0> public void loadHetuMetastore(FileSystemClientManager fileSystemClientManager) <line1> throws IOException { <line2> if (HETUMETASTORE_CONFIG_FILE.exists()) { <line3> Map<String, String> config = <line4> new HashMap<>(loadPropertiesFrom(HETUMETASTORE_CONFIG_FILE.getPath())); <line5> loadHetuMetastore(fileSystemClientManager, config); <line6> } <line7> } <line8> } <line9> 	"<line2>    LOG.info(""-- Loading Hetu Metastore --"");"	task4	
public class A { <line0> @Override <line1> public void info(String string, Object o) { <line2> } <line3> } <line4> 	<line2>    logger.info(string, o);	task4	
"public class A { <line0> @AllowConcurrentEvents <line1> @Subscribe <line2> public void handleKillbillEvent(final ExtBusEvent event) throws IOException, BundleException { <line3> if (event.getEventType() != ExtBusEventType.BROADCAST_SERVICE) { <line4> return; <line5> } <line6> final BroadcastMetadata metadata = <line7> objectMapper.readValue(event.getMetaData(), BroadcastMetadata.class); <line8> final SystemNodeCommandType commandType = <line9> getSystemNodeCommandTypeOrNull(metadata.getCommandType()); <line10> if (commandType == null <line11> || (commandType != SystemNodeCommandType.START_PLUGIN <line12> && commandType != SystemNodeCommandType.STOP_PLUGIN <line13> && commandType != SystemNodeCommandType.RESTART_PLUGIN)) { <line14> return; <line15> } <line16> final PluginNodeCommandMetadata nodeCommandMetadata = <line17> (PluginNodeCommandMetadata) <line18> deserializeNodeCommand(metadata.getEventJson(), metadata.getCommandType()); <line19> final String pluginName = <line20> nodeCommandMetadata.getPluginName() != null <line21> ? nodeCommandMetadata.getPluginName() <line22> : (pluginFinder.resolvePluginKey(nodeCommandMetadata.getPluginKey()) != null <line23> ? pluginFinder.resolvePluginKey(nodeCommandMetadata.getPluginKey()).getPluginName() <line24> : null); <line25> if (pluginName == null) { <line26> return; <line27> } <line28> BundleWithMetadata bundleWithMetadata = null; <line29> switch (commandType) { <line30> case STOP_PLUGIN: <line31> bundleRegistry.stopAndUninstallNewBundle( <line32> pluginName, nodeCommandMetadata.getPluginVersion()); <line33> break; <line34> case START_PLUGIN: <line35> bundleWithMetadata = <line36> bundleRegistry.installAndStartNewBundle( <line37> pluginName, nodeCommandMetadata.getPluginVersion()); <line38> break; <line39> case RESTART_PLUGIN: <line40> bundleRegistry.stopAndUninstallNewBundle( <line41> pluginName, nodeCommandMetadata.getPluginVersion()); <line42> bundleWithMetadata = <line43> bundleRegistry.installAndStartNewBundle( <line44> pluginName, nodeCommandMetadata.getPluginVersion()); <line45> break; <line46> default: <line47> throw new IllegalStateException(""Unexpected type "" + commandType); <line48> } <line49> final String defaultPluginVersion = <line50> pluginFinder.getPluginVersionSelectedForStart(nodeCommandMetadata.getPluginName()); <line51> final boolean isSelectedForStart = <line52> defaultPluginVersion != null && nodeCommandMetadata.getPluginVersion() != null <line53> ? defaultPluginVersion.equals(nodeCommandMetadata.getPluginVersion()) <line54> : true; <line55> final String symbolicName = <line56> (bundleWithMetadata != null && bundleWithMetadata.getBundle() != null) <line57> ? bundleWithMetadata.getBundle().getSymbolicName() <line58> : null; <line59> final HashMap<String, String> eventProperties = new HashMap<String, String>(); <line60> eventProperties.put(""pluginName"", pluginName); <line61> eventProperties.put(""pluginKey"", nodeCommandMetadata.getPluginKey()); <line62> eventProperties.put(""symbolicName"", symbolicName); <line63> killbillActivator.sendEvent(""org/killbill/billing/osgi/plugin/"" + commandType, eventProperties); <line64> final PluginInfo pluginInfo = <line65> new DefaultPluginInfo( <line66> nodeCommandMetadata.getPluginKey(), <line67> symbolicName, <line68> nodeCommandMetadata.getPluginName(), <line69> nodeCommandMetadata.getPluginVersion(), <line70> DefaultPluginsInfoApi.toPluginState(bundleWithMetadata), <line71> isSelectedForStart, <line72> ImmutableSet.<PluginServiceInfo>of()); <line73> nodesApi.notifyPluginChanged(pluginInfo, pluginsInfoApi.getPluginsInfo()); <line74> } <line75> } <line76> "	"<line26>      logger.warn(String.format(""Failed to dispatch event %s : Input must have a pluginName or a valid pluginKey""+ "" specified json=%s"",commandType, metadata.getEventJson()));"	task4	
public class A { <line0> @Test <line1> public void testDispatchingJobsHigherMaxLoad() throws Exception { <line2> Job testJob = <line3> serviceRegistryJpaImpl.createJob( <line4> TEST_HOST, TEST_SERVICE_FAIRNESS, TEST_OPERATION, null, null, true, null, 10.0f); <line5> JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob); <line6> launchDispatcherOnce(false); <line7> assertThrows(IllegalStateException.class, () -> barrier.waitForJobs(JOB_BARRIER_TIMEOUT)); <line8> } <line9> } <line10> 	"<line2>    logger.debug(""KHD start of testDispatchingJobsHigherMaxLoad"");"	task4	
public class A { <line0> @Override <line1> public void cancel(final BackgroundAction action) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	"<line3>      log.debug(String.format(""Cancel action %s"", action));"	task4	
public class A { <line0> private static void attachShutdownHook() { <line1> Runtime.getRuntime() <line2> .addShutdownHook( <line3> new Thread() { <line4> @Override <line5> public void run() { <line6> LogManager.shutdown(); <line7> } <line8> }); <line9> } <line10> } <line11> 	"<line6>                log.info(""JMXFetch is closing"");"	task4	
"public class A { <line0> @Override <line1> public List<? extends Command> getDisposeCommands(Context context, boolean withDao) { <line2> InitialContext initialContext = (InitialContext) context.get(INITIAL_CONTEXT); <line3> List<Command> commands = new ArrayList<>(); <line4> try { <line5> commands.add(CommandFactory.create(initialContext, GtfsDisposeImportCommand.class.getName())); <line6> } catch (Exception e) { <line7> throw new RuntimeException(""unable to call factories""); <line8> } <line9> return commands; <line10> } <line11> } <line12> "	<line7>      log.error(e, e);	task4	
"public class A { <line0> protected String createWorkDirectory(String location) { <line1> if (location == null) { <line2> location = "".""; <line3> } <line4> File f = new File(location); <line5> f.mkdirs(); <line6> return location; <line7> } <line8> } <line9> "	"<line4>    log.info(""creating work directory {}"", location);"	task4	
"public class A { <line0> @ApiOperation( <line1> httpMethod = ""POST"", <line2> value = ""API to update roles details"", <line3> response = Response.class, <line4> consumes = MediaType.APPLICATION_JSON_VALUE) <line5> @RequestMapping( <line6> path = ""/update"", <line7> method = RequestMethod.POST, <line8> consumes = MediaType.APPLICATION_JSON_VALUE) <line9> public ResponseEntity<Object> updateUserRole( <line10> @AuthenticationPrincipal Principal user, <line11> @ApiParam(value = ""provide valid role details"", required = true) @RequestBody(required = true) <line12> UpdateRoleDetailsRequest roleDetailsRequest) { <line13> try { <line14> return ResponseUtils.buildSucessResponse( <line15> userRolesService.updateUserRole(roleDetailsRequest, user.getName())); <line16> } catch (Exception exception) { <line17> return ResponseUtils.buildFailureResponse( <line18> new Exception(UNEXPECTED_ERROR_OCCURRED), exception.getMessage()); <line19> } <line20> } <line21> } <line22> "	<line17>      log.error(UNEXPECTED_ERROR_OCCURRED, exception);	task4	
"public class A { <line0> @Override <line1> public String copyToAnotherMeta(KylinConfig srcConfig, KylinConfig dstConfig) throws IOException { <line2> if (baseDir.contains(""resources/SegmentDict"")) { <line3> return baseDir; <line4> } <line5> checkArgument( <line6> baseDir.startsWith(srcConfig.getHdfsWorkingDirectory()), <line7> ""Please check why current directory {} doesn't belong to source working directory {}"", <line8> baseDir, <line9> srcConfig.getHdfsWorkingDirectory()); <line10> final String dstBaseDir = <line11> baseDir.replaceFirst( <line12> srcConfig.getHdfsWorkingDirectory(), dstConfig.getHdfsWorkingDirectory()); <line13> Long[] versions = listAllVersions(); <line14> if (versions.length == 0) { <line15> return dstBaseDir; <line16> } <line17> Path srcVersionDir = getVersionDir(versions[versions.length - 1]); <line18> Path dstVersionDir = <line19> new Path( <line20> srcVersionDir <line21> .toString() <line22> .replaceFirst( <line23> srcConfig.getHdfsWorkingDirectory(), dstConfig.getHdfsWorkingDirectory())); <line24> FileSystem dstFS = dstVersionDir.getFileSystem(conf); <line25> if (dstFS.exists(dstVersionDir)) { <line26> dstFS.delete(dstVersionDir, true); <line27> } <line28> FileUtil.copy(fileSystem, srcVersionDir, dstFS, dstVersionDir, false, true, conf); <line29> return dstBaseDir; <line30> } <line31> } <line32> "	"<line3>      logger.info(""SegmentAppendTrieDict needn't to copy"");"	task4	
public class A { <line0> @Override <line1> protected void loadInternals(final File nodeInternDir, final ExecutionMonitor exec) <line2> throws CanceledExecutionException { <line3> try { <line4> final File dataDir = new File(nodeInternDir, CFG_DATA_DIR_NAME); <line5> loadPieInternals(dataDir, exec); <line6> } catch (final CanceledExecutionException e) { <line7> throw e; <line8> } catch (final Exception e) { <line9> } <line10> } <line11> } <line12> 	"<line9>      LOGGER.debug(""Error while loading internals: "" + e.getMessage());"	task4	
public class A { <line0> private void purgeNodes() throws IOException, JSONException { <line1> while (nodesToPurge.peek() != null) { <line2> Long nodeId = nodesToPurge.poll(); <line3> if (nodeId != null) { <line4> this.infoSrv.deleteByNodeId(nodeId); <line5> } <line6> checkShutdown(); <line7> } <line8> } <line9> } <line10> 	"<line5>        LOGGER.info(""PURGE ACTION - Purged nodeId {}"", nodeId);"	task4	
"public class A { <line0> private List<DownloadFile> downloadEnsemblData(Path geneFolder) <line1> throws IOException, InterruptedException { <line2> List<String> downloadedUrls = new ArrayList<>(4); <line3> List<DownloadFile> downloadFiles = new ArrayList<>(); <line4> String ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease; <line5> if (!configuration.getSpecies().getVertebrates().contains(speciesConfiguration)) { <line6> ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease + ""/"" + getPhylo(speciesConfiguration); <line7> } <line8> String ensemblCollection = """"; <line9> if (configuration.getSpecies().getBacteria().contains(speciesConfiguration)) { <line10> ensemblCollection = speciesConfiguration.getAssemblies().get(0).getEnsemblCollection() + ""/""; <line11> } <line12> String version = ensemblRelease.split(""-"")[1]; <line13> String url = <line14> ensemblHost + ""/gtf/"" + ensemblCollection + speciesShortName + ""/*"" + version + "".gtf.gz""; <line15> String fileName = geneFolder.resolve(speciesShortName + "".gtf.gz"").toString(); <line16> downloadFiles.add(downloadFile(url, fileName)); <line17> downloadedUrls.add(url); <line18> url = ensemblHost + ""/fasta/"" + ensemblCollection + speciesShortName + ""/pep/*.pep.all.fa.gz""; <line19> fileName = geneFolder.resolve(speciesShortName + "".pep.all.fa.gz"").toString(); <line20> downloadFiles.add(downloadFile(url, fileName)); <line21> downloadedUrls.add(url); <line22> url = ensemblHost + ""/fasta/"" + ensemblCollection + speciesShortName + ""/cdna/*.cdna.all.fa.gz""; <line23> fileName = geneFolder.resolve(speciesShortName + "".cdna.all.fa.gz"").toString(); <line24> downloadFiles.add(downloadFile(url, fileName)); <line25> downloadedUrls.add(url); <line26> saveVersionData( <line27> EtlCommons.GENE_DATA, <line28> ENSEMBL_NAME, <line29> ensemblVersion, <line30> getTimeStamp(), <line31> downloadedUrls, <line32> geneFolder.resolve(""ensemblCoreVersion.json"")); <line33> return downloadFiles; <line34> } <line35> } <line36> "	"<line2>    logger.info(""Downloading gene Ensembl data (gtf, pep, cdna, motifs) ..."");"	task4	
public class A { <line0> public org.talend.mdm.webservice.WSTransformerPK putTransformer( <line1> org.talend.mdm.webservice.WSPutTransformer arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSTransformerPK _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	"<line2>    LOG.info(""Executing operation putTransformer"");"	task4	
"public class A { <line0> @Override <line1> public void close() { <line2> if (!state.equals(ReaderWriterState.OPEN)) { <line3> return; <line4> } <line5> iterator = null; <line6> try { <line7> incoming.close(); <line8> } catch (IOException e) { <line9> throw new DatasetIOException(""Unable to close reader path:"" + path, e); <line10> } <line11> state = ReaderWriterState.CLOSED; <line12> } <line13> } <line14> "	"<line5>    LOG.debug(""Closing reader on path:{}"", path);"	task4	
"public class A { <line0> @Override <line1> public void postAnalyze( <line2> HiveSemanticAnalyzerHookContext context, List<Task<? extends Serializable>> rootTasks) <line3> throws SemanticException { <line4> HiveOperation stmtOperation = getCurrentHiveStmtOp(); <line5> HiveAuthzPrivileges stmtAuthObject; <line6> stmtAuthObject = HiveAuthzPrivilegesMap.getHiveAuthzPrivileges(stmtOperation); <line7> Subject subject = getCurrentSubject(context); <line8> Set<String> subjectGroups = hiveAuthzBinding.getGroups(subject); <line9> for (Task<? extends Serializable> task : rootTasks) { <line10> if (task instanceof SentryGrantRevokeTask) { <line11> SentryGrantRevokeTask sentryTask = (SentryGrantRevokeTask) task; <line12> sentryTask.setHiveAuthzBinding(hiveAuthzBinding); <line13> sentryTask.setAuthzConf(authzConf); <line14> sentryTask.setSubject(subject); <line15> sentryTask.setSubjectGroups(subjectGroups); <line16> sentryTask.setIpAddress(context.getIpAddress()); <line17> sentryTask.setOperation(stmtOperation); <line18> } <line19> } <line20> try { <line21> if (stmtAuthObject == null) { <line22> return; <line23> } <line24> for (int i = 0; i < rootTasks.size(); i++) { <line25> Task<? extends Serializable> task = rootTasks.get(i); <line26> if (task instanceof DDLTask) { <line27> SentryFilterDDLTask filterTask = <line28> new SentryFilterDDLTask(hiveAuthzBinding, subject, stmtOperation); <line29> filterTask.setWork((DDLWork) task.getWork()); <line30> rootTasks.set(i, filterTask); <line31> } <line32> } <line33> authorizeWithHiveBindings(context, stmtAuthObject, stmtOperation); <line34> } catch (AuthorizationException e) { <line35> executeOnFailureHooks(context, stmtOperation, e); <line36> StringBuilder permsBuilder = new StringBuilder(); <line37> for (String perm : hiveAuthzBinding.getLastQueryPrivilegeErrors()) { <line38> permsBuilder.append(perm); <line39> permsBuilder.append("";""); <line40> } <line41> String permsRequired = permsBuilder.toString(); <line42> SessionState.get().getConf().set(HiveAuthzConf.HIVE_SENTRY_AUTH_ERRORS, permsRequired); <line43> String msgForLog = <line44> HiveAuthzConf.HIVE_SENTRY_PRIVILEGE_ERROR_MESSAGE <line45> + ""\n Required privileges for this query: "" <line46> + permsRequired; <line47> String msgForConsole = <line48> HiveAuthzConf.HIVE_SENTRY_PRIVILEGE_ERROR_MESSAGE <line49> + ""\n "" <line50> + e.getMessage() <line51> + ""\n The required privileges: "" <line52> + permsRequired; <line53> throw new SemanticException(msgForConsole, e); <line54> } finally { <line55> hiveAuthzBinding.close(); <line56> } <line57> if (""true"" <line58> .equalsIgnoreCase(context.getConf().get(HiveAuthzConf.HIVE_SENTRY_MOCK_COMPILATION))) { <line59> throw new SemanticException( <line60> HiveAuthzConf.HIVE_SENTRY_MOCK_ERROR <line61> + "" Mock query compilation aborted. Set "" <line62> + HiveAuthzConf.HIVE_SENTRY_MOCK_COMPILATION <line63> + "" to 'false' for normal query processing""); <line64> } <line65> } <line66> } <line67> "	<line53>      LOG.info(msgForLog);	task4	
"public class A { <line0> public static Thread addShutdownHook(final Runnable task) { <line1> Thread t = <line2> new Thread(""shutdownHookThread"") { <line3> public void run() { <line4> try { <line5> task.run(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> }; <line10> Runtime.getRuntime().addShutdownHook(t); <line11> return t; <line12> } <line13> } <line14> "	"<line7>              log.error(""Failed to execute shutdownhook"", e);"	task4	
public class A { <line0> @Override <line1> public void connect() { <line2> RPCHook rpcHook = null; <line3> if (null != accessKey <line4> && accessKey.length() > 0 <line5> && null != secretKey <line6> && secretKey.length() > 0) { <line7> SessionCredentials sessionCredentials = new SessionCredentials(); <line8> sessionCredentials.setAccessKey(accessKey); <line9> sessionCredentials.setSecretKey(secretKey); <line10> rpcHook = new AclClientRPCHook(sessionCredentials); <line11> } <line12> rocketMQConsumer = <line13> new DefaultMQPushConsumer( <line14> groupName, <line15> rpcHook, <line16> new AllocateMessageQueueAveragely(), <line17> enableMessageTrace, <line18> customizedTraceTopic); <line19> rocketMQConsumer.setVipChannelEnabled(false); <line20> if (CLOUD_ACCESS_CHANNEL.equals(this.accessChannel)) { <line21> rocketMQConsumer.setAccessChannel(AccessChannel.CLOUD); <line22> } <line23> if (!StringUtils.isEmpty(this.namespace)) { <line24> rocketMQConsumer.setNamespace(this.namespace); <line25> } <line26> if (!StringUtils.isBlank(nameServer)) { <line27> rocketMQConsumer.setNamesrvAddr(nameServer); <line28> } <line29> if (batchSize != -1) { <line30> rocketMQConsumer.setConsumeMessageBatchMaxSize(batchSize); <line31> } <line32> try { <line33> if (rocketMQConsumer == null) { <line34> this.connect(); <line35> } <line36> rocketMQConsumer.subscribe(this.topic, this.filter); <line37> rocketMQConsumer.registerMessageListener( <line38> (MessageListenerOrderly) <line39> (messageExts, context) -> { <line40> context.setAutoCommit(true); <line41> boolean isSuccess = process(messageExts); <line42> if (isSuccess) { <line43> return ConsumeOrderlyStatus.SUCCESS; <line44> } else { <line45> return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; <line46> } <line47> }); <line48> rocketMQConsumer.start(); <line49> } catch (MQClientException ex) { <line50> } <line51> } <line52> } <line53> 	"<line50>      logger.error(""Start RocketMQ consumer error"", ex);"	task4	
"public class A { <line0> @ApiOperation(value = ""Get access contract by ID"") <line1> @GetMapping(path = RestApi.PATH_REFERENTIAL_ID) <line2> public AccessContractDto getById(final @PathVariable(""identifier"") String identifier) <line3> throws UnsupportedEncodingException { <line4> return service.getOne( <line5> buildUiHttpContext(), URLEncoder.encode(identifier, StandardCharsets.UTF_8.toString())); <line6> } <line7> } <line8> "	"<line4>    LOGGER.debug(""getById {} / {}"",identifier,URLEncoder.encode(identifier, StandardCharsets.UTF_8.toString()));"	task4	
"public class A { <line0> public void removeTableFromGroup(TableName groupName, String schemaName, String tableName) { <line1> Group group = ais.getGroup(groupName); <line2> checkFound(group, ""removing join from group"", ""group"", groupName); <line3> Table table = ais.getTable(schemaName, tableName); <line4> checkFound(table, ""removing join from group"", ""table table"", concat(schemaName, tableName)); <line5> checkInGroup(group, table, ""removing join from group"", ""table table""); <line6> if (table.getParentJoin() != null || !table.getChildJoins().isEmpty()) { <line7> throw new GroupStructureException( <line8> ""Cannot remove table from a group unless "" <line9> + ""it is the only table in the group, group "" <line10> + group.getName() <line11> + "", table "" <line12> + table.getName()); <line13> } <line14> setTablesGroup(table, null); <line15> } <line16> } <line17> "	"<line1>    LOG.trace(""removeTableFromGroup: "" + groupName + "": "" + schemaName + ""."" + tableName);"	task4	
"public class A { <line0> public static int getAssetListEntriesCount(HttpPrincipal httpPrincipal, long[] groupIds) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> AssetListEntryServiceUtil.class, <line5> ""getAssetListEntriesCount"", <line6> _getAssetListEntriesCountParameterTypes20); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, groupIds); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> return ((Integer) returnObj).intValue(); <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public void requestInitialized(ServletRequestEvent servletRequestEvent) { <line2> Request request = ((Request) servletRequestEvent.getServletRequest()); <line3> } <line4> } <line5> 	"<line3>    LOG.info(""Styx REST Interface incoming request uri={}, method={}"",request.getRequestURI(),request.getMethod());"	task4	
public class A { <line0> public byte[] toJson(Object value) { <line1> byte[] result = null; <line2> if (isJsonString(value)) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> result = ((String) value).getBytes(StandardCharsets.UTF_8); <line6> } <line7> return result; <line8> } <line9> } <line10> 	"<line4>        logger.debug(""String already represents JSON. Skipping conversion in favor of""+ "" 'getBytes(StandardCharsets.UTF_8'."");"	task4	
public class A { <line0> public DocumentVo toDocumentVo() { <line1> DocumentVo documentVo = new DocumentVo(); <line2> if (ssrDocsType != null) { <line3> documentVo.setDocumentType(ssrDocsType.toString()); <line4> } <line5> documentVo.setDocumentNumber(travelDocNumber); <line6> documentVo.setIssuanceCountry(issueingCountryState); <line7> try { <line8> if (StringUtils.isNotBlank(travelDocumentExpirationDate)) { <line9> documentVo.setExpirationDate( <line10> ParseUtils.parseDateTime(travelDocumentExpirationDate, DOC_DATE_FORMAT)); <line11> } <line12> } catch (Exception ignored) { <line13> } <line14> return documentVo; <line15> } <line16> } <line17> 	"<line13>      logger.warn(""failed to parse expiration date on SSR DOCS"");"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public List<E> getByCriteriaWithAliasByOrder( <line3> Criterion criterion, <line4> String order, <line5> String[] orderBy, <line6> Integer count, <line7> String aliasTable, <line8> Criterion aliasCriterion) { <line9> Session session = getCurrentSession(); <line10> List<E> fetchedList = new ArrayList<E>(); <line11> Criteria criteria = session.createCriteria(entityClass); <line12> criteria.add(criterion); <line13> criteria <line14> .createAlias(aliasTable, aliasTable, org.hibernate.sql.JoinType.LEFT_OUTER_JOIN) <line15> .add(aliasCriterion); <line16> if (orderBy != null) { <line17> for (int i = 0; i < orderBy.length; i++) { <line18> if (order != null && order.equalsIgnoreCase(""desc"")) { <line19> criteria.addOrder(Order.desc(orderBy[i])); <line20> } else { <line21> criteria.addOrder(Order.asc(orderBy[i])); <line22> } <line23> } <line24> } <line25> if (count != null && count > 0) { <line26> criteria.setMaxResults(count); <line27> } <line28> try { <line29> fetchedList = criteria.list(); <line30> return fetchedList; <line31> } catch (Exception e) { <line32> throw new HibernateException( <line33> ""getByCriteriaWithAliasByOrder failed, criteria = "" + criterion.toString()); <line34> } <line35> } <line36> } <line37> "	"<line32>      logger.error(""getByCriteriaWithAliasByOrder failed, criteria = "" + criterion.toString(), e);"	task4	
public class A { <line0> public List<CosemObject> filterMeterValues(List<CosemObject> cosemObjects) { <line1> List<CosemObject> filteredValues = <line2> cosemObjects.stream() <line3> .filter( <line4> cosemObject -> <line5> supportedIdentifiers.contains( <line6> cosemObject.getObisIdentifier().getReducedOBISIdentifier())) <line7> .collect(Collectors.toList()); <line8> return filteredValues; <line9> } <line10> } <line11> 	"<line1>    logger.trace(""supported identifiers: {}, searching for objects {}"", supportedIdentifiers, cosemObjects);"	task4	
public class A { <line0> private JRDataSource createQueryDatasource() throws JRException { <line1> if (query == null) { <line2> return null; <line3> } <line4> try { <line5> if (log.isDebugEnabled()) { <line6> } <line7> QueryExecuterFactory queryExecuterFactory = <line8> JRQueryExecuterUtils.getInstance(getJasperReportsContext()) <line9> .getExecuterFactory(query.getLanguage()); <line10> SimpleQueryExecutionContext queryExecutionContext = <line11> SimpleQueryExecutionContext.of(getJasperReportsContext(), getRepositoryContext()); <line12> queryExecuter = <line13> queryExecuterFactory.createQueryExecuter(queryExecutionContext, this, parametersMap); <line14> filler.fillContext.setRunningQueryExecuter(queryExecuter); <line15> return queryExecuter.createDatasource(); <line16> } finally { <line17> filler.fillContext.clearRunningQueryExecuter(); <line18> } <line19> } <line20> } <line21> 	"<line6>        log.debug(""Fill "" + filler.fillerId + "": Creating "" + query.getLanguage() + "" query executer"");"	task4	
public class A { <line0> @Override <line1> public void doPostRollback(IndexWriter writer) throws IOException { <line2> Path path = directory.getPath(); <line3> String name = path.getName(); <line4> fileSystem.rename(path, new Path(path.getParent(), rename(name, BADROWIDS))); <line5> } <line6> } <line7> 	"<line2>    LOG.info(""Finished rollback on [{0}/{1}]"", _shard, _table);"	task4	
public class A { <line0> @Async <line1> public Future<Set<ObjectClassInfo>> getObjectClassInfo(final ConnectorFacade connector) { <line2> Set<ObjectClassInfo> result = Set.of(); <line3> try { <line4> result = connector.schema().getObjectClassInfo(); <line5> } catch (Exception e) { <line6> } <line7> return new AsyncResult<>(result); <line8> } <line9> } <line10> 	"<line6>      LOG.debug(""While reading schema on connector {}"", connector, e);"	task4	
public class A { <line0> private void parseClientNonce(ClientEsniInner clientEsniInne) { <line1> byte[] clientNonce = parseByteArrayField(ExtensionByteLength.NONCE); <line2> clientEsniInne.setClientNonce(clientNonce); <line3> } <line4> } <line5> 	"<line3>    LOGGER.debug(""clientNonce: ""+ ArrayConverter.bytesToHexString(clientEsniInne.getClientNonce().getValue()));"	task4	
public class A { <line0> private static SubjectConfirmationData createSubjectConfirmationData( <line1> final KeyInfoBean keyInforBean, final SubjectConfirmationDataBean confirDataBean) <line2> throws SAMLComponentBuilderException { <line3> try { <line4> return SAML2ComponentBuilder.createSubjectConfirmationData(confirDataBean, keyInforBean); <line5> } catch (SecurityException | WSSecurityException e) { <line6> throw new SAMLComponentBuilderException(e.getLocalizedMessage(), e); <line7> } <line8> } <line9> } <line10> 	<line6>      LOG.error(e.getLocalizedMessage());	task4	
public class A { <line0> @Override <line1> public void run() { <line2> for (ByteString topic : top2sub2seq.keySet()) { <line3> final Map<ByteString, InMemorySubscriptionState> topicSubscriptions = top2sub2seq.get(topic); <line4> if (topicSubscriptions == null) { <line5> continue; <line6> } <line7> long minConsumedMessage = Long.MAX_VALUE; <line8> boolean hasBound = true; <line9> for (InMemorySubscriptionState curSubscription : topicSubscriptions.values()) { <line10> if (curSubscription.getLastPersistedSeqId() < minConsumedMessage) { <line11> minConsumedMessage = curSubscription.getLastPersistedSeqId(); <line12> } <line13> hasBound = hasBound && curSubscription.getSubscriptionPreferences().hasMessageBound(); <line14> } <line15> Long minConsumedFromMap = topic2MinConsumedMessagesMap.get(topic); <line16> if (topicSubscriptions.isEmpty() <line17> || (minConsumedFromMap != null && minConsumedFromMap < minConsumedMessage) <line18> || (minConsumedFromMap == null && minConsumedMessage != 0)) { <line19> topic2MinConsumedMessagesMap.put(topic, minConsumedMessage); <line20> if (logger.isDebugEnabled()) { <line21> } <line22> pm.consumedUntil(topic, minConsumedMessage); <line23> } else if (hasBound) { <line24> pm.consumeToBound(topic); <line25> } <line26> } <line27> } <line28> } <line29> 	"<line21>          logger.debug(""Issuing consumed until request to persistence manager for topic: {} with min-id: {}"",topic.toStringUtf8(),minConsumedMessage);"	task4	
"public class A { <line0> @RequestMapping( <line1> value = ""/deleteAttribute.action"", <line2> method = {RequestMethod.GET}) <line3> @ResponseBody <line4> public Map<String, Object> deleteAttribute(@RequestParam Integer id) { <line5> try { <line6> boolean success = taggerService.deleteAttribute(id); <line7> if (success) { <line8> return getUIWrapper(true, ""Attribute was successful deleted""); <line9> } else { <line10> return getUIWrapper(false, ""Error while deleting attribute in Tagger""); <line11> } <line12> } catch (Exception e) { <line13> return getUIWrapper(false, e.getMessage()); <line14> } <line15> } <line16> } <line17> "	"<line13>      logger.error(""Error while deleting attributeId: "" + id, e);"	task4	
public class A { <line0> protected RestContainer assertParseRestAsJaxb(String uri) throws JAXBException { <line1> Object value = parseUri(uri); <line2> RestContainer context = assertIsInstanceOf(RestContainer.class, value); <line3> return context; <line4> } <line5> } <line6> 	"<line3>    log.info(""Found: "" + context);"	task4	
"public class A { <line0> @Override <line1> public void beforeConfiguration(ITestResult tr, ITestNGMethod tm) { <line2> try { <line3> Field configListenersField = <line4> this.getClass().getSuperclass().getDeclaredField(""configListeners""); <line5> configListenersField.setAccessible(true); <line6> List<IConfigurationListener> listeners = <line7> (List<IConfigurationListener>) configListenersField.get(this); <line8> invokeListeners(tr, tm, listeners); <line9> } catch (NoSuchFieldException | IllegalAccessException e) { <line10> } <line11> } <line12> } <line13> "	"<line10>      LOGGER.error(""Could not invoke configuration listeners."", e);"	task4	
public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> if (fnWorkerService != null) { <line4> fnWorkerService.stop(); <line5> } <line6> if (broker != null) { <line7> broker.close(); <line8> } <line9> if (bkEnsemble != null) { <line10> bkEnsemble.stop(); <line11> } <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> 	"<line13>      log.error(""Shutdown failed: {}"", e.getMessage(), e);"	task4	
public class A { <line0> private void addAllowedHeaderIfValid(String headerName, HttpServletResponse response) { <line1> if (isValidHttpHeaderName(headerName)) { <line2> response.addHeader(ACCESS_CONTROL_ALLOW_HEADERS, headerName); <line3> } else { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.warn(""Invalid HTTP header specified in ""+ ACCESS_CONTROL_REQUEST_HEADERS+ "" '""+ headerName+ ""'. ""+ ""It will be ignored and not attached to the ""+ ACCESS_CONTROL_ALLOW_HEADERS+ "" response header"");"	task4	
public class A { <line0> public void disconnect() { <line1> JmsUtils.closeQuietly(connection); <line2> } <line3> } <line4> 	"<line1>    LOG.info(""Disconnecting from broker {} on user {}"", config.url(), config.username());"	task4	
public class A { <line0> public VariantStudyMetadata getVariantStudyMetadata(String studyId) { <line1> if (studyId != null) { <line2> if (variantMetadata.getStudies() == null) { <line3> variantMetadata.setStudies(new ArrayList<>()); <line4> } <line5> for (VariantStudyMetadata study : variantMetadata.getStudies()) { <line6> if (studyId.equals(study.getId())) { <line7> return study; <line8> } <line9> } <line10> } else { <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line11>      logger.error(""Study ID is null"");"	task4	
"public class A { <line0> private void init() throws Exception { <line1> this.depResolver = <line2> new DependencyResolver(zconf.getString(ConfVars.ZEPPELIN_INTERPRETER_LOCALREPO)); <line3> InterpreterOutput.limit = zconf.getInt(ConfVars.ZEPPELIN_INTERPRETER_OUTPUT_LIMIT); <line4> HeliumApplicationFactory heliumApplicationFactory = new HeliumApplicationFactory(); <line5> HeliumVisualizationFactory heliumVisualizationFactory; <line6> if (isBinaryPackage(zconf)) { <line7> heliumVisualizationFactory = <line8> new HeliumVisualizationFactory( <line9> zconf, <line10> new File(zconf.getRelativeDir(ConfVars.ZEPPELIN_DEP_LOCALREPO)), <line11> new File(zconf.getRelativeDir(""lib/node_modules/zeppelin-tabledata"")), <line12> new File(zconf.getRelativeDir(""lib/node_modules/zeppelin-vis""))); <line13> } else { <line14> heliumVisualizationFactory = <line15> new HeliumVisualizationFactory( <line16> zconf, <line17> new File(zconf.getRelativeDir(ConfVars.ZEPPELIN_DEP_LOCALREPO)), <line18> new File(zconf.getRelativeDir(""smart-zeppelin/zeppelin-web/src/app/tabledata"")), <line19> new File(zconf.getRelativeDir(""smart-zeppelin/zeppelin-web/src/app/visualization""))); <line20> } <line21> this.helium = <line22> new Helium( <line23> zconf.getHeliumConfPath(), <line24> zconf.getHeliumDefaultLocalRegistryPath(), <line25> heliumVisualizationFactory, <line26> heliumApplicationFactory); <line27> try { <line28> heliumVisualizationFactory.bundle(helium.getVisualizationPackagesToBundle()); <line29> } catch (Exception e) { <line30> } <line31> this.schedulerFactory = new SchedulerFactory(); <line32> this.interpreterSettingManager = <line33> new InterpreterSettingManager(zconf, depResolver, new InterpreterOption(true)); <line34> this.noteSearchService = new LuceneSearch(); <line35> this.notebookAuthorization = NotebookAuthorization.init(zconf); <line36> this.credentials = new Credentials(zconf.credentialsPersist(), zconf.getCredentialsPath()); <line37> } <line38> } <line39> "	<line30>      LOG.error(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public CommitteeProposalComponentData getCommitteeProposal(final String id) <line2> throws DataFailureException { <line3> try { <line4> final String url = <line5> COMMITTE_PROPOSAL.replace( <line6> ID_KEY, UrlHelper.urlEncode(id, StandardCharsets.UTF_8.toString())); <line7> return ((JAXBElement<CommitteeProposalComponentData>) <line8> xmlAgent.unmarshallXml( <line9> riksdagenCommitteeProposalMarshaller, <line10> url, <line11> HTTP_UTSKOTTSFORSLAG_RIKSDAGEN_EXTERNAL_MODEL_CIA_HACK23_COM_IMPL, <line12> null, <line13> null)) <line14> .getValue(); <line15> } catch (final XmlAgentException e) { <line16> throw new DataFailureException(e); <line17> } <line18> } <line19> } <line20> 	<line16>      LOGGER.warn(PROBLEM_GETTING_COMMITTEE_PROPOSAL_FOR_ID_S_FROM_DATA_RIKSDAGEN_SE, id);	task4	
"public class A { <line0> private static DataSource _getSlaveDataSource(Ioc ioc, PropertiesProxy conf, String prefix) { <line1> List<DataSource> slaveDataSources = new ArrayList<>(); <line2> for (String key : conf.keys()) { <line3> if (key.startsWith(prefix) && key.endsWith("".url"")) { <line4> String slaveName = key.substring(prefix.length(), key.length() - "".url"".length()); <line5> try { <line6> DataSource slaveDataSource = <line7> DataSourceStarter.createSlaveDataSource(ioc, conf, prefix + slaveName + "".""); <line8> slaveDataSources.add(slaveDataSource); <line9> slaves.add(slaveDataSource); <line10> } catch (Exception e) { <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> if (slaveDataSources.size() > 0) { <line16> if (slaveDataSources.size() == 1) { <line17> return slaveDataSources.get(0); <line18> } else { <line19> return new DynaDataSource(new DynaDataSourceSeletor(slaveDataSources)); <line20> } <line21> } <line22> return null; <line23> } <line24> } <line25> "	"<line5>        log.debug(""found Slave DataSource name="" + slaveName);"	task4	
public class A { <line0> public static int getCommerceOrderItemsCount( <line1> long groupId, long commerceAccountId, int[] orderStatuses) throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceOrderItemServiceUtil.getCommerceOrderItemsCount( <line5> groupId, commerceAccountId, orderStatuses); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line8>      log.error(exception, exception);	task4	
public class A { <line0> public void addAttributeListener(ZclAttributeListener listener) { <line1> attributeListeners.add(listener); <line2> } <line3> } <line4> 	"<line1>    logger.trace(""{}: ZclCluster.addAttributeListener adding {}"",zigbeeEndpoint.getEndpointAddress(),listener);"	task4	
public class A { <line0> @Override <line1> public boolean handleGraphObject(SecurityContext securityContext, AbstractRelationship rel) { <line2> if (rel.getProperty(GraphObject.id) != null) { <line3> Class type = rel.getClass(); <line4> PropertyKey destPropertyKey = <line5> StructrApp.getConfiguration().getPropertyKeyForDatabaseName(type, destKey); <line6> PropertyKey sourcePropertyKey = <line7> StructrApp.getConfiguration().getPropertyKeyForDatabaseName(type, sourceKey); <line8> try { <line9> rel.setProperty(destPropertyKey, rel.getProperty(sourcePropertyKey)); <line10> } catch (FrameworkException fex) { <line11> } <line12> } <line13> return true; <line14> } <line15> } <line16> 	"<line11>        logger.warn(""Unable to copy relationship property {} of relationship {} to {}: {}"",new Object[] {sourcePropertyKey, rel.getUuid(), destPropertyKey, fex.getMessage()});"	task4	
public class A { <line0> @Override <line1> public void bundleChanged(BundleEvent event) { <line2> if (event.getType() == BundleEvent.STARTED) { <line3> try { <line4> tryInstallingFailedArtifacts(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        LOGGER.debug(""error when trying to instal artifacts"", e);"	task4	
public class A { <line0> @Override <line1> public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) { <line2> initializeBridge( <line3> (getBridge() == null) ? null : getBridge().getHandler(), bridgeStatusInfo.getStatus()); <line4> } <line5> } <line6> 	"<line2>    logger.debug(""bridgeStatusChanged {} for thing {}"", bridgeStatusInfo, getThing().getUID());"	task4	
"public class A { <line0> public static java.util.List<com.liferay.commerce.account.model.CommerceAccountUserRel> <line1> getCommerceAccountUserRels( <line2> HttpPrincipal httpPrincipal, long commerceAccountId, int start, int end) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceAccountUserRelServiceUtil.class, <line8> ""getCommerceAccountUserRels"", <line9> _getCommerceAccountUserRelsParameterTypes7); <line10> MethodHandler methodHandler = new MethodHandler(methodKey, commerceAccountId, start, end); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<com.liferay.commerce.account.model.CommerceAccountUserRel>) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> public void onNewSnapshot(final PersistedSnapshot persistedSnapshot) { <line2> if (threadContext.isCurrentContext()) { <line3> final var index = persistedSnapshot.getIndex(); <line4> final var lastIndex = raftLog.getLastIndex(); <line5> if (lastIndex < index) { <line6> raftLog.reset(index + 1); <line7> } <line8> } else { <line9> threadContext.execute(() -> onNewSnapshot(persistedSnapshot)); <line10> } <line11> } <line12> } <line13> 	"<line6>        log.info(""Delete existing log (lastIndex '{}') and replace with received snapshot (index '{}')"",lastIndex,index);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> connectDistributedSystem(); <line3> DLockService dls = (DLockService) DistributedLockService.getServiceNamed(dlsName); <line4> assertThat(dls.lock(key1, -1, -1)).isTrue(); <line5> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(1); <line6> assertThat(dls.lock(key1, -1, -1)).isTrue(); <line7> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(2); <line8> assertThat(dls.lock(key1, -1, -1)).isTrue(); <line9> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(3); <line10> DLockToken token0 = dls.getToken(key1); <line11> assertThat(token0).isNotNull(); <line12> Collection tokens = dls.getTokens(); <line13> assertThat(tokens.contains(token0)).isTrue(); <line14> assertThat(tokens.size()).isEqualTo(1); <line15> dls.unlock(key1); <line16> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(2); <line17> dls.freeResources(key1); <line18> DLockToken token1 = dls.getToken(key1); <line19> assertThat(token1).isNotNull(); <line20> assertThat(token1).isEqualTo(token0); <line21> tokens = dls.getTokens(); <line22> assertThat(tokens.contains(token1)).isTrue(); <line23> assertThat(tokens.size()).isEqualTo(1); <line24> dls.unlock(key1); <line25> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(1); <line26> dls.freeResources(key1); <line27> assertThat(dls.getToken(key1)).isNotNull(); <line28> DLockToken token2 = dls.getToken(key1); <line29> assertThat(token2).isNotNull(); <line30> assertThat(token2).isEqualTo(token0); <line31> tokens = dls.getTokens(); <line32> assertThat(tokens.contains(token2)).isTrue(); <line33> assertThat(tokens.size()).isEqualTo(1); <line34> dls.unlock(key1); <line35> assertThat(dls.getToken(key1).getUsageCount()).isEqualTo(0); <line36> dls.freeResources(key1); <line37> DLockToken token3 = dls.getToken(key1); <line38> assertThat(token3).withFailMessage(""Failed with bug 38180: "" + token3).isNull(); <line39> tokens = dls.getTokens(); <line40> assertThat(tokens.size()) <line41> .isEqualTo(0) <line42> .withFailMessage(""Failed with bug 38180: tokens="" + tokens); <line43> } <line44> } <line45> "	"<line2>    logger.info(""[testTokenCleanup] vm1 tests recursion"");"	task4	
public class A { <line0> public long getQueueNotVisibleMessageCount(String queueUrl) { <line1> long messageCount = 0; <line2> try { <line3> messageCount = getQueueNotVisibleMessageCount(queueUrl, false); <line4> } catch (Exception ex) { <line5> } <line6> return messageCount; <line7> } <line8> } <line9> 	"<line5>      logger.error(""event=failed_to_get_number_of_not_visible_messages queue_url="" + queueUrl);"	task4	
"public class A { <line0> public static String parameterizeUrl(String baseUrl, Properties params) { <line1> baseUrl = StringUtils.trim(baseUrl); <line2> if (StringUtils.isEmpty(baseUrl)) { <line3> throw new IllegalArgumentException(""invalid (blank) base URL""); <line4> } <line5> if (params == null) { <line6> throw new IllegalArgumentException(""invalid (null) Properties""); <line7> } <line8> StringBuffer ret = new StringBuffer(baseUrl); <line9> String delimiter = (ret.indexOf(""?"") == -1) ? ""?"" : ""&""; <line10> for (Object key : params.keySet()) { <line11> String paramName = StringUtils.trim((String) key); <line12> String paramValue = params.getProperty(paramName); <line13> ret.append(delimiter); <line14> if (StringUtils.isEmpty(paramName)) { <line15> throw new IllegalArgumentException(""invalid (blank) paramName""); <line16> } <line17> if (paramValue == null) { <line18> ret.append(paramName); <line19> ret.append(""=""); <line20> } else { <line21> try { <line22> ret.append(paramName); <line23> ret.append(""=""); <line24> ret.append(urlCodec.encode(paramValue)); <line25> } catch (EncoderException ex) { <line26> throw new RuntimeException( <line27> ""Unable to encode parameter name or value: "" + paramName + ""="" + paramValue, ex); <line28> } <line29> } <line30> delimiter = ""&""; <line31> } <line32> return ret.toString(); <line33> } <line34> } <line35> "	"<line26>          LOG.error(""Unable to encode parameter name or value: "" + paramName + ""="" + paramValue, ex);"	task4	
"public class A { <line0> @Override <line1> public AsyncAdminBuilder getAdminBuilder() { <line2> return new AsyncAdminBuilder() { <line3> @Override <line4> public AsyncAdminBuilder setStartLogErrorsCnt(int arg0) { <line5> return this; <line6> } <line7>  <line8> @Override <line9> public AsyncAdminBuilder setRpcTimeout(long arg0, TimeUnit arg1) { <line10> return this; <line11> } <line12>  <line13> @Override <line14> public AsyncAdminBuilder setRetryPause(long arg0, TimeUnit arg1) { <line15> return this; <line16> } <line17>  <line18> @Override <line19> public AsyncAdminBuilder setRetryPauseForCQTBE(long l, TimeUnit timeUnit) { <line20> return this; <line21> } <line22>  <line23> @Override <line24> public AsyncAdminBuilder setOperationTimeout(long arg0, TimeUnit arg1) { <line25> return this; <line26> } <line27>  <line28> @Override <line29> public AsyncAdminBuilder setMaxAttempts(int arg0) { <line30> return this; <line31> } <line32>  <line33> @Override <line34> public AsyncAdmin build() { <line35> try { <line36> return new BigtableAsyncAdmin(BigtableAsyncConnection.this); <line37> } catch (IOException e) { <line38> throw new UncheckedIOException(""failed to build BigtableAsyncAdmin"", e); <line39> } <line40> } <line41> }; <line42> } <line43> } <line44> "	"<line38>          LOG.error(""failed to build BigtableAsyncAdmin"", e);"	task4	
public class A { <line0> public static void prepareRuntimeContext() { <line1> RuntimeContext.set(RuntimeContext.DEFAULT.apply(System.getenv())); <line2> RuntimeContext.get().verifyApplication(WindGate.class.getClassLoader()); <line3> } <line4> } <line5> 	"<line3>    LOG.debug(""Runtime context is prepared: {}"", RuntimeContext.get());"	task4	
"public class A { <line0> @Test <line1> public void test1() { <line2> Text colf = new Text(""a""); <line3> Text colq = new Text(""b""); <line4> TreeMap<Key, Value> tm = new TreeMap<>(); <line5> createTestData(tm, colf, colq); <line6> try { <line7> VersioningIterator it = new VersioningIterator(); <line8> IteratorSetting is = new IteratorSetting(1, VersioningIterator.class); <line9> VersioningIterator.setMaxVersions(is, 3); <line10> it.init(new SortedMapIterator(tm), is.getOptions(), null); <line11> it.seek(new Range(), EMPTY_COL_FAMS, false); <line12> TreeMap<Key, Value> tmOut = iteratorOverTestData(it); <line13> for (Entry<Key, Value> e : tmOut.entrySet()) { <line14> assertEquals(8, e.getValue().get().length); <line15> assertTrue(16 < encoder.decode(e.getValue().get())); <line16> } <line17> assertEquals(""size after keeping 3 versions was "" + tmOut.size(), 6, tmOut.size()); <line18> } catch (IOException e) { <line19> fail(); <line20> } catch (Exception e) { <line21> fail(); <line22> } <line23> } <line24> } <line25> "	"<line21>      log.error(""{}"", e.getMessage(), e);"	task4	
public class A { <line0> @Deactivate <line1> public void stop() { <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""Stopping lock service"");"	task4	
public class A { <line0> private List getIndexes(String rootRegion, String bucketRegion) { <line1> List indexes = null; <line2> if (!this.partitionedRegion.isIndexed()) { <line3> return indexes; <line4> } <line5> Map indexMap = this.partitionedRegion.getIndex(); <line6> if (indexMap == null || indexMap.isEmpty()) { <line7> return indexes; <line8> } <line9> indexes = new ArrayList(); <line10> Set indexSet = indexMap.entrySet(); <line11> for (Iterator it = indexSet.iterator(); it.hasNext(); ) { <line12> try { <line13> Map.Entry indexEntry = (Map.Entry) it.next(); <line14> PartitionedIndex index = (PartitionedIndex) indexEntry.getValue(); <line15> IndexCreationData icd = new IndexCreationData(index.getName()); <line16> new QCompiler(); <line17> String imports = index.getImports(); <line18> icd.setIndexData( <line19> index.getType(), <line20> index.getCanonicalizedFromClause(), <line21> index.getCanonicalizedIndexedExpression(), <line22> index.getImports()); <line23> icd.setPartitionedIndex(index); <line24> indexes.add(icd); <line25> } catch (Exception ignor) { <line26> } <line27> } <line28> return indexes; <line29> } <line30> } <line31> 	"<line26>        logger.info(String.format(""Excpetion  in bucket index creation : %s"", ignor.getLocalizedMessage()),ignor);"	task4	
public class A { <line0> private void handleUncaughtThrowable(Throwable t) { <line1> if (errored.compareAndSet(false, true)) { <line2> Runtime.getRuntime().halt(1); <line3> } <line4> } <line5> } <line6> 	"<line2>      log.error(""unrecoverable error in task feeder or one of its mapper threads. immediately halting""+ "" jvm"",t);"	task4	
public class A { <line0> @Override <line1> public Map<String, SyncTaskStatistic> getSyncTaskStatistics() { <line2> Map<String, SyncTaskStatistic> ret = new ConcurrentHashMap<>(); <line3> synchronized (syncTasks) { <line4> for (SyncTaskQueueWrapper wrapper : syncTasks.values()) { <line5> SyncTaskStatistic statistic = <line6> new SyncTaskStatistic( <line7> wrapper.syncSignature, <line8> wrapper.maxThreadNum, <line9> wrapper.counter.intValue(), <line10> wrapper.queue.size()); <line11> ret.put(statistic.getSyncSignature(), statistic); <line12> } <line13> } <line14> return ret; <line15> } <line16> } <line17> 	<line12>        logger.warn(JSONObjectUtil.toJsonString(statistic));	task4	
public class A { <line0> public edu.indiana.extreme.wsdl.benchmark1.ReceiveMeshInterfaceObjectsResponse <line1> receiveMeshInterfaceObjects( <line2> edu.indiana.extreme.wsdl.benchmark1.ReceiveMeshInterfaceObjectsRequest input) { <line3> ReceiveMeshInterfaceObjectsResponse ret = new ReceiveMeshInterfaceObjectsResponse(); <line4> ret.setReceiveMeshInterfaceObjectsReturn(input.getInput().getItem().size()); <line5> return ret; <line6> } <line7> } <line8> 	"<line3>    LOG.info(""Executing operation receiveMeshInterfaceObjects"");"	task4	
public class A { <line0> @Override <line1> public void deleteList(String uuid) throws BusinessException { <line2> ContactList listToDelete = findByUuid(uuid); <line3> listRepository.delete(listToDelete); <line4> } <line5> } <line6> 	"<line3>    logger.debug(""List to delete: "" + uuid);"	task4	
public class A { <line0> @Override <line1> public void getGeoDetails(final String id) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(GEO_DETAILS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> Place place = twitter.getGeoDetails(id); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotGeoDetails(place); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	"<line12>                    logger.warn(""Exception at getGeoDetails"", e);"	task4	
"public class A { <line0> @Test <line1> public void testKeyValue() throws Exception { <line2> User user = new User(); <line3> user.setUsername(""edanuff""); <line4> user.setEmail(""ed@anuff.com""); <line5> Activity activity = <line6> Activity.newActivity( <line7> Activity.VERB_POST, <line8> null, <line9> ""I ate another sammich"", <line10> null, <line11> user, <line12> null, <line13> ""tweet"", <line14> null, <line15> null); <line16> List<Entry<String, Object>> l = IndexUtils.getKeyValueList(activity, false); <line17> for (Entry<String, Object> e : l) { <line18> } <line19> assertEquals(7, l.size()); <line20> } <line21> } <line22> "	"<line18>      logger.info(e.getKey() + "" = "" + e.getValue());"	task4	
"public class A { <line0> public MrGeoRaster createColorScaleSwatch(String name, String format, int width, int height) <line1> throws MrsPyramidServiceException { <line2> try { <line3> ColorScale cs = getColorScaleFromName(name); <line4> return createColorScaleSwatch(cs, format, width, height); <line5> } catch (Exception e) { <line6> throw new MrsPyramidServiceException(""Error creating color scale "" + name, e); <line7> } <line8> } <line9> } <line10> "	"<line6>      log.error(""Exception thrown"", e);"	task4	
public class A { <line0> protected String getJWTFromCookie(HttpServletRequest req) { <line1> String serializedJWT = null; <line2> Cookie[] cookies = req.getCookies(); <line3> if (cookieName != null && cookies != null) { <line4> for (Cookie cookie : cookies) { <line5> if (cookieName.equals(cookie.getName())) { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> serializedJWT = cookie.getValue(); <line9> break; <line10> } <line11> } <line12> } <line13> return serializedJWT; <line14> } <line15> } <line16> 	"<line7>            LOG.debug(""{} cookie has been found and is being processed"", cookieName);"	task4	
public class A { <line0> private static String getMessage(String key) { <line1> try { <line2> return PropertyAccessor.getInstance().getProperty(NhincConstants.MESSAGES_PROPERTY_FILE, key); <line3> } catch (PropertyAccessException ex) { <line4> } <line5> return null; <line6> } <line7> } <line8> 	"<line4>      LOG.error(""Unable to read {} from file {}: {}"",key,NhincConstants.MESSAGES_PROPERTY_FILE,ex.getLocalizedMessage(),ex);"	task4	
public class A { <line0> @Override <line1> protected void parseHandshakeMessageContent(HelloRetryRequestMessage msg) { <line2> parseProtocolVersion(msg); <line3> parseSelectedCiphersuite(msg); <line4> if (hasExtensionLengthField(msg)) { <line5> parseExtensionLength(msg); <line6> if (hasExtensions(msg)) { <line7> parseExtensionBytes(msg); <line8> } <line9> } <line10> } <line11> } <line12> 	"<line2>    LOGGER.debug(""Parsing HelloRetryRequestMessage"");"	task4	
"public class A { <line0> @Override <line1> public void contextInitialized(ServletContextEvent event) { <line2> try { <line3> cloudStackContext = new CloudStackSpringContext(); <line4> cloudStackContext.registerShutdownHook(); <line5> event <line6> .getServletContext() <line7> .setAttribute(CloudStackSpringContext.CLOUDSTACK_CONTEXT_SERVLET_KEY, cloudStackContext); <line8> } catch (IOException e) { <line9> throw new RuntimeException(""Failed to initialize CloudStack Spring modules"", e); <line10> } <line11> configuredParentName = event.getServletContext().getInitParameter(WEB_PARENT_MODULE); <line12> if (configuredParentName == null) { <line13> configuredParentName = WEB_PARENT_MODULE_DEFAULT; <line14> } <line15> super.contextInitialized(event); <line16> } <line17> } <line18> "	"<line9>      log.error(""Failed to start CloudStack"", e);"	task4	
public class A { <line0> protected void truncate(final long length) throws IOException { <line1> fc.truncate(length); <line2> } <line3> } <line4> 	"<line1>    log.info(""Truncating file [{0}] to {1}"", filepath, length);"	task4	
public class A { <line0> @Override <line1> protected void execute(final TraceEventRecords invalidTrace) throws Exception { <line2> if (this.logInvalidTraces) { <line3> } <line4> final TraceMetadata traceMetadata = invalidTrace.getTraceMetadata(); <line5> if (traceMetadata != null) { <line6> this.reportError(invalidTrace.getTraceMetadata().getTraceId()); <line7> } else { <line8> final AbstractTraceEvent[] events = invalidTrace.getTraceEvents(); <line9> if ((events != null) && (events.length > 0)) { <line10> this.reportError(events[0].getTraceId()); <line11> } else { <line12> this.reportError(InvalidEventRecordTraceCounter.TRACE_ID_IF_NONE); <line13> } <line14> } <line15> } <line16> } <line17> 	"<line3>      this.logger.error(""Invalid trace: {}"", invalidTrace);"	task4	
public class A { <line0> @Subscribe <line1> public void eventReceived(Object event) { <line2> if (eventClass == null || eventClass.isAssignableFrom(event.getClass())) { <line3> doEventReceived(event); <line4> } else { <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        log.debug(""Cannot process event: {} as its class type: {} is not assignable with: {}"",new Object[] {event, event.getClass().getName(), eventClass.getName()});"	task4	
"public class A { <line0> @Override <line1> protected void readTimedOut(final ChannelHandlerContext ctx) throws Exception { <line2> if (first) { <line3> SwitchIdleEventBuilder builder = new SwitchIdleEventBuilder(); <line4> builder.setInfo(""Switch idle""); <line5> ctx.fireChannelRead(builder.build()); <line6> first = false; <line7> } <line8> } <line9> } <line10> "	"<line3>      LOG.debug(""Switch idle"");"	task4	
public class A { <line0> @Override <line1> public void updateEnvelopeForOffering(final String offering, final Envelope envelope) { <line2> CacheValidation.notNullOrEmpty(OFFERING, offering); <line3> Objects.requireNonNull(envelope, ENVELOPE); <line4> if (hasEnvelopeForOffering(offering)) { <line5> final ReferencedEnvelope offeringEnvelope = this.envelopeForOfferings.get(offering); <line6> offeringEnvelope.expandToInclude(envelope); <line7> } else { <line8> setEnvelopeForOffering(offering, new ReferencedEnvelope(envelope, getDefaultEPSGCode())); <line9> } <line10> } <line11> } <line12> 	"<line6>      LOG.trace(""Expanding envelope {} for offering {} to include {}"",offeringEnvelope,offering,envelope);"	task4	
public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture future) throws Exception { <line2> if (!future.isSuccess()) { <line3> ctx.close(); <line4> } <line5> } <line6> } <line7> 	"<line3>      logger.debug(""Failed to send a 413 Request Entity Too Large."", future.cause());"	task4	
public class A { <line0> public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException { <line1> MagicAnnotation annotation = field.getAnnotation(MagicAnnotation.class); <line2> if (annotation != null && field.getType() == String.class) { <line3> ReflectionUtils.makeAccessible(field); <line4> field.set(bean, annotation.value()); <line5> } <line6> } <line7> } <line8> 	"<line3>      log.info(""Found MagicAnnotation on field "" + field + "" of class "" + bean.getClass());"	task4	
public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceChannel commerceChannel) { <line2> try { <line3> if (!GroupPermissionUtil.contains( <line4> PermissionThreadLocal.getPermissionChecker(), <line5> commerceChannel.getSiteGroupId(), <line6> ActionKeys.ADD_LAYOUT)) { <line7> return false; <line8> } <line9> } catch (PortalException portalException) { <line10> return false; <line11> } <line12> if (!CommerceChannelConstants.CHANNEL_TYPE_SITE.equals(commerceChannel.getType())) { <line13> return false; <line14> } <line15> return true; <line16> } <line17> } <line18> 	<line10>      log.error(portalException, portalException);	task4	
public class A { <line0> private void joinEnvironmentP2PSwarm(ProxyDto proxyDto) { <line1> try { <line2> ResourceHost resourceHost = peerManager.getLocalPeer().getManagementHost(); <line3> resourceHost.joinP2PSwarmDHCP( <line4> proxyDto.getP2pIfaceName(), <line5> proxyDto.getP2pHash(), <line6> proxyDto.getP2SecretKey(), <line7> proxyDto.getP2pSecretTTL()); <line8> for (final P2PConnection p2PConnection : resourceHost.getP2PConnections().getConnections()) { <line9> if (p2PConnection.getHash().equals(proxyDto.getP2pHash())) { <line10> proxyDto.setP2pIpAddr(p2PConnection.getIp()); <line11> break; <line12> } <line13> } <line14> proxyDto.setState(ProxyDto.State.READY); <line15> } catch (Exception e) { <line16> proxyDto.setState(ProxyDto.State.FAILED); <line17> proxyDto.setLogs(e.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line18>      log.error(e.getMessage());	task4	
"public class A { <line0> @Override <line1> public void create(String filePath, InputStream content, boolean doPrepare) throws IOException { <line2> if (content == null) { <line3> throw new IllegalArgumentException(""Content of a file can not be null.""); <line4> } <line5> if (filePath == null) { <line6> throw new IllegalArgumentException(""Name of a file can not be null.""); <line7> } <line8> if (checkFileExists(filePath)) { <line9> throw new IllegalArgumentException(""The file already exists""); <line10> } <line11> File targetFile = new File(getAbsolutePath(filePath).toUri()); <line12> FileUtils.copyInputStreamToFile(content, targetFile); <line13> if (doPrepare && prepareScript != null) { <line14> Process p = Runtime.getRuntime().exec(prepareScript + "" "" + targetFile.getAbsolutePath()); <line15> LOGGER.warning(new String(IOUtils.toByteArray(p.getErrorStream()))); <line16> try { <line17> int e = p.waitFor(); <line18> if (e != 0) { <line19> throw new IOException(""Preparation script ended with exit code "" + e); <line20> } <line21> } catch (InterruptedException e) { <line22> } <line23> } <line24> } <line25> } <line26> "	<line15>      LOGGER.info(new String(IOUtils.toByteArray(p.getInputStream())));	task4	
"public class A { <line0> public void migrateNavigation(FileSystem sourceFS, FileSystem targetFS) { <line1> migrate(sourceFS, targetFS, path -> path.getFileName().toString().equals(""navtree.json"")); <line2> } <line3> } <line4> "	"<line1>    LOGGER.info(""attempt to migrate navigation"");"	task4	
public class A { <line0> public static void recursiveDelete(File file) { <line1> try { <line2> Files.walk(file.toPath()) <line3> .sorted(Comparator.reverseOrder()) <line4> .map(Path::toFile) <line5> .forEach(File::delete); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      log.error(""Failed to delete file: {}"", file, e);"	task4	
public class A { <line0> @Override <line1> public boolean savePatient(PatientType patient) throws LoadTestDataException { <line2> SavePatientRequestMessageType request = new SavePatientRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setPatient(patient); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_SAVEPATIENT, request); <line9> logDebug(AdminWSConstants.ADMIN_LTD_SAVEPATIENT, response.isStatus(), response.getMessage()); <line10> if (response.isStatus()) { <line11> patient.setPatientId(response.getSaveRecordId()); <line12> } <line13> return response.isStatus(); <line14> } catch (Exception e) { <line15> } <line16> return false; <line17> } <line18> } <line19> 	"<line15>      LOG.error(""error during save patient: {}"", e.getLocalizedMessage(), e);"	task4	
public class A { <line0> @Override <line1> protected boolean bridgeDirectCommunicate( <line2> BridgeCommunicationProtocol communication, boolean useAuthentication) { <line3> return bridgeDirectCommunicate( <line4> (JsonBridgeCommunicationProtocol) communication, useAuthentication); <line5> } <line6> } <line7> 	"<line3>    logger.trace(""bridgeDirectCommunicate(BCP: {},{}authenticated) called."",communication.name(),useAuthentication ? """" : ""un"");"	task4	
"public class A { <line0> @Override <line1> public void generate(Model model, MolgenisOptions options) throws Exception { <line2> Template template = createTemplate(""/"" + this.getClass().getSimpleName() + "".psql.ftl""); <line3> Map<String, Object> templateArgs = createTemplateArguments(options); <line4> List<Entity> entityList = model.getEntities(); <line5> entityList = MolgenisModel.sortEntitiesByDependency(entityList, model); <line6> File target = new File(this.getSqlPath(options) + ""/create_tables.sql""); <line7> boolean created = target.getParentFile().mkdirs(); <line8> if (!created && !target.getParentFile().exists()) { <line9> throw new IOException(""could not create "" + target.getParentFile()); <line10> } <line11> templateArgs.put(""model"", model); <line12> templateArgs.put(""entities"", entityList); <line13> OutputStream targetOut = new FileOutputStream(target); <line14> template.process(templateArgs, new OutputStreamWriter(targetOut, Charset.forName(""UTF-8""))); <line15> targetOut.close(); <line16> } <line17> } <line18> "	"<line16>    logger.info(""generated "" + target);"	task4	
public class A { <line0> @Override <line1> protected void onWrite( <line2> DataObjectModification<ResolvedPolicy> rootNode, <line3> InstanceIdentifier<ResolvedPolicy> rootIdentifier) { <line4> ResolvedPolicy resolvedPolicy = rootNode.getDataAfter(); <line5> Map<InstanceIdentifier<Classifier>, Classifier> classifierByIid = <line6> resolveClassifiers(resolvedPolicy, rootIdentifier); <line7> for (Entry<InstanceIdentifier<Classifier>, Classifier> classifierEntry : <line8> classifierByIid.entrySet()) { <line9> ofStatsManager.pullStatsForClassifier(classifierEntry.getKey(), classifierEntry.getValue()); <line10> } <line11> } <line12> } <line13> 	"<line9>      LOG.trace(""New classifier created: {}\n{}"", classifierEntry.getKey(), classifierEntry.getValue());"	task4	
public class A { <line0> @Override <line1> public RemoteClient select(List<RemoteClient> clients, StreamData streamData) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> return clients.get(0); <line5> } <line6> } <line7> 	"<line3>      LOGGER.debug(""clients size: {}"", clients.size());"	task4	
public class A { <line0> @Override <line1> public void log(JobLogPo jobLogPo) { <line2> } <line3> } <line4> 	<line2>    LOGGER.info(JSON.toJSONString(jobLogPo));	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void createContainer( <line3> String id, KieContainerInstance kieContainerInstance, Map<String, Object> parameters) { <line4> if (!initialized) { <line5> return; <line6> } <line7> List<Message> messages = <line8> (List<Message>) parameters.get(KieServerConstants.KIE_SERVER_PARAM_MESSAGES); <line9> try { <line10> DeployedUnit deployedUnit = deploymentService.getDeployedUnit(id); <line11> if (deployedUnit != null) { <line12> String kieBaseName = <line13> ((KModuleDeploymentUnit) deployedUnit.getDeploymentUnit()).getKbaseName(); <line14> KieContainer kieContainer = kieContainerInstance.getKieContainer(); <line15> imageReferences.putIfAbsent(id, new ImageReference(kieContainer, kieBaseName)); <line16> formRendererBase.indexDeploymentForms(id); <line17> } <line18> } catch (Exception e) { <line19> messages.add( <line20> new Message( <line21> Severity.WARN, <line22> ""Unable to create image reference for container "" <line23> + id <line24> + "" by extension "" <line25> + this <line26> + "" due to "" <line27> + e.getMessage())); <line28> } <line29> } <line30> } <line31> "	"<line28>      logger.warn(""Unable to create image reference for container {} due to {}"", id, e.getMessage(), e);"	task4	
public class A { <line0> @Override <line1> public BuildSetTask build( <line2> BuildConfigurationSet buildConfigurationSet, User user, BuildOptions buildOptions) { <line3> return Mockito.mock(BuildSetTask.class); <line4> } <line5> } <line6> 	"<line3>    logger.warn(""Invoking unimplemented method build"");"	task4	
public class A { <line0> public PreparedTickler loadClass(String className) { <line1> PreparedTickler pt = null; <line2> ClassLoader cl = Thread.currentThread().getContextClassLoader(); <line3> try { <line4> pt = (PreparedTickler) cl.loadClass(className).newInstance(); <line5> } catch (Exception e) { <line6> } <line7> return pt; <line8> } <line9> } <line10> 	"<line6>      log.warn(""Warning"", e);"	task4	
public class A { <line0> public void stop() { <line1> running = false; <line2> close(); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""{} stopped"", this);"	task4	
public class A { <line0> void unblockTo(Address address) { <line1> LockPair lockPair = getLockPair(address); <line2> lockPair.unblockOutgoing(); <line3> } <line4> } <line5> 	"<line1>    LOGGER.info(""Unblocked messages to "" + address);"	task4	
public class A { <line0> public static Serializable getSerializable(int type, String value) { <line1> if (type == BOOLEAN) { <line2> return GetterUtil.getBoolean(value); <line3> } else if (type == BOOLEAN_ARRAY) { <line4> return new Boolean[] {GetterUtil.getBoolean(value)}; <line5> } else if (type == DATE) { <line6> try { <line7> DateFormat dateFormat = DateFormatFactoryUtil.getDateTime(LocaleUtil.getDefault()); <line8> return dateFormat.parse(value); <line9> } catch (Exception exception) { <line10> if (log.isWarnEnabled()) { <line11> } <line12> } <line13> } else if (type == DATE_ARRAY) { <line14> Serializable dateSerializable = getSerializable(DATE, value); <line15> if (dateSerializable instanceof Date) { <line16> return new Date[] {(Date) dateSerializable}; <line17> } <line18> } else if (type == DOUBLE) { <line19> return GetterUtil.getDouble(value); <line20> } else if (type == DOUBLE_ARRAY) { <line21> return new double[] {GetterUtil.getDouble(value)}; <line22> } else if (type == FLOAT) { <line23> return GetterUtil.getFloat(value); <line24> } else if (type == FLOAT_ARRAY) { <line25> return new float[] {GetterUtil.getFloat(value)}; <line26> } else if (type == INTEGER) { <line27> return GetterUtil.getInteger(value); <line28> } else if (type == INTEGER_ARRAY) { <line29> return new int[] {GetterUtil.getInteger(value)}; <line30> } else if (type == LONG) { <line31> return GetterUtil.getLong(value); <line32> } else if (type == LONG_ARRAY) { <line33> return new long[] {GetterUtil.getLong(value)}; <line34> } else if (type == NUMBER) { <line35> return GetterUtil.getNumber(value); <line36> } else if (type == NUMBER_ARRAY) { <line37> return new Number[] {GetterUtil.getNumber(value)}; <line38> } else if (type == SHORT) { <line39> return GetterUtil.getShort(value); <line40> } else if (type == SHORT_ARRAY) { <line41> return new short[] {GetterUtil.getShort(value)}; <line42> } else if (type == STRING_ARRAY) { <line43> return new String[] {value}; <line44> } <line45> return value; <line46> } <line47> } <line48> 	"<line11>          log.warn(""Unable to parse date "" + value, exception);"	task4	
public class A { <line0> public String getHomePath() { <line1> try { <line2> return env.getServerHome().getCanonicalPath(); <line3> } catch (IOException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	"<line4>      log.error(""Cannot get home path"");"	task4	
"public class A { <line0> @Override <line1> public void doFlush( <line2> boolean xa, String name, final String flushOp, final AsyncCallback<Boolean> callback) { <line3> String parentAddress = xa ? ""xa-data-source"" : ""data-source""; <line4> AddressBinding address = poolMetaData.getAddress(); <line5> ModelNode operation = address.asResource(baseadress.getAdress(), parentAddress, name); <line6> operation.get(OP).set(flushOp); <line7> dispatcher.execute( <line8> new DMRAction(operation), <line9> new AsyncCallback<DMRResponse>() { <line10> @Override <line11> public void onFailure(Throwable caught) { <line12> callback.onFailure(caught); <line13> } <line14>  <line15> @Override <line16> public void onSuccess(DMRResponse result) { <line17> ModelNode response = result.get(); <line18> boolean failure = response.isFailure(); <line19> callback.onSuccess(!failure); <line20> } <line21> }); <line22> } <line23> } <line24> "	"<line19>            Log.info(""Successfully executed flush operation ':"" + flushOp + ""'"");"	task4	
"public class A { <line0> public static String getVersion() { <line1> Properties releaseProperties = new Properties(); <line2> try { <line3> InputStream in = BalancerRunner.class.getResourceAsStream(""release.properties""); <line4> if (in != null) { <line5> releaseProperties.load(in); <line6> in.close(); <line7> String releaseVersion = releaseProperties.getProperty(RELEASE_VERSION); <line8> String releaseName = releaseProperties.getProperty(RELEASE_NAME); <line9> String releaseDate = releaseProperties.getProperty(RELEASE_DATE); <line10> String releaseRevision = releaseProperties.getProperty(RELEASE_REVISION); <line11> return ""Release ID: ("" <line12> + releaseName <line13> + "") Load Balancer "" <line14> + releaseVersion <line15> + "" (build: Git Hash="" <line16> + releaseRevision <line17> + "" date="" <line18> + releaseDate <line19> + "")""; <line20> } <line21> } catch (Exception e) { <line22> } <line23> return null; <line24> } <line25> } <line26> "	"<line22>      logger.warn(""Unable to extract the version of Restcomm Load Balancer currently running"", e);"	task4	
"public class A { <line0> private void init(Console console) { <line1> try { <line2> checkForToken(console); <line3> setResourceLocation(tokenFile.getCanonicalPath()); <line4> salt = ""Ge0W@v3-Ro0t-K3y"".getBytes(""UTF-8""); <line5> generateRootKeyFromToken(); <line6> } catch (final Throwable t) { <line7> } <line8> } <line9> } <line10> "	<line7>      LOGGER.error(t.getLocalizedMessage(), t);	task4	
public class A { <line0> private boolean shouldFailFast(RunState state, Optional<Integer> exitCode) { <line1> if (exitCode.isPresent() && exitCode.orElseThrow() == FAIL_FAST_EXIT_CODE) { <line2> return true; <line3> } <line4> var workflow = workflows.get().get(state.workflowInstance().workflowId()); <line5> if (workflow == null) { <line6> return false; <line7> } <line8> return workflow <line9> .configuration() <line10> .retryCondition() <line11> .map(s -> !retryConditionMet(state, exitCode, s)) <line12> .orElse(false); <line13> } <line14> } <line15> 	"<line6>      LOG.debug(""Workflow {} does not exist possibly due to stale workflow cache"",state.workflowInstance().workflowId().toKey());"	task4	
public class A { <line0> public static void close(final ResultSet resultSet) { <line1> if (resultSet == null) { <line2> return; <line3> } <line4> try { <line5> resultSet.close(); <line6> } catch (final SQLException e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOGGER.warn(""Caught exception while closing result set '"" + resultSet + ""', ignoring."", e);"	task4	
"public class A { <line0> @Test <line1> public void testKerbFileAccess() <line2> throws InterruptedException, LifecycleException, EventDeliveryException, IOException { <line3> final String fileName = ""FlumeData""; <line4> final long rollCount = 5; <line5> final long batchSize = 2; <line6> String newPath = testPath + ""/singleBucket""; <line7> String kerbConfPrincipal = ""user1/localhost@EXAMPLE.COM""; <line8> String kerbKeytab = ""/usr/lib/flume/nonexistkeytabfile""; <line9> Configuration conf = new Configuration(); <line10> conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION, ""kerberos""); <line11> UserGroupInformation.setConfiguration(conf); <line12> Context context = new Context(); <line13> context.put(""hdfs.path"", newPath); <line14> context.put(""hdfs.filePrefix"", fileName); <line15> context.put(""hdfs.rollCount"", String.valueOf(rollCount)); <line16> context.put(""hdfs.batchSize"", String.valueOf(batchSize)); <line17> context.put(""hdfs.kerberosPrincipal"", kerbConfPrincipal); <line18> context.put(""hdfs.kerberosKeytab"", kerbKeytab); <line19> try { <line20> Configurables.configure(sink, context); <line21> Assert.fail(""no exception thrown""); <line22> } catch (IllegalArgumentException expected) { <line23> Assert.assertTrue(expected.getMessage().contains(""Keytab is not a readable file"")); <line24> } finally { <line25> conf.set(CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION, ""simple""); <line26> UserGroupInformation.setConfiguration(conf); <line27> } <line28> } <line29> } <line30> "	"<line3>    LOG.debug(""Starting testKerbFileAccess() ..."");"	task4	
public class A { <line0> @Test <line1> public void get() { <line2> Run run = ESSuiteTest.runDao.get(ESSuiteTest.RUN_ID_3); <line3> assertEquals(ESSuiteTest.COMMIT_ID_3, run.getCommitId()); <line4> assertEquals(ESSuiteTest.RUNNER_HOSTNAME_1, run.getRunner()); <line5> assertEquals(ESSuiteTest.RUN_DURATION, (Long) run.getActualTime()); <line6> } <line7> } <line8> 	"<line2>    LOG.info(""\n===RunDaoTest.get===\n"");"	task4	
"public class A { <line0> private void checkForFailures() throws IOException { <line1> if (failures.isEmpty()) { <line2> return; <line3> } <line4> StringBuilder logEntry = new StringBuilder(); <line5> int i = 0; <line6> List<BigtableWriteException> suppressed = Lists.newArrayList(); <line7> for (; i < 10 && !failures.isEmpty(); ++i) { <line8> BigtableWriteException exc = failures.remove(); <line9> logEntry.append(""\n"").append(exc.getMessage()); <line10> if (exc.getCause() != null) { <line11> logEntry.append("": "").append(exc.getCause().getMessage()); <line12> } <line13> suppressed.add(exc); <line14> } <line15> String message = <line16> String.format( <line17> ""At least %d errors occurred writing to Bigtable. First %d errors: %s"", <line18> i + failures.size(), i, logEntry.toString()); <line19> IOException exception = new IOException(message); <line20> for (BigtableWriteException e : suppressed) { <line21> exception.addSuppressed(e); <line22> } <line23> throw exception; <line24> } <line25> } <line26> "	<line19>    LOG.error(message);	task4	
public class A { <line0> @Override <line1> public Set<OWLClassExpression> refine(OWLClassExpression concept) { <line2> ELDescriptionTree tree = new ELDescriptionTree(rs, concept); <line3> List<ELDescriptionTree> refinementTrees = refine(tree); <line4> Set<OWLClassExpression> refinements = new HashSet<>(); <line5> for (ELDescriptionTree refinementTree : refinementTrees) { <line6> refinements.add(refinementTree.transformToClassExpression()); <line7> } <line8> return refinements; <line9> } <line10> } <line11> 	"<line2>    logger.trace(""refining "" + concept);"	task4	
public class A { <line0> public AbstractFeatureEntity getFeature(String identifier, Session session) { <line1> Criteria criteria = <line2> getDefaultCriteria(session) <line3> .add(Restrictions.eq(AbstractFeatureEntity.IDENTIFIER, identifier)); <line4> return (AbstractFeatureEntity) criteria.uniqueResult(); <line5> } <line6> } <line7> 	"<line4>    LOGGER.trace(""QUERY getFeature(identifier): {}"", HibernateHelper.getSqlString(criteria));"	task4	
public class A { <line0> @Transactional <line1> public void step0_prepareTargetStoreForJobDatasets(@NonNull UUID jobId, @NonNull UserInfo user) { <line2> DataUploadJob job = findAndCheckPublishStatusIsRunning(jobId); <line3> backendService.prepareBackend(job, user); <line4> job.getPublishableDatasets() <line5> .forEach( <line6> dset -> { <line7> dset.setPublishStatus(JobStatus.RUNNING); <line8> if (dset.getPublishing() == null) { <line9> dset.setPublishing(new PublishSettings()); <line10> } <line11> }); <line12> save(job); <line13> } <line14> } <line15> 	"<line2>    log.info(""Publish {}: Prepare target store for uploaded datasets"", jobId);"	task4	
"public class A { <line0> @Override <line1> public void configure() { <line2> from(from) <line3> .routeId(""testNegativeAcknowledge:myRoute"") <line4> .to(to) <line5> .process( <line6> exchange -> { <line7> if (processed.compareAndSet(false, true)) { <line8> PulsarMessageReceipt receipt = <line9> (PulsarMessageReceipt) <line10> exchange.getIn().getHeader(PulsarMessageHeaders.MESSAGE_RECEIPT); <line11> receipt.negativeAcknowledge(); <line12> } else { <line13> PulsarMessageReceipt receipt = <line14> (PulsarMessageReceipt) <line15> exchange.getIn().getHeader(PulsarMessageHeaders.MESSAGE_RECEIPT); <line16> receipt.acknowledge(); <line17> } <line18> }); <line19> } <line20> } <line21> "	"<line7>              LOGGER.info(""Processing message {}"", exchange.getIn().getBody());"	task4	
public class A { <line0> private boolean contactExists(Folder folder, ServerId serverId) { <line1> try { <line2> AddressBookId addressBookId = folder.getTypedBackendId(); <line3> return getBookClient() <line4> .getContactFromId(getAccessToken(), addressBookId.getId(), serverId.getItemId()) <line5> != null; <line6> } catch (ServerFault | ContactNotFoundException e) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	"<line7>      logger.info(""This contact has not been found by obm-sync"", e);"	task4	
public class A { <line0> public static void writeLong(Long value, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> out.writeLong(value); <line5> } <line6> } <line7> 	"<line3>      logger.trace(LogMarker.SERIALIZER_VERBOSE, ""Writing Long {}"", value);"	task4	
"public class A { <line0> @Override <line1> protected void startJsonRpcServer(RomServerJsonRpcHandler jsonRpcHandler) { <line2> handler = jsonRpcHandler; <line3> Properties properties = new Properties(); <line4> String port = getPort(); <line5> properties.put(""server.port"", port); <line6> SpringApplication application = new SpringApplication(BootTestApplication.class); <line7> application.setDefaultProperties(properties); <line8> context = application.run(); <line9> } <line10> } <line11> "	"<line8>    log.debug(""Creating server in port: "" + port);"	task4	
public class A { <line0> public void put(StoragePath storagePath, Source source) throws AssetStoreException { <line1> final File origin = getFileFromWorkspace(source); <line2> String objectName = buildObjectName(origin, storagePath); <line3> String objectVersion = null; <line4> try { <line5> AwsUploadOperationResult result = uploadObject(origin, objectName); <line6> objectName = result.getObjectName(); <line7> objectVersion = result.getObjectVersion(); <line8> } catch (Exception e) { <line9> throw new AssetStoreException(e); <line10> } <line11> try { <line12> database.storeMapping(storagePath, objectName, objectVersion); <line13> } catch (AwsAssetDatabaseException e) { <line14> throw new AssetStoreException(e); <line15> } <line16> } <line17> } <line18> 	"<line12>      logger.debug(""Adding AWS {} mapping to database: {} points to {}, object version {}"",getStoreType(),storagePath,objectName,objectVersion);"	task4	
"public class A { <line0> @Override <line1> public CPOptionValue findByC_K(long CPOptionId, String key) throws NoSuchCPOptionValueException { <line2> CPOptionValue cpOptionValue = fetchByC_K(CPOptionId, key); <line3> if (cpOptionValue == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""CPOptionId=""); <line7> sb.append(CPOptionId); <line8> sb.append("", key=""); <line9> sb.append(key); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchCPOptionValueException(sb.toString()); <line14> } <line15> return cpOptionValue; <line16> } <line17> } <line18> "	<line12>        log.debug(sb.toString());	task4	
public class A { <line0> protected AuthenticationInfo queryForAuthenticationInfo( <line1> AuthenticationToken token, LdapContextFactory ldapContextFactory) throws NamingException { <line2> Object principal = token.getPrincipal(); <line3> Object credentials = token.getCredentials(); <line4> principal = getLdapPrincipal(token); <line5> LdapContext ctx = null; <line6> try { <line7> ctx = ldapContextFactory.getLdapContext(principal, credentials); <line8> return createAuthenticationInfo(token, principal, credentials, ctx); <line9> } finally { <line10> LdapUtils.closeContext(ctx); <line11> } <line12> } <line13> } <line14> 	"<line4>    log.debug(""Authenticating user '{}' through LDAP"", principal);"	task4	
public class A { <line0> @Override <line1> protected void doInTransactionWithoutResult(TransactionStatus status) { <line2> emailDao.populateEmailHash(email, correctedEmailHash); <line3> } <line4> } <line5> 	"<line3>    LOG.info(""Fixed: "" + orcid + "" "" + correctedEmailHash);"	task4	
"public class A { <line0> public static List<FileShortcut> getFileShortcuts(HttpServletRequest httpServletRequest) <line1> throws PortalException { <line2> long[] fileShortcutIds = ParamUtil.getLongValues(httpServletRequest, ""rowIdsDLFileShortcut""); <line3> List<FileShortcut> fileShortcuts = new ArrayList<>(); <line4> for (long fileShortcutId : fileShortcutIds) { <line5> try { <line6> fileShortcuts.add(DLAppServiceUtil.getFileShortcut(fileShortcutId)); <line7> } catch (NoSuchFileShortcutException noSuchFileShortcutException) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> return fileShortcuts; <line13> } <line14> } <line15> "	<line9>          log.debug(noSuchFileShortcutException, noSuchFileShortcutException);	task4	
"public class A { <line0> public MessageResponse handleMissingRequestedArtifact( <line1> final URI requestedArtifact, <line2> final URI transferContract, <line3> final URI issuerConnector, <line4> final URI messageId) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> return ErrorResponse.withDefaultHeader( <line8> RejectionReason.BAD_PARAMETERS, <line9> ""Missing requested artifact."", <line10> connectorService.getConnectorId(), <line11> connectorService.getOutboundModelVersion()); <line12> } <line13> } <line14> "	"<line6>      log.debug(""Missing requested artifact. [artifact=({}), contract=({}), ""+ ""issuer=({}), messageId=({})]"",requestedArtifact,transferContract,issuerConnector,messageId);"	task4	
public class A { <line0> private void notifyListeners( <line1> Identifiable identifiable, <line2> String attribute, <line3> String variantId, <line4> Object oldValue, <line5> Object newValue) { <line6> for (NetworkListener listener : listeners) { <line7> try { <line8> listener.onUpdate(identifiable, attribute, variantId, oldValue, newValue); <line9> } catch (Exception t) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line10>        LOGGER.error(t.toString(), t);	task4	
"public class A { <line0> @Test(groups = {""standalone"", ""default_provider""}) <line1> public void relativePathRedirectTest() throws Throwable { <line2> isSet.getAndSet(false); <line3> AsyncHttpClientConfig cg = new AsyncHttpClientConfig.Builder().setFollowRedirect(true).build(); <line4> try (AsyncHttpClient client = getAsyncHttpClient(cg)) { <line5> String redirectTarget = ""bar/test1""; <line6> String destinationUrl = new URI(getTargetUrl()).resolve(redirectTarget).toString(); <line7> Response response = <line8> client.prepareGet(getTargetUrl()).setHeader(""X-redirect"", redirectTarget).execute().get(); <line9> assertNotNull(response); <line10> assertEquals(response.getStatusCode(), 200); <line11> assertEquals(response.getUri().toString(), destinationUrl); <line12> } <line13> } <line14> } <line15> "	"<line12>      log.debug(""{} was redirected to {}"", redirectTarget, destinationUrl);"	task4	
public class A { <line0> public static void main(String[] args) throws Exception { <line1> Thread.setDefaultUncaughtExceptionHandler(new TajoUncaughtExceptionHandler()); <line2> StringUtils.startupShutdownMessage(TajoMaster.class, args, LOG); <line3> try { <line4> TajoMaster master = new TajoMaster(); <line5> TajoConf conf = new TajoConf(); <line6> master.init(conf); <line7> master.start(); <line8> } catch (Throwable t) { <line9> System.exit(-1); <line10> } <line11> } <line12> } <line13> 	"<line9>      LOG.fatal(""Error starting TajoMaster"", t);"	task4	
public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap moveFileEntryToTrash( <line1> long fileEntryId) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.repository.model.FileEntry returnValue = <line4> DLTrashServiceUtil.moveFileEntryToTrash(fileEntryId); <line5> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>      log.error(exception, exception);	task4	
public class A { <line0> String getMetacardIdFromReference( <line1> String referenceKey, <line2> String catalogOperation, <line3> FileSystemPersistenceProvider productToMetacardIdMap) { <line4> String ref = getShaFor(referenceKey); <line5> if (!productToMetacardIdMap.loadAllKeys().contains(ref)) { <line6> return null; <line7> } <line8> return (String) productToMetacardIdMap.loadFromPersistence(ref); <line9> } <line10> } <line11> 	"<line6>      LOGGER.debug(""Received a [{}] operation, but no mapped metacardIds were available for product [{}]."",catalogOperation,referenceKey);"	task4	
public class A { <line0> @Override <line1> protected void doStop() throws Exception { <line2> super.doStop(); <line3> if (createdVertx && vertx != null) { <line4> vertx.close(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOG.info(""Stopping Vertx {}"", vertx);"	task4	
public class A { <line0> @Override <line1> public List<EducationLevelInfo> getEducationLevelList() { <line2> List<EducationLevelInfo> infoList = new LinkedList<EducationLevelInfo>(); <line3> List<EducationLevel> levelsDb = educationLevelDao.getAllRecords(); <line4> for (EducationLevel o : levelsDb) { <line5> EducationLevelInfo i = new EducationLevelInfo(); <line6> i.setEducationLevelId(o.getEducationLevelId()); <line7> i.setTitle(o.getTitle()); <line8> i.setDefaultNumber(o.getDefaultNumber()); <line9> infoList.add(i); <line10> } <line11> return infoList; <line12> } <line13> } <line14> 	"<line11>    log.debug(""User "" + personDao.getLoggedPerson().getEmail() + "" retrieved list of education levels."");"	task4	
public class A { <line0> @Override <line1> public void run(String... args) throws Exception { <line2> if (args.length != ARGS_LENGTH) { <line3> return; <line4> } <line5> zookeeperOperator.remove(args[0]); <line6> zookeeperOperator.close(); <line7> } <line8> } <line9> 	"<line3>      logger.error(""Usage: <node>"");"	task4	
"public class A { <line0> public void update(Map<String, Object> config) { <line1> Object cSystemId = config.get(""system.id""); <line2> if (cSystemId == null || cSystemId.toString().isEmpty()) { <line3> systemId = InstanceUUID.get(); <line4> } else { <line5> systemId = cSystemId.toString(); <line6> } <line7> Object rootUrlObj = config.get(""openhab.rootUrl""); <line8> if (rootUrlObj != null) { <line9> rootUrl = String.valueOf(rootUrlObj); <line10> if (!rootUrl.endsWith(""/"")) { <line11> rootUrl += ""/""; <line12> } <line13> } <line14> } <line15> } <line16> "	"<line14>    logger.info(""Configuration updated"");"	task4	
"public class A { <line0> @Test <line1> public void skimPomForExistingRepoAndAddItInGroup() throws Exception { <line2> RemoteRepository repo = new RemoteRepository(REPO, server.formatUrl(REPO)); <line3> repo.setAllowReleases(Boolean.TRUE); <line4> repo.setAllowSnapshots(Boolean.FALSE); <line5> repo = client.stores().create(repo, ""Pre stored remote repo"", RemoteRepository.class); <line6> final StoreKey remoteRepoKey = repo.getKey(); <line7> final PomRef ref = <line8> loadPom(""one-repo"", Collections.singletonMap(""one-repo.url"", server.formatUrl(REPO))); <line9> server.expect(""HEAD"", server.formatUrl(REPO, ""/""), 200, (String) null); <line10> server.expect(server.formatUrl(TEST_REPO, ref.path), 200, ref.pom); <line11> final StoreKey pubGroupKey = <line12> new StoreKey(MavenPackageTypeDescriptor.MAVEN_PKG_KEY, StoreType.group, PUBLIC); <line13> Group g = client.stores().load(pubGroupKey, Group.class); <line14> assertThat( <line15> ""Group membership should not contain implied before getting pom."", <line16> g.getConstituents().contains(remoteRepoKey), <line17> equalTo(false)); <line18> final InputStream stream = client.content().get(pubGroupKey, ref.path); <line19> final String downloaded = IOUtils.toString(stream); <line20> IOUtils.closeQuietly(stream); <line21> System.out.println(""Waiting 5s for events to run.""); <line22> Thread.sleep(5000); <line23> g = client.stores().load(pubGroupKey, Group.class); <line24> assertThat( <line25> ""Group membership does not contain implied repository"", <line26> g.getConstituents().contains(remoteRepoKey), <line27> equalTo(true)); <line28> repo = <line29> client <line30> .stores() <line31> .load( <line32> new StoreKey(MavenPackageTypeDescriptor.MAVEN_PKG_KEY, StoreType.remote, TEST_REPO), <line33> RemoteRepository.class); <line34> String metadata = repo.getMetadata(ImpliedRepoMetadataManager.IMPLIED_STORES); <line35> assertThat( <line36> ""Reference to repositories implied by POMs in this repo is missing from metadata."", <line37> metadata.contains(""remote:"" + REPO), <line38> equalTo(true)); <line39> repo = client.stores().load(remoteRepoKey, RemoteRepository.class); <line40> metadata = repo.getMetadata(ImpliedRepoMetadataManager.IMPLIED_BY_STORES); <line41> assertThat( <line42> ""Backref to repo with pom that implies this repo is missing from metadata."", <line43> metadata.contains(""remote:"" + TEST_REPO), <line44> equalTo(true)); <line45> } <line46> } <line47> "	"<line18>    logger.debug(""Start fetching pom!"");"	task4	
public class A { <line0> private void maybeUpdateLastAuthenticationTimestamp(ObjectContext context, User user) { <line1> long millisNow = Clock.systemUTC().millis(); <line2> long millisStored = <line3> Optional.ofNullable(user.getLastAuthenticationTimestamp()) <line4> .map(Timestamp::getTime) <line5> .orElse(0L); <line6> if (Math.abs(millisNow - millisStored) > TimeUnit.MILLISECONDS.convert(1, TimeUnit.HOURS)) { <line7> user.setLastAuthenticationTimestamp(new java.sql.Timestamp(millisNow)); <line8> context.commitChanges(); <line9> } <line10> } <line11> } <line12> 	"<line9>      LOGGER.debug(""did store last authenticated timestamp for user [{}]"", user.getNickname());"	task4	
"public class A { <line0> @Override <line1> public String getURLString( <line2> com.agiletec.aps.system.services.url.PageURL pageUrl, RequestContext reqCtx) { <line3> try { <line4> if (!(pageUrl instanceof PageURL)) { <line5> return super.getURLString(pageUrl, reqCtx); <line6> } <line7> Lang lang = this.extractLang(pageUrl, reqCtx); <line8> IPage destPage = this.extractDestPage(pageUrl, reqCtx); <line9> String friendlyCode = ((PageURL) pageUrl).getFriendlyCode(); <line10> if (StringUtils.isBlank(friendlyCode)) { <line11> friendlyCode = this.extractFriendlyCode(destPage, lang, pageUrl); <line12> } <line13> HttpServletRequest request = (null != reqCtx) ? reqCtx.getRequest() : null; <line14> String url = null; <line15> if (StringUtils.isBlank(friendlyCode)) { <line16> url = super.createURL(destPage, lang, pageUrl.getParams(), pageUrl.isEscapeAmp(), request); <line17> } else { <line18> url = <line19> this.createFriendlyUrl( <line20> friendlyCode, lang, pageUrl.getParams(), pageUrl.isEscapeAmp(), request); <line21> } <line22> if (null != reqCtx && null != reqCtx.getResponse() && this.useJsessionId()) { <line23> HttpServletResponse resp = reqCtx.getResponse(); <line24> return resp.encodeURL(url.toString()); <line25> } else { <line26> return url; <line27> } <line28> } catch (Exception e) { <line29> throw new RuntimeException(""Error creating url"", e); <line30> } <line31> } <line32> } <line33> "	"<line29>      logger.error(""Error creating url"", e);"	task4	
"public class A { <line0> private List<AstrixServiceRegistryEntry> getServiceProvidersForConsumer( <line1> List<AstrixServiceRegistryEntry> entries, ServiceConsumerProperties serviceConsumer) { <line2> List<AstrixServiceRegistryEntry> activeServices = new ArrayList<>(entries.size()); <line3> String consumerZone = serviceConsumer.getProperty(ServiceConsumerProperties.CONSUMER_ZONE); <line4> for (AstrixServiceRegistryEntry entry : entries) { <line5> if (""true"".equals(entry.getServiceProperties().get(ServiceProperties.PUBLISHED))) { <line6> activeServices.add(entry); <line7> continue; <line8> } <line9> if (!Objects.equals( <line10> consumerZone, entry.getServiceProperties().get(ServiceProperties.SERVICE_ZONE))) { <line11> continue; <line12> } <line13> activeServices.add(entry); <line14> } <line15> return activeServices; <line16> } <line17> } <line18> "	"<line11>        log.debug(""Discarding service-provider={}, consumer={}"",entry.getServiceProperties(),serviceConsumer);"	task4	
"public class A { <line0> @Override <line1> public List<Page> listPagesInCourse(String courseId) throws IOException { <line2> String url = buildCanvasUrl(""courses/"" + courseId + ""/pages"", Collections.emptyMap()); <line3> return getListFromCanvas(url); <line4> } <line5> } <line6> "	"<line2>    LOG.debug(""fetching all pages for course "" + courseId);"	task4	
public class A { <line0> private void searchLocation(Request request) { <line1> try { <line2> Response response = searchLocation(request.getRequest(), request.getRequestContext()); <line3> sender().tell(response, self()); <line4> SearchDTO searchDto = Util.createSearchDto(request.getRequest()); <line5> String[] types = {ProjectUtil.EsType.location.getTypeName()}; <line6> generateSearchTelemetryEvent(searchDto, types, response.getResult(), request.getContext()); <line7> } catch (Exception ex) { <line8> sender().tell(ex, self()); <line9> } <line10> } <line11> } <line12> 	<line8>      logger.error(request.getRequestContext(), ex.getMessage(), ex);	task4	
public class A { <line0> private CompletionStage<Boolean> fetchRebalancingStatusFromCoordinator(int attempts) { <line1> if (transport.isCoordinator()) { <line2> return CompletableFutures.completedTrue(); <line3> } <line4> ReplicableCommand command = new RebalanceStatusRequestCommand(); <line5> Address coordinator = transport.getCoordinator(); <line6> return helper <line7> .executeOnCoordinator(transport, command, getGlobalTimeout() / INITIAL_CONNECTION_ATTEMPTS) <line8> .handle( <line9> (rebalancingStatus, throwable) -> { <line10> if (throwable == null) <line11> return CompletableFuture.completedFuture( <line12> rebalancingStatus != RebalancingStatus.SUSPENDED); <line13> if (attempts == 1 || !(throwable instanceof TimeoutException)) { <line14> log.errorReadingRebalancingStatus(coordinator, throwable); <line15> return CompletableFutures.completedTrue(); <line16> } <line17> return fetchRebalancingStatusFromCoordinator(attempts - 1); <line18> }) <line19> .thenCompose(Function.identity()); <line20> } <line21> } <line22> 	"<line17>              log.debug(""Timed out waiting for rebalancing status from coordinator, trying again"");"	task4	
public class A { <line0> @Override <line1> public User getUserByName(String userName) throws FtpException { <line2> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line3> org.structr.web.entity.User structrUser = getStructrUser(userName); <line4> tx.success(); <line5> if (structrUser != null) { <line6> return new StructrFtpUser(securityContext, structrUser); <line7> } else { <line8> return null; <line9> } <line10> } catch (FrameworkException fex) { <line11> } <line12> return null; <line13> } <line14> } <line15> 	"<line11>      logger.error(""Unable to get user by its name"", fex);"	task4	
public class A { <line0> @Override <line1> public int size() { <line2> int size = 0; <line3> for (PartitionedRegion prQ : this.userRegionNameToShadowPRMap.values()) { <line4> if (logger.isDebugEnabled()) { <line5> } <line6> size += prQ.size(); <line7> } <line8> return size + sender.getTmpQueuedEventSize(); <line9> } <line10> } <line11> 	"<line5>        logger.debug(""The name of the queue region is {} and the size is {}. keyset size is {}"",prQ.getName(),prQ.size(),prQ.keys().size());"	task4	
"public class A { <line0> @Override <line1> protected List<LogEntry> queryAuditEntries( <line2> CoreSession session, <line3> SynchronizationRoots activeRoots, <line4> Set<String> collectionSyncRootMemberIds, <line5> long lowerBound, <line6> long upperBound, <line7> int limit) { <line8> List<LogEntry> entries = <line9> queryESAuditEntries( <line10> session, activeRoots, collectionSyncRootMemberIds, lowerBound, upperBound, limit); <line11> List<LogEntry> postFilteredEntries = new ArrayList<>(); <line12> String principalName = session.getPrincipal().getName(); <line13> for (LogEntry entry : entries) { <line14> ExtendedInfo impactedUserInfo = entry.getExtendedInfos().get(""impactedUserName""); <line15> if (impactedUserInfo != null <line16> && !principalName.equals(impactedUserInfo.getValue(String.class))) { <line17> continue; <line18> } <line19> postFilteredEntries.add(entry); <line20> } <line21> return postFilteredEntries; <line22> } <line23> } <line24> "	"<line19>      log.debug(""Change detected: {}"", entry);"	task4	
public class A { <line0> @Override <line1> protected void updatePortlet(String oldRootPortletId, String newRootPortletId) throws Exception { <line2> try { <line3> updateResourcePermission(oldRootPortletId, newRootPortletId, true); <line4> updateInstanceablePortletPreferences(oldRootPortletId, newRootPortletId); <line5> } catch (Exception exception) { <line6> if (log.isWarnEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>        log.warn(exception, exception);	task4	
public class A { <line0> @Override <line1> public Response toResponse(SelfManagedOnlyException exception) { <line2> return Response.status(Status.FORBIDDEN) <line3> .entity(new SelfManagedOnlyExceptionInfo(Status.FORBIDDEN, exception)) <line4> .build(); <line5> } <line6> } <line7> 	"<line2>    LOG.error(""Only self managed allowed!"", exception);"	task4	
public class A { <line0> @Override <line1> public void close() throws Exception { <line2> if (coordinator != null) { <line3> coordinator.beginShutdown(false); <line4> } <line5> for (Agent agent : agents.values()) { <line6> agent.beginShutdown(); <line7> } <line8> for (Agent agent : agents.values()) { <line9> agent.waitForShutdown(); <line10> } <line11> if (coordinator != null) { <line12> coordinator.waitForShutdown(); <line13> } <line14> } <line15> } <line16> 	"<line2>    log.info(""Closing MiniTrogdorCluster."");"	task4	
"public class A { <line0> void augmentCollectionEntryForSpecialCollections( <line1> final ObjStat objStat, <line2> final String effectiveAbsolutePath, <line3> final CollectionAndDataObjectListingEntry entry) { <line4> if (objStat.getSpecColType() == SpecColType.LINKED_COLL) { <line5> entry.setSpecialObjectPath(objStat.getObjectPath()); <line6> CollectionAndPath collectionAndPathForAbsPath = <line7> MiscIRODSUtils.separateCollectionAndPathFromGivenAbsolutePath(entry.getPathOrName()); <line8> if (entry.isCollection()) { <line9> entry.setPathOrName( <line10> objStat.getAbsolutePath() + ""/"" + collectionAndPathForAbsPath.getChildName()); <line11> entry.setParentPath(objStat.getAbsolutePath()); <line12> } else { <line13> entry.setParentPath(objStat.getAbsolutePath()); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line5>      log.info(""adjusting paths in entry to reflect linked collection info"");"	task4	
public class A { <line0> public static String format(Object jsonObj) { <line1> ObjectMapper mapper = getDefaultObjectMapper(false); <line2> String jsonText = null; <line3> try { <line4> jsonText = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObj); <line5> } catch (IOException e) { <line6> } <line7> return jsonText; <line8> } <line9> } <line10> 	"<line6>      LOGGER.error(""Failed to transform JSON: "" + e, e);"	task4	
"public class A { <line0> @Test <line1> public void testFolderishCollection2() { <line2> DocumentModel collectionFolder; <line3> DocumentModel collectionSyncRoot; <line4> DocumentModel testDoc; <line5> List<FileSystemItemChange> changes; <line6> try { <line7> collectionFolder = <line8> session.createDocumentModel(FOLDER_1_PATH, COLLECTION_FOLDER, FOLDERISH_COLLECTION); <line9> collectionFolder = session.createDocument(collectionFolder); <line10> collectionManager.addToCollection(collectionFolder, folder1, session); <line11> nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder1, session); <line12> collectionSyncRoot = <line13> collectionManager.createCollection(session, COLLECTION_SYNC_ROOT, null, ""/""); <line14> nuxeoDriveManager.registerSynchronizationRoot( <line15> session.getPrincipal(), collectionSyncRoot, session); <line16> testDoc = session.createDocumentModel(""/"", TEST_DOC, ""File""); <line17> testDoc.setPropertyValue(FILE_CONTENT, new StringBlob(TEST_DOC_CONTENT)); <line18> testDoc = session.createDocument(testDoc); <line19> collectionManager.addToCollection(collectionFolder, testDoc, session); <line20> collectionManager.addToCollection(collectionSyncRoot, testDoc, session); <line21> } finally { <line22> commitAndWaitForAsyncCompletion(); <line23> } <line24> try { <line25> changes = getChanges(session.getPrincipal()); <line26> assertEquals(12, changes.size()); <line27> Set<SimpleFileSystemItemChange> expectedChanges = new HashSet<>(); <line28> expectedChanges.add(new SimpleFileSystemItemChange(testDoc.getId(), ADDED_TO_COLLECTION)); <line29> expectedChanges.add( <line30> new SimpleFileSystemItemChange(collectionSyncRoot.getId(), DOCUMENT_UPDATED)); <line31> expectedChanges.add( <line32> new SimpleFileSystemItemChange(collectionFolder.getId(), DOCUMENT_UPDATED)); <line33> expectedChanges.add(new SimpleFileSystemItemChange(testDoc.getId(), DOCUMENT_CREATED)); <line34> expectedChanges.add( <line35> new SimpleFileSystemItemChange(collectionSyncRoot.getId(), ROOT_REGISTERED)); <line36> expectedChanges.add( <line37> new SimpleFileSystemItemChange(collectionSyncRoot.getId(), DOCUMENT_CREATED)); <line38> expectedChanges.add(new SimpleFileSystemItemChange(folder1.getId(), ROOT_REGISTERED)); <line39> expectedChanges.add(new SimpleFileSystemItemChange(folder1.getId(), ADDED_TO_COLLECTION)); <line40> expectedChanges.add( <line41> new SimpleFileSystemItemChange(collectionFolder.getId(), DOCUMENT_CREATED)); <line42> expectedChanges.add(new SimpleFileSystemItemChange(folder1.getId(), DOCUMENT_CREATED)); <line43> assertTrue( <line44> CollectionUtils.isEqualCollection( <line45> expectedChanges, toSimpleFileSystemItemChanges(changes))); <line46> } finally { <line47> commitAndWaitForAsyncCompletion(); <line48> } <line49> } <line50> } <line51> "	"<line7>      log.trace(""testFolderishCollection2():\n""+ ""Create a folder with the Collection facet (\""collectionFolder\"") inside a folder""+ "" (\""folder1\"");\n""+ ""Add \""folder1\"" to the \""collectionFolder\"" collection;\n""+ ""Register \""folder1\"" as a synchronization root;\n""+ ""Create a collection \""collectionSyncRoot\"" and register it as a synchronization""+ "" root;\n""+ ""Create a document \""testDoc\"" and add it to both collections \""collectionFolder\""""+ "" and \""collectionSyncRoot\"".\n"");"	task4	
"public class A { <line0> private OAuthUser getAuthParams(AuthInfo authInfo, String code, OAuthServer server) <line1> throws IOException, InterruptedException { <line2> String requestInfoUrl = <line3> prepareUrl(server.getRequestInfoUrl(), getParams(server, code, authInfo)); <line4> HttpRequest.Builder builder = <line5> setNoCache(HttpRequest.newBuilder().uri(URI.create(requestInfoUrl))); <line6> if (server.getRequestInfoMethod() == RequestInfoMethod.HEADER) { <line7> builder.header(""Authorization"", ""Bearer "" + authInfo.accessToken); <line8> } else { <line9> builder.method(server.getRequestInfoMethod().name(), BodyPublishers.noBody()); <line10> } <line11> String json = doRequest(builder.build()); <line12> return new OAuthUser(json, server); <line13> } <line14> } <line15> "	"<line12>    log.debug(""User info={}"", json);"	task4	
"public class A { <line0> @RequestMapping(""/adminNotificationView/viewNotificationList.do"") <line1> public ModelAndView viewNotificationList(HttpServletRequest request) { <line2> logger.entry(""begin viewNotificationList()""); <line3> String sucMsg = """"; <line4> String errMsg = """"; <line5> ModelMap map = new ModelMap(); <line6> List<NotificationBO> notificationList = null; <line7> ModelAndView mav = new ModelAndView(""login"", map); <line8> try { <line9> AuditLogEventRequest auditRequest = AuditEventMapper.fromHttpServletRequest(request); <line10> if (null != request.getSession().getAttribute(FdahpStudyDesignerConstants.SUC_MSG)) { <line11> sucMsg = (String) request.getSession().getAttribute(FdahpStudyDesignerConstants.SUC_MSG); <line12> map.addAttribute(FdahpStudyDesignerConstants.SUC_MSG, sucMsg); <line13> request.getSession().removeAttribute(FdahpStudyDesignerConstants.SUC_MSG); <line14> } <line15> if (null != request.getSession().getAttribute(FdahpStudyDesignerConstants.ERR_MSG)) { <line16> errMsg = (String) request.getSession().getAttribute(FdahpStudyDesignerConstants.ERR_MSG); <line17> map.addAttribute(FdahpStudyDesignerConstants.ERR_MSG, errMsg); <line18> request.getSession().removeAttribute(FdahpStudyDesignerConstants.ERR_MSG); <line19> } <line20> notificationList = notificationService.getNotificationList(0, """"); <line21> for (NotificationBO notification : notificationList) { <line22> if (!notification.isNotificationSent() <line23> && notification <line24> .getNotificationScheduleType() <line25> .equals(FdahpStudyDesignerConstants.NOTIFICATION_NOTIMMEDIATE)) { <line26> notification.setCheckNotificationSendingStatus(""Scheduled""); <line27> } else if (!notification.isNotificationSent() <line28> && notification <line29> .getNotificationScheduleType() <line30> .equals(FdahpStudyDesignerConstants.NOTIFICATION_IMMEDIATE)) { <line31> notification.setCheckNotificationSendingStatus(""Sending""); <line32> } else if (notification.isNotificationSent()) { <line33> notification.setCheckNotificationSendingStatus(""Sent""); <line34> } <line35> } <line36> map.addAttribute(""notificationList"", notificationList); <line37> auditLogEventHelper.logEvent(APP_LEVEL_NOTIFICATION_LIST_VIEWED, auditRequest); <line38> mav = new ModelAndView(""notificationListPage"", map); <line39> } catch (Exception e) { <line40> } <line41> logger.exit(""viewNotificationList() - ends""); <line42> return mav; <line43> } <line44> } <line45> "	"<line40>      logger.error(""NotificationController - viewNotificationList() - ERROR "", e);"	task4	
public class A { <line0> @Override <line1> public InstancesInfo getApplicationInstances(CloudApplication app) { <line2> return delegate.getApplicationInstances(app); <line3> } <line4> } <line5> 	<line2>    logger.debug(Messages.GETTING_INSTANCES_OF_APPLICATION_0, app.getName());	task4	
public class A { <line0> private void registerStateInternal( <line1> String id, <line2> String description, <line3> Collection<? extends String> tags, <line4> Collection<? extends String> modules, <line5> Object state) { <line6> if (LOGGER.isDebugEnabled()) { <line7> } <line8> List<String> allModules = New.list(modules); <line9> allModules.addAll(getAlwaysActivateModules()); <line10> addStateToMap(id, description, tags, modules, state); <line11> saveToPreferences(); <line12> } <line13> } <line14> 	"<line7>      LOGGER.debug(""Registering module state with id ["" + id + ""]"");"	task4	
public class A { <line0> @Override <line1> public void channelActive(ChannelHandlerContext ctx) throws Exception { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> producer.getAllChannels().add(ctx.channel()); <line5> disconnecting = false; <line6> messageReceived = false; <line7> exceptionHandled = false; <line8> super.channelActive(ctx); <line9> } <line10> } <line11> 	"<line3>      LOG.trace(""Channel open: {}"", ctx.channel());"	task4	
"public class A { <line0> public static void checkStopWithSavepointPreconditions( <line1> CheckpointCoordinator checkpointCoordinator, <line2> @Nullable String targetDirectory, <line3> JobID jobId, <line4> Logger logger) { <line5> if (checkpointCoordinator == null) { <line6> throw new IllegalStateException(String.format(""Job %s is not a streaming job."", jobId)); <line7> } <line8> if (targetDirectory == null <line9> && !checkpointCoordinator.getCheckpointStorage().hasDefaultSavepointLocation()) { <line10> throw new IllegalStateException( <line11> ""No savepoint directory configured. You can either specify a directory "" <line12> + ""while cancelling via -s :targetDirectory or configure a cluster-wide "" <line13> + ""default via key '"" <line14> + CheckpointingOptions.SAVEPOINT_DIRECTORY.key() <line15> + ""'.""); <line16> } <line17> } <line18> } <line19> "	"<line10>      logger.info(""Trying to cancel job {} with savepoint, but no savepoint directory configured."", jobId);"	task4	
"public class A { <line0> public static String getTaskManagerShellCommand( <line1> Configuration flinkConfig, <line2> ContaineredTaskManagerParameters tmParams, <line3> String configDirectory, <line4> String logDirectory, <line5> boolean hasLogback, <line6> boolean hasLog4j, <line7> boolean hasKrb5, <line8> Class<?> mainClass, <line9> String mainArgs) { <line10> final Map<String, String> startCommandValues = new HashMap<>(); <line11> startCommandValues.put(""java"", ""$JAVA_HOME/bin/java""); <line12> final TaskExecutorProcessSpec taskExecutorProcessSpec = tmParams.getTaskExecutorProcessSpec(); <line13> startCommandValues.put( <line14> ""jvmmem"", ProcessMemoryUtils.generateJvmParametersStr(taskExecutorProcessSpec)); <line15> String javaOpts = flinkConfig.getString(CoreOptions.FLINK_JVM_OPTIONS); <line16> if (flinkConfig.getString(CoreOptions.FLINK_TM_JVM_OPTIONS).length() > 0) { <line17> javaOpts += "" "" + flinkConfig.getString(CoreOptions.FLINK_TM_JVM_OPTIONS); <line18> } <line19> if (hasKrb5) { <line20> javaOpts += "" -Djava.security.krb5.conf=krb5.conf""; <line21> } <line22> startCommandValues.put(""jvmopts"", javaOpts); <line23> String logging = """"; <line24> if (hasLogback || hasLog4j) { <line25> logging = ""-Dlog.file="" + logDirectory + ""/taskmanager.log""; <line26> if (hasLogback) { <line27> logging += "" -Dlogback.configurationFile=file:"" + configDirectory + ""/logback.xml""; <line28> } <line29> if (hasLog4j) { <line30> logging += "" -Dlog4j.configuration=file:"" + configDirectory + ""/log4j.properties""; <line31> logging += "" -Dlog4j.configurationFile=file:"" + configDirectory + ""/log4j.properties""; <line32> } <line33> } <line34> startCommandValues.put(""logging"", logging); <line35> startCommandValues.put(""class"", mainClass.getName()); <line36> startCommandValues.put( <line37> ""redirects"", <line38> ""1> "" + logDirectory + ""/taskmanager.out "" + ""2> "" + logDirectory + ""/taskmanager.err""); <line39> String argsStr = <line40> TaskExecutorProcessUtils.generateDynamicConfigsStr(taskExecutorProcessSpec) <line41> + "" --configDir "" <line42> + configDirectory; <line43> if (!mainArgs.isEmpty()) { <line44> argsStr += "" "" + mainArgs; <line45> } <line46> startCommandValues.put(""args"", argsStr); <line47> final String commandTemplate = <line48> flinkConfig.getString( <line49> ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE, <line50> ConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE); <line51> String startCommand = getStartCommand(commandTemplate, startCommandValues); <line52> return startCommand; <line53> } <line54> } <line55> "	"<line52>    LOG.debug(""TaskManager start command: "" + startCommand);"	task4	
public class A { <line0> public void addLogln(String message) { <line1> progressStatus.append(message); <line2> progressStatus.append(NEWLINE); <line3> } <line4> } <line5> 	<line1>    logger.debug(message);	task4	
public class A { <line0> public PTNetworkSourceTypeEnum readPTNetworkSourceType(String netexSourceType) { <line1> if (netexSourceType == null) return null; <line2> PTNetworkSourceTypeEnum sourceType = null; <line3> try { <line4> sourceType = PTNetworkSourceTypeEnum.valueOf(firstLetterUpcase(netexSourceType)); <line5> } catch (Exception e) { <line6> } <line7> return sourceType; <line8> } <line9> } <line10> 	"<line6>      logger.error(""unable to translate "" + netexSourceType + "" as PTNetworkSourceType"");"	task4	
public class A { <line0> private static String nextLine(LineProducer lineProducer) throws IllegalArgumentException { <line1> try { <line2> return lineProducer.nextLine(); <line3> } catch (IOException e1) { <line4> throw new IllegalArgumentException(e1); <line5> } <line6> } <line7> } <line8> 	"<line4>      log.error(""Got IOException while reading delimited file: "" + lineProducer);"	task4	
"public class A { <line0> private void onUploadSuccess(final String result) { <line1> final FileUploadResponse response = FileUploadResponse.parse(result); <line2> final FileVersionDTO fileVersion = response.getFileVersion(); <line3> final MonitoredPointDTO point = response.getMonitoredPoint(); <line4> if (fileVersion == null) { <line5> throw new UnsupportedOperationException(""Invalid required file version.""); <line6> } <line7> fileVersion.setAvailable(true); <line8> final ReportReference reportReference = new ReportReference(fileVersion); <line9> reportReference.setId(fileVersion.getId()); <line10> reportReference.setName(view.getFileUploadButtonField().getValue()); <line11> reportReference.setLastEditDate(new Date()); <line12> reportReference.setEditorName(auth().getUserShortName()); <line13> reportReference.setFlexibleElementLabel((String) view.getElementField().getValue()); <line14> reportReference.setPhaseName((String) view.getPhaseField().getValue()); <line15> N10N.infoNotif( <line16> I18N.CONSTANTS.infoConfirmation(), <line17> I18N.CONSTANTS.flexibleElementFilesListUploadFileConfirm()); <line18> if (point != null) { <line19> if (Log.isDebugEnabled()) { <line20> } <line21> N10N.infoNotif(I18N.CONSTANTS.infoConfirmation(), I18N.CONSTANTS.monitoredPointAddConfirm()); <line22> } <line23> eventBus.fireEvent(new UpdateEvent(UpdateEvent.REPORT_DOCUMENTS_UPDATE, reportReference)); <line24> hideView(); <line25> } <line26> } <line27> "	"<line20>        Log.debug(""Adds a monitored point '""+ point.getLabel()+ ""' to container with id #""+ containerId+ ""."");"	task4	
"public class A { <line0> public Map<String, Long> getAppsBySeverity(String assetGroup, String parentType, String severity) <line1> throws Exception { <line2> Map<String, Long> appDetails = new HashMap<>(); <line3> StringBuilder urlToQuery = new StringBuilder(esUrl).append(""/"").append(assetGroup); <line4> urlToQuery.append(""/"").append(parentType); <line5> urlToQuery.append(""/"").append(SEARCH); <line6> StringBuilder requestBody = <line7> new StringBuilder( <line8> ""{\""size\"":0,\""query\"":{\""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}}]}},"" <line9> + ""\""aggs\"":{\""apps\"":{\""terms\"":{\""field\"":\""tags.Application.keyword\"",\""size\"":10000},"" <line10> + ""\""aggs\"":{\""vulns\"":{\""children\"":{\""type\"":\""vulninfo\""},\""aggs\"":{\""NAME\"":{\""filters\"":{\""filters\"":{\""severity\"":{\""terms\"":{\""severitylevel.keyword\"":[""); <line11> requestBody.append(severity); <line12> requestBody.append(""]}}}}}}}}}}}""); <line13> String responseJson = """"; <line14> try { <line15> responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString()); <line16> } catch (Exception e) { <line17> throw e; <line18> } <line19> JsonParser jsonParser = new JsonParser(); <line20> JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson); <line21> JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString()); <line22> JsonArray buckets = aggsJson.getAsJsonObject(""apps"").getAsJsonArray(BUCKETS); <line23> if (buckets.size() > 0) { <line24> for (int i = 0; i < buckets.size(); i++) { <line25> appDetails.put( <line26> buckets.get(i).getAsJsonObject().get(""key"").getAsString(), <line27> buckets <line28> .get(i) <line29> .getAsJsonObject() <line30> .getAsJsonObject(""vulns"") <line31> .getAsJsonObject(""NAME"") <line32> .getAsJsonObject(""buckets"") <line33> .getAsJsonObject(""severity"") <line34> .get(DOC_COUNT) <line35> .getAsLong()); <line36> } <line37> } <line38> return appDetails; <line39> } <line40> } <line41> "	"<line17>      LOGGER.error(""Error in getAppsBySeverity from ES"", e);"	task4	
public class A { <line0> public void reconfigure(Dictionary<String, ?> props) { <line1> if (props == null) { <line2> if (bundleTracker != null) { <line3> bundleTracker.close(); <line4> } <line5> HttpContextTracker tracker = httpContextTrackers.remove(pid); <line6> if (tracker != null && symbolicName != null) { <line7> configExecutor.execute(tracker::cleanupContext); <line8> } <line9> properties = null; <line10> } else { <line11> if (bundleTracker != null) { <line12> bundleTracker.close(); <line13> configExecutor.execute(this::cleanupContext); <line14> } <line15> if (props.get(KEY_BUNDLE_SN) == null) { <line16> return; <line17> } <line18> properties = props; <line19> symbolicName = properties.get(KEY_BUNDLE_SN).toString().trim(); <line20> if (bundleTracker == null) { <line21> bundleTracker = new BundleTracker<>(serviceContext, Bundle.ACTIVE, this); <line22> } <line23> bundleTracker.open(); <line24> } <line25> } <line26> } <line27> 	"<line16>        LOG.warn(""Incorrect {} configuration - missing {} selector"", pid, KEY_BUNDLE_SN);"	task4	
public class A { <line0> private ModulesConfigurationProperties getModulesConfigurationPropertiesFallback( <line1> String serviceName, Throwable e) { <line2> e.printStackTrace(); <line3> return null; <line4> } <line5> } <line6> 	"<line2>    log.error(""getModulesConfigurationPropertiesFallback: "" + serviceName);"	task4	
"public class A { <line0> protected void setDesiredAutoCommit(boolean desiredAutoCommit) { <line1> try { <line2> if (connection.getAutoCommit() != desiredAutoCommit) { <line3> if (log.isDebugEnabled()) { <line4> } <line5> connection.setAutoCommit(desiredAutoCommit); <line6> } <line7> } catch (SQLException e) { <line8> throw new TransactionException( <line9> ""Error configuring AutoCommit.  "" <line10> + ""Your driver may not support getAutoCommit() or setAutoCommit(). "" <line11> + ""Requested setting: "" <line12> + desiredAutoCommit <line13> + "".  Cause: "" <line14> + e, <line15> e); <line16> } <line17> } <line18> } <line19> "	"<line4>          log.debug(""Setting autocommit to ""+ desiredAutoCommit+ "" on JDBC Connection [""+ connection+ ""]"");"	task4	
"public class A { <line0> public List<AttributeInterface> getAllowedNestedTypes(AttributeInterface listType) { <line1> List<AttributeInterface> attributes = new ArrayList<AttributeInterface>(); <line2> try { <line3> IEntityManager entityManager = this.getEntityManager(); <line4> Map<String, AttributeInterface> attributeTypes = entityManager.getEntityAttributePrototypes(); <line5> Iterator<AttributeInterface> attributeIter = attributeTypes.values().iterator(); <line6> while (attributeIter.hasNext()) { <line7> AttributeInterface attribute = attributeIter.next(); <line8> boolean simple = attribute.isSimple(); <line9> boolean multiLanguage = attribute.isMultilingual(); <line10> if ((listType instanceof ListAttribute && simple && !multiLanguage) <line11> || (listType instanceof MonoListAttribute <line12> && !(attribute instanceof AbstractListAttribute))) { <line13> attributes.add(attribute); <line14> } <line15> } <line16> Collections.sort(attributes, new BeanComparator(""type"")); <line17> } catch (Throwable t) { <line18> throw new RuntimeException(""Error while extracting Allowed Nested Types"", t); <line19> } <line20> return attributes; <line21> } <line22> } <line23> "	"<line18>      logger.error(""Error while extracting Allowed Nested Types"", t);"	task4	
public class A { <line0> private SortByType buildSortBy(QName featureType, SortBy incomingSortBy) { <line1> net.opengis.filter.v_1_1_0.ObjectFactory filterObjectFactory = <line2> new net.opengis.filter.v_1_1_0.ObjectFactory(); <line3> String propertyName = <line4> mapSortByPropertyName( <line5> featureType, incomingSortBy.getPropertyName().getPropertyName(), metacardMappers); <line6> if (propertyName != null) { <line7> SortOrder sortOrder = incomingSortBy.getSortOrder(); <line8> SortPropertyType sortPropertyType = filterObjectFactory.createSortPropertyType(); <line9> PropertyNameType propertyNameType = filterObjectFactory.createPropertyNameType(); <line10> List<Serializable> props = Arrays.asList(propertyName); <line11> propertyNameType.setContent(props); <line12> sortPropertyType.setPropertyName(propertyNameType); <line13> if (SortOrder.ASCENDING.equals(sortOrder)) { <line14> sortPropertyType.setSortOrder(SortOrderType.ASC); <line15> } else if (SortOrder.DESCENDING.equals(sortOrder)) { <line16> sortPropertyType.setSortOrder(SortOrderType.DESC); <line17> } else { <line18> return null; <line19> } <line20> SortByType sortByType = filterObjectFactory.createSortByType(); <line21> sortByType.getSortProperty().add(sortPropertyType); <line22> return sortByType; <line23> } <line24> return null; <line25> } <line26> } <line27> 	"<line18>        LOGGER.debug(""Unable to build query. Unknown sort order of [{}]."",sortOrder == null ? null : sortOrder.identifier());"	task4	
"public class A { <line0> private void decodeVideo( <line1> DataTypeInfo dataType, InputStream inStream, long startTime, VideoPositionTracker tracker) { <line2> Runnable emptyHandler = () -> {}; <line3> try (CancellableInputStream cancellableStream = <line4> new CancellableInputStream(inStream, emptyHandler)) { <line5> Iterator<VideoDecoder> decodersIterator = ServiceLoader.load(VideoDecoder.class).iterator(); <line6> if (!decodersIterator.hasNext()) { <line7> throw new IllegalStateException(""Could not find a decoder for processing video.""); <line8> } <line9> VideoDecoder videoDecoder = decodersIterator.next(); <line10> videoDecoder.setInputStream(cancellableStream, TimeInstant.get(startTime)); <line11> videoDecoder.registerVideoContentHandler(new OSHVideoContentHandler(dataType, tracker), null); <line12> videoDecoder.decode(); <line13> } catch (IOException | VideoDecoderException e) { <line14> } <line15> } <line16> } <line17> "	<line14>      LOGGER.error(e, e);	task4	
"public class A { <line0> @Override <line1> public Authentication attemptAuthentication( <line2> HttpServletRequest request, HttpServletResponse response) <line3> throws AuthenticationException, IOException, ServletException { <line4> SpringSocialSecuritySignInDetails signInDetails = <line5> (SpringSocialSecuritySignInDetails) <line6> request <line7> .getSession() <line8> .getAttribute( <line9> SpringSocialSecuritySignInService.SIGN_IN_DETAILS_SESSION_ATTRIBUTE_NAME); <line10> String alreadyAuthenticatedUserId = AuthenticatedUserIdHolder.getAuthenticatedUserId(); <line11> if (signInDetails != null) { <line12> UserDetails user = <line13> userDetailsService.loadUserByUsername( <line14> signInDetails.getConnectionData().getProviderId() <line15> + Constants.USER_NAME_SPLITTER <line16> + signInDetails.getUserId()); <line17> if (removeSignInDetailsFromSessionOnSuccessfulAuthentication) { <line18> request <line19> .getSession() <line20> .removeAttribute( <line21> SpringSocialSecuritySignInService.SIGN_IN_DETAILS_SESSION_ATTRIBUTE_NAME); <line22> } <line23> updateUserKeys(signInDetails.getConnectionData(), signInDetails.getUserId()); <line24> return authenticationFactory.createAuthenticationFromUserDetails(user); <line25> } else if (allowRepeatedAuthenticationAttempts && alreadyAuthenticatedUserId != null) { <line26> return SecurityContextHolder.getContext().getAuthentication(); <line27> } else { <line28> throw new InsufficientAuthenticationException( <line29> ""SpringSocialSecurity sign in details not found in session""); <line30> } <line31> } <line32> } <line33> "	"<line28>      logger.info(""SpringSocialSecurity sign in details not found in session"");"	task4	
"public class A { <line0> @Override <line1> protected void before() throws Throwable { <line2> server = <line3> H2ServerBootstrap.bootstrap() <line4> .setLookupRegistry(new UriPatternMatcher<>()) <line5> .setVersionPolicy(HttpVersionPolicy.NEGOTIATE) <line6> .setIOReactorConfig(IOReactorConfig.custom().setSoTimeout(TIMEOUT).build()) <line7> .setTlsStrategy( <line8> scheme == URIScheme.HTTPS <line9> ? new H2ServerTlsStrategy(SSLTestContexts.createServerSSLContext()) <line10> : null) <line11> .setStreamListener(LoggingHttp1StreamListener.INSTANCE_SERVER) <line12> .setStreamListener(LoggingH2StreamListener.INSTANCE) <line13> .setIOSessionDecorator(LoggingIOSessionDecorator.INSTANCE) <line14> .setExceptionCallback(LoggingExceptionCallback.INSTANCE) <line15> .setIOSessionListener(LoggingIOSessionListener.INSTANCE) <line16> .register(""*"", () -> new EchoHandler(2048)) <line17> .create(); <line18> } <line19> } <line20> "	"<line2>    log.debug(""Starting up test server"");"	task4	
"public class A { <line0> public MediaPackageElement newElement( <line1> MediaPackageElement.Type type, MediaPackageElementFlavor flavor) { <line2> List<MediaPackageElementBuilderPlugin> candidates = <line3> new ArrayList<MediaPackageElementBuilderPlugin>(); <line4> for (Class<? extends MediaPackageElementBuilderPlugin> pluginClass : plugins) { <line5> MediaPackageElementBuilderPlugin plugin = createPlugin(pluginClass); <line6> if (plugin.accept(type, flavor)) { <line7> candidates.add(plugin); <line8> } <line9> } <line10> if (candidates.size() == 0) return null; <line11> else if (candidates.size() > 1) { <line12> StringBuffer buf = new StringBuffer(); <line13> for (MediaPackageElementBuilderPlugin plugin : candidates) { <line14> if (buf.length() > 0) buf.append("", ""); <line15> buf.append(plugin.toString()); <line16> } <line17> } <line18> MediaPackageElementBuilderPlugin builderPlugin = candidates.get(0); <line19> MediaPackageElement element = builderPlugin.newElement(type, flavor); <line20> builderPlugin.destroy(); <line21> return element; <line22> } <line23> } <line24> "	"<line17>      logger.debug(""More than one element builder plugin claims responsibilty for ""+ flavor+ "": ""+ buf.toString());"	task4	
"public class A { <line0> synchronized void start() { <line1> if (!isEnabled() || started) return; <line2> pageSize = ctx.igniteConfiguration().getDataStorageConfiguration().getPageSize(); <line3> pageMemoryMock = mockPageMemory(); <line4> GridCacheSharedContext sharedCtx = gridCtx.cache().context(); <line5> long maxMemorySize = 0; <line6> for (DataRegion dataRegion : sharedCtx.database().dataRegions()) { <line7> if (dataRegion.pageMemory() instanceof PageMemoryImpl) <line8> maxMemorySize += dataRegion.config().getMaxSize(); <line9> } <line10> long[] chunks = new long[] {maxMemorySize}; <line11> memoryProvider = new UnsafeMemoryProvider(log); <line12> memoryProvider.initialize(chunks); <line13> memoryRegion = memoryProvider.nextRegion(); <line14> GridUnsafe.setMemory(memoryRegion.address(), memoryRegion.size(), (byte) 0); <line15> maxPages = (int) (maxMemorySize / pageSize); <line16> pageSlots = new DirectMemoryPageSlot[maxPages]; <line17> freeSlotsCnt = maxPages; <line18> tmpBuf1 = ByteBuffer.allocateDirect(pageSize); <line19> tmpBuf2 = ByteBuffer.allocateDirect(pageSize); <line20> if (cfg.isCheckPagesOnCheckpoint()) { <line21> checkpointLsnr = <line22> new CheckpointListener() { <line23> @Override <line24> public void onMarkCheckpointBegin(Context ctx) throws IgniteCheckedException { <line25> if (!checkPages(false, true)) <line26> throw new IgniteCheckedException( <line27> ""Page memory is inconsistent after applying WAL delta records.""); <line28> } <line29>  <line30> @Override <line31> public void beforeCheckpointBegin(Context ctx) {} <line32>  <line33> @Override <line34> public void onCheckpointBegin(Context ctx) {} <line35> }; <line36> ((GridCacheDatabaseSharedManager) gridCtx.cache().context().database()) <line37> .addCheckpointListener(checkpointLsnr); <line38> } <line39> lastPageIdx = 0; <line40> started = true; <line41> } <line42> } <line43> "	"<line41>    log.info(""PageMemory tracker started, ""+ U.readableSize(maxMemorySize, false)+ "" offheap memory allocated."");"	task4	
"public class A { <line0> @Incoming(""my-server"") <line1> public CompletionStage<Void> source(MqttMessage message) { <line2> return message.ack(); <line3> } <line4> } <line5> "	"<line2>    LOGGER.info(""MQTT Message received {}"", new String(message.getPayload()));"	task4	
public class A { <line0> private URI getURI(final String string) { <line1> if (string != null) { <line2> try { <line3> return new URI(string); <line4> } catch (final URISyntaxException e) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	"<line5>        LOG.error(""Failed to transform String to URI: {} "", string);"	task4	
public class A { <line0> protected void onLinkAddedPost( <line1> final String networkId, final Link link, final HashMap<String, Response> respList) { <line2> } <line3> } <line4> 	"<line2>    log.debug("""");"	task4	
public class A { <line0> private void createUrlResolver(HUITypeFactory typeFactory) { <line1> final Set<String> allIDs = new HashSet<String>(); <line2> try { <line3> List<PropertyType> types; <line4> types = typeFactory.getURLPropertyTypes(); <line5> for (PropertyType type : types) { <line6> allIDs.add(type.getId()); <line7> } <line8> } catch (Exception e) { <line9> return; <line10> } <line11> urlresolver = <line12> new IUrlResolver() { <line13> public List<HuiUrl> resolve() { <line14> List<HuiUrl> result = Collections.emptyList(); <line15> try { <line16> FindHuiUrls command = new FindHuiUrls(allIDs); <line17> command = ServiceFactory.lookupCommandService().executeCommand(command); <line18> result = command.getList(); <line19> } catch (Exception e) { <line20> } <line21> return result; <line22> } <line23> }; <line24> } <line25> } <line26> 	<line20>              LOG.error(STD_ERR_MSG, e);	task4	
public class A { <line0> public CancellableCompletableFuture<Void> monitor( <line1> Supplier<Boolean> condition, int checkInterval, int timeout, TimeUnit timeUnit) { <line2> return scheduledExecutor.scheduleWithFixedDelayAndTimeout( <line3> condition, 0L, checkInterval, timeout, timeUnit); <line4> } <line5> } <line6> 	"<line2>    log.debug(""Monitoring condition with specified checkInterval of {}, timeout of {}, timeUnit {}"",checkInterval,timeout,timeUnit);"	task4	
public class A { <line0> public boolean saveProcessedFile(File file) { <line1> boolean saved = false; <line2> if (file == null || !file.isFile()) return saved; <line3> String destinationDir = messageProcessedDir; <line4> try { <line5> Utils.moveToDirectory(destinationDir, file); <line6> } catch (Exception ex) { <line7> } <line8> return saved; <line9> } <line10> } <line11> 	"<line7>      logger.error(""Unable to move file '"" + file.getName() + ""' to directory: "" + destinationDir, ex);"	task4	
public class A { <line0> private void parseHeartbeatMode(HeartbeatExtensionMessage msg) { <line1> msg.setHeartbeatMode(parseByteArrayField(ExtensionByteLength.HEARTBEAT_MODE)); <line2> } <line3> } <line4> 	"<line2>    LOGGER.debug(""HeartbeatMode: "" + ArrayConverter.bytesToHexString(msg.getHeartbeatMode().getValue()));"	task4	
public class A { <line0> @GetMapping(CommonConstants.PATH_LEVELS) <line1> public List<String> getLevels(final Optional<String> criteria) { <line2> RestUtils.checkCriteria(criteria); <line3> return internalProfileService.getLevels(criteria); <line4> } <line5> } <line6> 	"<line2>    LOGGER.debug(""Get levels with criteria={}"", criteria);"	task4	
"public class A { <line0> protected FileSec createFileSection() throws IOException { <line1> FileSec fileSec = new FileSec(); <line2> List<MCRPath> filePaths = MCRMetsSave.listFiles(getDerivatePath(), getIgnorePaths()); <line3> List<FileGrp> fileGrps = MCRMetsSave.buildFileGroups(filePaths); <line4> fileGrps.forEach(fileSec::addFileGrp); <line5> for (MCRPath file : filePaths) { <line6> String contentType = MCRContentTypes.probeContentType(file); <line7> FileRef ref = buildFileRef(file, contentType); <line8> this.files.add(ref); <line9> } <line10> for (FileRef ref : this.files) { <line11> String use = <line12> MCRMetsModelHelper.getUseForHref(ref.getPath().getOwnerRelativePath()).orElse(""UNKNOWN""); <line13> FileGrp fileGrp = <line14> fileGrps.stream().filter(grp -> grp.getUse().equals(use)).findFirst().orElse(null); <line15> if (fileGrp == null) { <line16> continue; <line17> } <line18> addFile(ref, fileGrp); <line19> } <line20> return fileSec; <line21> } <line22> } <line23> "	"<line16>        LOGGER.warn(""Unable to add file '{}' because cannot find corresponding group  with @USE='{}'. ""+ ""Ignore file and continue."",ref.toFileId(),use);"	task4	
"public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final RoleTO ignore) { <line2> AnyLayoutWrapper wrapper = <line3> new AnyLayoutWrapper( <line4> model.getObject().getKey(), <line5> AnyLayoutUtils.defaultIfEmpty( <line6> RoleRestClient.readAnyLayout(model.getObject().getKey()), <line7> AnyTypeRestClient.list())); <line8> utilityModal.header(new ResourceModel(""console.layout.info"", ""JSON Content"")); <line9> utilityModal.setContent( <line10> new JsonEditorPanel( <line11> utilityModal, new PropertyModel<String>(wrapper, ""content""), false, pageRef) { <line12> private static final long serialVersionUID = -8927036362466990179L; <line13>  <line14> @Override <line15> public void onSubmit(final AjaxRequestTarget target) { <line16> try { <line17> RoleRestClient.setAnyLayout(wrapper.getKey(), wrapper.getContent()); <line18> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line19> modal.show(false); <line20> modal.close(target); <line21> } catch (Exception e) { <line22> SyncopeConsoleSession.get().onException(e); <line23> } <line24> ((BasePage) pageRef.getPage()).getNotificationPanel().refresh(target); <line25> } <line26> }); <line27> utilityModal.show(true); <line28> target.add(utilityModal); <line29> } <line30> } <line31> "	"<line22>              LOG.error(""While updating console layout for role {}"", wrapper.getKey(), e);"	task4	
public class A { <line0> private void activateCurrentTime(TimeType time) { <line1> PlayStateType playState = <line2> time.getAnimation() != null ? time.getAnimation().getPlayState() : null; <line3> boolean animationSetTheTime = <line4> EqualsHelper.equalsAny(playState, PlayState.FORWARD, PlayState.REVERSE); <line5> if (StringUtils.isNotEmpty(time.getCurrent()) && !animationSetTheTime) { <line6> try { <line7> TimeSpan span = TimeSpan.fromISO8601String(time.getCurrent()); <line8> resetPlanIfNecessary(span); <line9> myTimeManager.setPrimaryActiveTimeSpan(span); <line10> } catch (ParseException e) { <line11> } <line12> } <line13> } <line14> } <line15> 	"<line11>        LOGGER.error(""Failed to parse state interval: "" + e, e);"	task4	
public class A { <line0> protected void addManagedBlockDisks(Collection<DiskImage> templateDisks) { <line1> List<ManagedBlockStorageDisk> managedBlockDisks = <line2> DisksFilter.filterManagedBlockStorageDisks(templateDisks); <line3> if (managedBlockDisks.isEmpty()) { <line4> return; <line5> } <line6> Map<Guid, Guid> diskImageMap = new HashMap<>(); <line7> for (ManagedBlockStorageDisk managedBlockDisk : managedBlockDisks) { <line8> ImagesContainterParametersBase params = buildImagesContainterParameters(managedBlockDisk); <line9> ActionReturnValue actionReturnValue = <line10> runInternalAction( <line11> ActionType.CloneSingleManagedBlockDisk, <line12> params, <line13> cloneContext().withoutExecutionContext().withoutLock()); <line14> if (!actionReturnValue.getSucceeded()) { <line15> getReturnValue().setFault(actionReturnValue.getFault()); <line16> return; <line17> } <line18> Guid imageId = actionReturnValue.getActionReturnValue(); <line19> diskImageMap.put(managedBlockDisk.getId(), imageId); <line20> } <line21> srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap); <line22> } <line23> } <line24> 	"<line15>        log.error(""Error cloning Managed block disk '{}': {}"", managedBlockDisk.getDiskAlias());"	task4	
public class A { <line0> private List<EntityReference> collectWikiObjectsList() { <line1> List<EntityReference> wikiObjectsList = new ArrayList<>(); <line2> try { <line3> List<WikiObjectComponentBuilder> componentBuilders = <line4> this.contextComponent.getInstanceList(WikiObjectComponentBuilder.class); <line5> for (WikiObjectComponentBuilder componentBuilder : componentBuilders) { <line6> wikiObjectsList.add(componentBuilder.getClassReference()); <line7> } <line8> } catch (ComponentLookupException e) { <line9> } <line10> return wikiObjectsList; <line11> } <line12> } <line13> 	"<line9>      logger.warn(""Unable to collect a list of wiki objects components: %s"", e);"	task4	
public class A { <line0> public static <T> T getJsonObject(String jsonstr, Class<T> type) { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true); <line3> try { <line4> return mapper.readValue(jsonstr, type); <line5> } catch (IOException e) { <line6> } <line7> return null; <line8> } <line9> } <line10> 	"<line6>      logger.error(""fail to unMarshal json {}"", e.getMessage());"	task4	
public class A { <line0> public String getCaseFileDataByName( <line1> String containerId, String caseId, String name, String marshallingType) { <line2> verifyContainerId(containerId, caseId); <line3> CaseFileInstance caseFileInstance = caseService.getCaseFileInstance(caseId); <line4> Object caseFileData = caseFileInstance.getData(name); <line5> return marshallerHelper.marshal( <line6> containerId, marshallingType, caseFileData, new ByCaseIdContainerLocator(caseId)); <line7> } <line8> } <line9> 	"<line5>    logger.debug(""About to marshal case file data (name = {}) for case with id '{}' {}"",name,caseId,caseFileData);"	task4	
"public class A { <line0> @DELETE <line1> @Path(""{jobId}"") <line2> @Timed <line3> @ApiOperation(value = ""Cancel job with the given ID"") <line4> @Produces(MediaType.APPLICATION_JSON) <line5> @AuditEvent(type = AuditEventTypes.SYSTEM_JOB_STOP) <line6> public SystemJobSummary cancelJob( <line7> @ApiParam(name = ""jobId"", required = true) @PathParam(""jobId"") @NotEmpty String jobId) <line8> throws IOException { <line9> final Optional<Response<SystemJobSummary>> summaryResponse = <line10> nodeService.allActive().entrySet().stream() <line11> .map( <line12> entry -> { <line13> final RemoteSystemJobResource resource = <line14> remoteInterfaceProvider.get( <line15> entry.getValue(), <line16> this.authenticationToken, <line17> RemoteSystemJobResource.class); <line18> try { <line19> return resource.delete(jobId).execute(); <line20> } catch (IOException e) { <line21> return null; <line22> } <line23> }) <line24> .filter(response -> response != null && response.isSuccessful()) <line25> .findFirst(); <line26> return summaryResponse <line27> .orElseThrow(() -> new NotFoundException(""System job with ID <"" + jobId + ""> not found!"")) <line28> .body(); <line29> } <line30> } <line31> "	"<line21>                    LOG.warn(""Unable to fetch system jobs from node {}:"", entry.getKey(), e);"	task4	
public class A { <line0> private void readCompoundCheckpoint(CheckpointInputStream checkpoint, Path path) <line1> throws IOException { <line2> Files.createDirectories(path); <line3> CompoundCheckpointFormat.CompoundCheckpointReader reader = <line4> new CompoundCheckpointFormat.CompoundCheckpointReader(checkpoint); <line5> Optional<CompoundCheckpointFormat.CompoundCheckpointReader.Entry> entryOpt; <line6> while ((entryOpt = reader.nextCheckpoint()).isPresent()) { <line7> CompoundCheckpointFormat.CompoundCheckpointReader.Entry entry = entryOpt.get(); <line8> Path checkpointPath = path.resolve(entry.getName().toString()); <line9> readCheckpoint(entry.getStream(), checkpointPath); <line10> } <line11> } <line12> } <line13> 	"<line9>      LOG.debug(""Reading checkpoint for {} to {}"", entry.getName(), checkpointPath);"	task4	
public class A { <line0> @Override <line1> public boolean deleteIfExists(Path path) throws IOException { <line2> Path r = unroot(path); <line3> if (log.isTraceEnabled()) { <line4> } <line5> FileSystemProvider p = provider(r); <line6> return p.deleteIfExists(r); <line7> } <line8> } <line9> 	"<line4>      log.trace(""deleteIfExists({}): {}"", path, r);"	task4	
public class A { <line0> @Override <line1> public long getLong(String key) { <line2> if (containsKey(key)) { <line3> return PropertyConverter.toLong(getProperty(key)); <line4> } else { <line5> throw new NoSuchElementException(doesNotMapMessage(key)); <line6> } <line7> } <line8> } <line9> 	<line5>      log.warn(missingMessage(key));	task4	
public class A { <line0> private boolean isAppendedToInbox(Added addedEvent) { <line1> try { <line2> return systemMailboxesProvider <line3> .findMailbox(Role.INBOX, addedEvent.getUsername()) <line4> .getId() <line5> .equals(addedEvent.getMailboxId()); <line6> } catch (MailboxException e) { <line7> return false; <line8> } <line9> } <line10> } <line11> 	"<line7>      LOGGER.warn(""Could not resolve Inbox mailbox"", e);"	task4	
"public class A { <line0> @Override <line1> public void onFailure(IMqttToken asyncActionToken, Throwable exception) { <line2> Assert.fail(""MQTT connect failed: "" + exception.getMessage()); <line3> } <line4> } <line5> "	"<line2>    LOGGER.error(""Exception:"", exception);"	task4	
public class A { <line0> @Override <line1> public void commit(Xid xid, boolean b) throws XAException { <line2> this.commitStarted = true; <line3> } <line4> } <line5> 	"<line3>    logger.debug(""Committing XA TX. {}, One Face: {}"", xid, b);"	task4	
public class A { <line0> public void accept(RoutingContext ctx) { <line1> HttpResponse.responseText(ctx, 202); <line2> echo(ctx); <line3> } <line4> } <line5> 	"<line1>    logger.info(""test-auth: Auth accept OK"");"	task4	
public class A { <line0> private static SocketState extractSocketState(State state) { <line1> try { <line2> if (state.getTlsContext().getTransportHandler() instanceof ClientTcpTransportHandler) { <line3> SocketState socketState = <line4> (((ClientTcpTransportHandler) (state.getTlsContext().getTransportHandler())) <line5> .getSocketState()); <line6> return socketState; <line7> } else { <line8> return null; <line9> } <line10> } catch (InvalidTransportHandlerStateException ex) { <line11> return SocketState.DATA_AVAILABLE; <line12> } <line13> } <line14> } <line15> 	<line11>      LOGGER.warn(ex);	task4	
"public class A { <line0> @Test <line1> public void testQueryList() throws Exception { <line2> MvcResult mvcResult = <line3> mockMvc <line4> .perform(get(""/queue/list"").header(SESSION_ID, sessionId)) <line5> .andExpect(status().isOk()) <line6> .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8)) <line7> .andReturn(); <line8> Result result = <line9> JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class); <line10> Assert.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue()); <line11> } <line12> } <line13> "	"<line11>    logger.info(""query list queue return result:{}"", mvcResult.getResponse().getContentAsString());"	task4	
public class A { <line0> @Override <line1> public void rollback() { <line2> if (Objects.isNull(branch)) { <line3> return; <line4> } <line5> branch.rollback(); <line6> doOnRollback(); <line7> clear(); <line8> } <line9> } <line10> 	"<line3>      LOGGER.debug(""Nothing to commit. Transaction branch is null"");"	task4	
public class A { <line0> @Override <line1> public void injectConsistencyLevels(Session session, ConfigurationContext configContext) { <line2> ConsistencyLevel clusterConsistency = <line3> session.getCluster().getConfiguration().getQueryOptions().getConsistencyLevel(); <line4> ConsistencyLevel clusterSerialConsistency = <line5> session.getCluster().getConfiguration().getQueryOptions().getSerialConsistencyLevel(); <line6> final String tableOrViewName = this.getTableOrViewName(); <line7> this.readConsistencyLevel = <line8> OverridingOptional.from(staticReadConsistency) <line9> .andThen(configContext.getReadConsistencyLevelForTable(tableOrViewName)) <line10> .andThen(configContext.getDefaultReadConsistencyLevel()) <line11> .andThen(clusterConsistency) <line12> .defaultValue(ConfigurationContext.DEFAULT_CONSISTENCY_LEVEL) <line13> .get(); <line14> this.writeConsistencyLevel = <line15> OverridingOptional.from(staticWriteConsistency) <line16> .andThen(configContext.getWriteConsistencyLevelForTable(tableOrViewName)) <line17> .andThen(configContext.getDefaultWriteConsistencyLevel()) <line18> .andThen(clusterConsistency) <line19> .defaultValue(ConfigurationContext.DEFAULT_CONSISTENCY_LEVEL) <line20> .get(); <line21> this.serialConsistencyLevel = <line22> OverridingOptional.from(staticSerialConsistency) <line23> .andThen(configContext.getSerialConsistencyLevelForTable(tableOrViewName)) <line24> .andThen(clusterSerialConsistency) <line25> .andThen(configContext.getDefaultSerialConsistencyLevel()) <line26> .defaultValue(ConfigurationContext.DEFAULT_SERIAL_CONSISTENCY_LEVEL) <line27> .get(); <line28> if (LOGGER.isDebugEnabled()) { <line29> } <line30> } <line31> } <line32> 	"<line29>      LOGGER.debug(format(""Injecting read/write/serial consistency levels %s/%s/%s into entity meta of %s"",readConsistencyLevel.name(),writeConsistencyLevel.name(),serialConsistencyLevel.name(),entityClass.getCanonicalName()));"	task4	
"public class A { <line0> private Optional<Configuration> makeRootServiceConfiguration( <line1> final Optional<Configuration> serviceConfiguration) { <line2> final EvaluatorType evaluatorType = <line3> this.evaluatorManager.getEvaluatorDescriptor().getProcess().getType(); <line4> if (EvaluatorType.CLR == evaluatorType) { <line5> LOG.log( <line6> Level.FINE, <line7> ""Not using the ConfigurationProviders as we are configuring a {0} Evaluator."", <line8> evaluatorType); <line9> return serviceConfiguration; <line10> } <line11> if (!serviceConfiguration.isPresent() && this.evaluatorConfigurationProviders.isEmpty()) { <line12> return Optional.empty(); <line13> } else { <line14> final ConfigurationBuilder configurationBuilder = <line15> getConfigurationBuilder(serviceConfiguration); <line16> for (final ConfigurationProvider configurationProvider : <line17> this.evaluatorConfigurationProviders) { <line18> configurationBuilder.addConfiguration(configurationProvider.getConfiguration()); <line19> } <line20> return Optional.of(configurationBuilder.build()); <line21> } <line22> } <line23> } <line24> "	"<line12>      LOG.info(""No service configuration given and no ConfigurationProviders set."");"	task4	
public class A { <line0> @Override <line1> public void onNext(T t) { <line2> } <line3> } <line4> 	"<line2>    log.info(t + """");"	task4	
public class A { <line0> public boolean deleteConfiguration(String domainName, String configurationName) <line1> throws RemoteException { <line2> try { <line3> return templateManagerAdminServiceStub.deleteConfiguration(domainName, configurationName); <line4> } catch (RemoteException e) { <line5> throw new RemoteException(e.getMessage(), e); <line6> } <line7> } <line8> } <line9> 	"<line5>      log.error(""RemoteException"", e);"	task4	
"public class A { <line0> @Override <line1> public synchronized void run() { <line2> try { <line3> setStatus(PluginStatus.STOPPING); <line4> try { <line5> onStop(); <line6> } catch (PluginShutdownException shutdownEx) { <line7> notifyError(shutdownEx.getMessage()); <line8> } <line9> sensorThread = null; <line10> setStatus(PluginStatus.STOPPED); <line11> PluginHasChanged event = <line12> new PluginHasChanged(this, getName(), PluginHasChanged.PluginActions.STOP); <line13> event.getPayload().addStatement(""plugin.status"", getStatus()); <line14> getBusService().send(event); <line15> } catch (Exception e) { <line16> setStatus(PluginStatus.FAILED); <line17> setDescription(""Plugin stopping FAILED. see logs for details.""); <line18> PluginHasChanged event = <line19> new PluginHasChanged(this, getName(), PluginHasChanged.PluginActions.START); <line20> event.getPayload().addStatement(""plugin.status"", getStatus()); <line21> getBusService().send(event); <line22> } <line23> } <line24> } <line25> "	"<line18>      LOG.error(""Error stopping plugin \"""" + getName() + ""\"": "" + e.getLocalizedMessage(), e);"	task4	
"public class A { <line0> private static URL[] copyHdfsJarFilesToTempDir(String databaseName, List<String> jars) <line1> throws IOException { <line2> List<URL> urls = new ArrayList<URL>(); <line3> final Configuration conf = new Configuration(); <line4> Path localPath = createTempDir(databaseName, conf); <line5> for (String jar : jars) { <line6> Path jarPath = new Path(jar); <line7> final FileSystem fs = jarPath.getFileSystem(conf); <line8> if (fs.isFile(jarPath) && jarPath.getName().endsWith("".jar"")) { <line9> fs.copyToLocalFile(jarPath, localPath); <line10> } <line11> } <line12> urls.addAll(getJarsInPath(localPath.toUri().toURL())); <line13> return urls.toArray(new URL[urls.size()]); <line14> } <line15> } <line16> "	"<line9>        LOG.info(""Copying jarFile = "" + jarPath);"	task4	
"public class A { <line0> public List<Product> getProducts() { <line1> return Arrays.asList( <line2> new Product(""Laptop"", 31000.00), <line3> new Product(""Mobile"", 16000.00), <line4> new Product(""Tablet"", 15000.00), <line5> new Product(""Camera"", 23000.00)); <line6> } <line7> } <line8> "	"<line1>    logger.debug(""Product service returning list of products"");"	task4	
"public class A { <line0> public static int getCommerceWishListItemByContainsCProductCount( <line1> HttpPrincipal httpPrincipal, long commerceWishListId, long cProductId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceWishListItemServiceUtil.class, <line7> ""getCommerceWishListItemByContainsCProductCount"", <line8> _getCommerceWishListItemByContainsCProductCountParameterTypes5); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceWishListId, cProductId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public void stateUpdated(Item item, State newState) { <line2> OnOffType onOffState = (OnOffType) item.getStateAs(OnOffType.class); <line3> if (onOffState != null) { <line4> boolean isOn = onOffState == OnOffType.ON; <line5> DeviceParam param = new DeviceParam(ParamType.STATUS, isOn ^ isInverted() ? ""1"" : ""0""); <line6> addParam(param); <line7> } <line8> } <line9> } <line10> "	"<line2>    logger.debug(""Device item {} state changed to {}"", item, newState);"	task4	
public class A { <line0> public Cipher getDecryptCipher(String decryptKey) { <line1> Cipher cipher; <line2> setDataDecryptionKeyString(decryptKey); <line3> try { <line4> cipher = createDecryptCipherInternal(); <line5> } catch (Exception e) { <line6> cipher = null; <line7> } <line8> return cipher; <line9> } <line10> } <line11> 	<line6>      Log.error(e.getMessage());	task4	
"public class A { <line0> public static DefaultSlotPoolServiceSchedulerFactory fromConfiguration( <line1> Configuration configuration, JobType jobType) { <line2> final Time rpcTimeout = AkkaUtils.getTimeoutAsTime(configuration); <line3> final Time slotIdleTimeout = <line4> Time.milliseconds(configuration.getLong(JobManagerOptions.SLOT_IDLE_TIMEOUT)); <line5> final Time batchSlotTimeout = <line6> Time.milliseconds(configuration.getLong(JobManagerOptions.SLOT_REQUEST_TIMEOUT)); <line7> final SlotPoolServiceFactory slotPoolServiceFactory; <line8> final SchedulerNGFactory schedulerNGFactory; <line9> JobManagerOptions.SchedulerType schedulerType = ClusterOptions.getSchedulerType(configuration); <line10> if (schedulerType == JobManagerOptions.SchedulerType.Adaptive && jobType == JobType.BATCH) { <line11> schedulerType = JobManagerOptions.SchedulerType.Ng; <line12> } <line13> switch (schedulerType) { <line14> case Ng: <line15> schedulerNGFactory = new DefaultSchedulerFactory(); <line16> slotPoolServiceFactory = <line17> new DeclarativeSlotPoolBridgeServiceFactory( <line18> SystemClock.getInstance(), rpcTimeout, slotIdleTimeout, batchSlotTimeout); <line19> break; <line20> case Adaptive: <line21> schedulerNGFactory = getAdaptiveSchedulerFactoryFromConfiguration(configuration); <line22> slotPoolServiceFactory = <line23> new DeclarativeSlotPoolServiceFactory( <line24> SystemClock.getInstance(), slotIdleTimeout, rpcTimeout); <line25> break; <line26> default: <line27> throw new IllegalArgumentException( <line28> String.format( <line29> ""Illegal value [%s] for config option [%s]"", <line30> schedulerType, JobManagerOptions.SCHEDULER.key())); <line31> } <line32> return new DefaultSlotPoolServiceSchedulerFactory(slotPoolServiceFactory, schedulerNGFactory); <line33> } <line34> } <line35> "	"<line11>      LOG.info(""Adaptive Scheduler configured, but Batch job detected. Changing scheduler type to NG /""+ "" DefaultScheduler."");"	task4	
"public class A { <line0> private void handleChecksumException(ChecksumException e) throws IOException { <line1> if (this.conf.getBoolean(""io.skip.checksum.errors"", false)) { <line2> sync(getPosition() + this.conf.getInt(""io.bytes.per.checksum"", 512)); <line3> } else { <line4> throw e; <line5> } <line6> } <line7> } <line8> "	"<line2>      log.warn(""Bad checksum at "" + getPosition() + "". Skipping entries."");"	task4	
"public class A { <line0> public static void stopProcessOnShutdown(final Process process) { <line1> Runtime.getRuntime() <line2> .addShutdownHook( <line3> new Thread( <line4> () -> { <line5> try { <line6> process.stop(); <line7> } catch (Throwable t) { <line8> } <line9> }, <line10> ""alluxio-process-shutdown-hook"")); <line11> } <line12> } <line13> "	"<line8>                    LOG.error(""Failed to stop process"", t);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> KunderaRedisClient cli = new KunderaRedisClient(); <line3> Properties props = new Properties(); <line4> props.setProperty(""hosts"", ""localhost""); <line5> cli.setProperties(props); <line6> try { <line7> cli.init(); <line8> } catch (Exception e) { <line9> System.exit(0); <line10> } <line11> HashMap<String, ByteIterator> vals = new HashMap<String, ByteIterator>(); <line12> vals.put(""age"", new StringByteIterator(""57"")); <line13> vals.put(""middlename"", new StringByteIterator(""bradley"")); <line14> vals.put(""favoritecolor"", new StringByteIterator(""blue"")); <line15> int res = cli.insert(""usertable"", ""BrianFrankCooper"", vals); <line16> cli.read(""usertable"", ""BrianFrankCooper"", null, null); <line17> System.out.println(""Result of insert: "" + res); <line18> try { <line19> cli.cleanup(); <line20> } catch (DBException e) { <line21> e.printStackTrace(); <line22> } <line23> } <line24> } <line25> "	<line9>      logger.error(e);	task4	
"public class A { <line0> @Scheduled(cron = ""0 0 1 * * ?"") <line1> public void removeNotActivatedUsers() { <line2> if (instanceId != 0) { <line3> return; <line4> } <line5> LocalDateTime now = LocalDateTime.now(); <line6> List<User> users = <line7> userRepository.findAllByActivatedIsFalseAndCreatedDateBefore(now.minusDays(3)); <line8> for (User user : users) { <line9> userRepository.delete(user); <line10> } <line11> } <line12> } <line13> "	"<line9>      log.debug(""Deleting not activated user {}"", user.getLogin());"	task4	
"public class A { <line0> public void validateRegisteredS3Files( <line1> List<StorageFile> expectedStorageFiles, <line2> List<S3ObjectSummary> s3ObjectSummaries, <line3> String storageName, <line4> BusinessObjectDataKey businessObjectDataKey) { <line5> Set<String> actualS3FilePaths = <line6> new HashSet<>(getFilePathsFromS3ObjectSummaries(s3ObjectSummaries)); <line7> for (StorageFile expectedStorageFile : expectedStorageFiles) { <line8> if (!actualS3FilePaths.contains(expectedStorageFile.getFilePath())) { <line9> throw new ObjectNotFoundException( <line10> String.format( <line11> ""Registered file \""%s\"" does not exist in \""%s\"" storage."", <line12> expectedStorageFile.getFilePath(), storageName)); <line13> } <line14> } <line15> Set<String> expectedFilePaths = <line16> new HashSet<>(getFilePathsFromStorageFiles(expectedStorageFiles)); <line17> String businessObjectDataKeyAsJson = jsonHelper.objectToJson(businessObjectDataKey); <line18> for (S3ObjectSummary s3ObjectSummary : s3ObjectSummaries) { <line19> if (!expectedFilePaths.contains(s3ObjectSummary.getKey())) { <line20> if (s3ObjectSummary.getSize() == 0) { <line21> } else { <line22> throw new IllegalStateException( <line23> String.format( <line24> ""Found unregistered non-empty S3 file \""%s\"" in \""%s\"" storage. Business object"" <line25> + "" data {%s}"", <line26> s3ObjectSummary.getKey(), <line27> storageName, <line28> businessObjectDataHelper.businessObjectDataKeyToString(businessObjectDataKey))); <line29> } <line30> } <line31> } <line32> } <line33> } <line34> "	"<line21>          LOGGER.info(""Ignoring unregistered zero byte S3 file. s3Key=\""{}\"" storageName=\""{}\""""+ "" businessObjectDataKey={}"",s3ObjectSummary.getKey(),storageName,businessObjectDataKeyAsJson);"	task4	
"public class A { <line0> @GET <line1> @Path(""/settings.json"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @RestQuery( <line4> name = ""getUserSettings"", <line5> description = ""Returns a list of the user settings for the current user"", <line6> returnDescription = ""Returns a JSON representation of the list of user settings"", <line7> restParameters = { <line8> @RestParameter( <line9> defaultValue = ""100"", <line10> description = ""The maximum number of items to return per page."", <line11> isRequired = false, <line12> name = ""limit"", <line13> type = RestParameter.Type.STRING), <line14> @RestParameter( <line15> defaultValue = ""0"", <line16> description = ""The page number."", <line17> isRequired = false, <line18> name = ""offset"", <line19> type = RestParameter.Type.STRING) <line20> }, <line21> responses = {@RestResponse(responseCode = SC_OK, description = ""The user settings."")}) <line22> public Response getUserSettings(@QueryParam(""limit"") int limit, @QueryParam(""offset"") int offset) <line23> throws IOException { <line24> if (limit < 1) { <line25> limit = 100; <line26> } <line27> UserSettings userSettings; <line28> try { <line29> userSettings = userSettingsService.findUserSettings(limit, offset); <line30> } catch (UserSettingsServiceException e) { <line31> return (Response.serverError().build()); <line32> } <line33> return Response.ok(userSettings.toJson().toJson()).build(); <line34> } <line35> } <line36> "	"<line31>      logger.error(""Unable to get user settings:"", e);"	task4	
public class A { <line0> @Override <line1> public void initialized() { <line2> async.withLog( <line3> log, <line4> () -> { <line5> Registration registration = <line6> new Registration( <line7> WORKSPACE_FOLDERS_CAPABILITY_ID, WORKSPACE_FOLDERS_CAPABILITY_NAME, null); <line8> RegistrationParams registrationParams = <line9> new RegistrationParams(Collections.singletonList(registration)); <line10> getClient().registerCapability(registrationParams); <line11> this.initialized.complete(null); <line12> }); <line13> } <line14> } <line15> 	"<line12>          log.info(""Initialization completed after {} ms"",ManagementFactory.getRuntimeMXBean().getUptime());"	task4	
public class A { <line0> private void logFirstTimeMBeanException(String mbeanObjectName, Exception e) { <line1> if (loggedMBeanGauges.add(mbeanObjectName)) { <line2> } <line3> } <line4> } <line5> 	"<line2>      logger.warn(""error accessing mbean: {}"", mbeanObjectName, e);"	task4	
"public class A { <line0> @Test <line1> void testUpgradeAcrossVersionsWithNoKafkaVersion(ExtensionContext extensionContext) <line2> throws IOException { <line3> JsonObject acrossUpgradeData = buildDataForUpgradeAcrossVersions(); <line4> JsonObject conversionTool = getConversionToolDataFromUpgradeJSON(); <line5> String continuousTopicName = ""continuous-topic""; <line6> String producerName = ""hello-world-producer""; <line7> String consumerName = ""hello-world-consumer""; <line8> String continuousConsumerGroup = ""continuous-consumer-group""; <line9> setupEnvAndUpgradeClusterOperator( <line10> extensionContext, <line11> acrossUpgradeData, <line12> producerName, <line13> consumerName, <line14> continuousTopicName, <line15> continuousConsumerGroup, <line16> null, <line17> NAMESPACE); <line18> convertCRDs(conversionTool, NAMESPACE); <line19> changeClusterOperator(acrossUpgradeData, NAMESPACE); <line20> zkPods = <line21> StatefulSetUtils.waitTillSsHasRolled( <line22> KafkaResources.zookeeperStatefulSetName(clusterName), 3, zkPods); <line23> kafkaPods = <line24> StatefulSetUtils.waitTillSsHasRolled( <line25> KafkaResources.kafkaStatefulSetName(clusterName), 3, kafkaPods); <line26> eoPods = <line27> DeploymentUtils.waitTillDepHasRolled( <line28> KafkaResources.entityOperatorDeploymentName(clusterName), 1, eoPods); <line29> logPodImages(clusterName); <line30> changeKafkaAndLogFormatVersion( <line31> acrossUpgradeData.getJsonObject(""proceduresAfterOperatorUpgrade""), <line32> acrossUpgradeData, <line33> clusterName, <line34> extensionContext); <line35> logPodImages(clusterName); <line36> checkAllImages(acrossUpgradeData.getJsonObject(""imagesAfterKafkaUpgrade"")); <line37> PodUtils.verifyThatRunningPodsAreStable(clusterName); <line38> verifyProcedure(acrossUpgradeData, producerName, consumerName, NAMESPACE); <line39> assertNoCoErrorsLogged(0); <line40> } <line41> } <line42> "	"<line29>    LOGGER.info(""Rolling to new images has finished!"");"	task4	
public class A { <line0> @Override <line1> public void init() throws Exception { <line2> String xmlConfig = this.getConfigManager().getConfigItem(SystemConstants.CONFIG_ITEM_LANGS); <line3> this.getCacheWrapper().initCache(xmlConfig); <line4> } <line5> } <line6> 	"<line4>    logger.debug(""{} ready: initialized"", this.getClass().getName());"	task4	
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command instanceof RefreshType) { <line3> return; <line4> } <line5> if (getThing().getStatus() == ThingStatus.UNKNOWN <line6> || (getThing().getStatus() == ThingStatus.OFFLINE <line7> && (getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.BRIDGE_OFFLINE <line8> || getThing().getStatusInfo().getStatusDetail() <line9> == ThingStatusDetail.BRIDGE_UNINITIALIZED <line10> || getThing().getStatusInfo().getStatusDetail() <line11> == ThingStatusDetail.CONFIGURATION_ERROR))) { <line12> return; <line13> } <line14> if (bridgeHandler == null) { <line15> return; <line16> } <line17> switch (channelUID.getId()) { <line18> case PLAYURL: <line19> playMedia(channelUID, command); <line20> break; <line21> case STOP: <line22> stopMedia(channelUID, command); <line23> break; <line24> default: <line25> break; <line26> } <line27> } <line28> } <line29> 	"<line25>        logger.debug(""Thing {}: unexpected command {} from channel {}"",getThing().getUID(),command,channelUID.getId());"	task4	
public class A { <line0> private void setMemberGroups( <line1> final CoreSession session, final String memberDN, final Set<String> groups) <line2> throws LdapException { <line3> final Set<String> newGroups = (groups == null) ? new HashSet<>() : new HashSet<>(groups); <line4> final Set<String> oldgroupDNs = getDNsOfGroupsContainingMember(session, memberDN); <line5> final Set<String> newgroupDNs = new HashSet<>(); <line6> for (String groupName : newGroups) { <line7> newgroupDNs.add(getGroupDN(groupName)); <line8> } <line9> final Set<String> tempOldgroupDNs = new HashSet<>(oldgroupDNs); <line10> tempOldgroupDNs.removeAll(newgroupDNs); <line11> for (String groupDN : tempOldgroupDNs) { <line12> removeMemberFromRoleOrGroup(session, groupDN, memberDN, UNIQUE_MEMBER); <line13> } <line14> newgroupDNs.removeAll(oldgroupDNs); <line15> if (this.rodaAdminDN.equals(memberDN)) { <line16> newgroupDNs.add(this.rodaAdministratorsDN); <line17> } <line18> for (String groupDN : newgroupDNs) { <line19> try { <line20> addMemberToRoleOrGroup(session, groupDN, memberDN, UNIQUE_MEMBER); <line21> } catch (final LdapNoSuchObjectException e) { <line22> } <line23> } <line24> } <line25> } <line26> 	"<line22>        LOGGER.debug(""Group {} doesn't exist"", groupDN);"	task4	
"public class A { <line0> @Override <line1> public void updateConfig(AvatarConfig config) throws ApsSystemException { <line2> try { <line3> String xml = new AvatarConfigDOM().createConfigXml(config); <line4> this.getConfigManager().updateConfigItem(JpAvatarSystemConstants.CONFIG_ITEM, xml); <line5> this.setConfig(config); <line6> } catch (Throwable t) { <line7> throw new ApsSystemException(""Error updating jpavatar config"", t); <line8> } <line9> } <line10> } <line11> "	"<line7>      logger.error(""Error updating jpavatar config"", t);"	task4	
public class A { <line0> @Override <line1> public void setValency(Integer valency) { <line2> super.setValency(valency); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Setting valency: "", valency);"	task4	
"public class A { <line0> public static java.util.List<com.liferay.calendar.model.CalendarBooking> getCalendarBookings( <line1> HttpPrincipal httpPrincipal, long calendarId, long startTime, long endTime) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CalendarBookingServiceUtil.class, <line7> ""getCalendarBookings"", <line8> _getCalendarBookingsParameterTypes12); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, calendarId, startTime, endTime); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.calendar.model.CalendarBooking>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static com.liferay.message.boards.model.MBBan addBan( <line1> HttpPrincipal httpPrincipal, <line2> long banUserId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = new MethodKey(MBBanServiceUtil.class, ""addBan"", _addBanParameterTypes0); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, banUserId, serviceContext); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.message.boards.model.MBBan) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>      log.error(systemException, systemException);	task4	
"public class A { <line0> public void registerUuid(String key) throws DaikinCommunicationException { <line1> Map<String, String> params = new HashMap<>(); <line2> params.put(""key"", key); <line3> String response = invoke(registerUuidUri, params); <line4> } <line5> } <line6> "	"<line4>    logger.debug(""registerUuid result: {}"", response);"	task4	
"public class A { <line0> public boolean isFinancialYearActiveForPosting(Date fromDate, Date toDate) { <line1> String result = """"; <line2> Query query = <line3> getCurrentSession() <line4> .createQuery( <line5> "" from CFinancialYear cfinancialyear where  "" <line6> + "" cfinancialyear.isActiveForPosting=false and cfinancialyear.startingDate"" <line7> + "" <=:sDate and cfinancialyear.endingDate >=:eDate  ""); <line8> query.setDate(""sDate"", fromDate); <line9> query.setDate(""eDate"", toDate); <line10> ArrayList list = (ArrayList) query.list(); <line11> if (list.size() > 0) return false; <line12> else return true; <line13> } <line14> } <line15> "	"<line1>    logger.info(""Obtained session"");"	task4	
public class A { <line0> protected boolean handleEnv(Buffer buffer) throws IOException { <line1> String name = buffer.getString(); <line2> String value = buffer.getString(); <line3> addEnvVariable(name, value); <line4> return true; <line5> } <line6> } <line7> 	"<line4>    log.debug(""env for channel {}: {} = {}"", new Object[] {id, name, value});"	task4	
"public class A { <line0> protected void processRequest(HttpServletRequest request, HttpServletResponse response) <line1> throws ServletException, IOException { <line2> PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS); <line3> String system = policy.sanitize(request.getParameter(""system"")); <line4> ApplicationContext appContext = <line5> WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()); <line6> ITestCaseService testService = appContext.getBean(ITestCaseService.class); <line7> JSONArray array = new JSONArray(); <line8> JSONObject jsonObject = new JSONObject(); <line9> for (String test : testService.findTestWithTestCaseActiveAutomatedBySystem(system)) { <line10> array.put(test); <line11> } <line12> try { <line13> jsonObject.put(""testsList"", array); <line14> response.setContentType(""application/json""); <line15> response.getWriter().print(jsonObject.toString()); <line16> } catch (JSONException exception) { <line17> } <line18> } <line19> } <line20> "	<line17>      LOG.warn(exception.toString());	task4	
public class A { <line0> private void initHeapStates() throws Exception { <line1> requestCount += 1; <line2> RowData partitionKey = (RowData) keyContext.getCurrentKey(); <line3> buffer = kvSortedMap.get(partitionKey); <line4> rowKeyMap = kvRowKeyMap.get(partitionKey); <line5> if (buffer == null) { <line6> buffer = new TopNBuffer(sortKeyComparator, LinkedHashSet::new); <line7> rowKeyMap = new HashMap<>(); <line8> kvSortedMap.put(partitionKey, buffer); <line9> kvRowKeyMap.put(partitionKey, rowKeyMap); <line10> Iterator<Map.Entry<RowData, Tuple2<RowData, Integer>>> iter = dataState.iterator(); <line11> if (iter != null) { <line12> Map<RowData, TreeMap<Integer, RowData>> tempSortedMap = new HashMap<>(); <line13> while (iter.hasNext()) { <line14> Map.Entry<RowData, Tuple2<RowData, Integer>> entry = iter.next(); <line15> RowData rowKey = entry.getKey(); <line16> Tuple2<RowData, Integer> recordAndInnerRank = entry.getValue(); <line17> RowData record = recordAndInnerRank.f0; <line18> Integer innerRank = recordAndInnerRank.f1; <line19> rowKeyMap.put(rowKey, new RankRow(record, innerRank, false)); <line20> RowData sortKey = sortKeySelector.getKey(record); <line21> TreeMap<Integer, RowData> treeMap = tempSortedMap.get(sortKey); <line22> if (treeMap == null) { <line23> treeMap = new TreeMap<>(); <line24> tempSortedMap.put(sortKey, treeMap); <line25> } <line26> treeMap.put(innerRank, rowKey); <line27> } <line28> Iterator<Map.Entry<RowData, TreeMap<Integer, RowData>>> tempIter = <line29> tempSortedMap.entrySet().iterator(); <line30> while (tempIter.hasNext()) { <line31> Map.Entry<RowData, TreeMap<Integer, RowData>> entry = tempIter.next(); <line32> RowData sortKey = entry.getKey(); <line33> TreeMap<Integer, RowData> treeMap = entry.getValue(); <line34> Iterator<Map.Entry<Integer, RowData>> treeMapIter = treeMap.entrySet().iterator(); <line35> while (treeMapIter.hasNext()) { <line36> Map.Entry<Integer, RowData> treeMapEntry = treeMapIter.next(); <line37> Integer innerRank = treeMapEntry.getKey(); <line38> RowData recordRowKey = treeMapEntry.getValue(); <line39> int size = buffer.put(sortKey, recordRowKey); <line40> if (innerRank != size) { <line41> } <line42> } <line43> } <line44> } <line45> } else { <line46> hitCount += 1; <line47> } <line48> } <line49> } <line50> 	"<line41>              LOG.warn(""Failed to build sorted map from state, this may result in wrong result. ""+ ""The sort key is {}, partition key is {}, ""+ ""treeMap is {}. The expected inner rank is {}, but current size is {}."",sortKey,partitionKey,treeMap,innerRank,size);"	task4	
public class A { <line0> @Override <line1> public String getTypeName(Locale locale, long subtypeId) { <line2> try { <line3> DLFileEntryType dlFileEntryType = _dlFileEntryTypeLocalService.getFileEntryType(subtypeId); <line4> return dlFileEntryType.getName(locale); <line5> } catch (Exception exception) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> return super.getTypeName(locale, subtypeId); <line9> } <line10> } <line11> } <line12> 	<line7>        log.debug(exception, exception);	task4	
public class A { <line0> @Override <line1> public boolean offer(ProcessContext context) throws FrameworkException { <line2> List<EventConsumer> eventHandlers = getEventConsumers(context.getClass()); <line3> if (CollectionUtils.isEmpty(eventHandlers)) { <line4> if (LOGGER.isWarnEnabled()) { <line5> } <line6> return false; <line7> } <line8> boolean isFirstEvent = false; <line9> Stack<ProcessContext> currentStack = <line10> (Stack<ProcessContext>) context.getVariable(VAR_NAME_SYNC_EXE_STACK); <line11> if (currentStack == null) { <line12> synchronized (context) { <line13> currentStack = (Stack<ProcessContext>) context.getVariable(VAR_NAME_SYNC_EXE_STACK); <line14> if (currentStack == null) { <line15> currentStack = new Stack<>(); <line16> context.setVariable(VAR_NAME_SYNC_EXE_STACK, currentStack); <line17> isFirstEvent = true; <line18> } <line19> } <line20> } <line21> currentStack.push(context); <line22> if (isFirstEvent) { <line23> try { <line24> while (currentStack.size() > 0) { <line25> ProcessContext currentContext = currentStack.pop(); <line26> for (EventConsumer eventHandler : eventHandlers) { <line27> eventHandler.process(currentContext); <line28> } <line29> } <line30> } finally { <line31> context.removeVariable(VAR_NAME_SYNC_EXE_STACK); <line32> } <line33> } <line34> return true; <line35> } <line36> } <line37> 	"<line5>        LOGGER.warn(""cannot find event handler by class: "" + context.getClass());"	task4	
public class A { <line0> public void stop() { <line1> if (server != null) { <line2> server.shutdown(); <line3> } <line4> } <line5> } <line6> 	"<line3>      LOG.info(""*** server shut down"");"	task4	
"public class A { <line0> private ComboPooledDataSource getComboPooledDataSource( <line1> String type, String host, String name, String driver, String user, String pass) { <line2> final String jdbcUrlTemplate = ""jdbc:%s://%s/%s""; <line3> ComboPooledDataSource pool = new ComboPooledDataSource(); <line4> try { <line5> pool.setDriverClass(driver); <line6> } catch (PropertyVetoException ex) { <line7> } <line8> final String jdbcUrl = String.format(jdbcUrlTemplate, type, host, name); <line9> pool.setJdbcUrl(jdbcUrl); <line10> pool.setUser(user); <line11> pool.setPassword(pass); <line12> pool.setMinPoolSize(1); <line13> pool.setMaxPoolSize(100); <line14> pool.setUnreturnedConnectionTimeout(30000); <line15> pool.setTestConnectionOnCheckout(false); <line16> pool.setTestConnectionOnCheckin(true); <line17> pool.setIdleConnectionTestPeriod(60); <line18> pool.setPreferredTestQuery(""SELECT 1""); <line19> return pool; <line20> } <line21> } <line22> "	"<line7>      logger.error(""Error when setting the database driver "" + driver + ""{}"", ex.getMessage());"	task4	
public class A { <line0> private void killBookie( <line1> ArrayList<BookieSocketAddress> firstEnsemble, BookieSocketAddress ensemble) <line2> throws InterruptedException { <line3> killBookie(ensemble); <line4> } <line5> } <line6> 	"<line3>    LOG.info(""Killing "" + ensemble + "" from ensemble="" + firstEnsemble);"	task4	
public class A { <line0> @Override <line1> public synchronized void saveHistory() { <line2> try { <line3> FileUtils.saveCommandHistoryString(history, new File(Constants.CMD_HISTORY_FILE)); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      logger.error(""save command history failed"", e);"	task4	
"public class A { <line0> @Test <line1> public void testGetRootFolder() throws Exception { <line2> final com.box.sdk.BoxFolder result = requestBody(""direct://GETROOTFOLDER"", null); <line3> assertNotNull(result, ""getRootFolder result""); <line4> } <line5> } <line6> "	"<line4>    LOG.debug(""getRootFolder: "" + result);"	task4	
public class A { <line0> @Override <line1> public void render( <line2> List<JournalArticle> articles, InfoListRendererContext infoListRendererContext) { <line3> InfoListBasicListTag infoListBasicListTag = new InfoListBasicListTag(); <line4> infoListBasicListTag.setInfoListObjects(articles); <line5> Optional<String> infoListItemRendererKeyOptional = <line6> infoListRendererContext.getListItemRendererKeyOptional(); <line7> if (infoListItemRendererKeyOptional.isPresent() <line8> && Validator.isNotNull(infoListItemRendererKeyOptional.get())) { <line9> infoListBasicListTag.setItemRendererKey(infoListItemRendererKeyOptional.get()); <line10> } else { <line11> infoListBasicListTag.setItemRendererKey(JournalArticleTitleInfoItemRenderer.class.getName()); <line12> } <line13> infoListBasicListTag.setListStyleKey(getListStyle()); <line14> Optional<String> templateKeyOptional = infoListRendererContext.getTemplateKeyOptional(); <line15> if (templateKeyOptional.isPresent() && Validator.isNotNull(templateKeyOptional.get())) { <line16> infoListBasicListTag.setTemplateKey(templateKeyOptional.get()); <line17> } <line18> try { <line19> infoListBasicListTag.doTag( <line20> infoListRendererContext.getHttpServletRequest(), <line21> infoListRendererContext.getHttpServletResponse()); <line22> } catch (Exception exception) { <line23> } <line24> } <line25> } <line26> 	"<line23>      log.error(""Unable to render journal articles list"", exception);"	task4	
"public class A { <line0> protected boolean checkSavedPreviousResource(DfAlterCheckFinalInfo finalInfo) { <line1> final boolean unzipped = extractPreviousResource(); <line2> try { <line3> playPreviousSchema(); <line4> } catch (RuntimeException threwLater) { <line5> markPreviousNG(getAlterCheckSavePreviousFailureNotice()); <line6> setupAlterCheckSavePreviousFailureException(finalInfo, threwLater); <line7> } <line8> if (finalInfo.isFailure()) { <line9> finalInfo.addDetailMessage(""x (save failure)""); <line10> return false; <line11> } <line12> if (unzipped) { <line13> deleteExtractedPreviousResource(); <line14> } <line15> return true; <line16> } <line17> } <line18> "	"<line2>    log.info(""...Checking previous resources by replacing"");"	task4	
public class A { <line0> public Object eval(String expression, Map<String, Object> vars) { <line1> try { <line2> Object obj = compile(expression, context); <line3> return MVEL.executeExpression(obj, vars); <line4> } catch (Throwable e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	"<line5>      log.error(""eval expression {} error"", expression, e);"	task4	
"public class A { <line0> public String registerBlockListener( <line1> BlockingQueue<QueuedBlockEvent> blockEventQueue, long timeout, TimeUnit timeUnit) <line2> throws InvalidArgumentException { <line3> if (shutdown) { <line4> throw new InvalidArgumentException(format(""Channel %s has been shutdown."", name)); <line5> } <line6> if (null == blockEventQueue) { <line7> throw new InvalidArgumentException(""BlockEventQueue parameter is null.""); <line8> } <line9> if (timeout < 0L) { <line10> throw new InvalidArgumentException( <line11> format(""Timeout parameter must be greater than 0 not %d"", timeout)); <line12> } <line13> if (null == timeUnit) { <line14> throw new InvalidArgumentException(""TimeUnit parameter must not be null.""); <line15> } <line16> String handle = new BL(blockEventQueue, timeout, timeUnit).getHandle(); <line17> return handle; <line18> } <line19> } <line20> "	"<line17>    logger.trace(format(""Register QueuedBlockEvent listener %s"", handle));"	task4	
"public class A { <line0> @Test( <line1> groups = {""TestClusteringService""}, <line2> dependsOnMethods = {""testCreateDhcpVmFolderFailed""}) <line3> public void testCreateDhcpVmNullResult() { <line4> List<NetworkAdd> networkAdds = createNetworkAdd(); <line5> List<BaseNode> vNodes = new ArrayList<BaseNode>(); <line6> BaseNode node = new BaseNode(""test-master-0""); <line7> ClusterCreate spec = createClusterSpec(); <line8> node.setCluster(spec); <line9> VmSchema vmSchema = createVmSchema(); <line10> node.setVmSchema(vmSchema); <line11> vNodes.add(node); <line12> MockTmScheduler.setFlag(VmOperation.CREATE_FOLDER, true); <line13> MockTmScheduler.setResultIsNull(true); <line14> try { <line15> service.createVcVms(spec, vNodes, null, false, null); <line16> Assert.assertTrue(false, ""should throw exception but not.""); <line17> } catch (Exception e) { <line18> Assert.assertTrue(true, ""got expected exception.""); <line19> } <line20> } <line21> } <line22> "	<line18>      logger.info(e.getMessage(), e);	task4	
public class A { <line0> @Override <line1> public CoachShuttleGatheringSolution readSolution() throws IOException { <line2> solution = new CoachShuttleGatheringSolution(); <line3> solution.setId(0L); <line4> readLocationList(); <line5> busOrStopOrHubId = 0L; <line6> readBusList(); <line7> readBusStopList(); <line8> int busListSize = solution.getCoachList().size() + solution.getShuttleList().size(); <line9> int base = solution.getStopList().size() + solution.getShuttleList().size(); <line10> BigInteger a = factorial(base + busListSize - 1); <line11> BigInteger b = factorial(busListSize - 1); <line12> BigInteger possibleSolutionSize = (a == null || b == null) ? null : a.divide(b); <line13> return solution; <line14> } <line15> } <line16> 	"<line13>    logger.info(""CoachShuttleGathering {} has {} road locations, {} coaches, {} shuttles and {} bus stops""+ "" with a search space of {}."",getInputId(),solution.getLocationList().size(),solution.getCoachList().size(),solution.getShuttleList().size(),solution.getStopList().size(),getFlooredPossibleSolutionSize(possibleSolutionSize));"	task4	
public class A { <line0> @Override <line1> protected ApplicationTO resolveReference(final Method method, final Object... args) <line2> throws UnresolvedReferenceException { <line3> String key = null; <line4> if (ArrayUtils.isNotEmpty(args)) { <line5> for (int i = 0; key == null && i < args.length; i++) { <line6> if (args[i] instanceof String) { <line7> key = (String) args[i]; <line8> } else if (args[i] instanceof ApplicationTO) { <line9> key = ((ApplicationTO) args[i]).getKey(); <line10> } <line11> } <line12> } <line13> if (key != null) { <line14> try { <line15> return binder.getApplicationTO(applicationDAO.find(key)); <line16> } catch (Throwable ignore) { <line17> throw new UnresolvedReferenceException(ignore); <line18> } <line19> } <line20> throw new UnresolvedReferenceException(); <line21> } <line22> } <line23> 	"<line17>        LOG.debug(""Unresolved reference"", ignore);"	task4	
"public class A { <line0> @Test <line1> public void testGrantResource() throws Exception { <line2> MultiValueMap<String, String> paramsMap = new LinkedMultiValueMap<>(); <line3> paramsMap.add(""userId"", ""32""); <line4> paramsMap.add(""resourceIds"", ""5""); <line5> MvcResult mvcResult = <line6> mockMvc <line7> .perform(post(""/users/grant-file"").header(SESSION_ID, sessionId).params(paramsMap)) <line8> .andExpect(status().isOk()) <line9> .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8)) <line10> .andReturn(); <line11> Result result = <line12> JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class); <line13> Assert.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue()); <line14> } <line15> } <line16> "	<line14>    logger.info(mvcResult.getResponse().getContentAsString());	task4	
public class A { <line0> public Module find(final Long id) { <line1> return moduleRepository.findOne(id); <line2> } <line3> } <line4> 	"<line1>    log.debug(""find() - id: {}"", id);"	task4	
public class A { <line0> private void loadTimelinesFromTableProperties( <line1> UpdatePeriod updatePeriod, String storageTableName, String timeLineKey) <line2> throws HiveException, LensException { <line3> for (String partCol : getTimePartColNamesOfTable(storageTableName)) { <line4> ensureEntry(timeLineKey, storageTableName, updatePeriod, partCol) <line5> .init(getTable(storageTableName)); <line6> } <line7> } <line8> } <line9> 	"<line3>    log.info(""loading from table properties: {}"", storageTableName);"	task4	
public class A { <line0> protected Function<InternalEvent, InternalEvent> doAfter( <line1> SourceInterceptor interceptor, Component component, Optional<Throwable> thrown) { <line2> return event -> { <line3> final InternalEvent eventWithResolvedParams = removeResolvedParameters(event); <line4> DefaultInterceptionEvent interceptionEvent = <line5> new DefaultInterceptionEvent(eventWithResolvedParams); <line6> try { <line7> Thread currentThread = currentThread(); <line8> ClassLoader originalTCCL = currentThread.getContextClassLoader(); <line9> ClassLoader ctxClassLoader = interceptor.getClass().getClassLoader(); <line10> setContextClassLoader(currentThread, originalTCCL, ctxClassLoader); <line11> try { <line12> interceptor.afterCallback(component.getLocation(), interceptionEvent, thrown); <line13> } finally { <line14> setContextClassLoader(currentThread, ctxClassLoader, originalTCCL); <line15> } <line16> return interceptionEvent.resolve(); <line17> } catch (Exception e) { <line18> throw propagate( <line19> resolveMessagingException( <line20> interceptionEvent.resolve(), e.getCause(), component, empty())); <line21> } <line22> }; <line23> } <line24> } <line25> 	"<line6>      LOGGER.debug(""Calling after() for '{}' in processor '{}'..."",interceptor,component.getLocation().getLocation());"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Thread.sleep(initialSleep); <line4> } catch (InterruptedException e) { <line5> } <line6> } <line7> } <line8> 	<line5>      LOG.warn(e.getMessage(), e);	task4	
public class A { <line0> public String safeGetJCRPath(Path path) { <line1> try { <line2> return context.getJCRPath(path); <line3> } catch (NamespaceException e) { <line4> return path.toString(); <line5> } <line6> } <line7> } <line8> 	"<line4>      log.error(""failed to convert {} to a JCR path"", path);"	task4	
"public class A { <line0> static void addRegistrationDateColumn(Statement st, String tableName, Columns col) <line1> throws SQLException { <line2> st.executeUpdate( <line3> ""ALTER TABLE "" <line4> + tableName <line5> + "" ADD COLUMN "" <line6> + col.REGISTRATION_DATE <line7> + "" BIGINT NOT NULL DEFAULT 0;""); <line8> long currentTimestamp = System.currentTimeMillis(); <line9> int updatedRows = <line10> st.executeUpdate( <line11> String.format( <line12> ""UPDATE %s SET %s = %d;"", tableName, col.REGISTRATION_DATE, currentTimestamp)); <line13> } <line14> } <line15> "	"<line13>    logger.info(""Created column '""+ col.REGISTRATION_DATE+ ""' and set the current timestamp, ""+ currentTimestamp+ "", to all ""+ updatedRows+ "" rows"");"	task4	
"public class A { <line0> @Nullable <line1> private static BitfinexWebSocketAuthBalance createBalanceObject(JsonNode balance) { <line2> if (balance.size() < 5) { <line3> return null; <line4> } <line5> String walletType = balance.get(0).textValue(); <line6> String currency = balance.get(1).textValue(); <line7> BigDecimal balanceValue = balance.get(2).decimalValue(); <line8> BigDecimal unsettledInterest = balance.get(3).decimalValue(); <line9> BigDecimal balanceAvailable = <line10> balance.get(4).asText().equals(""null"") ? null : balance.get(4).decimalValue(); <line11> return new BitfinexWebSocketAuthBalance( <line12> walletType, currency, balanceValue, unsettledInterest, balanceAvailable); <line13> } <line14> } <line15> "	"<line3>      LOG.error(""createBalanceObject unexpected record size={}, record={}"",balance.size(),balance.toString());"	task4	
"public class A { <line0> public String fetchDataViewerFormats() throws JSONException { <line1> String connURL; <line2> if (dataViewerUrl.endsWith(""/"")) { <line3> connURL = dataViewerUrl + ""api/explain/formats""; <line4> } else { <line5> connURL = dataViewerUrl + ""/api/explain/formats""; <line6> } <line7> DefaultHttpClient httpclient = new DefaultHttpClient(); <line8> HttpGet httpget = new HttpGet(connURL); <line9> HttpResponse resp; <line10> String str = """"; <line11> try { <line12> resp = httpclient.execute(httpget); <line13> if (200 == resp.getStatusLine().getStatusCode()) { <line14> HttpEntity entity = resp.getEntity(); <line15> if (entity != null) { <line16> String retSrc = EntityUtils.toString(entity); <line17> JSONArray array = new JSONArray(retSrc); <line18> int i = 0; <line19> while (i < array.length()) { <line20> str += array.get(i) + "", ""; <line21> i++; <line22> } <line23> } <line24> } <line25> } catch (Exception e) { <line26> } <line27> setDataViewerFormatListString(str); <line28> return """"; <line29> } <line30> } <line31> "	<line26>      LOGGER.error(e.getMessage(), e);	task4	
public class A { <line0> private void registerQueries() throws IOException { <line1> try (InputStream stream = <line2> this.getClass().getResourceAsStream(TASK_ASSIGNING_QUERY_DEFINITIONS_RESOURCE)) { <line3> if (stream == null) { <line4> throw new FileNotFoundException(QUERIES_RESOURCE_NOT_FOUND); <line5> } <line6> final Marshaller marshaller = <line7> MarshallerFactory.getMarshaller(MarshallingFormat.JSON, getClass().getClassLoader()); <line8> final String queriesString = IOUtils.toString(stream, StandardCharsets.UTF_8); <line9> final QueryDefinition[] queries = <line10> marshaller.unmarshall(queriesString, QueryDefinition[].class); <line11> if (queries == null || queries.length == 0) { <line12> return; <line13> } <line14> registerQueries(queries); <line15> } <line16> } <line17> } <line18> 	"<line12>        LOGGER.info(""No queries were found"");"	task4	
"public class A { <line0> public static com.liferay.commerce.model.CommerceShipment getCommerceShipment( <line1> HttpPrincipal httpPrincipal, long commerceShipmentId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceShipmentServiceUtil.class, <line7> ""getCommerceShipment"", <line8> _getCommerceShipmentParameterTypes4); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceShipmentId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.model.CommerceShipment) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> @Test <line1> public void testGetPaginatedGroup() { <line2> super.testGetPaginatedEntities(); <line3> } <line4> } <line5> 	"<line2>    LOGGER.debug(""testGetPaginatedGroup"");"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> sendHeartbeat(false); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.error(""Error performing heartbeat: "" + e.getMessage());"	task4	
public class A { <line0> @Override <line1> public HandlerResult handle(ProcessState state, ProcessInstance process) { <line2> Secret secret = (Secret) state.getResource(); <line3> String secretValue = secret.getValue(); <line4> if (StringUtils.isNotBlank(secretValue)) { <line5> try { <line6> secretsService.delete(secret.getAccountId(), secret.getValue()); <line7> } catch (IOException e) { <line8> throw new IllegalStateException(e); <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	"<line8>        log.error(""Failed to delete secret from storage [{}]"", secret.getId(), e);"	task4	
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> User user = twitter.updateProfileImage(image); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.updatedProfileImage(user); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.warn(""Exception at updateProfileImage"", e);"	task4	
"public class A { <line0> public String getRemoteBssWsUrl() { <line1> String servletAddress = ""https://"" + host + "":"" + port + ""/oscm/""; <line2> if (serviceVersion != null) { <line3> servletAddress += serviceVersion + ""/""; <line4> } <line5> servletAddress += serviceName + ""/"" + servicePort.name(); <line6> String url = servletAddress + ""?wsdl""; <line7> if (ServicePort.STS.equals(servicePort)) { <line8> String tenantParam = ""&tenantID="" + tenantId; <line9> url += tenantParam; <line10> } <line11> verifyAttributes(url); <line12> return url; <line13> } <line14> } <line15> "	<line11>    logger.debug(url);	task4	
"public class A { <line0> String removeFromStart(String string, int numberToRemove) { <line1> int startingFrom = string.indexOf(""#EXTINF:""); <line2> for (int loop = numberToRemove; loop > 0; loop--) { <line3> startingFrom = string.indexOf(""#EXTINF:"", startingFrom + 27); <line4> if (startingFrom == -1) { <line5> return string; <line6> } <line7> } <line8> mediaSequence = mediaSequence + numberToRemove; <line9> entries = entries - numberToRemove; <line10> return string.substring(startingFrom); <line11> } <line12> } <line13> "	"<line5>        logger.warn(""Playlist failed to remove entries from start, check all cameras in groups use the same""+ "" HLS settings."");"	task4	
"public class A { <line0> @Override <line1> public void deleteProjects(List<Project> projects) { <line2> EKBCommit commit = getEKBCommit(); <line3> preparePersistenceAccess(); <line4> for (Project project : projects) { <line5> List<Project> result = <line6> queryService.query(Project.class, QueryRequest.query(""name"", project.getName())); <line7> if (result.size() == 0) { <line8> } else { <line9> commit.addDelete(project); <line10> } <line11> deleteAllAssignmentsForProject(project); <line12> } <line13> persistService.commit(commit); <line14> revokePersistenceAccess(); <line15> } <line16> } <line17> "	"<line8>        LOGGER.warn(""Project {1} does not exist."", project.getName());"	task4	
public class A { <line0> public void reportActiveUser(String id) { <line1> if (!initialized) { <line2> return; <line3> } <line4> if (StringUtils.isBlank(id)) { <line5> return; <line6> } <line7> try { <line8> setupCurrentEntry(); <line9> hll.addRaw(id.hashCode()); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	"<line11>      log.error(""Failed to report active user."", e);"	task4	
public class A { <line0> private static int extractErrorIndex(final String message) { <line1> if (message != null) { <line2> final Matcher matcher = INDEX_EXTRACTION_PATTERN.matcher(message); <line3> if (matcher.find()) { <line4> try { <line5> return Integer.parseInt(matcher.group(1)); <line6> } catch (NumberFormatException ex) { <line7> } <line8> } <line9> } <line10> return -1; <line11> } <line12> } <line13> 	"<line7>          LOGGER.debug(""Can't parse the matched number."", ex);"	task4	
"public class A { <line0> @Test <line1> public void testLanguageJsonSchema() throws Exception { <line2> CamelContext context = new DefaultCamelContext(); <line3> String json = context.getLanguageParameterJsonSchema(""groovy""); <line4> assertNotNull(""Should have found some auto-generated JSON"", json); <line5> assertTrue(json.contains(""\""name\"": \""groovy\"""")); <line6> assertTrue(json.contains(""\""modelName\"": \""groovy\"""")); <line7> } <line8> } <line9> "	<line5>    log.info(json);	task4	
"public class A { <line0> private Map<String, Object> getFeatureOfInterestChanges() { <line1> try { <line2> Map<String, Object> changes = new HashMap<>(); <line3> changes.put(""encodingType"", ""SQUARE""); <line4> changes.put( <line5> ""feature"", new JSONObject(""{ \""type\"": \""Point\"", \""coordinates\"": [-114.05, 51.05] }"")); <line6> changes.put(""name"", ""POIUYTREW""); <line7> changes.put(""description"", ""POIUYTREW""); <line8> return changes; <line9> } catch (JSONException ex) { <line10> Assert.fail(""Generating FeatureOfInterest changes failed: "" + ex.getMessage()); <line11> } <line12> throw new IllegalStateException(); <line13> } <line14> } <line15> "	"<line10>      LOGGER.error(""Exception:"", ex);"	task4	
"public class A { <line0> public static int getGroupArticlesCount( <line1> HttpPrincipal httpPrincipal, long groupId, long userId, long rootFolderId, int status) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> JournalArticleServiceUtil.class, <line7> ""getGroupArticlesCount"", <line8> _getGroupArticlesCountParameterTypes43); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, groupId, userId, rootFolderId, status); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line22>      log.error(systemException, systemException);	task4	
public class A { <line0> @Override <line1> protected void recoverAndCommit(FlinkKafkaProducer.KafkaTransactionState transaction) { <line2> if (transaction.isTransactional()) { <line3> FlinkKafkaInternalProducer<byte[], byte[]> producer = null; <line4> try { <line5> producer = initTransactionalProducer(transaction.transactionalId, false); <line6> producer.resumeTransaction(transaction.producerId, transaction.epoch); <line7> producer.commitTransaction(); <line8> } catch (InvalidTxnStateException | ProducerFencedException ex) { <line9> } finally { <line10> if (producer != null) { <line11> producer.close(0, TimeUnit.SECONDS); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> 	"<line9>        LOG.warn(""Encountered error {} while recovering transaction {}. ""+ ""Presumably this transaction has been already committed before"",ex,transaction);"	task4	
public class A { <line0> @Override <line1> public boolean distinguishRole(@Nonnull PsiElementRole role) { <line2> switch (role) { <line3> case VARIABLE_NAME: <line4> return DISTINGUISH_VARIABLES; <line5> case FIELD_NAME: <line6> return DISTINGUISH_VARIABLES; <line7> case FUNCTION_NAME: <line8> return DISTINGUISH_FUNCTIONS; <line9> default: <line10> return true; <line11> } <line12> } <line13> } <line14> 	"<line10>        LOG.error(""Unknown role "" + role);"	task4	
"public class A { <line0> @AdapterDelegationEvent( <line1> beforeBuilder = PRPAIN201305UV02EventDescriptionBuilder.class, <line2> afterReturningBuilder = PRPAIN201306UV02EventDescriptionBuilder.class, <line3> serviceType = ""Patient Discovery"", <line4> version = ""LEVEL_a0"") <line5> @Override <line6> public PRPAIN201306UV02 respondingGatewayPRPAIN201305UV02( <line7> PRPAIN201305UV02 body, AssertionType assertion) { <line8> return new PRPAIN201306UV02(); <line9> } <line10> } <line11> "	"<line8>    LOG.debug(""Entering AdapterPatientDiscoveryProxyNoOpImpl.respondingGatewayPRPAIN201305UV02"");"	task4	
"public class A { <line0> @Test <line1> public void testTimePositionSubset() { <line2> String xml = <line3> ""<wfs:GetFeature "" <line4> + ""service=\""WFS\"" "" <line5> + ""version=\""1.1.0\"" "" <line6> + ""outputFormat=\""gml32\"" "" <line7> + ""xmlns:cdf=\""http://www.opengis.net/cite/data\"" "" <line8> + ""xmlns:ogc=\""http://www.opengis.net/ogc\"" "" <line9> + ""xmlns:wfs=\""http://www.opengis.net/wfs\"" "" <line10> + ""xmlns:gml=\""http://www.opengis.net/gml/3.2\"" "" <line11> + ""xmlns:csml=\"""" <line12> + TimeSeriesMockData.CSML_URI <line13> + ""\"" xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" "" <line14> + ""xsi:schemaLocation=\""http://www.opengis.net/wfs"" <line15> + "" http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\""><wfs:Query"" <line16> + "" typeName=\""csml:PointSeriesFeature\"">    <ogc:Filter>       "" <line17> + "" <ogc:PropertyIsBetween>            "" <line18> + "" <ogc:PropertyName>csml:PointSeriesFeature/csml:value/csml:PointSeriesCoverage/csml:pointSeriesDomain/csml:TimeSeries/csml:timePositionList</ogc:PropertyName>"" <line19> + ""            "" <line20> + "" <ogc:LowerBoundary><ogc:Literal>1949-05-01</ogc:Literal></ogc:LowerBoundary>       "" <line21> + ""      <ogc:UpperBoundary><ogc:Literal>1949-09-01</ogc:Literal></ogc:UpperBoundary>  "" <line22> + ""      </ogc:PropertyIsBetween>    </ogc:Filter></wfs:Query> </wfs:GetFeature>""; <line23> validate(xml); <line24> Document doc = postAsDOM(""wfs"", xml); <line25> assertEquals(""wfs:FeatureCollection"", doc.getDocumentElement().getNodeName()); <line26> assertXpathEvaluatesTo(""1"", ""/wfs:FeatureCollection/@numberReturned"", doc); <line27> assertXpathCount(1, ""//csml:PointSeriesFeature"", doc); <line28> checkPointFeatureTwo(doc); <line29> assertXpathEvaluatesTo( <line30> ""1949-05-01 1949-06-01 1949-07-01 1949-08-01 1949-09-01"", <line31> ""//csml:PointSeriesFeature[@gml:id='ID2"" <line32> + ""']/csml:value/csml:PointSeriesCoverage/csml:pointSeriesDomain/csml:TimeSeries/csml:timePositionList"", <line33> doc); <line34> assertXpathEvaluatesTo( <line35> ""16.2 17.1 22.0 25.1 23.9"", <line36> ""//csml:PointSeriesFeature[@gml:id='ID2"" <line37> + ""']/csml:value/csml:PointSeriesCoverage/gml:rangeSet/gml:ValueArray/gml:valueComponent/gml:QuantityList"", <line38> doc); <line39> } <line40> } <line41> "	"<line25>    LOGGER.info(""WFS filter GetFeature response:\n"" + prettyString(doc));"	task4	
public class A { <line0> @Override <line1> public HtmlPreviewEntry fetchByG_C_C( <line2> long groupId, long classNameId, long classPK, boolean useFinderCache) { <line3> Object[] finderArgs = null; <line4> if (useFinderCache) { <line5> finderArgs = new Object[] {groupId, classNameId, classPK}; <line6> } <line7> Object result = null; <line8> if (useFinderCache) { <line9> result = finderCache.getResult(_finderPathFetchByG_C_C, finderArgs); <line10> } <line11> if (result instanceof HtmlPreviewEntry) { <line12> HtmlPreviewEntry htmlPreviewEntry = (HtmlPreviewEntry) result; <line13> if ((groupId != htmlPreviewEntry.getGroupId()) <line14> || (classNameId != htmlPreviewEntry.getClassNameId()) <line15> || (classPK != htmlPreviewEntry.getClassPK())) { <line16> result = null; <line17> } <line18> } <line19> if (result == null) { <line20> StringBundler sb = new StringBundler(5); <line21> sb.append(_SQL_SELECT_HTMLPREVIEWENTRY_WHERE); <line22> sb.append(_FINDER_COLUMN_G_C_C_GROUPID_2); <line23> sb.append(_FINDER_COLUMN_G_C_C_CLASSNAMEID_2); <line24> sb.append(_FINDER_COLUMN_G_C_C_CLASSPK_2); <line25> String sql = sb.toString(); <line26> Session session = null; <line27> try { <line28> session = openSession(); <line29> Query query = session.createQuery(sql); <line30> QueryPos queryPos = QueryPos.getInstance(query); <line31> queryPos.add(groupId); <line32> queryPos.add(classNameId); <line33> queryPos.add(classPK); <line34> List<HtmlPreviewEntry> list = query.list(); <line35> if (list.isEmpty()) { <line36> if (useFinderCache) { <line37> finderCache.putResult(_finderPathFetchByG_C_C, finderArgs, list); <line38> } <line39> } else { <line40> if (list.size() > 1) { <line41> Collections.sort(list, Collections.reverseOrder()); <line42> if (log.isWarnEnabled()) { <line43> if (!useFinderCache) { <line44> finderArgs = new Object[] {groupId, classNameId, classPK}; <line45> } <line46> } <line47> } <line48> HtmlPreviewEntry htmlPreviewEntry = list.get(0); <line49> result = htmlPreviewEntry; <line50> cacheResult(htmlPreviewEntry); <line51> } <line52> } catch (Exception exception) { <line53> throw processException(exception); <line54> } finally { <line55> closeSession(session); <line56> } <line57> } <line58> if (result instanceof List<?>) { <line59> return null; <line60> } else { <line61> return (HtmlPreviewEntry) result; <line62> } <line63> } <line64> } <line65> 	"<line46>              log.warn(""HtmlPreviewEntryPersistenceImpl.fetchByG_C_C(long, long, long, boolean) with""+ "" parameters (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> List<ActiveQuerySnapshot> activeQueryList = new ArrayList<>(); <line3> cacheLock.readLock().lock(); <line4> try { <line5> for (ActiveQuery q : ActiveQueryLog.this.CACHE.asMap().values()) { <line6> activeQueryList.add(q.snapshot()); <line7> } <line8> } finally { <line9> cacheLock.readLock().unlock(); <line10> } <line11> activeQueryList.sort(ActiveQuerySnapshot.greatestElapsedTime); <line12> List<ActiveQuerySnapshot> sublist = activeQueryList; <line13> if (ActiveQueryLog.this.logMaxQueries > 0) { <line14> sublist = <line15> activeQueryList.subList( <line16> 0, Math.min(ActiveQueryLog.this.logMaxQueries, activeQueryList.size())); <line17> } <line18> if (sublist.size() > 0) { <line19> ActiveQueryLog.this.touch(); <line20> } <line21> for (ActiveQuerySnapshot q : sublist) { <line22> } <line23> } <line24> } <line25> 	<line22>      log.debug(q.toString());	task4	
public class A { <line0> void put(String uuid, CachingIndexReader reader, int n) { <line1> LRUMap cacheSegment = docNumbers[getSegmentIndex(uuid.charAt(0))]; <line2> synchronized (cacheSegment) { <line3> Entry e = (Entry) cacheSegment.get(uuid); <line4> if (e != null) { <line5> if (reader.getCreationTick() <= e.creationTick) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> e = null; <line9> } <line10> } else { <line11> e = new Entry(reader.getCreationTick(), n); <line12> } <line13> if (e != null) { <line14> cacheSegment.put(uuid, e); <line15> } <line16> } <line17> } <line18> } <line19> 	"<line7>            log.debug(""Ignoring put(). New entry is not from a newer reader. ""+ ""existing: ""+ e.creationTick+ "", new: ""+ reader.getCreationTick());"	task4	
"public class A { <line0> public void publish(Release release) { <line1> ServiceRegistration<Release> oldServiceRegistration = <line2> _serviceConfiguratorRegistrations.get(release.getServletContextName()); <line3> if (oldServiceRegistration != null) { <line4> oldServiceRegistration.unregister(); <line5> } <line6> Dictionary<String, Object> properties = new Hashtable<>(); <line7> properties.put(""release.bundle.symbolic.name"", release.getBundleSymbolicName()); <line8> properties.put(""release.state"", release.getState()); <line9> try { <line10> if (Validator.isNotNull(release.getSchemaVersion())) { <line11> Version version = new Version(release.getSchemaVersion()); <line12> properties.put(""release.schema.version"", version); <line13> } <line14> } catch (IllegalArgumentException illegalArgumentException) { <line15> if (log.isWarnEnabled()) { <line16> } <line17> } <line18> ServiceRegistration<Release> newServiceRegistration = <line19> _bundleContext.registerService(Release.class, release, properties); <line20> _serviceConfiguratorRegistrations.put(release.getServletContextName(), newServiceRegistration); <line21> } <line22> } <line23> "	"<line16>        log.warn(""Invalid schema version for release: "" + release, illegalArgumentException);"	task4	
"public class A { <line0> public String getProcessInstanceVariable( <line1> String containerId, Number processInstanceId, String varName, String marshallingType) { <line2> containerId = <line3> context.getContainerId( <line4> containerId, new ByProcessInstanceIdContainerLocator(processInstanceId.longValue())); <line5> Object variable = <line6> processService.getProcessInstanceVariable( <line7> containerId, processInstanceId.longValue(), varName); <line8> if (variable == null) { <line9> throw new IllegalStateException( <line10> ""Unable to find variable '"" <line11> + varName <line12> + ""' within process instance with id "" <line13> + processInstanceId); <line14> } <line15> String response = marshallerHelper.marshal(containerId, marshallingType, variable); <line16> return response; <line17> } <line18> } <line19> "	"<line15>    logger.debug(""About to marshal process variable with name '{}' {}"", varName, variable);"	task4	
public class A { <line0> @PostMapping <line1> public ContextDto create(@Valid @RequestBody ContextDto contextDto) { <line2> final VitamContext vitamContext = <line3> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line4> return contextInternalService.create(vitamContext, contextDto); <line5> } <line6> } <line7> 	"<line2>    LOGGER.debug(""create context={}"", contextDto);"	task4	
"public class A { <line0> private static SecretKey getRootKey() throws KeyManagementException { <line1> try { <line2> String rootKeyHex = CryptoUtils.extractKeyFromBootstrapFile(); <line3> return new SecretKeySpec(Hex.decodeHex(rootKeyHex.toCharArray()), ""AES""); <line4> } catch (IOException | DecoderException e) { <line5> throw new KeyManagementException(e); <line6> } <line7> } <line8> } <line9> "	"<line5>      logger.error(""Encountered an error: "", e);"	task4	
public class A { <line0> public Map<Integer, ImageResourceDimension> getDimensions() { <line1> Map<Integer, ImageResourceDimension> dimensions = <line2> new HashMap<Integer, ImageResourceDimension>(); <line3> List<Element> dimensionElements = _doc.getRootElement().getChildren(TAB_DIMENSION); <line4> if (null != dimensionElements && dimensionElements.size() > 0) { <line5> Iterator<Element> dimensionElementsIter = dimensionElements.iterator(); <line6> while (dimensionElementsIter.hasNext()) { <line7> Element currentElement = (Element) dimensionElementsIter.next(); <line8> ImageResourceDimension dimension = new ImageResourceDimension(); <line9> Element idElement = currentElement.getChild(TAB_ID); <line10> if (null != idElement) { <line11> String id = idElement.getText(); <line12> dimension.setIdDim(Integer.parseInt(id)); <line13> } <line14> Element dimxElement = currentElement.getChild(TAB_DIMX); <line15> if (null != dimxElement) { <line16> String dimx = dimxElement.getText(); <line17> dimension.setDimx(Integer.parseInt(dimx)); <line18> } <line19> Element dimyElement = currentElement.getChild(TAB_DIMY); <line20> if (null != dimyElement) { <line21> String dimy = dimyElement.getText(); <line22> dimension.setDimy(Integer.parseInt(dimy)); <line23> } <line24> dimensions.put(new Integer(dimension.getIdDim()), dimension); <line25> } <line26> } <line27> return dimensions; <line28> } <line29> } <line30> 	"<line25>        logger.debug(""Definita dimensione di resize: {}"", dimension.getIdDim());"	task4	
public class A { <line0> @VisibleForTesting <line1> void logFailure(AttachmentJobStatusResponse response) throws InternalServerErrorException { <line2> CloudStackErrorResponse errorResponse = response.getErrorResponse(); <line3> String errorText = <line4> String.format( <line5> FAILED_ATTACH_ERROR_MESSAGE, <line6> errorResponse.getErrorCode(), <line7> errorResponse.getErrorText()); <line8> } <line9> } <line10> 	<line8>    LOGGER.error(String.format(Messages.Log.ERROR_WHILE_ATTACHING_VOLUME_GENERAL_S, errorText));	task4	
public class A { <line0> void startExport(DocketData docketData, OutputStream os) throws IOException { <line1> try { <line2> Document doc = createDocument(docketData, true); <line3> XMLOutputter outp = new XMLOutputter(); <line4> outp.setFormat(Format.getPrettyFormat()); <line5> outp.output(doc, os); <line6> os.close(); <line7> } catch (RuntimeException e) { <line8> throw new IOException(e); <line9> } <line10> } <line11> } <line12> 	"<line8>      logger.error(""Document creation failed."");"	task4	
public class A { <line0> public int read(final String context) throws IOException { <line1> int b = read(); <line2> return b; <line3> } <line4> } <line5> 	"<line2>    log.trace(""Read {}  byte, val is {}"", context, ByteUtils.formatByte(b));"	task4	
public class A { <line0> private int getPoolSize(String plugin) { <line1> String prop = PROP_POOLSIZE + plugin; <line2> String sPoolSize = agentConfig.getProperty(prop); <line3> if (sPoolSize != null) { <line4> try { <line5> return Integer.parseInt(sPoolSize); <line6> } catch (NumberFormatException exc) { <line7> } <line8> } <line9> return 1; <line10> } <line11> } <line12> 	"<line7>        log.error(""Invalid setting for "" + prop + "" value="" + sPoolSize + "" using defaults."");"	task4	
"public class A { <line0> @Override <line1> public void rip() throws IOException { <line2> Document doc = Http.url(url).get(); <line3> List<String> mp4s = Utils.between(doc.html(), ""file:\"""", ""\""""); <line4> if (mp4s.size() == 0) { <line5> throw new IOException(""Could not find files at "" + url); <line6> } <line7> String vidUrl = mp4s.get(0); <line8> addURLToDownload(new URL(vidUrl), HOST + ""_"" + getGID(this.url)); <line9> waitForThreads(); <line10> } <line11> } <line12> "	"<line2>    logger.info(""Retrieving "" + this.url);"	task4	
"public class A { <line0> @Override <line1> public ContainerBuilder<T> newCustomContainerBuilder(String template) { <line2> if (log.isTraceEnabled()) { <line3> } <line4> Container container = new ContainerImpl(template, null); <line5> @SuppressWarnings(""unchecked"") <line6> T t = (T) this; <line7> return new CustomContainerBuilderImpl<T>(container, t); <line8> } <line9> } <line10> "	"<line3>      log.trace(""Creating a new custom container builder"");"	task4	
public class A { <line0> @Override <line1> public void init() throws Exception { <line2> this.getCacheWrapper().initCache(this.getWidgetTypeDAO()); <line3> } <line4> } <line5> 	"<line3>    logger.debug(""{} ready. Initialized"", this.getClass().getName());"	task4	
public class A { <line0> public DrillRpcFuture<Ack> cancelQuery(QueryId id) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> return client.send(RpcType.CANCEL_QUERY, id, Ack.class); <line4> } <line5> } <line6> 	"<line2>      logger.debug(""Cancelling query {}"", QueryIdHelper.getQueryId(id));"	task4	
"public class A { <line0> private void transformNode( <line1> Node node, Matrix4d inMatrix, Collection<? super AbstractGeometry> results) { <line2> Matrix4d nodeMatrix; <line3> if (node.getMatrix() == null) { <line4> nodeMatrix = null; <line5> } else { <line6> nodeMatrix = new Matrix4d(); <line7> nodeMatrix.set(node.getMatrix(), true); <line8> } <line9> Matrix4d matrix = <line10> nodeMatrix == null ? inMatrix : inMatrix == null ? nodeMatrix : inMatrix.mult(nodeMatrix); <line11> transformInstanceGeometries(node, matrix, results); <line12> for (Node child : node.getNodes()) { <line13> myUnusedTags.remove(""#"" + child.getId()); <line14> transformNode(child, matrix, results); <line15> } <line16> for (InstanceNode ref : node.getInstanceNodes()) { <line17> myUnusedTags.remove(ref.getUrl()); <line18> Node deref = myNodeLibrary.get(ref.getUrl()); <line19> if (deref == null) { <line20> } else { <line21> transformNode(deref, matrix, results); <line22> } <line23> } <line24> } <line25> } <line26> "	"<line20>        LOGGER.warn(""Node instance with url "" + ref.getUrl() + "" not found"");"	task4	
public class A { <line0> public ResponseEntity<ResultsDto> findObjectById(String id, ExternalHttpContext context) { <line1> return archiveSearchExternalRestClient.findObjectById(id, context); <line2> } <line3> } <line4> 	"<line1>    LOGGER.info(""Get the Object Group with Identifier {}"", id);"	task4	
"public class A { <line0> @Override <line1> public void onValueReceived( <line2> @Nullable String variable, @Nullable String value, @Nullable String service) { <line3> if (variable == null) { <line4> return; <line5> } <line6> String oldValue = stateMap.get(variable); <line7> if ((value == null && oldValue == null) || (value != null && value.equals(oldValue))) { <line8> return; <line9> } <line10> stateMap.put(variable, (value != null) ? value : """"); <line11> for (EventListener listener : listeners) { <line12> switch (variable) { <line13> case ""CurrentVolume"": <line14> listener.valueReceived( <line15> VOLUME, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line16> break; <line17> case ""CurrentMute"": <line18> State newState = UnDefType.UNDEF; <line19> if (value != null) { <line20> newState = value.equals(""true"") ? OnOffType.ON : OnOffType.OFF; <line21> } <line22> listener.valueReceived(MUTE, newState); <line23> break; <line24> case ""CurrentBrightness"": <line25> listener.valueReceived( <line26> BRIGHTNESS, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line27> break; <line28> case ""CurrentContrast"": <line29> listener.valueReceived( <line30> CONTRAST, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line31> break; <line32> case ""CurrentSharpness"": <line33> listener.valueReceived( <line34> SHARPNESS, (value != null) ? new PercentType(value) : UnDefType.UNDEF); <line35> break; <line36> case ""CurrentColorTemperature"": <line37> listener.valueReceived( <line38> COLOR_TEMPERATURE, (value != null) ? new DecimalType(value) : UnDefType.UNDEF); <line39> break; <line40> } <line41> } <line42> } <line43> } <line44> "	"<line8>      logger.trace(""Value '{}' for {} hasn't changed, ignoring update"", value, variable);"	task4	
"public class A { <line0> private void publishSegments(TaskToolbox toolbox, Map<String, PushedSegmentsReport> reportsMap) <line1> throws IOException { <line2> final Set<DataSegment> oldSegments = new HashSet<>(); <line3> final Set<DataSegment> newSegments = new HashSet<>(); <line4> reportsMap <line5> .values() <line6> .forEach( <line7> report -> { <line8> oldSegments.addAll(report.getOldSegments()); <line9> newSegments.addAll(report.getNewSegments()); <line10> }); <line11> final boolean storeCompactionState = <line12> getContextValue(Tasks.STORE_COMPACTION_STATE_KEY, Tasks.DEFAULT_STORE_COMPACTION_STATE); <line13> final Function<Set<DataSegment>, Set<DataSegment>> annotateFunction = <line14> compactionStateAnnotateFunction( <line15> storeCompactionState, <line16> toolbox, <line17> ingestionSchema.getTuningConfig(), <line18> ingestionSchema.getDataSchema().getGranularitySpec()); <line19> Set<DataSegment> segmentsFoundForDrop = null; <line20> if (ingestionSchema.getIOConfig().isDropExisting()) { <line21> segmentsFoundForDrop = <line22> getUsedSegmentsWithinInterval( <line23> toolbox, <line24> getDataSource(), <line25> ingestionSchema.getDataSchema().getGranularitySpec().inputIntervals()); <line26> } <line27> final TransactionalSegmentPublisher publisher = <line28> (segmentsToBeOverwritten, segmentsToDrop, segmentsToPublish, commitMetadata) -> <line29> toolbox <line30> .getTaskActionClient() <line31> .submit( <line32> SegmentTransactionalInsertAction.overwriteAction( <line33> segmentsToBeOverwritten, segmentsToDrop, segmentsToPublish)); <line34> final boolean published = <line35> newSegments.isEmpty() <line36> || publisher <line37> .publishSegments( <line38> oldSegments, segmentsFoundForDrop, newSegments, annotateFunction, null) <line39> .isSuccess(); <line40> if (published) { <line41> } else { <line42> throw new ISE(""Failed to publish segments""); <line43> } <line44> } <line45> } <line46> "	"<line41>      LOG.info(""Published [%d] segments"", newSegments.size());"	task4	
public class A { <line0> private boolean verifyCreatedAfter(Date invocationDate) { <line1> if (getCreated() != null && getCreated().after(invocationDate)) { <line2> return false; <line3> } else { <line4> return true; <line5> } <line6> } <line7> } <line8> 	"<line2>      LOG.info(""Validation of Timestamp: The message was created in the future!"");"	task4	
"public class A { <line0> private synchronized AttendanceScheduleSetting createNewScheduleSetting( <line1> String unitName, String topUnitName, Boolean debugger) throws Exception { <line2> AttendanceScheduleSetting new_attendanceScheduleSetting = null; <line3> Business business = null; <line4> List<String> ids = null; <line5> try (EntityManagerContainer emc = EntityManagerContainerFactory.instance().create()) { <line6> business = new Business(emc); <line7> new_attendanceScheduleSetting = new AttendanceScheduleSetting(); <line8> new_attendanceScheduleSetting.setAbsenceStartTime(null); <line9> new_attendanceScheduleSetting.setLateStartTime(""9:05""); <line10> new_attendanceScheduleSetting.setLeaveEarlyStartTime(null); <line11> new_attendanceScheduleSetting.setOffDutyTime(""17:00""); <line12> new_attendanceScheduleSetting.setOnDutyTime(""09:00""); <line13> new_attendanceScheduleSetting.setUnitOu(unitName); <line14> new_attendanceScheduleSetting.setTopUnitName(topUnitName); <line15> new_attendanceScheduleSetting.setUnitName(unitName); <line16> ids = business.getAttendanceScheduleSettingFactory().listByUnitName(unitName, topUnitName); <line17> if (ids == null || ids.isEmpty()) { <line18> emc.beginTransaction(AttendanceScheduleSetting.class); <line19> emc.persist(new_attendanceScheduleSetting, CheckPersistType.all); <line20> emc.commit(); <line21> } <line22> } catch (Exception e) { <line23> throw e; <line24> } <line25> return new_attendanceScheduleSetting; <line26> } <line27> } <line28> "	"<line18>        logger.debug(debugger,"">>>>>>>>>>create a new schedule setting for unit [""+ topUnitName+ ""][""+ unitName+ ""]......"");"	task4	
"public class A { <line0> @Test <line1> public void testGenerateAppId() { <line2> List<String> appIds = new ArrayList<>(); <line3> for (int i = 0; i < 10; i++) { <line4> String appId = appIdGenerationManager.createNewAppId(); <line5> assertNotNull(appId); <line6> assertTrue(appId.matches(""APP-[a-zA-Z0-9]{16}"")); <line7> assertFalse(appIds.contains(appId)); <line8> appIds.add(appId); <line9> } <line10> } <line11> } <line12> "	"<line5>      LOGGER.info(""Got app ID: {}"", appId);"	task4	
public class A { <line0> private void deleteAlertJob(JobKey scheduledJobKey) throws SchedulerException { <line1> Long configId = TaskUtils.getIdFromJobKey(scheduledJobKey.getName()); <line2> DetectionAlertConfigDTO alertConfigSpec = alertConfigDAO.findById(configId); <line3> if (alertConfigSpec == null) { <line4> stopJob(scheduledJobKey); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOG.info(""Found scheduled, but not in database {}"", configId);"	task4	
"public class A { <line0> @Override <line1> public void start(Collection<? extends Location> locs) { <line2> callHistory.add(""start""); <line3> ServiceStateLogic.setExpectedState(this, Lifecycle.STARTING); <line4> counter.incrementAndGet(); <line5> addLocations(locs); <line6> sensors().set(SERVICE_UP, true); <line7> ServiceStateLogic.setExpectedState(this, Lifecycle.RUNNING); <line8> } <line9> } <line10> "	"<line2>    LOG.trace(""Starting {}"", this);"	task4	
"public class A { <line0> private void treeConnected( <line1> SmbTransportImpl transport, SmbSessionImpl sess, TreeConnectResponse response) <line2> throws CIFSException { <line3> if (!response.isValidTid()) { <line4> throw new SmbException(""TreeID is invalid""); <line5> } <line6> this.tid = response.getTid(); <line7> String rsvc = response.getService(); <line8> if (rsvc == null && !transport.isSMB2()) { <line9> throw new SmbException(""Service is NULL""); <line10> } <line11> if (transport.getContext().getConfig().isIpcSigningEnforced() <line12> && (""IPC$"".equals(this.getShare()) || ""IPC"".equals(rsvc)) <line13> && !sess.getCredentials().isAnonymous() <line14> && sess.getDigest() == null) { <line15> throw new SmbException(""IPC signing is enforced, but no signing is available""); <line16> } <line17> this.service = rsvc; <line18> this.inDfs = response.isShareDfs(); <line19> this.treeNum = TREE_CONN_COUNTER.incrementAndGet(); <line20> this.connectionState.set(2); <line21> try { <line22> validateNegotiation(transport, sess); <line23> } catch (CIFSException se) { <line24> try { <line25> transport.disconnect(true); <line26> } catch (IOException e) { <line27> se.addSuppressed(e); <line28> } <line29> throw se; <line30> } <line31> } <line32> } <line33> "	"<line27>        log.warn(""Failed to disconnect transport"", e);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> webRtcReceiver[i - 1] = new WebRtcEndpoint.Builder(pipeline).build(); <line3> recordingFile[i - 1] = getRecordUrl(""-receiver"" + i + extension); <line4> recorder[i - 1] = <line5> new RecorderEndpoint.Builder(pipeline, recordingFile[i - 1]) <line6> .withMediaProfile(mediaProfileSpecType) <line7> .build(); <line8> webRtcSender.connect(webRtcReceiver[i - 1]); <line9> webRtcSender.connect(recorder[i - 1]); <line10> try { <line11> getPage(i).subscribeEvents(""playing""); <line12> getPage(i) <line13> .initWebRtc(webRtcReceiver[i - 1], WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY); <line14> Assert.assertTrue(""Not received media in receiver "" + i, getPage(i).waitForEvent(""playing"")); <line15> recorder[i - 1].record(); <line16> Thread.sleep(PLAYTIME_MS); <line17> recorder[i - 1].stopAndWait(); <line18> Thread.sleep(4000); <line19> } catch (InterruptedException e) { <line20> } <line21> latch.countDown(); <line22> } <line23> } <line24> "	"<line20>      log.error(""InterruptedException in receiver "" + i, e);"	task4	
"public class A { <line0> private boolean checkSplitBrainJoinMessage() { <line1> ClusterServiceImpl service = getService(); <line2> ILogger logger = getLogger(); <line3> try { <line4> if (!service.getClusterJoinManager().validateJoinMessage(request)) { <line5> return false; <line6> } <line7> if (!service.getClusterVersion().equals(request.getClusterVersion())) { <line8> return false; <line9> } <line10> SplitBrainMergeCheckResult result = service.getClusterJoinManager().shouldMerge(request); <line11> if (result == REMOTE_NODE_SHOULD_MERGE) { <line12> return service.getMembershipManager().verifySplitBrainMergeMemberListVersion(request); <line13> } <line14> return result != CANNOT_MERGE; <line15> } catch (Exception e) { <line16> if (logger.isFineEnabled()) { <line17> logger.fine(""Could not validate split-brain join message! -> "" + e.getMessage()); <line18> } <line19> return false; <line20> } <line21> } <line22> } <line23> "	"<line8>        logger.info(""Join check from ""+ getCallerAddress()+ "" failed validation due to incompatible version,""+ ""remote cluster version is ""+ request.getClusterVersion()+ "", this cluster is ""+ service.getClusterVersion());"	task4	
public class A { <line0> private static void compareXml(InputStream expected, InputStream actual) { <line1> Source sexpected = Input.fromStream(expected).build(); <line2> Source sactual = Input.fromStream(actual).build(); <line3> Diff myDiff = <line4> DiffBuilder.compare(sexpected) <line5> .withTest(sactual) <line6> .ignoreWhitespace() <line7> .ignoreComments() <line8> .build(); <line9> boolean hasDiff = myDiff.hasDifferences(); <line10> if (hasDiff) { <line11> } <line12> assertFalse(hasDiff); <line13> } <line14> } <line15> 	<line11>      LOG.error(myDiff.toString());	task4	
"public class A { <line0> @Test <line1> public void testDeleted() { <line2> SentinelHello normalHello = <line3> new SentinelHello(sentinels.iterator().next(), masterAddr, sentinelMonitorName); <line4> HostPort remoteDcMAster = new HostPort(""127.0.0.1"", 7379); <line5> Mockito.when(metaCache.getDc(remoteDcMAster)).thenReturn(""remote-dc""); <line6> Set<SentinelHello> hellos = new HashSet<>(); <line7> hellos.add(normalHello); <line8> hellos.add(new SentinelHello(new HostPort(""11.0.0.1"", 5000), masterAddr, sentinelMonitorName)); <line9> hellos.add(new SentinelHello(sentinels.iterator().next(), remoteDcMAster, sentinelMonitorName)); <line10> hellos.add(new SentinelHello(sentinels.iterator().next(), masterAddr, ""error-monitor-name"")); <line11> Set<SentinelHello> needDeletedHello = <line12> collector.checkAndDelete(sentinelMonitorName, sentinels, hellos, quorumConfig, masterAddr); <line13> Assert.assertEquals(3, needDeletedHello.size()); <line14> Assert.assertFalse(needDeletedHello.contains(normalHello)); <line15> Assert.assertEquals(1, hellos.size()); <line16> Assert.assertTrue(hellos.contains(normalHello)); <line17> } <line18> } <line19> "	"<line13>    logger.info(""[testDeleted] {}"", needDeletedHello);"	task4	
public class A { <line0> private void checkGetFromBackupStoreReadThroughDisabled( <line1> List<CacheConfiguration<Object, Object>> cacheCfgs) throws Exception { <line2> for (CacheConfiguration<Object, Object> ccfg : cacheCfgs) { <line3> ccfg.setCacheStoreFactory(new TestStoreFactory()); <line4> ccfg.setReadThrough(false); <line5> boolean near = (ccfg.getNearConfiguration() != null); <line6> ignite(0).createCache(ccfg); <line7> awaitPartitionMapExchange(); <line8> try { <line9> checkLocalRead(NODES, ccfg); <line10> } finally { <line11> ignite(0).destroyCache(ccfg.getName()); <line12> } <line13> } <line14> } <line15> } <line16> 	"<line6>      log.info(""Test cache [mode=""+ ccfg.getCacheMode()+ "", atomicity=""+ ccfg.getAtomicityMode()+ "", backups=""+ ccfg.getBackups()+ "", near=""+ near+ ""]"");"	task4	
public class A { <line0> @Before <line1> public void setup() throws Exception { <line2> policyFile = super.setupPolicy(); <line3> super.setup(); <line4> } <line5> } <line6> 	"<line2>    LOGGER.info(""TestJDBCInterface setup"");"	task4	
public class A { <line0> protected static Image createImage(String path, String description) { <line1> URL imageURL = TrayUI.class.getResource(path); <line2> if (imageURL == null) { <line3> return null; <line4> } else { <line5> return (new ImageIcon(imageURL, description)).getImage(); <line6> } <line7> } <line8> } <line9> 	"<line3>      logger.error(""Resource not found: "" + path);"	task4	
public class A { <line0> @Override <line1> public PerChannelBookieClient create(BookieSocketAddress address) { <line2> Optional<String> networkLocation = Optional.absent(); <line3> try { <line4> if (dnsResolver.isPresent()) { <line5> networkLocation = <line6> Optional.of( <line7> NetUtils.resolveNetworkLocation(dnsResolver.get(), address.getSocketAddress())); <line8> } <line9> } catch (Exception exc) { <line10> } <line11> return new PerChannelBookieClient( <line12> conf, executor, channelFactory, address, requestTimer, statsLogger, networkLocation); <line13> } <line14> } <line15> 	"<line10>      LOG.info(""Failed to resolve the network location"", exc);"	task4	
public class A { <line0> private Application create(AssemblyTemplate template, CampPlatform platform) { <line1> ManagementContext mgmt = getManagementContext(platform); <line2> BrooklynClassLoadingContext loader = JavaBrooklynClassLoadingContext.create(mgmt); <line3> EntitySpec<? extends Application> spec = <line4> createApplicationSpec(template, platform, loader, MutableSet.<String>of()); <line5> Application instance = mgmt.getEntityManager().createEntity(spec); <line6> return instance; <line7> } <line8> } <line9> 	"<line6>    log.info(""CAMP created '{}'"", instance);"	task4	
public class A { <line0> public void maybeSendShutdown() { <line1> if (assignmentErrorCode.get() == AssignorError.SHUTDOWN_REQUESTED.code()) { <line2> mainConsumer.enforceRebalance(); <line3> } <line4> } <line5> } <line6> 	"<line2>      log.warn(""Detected that shutdown was requested. ""+ ""All clients in this app will now begin to shutdown"");"	task4	
public class A { <line0> private void disconnect(Throwable reason) { <line1> try { <line2> if (session != null) { <line3> session.close(); <line4> session = null; <line5> } <line6> } catch (IOException e) { <line7> if (reason != null) { <line8> reason.addSuppressed(e); <line9> } else { <line10> } <line11> } finally { <line12> client.stop(); <line13> client = null; <line14> } <line15> } <line16> } <line17> 	<line10>        LOG.error(SshdText.get().sessionCloseFailed, e);	task4	
"public class A { <line0> @Test <line1> void testSplitDocumentation() throws Exception { <line2> try (CamelContext context = new DefaultCamelContext()) { <line3> String json = context.adapt(CatalogCamelContext.class).getEipParameterJsonSchema(""split""); <line4> assertNotNull(""Should have found json for split"", json); <line5> assertTrue(json.contains(""\""name\"": \""split\"""")); <line6> assertTrue( <line7> json.contains(""If enabled then processing each splitted messages occurs concurrently."")); <line8> assertTrue( <line9> json.contains( <line10> ""\""outputs\"": { \""kind\"": \""element\"", \""displayName\"": \""Outputs\"", \""required\"":"" <line11> + "" true, \""type\"": \""array\"", \""javaType\"""")); <line12> } <line13> } <line14> } <line15> "	<line4>      LOG.info(json);	task4	
public class A { <line0> private FileEntry _fetchFileEntry(long fileEntryId) { <line1> try { <line2> return _dlAppLocalService.getFileEntry(fileEntryId); <line3> } catch (PortalException portalException) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	"<line5>        log.debug(""Unable to get file entry "" + fileEntryId, portalException);"	task4	
"public class A { <line0> @Override <line1> public void initializeUI(UIBuilder builder) throws Exception { <line2> StopWatch watch = new StopWatch(); <line3> final UIContext context = builder.getUIContext(); <line4> letsChat = (LetsChatClient) builder.getUIContext().getAttributeMap().get(""letsChatClient""); <line5> taigaClient = (TaigaClient) builder.getUIContext().getAttributeMap().get(""taigaClient""); <line6> ProjectConfig config = (ProjectConfig) context.getAttributeMap().get(""projectConfig""); <line7> if (config != null) { <line8> CommandHelpers.setInitialComponentValue(chatRoom, config.getChatRoom()); <line9> CommandHelpers.setInitialComponentValue(issueProjectName, config.getIssueProjectName()); <line10> CommandHelpers.setInitialComponentValue(codeReview, config.getCodeReview()); <line11> } <line12> builder.add(chatRoom); <line13> builder.add(issueProjectName); <line14> builder.add(codeReview); <line15> } <line16> } <line17> "	"<line15>    LOG.info(""initializeUI took "" + watch.taken());"	task4	
"public class A { <line0> public String getHostName(GenericContainer container) { <line1> String OS = System.getProperty(""os.name"", ""generic"").toLowerCase(Locale.ENGLISH); <line2> if ((OS.indexOf(""mac"") >= 0) || (OS.indexOf(""darwin"") >= 0)) { <line3> return ""host.docker.internal""; <line4> } else if (OS.indexOf(""win"") >= 0) { <line5> return ""host.docker.internal""; <line6> } else if (OS.indexOf(""nux"") >= 0) { <line7> Container.ExecResult execResult; <line8> try { <line9> execResult = container.execInContainer(""/sbin/ip route|awk '/default/ { print $3 }'""); <line10> } catch (IOException e) { <line11> return DOCKER_FOR_LINUX_STATIC_IP; <line12> } catch (InterruptedException e) { <line13> Thread.currentThread().interrupt(); <line14> return DOCKER_FOR_LINUX_STATIC_IP; <line15> } <line16> String hostIpAddress = execResult.getStdout(); <line17> if (isValidIpAddress(hostIpAddress)) { <line18> return hostIpAddress; <line19> } else { <line20> return DOCKER_FOR_LINUX_STATIC_IP; <line21> } <line22> } <line23> return container.getTestHostIpAddress(); <line24> } <line25> } <line26> "	"<line11>        log.warn(""Cannot find host ip"", e);"	task4	
public class A { <line0> @Override <line1> public synchronized void onEndRequest(RequestCycle requestCycle) { <line2> val isisRequestCycle = requestCycle.getMetaData(REQ_CYCLE_HANDLE_KEY); <line3> requestCycle.setMetaData(REQ_CYCLE_HANDLE_KEY, null); <line4> if (isisRequestCycle != null) { <line5> isisRequestCycle.onEndRequest(); <line6> } <line7> } <line8> } <line9> 	"<line2>    log.debug(""onEndRequest"");"	task4	
public class A { <line0> @Test <line1> public void test_05() { <line2> double pvals[] = {0.01, 0.2, 0.3}; <line3> ScoreList gpl = new ScoreList(); <line4> for (double pval : pvals) gpl.add(pval); <line5> double pvalue = gpl.score(ScoreSummary.FISHER_CHI_SQUARE); <line6> Assert.assertEquals(0.021561751324834642, pvalue, EPSILON); <line7> } <line8> } <line9> 	"<line2>    Log.debug(""Test"");"	task4	
"public class A { <line0> private ProcessDefinitionLog moveProcessDefinition( <line1> User loginUser, <line2> Long targetProjectCode, <line3> ProcessDefinition processDefinition, <line4> Map<String, Object> result, <line5> List<String> failedProcessList) { <line6> try { <line7> Integer version = <line8> processDefinitionLogMapper.queryMaxVersionForDefinition(processDefinition.getCode()); <line9> ProcessDefinitionLog processDefinitionLog = new ProcessDefinitionLog(processDefinition); <line10> processDefinitionLog.setVersion(version == null || version == 0 ? 1 : version + 1); <line11> processDefinitionLog.setProjectCode(targetProjectCode); <line12> processDefinitionLog.setOperator(loginUser.getId()); <line13> Date now = new Date(); <line14> processDefinitionLog.setOperateTime(now); <line15> processDefinitionLog.setUpdateTime(now); <line16> processDefinitionLog.setCreateTime(now); <line17> int update = processDefinitionMapper.updateById(processDefinitionLog); <line18> int insertLog = processDefinitionLogMapper.insert(processDefinitionLog); <line19> if ((insertLog & update) > 0) { <line20> putMsg(result, Status.SUCCESS); <line21> } else { <line22> failedProcessList.add(processDefinition.getId() + ""["" + processDefinition.getName() + ""]""); <line23> putMsg(result, Status.UPDATE_PROCESS_DEFINITION_ERROR); <line24> } <line25> return processDefinitionLog; <line26> } catch (Exception e) { <line27> putMsg(result, Status.UPDATE_PROCESS_DEFINITION_ERROR); <line28> failedProcessList.add(processDefinition.getId() + ""["" + processDefinition.getName() + ""]""); <line29> } <line30> return null; <line31> } <line32> } <line33> "	"<line29>      logger.error(""move processDefinition error: {}"", e.getMessage(), e);"	task4	
"public class A { <line0> public URL getFinalUrl(URL url) throws IOException { <line1> if (url.getHost().endsWith(""artstation.com"")) { <line2> return url; <line3> } <line4> Response response = Http.url(url).connection().followRedirects(false).execute(); <line5> if (response.statusCode() / 100 == 3 && response.hasHeader(""location"")) { <line6> return getFinalUrl(new URL(response.header(""location""))); <line7> } else { <line8> return null; <line9> } <line10> } <line11> } <line12> "	"<line4>    LOGGER.info(""Checking url: "" + url);"	task4	
public class A { <line0> @Override <line1> public void destroy(IServerSession session) { <line2> try { <line3> session.stop(); <line4> } finally { <line5> if (m_clientNodeId != null) { <line6> BEANS <line7> .get(IClientNotificationService.class) <line8> .unregisterSession(m_clientNodeId, session.getId(), session.getUserId()); <line9> } <line10> } <line11> } <line12> } <line13> 	"<line2>    LOG.debug(""Destroying scout server scoutSessionId={}"", session.getId());"	task4	
"public class A { <line0> @Override <line1> public <T> T getJAXBObject( <line2> Class<T> type, String key, SupplierX<JAXBContext, JAXBException> contextSupplier, T def) { <line3> Preference<? extends Object> pref = getPreference(key); <line4> if (pref == null) { <line5> return def; <line6> } <line7> if (pref.getValueType() != null && type.isAssignableFrom(pref.getValueType())) { <line8> @SuppressWarnings(""unchecked"") <line9> Preference<T> castPref = (Preference<T>) pref; <line10> T value = castPref.getValue(def, contextSupplier); <line11> return value == null ? def : value; <line12> } <line13> return def; <line14> } <line15> } <line16> "	"<line13>    LOGGER.warn(""Could not cast preference value for key [""+ key+ ""] from [""+ pref.getValueType()+ ""] to [""+ type+ ""]"");"	task4	
public class A { <line0> private int runCommand(boolean json) <line1> throws InterruptedException, ExecutionException, IOException { <line2> final int ret = command.run(options, client, out, json, null); <line3> return ret; <line4> } <line5> } <line6> 	"<line3>    log.debug(""Output from command: [{}]"", baos.toString().replaceAll(""\n"", ""\\\\n""));"	task4	
"public class A { <line0> private BrooklynNode setUpBrooklynNodeWithApp() throws InterruptedException, ExecutionException { <line1> BrooklynNode brooklynNode = <line2> app.createAndManageChild( <line3> EntitySpec.create(BrooklynNode.class) <line4> .configure(BrooklynNode.NO_WEB_CONSOLE_AUTHENTICATION, Boolean.TRUE)); <line5> app.start(locs); <line6> EntityAsserts.assertAttributeEqualsEventually(brooklynNode, BrooklynNode.SERVICE_UP, true); <line7> String baseUrl = brooklynNode.getAttribute(BrooklynNode.WEB_CONSOLE_URI).toString(); <line8> waitForApps(baseUrl); <line9> final String id = <line10> brooklynNode <line11> .invoke( <line12> BrooklynNode.DEPLOY_BLUEPRINT, <line13> ConfigBag.newInstance() <line14> .configure( <line15> DeployBlueprintEffector.BLUEPRINT_TYPE, BasicApplication.class.getName()) <line16> .getAllConfig()) <line17> .get(); <line18> String entityUrl = Urls.mergePaths(baseUrl, ""v1/applications/"", id, ""entities"", id); <line19> Entity mirror = <line20> brooklynNode.addChild( <line21> EntitySpec.create(BrooklynEntityMirror.class) <line22> .configure(BrooklynEntityMirror.MIRRORED_ENTITY_URL, entityUrl) <line23> .configure(BrooklynEntityMirror.MIRRORED_ENTITY_ID, id)); <line24> assertEquals(brooklynNode.getChildren().size(), 1); <line25> return brooklynNode; <line26> } <line27> } <line28> "	"<line6>    log.info(""started ""+ app+ "" containing ""+ brooklynNode+ "" for ""+ JavaClassNames.niceClassAndMethod());"	task4	
public class A { <line0> protected final void setChannelError(@Nullable final Throwable cause) { <line1> if (hasException()) { <line2> return; <line3> } <line4> exception.set(cause); <line5> } <line6> } <line7> 	"<line4>    LOG.error(String.format(""A channel exception set on %s"", toString()));"	task4	
"public class A { <line0> public static int getUserGroupsAndOrganizationsActivitiesCount( <line1> HttpPrincipal httpPrincipal, long userId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> SocialActivityServiceUtil.class, <line6> ""getUserGroupsAndOrganizationsActivitiesCount"", <line7> _getUserGroupsAndOrganizationsActivitiesCountParameterTypes28); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, userId); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	<line17>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Override <line1> public boolean exportsClass(final String name) { <line2> checkArgument(!isEmpty(name), ""Class name cannot be empty""); <line3> boolean exported = classLoaderFilter.exportsClass(name); <line4> if (!exported) { <line5> exported = exportedClasses.get(name) != null; <line6> if (exported) { <line7> } <line8> } <line9> return exported; <line10> } <line11> } <line12> "	"<line7>        logger.warn(StringMessageUtils.getBoilerPlate(newArrayList(""WARNING:"","" "",""Class: '""+ name+ ""' is NOT exposed by the plugin but it will be visible ""+ ""due to it was manually forced to be exported for testing purposes."","" "",""Check if this is really necessary, this class won't be visible in standalone""+ "" mode.""),'*',DEFAULT_MESSAGE_WIDTH));"	task4	
public class A { <line0> @Override <line1> public void enqueueMutateBatch(List<RowMutation> mutations) throws BlurException, TException { <line2> try { <line3> resetSearchers(); <line4> for (RowMutation mutation : mutations) { <line5> checkTable(_cluster, mutation.table); <line6> checkForUpdates(_cluster, mutation.table); <line7> MutationHelper.validateMutation(mutation); <line8> } <line9> _indexManager.enqueue(mutations); <line10> } catch (Exception e) { <line11> if (e instanceof BlurException) { <line12> throw (BlurException) e; <line13> } <line14> throw new BException(e.getMessage(), e); <line15> } <line16> } <line17> } <line18> 	"<line11>      LOG.error(""Unknown error during processing of [mutations={0}]"", e, mutations);"	task4	
public class A { <line0> @Override <line1> public boolean userCanSendFrom(Username connectedUser, Username fromUser) { <line2> try { <line3> return connectedUser.equals(fromUser) <line4> || emailIsAnAliasOfTheConnectedUser(connectedUser, fromUser); <line5> } catch (RecipientRewriteTableException | RecipientRewriteTable.ErrorMappingException e) { <line6> return false; <line7> } <line8> } <line9> } <line10> 	"<line6>      LOGGER.warn(""Error upon {} mapping resolution for {}. You might want to audit mapping content for""+ "" this mapping entry. "",fromUser.asString(),connectedUser.asString());"	task4	
public class A { <line0> private String convertCheckName(DataType checkName) { <line1> if (checkName instanceof Text) { <line2> return checkName.toString(); <line3> } else { <line4> return checkName.toString(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.warn(MessageFormat.format(this.getActionExecution().getAction().getType()+ "" does not accept {0} as type for check name"",checkName.getClass()));"	task4	
public class A { <line0> public void addGlobal(FacesMessage msg) { <line1> if (shouldLogAsWarning(msg.getSeverity())) { <line2> } <line3> globalMessages.add(msg); <line4> } <line5> } <line6> 	"<line2>      log.warn(""Global FacesMessage to user (wid: {}): {})"",windowContext.getCurrentWindowId(),msg.getSummary());"	task4	
"public class A { <line0> @Test <line1> public void testBuildArgs() { <line2> SparkParameters param = new SparkParameters(); <line3> param.setDeployMode(mode); <line4> param.setMainClass(mainClass); <line5> param.setDriverCores(driverCores); <line6> param.setDriverMemory(driverMemory); <line7> param.setExecutorCores(executorCores); <line8> param.setExecutorMemory(executorMemory); <line9> param.setMainJar(mainJar); <line10> param.setNumExecutors(numExecutors); <line11> param.setProgramType(programType); <line12> param.setSparkVersion(sparkVersion); <line13> param.setMainArgs(mainArgs); <line14> param.setAppName(appName); <line15> param.setQueue(queue); <line16> List<String> result = SparkArgsUtils.buildArgs(param); <line17> for (String s : result) { <line18> } <line19> assertEquals(22, result.size()); <line20> assertEquals(""--master"", result.get(0)); <line21> assertEquals(""yarn"", result.get(1)); <line22> assertEquals(""--deploy-mode"", result.get(2)); <line23> assertEquals(mode, result.get(3)); <line24> assertEquals(""--class"", result.get(4)); <line25> assertEquals(mainClass, result.get(5)); <line26> assertEquals(""--driver-cores"", result.get(6)); <line27> assertSame(driverCores, Integer.valueOf(result.get(7))); <line28> assertEquals(""--driver-memory"", result.get(8)); <line29> assertEquals(driverMemory, result.get(9)); <line30> assertEquals(""--num-executors"", result.get(10)); <line31> assertSame(numExecutors, Integer.valueOf(result.get(11))); <line32> assertEquals(""--executor-cores"", result.get(12)); <line33> assertSame(executorCores, Integer.valueOf(result.get(13))); <line34> assertEquals(""--executor-memory"", result.get(14)); <line35> assertEquals(executorMemory, result.get(15)); <line36> assertEquals(""--name"", result.get(16)); <line37> assertEquals(ArgsUtils.escape(appName), result.get(17)); <line38> assertEquals(""--queue"", result.get(18)); <line39> assertEquals(queue, result.get(19)); <line40> assertEquals(mainJar.getRes(), result.get(20)); <line41> assertEquals(mainArgs, result.get(21)); <line42> SparkParameters param1 = new SparkParameters(); <line43> param1.setOthers(""--files xxx/hive-site.xml""); <line44> param1.setQueue(queue); <line45> result = SparkArgsUtils.buildArgs(param1); <line46> assertEquals(7, result.size()); <line47> } <line48> } <line49> "	<line18>      logger.info(s);	task4	
"public class A { <line0> @Override <line1> public void execute(final FunctionContext<String> context) { <line2> Cache cache = context.getCache(); <line3> try { <line4> if (cache instanceof InternalCache) { <line5> InternalCache gemfireCache = (InternalCache) cache; <line6> DistributedMember member = gemfireCache.getMyId(); <line7> String diskStoreName = context.getArguments(); <line8> String memberId = member.getId(); <line9> String memberName = member.getName(); <line10> DiskStore diskStore = gemfireCache.findDiskStore(diskStoreName); <line11> if (diskStore != null) { <line12> DiskStoreDetails diskStoreDetails = <line13> new DiskStoreDetails( <line14> diskStore.getDiskStoreUUID(), diskStore.getName(), memberId, memberName); <line15> diskStoreDetails.setAllowForceCompaction(diskStore.getAllowForceCompaction()); <line16> diskStoreDetails.setAutoCompact(diskStore.getAutoCompact()); <line17> diskStoreDetails.setCompactionThreshold(diskStore.getCompactionThreshold()); <line18> diskStoreDetails.setMaxOplogSize(diskStore.getMaxOplogSize()); <line19> diskStoreDetails.setQueueSize(diskStore.getQueueSize()); <line20> diskStoreDetails.setTimeInterval(diskStore.getTimeInterval()); <line21> diskStoreDetails.setWriteBufferSize(diskStore.getWriteBufferSize()); <line22> diskStoreDetails.setDiskUsageWarningPercentage(diskStore.getDiskUsageWarningPercentage()); <line23> diskStoreDetails.setDiskUsageCriticalPercentage( <line24> diskStore.getDiskUsageCriticalPercentage()); <line25> setDiskDirDetails(diskStore, diskStoreDetails); <line26> setRegionDetails(gemfireCache, diskStore, diskStoreDetails); <line27> setCacheServerDetails(gemfireCache, diskStore, diskStoreDetails); <line28> setGatewayDetails(gemfireCache, diskStore, diskStoreDetails); <line29> setPdxSerializationDetails(gemfireCache, diskStore, diskStoreDetails); <line30> setAsyncEventQueueDetails(gemfireCache, diskStore, diskStoreDetails); <line31> context.getResultSender().lastResult(diskStoreDetails); <line32> } else { <line33> context <line34> .getResultSender() <line35> .sendException( <line36> new EntityNotFoundException( <line37> String.format( <line38> ""A disk store with name '%1$s' was not found on member '%2$s'."", <line39> diskStoreName, memberName))); <line40> } <line41> } <line42> } catch (Exception e) { <line43> context.getResultSender().sendException(e); <line44> } <line45> } <line46> } <line47> "	"<line43>      logger.error(""Error occurred while executing 'describe disk-store': {}!"", e.getMessage(), e);"	task4	
"public class A { <line0> public FcmPushNotificationResponse pushFcmNotification( <line1> NotificationBean notification, AppEntity appPropertiesDetails) throws IOException { <line2> String authKey = """"; <line3> logger.entry(""Begin pushFCMNotification()""); <line4> if (notification.getDeviceToken() != null <line5> && notification.getDeviceToken().length() > 0 <line6> && appPropertiesDetails != null) { <line7> authKey = appPropertiesDetails.getAndroidServerKey(); <line8> URL url = new URL((String) applicationPropertyConfiguration.getApiUrlFcm()); <line9> HttpURLConnection conn = (HttpURLConnection) url.openConnection(); <line10> conn.setUseCaches(false); <line11> conn.setDoInput(true); <line12> conn.setDoOutput(true); <line13> conn.setRequestMethod(""POST""); <line14> conn.setRequestProperty(""Authorization"", ""key="" + authKey); <line15> conn.setRequestProperty(""Content-Type"", ""application/json""); <line16> JSONObject json = new JSONObject(); <line17> json.put(""registration_ids"", notification.getDeviceToken()); <line18> json.put(""priority"", ""high""); <line19> JSONObject dataInfo = new JSONObject(); <line20> dataInfo.put(""subtype"", notification.getNotificationSubType()); <line21> dataInfo.put(""type"", notification.getNotificationType()); <line22> dataInfo.put(""title"", notification.getNotificationTitle()); <line23> dataInfo.put(""message"", notification.getNotificationText()); <line24> if (notification.getCustomStudyId() != null <line25> && StringUtils.isNotEmpty(notification.getCustomStudyId())) { <line26> dataInfo.put(""studyId"", notification.getCustomStudyId()); <line27> } <line28> json.put(""data"", dataInfo); <line29> OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); <line30> wr.write(json.toString()); <line31> wr.flush(); <line32> String response = IOUtils.toString(conn.getInputStream(), StandardCharsets.UTF_8); <line33> JsonNode responseJson = new ObjectMapper().readTree(response); <line34> FcmPushNotificationResponse fcmNotificationResponse = <line35> new FcmPushNotificationResponse( <line36> responseJson, conn.getResponseCode(), conn.getResponseMessage()); <line37> return fcmNotificationResponse; <line38> } <line39> return new FcmPushNotificationResponse(null, HttpStatus.OK.value(), ""SUCCESS""); <line40> } <line41> } <line42> "	"<line37>      logger.trace(String.format(""FCM Notification Response status=%d, response=%s"",conn.getResponseCode(), response));"	task4	
public class A { <line0> public ID validRequestorForSendType_returnType(String sendType, String returnType) { <line1> if (StringUtils.isNotEmpty(sendType)) { <line2> return null; <line3> } <line4> if (StringUtils.isNotEmpty(returnType)) { <line5> if (NSPasteboard.FilenamesPboardType.equals(sendType)) { <line6> return this.id(); <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	"<line1>    log.debug(""validRequestorForSendType_returnType:"" + sendType + "","" + returnType);"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private String[] getAllNoteIdsWithinDateRange( <line2> LoggedInInfo loggedInInfo, <line3> HttpServletRequest request, <line4> String demoNo, <line5> Date startDate, <line6> Date endDate) { <line7> HttpSession se = loggedInInfo.getSession(); <line8> ProgramProvider pp = <line9> programManager2.getCurrentProgramInDomain( <line10> loggedInInfo, loggedInInfo.getLoggedInProviderNo()); <line11> String programId = null; <line12> if (pp != null && pp.getProgramId() != null) { <line13> programId = """" + pp.getProgramId(); <line14> } else { <line15> programId = String.valueOf(programMgr.getProgramIdByProgramName(""OSCAR"")); <line16> } <line17> NoteSelectionCriteria criteria = new NoteSelectionCriteria(); <line18> criteria.setStartDate(startDate); <line19> criteria.setEndDate(endDate); <line20> criteria.setMaxResults(Integer.MAX_VALUE); <line21> criteria.setDemographicId(ConversionUtils.fromIntString(demoNo)); <line22> criteria.setUserRole((String) request.getSession().getAttribute(""userrole"")); <line23> criteria.setUserName((String) request.getSession().getAttribute(""user"")); <line24> if (request.getParameter(""note_sort"") != null <line25> && request.getParameter(""note_sort"").length() > 0) { <line26> criteria.setNoteSort(request.getParameter(""note_sort"")); <line27> } <line28> if (programId != null && !programId.trim().isEmpty()) { <line29> criteria.setProgramId(programId); <line30> } <line31> if (se.getAttribute(""CaseManagementViewAction_filter_roles"") != null) { <line32> criteria <line33> .getRoles() <line34> .addAll((List<String>) se.getAttribute(""CaseManagementViewAction_filter_roles"")); <line35> } <line36> if (se.getAttribute(""CaseManagementViewAction_filter_providers"") != null) { <line37> criteria <line38> .getProviders() <line39> .addAll((List<String>) se.getAttribute(""CaseManagementViewAction_filter_providers"")); <line40> } <line41> if (se.getAttribute(""CaseManagementViewAction_filter_providers"") != null) { <line42> criteria <line43> .getIssues() <line44> .addAll((List<String>) se.getAttribute(""CaseManagementViewAction_filter_issues"")); <line45> } <line46> if (logger.isDebugEnabled()) { <line47> } <line48> NoteSelectionResult result = noteService.findNotes(loggedInInfo, criteria); <line49> List<String> buf = new ArrayList<String>(); <line50> for (NoteDisplay nd : result.getNotes()) { <line51> if (!(nd instanceof NoteDisplayLocal)) { <line52> continue; <line53> } <line54> buf.add(nd.getNoteId().toString()); <line55> } <line56> return buf.toArray(new String[0]); <line57> } <line58> } <line59> "	"<line47>      logger.debug(""SEARCHING FOR NOTES WITH CRITERIA: "" + criteria);"	task4	
"public class A { <line0> public static void unsubscribeFolder(HttpPrincipal httpPrincipal, long groupId, long folderId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> DLAppServiceUtil.class, ""unsubscribeFolder"", _unsubscribeFolderParameterTypes97); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, folderId); <line7> try { <line8> TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line11> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line12> } <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Test <line1> public void testCreateAndRemoveElement() throws Exception { <line2> uuidList = new LinkedList<String>(); <line3> Organization organization = createOrganization(); <line4> uuidList.add(organization.getUuid()); <line5> checkOrganization(organization); <line6> uuidList.addAll(createElementsInGroups(organization, NUMBER_PER_GROUP)); <line7> RemoveElement<CnATreeElement> removeCommand = new RemoveElement<CnATreeElement>(organization); <line8> commandService.executeCommand(removeCommand); <line9> for (String uuid : uuidList) { <line10> LoadElementByUuid<CnATreeElement> command = new LoadElementByUuid<CnATreeElement>(uuid); <line11> command = commandService.executeCommand(command); <line12> CnATreeElement element = command.getElement(); <line13> assertNull(""Organization was not deleted."", element); <line14> } <line15> } <line16> } <line17> "	"<line7>    LOG.info(""Total number of created elements: "" + uuidList.size());"	task4	
"public class A { <line0> @Override <line1> public boolean publishToStreaming() { <line2> HttpGet get = new HttpGet(""/publishToStreaming""); <line3> HttpResponse response = getResponse(get); <line4> if (response != null) { <line5> String content = null; <line6> try (BufferedReader r = <line7> new BufferedReader(new InputStreamReader(response.getEntity().getContent()))) { <line8> content = r.readLine(); <line9> } catch (Exception e) { <line10> } finally { <line11> closeConnection(response); <line12> } <line13> if (content != null) { <line14> return Boolean.parseBoolean(content.trim()); <line15> } <line16> } <line17> return false; <line18> } <line19> } <line20> "	"<line10>        logger.error(""Failed to read response from remote service: "", e);"	task4	
"public class A { <line0> protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) { <line1> SpringApplicationBuilder builder = createSpringApplicationBuilder(); <line2> builder.main(getClass()); <line3> ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); <line4> if (parent != null) { <line5> servletContext.setAttribute( <line6> WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); <line7> builder.initializers(new ParentContextApplicationContextInitializer(parent)); <line8> } <line9> builder.initializers(new ServletContextApplicationContextInitializer(servletContext)); <line10> builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); <line11> builder = configure(builder); <line12> SpringApplication application = builder.build(); <line13> if (application.getSources().isEmpty() <line14> && AnnotationUtils.findAnnotation(getClass(), Configuration.class) != null) { <line15> application.getSources().add(getClass()); <line16> } <line17> Assert.state( <line18> !application.getSources().isEmpty(), <line19> ""No SpringApplication sources have been defined. Either override the "" <line20> + ""configure method or add an @Configuration annotation""); <line21> if (this.registerErrorPageFilter) { <line22> application.getSources().add(ErrorPageFilter.class); <line23> } <line24> return run(application); <line25> } <line26> } <line27> "	"<line5>      this.logger.info(""Root context already created (using as parent)."");"	task4	
public class A { <line0> @Override <line1> public void delete(DeletePlan deletePlan) throws QueryProcessException { <line2> if (deletePlan.getPaths().isEmpty()) { <line3> return; <line4> } <line5> for (PartialPath path : deletePlan.getPaths()) { <line6> delete( <line7> path, <line8> deletePlan.getDeleteStartTime(), <line9> deletePlan.getDeleteEndTime(), <line10> deletePlan.getIndex()); <line11> } <line12> } <line13> } <line14> 	"<line3>      logger.info(""TimeSeries list to be deleted is empty."");"	task4	
"public class A { <line0> @DeleteMapping(value = ""/{modelId:.+}"") <line1> @PreAuthorize( <line2> ""hasAuthority('sysadmin') or "" <line3> + ""hasPermission(T(org.eclipse.vorto.model.ModelId).fromPrettyFormat(#modelId),"" <line4> + ""T(org.eclipse.vorto.repository.core.PolicyEntry.Permission).FULL_ACCESS)"") <line5> public ResponseEntity<Boolean> deleteModelResource(final @PathVariable String modelId) { <line6> Objects.requireNonNull(modelId, ""modelId must not be null""); <line7> try { <line8> getModelRepository(ModelId.fromPrettyFormat(modelId)) <line9> .removeModel(ModelId.fromPrettyFormat(modelId)); <line10> return new ResponseEntity<>(false, HttpStatus.OK); <line11> } catch (FatalModelRepositoryException | NullPointerException e) { <line12> return new ResponseEntity<>(false, HttpStatus.NOT_FOUND); <line13> } <line14> } <line15> } <line16> "	<line12>      LOGGER.error(e);	task4	
"public class A { <line0> @Override <line1> public void appendStripe( <line2> byte[] stripe, <line3> int offset, <line4> int length, <line5> StripeInformation stripeInfo, <line6> OrcProto.StripeStatistics stripeStatistics) <line7> throws IOException { <line8> checkArgument(stripe != null, ""Stripe must not be null""); <line9> checkArgument( <line10> length <= stripe.length, ""Specified length must not be greater specified array length""); <line11> checkArgument(stripeInfo != null, ""Stripe information must not be null""); <line12> checkArgument(stripeStatistics != null, ""Stripe statistics must not be null""); <line13> getStream(); <line14> long start = rawWriter.getBytesWritten(); <line15> long stripeLen = length; <line16> long availBlockSpace = blockSize - (start % blockSize); <line17> if (stripeLen < blockSize && stripeLen > availBlockSpace && addBlockPadding) { <line18> byte[] pad = new byte[(int) Math.min(HDFS_BUFFER_SIZE, availBlockSpace)]; <line19> start += availBlockSpace; <line20> while (availBlockSpace > 0) { <line21> int writeLen = (int) Math.min(availBlockSpace, pad.length); <line22> rawWriter.write(pad, 0, writeLen); <line23> availBlockSpace -= writeLen; <line24> } <line25> } <line26> rawWriter.write(stripe); <line27> rowsInStripe = stripeStatistics.getColStats(0).getNumberOfValues(); <line28> rowCount += rowsInStripe; <line29> treeWriter.stripeStatsBuilders.add(stripeStatistics.toBuilder()); <line30> updateFileStatistics(stripeStatistics); <line31> OrcProto.StripeInformation dirEntry = <line32> OrcProto.StripeInformation.newBuilder() <line33> .setOffset(start) <line34> .setNumberOfRows(rowsInStripe) <line35> .setIndexLength(stripeInfo.getIndexLength()) <line36> .setDataLength(stripeInfo.getDataLength()) <line37> .setFooterLength(stripeInfo.getFooterLength()) <line38> .build(); <line39> stripes.add(dirEntry); <line40> rowsInStripe = 0; <line41> } <line42> } <line43> "	"<line19>      LOG.info(String.format(""Padding ORC by %d bytes while merging.."", availBlockSpace));"	task4	
"public class A { <line0> protected void internalRemoveActivity(InternalActivityImpl activity) throws RepositoryException { <line1> WriteOperation operation = startWriteOperation(); <line2> try { <line3> NodeId nodeId = activity.getId(); <line4> if (stateMgr.hasNodeReferences(nodeId)) { <line5> NodeReferences refs = stateMgr.getNodeReferences(nodeId); <line6> if (refs.hasReferences()) { <line7> throw new ReferentialIntegrityException(""Unable to delete activity. still referenced.""); <line8> } <line9> } <line10> NodeStateEx act = getNodeStateEx(nodeId); <line11> NodeId parentId = act.getParentId(); <line12> Name name = act.getName(); <line13> while (parentId != null) { <line14> NodeStateEx parent = getNodeStateEx(parentId); <line15> parent.removeNode(name); <line16> parent.store(); <line17> if (parent.getChildNodes().length == 0 && !parentId.equals(activitiesId)) { <line18> name = parent.getName(); <line19> parentId = parent.getParentId(); <line20> } else { <line21> parentId = null; <line22> } <line23> } <line24> operation.save(); <line25> } catch (ItemStateException e) { <line26> } finally { <line27> operation.close(); <line28> } <line29> } <line30> } <line31> "	"<line26>      log.error(""Error while storing: "" + e.toString());"	task4	
public class A { <line0> private void matchMultiCallMethodNode( <line1> ISyntaxNode node, <line2> IBindingContext bindingContext, <line3> IOpenClass[] methodArguments, <line4> Deque<Integer> arrayArgArguments, <line5> int countOfChanged, <line6> MutableInt bestCountOfChanged, <line7> Map<MethodKey, IOpenMethod> candidates, <line8> MutableObject<IBoundNode> best) { <line9> if (countOfChanged > bestCountOfChanged.getValue() || arrayArgArguments.isEmpty()) { <line10> return; <line11> } <line12> IMethodCaller singleParameterMethodCaller; <line13> try { <line14> singleParameterMethodCaller = <line15> bindingContext.findMethodCaller( <line16> ISyntaxConstants.THIS_NAMESPACE, methodName, methodArguments); <line17> } catch (AmbiguousMethodException e) { <line18> if (countOfChanged < bestCountOfChanged.getValue()) { <line19> candidates.clear(); <line20> } <line21> for (IOpenMethod openMethod : e.getMatchingMethods()) { <line22> candidates.put(new MethodKey(openMethod), openMethod); <line23> } <line24> return; <line25> } <line26> if (singleParameterMethodCaller instanceof CastingMethodCaller) { <line27> CastingMethodCaller castingMethodCaller = (CastingMethodCaller) singleParameterMethodCaller; <line28> int i = 0; <line29> for (IOpenCast openCast : castingMethodCaller.getCasts()) { <line30> if (openCast instanceof IOneElementArrayCast && arrayArgArguments.contains(i)) { <line31> return; <line32> } <line33> i++; <line34> } <line35> } <line36> if (singleParameterMethodCaller == null) { <line37> return; <line38> } <line39> if (countOfChanged < bestCountOfChanged.getValue()) { <line40> candidates.clear(); <line41> bestCountOfChanged.setValue(countOfChanged); <line42> BindHelper.checkOnDeprecation(node, bindingContext, singleParameterMethodCaller); <line43> IBoundNode multiCallMethodBoundNode = <line44> makeMultiCallMethodBoundNode( <line45> node, children, new ArrayList<>(arrayArgArguments), singleParameterMethodCaller); <line46> best.setValue(multiCallMethodBoundNode); <line47> } <line48> candidates.put( <line49> new MethodKey(singleParameterMethodCaller.getMethod()), <line50> singleParameterMethodCaller.getMethod()); <line51> } <line52> } <line53> 	"<line24>      LOG.debug(""Error occurred: "", e);"	task4	
public class A { <line0> @Override <line1> public MatchResult getMatchingWeight(Record record1, Record record2) { <line2> Iterator<Attribute> mergedRecordAttributes = record1.getAttributes().iterator(); <line3> Iterator<Attribute> currentRecordAttributes = record2.getAttributes().iterator(); <line4> List<Double> leftWorstConfidenceValueScoreList = record1.getWorstConfidenceValueScoreList(); <line5> List<Double> rightWorstConfidenceValueScoreList = record2.getWorstConfidenceValueScoreList(); <line6> double confidence = 0; <line7> int matchIndex = 0; <line8> MatchResult result = new MatchResult(record1.getAttributes().size()); <line9> int maxWeight = 0; <line10> double finalWorstConfidenceValue = 0.0d; <line11> while (mergedRecordAttributes.hasNext()) { <line12> Attribute left = mergedRecordAttributes.next(); <line13> Attribute right = currentRecordAttributes.next(); <line14> IAttributeMatcher matcher = attributeMatchers[matchIndex]; <line15> Double leftWorstScore = getWorstScore(leftWorstConfidenceValueScoreList, matchIndex); <line16> Double rightWorstScore = getWorstScore(rightWorstConfidenceValueScoreList, matchIndex); <line17> double score = matchScore(left, right, matcher, leftWorstScore, rightWorstScore, matchIndex); <line18> attributeMatchingWeights[matchIndex] = score; <line19> result.setScore( <line20> matchIndex, <line21> matcher.getMatchType(), <line22> score, <line23> record1.getId(), <line24> left.getValue(), <line25> record2.getId(), <line26> right.getValue()); <line27> result.setThreshold(matchIndex, matcher.getThreshold()); <line28> result.storeWorstScore(matchIndex, worstConfidenceValue); <line29> confidence += score * matcher.getWeight(); <line30> finalWorstConfidenceValue += worstConfidenceValue * matcher.getWeight(); <line31> maxWeight += matcher.getWeight(); <line32> matchIndex++; <line33> } <line34> double normalizedConfidence = <line35> confidence > 0 && maxWeight != 0 ? confidence / maxWeight : confidence; <line36> finalWorstConfidenceValue = <line37> finalWorstConfidenceValue > 0 && maxWeight != 0 <line38> ? finalWorstConfidenceValue / maxWeight <line39> : finalWorstConfidenceValue; <line40> result.setConfidence(normalizedConfidence); <line41> result.setFinalWorstConfidenceValue(finalWorstConfidenceValue); <line42> if (normalizedConfidence < minConfidenceValue) { <line43> if (LOGGER.isDebugEnabled()) { <line44> } <line45> return MFB.NonMatchResult.wrap(result); <line46> } <line47> return result; <line48> } <line49> } <line50> 	"<line44>        LOGGER.debug(""Cannot match record: merged record has a too low confidence value (""+ normalizedConfidence+ "" < ""+ minConfidenceValue+ "")"");"	task4	
public class A { <line0> private Method getSetterMethod(S step, String propertyName, Class<?> expectedType) { <line1> Method setterMethod = null; <line2> String setterName = ClassUtils.setter(propertyName); <line3> try { <line4> setterMethod = step.getClass().getMethod(setterName, expectedType); <line5> } catch (Exception e) { <line6> try { <line7> setterName = getSetterName(propertyName); <line8> setterMethod = step.getClass().getMethod(setterName, expectedType); <line9> } catch (Exception e1) { <line10> } <line11> } <line12> return setterMethod; <line13> } <line14> } <line15> 	<line10>        LOG.warn(e1.getMessage(), e1);	task4	
public class A { <line0> @Override <line1> public boolean propogateKey() { <line2> if ((seenIgnore && count > maxUids) || !quarantinedIds.isEmpty()) return true; <line3> HashSet<String> uidsCopy = new HashSet<>(uids); <line4> uidsCopy.removeAll(uidsToRemove); <line5> if (log.isDebugEnabled()) { <line6> } <line7> if (count <= 0 && uidsCopy.isEmpty()) return false; <line8> else return true; <line9> } <line10> } <line11> 	"<line6>      log.debug(count+ "" ""+ uids.size()+ "" ""+ uidsToRemove.size()+ "" ""+ uidsCopy.size()+ "" removing ""+ (count == 0 && uidsCopy.isEmpty()));"	task4	
"public class A { <line0> @Override <line1> public void onMessage(final Message m) { <line2> TextMessage tm = (TextMessage) m; <line3> count++; <line4> try { <line5> if (count == 1) { <line6> if (!""a"".equals(tm.getText())) { <line7> failed(""Should be a but was "" + tm.getText()); <line8> latch.countDown(); <line9> } <line10> throw new RuntimeException(""Aardvark""); <line11> } else if (count == 2) { <line12> if (sess.getAcknowledgeMode() == Session.AUTO_ACKNOWLEDGE <line13> || sess.getAcknowledgeMode() == Session.DUPS_OK_ACKNOWLEDGE) { <line14> if (!""a"".equals(tm.getText())) { <line15> failed(""Should be a but was "" + tm.getText()); <line16> latch.countDown(); <line17> } <line18> if (!tm.getJMSRedelivered()) { <line19> failed(""Message was supposed to be a redelivery""); <line20> latch.countDown(); <line21> } <line22> } else { <line23> if (!""b"".equals(tm.getText())) { <line24> failed(""Should be b but was "" + tm.getText()); <line25> latch.countDown(); <line26> } <line27> } <line28> } else if (count == 3) { <line29> if (sess.getAcknowledgeMode() == Session.AUTO_ACKNOWLEDGE <line30> || sess.getAcknowledgeMode() == Session.DUPS_OK_ACKNOWLEDGE) { <line31> if (!""b"".equals(tm.getText())) { <line32> failed(""Should be b but was "" + tm.getText()); <line33> latch.countDown(); <line34> } <line35> } else { <line36> if (!""c"".equals(tm.getText())) { <line37> failed(""Should be c but was "" + tm.getText()); <line38> latch.countDown(); <line39> } <line40> latch.countDown(); <line41> } <line42> } else if (count == 4) { <line43> if (sess.getAcknowledgeMode() == Session.AUTO_ACKNOWLEDGE <line44> || sess.getAcknowledgeMode() == Session.DUPS_OK_ACKNOWLEDGE) { <line45> if (!""c"".equals(tm.getText())) { <line46> failed(""Should be c but was "" + tm.getText()); <line47> latch.countDown(); <line48> } <line49> latch.countDown(); <line50> } else { <line51> failed(""Shouldn't get a 4th message""); <line52> latch.countDown(); <line53> } <line54> } <line55> } catch (JMSException e) { <line56> failed(""Got a JMSException "" + e.toString()); <line57> latch.countDown(); <line58> } <line59> } <line60> } <line61> "	<line56>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> @Override <line2> public boolean containsPerson(GluuCustomPerson person) { <line3> boolean result = false; <line4> try { <line5> result = persistenceEntryManager.contains(GluuCustomPerson.class); <line6> } catch (Exception e) { <line7> } <line8> return result; <line9> } <line10> } <line11> "	<line7>      log.debug(e.getMessage(), e);	task4	
"public class A { <line0> @Ignore <line1> @Test <line2> public void findAllUsers() { <line3> UserSearchForm searchForm = new UserSearchForm(); <line4> searchForm.setSelectedLanguage(UserLanguage.ENGLISH); <line5> Pageable pageable = new PageRequest(0, 10, Sort.Direction.ASC, ""firstName""); <line6> Page<User> usersPage = userService.findAll(pageable, searchForm); <line7> assertEquals(5, usersPage.getTotalElements()); <line8> } <line9> } <line10> "	"<line7>    log.debug(""usersPage.getTotalElements(): {}"", usersPage.getTotalElements());"	task4	
"public class A { <line0> @Test <line1> public void test_binSeq_03() { <line2> checkOverlap( <line3> ""acgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgtacgt"", ""acgt"", 0, 0); <line4> } <line5> } <line6> "	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> @Override <line1> public void onError(Throwable t, Invoker<?> invoker, Invocation invocation) { <line2> } <line3> } <line4> 	"<line2>    logger.error(""Filter get error"", t);"	task4	
public class A { <line0> private void unregisterCommand(final ServiceRegistration<?> serviceRegistration) { <line1> try { <line2> serviceRegistration.unregister(); <line3> } catch (final IllegalStateException ex) { <line4> } <line5> } <line6> } <line7> 	"<line4>      logger.trace(""Service already unregistered."");"	task4	
public class A { <line0> public Object getJsonFieldValue(JSONObject jsonObject) { <line1> Object fieldValue = null; <line2> if (mNestedFields != null) { <line3> Object finalValue = null; <line4> for (int i = 0; i < mNestedFields.length; i++) { <line5> if (!jsonObject.containsKey(mNestedFields[i])) { <line6> break; <line7> } <line8> if (i < (mNestedFields.length - 1)) { <line9> jsonObject = (JSONObject) jsonObject.get(mNestedFields[i]); <line10> } else { <line11> finalValue = jsonObject.get(mNestedFields[i]); <line12> } <line13> } <line14> fieldValue = finalValue; <line15> } else { <line16> fieldValue = jsonObject.get(mConfig.getMessageTimestampName()); <line17> } <line18> return fieldValue; <line19> } <line20> } <line21> 	"<line6>          LOG.warn(""Could not find key {} in message"", mConfig.getMessageTimestampName());"	task4	
public class A { <line0> @Override <line1> public List<Project> getProjects(String key, String value, UserInfo userInfo) <line2> throws InvalidProtocolBufferException, ExecutionException, InterruptedException { <line3> FindProjects findProjects = <line4> FindProjects.newBuilder() <line5> .addPredicates( <line6> KeyValueQuery.newBuilder() <line7> .setKey(key) <line8> .setValue(Value.newBuilder().setStringValue(value).build()) <line9> .setOperator(OperatorEnum.Operator.EQ) <line10> .setValueType(ValueTypeEnum.ValueType.STRING) <line11> .build()) <line12> .build(); <line13> ProjectPaginationDTO projectPaginationDTO = <line14> findProjects(findProjects, null, userInfo, ResourceVisibility.PRIVATE); <line15> return projectPaginationDTO.getProjects(); <line16> } <line17> } <line18> 	"<line15>    LOGGER.debug(""Projects size is {}"", projectPaginationDTO.getProjects().size());"	task4	
"public class A { <line0> private void openGoogleForm() { <line1> String url = ""https://goo.gl/CC65By""; <line2> if (Desktop.isDesktopSupported()) { <line3> Desktop desktop = Desktop.getDesktop(); <line4> if (desktop.isSupported(java.awt.Desktop.Action.BROWSE)) { <line5> try { <line6> URI uri = new URI(url); <line7> desktop.browse(uri); <line8> } catch (IOException | URISyntaxException ex) { <line9> } <line10> } <line11> } else { <line12> JOptionPane.showMessageDialog(this, i18n.msg(""goto"") + url); <line13> } <line14> } <line15> } <line16> "	<line9>          LOG.error(ex.getLocalizedMessage());	task4	
"public class A { <line0> @DELETE <line1> @Path(""preparedqueries"") <line2> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN}) <line3> public APIResult destroyPreparedQueries( <line4> @QueryParam(""sessionid"") LensSessionHandle sessionid, <line5> @DefaultValue("""") @QueryParam(""user"") String user, <line6> @DefaultValue("""") @QueryParam(""queryName"") String queryName, <line7> @QueryParam(""fromDate"") String fromDate, <line8> @QueryParam(""toDate"") String toDate) <line9> throws LensException { <line10> validateSessionId(sessionid); <line11> int numDestroyed = 0; <line12> boolean failed = false; <line13> List<QueryPrepareHandle> handles = null; <line14> try { <line15> handles = getAllPreparedQueries(sessionid, user, queryName, fromDate, toDate); <line16> for (QueryPrepareHandle prepared : handles) { <line17> if (queryServer.destroyPrepared(sessionid, prepared)) { <line18> numDestroyed++; <line19> } <line20> } <line21> } catch (Exception e) { <line22> failed = true; <line23> } <line24> String msgString = (StringUtils.isBlank(user) ? """" : "" for user "" + user); <line25> if (handles != null && numDestroyed == handles.size()) { <line26> return new APIResult( <line27> Status.SUCCEEDED, ""Destroy all prepared "" + ""queries "" + msgString + "" is successful""); <line28> } else { <line29> assert (failed); <line30> if (numDestroyed == 0) { <line31> return new APIResult( <line32> Status.FAILED, ""Destroy all prepared "" + ""queries "" + msgString + "" has failed""); <line33> } else { <line34> return new APIResult( <line35> Status.PARTIAL, ""Destroy all prepared "" + ""queries "" + msgString + "" is partial""); <line36> } <line37> } <line38> } <line39> } <line40> "	"<line22>      log.error(""Error destroying prepared queries"", e);"	task4	
public class A { <line0> @Override <line1> public FileTime lastModifiedTime() { <line2> if (file == null) { <line3> return null; <line4> } <line5> FileTime time = null; <line6> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line7> final Date date = file.getLastModifiedDate(); <line8> if (date != null) { <line9> time = FileTime.fromMillis(date.getTime()); <line10> } <line11> tx.success(); <line12> } catch (FrameworkException fex) { <line13> } <line14> return time; <line15> } <line16> } <line17> 	"<line13>      logger.error("""", fex);"	task4	
public class A { <line0> public static boolean isByteValue(int b) { <line1> final boolean valid = ((b & 0xffffff00) == 0 || (b & 0xffffff00) == 0xffffff00); <line2> if (logger.isTraceEnabled() && valid && (b < -128 || b > 127)) { <line3> } <line4> return valid; <line5> } <line6> } <line7> 	"<line3>      logger.trace(""The value {} ({}) is considered a byte because only the 8 least significant bits are set""+ "", but its value is outside signed byte that is between -128 and 127"",b,Integer.toHexString(b));"	task4	
"public class A { <line0> @Override <line1> public Plugin newWikiPlugin(final String pluginName, final ResourceBundle rb) <line2> throws PluginException { <line3> Plugin plugin = null; <line4> WikiPluginInfo pluginInfo = m_pluginClassMap.get(pluginName); <line5> try { <line6> if (pluginInfo == null) { <line7> pluginInfo = WikiPluginInfo.newInstance(findPluginClass(pluginName)); <line8> registerPlugin(pluginInfo); <line9> } <line10> if (!checkCompatibility(pluginInfo)) { <line11> final String msg = <line12> ""Plugin '"" + pluginInfo.getName() + ""' not compatible with this version of JSPWiki""; <line13> } else { <line14> plugin = pluginInfo.newPluginInstance(m_searchPath, m_externalJars); <line15> } <line16> } catch (final ClassNotFoundException e) { <line17> throw new PluginException( <line18> MessageFormat.format(rb.getString(""plugin.error.couldnotfind""), pluginName), e); <line19> } catch (final InstantiationException e) { <line20> throw new PluginException( <line21> MessageFormat.format(rb.getString(""plugin.error.cannotinstantiate""), pluginName), e); <line22> } catch (final IllegalAccessException e) { <line23> throw new PluginException( <line24> MessageFormat.format(rb.getString(""plugin.error.notallowed""), pluginName), e); <line25> } catch (final Exception e) { <line26> throw new PluginException( <line27> MessageFormat.format(rb.getString(""plugin.error.instantationfailed""), pluginName), e); <line28> } <line29> return plugin; <line30> } <line31> } <line32> "	<line13>        log.info(msg);	task4	
"public class A { <line0> public static java.io.File getFileCustom(JFileChooser fileChooser) { <line1> fileChooser.rescanCurrentDirectory(); <line2> int retVal = fileChooser.showDialog(null, Bundle.getMessage(""MenuItemLoad"")); <line3> if (retVal != JFileChooser.APPROVE_OPTION) { <line4> return null; <line5> } <line6> if (log.isDebugEnabled()) { <line7> } <line8> return fileChooser.getSelectedFile(); <line9> } <line10> } <line11> "	"<line7>      log.debug(""Open file: {}"", fileChooser.getSelectedFile().getPath());"	task4	
"public class A { <line0> @PatchMapping(CommonConstants.PATH_ID) <line1> @Secured(ServicesData.ROLE_UPDATE_SECURITY_PROFILES) <line2> public SecurityProfileDto patch( <line3> final @PathVariable(""id"") String id, @RequestBody final Map<String, Object> partialDto) { <line4> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line5> Assert.isTrue( <line6> StringUtils.equals(id, (String) partialDto.get(""id"")), <line7> ""The DTO identifier must match the path identifier for update.""); <line8> return securityProfileExternalService.patch(partialDto); <line9> } <line10> } <line11> "	"<line4>    LOGGER.debug(""Patch {} with {}"", id, partialDto);"	task4	
"public class A { <line0> private static Query buildQuery(String keyword) { <line1> try { <line2> Analyzer analyzer = createAnalyzer(); <line3> QueryParser queryParser1 = new QueryParser(""text"", analyzer); <line4> Query termQuery1 = queryParser1.parse(keyword); <line5> BooleanClause booleanClause1 = new BooleanClause(termQuery1, BooleanClause.Occur.SHOULD); <line6> QueryParser queryParser2 = new QueryParser(""title"", analyzer); <line7> Query termQuery2 = queryParser2.parse(keyword); <line8> BooleanClause booleanClause2 = new BooleanClause(termQuery2, BooleanClause.Occur.SHOULD); <line9> BooleanQuery.Builder builder = new BooleanQuery.Builder(); <line10> builder.add(booleanClause1).add(booleanClause2); <line11> return builder.build(); <line12> } catch (ParseException e) { <line13> } <line14> return null; <line15> } <line16> } <line17> "	<line13>      LOG.error(e.toString(), e);	task4	
public class A { <line0> private String _toJSON(DataDefinition dataDefinition, DataRecord dataRecord) { <line1> try { <line2> return DataStorageUtil.toJSON(dataDefinition, dataRecord.getDataRecordValues()); <line3> } catch (Exception exception) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> return StringPool.BLANK; <line7> } <line8> } <line9> } <line10> 	<line5>        log.debug(exception, exception);	task4	
"public class A { <line0> @Override <line1> public void connectionLost(SocketAddress sa) { <line2> String msg = ""lost memcached connection ["" + sa + ""] reconnecting...""; <line3> } <line4> } <line5> "	<line3>    log.error(msg);	task4	
"public class A { <line0> @SuppressWarnings(""squid:S2583"") <line1> @SuppressFBWarnings( <line2> justification = <line3> ""yes, there is a redundant null check in the catch - to suppress warnings we are leaving"" <line4> + "" the null check"", <line5> value = {""RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE""}) <line6> public HttpURLConnection createHttpURLConnection(URL url) throws URLConnectionFailureException { <line7> HttpURLConnection conn = null; <line8> final String proxyHost = settings.getString(Settings.KEYS.PROXY_SERVER); <line9> try { <line10> if (proxyHost != null && !matchNonProxy(url)) { <line11> final int proxyPort = settings.getInt(Settings.KEYS.PROXY_PORT); <line12> final SocketAddress address = new InetSocketAddress(proxyHost, proxyPort); <line13> final String username = settings.getString(Settings.KEYS.PROXY_USERNAME); <line14> final String password = settings.getString(Settings.KEYS.PROXY_PASSWORD); <line15> if (username != null && password != null) { <line16> final Authenticator auth = <line17> new Authenticator() { <line18> @Override <line19> public PasswordAuthentication getPasswordAuthentication() { <line20> if (proxyHost.equals(getRequestingHost()) <line21> || getRequestorType().equals(Authenticator.RequestorType.PROXY)) { <line22> if (settings.getBoolean(Settings.KEYS.PROXY_DISABLE_SCHEMAS, true)) { <line23> System.setProperty(""jdk.http.auth.tunneling.disabledSchemes"", """"); <line24> } <line25> return new PasswordAuthentication(username, password.toCharArray()); <line26> } <line27> return super.getPasswordAuthentication(); <line28> } <line29> }; <line30> Authenticator.setDefault(auth); <line31> } <line32> final Proxy proxy = new Proxy(Proxy.Type.HTTP, address); <line33> conn = (HttpURLConnection) url.openConnection(proxy); <line34> } else { <line35> conn = (HttpURLConnection) url.openConnection(); <line36> } <line37> final int connectionTimeout = settings.getInt(Settings.KEYS.CONNECTION_TIMEOUT, 10000); <line38> conn.setConnectTimeout(connectionTimeout); <line39> conn.setInstanceFollowRedirects(true); <line40> } catch (IOException ex) { <line41> if (conn != null) { <line42> try { <line43> conn.disconnect(); <line44> } finally { <line45> conn = null; <line46> } <line47> } <line48> throw new URLConnectionFailureException(""Error getting connection."", ex); <line49> } <line50> configureTLS(url, conn); <line51> addAuthenticationIfPresent(conn); <line52> return conn; <line53> } <line54> } <line55> "	"<line22>                    LOGGER.debug(""Using the configured proxy username and password"");"	task4	
public class A { <line0> @Override <line1> public void registerRequestHandler(String appId, RequestHandler requestHandler) { <line2> this.registeredRequestHandlers.put(appId, requestHandler); <line3> if (isConnected()) { <line4> try { <line5> publishAppCertificate(); <line6> } catch (KuraException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.warn(""Unable to publish updated App Certificate"");"	task4	
public class A { <line0> @Override <line1> public void create(Object key, Object value) throws IOException { <line2> long start = stats.startUpdate(); <line3> Collection<Document> docs = Collections.emptyList(); <line4> boolean exceptionHappened = false; <line5> try { <line6> try { <line7> docs = serializer.toDocuments(index, value); <line8> } catch (Exception e) { <line9> exceptionHappened = true; <line10> stats.incFailedEntries(); <line11> } <line12> if (!exceptionHappened) { <line13> docs.forEach(doc -> SerializerUtil.addKey(key, doc)); <line14> writer.addDocuments(docs); <line15> } <line16> } finally { <line17> stats.endUpdate(start); <line18> } <line19> } <line20> } <line21> 	"<line11>        logger.info(""Failed to add index for "" + value + "" due to "" + e.getMessage());"	task4	
public class A { <line0> public ScheduledFuture<?> schedule(final Runnable task, long delay) { <line1> if (task == null) { <line2> return null; <line3> } <line4> return getProvider().getScheduler().schedule(task, delay, TimeUnit.MILLISECONDS); <line5> } <line6> } <line7> 	"<line2>      LOG.trace(""Resource attempted to schedule a null task."");"	task4	
public class A { <line0> public void executeTransaction( <line1> int serviceId, <line2> String interfaceName, <line3> int txId, <line4> byte[] arguments, <line5> BlockchainData blockchainData, <line6> int callerServiceId, <line7> HashCode txMessageHash, <line8> PublicKey authorPublicKey) { <line9> synchronized (lock) { <line10> ServiceWrapper service = getServiceById(serviceId); <line11> ExecutionContext context = <line12> newContext(service, blockchainData) <line13> .txMessageHash(txMessageHash) <line14> .authorPk(authorPublicKey) <line15> .build(); <line16> try { <line17> service.executeTransaction(interfaceName, txId, arguments, callerServiceId, context); <line18> } catch (Exception e) { <line19> throw e; <line20> } <line21> } <line22> } <line23> } <line24> 	"<line19>        logger.info(""Transaction execution failed (service={}, txId={}, txMessageHash={})"",service.getName(),txId,context.getTransactionMessageHash(),e);"	task4	
"public class A { <line0> static int getExpirationHoursForTable(String tableName, CentralStorageConfig storageConfig) { <line1> if (tableName.startsWith(""trace_"")) { <line2> return storageConfig.traceExpirationHours(); <line3> } else if (tableName.startsWith(""gauge_value_rollup_"")) { <line4> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line5> if (rollupLevel == 0) { <line6> return storageConfig.rollupExpirationHours().get(rollupLevel); <line7> } else { <line8> return storageConfig.rollupExpirationHours().get(rollupLevel - 1); <line9> } <line10> } else if (tableName.startsWith(""aggregate_tt_query_"") <line11> || tableName.startsWith(""aggregate_tn_query_"") <line12> || tableName.startsWith(""aggregate_tt_service_call_"") <line13> || tableName.startsWith(""aggregate_tn_service_call_"")) { <line14> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line15> return storageConfig.queryAndServiceCallRollupExpirationHours().get(rollupLevel); <line16> } else if (tableName.startsWith(""aggregate_tt_main_thread_profile_"") <line17> || tableName.startsWith(""aggregate_tn_main_thread_profile_"") <line18> || tableName.startsWith(""aggregate_tt_aux_thread_profile_"") <line19> || tableName.startsWith(""aggregate_tn_aux_thread_profile_"")) { <line20> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line21> return storageConfig.profileRollupExpirationHours().get(rollupLevel); <line22> } else if (tableName.startsWith(""aggregate_"") || tableName.startsWith(""synthetic_"")) { <line23> int rollupLevel = Integer.parseInt(tableName.substring(tableName.lastIndexOf('_') + 1)); <line24> return storageConfig.rollupExpirationHours().get(rollupLevel); <line25> } else if (tableName.equals(""gauge_name"") || tableName.equals(""agent"")) { <line26> return getMaxRollupExpirationHours(storageConfig); <line27> } else if (tableName.equals(""heartbeat"")) { <line28> return HeartbeatDao.EXPIRATION_HOURS; <line29> } else if (tableName.equals(""resolved_incident"")) { <line30> return Constants.RESOLVED_INCIDENT_EXPIRATION_HOURS; <line31> } else { <line32> return -1; <line33> } <line34> } <line35> } <line36> "	"<line32>      logger.warn(""unexpected table: {}"", tableName);"	task4	
public class A { <line0> public static boolean createUpgradeLog() { <line1> try { <line2> if (!upgradeLogPath.getParentFile().exists()) { <line3> upgradeLogPath.getParentFile().mkdirs(); <line4> } <line5> upgradeLogPath.createNewFile(); <line6> upgradeLogWriter = new BufferedWriter(new FileWriter(getUpgradeLogPath(), true)); <line7> return true; <line8> } catch (IOException e) { <line9> return false; <line10> } <line11> } <line12> } <line13> 	"<line9>      logger.error(""meet error when create upgrade log, file path:{}"", upgradeLogPath, e);"	task4	
public class A { <line0> @Override <line1> public void addTransaction(final PageTransactionInfo pageTransaction) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> transactions.put(pageTransaction.getTransactionID(), pageTransaction); <line5> } <line6> } <line7> 	"<line3>      logger.trace(""Adding pageTransaction "" + pageTransaction.getTransactionID());"	task4	
public class A { <line0> public org.talend.mdm.webservice.WSString getTransformerPluginV2Configuration( <line1> org.talend.mdm.webservice.WSTransformerPluginV2GetConfiguration arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSString _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	"<line2>    LOG.info(""Executing operation getTransformerPluginV2Configuration"");"	task4	
"public class A { <line0> private OAuthToken prepareNewToken( <line1> OAuthToken oldToken, <line2> String scope, <line3> List<String> oldRequestedScopesList, <line4> long ownerId, <line5> long clientId, <line6> String clientUserName, <line7> boolean createIdToken, <line8> String grant) <line9> throws OAuthErrorException { <line10> OAuthToken newToken = new OAuthToken(oldToken); <line11> List<String> newRequestedScopeList = new ArrayList<>(); <line12> if (scope != null && !scope.isEmpty()) { <line13> newRequestedScopeList.addAll(Arrays.asList(scope.split("" ""))); <line14> } <line15> if (!oldRequestedScopesList.containsAll(newRequestedScopeList)) { <line16> throw new OAuthErrorException(makeError(OAuth2Error.INVALID_SCOPE, ""wrong scope"")); <line17> } <line18> newToken.setRequestedScope(newRequestedScopeList.stream().toArray(String[]::new)); <line19> TranslationResult userInfoRes = getAttributes(clientId, ownerId, grant); <line20> List<ScopeInfo> newValidRequestedScopes = <line21> requestValidator.getValidRequestedScopes( <line22> Scope.parse(String.join("" "", newRequestedScopeList))); <line23> newToken.setEffectiveScope( <line24> newValidRequestedScopes.stream().map(s -> s.getName()).toArray(String[]::new)); <line25> UserInfo userInfoClaimSet = <line26> createUserInfo(newValidRequestedScopes, newToken.getSubject(), userInfoRes); <line27> newToken.setUserInfo(userInfoClaimSet.toJSONObject().toJSONString()); <line28> Date now = new Date(); <line29> if (newRequestedScopeList.contains(OIDCScopeValue.OPENID.getValue()) && createIdToken) { <line30> try { <line31> newToken.setOpenidToken( <line32> createIdToken( <line33> now, newToken, Arrays.asList(new Audience(clientUserName)), userInfoClaimSet)); <line34> } catch (Exception e) { <line35> throw new OAuthErrorException(makeError(OAuth2Error.SERVER_ERROR, e.getMessage())); <line36> } <line37> } else { <line38> newToken.setOpenidToken(null); <line39> } <line40> newToken.setMaxExtendedValidity(config.getMaxExtendedAccessTokenValidity()); <line41> newToken.setTokenValidity(config.getAccessTokenValidity()); <line42> newToken.setAccessToken(null); <line43> newToken.setRefreshToken(null); <line44> newToken.setIssuerUri(config.getIssuerName()); <line45> ; <line46> return newToken; <line47> } <line48> } <line49> "	"<line35>        log.error(""Cannot create new id token"", e);"	task4	
"public class A { <line0> @Override <line1> public void removeProperty(final String property) <line2> throws AccumuloException, AccumuloSecurityException { <line3> checkArgument(property != null, ""property is null""); <line4> DeprecatedPropertyUtil.getReplacementName( <line5> property, <line6> (log, replacement) -> { <line7> }); <line8> ManagerClient.executeVoid( <line9> context, <line10> client -> client.removeSystemProperty(TraceUtil.traceInfo(), context.rpcCreds(), property)); <line11> checkLocalityGroups(property); <line12> } <line13> } <line14> "	"<line7>          log.warn(""{} was deprecated and will be removed in a future release; assuming user meant""+ "" its replacement {} and will remove that instead"",property,replacement);"	task4	
public class A { <line0> @Override <line1> public void warn(Marker marker, String format, Object... arguments) { <line2> for (Logger logger : this.loggers) { <line3> } <line4> } <line5> } <line6> 	<line3>      logger.warn(marker, format, arguments);	task4	
"public class A { <line0> @Override <line1> public List<Broker> getBrokerByRetryType(String retryType) { <line2> Command request = <line3> new Command( <line4> new JoyQueueHeader(Direction.REQUEST, NsrCommandType.GET_BROKER_BY_RETRYTYPE), <line5> new GetBrokerByRetryType().retryType(retryType)); <line6> Command response = send(request); <line7> if (!response.isSuccess()) { <line8> throw new RuntimeException( <line9> String.format(""getBrokerByRetryType error request {},response {}"", request, response)); <line10> } <line11> return ((GetBrokerByRetryTypeAck) response.getPayload()).getBrokers(); <line12> } <line13> } <line14> "	"<line8>      logger.error(""getBrokerByRetryType error request {},response {}"", request, response);"	task4	
"public class A { <line0> @Override <line1> public Optional<MigrationIssue> getCourseMigrationIssue( <line2> String courseId, Integer migrationId, Integer issueId) throws IOException { <line3> String url = <line4> buildCanvasUrl( <line5> ""courses/"" <line6> + courseId <line7> + ""/content_migrations/"" <line8> + migrationId.toString() <line9> + ""/migration_issues/"" <line10> + issueId.toString(), <line11> Collections.emptyMap()); <line12> Response response = canvasMessenger.getSingleResponseFromCanvas(oauthToken, url); <line13> return responseParser.parseToObject(MigrationIssue.class, response); <line14> } <line15> } <line16> "	"<line3>    LOG.debug(""listing a migration issue for a content migration for the course"");"	task4	
public class A { <line0> public void requestThrottle(LocoAddress l) { <line1> ThrottleManager t = InstanceManager.throttleManagerInstance(); <line2> boolean result; <line3> result = t.requestThrottle(l, this, false); <line4> if (!result) { <line5> try { <line6> sendErrorStatus(); <line7> } catch (IOException ioe) { <line8> } <line9> } <line10> } <line11> } <line12> 	"<line8>        log.error(""Error writing to network port"");"	task4	
public class A { <line0> private void buildLanguagesFromClassification() { <line1> this.classificationLastRead = categoryDAO.getLastModified(); <line2> MCRCategory root = categoryDAO.getCategory(classification, -1); <line3> if (root == null) { <line4> return; <line5> } <line6> for (MCRCategory category : root.getChildren()) { <line7> buildLanguage(category); <line8> } <line9> } <line10> } <line11> 	"<line4>      LOGGER.warn(""Language classification {} not found"", classification.getRootID());"	task4	
"public class A { <line0> public static SiteReportRater getSiteReportRater(String recommendationLanguage) <line1> throws JAXBException { <line2> ClassLoader classLoader = SiteReport.class.getClassLoader(); <line3> JAXBContext context = JAXBContext.newInstance(RatingInfluencers.class); <line4> Unmarshaller um = context.createUnmarshaller(); <line5> InputStream in = classLoader.getResourceAsStream(INFLUENCERS_RESOURCE_LOCATION); <line6> RatingInfluencers influencers = (RatingInfluencers) um.unmarshal(in); <line7> context = JAXBContext.newInstance(Recommendations.class); <line8> um = context.createUnmarshaller(); <line9> String fileName = RECOMMENDATIONS_RESOURCE_LOCATION + ""_"" + recommendationLanguage + "".xml""; <line10> URL u = classLoader.getResource(fileName); <line11> if (u == null) { <line12> fileName = RECOMMENDATIONS_RESOURCE_LOCATION + "".xml""; <line13> } <line14> in = classLoader.getResourceAsStream(fileName); <line15> Recommendations recommendations = (Recommendations) um.unmarshal(in); <line16> SiteReportRater instance = new SiteReportRater(influencers, recommendations); <line17> return instance; <line18> } <line19> } <line20> "	"<line12>      LOGGER.warn(""Could not find language resources \""""+ fileName+ ""\"" for SiteReportRater. Using default (english)."");"	task4	
public class A { <line0> @Override <line1> public void doneUoW(Exchange exchange) { <line2> try { <line3> if (exchange == null) { <line4> return; <line5> } <line6> if (exchange.getUnitOfWork() == null) { <line7> List<Synchronization> synchronizations = <line8> exchange.adapt(ExtendedExchange.class).handoverCompletions(); <line9> UnitOfWorkHelper.doneSynchronizations(exchange, synchronizations, LOG); <line10> } else { <line11> exchange.getUnitOfWork().done(exchange); <line12> } <line13> } catch (Throwable e) { <line14> } <line15> } <line16> } <line17> 	"<line14>      LOG.warn(""Exception occurred during done UnitOfWork for Exchange: {}. This exception will be""+ "" ignored."",exchange,e);"	task4	
"public class A { <line0> protected void assignCurrentExpenditureToNonExistingAccountObjectCode( <line1> ContractsGrantsInvoiceDocument contractsGrantsInvoiceDocument, <line2> ContractsGrantsInvoiceDetail invoiceDetail) { <line3> String categoryCode = invoiceDetail.getCategoryCode(); <line4> if (StringUtils.isBlank(categoryCode)) { <line5> throw new IllegalArgumentException( <line6> ""Category Code can not be null during recalculation of account object code for Contracts"" <line7> + "" & Grants Invoice Document.""); <line8> } <line9> final CostCategory category = <line10> businessObjectService.findBySinglePrimaryKey(CostCategory.class, categoryCode); <line11> if (!ObjectUtils.isNull(category)) { <line12> final KualiDecimal oneCent = new KualiDecimal(0.01); <line13> int size = contractsGrantsInvoiceDocument.getAccountDetails().size(); <line14> KualiDecimal amount = <line15> new KualiDecimal( <line16> invoiceDetail <line17> .getInvoiceAmount() <line18> .bigDecimalValue() <line19> .divide(new BigDecimal(size), 2, RoundingMode.HALF_UP)); <line20> KualiDecimal remainder = <line21> invoiceDetail.getInvoiceAmount().subtract(amount.multiply(new KualiDecimal(size))); <line22> for (InvoiceAccountDetail invoiceAccountDetail : <line23> contractsGrantsInvoiceDocument.getAccountDetails()) { <line24> InvoiceDetailAccountObjectCode invoiceDetailAccountObjectCode = <line25> new InvoiceDetailAccountObjectCode(); <line26> invoiceDetailAccountObjectCode.setDocumentNumber( <line27> contractsGrantsInvoiceDocument.getDocumentNumber()); <line28> invoiceDetailAccountObjectCode.setProposalNumber( <line29> contractsGrantsInvoiceDocument.getInvoiceGeneralDetail().getProposalNumber()); <line30> invoiceDetailAccountObjectCode.setCategoryCode(categoryCode); <line31> invoiceDetailAccountObjectCode.setAccountNumber(invoiceAccountDetail.getAccountNumber()); <line32> invoiceDetailAccountObjectCode.setChartOfAccountsCode( <line33> invoiceAccountDetail.getChartOfAccountsCode()); <line34> invoiceDetailAccountObjectCode.setCumulativeExpenditures(KualiDecimal.ZERO); <line35> invoiceDetailAccountObjectCode.setTotalBilled(KualiDecimal.ZERO); <line36> final ObjectCodeCurrent objectCode = <line37> getCostCategoryService() <line38> .findObjectCodeForChartAndCategory( <line39> invoiceAccountDetail.getChartOfAccountsCode(), categoryCode); <line40> if (!ObjectUtils.isNull(objectCode)) { <line41> invoiceDetailAccountObjectCode.setFinancialObjectCode( <line42> objectCode.getFinancialObjectCode()); <line43> } <line44> if (remainder.isGreaterThan(KualiDecimal.ZERO)) { <line45> amount = amount.add(oneCent); <line46> remainder = remainder.subtract(oneCent); <line47> } else if (remainder.isLessThan(KualiDecimal.ZERO)) { <line48> amount = amount.subtract(oneCent); <line49> remainder = remainder.add(oneCent); <line50> } <line51> invoiceDetailAccountObjectCode.setCurrentExpenditures(amount); <line52> List<InvoiceDetailAccountObjectCode> invoiceDetailAccountObjectCodes = <line53> contractsGrantsInvoiceDocument.getInvoiceDetailAccountObjectCodes(); <line54> if (invoiceDetailAccountObjectCodes.contains(invoiceDetailAccountObjectCode)) { <line55> InvoiceDetailAccountObjectCode original = <line56> invoiceDetailAccountObjectCodes.get( <line57> invoiceDetailAccountObjectCodes.indexOf(invoiceDetailAccountObjectCode)); <line58> original.setCurrentExpenditures(amount); <line59> original.setCategoryCode(categoryCode); <line60> } else { <line61> contractsGrantsInvoiceDocument <line62> .getInvoiceDetailAccountObjectCodes() <line63> .add(invoiceDetailAccountObjectCode); <line64> } <line65> } <line66> } else { <line67> } <line68> } <line69> } <line70> "	"<line67>      LOG.error(""Category Code cannot be found from the category list during recalculation of account""+ "" object code for Contracts & Grants Invoice Document."");"	task4	
public class A { <line0> @Override <line1> protected void dispose(JRVirtualizable o) { <line2> VirtualizerStore store = store(o, false); <line3> if (store == null) { <line4> if (log.isTraceEnabled()) { <line5> } <line6> return; <line7> } <line8> store.remove(o.getUID()); <line9> } <line10> } <line11> 	"<line5>        log.trace(""no store found for "" + o.getUID() + "" for disposal"");"	task4	
public class A { <line0> @Override <line1> protected Group[] getRoleSets() throws LoginException { <line2> if (this.assertion == null) { <line3> try { <line4> this.assertion = SAMLUtil.fromElement(this.credential.getAssertionAsElement()); <line5> } catch (Exception e) { <line6> throw logger.authFailedToParseSAMLAssertion(e); <line7> } <line8> } <line9> if (logger.isTraceEnabled()) { <line10> try { <line11> } catch (ProcessingException ignore) { <line12> } <line13> } <line14> List<String> roleKeys = new ArrayList<String>(); <line15> if (StringUtil.isNotNull(roleKey)) { <line16> roleKeys.addAll(StringUtil.tokenize(roleKey)); <line17> } <line18> String groupName = SecurityConstants.ROLES_IDENTIFIER; <line19> Group rolesGroup = new PicketLinkGroup(groupName); <line20> List<String> roles = AssertionUtil.getRoles(assertion, roleKeys); <line21> for (String role : roles) { <line22> rolesGroup.addMember(new SimplePrincipal(role)); <line23> } <line24> return new Group[] {rolesGroup}; <line25> } <line26> } <line27> 	"<line11>        logger.trace(""Assertion from where roles will be sought = "" + AssertionUtil.asString(assertion));"	task4	
"public class A { <line0> @Override <line1> public Representation post(Representation entity) { <line2> try { <line3> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line4> JsonParameters jsonParameters = new JsonParameters(entity); <line5> String command = jsonParameters.getCommand(); <line6> ZkClient zkClient = <line7> (ZkClient) getContext().getAttributes().get(RestAdminApplication.ZKCLIENT); <line8> ClusterSetup setupTool = new ClusterSetup(zkClient); <line9> if (command.equalsIgnoreCase(ClusterSetup.addInstance) <line10> || JsonParameters.CLUSTERSETUP_COMMAND_ALIASES <line11> .get(ClusterSetup.addInstance) <line12> .contains(command)) { <line13> if (jsonParameters.getParameter(JsonParameters.INSTANCE_NAME) != null) { <line14> setupTool.addInstanceToCluster( <line15> clusterName, jsonParameters.getParameter(JsonParameters.INSTANCE_NAME)); <line16> } else if (jsonParameters.getParameter(JsonParameters.INSTANCE_NAMES) != null) { <line17> setupTool.addInstancesToCluster( <line18> clusterName, jsonParameters.getParameter(JsonParameters.INSTANCE_NAMES).split("";"")); <line19> } else { <line20> throw new HelixException( <line21> ""Missing Json paramaters: '"" <line22> + JsonParameters.INSTANCE_NAME <line23> + ""' or '"" <line24> + JsonParameters.INSTANCE_NAMES <line25> + ""' ""); <line26> } <line27> } else if (command.equalsIgnoreCase(ClusterSetup.swapInstance)) { <line28> if (jsonParameters.getParameter(JsonParameters.NEW_INSTANCE) == null <line29> || jsonParameters.getParameter(JsonParameters.OLD_INSTANCE) == null) { <line30> throw new HelixException( <line31> ""Missing Json paramaters: '"" <line32> + JsonParameters.NEW_INSTANCE <line33> + ""' or '"" <line34> + JsonParameters.OLD_INSTANCE <line35> + ""' ""); <line36> } <line37> setupTool.swapInstance( <line38> clusterName, <line39> jsonParameters.getParameter(JsonParameters.OLD_INSTANCE), <line40> jsonParameters.getParameter(JsonParameters.NEW_INSTANCE)); <line41> } else { <line42> throw new HelixException( <line43> ""Unsupported command: "" <line44> + command <line45> + "". Should be one of ["" <line46> + ClusterSetup.addInstance <line47> + "", "" <line48> + ClusterSetup.swapInstance <line49> + ""]""); <line50> } <line51> getResponse().setEntity(getInstancesRepresentation(clusterName)); <line52> getResponse().setStatus(Status.SUCCESS_OK); <line53> } catch (Exception e) { <line54> getResponse() <line55> .setEntity( <line56> ClusterRepresentationUtil.getErrorAsJsonStringFromException(e), <line57> MediaType.APPLICATION_JSON); <line58> getResponse().setStatus(Status.SUCCESS_OK); <line59> } <line60> return null; <line61> } <line62> } <line63> "	"<line59>      LOG.error("""", e);"	task4	
public class A { <line0> @Test <line1> public void testHexBase32() { <line2> try { <line3> final GUIDImpl parsed1 = new GUIDImpl(properties.getProperty(FIELDS.BASE32.name())); <line4> final GUIDImpl parsed2 = new GUIDImpl(properties.getProperty(FIELDS.BASE64.name())); <line5> final GUIDImpl parsed0 = new GUIDImpl(properties.getProperty(FIELDS.BASE16.name())); <line6> final GUIDImpl parsed8 = new GUIDImpl(properties.getProperty(FIELDS.BASEARK.name())); <line7> final byte[] bytes = <line8> StringUtils.getBytesFromArraysToString(properties.getProperty(FIELDS.BYTES.name())); <line9> final GUIDImpl parsed9 = new GUIDImpl(bytes); <line10> assertTrue(parsed1.equals(parsed2)); <line11> assertTrue(parsed1.equals(parsed0)); <line12> assertTrue(parsed1.equals(parsed8)); <line13> assertTrue(parsed1.equals(parsed9)); <line14> final GUIDImpl parsed3 = new GUIDImpl(parsed9.getBytes()); <line15> final GUIDImpl parsed4 = new GUIDImpl(parsed9.toBase32()); <line16> final GUIDImpl parsed5 = new GUIDImpl(parsed9.toHex()); <line17> final GUIDImpl parsed6 = new GUIDImpl(parsed9.toString()); <line18> final GUIDImpl parsed7 = new GUIDImpl(parsed9.toBase64()); <line19> assertTrue(parsed9.equals(parsed3)); <line20> assertTrue(parsed9.equals(parsed4)); <line21> assertTrue(parsed9.equals(parsed5)); <line22> assertTrue(parsed9.equals(parsed6)); <line23> assertTrue(parsed9.equals(parsed7)); <line24> final GUIDImpl generated = new GUIDImpl(); <line25> assertTrue(generated.getVersion() == 0); <line26> } catch (final InvalidGuidOperationException e) { <line27> fail(e.getMessage()); <line28> } <line29> } <line30> } <line31> 	<line27>      LOGGER.debug(e);	task4	
"public class A { <line0> @Override <line1> public List<DocumentInfo> findDocumentByEmployeeName(String employeeName) { <line2> List<DocumentInfo> documents = new ArrayList<DocumentInfo>(); <line3> String query = <line4> ""Select d from "" <line5> + DocumentInfo.class.getSimpleName() <line6> + "" d where d.ownerName =  "" <line7> + employeeName; <line8> documents = (List<DocumentInfo>) dao.findByQuery(query); <line9> for (DocumentInfo documentInfo : documents) { <line10> StreamedContent file = <line11> toStreamedContent( <line12> documentInfo.getData(), documentInfo.getDocumentName(), ""application/pdf""); <line13> documentInfo.addFile(file); <line14> } <line15> return documents; <line16> } <line17> } <line18> "	"<line3>    log.info(""Finding document by employee name {} ."", employeeName);"	task4	
"public class A { <line0> public void handleCondition( <line1> BaseCondition condition, String deplomentId, String statementName, String optionalEPL) { <line2> if (conditionHandlers.isEmpty()) { <line3> String message = <line4> ""Condition encountered processing deployment id '"" <line5> + deplomentId <line6> + ""' statement '"" <line7> + statementName <line8> + ""'""; <line9> if (optionalEPL != null) { <line10> message += "" statement text '"" + optionalEPL + ""'""; <line11> } <line12> message += "" :"" + condition.toString(); <line13> return; <line14> } <line15> ConditionHandlerContext context = <line16> new ConditionHandlerContext(runtimeURI, statementName, deplomentId, condition); <line17> for (ConditionHandler handler : conditionHandlers) { <line18> handler.handle(context); <line19> } <line20> } <line21> } <line22> "	<line13>      log.info(message);	task4	
"public class A { <line0> private PopupObjectListPanel<T> createObjectListPanel( <line1> String id, final String countId, final QName type) { <line2> PopupObjectListPanel<T> listPanel = <line3> new PopupObjectListPanel<T>(id, qnameToCompileTimeClass(type), true, getPageBase()) { <line4> @Override <line5> protected void onUpdateCheckbox(AjaxRequestTarget target) { <line6> refreshCounts(target); <line7> } <line8>  <line9> @Override <line10> protected ObjectQuery addFilterToContentQuery(ObjectQuery query) { <line11> if (type.equals(RoleType.COMPLEX_TYPE)) { <line12> OperationResult result = new OperationResult(OPERATION_LOAD_ASSIGNABLE_ROLES); <line13> ObjectFilter filter = null; <line14> try { <line15> ModelInteractionService mis = parentPage.getModelInteractionService(); <line16> RoleSelectionSpecification roleSpec = <line17> mis.getAssignableRoleSpecification( <line18> SecurityUtils.getPrincipalUser().getUser().asPrismObject(), result); <line19> filter = roleSpec.getFilter(); <line20> } catch (Exception ex) { <line21> LoggingUtils.logUnexpectedException(LOGGER, ""Couldn't load available roles"", ex); <line22> result.recordFatalError(""Couldn't load available roles"", ex); <line23> } finally { <line24> result.recomputeStatus(); <line25> } <line26> if (!result.isSuccess() && !result.isHandledError()) { <line27> parentPage.showResult(result); <line28> } <line29> if (query == null) { <line30> query = new ObjectQuery(); <line31> } <line32> query.addFilter(filter); <line33> } <line34> return query; <line35> } <line36> }; <line37> listPanel.setOutputMarkupId(true); <line38> listPanel.add( <line39> new VisibleEnableBehaviour() { <line40> @Override <line41> public boolean isVisible() { <line42> return type.equals(typeModel.getObject()); <line43> } <line44> }); <line45> return listPanel; <line46> } <line47> } <line48> "	"<line12>              LOGGER.debug(""Loading roles which the current user has right to assign"");"	task4	
"public class A { <line0> public static <T> T throwIfTypeNot(Object entity, Class<T> targetClass) { <line1> if (entity != null && !targetClass.isAssignableFrom(entity.getClass())) { <line2> throw new IllegalArgumentException(""Expected "" + targetClass + "" got "" + entity); <line3> } <line4> return (T) entity; <line5> } <line6> } <line7> "	"<line2>      LOGGER.error(""Expected {}, but got {}"", targetClass, entity);"	task4	
public class A { <line0> public SecurityEvent createSecurityEvent( <line1> String loggingClass, <line2> URI requestUri, <line3> String slMessage, <line4> Entity explicitRealmEntity, <line5> String entityType, <line6> Set<Entity> entities) { <line7> Set<String> targetEdOrgs = getTargetEdOrgStateIds(entityType, entities); <line8> return createSecurityEvent( <line9> loggingClass, requestUri, slMessage, null, null, explicitRealmEntity, targetEdOrgs, false); <line10> } <line11> } <line12> 	"<line7>    LOG.debug(""Creating security event with targetEdOrgList determined from entities of type ""+ entityType);"	task4	
"public class A { <line0> private void streamChangesForReplicaSet(ChangeEventSourceContext context, ReplicaSet replicaSet) { <line1> MongoPrimary primaryClient = null; <line2> try { <line3> primaryClient = establishConnectionToPrimary(replicaSet); <line4> if (primaryClient != null) { <line5> final AtomicReference<MongoPrimary> primaryReference = new AtomicReference<>(primaryClient); <line6> primaryClient.execute( <line7> ""read from oplog on '"" + replicaSet + ""'"", <line8> primary -> { <line9> readOplog(primary, primaryReference.get(), replicaSet, context); <line10> }); <line11> } <line12> } catch (Throwable t) { <line13> errorHandler.setProducerThrowable(t); <line14> } finally { <line15> if (primaryClient != null) { <line16> primaryClient.stop(); <line17> } <line18> } <line19> } <line20> } <line21> "	"<line13>      LOGGER.error(""Streaming for replica set {} failed"", replicaSet.replicaSetName(), t);"	task4	
public class A { <line0> @Override <line1> public void writeItems(List<Object> people) throws Exception { <line2> for (Object person : people) { <line3> if (LOG.isInfoEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	"<line4>        LOG.info(""Writing person: "" + person);"	task4	
public class A { <line0> @Override <line1> public boolean isAvailableLocale(long groupId, String languageId) { <line2> if (groupId <= 0) { <line3> return isAvailableLocale(languageId); <line4> } <line5> try { <line6> if (isInheritLocales(groupId)) { <line7> Group group = GroupLocalServiceUtil.getGroup(groupId); <line8> CompanyLocalesBag companyLocalesBag = _getCompanyLocalesBag(group.getCompanyId()); <line9> return companyLocalesBag.containsLanguageId(languageId); <line10> } <line11> } catch (Exception exception) { <line12> if (log.isDebugEnabled()) { <line13> } <line14> } <line15> Map<String, Locale> groupLanguageIdLocalesMap = _getGroupLanguageIdLocalesMap(groupId); <line16> return groupLanguageIdLocalesMap.containsKey(languageId); <line17> } <line18> } <line19> 	<line13>        log.debug(exception, exception);	task4	
"public class A { <line0> public String buildOutputZip() { <line1> bundleBuildResponse = bundleRequestService.lookupBuildRequest(getId()); <line2> String zipFileName = <line3> fileService.createOutputFilesZip(bundleBuildResponse.getRemoteOutputDirectory()); <line4> try { <line5> downloadInputStream = new FileInputStream(zipFileName); <line6> } catch (FileNotFoundException e) { <line7> e.printStackTrace(); <line8> } <line9> return ""downloadZip""; <line10> } <line11> } <line12> "	"<line1>    log.info(""buildOuputZip called with id="" + id);"	task4	
public class A { <line0> @Override <line1> public SegmentMetadata load(File segmentDir) throws Exception { <line2> final SegmentMetadata segmentMetadata = new SegmentMetadataImpl(segmentDir); <line3> return segmentMetadata; <line4> } <line5> } <line6> 	"<line3>    LOGGER.info(""Loaded segment metadata for segment : "" + segmentMetadata.getName());"	task4	
public class A { <line0> public synchronized void addConnection(Address peer_addr, Connection conn) throws Exception { <line1> boolean conn_exists = hasConnection(peer_addr), <line2> replace = conn_exists && local_addr.compareTo(peer_addr) < 0; <line3> if (!conn_exists || replace) { <line4> replaceConnection(peer_addr, conn); <line5> conn.start(); <line6> } else { <line7> Util.close(conn); <line8> } <line9> } <line10> } <line11> 	"<line7>      log.trace(""%s: rejected connection from %s %s"",local_addr, peer_addr, explanation(conn_exists, replace));"	task4	
public class A { <line0> public Map<String, IngestFromHdfsPlugin<?, ?>> createHdfsIngestPlugins() { <line1> final Map<String, IngestFromHdfsPlugin<?, ?>> ingestPlugins = new HashMap<>(); <line2> for (final Entry<String, IngestFormatPluginProviderSpi<?, ?>> entry : plugins.entrySet()) { <line3> final IngestFormatPluginProviderSpi<?, ?> formatPlugin = entry.getValue(); <line4> final IngestFormatOptions formatOptions = options.get(entry.getKey()); <line5> IngestFromHdfsPlugin<?, ?> plugin = null; <line6> try { <line7> plugin = formatPlugin.createIngestFromHdfsPlugin(formatOptions); <line8> if (plugin == null) { <line9> throw new UnsupportedOperationException(); <line10> } <line11> } catch (final UnsupportedOperationException e) { <line12> continue; <line13> } <line14> ingestPlugins.put(formatPlugin.getIngestFormatName(), plugin); <line15> } <line16> return ingestPlugins; <line17> } <line18> } <line19> 	"<line12>        LOGGER.warn(""Plugin provider for ingest type '""+ formatPlugin.getIngestFormatName()+ ""' does not support hdfs ingest"",e);"	task4	
public class A { <line0> public org.talend.mdm.webservice.WSTransformerV2PK putTransformerV2( <line1> org.talend.mdm.webservice.WSPutTransformerV2 arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSTransformerV2PK _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	"<line2>    LOG.info(""Executing operation putTransformerV2"");"	task4	
public class A { <line0> @Override <line1> public void onError(Throwable t) { <line2> PingPongImpl.this.streamRequests.add(streamRequests); <line3> } <line4> } <line5> 	"<line3>    LOG.info(""Error in pingAsyncAsync() {}"", t.getMessage());"	task4	
public class A { <line0> public void stop() { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> if (serializedExecutor != null) { <line4> serializedExecutor.shutdownNow(); <line5> } <line6> serializedExecutor = null; <line7> } <line8> } <line9> 	"<line2>      logger.debug(""{} Stopping leadership election..."", logPrefix());"	task4	
"public class A { <line0> @Override <line1> protected void onTimer(final AjaxRequestTarget target) { <line2> if (isStopped()) { <line3> getComponent().remove(this); <line4> return; <line5> } <line6> final TimerPushService pushService = TimerPushService.get(target.getPage().getApplication()); <line7> final WebRequest request = (WebRequest) RequestCycle.get().getRequest(); <line8> if (!request.getRequestParameters().getParameterValue(""unload"").isNull()) <line9> for (final TimerPushNode<?> node : handlers.keySet()) pushService.onDisconnect(node); <line10> else <line11> for (final Entry<TimerPushNode, IPushEventHandler> entry : handlers.entrySet()) { <line12> final TimerPushNode node = entry.getKey(); <line13> for (final IPushEventContext<?> ctx : <line14> (List<IPushEventContext<?>>) pushService.pollEvents(node)) <line15> try { <line16> entry.getValue().onEvent(target, ctx.getEvent(), node, ctx); <line17> } catch (final RuntimeException ex) { <line18> } <line19> } <line20> } <line21> } <line22> "	"<line18>            LOG.error(""Failed while processing event"", ex);"	task4	
"public class A { <line0> ReadonlyValueException translateReadonlyViolation( <line1> Throwable sourceThrowable, PSQLException pSqlException) { <line2> Matcher matcher = <line3> Pattern.compile( <line4> ""Updating read-only column \""?(.*?)\""? of table \""?(.*?)\""? with id \\[(.*?)] is"" <line5> + "" not allowed"") <line6> .matcher(pSqlException.getServerErrorMessage().getMessage()); <line7> boolean matches = matcher.matches(); <line8> if (!matches) { <line9> throw new RuntimeException(ERROR_TRANSLATING_EXCEPTION_MSG, pSqlException); <line10> } <line11> String colName = matcher.group(1); <line12> String tableName = matcher.group(2); <line13> String id = matcher.group(3); <line14> String attributeName = tryGetAttributeName(tableName, colName).orElse(null); <line15> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line16> return new ReadonlyValueException(entityTypeId, attributeName, id, sourceThrowable); <line17> } <line18> } <line19> "	<line9>      LOG.error(ERROR_TRANSLATING_POSTGRES_EXC_MSG, pSqlException);	task4	
public class A { <line0> private boolean isAccessPointReachable(String interfaceName, int tout) throws KuraException { <line1> boolean ret = true; <line2> RouteService rs = getRouteService(); <line3> RouteConfig rconf = rs.getDefaultRoute(interfaceName); <line4> if (rconf != null) { <line5> IPAddress ipAddress = rconf.getGateway(); <line6> String iface = rconf.getInterfaceName(); <line7> if (ipAddress != null && iface != null && iface.equals(interfaceName)) { <line8> try { <line9> InetAddress inetAddress = InetAddress.getByName(ipAddress.getHostAddress()); <line10> ret = inetAddress.isReachable(tout); <line11> } catch (Exception e) { <line12> throw new KuraException(KuraErrorCode.INTERNAL_ERROR, e); <line13> } <line14> } <line15> } <line16> return ret; <line17> } <line18> } <line19> 	"<line11>          logger.info(""Access point reachable? {}"", ret);"	task4	
public class A { <line0> private void showLater(TestModalSampleDialog dialog) { <line1> SwingUtilities.invokeLater( <line2> new Runnable() { <line3> @Override <line4> public void run() { <line5> dialog.showDialog(); <line6> } <line7> }); <line8> } <line9> } <line10> 	<line5>            logger.info(dialog.getTitle());	task4	
public class A { <line0> private void initializeFileSystem(final IndexedDiskCacheAttributes cattr) { <line1> this.rafDir = cattr.getDiskPath(); <line2> } <line3> } <line4> 	"<line2>    log.info(""{0}: Cache file root directory: {1}"", logCacheName, rafDir);"	task4	
"public class A { <line0> @Override <line1> public void deleteTestTopic(String topic) { <line2> Properties props = getSecureProperties(); <line3> props.putAll(getStandardProperties()); <line4> String clientId = Long.toString(new Random().nextLong()); <line5> props.put(""client.id"", clientId); <line6> AdminClient adminClient = AdminClient.create(props); <line7> try { <line8> tryDelete(adminClient, topic); <line9> } catch (Exception e) { <line10> e.printStackTrace(); <line11> fail(String.format(""Delete test topic : %s failed, %s"", topic, e.getMessage())); <line12> } finally { <line13> adminClient.close(Duration.ofMillis(5000L)); <line14> maybePrintDanglingThreadStacktrace(clientId); <line15> } <line16> } <line17> } <line18> "	"<line2>    LOG.info(""Deleting topic {}"", topic);"	task4	
"public class A { <line0> protected ExecutionResult prepareNetworkElementCommand(final IpAssocCommand cmd) { <line1> final Connection conn = getConnection(); <line2> final String routerName = cmd.getAccessDetail(NetworkElementCommand.ROUTER_NAME); <line3> final String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP); <line4> try { <line5> final IpAddressTO[] ips = cmd.getIpAddresses(); <line6> for (final IpAddressTO ip : ips) { <line7> final VM router = getVM(conn, routerName); <line8> final NicTO nic = new NicTO(); <line9> nic.setMac(ip.getVifMacAddress()); <line10> nic.setType(ip.getTrafficType()); <line11> if (ip.getBroadcastUri() == null) { <line12> nic.setBroadcastType(BroadcastDomainType.Native); <line13> } else { <line14> final URI uri = BroadcastDomainType.fromString(ip.getBroadcastUri()); <line15> nic.setBroadcastType(BroadcastDomainType.getSchemeValue(uri)); <line16> nic.setBroadcastUri(uri); <line17> } <line18> nic.setDeviceId(0); <line19> nic.setNetworkRateMbps(ip.getNetworkRate()); <line20> nic.setName(ip.getNetworkName()); <line21> final Network network = getNetwork(conn, nic); <line22> VIF correctVif = getCorrectVif(conn, router, network); <line23> boolean addVif = false; <line24> if (ip.isAdd() && correctVif == null) { <line25> addVif = true; <line26> } <line27> if (addVif) { <line28> final String vifDeviceNum = getLowestAvailableVIFDeviceNum(conn, router); <line29> if (vifDeviceNum == null) { <line30> throw new InternalErrorException( <line31> ""There were no more available slots for a new VIF on router: "" <line32> + router.getNameLabel(conn)); <line33> } <line34> nic.setDeviceId(Integer.parseInt(vifDeviceNum)); <line35> correctVif = createVif(conn, routerName, router, null, nic); <line36> correctVif.plug(conn); <line37> networkUsage(conn, routerIp, ""addVif"", ""eth"" + correctVif.getDevice(conn)); <line38> } <line39> if (ip.isAdd() && correctVif == null) { <line40> throw new InternalErrorException( <line41> ""Failed to find DomR VIF to associate/disassociate IP with.""); <line42> } <line43> if (correctVif != null) { <line44> ip.setNicDevId(Integer.valueOf(correctVif.getDevice(conn))); <line45> ip.setNewNic(addVif); <line46> } <line47> } <line48> } catch (final InternalErrorException e) { <line49> return new ExecutionResult(false, e.getMessage()); <line50> } catch (final Exception e) { <line51> return new ExecutionResult(false, e.getMessage()); <line52> } <line53> return new ExecutionResult(true, null); <line54> } <line55> } <line56> "	"<line49>      logger.error(""Ip Assoc failure on applying one ip due to exception:  "", e);"	task4	
"public class A { <line0> @Override <line1> public Set<AcceptApplication> findAcceptApplicationName( <line2> Application fromApplication, Range range) { <line3> Objects.requireNonNull(fromApplication, ""fromApplication""); <line4> final Scan scan = createScan(fromApplication, range); <line5> TableName hostApplicationMapTableName = <line6> tableNameProvider.getTableName(HbaseTable.HOST_APPLICATION_MAP_VER2); <line7> final List<List<AcceptApplication>> result = <line8> hbaseOperations2.findParallel( <line9> hostApplicationMapTableName, <line10> scan, <line11> acceptApplicationRowKeyDistributor, <line12> hostApplicationMapperVer2, <line13> HOST_APPLICATION_MAP_VER2_NUM_PARTITIONS); <line14> if (CollectionUtils.isNotEmpty(result)) { <line15> final Set<AcceptApplication> resultSet = new HashSet<>(); <line16> for (List<AcceptApplication> resultList : result) { <line17> resultSet.addAll(resultList); <line18> } <line19> return resultSet; <line20> } else { <line21> return Collections.emptySet(); <line22> } <line23> } <line24> } <line25> "	"<line19>      logger.debug(""findAcceptApplicationName result:{}"", resultSet);"	task4	
public class A { <line0> public AIResource mapAIPLarformValueToAIResource( <line1> AIPlatformValue aiPlatform, AIResource aiResource) { <line2> if (null == aiPlatform) { <line3> return aiResource; <line4> } <line5> if (null == aiResource) { <line6> aiResource = new AIResource(); <line7> } <line8> aiResource.setNaturalID(aiPlatform.getFqdn()); <line9> aiResource.setName(aiPlatform.getName()); <line10> aiResource.setResourceType(ResourceTypeModel.PLATFORM); <line11> ResourcePrototype resourcePrototype = new ResourcePrototype(); <line12> resourcePrototype.setName(aiPlatform.getPlatformTypeName()); <line13> aiResource.setResourcePrototype(resourcePrototype); <line14> AIServerValue[] aiServerValues = aiPlatform.getAIServerValues(); <line15> if ((null != aiServerValues) && (aiServerValues.length > 0)) { <line16> List<ResourceModel> subResources = new ArrayList<ResourceModel>(aiServerValues.length); <line17> for (int i = 0; i < aiServerValues.length; i++) { <line18> AIResource aiServer = mapAIServerValueToAIResource(aiServerValues[i], null); <line19> subResources.add(aiServer); <line20> } <line21> aiResource.setSubResources(subResources); <line22> } <line23> return aiResource; <line24> } <line25> } <line26> 	"<line3>      logger.debug(""Note: Empty AI platform is being mapped."");"	task4	
public class A { <line0> @Override <line1> public void onCommunicationLost(Association association) { <line2> this.handleCommDown(); <line3> } <line4> } <line5> 	"<line2>    logger.warn(String.format(""Communication channel lost for AspFactroy=%s Association=%s"",this.name, association.getName()));"	task4	
public class A { <line0> public void setTracingEnabled(String executionPlanName, boolean isEnabled) <line1> throws RemoteException { <line2> try { <line3> eventProcessorAdminServiceStub.setTracingEnabled(executionPlanName, isEnabled); <line4> } catch (RemoteException e) { <line5> throw e; <line6> } <line7> } <line8> } <line9> 	"<line5>      log.error(""RemoteException"", e);"	task4	
public class A { <line0> public void run() { <line1> while (true) { <line2> try { <line3> sleep(flushInterval); <line4> bookie.getSyncThread().checkpoint(Checkpoint.MAX); <line5> ledgerCache.flushLedger(true); <line6> } catch (InterruptedException ie) { <line7> Thread.currentThread().interrupt(); <line8> return; <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> } <line14> 	"<line10>        LOG.error(""Exception in flush thread"", e);"	task4	
"public class A { <line0> private void setStationData() throws IOException { <line1> String cStationName = this.stationName; <line2> if (this.getUrnToStationName().containsKey(this.stationName)) { <line3> cStationName = this.getUrnToStationName().get(this.stationName); <line4> } <line5> switch (this.getDatasetFeatureType()) { <line6> case STATION: <line7> this.stationData = new TimeSeries(new String[] {cStationName}, null, null); <line8> this.stationData.setData(this.getFeatureTypeDataSet()); <line9> break; <line10> case STATION_PROFILE: <line11> this.stationData = <line12> new TimeSeriesProfile( <line13> new String[] {cStationName}, null, null, false, false, false, null); <line14> this.stationData.setData(this.getFeatureTypeDataSet()); <line15> break; <line16> case PROFILE: <line17> this.stationData = new Profile(new String[] {cStationName}, null, null); <line18> this.stationData.setData(this.getFeatureTypeDataSet()); <line19> break; <line20> case TRAJECTORY: <line21> this.stationData = new Trajectory(new String[] {cStationName}, null, null); <line22> this.stationData.setData(this.getFeatureTypeDataSet()); <line23> this.locationLineFlag = true; <line24> break; <line25> case SECTION: <line26> this.stationData = new Section(new String[] {cStationName}, null, null); <line27> this.stationData.setData(this.getFeatureTypeDataSet()); <line28> this.locationLineFlag = true; <line29> break; <line30> case GRID: <line31> HashMap<String, String> latLon = new HashMap<String, String>(); <line32> latLon.put( <line33> Grid.LAT, <line34> this.getGridDataset().getBoundingBox().getLatMin() <line35> + ""_"" <line36> + this.getGridDataset().getBoundingBox().getLatMax()); <line37> latLon.put( <line38> Grid.LON, <line39> this.getGridDataset().getBoundingBox().getLonMin() <line40> + ""_"" <line41> + this.getGridDataset().getBoundingBox().getLonMax()); <line42> List<String> dataVars = new ArrayList<String>(); <line43> for (VariableSimpleIF var : this.getDataVariables()) { <line44> dataVars.add(var.getShortName()); <line45> } <line46> this.stationData = <line47> new Grid( <line48> new String[] {cStationName.replaceAll(""[A-Za-z]+"", """")}, <line49> null, <line50> dataVars.toArray(new String[dataVars.size()]), <line51> latLon); <line52> this.stationData.setData(this.getGridDataset()); <line53> break; <line54> default: <line55> this.errorString = ""Unsupported feature type for DS response""; <line56> } <line57> } <line58> } <line59> "	"<line55>        logger.error(""Unsupported feature type in Describe Platform M1_0: ""+ this.getDatasetFeatureType().toString());"	task4	
public class A { <line0> @Override <line1> public void injectCacheResult(Object result) { <line2> this.result = (CnATreeElement) result; <line3> resultInjectedFromCache = true; <line4> if (log.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.debug(""Result in "" + this.getClass().getCanonicalName() + "" injected from cache"");"	task4	
public class A { <line0> @Override <line1> public boolean insertListTestCaseCountryProperties( <line2> List<TestCaseCountryProperties> testCaseCountryPropertiesList) { <line3> for (TestCaseCountryProperties tccp : testCaseCountryPropertiesList) { <line4> try { <line5> insertTestCaseCountryProperties(tccp); <line6> } catch (CerberusException ex) { <line7> return false; <line8> } <line9> } <line10> return true; <line11> } <line12> } <line13> 	<line7>        LOG.warn(ex.toString());	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> Thread.currentThread().setName(""Pipe "" + pipe.getPipesLocation() + "" Reader""); <line3> try { <line4> while (readerAlive) { <line5> PipeCommand command; <line6> try { <line7> command = pipe.readCommand(); <line8> } catch (UnknownCommandException uce) { <line9> continue; <line10> } <line11> synchronized (ControlPipePair.this) { <line12> PendingCommandStatus commandStatus = waitingCommands.remove(command); <line13> if (commandStatus == null) { <line14> ControlPipePair.this.unusedCommands.add(command); <line15> } else { <line16> commandStatus.completed(false, command); <line17> } <line18> } <line19> } <line20> } catch (ExternalExecutorException eee) { <line21> synchronized (ControlPipePair.this) { <line22> for (PendingCommandStatus commandStatus : waitingCommands.values()) { <line23> commandStatus.completed(true, null); <line24> } <line25> } <line26> } <line27> } <line28> } <line29> "	"<line9>          LOGGER.warn(""UNKNOWN COMMAND RECEIVED TRHOUGH PIPE ""+ pipe.getInboundPipe()+ "": ""+ uce.getMessage());"	task4	
"public class A { <line0> public WebContainerContext resolveHttpContext(Bundle bundle) { <line1> if (httpContext != null) { <line2> return httpContext; <line3> } <line4> BundleContext bundleContext = bundle != null ? bundle.getBundleContext() : null; <line5> if (bundleContext == null) { <line6> throw new IllegalArgumentException( <line7> ""Can't resolve WebContainerContext without Bundle argument""); <line8> } <line9> if (contextSupplier != null) { <line10> return contextSupplier.apply(bundleContext, getName()); <line11> } <line12> if (contextReference != null) { <line13> Object context = bundleContext.getService(contextReference); <line14> if (context instanceof WebContainerContext) { <line15> return (WebContainerContext) context; <line16> } <line17> if (context instanceof HttpContext) { <line18> return new WebContainerContextWrapper( <line19> bundleContext.getBundle(), (HttpContext) context, name); <line20> } <line21> if (context instanceof ServletContextHelper) { <line22> return new WebContainerContextWrapper( <line23> bundleContext.getBundle(), (ServletContextHelper) context, name); <line24> } <line25> throw new IllegalStateException( <line26> ""Unsupported Whiteboard service for HttpContext/ServletContextHelper"" + "" specified""); <line27> } <line28> throw new IllegalStateException(""No HttpContext/ServletContextHelper configured for "" + this); <line29> } <line30> } <line31> "	"<line13>      LOG.debug(""Dereferencing {} for {}"", contextReference, bundleContext);"	task4	
public class A { <line0> private void publishToRegistry( <line1> Set<Geometry> oldVisibleGeomSet, <line2> Set<Geometry> newVisibleGeomSet, <line3> Set<Geometry> newHiddenGeomSet) { <line4> long start; <line5> start = System.nanoTime(); <line6> getProvider() <line7> .getToolbox() <line8> .getGeometryRegistry() <line9> .receiveObjects(getProvider().getUpdateSource(), newVisibleGeomSet, oldVisibleGeomSet); <line10> if (LOGGER.isTraceEnabled()) { <line11> } <line12> } <line13> } <line14> 	"<line11>      LOGGER.trace(StringUtilities.formatTimingMessage(""Added/Remove Geometries to registry[""+ newVisibleGeomSet.size()+ ""/""+ newHiddenGeomSet.size()+ ""] in "",System.nanoTime() - start));"	task4	
public class A { <line0> static <T> boolean trySuccess(Promise<T> promise, T result) { <line1> final boolean notifiedRecords = promise.trySuccess(result); <line2> if (!notifiedRecords) { <line3> } <line4> return notifiedRecords; <line5> } <line6> } <line7> 	"<line3>      logger.trace(""Failed to notify success ({}) to a promise: {}"", result, promise);"	task4	
"public class A { <line0> private Set<String> keyspacesInCluster(AppContext context, Cluster cluster) <line1> throws ReaperException { <line2> List<String> keyspaces = ClusterFacade.create(context).getKeyspaces(cluster); <line3> if (keyspaces.isEmpty()) { <line4> String message = format(""No keyspace found in cluster %s"", cluster.getName()); <line5> throw new IllegalArgumentException(message); <line6> } <line7> return Sets.newHashSet(keyspaces); <line8> } <line9> } <line10> "	<line5>      LOG.debug(message);	task4	
public class A { <line0> @Override <line1> public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) { <line2> } <line3> } <line4> 	"<line2>    logger.info(""Filter get the value: "" + appResponse.getValue());"	task4	
"public class A { <line0> @Override <line1> public OQueryDataProvider<ODocument> getDataProviderForGenericSearch( <line2> OClass oClass, IModel<String> queryModel) { <line3> String searchSql = CustomAttribute.SEARCH_QUERY.getValue(oClass); <line4> String sql = null; <line5> if (!Strings.isEmpty(searchSql)) { <line6> String upper = searchSql.toUpperCase().trim(); <line7> if (upper.startsWith(""SELECT"")) sql = searchSql; <line8> else if (upper.startsWith(""WHERE"")) sql = ""select from "" + oClass.getName() + "" "" + searchSql; <line9> else { <line10> } <line11> } <line12> if (sql == null) sql = ""select from "" + oClass.getName() + "" where any() containstext :query""; <line13> return new OQueryDataProvider<ODocument>(sql).setParameter(""query"", queryModel); <line14> } <line15> } <line16> "	"<line10>        LOG.error(""Unrecognized search sql: "" + searchSql);"	task4	
public class A { <line0> public void init() { <line1> requestDataService = new RequestDataService(daoManager); <line2> cleaner.scheduleWithFixedDelay( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> for (RequestedHostImpl requestedHost : requestDataService.getAll()) { <line7> if (requestedHost.getStatus() == ResourceHostRegistrationStatus.REQUESTED <line8> && System.currentTimeMillis() <line9> - (requestedHost.getDateUpdated() == null <line10> ? 0L <line11> : requestedHost.getDateUpdated()) <line12> > TimeUnit.MINUTES.toMillis(60)) { <line13> requestDataService.remove(requestedHost.getId()); <line14> } <line15> } <line16> } <line17> }, <line18> 3, <line19> 30, <line20> TimeUnit.MINUTES); <line21> } <line22> } <line23> 	"<line13>                LOG.warn(""Deleting stale registration request {} : {}"",requestedHost.getHostname(),requestedHost.getAddress());"	task4	
public class A { <line0> public static void deleteAccountEntryUserRelByEmailAddress( <line1> long accountEntryId, String emailAddress) throws RemoteException { <line2> try { <line3> AccountEntryUserRelServiceUtil.deleteAccountEntryUserRelByEmailAddress( <line4> accountEntryId, emailAddress); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line6>      log.error(exception, exception);	task4	
public class A { <line0> private void readObject(int index, DataInput in, DeserializationContext context) <line1> throws IOException, ClassNotFoundException { <line2> Object value; <line3> this.objectTypeArray[index] = in.readByte(); <line4> if (logger.isTraceEnabled(LogMarker.VERSIONED_OBJECT_LIST_VERBOSE)) { <line5> } <line6> boolean isException = this.objectTypeArray[index] == EXCEPTION; <line7> if (isException) { <line8> byte[] exBytes = DataSerializer.readByteArray(in); <line9> value = CacheServerHelper.deserialize(exBytes); <line10> DataSerializer.readString(in); <line11> } else if (this.serializeValues) { <line12> value = DataSerializer.readByteArray(in); <line13> } else { <line14> value = context.getDeserializer().readObject(in); <line15> } <line16> this.objects.add(value); <line17> } <line18> } <line19> 	"<line5>      logger.trace(LogMarker.VERSIONED_OBJECT_LIST_VERBOSE,""reading object {} of type {}"",index,objectTypeArray[index]);"	task4	
public class A { <line0> @Override <line1> public boolean create(Personname personnameRecord) { <line2> return personnameRecord != null ? super.create(personnameRecord) : true; <line3> } <line4> } <line5> 	"<line2>    LOG.trace(""PersonnameDAO.create() - Begin"");"	task4	
public class A { <line0> public BBSConfigSetting save(BBSConfigSetting bbsConfigSetting) throws Exception { <line1> BBSConfigSetting _bbsConfigSetting = null; <line2> try (EntityManagerContainer emc = EntityManagerContainerFactory.instance().create()) { <line3> _bbsConfigSetting = emc.find(bbsConfigSetting.getId(), BBSConfigSetting.class); <line4> if (_bbsConfigSetting != null) { <line5> emc.beginTransaction(BBSConfigSetting.class); <line6> bbsConfigSetting.copyTo(_bbsConfigSetting, JpaObject.FieldsUnmodify); <line7> emc.check(_bbsConfigSetting, CheckPersistType.all); <line8> emc.commit(); <line9> } else { <line10> emc.beginTransaction(BBSConfigSetting.class); <line11> emc.persist(bbsConfigSetting, CheckPersistType.all); <line12> emc.commit(); <line13> } <line14> } catch (Exception e) { <line15> throw e; <line16> } <line17> return bbsConfigSetting; <line18> } <line19> } <line20> 	"<line15>      logger.warn(""BBSConfigSetting update/ got a error!"");"	task4	
"public class A { <line0> private static final void setupExplicitSubstitutionsMap() throws Exception { <line1> java.lang.ClassLoader classLoader = BestMatchingMapper.class.getClassLoader(); <line2> JAXBContext substitutionsContext = <line3> JAXBContext.newInstance(""org.docx4j.fonts.substitutions"", classLoader); <line4> Unmarshaller u2 = substitutionsContext.createUnmarshaller(); <line5> u2.setEventHandler(new org.docx4j.jaxb.JaxbValidationEventHandler()); <line6> java.io.InputStream is2 = null; <line7> is2 = <line8> org.docx4j.utils.ResourceUtils.getResource( <line9> ""org/docx4j/fonts/substitutions/FontSubstitutions.xml""); <line10> org.docx4j.fonts.substitutions.FontSubstitutions fs = <line11> (org.docx4j.fonts.substitutions.FontSubstitutions) u2.unmarshal(is2); <line12> List<FontSubstitutions.Replace> replaceList = fs.getReplace(); <line13> for (FontSubstitutions.Replace replacement : replaceList) { <line14> explicitSubstitutionsMap.put(replacement.getName(), replacement); <line15> } <line16> } <line17> } <line18> "	"<line6>    log.info(""unmarshalling fonts.substitutions"");"	task4	
public class A { <line0> public boolean isEmailDomainValidationEnabled(ThemeDisplay themeDisplay) { <line1> try { <line2> AccountEntryEmailDomainsConfiguration accountEntryEmailDomainsConfiguration = <line3> ConfigurationProviderUtil.getCompanyConfiguration( <line4> AccountEntryEmailDomainsConfiguration.class, themeDisplay.getCompanyId()); <line5> if (accountEntryEmailDomainsConfiguration.enableEmailDomainValidation()) { <line6> return true; <line7> } <line8> } catch (ConfigurationException configurationException) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> } <line12> return false; <line13> } <line14> } <line15> 	<line10>        log.debug(configurationException, configurationException);	task4	
"public class A { <line0> public static AccountsCommon createAccountInstance( <line1> String screenName, <line2> String userName, <line3> String passwd, <line4> String email, <line5> String tenantId, <line6> boolean useScreenName, <line7> boolean invalidTenant, <line8> boolean useUser, <line9> boolean usePassword) { <line10> AccountsCommon account = new AccountsCommon(); <line11> if (useScreenName) { <line12> account.setScreenName(screenName); <line13> } <line14> if (useUser) { <line15> account.setUserId(userName); <line16> } <line17> if (usePassword) { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> account.setPassword(passwd.getBytes()); <line21> } <line22> account.setPersonRefName(screenName); <line23> account.setEmail(email); <line24> account.setPhone(""1234567890""); <line25> List<AccountTenant> atList = new ArrayList<AccountTenant>(); <line26> AccountTenant at = new AccountTenant(); <line27> if (!invalidTenant) { <line28> if (tenantId != null) { <line29> at.setTenantId(tenantId); <line30> atList.add(at); <line31> account.setTenants(atList); <line32> } <line33> } else { <line34> at.setTenantId(UUID.randomUUID().toString()); <line35> atList.add(at); <line36> account.setTenants(atList); <line37> } <line38> return account; <line39> } <line40> } <line41> "	"<line19>        logger.debug(""user=""+ userName+ "" password=""+ passwd+ "" password length=""+ passwd.getBytes().length);"	task4	
public class A { <line0> private static void logPlatform(ExtensionOrigin o, MessageWriter log) { <line1> final ArtifactCoords bom = o.isPlatform() ? o.getBom() : null; <line2> if (bom != null) { <line3> } <line4> } <line5> } <line6> 	<line3>      log.info(bom.toString());	task4	
public class A { <line0> @Override <line1> public void closeNativeSession(String reason) { <line2> try { <line3> wsSession.close(new CloseStatus(CloseStatus.NORMAL.getCode(), reason)); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	"<line5>      log.warn(""Exception closing webSocket session"", e);"	task4	
public class A { <line0> private void addMetadataRecordImpl(final InputStream input, String name, long recordLength) <line1> throws DataStoreException { <line2> try { <line3> CloudBlobDirectory metaDir = getAzureContainer().getDirectoryReference(META_DIR_NAME); <line4> CloudBlockBlob blob = metaDir.getBlockBlobReference(name); <line5> addLastModified(blob); <line6> blob.upload(input, recordLength); <line7> } catch (StorageException e) { <line8> throw new DataStoreException(e); <line9> } catch (URISyntaxException | IOException e) { <line10> throw new DataStoreException(e); <line11> } <line12> } <line13> } <line14> 	"<line8>      LOG.info(""Error adding metadata record. metadataName={} length={}"", name, recordLength, e);"	task4	
"public class A { <line0> @Test(timeout = 60000) <line1> public void testCannotConnectWithSameContainerId() throws Exception { <line2> AmqpClient client = createAmqpClient(); <line3> List<Symbol> desiredCapabilities = new ArrayList<>(1); <line4> desiredCapabilities.add(AmqpSupport.SOLE_CONNECTION_CAPABILITY); <line5> assertNotNull(client); <line6> AmqpConnection connection1 = addConnection(client.createConnection()); <line7> AmqpConnection connection2 = addConnection(client.createConnection()); <line8> connection1.setDesiredCapabilities(desiredCapabilities); <line9> connection2.setDesiredCapabilities(desiredCapabilities); <line10> connection1.setContainerId(getTestName()); <line11> connection2.setContainerId(getTestName()); <line12> connection1.connect(); <line13> assertEquals(1, server.getConnectionCount()); <line14> connection2.setStateInspector( <line15> new AmqpValidator() { <line16> @Override <line17> public void inspectOpenedResource(Connection connection) { <line18> if (!connection.getRemoteProperties().containsKey(CONNECTION_OPEN_FAILED)) { <line19> markAsInvalid(""Broker did not set connection establishment failed property""); <line20> } <line21> } <line22>  <line23> @Override <line24> public void inspectClosedResource(Connection connection) { <line25> ErrorCondition remoteError = connection.getRemoteCondition(); <line26> if (remoteError == null || remoteError.getCondition() == null) { <line27> markAsInvalid(""Broker did not add error condition for duplicate client ID""); <line28> } else { <line29> if (!remoteError.getCondition().equals(AmqpError.INVALID_FIELD)) { <line30> markAsInvalid(""Broker did not set condition to "" + AmqpError.INVALID_FIELD); <line31> } <line32> if (!remoteError.getCondition().equals(AmqpError.INVALID_FIELD)) { <line33> markAsInvalid(""Broker did not set condition to "" + AmqpError.INVALID_FIELD); <line34> } <line35> } <line36> Map<?, ?> infoMap = remoteError.getInfo(); <line37> if (infoMap == null) { <line38> markAsInvalid(""Broker did not set an info map on condition""); <line39> } else if (!infoMap.containsKey(INVALID_FIELD)) { <line40> markAsInvalid(""Info map does not contain expected key""); <line41> } else { <line42> Object value = infoMap.get(INVALID_FIELD); <line43> if (!CONTAINER_ID.equals(value)) { <line44> markAsInvalid(""Info map does not contain expected value: "" + value); <line45> } <line46> } <line47> } <line48> }); <line49> try { <line50> connection2.connect(); <line51> fail(""Should not be able to connect with same container Id.""); <line52> } catch (Exception ex) { <line53> } <line54> connection2.getStateInspector().assertValid(); <line55> connection2.close(); <line56> Wait.assertEquals(1, server::getConnectionCount); <line57> connection1.close(); <line58> Wait.assertEquals(0, server::getConnectionCount); <line59> } <line60> } <line61> "	"<line53>      LOG.debug(""Second connection with same container Id failed as expected."");"	task4	
"public class A { <line0> private HttpClientConfigurer configureHttpProxy( <line1> Map<String, Object> parameters, HttpClientConfigurer configurer, boolean secure) <line2> throws Exception { <line3> String proxyAuthScheme = <line4> getParameter(parameters, ""proxyAuthScheme"", String.class, getProxyAuthScheme()); <line5> if (proxyAuthScheme == null) { <line6> proxyAuthScheme = secure ? ""https"" : ""http""; <line7> } <line8> String proxyAuthHost = <line9> getParameter(parameters, ""proxyAuthHost"", String.class, getProxyAuthHost()); <line10> Integer proxyAuthPort = <line11> getParameter(parameters, ""proxyAuthPort"", Integer.class, getProxyAuthPort()); <line12> if (proxyAuthHost == null) { <line13> proxyAuthHost = getParameter(parameters, ""proxyHost"", String.class); <line14> } <line15> if (proxyAuthPort == null) { <line16> proxyAuthPort = getParameter(parameters, ""proxyPort"", Integer.class); <line17> } <line18> if (proxyAuthHost != null && proxyAuthPort != null) { <line19> String proxyAuthUsername = <line20> getParameter(parameters, ""proxyAuthUsername"", String.class, getProxyAuthUsername()); <line21> String proxyAuthPassword = <line22> getParameter(parameters, ""proxyAuthPassword"", String.class, getProxyAuthPassword()); <line23> String proxyAuthDomain = <line24> getParameter(parameters, ""proxyAuthDomain"", String.class, getProxyAuthDomain()); <line25> String proxyAuthNtHost = <line26> getParameter(parameters, ""proxyAuthNtHost"", String.class, getProxyAuthNtHost()); <line27> if (proxyAuthUsername != null && proxyAuthPassword != null) { <line28> return CompositeHttpConfigurer.combineConfigurers( <line29> configurer, <line30> new ProxyHttpClientConfigurer( <line31> proxyAuthHost, <line32> proxyAuthPort, <line33> proxyAuthScheme, <line34> proxyAuthUsername, <line35> proxyAuthPassword, <line36> proxyAuthDomain, <line37> proxyAuthNtHost)); <line38> } else { <line39> return CompositeHttpConfigurer.combineConfigurers( <line40> configurer, <line41> new ProxyHttpClientConfigurer(proxyAuthHost, proxyAuthPort, proxyAuthScheme)); <line42> } <line43> } <line44> return configurer; <line45> } <line46> } <line47> "	"<line27>      LOG.debug(""Configuring HTTP client to use HTTP proxy {}:{}"", proxyAuthHost, proxyAuthPort);"	task4	
"public class A { <line0> public String createSession(String username, String baseDatabaseName) <line1> throws InvalidSessionException { <line2> String sessionId; <line3> Session oldSession; <line4> sessionId = UUID.randomUUID().toString(); <line5> Session newSession = new Session(sessionId, username, baseDatabaseName); <line6> oldSession = sessions.putIfAbsent(sessionId, newSession); <line7> if (oldSession != null) { <line8> throw new InvalidSessionException(""Session id is duplicated: "" + oldSession.getSessionId()); <line9> } <line10> return sessionId; <line11> } <line12> } <line13> "	"<line10>    LOG.info(""Session "" + sessionId + "" is created."");"	task4	
public class A { <line0> private void send(final ByteBuffer buffer) { <line1> buffer.flip(); <line2> try { <line3> while (buffer.hasRemaining()) { <line4> this.socketChannel.write(buffer); <line5> } <line6> } catch (final IOException e) { <line7> } <line8> buffer.clear(); <line9> } <line10> } <line11> 	"<line7>      LOGGER.error(""Error on sending registry entry."", e);"	task4	
public class A { <line0> public synchronized void deactivateSplitSource(MarkerSplitSource splitSource) { <line1> if (activeSplitSources.remove(splitSource)) { <line2> for (MarkerSplitSource source : activeSplitSources) { <line3> source.finishDependency(splitSource); <line4> } <line5> if (!markerSplitSent.contains(splitSource)) { <line6> checkMarkerSplitCompleteness(); <line7> } <line8> } <line9> } <line10> } <line11> 	"<line5>      LOG.debug(""Finished split source: %s (%s)"", splitSource.getCatalogName(), splitSource.toString());"	task4	
public class A { <line0> private Object convertDocFieldToAvroField( <line1> final Schema fieldSchema, <line2> final OrientDBMapping.DocumentFieldType storeType, <line3> final Schema.Field field, <line4> final String docf, <line5> final ODocument obj) <line6> throws GoraException { <line7> Object result = null; <line8> switch (fieldSchema.getType()) { <line9> case MAP: <line10> result = convertDocFieldToAvroMap(docf, fieldSchema, obj, field, storeType); <line11> break; <line12> case ARRAY: <line13> result = convertDocFieldToAvroList(docf, fieldSchema, obj, field, storeType); <line14> break; <line15> case RECORD: <line16> ODocument record = obj.field(docf); <line17> if (record == null) { <line18> result = null; <line19> break; <line20> } <line21> result = convertAvroBeanToOrientDoc(fieldSchema, record); <line22> break; <line23> case BOOLEAN: <line24> result = OType.convert(obj.field(docf), Boolean.class); <line25> break; <line26> case DOUBLE: <line27> result = OType.convert(obj.field(docf), Double.class); <line28> break; <line29> case FLOAT: <line30> result = OType.convert(obj.field(docf), Float.class); <line31> break; <line32> case INT: <line33> result = OType.convert(obj.field(docf), Integer.class); <line34> break; <line35> case LONG: <line36> result = OType.convert(obj.field(docf), Long.class); <line37> break; <line38> case STRING: <line39> result = convertDocFieldToAvroString(storeType, docf, obj); <line40> break; <line41> case ENUM: <line42> result = AvroUtils.getEnumValue(fieldSchema, obj.field(docf)); <line43> break; <line44> case BYTES: <line45> case FIXED: <line46> if (obj.field(docf) == null) { <line47> result = null; <line48> break; <line49> } <line50> result = ByteBuffer.wrap((byte[]) obj.field(docf)); <line51> break; <line52> case NULL: <line53> result = null; <line54> break; <line55> case UNION: <line56> result = convertDocFieldToAvroUnion(fieldSchema, storeType, field, docf, obj); <line57> break; <line58> default: <line59> break; <line60> } <line61> return result; <line62> } <line63> } <line64> 	"<line59>        LOG.warn(""Unable to read {}"", docf);"	task4	
public class A { <line0> public void takeOverAccessCount(ActionInfo actionInfo) { <line1> List<String> smallFiles = getSmallFileList(actionInfo); <line2> List<Long> oldFids = actionInfo.getOldFileIds(); <line3> try { <line4> for (int i = 0; i < smallFiles.size(); i++) { <line5> String filePath = smallFiles.get(i); <line6> long oldFid = oldFids.get(i); <line7> long newFid = dfsClient.getFileInfo(filePath).getFileId(); <line8> metaStore.updateAccessCountTableFid(oldFid, newFid); <line9> } <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	"<line11>      LOG.warn(""Failed to take over file access count for all tables, ""+ ""which may make the measurement for data temperature inaccurate!"",e.getMessage());"	task4	
public class A { <line0> public synchronized void deleteUser(User user) throws IOException { <line1> String username = user.getName(); <line2> for (Group group : groups.values()) { <line3> group.removeMember(user.getId()); <line4> } <line5> users.remove(username); <line6> persistChanges(); <line7> } <line8> } <line9> 	"<line2>    log.info(""Removing user {}"", user);"	task4	
"public class A { <line0> private String executeCommand(String command, File pathToWorkingDirectory) { <line1> ExecutorService executor = Executors.newSingleThreadExecutor(); <line2> final Process process; <line3> try { <line4> process = Runtime.getRuntime().exec(command, null, pathToWorkingDirectory); <line5> } catch (IOException e) { <line6> throw new RuntimeException(e); <line7> } <line8> final Future<?> submit = <line9> executor.submit( <line10> () -> { <line11> try { <line12> process.waitFor(); <line13> } catch (Exception e) { <line14> throw new RuntimeException(e); <line15> } <line16> }); <line17> try { <line18> submit.get(5, TimeUnit.SECONDS); <line19> if (process != null) { <line20> InputStreamReader inputStreamReader = new InputStreamReader(process.getInputStream()); <line21> int current; <line22> StringBuilder output = new StringBuilder(); <line23> while (true) { <line24> try { <line25> if ((current = inputStreamReader.read()) == -1) { <line26> break; <line27> } <line28> output.append((char) current); <line29> } catch (Exception e) { <line30> throw new RuntimeException(e); <line31> } <line32> } <line33> try (FileWriter writer = new FileWriter(pathToWorkingDirectory + DIFF_FILE_NAME, false)) { <line34> writer.write(output.toString()); <line35> } catch (Exception e) { <line36> throw new RuntimeException(e); <line37> } <line38> return output.toString(); <line39> } else { <line40> return """"; <line41> } <line42> } catch (Exception e) { <line43> throw new RuntimeException(e); <line44> } finally { <line45> if (process != null) { <line46> process.destroyForcibly(); <line47> } <line48> submit.cancel(true); <line49> executor.shutdownNow(); <line50> } <line51> } <line52> } <line53> "	"<line1>    LOGGER.info(String.format(""Executing: %s from %s"",command,pathToWorkingDirectory != null? pathToWorkingDirectory.getAbsolutePath(): System.getProperty(""user.dir"")));"	task4	
public class A { <line0> public Optional<MailAddress> asMailAddress() { <line1> return user.flatMap( <line2> user -> { <line3> try { <line4> return Optional.of(user.asMailAddress()); <line5> } catch (AddressException e) { <line6> return Optional.empty(); <line7> } <line8> }); <line9> } <line10> } <line11> 	"<line6>            LOGGER.warn(""Ignoring failing MappingSource to MailAddress conversion for user {}"", user, e);"	task4	
public class A { <line0> public void update(List<Task> criticalPath) { <line1> if (criticalPath.isEmpty()) { <line2> return; <line3> } <line4> progressAllByNumHours = rootTask.getOrderElement().getAdvancePercentageChildren(); <line5> progressByDuration = calculateByDuration(criticalPath); <line6> progressByNumHours = calculateByNumHours(criticalPath); <line7> Date now = new Date(); <line8> theoreticalProgressByNumHoursForAllTasks = <line9> rootTask.getTheoreticalAdvancePercentageUntilDate(now); <line10> theoreticalProgressByDurationForCriticalPath = <line11> calculateTheoreticalAdvanceByDurationForCriticalPath(criticalPath, now); <line12> theoreticalProgressByNumHoursForCriticalPath = <line13> calculateTheoreticalAdvanceByNumHoursForCriticalPath(criticalPath, now); <line14> } <line15> } <line16> 	"<line2>      LOG.warn(""it can't be updated because the critical path provided is empty"");"	task4	
"public class A { <line0> public static com.liferay.sharing.model.SharingEntry deleteSharingEntry( <line1> HttpPrincipal httpPrincipal, <line2> long sharingEntryId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> SharingEntryServiceUtil.class, <line9> ""deleteSharingEntry"", <line10> _deleteSharingEntryParameterTypes2); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, sharingEntryId, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.sharing.model.SharingEntry) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	<line23>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Secured(ServicesData.ROLE_GET_INGEST) <line1> @GetMapping(CommonConstants.PATH_ID) <line2> public LogbookOperationDto getOne(@PathVariable(""id"") final String id) { <line3> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line4> return ingestExternalService.getOne(id); <line5> } <line6> } <line7> "	"<line3>    LOGGER.debug(""get One Ingest id={}"", id);"	task4	
public class A { <line0> @Override <line1> public synchronized Collection<OpMessage<OutT>> processWatermark(long time) { <line2> assert outputList.isEmpty(); <line3> try { <line4> op.processWatermark(new Instant(time), emitter); <line5> } catch (Exception e) { <line6> throw UserCodeException.wrap(e); <line7> } <line8> final List<OpMessage<OutT>> results = new ArrayList<>(outputList); <line9> outputList.clear(); <line10> return results; <line11> } <line12> } <line13> 	"<line6>      LOG.error(""Op {} threw an exception during processing watermark"", this.getClass().getName(), e);"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (status.compareAndSet(Status.QUEUED, Status.RUNNING)) { <line4> queuedTask.remove(this); <line5> compactable.compact(csid, getJob(), readLimiter, writeLimiter, queuedTime); <line6> completionCallback.accept(compactable); <line7> } <line8> } catch (Exception e) { <line9> status.compareAndSet(Status.RUNNING, Status.FAILED); <line10> } finally { <line11> status.compareAndSet(Status.RUNNING, Status.COMPLETE); <line12> } <line13> } <line14> } <line15> 	"<line9>      log.warn(""Compaction failed for {} on {}"", compactable.getExtent(), getJob(), e);"	task4	
public class A { <line0> protected InputStream getConfigurationInputStream(String resource) throws HibernateException { <line1> return ConfigHelper.getResourceAsStream(resource); <line2> } <line3> } <line4> 	"<line1>    log.info(""Configuration resource: "" + resource);"	task4	
public class A { <line0> private Connection getConnection() throws SQLException { <line1> if (connection == null) { <line2> this.connection = <line3> DriverManager.getConnection(config.hiveJDBCUrl, config.hiveUsername, config.hivePassword); <line4> } <line5> return connection; <line6> } <line7> } <line8> 	"<line2>      LOG.info(""Getting Hive Connection to "" + config.hiveJDBCUrl);"	task4	
public class A { <line0> @Override <line1> public int indexOf(ISingleElectron electron) { <line2> return super.indexOf(electron); <line3> } <line4> } <line5> 	"<line2>    logger.debug(""Getting index of single electron: "", electron);"	task4	
public class A { <line0> private File writeInTmpFile(File tmp, InputStream fis) throws IOException { <line1> FileOutputStream fos = new FileOutputStream(tmp); <line2> try { <line3> StorageUtils.writeInOut(fis, fos, true); <line4> return tmp; <line5> } catch (Exception e) { <line6> return null; <line7> } finally { <line8> fos.close(); <line9> fis.close(); <line10> } <line11> } <line12> } <line13> 	"<line6>      LOGGER.error(""Error writing uploaded File in temp file"", e);"	task4	
"public class A { <line0> public static LdapContext getWiredContext( <line1> LdapServer ldapServer, String principalDn, String password) throws NamingException { <line2> Hashtable<String, String> env = new Hashtable<>(); <line3> env.put(Context.INITIAL_CONTEXT_FACTORY, CTX_FACTORY); <line4> env.put(Context.PROVIDER_URL, Network.ldapLoopbackUrl(ldapServer.getPort())); <line5> env.put(Context.SECURITY_PRINCIPAL, principalDn); <line6> env.put(Context.SECURITY_CREDENTIALS, password); <line7> env.put(Context.SECURITY_AUTHENTICATION, ""simple""); <line8> return new InitialLdapContext(env, null); <line9> } <line10> } <line11> "	"<line2>    LOG.debug(""Creating a wired context to local LDAP server on port {}"", ldapServer.getPort());"	task4	
"public class A { <line0> public static int getAssetListEntriesCount(HttpPrincipal httpPrincipal, long groupId) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> AssetListEntryServiceUtil.class, <line5> ""getAssetListEntriesCount"", <line6> _getAssetListEntriesCountParameterTypes18); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> return ((Integer) returnObj).intValue(); <line15> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	<line16>      log.error(systemException, systemException);	task4	
"public class A { <line0> @GET <line1> @Timed <line2> @Compress <line3> @Produces(APPLICATION_JSON_WITH_CHARSET) <line4> public String list( <line5> @Context GraphManager manager, <line6> @PathParam(""graph"") String graph, <line7> @QueryParam(""ids"") List<String> stringIds) { <line8> E.checkArgument( <line9> stringIds != null && !stringIds.isEmpty(), ""The ids parameter can't be null or empty""); <line10> Object[] ids = new Id[stringIds.size()]; <line11> for (int i = 0; i < ids.length; i++) { <line12> ids[i] = HugeEdge.getIdValue(stringIds.get(i), false); <line13> } <line14> HugeGraph g = graph(manager, graph); <line15> Iterator<Edge> edges = g.edges(ids); <line16> return manager.serializer(g).writeEdges(edges, false); <line17> } <line18> } <line19> "	"<line8>    LOG.debug(""Graph [{}] get edges by ids: {}"", graph, stringIds);"	task4	
public class A { <line0> private void stopTimer() { <line1> if (myTimer != null) { <line2> if (LOGGER.isDebugEnabled()) { <line3> } <line4> myTimer.cancel(); <line5> myTimer = null; <line6> } <line7> } <line8> } <line9> 	"<line3>        LOGGER.debug(""Stopping periodic Server Refreshes."");"	task4	
"public class A { <line0> @GET <line1> @Path(""/address/regions/{countryId}"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> public Response getRegions( <line4> @PathParam(""countryId"") long countryId, @Context ThemeDisplay themeDisplay) { <line5> List<RegionModel> regionModels = new ArrayList<>(); <line6> List<Region> regions = _regionService.getRegions(countryId, true); <line7> for (Region region : regions) { <line8> regionModels.add(new RegionModel(region.getRegionId(), region.getName())); <line9> } <line10> try { <line11> String json = _OBJECT_MAPPER.writeValueAsString(regionModels); <line12> return Response.ok(json, MediaType.APPLICATION_JSON).build(); <line13> } catch (JsonProcessingException jsonProcessingException) { <line14> } <line15> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line16> } <line17> } <line18> "	<line14>      log.error(jsonProcessingException, jsonProcessingException);	task4	
public class A { <line0> @Override <line1> public PdxType getType(int typeId) { <line2> Collection<Pool> pools = getAllPools(); <line3> ServerConnectivityException lastException = null; <line4> for (Pool pool : pools) { <line5> try { <line6> PdxType type = GetPDXTypeByIdOp.execute((ExecutablePool) pool, typeId); <line7> if (type != null) { <line8> return type; <line9> } <line10> } catch (ServerConnectivityException e) { <line11> lastException = e; <line12> } <line13> } <line14> if (lastException != null) { <line15> throw lastException; <line16> } else { <line17> throw returnCorrectExceptionForFailure(pools, typeId, lastException); <line18> } <line19> } <line20> } <line21> 	"<line11>        logger.debug(""Received an exception getting pdx type from pool {}, {}"", pool, e.getMessage(), e);"	task4	
public class A { <line0> private boolean isWritablePath(Path path, FileSystem fileSystem) throws InterruptedIOException { <line1> try { <line2> FileStatus fileStatus = fileSystem.getFileStatus(path); <line3> if (fileStatus.isDirectory()) { <line4> fileSystem.access(path, FsAction.WRITE); <line5> return true; <line6> } <line7> } catch (FileNotFoundException e) { <line8> Path parent = path.getParent(); <line9> if (parent != null) { <line10> return isWritablePath(parent, fileSystem); <line11> } <line12> } catch (InterruptedIOException ioe) { <line13> throw ioe; <line14> } catch (Exception e) { <line15> } <line16> return false; <line17> } <line18> } <line19> 	"<line15>      log.error(""Failure to validate path "" + path, e);"	task4	
public class A { <line0> @Override <line1> public void delete(final String id) throws SeriesServiceDatabaseException { <line2> if (synchronousIndexing) { <line3> try { <line4> synchronized (solrServer) { <line5> solrServer.deleteById(getCompositeKey(id, securityService.getOrganization().getId())); <line6> solrServer.commit(); <line7> } <line8> } catch (Exception e) { <line9> throw new SeriesServiceDatabaseException(e); <line10> } <line11> } else { <line12> indexingExecutor.submit( <line13> new Runnable() { <line14> @Override <line15> public void run() { <line16> try { <line17> synchronized (solrServer) { <line18> solrServer.deleteById(id); <line19> solrServer.commit(); <line20> } <line21> } catch (Exception e) { <line22> } <line23> } <line24> }); <line25> } <line26> } <line27> } <line28> 	"<line22>                logger.warn(""Could not delete from index series {}: {}"", id, e.getMessage());"	task4	
public class A { <line0> public void doRemoveFromMap(Word e, C c) { <line1> C b = val.remove(e); <line2> if (debug) { <line3> if (c == null) { <line4> return; <line5> } <line6> if (!c.equals(b)) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        logger.error(""map entry wrong "" + e + "" to "" + c + "" old "" + b);"	task4	
"public class A { <line0> @Test <line1> public void testHeaderAndTrailer() throws Exception { <line2> results.expectedMessageCount(1); <line3> results.message(0).body().isInstanceOf(List.class); <line4> results.message(0).header(""camelFlatpackCounter"").isEqualTo(6); <line5> results.assertIsSatisfied(); <line6> List<Map<String, String>> data = <line7> CastUtils.cast(results.getExchanges().get(0).getIn().getBody(List.class)); <line8> Map<String, String> header = data.get(0); <line9> assertEquals(""HBT"", header.get(""INDICATOR"")); <line10> assertEquals(""20080817"", header.get(""DATE"")); <line11> int counter = 0; <line12> for (Map<String, String> row : data.subList(1, 5)) { <line13> assertEquals(expectedFirstName[counter], row.get(""FIRSTNAME""), ""FIRSTNAME""); <line14> counter++; <line15> } <line16> Map<String, String> trailer = data.get(5); <line17> assertEquals(""FBT"", trailer.get(""INDICATOR"")); <line18> assertEquals(""SUCCESS"", trailer.get(""STATUS"")); <line19> } <line20> } <line21> "	"<line14>      LOG.info(""Result: "" + counter + "" = "" + row);"	task4	
public class A { <line0> public void setScannerFactory(ScannerFactory scannerFactory) { <line1> this.scannerFactory = scannerFactory; <line2> } <line3> } <line4> 	"<line1>    log.debug(""Setting scanner factory on ShardQueryLogic: ""+ System.identityHashCode(this)+ "".setScannerFactory(""+ System.identityHashCode(scannerFactory)+ ')');"	task4	
public class A { <line0> @Override <line1> public ActionBuilderModule<DocumentSimilarity, Relation> instantiate(Configuration config) { <line2> Float similarityThreshold = null; <line3> String thresholdStr = <line4> WorkflowRuntimeParameters.getParamValue(EXPORT_DOCUMENTSSIMILARITY_THRESHOLD, config); <line5> if (thresholdStr != null) { <line6> similarityThreshold = Float.valueOf(thresholdStr); <line7> } <line8> return new DocumentSimilarityActionBuilderModule( <line9> provideTrustLevelThreshold(config), similarityThreshold); <line10> } <line11> } <line12> 	"<line7>      log.info(""setting documents similarity exporter threshold to: "" + similarityThreshold);"	task4	
public class A { <line0> private static void overrideRowsCommitTimeAndSetMicroseconds( <line1> Long commitTimestamp, <line2> Long transactionSequenceNumber, <line3> Collection<AugmentedRow> extractedAugmentedRows) { <line4> for (AugmentedRow ar : extractedAugmentedRows) { <line5> ar.setCommitTimestamp(commitTimestamp); <line6> ar.setTransactionSequenceNumber(transactionSequenceNumber); <line7> Long microsOverride = commitTimestamp * 1000 + ar.getTransactionSequenceNumber(); <line8> ar.setRowMicrosecondTimestamp(microsOverride); <line9> } <line10> } <line11> } <line12> 	"<line8>      LOG.debug(String.format(""table : %s, UUID: %s, commit-ts: %d, seq-no: %d, micro-ts: %d"",ar.getTableName(),ar.getTransactionUUID(),commitTimestamp,transactionSequenceNumber,microsOverride));"	task4	
public class A { <line0> @Override <line1> public void run() { <line2> for (int i = 0; i < this.runs; i++) { <line3> } <line4> } <line5> } <line6> 	<line3>      this.logger.info(fmt, i, i * 7L, i / 16.0);	task4	
public class A { <line0> private void advanceCursorsIfNecessary(List<LedgerInfo> ledgersToDelete) { <line1> if (ledgersToDelete.isEmpty()) { <line2> return; <line3> } <line4> long firstNonDeletedLedger = <line5> ledgers.higherKey(ledgersToDelete.get(ledgersToDelete.size() - 1).getLedgerId()); <line6> PositionImpl highestPositionToDelete = new PositionImpl(firstNonDeletedLedger, -1); <line7> cursors.forEach( <line8> cursor -> { <line9> if (highestPositionToDelete.compareTo((PositionImpl) cursor.getMarkDeletedPosition()) > 0 <line10> && highestPositionToDelete.compareTo( <line11> (PositionImpl) cursor.getManagedLedger().getLastConfirmedEntry()) <line12> <= 0) { <line13> cursor.asyncMarkDelete( <line14> highestPositionToDelete, <line15> new MarkDeleteCallback() { <line16> @Override <line17> public void markDeleteComplete(Object ctx) {} <line18>  <line19> @Override <line20> public void markDeleteFailed(ManagedLedgerException exception, Object ctx) { <line21> } <line22> }, <line23> null); <line24> } <line25> }); <line26> } <line27> } <line28> 	"<line21>                    log.warn(""[{}] Failed to mark delete while trimming data ledgers: {}"",name,exception.getMessage());"	task4	
public class A { <line0> public void stop() { <line1> clientController.stopClient(false); <line2> if (executor == null) return; <line3> serverChannel.unbind(); <line4> serverSecureChannel.unbind(); <line5> serverChannel.close(); <line6> serverSecureChannel.close(); <line7> serverChannel.getCloseFuture().awaitUninterruptibly(); <line8> serverSecureChannel.getCloseFuture().awaitUninterruptibly(); <line9> executor.shutdownNow(); <line10> executor = null; <line11> serverBootstrap.shutdown(); <line12> serverSecureBootstrap.shutdown(); <line13> nioServerSocketChannelFactory.shutdown(); <line14> } <line15> } <line16> 	"<line14>    logger.info(""HTTP server stoped : "" + node);"	task4	
public class A { <line0> public void onReleased(String serviceName) { <line1> } <line2> } <line3> 	"<line1>    log.info(""released {}"", serviceName);"	task4	
"public class A { <line0> private void affinityCallRestartNode() throws Exception { <line1> final int ITERS = 10; <line2> for (int i = 0; i < ITERS; i++) { <line3> Integer key = primaryKey(grid(0).cache(CACHE_NAME)); <line4> AffinityTopologyVersion topVer = grid(0).context().discovery().topologyVersionEx(); <line5> IgniteInternalFuture<Object> fut = <line6> GridTestUtils.runAsync( <line7> new Callable<Object>() { <line8> @Override <line9> public Object call() throws Exception { <line10> U.sleep(500); <line11> stopGrid(0); <line12> return null; <line13> } <line14> }, <line15> ""stop-thread""); <line16> while (!fut.isDone()) <line17> grid(1).compute().affinityCall(CACHE_NAME, key, new CheckCallable(key, topVer)); <line18> fut.get(); <line19> if (i < ITERS - 1) startGrid(0); <line20> } <line21> stopAllGrids(); <line22> } <line23> } <line24> "	"<line3>      log.info(""Iteration: "" + i);"	task4	
public class A { <line0> public void setDistanceTolerance(int distanceTolerance) { <line1> if (distanceTolerance < MIN_DISTANCE_TOLERANCE_IN_METERS) { <line2> this.distanceTolerance = distanceTolerance; <line3> } else { <line4> this.distanceTolerance = distanceTolerance; <line5> } <line6> } <line7> } <line8> 	"<line3>      LOGGER.debug(""Admin supplied distance tolerance is too low. Defaulting to the minimum of {} meter"",MIN_DISTANCE_TOLERANCE_IN_METERS);"	task4	
"public class A { <line0> @Override <line1> public boolean foundDuplicateDocumentNominalLabel(DocumentNominalLabelDTO documentNominalLabel) { <line2> Map<String, Long> attMap = new HashMap<String, Long>(); <line3> try { <line4> attMap.put(""id.documentId"", documentNominalLabel.getIdDTO().getDocumentId()); <line5> attMap.put(""id.nominalLabelId"", documentNominalLabel.getIdDTO().getNominalLabelId()); <line6> } catch (PropertyNotSetException e) { <line7> } <line8> DocumentNominalLabel obj = <line9> remoteDocumentNominalLabelEJB.getByCriterionID(Restrictions.allEq(attMap)); <line10> if (obj != null) { <line11> return true; <line12> } else { <line13> return false; <line14> } <line15> } <line16> } <line17> "	"<line7>      logger.warn(""Warning! duplication nominal label"");"	task4	
public class A { <line0> @Override <line1> public void stateChanged(int oldState) { <line2> super.stateChanged(oldState); <line3> if (_initialised && isAudioAlive()) { <line4> al.alSourcef(_source[0], AL.AL_PITCH, this.getPitch()); <line5> al.alSourcef(_source[0], AL.AL_GAIN, this.getGain()); <line6> al.alSource3f( <line7> _source[0], <line8> AL.AL_POSITION, <line9> this.getCurrentPosition().x, <line10> this.getCurrentPosition().y, <line11> this.getCurrentPosition().z); <line12> al.alSource3f( <line13> _source[0], <line14> AL.AL_VELOCITY, <line15> this.getVelocity().x, <line16> this.getVelocity().y, <line17> this.getVelocity().z); <line18> al.alSourcei(_source[0], AL.AL_LOOPING, this.isLooped() ? AL.AL_TRUE : AL.AL_FALSE); <line19> if (JoalAudioFactory.checkALError()) { <line20> } <line21> } else { <line22> _initialised = init(); <line23> } <line24> } <line25> } <line26> 	"<line20>        log.warn(""Error updating JoalAudioSource ({})"", this.getSystemName());"	task4	
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Consumes(MediaType.APPLICATION_JSON) <line3> @Path(""termsPolicy"") <line4> public Object termsPolicy( <line5> @Context ServletContext context, @Context HttpServletResponse response) { <line6> LOGGER.entry(""begin termsPolicy()""); <line7> TermsPolicyResponse termsPolicyResponse = new TermsPolicyResponse(); <line8> try { <line9> termsPolicyResponse = appMetaDataOrchestration.termsPolicy(); <line10> if (!termsPolicyResponse.getMessage().equals(StudyMetaDataConstants.SUCCESS)) { <line11> StudyMetaDataUtil.getFailureResponse( <line12> ErrorCodes.STATUS_103, ErrorCodes.NO_DATA, StudyMetaDataConstants.FAILURE, response); <line13> return Response.status(Response.Status.NO_CONTENT) <line14> .entity(StudyMetaDataConstants.NO_RECORD) <line15> .build(); <line16> } <line17> } catch (Exception e) { <line18> StudyMetaDataUtil.getFailureResponse( <line19> ErrorCodes.STATUS_104, ErrorCodes.UNKNOWN, StudyMetaDataConstants.FAILURE, response); <line20> return Response.status(Response.Status.INTERNAL_SERVER_ERROR) <line21> .entity(StudyMetaDataConstants.FAILURE) <line22> .build(); <line23> } <line24> LOGGER.exit(""termsPolicy() :: Ends""); <line25> return termsPolicyResponse; <line26> } <line27> } <line28> "	"<line18>      LOGGER.error(""StudyMetaDataService - termsPolicy() :: ERROR"", e);"	task4	
public class A { <line0> private static void multithreadTransition( <line1> final Transition transition, int[] workflowRunAccessions) { <line2> ExecutorService pool = Executors.newFixedThreadPool(Math.min(10, workflowRunAccessions.length)); <line3> List<Future<?>> futures = new ArrayList<>(workflowRunAccessions.length); <line4> for (int workflowRunAccession : workflowRunAccessions) { <line5> final int workflowRunAccessionCopy = workflowRunAccession; <line6> futures.add( <line7> pool.submit( <line8> new Runnable() { <line9> @Override <line10> public void run() { <line11> if (transition == Transition.RETRY) { <line12> retryWorkflowRun(workflowRunAccessionCopy); <line13> } else if (transition == Transition.CANCEL) { <line14> cancelWorkflowRun(workflowRunAccessionCopy); <line15> } else if (transition == Transition.FAIL) { <line16> failWorkflowRun(workflowRunAccessionCopy); <line17> } <line18> } <line19> })); <line20> } <line21> for (Future<?> future : futures) { <line22> try { <line23> future.get(); <line24> } catch (InterruptedException | ExecutionException ex) { <line25> } <line26> } <line27> pool.shutdown(); <line28> } <line29> } <line30> 	<line25>        Log.fatal(ex);	task4	
"public class A { <line0> private boolean doRequestWhenFailureExpected() throws InterruptedException { <line1> sink.start(); <line2> Assert.assertTrue(LifecycleController.waitForOneOf(sink, LifecycleState.START_OR_ERROR, 5000)); <line3> Transaction transaction = channel.getTransaction(); <line4> transaction.begin(); <line5> Event event = EventBuilder.withBody(""test event 1"", Charsets.UTF_8); <line6> channel.put(event); <line7> transaction.commit(); <line8> transaction.close(); <line9> boolean failed; <line10> try { <line11> sink.process(); <line12> failed = false; <line13> } catch (EventDeliveryException ex) { <line14> failed = true; <line15> } <line16> sink.stop(); <line17> Assert.assertTrue(LifecycleController.waitForOneOf(sink, LifecycleState.STOP_OR_ERROR, 5000)); <line18> return failed; <line19> } <line20> } <line21> "	"<line14>      logger.info(""Correctly failed to send event"", ex);"	task4	
public class A { <line0> @Override <line1> public TextMessage createTextMessage() throws JMSException { <line2> Session session = getSessionInternal(); <line3> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line4> } <line5> return session.createTextMessage(); <line6> } <line7> } <line8> 	"<line4>      ActiveMQRALogger.LOGGER.trace(""createTextMessage"" + session);"	task4	
public class A { <line0> @Override <line1> public void onClose() { <line2> doWakeup(); <line3> } <line4> } <line5> 	"<line2>    log.info(""Watch closed"");"	task4	
public class A { <line0> private Response notifyInPacketAdded(Packet inpacket) throws Exception { <line1> InPacketAdded msg = new InPacketAdded(inpacket); <line2> return postEvent(InPacketAdded.TYPE, msg); <line3> } <line4> } <line5> 	"<line1>    log.debug("""");"	task4	
"public class A { <line0> protected void createSchemaChangeEventsForTables( <line1> ChangeEventSourceContext sourceContext, <line2> RelationalSnapshotContext snapshotContext, <line3> SnapshottingTask snapshottingTask) <line4> throws Exception { <line5> tryStartingSnapshot(snapshotContext); <line6> for (Iterator<TableId> iterator = snapshotContext.capturedTables.iterator(); <line7> iterator.hasNext(); ) { <line8> final TableId tableId = iterator.next(); <line9> if (!sourceContext.isRunning()) { <line10> throw new InterruptedException(""Interrupted while capturing schema of table "" + tableId); <line11> } <line12> Table table = snapshotContext.tables.forTable(tableId); <line13> if (schema != null) { <line14> snapshotContext.offset.event(tableId, getClock().currentTime()); <line15> if (!snapshottingTask.snapshotData() && !iterator.hasNext()) { <line16> lastSnapshotRecord(snapshotContext); <line17> } <line18> dispatcher.dispatchSchemaChangeEvent( <line19> table.id(), <line20> (receiver) -> { <line21> try { <line22> receiver.schemaChangeEvent(getCreateTableEvent(snapshotContext, table)); <line23> } catch (Exception e) { <line24> throw new DebeziumException(e); <line25> } <line26> }); <line27> } <line28> } <line29> } <line30> } <line31> "	"<line12>      LOGGER.debug(""Capturing structure of table {}"", tableId);"	task4	
public class A { <line0> @Override <line1> public Output<T> output(String text) throws MediaException { <line2> OutputImpl<T> output = null; <line3> getComponentstLock().lock(); <line4> try { <line5> VerbRef verbRef = _mohoRemote.getRayoClient().output(text, this.getId()); <line6> output = new OutputImpl<T>(verbRef, this, (T) this); <line7> } catch (XmppException e) { <line8> throw new MediaException(e); <line9> } finally { <line10> getComponentstLock().unlock(); <line11> } <line12> return output; <line13> } <line14> } <line15> 	"<line8>      LOG.error("""", e);"	task4	
"public class A { <line0> @Test <line1> public void testProcessFlagsOrder() throws Exception { <line2> setUpFlagDir(); <line3> createTestFiles(2, 5); <line4> final List<Collection<InputFile>> flagFileLists = new ArrayList<>(); <line5> FlagMaker instance = <line6> new TestWrappedFlagMaker(fmc) { <line7> @Override <line8> void writeFlagFile(FlagDataTypeConfig fc, Collection<InputFile> inFiles) <line9> throws IOException { <line10> flagFileLists.add(inFiles); <line11> } <line12> }; <line13> instance.processFlags(); <line14> assertEquals(2, flagFileLists.size()); <line15> long lastTime = 0; <line16> for (Collection<InputFile> flagFileList : flagFileLists) { <line17> long nextTime = 0; <line18> for (InputFile file : flagFileList) { <line19> assertTrue(""Found file out of expected order"", file.getTimestamp() > lastTime); <line20> nextTime = Math.max(nextTime, file.getTimestamp()); <line21> } <line22> lastTime = nextTime; <line23> } <line24> } <line25> } <line26> "	"<line2>    log.info(""-----  testProcessFlagsOrder  -----"");"	task4	
"public class A { <line0> public static void messageReceived(ChannelHandlerContext ctx, User user, StringMessage message) { <line1> String[] split = split2(message.body); <line2> if (split.length < 2) { <line3> throw new IllegalCommandException(""Wrong income message format.""); <line4> } <line5> int dashId = Integer.parseInt(split[0]); <line6> String deviceString = split[1]; <line7> if (deviceString == null || deviceString.isEmpty()) { <line8> throw new IllegalCommandException(""Income tag message is empty.""); <line9> } <line10> Profile profile = user.profile; <line11> DashBoard dash = profile.getDashByIdOrThrow(dashId); <line12> Tag newTag = JsonParser.parseTag(deviceString, message.id); <line13> if (newTag.isNotValid()) { <line14> throw new IllegalCommandException(""Income tag name is not valid.""); <line15> } <line16> for (Tag tag : dash.tags) { <line17> if (tag.id == newTag.id || tag.name.equals(newTag.name)) { <line18> throw new IllegalCommandException(""Tag with same id/name already exists.""); <line19> } <line20> } <line21> profile.addTag(dash, newTag); <line22> user.lastModifiedTs = System.currentTimeMillis(); <line23> if (ctx.channel().isWritable()) { <line24> ctx.writeAndFlush( <line25> makeUTF8StringMessage(CREATE_TAG, message.id, newTag.toString()), ctx.voidPromise()); <line26> } <line27> } <line28> } <line29> "	"<line13>    log.debug(""Creating new tag {}."", newTag);"	task4	
public class A { <line0> public static void writeClass(Class<?> c, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> if (c == null || c.isPrimitive()) { <line5> StaticSerialization.writePrimitiveClass(c, out); <line6> } else { <line7> out.writeByte(DSCODE.CLASS.toByte()); <line8> String cname = c.getName(); <line9> cname = InternalDataSerializer.processOutgoingClassName(cname, out); <line10> writeString(cname, out); <line11> } <line12> } <line13> } <line14> 	"<line3>      logger.trace(LogMarker.SERIALIZER_VERBOSE, ""Writing Class {}"", c);"	task4	
"public class A { <line0> private static void sendEmailIntent( <line1> FragmentActivity activityContext, String to, String subject, String email) { <line2> Intent email_intent = new Intent(Intent.ACTION_SEND); <line3> email_intent.putExtra(Intent.EXTRA_EMAIL, new String[] {to}); <line4> email_intent.putExtra(Intent.EXTRA_SUBJECT, subject); <line5> email_intent.putExtra(Intent.EXTRA_TEXT, email); <line6> email_intent.setType(""plain/text""); <line7> try { <line8> email_intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <line9> if (activityContext != null) { <line10> Intent targetIntent = <line11> Intent.createChooser( <line12> email_intent, activityContext.getString(R.string.email_chooser_header)); <line13> targetIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <line14> activityContext.startActivity(targetIntent); <line15> } <line16> } catch (android.content.ActivityNotFoundException ex) { <line17> Toast.makeText( <line18> activityContext, <line19> activityContext.getString(R.string.email_client_not_present), <line20> Toast.LENGTH_SHORT) <line21> .show(); <line22> } <line23> } <line24> } <line25> "	<line22>      logger.error(ex);	task4	
public class A { <line0> public static void validate(long listTypeId, long classNameId, String type) <line1> throws RemoteException { <line2> try { <line3> ListTypeServiceUtil.validate(listTypeId, classNameId, type); <line4> } catch (Exception exception) { <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line5>      log.error(exception, exception);	task4	
"public class A { <line0> public static Properties getBuildProperties(final Console console) { <line1> final Properties props = new Properties(); <line2> try (InputStream stream = <line3> VersionUtils.class.getClassLoader().getResourceAsStream(BUILD_PROPERTIES_FILE_NAME); ) { <line4> if (stream != null) { <line5> props.load(stream); <line6> } <line7> return props; <line8> } catch (final IOException e) { <line9> if (console != null) { <line10> console.println( <line11> ""Cannot read GeoWave build properties to show version information: "" + e.getMessage()); <line12> } <line13> } <line14> return props; <line15> } <line16> } <line17> "	"<line9>      LOGGER.warn(""Cannot read GeoWave build properties to show version information"", e);"	task4	
public class A { <line0> @Override <line1> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { <line2> boolean sendContent = ihf.checkFile(file, attrs); <line3> try { <line4> if (sendContent) { <line5> subHandlerList.add(ihf.getIndexHandler(file, attrs, solrClient, true)); <line6> } else { <line7> SolrInputDocument fileDoc = <line8> MCRSolrPathDocumentFactory.getInstance().getDocument(file, attrs); <line9> docs.add(fileDoc); <line10> } <line11> } catch (Exception ex) { <line12> } <line13> return super.visitFile(file, attrs); <line14> } <line15> } <line16> 	"<line12>      LOGGER.error(""Error creating transfer thread"", ex);"	task4	
"public class A { <line0> @Override <line1> public void onClick(AjaxRequestTarget target) { <line2> String cacheInformation = getCacheInformation(); <line3> MidPointApplication.get().getCacheRegistry().dumpContent(); <line4> getSession().success(getPageBase().getString(""InternalsCachePanel.result.dumped"")); <line5> target.add(getPageBase()); <line6> } <line7> } <line8> "	"<line3>    LOGGER.info(""Dumping the content of the caches.\nCurrent counters:\n{}\n"", cacheInformation);"	task4	
"public class A { <line0> public ActionForward save( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> if (!securityInfoManager.hasPrivilege( <line8> LoggedInInfo.getLoggedInInfoFromSession(request), ""_admin"", ""w"", null)) { <line9> throw new SecurityException(""missing required security object (_admin)""); <line10> } <line11> ActionMessages errors = form.validate(mapping, request); <line12> if (!errors.isEmpty()) { <line13> saveErrors(request, errors); <line14> return mapping.findForward(""edit""); <line15> } <line16> DynaActionForm issueAdminForm = (DynaActionForm) form; <line17> String newCode = ((Issue) issueAdminForm.get(""issueAdmin"")).getCode(); <line18> String newId = String.valueOf(((Issue) issueAdminForm.get(""issueAdmin"")).getId()); <line19> List<Issue> issueAdmins = mgr.getIssueAdmins(); <line20> for (Iterator<Issue> it = issueAdmins.iterator(); it.hasNext(); ) { <line21> Issue issueAdmin = it.next(); <line22> String existCode = issueAdmin.getCode(); <line23> String existId = String.valueOf(issueAdmin.getId()); <line24> if ((existCode.equals(newCode)) && !(existId.equals(newId))) { <line25> ActionMessages messages = new ActionMessages(); <line26> messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(""issueAdmin.code.exist"")); <line27> saveErrors(request, messages); <line28> return mapping.findForward(""edit""); <line29> } <line30> } <line31> mgr.saveIssueAdmin((Issue) issueAdminForm.get(""issueAdmin"")); <line32> ActionMessages messages = new ActionMessages(); <line33> messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(""issueAdmin.saved"")); <line34> saveMessages(request, messages); <line35> return list(mapping, form, request, response); <line36> } <line37> } <line38> "	"<line6>      log.debug(""entering 'save' method..."");"	task4	
"public class A { <line0> public void foo(@Simple(""${header.foo}"") String bar) { <line1> this.bar = bar; <line2> } <line3> } <line4> "	"<line2>    LOG.info(""foo() method called with: "" + bar);"	task4	
public class A { <line0> @NotAtomicAndNotIdempotent <line1> List<Node> makeCubeImmutableInReplicaSet(ReplicaSet rs, String cubeName) { <line2> List<Node> failedNodes = new ArrayList<>(); <line3> for (final Node node : rs.getNodes()) { <line4> try { <line5> getCoordinator().makeCubeImmutableForReceiver(node, cubeName); <line6> } catch (IOException ioe) { <line7> failedNodes.add(node); <line8> } <line9> } <line10> return failedNodes; <line11> } <line12> } <line13> 	"<line7>        logger.error(String.format(Locale.ROOT,""Convert %s to immutable for node %s failed."",cubeName,node.toNormalizeString()),ioe);"	task4	
public class A { <line0> @PostConstruct <line1> public void start() { <line2> _executor.scheduleAtFixedRate(new ServiceUpdateImpl(), 0, _updateFrequency, TimeUnit.SECONDS); <line3> } <line4> } <line5> 	"<line2>    log.debug(""start"");"	task4	
public class A { <line0> private void fetchSTCCList() { <line1> try { <line2> } catch (Exception e) { <line3> } <line4> } <line5> } <line6> 	<line3>      LOG.error(e.getMessage());	task4	
public class A { <line0> private void closeEventExecutorGroup() { <line1> if (eventExecutorGroup != null) { <line2> try { <line3> eventExecutorGroup.shutdownGracefully().sync(); <line4> } catch (InterruptedException e) { <line5> } <line6> eventExecutorGroup = null; <line7> } <line8> } <line9> } <line10> 	"<line5>        logger.error(""Error stopping socket "" + socketDescription, e);"	task4	
public class A { <line0> private void updateTask(String task) { <line1> listenerForwarder.setTask(task); <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>      LOGGER.info(task);	task4	
public class A { <line0> @Override <line1> public void onDisconnected() { <line2> if (mode.contains(MODE.RESEND_SUBSCRIBE_ON_RECONNECTED)) { <line3> pubSubDriverSuspended = true; <line4> } else { <line5> } <line6> } <line7> } <line8> 	"<line2>    log.warn(""disconnected"");"	task4	
public class A { <line0> @Override <line1> public int read(final String context) throws IOException { <line2> int b = read(); <line3> return b; <line4> } <line5> } <line6> 	"<line3>    logger.trace(""Read {}  byte, val is {}"", context, ByteUtils.formatByte(b));"	task4	
"public class A { <line0> @Override <line1> public void handleWorkflowTransition( <line2> ServiceContext ctx, DocumentWrapper<DocumentModel> wrapDoc, TransitionDef transitionDef) <line3> throws Exception { <line4> if (this.getShouldUpdateRevNumber() == true) { <line5> updateRevNumbers(wrapDoc); <line6> } <line7> DocumentModel docModel = wrapDoc.getWrappedObject(); <line8> if (transitionDef.getName().equalsIgnoreCase(WorkflowClient.WORKFLOWTRANSITION_DELETE)) { <line9> AuthorityRefDocList refsToAllObjects = <line10> getReferencingObjectsForStateTransitions(ctx, docModel, RefObjsSearchType.ALL); <line11> AuthorityRefDocList refsToSoftDeletedObjects = <line12> getReferencingObjectsForStateTransitions(ctx, docModel, RefObjsSearchType.DELETED_ONLY); <line13> if (refsToAllObjects.getTotalItems() > 0) { <line14> if (refsToAllObjects.getTotalItems() > refsToSoftDeletedObjects.getTotalItems()) { <line15> if (logger.isWarnEnabled() == true) { <line16> logReferencingObjects(docModel, refsToAllObjects); <line17> } <line18> throw new DocumentReferenceException( <line19> String.format( <line20> ""Cannot delete authority item '%s' because it still has records in the system"" <line21> + "" that are referencing it.  See the service layer log file for details."", <line22> docModel.getName())); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> "	"<line15>          logger.error(String.format(""Cannot delete authority item CSID='%s' because it still has records in the""+ "" system that are referencing it."",docModel.getName()));"	task4	
public class A { <line0> @Override <line1> public void iterationDone(Model model, int iteration, int epoch) { <line2> if (iteration % frequency == 0) { <line3> double score = model.score(); <line4> listIteration.add(iteration); <line5> listScore.add(score); <line6> if (logScore) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        log.info(""Score at iteration {} is {}"", iteration, score);"	task4	
"public class A { <line0> @ApiOperation( <line1> value = ""Reopens a closed case instance for a specified case definition."", <line2> response = Void.class, <line3> code = 201) <line4> @ApiResponses( <line5> value = { <line6> @ApiResponse(code = 500, message = ""Unexpected error""), <line7> @ApiResponse(code = 404, message = ""Case instance not found"") <line8> }) <line9> @PUT <line10> @Path(REOPEN_CASE_PUT_URI) <line11> @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line12> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line13> public Response reopenCase( <line14> @javax.ws.rs.core.Context HttpHeaders headers, <line15> @ApiParam( <line16> value = ""container id where the case definition resides"", <line17> required = true, <line18> example = ""evaluation_1.0.0-SNAPSHOT"") <line19> @PathParam(CONTAINER_ID) <line20> String containerId, <line21> @ApiParam( <line22> value = ""case definition id that new instance should be created from"", <line23> required = true, <line24> example = ""evaluation"") <line25> @PathParam(CASE_DEF_ID) <line26> String caseDefId, <line27> @ApiParam(value = ""identifier of the case instance"", required = true) @PathParam(CASE_ID) <line28> String caseId, <line29> @ApiParam( <line30> value = ""optional CaseFile with variables and/or case role assignments"", <line31> required = false, <line32> examples = <line33> @Example( <line34> value = { <line35> @ExampleProperty(mediaType = JSON, value = CASE_FILE_JSON), <line36> @ExampleProperty(mediaType = XML, value = CASE_FILE_XML) <line37> })) <line38> String payload) { <line39> return invokeCaseOperation( <line40> headers, <line41> containerId, <line42> null, <line43> (Variant v, String type, Header... customHeaders) -> { <line44> caseManagementServiceBase.reopenCase(caseId, containerId, caseDefId, payload, type); <line45> return createResponse("""", v, Response.Status.CREATED, customHeaders); <line46> }); <line47> } <line48> } <line49> "	"<line45>          logger.debug(""Returning CREATED response for reopen case {}"", caseId);"	task4	
public class A { <line0> public static com.liferay.document.library.kernel.model.DLFileEntrySoap[] getFileEntries( <line1> long groupId, <line2> long folderId, <line3> String[] mimeTypes, <line4> int status, <line5> int start, <line6> int end, <line7> com.liferay.portal.kernel.util.OrderByComparator< <line8> com.liferay.document.library.kernel.model.DLFileEntry> <line9> orderByComparator) <line10> throws RemoteException { <line11> try { <line12> java.util.List<com.liferay.document.library.kernel.model.DLFileEntry> returnValue = <line13> DLFileEntryServiceUtil.getFileEntries( <line14> groupId, folderId, mimeTypes, status, start, end, orderByComparator); <line15> return com.liferay.document.library.kernel.model.DLFileEntrySoap.toSoapModels(returnValue); <line16> } catch (Exception exception) { <line17> throw new RemoteException(exception.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line17>      log.error(exception, exception);	task4	
public class A { <line0> @Override <line1> public void persist(TripUpdateModel tripUpdate) { <line2> boolean accepted = _tripUpdates.offer(tripUpdate); <line3> if (!accepted) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.error(""Local trip update buffer full!  Clearing!  Dropping "" + tripUpdate.getId() + "" record"");"	task4	
"public class A { <line0> @Override <line1> public void addObjectField(String fieldName, Object member) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> if (fieldName == null) { <line5> throw new IllegalStateException(""addObjectField:Object should have fieldname""); <line6> } <line7> fieldList.add(new JSONFieldHolder(fieldName, member, FieldType.OBJECT)); <line8> } <line9> } <line10> "	"<line3>      logger.trace(""addObjectField fieldName: {}"", fieldName);"	task4	
public class A { <line0> @Test <line1> public void testCacheAndNodeStop() throws Exception { <line2> final Ignite ignite = startGrid(0); <line3> for (int i = 0; i < 3; i++) { <line4> startGrid(1); <line5> final CacheConfiguration ccfg = new CacheConfiguration(DEFAULT_CACHE_NAME); <line6> ignite.createCache(ccfg); <line7> final CyclicBarrier barrier = new CyclicBarrier(2); <line8> IgniteInternalFuture<?> fut1 = <line9> GridTestUtils.runAsync( <line10> new Callable<Object>() { <line11> @Override <line12> public Object call() throws Exception { <line13> barrier.await(); <line14> ignite.destroyCache(DEFAULT_CACHE_NAME); <line15> return null; <line16> } <line17> }); <line18> IgniteInternalFuture<?> fut2 = <line19> GridTestUtils.runAsync( <line20> new Callable<Object>() { <line21> @Override <line22> public Object call() throws Exception { <line23> barrier.await(); <line24> stopGrid(1); <line25> return null; <line26> } <line27> }); <line28> fut1.get(); <line29> fut2.get(); <line30> } <line31> } <line32> } <line33> 	"<line4>      log.info(""Iteration: "" + i);"	task4	
"public class A { <line0> public void startHandshake(ClientHandshakeBuilder handshakedata) <line1> throws InvalidHandshakeException { <line2> this.handshakerequest = draft.postProcessHandshakeRequestAsClient(handshakedata); <line3> resourceDescriptor = handshakedata.getResourceDescriptor(); <line4> assert (resourceDescriptor != null); <line5> try { <line6> wsl.onWebsocketHandshakeSentAsClient(this, this.handshakerequest); <line7> } catch (InvalidDataException e) { <line8> throw new InvalidHandshakeException(""Handshake data rejected by client.""); <line9> } catch (RuntimeException e) { <line10> wsl.onWebsocketError(this, e); <line11> throw new InvalidHandshakeException(""rejected because of "" + e); <line12> } <line13> write(draft.createHandshake(this.handshakerequest)); <line14> } <line15> } <line16> "	"<line10>      log.error(""Exception in startHandshake"", e);"	task4	
"public class A { <line0> @Override <line1> public Object apply(final ActionContext ctx, final Object caller, final Object[] sources) <line2> throws FrameworkException { <line3> try { <line4> assertArrayHasLengthAndAllElementsNotNull(sources, 1); <line5> final HttpSession session = ctx.getSecurityContext().getSession(); <line6> if (session != null) { <line7> session.removeAttribute( <line8> ActionContext.SESSION_ATTRIBUTE_PREFIX.concat(sources[0].toString())); <line9> } else { <line10> } <line11> return """"; <line12> } catch (ArgumentNullException pe) { <line13> return null; <line14> } catch (ArgumentCountException pe) { <line15> logParameterError(caller, sources, pe.getMessage(), ctx.isJavaScriptContext()); <line16> return usage(ctx.isJavaScriptContext()); <line17> } <line18> } <line19> } <line20> "	"<line10>        logger.warn(""{}: No session available to remvoe session attribute! (this can happen in""+ "" onStructrLogin/onStructrLogout)"",getReplacement());"	task4	
"public class A { <line0> @Override <line1> public void initialize() { <line2> handlerConfig = getConfig().as(AccountHandlerConfig.class); <line3> synchronized (synchronizeConnection) { <line4> Connection connection = this.connection; <line5> if (connection == null) { <line6> this.connection = new Connection(null, gson); <line7> } <line8> } <line9> if (accountServlet == null) { <line10> try { <line11> accountServlet = <line12> new AccountServlet(httpService, this.getThing().getUID().getId(), this, gson); <line13> } catch (IllegalStateException e) { <line14> } <line15> } <line16> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, ""Wait for login""); <line17> checkLoginJob = scheduler.scheduleWithFixedDelay(this::checkLogin, 0, 60, TimeUnit.SECONDS); <line18> checkDataJob = scheduler.scheduleWithFixedDelay(this::checkData, 4, 60, TimeUnit.SECONDS); <line19> int pollingIntervalAlexa = handlerConfig.pollingIntervalSmartHomeAlexa; <line20> if (pollingIntervalAlexa < 10) { <line21> pollingIntervalAlexa = 10; <line22> } <line23> int pollingIntervalSkills = handlerConfig.pollingIntervalSmartSkills; <line24> if (pollingIntervalSkills < 60) { <line25> pollingIntervalSkills = 60; <line26> } <line27> smartHomeDeviceStateGroupUpdateCalculator = <line28> new SmartHomeDeviceStateGroupUpdateCalculator(pollingIntervalAlexa, pollingIntervalSkills); <line29> updateSmartHomeStateJob = <line30> scheduler.scheduleWithFixedDelay( <line31> () -> updateSmartHomeState(null), 20, 10, TimeUnit.SECONDS); <line32> } <line33> } <line34> "	"<line14>        logger.warn(""Failed to create account servlet"", e);"	task4	
public class A { <line0> public void submitSchemaRefresh( <line1> final SchemaElement targetType, final String targetKeyspace, final String targetName) { <line2> executor.submit( <line3> new ExceptionCatchingRunnable() { <line4> @Override <line5> public void runMayThrow() throws InterruptedException, ExecutionException { <line6> controlConnection.refreshSchema(targetType, targetKeyspace, targetName); <line7> } <line8> }); <line9> } <line10> } <line11> 	"<line2>    logger.trace(""Submitting schema refresh"");"	task4	
public class A { <line0> private void buildAndSignEnvelope( <line1> final DeviceRequest deviceRequest, <line2> final Oslp.Message payloadMessage, <line3> final Serializable extraData) { <line4> final String deviceIdentification = deviceRequest.getDeviceIdentification(); <line5> final String organisationIdentification = deviceRequest.getOrganisationIdentification(); <line6> final String correlationUid = deviceRequest.getCorrelationUid(); <line7> final String ipAddress = deviceRequest.getIpAddress(); <line8> final String domain = deviceRequest.getDomain(); <line9> final String domainVersion = deviceRequest.getDomainVersion(); <line10> final String messageType = deviceRequest.getMessageType(); <line11> final int messagePriority = deviceRequest.getMessagePriority(); <line12> final int retryCount = deviceRequest.getRetryCount(); <line13> final boolean isScheduled = deviceRequest.isScheduled(); <line14> final OslpDevice oslpDevice = <line15> this.oslpDeviceSettingsService.getDeviceByDeviceIdentification(deviceIdentification); <line16> if (oslpDevice == null) { <line17> return; <line18> } <line19> final byte[] deviceId = Base64.decodeBase64(oslpDevice.getDeviceUid()); <line20> final byte[] sequenceNumber = <line21> SequenceNumberUtils.convertIntegerToByteArray(oslpDevice.getSequenceNumber()); <line22> this.oslpSigningService.buildAndSignEnvelope( <line23> organisationIdentification, <line24> deviceIdentification, <line25> correlationUid, <line26> deviceId, <line27> sequenceNumber, <line28> ipAddress, <line29> domain, <line30> domainVersion, <line31> messageType, <line32> messagePriority, <line33> retryCount, <line34> isScheduled, <line35> payloadMessage, <line36> extraData); <line37> } <line38> } <line39> 	"<line17>      LOGGER.error(""Unable to find OSLP device: {}"", deviceIdentification);"	task4	
public class A { <line0> public void addSession(Session session) { <line1> this.availableSessionsById.put(session.getId(), session); <line2> final KieServerMessageHandler messageHandler = new KieServerMessageHandler(session); <line3> this.handlersPerSession.put(session.getId(), messageHandler); <line4> session.addMessageHandler(messageHandler); <line5> } <line6> } <line7> 	"<line5>    logger.debug(""Session '{}' added to Web Socket manager"", session.getId());"	task4	
public class A { <line0> @Override <line1> public State newState(String namespace, Map<String, Object> topoConf, TopologyContext context) { <line2> try { <line3> return getRedisKeyValueState(namespace, topoConf, context, getStateConfig(topoConf)); <line4> } catch (Exception ex) { <line5> throw new RuntimeException(ex); <line6> } <line7> } <line8> } <line9> 	"<line5>      LOG.error(""Error loading config from storm conf {}"", topoConf);"	task4	
public class A { <line0> @Override <line1> public boolean start() throws PlatformInitializationException { <line2> PentahoSystem.setSystemSettingsService(new PathBasedSystemSettings()); <line3> BasicConfigurator.configure(); <line4> boolean ret = super.start(); <line5> try { <line6> Object o = PentahoSystem.get(ISolutionEngine.class); <line7> if (o != null && o instanceof ILogger) { <line8> ((ILogger) o).setLoggingLevel(ILogger.DEBUG); <line9> } <line10> } catch (Throwable e) { <line11> } <line12> return ret; <line13> } <line14> } <line15> 	"<line11>      logger.error(""Failed to set DEBUG log level due to ISolutionEngine not being available in""+ "" MicroPlatform"");"	task4	
public class A { <line0> @After <line1> public void stopCounter() { <line2> final long runtime = System.currentTimeMillis() - testStartTime; <line3> if (runtime > 2000) { <line4> } <line5> } <line6> } <line7> 	"<line4>      log.warn(this.getClass().getName() + ""."" + methodName + ""() test took "" + runtime + ""ms"");"	task4	
"public class A { <line0> public List<UserDefinedCalendarConfiguration> getCalendarConfigurations(String subscribeId) { <line1> try { <line2> @SuppressWarnings(""unchecked"") <line3> List<UserDefinedCalendarConfiguration> configurations = <line4> (List<UserDefinedCalendarConfiguration>) <line5> getHibernateTemplate() <line6> .find( <line7> ""from CalendarConfiguration config where "" <line8> + ""subscribeId = ? and displayed = true "" <line9> + ""order by calendarDefinition.name"", <line10> subscribeId); <line11> return configurations; <line12> } catch (HibernateException ex) { <line13> throw convertHibernateAccessException(ex); <line14> } <line15> } <line16> } <line17> "	"<line2>      log.debug(""fetching calendar configurations for "" + subscribeId);"	task4	
"public class A { <line0> public List<String> terms( <line1> final String table, <line2> final String columnFamily, <line3> final String columnName, <line4> final String startWith, <line5> final short size) <line6> throws Exception { <line7> Map<String, BlurIndex> blurIndexes; <line8> try { <line9> blurIndexes = _indexServer.getIndexes(table); <line10> } catch (IOException e) { <line11> throw new BException(e.getMessage(), e); <line12> } <line13> TableContext tableContext = getTableContext(table); <line14> FieldManager fieldManager = tableContext.getFieldManager(); <line15> final FieldTypeDefinition typeDefinition = <line16> fieldManager.getFieldTypeDefinition(columnFamily + ""."" + columnName); <line17> return ForkJoin.execute( <line18> _executor, <line19> blurIndexes.entrySet(), <line20> new ParallelCall<Entry<String, BlurIndex>, List<String>>() { <line21> @Override <line22> public List<String> call(Entry<String, BlurIndex> input) throws Exception { <line23> BlurIndex index = input.getValue(); <line24> IndexSearcherCloseable searcher = index.getIndexSearcher(); <line25> try { <line26> return terms( <line27> searcher.getIndexReader(), <line28> typeDefinition, <line29> columnFamily, <line30> columnName, <line31> startWith, <line32> size); <line33> } finally { <line34> searcher.close(); <line35> } <line36> } <line37> }) <line38> .merge( <line39> new Merger<List<String>>() { <line40> @Override <line41> public List<String> merge(BlurExecutorCompletionService<List<String>> service) <line42> throws BlurException { <line43> SortedSet<String> terms = new TreeSet<String>(); <line44> while (service.getRemainingCount() > 0) { <line45> Future<List<String>> future = <line46> service.poll( <line47> _defaultParallelCallTimeout, <line48> TimeUnit.MILLISECONDS, <line49> true, <line50> table, <line51> columnFamily, <line52> columnName, <line53> startWith, <line54> size); <line55> terms.addAll( <line56> service.getResultThrowException( <line57> future, table, columnFamily, columnName, startWith, size)); <line58> } <line59> return new ArrayList<String>(terms).subList(0, Math.min(size, terms.size())); <line60> } <line61> }); <line62> } <line63> } <line64> "	"<line11>      LOG.error(""Unknown error while trying to fetch index readers."", e);"	task4	
public class A { <line0> public CreateProjectPage enterDescription(String projectDescription) { <line1> enterText(readyElement(descriptionField), projectDescription); <line2> return new CreateProjectPage(getDriver()); <line3> } <line4> } <line5> 	"<line1>    log.info(""Enter project description {}"", projectDescription);"	task4	
"public class A { <line0> @BeforeClass <line1> public static void setUpClass() { <line2> if (Info.PATHS.PATH_DATA_FOLDER.exists()) { <line3> hasDataDir = true; <line4> } else { <line5> try { <line6> File dataExample = <line7> new File(Info.PATHS.PATH_WORKDIR.getParentFile().getParentFile() + ""/data-example""); <line8> copy(dataExample.getAbsolutePath(), Info.PATHS.PATH_DATA_FOLDER.getAbsolutePath()); <line9> canPerformTest = true; <line10> } catch (IOException e) { <line11> canPerformTest = false; <line12> } <line13> } <line14> } <line15> } <line16> "	<line8>        LOG.info(dataExample.getAbsolutePath());	task4	
"public class A { <line0> @Override <line1> public int doEndTag() throws JspException { <line2> try { <line3> String value = this.extractValue(); <line4> if (null == value) { <line5> return super.doEndTag(); <line6> } <line7> IParameterParentTag parentTag = <line8> (IParameterParentTag) findAncestorWithClass(this, IParameterParentTag.class); <line9> parentTag.addParameter(this.getName(), value); <line10> } catch (Throwable t) { <line11> throw new JspException(""Error closing tag "", t); <line12> } <line13> return super.doEndTag(); <line14> } <line15> } <line16> "	"<line11>      logger.error(""Error closing tag"", t);"	task4	
public class A { <line0> @Override <line1> public void validate(Context context, DOReader reader) throws ServerException { <line2> if (m_enabled) { <line3> for (DOObjectValidator validator : m_validators.values()) { <line4> try { <line5> validator.validate(context, reader); <line6> } catch (ObjectValidityException e) { <line7> throw e; <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	"<line7>          logger.error(""Object validation error "" + reader.GetObjectPID() + "": "" + e.getMessage());"	task4	
public class A { <line0> private DlmsConnector connectorFor(final SecurityLevel securityLevel) throws FunctionalException { <line1> switch (securityLevel) { <line2> case HLS5: <line3> return this.hls5Connector; <line4> case LLS1: <line5> return this.lls1Connector; <line6> case LLS0: <line7> return this.lls0Connector; <line8> default: <line9> throw new FunctionalException( <line10> FunctionalExceptionType.UNSUPPORTED_COMMUNICATION_SETTING, ComponentType.PROTOCOL_DLMS); <line11> } <line12> } <line13> } <line14> 	"<line9>        LOGGER.error(""Only HLS 5, LLS 1 and public (LLS 0) connections are currently supported"");"	task4	
public class A { <line0> public boolean exists(String key) { <line1> Path dir = getKeyDir(key); <line2> boolean res = false; <line3> try { <line4> fileSystem = dir.getFileSystem(hadoopConf); <line5> res = fileSystem.exists(dir); <line6> } catch (IOException e) { <line7> } <line8> return res; <line9> } <line10> } <line11> 	"<line7>      LOG.warn(""Exception checking for exists on: "" + key);"	task4	
public class A { <line0> private synchronized void onInconsistency(AppendEntriesReplyProto reply) { <line1> AppendEntriesRequestProto request = pendingRequests.remove(reply.getServerReply().getCallId()); <line2> if (request == null) { <line3> return; <line4> } <line5> Preconditions.assertTrue(request.hasPreviousLog()); <line6> if (request.getPreviousLog().getIndex() >= reply.getNextIndex()) { <line7> clearPendingRequests(reply.getNextIndex()); <line8> } <line9> } <line10> } <line11> 	"<line3>      LOG.warn(""{}: Ignoring {}"", server.getId(), reply);"	task4	
public class A { <line0> public void debugFreeList() { <line1> } <line2> } <line3> 	"<line1>    LOG.debug(""{}: {}"", FileUtils.fileName(getFile()), freeList.toString());"	task4	
"public class A { <line0> @Override <line1> public void prepare(ResponseBuilder rb) throws IOException { <line2> SolrParams params = rb.req.getParams(); <line3> if (!params.getBool(COMPONENT_NAME, false)) { <line4> return; <line5> } <line6> boolean buildAll = params.getBool(SUGGEST_BUILD_ALL, false); <line7> boolean reloadAll = params.getBool(SUGGEST_RELOAD_ALL, false); <line8> final Collection<SolrSuggester> querysuggesters; <line9> if (buildAll || reloadAll) { <line10> Collection<SuggesterCache> suggesterCaches = suggesters.values(); <line11> querysuggesters = new ArrayList<SolrSuggester>(suggesterCaches.size()); <line12> for (SuggesterCache cache : suggesterCaches) { <line13> querysuggesters.add(cache.get(ASYNC_CACHE_KEY)); <line14> } <line15> } else { <line16> querysuggesters = getSuggesters(params); <line17> } <line18> if (params.getBool(SUGGEST_BUILD, false) || buildAll) { <line19> for (SolrSuggester suggester : querysuggesters) { <line20> suggester.build(rb.req.getCore(), rb.req.getSearcher()); <line21> } <line22> rb.rsp.add(""command"", (!buildAll) ? ""build"" : ""buildAll""); <line23> } else if (params.getBool(SUGGEST_RELOAD, false) || reloadAll) { <line24> for (SolrSuggester suggester : querysuggesters) { <line25> reloadSuggester(suggester, rb.req.getCore(), rb.req.getSearcher()); <line26> } <line27> rb.rsp.add(""command"", (!reloadAll) ? ""reload"" : ""reloadAll""); <line28> } <line29> } <line30> } <line31> "	"<line3>    LOG.debug(""SuggestComponent prepare with : "" + params);"	task4	
public class A { <line0> private Optional<Event> toEvent(Delivery delivery) { <line1> String message = new String(delivery.getBody(), StandardCharsets.UTF_8); <line2> try { <line3> Event event = serializer.deserialize(message); <line4> return Optional.of(event); <line5> } catch (Exception e) { <line6> return Optional.empty(); <line7> } <line8> } <line9> } <line10> 	"<line6>      LOGGER.error(""Unable to deserialize '{}'"", message, e);"	task4	
public class A { <line0> private void loadSQLDriverClass() { <line1> try { <line2> Class.forName(getChosenSQLDriver()); <line3> } catch (ClassNotFoundException e) { <line4> } <line5> } <line6> } <line7> 	"<line4>      LOGGER.error(getChosenSQLDriver() + "" class not found."", e);"	task4	
public class A { <line0> @Override <line1> public void startFolderEvent( <line2> Session session, FileOperation op, Path file, Set<PosixFilePermission> perms) <line3> throws IOException { <line4> } <line5> } <line6> 	"<line4>    log.info(""startFolderEvent({})[{}] {}"", session, op, file);"	task4	
"public class A { <line0> private Path createClassesLst( <line1> JarBuildItem jarResult, <line2> OutputTargetBuildItem outputTarget, <line3> String javaBinPath, <line4> String containerImage, <line5> Path appCDSDir, <line6> boolean isFastJar) { <line7> List<String> commonJavaArgs = new ArrayList<>(3); <line8> commonJavaArgs.add(""-XX:DumpLoadedClassList="" + CLASSES_LIST_FILE_NAME); <line9> commonJavaArgs.add( <line10> String.format(""-D%s=true"", MainClassBuildStep.GENERATE_APP_CDS_SYSTEM_PROPERTY)); <line11> commonJavaArgs.add(""-jar""); <line12> List<String> command; <line13> if (containerImage != null) { <line14> List<String> dockerRunCommand = <line15> dockerRunCommands(outputTarget, containerImage, CONTAINER_IMAGE_APPCDS_DIR); <line16> command = new ArrayList<>(dockerRunCommand.size() + 1 + commonJavaArgs.size()); <line17> command.addAll(dockerRunCommand); <line18> command.add(""java""); <line19> command.addAll(commonJavaArgs); <line20> if (isFastJar) { <line21> command.add( <line22> CONTAINER_IMAGE_BASE_BUILD_DIR <line23> + ""/"" <line24> + JarResultBuildStep.DEFAULT_FAST_JAR_DIRECTORY_NAME <line25> + ""/"" <line26> + JarResultBuildStep.QUARKUS_RUN_JAR); <line27> } else { <line28> command.add( <line29> CONTAINER_IMAGE_BASE_BUILD_DIR + ""/"" + jarResult.getPath().getFileName().toString()); <line30> } <line31> } else { <line32> command = new ArrayList<>(2 + commonJavaArgs.size()); <line33> command.add(javaBinPath); <line34> command.addAll(commonJavaArgs); <line35> if (isFastJar) { <line36> command.add( <line37> jarResult <line38> .getLibraryDir() <line39> .getParent() <line40> .resolve(JarResultBuildStep.QUARKUS_RUN_JAR) <line41> .toAbsolutePath() <line42> .toString()); <line43> } else { <line44> command.add(jarResult.getPath().toAbsolutePath().toString()); <line45> } <line46> } <line47> if (log.isDebugEnabled()) { <line48> log.debugf( <line49> ""Launching command: '%s' to create '"" + CLASSES_LIST_FILE_NAME + ""' file."", <line50> String.join("" "", command)); <line51> } <line52> int exitCode; <line53> try { <line54> ProcessBuilder processBuilder = new ProcessBuilder(command).directory(appCDSDir.toFile()); <line55> if (log.isDebugEnabled()) { <line56> processBuilder.inheritIO(); <line57> } else { <line58> processBuilder.redirectError(NULL_FILE); <line59> processBuilder.redirectOutput(NULL_FILE); <line60> } <line61> exitCode = processBuilder.start().waitFor(); <line62> } catch (Exception e) { <line63> return null; <line64> } <line65> if (exitCode != 0) { <line66> log.debugf( <line67> ""The process that was supposed to create AppCDS exited with error code: %d."", exitCode); <line68> return null; <line69> } <line70> Path result = appCDSDir.resolve(CLASSES_LIST_FILE_NAME); <line71> if (!Files.exists(result)) { <line72> log.warnf( <line73> ""Unable to create AppCDS because '%s' was not created. Check the logs for details"", <line74> CLASSES_LIST_FILE_NAME); <line75> return null; <line76> } <line77> return result; <line78> } <line79> } <line80> "	"<line63>      log.debug(""Failed to launch process used to create '"" + CLASSES_LIST_FILE_NAME + ""'."", e);"	task4	
public class A { <line0> protected void unmapSession(Long sessionId) { <line1> if (sessionId != null) { <line2> IoSession ioSession = sessions.remove(sessionId); <line3> if (log.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	"<line4>        log.debug(""unmapSession(id={}): {}"", sessionId, ioSession);"	task4	
"public class A { <line0> private RestResponse<CustomGroup> groups() throws CatalogException, ClientException { <line1> studiesCommandOptions.groupsCommandOptions.study = <line2> getSingleValidStudy(studiesCommandOptions.groupsCommandOptions.study); <line3> ObjectMap params = new ObjectMap(); <line4> params.putIfNotNull(""id"", studiesCommandOptions.groupsCommandOptions.group); <line5> return openCGAClient <line6> .getStudyClient() <line7> .groups(studiesCommandOptions.groupsCommandOptions.study, params); <line8> } <line9> } <line10> "	"<line1>    logger.debug(""Groups"");"	task4	
"public class A { <line0> @Override <line1> public ProjectRecord cloneProject(Long idProject) { <line2> ProjectRecord original = getProject(idProject); <line3> if (original == null) { <line4> throw new NullPointerException(""Project doesn't exist""); <line5> } <line6> Long idUser = BlocklyPropSecurityUtils.getCurrentUserId(); <line7> if (original.getIdUser().equals(idUser) || original.getShared()) { <line8> return doProjectClone(original); <line9> } <line10> return null; <line11> } <line12> } <line13> "	"<line2>    LOG.info(""Clone existing project {} to a new project."", idProject);"	task4	
public class A { <line0> @Override <line1> public void close() throws HiveException { <line2> if (model != null) { <line3> if (count == 0) { <line4> this.model = null; <line5> return; <line6> } <line7> if (iterations > 1) { <line8> runIterativeTraining(iterations); <line9> } <line10> final IntWritable idx = new IntWritable(); <line11> final FloatWritable[] Pu = HiveUtils.newFloatArray(factor, 0.f); <line12> final FloatWritable[] Qi = HiveUtils.newFloatArray(factor, 0.f); <line13> final FloatWritable Bu = new FloatWritable(); <line14> final FloatWritable Bi = new FloatWritable(); <line15> final Object[] forwardObj; <line16> if (updateMeanRating) { <line17> assert useBiasClause; <line18> float meanRating = model.getMeanRating(); <line19> FloatWritable mu = new FloatWritable(meanRating); <line20> forwardObj = new Object[] {idx, Pu, Qi, Bu, Bi, mu}; <line21> } else { <line22> if (useBiasClause) { <line23> forwardObj = new Object[] {idx, Pu, Qi, Bu, Bi}; <line24> } else { <line25> forwardObj = new Object[] {idx, Pu, Qi}; <line26> } <line27> } <line28> int numForwarded = 0; <line29> for (int i = model.getMinIndex(), maxIdx = model.getMaxIndex(); i <= maxIdx; i++) { <line30> idx.set(i); <line31> Rating[] userRatings = model.getUserVector(i); <line32> if (userRatings == null) { <line33> forwardObj[1] = null; <line34> } else { <line35> forwardObj[1] = Pu; <line36> copyTo(userRatings, Pu); <line37> } <line38> Rating[] itemRatings = model.getItemVector(i); <line39> if (itemRatings == null) { <line40> forwardObj[2] = null; <line41> } else { <line42> forwardObj[2] = Qi; <line43> copyTo(itemRatings, Qi); <line44> } <line45> if (useBiasClause) { <line46> Bu.set(model.getUserBias(i)); <line47> Bi.set(model.getItemBias(i)); <line48> } <line49> forward(forwardObj); <line50> numForwarded++; <line51> } <line52> this.model = null; <line53> } <line54> } <line55> } <line56> 	"<line53>      logger.info(""Forwarded the prediction model of ""+ numForwarded+ "" rows. [totalErrors=""+ cvState.getTotalErrors()+ "", lastLosses=""+ cvState.getCumulativeLoss()+ "", #trainingExamples=""+ count+ ""]"");"	task4	
public class A { <line0> @Override <line1> public void start(final Map<String, String> props) { <line2> config = new JdbcSinkConfig(props); <line3> initWriter(); <line4> remainingRetries = config.maxRetries; <line5> try { <line6> reporter = context.errantRecordReporter(); <line7> } catch (NoSuchMethodError | NoClassDefFoundError e) { <line8> reporter = null; <line9> } <line10> } <line11> } <line12> 	"<line2>    log.info(""Starting JDBC Sink task"");"	task4	
"public class A { <line0> private void logEntityInfo( <line1> final DataDefinition dataDefinition, final Long entityId, final String message) { <line2> if (LOG.isInfoEnabled()) { <line3> StringBuilder entityInfo = new StringBuilder(""Entity[""); <line4> entityInfo <line5> .append(dataDefinition.getPluginIdentifier()) <line6> .append('.') <line7> .append(dataDefinition.getName()); <line8> entityInfo.append(""][id="").append(entityId).append(""] ""); <line9> entityInfo.append(message); <line10> } <line11> } <line12> } <line13> "	<line10>      LOG.info(entityInfo.toString());	task4	
"public class A { <line0> @Override <line1> public CertificateVerificationResult verifyCertificate( <line2> final ConnectionId cid, <line3> final ServerNames serverName, <line4> final Boolean clientUsage, <line5> final boolean truncateCertificatePath, <line6> final CertificateMessage message, <line7> final DTLSSession session) { <line8> try { <line9> final CertPath certChain = message.getCertificateChain(); <line10> if (certChain == null) { <line11> final AlertMessage alert = <line12> new AlertMessage(AlertLevel.FATAL, AlertDescription.BAD_CERTIFICATE, session.getPeer()); <line13> throw new HandshakeException(""RPK not supported"", alert); <line14> } <line15> final List<? extends Certificate> list = certChain.getCertificates(); <line16> final int pathSize = list.size(); <line17> if (pathSize < 1) { <line18> final AlertMessage alert = <line19> new AlertMessage(AlertLevel.FATAL, AlertDescription.BAD_CERTIFICATE, session.getPeer()); <line20> throw new HandshakeException(""client certificate chain must not be empty"", alert); <line21> } <line22> if (clientUsage != null) { <line23> final Certificate certificate = list.get(0); <line24> if (certificate instanceof X509Certificate) { <line25> if (!CertPathUtil.canBeUsedForAuthentication( <line26> (X509Certificate) certificate, clientUsage)) { <line27> final AlertMessage alert = <line28> new AlertMessage( <line29> AlertLevel.FATAL, AlertDescription.BAD_CERTIFICATE, session.getPeer()); <line30> throw new HandshakeException( <line31> ""certificate cannot be used for client authentication"", alert); <line32> } <line33> } <line34> } <line35> adapter.runOnContext((v) -> validateCertificateAndLoadDevice(cid, certChain, session)); <line36> return null; <line37> } catch (HandshakeException e) { <line38> return new CertificateVerificationResult(cid, e, null); <line39> } <line40> } <line41> } <line42> "	"<line38>      LOG.debug(""certificate validation failed"", e);"	task4	
"public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent e) { <line2> try { <line3> this.application.getMainFrame().removeAllProjectFrames(); <line4> URL paysURL = new URL(""file"", """", ""./data/ne_admin_0_countries/ne_50m_admin_0_countries.shp""); <line5> IPopulation<IFeature> paysPop = ShapefileReader.read(paysURL.getPath()); <line6> double saut = 45.0; <line7> double sautCourant = 45.0; <line8> while (sautCourant <= 180.0) { <line9> System.out.println(""Saut = "" + sautCourant); <line10> Population<DefaultFeature> popTranslation = new Population<DefaultFeature>(); <line11> popTranslation.setFeatureType(paysPop.getFeatureType()); <line12> for (IFeature feature : paysPop.getElements()) { <line13> String continent = feature.getAttribute(""continent"").toString().trim(); <line14> if (continent.equals(""North America"") || continent.equals(""Europe"")) { <line15> ArrayList<DefaultFeature> listATraiter = splitMultiPolygonToSinglePolygon(feature); <line16> for (DefaultFeature feat : listATraiter) { <line17> List<DefaultFeature> listNouveauFeature = getFeatureTranslate(feat, saut); <line18> if (listNouveauFeature != null && listNouveauFeature.size() > 0) { <line19> for (int j = 0; j < listNouveauFeature.size(); j++) { <line20> popTranslation.add(listNouveauFeature.get(j)); <line21> } <line22> } <line23> } <line24> } <line25> } <line26> ProjectFrame projectFrame = application.getMainFrame().newProjectFrame(); <line27> Layer layerEntite = <line28> projectFrame.addUserLayer( <line29> popTranslation, popTranslation.getNom() + ""-"" + sautCourant, null); <line30> Float size = 2f; <line31> ((PolygonSymbolizer) layerEntite.getSymbolizer()).getStroke().setStrokeWidth(size); <line32> Color darkGreen = new Color(0, 148, 255); <line33> Color lightGreen = new Color(127, 201, 255); <line34> ((PolygonSymbolizer) layerEntite.getSymbolizer()).getFill().setColor(lightGreen); <line35> ((PolygonSymbolizer) layerEntite.getSymbolizer()).getStroke().setStroke(darkGreen); <line36> layerEntite.getSymbolizer().setUnitOfMeasurePixel(); <line37> sautCourant = sautCourant + saut; <line38> } <line39> } catch (Exception ex) { <line40> ex.printStackTrace(); <line41> } <line42> try { <line43> this.application.getMainFrame().organizeCurrentDesktop(); <line44> for (int i = 0; i < this.application.getMainFrame().getDesktopProjectFrames().length; i++) { <line45> ProjectFrame frame = this.application.getMainFrame().getDesktopProjectFrames()[i]; <line46> frame.getLayerLegendPanel().getLayerViewPanel().getViewport().zoomToFullExtent(); <line47> } <line48> } catch (Exception ex) { <line49> ex.printStackTrace(); <line50> } <line51> System.out.println(""----""); <line52> } <line53> } <line54> "	"<line2>    LOGGER.debug(""Start"");"	task4	
public class A { <line0> public static void writeAllFiles(Map<Path, String> outputDataByPath) throws IOException { <line1> for (Entry<Path, String> outputDataEntry : outputDataByPath.entrySet()) { <line2> Path outputPath = outputDataEntry.getKey(); <line3> outputPath.getParent().toFile().mkdirs(); <line4> MoreFiles.asCharSink(outputPath, UTF_8).write(outputDataEntry.getValue()); <line5> } <line6> } <line7> } <line8> 	"<line3>      LOGGER.debug(""Writing: {}"", outputPath);"	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> Object o = event.getSource(); <line3> if (o == attachButton) { <line4> if (attachButton.getText().equals(attach)) { <line5> int index = controllerList.getSelectedIndex(); <line6> if (index != -1) { <line7> swingGui.send( <line8> boundServiceName, <line9> attach, <line10> controllerList.getSelectedItem(), <line11> deviceBusList.getSelectedItem(), <line12> deviceAddressList.getSelectedItem()); <line13> } <line14> } else { <line15> swingGui.send(boundServiceName, detach, controllerList.getSelectedItem()); <line16> } <line17> } <line18> if (o == refresh) { <line19> swingGui.send(boundServiceName, ""refresh""); <line20> } <line21> } <line22> } <line23> "	"<line15>        log.info(""detach {}"", controllerList.getSelectedItem());"	task4	
public class A { <line0> @Override <line1> public void transportInterupted() { <line2> interruptedCount.incrementAndGet(); <line3> } <line4> } <line5> 	"<line2>    LOG.info(""Worker "" + name + "" was interrupted..."");"	task4	
public class A { <line0> public Map setPartitionFieldValues(String partitionfieldValuesStr) { <line1> Map<String, Object> fieldValues; <line2> try { <line3> ObjectMapper objectMapper = new ObjectMapper(); <line4> fieldValues = objectMapper.readValue(partitionfieldValuesStr, Map.class); <line5> for (String key : fieldValues.keySet()) { <line6> List value = (List) fieldValues.get(key); <line7> fieldValues.put(key, value); <line8> } <line9> return fieldValues; <line10> } catch (Exception e) { <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> 	"<line11>      LOG.error("""", e);"	task4	
public class A { <line0> public StepPhase stageApp(CloudApplication app) { <line1> CloudPackage cloudPackage = context.getVariable(Variables.CLOUD_PACKAGE); <line2> if (cloudPackage == null) { <line3> return StepPhase.DONE; <line4> } <line5> return createBuild(cloudPackage.getGuid()); <line6> } <line7> } <line8> 	<line5>    logger.info(Messages.STAGING_APP, app.getName());	task4	
"public class A { <line0> public B addExtra(String key, String value) { <line1> Preconditions.checkArgument(!(null == key), ""Key should not be null.""); <line2> if (null == value) { <line3> return theBuilder; <line4> } <line5> if (null == extrasBuilder) { <line6> extrasBuilder = new HashMap<String, String>(); <line7> } <line8> extrasBuilder.put(key, value); <line9> return theBuilder; <line10> } <line11> } <line12> "	"<line3>      LOG.debug(""Extra value is null, throw away it."");"	task4	
"public class A { <line0> @Override <line1> public void process(InputStream in, OutputStream out) throws IOException { <line2> InputStream pgpin = getDecoderStream(in); <line3> JcaPGPObjectFactory pgpFactory = new JcaPGPObjectFactory(pgpin); <line4> Object obj = pgpFactory.nextObject(); <line5> if (!(obj instanceof PGPEncryptedDataList)) { <line6> obj = pgpFactory.nextObject(); <line7> if (!(obj instanceof PGPEncryptedDataList)) { <line8> throw new ProcessException(""Invalid OpenPGP data""); <line9> } <line10> } <line11> PGPEncryptedDataList encList = (PGPEncryptedDataList) obj; <line12> obj = encList.get(0); <line13> if (!(obj instanceof PGPPBEEncryptedData)) { <line14> throw new ProcessException(""Invalid OpenPGP data""); <line15> } <line16> PGPPBEEncryptedData encryptedData = (PGPPBEEncryptedData) obj; <line17> try { <line18> final PGPDigestCalculatorProvider digestCalculatorProvider = <line19> new JcaPGPDigestCalculatorProviderBuilder().setProvider(provider).build(); <line20> final PBEDataDecryptorFactory decryptorFactory = <line21> new JcePBEDataDecryptorFactoryBuilder(digestCalculatorProvider) <line22> .setProvider(provider) <line23> .build(password); <line24> InputStream clear = encryptedData.getDataStream(decryptorFactory); <line25> JcaPGPObjectFactory pgpObjectFactory = new JcaPGPObjectFactory(clear); <line26> obj = pgpObjectFactory.nextObject(); <line27> if (obj instanceof PGPCompressedData) { <line28> PGPCompressedData compressedData = (PGPCompressedData) obj; <line29> pgpObjectFactory = new JcaPGPObjectFactory(compressedData.getDataStream()); <line30> obj = pgpObjectFactory.nextObject(); <line31> } <line32> PGPLiteralData literalData = (PGPLiteralData) obj; <line33> InputStream plainIn = literalData.getInputStream(); <line34> final byte[] buffer = new byte[org.apache.nifi.processors.standard.util.PGPUtil.BLOCK_SIZE]; <line35> int len; <line36> while ((len = plainIn.read(buffer)) >= 0) { <line37> out.write(buffer, 0, len); <line38> } <line39> if (encryptedData.isIntegrityProtected()) { <line40> if (!encryptedData.verify()) { <line41> throw new PGPException(""Integrity check failed""); <line42> } <line43> } else { <line44> } <line45> } catch (Exception e) { <line46> throw new ProcessException(e.getMessage()); <line47> } <line48> } <line49> } <line50> "	"<line44>        logger.warn(""No message integrity check"");"	task4	
"public class A { <line0> @NonNull <line1> @Override <line2> public ReconnectionSchedule newControlConnectionSchedule( <line3> @SuppressWarnings(""ignored"") boolean isInitialConnection) { <line4> return new ExponentialSchedule(); <line5> } <line6> } <line7> "	"<line4>    LOG.debug(""[{}] Creating new schedule for the control connection"", logPrefix);"	task4	
"public class A { <line0> @Override <line1> public ListProperty getListProperty(String name) { <line2> if (name == null) { <line3> return new ListPropertyImpl(""""); <line4> } <line5> ListPropertyImpl listProperty = new ListPropertyImpl(name); <line6> configListeners.put(listProperty, true); <line7> return listProperty; <line8> } <line9> } <line10> "	"<line3>      logger.error(""getListProperty(): argument 'name' must be non-null"");"	task4	
public class A { <line0> public static <K, C> void createColumnFamiliy( <line1> final Keyspace keyspace, <line2> final ColumnFamily<K, C> columnFamily, <line3> final Map<String, Object> options) { <line4> try { <line5> if (keyspace.describeKeyspace().getColumnFamily(columnFamily.getName()) == null) { <line6> keyspace.createColumnFamily(columnFamily, new HashMap<String, Object>()); <line7> } <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> 	"<line9>      logger.error(""Error on creating column family, ignoring"", e);"	task4	
public class A { <line0> public void readEntryAndFenceLedger( <line1> final long ledgerId, byte[] masterKey, final long entryId, ReadEntryCallback cb, Object ctx) { <line2> final long txnId = getTxnId(); <line3> final CompletionKey completionKey = new CompletionKey(txnId, OperationType.READ_ENTRY); <line4> completionObjects.put( <line5> completionKey, <line6> new ReadCompletion( <line7> statsLogger, <line8> BookKeeperClientStats.CHANNEL_READ_ENTRY_AND_FENCE, <line9> cb, <line10> ctx, <line11> ledgerId, <line12> entryId, <line13> scheduleTimeout(completionKey, conf.getReadEntryTimeout()))); <line14> BKPacketHeader.Builder headerBuilder = <line15> BKPacketHeader.newBuilder() <line16> .setVersion(ProtocolVersion.VERSION_THREE) <line17> .setOperation(OperationType.READ_ENTRY) <line18> .setTxnId(txnId); <line19> ReadRequest.Builder readBuilder = <line20> ReadRequest.newBuilder() <line21> .setLedgerId(ledgerId) <line22> .setEntryId(entryId) <line23> .setMasterKey(ByteString.copyFrom(masterKey)) <line24> .setFlag(ReadRequest.Flag.FENCE_LEDGER); <line25> final Request readRequest = <line26> Request.newBuilder().setHeader(headerBuilder).setReadRequest(readBuilder).build(); <line27> final Channel c = channel; <line28> if (c == null) { <line29> errorOutReadKey(completionKey); <line30> return; <line31> } <line32> writeRequestToChannel( <line33> c, <line34> readRequest, <line35> new GenericCallback<Void>() { <line36> @Override <line37> public void operationComplete(int rc, Void result) { <line38> if (rc != 0) { <line39> errorOutReadKey(completionKey); <line40> } else { <line41> if (LOG.isDebugEnabled()) { <line42> } <line43> } <line44> } <line45> }); <line46> } <line47> } <line48> 	"<line42>                LOG.debug(""Successfully wrote request to fence ledger and read entry: ""+ entryId+ "" ledger-id: ""+ ledgerId+ "" bookie: ""+ channel.getRemoteAddress());"	task4	
"public class A { <line0> private ResultSet getColumnsMetadata(Connection con, String tableNameFilter) { <line1> try { <line2> if (con != null) { <line3> DatabaseMetaData dbMetaData = con.getMetaData(); <line4> if (dbMetaData != null) { <line5> return dbMetaData.getColumns(null, null, tableNameFilter, ""%""); <line6> } <line7> } <line8> } catch (SQLException ex) { <line9> } <line10> return null; <line11> } <line12> } <line13> "	<line9>      Logger.error(this.getClass().getName(), ex.getMessage(), ex);	task4	
"public class A { <line0> @Override <line1> public void onTraversalDone(GenomeLocSortedSet result) { <line2> if (VALIDATE_GVCF) { <line3> final GenomeLocSortedSet toolkitIntervals = getToolkit().getIntervals(); <line4> final GenomeLocSortedSet traversalIntervals; <line5> if (toolkitIntervals == null) { <line6> traversalIntervals = <line7> GenomeLocSortedSet.createSetFromSequenceDictionary( <line8> getToolkit().getMasterSequenceDictionary()); <line9> } else { <line10> traversalIntervals = toolkitIntervals; <line11> } <line12> final GenomeLocSortedSet uncoveredIntervals = traversalIntervals.subtractRegions(result); <line13> if (traversalIntervals.subtractRegions(result).coveredSize() > 0) { <line14> final UserException e = <line15> new UserException.FailsStrictValidation( <line16> file, <line17> ""Found "" <line18> + uncoveredIntervals.coveredSize() <line19> + "" positions not covered by a VariantContext record. The first uncovered"" <line20> + "" segment is: "" <line21> + uncoveredIntervals.iterator().next() <line22> + "". As noted in the documentation for the --validateGVCF/-gvcf argument, GVCF"" <line23> + "" validation requires that all positions to validate be covered by records."" <line24> + "" Use -L or --XL to specify what intervals are covered in the GVCF. These"" <line25> + "" should be the same intervals used to generate the GVCF or a subset"" <line26> + "" thereof.""); <line27> if (WARN_ON_ERROR) { <line28> numErrors++; <line29> } else { <line30> throw e; <line31> } <line32> } <line33> } <line34> if (numErrors == 0) <line35> System.out.println( <line36> ""Successfully validated the input file.  Checked "" <line37> + result.size() <line38> + "" records with no failures.""); <line39> else System.out.println(""Found "" + numErrors + "" records with failures.""); <line40> } <line41> } <line42> "	"<line29>          logger.warn(""***** "" + e.getMessage() + "" *****"");"	task4	
public class A { <line0> protected final void sneakySaveLevelDat() { <line1> try { <line2> this.saveLevelDat(); <line3> } catch (IOException cause) { <line4> } <line5> } <line6> } <line7> 	"<line4>      this.logger.warn(""level.dat for world '{}' could not be saved: "", this.levelName, cause);"	task4	
public class A { <line0> public final ApplicationTraceMetadata registerTrace() { <line1> final TraceMetadata enclosingTrace = this.getTrace(); <line2> if (enclosingTrace != null) { <line3> Stack<TraceMetadata> localTraceStack = this.enclosingTraceStack.get(); <line4> if (localTraceStack == null) { <line5> localTraceStack = new Stack<>(); <line6> this.enclosingTraceStack.set(localTraceStack); <line7> } <line8> localTraceStack.push(enclosingTrace); <line9> } <line10> final Thread thread = Thread.currentThread(); <line11> final TracePoint tp = this.getAndRemoveParentTraceId(thread); <line12> final long traceId = this.getNewId(); <line13> final long parentTraceId; <line14> final int parentOrderId; <line15> if (tp != null) { <line16> if ((enclosingTrace != null) && (enclosingTrace.getTraceId() != tp.traceId)) { <line17> } <line18> parentTraceId = tp.traceId; <line19> parentOrderId = tp.orderId; <line20> } else if (enclosingTrace != null) { <line21> parentTraceId = enclosingTrace.getTraceId(); <line22> parentOrderId = -1; <line23> } else { <line24> parentTraceId = traceId; <line25> parentOrderId = -1; <line26> } <line27> final String sessionId = SessionRegistry.INSTANCE.recallThreadLocalSessionId(); <line28> final String applicationName = MonitoringController.getInstance().getApplicationName(); <line29> final ApplicationTraceMetadata trace = <line30> new ApplicationTraceMetadata( <line31> traceId, <line32> thread.getId(), <line33> sessionId, <line34> this.hostname, <line35> parentTraceId, <line36> parentOrderId, <line37> applicationName); <line38> this.traceStorage.set(trace); <line39> return trace; <line40> } <line41> } <line42> 	"<line17>        LOGGER.error(""Enclosing trace does not match split point. Found: {} expected: {}"",enclosingTrace.getTraceId(),enclosingTrace.getTraceId());"	task4	
public class A { <line0> public final Response putConnection(final ComponentConnection body) { <line1> if (body == null) { <line2> return new Response(Response.BAD_REQUEST, null); <line3> } <line4> String path = String.format(CONNECTION_PATH, body.getObjectId()); <line5> return putObjectToSystemMng(path, body); <line6> } <line7> } <line8> 	"<line5>    log.debug("""");"	task4	
"public class A { <line0> protected String getXacmlDataType(String curPermValue) { <line1> if (""false"".equalsIgnoreCase(curPermValue) || ""true"".equalsIgnoreCase(curPermValue)) { <line2> return BOOLEAN_DATA_TYPE; <line3> } else if (IntegerValidator.getInstance().validate(curPermValue) != null) { <line4> return INTEGER_DATA_TYPE; <line5> } else if (DoubleValidator.getInstance().validate(curPermValue, Locale.getDefault()) != null) { <line6> return DOUBLE_DATA_TYPE; <line7> } else if (TimeValidator.getInstance().validate(curPermValue, ""H:mm:ss"") != null <line8> || TimeValidator.getInstance().validate(curPermValue, ""H:mm:ss.SSS"") != null <line9> || TimeValidator.getInstance().validate(curPermValue, ""H:mm:ssXXX"") != null <line10> || TimeValidator.getInstance().validate(curPermValue, ""H:mm:ss.SSSXXX"") != null) { <line11> return TIME_DATA_TYPE; <line12> } else if (DateValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd"") != null <line13> || DateValidator.getInstance().validate(curPermValue, ""yyyy-MM-ddXXX"") != null) { <line14> return DATE_DATA_TYPE; <line15> } else if (CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd:ss'T'H:mm"") <line16> != null <line17> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ssXXX"") != null <line18> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ss.SSS"") <line19> != null <line20> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ss.SSSXXX"") <line21> != null <line22> || CalendarValidator.getInstance().validate(curPermValue, ""yyyy-MM-dd'T'H:mm:ss"") != null) { <line23> return DATE_TIME_DATA_TYPE; <line24> } else if (EmailValidator.getInstance().isValid(curPermValue)) { <line25> return RFC822_NAME_DATA_TYPE; <line26> } else if (new UrlValidator().isValid(curPermValue)) { <line27> return URI_DATA_TYPE; <line28> } else if (InetAddresses.isUriInetAddress(curPermValue)) { <line29> return IP_ADDRESS_DATA_TYPE; <line30> } else { <line31> try { <line32> if (new X500Name(curPermValue).getRDNs().length > 0) { <line33> return X500_NAME_DATA_TYPE; <line34> } <line35> } catch (IllegalArgumentException e) { <line36> } <line37> } <line38> return STRING_DATA_TYPE; <line39> } <line40> } <line41> "	"<line36>        LOGGER.debug(""Unable to get X500 Name"", e);"	task4	
"public class A { <line0> protected boolean processZKCmd(MyCommandOptions co) <line1> throws CliException, IOException, InterruptedException { <line2> String[] args = co.getArgArray(); <line3> String cmd = co.getCommand(); <line4> if (args.length < 1) { <line5> usage(); <line6> throw new MalformedCommandException(""No command entered""); <line7> } <line8> if (!commandMap.containsKey(cmd)) { <line9> usage(); <line10> throw new CommandNotFoundException(""Command not found "" + cmd); <line11> } <line12> boolean watch = false; <line13> if (cmd.equals(""quit"")) { <line14> zk.close(); <line15> ServiceUtils.requestSystemExit(exitCode); <line16> } else if (cmd.equals(""redo"") && args.length >= 2) { <line17> Integer i = Integer.decode(args[1]); <line18> if (commandCount <= i || i < 0) { <line19> throw new MalformedCommandException(""Command index out of range""); <line20> } <line21> cl.parseCommand(history.get(i)); <line22> if (cl.getCommand().equals(""redo"")) { <line23> throw new MalformedCommandException(""No redoing redos""); <line24> } <line25> history.put(commandCount, history.get(i)); <line26> processCmd(cl); <line27> } else if (cmd.equals(""history"")) { <line28> for (int i = commandCount - 10; i <= commandCount; ++i) { <line29> if (i < 0) { <line30> continue; <line31> } <line32> System.out.println(i + "" - "" + history.get(i)); <line33> } <line34> } else if (cmd.equals(""printwatches"")) { <line35> if (args.length == 1) { <line36> System.out.println(""printwatches is "" + (printWatches ? ""on"" : ""off"")); <line37> } else { <line38> printWatches = args[1].equals(""on""); <line39> } <line40> } else if (cmd.equals(""connect"")) { <line41> if (args.length >= 2) { <line42> connectToZK(args[1]); <line43> } else { <line44> connectToZK(host); <line45> } <line46> } <line47> if (zk == null || !zk.getState().isAlive()) { <line48> System.out.println(""Not connected""); <line49> return false; <line50> } <line51> CliCommand cliCmd = commandMapCli.get(cmd); <line52> if (cliCmd != null) { <line53> cliCmd.setZk(zk); <line54> watch = cliCmd.parse(args).exec(); <line55> } else if (!commandMap.containsKey(cmd)) { <line56> usage(); <line57> } <line58> return watch; <line59> } <line60> } <line61> "	"<line13>    LOG.debug(""Processing {}"", cmd);"	task4	
public class A { <line0> @EventListener(ApplicationReadyEvent.class) <line1> @Order(value = 2) <line2> public void onApplicationEvent(ApplicationReadyEvent event) { <line3> this.nfConsumer.subscribe(); <line4> launchNotificationsConsumer(); <line5> launchMainConsumers(); <line6> } <line7> } <line8> 	"<line3>    log.info(""Subscribing to notifications: {}"", nfConsumer.getTopic());"	task4	
public class A { <line0> @Override <line1> public BroadcastSubscriptionListener getBroadcastSubscriptionListener(String subscriptionId) { <line2> if (!subscriptionStates.containsKey(subscriptionId) <line3> || !broadcastSubscriptionListenerDirectory.containsKey(subscriptionId)) { <line4> } <line5> return broadcastSubscriptionListenerDirectory.get(subscriptionId); <line6> } <line7> } <line8> 	"<line4>      logger.error(""Received publication for not existing subscription callback with subscriptionId {}"",subscriptionId);"	task4	
public class A { <line0> private void notifyServerFailed(GrayServer server, boolean notifyToMaster) <line1> throws ServiceException { <line2> try { <line3> dispatchMessageQueue.put(new ServerEvent(EventType.SERVER_FAILED, server.psLoc)); <line4> } catch (Exception e) { <line5> } <line6> if (notifyToMaster) { <line7> PSAgentContext.get().getMasterClient().psFailed(server.psLoc); <line8> } <line9> } <line10> } <line11> 	"<line5>      LOG.error(""add SERVER_FAILED event for request failed, "", e);"	task4	
public class A { <line0> private boolean updateTextSections() { <line1> XTextSectionsSupplier supp = UNO.XTextSectionsSupplier(doc); <line2> if (supp == null) { <line3> return false; <line4> } <line5> long startTime = System.currentTimeMillis(); <line6> HashSet<String> knownTextSections = new HashSet<>(); <line7> HashSet<TextSection> invalidTextSections = new HashSet<>(); <line8> for (Iterator<TextSection> iter = allTextSectionsWithGROUPS.iterator(); iter.hasNext(); ) { <line9> TextSection s = iter.next(); <line10> if (s.isInvalid()) invalidTextSections.add(s); <line11> else knownTextSections.add(s.getName()); <line12> } <line13> HashSet<TextSection> newTextSections = new HashSet<>(); <line14> String[] textSectionNames = supp.getTextSections().getElementNames(); <line15> for (int i = 0; i < textSectionNames.length; i++) { <line16> String name = textSectionNames[i]; <line17> Matcher m = sectionWithGROUPSPattern.matcher(name); <line18> if (m.find() && !knownTextSections.contains(name)) { <line19> TextSection s = createTextSection(name, m.group(1), UNO.XTextSectionsSupplier(doc)); <line20> if (s != null) { <line21> newTextSections.add(s); <line22> } <line23> } <line24> } <line25> removeInvalidTextSections(invalidTextSections); <line26> addNewTextSections(newTextSections); <line27> return !invalidTextSections.isEmpty() || !newTextSections.isEmpty(); <line28> } <line29> } <line30> 	"<line27>    LOGGER.trace(""updateTextSections fertig nach {} ms. Entfernte/Neue TextSections: {} / {}"",Integer.valueOf((int) (System.currentTimeMillis() - startTime)),invalidTextSections.size(),newTextSections.size());"	task4	
"public class A { <line0> protected List<Elem> getReleaseChoices(final String keyword) { <line1> try { <line2> final List<Elem> choices = new ArrayList<Elem>(); <line3> getContainer() <line4> .run( <line5> true, <line6> true, <line7> new IRunnableWithProgress() { <line8> @Override <line9> public void run(IProgressMonitor monitor) <line10> throws InvocationTargetException, InterruptedException { <line11> monitor.beginTask(""Fetching latest releases from the Forge"", 55); <line12> try { <line13> final Exception[] te = new Exception[1]; <line14> Thread t = <line15> new Thread() { <line16> @Override <line17> public void run() { <line18> try { <line19> for (Module module : <line20> moduleService.listAll( <line21> new Modules.WithText(keyword), <line22> Modules.LAST_RELEASED, <line23> false)) { <line24> for (AbbrevRelease ab : module.getReleases()) <line25> choices.add(new Elem(ab)); <line26> } <line27> } catch (SocketException e) { <line28> if (!""Socket closed"".equals(e.getMessage())) te[0] = e; <line29> } catch (Exception e) { <line30> te[0] = e; <line31> } <line32> } <line33> }; <line34> t.start(); <line35> int idx = 0; <line36> while (t.isAlive()) { <line37> t.join(1000); <line38> if (monitor.isCanceled()) { <line39> moduleService.abortCurrentRequest(); <line40> throw new OperationCanceledException(); <line41> } <line42> if (++idx <= 5) monitor.worked(1); <line43> } <line44> if (te[0] != null) throw new InvocationTargetException(te[0]); <line45> } catch (RuntimeException e) { <line46> throw e; <line47> } catch (InvocationTargetException e) { <line48> throw e; <line49> } catch (Exception e) { <line50> throw new InvocationTargetException(e); <line51> } finally { <line52> monitor.done(); <line53> } <line54> } <line55> }); <line56> if (!choices.isEmpty()) return choices; <line57> MessageDialog.openConfirm( <line58> getShell(), <line59> getLocalString(""_UI_No_modules_found""), <line60> getLocalString(""_UI_No_module_matching_keyword"", keyword)); <line61> } catch (InvocationTargetException e) { <line62> Throwable t = e.getTargetException(); <line63> StringBuilder builder = new StringBuilder(); <line64> builder.append(t.getClass().getName()); <line65> builder.append(""\n""); <line66> builder.append(t.getMessage()); <line67> builder.append(""\n\n(See the log view for technical details).""); <line68> MessageDialog.openError( <line69> getShell(), ""Error while communicating with the ForgeAPI."", builder.toString()); <line70> } catch (InterruptedException e) { <line71> } <line72> return Collections.emptyList(); <line73> } <line74> } <line75> "	"<line70>      log.error(""Error while communicating with the ForgeAPI"", t);"	task4	
"public class A { <line0> @PayloadRoot( <line1> localPart = ""SetDeviceVerificationKeyRequest"", <line2> namespace = DEVICE_MANAGEMENT_NAMESPACE) <line3> @ResponsePayload <line4> public SetDeviceVerificationKeyAsyncResponse setDeviceVerificationKey( <line5> @OrganisationIdentification final String organisationIdentification, <line6> @RequestPayload final SetDeviceVerificationKeyRequest request, <line7> @MessagePriority final String messagePriority) <line8> throws OsgpException { <line9> final SetDeviceVerificationKeyAsyncResponse response = <line10> new SetDeviceVerificationKeyAsyncResponse(); <line11> try { <line12> final String correlationUid = <line13> this.deviceManagementService.enqueueSetDeviceVerificationKeyRequest( <line14> organisationIdentification, <line15> request.getDeviceIdentification(), <line16> request.getVerificationKey(), <line17> MessagePriorityEnum.getMessagePriority(messagePriority)); <line18> final AsyncResponse asyncResponse = new AsyncResponse(); <line19> asyncResponse.setCorrelationUid(correlationUid); <line20> asyncResponse.setDeviceId(request.getDeviceIdentification()); <line21> response.setAsyncResponse(asyncResponse); <line22> } catch (final ConstraintViolationException e) { <line23> throw new FunctionalException( <line24> FunctionalExceptionType.VALIDATION_ERROR, <line25> ComponentType.WS_CORE, <line26> new ValidationException(e.getConstraintViolations())); <line27> } catch (final Exception e) { <line28> this.handleException(e); <line29> } <line30> return response; <line31> } <line32> } <line33> "	"<line9>    LOGGER.info(""Set Device Verification Key Request received from organisation: {} for device: {} with""+ "" message priority: {}."",organisationIdentification,request.getDeviceIdentification(),messagePriority);"	task4	
public class A { <line0> protected Scroll buildScroll(BulkCommand command) { <line1> ScrollRequest request; <line2> String query = command.getQuery(); <line3> if (command.useExternalScroller()) { <line4> request = EmptyScrollRequest.of(); <line5> } else if (command.useGenericScroller()) { <line6> request = <line7> GenericScrollRequest.builder(command.getScroller(), query) <line8> .options(command.getParams()) <line9> .size(scrollSize) <line10> .build(); <line11> } else { <line12> request = <line13> DocumentScrollRequest.builder(query) <line14> .username(command.getUsername()) <line15> .repository(command.getRepository()) <line16> .size(scrollSize) <line17> .timeout(Duration.ofSeconds(scrollKeepAliveSeconds)) <line18> .name(command.getScroller()) <line19> .build(); <line20> } <line21> ScrollService service = Framework.getService(ScrollService.class); <line22> return service.scroll(request); <line23> } <line24> } <line25> 	"<line3>    log.debug(""Build scroll with query: {}"", query);"	task4	
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> @Test <line2> public void testSqlSelect() { <line3> OuterJoinOperator oper = new OuterJoinOperator(); <line4> oper.setFullJoin(true); <line5> CollectorTestSink sink = new CollectorTestSink(); <line6> oper.outport.setSink(sink); <line7> Condition cond = new JoinColumnEqualCondition(""a"", ""a""); <line8> oper.setJoinCondition(cond); <line9> oper.selectTable1Column(new ColumnIndex(""b"", null)); <line10> oper.selectTable2Column(new ColumnIndex(""c"", null)); <line11> oper.setup(null); <line12> oper.beginWindow(1); <line13> HashMap<String, Object> tuple = new HashMap<String, Object>(); <line14> tuple.put(""a"", 0); <line15> tuple.put(""b"", 1); <line16> tuple.put(""c"", 2); <line17> oper.inport1.process(tuple); <line18> tuple = new HashMap<String, Object>(); <line19> tuple.put(""a"", 1); <line20> tuple.put(""b"", 3); <line21> tuple.put(""c"", 4); <line22> oper.inport1.process(tuple); <line23> tuple = new HashMap<String, Object>(); <line24> tuple.put(""a"", 2); <line25> tuple.put(""b"", 11); <line26> tuple.put(""c"", 12); <line27> oper.inport1.process(tuple); <line28> tuple = new HashMap<String, Object>(); <line29> tuple.put(""a"", 0); <line30> tuple.put(""b"", 7); <line31> tuple.put(""c"", 8); <line32> oper.inport2.process(tuple); <line33> tuple = new HashMap<String, Object>(); <line34> tuple.put(""a"", 1); <line35> tuple.put(""b"", 5); <line36> tuple.put(""c"", 6); <line37> oper.inport2.process(tuple); <line38> oper.endWindow(); <line39> oper.teardown(); <line40> } <line41> } <line42> "	"<line40>    LOG.debug(""{}"", sink.collectedTuples);"	task4	
public class A { <line0> private void severeCannotLoad(AbstractResource menubarsLayoutXmlResource, Exception cause) { <line1> } <line2> } <line3> 	"<line1>    log.error(""{}: could not find readable resource {} for the Menubars-Layout."",WebAppContextPath.class.getName(),menubarsLayoutXmlResource,cause);"	task4	
public class A { <line0> public String decrypt(String password, String keyString) { <line1> try { <line2> byte[] keySrcBytes = encodeUTF8(keyString); <line3> byte[] newKey1 = Base64.decodeBase64(keySrcBytes); <line4> Key newKey2 = toKey(newKey1); <line5> byte[] srcBytes = encodeUTF8(password); <line6> byte[] desBytes = decrypt(Base64.decodeBase64(srcBytes), newKey2); <line7> String tempdecodeUTF8 = decodeUTF8(desBytes); <line8> if (tempdecodeUTF8.substring(0, appendString.length()).equals(appendString)) { <line9> return tempdecodeUTF8.substring(appendString.length(), tempdecodeUTF8.length()); <line10> } <line11> return password; <line12> } catch (Exception e) { <line13> return password; <line14> } <line15> } <line16> } <line17> 	<line13>      logger.debug(e.getMessage());	task4	
public class A { <line0> private static boolean _exists(long groupId, long userId, String curFileName) { <line1> try { <line2> FileEntry fileEntry = <line3> TempFileEntryUtil.getTempFileEntry(groupId, userId, _TEMP_FILE_NAME, curFileName); <line4> if (fileEntry != null) { <line5> return true; <line6> } <line7> return false; <line8> } catch (PortalException portalException) { <line9> if (log.isDebugEnabled()) { <line10> } <line11> return false; <line12> } <line13> } <line14> } <line15> 	<line10>        log.debug(portalException, portalException);	task4	
public class A { <line0> @Override <line1> public void sendCeaMessage(int resultCode, Message cer, String errMessage) <line2> throws TransportException, OverloadException { <line3> IMessage message = parser.createEmptyMessage(Message.CAPABILITIES_EXCHANGE_ANSWER, 0); <line4> message.setRequest(false); <line5> message.setHopByHopIdentifier(cer.getHopByHopIdentifier()); <line6> message.setEndToEndIdentifier(cer.getEndToEndIdentifier()); <line7> message <line8> .getAvps() <line9> .addAvp(Avp.ORIGIN_HOST, metaData.getLocalPeer().getUri().getFQDN(), true, false, true); <line10> message <line11> .getAvps() <line12> .addAvp(Avp.ORIGIN_REALM, metaData.getLocalPeer().getRealmName(), true, false, true); <line13> for (InetAddress ia : metaData.getLocalPeer().getIPAddresses()) { <line14> message.getAvps().addAvp(Avp.HOST_IP_ADDRESS, ia, true, false); <line15> } <line16> message <line17> .getAvps() <line18> .addAvp(Avp.VENDOR_ID, metaData.getLocalPeer().getVendorId(), true, false, true); <line19> for (ApplicationId appId : metaData.getLocalPeer().getCommonApplications()) { <line20> addAppId(appId, message); <line21> } <line22> message.getAvps().addAvp(Avp.PRODUCT_NAME, metaData.getLocalPeer().getProductName(), false); <line23> message.getAvps().addAvp(Avp.RESULT_CODE, resultCode, true, false, true); <line24> message.getAvps().addAvp(Avp.FIRMWARE_REVISION, metaData.getLocalPeer().getFirmware(), true); <line25> if (errMessage != null) { <line26> message.getAvps().addAvp(Avp.ERROR_MESSAGE, errMessage, false); <line27> } <line28> sendMessage(message); <line29> } <line30> } <line31> 	"<line3>    logger.debug(""Send CEA message"");"	task4	
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> VelbusBridgeHandler velbusBridgeHandler = getVelbusBridgeHandler(); <line3> if (velbusBridgeHandler == null) { <line4> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); <line5> return; <line6> } <line7> if (command instanceof RefreshType) { <line8> VelbusStatusRequestPacket packet = <line9> new VelbusStatusRequestPacket(getModuleAddress().getChannelIdentifier(channelUID)); <line10> byte[] packetBytes = packet.getBytes(); <line11> velbusBridgeHandler.sendPacket(packetBytes); <line12> } else if (command instanceof UpDownType) { <line13> UpDownType s = (UpDownType) command; <line14> if (s == UpDownType.UP) { <line15> byte commandByte = COMMAND_BLIND_UP; <line16> VelbusBlindUpDownPacket packet = <line17> new VelbusBlindUpDownPacket( <line18> getModuleAddress().getChannelIdentifier(channelUID), commandByte); <line19> byte[] packetBytes = packet.getBytes(); <line20> velbusBridgeHandler.sendPacket(packetBytes); <line21> } else { <line22> byte commandByte = COMMAND_BLIND_DOWN; <line23> VelbusBlindUpDownPacket packet = <line24> new VelbusBlindUpDownPacket( <line25> getModuleAddress().getChannelIdentifier(channelUID), commandByte); <line26> byte[] packetBytes = packet.getBytes(); <line27> velbusBridgeHandler.sendPacket(packetBytes); <line28> } <line29> } else if (command instanceof StopMoveType) { <line30> StopMoveType s = (StopMoveType) command; <line31> if (s == StopMoveType.STOP) { <line32> VelbusBlindOffPacket packet = <line33> new VelbusBlindOffPacket(getModuleAddress().getChannelIdentifier(channelUID)); <line34> byte[] packetBytes = packet.getBytes(); <line35> velbusBridgeHandler.sendPacket(packetBytes); <line36> } <line37> } else if (command instanceof PercentType) { <line38> VelbusBlindPositionPacket packet = <line39> new VelbusBlindPositionPacket( <line40> getModuleAddress().getChannelIdentifier(channelUID), <line41> ((PercentType) command).byteValue()); <line42> byte[] packetBytes = packet.getBytes(); <line43> velbusBridgeHandler.sendPacket(packetBytes); <line44> } else { <line45> } <line46> } <line47> } <line48> 	"<line45>      logger.debug(""The command '{}' is not supported by this handler."", command.getClass());"	task4	
public class A { <line0> @ParamName(LegacyResourceConstants.HOMEPAGE_URL_PARAM) <line1> public void setDatasetHomepageUrl(String homepageUrl) { <line2> if (!Strings.isNullOrEmpty(homepageUrl)) { <line3> try { <line4> URI uri = new URI(homepageUrl); <line5> setHomepage(uri); <line6> } catch (URISyntaxException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	"<line7>        LOG.warn(""Dataset homepageURL was invalid: {}"", Strings.nullToEmpty(homepageUrl));"	task4	
"public class A { <line0> public static String getKBArticleRSS( <line1> HttpPrincipal httpPrincipal, <line2> long resourcePrimKey, <line3> int status, <line4> int rssDelta, <line5> String rssDisplayStyle, <line6> String rssFormat, <line7> com.liferay.portal.kernel.theme.ThemeDisplay themeDisplay) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey( <line12> KBArticleServiceUtil.class, ""getKBArticleRSS"", _getKBArticleRSSParameterTypes17); <line13> MethodHandler methodHandler = <line14> new MethodHandler( <line15> methodKey, <line16> resourcePrimKey, <line17> status, <line18> rssDelta, <line19> rssDisplayStyle, <line20> rssFormat, <line21> themeDisplay); <line22> Object returnObj = null; <line23> try { <line24> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line25> } catch (Exception exception) { <line26> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line27> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line28> } <line29> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line30> } <line31> return (String) returnObj; <line32> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line33> throw systemException; <line34> } <line35> } <line36> } <line37> "	<line33>      log.error(systemException, systemException);	task4	
public class A { <line0> public static <T> T fromJson(String json, Class<T> clazz) { <line1> T output = null; <line2> try { <line3> output = mapper.readValue(json, clazz); <line4> } catch (Exception e) { <line5> } <line6> return output; <line7> } <line8> } <line9> 	"<line5>      log.error(""Could no de-serialize the following json "" + json, e);"	task4	
"public class A { <line0> TenantResult<JsonObject> getTenantObjectResult(final String tenantId, final Span span) { <line1> final Versioned<Tenant> tenant = tenants.get(tenantId); <line2> if (tenant == null) { <line3> TracingHelper.logError(span, ""tenant not found""); <line4> return TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND); <line5> } else { <line6> return TenantResult.from( <line7> HttpURLConnection.HTTP_OK, <line8> DeviceRegistryUtils.convertTenant(tenantId, tenant.getValue(), true), <line9> DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())); <line10> } <line11> } <line12> } <line13> "	"<line1>    LOG.debug(""reading tenant info [id: {}]"", tenantId);"	task4	
public class A { <line0> protected List<String> getPoolNamesForHost(String host) { <line1> String test = host; <line2> if (!hrtlbConf.derive().isIpBasedRegex) { <line3> try { <line4> test = getNameFromIp(host); <line5> } catch (UnknownHostException e1) { <line6> return Collections.singletonList(DEFAULT_POOL); <line7> } <line8> } <line9> List<String> pools = new ArrayList<>(); <line10> for (Entry<String, Pattern> e : hrtlbConf.derive().poolNameToRegexPattern.entrySet()) { <line11> if (e.getValue().matcher(test).matches()) { <line12> pools.add(e.getKey()); <line13> } <line14> } <line15> if (pools.isEmpty()) { <line16> pools.add(DEFAULT_POOL); <line17> } <line18> return pools; <line19> } <line20> } <line21> 	"<line6>        LOG.error(""Unable to determine host name for IP: "" + host + "", setting to default pool"", e1);"	task4	
"public class A { <line0> @Transactional <line1> public FileDTO generatePackageFile( <line2> ExperimentPackage pckg, <line3> MetadataCommand mc, <line4> License license, <line5> List<Experiment> selectList, <line6> Person loggedUser, <line7> DownloadPackageManager manager) { <line8> ZipOutputStream zipOutputStream = null; <line9> FileOutputStream fileOutputStream = null; <line10> File tempZipFile = null; <line11> ZipInputStream in = null; <line12> File file = null; <line13> try { <line14> FileDTO dto = new FileDTO(); <line15> dto.setFileName(pckg.getName().replaceAll(""\\s"", ""_"") + "".zip""); <line16> tempZipFile = File.createTempFile(""experimentDownload_"", "".zip""); <line17> fileOutputStream = new FileOutputStream(tempZipFile); <line18> zipOutputStream = new ZipOutputStream(fileOutputStream); <line19> for (Experiment tmp : selectList) { <line20> Experiment exp = service.getExperimentForDetail(tmp.getExperimentId()); <line21> String experimentDirPrefix = """"; <line22> String scenarioName = exp.getScenario().getTitle(); <line23> if (scenarioName != null) { <line24> experimentDirPrefix = <line25> ""Experiment_"" <line26> + exp.getExperimentId() <line27> + ""_"" <line28> + scenarioName.replaceAll(""\\s"", ""_"") <line29> + ""/""; <line30> } else experimentDirPrefix = ""Experiment_data_"" + exp.getExperimentId() + ""/""; <line31> byte[] licenseFile = licenseService.getLicenseAttachmentContent(license.getLicenseId()); <line32> file = <line33> zipGenerator.generate( <line34> exp, mc, exp.getDataFiles(), licenseFile, license.getAttachmentFileName()); <line35> in = new ZipInputStream(new FileInputStream(file)); <line36> ZipEntry entryIn = null; <line37> while ((entryIn = in.getNextEntry()) != null) { <line38> zipOutputStream.putNextEntry(new ZipEntry(experimentDirPrefix + entryIn.getName())); <line39> IOUtils.copyLarge(in, zipOutputStream); <line40> zipOutputStream.closeEntry(); <line41> } <line42> FileUtils.deleteOnExitQuietly(file); <line43> IOUtils.closeQuietly(in); <line44> FileUtils.deleteQuietly(file); <line45> createHistoryRecordAboutDownload(exp, loggedUser); <line46> synchronized (this) { <line47> manager.setNumberOfDownloadedExperiments(manager.getNumberOfDownloadedExperiments() + 1); <line48> } <line49> } <line50> dto.setFile(tempZipFile); <line51> FileUtils.deleteOnExitQuietly(tempZipFile); <line52> IOUtils.closeQuietly(zipOutputStream); <line53> IOUtils.closeQuietly(fileOutputStream); <line54> return dto; <line55> } catch (Exception e) { <line56> IOUtils.closeQuietly(zipOutputStream); <line57> IOUtils.closeQuietly(fileOutputStream); <line58> FileUtils.deleteOnExitQuietly(tempZipFile); <line59> FileUtils.deleteOnExitQuietly(file); <line60> FileUtils.deleteQuietly(tempZipFile); <line61> FileUtils.deleteQuietly(file); <line62> return null; <line63> } <line64> } <line65> } <line66> "	<line56>      log.error(e.getMessage(), e);	task4	
"public class A { <line0> @Test <line1> public void testSaveGridSet() throws Exception { <line2> String name = ""testGrid""; <line3> SRS srs = SRS.getEPSG4326(); <line4> BoundingBox extent = new BoundingBox(-1, -1, 1, 1); <line5> boolean alignTopLeft = true; <line6> double[] resolutions = {3, 2, 1}; <line7> double[] scaleDenoms = null; <line8> Double metersPerUnit = 1.5; <line9> double pixelSize = 2 * GridSetFactory.DEFAULT_PIXEL_SIZE_METER; <line10> String[] scaleNames = {""uno"", ""dos"", ""tres""}; <line11> int tileWidth = 128; <line12> int tileHeight = 512; <line13> boolean yCoordinateFirst = true; <line14> GridSet gridSet = <line15> GridSetFactory.createGridSet( <line16> name, <line17> srs, <line18> extent, <line19> alignTopLeft, <line20> resolutions, <line21> scaleDenoms, <line22> metersPerUnit, <line23> pixelSize, <line24> scaleNames, <line25> tileWidth, <line26> tileHeight, <line27> yCoordinateFirst); <line28> gridSet.setDescription(""test description""); <line29> config.addGridSet(gridSet); <line30> try { <line31> XMLConfiguration.validate(XMLConfiguration.loadDocument(new FileInputStream(configFile))); <line32> } catch (SAXParseException e) { <line33> fail(e.getMessage()); <line34> } <line35> XMLConfiguration config2 = new XMLConfiguration(null, configDir.getAbsolutePath()); <line36> GridSetBroker gridSetBroker2 = <line37> new GridSetBroker(Arrays.asList(new DefaultGridsets(true, true), config2)); <line38> config2.setGridSetBroker(gridSetBroker2); <line39> config2.afterPropertiesSet(); <line40> config2.getLayerCount(); <line41> GridSet gridSet2 = gridSetBroker2.get(name); <line42> assertNotNull(gridSet2); <line43> assertEquals(gridSet, gridSet2); <line44> } <line45> } <line46> "	<line33>      log.error(e.getMessage());	task4	
"public class A { <line0> @GET <line1> public Object getCountries(@QueryParam(""fields"") String fields) { <line2> List<Country> countries = CountryService.getInstance().getAll(); <line3> return parsedCountries(countries, fields); <line4> } <line5> } <line6> "	"<line2>    LOG.info(""Getting all"");"	task4	
public class A { <line0> @Override <line1> public void run(FlowTrigger trigger, Map data) { <line2> VmInstanceSpec spec = <line3> (VmInstanceSpec) data.get(VmInstanceConstant.Params.VmInstanceSpec.toString()); <line4> changeVmStateInDb( <line5> struct.getStrategy() == VmCreationStrategy.InstantStart <line6> ? VmInstanceStateEvent.running <line7> : VmInstanceStateEvent.paused, <line8> () -> { <line9> self.setLastHostUuid(spec.getDestHost().getUuid()); <line10> self.setHostUuid(spec.getDestHost().getUuid()); <line11> self.setClusterUuid(spec.getDestHost().getClusterUuid()); <line12> self.setZoneUuid(spec.getDestHost().getZoneUuid()); <line13> self.setHypervisorType(spec.getDestHost().getHypervisorType()); <line14> self.setRootVolumeUuid(spec.getDestRootVolume().getUuid()); <line15> }); <line16> VmInstanceInventory inv = VmInstanceInventory.valueOf(self); <line17> extEmitter.afterStartNewCreatedVm(inv); <line18> trigger.next(); <line19> } <line20> } <line21> 	"<line16>    logger.debug(String.format(""vm[uuid:%s] is started .."", self.getUuid()));"	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Stop""}, <line2> description = ""empty column stop_id"", <line3> priority = 46) <line4> public void verifyTest_2_3_1() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""stop_3_1"", GTFS_1_GTFS_Common_12, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""stops.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(5), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	"<line5>    log.info(Color.GREEN + ""Stop_2 : empty column stop_id"" + Color.NORMAL);"	task4	
public class A { <line0> private static void validateResult(String input, String origInput) { <line1> if (input.length() == 0) { <line2> } <line3> } <line4> } <line5> 	"<line2>      logger.debug(""Failed to cleanup the input "" + origInput);"	task4	
public class A { <line0> @Override <line1> public Resource getResource() { <line2> final String path = _pathTextField.getText(); <line3> try { <line4> return _resourceTypeHandler.parsePath(path); <line5> } catch (final Exception e) { <line6> return null; <line7> } <line8> } <line9> } <line10> 	"<line6>      logger.debug(""Failed to parse path '{}', returning null"", path, e);"	task4	
public class A { <line0> private void handleBrightness(Command command) throws IOException, CommandUnsuccessfulException { <line1> if (command instanceof PercentType) { <line2> PercentType percent = (PercentType) command; <line3> Transform transform = new Transform(); <line4> transform.setLuminanceGain(percent.doubleValue() / 100); <line5> TransformCommand transformCommand = new TransformCommand(transform); <line6> sendCommand(transformCommand); <line7> } else { <line8> } <line9> } <line10> } <line11> 	"<line8>      logger.debug(""Channel {} unable to process command {}"", CHANNEL_BRIGHTNESS, command);"	task4	
public class A { <line0> @Override <line1> public boolean acquire(String tableName) { <line2> if (isQueryRateLimitDisabled()) { <line3> return true; <line4> } <line5> String offlineTableName = null; <line6> String realtimeTableName = null; <line7> QueryQuotaEntity offlineTableQueryQuotaEntity = null; <line8> QueryQuotaEntity realtimeTableQueryQuotaEntity = null; <line9> TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableName); <line10> if (tableType == TableType.OFFLINE) { <line11> offlineTableName = tableName; <line12> offlineTableQueryQuotaEntity = _rateLimiterMap.get(tableName); <line13> } else if (tableType == TableType.REALTIME) { <line14> realtimeTableName = tableName; <line15> realtimeTableQueryQuotaEntity = _rateLimiterMap.get(tableName); <line16> } else { <line17> offlineTableName = TableNameBuilder.OFFLINE.tableNameWithType(tableName); <line18> realtimeTableName = TableNameBuilder.REALTIME.tableNameWithType(tableName); <line19> offlineTableQueryQuotaEntity = _rateLimiterMap.get(offlineTableName); <line20> realtimeTableQueryQuotaEntity = _rateLimiterMap.get(realtimeTableName); <line21> } <line22> boolean offlineQuotaOk = <line23> offlineTableQueryQuotaEntity == null <line24> || tryAcquireToken(offlineTableName, offlineTableQueryQuotaEntity); <line25> boolean realtimeQuotaOk = <line26> realtimeTableQueryQuotaEntity == null <line27> || tryAcquireToken(realtimeTableName, realtimeTableQueryQuotaEntity); <line28> return offlineQuotaOk && realtimeQuotaOk; <line29> } <line30> } <line31> 	"<line5>    LOGGER.debug(""Trying to acquire token for table: {}"", tableName);"	task4	
"public class A { <line0> @Override <line1> public KBFolder fetchByG_P_UT( <line2> long groupId, long parentKBFolderId, String urlTitle, boolean useFinderCache) { <line3> urlTitle = Objects.toString(urlTitle, """"); <line4> Object[] finderArgs = null; <line5> if (useFinderCache) { <line6> finderArgs = new Object[] {groupId, parentKBFolderId, urlTitle}; <line7> } <line8> Object result = null; <line9> if (useFinderCache) { <line10> result = finderCache.getResult(_finderPathFetchByG_P_UT, finderArgs); <line11> } <line12> if (result instanceof KBFolder) { <line13> KBFolder kbFolder = (KBFolder) result; <line14> if ((groupId != kbFolder.getGroupId()) <line15> || (parentKBFolderId != kbFolder.getParentKBFolderId()) <line16> || !Objects.equals(urlTitle, kbFolder.getUrlTitle())) { <line17> result = null; <line18> } <line19> } <line20> if (result == null) { <line21> StringBundler sb = new StringBundler(5); <line22> sb.append(_SQL_SELECT_KBFOLDER_WHERE); <line23> sb.append(_FINDER_COLUMN_G_P_UT_GROUPID_2); <line24> sb.append(_FINDER_COLUMN_G_P_UT_PARENTKBFOLDERID_2); <line25> boolean bindUrlTitle = false; <line26> if (urlTitle.isEmpty()) { <line27> sb.append(_FINDER_COLUMN_G_P_UT_URLTITLE_3); <line28> } else { <line29> bindUrlTitle = true; <line30> sb.append(_FINDER_COLUMN_G_P_UT_URLTITLE_2); <line31> } <line32> String sql = sb.toString(); <line33> Session session = null; <line34> try { <line35> session = openSession(); <line36> Query query = session.createQuery(sql); <line37> QueryPos queryPos = QueryPos.getInstance(query); <line38> queryPos.add(groupId); <line39> queryPos.add(parentKBFolderId); <line40> if (bindUrlTitle) { <line41> queryPos.add(urlTitle); <line42> } <line43> List<KBFolder> list = query.list(); <line44> if (list.isEmpty()) { <line45> if (useFinderCache) { <line46> finderCache.putResult(_finderPathFetchByG_P_UT, finderArgs, list); <line47> } <line48> } else { <line49> if (list.size() > 1) { <line50> Collections.sort(list, Collections.reverseOrder()); <line51> if (log.isWarnEnabled()) { <line52> if (!useFinderCache) { <line53> finderArgs = new Object[] {groupId, parentKBFolderId, urlTitle}; <line54> } <line55> } <line56> } <line57> KBFolder kbFolder = list.get(0); <line58> result = kbFolder; <line59> cacheResult(kbFolder); <line60> } <line61> } catch (Exception exception) { <line62> throw processException(exception); <line63> } finally { <line64> closeSession(session); <line65> } <line66> } <line67> if (result instanceof List<?>) { <line68> return null; <line69> } else { <line70> return (KBFolder) result; <line71> } <line72> } <line73> } <line74> "	"<line55>              log.warn(""KBFolderPersistenceImpl.fetchByG_P_UT(long, long, String, boolean) with""+ "" parameters (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."");"	task4	
public class A { <line0> public static void debug(String strLogger, Object objToLog) { <line1> Logger logger = Logger.getLogger(strLogger); <line2> if (logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>      logger.debug(objToLog);	task4	
"public class A { <line0> @Override <line1> public void clear(Properties properties) { <line2> Map<String, Object> settings = parseDatasourceProperties(properties); <line3> Connection conn = null; <line4> Statement stmt = null; <line5> try { <line6> conn = openConnection(settings); <line7> List<String> names = getQuotedSchemaTableNames(settings, conn); <line8> if (!names.isEmpty()) { <line9> List<String> list = Lists.newArrayList(); <line10> list.add(""SET FOREIGN_KEY_CHECKS=0;""); <line11> for (String name : names) { <line12> list.add(String.format(""truncate %s;"", name)); <line13> } <line14> list.add(""SET FOREIGN_KEY_CHECKS=1;""); <line15> stmt = conn.createStatement(); <line16> for (String sql : list) { <line17> stmt.execute(sql); <line18> } <line19> } <line20> } catch (SQLException ex) { <line21> throw new ConfigurationError(ex); <line22> } finally { <line23> close(stmt); <line24> close(conn); <line25> } <line26> } <line27> } <line28> "	"<line17>          LOGGER.debug(""Executed clear datasource SQL statement: {}"", sql);"	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Stop""}, <line2> description = ""missing column stop_lat"", <line3> priority = 44) <line4> public void verifyTest_2_2_3() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""stop_2_3"", GTFS_1_GTFS_Common_9, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""stops.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(1), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	"<line5>    log.info(Color.GREEN + ""Stop_2_3 : missing column stop_lat"" + Color.NORMAL);"	task4	
public class A { <line0> private void processChangeGlobalStateResponse( <line1> final UUID nodeId, final GridChangeGlobalStateMessageResponse msg) { <line2> assert nodeId != null; <line3> assert msg != null; <line4> if (log.isDebugEnabled()) { <line5> } <line6> UUID requestId = msg.getRequestId(); <line7> final GridChangeGlobalStateFuture fut = stateChangeFut.get(); <line8> if (fut != null && requestId.equals(fut.requestId)) { <line9> if (fut.initFut.isDone()) fut.onResponse(nodeId, msg); <line10> else { <line11> fut.initFut.listen( <line12> new CI1<IgniteInternalFuture<?>>() { <line13> @Override <line14> public void apply(IgniteInternalFuture<?> f) { <line15> ctx.getSystemExecutorService() <line16> .execute( <line17> new Runnable() { <line18> @Override <line19> public void run() { <line20> fut.onResponse(nodeId, msg); <line21> } <line22> }); <line23> } <line24> }); <line25> } <line26> } <line27> } <line28> } <line29> 	"<line5>      log.debug(""Received activation response [requestId=""+ msg.getRequestId()+ "", nodeId=""+ nodeId+ ""]"");"	task4	
public class A { <line0> private void run() { <line1> try { <line2> refresh(); <line3> if (super.thing.getStatus() == ThingStatus.INITIALIZING) { <line4> setBridgeProperties(); <line5> } <line6> } catch (PlugwiseHAInvalidHostException e) { <line7> updateStatus(OFFLINE, CONFIGURATION_ERROR, STATUS_DESCRIPTION_INVALID_HOSTNAME); <line8> } catch (PlugwiseHAUnauthorizedException | PlugwiseHANotAuthorizedException e) { <line9> updateStatus(OFFLINE, CONFIGURATION_ERROR, STATUS_DESCRIPTION_INVALID_CREDENTIALS); <line10> } catch (PlugwiseHACommunicationException e) { <line11> updateStatus(OFFLINE, COMMUNICATION_ERROR, STATUS_DESCRIPTION_COMMUNICATION_ERROR); <line12> } catch (PlugwiseHATimeoutException e) { <line13> updateStatus(OFFLINE, COMMUNICATION_ERROR, STATUS_DESCRIPTION_TIMEOUT); <line14> } catch (PlugwiseHAException e) { <line15> updateStatus(OFFLINE, COMMUNICATION_ERROR, e.getMessage()); <line16> } catch (RuntimeException e) { <line17> updateStatus(OFFLINE, COMMUNICATION_ERROR, e.getMessage()); <line18> } <line19> } <line20> } <line21> 	"<line2>      logger.trace(""Executing refresh job"");"	task4	
public class A { <line0> @Override <line1> public String getPassword() { <line2> return config.getPassword(); <line3> } <line4> } <line5> 	"<line2>    LOG.debug(""Providing password for ssh authentication of user '{}'"", config.getUsername());"	task4	
public class A { <line0> private void closeAllSources() { <line1> for (DataSourceHolder sourceHolder : dataSources) { <line2> try { <line3> sourceHolder.close(); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> } <line9> 	"<line5>        logger.error(""Error in closing data source "" + sourceHolder, e);"	task4	
public class A { <line0> @Override <line1> public Enumeration getMapNames() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> return ((MapMessage) message).getMapNames(); <line5> } <line6> } <line7> 	"<line3>      ActiveMQRALogger.LOGGER.trace(""getMapNames()"");"	task4	
public class A { <line0> void asyncCloseInternal(final CloseCallback cb, final Object ctx, final int rc) { <line1> try { <line2> doAsyncCloseInternal(cb, ctx, rc); <line3> } catch (RejectedExecutionException re) { <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> errorOutPendingAdds(BookKeeper.getReturnRc(clientCtx.getBookieClient(), rc)); <line7> cb.closeComplete( <line8> BookKeeper.getReturnRc( <line9> clientCtx.getBookieClient(), BKException.Code.InterruptedException), <line10> this, <line11> ctx); <line12> } <line13> } <line14> } <line15> 	"<line5>        LOG.debug(""Failed to close ledger {} : "", ledgerId, re);"	task4	
"public class A { <line0> private Integer queryAfterUpdateRowId( <line1> String dbName, String tableName, Map<Field, Object[]> fieldMap) { <line2> int count = 0, id = 0; <line3> ResultSet rs; <line4> PreparedStatement stmt; <line5> Boolean finishQuery = false; <line6> String query = ""select id from "" + dbName + ""."" + tableName + "" where 1=1""; <line7> for (Map.Entry<Field, Object[]> entry : fieldMap.entrySet()) { <line8> count++; <line9> String fieldName = entry.getKey().getName(); <line10> FieldType fieldType = entry.getKey().getType(); <line11> Object fieldValue = entry.getValue()[1]; <line12> if (""id"".equals(fieldName)) continue; <line13> if (count <= fieldMap.size()) { <line14> query += "" and ""; <line15> } <line16> if (fieldValue == null) { <line17> query += fieldName + "" is NULL""; <line18> } else { <line19> query = typeParser(fieldType, fieldName, fieldValue, query); <line20> } <line21> } <line22> try { <line23> while (!connection.isClosed() && !finishQuery) { <line24> stmt = connection.prepareStatement(query); <line25> rs = stmt.executeQuery(); <line26> if (rs != null) { <line27> while (rs.next()) { <line28> id = rs.getInt(""id""); <line29> } <line30> finishQuery = true; <line31> rs.close(); <line32> } <line33> } <line34> } catch (SQLException e) { <line35> } <line36> return id; <line37> } <line38> } <line39> "	"<line35>      log.error(""query table error,{}"", e);"	task4	
"public class A { <line0> @Test( <line1> groups = {""Phase 2 Route""}, <line2> description = ""route_long_name includes route_short_name"", <line3> priority = 326) <line4> public void verifyTest_2_8() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""route_8"", GTFS_2_GTFS_Route_2, SEVERITY.WARNING, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""routes.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(2), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	"<line5>    log.info(Color.GREEN + ""Route_8 : route_long_name includes route_short_name"" + Color.NORMAL);"	task4	
public class A { <line0> void cleanHelperFiles() { <line1> try { <line2> fs.delete(basePath, true); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	<line4>      logger.warn(e.getMessage());	task4	
public class A { <line0> @Override <line1> public void setResponseManaType(UUID manaTypePlayerId, ManaType manaType) { <line2> waitResponseOpen(); <line3> synchronized (response) { <line4> response.setManaType(manaType); <line5> response.setResponseManaTypePlayerId(manaTypePlayerId); <line6> response.notifyAll(); <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.debug(""Got response mana type from player: "" + getId());"	task4	
"public class A { <line0> @PostConstruct <line1> public void load() { <line2> this.loadLoginModuleNames(); <line3> this.loadJaasConfig(); <line4> authenticatedSessionTimeoutMinutes = <line5> sysPropConfigStore.get(""authenticatedSessionTimeoutMinutes"", 180); <line6> enforceMatchingUsernames = <line7> Boolean.parseBoolean(sysPropConfigStore.get(""zanata.enforce.matchingusernames"")); <line8> tokenExpiresInSeconds = sysPropConfigStore.getLong(ACCESS_TOKEN_EXPIRES_IN_SECONDS, 3600); <line9> } <line10> } <line11> "	"<line2>    log.info(""Reloading configuration"");"	task4	
public class A { <line0> @Override <line1> public PlayerSkin createPlayerSkin(InputStream inputStream) { <line2> try { <line3> return io.gomint.server.player.PlayerSkin.fromInputStream(inputStream); <line4> } catch (IOException e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	"<line5>      LOGGER.error(""Could not read skin from input: "", e);"	task4	
public class A { <line0> @Override <line1> public IoWriteFuture writeBuffer(Buffer buffer) throws IOException { <line2> if (log.isDebugEnabled()) { <line3> } <line4> ByteBuffer buf = ByteBuffer.wrap(buffer.array(), buffer.rpos(), buffer.available()); <line5> Nio2DefaultIoWriteFuture future = new Nio2DefaultIoWriteFuture(getRemoteAddress(), null, buf); <line6> if (isClosing()) { <line7> Throwable exc = new ClosedChannelException(); <line8> future.setException(exc); <line9> exceptionCaught(exc); <line10> return future; <line11> } <line12> writes.add(future); <line13> startWriting(); <line14> return future; <line15> } <line16> } <line17> 	"<line3>      log.debug(""writeBuffer({}) writing {} bytes"", this, buffer.available());"	task4	
"public class A { <line0> @Override <line1> public <E> List<E> getColumnsById( <line2> String schemaName, <line3> String tableName, <line4> String pKeyColumnName, <line5> String inverseJoinColumnName, <line6> Object pKeyColumnValue, <line7> Class columnJavaType) { <line8> List<E> foreignKeys = new ArrayList<E>(); <line9> URI uri = null; <line10> HttpResponse response = null; <line11> try { <line12> String q = ""key="" + CouchDBUtils.appendQuotes(pKeyColumnValue); <line13> uri = <line14> new URI( <line15> CouchDBConstants.PROTOCOL, <line16> null, <line17> httpHost.getHostName(), <line18> httpHost.getPort(), <line19> CouchDBConstants.URL_SEPARATOR <line20> + schemaName.toLowerCase() <line21> + CouchDBConstants.URL_SEPARATOR <line22> + CouchDBConstants.DESIGN <line23> + tableName <line24> + CouchDBConstants.VIEW <line25> + pKeyColumnName, <line26> q, <line27> null); <line28> HttpGet get = new HttpGet(uri); <line29> get.addHeader(""Accept"", ""application/json""); <line30> response = httpClient.execute(get); <line31> InputStream content = response.getEntity().getContent(); <line32> Reader reader = new InputStreamReader(content); <line33> JsonObject json = gson.fromJson(reader, JsonObject.class); <line34> JsonElement jsonElement = json.get(""rows""); <line35> if (jsonElement == null) { <line36> return foreignKeys; <line37> } <line38> JsonArray array = jsonElement.getAsJsonArray(); <line39> for (JsonElement element : array) { <line40> JsonElement value = <line41> element.getAsJsonObject().get(""value"").getAsJsonObject().get(inverseJoinColumnName); <line42> if (value != null) { <line43> foreignKeys.add( <line44> (E) <line45> PropertyAccessorHelper.fromSourceToTargetClass( <line46> columnJavaType, String.class, value.getAsString())); <line47> } <line48> } <line49> } catch (Exception e) { <line50> throw new KunderaException(e); <line51> } finally { <line52> closeContent(response); <line53> } <line54> return foreignKeys; <line55> } <line56> } <line57> "	"<line50>      log.error(""Error while fetching column by id {}, Caused by {}."", pKeyColumnValue, e);"	task4	
public class A { <line0> @Override <line1> public Void run() { <line2> startServer(server); <line3> return null; <line4> } <line5> } <line6> 	"<line2>    LOG.info(""Starting Server using kerberos credential"");"	task4	
public class A { <line0> private static Set<JobInfo> getAllJobInfo( <line1> ProcessType ptype, <line2> JobInfo parentJobInfo, <line3> Set<JobInfo> jobInfos, <line4> boolean firstChildOnly, <line5> boolean includeJoblet) { <line6> if (ptype == null) { <line7> return jobInfos; <line8> } <line9> EList<NodeType> nodes = ptype.getNode(); <line10> getSubjobInfo(nodes, ptype, parentJobInfo, jobInfos, firstChildOnly, includeJoblet); <line11> if (parentJobInfo.isTestContainer() <line12> && GlobalServiceRegister.getDefault() <line13> .isServiceRegistered(ITestContainerProviderService.class)) { <line14> ITestContainerProviderService testContainerService = <line15> GlobalServiceRegister.getDefault().getService(ITestContainerProviderService.class); <line16> if (testContainerService != null) { <line17> getSubjobInfo( <line18> testContainerService.getOriginalNodes(ptype), <line19> ptype, <line20> parentJobInfo, <line21> jobInfos, <line22> firstChildOnly, <line23> includeJoblet); <line24> } <line25> } <line26> if (!parentJobInfo.isTestContainer() <line27> && !parentJobInfo.isJoblet() <line28> && GlobalServiceRegister.getDefault() <line29> .isServiceRegistered(ITestContainerProviderService.class)) { <line30> ITestContainerProviderService testContainerService = <line31> GlobalServiceRegister.getDefault().getService(ITestContainerProviderService.class); <line32> if (testContainerService != null) { <line33> List<ProcessItem> testsItems = <line34> testContainerService.getTestContainersByVersion(parentJobInfo.getProcessItem()); <line35> for (ProcessItem testItem : testsItems) { <line36> ProcessType testProcess = testContainerService.getTestContainerProcess(testItem); <line37> if (testItem.getProcess() == null) { <line38> testItem.setProcess(testProcess); <line39> } <line40> if (testProcess == null) { <line41> continue; <line42> } <line43> JobInfo jobInfo = new JobInfo(testItem, testProcess.getDefaultContext()); <line44> jobInfo.setTestContainer(true); <line45> jobInfo.setFatherJobInfo(parentJobInfo); <line46> if (!jobInfos.contains(jobInfo)) { <line47> jobInfos.add(jobInfo); <line48> getSubjobInfo( <line49> testProcess.getNode(), <line50> testProcess, <line51> parentJobInfo, <line52> jobInfos, <line53> firstChildOnly, <line54> includeJoblet); <line55> } <line56> } <line57> } <line58> } <line59> return jobInfos; <line60> } <line61> } <line62> 	"<line41>            log.warn(Messages.getString(""ProcessorUtilities.nullProcess""));"	task4	
public class A { <line0> public static void moveQuantitiesBetweenWarehouses( <line1> long fromCommerceInventoryWarehouseId, <line2> long toCommerceInventoryWarehouseId, <line3> String sku, <line4> int quantity) <line5> throws RemoteException { <line6> try { <line7> CommerceInventoryWarehouseItemServiceUtil.moveQuantitiesBetweenWarehouses( <line8> fromCommerceInventoryWarehouseId, toCommerceInventoryWarehouseId, sku, quantity); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>      log.error(exception, exception);	task4	
public class A { <line0> protected void reset() { <line1> for (RouteMap.Entry<String, RouteAsImpl> e = this.route.head(), end = this.route.tail(); <line2> (e = e.getNext()) != end; ) { <line3> String key = e.getKey(); <line4> RouteAsImpl routeAs = e.getValue(); <line5> routeAs.setM3uaManagement(this.m3uaManagement); <line6> routeAs.reset(); <line7> As[] asList = routeAs.getAsArray(); <line8> try { <line9> String[] keys = key.split(KEY_SEPARATOR); <line10> int dpc = Integer.parseInt(keys[0]); <line11> for (count = 0; count < asList.length; count++) { <line12> AsImpl asImpl = (AsImpl) asList[count]; <line13> if (asImpl != null) { <line14> this.addAsToDPC(dpc, asImpl); <line15> } <line16> } <line17> } catch (Exception ex) { <line18> } <line19> } <line20> } <line21> } <line22> 	"<line18>        logger.error(String.format(""Error while adding key=%s to As list=%s"", key, Arrays.toString(asList)));"	task4	
"public class A { <line0> public static <T> T getObjectFromAerospikeRecord( <line1> Class<T> classEntity, AerospikeRecord aerospikeRecord, AerospikeDeepJobConfig aerospikeConfig) <line2> throws IllegalAccessException, InstantiationException, InvocationTargetException { <line3> Tuple2<String, Object> equalsFilter = aerospikeConfig.getEqualsFilter(); <line4> String equalsFilterBin = equalsFilter != null ? equalsFilter._1() : null; <line5> Object equalsFilterValue = equalsFilter != null ? equalsFilter._2() : null; <line6> Map<String, Object> bins = aerospikeRecord.bins; <line7> T t = classEntity.newInstance(); <line8> if (equalsFilter == null || checkEqualityFilter(bins, equalsFilterBin, equalsFilterValue)) { <line9> Field[] fields = AnnotationUtils.filterDeepFields(classEntity); <line10> Object insert = null; <line11> List<String> inputColumns = null; <line12> if (aerospikeConfig.getInputColumns() != null) { <line13> inputColumns = Arrays.asList(aerospikeConfig.getInputColumns()); <line14> } <line15> for (Field field : fields) { <line16> if (inputColumns != null && !inputColumns.contains(AnnotationUtils.deepFieldName(field))) { <line17> continue; <line18> } <line19> Object currentBin = null; <line20> Method method = null; <line21> Class<?> classField = field.getType(); <line22> try { <line23> method = Utils.findSetter(field.getName(), classEntity, field.getType()); <line24> currentBin = bins.get(AnnotationUtils.deepFieldName(field)); <line25> if (currentBin != null) { <line26> if (currentBin instanceof Integer && classField.equals(Long.class)) { <line27> currentBin = new Long((Integer) currentBin); <line28> } <line29> if (currentBin instanceof String <line30> || currentBin instanceof Integer <line31> || currentBin instanceof Long) { <line32> insert = currentBin; <line33> } else { <line34> throw new DeepGenericException( <line35> ""Data type ["" <line36> + classField.toString() <line37> + ""] not supported in Aerospike entity extractor (only Strings and"" <line38> + "" Integers)""); <line39> } <line40> method.invoke(t, insert); <line41> } <line42> } catch (IllegalAccessException | InvocationTargetException | IllegalArgumentException e) { <line43> method.invoke(t, Utils.castNumberType(insert, classField)); <line44> } <line45> } <line46> } <line47> return t; <line48> } <line49> } <line50> "	"<line43>          LOG.error(""impossible to create a java object from Bin:""+ field.getName()+ "" and type:""+ field.getType()+ "" and value:""+ t+ ""; recordReceived:""+ currentBin);"	task4	
"public class A { <line0> private void runJoinSample(EPRuntime runtime) { <line1> String epl = <line2> ""select sw.* "" <line3> + ""from SampleJoinEvent#lastevent sje, MySampleWindow sw "" <line4> + ""where sw.key1 = sje.propOne and sw.key2 = sje.propTwo""; <line5> EPStatement stmt = compileDeploy(epl, runtime); <line6> SampleUpdateListener sampleListener = new SampleUpdateListener(); <line7> stmt.addListener(sampleListener); <line8> runtime <line9> .getEventService() <line10> .sendEventBean(new SampleJoinEvent(""sample1"", ""sample2""), ""SampleJoinEvent""); <line11> } <line12> } <line13> "	"<line11>    log.info(""Join query returned: ""+ sampleListener.getLastEvent().get(""key1"")+ "" and ""+ sampleListener.getLastEvent().get(""key2""));"	task4	
"public class A { <line0> public static void storeQuery(List<String> querySet, String outputPath) throws IOException { <line1> String fileName = outputPath + "".sql""; <line2> File parentFile = new File(fileName).getParentFile(); <line3> if (!parentFile.exists()) { <line4> parentFile.mkdirs(); <line5> } <line6> try (BufferedWriter bufferedWriter = <line7> new BufferedWriter( <line8> new OutputStreamWriter(new FileOutputStream(fileName), StandardCharsets.UTF_8))) { <line9> for (String query : querySet) { <line10> bufferedWriter.append(query); <line11> bufferedWriter.append(SQL_SEPARATOR + ""\n""); <line12> } <line13> } <line14> } <line15> } <line16> "	<line12>        logger.info(query);	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.ClassName fetchByClassNameId( <line1> HttpPrincipal httpPrincipal, long classNameId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> ClassNameServiceUtil.class, ""fetchByClassNameId"", _fetchByClassNameIdParameterTypes0); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, classNameId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> return (com.liferay.portal.kernel.model.ClassName) returnObj; <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	<line15>      log.error(systemException, systemException);	task4	
public class A { <line0> public void setPrimaryFieldPos(int p) { <line1> primaryFieldPos = p; <line2> } <line3> } <line4> 	"<line1>    LOG.debug(""setPrimaryFieldPos()"");"	task4	
"public class A { <line0> protected BinaryAttachmentResponse encodeNetCDFObsToNetcdf( <line1> List<NetCDFObservation> netCDFObsList, Version version) throws EncodingException { <line2> if (CollectionHelper.isEmptyOrNull(netCDFObsList)) { <line3> throw new EncodingException(""No feature types to encode""); <line4> } else if (netCDFObsList.size() > 1) { <line5> throwTooManyFeatureTypesOrSensorsException(netCDFObsList, netCDFObsList.size(), null); <line6> } <line7> NetCDFObservation netCDFObservation = netCDFObsList.get(0); <line8> if (CollectionHelper.isEmpty(netCDFObservation.getSensorDatasets())) { <line9> throw new EncodingException(""No sensors to encode""); <line10> } else if (netCDFObservation.getSensorDatasets().size() > 1) { <line11> throwTooManyFeatureTypesOrSensorsException( <line12> netCDFObsList, null, netCDFObservation.getSensorDatasets().size()); <line13> } <line14> AbstractSensorDataset sensorDataset = netCDFObservation.getSensorDatasets().get(0); <line15> File tempDir = Files.createTempDir(); <line16> String filename = getFilename(sensorDataset); <line17> File netcdfFile = new File(tempDir, filename); <line18> try { <line19> encodeSensorDataToNetcdf(netcdfFile, sensorDataset, version); <line20> return new BinaryAttachmentResponse( <line21> Files.toByteArray(netcdfFile), <line22> getContentType(), <line23> String.format(filename, makeDateSafe(new DateTime(DateTimeZone.UTC)))); <line24> } catch (IOException e) { <line25> throw new EncodingException(""Couldn't create netCDF file"", e); <line26> } finally { <line27> } <line28> } <line29> } <line30> "	"<line27>      LOGGER.debug(""Temporary file deleted: {}"", tempDir.delete());"	task4	
"public class A { <line0> @Override <line1> public void delete(String... usernames) throws SecurityManagementException { <line2> checkNotNull(""usernames"", usernames); <line3> for (String username : usernames) { <line4> final User user = get(username); <line5> if (user == null) { <line6> throw new UserNotFoundException(username); <line7> } <line8> try { <line9> usersFileLoader.getProperties().remove(username); <line10> usersFileLoader.persistProperties(); <line11> getGroupsPropertiesManager().removeEntry(username); <line12> } catch (IOException e) { <line13> throw new SecurityManagementException(e); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line13>        LOG.error(""Error deleting user "" + username, e);"	task4	
public class A { <line0> public static void schedule() { <line1> service.scheduleWithFixedDelay(new DataCacheHandler(), 0, TTL, TimeUnit.SECONDS); <line2> } <line3> } <line4> 	"<line2>    logger.info(""SchedulerManager:schedule: Started scheduler job for cache refresh with ttl in sec =""+ TTL);"	task4	
"public class A { <line0> @Override <line1> protected void doExportStagedModel(PortletDataContext portletDataContext, BlogsEntry entry) <line2> throws Exception { <line3> Element entryElement = portletDataContext.getExportDataElement(entry); <line4> if (entry.isSmallImage()) { <line5> if (entry.getSmallImageFileEntryId() > 0) { <line6> FileEntry fileEntry = <line7> _portletFileRepository.getPortletFileEntry(entry.getSmallImageFileEntryId()); <line8> StagedModelDataHandlerUtil.exportReferenceStagedModel( <line9> portletDataContext, entry, fileEntry, PortletDataContext.REFERENCE_TYPE_WEAK); <line10> } else if (entry.getSmallImageId() > 0) { <line11> Image smallImage = _imageLocalService.fetchImage(entry.getSmallImageId()); <line12> if ((smallImage != null) && (smallImage.getTextObj() != null)) { <line13> String smallImagePath = <line14> ExportImportPathUtil.getModelPath( <line15> entry, smallImage.getImageId() + StringPool.PERIOD + smallImage.getType()); <line16> entryElement.addAttribute(""small-image-path"", smallImagePath); <line17> entry.setSmallImageType(smallImage.getType()); <line18> portletDataContext.addZipEntry(smallImagePath, smallImage.getTextObj()); <line19> } else { <line20> if (log.isWarnEnabled()) { <line21> StringBundler sb = new StringBundler(4); <line22> sb.append(""Unable to export small image ""); <line23> sb.append(entry.getSmallImageId()); <line24> sb.append("" to blogs entry ""); <line25> sb.append(entry.getEntryId()); <line26> } <line27> entry.setSmallImage(false); <line28> entry.setSmallImageId(0); <line29> } <line30> } <line31> } <line32> if (entry.getCoverImageFileEntryId() != 0) { <line33> FileEntry fileEntry = <line34> _portletFileRepository.getPortletFileEntry(entry.getCoverImageFileEntryId()); <line35> StagedModelDataHandlerUtil.exportReferenceStagedModel( <line36> portletDataContext, entry, fileEntry, PortletDataContext.REFERENCE_TYPE_WEAK); <line37> } <line38> _exportFriendlyURLEntries(portletDataContext, entry); <line39> String content = <line40> _exportImportContentProcessor.replaceExportContentReferences( <line41> portletDataContext, <line42> entry, <line43> entry.getContent(), <line44> portletDataContext.getBooleanParameter(""blogs"", ""referenced-content""), <line45> true); <line46> entry.setContent(content); <line47> _exportAssetDisplayPage(portletDataContext, entry); <line48> portletDataContext.addClassedModel( <line49> entryElement, ExportImportPathUtil.getModelPath(entry), entry); <line50> } <line51> } <line52> "	<line26>            log.warn(sb.toString());	task4	
public class A { <line0> private void closeMoveOutNamespace( <line1> String zkClusterKey, <line2> List<NamespaceZkClusterMapping> nsZkClusterMappingList, <line3> List<RegistryCenterConfiguration> regCenterConfList) { <line4> if (regCenterConfList == null) { <line5> return; <line6> } <line7> Iterator<RegistryCenterConfiguration> regIter = regCenterConfList.iterator(); <line8> while (regIter.hasNext()) { <line9> RegistryCenterConfiguration conf = regIter.next(); <line10> String namespace = conf.getNamespace(); <line11> String nns = conf.getNameAndNamespace(); <line12> boolean include = false; <line13> if (nsZkClusterMappingList != null) { <line14> for (NamespaceZkClusterMapping mapping : nsZkClusterMappingList) { <line15> if (namespace.equals(mapping.getNamespace())) { <line16> include = true; <line17> break; <line18> } <line19> } <line20> } <line21> if (!include) { <line22> synchronized (getNnsLock(nns)) { <line23> regIter.remove(); <line24> closeNamespace(nns); <line25> } <line26> } <line27> } <line28> } <line29> } <line30> 	"<line25>          log.info(""closed the moved namespace info, namespace is {}, old zkClusterKey is {}"",namespace,zkClusterKey);"	task4	
"public class A { <line0> @Override <line1> public ContentRecordVO loadContentVO(String id) throws ApsSystemException { <line2> try { <line3> return (ContentRecordVO) this.getContentDAO().loadEntityRecord(id); <line4> } catch (Throwable t) { <line5> throw new ApsSystemException(""Error while loading content vo : id "" + id, t); <line6> } <line7> } <line8> } <line9> "	"<line5>      logger.error(""Error while loading content vo : id {}"", id, t);"	task4	
"public class A { <line0> public static void initDataSources(ThirdEyeConfiguration thirdeyeConfig) { <line1> try { <line2> URL dataSourcesUrl = thirdeyeConfig.getDataSourcesAsUrl(); <line3> DataSources dataSources = DataSourcesLoader.fromDataSourcesUrl(dataSourcesUrl); <line4> if (dataSources == null) { <line5> throw new IllegalStateException( <line6> ""Could not create data sources from path "" + dataSourcesUrl); <line7> } <line8> Map<String, ThirdEyeDataSource> thirdEyeDataSourcesMap = <line9> DataSourcesLoader.getDataSourceMap(dataSources); <line10> QueryCache queryCache = <line11> new QueryCache(thirdEyeDataSourcesMap, Executors.newCachedThreadPool()); <line12> ThirdEyeCacheRegistry.getInstance().registerQueryCache(queryCache); <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> "	"<line14>      LOGGER.info(""Caught exception while initializing caches"", e);"	task4	
public class A { <line0> public void updateStatus(WorkerHeartbeat heartbeat) { <line1> String workerAddress = heartbeat.getWorkerAddress(); <line2> long heartbeatTime = heartbeat.getHeartbeatTime(); <line3> WorkerInfo workerInfo = <line4> address2WorkerInfo.computeIfAbsent( <line5> workerAddress, <line6> ignore -> { <line7> WorkerInfo wf = new WorkerInfo(); <line8> wf.refresh(heartbeat); <line9> return wf; <line10> }); <line11> long oldTime = workerInfo.getLastActiveTime(); <line12> if (heartbeatTime < oldTime) { <line13> return; <line14> } <line15> workerInfo.refresh(heartbeat); <line16> List<DeployedContainerInfo> containerInfos = heartbeat.getContainerInfos(); <line17> if (!CollectionUtils.isEmpty(containerInfos)) { <line18> containerInfos.forEach( <line19> containerInfo -> { <line20> Map<String, DeployedContainerInfo> infos = <line21> containerId2Infos.computeIfAbsent( <line22> containerInfo.getContainerId(), ignore -> Maps.newConcurrentMap()); <line23> infos.put(workerAddress, containerInfo); <line24> }); <line25> } <line26> } <line27> } <line28> 	"<line13>      log.warn(""[ClusterStatusHolder-{}] receive the expired heartbeat from {}, serverTime: {},""+ "" heartTime: {}"",appName,heartbeat.getWorkerAddress(),System.currentTimeMillis(),heartbeat.getHeartbeatTime());"	task4	
"public class A { <line0> @Override <line1> public void emit(Event event) { <line2> if (!started.get()) { <line3> throw new ISE(""Emit called unexpectedly before service start""); <line4> } <line5> if (event instanceof ServiceMetricEvent) { <line6> OpentsdbEvent opentsdbEvent = converter.convert((ServiceMetricEvent) event); <line7> if (opentsdbEvent != null) { <line8> sender.enqueue(opentsdbEvent); <line9> } else { <line10> } <line11> } <line12> } <line13> } <line14> "	"<line10>        log.debug(""Metric=[%s] has not been configured to be emitted to opentsdb"",((ServiceMetricEvent) event).getMetric());"	task4	
"public class A { <line0> public static List<Folder> getFolders(HttpServletRequest httpServletRequest) <line1> throws PortalException { <line2> long[] folderIds = ParamUtil.getLongValues(httpServletRequest, ""rowIdsFolder""); <line3> List<Folder> folders = new ArrayList<>(); <line4> for (long folderId : folderIds) { <line5> try { <line6> folders.add(DLAppServiceUtil.getFolder(folderId)); <line7> } catch (NoSuchFolderException noSuchFolderException) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> return folders; <line13> } <line14> } <line15> "	<line9>          log.debug(noSuchFolderException, noSuchFolderException);	task4	
"public class A { <line0> @Test <line1> public void testPrepare() { <line2> TimeHelper.setProvider(new FixedTimeProvider(12345l)); <line3> List<CipherSuite> suiteList = new LinkedList<>(); <line4> context.getConfig().setHighestProtocolVersion(ProtocolVersion.TLS12); <line5> suiteList.add(CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA256); <line6> suiteList.add(CipherSuite.TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256); <line7> suiteList.add(CipherSuite.TLS_DHE_PSK_WITH_AES_128_GCM_SHA256); <line8> context.setClientSupportedCiphersuites(suiteList); <line9> List<CipherSuite> ourSuiteList = new LinkedList<>(); <line10> ourSuiteList.add(CipherSuite.TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256); <line11> List<CompressionMethod> ourCompressionList = new LinkedList<>(); <line12> ourCompressionList.add(CompressionMethod.LZS); <line13> context.getConfig().setDefaultClientSupportedCiphersuites(ourSuiteList); <line14> context.getConfig().setDefaultServerSupportedCompressionMethods(ourCompressionList); <line15> context.setHighestClientProtocolVersion(ProtocolVersion.TLS11); <line16> List<CompressionMethod> compressionList = new LinkedList<>(); <line17> compressionList.add(CompressionMethod.NULL); <line18> compressionList.add(CompressionMethod.LZS); <line19> context.setClientSupportedCompressions(compressionList); <line20> context.getConfig().setDefaultServerSessionId(new byte[] {0, 1, 2, 3, 4, 5}); <line21> preparator.prepare(); <line22> assertArrayEquals(ProtocolVersion.TLS11.getValue(), message.getProtocolVersion().getValue()); <line23> assertArrayEquals(ArrayConverter.longToUint32Bytes(12345l), message.getUnixTime().getValue()); <line24> assertArrayEquals( <line25> ArrayConverter.concatenate( <line26> ArrayConverter.longToUint32Bytes(12345l), <line27> ArrayConverter.hexStringToByteArray( <line28> ""60B420BB3851D9D47ACB933DBE70399BF6C92DA33AF01D4FB770E98C"")), <line29> message.getRandom().getValue()); <line30> assertArrayEquals( <line31> ArrayConverter.hexStringToByteArray(""000102030405""), message.getSessionId().getValue()); <line32> assertTrue(6 == message.getSessionIdLength().getValue()); <line33> assertTrue(message.getExtensionBytes().getValue().length == 0); <line34> assertTrue(0 == message.getExtensionsLength().getValue()); <line35> } <line36> } <line37> "	<line24>    LOGGER.info(ArrayConverter.bytesToHexString(message.getRandom().getValue()));	task4	
public class A { <line0> private void updateRack() { <line1> Rack rack = this.rackClient.getByName(RACK_NAME).get(0); <line2> String resourceId = rack.getResourceId(); <line3> rack.setThermalLimit(Integer.valueOf(1000)); <line4> Rack updatedRack = this.rackClient.update(resourceId, rack); <line5> } <line6> } <line7> 	"<line5>    LOGGER.info(""Rack object returned to client : "" + updatedRack.toJsonString());"	task4	
public class A { <line0> private RegionLocations locateRowBeforeInCache( <line1> TableCache tableCache, TableName tableName, byte[] row, int replicaId) { <line2> boolean isEmptyStopRow = isEmptyStopRow(row); <line3> Map.Entry<byte[], RegionLocations> entry = <line4> isEmptyStopRow ? tableCache.cache.lastEntry() : tableCache.cache.lowerEntry(row); <line5> if (entry == null) { <line6> recordCacheMiss(); <line7> return null; <line8> } <line9> RegionLocations locs = entry.getValue(); <line10> HRegionLocation loc = locs.getRegionLocation(replicaId); <line11> if (loc == null) { <line12> recordCacheMiss(); <line13> return null; <line14> } <line15> if (isEmptyStopRow(loc.getRegion().getEndKey()) <line16> || (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) { <line17> if (LOG.isTraceEnabled()) { <line18> } <line19> recordCacheHit(); <line20> return locs; <line21> } else { <line22> recordCacheMiss(); <line23> return null; <line24> } <line25> } <line26> } <line27> 	"<line18>        LOG.trace(""Found {} in cache for {}, row='{}', locateType={}, replicaId={}"",loc,tableName,Bytes.toStringBinary(row),RegionLocateType.BEFORE,replicaId);"	task4	
public class A { <line0> public void startBackupExclusiveOperation() throws IOException { <line1> try (Table table = connection.getTable(tableName)) { <line2> Put put = createPutForStartBackupSession(); <line3> if (!table <line4> .checkAndMutate(ACTIVE_SESSION_ROW, SESSIONS_FAMILY) <line5> .qualifier(ACTIVE_SESSION_COL) <line6> .ifNotExists() <line7> .thenPut(put)) { <line8> if (!table <line9> .checkAndMutate(ACTIVE_SESSION_ROW, SESSIONS_FAMILY) <line10> .qualifier(ACTIVE_SESSION_COL) <line11> .ifEquals(ACTIVE_SESSION_NO) <line12> .thenPut(put)) { <line13> throw new ExclusiveOperationException(); <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	"<line1>    LOG.debug(""Start new backup exclusive operation"");"	task4	
"public class A { <line0> public void sendEventJson(String json, String jsonEventTypeName) { <line1> if (json == null) { <line2> throw new IllegalArgumentException(""Invalid null event object""); <line3> } <line4> if ((ExecutionPathDebugLog.isDebugEnabled) && (log.isDebugEnabled())) { <line5> } <line6> if (inboundThreading) { <line7> services <line8> .getThreadingService() <line9> .submitInbound(new InboundUnitSendJson(json, jsonEventTypeName, this, services)); <line10> } else { <line11> EventBean eventBean = wrapEventJson(json, jsonEventTypeName); <line12> processWrappedEvent(eventBean); <line13> } <line14> } <line15> } <line16> "	"<line5>      log.debug("".sendEventJson Processing event "" + json);"	task4	
public class A { <line0> @Override <line1> public byte[] serializeHandshakeMessageContent() { <line2> if (!version.isSSL()) { <line3> writeSerializedPublicKeyLength(msg); <line4> } <line5> writeSerializedPublickey(msg); <line6> return getAlreadySerialized(); <line7> } <line8> } <line9> 	"<line2>    LOGGER.debug(""Serializing RSAClientKeyExchangeMessage"");"	task4	
"public class A { <line0> public static java.util.List<com.liferay.commerce.tax.model.CommerceTaxMethod> <line1> getCommerceTaxMethods(HttpPrincipal httpPrincipal, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceTaxMethodServiceUtil.class, <line7> ""getCommerceTaxMethods"", <line8> _getCommerceTaxMethodsParameterTypes6); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.commerce.tax.model.CommerceTaxMethod>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
public class A { <line0> @Test <line1> public void test_00() { <line2> initRand(); <line3> for (int len = 1; len < 1000; len++) DnaSequenceBaseAt(len); <line4> } <line5> } <line6> 	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> public void terminated(TaskAttemptID taskid) { <line1> TaskStatus status = taskStatuses.get(taskid); <line2> status.setRunState(TaskStatus.State.FAILED); <line3> activeTasks.remove(taskid); <line4> } <line5> } <line6> 	"<line1>    LOG.info(""Task '"" + taskid.getTaskID().toString() + ""' has failed."");"	task4	
public class A { <line0> private boolean importImpersonators( <line1> @NotNull Tree parent, <line2> @NotNull Authorizable a, <line3> @NotNull PropInfo propInfo, <line4> @NotNull PropertyDefinition def) { <line5> if (a.isGroup() || !isValid(def, MIX_REP_IMPERSONATABLE, true)) { <line6> return false; <line7> } <line8> referenceTracker.processedReference( <line9> new Impersonators(parent.getPath(), propInfo.getTextValues())); <line10> return true; <line11> } <line12> } <line13> 	"<line6>      log.warn(""Unexpected authorizable or definition for property rep:impersonators"");"	task4	
public class A { <line0> public static com.liferay.oauth2.provider.model.OAuth2AuthorizationSoap[] <line1> getApplicationOAuth2Authorizations( <line2> long oAuth2ApplicationId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator< <line6> com.liferay.oauth2.provider.model.OAuth2Authorization> <line7> orderByComparator) <line8> throws RemoteException { <line9> try { <line10> java.util.List<com.liferay.oauth2.provider.model.OAuth2Authorization> returnValue = <line11> OAuth2AuthorizationServiceUtil.getApplicationOAuth2Authorizations( <line12> oAuth2ApplicationId, start, end, orderByComparator); <line13> return com.liferay.oauth2.provider.model.OAuth2AuthorizationSoap.toSoapModels(returnValue); <line14> } catch (Exception exception) { <line15> throw new RemoteException(exception.getMessage()); <line16> } <line17> } <line18> } <line19> 	<line15>      log.error(exception, exception);	task4	
"public class A { <line0> @Override <line1> public @Nullable CounterUpdate transform(MonitoringInfo monitoringInfo) { <line2> Optional<String> validationResult = validate(monitoringInfo); <line3> if (validationResult.isPresent()) { <line4> return null; <line5> } <line6> DistributionData data = decodeInt64Distribution(monitoringInfo.getPayload()); <line7> final String pcollectionId = <line8> monitoringInfo.getLabelsMap().get(MonitoringInfoConstants.Labels.PCOLLECTION); <line9> final String pcollectionName = pcollectionIdToNameContext.get(pcollectionId).userName(); <line10> String counterName = pcollectionName + ""-MeanByteCount""; <line11> NameAndKind name = new NameAndKind(); <line12> name.setName(counterName).setKind(Kind.MEAN.toString()); <line13> return new CounterUpdate() <line14> .setNameAndKind(name) <line15> .setCumulative(true) <line16> .setIntegerMean( <line17> new IntegerMean() <line18> .setSum(longToSplitInt(data.sum())) <line19> .setCount(longToSplitInt(data.count()))); <line20> } <line21> } <line22> "	<line4>      LOG.debug(validationResult.get());	task4	
public class A { <line0> @Override <line1> public View onCreateView( <line2> LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <line3> try { <line4> isSystemUpdatingWebView = false; <line5> return inflater.inflate(R.layout.fragment_authenticated_webview, container, false); <line6> } catch (InflateException e) { <line7> isSystemUpdatingWebView = true; <line8> return inflater.inflate(R.layout.content_error, container, false); <line9> } <line10> } <line11> } <line12> 	<line7>      logger.error(e, true);	task4	
public class A { <line0> public static void setTableLayout( <line1> final CuratorFramework zkClient, final KijiURI tableURI, final String layoutID) <line2> throws IOException { <line3> final String path = ZooKeeperUtils.getTableLayoutFile(tableURI).getPath(); <line4> try { <line5> zkClient.newNamespaceAwareEnsurePath(path).ensure(zkClient.getZookeeperClient()); <line6> zkClient.setData().forPath(path, Bytes.toBytes(layoutID)); <line7> } catch (Exception e) { <line8> wrapAndRethrow(e); <line9> } <line10> } <line11> } <line12> 	"<line7>      LOG.debug(""Updated layout ID for table {} to {}."", tableURI, layoutID);"	task4	
public class A { <line0> @Override <line1> public void handleMessage(Message msg) { <line2> if (msg.what == MSG_TYPE_TICK) { <line3> if (callback != null) { <line4> if (player != null && player.isPlaying()) { <line5> long pos = player.getCurrentPosition(); <line6> if (pos > 0 && pos != lastSavedPosition) { <line7> lastSavedPosition = pos; <line8> callback.saveCurrentPlaybackPosition(pos); <line9> } <line10> } <line11> } <line12> sendEmptyMessageDelayed(MSG_TYPE_TICK, DELAY_TIME_MS); <line13> } <line14> } <line15> } <line16> 	"<line9>            logger.debug(""Current position saved: "" + pos);"	task4	
public class A { <line0> public void extract(IItem evidence) { <line1> InputStream is = null; <line2> try { <line3> is = evidence.getBufferedStream(); <line4> extractFile(is, evidence, null); <line5> } catch (IOException e) { <line6> } finally { <line7> IOUtil.closeQuietly(is); <line8> } <line9> } <line10> } <line11> 	"<line6>      LOGGER.warn(""{} Error exporting {} \t{}"",Thread.currentThread().getName(),evidence.getPath(),e.toString());"	task4	
"public class A { <line0> @Override <line1> public void initExtensions(PluginContext ctx, ExtensionRegistry registry) { <line2> IgniteConfiguration igniteCfg = ctx.igniteConfiguration(); <line3> log = ctx.log(getClass()); <line4> if (igniteCfg.getPluginConfigurations() != null) { <line5> for (PluginConfiguration pluginCfg : igniteCfg.getPluginConfigurations()) { <line6> if (pluginCfg instanceof PageMemoryTrackerConfiguration) { <line7> PageMemoryTrackerConfiguration cfg = (PageMemoryTrackerConfiguration) pluginCfg; <line8> plugin = new PageMemoryTracker(ctx, cfg); <line9> if (cfg.isEnabled() && !CU.isPersistenceEnabled(igniteCfg)) { <line10> log.warning( <line11> ""Page memory tracker plugin enabled, but there are no persistable data regions in"" <line12> + "" configuration. Tracker will be disabled.""); <line13> } <line14> return; <line15> } <line16> } <line17> } <line18> if (Boolean.getBoolean(IGNITE_ENABLE_PAGE_MEMORY_TRACKER) <line19> && CU.isPersistenceEnabled(igniteCfg)) { <line20> plugin = <line21> new PageMemoryTracker( <line22> ctx, <line23> new PageMemoryTrackerConfiguration() <line24> .setEnabled(true) <line25> .setCheckPagesOnCheckpoint(true)); <line26> } else plugin = new PageMemoryTracker(ctx, null); <line27> } <line28> } <line29> "	"<line26>      log.info(""PageMemory tracking enabled by system property."");"	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public <T extends Page> List<T> getVersionHistory(final String pageName) { <line3> List<T> c = null; <line4> try { <line5> if (pageExists(pageName)) { <line6> c = (List<T>) m_provider.getVersionHistory(pageName); <line7> } <line8> if (c == null) { <line9> c = (List<T>) m_engine.getManager(AttachmentManager.class).getVersionHistory(pageName); <line10> } <line11> } catch (final ProviderException e) { <line12> } <line13> return c; <line14> } <line15> } <line16> "	"<line12>      LOG.error(""ProviderException requesting version history for "" + pageName, e);"	task4	
public class A { <line0> public Form build() { <line1> Form form = new Form(mode); <line2> if (groupedPropertyAccessors == null) { <line3> configReflectiveFields(); <line4> } <line5> List<PropertyAccessor> allPropertyAccessors = new ArrayList<PropertyAccessor>(); <line6> for (ArrayList<PropertyAccessor> group : groupedPropertyAccessors) { <line7> allPropertyAccessors.addAll(group); <line8> } <line9> removeUnusedSelectionProviders(allPropertyAccessors); <line10> Map<String, Field> fieldMap = new HashMap<String, Field>(); <line11> for (int i = 0; i < groupedPropertyAccessors.size(); i++) { <line12> buildFieldGroup(form, i, fieldMap); <line13> } <line14> for (Map.Entry<String[], SelectionProvider> current : selectionProviders.entrySet()) { <line15> String[] fieldNames = current.getKey(); <line16> SelectionProvider selectionProvider = current.getValue(); <line17> SelectionModel selectionModel = selectionProvider.createSelectionModel(); <line18> SelectField previousField = null; <line19> for (int i = 0; i < fieldNames.length; i++) { <line20> SelectField selectField = (SelectField) fieldMap.get(fieldNames[i]); <line21> selectField.setSelectionModel(selectionModel); <line22> selectField.setSelectionModelIndex(i); <line23> if (previousField != null) { <line24> selectField.setPreviousSelectField(previousField); <line25> previousField.setNextSelectField(selectField); <line26> } <line27> previousField = selectField; <line28> } <line29> } <line30> return form; <line31> } <line32> } <line33> 	"<line1>    logger.debug(""build"");"	task4	
public class A { <line0> @Override <line1> public boolean moveNext() { <line2> currentRow = null; <line3> if (iteratorBreadcrumb.isEmpty()) { <line4> ProcessGroupStatus rootStatus = context.getEventAccess().getControllerStatus(); <line5> iteratorBreadcrumb.push(rootStatus.getProcessGroupStatus().iterator()); <line6> processorStatusIterator = rootStatus.getProcessorStatus().iterator(); <line7> } <line8> final ProcessorStatus connectionStatus = getNextProcessorStatus(); <line9> if (connectionStatus == null) { <line10> close(); <line11> try { <line12> onFinish(); <line13> } catch (final Exception e) { <line14> } <line15> return false; <line16> } <line17> currentRow = filterColumns(connectionStatus); <line18> recordsRead++; <line19> return true; <line20> } <line21> } <line22> 	"<line14>        logger.error(""Failed to perform tasks when enumerator was finished"", e);"	task4	
public class A { <line0> private static boolean canMove(UIComponent child, final UIContainer parent) { <line1> if (parent instanceof org.exoplatform.portal.webui.container.UIContainer) { <line2> org.exoplatform.portal.webui.container.UIContainer targetContainer = <line3> (org.exoplatform.portal.webui.container.UIContainer) parent; <line4> if (child instanceof UIPortlet<?, ?>) { <line5> return targetContainer.hasMoveAppsPermission(); <line6> } else if (child instanceof org.exoplatform.portal.webui.container.UIContainer) { <line7> return targetContainer.hasMoveContainersPermission(); <line8> } else if (child instanceof org.exoplatform.portal.webui.page.UIPageBody) { <line9> return true; <line10> } else { <line11> return false; <line12> } <line13> } else { <line14> return false; <line15> } <line16> } <line17> } <line18> 	"<line11>        log.warn(""Unexpected uiSource type '"" + child.getClass().getName() + ""'."");"	task4	
"public class A { <line0> private Response runFailover(SingularityUser user) { <line1> CompletableFuture.runAsync( <line2> () -> { <line3> abort.abort( <line4> AbortReason.MANUAL, <line5> Optional.of( <line6> new RuntimeException(String.format(""Forced failover by %s"", user.getId())))); <line7> }, <line8> Executors.newSingleThreadExecutor()); <line9> return Response.ok().build(); <line10> } <line11> } <line12> "	"<line3>          LOG.warn(""Failover triggered by {}"", user.getId());"	task4	
public class A { <line0> @Override <line1> public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) { <line2> try { <line3> sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS); <line4> } catch (InterruptedException e) { <line5> Thread.currentThread().interrupt(); <line6> return false; <line7> } <line8> return true; <line9> } <line10> } <line11> 	"<line6>      log.warn(""Error occurred while sleeping"", e);"	task4	
public class A { <line0> private String convertSourceFileName(DataType sourceFileName) { <line1> if (sourceFileName instanceof Text) { <line2> return sourceFileName.toString(); <line3> } else { <line4> return sourceFileName.toString(); <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.warn(MessageFormat.format(this.getActionExecution().getAction().getType()+ "" does not accept {0} as type for sourceFileName"",sourceFileName.getClass()));"	task4	
public class A { <line0> public void shutdown() { <line1> try { <line2> ldapService.stop(); <line3> service.shutdown(); <line4> if (workingDirectory.exists()) { <line5> FileUtils.deleteDirectory(workingDirectory); <line6> } <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	"<line8>      LOG.error(""exception while shutting down ldap"", e);"	task4	
public class A { <line0> public FeedMessage getFeedMessage(final String urlString, int timeoutSeconds) <line1> throws ClientProtocolException, IOException { <line2> CloseableHttpResponse response = null; <line3> try { <line4> response = getResponse(urlString, timeoutSeconds); <line5> HttpEntity entity = getEntity(response); <line6> InputStream content = entity.getContent(); <line7> try { <line8> FeedMessage msg = FeedMessage.parseFrom(content); <line9> return msg; <line10> } finally { <line11> content.close(); <line12> } <line13> } catch (Exception e) { <line14> throw e; <line15> } finally { <line16> if (response != null) { <line17> response.close(); <line18> } <line19> } <line20> } <line21> } <line22> 	"<line14>      log.error(""Error handling url: "" + urlString, e);"	task4	
"public class A { <line0> public static List<String> getVMCommand( <line1> Configuration conf, ApplicationId appid, PSAttemptId psAttemptId) { <line2> Vector<String> vargs = new Vector<String>(8); <line3> vargs.add(Environment.JAVA_HOME.$() + ""/bin/java""); <line4> String javaOpts = getChildJavaOpts(conf, appid, psAttemptId); <line5> String[] javaOptsSplit = javaOpts.split("" ""); <line6> for (int i = 0; i < javaOptsSplit.length; i++) { <line7> vargs.add(javaOptsSplit[i]); <line8> } <line9> Path childTmpDir = new Path(Environment.PWD.$(), YarnConfiguration.DEFAULT_CONTAINER_TEMP_DIR); <line10> vargs.add(""-Djava.io.tmpdir="" + childTmpDir); <line11> long logSize = 0; <line12> setupLog4jProperties(conf, vargs, logSize); <line13> String psClassName = conf.get(AngelConf.ANGEL_PS_CLASS, AngelConf.DEFAULT_ANGEL_PS_CLASS); <line14> vargs.add(psClassName); <line15> vargs.add(""1>"" + getTaskLogFile(TaskLog.LogName.STDOUT)); <line16> vargs.add(""2>"" + getTaskLogFile(TaskLog.LogName.STDERR)); <line17> StringBuilder mergedCommand = new StringBuilder(); <line18> for (CharSequence str : vargs) { <line19> mergedCommand.append(str).append("" ""); <line20> } <line21> Vector<String> vargsFinal = new Vector<String>(1); <line22> vargsFinal.add(mergedCommand.toString()); <line23> return vargsFinal; <line24> } <line25> } <line26> "	"<line23>    LOG.info(""Command to launch container for PS is : "" + mergedCommand);"	task4	
"public class A { <line0> @POST <line1> @Path(""submitAndSchedule/{extension-name}"") <line2> @Consumes({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.MULTIPART_FORM_DATA}) <line3> @Produces({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON}) <line4> public APIResult submitAndSchedule( <line5> @PathParam(""extension-name"") String extensionName, <line6> @Context HttpServletRequest request, <line7> @DefaultValue("""") @QueryParam(""doAs"") String doAsUser, <line8> @QueryParam(""jobName"") String jobName, <line9> @FormDataParam(""processes"") List<FormDataBodyPart> processForms, <line10> @FormDataParam(""feeds"") List<FormDataBodyPart> feedForms, <line11> @FormDataParam(""config"") InputStream config) { <line12> throw FalconWebException.newAPIException( <line13> ""submitAndSchedule is not supported on Server. Please run your "" + ""operation on Prism.""); <line14> } <line15> } <line16> "	"<line12>    LOG.error(""submitAndSchedule is not supported on Server.Please run your operation on Prism "");"	task4	
public class A { <line0> @Override <line1> protected void setupMocks() { <line2> Mockito.when(dockerClient.logContainerCmd(anyString())).thenReturn(mockObject); <line3> Mockito.when(mockObject.exec(any())).thenReturn(callback); <line4> try { <line5> Mockito.when(callback.awaitCompletion()).thenReturn(callback); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOG.warn(""Interrupted while setting up mocks"", e);"	task4	
public class A { <line0> public void remove(String uuid) { <line1> try { <line2> CnATreeElement element = getElement(uuid); <line3> if (element != null) { <line4> remove(element); <line5> } <line6> } catch (Exception t) { <line7> } <line8> } <line9> } <line10> 	"<line7>      LOG.error(""Error while removing object"", t);"	task4	
"public class A { <line0> public String getGitPath(String path) { <line1> Path gitPath = Paths.get(path); <line2> gitPath = gitPath.normalize(); <line3> try { <line4> gitPath = Paths.get(FILE_SEPARATOR).relativize(gitPath); <line5> } catch (IllegalArgumentException e) { <line6> } <line7> if (StringUtils.isEmpty(gitPath.toString())) { <line8> return "".""; <line9> } <line10> String toRet = gitPath.toString(); <line11> toRet = FilenameUtils.separatorsToUnix(toRet); <line12> return toRet; <line13> } <line14> } <line15> "	"<line6>      logger.debug(""Path: "" + path + "" is already relative path."");"	task4	
"public class A { <line0> @After <line1> public void tearDown() { <line2> .$(""Tearing down test "") <line3> .$(getClass().getSimpleName()) <line4> .$('#') <line5> .$(testName.getMethodName()) <line6> .$(); <line7> engine.freeTableId(); <line8> engine.clear(); <line9> TestUtils.removeTestPath(root); <line10> configOverrideMaxUncommittedRows = -1; <line11> configOverrideCommitLag = -1; <line12> currentMicros = -1; <line13> } <line14> } <line15> "	<line2>    LOG.info()	task4	
"public class A { <line0> @Override <line1> protected boolean matchedWhitelist(MailAddress recipientMailAddress, Mail mail) <line2> throws MessagingException { <line3> Connection conn = null; <line4> PreparedStatement selectStmt = null; <line5> ResultSet selectRS = null; <line6> try { <line7> String recipientUser = recipientMailAddress.getLocalPart().toLowerCase(Locale.US); <line8> String recipientHost = recipientMailAddress.getDomain().asString(); <line9> if (conn == null) { <line10> conn = datasource.getConnection(); <line11> } <line12> List<String> nets = new ArrayList<>(); <line13> try { <line14> if (selectStmt == null) { <line15> selectStmt = conn.prepareStatement(selectNetworks); <line16> } <line17> selectStmt.setString(1, recipientUser); <line18> selectStmt.setString(2, recipientHost); <line19> selectRS = selectStmt.executeQuery(); <line20> while (selectRS.next()) { <line21> nets.add(selectRS.getString(1)); <line22> } <line23> } finally { <line24> jdbcUtil.closeJDBCResultSet(selectRS); <line25> jdbcUtil.closeJDBCStatement(selectStmt); <line26> } <line27> NetMatcher matcher = new NetMatcher(nets, dns); <line28> boolean matched = matcher.matchInetNetwork(mail.getRemoteAddr()); <line29> if (!matched) { <line30> try { <line31> selectStmt = conn.prepareStatement(selectNetworks); <line32> selectStmt.setString(1, ""*""); <line33> selectStmt.setString(2, recipientHost); <line34> selectRS = selectStmt.executeQuery(); <line35> nets = new ArrayList<>(); <line36> while (selectRS.next()) { <line37> nets.add(selectRS.getString(1)); <line38> } <line39> } finally { <line40> jdbcUtil.closeJDBCResultSet(selectRS); <line41> jdbcUtil.closeJDBCStatement(selectStmt); <line42> } <line43> matcher = new NetMatcher(nets, dns); <line44> matched = matcher.matchInetNetwork(mail.getRemoteAddr()); <line45> } <line46> return matched; <line47> } catch (SQLException sqle) { <line48> throw new MessagingException(""Exception thrown"", sqle); <line49> } finally { <line50> theJDBCUtil.closeJDBCConnection(conn); <line51> } <line52> } <line53> } <line54> "	"<line48>      LOGGER.error(""Error accessing database"", sqle);"	task4	
public class A { <line0> @Override <line1> public Entity createApplicationV2( <line2> String orgName, <line3> String name, <line4> UUID applicationId, <line5> Map<String, Object> properties, <line6> boolean forMigration) <line7> throws Exception { <line8> String appName = buildAppName(orgName, name); <line9> final UUID appId = applicationIdCache.getApplicationId(appName); <line10> if (appId != null) { <line11> throw new ApplicationAlreadyExistsException(name); <line12> } <line13> applicationId = applicationId == null ? UUIDGenerator.newTimeUUID() : applicationId; <line14> if (logger.isDebugEnabled()) { <line15> } <line16> return initializeApplicationV2(orgName, applicationId, appName, properties, forMigration); <line17> } <line18> } <line19> 	"<line15>      logger.debug(""New application orgName {} orgAppName {} id {} "",orgName,name,applicationId.toString());"	task4	
public class A { <line0> @Override <line1> public void handleError(@Nullable Throwable cause) { <line2> Closeables.closeQuietly(responseInfo); <line3> } <line4> } <line5> 	"<line2>    LOG.warn(""Exception raised when handling request to {}"", url, cause);"	task4	
"public class A { <line0> @Override <line1> public void stop(Platform platform) throws Exception { <line2> if (!running.compareAndSet(true, false)) { <line3> throw new IllegalStateException(""ConsumeBenchWorker is not running.""); <line4> } <line5> doneFuture.complete(""""); <line6> executor.shutdownNow(); <line7> executor.awaitTermination(1, TimeUnit.DAYS); <line8> consumer.close(); <line9> this.consumer = null; <line10> this.executor = null; <line11> this.statusUpdater = null; <line12> this.statusUpdaterFuture = null; <line13> this.workerStatus = null; <line14> this.doneFuture = null; <line15> } <line16> } <line17> "	"<line5>    log.info(""{}: Deactivating ConsumeBenchWorker."", id);"	task4	
public class A { <line0> private JComboBox getOperationsBox() { <line1> JComboBox comboOpe = new JComboBox(); <line2> ArrayList<Operation> opeList = new ArrayList<>(); <line3> try { <line4> opeList.addAll(opeManager.getOperationAdm()); <line5> } catch (OHServiceException ex) { <line6> } <line7> comboOpe.addItem(null); <line8> for (org.isf.operation.model.Operation elem : opeList) { <line9> comboOpe.addItem(elem); <line10> } <line11> comboOpe.setEnabled(true); <line12> return comboOpe; <line13> } <line14> } <line15> 	<line6>      LOGGER.error(ex.getMessage(), ex);	task4	
public class A { <line0> @Override <line1> public void reportFillError(Throwable t) { <line2> lock(); <line3> try { <line4> error = t; <line5> done = true; <line6> pageCount = jasperPrint == null ? 0 : jasperPrint.getPages().size(); <line7> fillHandle = null; <line8> pageCondition.signalAll(); <line9> } finally { <line10> unlock(); <line11> } <line12> } <line13> } <line14> 	"<line2>    log.error(""Error during report execution"", t);"	task4	
"public class A { <line0> @Override <line1> public void start() { <line2> int numCores = Runtime.getRuntime().availableProcessors(); <line3> int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores); <line4> workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000); <line5> initBatchSizes(); <line6> if (workerPool == null) { <line7> workerPool = new WorkerService(""CommitProcWork"", numWorkerThreads, true); <line8> } <line9> stopped = false; <line10> stoppedMainLoop = false; <line11> super.start(); <line12> } <line13> } <line14> "	"<line6>    LOG.info(""Configuring CommitProcessor with {} worker threads."",numWorkerThreads > 0 ? numWorkerThreads : ""no"");"	task4	
public class A { <line0> private void createAuditMessage(AuditMessageType messageType, Map<String, String> data) { <line1> lock.lock(); <line2> try { <line3> AuditMessage auditMessage = new AuditMessage(DateUtil.now(), messageIndex, messageType, data); <line4> messages.add(auditMessage); <line5> messageIndex++; <line6> prune(); <line7> } finally { <line8> lock.unlock(); <line9> } <line10> } <line11> } <line12> 	"<line6>      logger.debug(MessageFormat.format(""Added message: {0}"", auditMessage));"	task4	
public class A { <line0> private void processExecutionChangedEvent(SomfyTahomaEvent event) { <line1> if (FAILED_EVENT.equals(event.getNewState()) || COMPLETED_EVENT.equals(event.getNewState())) { <line2> unregisterExecution(event.getExecId()); <line3> } <line4> } <line5> } <line6> 	"<line2>      logger.debug(""Removing execution id: {}"", event.getExecId());"	task4	
"public class A { <line0> @Override <line1> public int[] executeBatch(final String[] sql) throws SQLException { <line2> if (sql == null || sql.length == 0) { <line3> throw new NullPointerException(""SQL array must not be empty""); <line4> } <line5> if (logger.isDebugEnabled()) { <line6> } <line7> class BatchUpdateStatementCallback implements StatementCallback<int[]>, SqlProvider { <line8> private String currSql; <line9>  <line10> @Override <line11> public int[] doInStatement(final Statement stmt) throws SQLException { <line12> DatabaseMetaData dbmd = stmt.getConnection().getMetaData(); <line13> int[] rowsAffected = new int[sql.length]; <line14> if (dbmd.supportsBatchUpdates()) { <line15> for (String sqlStmt : sql) { <line16> this.currSql = sqlStmt; <line17> stmt.addBatch(sqlStmt); <line18> } <line19> rowsAffected = stmt.executeBatch(); <line20> } else { <line21> for (int i = 0; i < sql.length; i++) { <line22> this.currSql = sql[i]; <line23> if (!stmt.execute(sql[i])) { <line24> rowsAffected[i] = stmt.getUpdateCount(); <line25> } else { <line26> throw new SQLException(""Invalid batch SQL statement: "" + sql[i]); <line27> } <line28> } <line29> } <line30> return rowsAffected; <line31> } <line32>  <line33> @Override <line34> public String getSql() { <line35> return this.currSql; <line36> } <line37> } <line38> return this.execute(new BatchUpdateStatementCallback()); <line39> } <line40> } <line41> "	"<line6>      logger.debug(""Executing SQL batch update of {} statements"", sql.length);"	task4	
"public class A { <line0> protected void createJmxRemoteAccessFile(File directory) throws IOFailure { <line1> File jmxFile = new File(directory, Constants.JMX_ACCESS_FILE_NAME); <line2> try { <line3> PrintWriter jw = new PrintWriter(jmxFile, getTargetEncoding()); <line4> try { <line5> jw.print(ScriptConstants.JMXREMOTE_ACCESS_HEADER); <line6> StringBuilder logins = new StringBuilder(); <line7> logins.append(getMonitorUsername()); <line8> logins.append(getHeritrixUsername()); <line9> jw.print(logins.toString()); <line10> } finally { <line11> jw.close(); <line12> } <line13> } catch (IOException e) { <line14> throw new IOFailure(""Cannot create jmxremote.access file."", e); <line15> } <line16> } <line17> } <line18> "	"<line14>      log.trace(""IOException while creating jmxremote.access file:"", e);"	task4	
"public class A { <line0> @Override <line1> public List<ColumnMetadata> getColumns( <line2> Connection conn, String catalogName, String schemaName, String tableName, String columnName) <line3> throws JdbcMetadataException { <line4> CheckArg.isNotNull(tableName, ""Table name""); <line5> List<ColumnMetadata> columnData = new LinkedList<ColumnMetadata>(); <line6> ResultSet columns = null; <line7> try { <line8> DatabaseMetaData dmd = conn.getMetaData(); <line9> if (catalogName == null) { <line10> catalogName = """"; <line11> } <line12> if (schemaName == null) { <line13> schemaName = """"; <line14> } <line15> columns = dmd.getColumns(catalogName, schemaName, tableName, columnName); <line16> Set<String> columnNames = columnsFor(columns); <line17> while (columns.next()) { <line18> ColumnMetadata column = <line19> new ColumnMetadata( <line20> columns.getString(""COLUMN_NAME""), <line21> columns.getInt(""DATA_TYPE""), <line22> columns.getString(""TYPE_NAME""), <line23> columns.getInt(""COLUMN_SIZE""), <line24> columns.getInt(""DECIMAL_DIGITS""), <line25> columns.getInt(""NUM_PREC_RADIX""), <line26> getNullableBoolean(columns, ""NULLABLE""), <line27> getStringIfPresent(columns, ""REMARKS"", columnNames), <line28> getStringIfPresent(columns, ""COLUMN_DEF"", columnNames), <line29> columns.getInt(""CHAR_OCTET_LENGTH""), <line30> columns.getInt(""ORDINAL_POSITION""), <line31> getStringIfPresent(columns, ""SCOPE_CATLOG"", columnNames), <line32> getStringIfPresent(columns, ""SCOPE_SCHEMA"", columnNames), <line33> getStringIfPresent(columns, ""SCOPE_TABLE"", columnNames), <line34> getIntegerIfPresent(columns, ""SOURCE_DATA_TYPE"", columnNames)); <line35> columnData.add(column); <line36> } <line37> return columnData; <line38> } catch (SQLException se) { <line39> throw new JdbcMetadataException(se); <line40> } finally { <line41> try { <line42> if (columns != null) { <line43> columns.close(); <line44> } <line45> } catch (Exception ignore) { <line46> } <line47> } <line48> } <line49> } <line50> "	"<line46>        LOG.debug(ignore, ""Cannot close columns result set"");"	task4	
public class A { <line0> public void update(Map<String, String> properties) { <line1> if (properties != null) { <line2> if (properties.containsKey(ATTRIBUTE_SEPARATOR)) { <line3> setAttributeSeparator(properties.get(ATTRIBUTE_SEPARATOR)); <line4> } <line5> if (properties.containsKey(EXPANSION_FILE_NAME)) { <line6> setExpansionFileName(properties.get(EXPANSION_FILE_NAME)); <line7> } <line8> } <line9> } <line10> } <line11> 	"<line1>    LOGGER.debug(""Updating Expansion Properties."");"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> @DB <line3> public long submitAsyncJob(final AsyncJob job, final String syncObjType, final long syncObjId) { <line4> try { <line5> @SuppressWarnings(""rawtypes"") <line6> final GenericDao dao = GenericDaoBase.getDao(job.getClass()); <line7> if (dao == null) { <line8> throw new CloudRuntimeException( <line9> String.format( <line10> ""Failed to get dao from job's class=%s, for job id=%d, cmd=%s"", <line11> job.getClass(), job.getId(), job.getCmd())); <line12> } <line13> publishOnEventBus(job, ""submit""); <line14> if (!_vmInstanceDao.lockInLockTable(String.valueOf(syncObjId), VmJobLockTimeout.value())) { <line15> throw new CloudRuntimeException( <line16> ""Failed to acquire lock in submitting async job: "" <line17> + job.getCmd() <line18> + "" with timeout value = "" <line19> + VmJobLockTimeout.value()); <line20> } <line21> try { <line22> return Transaction.execute( <line23> new TransactionCallback<Long>() { <line24> @Override <line25> public Long doInTransaction(TransactionStatus status) { <line26> job.setInitMsid(getMsid()); <line27> dao.persist(job); <line28> syncAsyncJobExecution(job, syncObjType, syncObjId, 1); <line29> return job.getId(); <line30> } <line31> }); <line32> } finally { <line33> _vmInstanceDao.unlockFromLockTable(String.valueOf(syncObjId)); <line34> } <line35> } catch (Exception e) { <line36> String errMsg = <line37> ""Unable to schedule async job for command "" + job.getCmd() + "", unexpected exception.""; <line38> throw new CloudRuntimeException(errMsg); <line39> } <line40> } <line41> } <line42> "	<line38>      logger.warn(errMsg, e);	task4	
public class A { <line0> private Collection<UserGroup> searchBySPARQLQuery(String q, User user) { <line1> Collection<UserGroup> userGroups = new ArrayList<UserGroup>(); <line2> Search search = SearchFactory.create(); <line3> for (String uri : search.searchString(q, null, null, 0, -1).getResults()) { <line4> try { <line5> userGroups.add((UserGroup) READER.read(uri, user, new UserGroup())); <line6> } catch (ImejiException e) { <line7> } <line8> } <line9> return userGroups; <line10> } <line11> } <line12> 	"<line7>        LOGGER.info(""User group with uri "" + uri + "" not found."");"	task4	
"public class A { <line0> @SuppressWarnings(""java:S2274"") <line1> private ByteBuffer fetchResultAsync() throws IOException { <line2> synchronized (fetchResult) { <line3> fetchResult.set(null); <line4> try { <line5> sourceInfo <line6> .getCurAsyncClient(RaftServer.getReadOperationTimeoutMS()) <line7> .fetchSingleSeries(sourceInfo.getHeader(), sourceInfo.getReaderId(), handler); <line8> fetchResult.wait(RaftServer.getReadOperationTimeoutMS()); <line9> } catch (TException e) { <line10> if (!sourceInfo.switchNode(false, lastTimestamp)) { <line11> return null; <line12> } <line13> return fetchResultAsync(); <line14> } catch (InterruptedException e) { <line15> Thread.currentThread().interrupt(); <line16> return null; <line17> } <line18> } <line19> return fetchResult.get(); <line20> } <line21> } <line22> "	"<line16>        logger.warn(""Query {} interrupted"", sourceInfo);"	task4	
"public class A { <line0> @Test <line1> public void testGenerateGroupIdWithEntity() { <line2> app = <line3> ApplicationBuilder.newManagedApp( <line4> EntitySpec.create(TestApplication.class).displayName(""TistApp""), <line5> LocalManagementContextForTests.newInstance()); <line6> TestEntity child = <line7> app.createAndManageChild(EntitySpec.create(TestEntity.class).displayName(""TestEnt"")); <line8> ConfigBag cfg = new ConfigBag().configure(CloudLocationConfig.CALLER_CONTEXT, child); <line9> String result = new BasicCloudMachineNamer().generateNewGroupId(cfg); <line10> Assert.assertTrue(result.length() <= 60); <line11> String user = Strings.maxlen(System.getProperty(""user.name""), 4).toLowerCase(); <line12> Assert.assertTrue(result.indexOf(user) >= 0); <line13> Assert.assertTrue(result.indexOf(""-tistapp-"") >= 0); <line14> Assert.assertTrue(result.indexOf(""-testent-"") >= 0); <line15> Assert.assertTrue(result.indexOf(""-"" + Strings.maxlen(app.getId(), 4).toLowerCase()) >= 0); <line16> Assert.assertTrue(result.indexOf(""-"" + Strings.maxlen(child.getId(), 4).toLowerCase()) >= 0); <line17> } <line18> } <line19> "	"<line10>    log.info(""test entity child group id gives: "" + result);"	task4	
public class A { <line0> @Override <line1> public boolean validate(Message query, Object context) { <line2> DataQuerySnapshot gdqt = (DataQuerySnapshot) query; <line3> SnapshotSchema schema = <line4> (SnapshotSchema) ((SchemaRegistry) context).getSchema(gdqt.getSchemaKeys()); <line5> Set<String> fields = schema.getValuesDescriptor().getFields().getFields(); <line6> if (!fields.containsAll(gdqt.getFields().getFields())) { <line7> return false; <line8> } <line9> if (gdqt.getFields().getFields().isEmpty()) { <line10> gdqt.setFieldsVal(new Fields(fields)); <line11> } <line12> return true; <line13> } <line14> } <line15> 	"<line7>      LOG.error(""Some of the fields in the query {} are not one of the valid fields {}."",fields,gdqt.getFields().getFields());"	task4	
public class A { <line0> public void setProperty(String key, Object value) { <line1> ExecutionContextProperty property = this.properties.get(key); <line2> if (property == null) { <line3> newProperty(key).declare(); <line4> property = this.properties.get(key); <line5> } else if (property.isFinal()) { <line6> throw new PropertyIsFinalException(key); <line7> } <line8> property.setValue(value); <line9> } <line10> } <line11> 	"<line3>      LOGGER.debug(""Implicit declaration of property {}."", key);"	task4	
"public class A { <line0> public boolean dropRole(String roleName) throws SentryClientException { <line1> String dropRoleStmt = ""drop role "" + roleName; <line2> this.sentryJdbcTemplate.execute(dropRoleStmt); <line3> return true; <line4> } <line5> } <line6> "	"<line3>    log.info(""Role  {} dropped successfully "", roleName);"	task4	
"public class A { <line0> @SuppressWarnings(""PMD.ExcessiveParameterList"") <line1> @Override <line2> public void report( <line3> SortedMap<String, Gauge> gauges, <line4> SortedMap<String, Counter> counters, <line5> SortedMap<String, Histogram> histograms, <line6> SortedMap<String, Meter> meters, <line7> SortedMap<String, Timer> timers) { <line8> try { <line9> for (Map.Entry<String, Gauge> entry : gauges.entrySet()) { <line10> publishMetric(entry.getKey(), entry.getValue()); <line11> } <line12> for (Map.Entry<String, Counter> entry : counters.entrySet()) { <line13> publishMetric(entry.getKey(), entry.getValue()); <line14> } <line15> for (Map.Entry<String, Histogram> entry : histograms.entrySet()) { <line16> publishMetric(entry.getKey(), entry.getValue()); <line17> } <line18> for (Map.Entry<String, Meter> entry : meters.entrySet()) { <line19> publishMetric(entry.getKey(), entry.getValue()); <line20> } <line21> for (Map.Entry<String, Timer> entry : timers.entrySet()) { <line22> publishMetric(entry.getKey(), entry.getValue()); <line23> } <line24> } catch (RuntimeException ex) { <line25> } <line26> } <line27> } <line28> "	"<line25>      LOGGER.error(""An exception occurred publishing metrics to Parfait"", ex);"	task4	
"public class A { <line0> private TrackJobResult copyTrack(final Track track) throws WorkflowOperationException { <line1> final Track copiedTrack = (Track) track.clone(); <line2> copiedTrack.setIdentifier(UUID.randomUUID().toString()); <line3> try { <line4> String targetFilename = copiedTrack.getIdentifier(); <line5> final String extension = FilenameUtils.getExtension(track.getURI().getPath()); <line6> if (!extension.isEmpty()) { <line7> targetFilename += ""."" + extension; <line8> } <line9> final URI newUri = <line10> workspace.put( <line11> track.getMediaPackage().getIdentifier().toString(), <line12> copiedTrack.getIdentifier(), <line13> targetFilename, <line14> workspace.read(track.getURI())); <line15> copiedTrack.setURI(newUri); <line16> } catch (IOException | NotFoundException e) { <line17> throw new WorkflowOperationException( <line18> String.format(""Error while copying track %s"", track.getIdentifier()), e); <line19> } <line20> return new TrackJobResult(copiedTrack, 0); <line21> } <line22> } <line23> "	"<line1>    logger.debug(""Create copy of track {}"", track);"	task4	
"public class A { <line0> @Override <line1> public String getLogoutRedirectionUrl(WebContext context) { <line2> init(); <line3> final String state = RandomStringUtils.randomAlphanumeric(10); <line4> final String postLogoutRedirectUri = this.appConfiguration.getOpenIdPostLogoutRedirectUri(); <line5> String idToken = (String) context.getSessionAttribute(getName() + SESSION_ID_TOKEN_PARAMETER); <line6> if (idToken == null) { <line7> idToken = """"; <line8> } <line9> final EndSessionRequest endSessionRequest = <line10> new EndSessionRequest(idToken, postLogoutRedirectUri, state); <line11> final String redirectionUrl = <line12> this.openIdConfiguration.getEndSessionEndpoint() + ""?"" + endSessionRequest.getQueryString(); <line13> return redirectionUrl; <line14> } <line15> } <line16> "	"<line13>    logger.debug(""oxAuth redirection Url: '{}'"", redirectionUrl);"	task4	
public class A { <line0> @Override <line1> public Iterator<ResultsGroup> iterator(long first, long count) { <line2> if (query == null) { <line3> pagesCacheModel.getObject().clear(); <line4> return IteratorUtils.emptyIterator(); <line5> } <line6> if (pagesCacheModel.getObject().containsPage(first, count)) { <line7> return pagesCacheModel.getObject().getPage(first, count).iterator(); <line8> } <line9> try { <line10> List<ResultsGroup> queryResults = <line11> searchService <line12> .query( <line13> user, project, query, document, annotationLayer, annotationFeature, first, count) <line14> .entrySet() <line15> .stream() <line16> .map(e -> new ResultsGroup(e.getKey(), e.getValue())) <line17> .collect(Collectors.toList()); <line18> pagesCacheModel.getObject().putPage(first, count, queryResults); <line19> return queryResults.iterator(); <line20> } catch (IOException | ExecutionException e) { <line21> return emptyIterator(); <line22> } <line23> } <line24> } <line25> 	"<line21>      LOG.error(""Unable to retrieve results"", e);"	task4	
public class A { <line0> private static @Nullable JAXBContext initJAXBContextTemplates() { <line1> try { <line2> return JAXBContext.newInstance(TemplateListModel.class); <line3> } catch (JAXBException e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	"<line4>      LOGGER.error(""Exception creating JAXBContext for templates: {}"", e.getLocalizedMessage(), e);"	task4	
public class A { <line0> private void runAsyncImageBuild(Exchange exchange, Message message, DockerClient client) <line1> throws DockerException, InterruptedException { <line2> try (BuildImageCmd cmd = executeBuildImageRequest(client, message)) { <line3> BuildImageResultCallback item = <line4> cmd.exec( <line5> new BuildImageResultCallback() { <line6> @Override <line7> public void onNext(BuildResponseItem item) { <line8> super.onNext(item); <line9> exchange.getIn().setBody(item.getImageId()); <line10> } <line11> }); <line12> setResponse(exchange, item); <line13> } <line14> } <line15> } <line16> 	"<line9>                  LOG.trace(""build image callback {}"", item);"	task4	
"public class A { <line0> public Date parseDate(String str) { <line1> SimpleDateFormat date; <line2> try { <line3> if (str.matches(""^....-..-..T..:..:..\\....Z$"")) { <line4> date = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'""); <line5> date.setTimeZone(TimeZone.getTimeZone(""GMT"")); <line6> return date.parse(str); <line7> } else if (str.matches(""^........T......Z$"")) { <line8> date = new SimpleDateFormat(""yyyyMMdd'T'HHmmss'Z'""); <line9> date.setTimeZone(TimeZone.getTimeZone(""GMT"")); <line10> return date.parse(str); <line11> } <line12> } catch (ParseException e) { <line13> } <line14> return null; <line15> } <line16> } <line17> "	<line13>      logger.error(e.getMessage(), e);	task4	
"public class A { <line0> @Test <line1> public void testInsufficientArgsLogsErrorForWarn() { <line2> String format = ""some message: %s, %d""; <line3> String param = ""blah""; <line4> assertLogLike( <line5> Level.SEVERE, <line6> ImmutableList.of(""Invalid format"", ""WARN"", format, param), <line7> IllegalArgumentException.class); <line8> assertLog(Level.WARNING, String.format(""'%s' [%s]"", format, param)); <line9> } <line10> } <line11> "	<line4>    logger.warn(format, param);	task4	
"public class A { <line0> public String save() throws Exception { <line1> user.setEnabled(true); <line2> user.addRole(roleManager.getRole(Constants.USER_ROLE)); <line3> try { <line4> user = userManager.saveUser(user); <line5> } catch (AccessDeniedException ade) { <line6> getResponse().sendError(HttpServletResponse.SC_FORBIDDEN); <line7> return null; <line8> } catch (UserExistsException e) { <line9> addMessage(""errors.existing.user"", new Object[] {user.getUsername(), user.getEmail()}); <line10> user.setPassword(user.getConfirmPassword()); <line11> return null; <line12> } <line13> addMessage(""user.registered""); <line14> getSession().setAttribute(Constants.REGISTERED, Boolean.TRUE); <line15> UsernamePasswordAuthenticationToken auth = <line16> new UsernamePasswordAuthenticationToken( <line17> user.getUsername(), user.getConfirmPassword(), user.getAuthorities()); <line18> auth.setDetails(user); <line19> SecurityContextHolder.getContext().setAuthentication(auth); <line20> message.setSubject(getText(""signup.email.subject"")); <line21> try { <line22> sendUserMessage(user, getText(""signup.email.message""), RequestUtil.getAppURL(getRequest())); <line23> } catch (MailException me) { <line24> addError(me.getMostSpecificCause().getMessage()); <line25> return null; <line26> } <line27> return ""home""; <line28> } <line29> } <line30> "	<line6>      log.warn(ade.getMessage());	task4	
public class A { <line0> static Method findMethod(String className, String methodName, Class<?>... parameterTypes) { <line1> try { <line2> Class<?> aClass = Class.forName(className, false, TaskExecutors.class.getClassLoader()); <line3> Method method = aClass.getDeclaredMethod(methodName, parameterTypes); <line4> method.setAccessible(true); <line5> return method; <line6> } catch (Exception e) { <line7> return null; <line8> } <line9> } <line10> } <line11> 	"<line7>      LOG.trace(""failed to activate method: {}#{}"", className, methodName, e);"	task4	
public class A { <line0> @Override <line1> public Void execute() { <line2> behaviourFilter.disableBehaviour(nodeRef, TYPE_DISPOSITION_ACTION_DEFINITION); <line3> try { <line4> if (nodeService.exists(nodeRef) <line5> && nodeService.hasAspect(nodeRef, ASPECT_UNPUBLISHED_UPDATE)) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> nodeService.setProperty(nodeRef, PROP_PUBLISH_IN_PROGRESS, false); <line9> } <line10> } finally { <line11> behaviourFilter.enableBehaviour(nodeRef, TYPE_DISPOSITION_ACTION_DEFINITION); <line12> } <line13> return null; <line14> } <line15> } <line16> 	"<line7>          logger.debug(""Removing publish in progress marker from updated node, because update was not""+ "" successful. (node=""+ nodeRef.toString()+ "")"");"	task4	
public class A { <line0> @Override <line1> protected void handleJavaScriptException( <line2> ScriptException scriptException, boolean triggerOnError) { <line3> final InteractivePage page = scriptException.getPage(); <line4> if (triggerOnError && page != null) { <line5> final WebWindow window = page.getEnclosingWindow(); <line6> if (window != null) { <line7> final Window w = (Window) window.getScriptableObject(); <line8> if (w != null) { <line9> try { <line10> triggerOnError(w, scriptException); <line11> } catch (final Exception e) { <line12> handleJavaScriptException(new ScriptException(page, e, null), false); <line13> } <line14> } <line15> } <line16> } <line17> final JavaScriptErrorListener javaScriptErrorListener = <line18> getWebClient().getJavaScriptErrorListener(); <line19> if (javaScriptErrorListener != null) { <line20> javaScriptErrorListener.scriptException(page, scriptException); <line21> } <line22> if (getWebClient().getOptions().isThrowExceptionOnScriptError()) { <line23> throw scriptException; <line24> } <line25> } <line26> } <line27> 	"<line25>    LOG.info(""Caught script exception"", scriptException);"	task4	
"public class A { <line0> private JSONObject getTweets() throws IOException { <line1> currentRequest++; <line2> String url = getApiURL(lastMaxID - 1); <line3> Document doc = <line4> Http.url(url) <line5> .ignoreContentType() <line6> .header(""Authorization"", ""Bearer "" + accessToken) <line7> .header(""Content-Type"", ""application/x-www-form-urlencoded;charset=UTF-8"") <line8> .header(""User-agent"", ""ripe and zipe"") <line9> .get(); <line10> String body = doc.body().html().replaceAll(""&quot;"", ""\""""); <line11> Object jsonObj = new JSONTokener(body).nextValue(); <line12> JSONArray statuses; <line13> if (jsonObj instanceof JSONObject) { <line14> JSONObject json = (JSONObject) jsonObj; <line15> if (json.has(""errors"")) { <line16> String msg = json.getJSONObject(""errors"").getString(""message""); <line17> throw new IOException(""Twitter responded with errors: "" + msg); <line18> } <line19> statuses = json.getJSONArray(""statuses""); <line20> } else { <line21> statuses = (JSONArray) jsonObj; <line22> } <line23> JSONObject r = new JSONObject(); <line24> r.put(""tweets"", statuses); <line25> return r; <line26> } <line27> } <line28> "	"<line3>    LOGGER.info(""    Retrieving "" + url);"	task4	
public class A { <line0> public static com.liferay.portal.reports.engine.console.model.EntrySoap[] getEntries( <line1> long groupId, <line2> String definitionName, <line3> String userName, <line4> java.util.Date createDateGT, <line5> java.util.Date createDateLT, <line6> boolean andSearch, <line7> int start, <line8> int end, <line9> com.liferay.portal.kernel.util.OrderByComparator< <line10> com.liferay.portal.reports.engine.console.model.Entry> <line11> orderByComparator) <line12> throws RemoteException { <line13> try { <line14> java.util.List<com.liferay.portal.reports.engine.console.model.Entry> returnValue = <line15> EntryServiceUtil.getEntries( <line16> groupId, <line17> definitionName, <line18> userName, <line19> createDateGT, <line20> createDateLT, <line21> andSearch, <line22> start, <line23> end, <line24> orderByComparator); <line25> return com.liferay.portal.reports.engine.console.model.EntrySoap.toSoapModels(returnValue); <line26> } catch (Exception exception) { <line27> throw new RemoteException(exception.getMessage()); <line28> } <line29> } <line30> } <line31> 	<line27>      log.error(exception, exception);	task4	
public class A { <line0> @Test <line1> public void intervalTest2() throws BackendException { <line2> String[][] values = generateValues(); <line3> loadValues(values); <line4> newTx(); <line5> Set<KeyColumn> deleted = deleteValues(7); <line6> clopen(); <line7> checkRandomSlices(values, deleted); <line8> } <line9> } <line10> 	"<line3>    log.debug(""Loading values..."");"	task4	
"public class A { <line0> public void deactivate() { <line1> if (orb != null) { <line2> if (bindingPOA == null) { <line3> throw new CorbaBindingException(""Corba Port deactivation failed because the poa is null""); <line4> } <line5> try { <line6> bindingPOA.deactivate_object(objectId); <line7> } catch (ObjectNotActive ona) { <line8> } catch (Exception ex) { <line9> throw new CorbaBindingException(""Unable to deactivate CORBA servant"", ex); <line10> } <line11> } <line12> } <line13> } <line14> "	"<line8>        LOG.info(""Caught ObjectNotActive exception: ""+ ona+ "" during deactivate_object() call on POA: ""+ bindingPOA);"	task4	
public class A { <line0> public Boolean isEnable1xPrefixes() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> return raProperties.isEnable1xPrefixes(); <line4> } <line5> } <line6> 	"<line2>      ActiveMQRALogger.LOGGER.trace(""isEnable1xPrefixes()"");"	task4	
public class A { <line0> public static void setQueryLogLevelInfo(boolean queryLogLevelInfo) { <line1> assertUnlocked(); <line2> if (log.isInfoEnabled()) { <line3> } <line4> _queryLogLevelInfo = queryLogLevelInfo; <line5> lock(); <line6> } <line7> } <line8> 	"<line3>      log.info(""...Setting queryLogLevelInfo: "" + queryLogLevelInfo);"	task4	
public class A { <line0> @Override <line1> public void initialize(IAsyncResultHandler<Void> startupHandler) { <line2> this.proxy = new EBRegistryProxy(vertx, address(), registryUuid); <line3> listenProxyHandler(startupHandler); <line4> } <line5> } <line6> 	"<line2>    log.info(""Starting an EBInMemoryRegistry on UUID {0}"", registryUuid);"	task4	
public class A { <line0> @Override <line1> public Optional<Commit> commit(String commitComment) { <line2> final Set<String> idsToRegister = <line3> ImmutableSet.copyOf( <line4> newComponents.keySet().stream().filter(SnomedIdentifiers::isValid).iterator()); <line5> newComponents = newHashMap(); <line6> Optional<Commit> commit = getDelegate().commit(commitComment); <line7> final ISnomedIdentifierService cis = service(ISnomedIdentifierService.class); <line8> if (cis.importSupported()) { <line9> cis.register(idsToRegister); <line10> } <line11> return commit; <line12> } <line13> } <line14> 	"<line6>    LOG.info(""Pushing changes: {}"", commitComment);"	task4	
"public class A { <line0> private Map<InternalDistributedMember, List<Integer>> buildNodeToBucketMapForBuckets( <line1> final Set<Integer> bucketIdsToConsider) throws QueryException { <line2> final HashMap<InternalDistributedMember, List<Integer>> ret = new HashMap<>(); <line3> if (bucketIdsToConsider.isEmpty()) { <line4> return ret; <line5> } <line6> List<Integer> bucketIds; <line7> if (query != null && query.isCqQuery()) { <line8> bucketIds = findPrimaryBucketOwners(bucketIdsToConsider, ret); <line9> } else { <line10> bucketIds = findBucketOwners(bucketIdsToConsider, ret); <line11> } <line12> if (bucketIds.size() != bucketIdsToConsider.size()) { <line13> bucketIdsToConsider.removeAll(bucketIds); <line14> throw new QueryException( <line15> ""Data loss detected, unable to find the hosting "" <line16> + "" node for some of the dataset. [dataset/bucket ids:"" <line17> + bucketIdsToConsider <line18> + ""]""); <line19> } <line20> if (logger.isDebugEnabled()) { <line21> } <line22> return ret; <line23> } <line24> } <line25> "	"<line21>      logger.debug(""Node to bucketId map: {}"", ret);"	task4	
"public class A { <line0> protected void validateAttachmentContentType( <line1> SoapAttachment receivedAttachment, SoapAttachment controlAttachment) { <line2> if (!StringUtils.hasText(controlAttachment.getContentType())) { <line3> return; <line4> } <line5> if (receivedAttachment.getContentType() != null) { <line6> Assert.isTrue( <line7> controlAttachment.getContentType() != null, <line8> buildValidationErrorMessage( <line9> ""Values not equal for attachment contentType"", <line10> null, <line11> receivedAttachment.getContentType())); <line12> Assert.isTrue( <line13> receivedAttachment.getContentType().equals(controlAttachment.getContentType()), <line14> buildValidationErrorMessage( <line15> ""Values not equal for attachment contentType"", <line16> controlAttachment.getContentType(), <line17> receivedAttachment.getContentType())); <line18> } else { <line19> Assert.isTrue( <line20> controlAttachment.getContentType() == null <line21> || controlAttachment.getContentType().length() == 0, <line22> buildValidationErrorMessage( <line23> ""Values not equal for attachment contentType"", <line24> controlAttachment.getContentType(), <line25> null)); <line26> } <line27> if (log.isDebugEnabled()) { <line28> } <line29> } <line30> } <line31> "	"<line28>      log.debug(""Validating attachment contentType: ""+ receivedAttachment.getContentType()+ ""='""+ controlAttachment.getContentType()+ ""': OK."");"	task4	
"public class A { <line0> public static void mergeTags(HttpPrincipal httpPrincipal, long[] fromTagIds, long toTagId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey(AssetTagServiceUtil.class, ""mergeTags"", _mergeTagsParameterTypes21); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, fromTagIds, toTagId); <line6> try { <line7> TunnelUtil.invoke(httpPrincipal, methodHandler); <line8> } catch (Exception exception) { <line9> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line10> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line11> } <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	<line15>      log.error(systemException, systemException);	task4	
public class A { <line0> public void trace(final String message, final Throwable error) { <line1> } <line2> } <line3> 	<line1>    Logger.trace(id, message, error);	task4	
public class A { <line0> @Override <line1> public void doExecute(TestContext context) { <line2> } <line3> } <line4> 	"<line2>    log.info(context.getVariable(""index""));"	task4	
public class A { <line0> @Override <line1> public void delete(ScriptKey scriptKey) { <line2> ScriptVersionKey scriptVersionKey = <line3> new ScriptVersionKey(new ScriptKey(scriptKey.getScriptId(), scriptKey.getScriptVersion())); <line4> ScriptVersionConfiguration.getInstance().delete(scriptVersionKey); <line5> ActionConfiguration.getInstance().deleteByScript(scriptKey); <line6> ScriptParameterConfiguration.getInstance().deleteByScript(scriptKey); <line7> ScriptLabelConfiguration.getInstance().deleteByScript(scriptKey); <line8> getDeleteStatement(scriptKey).ifPresent(getMetadataRepository()::executeUpdate); <line9> } <line10> } <line11> 	"<line2>    log.trace(MessageFormat.format(""Deleting script {0}"", scriptKey.toString()));"	task4	
"public class A { <line0> @GET(path = ""/backend/jvm/capabilities"", permission = ""agent:jvm:capabilities"") <line1> String getCapabilities(@BindAgentId String agentId) throws Exception { <line2> checkNotNull(liveJvmService); <line3> Capabilities capabilities; <line4> try { <line5> capabilities = liveJvmService.getCapabilities(agentId); <line6> } catch (AgentNotConnectedException e) { <line7> return ""{\""agentNotConnected\"":true}""; <line8> } <line9> StringBuilder sb = new StringBuilder(); <line10> JsonGenerator jg = mapper.getFactory().createGenerator(CharStreams.asWriter(sb)); <line11> try { <line12> jg.writeStartObject(); <line13> writeAvailability(""threadCpuTime"", capabilities.getThreadCpuTime(), jg); <line14> writeAvailability(""threadContentionTime"", capabilities.getThreadContentionTime(), jg); <line15> writeAvailability(""threadAllocatedBytes"", capabilities.getThreadAllocatedBytes(), jg); <line16> jg.writeEndObject(); <line17> } finally { <line18> jg.close(); <line19> } <line20> return sb.toString(); <line21> } <line22> } <line23> "	<line7>      logger.debug(e.getMessage(), e);	task4	
"public class A { <line0> @Override <line1> public void save(Note note, AuthenticationInfo subject) throws IOException { <line2> String json = note.toJson(); <line3> ByteArrayOutputStream output = new ByteArrayOutputStream(); <line4> Writer writer = new OutputStreamWriter(output); <line5> writer.write(json); <line6> writer.close(); <line7> output.close(); <line8> byte[] buffer = output.toByteArray(); <line9> try { <line10> CloudFileDirectory dir = rootDir.getDirectoryReference(note.getId()); <line11> dir.createIfNotExists(); <line12> CloudFile cloudFile = dir.getFileReference(""note.json""); <line13> cloudFile.uploadFromByteArray(buffer, 0, buffer.length); <line14> } catch (URISyntaxException | StorageException e) { <line15> String msg = String.format(""Error saving notebook %s to Azure storage"", note.getId()); <line16> throw new IOException(msg, e); <line17> } <line18> } <line19> } <line20> "	<line16>      LOG.error(msg, e);	task4	
public class A { <line0> private void reportCrucialExceptions(Map<String, JournalException> crucialExceptions) <line1> throws JournalException { <line2> if (!crucialExceptions.isEmpty()) { <line3> JournalOperatingMode.setMode(JournalOperatingMode.READ_ONLY); <line4> } <line5> for (String transportName : crucialExceptions.keySet()) { <line6> JournalException e = crucialExceptions.get(transportName); <line7> } <line8> } <line9> } <line10> 	"<line7>      logger.error(""Exception thrown from crucial Journal Transport: '"" + transportName + ""'"", e);"	task4	
public class A { <line0> public boolean isDefinitionInputDisabled( <line1> boolean previewBeforeRestore, <line2> KaleoDefinitionVersion kaleoDefinitionVersion, <line3> PermissionChecker permissionChecker) { <line4> if (previewBeforeRestore) { <line5> return true; <line6> } <line7> if ((kaleoDefinitionVersion == null) <line8> && KaleoDesignerPermission.contains( <line9> permissionChecker, <line10> _themeDisplay.getCompanyGroupId(), <line11> KaleoDesignerActionKeys.ADD_NEW_WORKFLOW)) { <line12> return false; <line13> } <line14> try { <line15> if ((kaleoDefinitionVersion != null) <line16> && KaleoDefinitionVersionPermission.contains( <line17> permissionChecker, kaleoDefinitionVersion, ActionKeys.UPDATE)) { <line18> return false; <line19> } <line20> } catch (PortalException portalException) { <line21> if (log.isDebugEnabled()) { <line22> } <line23> } <line24> return true; <line25> } <line26> } <line27> 	<line22>        log.debug(portalException, portalException);	task4	
"public class A { <line0> public Map<String, String> getQueryMap(@Nullable String query) { <line1> Map<String, String> map = new HashMap<>(); <line2> if (query != null) { <line3> String[] params = query.split(""&""); <line4> for (String param : params) { <line5> String[] elements = param.split(""=""); <line6> if (elements.length == 2) { <line7> String name = elements[0]; <line8> String value = """"; <line9> try { <line10> value = URLDecoder.decode(elements[1], ""UTF8""); <line11> } catch (UnsupportedEncodingException e) { <line12> } <line13> map.put(name, value); <line14> } <line15> } <line16> } <line17> return map; <line18> } <line19> } <line20> "	"<line12>            logger.info(""Unsupported encoding"", e);"	task4	
"public class A { <line0> @Override <line1> public Map<String, Object> perform( <line2> EntityManager entityManager, <line3> int ciTypeId, <line4> String guid, <line5> AdmStateTransition transition, <line6> Map<String, Object> ciData, <line7> DynamicEntityHolder ciHolder, <line8> Date date) { <line9> SimpleDateFormat dateFmt = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); <line10> dateFmt.setTimeZone(TimeZone.getDefault()); <line11> if (ciHolder == null) { <line12> ciHolder = ciService.getCiHolder(ciTypeId, guid); <line13> } <line14> String fixedDate = (String) ciHolder.get(CmdbConstants.DEFAULT_FIELD_FIXED_DATE); <line15> if (!Strings.isNullOrEmpty(fixedDate)) { <line16> throw new InvalidArgumentException( <line17> String.format(""The Ci [%s] has been confirmed, can not be confirmed again."", guid)); <line18> } <line19> if (date != null) { <line20> fixedDate = dateFmt.format(date); <line21> } else { <line22> fixedDate = dateFmt.format(new Date()); <line23> } <line24> Map<String, Object> updateMap = Maps.newHashMap(); <line25> int targetState = transition.getTargetState(); <line26> MapUtils.putAll( <line27> updateMap, <line28> new Object[] { <line29> CmdbConstants.GUID, <line30> guid, <line31> CmdbConstants.DEFAULT_FIELD_FIXED_DATE, <line32> fixedDate, <line33> CmdbConstants.DEFAULT_FIELD_STATE, <line34> targetState <line35> }); <line36> ciHolder.update(updateMap, CmdbThreadLocal.getIntance().getCurrentUser(), entityManager); <line37> entityManager.merge(ciHolder.getEntityObj()); <line38> return ClassUtils.convertBeanToMap(ciHolder.getEntityObj(), ciHolder.getEntityMeta(), false); <line39> } <line40> } <line41> "	"<line38>    logger.info(""Update fixed_date to {} on ci [{}:{}]"", fixedDate, ciTypeId, guid);"	task4	
"public class A { <line0> void createPortForward(String vmName, int port) { <line1> if (!isPortForwarded(vmName, port)) { <line2> commandExecutor.exec( <line3> String.format( <line4> ""VBoxManage controlvm "" + vmName + "" natpf1 %d,tcp,127.0.0.1,%d,,%d"", <line5> port, <line6> port, <line7> port)); <line8> } <line9> } <line10> } <line11> "	"<line2>      LOGGER.info(""Creating VirtualBox port forward for "" + port);"	task4	
public class A { <line0> @Test <line1> public void testZeroOnUpdate() throws Exception { <line2> factory = new FactoryBuilder.SingletonFactory<>(new TestPolicy(null, 0L, null)); <line3> startGrids(); <line4> for (final Integer key : keys()) { <line5> zeroOnUpdate(key); <line6> } <line7> } <line8> } <line9> 	"<line5>      log.info(""Test zero duration on update, key: "" + key);"	task4	
public class A { <line0> @BeforeClass <line1> public static void setUpClass() throws Exception { <line2> if (testDriver != null && !setUpClassCalled) { <line3> testDriver.setUpClass(); <line4> setUpClassCalled = true; <line5> } <line6> } <line7> } <line8> 	"<line3>      log.info(""setting up class"");"	task4	
"public class A { <line0> @Override <line1> public File getObject() { <line2> String home = getPageBase().getMidpointConfiguration().getMidpointHome(); <line3> File f = new File(home, ""result""); <line4> DataOutputStream dos = null; <line5> try { <line6> dos = new DataOutputStream(new FileOutputStream(f)); <line7> dos.writeBytes(OperationResultPanel.this.getModel().getObject().getXml()); <line8> } catch (IOException e) { <line9> } finally { <line10> IOUtils.closeQuietly(dos); <line11> } <line12> return f; <line13> } <line14> } <line15> "	"<line9>      LOGGER.error(""Could not download result: {}"", e.getMessage(), e);"	task4	
"public class A { <line0> public synchronized void updateContainerXMLTree(String spaceName, JSpaceAttributes spaceAttr) { <line1> if (m_rootSpaceElement == null) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> return; <line5> } <line6> spaceAttr = (spaceAttr == null) ? new JSpaceAttributes() : spaceAttr; <line7> NodeList spaceNL = m_rootSpaceElement.getElementsByTagName(spaceName); <line8> for (int i = 0; i < spaceNL.getLength(); i++) m_rootSpaceElement.removeChild(spaceNL.item(i)); <line9> Element jspaceElement = m_containerFileDocument.createElement(spaceName); <line10> m_rootSpaceElement.appendChild(jspaceElement); <line11> m_rootSpaceElement.appendChild(jspaceElement); <line12> Element propertiesElem = m_containerFileDocument.createElement(SpaceURL.PROPERTIES_FILE_NAME); <line13> Element schemaElem = m_containerFileDocument.createElement(SCHEMA_ELEMENT); <line14> Text schemaText = null; <line15> if (spaceAttr.getSchemaName() != null) <line16> schemaText = m_containerFileDocument.createTextNode(spaceAttr.getSchemaName()); <line17> else schemaText = m_containerFileDocument.createTextNode(""""); <line18> Text propertiesText = null; <line19> if (spaceAttr.getCustomProperties() != null <line20> && spaceAttr.getCustomProperties().getProperty(SpaceURL.PROPERTIES_FILE_NAME) != null) <line21> propertiesText = <line22> m_containerFileDocument.createTextNode( <line23> spaceAttr.getCustomProperties().getProperty(SpaceURL.PROPERTIES_FILE_NAME)); <line24> else propertiesText = m_containerFileDocument.createTextNode(""""); <line25> jspaceElement.appendChild(schemaElem).appendChild(schemaText); <line26> jspaceElement.appendChild(propertiesElem).appendChild(propertiesText); <line27> Element isLoadOnStartupElem = <line28> m_containerFileDocument.createElement(Constants.IS_SPACE_LOAD_ON_STARTUP); <line29> Text isLoadOnStartupText = <line30> m_containerFileDocument.createTextNode(String.valueOf(spaceAttr.isLoadOnStartup())); <line31> jspaceElement.appendChild(isLoadOnStartupElem).appendChild(isLoadOnStartupText); <line32> saveState(); <line33> } <line34> } <line35> "	"<line3>        logger.debug(""Fail to update the ""+ _containerName+ "" container XML file for ""+ spaceName+ "" space; the DOM element for spaces is null"");"	task4	
public class A { <line0> private String encryptData(String decryptedData) { <line1> long encStartTime = System.currentTimeMillis(); <line2> try { <line3> String encryptedData = encryptionService.encryptData(decryptedData, null); <line4> return encryptedData; <line5> } catch (Exception e) { <line6> throw new ProjectCommonException( <line7> ResponseCode.SERVER_ERROR.getErrorCode(), <line8> ResponseCode.userDataEncryptionError.getErrorMessage(), <line9> ResponseCode.userDataEncryptionError.getResponseCode()); <line10> } <line11> } <line12> } <line13> 	"<line6>      logger.error(""BulkMigrationUser:encryptData:error occurred while encrypting data"", e);"	task4	
public class A { <line0> @Override <line1> public void afterConnectionEstablished(Session session) throws Exception { <line2> afterConnectionEstablishedLatch.countDown(); <line3> } <line4> } <line5> 	"<line2>    log.debug(""Connection established with sessionId: "" + session.getSessionId());"	task4	
"public class A { <line0> @Override <line1> public void populateConfigJSONObject( <line2> JSONObject jsonObject, <line3> Map<String, Object> inputEditorTaglibAttributes, <line4> ThemeDisplay themeDisplay, <line5> RequestBackedPortletURLFactory requestBackedPortletURLFactory) { <line6> PortletDisplay portletDisplay = themeDisplay.getPortletDisplay(); <line7> try { <line8> BlogsPortletInstanceConfiguration blogsPortletInstanceConfiguration = <line9> portletDisplay.getPortletInstanceConfiguration(BlogsPortletInstanceConfiguration.class); <line10> if (!blogsPortletInstanceConfiguration.enableReadingTime()) { <line11> return; <line12> } <line13> } catch (ConfigurationException configurationException) { <line14> } <line15> String extraPlugins = jsonObject.getString(""extraPlugins""); <line16> if (Validator.isNotNull(extraPlugins)) { <line17> extraPlugins = extraPlugins + "",readingtime""; <line18> } else { <line19> extraPlugins = ""readingtime""; <line20> } <line21> jsonObject.put(""extraPlugins"", extraPlugins); <line22> _readingTimeConfigContributor.populateConfigJSONObject( <line23> jsonObject, inputEditorTaglibAttributes, themeDisplay, requestBackedPortletURLFactory); <line24> JSONObject readingTimeJSONObject = jsonObject.getJSONObject(""readingTime""); <line25> if (readingTimeJSONObject != null) { <line26> String namespace = <line27> GetterUtil.getString( <line28> inputEditorTaglibAttributes.get(""liferay-ui:input-editor:namespace"")); <line29> readingTimeJSONObject.put(""elementId"", namespace + ""readingTime""); <line30> } <line31> } <line32> } <line33> "	"<line14>      log.error(""Unable to get blogs portlet instance configuration"", configurationException);"	task4	
"public class A { <line0> public static <C extends RingElem<C>> List<GenWordPolynomial<C>> intersect( <line1> GenWordPolynomialRing<C> R, List<GenWordPolynomial<C>> F) { <line2> if (F == null || F.isEmpty()) { <line3> return F; <line4> } <line5> GenWordPolynomialRing<C> pfac = F.get(0).ring; <line6> assert pfac.alphabet.isSubFactory(R.alphabet) : ""pfac="" + pfac.alphabet + "", R="" + R.alphabet; <line7> List<GenWordPolynomial<C>> H = new ArrayList<GenWordPolynomial<C>>(F.size()); <line8> for (GenWordPolynomial<C> p : F) { <line9> if (p == null || p.isZERO()) { <line10> continue; <line11> } <line12> GenWordPolynomial<C> m = p.contract(R); <line13> if (logger.isDebugEnabled()) { <line14> } <line15> if (!m.isZERO()) { <line16> H.add(m); <line17> } <line18> } <line19> return H; <line20> } <line21> } <line22> "	"<line14>        logger.debug(""intersect contract m = "" + m);"	task4	
"public class A { <line0> public void endCurrentTransaction() { <line1> try { <line2> Transaction transaction = tracer.currentTransaction(); <line3> if (transaction != null && ""messaging"".equals(transaction.getType())) { <line4> transaction.deactivate().end(); <line5> } <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> "	"<line7>      logger.error(""Error in Kafka iterator wrapper"", e);"	task4	
"public class A { <line0> @Override <line1> public Path read(Class<? extends Path> clazz, HttpInputMessage inputMessage) <line2> throws IOException, HttpMessageNotReadableException { <line3> InputStream inputStream = inputMessage.getBody(); <line4> Path fileDirectory = Files.createTempDirectory(null); <line5> Path tempFile = fileDirectory.resolve(fileName); <line6> tempFile = Files.createFile(tempFile); <line7> try (OutputStream outputStream = Files.newOutputStream(tempFile)) { <line8> long fileSize = IOUtils.copyLarge(inputStream, outputStream); <line9> long expectedSize = inputMessage.getHeaders().getContentLength(); <line10> if (fileSize != expectedSize) { <line11> throw new IOException( <line12> ""Error when writing remote file ["" <line13> + fileName <line14> + ""], to path ["" <line15> + tempFile <line16> + ""], expectedSize ["" <line17> + expectedSize <line18> + ""] != actual size ["" <line19> + fileSize <line20> + ""]""); <line21> } <line22> } <line23> return tempFile; <line24> } <line25> } <line26> "	"<line3>    logger.debug(""Converting  response to "" + clazz);"	task4	
public class A { <line0> private void processBuffer(final Connection connection) throws IOException { <line1> final ByteBuffer buffer = connection.getBuffer(); <line2> buffer.flip(); <line3> try { <line4> while ((buffer.position() + 4) < buffer.limit()) { <line5> buffer.mark(); <line6> if (!this.onBufferReceived(connection)) { <line7> return; <line8> } <line9> } <line10> buffer.mark(); <line11> buffer.compact(); <line12> } catch (final BufferUnderflowException ex) { <line13> buffer.reset(); <line14> buffer.compact(); <line15> } <line16> } <line17> } <line18> 	"<line13>      this.logger.warn(""Unexpected buffer underflow. Resetting and compacting buffer."", ex);"	task4	
public class A { <line0> @Override <line1> public void process(AuditMessage auditMessage) { <line2> try { <line3> doProcess(auditMessage); <line4> } catch (CTTransactionException ctTransactionException) { <line5> throw ctTransactionException; <line6> } catch (Exception exception) { <line7> } <line8> } <line9> } <line10> 	"<line7>      log.fatal(""Unable to process audit message "" + auditMessage, exception);"	task4	
public class A { <line0> private HttpServletRequest _encryptRequest( <line1> HttpServletRequest httpServletRequest, long companyId) { <line2> boolean encryptRequest = ParamUtil.getBoolean(httpServletRequest, WebKeys.ENCRYPT); <line3> if (!encryptRequest) { <line4> return httpServletRequest; <line5> } <line6> try { <line7> Company company = CompanyLocalServiceUtil.getCompanyById(companyId); <line8> httpServletRequest = new EncryptedServletRequest(httpServletRequest, company.getKeyObj()); <line9> } catch (Exception exception) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> } <line13> return httpServletRequest; <line14> } <line15> } <line16> 	<line11>        log.debug(exception, exception);	task4	
"public class A { <line0> @Override <line1> public boolean init( <line2> @NotNull Session session, <line3> @NotNull Root root, <line4> @NotNull NamePathMapper namePathMapper, <line5> boolean isWorkspaceImport, <line6> int uuidBehavior, <line7> @NotNull ReferenceChangeTracker referenceTracker, <line8> @NotNull SecurityProvider securityProvider) { <line9> if (initialized) { <line10> throw new IllegalStateException(""Already initialized""); <line11> } <line12> try { <line13> ConfigurationParameters config = <line14> securityProvider.getConfiguration(AuthorizationConfiguration.class).getParameters(); <line15> supportedPaths = CugUtil.getSupportedPaths(config, mountInfoProvider); <line16> importBehavior = CugUtil.getImportBehavior(config); <line17> if (isWorkspaceImport) { <line18> PrincipalConfiguration pConfig = <line19> securityProvider.getConfiguration(PrincipalConfiguration.class); <line20> principalManager = pConfig.getPrincipalManager(root, namePathMapper); <line21> } else { <line22> principalManager = ((JackrabbitSession) session).getPrincipalManager(); <line23> } <line24> initialized = true; <line25> } catch (RepositoryException e) { <line26> } <line27> return initialized; <line28> } <line29> } <line30> "	"<line26>      log.warn(""Error while initializing cug importer"", e);"	task4	
"public class A { <line0> protected void informAdministrator(String errorMessage) { <line1> if (!_informAdministrator || !log.isWarnEnabled()) { <line2> return; <line3> } <line4> _informAdministrator = false; <line5> StringBundler sb = new StringBundler(7); <line6> sb.append(""Liferay does not have the Xuggler native libraries ""); <line7> sb.append(""installed. In order to generate video and audio previews, ""); <line8> sb.append(""please follow the instructions for Xuggler in the Server ""); <line9> sb.append(""Administration section of the Control Panel at: ""); <line10> sb.append(""http://<server>/group/control_panel/manage/-/server""); <line11> sb.append(""/external-services. Warning: ""); <line12> sb.append(errorMessage); <line13> } <line14> } <line15> "	<line13>    log.warn(sb.toString());	task4	
public class A { <line0> public boolean loadModelFromFilename(String file) { <line1> URL fileURL = null; <line2> try { <line3> fileURL = new URL(file); <line4> } catch (MalformedURLException e) { <line5> return false; <line6> } <line7> return loadModelFromURL(fileURL); <line8> } <line9> } <line10> 	<line5>      logger.error(e);	task4	
public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public ServiceDefinitionResponseDTO createServiceDefinitionResponse( <line2> final String serviceDefinition) { <line3> final ServiceDefinition serviceDefinitionEntry = createServiceDefinition(serviceDefinition); <line4> return DTOConverter.convertServiceDefinitionToServiceDefinitionResponseDTO( <line5> serviceDefinitionEntry); <line6> } <line7> } <line8> 	"<line3>    logger.debug(""createServiceDefinitionResponse started..."");"	task4	
"public class A { <line0> public void onKapuaEvent(ServiceEvent kapuaEvent) throws KapuaException { <line1> if (kapuaEvent == null) {} <line2> if (""user"".equals(kapuaEvent.getService()) && ""delete"".equals(kapuaEvent.getOperation())) { <line3> deleteCredentialByUserId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId()); <line4> } else if (""account"".equals(kapuaEvent.getService()) <line5> && ""delete"".equals(kapuaEvent.getOperation())) { <line6> deleteCredentialByAccountId(kapuaEvent.getScopeId(), kapuaEvent.getEntityId()); <line7> } <line8> } <line9> } <line10> "	"<line2>    LOGGER.info(""CredentialService: received kapua event from {}, operation {}"",kapuaEvent.getService(),kapuaEvent.getOperation());"	task4	
public class A { <line0> @Override <line1> public void service(Mail mail) throws MessagingException { <line2> try { <line3> MimeMessage message = mail.getMessage(); <line4> message.writeTo(System.err); <line5> } catch (IOException ioe) { <line6> } <line7> } <line8> } <line9> 	"<line6>      LOGGER.error(""error printing message"", ioe);"	task4	
"public class A { <line0> @Override <line1> public KBTemplate findByUUID_G(String uuid, long groupId) throws NoSuchTemplateException { <line2> KBTemplate kbTemplate = fetchByUUID_G(uuid, groupId); <line3> if (kbTemplate == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchTemplateException(sb.toString()); <line14> } <line15> return kbTemplate; <line16> } <line17> } <line18> "	<line12>        log.debug(sb.toString());	task4	
public class A { <line0> public void stopHBaseCluster() throws IOException { <line1> if (hbaseCluster != null) { <line2> hbaseCluster.shutdown(); <line3> hbaseCluster.waitUntilShutDown(); <line4> hbaseCluster = null; <line5> } <line6> } <line7> } <line8> 	"<line2>      LOG.info(""MiniHBaseCluster stopped"");"	task4	
"public class A { <line0> private void reportMessageSizes(final Map<URI, URI> msgUris, String name) { <line1> int[] counter = new int[4]; <line2> Set<URI> keys = msgUris.keySet(); <line3> for (URI uri : keys) { <line4> Dataset dataset = <line5> getEventListenerContext().getLinkedDataSource().getDataForResource(uri, msgUris.get(uri)); <line6> record(dataset, counter); <line7> } <line8> String sizeInfo = <line9> ""\nSIZES for "" <line10> + name <line11> + "":\n"" <line12> + ""messages="" <line13> + counter[0] <line14> + "", named-graphs="" <line15> + counter[1] <line16> + "", "" <line17> + ""quads="" <line18> + counter[2] <line19> + "", bytes-in-Trig-UTF8="" <line20> + counter[3]; <line21> } <line22> } <line23> "	<line21>    logger.info(sizeInfo);	task4	
public class A { <line0> private void createNewID(Connection con, int type) throws SQLException { <line1> PreparedStatement pstmt = null; <line2> try { <line3> pstmt = con.prepareStatement(CREATE_ID); <line4> pstmt.setInt(1, type); <line5> pstmt.execute(); <line6> } finally { <line7> DbConnectionManager.closeStatement(pstmt); <line8> } <line9> } <line10> } <line11> 	"<line1>    Log.warn(""Autocreating jiveID row for type '"" + type + ""'"");"	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public T mapBinLogEvent(Row row, Schema schema, DbusOpcode eventType) { <line3> Map<String, Object> keyValuePairs = new HashMap<String, Object>(); <line4> List<Column> columns = row.getColumns(); <line5> List<Schema.Field> orderedFields; <line6> try { <line7> orderedFields = <line8> SchemaHelper.getOrderedFieldsByMetaField( <line9> schema, <line10> ""dbFieldPosition"", <line11> new Comparator<String>() { <line12> public int compare(String o1, String o2) { <line13> Integer pos1 = Integer.parseInt(o1); <line14> Integer pos2 = Integer.parseInt(o2); <line15> return pos1.compareTo(pos2); <line16> } <line17> }); <line18> int cnt = 0; <line19> for (Schema.Field field : orderedFields) { <line20> Column column = null; <line21> if (cnt < columns.size()) { <line22> column = columns.get(cnt); <line23> } <line24> keyValuePairs.put( <line25> field.name(), column == null ? null : orToMysqlMapper.orToMysqlType(column)); <line26> cnt++; <line27> } <line28> return (T) <line29> new SourceEvent( <line30> keyValuePairs, <line31> getPkListFromSchema(schema), <line32> schema.getName(), <line33> schema.getNamespace(), <line34> eventType); <line35> } catch (Exception e) { <line36> } <line37> return null; <line38> } <line39> } <line40> "	"<line36>      LOGGER.error(""Error while mapping to MysqlBinLogEvent . Exception : ""+ e.getMessage()+ "" Cause: ""+ e.getCause(),e);"	task4	
public class A { <line0> public static void deletePageAttachments(long nodeId, String title) throws RemoteException { <line1> try { <line2> WikiPageServiceUtil.deletePageAttachments(nodeId, title); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	<line4>      log.error(exception, exception);	task4	
public class A { <line0> private void preprocessHiveTypes(PreprocessorContext context) { <line1> List<AtlasEntity> entities = context.getEntities(); <line2> if (entities != null) { <line3> for (int i = 0; i < entities.size(); i++) { <line4> AtlasEntity entity = entities.get(i); <line5> EntityPreprocessor preprocessor = <line6> EntityPreprocessor.getHivePreprocessor(entity.getTypeName()); <line7> if (preprocessor != null) { <line8> preprocessor.preprocess(entity, context); <line9> if (context.isIgnoredEntity(entity.getGuid())) { <line10> entities.remove(i--); <line11> } <line12> } <line13> } <line14> Map<String, AtlasEntity> referredEntities = context.getReferredEntities(); <line15> if (referredEntities != null) { <line16> for (Iterator<Map.Entry<String, AtlasEntity>> iter = referredEntities.entrySet().iterator(); <line17> iter.hasNext(); ) { <line18> AtlasEntity entity = iter.next().getValue(); <line19> EntityPreprocessor preprocessor = <line20> EntityPreprocessor.getHivePreprocessor(entity.getTypeName()); <line21> if (preprocessor != null) { <line22> preprocessor.preprocess(entity, context); <line23> if (context.isIgnoredEntity(entity.getGuid())) { <line24> iter.remove(); <line25> } <line26> } <line27> } <line28> } <line29> int ignoredEntities = context.getIgnoredEntities().size(); <line30> int prunedEntities = context.getPrunedEntities().size(); <line31> if (ignoredEntities > 0 || prunedEntities > 0) { <line32> } <line33> } <line34> } <line35> } <line36> 	"<line32>        LOG.info(""preprocess: ignored entities={}; pruned entities={}. topic-offset={}, partition={}"",ignoredEntities,prunedEntities,context.getKafkaMessageOffset(),context.getKafkaPartition());"	task4	
public class A { <line0> private void processReceive(final CamelContext context, final WireEnvelope envelope) <line1> throws Exception { <line2> final String endpointUri = this.endpointUri; <line3> if (StringUtil.isNullOrEmpty(endpointUri)) { <line4> return; <line5> } <line6> processReceive(context, endpointUri, envelope); <line7> } <line8> } <line9> 	"<line4>      logger.debug(""Endpoint missing. Component is disabled."");"	task4	
public class A { <line0> @Override <line1> public MBThreadFlag remove(Serializable primaryKey) throws NoSuchThreadFlagException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> MBThreadFlag mbThreadFlag = (MBThreadFlag) session.get(MBThreadFlagImpl.class, primaryKey); <line6> if (mbThreadFlag == null) { <line7> if (log.isDebugEnabled()) { <line8> } <line9> throw new NoSuchThreadFlagException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return remove(mbThreadFlag); <line12> } catch (NoSuchThreadFlagException noSuchEntityException) { <line13> throw noSuchEntityException; <line14> } catch (Exception exception) { <line15> throw processException(exception); <line16> } finally { <line17> closeSession(session); <line18> } <line19> } <line20> } <line21> 	<line8>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task4	
"public class A { <line0> public static com.liferay.knowledge.base.model.KBArticle getLatestKBArticle( <line1> HttpPrincipal httpPrincipal, long resourcePrimKey, int status) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KBArticleServiceUtil.class, <line7> ""getLatestKBArticle"", <line8> _getLatestKBArticleParameterTypes26); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, resourcePrimKey, status); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.knowledge.base.model.KBArticle) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>      log.error(systemException, systemException);	task4	
"public class A { <line0> public static void deleteCommerceBOMFolder(HttpPrincipal httpPrincipal, long commerceBOMFolderId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CommerceBOMFolderServiceUtil.class, <line6> ""deleteCommerceBOMFolder"", <line7> _deleteCommerceBOMFolderParameterTypes1); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, commerceBOMFolderId); <line9> try { <line10> TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>      log.error(systemException, systemException);	task4	
"public class A { <line0> @Test <line1> public void mysqlParse6() { <line2> final String jdbcUrl = <line3> CONNECTION_STRING <line4> + ""?useUnicode=true&characterEncoding=UTF-8&noAccessToProcedureBodies=true&autoDeserialize=true&elideSetAutoCommits=true&sessionVariables=time_zone='%2B09:00',tx_isolation='READ-COMMITTED'""; <line5> DatabaseInfo dbInfo = jdbcUrlParser.parse(jdbcUrl); <line6> Assert.assertTrue(dbInfo.isParsingComplete()); <line7> Assert.assertEquals(dbInfo.getType(), SERVICE_TYPE); <line8> Assert.assertEquals(dbInfo.getHost().get(0), IP_PORT); <line9> Assert.assertEquals(dbInfo.getDatabaseId(), DATABASE_ID); <line10> Assert.assertEquals(dbInfo.getUrl(), CONNECTION_STRING); <line11> } <line12> } <line13> "	<line11>    logger.debug(dbInfo.toString());	task4	
public class A { <line0> private void logException(IOException e) { <line1> if (exceptionLogged) { <line2> return; <line3> } <line4> exceptionLogged = true; <line5> } <line6> } <line7> 	"<line4>    logger.warn(""Unable to write trace to disk"", e);"	task4	
"public class A { <line0> protected void assertNotSshable(Map<?, ?> machineConfig) { <line1> try { <line2> assertSshable(machineConfig); <line3> Assert.fail(""ssh should not have succeeded "" + machineConfig); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> "	"<line5>      LOG.debug(""Exception as expected when testing sshable "" + machineConfig);"	task4	
public class A { <line0> public String getLocation(final String locationType) { <line1> String value = null; <line2> for (Location location : getLocations().getLocations()) { <line3> if (location.getName().name().trim().equalsIgnoreCase(locationType.trim().toLowerCase())) { <line4> value = location.getPath(); <line5> } <line6> } <line7> return value; <line8> } <line9> } <line10> 	"<line7>    LOGGER.info(""Cluster: "" + getName() + "" locationType: "" + locationType + "" value:"" + value);"	task4	
public class A { <line0> public void setOccupancyGroups(List<OccupancyGroup> oGroupList) { <line1> this.oGroupList = oGroupList; <line2> if (areaMap != null) { <line3> processOccupancyGroups(); <line4> } <line5> } <line6> } <line7> 	"<line1>    logger.trace(""Setting occupancy groups list"");"	task4	
public class A { <line0> protected void handleFailureMessage( <line1> final AppAnswerEvent event, final AppRequestEvent request, final Event.Type eventType) { <line2> try { <line3> setState(ClientRxSessionState.IDLE); <line4> } catch (Exception e) { <line5> if (logger.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> 	"<line6>        logger.debug(""Failure handling failure message for Event ""+ event+ "" (""+ eventType+ "") and Request ""+ request,e);"	task4	
public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent e) { <line2> TagFocusSelector tagFocusSelector = getActionFocusSelector(); <line3> SignalDocument signalDocument = tagFocusSelector.getActiveSignalDocument(); <line4> if (signalDocument == null) { <line5> return; <line6> } <line7> PositionedTag positionedTag = tagFocusSelector.getActiveTag(); <line8> if (positionedTag == null) { <line9> return; <line10> } <line11> TagDocument tagDocument = <line12> signalDocument.getTagDocuments().get(positionedTag.getTagPositionIndex()); <line13> boolean ok = editTagAnnotationDialog.showDialog(positionedTag.getTag(), true); <line14> if (!ok) { <line15> return; <line16> } <line17> StyledTagSet tagSet = tagDocument.getTagSet(); <line18> tagSet.editTag(positionedTag.getTag()); <line19> tagDocument.invalidate(); <line20> } <line21> } <line22> 	"<line9>      logger.warn(""Target tag doesn't exist"");"	task4	
"public class A { <line0> @POST <line1> @Path(""/transfers/reply"") <line2> @Consumes(MediaType.APPLICATION_XML) <line3> @Produces(MediaType.APPLICATION_JSON) <line4> @Secured(permission = TRANSFERS_REPLY, description = ""Start transfer reply workflow."") <line5> public Response transferReply(InputStream transferReply) { <line6> try (AccessInternalClient client = accessInternalClientFactory.getClient()) { <line7> return client.startTransferReplyWorkflow(transferReply).toResponse(); <line8> } catch (Exception e) { <line9> return Response.status(Status.INTERNAL_SERVER_ERROR) <line10> .entity(getErrorEntity(Status.INTERNAL_SERVER_ERROR, e.getLocalizedMessage())) <line11> .build(); <line12> } <line13> } <line14> } <line15> "	<line9>      LOGGER.error(e);	task4	
public class A { <line0> @Override <line1> public Space apply(String id) { <line2> try { <line3> return retrieve(URI.create(id), Imeji.adminUser); <line4> } catch (ImejiException e) { <line5> } <line6> return null; <line7> } <line8> } <line9> 	"<line5>      LOGGER.info(""Cannot retrieve space: "" + id);"	task4	
"public class A { <line0> protected HiveMetaStoreClient getMetaStoreClient() { <line1> if (hiveClient == null) { <line2> try { <line3> HiveConf hiveConf = new HiveConf(); <line4> hiveConf.set(""hive.metastore.uris"", IMConfig.getProperty(""etl.hive-metastore-uris"")); <line5> hiveConf.set(""hive.exec.dynamic.partition.mode"", ""nonstrict""); <line6> hiveConf.set(""hive.exec.dynamic.partition"", ""true""); <line7> hiveConf.set(""hive.exec.max.dynamic.partitions.pernode"", ""1000""); <line8> hiveClient = new HiveMetaStoreClient(hiveConf); <line9> } catch (MetaException e) { <line10> throw new ETLException(e); <line11> } <line12> } <line13> return hiveClient; <line14> } <line15> } <line16> "	<line10>        LOGGER.error(e);	task4	
public class A { <line0> @Override <line1> public void endWindow() { <line2> super.endWindow(); <line3> if (++windowCount == logWindows) { <line4> long endTime = System.currentTimeMillis(); <line5> totalCount += tupleCount; <line6> windowCount = 0; <line7> beginTime = System.currentTimeMillis(); <line8> tupleCount = 0; <line9> } <line10> } <line11> } <line12> 	"<line6>      logger.info(""total: count: {}; time: {}; average: {}; period: count: {}; time: {}; average: {}"",totalCount,endTime - totalBeginTime,totalCount * 1000 / (endTime - totalBeginTime),tupleCount,endTime - beginTime,tupleCount * 1000 / (endTime - beginTime));"	task4	
"public class A { <line0> @Override <line1> public List<FlightVo> convertFlightToFlightVo(List<Flight> flights) { <line2> List<FlightVo> flightVos = new ArrayList<>(); <line3> CountDownCalculator countDownCalculator = new CountDownCalculator(new Date()); <line4> for (Flight f : flights) { <line5> FlightVo vo = new FlightVo(); <line6> Date countDownToDate = f.getFlightCountDownView().getCountDownTimer(); <line7> CountDownVo countDownVo; <line8> if (countDownToDate == null) { <line9> countDownVo = <line10> new CountDownVo(""Error, no date provided (it is null)!"", false, Long.MIN_VALUE); <line11> } else { <line12> countDownVo = countDownCalculator.getCountDownFromDate(countDownToDate); <line13> } <line14> vo.setCountDown(countDownVo); <line15> vo.setDirection(f.getDirection()); <line16> List<CodeShareVo> codeshareList = new ArrayList<>(); <line17> BeanUtils.copyProperties(f, vo); <line18> BeanUtils.copyProperties(f.getMutableFlightDetails(), vo); <line19> Integer fuzzyHits = 0; <line20> if (f.getFlightHitsFuzzy() != null) { <line21> fuzzyHits = f.getFlightHitsFuzzy().getHitCount(); <line22> vo.setFuzzyHitCount(fuzzyHits); <line23> } <line24> if (f.getFlightHitsGraph() != null) { <line25> vo.setGraphHitCount(f.getFlightHitsGraph().getHitCount()); <line26> } <line27> if (f.getFlightHitsWatchlist() != null) { <line28> vo.setListHitCount(f.getFlightHitsWatchlist().getHitCount()); <line29> } <line30> if (f.getFlightHitsRule() != null) { <line31> vo.setRuleHitCount(f.getFlightHitsRule().getHitCount()); <line32> } <line33> if (f.getFlightHitsExternal() != null) { <line34> vo.setExternalHitCount(f.getFlightHitsExternal().getHitCount()); <line35> } <line36> if (f.getFlightPassengerCount() != null) { <line37> vo.setPassengerCount(f.getFlightPassengerCount().getPassengerCount()); <line38> } <line39> vo.setPaxWatchlistLinkHits(fuzzyHits.longValue()); <line40> List<CodeShareFlight> csl = flightRespository.getCodeSharesForFlight(f.getId()); <line41> for (CodeShareFlight cs : csl) { <line42> CodeShareVo codeshare = new CodeShareVo(); <line43> BeanUtils.copyProperties(cs, codeshare); <line44> codeshareList.add(codeshare); <line45> } <line46> vo.setCodeshares(codeshareList); <line47> flightVos.add(vo); <line48> } <line49> return flightVos; <line50> } <line51> } <line52> "	"<line9>        logger.error(""count down is null, returning generic countdown vo!"");"	task4	
public class A { <line0> private boolean unlocked(Ignite ignite) { <line1> IgniteCache<Integer, Integer> cache = ignite.cache(DEFAULT_CACHE_NAME); <line2> for (Integer key : keys) { <line3> if (cache.isLocalLocked(key, false)) { <line4> return false; <line5> } <line6> } <line7> return true; <line8> } <line9> } <line10> 	"<line4>        log.info(""Key is locked [key="" + key + "", node="" + ignite.name() + ']');"	task4	
"public class A { <line0> public JSONObject toJson() { <line1> JSONObject result = new JSONObject(); <line2> try { <line3> result.put(""id"", this.getId()); <line4> result.put(""level"", this.getLevel()); <line5> result.put(""fileDesc"", this.getFileDesc()); <line6> result.put(""fileName"", this.getFileName()); <line7> result.put(""fileType"", this.getFileType()); <line8> } catch (JSONException ex) { <line9> } <line10> return result; <line11> } <line12> } <line13> "	<line9>      LOG.error(ex.toString(), ex);	task4	
public class A { <line0> public NextState getScannerState(final ScannerContext instance) { <line1> if (!exception) { <line2> try { <line3> return (NextState) scannerState.get(instance); <line4> } catch (final Exception e) { <line5> exception = true; <line6> } <line7> } <line8> return NextState.MORE_VALUES; <line9> } <line10> } <line11> 	"<line5>        LOGGER.warn(""Unable to check partial result of scanner context"", e);"	task4	
"public class A { <line0> private DataObjectAttrExecutor getDayProfileTablePassiveExecutor( <line1> final Set<DayProfileDto> dayProfileSet) { <line2> final AttributeAddress dayProfileTablePassive = <line3> new AttributeAddress(CLASS_ID, OBIS_CODE, ATTRIBUTE_ID_DAY_PROFILE_TABLE_PASSIVE); <line4> final DataObject dayArray = <line5> DataObject.newArrayData( <line6> this.configurationMapper.mapAsList(dayProfileSet, DataObject.class)); <line7> return new DataObjectAttrExecutor( <line8> ""DAYS"", <line9> dayProfileTablePassive, <line10> dayArray, <line11> CLASS_ID, <line12> OBIS_CODE, <line13> ATTRIBUTE_ID_DAY_PROFILE_TABLE_PASSIVE); <line14> } <line15> } <line16> "	"<line7>    LOGGER.info(""DayProfileTablePassive to set is: {}"", this.dlmsHelper.getDebugInfo(dayArray));"	task4	
public class A { <line0> private void processAddedTerminationPoints( <line1> final DataTreeModification<FlowCapableNodeConnector> modification) { <line2> final InstanceIdentifier<FlowCapableNodeConnector> iiToNodeInInventory = <line3> modification.getRootPath().getRootIdentifier(); <line4> TpId terminationPointIdInTopology = provideTopologyTerminationPointId(iiToNodeInInventory); <line5> if (terminationPointIdInTopology != null) { <line6> InstanceIdentifier<TerminationPoint> iiToTopologyTerminationPoint = <line7> provideIIToTopologyTerminationPoint(terminationPointIdInTopology, iiToNodeInInventory); <line8> TerminationPoint point = <line9> prepareTopologyTerminationPoint(terminationPointIdInTopology, iiToNodeInInventory); <line10> sendToTransactionChain(point, iiToTopologyTerminationPoint); <line11> removeLinks(modification.getRootNode().getDataAfter(), point); <line12> } else { <line13> } <line14> } <line15> } <line16> 	"<line13>      LOG.debug(""Inventory node connector key is null. Data can't be written to topology termination""+ "" point"");"	task4	
public class A { <line0> UserToken find(String token) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> UserToken result = null; <line3> try { <line4> daoManager.startTransaction(em); <line5> result = em.find(UserTokenEntity.class, token); <line6> daoManager.commitTransaction(em); <line7> } catch (Exception e) { <line8> daoManager.rollBackTransaction(em); <line9> } finally { <line10> daoManager.closeEntityManager(em); <line11> } <line12> return result; <line13> } <line14> } <line15> 	"<line9>      logger.error(""**** Error in UserTokenDAO:"", e);"	task4	
"public class A { <line0> @Override <line1> public void addAttributes( <line2> Document document, DDMStructure ddmStructure, DDMFormValues ddmFormValues) { <line3> boolean legacyDDMIndexFieldsEnabled = isLegacyDDMIndexFieldsEnabled(); <line4> FieldArray fieldArray = (FieldArray) document.getField(DDM_FIELD_ARRAY); <line5> if ((fieldArray == null) && !legacyDDMIndexFieldsEnabled) { <line6> fieldArray = new FieldArray(DDM_FIELD_ARRAY); <line7> document.add(fieldArray); <line8> } <line9> Set<Locale> locales = ddmFormValues.getAvailableLocales(); <line10> Fields fields = toFields(ddmStructure, ddmFormValues); <line11> for (Field field : fields) { <line12> try { <line13> String indexType = ddmStructure.getFieldProperty(field.getName(), ""indexType""); <line14> if (Validator.isNull(indexType) || indexType.equals(""none"")) { <line15> continue; <line16> } <line17> DDMFormField ddmFormField = ddmStructure.getDDMFormField(field.getName()); <line18> String name = null; <line19> Serializable value = null; <line20> if (GetterUtil.getBoolean(ddmStructure.getFieldProperty(field.getName(), ""localizable""))) { <line21> for (Locale locale : locales) { <line22> name = <line23> encodeName( <line24> ddmStructure.getStructureId(), <line25> ddmFormField.getFieldReference(), <line26> locale, <line27> indexType); <line28> value = field.getValue(locale); <line29> if (legacyDDMIndexFieldsEnabled) { <line30> addToDocument(document, field, indexType, name, value); <line31> } else { <line32> fieldArray.addField(createField(ddmFormField, field, indexType, locale, name, value)); <line33> } <line34> } <line35> } else { <line36> name = <line37> encodeName( <line38> ddmStructure.getStructureId(), ddmFormField.getFieldReference(), null, indexType); <line39> value = field.getValue(ddmFormValues.getDefaultLocale()); <line40> if (legacyDDMIndexFieldsEnabled) { <line41> addToDocument(document, field, indexType, name, value); <line42> } else { <line43> fieldArray.addField(createField(ddmFormField, field, indexType, null, name, value)); <line44> } <line45> } <line46> } catch (Exception exception) { <line47> if (log.isWarnEnabled()) { <line48> } <line49> } <line50> } <line51> } <line52> } <line53> "	<line48>          log.warn(exception, exception);	task4	
"public class A { <line0> @RequestMapping(value = ""/updateMicromapperEnabled.action"", method = RequestMethod.POST) <line1> @ResponseBody <line2> public Map<String, Object> updateMicromapperEnabled( <line3> @RequestParam Boolean isMicromapperEnabled, @RequestParam String code) throws Exception { <line4> try { <line5> Collection collectionToUpdate = collectionService.findByCode(code); <line6> if (collectionToUpdate != null) { <line7> collectionToUpdate.setMicromappersEnabled(isMicromapperEnabled); <line8> collectionService.update(collectionToUpdate); <line9> } <line10> return getUIWrapper(null, true); <line11> } catch (Exception e) { <line12> return getUIWrapper( <line13> false, ""Unable to update micromapperEnabled for collection, code = "" + code); <line14> } <line15> } <line16> } <line17> "	"<line12>      logger.error(""Error while updating isMicromapperEnabled flag for crisis: "" + code, e);"	task4	
"public class A { <line0> @Override <line1> public boolean processEvents(@SuppressWarnings(""rawtypes"") List<AsyncEvent> events) { <line2> changeTotalEvents(events.size()); <line3> if (!events.isEmpty()) { <line4> try { <line5> checkInitialized(events.get(0).getRegion()); <line6> } catch (RuntimeException ex) { <line7> changeFailedEvents(events.size()); <line8> return true; <line9> } <line10> } <line11> Boolean initialPdxReadSerialized = cache.getPdxReadSerializedOverride(); <line12> cache.setPdxReadSerializedOverride(true); <line13> try { <line14> processEventsList(events); <line15> } finally { <line16> cache.setPdxReadSerializedOverride(initialPdxReadSerialized); <line17> } <line18> return true; <line19> } <line20> } <line21> "	"<line8>        logger.error(""Exception initializing JdbcAsyncWriter"", ex);"	task4	
public class A { <line0> public void postPreset(DecimalType command) { <line1> ContentItem item = null; <line2> try { <line3> item = handler.getPresetContainer().get(command.intValue()); <line4> postContentItem(item); <line5> } catch (NoPresetFoundException e) { <line6> } <line7> } <line8> } <line9> 	"<line6>      logger.warn(""{}: No preset found at id: {}"", handler.getDeviceName(), command.intValue());"	task4	
public class A { <line0> @Test <line1> public void test_02_long() { <line2> long seed = 20100614; <line3> int lenMask = 0xffff; <line4> int numTests = 10; <line5> randDnaSeqTest(numTests, lenMask, seed); <line6> } <line7> } <line8> 	"<line2>    Log.debug(""Test"");"	task4	
public class A { <line0> @Override <line1> public void dropIndex() { <line2> try { <line3> Path[] indexPaths = new Path[] {partitionIndexPath(metaClient), fileIdIndexPath(metaClient)}; <line4> for (Path indexPath : indexPaths) { <line5> if (metaClient.getFs().exists(indexPath)) { <line6> metaClient.getFs().delete(indexPath); <line7> } <line8> } <line9> } catch (IOException ioe) { <line10> throw new HoodieIOException(ioe.getMessage(), ioe); <line11> } <line12> } <line13> } <line14> 	"<line6>          LOG.info(""Dropping bootstrap index. Deleting file : "" + indexPath);"	task4	
public class A { <line0> void setDefault(SimpleEntry<String, String> keyValueDefault, String currentValue) { <line1> if (StringUtils.isNotEmpty(currentValue)) { <line2> return; <line3> } <line4> clearPropertyDirect(keyValueDefault.getKey()); <line5> addPropertyDirect(keyValueDefault.getKey(), keyValueDefault.getValue()); <line6> } <line7> } <line8> 	"<line6>    LOG.info(""Property (set to default) {} = {}"", keyValueDefault.getKey(), keyValueDefault.getValue());"	task4	
public class A { <line0> @Override <line1> public void setGlobalAlpha(final double globalAlpha) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> if (globalAlpha >= 0 && globalAlpha <= 1) { <line5> globalAlpha_ = (float) globalAlpha; <line6> final AlphaComposite composite = <line7> AlphaComposite.getInstance(AlphaComposite.SRC_OVER, globalAlpha_); <line8> graphics2D_.setComposite(composite); <line9> } <line10> } <line11> } <line12> 	"<line3>      LOG.debug(""["" + id_ + ""] setGlobalAlpha("" + globalAlpha + "")"");"	task4	
"public class A { <line0> AgentServerHandler loadServerHandler(String jarPath) throws AgentLoaderException { <line1> AgentServerHandler handler = null; <line2> Class pluginClass = null; <line3> try { <line4> PluginLoader loader = PluginLoader.create(jarPath, _loader); <line5> PluginLoader.setClassLoader(loader); <line6> pluginClass = loader.loadPlugin(); <line7> handler = (AgentServerHandler) pluginClass.newInstance(); <line8> } catch (Exception e) { <line9> throw new AgentLoaderException(""Unable to load server handler "" + ""jar: "" + e.getMessage()); <line10> } finally { <line11> if (handler != null) { <line12> PluginLoader.resetClassLoader(handler); <line13> } <line14> } <line15> validateServerHandler(handler, pluginClass.getName()); <line16> return handler; <line17> } <line18> } <line19> "	"<line9>      this.logger.error(""Error loading server handler jar"", e);"	task4	
"public class A { <line0> private void benchmarkAddExtendedDataRows( <line1> Random random, int vertexCount, int extendedDataRowCount) { <line2> double startTime = System.currentTimeMillis(); <line3> for (int i = 0; i < extendedDataRowCount; i++) { <line4> String row = ""row"" + i; <line5> String vertexId = ""v"" + random.nextInt(vertexCount); <line6> graph <line7> .prepareVertex(vertexId, VISIBILITY_A) <line8> .addExtendedData(""table1"", row, ""column1"", ""value1"", VISIBILITY_A) <line9> .save(AUTHORIZATIONS_ALL); <line10> } <line11> graph.flush(); <line12> double endTime = System.currentTimeMillis(); <line13> } <line14> } <line15> "	"<line13>    LOGGER.info(""add rows in %.3fs"", (endTime - startTime) / 1000);"	task4	
public class A { <line0> public GSSContext run() { <line1> try { <line2> GSSManager manager = GSSManager.getInstance(); <line3> GSSName peerName = manager.createName(servicePrincipalName, GSSName.NT_HOSTBASED_SERVICE); <line4> GSSContext context = manager.createContext(peerName, null, null, GSSContext.DEFAULT_LIFETIME); <line5> while (!context.isEstablished()) { <line6> context.initSecContext(socket.getInputStream(), socket.getOutputStream()); <line7> } <line8> return context; <line9> } catch (Exception e) { <line10> return null; <line11> } <line12> } <line13> } <line14> 	"<line10>      log.error(""Unable to authenticate client against Kerberos"", e);"	task4	
public class A { <line0> @Nonnull <line1> @Override <line2> public List<DiffFragment> compareChars( <line3> @Nonnull CharSequence text1, <line4> @Nonnull CharSequence text2, <line5> @Nonnull ComparisonPolicy policy, <line6> @Nonnull ProgressIndicator indicator) <line7> throws DiffTooBigException { <line8> if (policy == ComparisonPolicy.IGNORE_WHITESPACES) { <line9> return convertIntoDiffFragments(ByChar.compareIgnoreWhitespaces(text1, text2, indicator)); <line10> } <line11> if (policy == ComparisonPolicy.DEFAULT) { <line12> return convertIntoDiffFragments(ByChar.compareTwoStep(text1, text2, indicator)); <line13> } <line14> return convertIntoDiffFragments(ByChar.compareTwoStep(text1, text2, indicator)); <line15> } <line16> } <line17> 	"<line14>    LOG.warn(policy.toString() + "" is not supported by ByChar comparison"");"	task4	
public class A { <line0> static GbpAceBuilder allowExternalNetworksForEp( <line1> @Nonnull RendererEndpointKey rendEp, AccessListUtil.ACE_DIRECTION dir) { <line2> InetAddress byName; <line3> try { <line4> byName = InetAddress.getByName(substringBeforeSlash(rendEp.getAddress())); <line5> } catch (UnknownHostException e) { <line6> return null; <line7> } <line8> if (byName instanceof Inet4Address) { <line9> if (AccessListUtil.ACE_DIRECTION.INGRESS.equals(dir)) { <line10> return new GbpAceBuilder(PERMIT_EXTERNAL_INGRESS) <line11> .setIpAddresses(new Ipv4Prefix(rendEp.getAddress()), null) <line12> .setPermit(); <line13> } else { <line14> return new GbpAceBuilder(PERMIT_EXTERNAL_EGRESS) <line15> .setIpAddresses(null, new Ipv4Prefix(rendEp.getAddress())) <line16> .setPermit(); <line17> } <line18> } else if (byName instanceof Inet6Address) { <line19> if (AccessListUtil.ACE_DIRECTION.INGRESS.equals(dir)) { <line20> new GbpAceBuilder(PERMIT_EXTERNAL_INGRESS) <line21> .setIpAddresses(new Ipv6Prefix(rendEp.getAddress()), null) <line22> .setPermit(); <line23> } else { <line24> new GbpAceBuilder(PERMIT_EXTERNAL_EGRESS) <line25> .setIpAddresses(null, new Ipv6Prefix(rendEp.getAddress())) <line26> .setPermit(); <line27> } <line28> } <line29> return null; <line30> } <line31> } <line32> 	"<line6>      LOG.error(""Failed to parse IP address {}"", e);"	task4	
public class A { <line0> public URI getURI() { <line1> switch (this.uriType) { <line2> case BPELVAR: <line3> return null; <line4> case BOTH: <line5> try { <line6> return new URI(this.getURIPart()); <line7> } catch (final URISyntaxException e) { <line8> } <line9> default: <line10> return this.uri; <line11> } <line12> } <line13> } <line14> 	"<line8>          BPELRESTLightElement.LOG.error(""Internal Error: Stored URI was invalid"", e);"	task4	
public class A { <line0> @Override <line1> public void timeoutExpired(Request request) { <line2> try { <line3> sendAndStateLock.lock(); <line4> handleEvent(new Event(Event.Type.FAILED_SEND_RECORD, createAccountRequest(request))); <line5> } catch (Exception e) { <line6> } finally { <line7> sendAndStateLock.unlock(); <line8> } <line9> } <line10> } <line11> 	"<line6>      logger.debug(""Can not handle timeout event"", e);"	task4	
"public class A { <line0> @Override <line1> public String get() { <line2> return AccessController.doPrivileged( <line3> (PrivilegedAction<String>) <line4> () -> { <line5> try { <line6> return resourceBundleLocator <line7> .getBundle(INTRIGUE_BASE_NAME) <line8> .getString(""validation.attribute.unsupported""); <line9> } catch (IOException e) { <line10> return DEFAULT_MESSAGE_FORMAT; <line11> } <line12> }); <line13> } <line14> } <line15> "	"<line10>                LOGGER.debug(""Failed getting {} resource bundle, using default \""{}\"""",INTRIGUE_BASE_NAME,DEFAULT_MESSAGE_FORMAT);"	task4	
"public class A { <line0> public Config getConfig(String factoryPid, String identifier) throws IOException { <line1> try { <line2> Configuration[] configurations = <line3> configAdmin.listConfigurations(""(service.factoryPid="" + factoryPid + "")""); <line4> if (configurations != null) { <line5> for (Configuration configuration : configurations) { <line6> Object filename = configuration.getProperties().get(FELIX_FILEINSTALL_FILENAME); <line7> if (filename != null <line8> && filename.toString().endsWith(""/"" + factoryPid + ""-"" + identifier + "".cfg"")) { <line9> return new ConfigImpl(configuration, identifier); <line10> } <line11> } <line12> } <line13> } catch (InvalidSyntaxException e) { <line14> } <line15> Configuration result = configAdmin.createFactoryConfiguration(factoryPid, ""?""); <line16> return new ConfigImpl(result, identifier); <line17> } <line18> } <line19> "	"<line14>      logger.debug(""invalid syntax"", e);"	task4	
public class A { <line0> @Override <line1> public void process(DistributionMessage msg) { <line2> if (msg instanceof MembershipViewReplyMessage) { <line3> PersistentMembershipView view = ((MembershipViewReplyMessage) msg).view; <line4> if (logger.isDebugEnabled()) { <line5> } <line6> if (view != null) { <line7> synchronized (this) { <line8> this.views.add(view); <line9> } <line10> } <line11> } <line12> super.process(msg); <line13> } <line14> } <line15> 	"<line5>        logger.debug(""MembershipViewReplyProcessor received {}"", view);"	task4	
public class A { <line0> @Override <line1> public T localeResolver(LocaleResolver localeResolver) { <line2> if (LOG.isDebugEnabled()) { <line3> if (localeResolver != null) { <line4> } <line5> } <line6> this.localeResolver = localeResolver; <line7> return thisAsT(); <line8> } <line9> } <line10> 	"<line4>        LOG.debug(""Setting custom LocaleResolver of type "" + localeResolver.getClass().getName());"	task4	
public class A { <line0> public void checkPolicy() { <line1> } <line2> } <line3> 	"<line1>    log.info(""controller.policyFlags()"");"	task4	
"public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> HuiRelation relation = HUITypeFactory.getInstance().getRelation(linkId); <line4> String hql; <line5> if (PERSON_TYPE_IDS.contains(relation.getFrom())) { <line6> hql = HQL_FOR_LINK_DOWN_FROM_PERSON; <line7> } else if (PERSON_TYPE_IDS.contains(relation.getTo())) { <line8> hql = HQL_FOR_LINK_UP_FROM_PERSON; <line9> } else { <line10> throw new IllegalStateException( <line11> ""Unable to find assignee for task/control "" <line12> + uuid <line13> + "", unsupported relation type "" <line14> + linkId); <line15> } <line16> IBaseDao<Configuration, Serializable> dao = getDaoFactory().getDAO(Configuration.class); <line17> List<?> result = <line18> dao.findByQuery(hql, new String[] {uuid, linkId, Configuration.PROP_USERNAME}); <line19> if (result != null && !result.isEmpty()) { <line20> username = (String) result.get(0); <line21> } <line22> } catch (Exception t) { <line23> } <line24> } <line25> } <line26> "	"<line23>      logger.error(""Error while loading username for control uuid: "" + uuid, t);"	task4	
public class A { <line0> private void runIndexing(Session upperSession, Tuple tuple) { <line1> initSession(upperSession); <line2> try { <line3> index(upperSession, entity(upperSession, tuple)); <line4> } catch (Throwable e) { <line5> errorHandler.handleException(log.massIndexerUnexpectedErrorMessage(), e); <line6> } finally { <line7> } <line8> } <line9> } <line10> 	"<line7>      log.debug(""finished"");"	task4	
public class A { <line0> @Override <line1> public FileVisitResult visitFile(final Path path, final BasicFileAttributes attrs) <line2> throws IOException { <line3> if (attrs.isDirectory()) { <line4> return FileVisitResult.CONTINUE; <line5> } <line6> final File file = path.toFile(); <line7> if (sectionName == null || !sectionName.equals(file.getParentFile().getName())) { <line8> return FileVisitResult.CONTINUE; <line9> } <line10> final String identifier = file.getName(); <line11> ResourceClaim resourceClaim = <line12> resourceClaimManager.getResourceClaim(containerName, sectionName, identifier); <line13> if (resourceClaim == null) { <line14> resourceClaim = <line15> resourceClaimManager.newResourceClaim( <line16> containerName, sectionName, identifier, false, false); <line17> } <line18> activeResourceClaims.add(resourceClaim); <line19> return FileVisitResult.CONTINUE; <line20> } <line21> } <line22> 	"<line8>      LOG.debug(""Obtaining active resource claims, will NOT consider {} because its parent is not the""+ "" current section"",file);"	task4	
"public class A { <line0> public void delete(String filename) { <line1> File file = new File(filename); <line2> if (!file.delete()) { <line3> throw new IllegalStateException(""Unable to delete the following file: "" + filename); <line4> } <line5> } <line6> } <line7> "	"<line3>      LOGGER.error(""Unable to delete the following file: "" + filename);"	task4	
