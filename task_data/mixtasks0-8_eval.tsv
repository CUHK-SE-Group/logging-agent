code	label	task	lineID
"public class A { <line0> @Override <line1> public void appendJsonLog(ActionData actionData) { <line2> if (isJsonLogActive()) { <line3> String dir = ""gamelogsJson""; <line4> File saveDir = new File(dir); <line5> if (!saveDir.exists()) { <line6> saveDir.mkdirs(); <line7> } <line8> actionData.sessionId = getSessionId(); <line9> String logFileName = dir + File.separator + ""game-"" + actionData.gameId + "".json""; <line10> try (PrintWriter out = <line11> new PrintWriter(new BufferedWriter(new FileWriter(logFileName, true)))) { <line12> out.println(actionData.toJson()); <line13> } catch (IOException e) { <line14> logger.error(""Cant write JSON game log file - "" + logFileName, e); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line14>        logger.error(""Cant write JSON game log file - "" + logFileName, e);"	task0	
"public class A { <line0> public void setName(final String s) { <line1> logger.trace(""setting name: {}"", s); <line2> name = s; <line3> } <line4> } <line5> "	"<line1>    logger.trace(""setting name: {}"", s);"	task0	
"public class A { <line0> private String deleteAssetGroupDetails(final DeleteAssetGroupRequest deleteAssetGroupRequest) <line1> throws PacManException { <line2> if (assetGroupRepository.existsById(deleteAssetGroupRequest.getGroupId())) { <line3> AssetGroupDetails assetGroupDetails = <line4> assetGroupRepository.findById(deleteAssetGroupRequest.getGroupId()).get(); <line5> boolean isDeleted = deleteAssetGroupAlias(assetGroupDetails); <line6> if (isDeleted) { <line7> try { <line8> assetGroupRepository.delete(assetGroupDetails); <line9> return ASSET_GROUP_DELETE_SUCCESS; <line10> } catch (Exception exception) { <line11> log.error(UNEXPECTED_ERROR_OCCURRED, exception); <line12> commonService.invokeAPI(""POST"", ALIASES, assetGroupDetails.getAliasQuery()); <line13> throw new PacManException( <line14> UNEXPECTED_ERROR_OCCURRED.concat("": "").concat(exception.getMessage())); <line15> } <line16> } else { <line17> return ASSET_GROUP_DELETE_FAILED; <line18> } <line19> } else { <line20> throw new PacManException(ASSET_GROUP_NOT_EXITS); <line21> } <line22> } <line23> } <line24> "	<line11>          log.error(UNEXPECTED_ERROR_OCCURRED, exception);	task0	
"public class A { <line0> public void setAsTag(String refId) { <line1> try (PreparedStatement statement = <line2> prepareStatement( <line3> ""UPDATE refs SET tag = true WHERE (refId = ? OR refName = ?) AND deleted = false"")) { <line4> statement.setString(1, sanitizeRefId(refId)); <line5> statement.setString(2, sanitizeRefId(refId)); <line6> statement.executeUpdate(); <line7> execUpdate( <line8> String.format( <line9> ""REVOKE INSERT, UPDATE, DELETE ON nodes%1$s, edges%1$s, artifacts%1$s FROM %2$s"", <line10> sanitizeRefId(refId), EmsConfig.get(""pg.user""))); <line11> } catch (Exception e) { <line12> logger.warn(String.format(""%s"", LogUtil.getStackTrace(e))); <line13> } finally { <line14> close(); <line15> } <line16> } <line17> } <line18> "	"<line12>      logger.warn(String.format(""%s"", LogUtil.getStackTrace(e)));"	task0	
"public class A { <line0> @Override <line1> void execute(ExoContainer exoContainer) { <line2> try { <line3> DocumentEditorProvider editorProvider = documentService.getEditorProvider(provider); <line4> Identity identity = userIdentity(userId); <line5> boolean allowed = editorProvider.isAvailableForUser(identity); <line6> List<String> availableProviders = service.getAllAvailableProviders(identity); <line7> String currentProvider = documentService.getCurrentDocumentProvider(fileId, workspace); <line8> boolean available = allowed && (currentProvider == null || provider.equals(currentProvider)); <line9> service.sendCurrentProviderInfo(fileId, available, availableProviders); <line10> if (currentProvider == null) { <line11> setCurrentDocumentProvider(fileId, workspace, provider); <line12> } <line13> } catch (DocumentEditorProviderNotFoundException | RepositoryException e) { <line14> LOG.error( <line15> ""Cannot send current provider info for fileId: "" + fileId + "", workspace: "" + workspace, <line16> e); <line17> } <line18> } <line19> } <line20> "	"<line14>      LOG.error(""Cannot send current provider info for fileId: "" + fileId + "", workspace: "" + workspace,e);"	task0	
"public class A { <line0> private boolean isPrevEventMatchingCall( <line1> final BeforeOperationEvent beforeOperationEvent, <line2> final AbstractTraceEvent prevEvent, <line3> final Class<? extends CallOperationEvent> callClass) { <line4> if ((prevEvent != null) <line5> && callClass.isAssignableFrom(prevEvent.getClass()) <line6> && (prevEvent.getOrderIndex() == (beforeOperationEvent.getOrderIndex() - 1))) { <line7> if (this.callsReferencedOperationOf((CallOperationEvent) prevEvent, beforeOperationEvent)) { <line8> return true; <line9> } else if (this.enhanceCallDetection) { <line10> final boolean isConstructor = beforeOperationEvent instanceof BeforeConstructorEvent; <line11> final CallOperationEvent callEvent = (CallOperationEvent) prevEvent; <line12> final Signature callSignature = <line13> ClassOperationSignaturePair.splitOperationSignatureStr( <line14> callEvent.getCalleeOperationSignature(), <line15> isConstructor && this.enhanceJavaConstructors) <line16> .getSignature(); <line17> final Signature afterSignature = <line18> ClassOperationSignaturePair.splitOperationSignatureStr( <line19> beforeOperationEvent.getOperationSignature(), <line20> isConstructor && this.enhanceJavaConstructors) <line21> .getSignature(); <line22> if (callSignature.equals(afterSignature) <line23> && callEvent <line24> .getCalleeClassSignature() <line25> .equals(beforeOperationEvent.getClassSignature())) { <line26> this.logger.debug(""Guessed call of \n\t{}\n\t{}"", callEvent, beforeOperationEvent); <line27> return true; <line28> } <line29> } <line30> } <line31> return false; <line32> } <line33> } <line34> "	"<line26>          this.logger.debug(""Guessed call of \n\t{}\n\t{}"", callEvent, beforeOperationEvent);"	task0	
"public class A { <line0> @Override <line1> public void apply() { <line2> try { <line3> for (int i = 0; i < TOP_CHANGE_CNT; i++) { <line4> if (failed.get()) return; <line5> Collection<String> names = new GridLeanSet<>(3); <line6> try { <line7> for (int j = 0; j < 3; j++) { <line8> if (failed.get()) return; <line9> String name = UUID.randomUUID().toString(); <line10> log.info(""Start node: "" + name); <line11> Ignite g = startGrid(name); <line12> names.add(name); <line13> cb.apply(g); <line14> } <line15> } finally { <line16> for (String name : names) stopGrid(name); <line17> } <line18> } <line19> } catch (Exception e) { <line20> if (failed.compareAndSet(false, true)) throw F.wrap(e); <line21> } <line22> } <line23> } <line24> "	"<line10>            log.info(""Start node: "" + name);"	task0	
"public class A { <line0> @Override <line1> public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) { <line2> logger.debug(""bridgeStatusChanged {} for thing {}"", bridgeStatusInfo, getThing().getUID()); <line3> Bridge bridge = getBridge(); <line4> if (bridge != null) { <line5> initializeBridge(bridge.getHandler(), bridgeStatusInfo.getStatus()); <line6> } <line7> } <line8> } <line9> "	"<line2>    logger.debug(""bridgeStatusChanged {} for thing {}"", bridgeStatusInfo, getThing().getUID());"	task0	
"public class A { <line0> public void update( <line1> EventBean[] newEvents, EventBean[] oldEvents, EPStatement statement, EPRuntime runtime) { <line2> if (newEvents == null) { <line3> return; <line4> } <line5> for (int i = 0; i < newEvents.length; i++) { <line6> if (log.isInfoEnabled()) { <line7> log.info( <line8> ""IPAddress: "" <line9> + newEvents[i].get(""ipAddress"") <line10> + "" Avg Duration: "" <line11> + newEvents[i].get(""avg(duration)"")); <line12> } <line13> } <line14> } <line15> } <line16> "	"<line7>        log.info(""IPAddress: ""+ newEvents[i].get(""ipAddress"")+ "" Avg Duration: ""+ newEvents[i].get(""avg(duration)""));"	task0	
"public class A { <line0> @Override <line1> public Pixel read(Kryo kryo, Input input, Class<Pixel> type) { <line2> log.debug(""De-serializing Pixel...""); <line3> int X = input.readInt(); <line4> int Y = input.readInt(); <line5> int ResolutionX = input.readInt(); <line6> int ResolutionY = input.readInt(); <line7> boolean isDuplicate = input.readBoolean(); <line8> int currentPartitionId = input.readInt(); <line9> Pixel pixel = new Pixel(X, Y, ResolutionX, ResolutionY, isDuplicate, currentPartitionId); <line10> return pixel; <line11> } <line12> } <line13> "	"<line2>    log.debug(""De-serializing Pixel..."");"	task0	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public List<Role> getRoles() { <line2> log.debug(""Retrieving all role names...""); <line3> return entityManager.createQuery(""select r from Role r order by name"").getResultList(); <line4> } <line5> } <line6> "	"<line2>    log.debug(""Retrieving all role names..."");"	task0	
"public class A { <line0> @Override <line1> public void updateClusterConfig(ClusterConfigRequest request) { <line2> if (clusterManager() != null) { <line3> OHazelcastPlugin plugin = clusterManager().getHazelcastPlugin(); <line4> ODistributedConfiguration storageCfg = plugin.getDatabaseConfiguration(GraphStorage.DB_NAME); <line5> final OModifiableDistributedConfiguration newCfg = storageCfg.modify(); <line6> for (ClusterServerConfig server : request.getServers()) { <line7> ServerRole newRole = server.getRole(); <line8> ROLES newORole = ROLES.valueOf(newRole.name()); <line9> ROLES oldRole = newCfg.getServerRole(server.getName()); <line10> if (oldRole != newORole) { <line11> log.debug( <line12> ""Updating server role {"" <line13> + server.getName() <line14> + ""} from {"" <line15> + oldRole <line16> + ""} to {"" <line17> + newRole <line18> + ""}""); <line19> newCfg.setServerRole(server.getName(), newORole); <line20> } <line21> } <line22> String newWriteQuorum = request.getWriteQuorum(); <line23> if (newWriteQuorum != null) { <line24> if (newWriteQuorum.equalsIgnoreCase(""all"") || newWriteQuorum.equalsIgnoreCase(""majority"")) { <line25> newCfg.getDocument().setProperty(""writeQuorum"", newWriteQuorum); <line26> } else { <line27> try { <line28> int newWriteQuorumInt = Integer.parseInt(newWriteQuorum); <line29> newCfg.getDocument().setProperty(""writeQuorum"", newWriteQuorumInt); <line30> } catch (Exception e) { <line31> throw new RuntimeException(""Unsupported write quorum value {"" + newWriteQuorum + ""}""); <line32> } <line33> } <line34> } <line35> Integer newReadQuorum = request.getReadQuorum(); <line36> if (newReadQuorum != null) { <line37> newCfg.getDocument().setProperty(""readQuorum"", newReadQuorum); <line38> } <line39> plugin.updateCachedDatabaseConfiguration(GraphStorage.DB_NAME, newCfg, true); <line40> } else { <line41> throw error(BAD_REQUEST, ""error_cluster_status_only_available_in_cluster_mode""); <line42> } <line43> } <line44> } <line45> "	"<line11>          log.debug(""Updating server role {""+ server.getName()+ ""} from {""+ oldRole+ ""} to {""+ newRole+ ""}"");"	task0	
"public class A { <line0> private void drawPoint( <line1> PdfContext context, Rectangle iconRect, Color fillColor, Color strokeColor) { <line2> float baseWidth = iconRect.getWidth() / 10; <line3> SymbolInfo symbol = styleInfo.getSymbol(); <line4> if (symbol.getImage() != null) { <line5> try { <line6> Image pointImage = Image.getInstance(symbol.getImage().getHref()); <line7> context.drawImage(pointImage, iconRect, iconRect); <line8> } catch (Exception ex) { <line9> log.error(""Not able to create image for POINT Symbol"", ex); <line10> } <line11> } else if (symbol.getRect() != null) { <line12> context.fillRectangle(iconRect, fillColor); <line13> context.strokeRectangle(iconRect, strokeColor, baseWidth / 2); <line14> } else { <line15> context.fillEllipse(iconRect, fillColor); <line16> context.strokeEllipse(iconRect, strokeColor, baseWidth / 2); <line17> } <line18> } <line19> } <line20> "	"<line9>        log.error(""Not able to create image for POINT Symbol"", ex);"	task0	
"public class A { <line0> protected Response JSONRepresentation(Object entity) { <line1> try { <line2> String jsonStr = toJson(entity); <line3> return OK(jsonStr); <line4> } catch (IOException e) { <line5> logger.error(""Failed to convert "" + entity + "" to JSON response"", e); <line6> return serverError(); <line7> } <line8> } <line9> } <line10> "	"<line5>      logger.error(""Failed to convert "" + entity + "" to JSON response"", e);"	task0	
"public class A { <line0> private static LoggingConfigurationType applyProfilingConfiguration( <line1> PrismObject<SystemConfigurationType> systemConfigurationPrism, <line2> ProfilingConfigurationType profilingConfig, <line3> boolean subsystemProfiling) { <line4> SystemConfigurationType systemConfig = systemConfigurationPrism.asObjectable(); <line5> LoggingConfigurationType loggingConfig = systemConfig.getLogging(); <line6> if (loggingConfig != null) { <line7> if (checkXsdBooleanValue(profilingConfig.isRequestFilter())) { <line8> ClassLoggerConfigurationType requestFilterLogger = new ClassLoggerConfigurationType(); <line9> requestFilterLogger.setPackage(REQUEST_FILTER_LOGGER_CLASS_NAME); <line10> requestFilterLogger.setLevel(LoggingLevelType.TRACE); <line11> requestFilterLogger.getAppender().clear(); <line12> requestFilterLogger.getAppender().add(APPENDER_IDM_PROFILE); <line13> loggingConfig.getClassLogger().add(requestFilterLogger); <line14> } <line15> if (subsystemProfiling) { <line16> ClassLoggerConfigurationType subsystemLogger = new ClassLoggerConfigurationType(); <line17> subsystemLogger.setPackage(SUBSYSTEM_PROFILING_LOGGER); <line18> subsystemLogger.setLevel(LoggingLevelType.DEBUG); <line19> subsystemLogger.getAppender().clear(); <line20> subsystemLogger.getAppender().add(APPENDER_IDM_PROFILE); <line21> loggingConfig.getClassLogger().add(subsystemLogger); <line22> } <line23> } <line24> LOGGER.info(""Applying profiling configuration.""); <line25> return loggingConfig; <line26> } <line27> } <line28> "	"<line24>    LOGGER.info(""Applying profiling configuration."");"	task0	
"public class A { <line0> private double computeLoadFactor() { <line1> ensureInEventLoop(); <line2> long pendingRequestCountMin = Long.MAX_VALUE; <line3> long pendingRequestCountTotal = 0L; <line4> long channelCount = 0; <line5> for (Channel channel : this.availableChannels) { <line6> final RntbdRequestManager manager = channel.pipeline().get(RntbdRequestManager.class); <line7> if (manager == null) { <line8> logger.debug(""Channel({}) connection lost"", channel); <line9> continue; <line10> } <line11> final long pendingRequestCount = manager.pendingRequestCount(); <line12> if (pendingRequestCount < pendingRequestCountMin) { <line13> pendingRequestCountMin = pendingRequestCount; <line14> } <line15> pendingRequestCountTotal += pendingRequestCount; <line16> channelCount++; <line17> } <line18> for (Channel channel : this.acquiredChannels.values()) { <line19> final RntbdRequestManager manager = channel.pipeline().get(RntbdRequestManager.class); <line20> if (manager != null) { <line21> final long pendingRequestCount = manager.pendingRequestCount(); <line22> if (pendingRequestCount < pendingRequestCountMin) { <line23> pendingRequestCountMin = pendingRequestCount; <line24> } <line25> pendingRequestCountTotal += pendingRequestCount; <line26> } <line27> channelCount++; <line28> } <line29> return channelCount > 0 <line30> ? (double) pendingRequestCountTotal / (channelCount * this.maxRequestsPerChannel) <line31> : 1D; <line32> } <line33> } <line34> "	"<line8>        logger.debug(""Channel({}) connection lost"", channel);"	task0	
"public class A { <line0> public void start() { <line1> if (container.getState().isStarted()) <line2> throw new IllegalArgumentException( <line3> ""Container "" <line4> + description <line5> + "" failed to start because it is currently "" <line6> + container.getState()); <line7> LocalConfiguration config = getConfiguration(); <line8> int servletPort = portSupplier.getAsInt(); <line9> int containerRmiPort = portSupplier.getAsInt(); <line10> int tomcatAjpPort = portSupplier.getAsInt(); <line11> config.setProperty(ServletPropertySet.PORT, Integer.toString(servletPort)); <line12> config.setProperty(GeneralPropertySet.RMI_PORT, Integer.toString(containerRmiPort)); <line13> config.setProperty(TomcatPropertySet.AJP_PORT, Integer.toString(tomcatAjpPort)); <line14> config.setProperty(GeneralPropertySet.PORT_OFFSET, ""0""); <line15> int jvmJmxPort = portSupplier.getAsInt(); <line16> String jvmArgs = ""-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address="" + jvmJmxPort; <line17> if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)) { <line18> jvmArgs += <line19> "" --add-opens java.base/java.lang.module=ALL-UNNAMED"" <line20> + "" --add-opens java.base/jdk.internal.module=ALL-UNNAMED"" <line21> + "" --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED"" <line22> + "" --add-opens java.base/jdk.internal.misc=ALL-UNNAMED"" <line23> + "" --add-opens java.base/jdk.internal.ref=ALL-UNNAMED"" <line24> + "" --add-opens java.base/jdk.internal.platform.cgroupv1=ALL-UNNAMED"" <line25> + "" --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED""; <line26> } <line27> config.setProperty(GeneralPropertySet.START_JVMARGS, jvmArgs); <line28> container.setConfiguration(config); <line29> try { <line30> logger.info(""Starting container {} RMI Port: {}"", description, jvmJmxPort); <line31> writeSettings(); <line32> container.start(); <line33> } catch (Exception e) { <line34> throw new RuntimeException( <line35> ""Something very bad happened to this container when starting. Check the cargo_logs folder"" <line36> + "" for container logs."", <line37> e); <line38> } <line39> } <line40> } <line41> "	"<line30>      logger.info(""Starting container {} RMI Port: {}"", description, jvmJmxPort);"	task0	
"public class A { <line0> protected void setRecordCipher() { <line1> KeySet keySet = getKeySet(tlsContext); <line2> LOGGER.debug(""Setting new Cipher in RecordLayer""); <line3> RecordCipher recordCipher = RecordCipherFactory.getRecordCipher(tlsContext, keySet); <line4> tlsContext.getRecordLayer().setRecordCipher(recordCipher); <line5> } <line6> } <line7> "	"<line2>    LOGGER.debug(""Setting new Cipher in RecordLayer"");"	task0	
"public class A { <line0> public <T extends ComputeMetadata> T findObjectOfTypeForServerOrNull( <line1> Set<? extends T> supply, <line2> String type, <line3> final String objectId, <line4> final RegionAndId serverInRegion) { <line5> try { <line6> return find( <line7> supply, <line8> new Predicate<T>() { <line9> @Override <line10> public boolean apply(T input) { <line11> return input <line12> .getId() <line13> .equals( <line14> RegionAndId.fromRegionAndId(serverInRegion.getRegion(), objectId) <line15> .slashEncode()); <line16> } <line17> }); <line18> } catch (NoSuchElementException e) { <line19> logger.trace(""could not find %s with id(%s) for server(%s)"", type, objectId, serverInRegion); <line20> } <line21> return null; <line22> } <line23> } <line24> "	"<line19>      logger.trace(""could not find %s with id(%s) for server(%s)"", type, objectId, serverInRegion);"	task0	
"public class A { <line0> private void createACL( <line1> UnManagedCifsShareACL origACL, List<CifsShareACL> shareACLList, FileShare fileshare) { <line2> CifsShareACL shareACL = null; <line3> shareACL = new CifsShareACL(); <line4> shareACL.setId(URIUtil.createId(CifsShareACL.class)); <line5> String user = origACL.getUser(); <line6> if (user != null) { <line7> shareACL.setUser(user); <line8> } else { <line9> shareACL.setGroup(origACL.getGroup()); <line10> } <line11> String permissionText = null; <line12> switch (origACL.getPermission().toLowerCase()) { <line13> case ""read"": <line14> permissionText = FileControllerConstants.CIFS_SHARE_PERMISSION_READ; <line15> break; <line16> case ""change"": <line17> permissionText = FileControllerConstants.CIFS_SHARE_PERMISSION_CHANGE; <line18> break; <line19> case ""full"": <line20> case ""fullcontrol"": <line21> permissionText = FileControllerConstants.CIFS_SHARE_PERMISSION_FULLCONTROL; <line22> break; <line23> } <line24> shareACL.setPermission(permissionText); <line25> shareACL.setShareName(origACL.getShareName()); <line26> shareACL.setFileSystemId(fileshare.getId()); <line27> shareACLList.add(shareACL); <line28> logger.info(""share ACLs details {}"", shareACL.toString()); <line29> } <line30> } <line31> "	"<line28>    logger.info(""share ACLs details {}"", shareACL.toString());"	task0	
public class A { <line0> public static int getCategoriesCount(long groupId, long[] parentCategoryIds) <line1> throws RemoteException { <line2> try { <line3> int returnValue = MBCategoryServiceUtil.getCategoriesCount(groupId, parentCategoryIds); <line4> return returnValue; <line5> } catch (Exception exception) { <line6> log.error(exception, exception); <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line6>      log.error(exception, exception);	task0	
"public class A { <line0> public void handle(final HttpServerRequest request) { <line1> Logger log = RequestLoggerFactory.getLogger(CORSHandler.class, request); <line2> addCORSHeaders(request, log); <line3> if (isOptionsRequest(request)) { <line4> log.info(""Got OPTIONS request. Respond with statusCode 200""); <line5> request.response().setStatusCode(StatusCode.OK.getStatusCode()); <line6> request.response().end(); <line7> } <line8> } <line9> } <line10> "	"<line4>      log.info(""Got OPTIONS request. Respond with statusCode 200"");"	task0	
"public class A { <line0> @Log <line1> Object onDelete() { <line2> String fullName = user.getFullName(); <line3> userManager.removeUser(user.getId().toString()); <line4> alertManager.alert( <line5> Duration.TRANSIENT, Severity.SUCCESS, messages.format(""user.deleted"", fullName)); <line6> logger.debug(""After deletion.. ready to return userList object""); <line7> return UserList.class; <line8> } <line9> } <line10> "	"<line6>    logger.debug(""After deletion.. ready to return userList object"");"	task0	
"public class A { <line0> public static String getStandardFileNameForResponses( <line1> String activityId, <line2> String studyId, <line3> String activityRunId, <line4> String participantId, <line5> String version) { <line6> LOGGER.entry(""begin getStandardFileNameForResponses()""); <line7> String fileName = null; <line8> try { <line9> fileName = <line10> new StringBuilder() <line11> .append(""FDAHPHCI_"") <line12> .append(new SimpleDateFormat(""MMddyyyyHHmmss"").format(new Date())) <line13> .append(""_"") <line14> .append(studyId) <line15> .append(""_"") <line16> .append(activityId) <line17> .append(""_"") <line18> .append(activityRunId) <line19> .append(""_"") <line20> .append(participantId) <line21> .append(""_"") <line22> .append(version) <line23> .append("".json"") <line24> .toString(); <line25> } catch (Exception e) { <line26> LOGGER.error(""ERROR: StudyMetaDataUtil - getStandardFileNameForResponses()"", e); <line27> } <line28> LOGGER.exit(""getStandardFileNameForResponses() :: ends""); <line29> return fileName; <line30> } <line31> } <line32> "	"<line26>      LOGGER.error(""ERROR: StudyMetaDataUtil - getStandardFileNameForResponses()"", e);"	task0	
"public class A { <line0> @GET <line1> @Path(""/callback"") <line2> public Response callback( <line3> @QueryParam(""state"") UUID loginSession, @QueryParam(""code"") String code) { <line4> if (!loginSessionRedirects.containsKey(loginSession)) { <line5> return Response.status(417).entity(""Login session unknown"").build(); <line6> } <line7> try { <line8> final Optional<Tokens> userTokens = openIdClient.getUserTokens(code); <line9> final String value = <line10> userTokens.isPresent() ? userTokens.get().getBearerAccessToken().getValue() : ""no-token""; <line11> final URI userUri = <line12> UriBuilder.fromUri(loginSessionRedirects.get(loginSession)) <line13> .queryParam(""sessionToken"", value) <line14> .build(); <line15> return Response.temporaryRedirect(userUri).build(); <line16> } catch (IOException | ParseException e) { <line17> LOG.error(""Retrieval of userTokes failed"", e); <line18> return Response.serverError().build(); <line19> } <line20> } <line21> } <line22> "	"<line17>      LOG.error(""Retrieval of userTokes failed"", e);"	task0	
"public class A { <line0> @OnWebSocketClose <line1> public void onClose(int statusCode, String reason) { <line2> if (statusCode != StatusCode.NORMAL) { <line3> logger.debug(""WebSocket Connection closed: {} - {}"", statusCode, reason); <line4> } <line5> if (session != null) { <line6> if (!session.isOpen()) { <line7> if (session != null) { <line8> session.close(); <line9> } <line10> } <line11> session = null; <line12> } <line13> if (websocketHandler != null) { <line14> websocketHandler.onClose(); <line15> } <line16> } <line17> } <line18> "	"<line3>      logger.debug(""WebSocket Connection closed: {} - {}"", statusCode, reason);"	task0	
"public class A { <line0> private List<RemoteInfo> loadRemoteInfos(RepositoryInfo repo) { <line1> String repoId = repo.getId(); <line2> if (null == repoId) { <line3> return new ArrayList<>(); <line4> } <line5> ArrayList<RemoteInfo> list = new ArrayList<>(); <line6> Repository geogig; <line7> try { <line8> geogig = RepositoryManager.get().getRepository(repoId); <line9> if (geogig != null) { <line10> ImmutableList<Remote> geogigRemotes = geogig.command(RemoteListOp.class).call(); <line11> list = RemoteInfo.fromList(geogigRemotes); <line12> } <line13> } catch (Exception e) { <line14> LOGGER.warn(""Failed to load Remotes for repository"", e); <line15> } <line16> return list; <line17> } <line18> } <line19> "	"<line14>      LOGGER.warn(""Failed to load Remotes for repository"", e);"	task0	
"public class A { <line0> @Override <line1> public BusinessObjectEntry getBusinessObjectEntryForConcreteClass( <line2> DataDictionaryIndex ddIndex, String className) { <line3> if (StringUtils.isBlank(className)) { <line4> throw new IllegalArgumentException(""invalid (blank) className""); <line5> } <line6> if (LOG.isDebugEnabled()) { <line7> LOG.debug(""calling getBusinessObjectEntry '"" + className + ""'""); <line8> } <line9> int index = className.indexOf(""$$""); <line10> if (index >= 0) { <line11> className = className.substring(0, index); <line12> } <line13> return ddIndex.getBusinessObjectEntries().get(className); <line14> } <line15> } <line16> "	"<line7>      LOG.debug(""calling getBusinessObjectEntry '"" + className + ""'"");"	task0	
"public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItem <line1> increaseCommerceInventoryWarehouseItemQuantity( <line2> HttpPrincipal httpPrincipal, long commerceInventoryWarehouseItemId, int quantity) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceInventoryWarehouseItemServiceUtil.class, <line8> ""increaseCommerceInventoryWarehouseItemQuantity"", <line9> _increaseCommerceInventoryWarehouseItemQuantityParameterTypes19); <line10> MethodHandler methodHandler = <line11> new MethodHandler(methodKey, commerceInventoryWarehouseItemId, quantity); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItem) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> log.error(systemException, systemException); <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	<line23>      log.error(systemException, systemException);	task0	
"public class A { <line0> @PostConstruct <line1> public void init() { <line2> if (log.isDebugEnabled()) { <line3> log.debug(""@PostConstruct - init()""); <line4> } <line5> if (conf == null) { <line6> throw new IllegalArgumentException(""QueryExpirationConfiguration is null""); <line7> } <line8> } <line9> } <line10> "	"<line3>      log.debug(""@PostConstruct - init()"");"	task0	
"public class A { <line0> @Override <line1> public int truncate(String path, long size) { <line2> LOG.error(""Truncate is not supported {}"", path); <line3> return -ErrorCodes.EOPNOTSUPP(); <line4> } <line5> } <line6> "	"<line2>    LOG.error(""Truncate is not supported {}"", path);"	task0	
"public class A { <line0> private void doHousekeeping() { <line1> try { <line2> doClaimCleanup(); <line3> updateStallStop(); <line4> doRecovery(); <line5> } catch (Throwable t) { <line6> logger.error(""Encountered problem during housekeeping"", t); <line7> } <line8> } <line9> } <line10> "	"<line6>      logger.error(""Encountered problem during housekeeping"", t);"	task0	
"public class A { <line0> public static com.liferay.commerce.product.model.CPOption addCPOption( <line1> HttpPrincipal httpPrincipal, <line2> java.util.Map<java.util.Locale, String> nameMap, <line3> java.util.Map<java.util.Locale, String> descriptionMap, <line4> String ddmFormFieldTypeName, <line5> boolean facetable, <line6> boolean required, <line7> boolean skuContributor, <line8> String key, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey(CPOptionServiceUtil.class, ""addCPOption"", _addCPOptionParameterTypes0); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, <line17> nameMap, <line18> descriptionMap, <line19> ddmFormFieldTypeName, <line20> facetable, <line21> required, <line22> skuContributor, <line23> key, <line24> serviceContext); <line25> Object returnObj = null; <line26> try { <line27> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line28> } catch (Exception exception) { <line29> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line30> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line31> } <line32> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line33> } <line34> return (com.liferay.commerce.product.model.CPOption) returnObj; <line35> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line36> log.error(systemException, systemException); <line37> throw systemException; <line38> } <line39> } <line40> } <line41> "	<line36>      log.error(systemException, systemException);	task0	
"public class A { <line0> @Test <line1> public void testJmsProperties() throws Exception { <line2> QueueDeployment deployment = new QueueDeployment(); <line3> deployment.setDuplicatesAllowed(true); <line4> deployment.setDurableSend(false); <line5> final String queueName = ""testQueue""; <line6> deployment.setName(queueName); <line7> manager.getQueueManager().deploy(deployment); <line8> ClientSession session = manager.getQueueManager().getSessionFactory().createSession(); <line9> try { <line10> session.createConsumer(queueName).setMessageHandler(new Listener()); <line11> session.start(); <line12> ClientRequest request = new ClientRequest(generateURL(Util.getUrlPath(queueName))); <line13> ClientResponse<?> response = request.head(); <line14> response.releaseConnection(); <line15> Assert.assertEquals(200, response.getStatus()); <line16> Link sender = getLinkByTitle(manager.getQueueManager().getLinkStrategy(), response, ""create""); <line17> log.debug(""create: "" + sender); <line18> { <line19> response = <line20> sender <line21> .request() <line22> .body(""text/plain"", ""val"") <line23> .header(""dummyHeader"", ""DummyValue"") <line24> .header(HttpHeaderProperty.MESSAGE_PROPERTY_DISCRIMINATOR + ""property1"", ""val"") <line25> .post(); <line26> response.releaseConnection(); <line27> Assert.assertEquals(201, response.getStatus()); <line28> Listener.latch.await(2, TimeUnit.SECONDS); <line29> Assert.assertEquals(4, Listener.propertyNames.size()); <line30> Assert.assertThat(Listener.propertyNames, hasItem(new SimpleString(""http_content$type""))); <line31> Assert.assertThat(Listener.propertyNames, hasItem(new SimpleString(""http_content$length""))); <line32> Assert.assertThat( <line33> Listener.propertyNames, hasItem(new SimpleString(POSTED_AS_HTTP_MESSAGE))); <line34> Assert.assertThat(Listener.propertyNames, hasItem(new SimpleString(""property1""))); <line35> Assert.assertThat(Listener.propertyNames, not(hasItem(new SimpleString(""dummyHeader"")))); <line36> } <line37> } finally { <line38> session.close(); <line39> } <line40> } <line41> } <line42> "	"<line17>      log.debug(""create: "" + sender);"	task0	
"public class A { <line0> public static String getParentName(ComposedSchema composedSchema, OpenAPI openAPI) { <line1> Map<String, Schema> allSchemas = OpenLOpenAPIUtils.getSchemas(openAPI); <line2> List<Schema> interfaces = OpenLOpenAPIUtils.getInterfaces(composedSchema); <line3> List<String> refedWithoutDiscriminator = new ArrayList<>(); <line4> if (CollectionUtils.isNotEmpty(interfaces)) { <line5> for (Schema<?> schema : interfaces) { <line6> if (StringUtils.isNotEmpty(schema.get$ref())) { <line7> String parentName = OpenAPITypeUtils.getSimpleName(schema.get$ref()); <line8> Schema<?> s = allSchemas.get(parentName); <line9> if (s == null) { <line10> LOGGER.error(""Failed to obtain schema from {}"", parentName); <line11> return ""UNKNOWN_PARENT_NAME""; <line12> } else if (hasOrInheritsDiscriminator(s, allSchemas)) { <line13> return parentName; <line14> } else { <line15> refedWithoutDiscriminator.add(parentName); <line16> } <line17> } <line18> } <line19> } <line20> if (refedWithoutDiscriminator.size() == 1) { <line21> return refedWithoutDiscriminator.get(0); <line22> } <line23> return null; <line24> } <line25> } <line26> "	"<line10>            LOGGER.error(""Failed to obtain schema from {}"", parentName);"	task0	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public void shutdown(Database database) { <line2> log.debug(""shutting down "" + database.toString()); <line3> getDatabaseService(database).shutdown(database); <line4> } <line5> } <line6> "	"<line2>    log.debug(""shutting down "" + database.toString());"	task0	
"public class A { <line0> public SendableEvent read() throws EPException { <line1> if (stateManager.getState() == AdapterState.DESTROYED || atEOF) { <line2> return null; <line3> } <line4> try { <line5> if (eventsToSend.isEmpty()) { <line6> if (beanClass != null) { <line7> return new SendableBeanEvent( <line8> newMapEvent(), beanClass, eventTypeName, totalDelay, scheduleSlot); <line9> } else { <line10> return new SendableMapEvent(newMapEvent(), eventTypeName, totalDelay, scheduleSlot); <line11> } <line12> } else { <line13> SendableEvent theEvent = eventsToSend.first(); <line14> eventsToSend.remove(theEvent); <line15> return theEvent; <line16> } <line17> } catch (EOFException e) { <line18> if ((ExecutionPathDebugLog.isDebugEnabled) && (log.isDebugEnabled())) { <line19> log.debug("".read reached end of CSV file""); <line20> } <line21> atEOF = true; <line22> if (stateManager.getState() == AdapterState.STARTED) { <line23> stop(); <line24> } else { <line25> destroy(); <line26> } <line27> return null; <line28> } <line29> } <line30> } <line31> "	"<line19>        log.debug("".read reached end of CSV file"");"	task0	
"public class A { <line0> public static MTree deserializeFrom(File mtreeSnapshot) { <line1> try (MLogReader mLogReader = new MLogReader(mtreeSnapshot)) { <line2> return deserializeFromReader(mLogReader); <line3> } catch (IOException e) { <line4> logger.warn(""Failed to deserialize from {}. Use a new MTree."", mtreeSnapshot.getPath()); <line5> return new MTree(); <line6> } finally { <line7> limit = new ThreadLocal<>(); <line8> offset = new ThreadLocal<>(); <line9> count = new ThreadLocal<>(); <line10> curOffset = new ThreadLocal<>(); <line11> } <line12> } <line13> } <line14> "	"<line4>      logger.warn(""Failed to deserialize from {}. Use a new MTree."", mtreeSnapshot.getPath());"	task0	
"public class A { <line0> private void createMustUnderstandFault( <line1> SoapMessage soapResponse, List<QName> notUnderstoodHeaderNames, String[] actorsOrRoles) { <line2> if (logger.isWarnEnabled()) { <line3> logger.warn( <line4> ""Could not handle mustUnderstand headers: "" <line5> + StringUtils.collectionToCommaDelimitedString(notUnderstoodHeaderNames) <line6> + "". Returning fault""); <line7> } <line8> SoapBody responseBody = soapResponse.getSoapBody(); <line9> SoapFault fault = <line10> responseBody.addMustUnderstandFault( <line11> mustUnderstandFaultString, mustUnderstandFaultStringLocale); <line12> if (!ObjectUtils.isEmpty(actorsOrRoles)) { <line13> fault.setFaultActorOrRole(actorsOrRoles[0]); <line14> } <line15> SoapHeader header = soapResponse.getSoapHeader(); <line16> if (header instanceof Soap12Header) { <line17> Soap12Header soap12Header = (Soap12Header) header; <line18> for (QName headerName : notUnderstoodHeaderNames) { <line19> soap12Header.addNotUnderstoodHeaderElement(headerName); <line20> } <line21> } <line22> } <line23> } <line24> "	"<line3>      logger.warn(""Could not handle mustUnderstand headers: ""+ StringUtils.collectionToCommaDelimitedString(notUnderstoodHeaderNames)+ "". Returning fault"");"	task0	
public class A { <line0> @Override <line1> public String getContentType() { <line2> FileEntry fileEntry = getModel(); <line3> try { <line4> FileVersion fileVersion = fileEntry.getLatestFileVersion(); <line5> return fileVersion.getMimeType(); <line6> } catch (Exception exception) { <line7> if (log.isDebugEnabled()) { <line8> log.debug(exception, exception); <line9> } <line10> return fileEntry.getMimeType(); <line11> } <line12> } <line13> } <line14> 	<line8>        log.debug(exception, exception);	task0	
"public class A { <line0> public void save(String fileName) { <line1> Log.info(""Saving to file: "" + fileName); <line2> Gpr.toFileSerializeGz(fileName, this); <line3> } <line4> } <line5> "	"<line1>    Log.info(""Saving to file: "" + fileName);"	task0	
"public class A { <line0> @PUT <line1> @Timed <line2> @Path(""{name}/graph_read_mode"") <line3> @Consumes(APPLICATION_JSON) <line4> @Produces(APPLICATION_JSON_WITH_CHARSET) <line5> @RolesAllowed(""admin"") <line6> public Map<String, GraphReadMode> graphReadMode( <line7> @Context GraphManager manager, @PathParam(""name"") String name, GraphReadMode readMode) { <line8> LOG.debug(""Set graph read mode to: '{}' of graph '{}'"", readMode, name); <line9> E.checkArgument(readMode != null, ""Graph read mode can't be null""); <line10> HugeGraph g = graph(manager, name); <line11> g.readMode(readMode); <line12> return ImmutableMap.of(""graph_read_mode"", readMode); <line13> } <line14> } <line15> "	"<line8>    LOG.debug(""Set graph read mode to: '{}' of graph '{}'"", readMode, name);"	task0	
"public class A { <line0> public static void sendApplicationInstanceTerminatedEvent(String appId, String instanceId) { <line1> if (log.isInfoEnabled()) { <line2> log.info( <line3> ""Publishing application instance terminated event: [application] "" <line4> + appId <line5> + "" [instance] "" <line6> + instanceId); <line7> } <line8> ApplicationInstanceTerminatedEvent applicationTerminatedEvent = <line9> new ApplicationInstanceTerminatedEvent(appId, instanceId); <line10> publishEvent(applicationTerminatedEvent); <line11> } <line12> } <line13> "	"<line2>      log.info(""Publishing application instance terminated event: [application] ""+ appId+ "" [instance] ""+ instanceId);"	task0	
"public class A { <line0> @Override <line1> public GenericQueryConfiguration initialize( <line2> AccumuloClient client, Query settings, Set<Authorizations> auths) throws Exception { <line3> this.config = ShardQueryConfiguration.create(this, settings); <line4> if (log.isTraceEnabled()) <line5> log.trace( <line6> ""Initializing ShardQueryLogic: "" <line7> + System.identityHashCode(this) <line8> + '(' <line9> + (this.getSettings() == null ? ""empty"" : this.getSettings().getId()) <line10> + ')'); <line11> this.config.setExpandFields(true); <line12> this.config.setExpandValues(true); <line13> initialize(config, client, settings, auths); <line14> return config; <line15> } <line16> } <line17> "	"<line5>      log.trace(""Initializing ShardQueryLogic: ""+ System.identityHashCode(this)+ '('+ (this.getSettings() == null ? ""empty"" : this.getSettings().getId())+ ')');"	task0	
"public class A { <line0> @Override <line1> public final void afterPropertiesSet() throws Exception { <line2> Object parentObject = null; <line3> if (ResourcesUtils.getResourceAsStream( <line4> ""/org/springframework/web/context/WebApplicationContext.class"") <line5> != null) { <line6> if (this.applicationContext instanceof WebApplicationContext) { <line7> parentObject = ((WebApplicationContext) this.applicationContext).getServletContext(); <line8> } <line9> } <line10> Set<Class<?>> needCheckRepeat = new HashSet<>(); <line11> if (this.loadModules != null) { <line12> for (String name : this.loadModules) { <line13> needCheckRepeat.add(this.applicationContext.getType(name)); <line14> this.buildConfig.loadModules.add((Module) this.applicationContext.getBean(name)); <line15> } <line16> } <line17> if (this.scanPackages != null && this.scanPackages.length > 0) { <line18> Predicate<Class<?>> classPredicate = <line19> needCheckRepeat.isEmpty() <line20> ? Matchers.anyClass() <line21> : Matchers.anyClassExcludes(needCheckRepeat); <line22> AutoScanPackagesModule autoScanModule = <line23> new AutoScanPackagesModule(this.scanPackages, classPredicate); <line24> autoScanModule.setApplicationContext(Objects.requireNonNull(this.applicationContext)); <line25> this.buildConfig.loadModules.add(autoScanModule); <line26> } <line27> this.realAppContext = this.buildConfig.build(parentObject, this.applicationContext).build(this); <line28> logger.info(""hasor Spring factory inited.""); <line29> } <line30> } <line31> "	"<line28>    logger.info(""hasor Spring factory inited."");"	task0	
"public class A { <line0> @Override <line1> public double get() { <line2> try (BufferedReader fileReaderMemoryMax = new BufferedReader(new FileReader(maxMemoryFile))) { <line3> return Long.parseLong(fileReaderMemoryMax.readLine()); <line4> } catch (Exception e) { <line5> logger.debug(""Failed to read "" + maxMemoryFile + "" file"", e); <line6> return Double.NaN; <line7> } <line8> } <line9> } <line10> "	"<line5>      logger.debug(""Failed to read "" + maxMemoryFile + "" file"", e);"	task0	
"public class A { <line0> @Override <line1> protected RouteBuilder createRouteBuilder() throws Exception { <line2> return new RouteBuilder() { <line3> @Override <line4> public void configure() throws Exception { <line5> getContext().setTracing(true); <line6> from(""direct:start"") <line7> .delay(10) <line8> .to(""mock:a"") <line9> .process( <line10> new Processor() { <line11> public void process(Exchange exchange) throws Exception { <line12> LOG.info(""This is the processor being invoked between mock:a and mock:b""); <line13> } <line14> }) <line15> .to(""mock:b"") <line16> .toD(""direct:c"") <line17> .to(""mock:result"") <line18> .transform(simple(""${body}${body}"")); <line19> from(""direct:c"").transform(constant(""Bye World"")).to(""mock:c""); <line20> } <line21> }; <line22> } <line23> } <line24> "	"<line12>                    LOG.info(""This is the processor being invoked between mock:a and mock:b"");"	task0	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> try (SmbResource f = createTestFile()) { <line4> try { <line5> } finally { <line6> try { <line7> f.delete(); <line8> } catch (IOException e) { <line9> System.err.println(f.getLocator().getUNCPath()); <line10> throw e; <line11> } <line12> } <line13> } <line14> this.completed = true; <line15> } catch (IOException | RuntimeException e) { <line16> log.error(""Test case failed"", e); <line17> } <line18> } <line19> } <line20> "	"<line16>      log.error(""Test case failed"", e);"	task0	
public class A { <line0> public static int getGroupThreadsCount( <line1> long groupId, long userId, int status, boolean subscribed, boolean includeAnonymous) <line2> throws RemoteException { <line3> try { <line4> int returnValue = <line5> MBThreadServiceUtil.getGroupThreadsCount( <line6> groupId, userId, status, subscribed, includeAnonymous); <line7> return returnValue; <line8> } catch (Exception exception) { <line9> log.error(exception, exception); <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line9>      log.error(exception, exception);	task0	
"public class A { <line0> @Override <line1> public int abortMultipartUploads(S3FileTransferRequestParamsDto params, Date thresholdDate) { <line2> AmazonS3Client s3Client = getAmazonS3(params); <line3> int abortedMultipartUploadsCount = 0; <line4> try { <line5> String uploadIdMarker = null; <line6> String keyMarker = null; <line7> boolean truncated; <line8> do { <line9> ListMultipartUploadsRequest request = <line10> new ListMultipartUploadsRequest(params.getS3BucketName()); <line11> request.setUploadIdMarker(uploadIdMarker); <line12> request.setKeyMarker(keyMarker); <line13> MultipartUploadListing uploadListing = <line14> s3Operations.listMultipartUploads( <line15> TransferManager.appendSingleObjectUserAgent(request), s3Client); <line16> for (MultipartUpload upload : uploadListing.getMultipartUploads()) { <line17> if (upload.getInitiated().compareTo(thresholdDate) < 0) { <line18> s3Operations.abortMultipartUpload( <line19> TransferManager.appendSingleObjectUserAgent( <line20> new AbortMultipartUploadRequest( <line21> params.getS3BucketName(), upload.getKey(), upload.getUploadId())), <line22> s3Client); <line23> LOGGER.info( <line24> ""Aborted S3 multipart upload. s3Key=\""{}\"" s3BucketName=\""{}\"""" <line25> + "" s3MultipartUploadInitiatedDate=\""{}\"""", <line26> upload.getKey(), <line27> params.getS3BucketName(), <line28> upload.getInitiated()); <line29> abortedMultipartUploadsCount++; <line30> } <line31> } <line32> truncated = uploadListing.isTruncated(); <line33> if (truncated) { <line34> uploadIdMarker = uploadListing.getNextUploadIdMarker(); <line35> keyMarker = uploadListing.getNextKeyMarker(); <line36> } <line37> } while (truncated); <line38> } finally { <line39> s3Client.shutdown(); <line40> } <line41> return abortedMultipartUploadsCount; <line42> } <line43> } <line44> "	"<line23>            LOGGER.info(""Aborted S3 multipart upload. s3Key=\""{}\"" s3BucketName=\""{}\""""+ "" s3MultipartUploadInitiatedDate=\""{}\"""",upload.getKey(),params.getS3BucketName(),upload.getInitiated());"	task0	
public class A { <line0> public static long[] getCPDefinitionIds(long commercePricingClassId) throws RemoteException { <line1> try { <line2> long[] returnValue = <line3> CommercePricingClassCPDefinitionRelServiceUtil.getCPDefinitionIds(commercePricingClassId); <line4> return returnValue; <line5> } catch (Exception exception) { <line6> log.error(exception, exception); <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line6>      log.error(exception, exception);	task0	
"public class A { <line0> @Override <line1> public void sessionIdle(NextFilter nextFilter, IoSession session, IdleStatus status) <line2> throws Exception { <line3> if (status == IdleStatus.BOTH_IDLE && SESSION_IDLE_TIMEOUT_KEY.get(session) != null) { <line4> if (logger.isDebugEnabled()) { <line5> logger.debug( <line6> String.format( <line7> ""Closing HTTP parent session %s because http.keepalive.timeout of %d secs is"" <line8> + "" exceeded"", <line9> session, SESSION_IDLE_TIMEOUT_KEY.get(session))); <line10> } <line11> session.close(false); <line12> } <line13> super.sessionIdle(nextFilter, session, status); <line14> } <line15> } <line16> "	"<line5>        logger.debug(String.format(""Closing HTTP parent session %s because http.keepalive.timeout of %d secs is""+ "" exceeded"",session, SESSION_IDLE_TIMEOUT_KEY.get(session)));"	task0	
public class A { <line0> private InternalFuture<Void> createRoleBindingsForExperimentRun( <line1> final ExperimentRun experimentRun) { <line2> ModelDBResourceEnum.ModelDBServiceResourceTypes modelDBServiceResourceType = <line3> ModelDBResourceEnum.ModelDBServiceResourceTypes.EXPERIMENT_RUN; <line4> String roleName = ModelDBConstants.ROLE_EXPERIMENT_RUN_OWNER; <line5> return FutureGrpc.ClientRequest( <line6> uac.getRoleService() <line7> .setRoleBinding( <line8> SetRoleBinding.newBuilder() <line9> .setRoleBinding( <line10> RoleBinding.newBuilder() <line11> .setName( <line12> buildRoleBindingName( <line13> roleName, <line14> experimentRun.getId(), <line15> experimentRun.getOwner(), <line16> modelDBServiceResourceType.name())) <line17> .setScope(RoleScope.newBuilder().build()) <line18> .setRoleName(roleName) <line19> .addEntities( <line20> Entities.newBuilder() <line21> .addUserIds(experimentRun.getOwner()) <line22> .build()) <line23> .addResources( <line24> Resources.newBuilder() <line25> .setService(ServiceEnum.Service.MODELDB_SERVICE) <line26> .setResourceType( <line27> ResourceType.newBuilder() <line28> .setModeldbServiceResourceType( <line29> modelDBServiceResourceType)) <line30> .addResourceIds(experimentRun.getId()) <line31> .build()) <line32> .build()) <line33> .build()), <line34> executor) <line35> .thenAccept( <line36> response -> { <line37> LOGGER.trace(CommonMessages.ROLE_SERVICE_RES_RECEIVED_TRACE_MSG, response); <line38> }, <line39> executor); <line40> } <line41> } <line42> 	<line37>              LOGGER.trace(CommonMessages.ROLE_SERVICE_RES_RECEIVED_TRACE_MSG, response);	task0	
"public class A { <line0> public static Error from(final GafferRuntimeException gex) { <line1> LOGGER.error(""Error: {}"", gex.getMessage(), gex); <line2> return new ErrorBuilder() <line3> .status(gex.getStatus()) <line4> .simpleMessage(gex.getMessage()) <line5> .detailMessage(ExceptionUtils.getStackTrace(gex)) <line6> .build(); <line7> } <line8> } <line9> "	"<line1>    LOGGER.error(""Error: {}"", gex.getMessage(), gex);"	task0	
"public class A { <line0> protected void updatePreferences(ActionRequest actionRequest, PortletPreferences preferences) <line1> throws Exception { <line2> String domainName = ParamUtil.getString(actionRequest, ""domainName""); <line3> String rules = ParamUtil.getString(actionRequest, ""rules""); <line4> long[] classNameIds = StringUtil.split(ParamUtil.getString(actionRequest, ""classNameIds""), 0L); <line5> if (Validator.isNull(domainName)) { <line6> SessionErrors.add(actionRequest, ""domainName""); <line7> } else if (Validator.isNull(rules)) { <line8> SessionErrors.add(actionRequest, ""rules""); <line9> } else if (classNameIds.length == 0) { <line10> SessionErrors.add(actionRequest, ""classNameIds""); <line11> } else { <line12> RulesResourceRetriever rulesResourceRetriever = <line13> new RulesResourceRetriever( <line14> new StringResourceRetriever(rules), <line15> String.valueOf(RulesLanguage.DROOLS_RULE_LANGUAGE)); <line16> try { <line17> _rulesEngine.update(domainName, rulesResourceRetriever); <line18> } catch (RulesEngineException rulesEngineException) { <line19> log.error(rulesEngineException, rulesEngineException); <line20> SessionErrors.add(actionRequest, ""rulesEngineException""); <line21> } <line22> } <line23> if (SessionErrors.isEmpty(actionRequest)) { <line24> preferences.setValue(""rules"", rules); <line25> preferences.setValue(""domain-name"", domainName); <line26> String userCustomAttributeNames = <line27> ParamUtil.getString(actionRequest, ""userCustomAttributeNames""); <line28> preferences.setValue(""user-custom-attribute-names"", userCustomAttributeNames); <line29> preferences.setValues(""class-name-ids"", ArrayUtil.toStringArray(classNameIds)); <line30> } <line31> } <line32> } <line33> "	<line19>        log.error(rulesEngineException, rulesEngineException);	task0	
"public class A { <line0> @Override <line1> public void streamClosed(Stream s) { <line2> log.debug(""Stream {} closed"", s.getName()); <line3> } <line4> } <line5> "	"<line2>    log.debug(""Stream {} closed"", s.getName());"	task0	
"public class A { <line0> @Test <line1> public void testDescribeFeatureTypeManyTypes() { <line2> Document doc = <line3> getAsDOM( <line4> ""wfs?request=DescribeFeatureType&version=1.1.0&typeName=gsml:MappedFeature,gsml:GeologicUnit,ex:FirstParentFeature,ex:SecondParentFeature""); <line5> LOGGER.info( <line6> ""WFS DescribeFeatureType,"" <line7> + "" typename=gsml:MappedFeature,gsml:GeologicUnit,ex:FirstParentFeature,ex:SecondParentFeature"" <line8> + "" response:\n"" <line9> + prettyString(doc)); <line10> checkGsmlExDescribeFeatureType(doc); <line11> } <line12> } <line13> "	"<line5>    LOGGER.info(""WFS DescribeFeatureType,""+ "" typename=gsml:MappedFeature,gsml:GeologicUnit,ex:FirstParentFeature,ex:SecondParentFeature""+ "" response:\n""+ prettyString(doc));"	task0	
"public class A { <line0> @Override <line1> public Collection<AugmentedEvent> apply(Collection<AugmentedEvent> events) { <line2> if (this.sought.get()) { <line3> return events; <line4> } else { <line5> Collection<AugmentedEvent> soughtEvents = new ArrayList<>(); <line6> for (AugmentedEvent event : events) { <line7> int partition = this.partitioner.apply(event, this.totalPartitions); <line8> if (this.partitionSought.get(partition)) { <line9> soughtEvents.add(event); <line10> } else if (this.partitionCheckpoint[partition] == null <line11> || this.partitionCheckpoint[partition].compareTo(event.getHeader().getCheckpoint()) <line12> < 0) { <line13> this.partitionSought.set(partition); <line14> this.sought.set(this.partitionSought.cardinality() == this.totalPartitions); <line15> soughtEvents.add(event); <line16> KafkaSeeker.LOG.info(String.format(""sought partition %d"", partition)); <line17> } <line18> } <line19> if (soughtEvents.size() > 0) { <line20> return soughtEvents; <line21> } else { <line22> return null; <line23> } <line24> } <line25> } <line26> } <line27> "	"<line16>          KafkaSeeker.LOG.info(String.format(""sought partition %d"", partition));"	task0	
"public class A { <line0> private void processAuthenticatedPasswordModify( <line1> LdapSession requestor, PasswordModifyRequest req, Dn userDn) { <line2> byte[] oldPassword = req.getOldPassword(); <line3> byte[] newPassword = req.getNewPassword(); <line4> Entry modifiedEntry = null; <line5> Dn principalDn = requestor.getCoreSession().getEffectivePrincipal().getDn(); <line6> LOG.debug(""User {} trying to modify password of user {}"", principalDn, userDn); <line7> if ((userDn != null) && (!userDn.equals(principalDn))) { <line8> if (requestor.getCoreSession().isAdministrator()) { <line9> modifiedEntry = getModifiedEntry(requestor, req, userDn); <line10> if (modifiedEntry == null) { <line11> return; <line12> } <line13> modifyUserPassword( <line14> requestor.getCoreSession(), modifiedEntry, userDn, oldPassword, newPassword, req); <line15> } else { <line16> writeResult( <line17> requestor, <line18> req, <line19> ResultCodeEnum.INSUFFICIENT_ACCESS_RIGHTS, <line20> ""Non-admin user cannot access another user's password to modify it""); <line21> } <line22> } else { <line23> modifiedEntry = getModifiedEntry(requestor, req, principalDn); <line24> if (modifiedEntry == null) { <line25> return; <line26> } <line27> modifyUserPassword( <line28> requestor.getCoreSession(), modifiedEntry, principalDn, oldPassword, newPassword, req); <line29> } <line30> } <line31> } <line32> "	"<line6>    LOG.debug(""User {} trying to modify password of user {}"", principalDn, userDn);"	task0	
"public class A { <line0> public CompletableFuture<String> asyncGet() { <line1> logger.debug(""CoAP GET request\nuri: {}"", getURI()); <line2> CompletableFuture<String> future = new CompletableFuture<>(); <line3> get(new TradfriCoapHandler(future)); <line4> return future; <line5> } <line6> } <line7> "	"<line1>    logger.debug(""CoAP GET request\nuri: {}"", getURI());"	task0	
"public class A { <line0> @Override <line1> public void searchPlaces(final GeoQuery query) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(SEARCH_PLACES, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> ResponseList<Place> places = twitter.searchPlaces(query); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.searchedPlaces(places); <line11> } catch (Exception e) { <line12> logger.warn(""Exception at searchPlaces"", e); <line13> } <line14> } <line15> } <line16> }); <line17> } <line18> } <line19> "	"<line12>                    logger.warn(""Exception at searchPlaces"", e);"	task0	
"public class A { <line0> public static int getArticlesCount( <line1> HttpPrincipal httpPrincipal, long groupId, long folderId, int status) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> JournalArticleServiceUtil.class, <line6> ""getArticlesCount"", <line7> _getArticlesCountParameterTypes31); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, folderId, status); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> log.error(systemException, systemException); <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line17>      log.error(systemException, systemException);	task0	
"public class A { <line0> public void initSchema() { <line1> DbType dbType = getDbType(); <line2> String initSqlPath = """"; <line3> if (dbType != null) { <line4> switch (dbType) { <line5> case MYSQL: <line6> initSqlPath = ""/sql/create/release-1.0.0_schema/mysql/""; <line7> initSchema(initSqlPath); <line8> break; <line9> case POSTGRESQL: <line10> initSqlPath = ""/sql/create/release-1.2.0_schema/postgresql/""; <line11> initSchema(initSqlPath); <line12> break; <line13> default: <line14> logger.error(""not support sql type: {},can't upgrade"", dbType); <line15> throw new IllegalArgumentException(""not support sql type,can't upgrade""); <line16> } <line17> } <line18> } <line19> } <line20> "	"<line14>          logger.error(""not support sql type: {},can't upgrade"", dbType);"	task0	
"public class A { <line0> public void export(Dashboard dashboard, Path path, ExportType type) { <line1> DashboardSerializer serializer = serializerFor(type); <line2> validate(dashboard); <line3> Path temp = createTempDashboardFile(); <line4> try (FileOutputStream fos = new FileOutputStream(temp.toFile())) { <line5> serializer.serialize(dashboard, fos); <line6> Files.move(temp, path, StandardCopyOption.REPLACE_EXISTING); <line7> } catch (FileNotFoundException e) { <line8> throw new IllegalArgumentException(""File not found: "" + path, e); <line9> } catch (IOException e) { <line10> throw new RuntimeException(""Error writing to file "" + path, e); <line11> } finally { <line12> try { <line13> Files.deleteIfExists(temp); <line14> } catch (IOException e) { <line15> logger.error(""Error deleting temp file"", e); <line16> } <line17> } <line18> } <line19> } <line20> "	"<line15>        logger.error(""Error deleting temp file"", e);"	task0	
"public class A { <line0> @Override <line1> public void dispose() { <line2> super.dispose(); <line3> try { <line4> XTextContent xTextContent = UNO.XTextContent(inputField); <line5> xTextContent.getAnchor().getText().removeTextContent(xTextContent); <line6> } catch (NoSuchElementException e) { <line7> LOGGER.info("""", e); <line8> } <line9> } <line10> } <line11> "	"<line7>      LOGGER.info("""", e);"	task0	
"public class A { <line0> public static <T> void attachOutputPortToInputPort( <line1> DefaultOutputPort<T> outputPort, final DefaultInputPort<T> inputPort) { <line2> outputPort.setSink( <line3> new Sink<Object>() { <line4> @Override <line5> @SuppressWarnings(""unchecked"") <line6> public void put(Object tuple) { <line7> LOG.debug(""processing tuple""); <line8> inputPort.process((T) tuple); <line9> } <line10>  <line11> @Override <line12> public int getCount(boolean reset) { <line13> return 0; <line14> } <line15> }); <line16> } <line17> } <line18> "	"<line7>            LOG.debug(""processing tuple"");"	task0	
"public class A { <line0> @Override <line1> public JobExecution abandon(long jobExecutionId) <line2> throws NoSuchJobExecutionException, JobExecutionAlreadyRunningException { <line3> JobExecution jobExecution = findExecutionById(jobExecutionId); <line4> if (jobExecution.getStatus().isLessThan(BatchStatus.STOPPING)) { <line5> throw new JobExecutionAlreadyRunningException( <line6> ""JobExecution is running or complete and therefore cannot be aborted""); <line7> } <line8> if (logger.isInfoEnabled()) { <line9> logger.info(""Aborting job execution: "" + jobExecution); <line10> } <line11> jobExecution.upgradeStatus(BatchStatus.ABANDONED); <line12> jobExecution.setEndTime(new Date()); <line13> jobRepository.update(jobExecution); <line14> return jobExecution; <line15> } <line16> } <line17> "	"<line9>      logger.info(""Aborting job execution: "" + jobExecution);"	task0	
public class A { <line0> private void _generateImages(FileVersion sourceFileVersion, FileVersion destinationFileVersion) <line1> throws Exception { <line2> try { <line3> if (sourceFileVersion != null) { <line4> copy(sourceFileVersion, destinationFileVersion); <line5> return; <line6> } <line7> if (!PropsValues.DL_FILE_ENTRY_THUMBNAIL_ENABLED <line8> && !PropsValues.DL_FILE_ENTRY_PREVIEW_ENABLED) { <line9> return; <line10> } <line11> try (InputStream inputStream = destinationFileVersion.getContentStream(false)) { <line12> byte[] bytes = FileUtil.getBytes(inputStream); <line13> ImageBag imageBag = ImageToolUtil.read(bytes); <line14> RenderedImage renderedImage = imageBag.getRenderedImage(); <line15> if (renderedImage == null) { <line16> _fileVersionPreviewEventListener.onFailure(destinationFileVersion); <line17> return; <line18> } <line19> ColorModel colorModel = renderedImage.getColorModel(); <line20> if (colorModel.getNumColorComponents() == 4) { <line21> Future<RenderedImage> future = ImageToolUtil.convertCMYKtoRGB(bytes, imageBag.getType()); <line22> if (future == null) { <line23> _fileVersionPreviewEventListener.onFailure(destinationFileVersion); <line24> return; <line25> } <line26> String processIdentity = String.valueOf(destinationFileVersion.getFileVersionId()); <line27> futures.put(processIdentity, future); <line28> RenderedImage convertedRenderedImage = future.get(); <line29> if (convertedRenderedImage != null) { <line30> renderedImage = convertedRenderedImage; <line31> } <line32> } <line33> if (!_hasPreview(destinationFileVersion)) { <line34> _storePreviewImage(destinationFileVersion, renderedImage); <line35> } <line36> if (!hasThumbnails(destinationFileVersion)) { <line37> storeThumbnailImages(destinationFileVersion, renderedImage); <line38> } <line39> _fileVersionPreviewEventListener.onSuccess(destinationFileVersion); <line40> } <line41> } catch (NoSuchFileEntryException noSuchFileEntryException) { <line42> if (log.isDebugEnabled()) { <line43> log.debug(noSuchFileEntryException, noSuchFileEntryException); <line44> } <line45> _fileVersionPreviewEventListener.onFailure(destinationFileVersion); <line46> } finally { <line47> _fileVersionIds.remove(destinationFileVersion.getFileVersionId()); <line48> } <line49> } <line50> } <line51> 	<line43>        log.debug(noSuchFileEntryException, noSuchFileEntryException);	task0	
"public class A { <line0> public void createHttpPrincipal(LocalKadmin kadmin) throws HasException { <line1> String httpPrincipal = getHttpPrincipal(); <line2> IdentityBackend backend = kdcServer.getIdentityService(); <line3> try { <line4> if (backend.getIdentity(httpPrincipal) == null) { <line5> kadmin.addPrincipal(httpPrincipal); <line6> } else { <line7> LOG.info(""The http principal already exists in backend.""); <line8> } <line9> } catch (KrbException e) { <line10> throw new HasException(""Failed to add principal, "" + e.getMessage()); <line11> } <line12> } <line13> } <line14> "	"<line7>        LOG.info(""The http principal already exists in backend."");"	task0	
"public class A { <line0> public List<Token> tokenize(final String pattern) { <line1> if (pattern == null) { <line2> return Arrays.asList(NullToken.INSTANCE); <line3> } <line4> if ("""".equals(pattern)) { <line5> return Arrays.asList(BlankToken.INSTANCE); <line6> } <line7> final List<Token> tokens; <line8> if (_predefinedTokens) { <line9> final List<PredefinedTokenDefinition> predefinedTokens = _configuration.getPredefinedTokens(); <line10> final PredefinedTokenTokenizer tokenizer = new PredefinedTokenTokenizer(predefinedTokens); <line11> tokens = tokenizer.tokenize(pattern); <line12> for (final ListIterator<Token> it = tokens.listIterator(); it.hasNext(); ) { <line13> final Token token = it.next(); <line14> final TokenType tokenType = token.getType(); <line15> logger.debug(""Next token type is: {}"", tokenType); <line16> if (tokenType == TokenType.UNDEFINED) { <line17> final List<SimpleToken> replacementTokens = tokenizeInternal(token.getString()); <line18> boolean replace = true; <line19> if (replacementTokens.size() == 1) { <line20> if (token.equals(replacementTokens.get(0))) { <line21> replace = false; <line22> } <line23> } <line24> if (replace) { <line25> it.remove(); <line26> for (final SimpleToken replacementToken : replacementTokens) { <line27> it.add(replacementToken); <line28> } <line29> } <line30> } <line31> } <line32> } else { <line33> tokens = new ArrayList<>(); <line34> tokens.addAll(tokenizeInternal(pattern)); <line35> } <line36> return tokens; <line37> } <line38> } <line39> "	"<line15>        logger.debug(""Next token type is: {}"", tokenType);"	task0	
"public class A { <line0> @Override <line1> public void updateNonExistent(String testName) throws Exception { <line2> setupUpdateNonExistent(); <line3> AcquisitionClient client = new AcquisitionClient(); <line4> PoxPayloadOut multipart = createAcquisitionInstance(NON_EXISTENT_ID); <line5> Response res = client.update(NON_EXISTENT_ID, multipart); <line6> try { <line7> int statusCode = res.getStatus(); <line8> if (logger.isDebugEnabled()) { <line9> logger.debug(testName + "": status = "" + statusCode); <line10> } <line11> Assert.assertTrue( <line12> testRequestType.isValidStatusCode(statusCode), <line13> invalidStatusCodeMessage(testRequestType, statusCode)); <line14> Assert.assertEquals(statusCode, testExpectedStatusCode); <line15> } finally { <line16> res.close(); <line17> } <line18> } <line19> } <line20> "	"<line9>        logger.debug(testName + "": status = "" + statusCode);"	task0	
"public class A { <line0> private void reuse( <line1> OutOfOffHeapMemoryListener oooml, <line2> OffHeapMemoryStats newStats, <line3> long offHeapMemorySize, <line4> Slab[] slabs) { <line5> if (isClosed()) { <line6> throw new IllegalStateException(""Can not reuse a closed off-heap memory manager.""); <line7> } <line8> if (oooml == null) { <line9> throw new IllegalArgumentException(""OutOfOffHeapMemoryListener is null""); <line10> } <line11> if (getTotalMemory() != offHeapMemorySize) { <line12> logger.warn( <line13> ""Using {} bytes of existing off-heap memory instead of the requested {}."", <line14> getTotalMemory(), <line15> offHeapMemorySize); <line16> } <line17> if (!this.freeList.okToReuse(slabs)) { <line18> throw new IllegalStateException( <line19> ""attempted to reuse existing off-heap memory even though new off-heap memory was"" <line20> + "" allocated""); <line21> } <line22> this.ooohml = oooml; <line23> newStats.initialize(this.stats); <line24> this.stats = newStats; <line25> } <line26> } <line27> "	"<line12>      logger.warn(""Using {} bytes of existing off-heap memory instead of the requested {}."",getTotalMemory(),offHeapMemorySize);"	task0	
"public class A { <line0> public IIdea getIdea(String code) { <line1> IIdea idea = null; <line2> try { <line3> idea = this.getIdeaManager().getIdea(code); <line4> if (null != idea && idea.getStatus() != IIdea.STATUS_APPROVED) { <line5> return null; <line6> } <line7> } catch (Throwable t) { <line8> logger.error(""error in getIdea"", t); <line9> throw new RuntimeException(""Errore in caricamento idea "" + code); <line10> } <line11> return idea; <line12> } <line13> } <line14> "	"<line8>      logger.error(""error in getIdea"", t);"	task0	
"public class A { <line0> public Future<SummaryCollection> gather(ExecutorService es) { <line1> int numFiles = countFiles(); <line2> log.debug(""Gathering summaries from {} files"", numFiles); <line3> if (numFiles == 0) { <line4> return CompletableFuture.completedFuture(new SummaryCollection()); <line5> } <line6> int numRequest = Math.max(numFiles / 100_000, 1); <line7> List<CompletableFuture<SummaryCollection>> futures = new ArrayList<>(); <line8> AtomicBoolean cancelFlag = new AtomicBoolean(false); <line9> TInfo tinfo = TraceUtil.traceInfo(); <line10> for (int i = 0; i < numRequest; i++) { <line11> futures.add( <line12> CompletableFuture.supplyAsync(new GatherRequest(tinfo, i, numRequest, cancelFlag), es)); <line13> } <line14> Future<SummaryCollection> future = <line15> CompletableFutureUtil.merge( <line16> futures, <line17> (sc1, sc2) -> SummaryCollection.merge(sc1, sc2, factory), <line18> SummaryCollection::new); <line19> return new CancelFlagFuture<>(future, cancelFlag); <line20> } <line21> } <line22> "	"<line2>    log.debug(""Gathering summaries from {} files"", numFiles);"	task0	
"public class A { <line0> public LocalParameter createKineticParameter(String id) { <line1> Reaction lastReaction = getLastElementOf(listOfReactions); <line2> KineticLaw lastKineticLaw = null; <line3> if (lastReaction == null) { <line4> logger.warn( <line5> MessageFormat.format( <line6> COULD_NOT_CREATE_ELEMENT_MSG, ""LocalParameter for KineticLaw"", ""reactions"")); <line7> return null; <line8> } else { <line9> lastKineticLaw = lastReaction.getKineticLaw(); <line10> if (lastKineticLaw == null) { <line11> return null; <line12> } <line13> } <line14> LocalParameter parameter = new LocalParameter(id, getLevel(), getVersion()); <line15> lastKineticLaw.addLocalParameter(parameter); <line16> return parameter; <line17> } <line18> } <line19> "	"<line4>      logger.warn(MessageFormat.format(COULD_NOT_CREATE_ELEMENT_MSG, ""LocalParameter for KineticLaw"", ""reactions""));"	task0	
"public class A { <line0> public void messageReceived( <line1> ChannelHandlerContext ctx, MobileStateHolder state, StringMessage message) { <line2> var splitBody = split2(message.body); <line3> var user = state.user; <line4> var energyAmountToAdd = Integer.parseInt(splitBody[0]); <line5> ResponseMessage response; <line6> if (splitBody.length == 2 && isValidTransactionId(splitBody[1])) { <line7> double price = calcPrice(energyAmountToAdd); <line8> insertPurchase(user.email, energyAmountToAdd, price, splitBody[1]); <line9> user.addEnergy(energyAmountToAdd); <line10> response = ok(message.id); <line11> } else { <line12> if (!wasErrorPrinted) { <line13> log.warn( <line14> ""Purchase {} with invalid transaction id '{}'. {} ({})."", <line15> splitBody[0], <line16> splitBody[1], <line17> user.email, <line18> state.version); <line19> wasErrorPrinted = true; <line20> } <line21> response = notAllowed(message.id); <line22> } <line23> ctx.writeAndFlush(response, ctx.voidPromise()); <line24> } <line25> } <line26> "	"<line13>        log.warn(""Purchase {} with invalid transaction id '{}'. {} ({})."",splitBody[0],splitBody[1],user.email,state.version);"	task0	
"public class A { <line0> @Override <line1> public void startElement(String uri, String localName, String qName, Attributes attributes) { <line2> log.trace(String.format(""Start of element <%s>"", localName)); <line3> String name = localName; <line4> if (uri != null && !"""".equals(uri)) name = uri + "":"" + name; <line5> events.start(name); <line6> for (int i = 0; i < attributes.getLength(); i++) { <line7> String k = attributes.getLocalName(i); <line8> String auri = attributes.getURI(i); <line9> if (auri != null && (XMLNS.equals(auri) || XML.equals(auri))) continue; <line10> if (auri != null && !"""".equals(auri)) k = auri + "":"" + k; <line11> events.start(""@"" + k); <line12> events.text(attributes.getValue(i)); <line13> events.end(); <line14> } <line15> } <line16> } <line17> "	"<line2>    log.trace(String.format(""Start of element <%s>"", localName));"	task0	
"public class A { <line0> protected List<String> resolveTableSchema( <line1> @Nonnull final String schema, @Nonnull final String table) { <line2> List<String> columnSet = new Vector<>(); <line3> try (final Statement st = conn.createStatement()) { <line4> st.execute(""use default""); <line5> String ddl = ""desc "" + HiveUtils.quoteIdentifier(schema, table); <line6> logger.info(""Resolving table schema [{}]"", ddl); <line7> ResultSet rs = doSelectSQL(st, ddl); <line8> while (rs.next()) { <line9> if (StringUtils.isEmpty(rs.getString(1))) { <line10> break; <line11> } <line12> columnSet.add(rs.getString(1)); <line13> } <line14> } catch (SQLException e) { <line15> throw new RuntimeException(""Failed to inspect schema"", e); <line16> } <line17> return columnSet; <line18> } <line19> } <line20> "	"<line6>      logger.info(""Resolving table schema [{}]"", ddl);"	task0	
"public class A { <line0> @Override <line1> public void run() { <line2> boolean duplicateFound = false; <line3> for (RadioStation station : stationsList) { <line4> if (!duplicateFound && station.getName().equals(radioStation.getName())) { <line5> duplicateFound = true; <line6> deferred.reject(AddFavoriteStationErrorEnum.DUPLICATE_RADIOSTATION); <line7> break; <line8> } <line9> } <line10> if (!duplicateFound) { <line11> logger.info(PRINT_BORDER + ""addFavoriteStation("" + radioStation + "")"" + PRINT_BORDER); <line12> stationsList.add(radioStation); <line13> deferred.resolve(true); <line14> } <line15> } <line16> } <line17> "	"<line11>      logger.info(PRINT_BORDER + ""addFavoriteStation("" + radioStation + "")"" + PRINT_BORDER);"	task0	
"public class A { <line0> private void updateLogProperties(File karafHome, ExamSystem _system) throws IOException { <line1> DoNotModifyLogOption[] modifyLog = _system.getOptions(DoNotModifyLogOption.class); <line2> if (modifyLog != null && modifyLog.length != 0) { <line3> LOGGER.info(""Log file should not be modified by the test framework""); <line4> return; <line5> } <line6> LoggingBackend loggingBackend = getLoggingBackend(karafHome); <line7> String realLogLevel = retrieveRealLogLevel(_system); <line8> File customPropertiesFile = <line9> new File(karafHome, framework.getKarafEtc() + ""/org.ops4j.pax.logging.cfg""); <line10> Properties karafPropertyFile = new Properties(); <line11> karafPropertyFile.load(new FileInputStream(customPropertiesFile)); <line12> loggingBackend.updatePaxLoggingConfiguration(karafPropertyFile, realLogLevel); <line13> karafPropertyFile.store(new FileOutputStream(customPropertiesFile), ""updated by pax-exam""); <line14> } <line15> } <line16> "	"<line3>      LOGGER.info(""Log file should not be modified by the test framework"");"	task0	
"public class A { <line0> @Override <line1> public void delete(ScriptVersionTraceKey scriptVersionTraceKey) { <line2> LOGGER.trace( <line3> MessageFormat.format(""Deleting ScriptVersionTrace {0}."", scriptVersionTraceKey.toString())); <line4> String deleteStatement = deleteStatement(scriptVersionTraceKey); <line5> getMetadataRepository().executeUpdate(deleteStatement); <line6> } <line7> } <line8> "	"<line2>    LOGGER.trace(MessageFormat.format(""Deleting ScriptVersionTrace {0}."", scriptVersionTraceKey.toString()));"	task0	
"public class A { <line0> @PostConstruct <line1> public void init() { <line2> logger = LoggerFactory.getLogger(getClass()); <line3> logger.debug(""initializing bean "" + getClass().getName()); <line4> attributes = Attributes.getComponentAttributesFromFacesConfig(UIQueue.class, getClass()); <line5> attributes.setAttribute(""rendered"", true); <line6> attributes.setAttribute(""requestDelay"", 750); <line7> } <line8> } <line9> "	"<line3>    logger.debug(""initializing bean "" + getClass().getName());"	task0	
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> @Test <line2> public void testSqlSelect() { <line3> SelectOperator oper = new SelectOperator(); <line4> oper.addIndex(new ColumnIndex(""b"", null)); <line5> oper.addIndex(new ColumnIndex(""c"", null)); <line6> BetweenCondition cond = new BetweenCondition(""a"", 0, 2); <line7> oper.setCondition(cond); <line8> CollectorTestSink sink = new CollectorTestSink(); <line9> oper.outport.setSink(sink); <line10> oper.setup(null); <line11> oper.beginWindow(1); <line12> HashMap<String, Object> tuple = new HashMap<String, Object>(); <line13> tuple.put(""a"", 0); <line14> tuple.put(""b"", 1); <line15> tuple.put(""c"", 2); <line16> oper.inport.process(tuple); <line17> tuple = new HashMap<String, Object>(); <line18> tuple.put(""a"", 1); <line19> tuple.put(""b"", 3); <line20> tuple.put(""c"", 4); <line21> oper.inport.process(tuple); <line22> tuple = new HashMap<String, Object>(); <line23> tuple.put(""a"", 2); <line24> tuple.put(""b"", 5); <line25> tuple.put(""c"", 6); <line26> oper.inport.process(tuple); <line27> tuple = new HashMap<String, Object>(); <line28> tuple.put(""a"", 3); <line29> tuple.put(""b"", 7); <line30> tuple.put(""c"", 8); <line31> oper.inport.process(tuple); <line32> oper.endWindow(); <line33> oper.teardown(); <line34> LOG.debug(""{}"", sink.collectedTuples); <line35> } <line36> } <line37> "	"<line34>    LOG.debug(""{}"", sink.collectedTuples);"	task0	
"public class A { <line0> @RequestMapping(value = ""/{id}"", method = RequestMethod.GET) <line1> public String handleRequest(Model model, @PathVariable Long id) { <line2> logger.info(""handleRequest""); <line3> LetterToAllophoneMapping letterToAllophoneMapping = letterToAllophoneMappingDao.read(id); <line4> model.addAttribute(""letterToAllophoneMapping"", letterToAllophoneMapping); <line5> List<Letter> letters = letterDao.readAllOrdered(); <line6> model.addAttribute(""letters"", letters); <line7> List<Allophone> allophones = allophoneDao.readAllOrdered(); <line8> model.addAttribute(""allophones"", allophones); <line9> return ""content/letter-to-allophone-mapping/edit""; <line10> } <line11> } <line12> "	"<line2>    logger.info(""handleRequest"");"	task0	
public class A { <line0> @Override <line1> public void addRelatedEntryFields(Document document, Object object) throws Exception { <line2> Comment comment = (Comment) object; <line3> FileEntry fileEntry = null; <line4> try { <line5> fileEntry = dlAppLocalService.getFileEntry(comment.getClassPK()); <line6> } catch (Exception exception) { <line7> if (log.isDebugEnabled()) { <line8> log.debug(exception, exception); <line9> } <line10> return; <line11> } <line12> if (fileEntry instanceof LiferayFileEntry) { <line13> DLFileEntry dlFileEntry = (DLFileEntry) fileEntry.getModel(); <line14> document.addKeyword(Field.FOLDER_ID, dlFileEntry.getFolderId()); <line15> document.addKeyword(Field.HIDDEN, dlFileEntry.isInHiddenFolder()); <line16> document.addKeyword( <line17> Field.TREE_PATH, StringUtil.split(dlFileEntry.getTreePath(), CharPool.SLASH)); <line18> } <line19> } <line20> } <line21> 	<line8>        log.debug(exception, exception);	task0	
"public class A { <line0> @Override <line1> public void merge(Collection<W> toBeMerged, W mergeResult) { <line2> if (LOG.isDebugEnabled()) { <line3> LOG.debug(""Merging {} into {}"", toBeMerged, mergeResult); <line4> } <line5> mergeResults.put(mergeResult, toBeMerged); <line6> } <line7> } <line8> "	"<line3>      LOG.debug(""Merging {} into {}"", toBeMerged, mergeResult);"	task0	
"public class A { <line0> @Override <line1> public boolean process(Exchange exchange, final AsyncCallback callback) { <line2> final Object oldStepId = exchange.removeProperty(ExchangePropertyKey.STEP_ID); <line3> exchange.setProperty(ExchangePropertyKey.STEP_ID, stepId); <line4> EventHelper.notifyStepStarted(exchange.getContext(), exchange, stepId); <line5> return super.process( <line6> exchange, <line7> sync -> { <line8> boolean failed = exchange.isFailed(); <line9> try { <line10> if (failed) { <line11> EventHelper.notifyStepFailed(exchange.getContext(), exchange, stepId); <line12> } else { <line13> EventHelper.notifyStepDone(exchange.getContext(), exchange, stepId); <line14> } <line15> } catch (Throwable t) { <line16> LOG.warn( <line17> ""Exception occurred during event notification. This exception will be ignored."", t); <line18> } finally { <line19> if (oldStepId != null) { <line20> exchange.setProperty(ExchangePropertyKey.STEP_ID, oldStepId); <line21> } else { <line22> exchange.removeProperty(ExchangePropertyKey.STEP_ID); <line23> } <line24> callback.done(sync); <line25> } <line26> }); <line27> } <line28> } <line29> "	"<line16>            LOG.warn(""Exception occurred during event notification. This exception will be ignored."", t);"	task0	
"public class A { <line0> public static void deleteLiferayUser( <line1> PortletRequest request, org.eclipse.sw360.datahandler.thrift.users.User user) { <line2> try { <line3> User liferayUser = findLiferayUser(request, user); <line4> UserLocalServiceUtil.deleteUser(liferayUser); <line5> } catch (PortalException | SystemException e) { <line6> log.error(""Could not delete Liferay user"", e); <line7> } <line8> } <line9> } <line10> "	"<line6>      log.error(""Could not delete Liferay user"", e);"	task0	
"public class A { <line0> @Override <line1> public void afterMessageProcessed( <line2> PipeLineResult processResult, Object rawMessageOrWrapper, Map<String, Object> context) <line3> throws ListenerException { <line4> FS fileSystem = getFileSystem(); <line5> if ((rawMessageOrWrapper instanceof MessageWrapper)) { <line6> MessageWrapper<?> wrapper = (MessageWrapper<?>) rawMessageOrWrapper; <line7> if (StringUtils.isNotEmpty(getLogFolder()) <line8> || StringUtils.isNotEmpty(getErrorFolder()) <line9> || StringUtils.isNotEmpty(getProcessedFolder())) { <line10> log.warn( <line11> ""cannot write ["" <line12> + wrapper.getId() <line13> + ""] to logFolder, errorFolder or processedFolder after manual retry from"" <line14> + "" errorStorage""); <line15> } <line16> } else { <line17> @SuppressWarnings(""unchecked"") <line18> F rawMessage = (F) rawMessageOrWrapper; <line19> try { <line20> if (StringUtils.isNotEmpty(getLogFolder())) { <line21> FileSystemUtils.copyFile( <line22> fileSystem, <line23> rawMessage, <line24> getLogFolder(), <line25> isOverwrite(), <line26> getNumberOfBackups(), <line27> isCreateFolders()); <line28> } <line29> if (isDelete() && (processResult.isSuccessful() || StringUtils.isEmpty(getErrorFolder()))) { <line30> fileSystem.deleteFile(rawMessage); <line31> return; <line32> } <line33> } catch (FileSystemException e) { <line34> throw new ListenerException( <line35> ""Could not move or delete file ["" + fileSystem.getName(rawMessage) + ""]"", e); <line36> } <line37> } <line38> } <line39> } <line40> "	"<line10>        log.warn(""cannot write [""+ wrapper.getId()+ ""] to logFolder, errorFolder or processedFolder after manual retry from""+ "" errorStorage"");"	task0	
"public class A { <line0> private void showNotSpecifiedError( <line1> @NonNls final String resourceId, List<String> modules, String editorNameToSelect) { <line2> String nameToSelect = null; <line3> final StringBuilder names = StringBuilderSpinAllocator.alloc(); <line4> final String message; <line5> try { <line6> final int maxModulesToShow = 10; <line7> for (String name : <line8> modules.size() > maxModulesToShow ? modules.subList(0, maxModulesToShow) : modules) { <line9> if (nameToSelect == null) { <line10> nameToSelect = name; <line11> } <line12> if (names.length() > 0) { <line13> names.append("",\n""); <line14> } <line15> names.append(""\""""); <line16> names.append(name); <line17> names.append(""\""""); <line18> } <line19> if (modules.size() > maxModulesToShow) { <line20> names.append("",\n...""); <line21> } <line22> message = CompilerBundle.message(resourceId, modules.size(), names.toString()); <line23> } finally { <line24> StringBuilderSpinAllocator.dispose(names); <line25> } <line26> if (ApplicationManager.getApplication().isUnitTestMode()) { <line27> LOG.error(message); <line28> } <line29> Messages.showMessageDialog( <line30> myProject, message, CommonBundle.getErrorTitle(), Messages.getErrorIcon()); <line31> showConfigurationDialog(nameToSelect, editorNameToSelect); <line32> } <line33> } <line34> "	<line27>      LOG.error(message);	task0	
"public class A { <line0> private X509CRL getCrl(String url) <line1> throws CertificateException, CRLException, NoSuchProviderException, NoSuchParserException, <line2> StreamParsingException, MalformedURLException, IOException, ExecutionException { <line3> if (!(url.startsWith(""http://"") || url.startsWith(""https://""))) { <line4> log.error(""It's possible to download CRL via HTTP and HTTPS only""); <line5> return null; <line6> } <line7> String cacheKey = url.toLowerCase(); <line8> X509CRL crl = crlCache.get(cacheKey); <line9> return crl; <line10> } <line11> } <line12> "	"<line4>      log.error(""It's possible to download CRL via HTTP and HTTPS only"");"	task0	
"public class A { <line0> public void run() { <line1> try { <line2> Thread.sleep(1000); <line3> cubeService.updateOnNewSegmentReady(cubeName); <line4> } catch (Throwable ex) { <line5> logger.error(""Error in updateOnNewSegmentReady()"", ex); <line6> } <line7> } <line8> } <line9> "	"<line5>      logger.error(""Error in updateOnNewSegmentReady()"", ex);"	task0	
"public class A { <line0> private synchronized void addComputation( <line1> String computationId, <line2> MapTask originalMapTask, <line3> Map<String, String> transformUserNameToStateFamily) { <line4> MapTask mapTask = fixMultiOutputInfos.apply(originalMapTask); <line5> if (!computationMap.containsKey(computationId)) { <line6> LOG.info(""Adding config for {}: {}"", computationId, mapTask); <line7> computationMap.put( <line8> computationId, <line9> new ComputationState( <line10> computationId, <line11> mapTask, <line12> workUnitExecutor, <line13> transformUserNameToStateFamily, <line14> stateCache.forComputation(computationId))); <line15> } <line16> } <line17> } <line18> "	"<line6>      LOG.info(""Adding config for {}: {}"", computationId, mapTask);"	task0	
"public class A { <line0> @Subscribe <line1> @SuppressWarnings(""unused"") <line2> public void listen(DeadEvent event) { <line3> LOG.trace(""No subscribers were interested in this event: "" + event.getEvent()); <line4> } <line5> } <line6> "	"<line3>    LOG.trace(""No subscribers were interested in this event: "" + event.getEvent());"	task0	
"public class A { <line0> @Override <line1> public void deleteSchemaVersion(Long schemaVersionId) <line2> throws SchemaNotFoundException, SchemaLifecycleException { <line3> LOG.info(""++++++++++++ deleteSchemaVersion {}"", schemaVersionId); <line4> } <line5> } <line6> "	"<line3>    LOG.info(""++++++++++++ deleteSchemaVersion {}"", schemaVersionId);"	task0	
public class A { <line0> @Override <line1> public void contribute(Document document, KaleoInstanceToken kaleoInstanceToken) { <line2> document.addKeyword(KaleoInstanceTokenField.CLASS_NAME, kaleoInstanceToken.getClassName()); <line3> document.addKeyword(Field.CLASS_PK, kaleoInstanceToken.getClassPK()); <line4> document.addKeywordSortable( <line5> KaleoInstanceTokenField.COMPLETED, kaleoInstanceToken.isCompleted()); <line6> document.addDateSortable( <line7> KaleoInstanceTokenField.COMPLETION_DATE, kaleoInstanceToken.getCompletionDate()); <line8> document.addDateSortable(Field.CREATE_DATE, kaleoInstanceToken.getCreateDate()); <line9> document.addKeywordSortable( <line10> KaleoInstanceTokenField.CURRENT_KALEO_NODE_NAME, <line11> kaleoInstanceToken.getCurrentKaleoNodeName()); <line12> document.addNumberSortable( <line13> KaleoInstanceTokenField.KALEO_INSTANCE_ID, kaleoInstanceToken.getKaleoInstanceId()); <line14> document.addKeyword( <line15> KaleoInstanceTokenField.KALEO_INSTANCE_TOKEN_ID, <line16> kaleoInstanceToken.getKaleoInstanceTokenId()); <line17> document.addDateSortable(Field.MODIFIED_DATE, kaleoInstanceToken.getModifiedDate()); <line18> document.addKeyword( <line19> KaleoInstanceTokenField.PARENT_KALEO_INSTANCE_TOKEN_ID, <line20> kaleoInstanceToken.getParentKaleoInstanceTokenId()); <line21> try { <line22> KaleoInstance kaleoInstance = <line23> kaleoInstanceLocalService.getKaleoInstance(kaleoInstanceToken.getKaleoInstanceId()); <line24> document.addKeyword( <line25> KaleoInstanceTokenField.KALEO_DEFINITION_NAME, kaleoInstance.getKaleoDefinitionName()); <line26> } catch (PortalException portalException) { <line27> if (log.isWarnEnabled()) { <line28> log.warn(portalException, portalException); <line29> } <line30> } <line31> AssetEntry assetEntry = getAssetEntry(kaleoInstanceToken); <line32> if (assetEntry != null) { <line33> document.addLocalizedText( <line34> KaleoInstanceTokenField.ASSET_DESCRIPTION, <line35> LocalizationUtil.populateLocalizationMap( <line36> assetEntry.getDescriptionMap(), <line37> assetEntry.getDefaultLanguageId(), <line38> assetEntry.getGroupId())); <line39> document.addLocalizedText( <line40> KaleoInstanceTokenField.ASSET_TITLE, <line41> LocalizationUtil.populateLocalizationMap( <line42> assetEntry.getTitleMap(), <line43> assetEntry.getDefaultLanguageId(), <line44> assetEntry.getGroupId())); <line45> } else { <line46> WorkflowHandler<?> workflowHandler = <line47> WorkflowHandlerRegistryUtil.getWorkflowHandler(kaleoInstanceToken.getClassName()); <line48> for (Locale availableLocale : <line49> LanguageUtil.getAvailableLocales(kaleoInstanceToken.getGroupId())) { <line50> document.addText( <line51> LocalizationUtil.getLocalizedName( <line52> KaleoInstanceTokenField.ASSET_TITLE, availableLocale.getLanguage()), <line53> workflowHandler.getTitle(kaleoInstanceToken.getClassPK(), availableLocale)); <line54> } <line55> } <line56> } <line57> } <line58> 	<line28>        log.warn(portalException, portalException);	task0	
"public class A { <line0> CacheSerializableRunnable getCacheSerializableRunnableForIndexUsageCheck() { <line1> SerializableRunnable PrIndexCheck = <line2> new CacheSerializableRunnable(""PrIndexCheck"") { <line3> @Override <line4> public void run2() { <line5> Cache cache = getCache(); <line6> QueryService qs = cache.getQueryService(); <line7> LogWriter logger = cache.getLogger(); <line8> Collection indexes = qs.getIndexes(); <line9> Iterator it = indexes.iterator(); <line10> while (it.hasNext()) { <line11> PartitionedIndex ind = (PartitionedIndex) it.next(); <line12> int indexUsageWithSizeEstimation = 3; <line13> logger.info( <line14> ""index uses for "" <line15> + ind.getNumberOfIndexedBuckets() <line16> + "" index "" <line17> + ind.getName() <line18> + "": "" <line19> + ind.getStatistics().getTotalUses()); <line20> assertEquals(6, ind.getStatistics().getTotalUses()); <line21> } <line22> } <line23> }; <line24> return (CacheSerializableRunnable) PrIndexCheck; <line25> } <line26> } <line27> "	"<line13>              logger.info(""index uses for ""+ ind.getNumberOfIndexedBuckets()+ "" index ""+ ind.getName()+ "": ""+ ind.getStatistics().getTotalUses());"	task0	
"public class A { <line0> @Override <line1> public CommerceChannelHealthStatus getCommerceChannelHealthStatus(String key) { <line2> if (Validator.isNull(key)) { <line3> return null; <line4> } <line5> ServiceWrapper<CommerceChannelHealthStatus> commerceChannelHealthStatusServiceWrapper = <line6> _commerceChannelHealthStatusRegistryMap.getService(key); <line7> if (commerceChannelHealthStatusServiceWrapper == null) { <line8> if (log.isDebugEnabled()) { <line9> log.debug(""No commerce health status registered with key "" + key); <line10> } <line11> return null; <line12> } <line13> return commerceChannelHealthStatusServiceWrapper.getService(); <line14> } <line15> } <line16> "	"<line9>        log.debug(""No commerce health status registered with key "" + key);"	task0	
public class A { <line0> @Override <line1> public void info(String message, Object... params) { <line2> if (params != null && params.length > 0) { <line3> message = String.format(message, params); <line4> } <line5> logger.info(message); <line6> } <line7> } <line8> 	<line5>    logger.info(message);	task0	
public class A { <line0> public static void error(Object msg, Throwable ex) { <line1> Logger logger = LogUtil.getLogger(); <line2> if (logger != null && logger.isErrorEnabled()) { <line3> logger.error(LogUtil.getMsg(msg), ex); <line4> } <line5> } <line6> } <line7> 	<line3>      logger.error(LogUtil.getMsg(msg), ex);	task0	
"public class A { <line0> private void check3VehicleJourney1( <line1> Context context, VehicleJourney vj, ValidationParameters parameters) { <line2> if (isEmpty(vj.getVehicleJourneyAtStops())) { <line3> log.error(""vehicleJourney "" + vj.getObjectId() + "" has no vehicleJourneyAtStop""); <line4> return; <line5> } <line6> long maxDiffTime = parameters.getInterStopDurationMax(); <line7> List<VehicleJourneyAtStop> vjasList = vj.getVehicleJourneyAtStops(); <line8> for (VehicleJourneyAtStop vjas : vjasList) { <line9> long diffTime = <line10> Math.abs( <line11> diffTime( <line12> vjas.getArrivalTime(), <line13> vjas.getArrivalDayOffset(), <line14> vjas.getDepartureTime(), <line15> vjas.getDepartureDayOffset())); <line16> if (diffTime > maxDiffTime) { <line17> DataLocation location = buildLocation(context, vj); <line18> DataLocation target = buildLocation(context, vjas.getStopPoint().getContainedInStopArea()); <line19> ValidationReporter reporter = ValidationReporter.Factory.getInstance(); <line20> reporter.addCheckPointReportError( <line21> context, <line22> VEHICLE_JOURNEY_1, <line23> location, <line24> Long.toString(diffTime), <line25> Long.toString(maxDiffTime), <line26> target); <line27> } <line28> } <line29> } <line30> } <line31> "	"<line3>      log.error(""vehicleJourney "" + vj.getObjectId() + "" has no vehicleJourneyAtStop"");"	task0	
"public class A { <line0> @Test <line1> public void testFirst() throws Exception { <line2> LOG.info(""Starting RX-Java2 Flowable first""); <line3> Flowable.just(""Camel"", ""rocks"", ""streams"", ""as"", ""well"") <line4> .map(String::toUpperCase) <line5> .doOnNext(LOG::info) <line6> .subscribe(); <line7> } <line8> } <line9> "	"<line2>    LOG.info(""Starting RX-Java2 Flowable first"");"	task0	
public class A { <line0> public void config(String message) { <line1> logger.info(message); <line2> } <line3> } <line4> 	<line1>    logger.info(message);	task0	
"public class A { <line0> public AWSError parseAWSErrorFromContent(HttpRequest request, HttpResponse response) { <line1> if (response.getPayload() == null) return null; <line2> if (""text/plain"".equals(response.getPayload().getContentMetadata().getContentType())) <line3> return null; <line4> try { <line5> AWSError error = <line6> factory.create(errorHandlerProvider.get()).setContext(request).apply(response); <line7> if (error.getRequestId() == null) <line8> error.setRequestId(response.getFirstHeaderOrNull(requestId)); <line9> error.setRequestToken(response.getFirstHeaderOrNull(requestToken)); <line10> if (""SignatureDoesNotMatch"".equals(error.getCode())) { <line11> error.setStringSigned(signer.createStringToSign(request)); <line12> error.setSignature(signer.sign(error.getStringSigned())); <line13> } <line14> return error; <line15> } catch (RuntimeException e) { <line16> logger.warn(e, ""error parsing error""); <line17> return null; <line18> } <line19> } <line20> } <line21> "	"<line16>      logger.warn(e, ""error parsing error"");"	task0	
"public class A { <line0> @Test <line1> public void testMethodName() { <line2> Logger logger = LoggerFactory.getLogger(""my-log4j2-logger""); <line3> String result = <line4> recording.execute( <line5> new Runnable() { <line6> @Override <line7> public void run() { <line8> logger.warn(""hello""); <line9> } <line10> }); <line11> assertTrue(result.contains("".run:"")); <line12> } <line13> } <line14> "	"<line8>                logger.warn(""hello"");"	task0	
"public class A { <line0> @Override <line1> public void handleKillbillEvent(final ExtBusEvent killbillEvent) { <line2> logger.info(""Received external event {}"", killbillEvent.toString()); <line3> if (killbillEvent.getEventType() == ExtBusEventType.BLOCKING_STATE) { <line4> if (countPerToken.get(killbillEvent.getUserToken()) == null) { <line5> countPerToken.put(killbillEvent.getUserToken(), new AtomicInteger()); <line6> } <line7> final Integer seen = countPerToken.get(killbillEvent.getUserToken()).incrementAndGet(); <line8> if (!seen.toString().equalsIgnoreCase(killbillEvent.getMetaData())) { <line9> testDao.insertExternalKey(""error-"" + seen); <line10> throw new NotificationPluginApiRetryException(); <line11> } else { <line12> testDao.insertExternalKey(killbillEvent.getAccountId().toString()); <line13> return; <line14> } <line15> } <line16> if (killbillEvent.getEventType() != ExtBusEventType.ACCOUNT_CREATION) { <line17> return; <line18> } <line19> testDao.insertExternalKey(killbillEvent.getAccountId().toString()); <line20> } <line21> } <line22> "	"<line2>    logger.info(""Received external event {}"", killbillEvent.toString());"	task0	
"public class A { <line0> @Test <line1> public void testLoadAllNotes() { <line2> Note note; <line3> try { <line4> assertEquals(0, notebook.getAllNotes().size()); <line5> note = notebook.createNote(""note1"", anonymous); <line6> Paragraph p1 = note.addNewParagraph(AuthenticationInfo.ANONYMOUS); <line7> Map<String, Object> config = p1.getConfig(); <line8> config.put(""enabled"", true); <line9> p1.setConfig(config); <line10> p1.setText(""hello world""); <line11> notebook.saveNote(note, anonymous); <line12> } catch (IOException fe) { <line13> logger.warn( <line14> ""Failed to create note and paragraph. Possible problem with persisting note, safe to"" <line15> + "" ignore"", <line16> fe); <line17> } <line18> assertEquals(1, notebook.getAllNotes().size()); <line19> } <line20> } <line21> "	"<line13>      logger.warn(""Failed to create note and paragraph. Possible problem with persisting note, safe to""+ "" ignore"",fe);"	task0	
public class A { <line0> @Override <line1> public String getSummary( <line2> long classPK, PortletRequest portletRequest, PortletResponse portletResponse) { <line3> try { <line4> AssetRenderer<?> assetRenderer = getAssetRenderer(classPK); <line5> if (assetRenderer != null) { <line6> return assetRenderer.getSummary(portletRequest, portletResponse); <line7> } <line8> } catch (Exception exception) { <line9> if (log.isWarnEnabled()) { <line10> log.warn(exception, exception); <line11> } <line12> } <line13> return null; <line14> } <line15> } <line16> 	<line10>        log.warn(exception, exception);	task0	
"public class A { <line0> @Override <line1> public void updateExperimentRunName(String experimentRunId, String experimentRunName) { <line2> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line3> ExperimentRunEntity experimentRunEntity = <line4> session.load(ExperimentRunEntity.class, experimentRunId, LockMode.PESSIMISTIC_WRITE); <line5> experimentRunEntity.setName(experimentRunName); <line6> long currentTimestamp = Calendar.getInstance().getTimeInMillis(); <line7> experimentRunEntity.setDate_updated(currentTimestamp); <line8> Transaction transaction = session.beginTransaction(); <line9> session.update(experimentRunEntity); <line10> transaction.commit(); <line11> LOGGER.debug(""ExperimentRun name updated successfully""); <line12> } catch (Exception ex) { <line13> if (ModelDBUtils.needToRetry(ex)) { <line14> updateExperimentRunName(experimentRunId, experimentRunName); <line15> } else { <line16> throw ex; <line17> } <line18> } <line19> } <line20> } <line21> "	"<line11>      LOGGER.debug(""ExperimentRun name updated successfully"");"	task0	
"public class A { <line0> public String getAspectSpeed(@Nonnull String aspect, @Nonnull jmri.SignalSystem system) { <line1> String property = (String) system.getProperty(aspect, ""speed""); <line2> log.debug(""getAspectSpeed: aspect={}, speed={}"", aspect, property); <line3> return property; <line4> } <line5> } <line6> "	"<line2>    log.debug(""getAspectSpeed: aspect={}, speed={}"", aspect, property);"	task0	
public class A { <line0> public static com.liferay.portal.kernel.model.EmailAddressSoap getEmailAddress( <line1> long emailAddressId) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.EmailAddress returnValue = <line4> EmailAddressServiceUtil.getEmailAddress(emailAddressId); <line5> return com.liferay.portal.kernel.model.EmailAddressSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> log.error(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line7>      log.error(exception, exception);	task0	
"public class A { <line0> private boolean downloadFernflowerJar(PackageConfig packageConfig, Path fernflowerJar) { <line1> String downloadURL = <line2> String.format( <line3> ""https://jitpack.io/com/github/fesh0r/fernflower/%s/fernflower-%s.jar"", <line4> packageConfig.fernflower.hash, packageConfig.fernflower.hash); <line5> try (BufferedInputStream in = new BufferedInputStream(new URL(downloadURL).openStream()); <line6> FileOutputStream fileOutputStream = new FileOutputStream(fernflowerJar.toFile())) { <line7> byte[] dataBuffer = new byte[1024]; <line8> int bytesRead; <line9> while ((bytesRead = in.read(dataBuffer, 0, 1024)) != -1) { <line10> fileOutputStream.write(dataBuffer, 0, bytesRead); <line11> } <line12> return true; <line13> } catch (IOException e) { <line14> log.error(""Unable to download Fernflower from "" + downloadURL, e); <line15> return false; <line16> } <line17> } <line18> } <line19> "	"<line14>      log.error(""Unable to download Fernflower from "" + downloadURL, e);"	task0	
"public class A { <line0> @Override <line1> public SpiResponse<List<SpiTrustedBeneficiaries>> requestTrustedBeneficiariesList( <line2> @NotNull SpiContextData spiContextData, <line3> SpiAccountReference accountReference, <line4> @NotNull SpiAccountConsent spiAccountConsent, <line5> @NotNull SpiAspspConsentDataProvider spiAspspConsentDataProvider) { <line6> logger.info(""Retrieving mock trusted beneficiaries list for consent: {}"", spiAccountConsent); <line7> SpiTrustedBeneficiaries trustedBeneficiaries = <line8> new SpiTrustedBeneficiaries( <line9> ""mocked trusted beneficiaries id"", <line10> SpiAccountReference.builder().iban(""mocked debtor iban"").build(), <line11> SpiAccountReference.builder().iban(""mocked creditor iban"").build(), <line12> ""mocked creditor agent"", <line13> ""mocked creditor name"", <line14> ""mocked creditor alias"", <line15> ""mocked creditor id"", <line16> new SpiAddress( <line17> ""mocked street name"", <line18> ""mocked building number"", <line19> ""mocked town name"", <line20> ""mocked post code"", <line21> ""mocked country"")); <line22> return SpiResponse.<List<SpiTrustedBeneficiaries>>builder() <line23> .payload(Collections.singletonList(trustedBeneficiaries)) <line24> .build(); <line25> } <line26> } <line27> "	"<line6>    logger.info(""Retrieving mock trusted beneficiaries list for consent: {}"", spiAccountConsent);"	task0	
public class A { <line0> private void createFeatureTypes(Collection<Pair<ArcGISLayer, DataGroupInfo>> layersAndParents) { <line1> List<FeatureCreator> tasks = <line2> layersAndParents.stream() <line3> .filter(lp -> !lp.getFirstObject().isSingleFusedMapCache()) <line4> .map(lp -> new FeatureCreator(lp.getFirstObject(), lp.getSecondObject())) <line5> .collect(Collectors.toList()); <line6> try { <line7> myExecutor.invokeAll(tasks); <line8> } catch (InterruptedException e) { <line9> LOGGER.error(e, e); <line10> } <line11> } <line12> } <line13> 	<line9>      LOGGER.error(e, e);	task0	
"public class A { <line0> public static void trace(ResourceRequest req, String src) { <line1> if (isTrace) { <line2> List<String> attrNames = Collections.list(req.getAttributeNames()); <line3> StringBuilder txt = new StringBuilder(128); <line4> txt.append(src); <line5> txt.append(""\nAttribute names: "").append(attrNames); <line6> txt.append(""\nasync_request_uri:      "") <line7> .append((String) req.getAttribute(""javax.servlet.async.request_uri"")); <line8> txt.append(""\nasync_context_path:      "") <line9> .append((String) req.getAttribute(""javax.servlet.async.context_path"")); <line10> txt.append(""\nasync_servlet_path:      "") <line11> .append((String) req.getAttribute(""javax.servlet.async.servlet_path"")); <line12> txt.append(""\nasync_path_info:      "") <line13> .append((String) req.getAttribute(""javax.servlet.async.path_info"")); <line14> txt.append(""\nasync_query_string:      "") <line15> .append((String) req.getAttribute(""javax.servlet.async.query_string"")); <line16> txt.append(""\nforward_request_uri:      "") <line17> .append((String) req.getAttribute(""javax.servlet.forward.request_uri"")); <line18> txt.append(""\nforward_context_path:      "") <line19> .append((String) req.getAttribute(""javax.servlet.forward.context_path"")); <line20> txt.append(""\nforward_servlet_path:      "") <line21> .append((String) req.getAttribute(""javax.servlet.forward.servlet_path"")); <line22> txt.append(""\nforward_path_info:      "") <line23> .append((String) req.getAttribute(""javax.servlet.forward.path_info"")); <line24> txt.append(""\nforward_query_string:      "") <line25> .append((String) req.getAttribute(""javax.servlet.forward.query_string"")); <line26> txt.append(""\ninclude_request_uri:      "") <line27> .append((String) req.getAttribute(""javax.servlet.include.request_uri"")); <line28> txt.append(""\ninclude_context_path:      "") <line29> .append((String) req.getAttribute(""javax.servlet.include.context_path"")); <line30> txt.append(""\ninclude_servlet_path:      "") <line31> .append((String) req.getAttribute(""javax.servlet.include.servlet_path"")); <line32> txt.append(""\ninclude_path_info:      "") <line33> .append((String) req.getAttribute(""javax.servlet.include.path_info"")); <line34> txt.append(""\ninclude_query_string:      "") <line35> .append((String) req.getAttribute(""javax.servlet.include.query_string"")); <line36> txt.append(""\nmethod_context_path:      "").append(req.getContextPath()); <line37> logger.debug(txt.toString()); <line38> } <line39> } <line40> } <line41> "	<line37>      logger.debug(txt.toString());	task0	
public class A { <line0> public String print(String xmlDeclaration, String indent) { <line1> Transformer serializer; <line2> try { <line3> serializer = tf.newTransformer(); <line4> serializer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, xmlDeclaration); <line5> serializer.setOutputProperty(OutputKeys.INDENT, indent); <line6> serializer.setOutputProperty( <line7> OutputPropertiesFactory.S_KEY_CONTENT_HANDLER, <line8> org.apache.xml.serializer.ToXMLStream.class.getName()); <line9> StringWriter writer = new StringWriter(); <line10> serializer.transform(new DOMSource(document), new StreamResult(writer)); <line11> return writer.toString(); <line12> } catch (TransformerFactoryConfigurationError | TransformerException e) { <line13> LOGGER.debug(e.getMessage(), e); <line14> } <line15> return null; <line16> } <line17> } <line18> 	<line13>      LOGGER.debug(e.getMessage(), e);	task0	
public class A { <line0> public static boolean isReachable(String url) { <line1> try { <line2> return isReachable(new URL(url)); <line3> } catch (MalformedURLException e) { <line4> LOG.error(e.getMessage(), e); <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line4>      LOG.error(e.getMessage(), e);	task0	
"public class A { <line0> private void setLocationFromBoundingBox( <line1> MetacardImpl metacard, String north, String south, String east, String west) { <line2> try { <line3> Envelope envelope = <line4> new Envelope( <line5> Double.parseDouble(east.trim()), <line6> Double.parseDouble(west.trim()), <line7> Double.parseDouble(south.trim()), <line8> Double.parseDouble(north.trim())); <line9> String wkt = WKT_WRITER_THREAD_LOCAL.get().write(factory.toGeometry(envelope)); <line10> if (wkt != null) { <line11> metacard.setAttribute(Core.LOCATION, wkt); <line12> } <line13> } catch (NumberFormatException nfe) { <line14> LOGGER.debug( <line15> ""Unable to parse double from GMD metadata {}, {}, {}, {}"", west, east, south, north); <line16> } <line17> } <line18> } <line19> "	"<line14>      LOGGER.debug(""Unable to parse double from GMD metadata {}, {}, {}, {}"", west, east, south, north);"	task0	
"public class A { <line0> @Override <line1> protected void persistBlobs(String key, long sizeOfBlobs, List<Map<String, String>> blobInfos) { <line2> synchronized (this) { <line3> StorageEntry entry = getStorageEntry(key); <line4> if (entry == null) { <line5> if (sizeOfBlobs > 0) { <line6> incrementStorageSize(sizeOfBlobs); <line7> } <line8> entry = new StorageEntry(); <line9> } else { <line10> incrementStorageSize(sizeOfBlobs - entry.getSize()); <line11> } <line12> entry.setSize(sizeOfBlobs); <line13> entry.setBlobInfos(blobInfos); <line14> if (log.isDebugEnabled()) { <line15> log.debug( <line16> String.format(""Setting blobs %s in StorageEntry stored at key %s"", blobInfos, key)); <line17> } <line18> putStorageEntry(key, entry); <line19> } <line20> } <line21> } <line22> "	"<line15>        log.debug(String.format(""Setting blobs %s in StorageEntry stored at key %s"", blobInfos, key));"	task0	
"public class A { <line0> private Option<DublinCoreCatalog> isNew(DublinCoreCatalog dc) <line1> throws SeriesServiceDatabaseException { <line2> final String id = dc.getFirst(DublinCore.PROPERTY_IDENTIFIER); <line3> if (id != null) { <line4> try { <line5> return equals(persistence.getSeries(id), dc) ? Option.<DublinCoreCatalog>none() : some(dc); <line6> } catch (NotFoundException e) { <line7> return some(dc); <line8> } <line9> } else { <line10> logger.info(""Series Dublin Core does not contain identifier, generating one""); <line11> dc.set(DublinCore.PROPERTY_IDENTIFIER, UUID.randomUUID().toString()); <line12> return some(dc); <line13> } <line14> } <line15> } <line16> "	"<line10>      logger.info(""Series Dublin Core does not contain identifier, generating one"");"	task0	
public class A { <line0> @Override <line1> public IQ handle(IQ iq) { <line2> LOGGER.debug(String.format(Messages.Log.RECEIVING_REMOTE_REQUEST_S, iq.getID())); <line3> String orderJsonStr = unmarshalOrder(iq); <line4> String className = unmarshalClassName(iq); <line5> IQ response = IQ.createResultIQ(iq); <line6> Gson gson = new Gson(); <line7> Order order = null; <line8> try { <line9> order = (Order) gson.fromJson(orderJsonStr, Class.forName(className)); <line10> String senderId = <line11> IntercomponentUtil.getSender( <line12> iq.getFrom().toBareJID(), SystemConstants.XMPP_SERVER_NAME_PREFIX); <line13> RemoteFacade.getInstance().activateOrder(senderId, order); <line14> } catch (Throwable e) { <line15> XmppExceptionToErrorConditionTranslator.updateErrorCondition(response, e); <line16> } <line17> return response; <line18> } <line19> } <line20> 	<line2>    LOGGER.debug(String.format(Messages.Log.RECEIVING_REMOTE_REQUEST_S, iq.getID()));	task0	
"public class A { <line0> @Override <line1> public void execute() { <line2> if (!resultInjectedFromCache) { <line3> try { <line4> LoadPolymorphicCnAElementById command = <line5> new LoadPolymorphicCnAElementById(new Integer[] {rootElmt}); <line6> command = getCommandService().executeCommand(command); <line7> CnATreeElement root = command.getElements().get(0); <line8> List<Process> processList = new ArrayList<Process>(0); <line9> if (root instanceof Organization || root instanceof Audit) { <line10> processList.addAll(getProcesses(root)); <line11> } else if (root instanceof Process) { <line12> processList.add((Process) root); <line13> } <line14> for (Process p : processList) { <line15> List<CnATreeElement> assets = loadLinkedProcesses(p); <line16> for (CnATreeElement asset : assets) { <line17> List<CnATreeElement> scenarios = loadLinkedIncidentSzenarios(asset); <line18> for (CnATreeElement scenario : scenarios) { <line19> if (affectsCIA(scenario)) { <line20> scenario = <line21> (IncidentScenario) <line22> getDaoFactory() <line23> .getDAO(IncidentScenario.TYPE_ID) <line24> .initializeAndUnproxy(scenario); <line25> CnATreeElement parent = loadScenarioParent(scenario); <line26> if (!isScenarioGroupRoot(parent, scenario)) { <line27> int riskColor = getRiskColour(asset, scenario); <line28> setRiskColourForParentScenarioGroup(parent.getUuid(), riskColor); <line29> } <line30> } <line31> } <line32> } <line33> } <line34> generateResult(); <line35> } catch (CommandException e) { <line36> log.error(""Error while executing command"", e); <line37> } <line38> } <line39> } <line40> } <line41> "	"<line36>        log.error(""Error while executing command"", e);"	task0	
"public class A { <line0> protected void rollback() { <line1> try { <line2> connection.rollback(); <line3> } catch (Exception e) { <line4> log.warn(""An error occurred while trying to rollback a connection"", e); <line5> } <line6> } <line7> } <line8> "	"<line4>      log.warn(""An error occurred while trying to rollback a connection"", e);"	task0	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> switch (request.getCommandCode()) { <line4> case RxAARequest.code: <line5> handleEvent(new Event(true, factory.createAARequest(request), null)); <line6> break; <line7> case RxSessionTermRequest.code: <line8> handleEvent(new Event(true, factory.createSessionTermRequest(request), null)); <line9> break; <line10> default: <line11> listener.doOtherEvent(session, new AppRequestEventImpl(request), null); <line12> break; <line13> } <line14> } catch (Exception e) { <line15> logger.debug(""Failed to process request message"", e); <line16> } <line17> } <line18> } <line19> "	"<line15>      logger.debug(""Failed to process request message"", e);"	task0	
public class A { <line0> private void addToNode(Node node, List<WMSLayerState> layerStates) { <line1> for (WMSLayerState layerState : layerStates) { <line2> try { <line3> XMLUtilities.marshalJAXBObjectToElement(layerState, node); <line4> } catch (JAXBException e) { <line5> LOGGER.error(e.getMessage(), e); <line6> } <line7> } <line8> } <line9> } <line10> 	<line5>        LOGGER.error(e.getMessage(), e);	task0	
"public class A { <line0> @Override <line1> public void abort(String why, Throwable e) { <line2> LOG.warn(""Aborting ReplicationHFileCleaner because "" + why, e); <line3> this.aborted = true; <line4> stop(why); <line5> } <line6> } <line7> "	"<line2>    LOG.warn(""Aborting ReplicationHFileCleaner because "" + why, e);"	task0	
"public class A { <line0> public static void initCredentialsForCluster(Job job, Configuration conf) throws IOException { <line1> UserProvider userProvider = UserProvider.instantiate(job.getConfiguration()); <line2> if (userProvider.isHBaseSecurityEnabled()) { <line3> try { <line4> Connection peerConn = ConnectionFactory.createConnection(conf); <line5> try { <line6> TokenUtil.addTokenForJob(peerConn, userProvider.getCurrent(), job); <line7> } finally { <line8> peerConn.close(); <line9> } <line10> } catch (InterruptedException e) { <line11> LOG.info(""Interrupted obtaining user authentication token""); <line12> Thread.interrupted(); <line13> } <line14> } <line15> } <line16> } <line17> "	"<line11>        LOG.info(""Interrupted obtaining user authentication token"");"	task0	
"public class A { <line0> public String getUrlLink(final Map<String, Object> document) { <line1> final FessConfig fessConfig = ComponentUtil.getFessConfig(); <line2> String url = DocumentUtil.getValue(document, fessConfig.getIndexFieldUrl(), String.class); <line3> if (StringUtil.isBlank(url)) { <line4> return ""#not-found-"" <line5> + DocumentUtil.getValue(document, fessConfig.getIndexFieldDocId(), String.class); <line6> } <line7> final boolean isSmbUrl = url.startsWith(""smb:"") || url.startsWith(""smb1:""); <line8> final boolean isFtpUrl = url.startsWith(""ftp:""); <line9> final boolean isSmbOrFtpUrl = isSmbUrl || isFtpUrl; <line10> url = ComponentUtil.getPathMappingHelper().replaceUrl(url); <line11> final boolean isHttpUrl = url.startsWith(""http:"") || url.startsWith(""https:""); <line12> if (isSmbUrl) { <line13> url = url.replace(""smb:"", ""file:""); <line14> url = url.replace(""smb1:"", ""file:""); <line15> } <line16> if (isHttpUrl && isSmbOrFtpUrl) { <line17> final StringBuilder buf = new StringBuilder(url.length() + 100); <line18> for (final char c : url.toCharArray()) { <line19> if (CharUtil.isUrlChar(c)) { <line20> buf.append(c); <line21> } else { <line22> try { <line23> buf.append(URLEncoder.encode(String.valueOf(c), urlLinkEncoding)); <line24> } catch (final UnsupportedEncodingException e) { <line25> buf.append(c); <line26> } <line27> } <line28> } <line29> url = buf.toString(); <line30> } else if (url.startsWith(""file:"")) { <line31> url = updateFileProtocol(url); <line32> if (encodeUrlLink) { <line33> return appendQueryParameter(document, url); <line34> } <line35> if (!isSmbOrFtpUrl) { <line36> try { <line37> url = URLDecoder.decode(url.replace(""+"", ""%2B""), urlLinkEncoding); <line38> } catch (final Exception e) { <line39> if (logger.isDebugEnabled()) { <line40> logger.warn(""Failed to decode {}"", url, e); <line41> } <line42> } <line43> } <line44> } <line45> return appendQueryParameter(document, url); <line46> } <line47> } <line48> "	"<line40>            logger.warn(""Failed to decode {}"", url, e);"	task0	
"public class A { <line0> public String getValueFromServer(String url) throws Exception { <line1> RemoteUrl remoteUrl = new RemoteUrl(url, hostList); <line2> ValueVo confItemVo = <line3> restfulMgr.getJsonData(ValueVo.class, remoteUrl, retryTime, retrySleepSeconds); <line4> LOGGER.debug(""remote server return: "" + confItemVo.toString()); <line5> if (confItemVo.getStatus().equals(Constants.NOTOK)) { <line6> throw new Exception(""status is not ok.""); <line7> } <line8> return confItemVo.getValue(); <line9> } <line10> } <line11> "	"<line4>    LOGGER.debug(""remote server return: "" + confItemVo.toString());"	task0	
"public class A { <line0> private void findConfigurationsInsideVfModule( <line1> DelegateExecution execution, <line2> String vnfId, <line3> String vfModuleId, <line4> List<Resource> resourceList, <line5> List<Pair<WorkflowType, String>> aaiResourceIds) { <line6> try { <line7> org.onap.aai.domain.yang.VfModule aaiVfModule = <line8> bbInputSetupUtils.getAAIVfModule(vnfId, vfModuleId); <line9> AAIResultWrapper vfModuleWrapper = <line10> new AAIResultWrapper( <line11> new AAICommonObjectMapperProvider().getMapper().writeValueAsString(aaiVfModule)); <line12> Optional<Relationships> relationshipsOp; <line13> relationshipsOp = vfModuleWrapper.getRelationships(); <line14> if (relationshipsOp.isPresent()) { <line15> relationshipsOp = workflowActionUtils.extractRelationshipsVnfc(relationshipsOp.get()); <line16> addConfigToResources(relationshipsOp, resourceList, aaiResourceIds); <line17> } <line18> } catch (Exception ex) { <line19> logger.error(""Exception in findConfigurationsInsideVfModule"", ex); <line20> buildAndThrowException(execution, ""Failed to find Configuration object from the vfModule.""); <line21> } <line22> } <line23> } <line24> "	"<line19>      logger.error(""Exception in findConfigurationsInsideVfModule"", ex);"	task0	
"public class A { <line0> @Override <line1> public List<Long> getRunningSecStorageVmListByMsid(SecondaryStorageVm.Role role, long msid) { <line2> List<Long> l = new ArrayList<Long>(); <line3> TransactionLegacy txn = TransactionLegacy.currentTxn(); <line4> ; <line5> PreparedStatement pstmt = null; <line6> try { <line7> String sql; <line8> if (role == null) { <line9> sql = <line10> ""SELECT s.id FROM secondary_storage_vm s, vm_instance v, host h "" <line11> + ""WHERE s.id=v.id AND v.state='Running' AND v.host_id=h.id AND h.mgmt_server_id=?""; <line12> } else { <line13> sql = <line14> ""SELECT s.id FROM secondary_storage_vm s, vm_instance v, host h WHERE s.id=v.id AND"" <line15> + "" v.state='Running' AND s.role=? AND v.host_id=h.id AND h.mgmt_server_id=?""; <line16> } <line17> pstmt = txn.prepareAutoCloseStatement(sql); <line18> if (role == null) { <line19> pstmt.setLong(1, msid); <line20> } else { <line21> pstmt.setString(1, role.toString()); <line22> pstmt.setLong(2, msid); <line23> } <line24> ResultSet rs = pstmt.executeQuery(); <line25> while (rs.next()) { <line26> l.add(rs.getLong(1)); <line27> } <line28> } catch (SQLException e) { <line29> logger.debug(""Caught SQLException: "", e); <line30> } <line31> return l; <line32> } <line33> } <line34> "	"<line29>      logger.debug(""Caught SQLException: "", e);"	task0	
"public class A { <line0> @Override <line1> public void shutDown() { <line2> if (initialized.compareAndSet(true, false)) { <line3> stop(); <line4> configuration.removeChangeListener(this); <line5> instrumentation.removeTransformer(this); <line6> Thread t = transformThread; <line7> transformThread = null; <line8> if (t != null && !t.isInterrupted()) { <line9> t.interrupt(); <line10> } <line11> cleanUp.set(true); <line12> try { <line13> instrumentApplication(); <line14> } catch (Throwable e) { <line15> LOG.warn(""Failed to shutdown due "" + e.getMessage() + "". This exception is ignored."", e); <line16> } <line17> } <line18> } <line19> } <line20> "	"<line15>        LOG.warn(""Failed to shutdown due "" + e.getMessage() + "". This exception is ignored."", e);"	task0	
"public class A { <line0> protected <T extends Comparable<T>> void assertSorted( <line1> String message, Iterable<T> list, boolean reverse) { <line2> LOGGER.info(""Assert sort reverse: "" + reverse); <line3> if (!reverse) { <line4> assertTrue(Ordering.natural().isOrdered(list), message); <line5> } else { <line6> assertTrue(Ordering.natural().reverse().isOrdered(list), message); <line7> } <line8> } <line9> } <line10> "	"<line2>    LOGGER.info(""Assert sort reverse: "" + reverse);"	task0	
"public class A { <line0> private static SSLContext createEasySSLContext() { <line1> try { <line2> SSLContext context = SSLContext.getInstance(""TLS""); <line3> context.init(null, new TrustManager[] {new DefaultX509TrustManager(null)}, null); <line4> return context; <line5> } catch (Exception e) { <line6> LOG.error(e.getMessage(), e); <line7> throw new HttpClientError(e.toString()); <line8> } <line9> } <line10> } <line11> "	<line6>      LOG.error(e.getMessage(), e);	task0	
"public class A { <line0> @Override <line1> public long length() { <line2> try { <line3> return fs.getFileStatus(hdfsPath).getLen(); <line4> } catch (IOException e) { <line5> logger.error(""Fail to get length of the file {}, "", hdfsPath.toUri(), e); <line6> return 0; <line7> } <line8> } <line9> } <line10> "	"<line5>      logger.error(""Fail to get length of the file {}, "", hdfsPath.toUri(), e);"	task0	
"public class A { <line0> @Override <line1> public String execute() { <line2> myValidate(); <line3> if (!hasActionErrors()) { <line4> try { <line5> getBean().copyTo(pingTarget); <line6> PingTargetManager pingTargetMgr = WebloggerFactory.getWeblogger().getPingTargetManager(); <line7> pingTargetMgr.savePingTarget(pingTarget); <line8> WebloggerFactory.getWeblogger().flush(); <line9> addMessage(isAdd() ? ""pingTarget.created"" : ""pingTarget.updated"", pingTarget.getName()); <line10> return SUCCESS; <line11> } catch (WebloggerException ex) { <line12> log.error(""Error adding/editing ping target"", ex); <line13> addError(""generic.error.check.logs""); <line14> } <line15> } <line16> return INPUT; <line17> } <line18> } <line19> "	"<line12>        log.error(""Error adding/editing ping target"", ex);"	task0	
"public class A { <line0> @Aspect(advice = org.support.project.ormapping.transaction.Transaction.class) <line1> private List<PointUserHistoriesEntity> reCalcPointUserHistoryOnUser(Integer userId, int offset2) { <line2> List<PointUserHistoriesEntity> list; <line3> list = PointUserHistoriesDao.get().selectOnUser(userId, limit, offset2, Order.ASC); <line4> for (PointUserHistoriesEntity item : list) { <line5> item.setBeforeTotal(calcTotal); <line6> calcTotal += item.getPoint(); <line7> item.setTotal(calcTotal); <line8> LOG.debug( <line9> ""\t"" <line10> + DateUtils.getSimpleFormat().format(item.getInsertDatetime()) <line11> + "" [total]"" <line12> + calcTotal); <line13> PointUserHistoriesDao.get().physicalUpdate(item); <line14> } <line15> return list; <line16> } <line17> } <line18> "	"<line8>      LOG.debug(""\t""+ DateUtils.getSimpleFormat().format(item.getInsertDatetime())+ "" [total]""+ calcTotal);"	task0	
public class A { <line0> @Override <line1> public MBStatsUser findByPrimaryKey(Serializable primaryKey) throws NoSuchStatsUserException { <line2> MBStatsUser mbStatsUser = fetchByPrimaryKey(primaryKey); <line3> if (mbStatsUser == null) { <line4> if (log.isDebugEnabled()) { <line5> log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line6> } <line7> throw new NoSuchStatsUserException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return mbStatsUser; <line10> } <line11> } <line12> 	<line5>        log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task0	
"public class A { <line0> @Override <line1> protected void postBusEventFromTransaction( <line2> final AccountModelDao account, <line3> final AccountModelDao savedAccount, <line4> final ChangeType changeType, <line5> final EntitySqlDaoWrapperFactory entitySqlDaoWrapperFactory, <line6> final InternalCallContext context) <line7> throws BillingExceptionBase { <line8> switch (changeType) { <line9> case INSERT: <line10> break; <line11> default: <line12> return; <line13> } <line14> final Long recordId = savedAccount.getRecordId(); <line15> final InternalCallContext rehydratedContext = <line16> internalCallContextFactory.createInternalCallContext(savedAccount, recordId, context); <line17> final AccountCreationInternalEvent creationEvent = <line18> new DefaultAccountCreationEvent( <line19> new DefaultAccountData(savedAccount), <line20> savedAccount.getId(), <line21> rehydratedContext.getAccountRecordId(), <line22> rehydratedContext.getTenantRecordId(), <line23> rehydratedContext.getUserToken()); <line24> try { <line25> eventBus.postFromTransaction( <line26> creationEvent, entitySqlDaoWrapperFactory.getHandle().getConnection()); <line27> } catch (final EventBusException e) { <line28> log.warn(""Failed to post account creation event for accountId='{}'"", savedAccount.getId(), e); <line29> } <line30> } <line31> } <line32> "	"<line28>      log.warn(""Failed to post account creation event for accountId='{}'"", savedAccount.getId(), e);"	task0	
"public class A { <line0> public static <T> T getFromJobExecutionContext( <line1> ExecutionContext context, String key, Type typeOfT) { <line2> Object valueString = context.get(key); <line3> if (valueString != null) { <line4> if (valueString instanceof String) { <line5> Gson gson = new Gson(); <line6> return (T) gson.fromJson((String) valueString, typeOfT); <line7> } else { <line8> logger.error( <line9> ""invalid data type saved into execution context: "" <line10> + valueString.getClass() <line11> + "", "" <line12> + valueString); <line13> } <line14> } <line15> return null; <line16> } <line17> } <line18> "	"<line8>        logger.error(""invalid data type saved into execution context: ""+ valueString.getClass()+ "", ""+ valueString);"	task0	
public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> if (_writer == null) { <line4> return; <line5> } <line6> _writer.close(); <line7> _writer = null; <line8> } catch (IOException ioException) { <line9> if (log.isDebugEnabled()) { <line10> log.debug(ioException, ioException); <line11> } <line12> _hasError = true; <line13> } <line14> } <line15> } <line16> 	<line10>        log.debug(ioException, ioException);	task0	
"public class A { <line0> @Override <line1> protected byte[] getData(Attributes attributes) { <line2> if (isRelative(uri)) { <line3> File img = OmFileHelper.getUserProfilePicture(userId, uri); <line4> try (InputStream is = new FileInputStream(img)) { <line5> return IOUtils.toByteArray(is); <line6> } catch (Exception e) { <line7> log.error(""failed to get bytes from image"", e); <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> "	"<line7>        log.error(""failed to get bytes from image"", e);"	task0	
public class A { <line0> public void logInfo(String string) { <line1> logger.info(string); <line2> } <line3> } <line4> 	<line1>    logger.info(string);	task0	
"public class A { <line0> private void setupWsClient() <line1> throws ExecutionException, IOException, InterruptedException, TimeoutException { <line2> if (wsClient != null) { <line3> wsClient.addHandler( <line4> recordingNameTopic, <line5> true, <line6> new Handler() { <line7> @Override <line8> public void onMessage(String type, String topic, Object data) { <line9> numSubscribers = Integer.valueOf((String) data); <line10> logger.info( <line11> ""Number of subscribers for recording started at {} is now {}"", <line12> getStartTime(), <line13> numSubscribers); <line14> } <line15>  <line16> @Override <line17> public void onClose() { <line18> numSubscribers = 0; <line19> } <line20> }); <line21> } <line22> } <line23> } <line24> "	"<line10>              logger.info(""Number of subscribers for recording started at {} is now {}"",getStartTime(),numSubscribers);"	task0	
"public class A { <line0> public static void delete(File file) throws HyracksDataException { <line1> try { <line2> if (file.isDirectory()) { <line3> if (!file.exists()) { <line4> return; <line5> } else if (!FileUtils.isSymlink(file)) { <line6> cleanDirectory(file); <line7> } <line8> } <line9> Files.delete(file.toPath()); <line10> } catch (NoSuchFileException | FileNotFoundException e) { <line11> LOGGER.warn(() -> FILE_NOT_FOUND_MSG + "": "" + e.getMessage(), e); <line12> } catch (IOException e) { <line13> throw HyracksDataException.create(ErrorCode.CANNOT_DELETE_FILE, e, file.getAbsolutePath()); <line14> } <line15> } <line16> } <line17> "	"<line11>      LOGGER.warn(() -> FILE_NOT_FOUND_MSG + "": "" + e.getMessage(), e);"	task0	
"public class A { <line0> public static Process startProcess(List<String> command) { <line1> String commandString = Joiner.on("" "").join(command); <line2> log.info(""Starting: %s"", commandString); <line3> ProcessBuilder processBuilder = new ProcessBuilder(command); <line4> Process process = startProcess(processBuilder); <line5> closeInput(process); <line6> pipeStdout(commandString, process); <line7> pipeStderr(commandString, process); <line8> return process; <line9> } <line10> } <line11> "	"<line2>    log.info(""Starting: %s"", commandString);"	task0	
"public class A { <line0> @POST <line1> @Path(""/{cmdletId}/stop"") <line2> public Response stop(@PathParam(""cmdletId"") String cmdletId) { <line3> Long longNumber = Long.parseLong(cmdletId); <line4> try { <line5> smartEngine.getCmdletManager().disableCmdlet(longNumber); <line6> return new JsonResponse<>(Response.Status.OK).build(); <line7> } catch (Exception e) { <line8> logger.error(""Exception in CmdletRestApi while stop cmdlet "" + longNumber, e); <line9> return new JsonResponse<>( <line10> Response.Status.INTERNAL_SERVER_ERROR, <line11> e.getMessage(), <line12> ExceptionUtils.getStackTrace(e)) <line13> .build(); <line14> } <line15> } <line16> } <line17> "	"<line8>      logger.error(""Exception in CmdletRestApi while stop cmdlet "" + longNumber, e);"	task0	
"public class A { <line0> @PreDestroy <line1> public void destroy() { <line2> log.info(""destroy""); <line3> if (_taskScheduler != null) { <line4> _taskScheduler.shutdown(); <line5> } <line6> } <line7> } <line8> "	"<line2>    log.info(""destroy"");"	task0	
"public class A { <line0> @Override <line1> public List<Study> findByTitle(String title) { <line2> List<Study> study = null; <line3> if (title != null) { <line4> try { <line5> study = studyDAO.findByTitle(title.trim()); <line6> } catch (Exception exception) { <line7> LOG.debug(""Cannot find Study by title "" + title); <line8> } <line9> } <line10> return study; <line11> } <line12> } <line13> "	"<line7>        LOG.debug(""Cannot find Study by title "" + title);"	task0	
"public class A { <line0> private void tagFrontLoadLastPeriods() { <line1> List<Period> periodList = examination.getPeriodList(); <line2> int frontLoadLastPeriodSize = <line3> examination.getConstraintConfiguration().getFrontLoadLastPeriodSize(); <line4> if (frontLoadLastPeriodSize == 0) { <line5> return; <line6> } <line7> int minimumPeriodId = periodList.size() - frontLoadLastPeriodSize; <line8> if (minimumPeriodId < 0) { <line9> logger.warn( <line10> ""The frontLoadLastPeriodSize ("" <line11> + frontLoadLastPeriodSize <line12> + "") is bigger than periodListSize ("" <line13> + periodList.size() <line14> + ""). Tagging all periods as frontLoadLast...""); <line15> minimumPeriodId = 0; <line16> } <line17> for (Period period : periodList.subList(minimumPeriodId, periodList.size())) { <line18> period.setFrontLoadLast(true); <line19> } <line20> } <line21> } <line22> "	"<line9>      logger.warn(""The frontLoadLastPeriodSize (""+ frontLoadLastPeriodSize+ "") is bigger than periodListSize (""+ periodList.size()+ ""). Tagging all periods as frontLoadLast..."");"	task0	
"public class A { <line0> private void notifyAsynchronousCommand(final ZToolPacket packet) { <line1> final AsynchronousCommandListener[] listeners; <line2> synchronized (asynchrounsCommandListeners) { <line3> listeners = asynchrounsCommandListeners.toArray(new AsynchronousCommandListener[] {}); <line4> } <line5> for (final AsynchronousCommandListener listener : listeners) { <line6> try { <line7> listener.receivedAsynchronousCommand(packet); <line8> } catch (Throwable e) { <line9> LOGGER.error(""Error in incoming asynchronous message processing."", e); <line10> } <line11> } <line12> } <line13> } <line14> "	"<line9>        LOGGER.error(""Error in incoming asynchronous message processing."", e);"	task0	
"public class A { <line0> private boolean needReloadContainerProviders(List<ContainerProvider> providers) { <line1> for (ContainerProvider provider : providers) { <line2> if (provider.needsReload()) { <line3> LOG.info( <line4> ""Detected container provider [{}] needs to be reloaded. Reloading all providers."", <line5> provider); <line6> return true; <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> "	"<line3>        LOG.info(""Detected container provider [{}] needs to be reloaded. Reloading all providers."",provider);"	task0	
"public class A { <line0> @Override <line1> public Optional<ActionResultOutput> get(ActionResultOutputKey actionResultOutputKey) { <line2> try { <line3> String query = <line4> ""select RUN_ID, PRC_ID, ACTION_ID, OUT_NM, OUT_VAL from "" <line5> + getMetadataRepository().getTableNameByLabel(""ActionResultOutputs"") <line6> + "" where RUN_ID = "" <line7> + SQLTools.getStringForSQL(actionResultOutputKey.getRunId()) <line8> + "" and ACTION_ID = "" <line9> + SQLTools.getStringForSQL(actionResultOutputKey.getActionId()) <line10> + "" and OUT_NM = "" <line11> + SQLTools.getStringForSQL(actionResultOutputKey.getOutputName()) <line12> + "" and PRC_ID = "" <line13> + actionResultOutputKey.getProcessId() <line14> + "";""; <line15> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(query, ""reader""); <line16> if (cachedRowSet.size() == 0) { <line17> return Optional.empty(); <line18> } else if (cachedRowSet.size() > 1) { <line19> LOGGER.warn( <line20> MessageFormat.format( <line21> ""Found multiple implementations for ActionResultOutput {0}. Returning first"" <line22> + "" implementation"", <line23> actionResultOutputKey.toString())); <line24> } <line25> cachedRowSet.next(); <line26> return Optional.of( <line27> new ActionResultOutput(actionResultOutputKey, cachedRowSet.getString(""OUT_VAL""))); <line28> } catch (SQLException e) { <line29> throw new RuntimeException(e); <line30> } <line31> } <line32> } <line33> "	"<line19>        LOGGER.warn(MessageFormat.format(""Found multiple implementations for ActionResultOutput {0}. Returning first""+ "" implementation"",actionResultOutputKey.toString()));"	task0	
"public class A { <line0> public static List<CartridgeInfoBean> fetchSubscriptionDataList() <line1> throws ArtifactLoadingException { <line2> String cartridgeString = <line3> readUrl(System.getProperty(Constants.BASE_URL400) + Constants.URL_SUBSCRIPTION); <line4> String cartridgeListString; <line5> if (cartridgeString != null) { <line6> cartridgeListString = <line7> cartridgeString.substring( <line8> cartridgeString.indexOf('['), (cartridgeString.lastIndexOf(']') + 1)); <line9> } else { <line10> String msg = ""Error while fetching subscription data list""; <line11> log.error(msg); <line12> throw new ArtifactLoadingException(msg); <line13> } <line14> return gson.fromJson( <line15> cartridgeListString, new TypeToken<List<CartridgeInfoBean>>() {}.getType()); <line16> } <line17> } <line18> "	<line11>      log.error(msg);	task0	
"public class A { <line0> protected void onStreamUnstalled(IStream stream) { <line1> Long time = streamsStalls.remove(stream); <line2> if (time != null) { <line3> long stallTime = System.nanoTime() - time; <line4> streamsStallTime.addAndGet(stallTime); <line5> if (LOG.isDebugEnabled()) <line6> LOG.debug( <line7> ""Stream unstalled after {} ms {}"", TimeUnit.NANOSECONDS.toMillis(stallTime), stream); <line8> } <line9> } <line10> } <line11> "	"<line6>        LOG.debug(""Stream unstalled after {} ms {}"", TimeUnit.NANOSECONDS.toMillis(stallTime), stream);"	task0	
"public class A { <line0> public ImportLocalizedAssetBody importLocalizedAssetForContent( <line1> Long assetId, <line2> Long localeId, <line3> String content, <line4> ImportLocalizedAssetBody.StatusForEqualTarget statusForEqualTarget, <line5> FilterConfigIdOverride filterConfigIdOverride, <line6> List<String> filterOptions) { <line7> logger.debug(""Import localized asset with asset id = {}, locale id = {}"", assetId, localeId); <line8> UriComponentsBuilder uriBuilder = <line9> UriComponentsBuilder.fromPath( <line10> getBasePathForResource(assetId, ""localized"", localeId, ""import"")); <line11> ImportLocalizedAssetBody importLocalizedAssetBody = new ImportLocalizedAssetBody(); <line12> importLocalizedAssetBody.setContent(content); <line13> importLocalizedAssetBody.setStatusForEqualTarget(statusForEqualTarget); <line14> importLocalizedAssetBody.setFilterConfigIdOverride(filterConfigIdOverride); <line15> importLocalizedAssetBody.setFilterOptions(filterOptions); <line16> return authenticatedRestTemplate.postForObject( <line17> uriBuilder.toUriString(), importLocalizedAssetBody, ImportLocalizedAssetBody.class); <line18> } <line19> } <line20> "	"<line7>    logger.debug(""Import localized asset with asset id = {}, locale id = {}"", assetId, localeId);"	task0	
"public class A { <line0> public void addBytes(String fileName, byte[] bytes) { <line1> try { <line2> fileName = MimeUtility.decodeText(fileName); <line3> } catch (UnsupportedEncodingException unsupportedEncodingException) { <line4> if (log.isWarnEnabled()) { <line5> log.warn(""Unable to decode file name "" + fileName, unsupportedEncodingException); <line6> } <line7> } <line8> _bytesOVPs.add(new ObjectValuePair<String, byte[]>(fileName, bytes)); <line9> } <line10> } <line11> "	"<line5>        log.warn(""Unable to decode file name "" + fileName, unsupportedEncodingException);"	task0	
"public class A { <line0> @Override <line1> public void selectBlockers(Ability source, Game game, UUID defendingPlayerId) { <line2> log.debug(""selectBlockers""); <line3> List<Permanent> blockers = getAvailableBlockers(game); <line4> CombatSimulator sim = simulateBlock(CombatSimulator.load(game), blockers, game); <line5> List<CombatGroup> groups = game.getCombat().getGroups(); <line6> for (int i = 0; i < groups.size(); i++) { <line7> for (CreatureSimulator creature : sim.groups.get(i).blockers) { <line8> groups.get(i).addBlocker(creature.id, playerId, game); <line9> } <line10> } <line11> } <line12> } <line13> "	"<line2>    log.debug(""selectBlockers"");"	task0	
public class A { <line0> @Override <line1> public AuditEvent remove(Serializable primaryKey) throws NoSuchEventException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> AuditEvent auditEvent = (AuditEvent) session.get(AuditEventImpl.class, primaryKey); <line6> if (auditEvent == null) { <line7> if (log.isDebugEnabled()) { <line8> log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line9> } <line10> throw new NoSuchEventException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(auditEvent); <line13> } catch (NoSuchEventException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	<line8>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task0	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public void run() { <line2> long lastTime = 0; <line3> while (true) { <line4> int[] copiedSelectedPositionIndices; <line5> List<NavigationPosition> copiedPositions; <line6> boolean recenter; <line7> synchronized (notificationMutex) { <line8> try { <line9> notificationMutex.wait(250); <line10> } catch (InterruptedException e) { <line11> } <line12> if (!running) return; <line13> if (!hasPositions()) continue; <line14> if (!isVisible()) continue; <line15> long currentTime = currentTimeMillis(); <line16> if (haveToRecenterMap <line17> || haveToRepaintSelectionImmediately <line18> || (haveToRepaintSelection && (currentTime - lastTime > 500))) { <line19> log.fine( <line20> ""Woke up to update selected positions: "" <line21> + selectionUpdateReason <line22> + "" haveToRepaintSelection: "" <line23> + haveToRepaintSelection <line24> + "" haveToRepaintSelectionImmediately: "" <line25> + haveToRepaintSelectionImmediately <line26> + "" haveToRecenterMap: "" <line27> + haveToRecenterMap); <line28> recenter = haveToRecenterMap; <line29> haveToRecenterMap = false; <line30> haveToRepaintSelectionImmediately = false; <line31> haveToRepaintSelection = false; <line32> copiedSelectedPositionIndices = new int[selectedPositionIndices.length]; <line33> System.arraycopy( <line34> selectedPositionIndices, <line35> 0, <line36> copiedSelectedPositionIndices, <line37> 0, <line38> copiedSelectedPositionIndices.length); <line39> copiedPositions = new ArrayList<>(positionsModel.getRoute().getPositions()); <line40> } else continue; <line41> } <line42> List<NavigationPosition> render = <line43> new ArrayList<>( <line44> positionReducer.reduceSelectedPositions( <line45> copiedPositions, copiedSelectedPositionIndices)); <line46> render.addAll(selectedPositions); <line47> NavigationPosition centerPosition = <line48> render.size() > 0 ? new BoundingBox(render).getCenter() : null; <line49> selectPositions(render, recenter ? centerPosition : null); <line50> log.info( <line51> ""Selected positions updated for "" <line52> + render.size() <line53> + "" positions, reason: "" <line54> + selectionUpdateReason <line55> + "", recentering: "" <line56> + recenter <line57> + "" to: "" <line58> + centerPosition); <line59> lastTime = currentTimeMillis(); <line60> } <line61> } <line62> } <line63> "	"<line50>      log.info(""Selected positions updated for ""+ render.size()+ "" positions, reason: ""+ selectionUpdateReason+ "", recentering: ""+ recenter+ "" to: ""+ centerPosition);"	task0	
"public class A { <line0> private void updateTaskWithChangedElementProperties() { <line1> if (!changedElementProperties.isEmpty()) { <line2> getTaskService().updateChangedElementProperties(task.getId(), changedElementProperties); <line3> changedElementProperties.clear(); <line4> LOG.info(""Updated task: saved changes in element properties.""); <line5> } <line6> } <line7> } <line8> "	"<line4>      LOG.info(""Updated task: saved changes in element properties."");"	task0	
"public class A { <line0> protected void restoreBackup(String backupSubFolder) throws ApsSystemException { <line1> try { <line2> this.restoreLocalDump(this.getEntandoTableMapping(), backupSubFolder); <line3> List<Component> components = this.getComponents(); <line4> for (int i = 0; i < components.size(); i++) { <line5> Component componentConfiguration = components.get(i); <line6> this.restoreLocalDump(componentConfiguration.getTableMapping(), backupSubFolder); <line7> } <line8> } catch (Throwable t) { <line9> logger.error(""Error while restoring local backup"", t); <line10> throw new ApsSystemException(""Error while restoring local backup"", t); <line11> } <line12> } <line13> } <line14> "	"<line9>      logger.error(""Error while restoring local backup"", t);"	task0	
"public class A { <line0> @Override <line1> @Transactional <line2> public void registerChannel(ChannelRequest channelRequest) { <line3> LOGGER.info(""Registering channel: {}"", channelRequest.getModuleName()); <line4> addOrUpdate(ChannelBuilder.fromChannelRequest(channelRequest).build()); <line5> } <line6> } <line7> "	"<line3>    LOGGER.info(""Registering channel: {}"", channelRequest.getModuleName());"	task0	
"public class A { <line0> @Override <line1> public void startStream() { <line2> LOGGER.debug(""startStream""); <line3> task = executor.submit(new WebHdfsPersistReaderTask(this)); <line4> } <line5> } <line6> "	"<line2>    LOGGER.debug(""startStream"");"	task0	
"public class A { <line0> public synchronized boolean deleteAll() { <line1> logger.info(""Start deleting all storage groups' timeseries""); <line2> syncCloseAllProcessor(); <line3> for (PartialPath storageGroup : IoTDB.metaManager.getAllStorageGroupPaths()) { <line4> this.deleteAllDataFilesInOneStorageGroup(storageGroup); <line5> } <line6> return true; <line7> } <line8> } <line9> "	"<line1>    logger.info(""Start deleting all storage groups' timeseries"");"	task0	
"public class A { <line0> private void readAndCheckEntry(JarFile jarFile, JarEntry entry) throws VerifyFailedException { <line1> InputStream is = null; <line2> byte[] buffer = new byte[8192]; <line3> try { <line4> is = jarFile.getInputStream(entry); <line5> while ((is.read(buffer, 0, buffer.length)) != -1) <line6> ; <line7> } catch (java.lang.SecurityException ex) { <line8> throw new VerifyFailedException(""Verify failed."" + ex.getMessage(), ex); <line9> } catch (IOException ex) { <line10> throw new VerifyFailedException(""Verify failed."" + ex.getMessage(), ex); <line11> } finally { <line12> if (is != null) { <line13> try { <line14> is.close(); <line15> } catch (IOException ex) { <line16> LOGGER.debug(""Close stream failed:"" + ex); <line17> } <line18> } <line19> } <line20> } <line21> } <line22> "	"<line16>          LOGGER.debug(""Close stream failed:"" + ex);"	task0	
"public class A { <line0> public void superAddValues(RecordingObject recordingObject) throws Exception { <line1> Group root = getRoot(); <line2> String path = ""/"" + recordingObject.getVariable().replace(""."", ""/""); <line3> HObject v = FileFormat.findObject(recordingsH5File, path); <line4> if (v == null) { <line5> logger.warn(""Creating variable "" + recordingObject.getVariable() + "" "" + i++); <line6> String[] splitByPeriod = recordingObject.getVariable().split(""\\.""); <line7> Group current = root; <line8> String currentTag = recordingObject.getVariable(); <line9> String currentPath = """"; <line10> for (int s = 0; s < splitByPeriod.length - 1; s++) { <line11> currentTag = splitByPeriod[s]; <line12> currentPath = currentPath.concat(""/"" + currentTag); <line13> current = createGroup(current, currentTag, currentPath, root); <line14> } <line15> currentTag = splitByPeriod[splitByPeriod.length - 1]; <line16> this.createDataSet(recordingObject, current, currentTag); <line17> } <line18> } <line19> } <line20> "	"<line5>      logger.warn(""Creating variable "" + recordingObject.getVariable() + "" "" + i++);"	task0	
"public class A { <line0> @Override <line1> public void onAccuracyChanged(Sensor sensor, int accuracy) { <line2> logger.debug(String.format(""accuracy changed to %d for %s"", accuracy, sensor.getName())); <line3> } <line4> } <line5> "	"<line2>    logger.debug(String.format(""accuracy changed to %d for %s"", accuracy, sensor.getName()));"	task0	
"public class A { <line0> @Override <line1> public Number readByValue(Integer value) throws DataAccessException { <line2> try { <line3> return (Number) <line4> em.createQuery(""SELECT n "" + ""FROM Number n "" + ""WHERE n.value = :value"") <line5> .setParameter(""value"", value) <line6> .getSingleResult(); <line7> } catch (NoResultException e) { <line8> logger.warn(""Number \"""" + value + ""\"" was not found""); <line9> return null; <line10> } <line11> } <line12> } <line13> "	"<line8>      logger.warn(""Number \"""" + value + ""\"" was not found"");"	task0	
"public class A { <line0> @Override <line1> public void onContainerStopped(ContainerId containerId) { <line2> if (LOG.isDebugEnabled()) { <line3> LOG.debug(""Succeeded to stop Container "" + containerId); <line4> } <line5> containers.remove(containerId); <line6> } <line7> } <line8> "	"<line3>      LOG.debug(""Succeeded to stop Container "" + containerId);"	task0	
"public class A { <line0> @Override <line1> public void reloadEntitySearchRecords(String id, IApsEntity entity) { <line2> Connection conn = null; <line3> try { <line4> conn = this.getConnection(); <line5> conn.setAutoCommit(false); <line6> this.executeReloadEntitySearchRecords(id, entity, conn); <line7> conn.commit(); <line8> } catch (Throwable t) { <line9> this.executeRollback(conn); <line10> logger.error(""Error detected while reloading references"", t); <line11> throw new RuntimeException(""Error detected while reloading references"", t); <line12> } finally { <line13> this.closeConnection(conn); <line14> } <line15> } <line16> } <line17> "	"<line10>      logger.error(""Error detected while reloading references"", t);"	task0	
"public class A { <line0> @Override <line1> public void before( <line2> Object target, <line3> String className, <line4> String methodName, <line5> String parameterDescription, <line6> Object[] args) { <line7> final InterceptorScopeInvocation transaction = scope.getCurrentInvocation(); <line8> if (transaction.tryEnter(policy)) { <line9> try { <line10> this.delegate.before(target, className, methodName, parameterDescription, args); <line11> } catch (Throwable t) { <line12> exceptionHandler.handleException(t); <line13> } <line14> } else { <line15> if (debugEnabled) { <line16> logger.debug( <line17> ""tryBefore() returns false: interceptorScopeTransaction: {}, executionPoint: {}. Skip"" <line18> + "" interceptor {}"", <line19> transaction, <line20> policy, <line21> delegate.getClass()); <line22> } <line23> } <line24> } <line25> } <line26> "	"<line16>        logger.debug(""tryBefore() returns false: interceptorScopeTransaction: {}, executionPoint: {}. Skip""+ "" interceptor {}"",transaction,policy,delegate.getClass());"	task0	
"public class A { <line0> private void submitParentCreateRequest(Context context, CreateRequest createRequest) <line1> throws IngestException, SourceUnavailableException { <line2> List<Metacard> createdMetacards = catalogFramework.create(createRequest).getCreatedMetacards(); <line3> List<String> createdIds = <line4> createdMetacards.stream().map(Metacard::getId).collect(Collectors.toList()); <line5> LOGGER.debug(""created parent metacards with ids: {}"", createdIds); <line6> context.setParentMetacard(createdMetacards.get(createdMetacards.size() - 1)); <line7> } <line8> } <line9> "	"<line5>    LOGGER.debug(""created parent metacards with ids: {}"", createdIds);"	task0	
"public class A { <line0> private URI buildResourceUri(final String... path) { <line1> final UriBuilder uriBuilder = uriInfo.getBaseUriBuilder(); <line2> uriBuilder.segment(path); <line3> URI uri = uriBuilder.build(); <line4> try { <line5> final String scheme = <line6> getFirstHeaderValue(PROXY_SCHEME_HTTP_HEADER, FORWARDED_PROTO_HTTP_HEADER); <line7> final String hostHeaderValue = <line8> getFirstHeaderValue(PROXY_HOST_HTTP_HEADER, FORWARDED_HOST_HTTP_HEADER); <line9> final String portHeaderValue = <line10> getFirstHeaderValue(PROXY_PORT_HTTP_HEADER, FORWARDED_PORT_HTTP_HEADER); <line11> final String host = WebUtils.determineProxiedHost(hostHeaderValue); <line12> final String port = WebUtils.determineProxiedPort(hostHeaderValue, portHeaderValue); <line13> String allowedContextPaths = properties.getAllowedContextPaths(); <line14> String resourcePath = WebUtils.getResourcePath(uri, httpServletRequest, allowedContextPaths); <line15> int uriPort = uri.getPort(); <line16> if (port != null) { <line17> if (StringUtils.isWhitespace(port)) { <line18> uriPort = -1; <line19> } else { <line20> try { <line21> uriPort = Integer.parseInt(port); <line22> } catch (final NumberFormatException nfe) { <line23> logger.warn( <line24> String.format( <line25> ""Unable to parse proxy port HTTP header '%s'. Using port from request URI"" <line26> + "" '%s'."", <line27> port, uriPort)); <line28> } <line29> } <line30> } <line31> uri = <line32> new URI( <line33> (StringUtils.isBlank(scheme)) ? uri.getScheme() : scheme, <line34> uri.getUserInfo(), <line35> (StringUtils.isBlank(host)) ? uri.getHost() : host, <line36> uriPort, <line37> resourcePath, <line38> uri.getQuery(), <line39> uri.getFragment()); <line40> } catch (final URISyntaxException use) { <line41> throw new UriBuilderException(use); <line42> } <line43> return uri; <line44> } <line45> } <line46> "	"<line23>            logger.warn(String.format(""Unable to parse proxy port HTTP header '%s'. Using port from request URI""+ "" '%s'."",port, uriPort));"	task0	
"public class A { <line0> protected boolean abortExecution() { <line1> final boolean abort = engine.exceedsRuntimeLimit(); <line2> if (abort) { <line3> final AutoFormattingTime aft = <line4> new AutoFormattingTime(engine.getRuntimeLimitInNanoseconds(), -1, 4); <line5> logger.info( <line6> ""Aborting execution (cleanly) because the runtime has exceeded the requested maximum "" <line7> + aft); <line8> } <line9> return abort; <line10> } <line11> } <line12> "	"<line5>      logger.info(""Aborting execution (cleanly) because the runtime has exceeded the requested maximum ""+ aft);"	task0	
"public class A { <line0> private void removeProcessControlTags(Process process, ConfigurationElementReport processReport) { <line1> LOGGER.debug(""Removing Process control tags for process "" + process.getId()); <line2> Long aliveTagId = process.getAliveTagId(); <line3> if (aliveTagId != null) { <line4> ConfigurationElementReport tagReport = <line5> new ConfigurationElementReport(Action.REMOVE, Entity.CONTROLTAG, aliveTagId); <line6> processReport.addSubReport(tagReport); <line7> controlTagConfigHandler.removeControlTag(aliveTagId, tagReport); <line8> } <line9> Long stateTagId = process.getStateTagId(); <line10> ConfigurationElementReport tagReport = <line11> new ConfigurationElementReport(Action.REMOVE, Entity.CONTROLTAG, stateTagId); <line12> processReport.addSubReport(tagReport); <line13> controlTagConfigHandler.removeControlTag(stateTagId, tagReport); <line14> } <line15> } <line16> "	"<line1>    LOGGER.debug(""Removing Process control tags for process "" + process.getId());"	task0	
"public class A { <line0> @Override <line1> public void reply(Message request, MessageReply reply) { <line2> if (Boolean.valueOf(request.getHeaderEntry(CloudBus.HEADER_NO_NEED_REPLY_MSG))) { <line3> if (logger.isTraceEnabled()) { <line4> logger.trace( <line5> String.format( <line6> ""%s in message%s is set, drop reply%s"", <line7> CloudBus.HEADER_NO_NEED_REPLY_MSG, <line8> wire.dumpMessage(request), <line9> wire.dumpMessage(reply))); <line10> } <line11> return; <line12> } <line13> AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder(); <line14> reply.setAMQPProperties(builder.deliveryMode(1).build()); <line15> reply.getHeaders().put(CloudBus.HEADER_IS_MESSAGE_REPLY, Boolean.TRUE.toString()); <line16> reply.putHeaderEntry(CloudBus.HEADER_CORRELATION_ID, request.getId()); <line17> reply.setServiceId(request.getHeaderEntry(CloudBus.HEADER_REPLY_TO)); <line18> buildResponseMessageMetaData(reply); <line19> if (request instanceof NeedReplyMessage) { <line20> callReplyPreSendingExtensions(reply, (NeedReplyMessage) request); <line21> } <line22> wire.send(reply, false); <line23> } <line24> } <line25> "	"<line4>        logger.trace(String.format(""%s in message%s is set, drop reply%s"",CloudBus.HEADER_NO_NEED_REPLY_MSG,wire.dumpMessage(request),wire.dumpMessage(reply)));"	task0	
"public class A { <line0> public void stopBeans() { <line1> with( <line2> new WithComponentLifeCycle() { <line3> @Override <line4> public void with(ComponentLifecycle lifecycle) { <line5> log.info(""stopping bean "" + lifecycle.getName()); <line6> lifecycle.stop(); <line7> } <line8> }); <line9> } <line10> } <line11> "	"<line5>            log.info(""stopping bean "" + lifecycle.getName());"	task0	
"public class A { <line0> public static void incrementFailedLoginAttemptsCounter(final Principal principal) { <line1> try { <line2> final PropertyKey<Integer> passwordAttemptsKey = <line3> StructrApp.key(Principal.class, ""passwordAttempts""); <line4> Integer failedAttempts = principal.getProperty(passwordAttemptsKey); <line5> if (failedAttempts == null) { <line6> failedAttempts = 0; <line7> } <line8> failedAttempts++; <line9> principal.setProperty(passwordAttemptsKey, failedAttempts); <line10> } catch (FrameworkException fex) { <line11> logger.warn(""Exception while incrementing failed login attempts counter"", fex); <line12> } <line13> } <line14> } <line15> "	"<line11>      logger.warn(""Exception while incrementing failed login attempts counter"", fex);"	task0	
"public class A { <line0> @Override <line1> public StubDownloader build(StubRunnerOptions stubRunnerOptions) { <line2> log.info(""Will download contracts using current build's Maven repository setup""); <line3> return new AetherStubDownloader( <line4> AetherStubDownloaderFactory.this.repoSystem, <line5> AetherStubDownloaderFactory.this.project.getRemoteProjectRepositories(), <line6> repoSession, <line7> AetherStubDownloaderFactory.this.settings); <line8> } <line9> } <line10> "	"<line2>    log.info(""Will download contracts using current build's Maven repository setup"");"	task0	
"public class A { <line0> @Test <line1> public void errorLevel_exceptionMessage_loggedInBefore_failsInLocator() { <line2> given(LOCATOR, () -> logger.error(EXCEPTION_MESSAGE)); <line3> Result result = runTest(ExecuteTaskBefore.class); <line4> assertThat(getFailure(result)) <line5> .isInstanceOf(AssertionError.class) <line6> .hasMessageContaining(""error"") <line7> .hasMessageContaining(EXCEPTION_MESSAGE); <line8> } <line9> } <line10> "	<line2>    given(LOCATOR, () -> logger.error(EXCEPTION_MESSAGE));	task0	
"public class A { <line0> protected <TransformT extends PTransform<? super PInput, POutput>> <line1> TransformEvaluator<TransformT> translate(TransformHierarchy.Node node, TransformT transform) { <line2> Map<TupleTag<?>, PCollection<?>> pValues; <line3> if (node.getInputs().isEmpty()) { <line4> pValues = node.getOutputs(); <line5> } else { <line6> pValues = node.getInputs(); <line7> } <line8> PCollection.IsBounded isNodeBounded = isBoundedCollection(pValues.values()); <line9> LOG.debug(""Translating {} as {}"", transform, isNodeBounded); <line10> return isNodeBounded.equals(PCollection.IsBounded.BOUNDED) <line11> ? translator.translateBounded(transform) <line12> : translator.translateUnbounded(transform); <line13> } <line14> } <line15> "	"<line9>    LOG.debug(""Translating {} as {}"", transform, isNodeBounded);"	task0	
"public class A { <line0> private void removeConnectionFromNote(String noteId, NotebookSocket socket) { <line1> LOGGER.debug(""Remove connection {} from note: {}"", socket, noteId); <line2> synchronized (noteSocketMap) { <line3> List<NotebookSocket> socketList = noteSocketMap.get(noteId); <line4> if (socketList != null) { <line5> socketList.remove(socket); <line6> } <line7> checkCollaborativeStatus(noteId, socketList); <line8> } <line9> } <line10> } <line11> "	"<line1>    LOGGER.debug(""Remove connection {} from note: {}"", socket, noteId);"	task0	
public class A { <line0> public Stream<Record> fetchAsStream() throws IOException { <line1> int retryCount = 0; <line2> final QueryStatistics.Measurer statTracker = new QueryStatistics.Measurer(); <line3> statTracker.recordQueryPrepStart(); <line4> PreparedStatement preparedStatement = getPreparedStatementStreaming(); <line5> statTracker.recordQueryPrepEnd(); <line6> while (true) { <line7> try { <line8> statTracker.recordQueryExecStart(); <line9> RecordIterator itr = <line10> QueryFetcher.getQueryResultsStream(preparedStatement, selectedColumns, dbConnection); <line11> itr.addStatisticsMeasurer(statTracker); <line12> Iterable<Record> i = () -> itr; <line13> Stream<Record> stream = StreamSupport.stream(i.spliterator(), false); <line14> stream = stream.onClose(() -> itr.close()); <line15> return stream; <line16> } catch (SQLRecoverableException e) { <line17> LOG.error(e.toString()); <line18> if (++retryCount > MAX_CONNECTION_RETRIES) { <line19> throw new IOException(e); <line20> } <line21> } catch (SQLException e) { <line22> throw new IOException(e); <line23> } <line24> } <line25> } <line26> } <line27> 	<line17>        LOG.error(e.toString());	task0	
"public class A { <line0> @Override <line1> public Long getRunningCollectionDataCount() { <line2> Long collectionCountSinceLastRestart = 0L; <line3> Client client = ClientBuilder.newBuilder().register(JacksonFeature.class).build(); <line4> try { <line5> WebTarget webResource = client.target(fetchMainUrl + ""/manage/count""); <line6> Response clientResponse = webResource.request(MediaType.APPLICATION_JSON).get(); <line7> String jsonString = clientResponse.readEntity(String.class); <line8> JSONParser parser = new JSONParser(); <line9> JSONObject jsonResponse = (JSONObject) parser.parse(jsonString); <line10> collectionCountSinceLastRestart = (Long) jsonResponse.get(""count""); <line11> } catch (Exception e) { <line12> logger.warn(""Error while fetching count"", e); <line13> } <line14> return collectionCountSinceLastRestart; <line15> } <line16> } <line17> "	"<line12>      logger.warn(""Error while fetching count"", e);"	task0	
"public class A { <line0> protected boolean objectExistsInRegistry(String pid) throws StorageDeviceException { <line1> logger.debug(""Checking if {} already exists"", pid); <line2> Connection conn = null; <line3> PreparedStatement s = null; <line4> ResultSet results = null; <line5> try { <line6> conn = m_connectionPool.getReadOnlyConnection(); <line7> s = conn.prepareStatement(REGISTERED_PID_QUERY); <line8> s.setString(1, pid); <line9> results = s.executeQuery(); <line10> return results.next(); <line11> } catch (SQLException sqle) { <line12> throw new StorageDeviceException( <line13> ""Unexpected error from SQL database: "" + sqle.getMessage(), sqle); <line14> } finally { <line15> try { <line16> if (results != null) { <line17> results.close(); <line18> } <line19> if (s != null) { <line20> s.close(); <line21> } <line22> if (conn != null) { <line23> m_connectionPool.free(conn); <line24> } <line25> } catch (SQLException sqle) { <line26> throw new StorageDeviceException( <line27> ""Unexpected error from SQL database: "" + sqle.getMessage(), sqle); <line28> } finally { <line29> results = null; <line30> s = null; <line31> } <line32> } <line33> } <line34> } <line35> "	"<line1>    logger.debug(""Checking if {} already exists"", pid);"	task0	
"public class A { <line0> public void logout(KeycloakDeployment deployment) { <line1> try { <line2> ServerRequest.invokeLogout(deployment, refreshToken); <line3> } catch (Exception e) { <line4> log.error(""failed to invoke remote logout"", e); <line5> } <line6> } <line7> } <line8> "	"<line4>      log.error(""failed to invoke remote logout"", e);"	task0	
"public class A { <line0> @POST(path = ""/backend/config/gauges/update"", permission = ""agent:config:edit:gauge"") <line1> String updateGauge(@BindAgentId String agentId, @BindRequest GaugeConfigDto gaugeConfigDto) <line2> throws Exception { <line3> GaugeConfig gaugeConfig = gaugeConfigDto.convert(); <line4> String version = gaugeConfigDto.version().get(); <line5> try { <line6> configRepository.updateGaugeConfig(agentId, gaugeConfig, version); <line7> } catch (DuplicateMBeanObjectNameException e) { <line8> logger.debug(e.getMessage(), e); <line9> throw new JsonServiceException(CONFLICT, ""mbeanObjectName""); <line10> } <line11> return getGaugeResponse(agentId, gaugeConfig); <line12> } <line13> } <line14> "	<line8>      logger.debug(e.getMessage(), e);	task0	
public class A { <line0> @Override <line1> public void backup(final Collection colection, final SAXSerializer serializer) { <line2> for (final Plug plugin : jacks.values()) { <line3> if (plugin instanceof BackupHandler) { <line4> try { <line5> ((BackupHandler) plugin).backup(colection, serializer); <line6> } catch (final Exception e) { <line7> LOG.error(e.getMessage(), e); <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	<line7>          LOG.error(e.getMessage(), e);	task0	
"public class A { <line0> @Override <line1> public void onSuccessfulConnection(Address address) { <line2> logger.info(""Successful connection: "" + address); <line3> } <line4> } <line5> "	"<line2>    logger.info(""Successful connection: "" + address);"	task0	
"public class A { <line0> public void addReasonerFactories(Set<ProtegeOWLReasonerPlugin> plugins) { <line1> for (ProtegeOWLReasonerPlugin plugin : plugins) { <line2> try { <line3> ProtegeOWLReasonerInfo factory = plugin.newInstance(); <line4> factory.initialise(); <line5> reasonerFactories.add(factory); <line6> } catch (Throwable t) { <line7> logger.warn( <line8> ""An error occurred whilst instantiating the '{}' reasoner.  Error: {}"", <line9> plugin.getName(), <line10> t); <line11> } <line12> } <line13> } <line14> } <line15> "	"<line7>        logger.warn(""An error occurred whilst instantiating the '{}' reasoner.  Error: {}"",plugin.getName(),t);"	task0	
"public class A { <line0> @Override <line1> public void visit(FilterModelChange change) { <line2> FilterModel model = change.getFilterModel(); <line3> Set<String> done = new HashSet<>(); <line4> if (change.getKind() == OpCode.ADD && model.isDynamic()) { <line5> for (OsgiContextModel ocm : change.getContextModels()) { <line6> String contextPath = ocm.getContextPath(); <line7> if (!done.add(contextPath)) { <line8> continue; <line9> } <line10> LOG.info(""Adding dynamic filter to context {}"", contextPath); <line11> OsgiContextModel highestRankedModel = null; <line12> for (OsgiContextModel cm : model.getContextModels()) { <line13> if (cm.getContextPath().equals(contextPath)) { <line14> highestRankedModel = cm; <line15> break; <line16> } <line17> } <line18> if (highestRankedModel == null) { <line19> highestRankedModel = ocm; <line20> } <line21> PaxWebServletContextHandler sch = contextHandlers.get(contextPath); <line22> OsgiServletContext context = osgiServletContexts.get(highestRankedModel); <line23> ServletHandler servletHandler = sch.getServletHandler(); <line24> List<PaxWebFilterMapping> mapping = configureFilterMappings(model); <line25> PaxWebFilterHolder holder = new PaxWebFilterHolder(model, context); <line26> for (PaxWebFilterMapping m : mapping) { <line27> servletHandler.addFilter(holder, m); <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	"<line10>        LOG.info(""Adding dynamic filter to context {}"", contextPath);"	task0	
"public class A { <line0> @Override <line1> public RepositoryCreationResponse createSCMRepository( <line2> String scmUrl, <line3> Boolean preBuildSyncEnabled, <line4> JobNotificationType jobType, <line5> Consumer<RepositoryCreated> consumer, <line6> Optional<BuildConfiguration> buildConfiguration) { <line7> log.trace( <line8> ""Received request to start RC creation with url autodetect: "" <line9> + scmUrl <line10> + "" (sync enabled? "" <line11> + preBuildSyncEnabled <line12> + "")""); <line13> if (StringUtils.isEmpty(scmUrl)) <line14> throw new InvalidEntityException(""You must specify the SCM URL.""); <line15> if (scmUrl.contains(config.getInternalScmAuthority())) { <line16> validateInternalRepository(scmUrl); <line17> validateRepositoryWithInternalURLDoesNotExist(scmUrl, null); <line18> SCMRepository scmRepository = createSCMRepositoryFromValues(null, scmUrl, false); <line19> consumer.accept(new RepositoryCreated(null, Integer.valueOf(scmRepository.getId()))); <line20> return new RepositoryCreationResponse(scmRepository); <line21> } else { <line22> validateRepositoryWithExternalURLDoesNotExist(scmUrl, null); <line23> boolean sync = preBuildSyncEnabled == null || preBuildSyncEnabled; <line24> Integer taskId = startRCreationTask(scmUrl, sync, jobType, consumer, buildConfiguration); <line25> return new RepositoryCreationResponse(taskId); <line26> } <line27> } <line28> } <line29> "	"<line7>    log.trace(""Received request to start RC creation with url autodetect: ""+ scmUrl+ "" (sync enabled? ""+ preBuildSyncEnabled+ "")"");"	task0	
public class A { <line0> @Override <line1> public void deletePortletFileEntry(long fileEntryId) throws PortalException { <line2> try { <line3> LocalRepository localRepository = <line4> _repositoryProvider.getFileEntryLocalRepository(fileEntryId); <line5> if (_isAttachment(localRepository.getFileEntry(fileEntryId))) { <line6> _run( <line7> FileEntry.class, <line8> () -> { <line9> localRepository.deleteFileEntry(fileEntryId); <line10> return null; <line11> }); <line12> } else { <line13> _run( <line14> () -> { <line15> localRepository.deleteFileEntry(fileEntryId); <line16> return null; <line17> }); <line18> } <line19> } catch (NoSuchFileEntryException noSuchFileEntryException) { <line20> if (log.isWarnEnabled()) { <line21> log.warn(noSuchFileEntryException, noSuchFileEntryException); <line22> } <line23> } <line24> } <line25> } <line26> 	<line21>        log.warn(noSuchFileEntryException, noSuchFileEntryException);	task0	
public class A { <line0> @Override <line1> public void logError(Throwable e) { <line2> ILogger logger = getLogger(); <line3> if (e instanceof PartitionStateVersionMismatchException) { <line4> if (logger.isFineEnabled()) { <line5> logger.fine(e.getMessage(), e); <line6> } else { <line7> logger.info(e.getMessage()); <line8> } <line9> return; <line10> } <line11> if (!nodeStartCompleted && e instanceof IllegalStateException) { <line12> logger.warning(e.getMessage()); <line13> if (logger.isFineEnabled()) { <line14> logger.fine(e); <line15> } <line16> return; <line17> } <line18> super.logError(e); <line19> } <line20> } <line21> 	<line7>        logger.info(e.getMessage());	task0	
"public class A { <line0> @Override <line1> protected void doPost( <line2> final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse) <line3> throws ServletException { <line4> try { <line5> if (Math.random() > 0.7d) { <line6> httpServletResponse.setStatus(404); <line7> httpServletResponse.getWriter().println(""The chaos monkey strikes again!""); <line8> httpServletResponse.flushBuffer(); <line9> } else if (Math.random() < 0.3d) { <line10> httpServletResponse.setStatus(401); <line11> httpServletResponse.getWriter().println(""The chaos monkey strikes again!""); <line12> httpServletResponse.flushBuffer(); <line13> } else { <line14> super.doPost(httpServletRequest, httpServletResponse); <line15> } <line16> } catch (IOException ioe) { <line17> log.debug(""Chaos Monkey ran into problem"", ioe); <line18> } <line19> } <line20> } <line21> "	"<line17>      log.debug(""Chaos Monkey ran into problem"", ioe);"	task0	
"public class A { <line0> @RequestMapping(value = Constants.WHITELIST_DELETE, method = RequestMethod.DELETE) <line1> public void deleteWhitelist(@PathVariable(value = ""id"") String id) { <line2> logger.info(""delete a whitelist.""); <line3> whitelistService.delete(Long.valueOf(id), GtasSecurityUtils.fetchLoggedInUserId()); <line4> } <line5> } <line6> "	"<line2>    logger.info(""delete a whitelist."");"	task0	
"public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final UserTO ignore) { <line2> model.setObject(restClient.read(model.getObject().getKey())); <line3> target.add( <line4> altDefaultModal.setContent( <line5> new AuditHistoryModal<UserTO>( <line6> altDefaultModal, <line7> AuditElements.EventCategoryType.LOGIC, <line8> ""UserLogic"", <line9> model.getObject(), <line10> IdRepoEntitlement.USER_UPDATE, <line11> pageRef) { <line12> private static final long serialVersionUID = 959378158400669867L; <line13>  <line14> @Override <line15> protected void restore(final String json, final AjaxRequestTarget target) { <line16> UserTO original = model.getObject(); <line17> try { <line18> UserTO updated = MAPPER.readValue(json, UserTO.class); <line19> UserUR updateReq = AnyOperations.diff(updated, original, false); <line20> updateReq.setPassword(null); <line21> updateReq.setSecurityAnswer(null); <line22> ProvisioningResult<UserTO> result = <line23> restClient.update(original.getETagValue(), updateReq); <line24> model.getObject().setLastChangeDate(result.getEntity().getLastChangeDate()); <line25> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line26> target.add(container); <line27> } catch (Exception e) { <line28> LOG.error(""While restoring user {}"", model.getObject().getKey(), e); <line29> SyncopeConsoleSession.get().onException(e); <line30> } <line31> ((BasePage) pageRef.getPage()).getNotificationPanel().refresh(target); <line32> } <line33> })); <line34> altDefaultModal.header( <line35> new Model<>( <line36> getString(""auditHistory.title"", new Model<>(new AnyWrapper<>(model.getObject()))))); <line37> altDefaultModal.show(true); <line38> } <line39> } <line40> "	"<line28>                  LOG.error(""While restoring user {}"", model.getObject().getKey(), e);"	task0	
"public class A { <line0> private void GetPercentageFromErrorStream(String input) { <line1> Matcher matcher; <line2> try { <line3> matcher = CACHE.get(PATTERN_FFMPEG).matcher(input); <line4> if (matcher.find()) { <line5> String dauer = matcher.group().trim(); <line6> String[] hms = dauer.split("":""); <line7> totalSecs = <line8> Integer.parseInt(hms[0]) * 3600 <line9> + Integer.parseInt(hms[1]) * 60 <line10> + Double.parseDouble(hms[2]); <line11> } <line12> matcher = CACHE.get(PATTERN_SIZE).matcher(input); <line13> if (matcher.find()) { <line14> String s = matcher.group().trim(); <line15> if (!s.isEmpty()) { <line16> try { <line17> final long aktSize = Integer.parseInt(StringUtils.replace(s, ""kB"", """")); <line18> mVFilmSize.setAktSize(aktSize * 1_000); <line19> long akt = start.startZeit.diffInSekunden(); <line20> if (oldSecs < akt - 5) { <line21> start.bandbreite = (aktSize - oldSize) * 1_000 / (akt - oldSecs); <line22> oldSecs = akt; <line23> oldSize = aktSize; <line24> } <line25> } catch (NumberFormatException ignored) { <line26> } <line27> } <line28> } <line29> matcher = CACHE.get(PATTERN_TIME).matcher(input); <line30> if (totalSecs > 0 && matcher.find()) { <line31> String zeit = matcher.group(); <line32> if (zeit.contains("":"")) { <line33> String[] hms = zeit.split("":""); <line34> final double aktSecs = <line35> Integer.parseInt(hms[0]) * 3600 <line36> + Integer.parseInt(hms[1]) * 60 <line37> + Double.parseDouble(hms[2]); <line38> double d = aktSecs / totalSecs * 100; <line39> meldenDouble(d); <line40> } else { <line41> double aktSecs = Double.parseDouble(zeit); <line42> double d = aktSecs / totalSecs * 100; <line43> meldenDouble(d); <line44> } <line45> } <line46> } catch (Exception ex) { <line47> MessageBus.getMessageBus().publishAsync(new DownloadProgressChangedEvent()); <line48> logger.error(""GetPercentageFromErrorStream(): {}"", input); <line49> } <line50> } <line51> } <line52> "	"<line48>      logger.error(""GetPercentageFromErrorStream(): {}"", input);"	task0	
"public class A { <line0> @Override <line1> public void onMessage(final Message message) { <line2> try { <line3> configureAuthentication(); <line4> updateService.updateDocumentElement((DocumentElement) ((ObjectMessage) message).getObject()); <line5> } catch (final JMSException e) { <line6> LOGGER.warn(""Error loading riksdagen document"", e); <line7> } finally { <line8> clearAuthentication(); <line9> } <line10> } <line11> } <line12> "	"<line6>      LOGGER.warn(""Error loading riksdagen document"", e);"	task0	
"public class A { <line0> private Map<String, List<String>> validationMessages(Set<ConstraintViolation<?>> failures) { <line1> Map<String, List<String>> mp = new HashMap<>(); <line2> for (ConstraintViolation<?> failure : failures) { <line3> logger.debug(failure.getPropertyPath().toString() + "": "" + failure.getMessage()); <line4> String property = failure.getPropertyPath().toString(); <line5> if (mp.containsKey(property)) { <line6> mp.get(failure.getPropertyPath().toString()).add(failure.getMessage()); <line7> } else { <line8> List<String> list = new ArrayList<>(); <line9> list.add(failure.getMessage()); <line10> mp.put(property, list); <line11> } <line12> } <line13> return mp; <line14> } <line15> } <line16> "	"<line3>      logger.debug(failure.getPropertyPath().toString() + "": "" + failure.getMessage());"	task0	
"public class A { <line0> @Override <line1> protected boolean generate(ByteBufferPool.Lease lease) { <line2> int dataRemaining = getDataBytesRemaining(); <line3> int sessionSendWindow = getSendWindow(); <line4> int streamSendWindow = stream.updateSendWindow(0); <line5> int window = Math.min(streamSendWindow, sessionSendWindow); <line6> if (window <= 0 && dataRemaining > 0) return false; <line7> int length = Math.min(dataRemaining, window); <line8> DataFrame dataFrame = (DataFrame) frame; <line9> int frameBytes = generator.data(lease, dataFrame, length); <line10> this.frameBytes += frameBytes; <line11> this.frameRemaining += frameBytes; <line12> int dataBytes = frameBytes - Frame.HEADER_LENGTH; <line13> this.dataBytes += dataBytes; <line14> this.dataRemaining -= dataBytes; <line15> if (LOG.isDebugEnabled()) <line16> LOG.debug( <line17> ""Generated {}, length/window/data={}/{}/{}"", dataFrame, dataBytes, window, dataRemaining); <line18> flowControl.onDataSending(stream, dataBytes); <line19> stream.updateClose(dataFrame.isEndStream(), CloseState.Event.BEFORE_SEND); <line20> return true; <line21> } <line22> } <line23> "	"<line16>      LOG.debug(""Generated {}, length/window/data={}/{}/{}"", dataFrame, dataBytes, window, dataRemaining);"	task0	
"public class A { <line0> private List<GluuSimplePerson> loadSourceServerEntries( <line1> CacheRefreshConfiguration cacheRefreshConfiguration, <line2> LdapServerConnection[] sourceServerConnections) <line3> throws SearchException { <line4> Filter customFilter = <line5> cacheRefreshService.createFilter(cacheRefreshConfiguration.getCustomLdapFilter()); <line6> String[] keyAttributes = getCompoundKeyAttributes(cacheRefreshConfiguration); <line7> String[] keyAttributesWithoutValues = <line8> getCompoundKeyAttributesWithoutValues(cacheRefreshConfiguration); <line9> String[] keyObjectClasses = getCompoundKeyObjectClasses(cacheRefreshConfiguration); <line10> String[] sourceAttributes = getSourceAttributes(cacheRefreshConfiguration); <line11> String[] twoLettersArray = createTwoLettersArray(); <line12> String[] returnAttributes = <line13> ArrayHelper.arrayMerge(keyAttributesWithoutValues, sourceAttributes); <line14> Set<String> addedDns = new HashSet<String>(); <line15> List<GluuSimplePerson> sourcePersons = new ArrayList<GluuSimplePerson>(); <line16> for (LdapServerConnection sourceServerConnection : sourceServerConnections) { <line17> String sourceServerName = sourceServerConnection.getSourceServerName(); <line18> PersistenceEntryManager sourcePersistenceEntryManager = <line19> sourceServerConnection.getPersistenceEntryManager(); <line20> String[] baseDns = sourceServerConnection.getBaseDns(); <line21> for (String keyAttributeStart : twoLettersArray) { <line22> Filter filter = <line23> cacheRefreshService.createFilter( <line24> keyAttributes, keyObjectClasses, keyAttributeStart, customFilter); <line25> if (log.isDebugEnabled()) { <line26> log.trace(""Using next filter to load entris from source server: {}"", filter); <line27> } <line28> for (String baseDn : baseDns) { <line29> List<GluuSimplePerson> currentSourcePersons = <line30> sourcePersistenceEntryManager.findEntries( <line31> baseDn, <line32> GluuSimplePerson.class, <line33> filter, <line34> SearchScope.SUB, <line35> returnAttributes, <line36> null, <line37> 0, <line38> 0, <line39> cacheRefreshConfiguration.getLdapSearchSizeLimit()); <line40> for (GluuSimplePerson currentSourcePerson : currentSourcePersons) { <line41> currentSourcePerson.setSourceServerName(sourceServerName); <line42> String currentSourcePersonDn = currentSourcePerson.getDn().toLowerCase(); <line43> if (!addedDns.contains(currentSourcePersonDn)) { <line44> sourcePersons.add(currentSourcePerson); <line45> addedDns.add(currentSourcePersonDn); <line46> } <line47> } <line48> } <line49> } <line50> } <line51> return sourcePersons; <line52> } <line53> } <line54> "	"<line26>          log.trace(""Using next filter to load entris from source server: {}"", filter);"	task0	
"public class A { <line0> @Override <line1> @SuppressFBWarnings(""BC_UNCONFIRMED_CAST_OF_RETURN_VALUE"") <line2> protected NetconfServerSession getSession( <line3> NetconfServerSessionListener sessionListener, Channel channel, NetconfHelloMessage message) { <line4> Optional<NetconfHelloMessageAdditionalHeader> additionalHeader = message.getAdditionalHeader(); <line5> NetconfHelloMessageAdditionalHeader parsedHeader; <line6> if (additionalHeader.isPresent()) { <line7> parsedHeader = additionalHeader.get(); <line8> } else { <line9> parsedHeader = <line10> new NetconfHelloMessageAdditionalHeader( <line11> UNKNOWN, <line12> getHostName(channel.localAddress()).getValue(), <line13> getHostName(channel.localAddress()).getKey(), <line14> ""tcp"", <line15> ""client""); <line16> } <line17> LOG.debug(""Additional header from hello parsed as {} from {}"", parsedHeader, additionalHeader); <line18> return new NetconfServerSession( <line19> sessionListener, channel, getSessionPreferences().getSessionId(), parsedHeader); <line20> } <line21> } <line22> "	"<line17>    LOG.debug(""Additional header from hello parsed as {} from {}"", parsedHeader, additionalHeader);"	task0	
"public class A { <line0> public JSONArray getDDMFormFieldTypesJSONArray() throws PortalException { <line1> List<DDMFormFieldType> availableDDMFormFieldTypes = <line2> _removeDDMFormFieldTypesOutOfScope(_ddmFormFieldTypeServicesTracker.getDDMFormFieldTypes()); <line3> String serializedFormFieldTypes = serialize(availableDDMFormFieldTypes); <line4> JSONArray jsonArray = jsonFactory.createJSONArray(serializedFormFieldTypes); <line5> HttpServletRequest httpServletRequest = formAdminRequestHelper.getRequest(); <line6> HttpServletResponse httpServletResponse = PortalUtil.getHttpServletResponse(renderResponse); <line7> for (int i = 0; i < jsonArray.length(); i++) { <line8> DDMFormFieldType ddmFormFieldType = availableDDMFormFieldTypes.get(i); <line9> JSONObject jsonObject = jsonArray.getJSONObject(i); <line10> Class<?> ddmFormFieldTypeSettings = ddmFormFieldType.getDDMFormFieldTypeSettings(); <line11> DDMForm ddmForm = DDMFormFactory.create(ddmFormFieldTypeSettings); <line12> DDMFormLayout ddmFormLayout = DDMFormLayoutFactory.create(ddmFormFieldTypeSettings); <line13> DDMFormRenderingContext ddmFormRenderingContext = new DDMFormRenderingContext(); <line14> ddmFormRenderingContext.setHttpServletRequest(httpServletRequest); <line15> ddmFormRenderingContext.setHttpServletResponse(httpServletResponse); <line16> ddmFormRenderingContext.setContainerId(""settings""); <line17> ddmFormRenderingContext.setLocale(LocaleUtil.fromLanguageId(getDefaultLanguageId())); <line18> ddmFormRenderingContext.setPortletNamespace(renderResponse.getNamespace()); <line19> ddmFormRenderingContext.setViewMode(true); <line20> try { <line21> Map<String, Object> ddmFormTemplateContext = <line22> _ddmFormTemplateContextFactory.create(ddmForm, ddmFormLayout, ddmFormRenderingContext); <line23> jsonObject.put( <line24> ""settingsContext"", <line25> jsonFactory.createJSONObject(jsonFactory.looseSerializeDeep(ddmFormTemplateContext))); <line26> ThemeDisplay themeDisplay = <line27> (ThemeDisplay) httpServletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line28> if ((themeDisplay != null) && StringUtil.equals(ddmFormFieldType.getName(), ""rich_text"")) { <line29> EditorConfiguration editorConfiguration = <line30> EditorConfigurationFactoryUtil.getEditorConfiguration( <line31> StringPool.BLANK, <line32> ddmFormFieldType.getName(), <line33> ""ckeditor_classic"", <line34> new HashMap<String, Object>(), <line35> themeDisplay, <line36> RequestBackedPortletURLFactoryUtil.create(httpServletRequest)); <line37> Map<String, Object> editorConfigurationData = editorConfiguration.getData(); <line38> jsonObject.put(""editorConfig"", editorConfigurationData.get(""editorConfig"")); <line39> } <line40> } catch (PortalException portalException) { <line41> log.error(portalException, portalException); <line42> } <line43> } <line44> return jsonArray; <line45> } <line46> } <line47> "	<line41>        log.error(portalException, portalException);	task0	
"public class A { <line0> public String getLimitClause() { <line1> String ret = limit == 0 ? """" : concat(LIMIT, limit.toString(), OFFSET, offset.toString()); <line2> LOGGER.debug(concat(""getLimitClause() returns: "", ret)); <line3> return ret; <line4> } <line5> } <line6> "	"<line2>    LOGGER.debug(concat(""getLimitClause() returns: "", ret));"	task0	
"public class A { <line0> @Override <line1> public void startTimedTask() { <line2> executorService.scheduleWithFixedDelay( <line3> () -> { <line4> try { <line5> syncAll(); <line6> } catch (Exception e) { <line7> logger.error(""Sync failed"", e); <line8> } <line9> }, <line10> SyncConstant.SYNC_PROCESS_DELAY, <line11> SyncConstant.SYNC_PROCESS_PERIOD, <line12> TimeUnit.SECONDS); <line13> } <line14> } <line15> "	"<line7>            logger.error(""Sync failed"", e);"	task0	
public class A { <line0> public static void deleteOrganization(long organizationId) throws RemoteException { <line1> try { <line2> OrganizationServiceUtil.deleteOrganization(organizationId); <line3> } catch (Exception exception) { <line4> log.error(exception, exception); <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	<line4>      log.error(exception, exception);	task0	
"public class A { <line0> public static String getSchema() { <line1> Connection conn = null; <line2> PreparedStatement pstmt = null; <line3> ResultSet resultSet = null; <line4> try { <line5> conn = dataSource.getConnection(); <line6> pstmt = conn.prepareStatement(""select current_schema()""); <line7> resultSet = pstmt.executeQuery(); <line8> while (resultSet.next()) { <line9> if (resultSet.isFirst()) { <line10> return resultSet.getString(1); <line11> } <line12> } <line13> } catch (SQLException e) { <line14> logger.error(e.getMessage(), e); <line15> } finally { <line16> ConnectionUtils.releaseResource(resultSet, pstmt, conn); <line17> } <line18> return """"; <line19> } <line20> } <line21> "	<line14>      logger.error(e.getMessage(), e);	task0	
"public class A { <line0> public void onProcessUnstructuredSSRequest(ProcessUnstructuredSSRequest procUnstrReqInd) { <line1> this.logger.debug(""onProcessUnstructuredSSRequest""); <line2> TestEvent te = <line3> TestEvent.createReceivedEvent( <line4> EventType.ProcessUnstructuredSSRequestIndication, procUnstrReqInd, sequence++); <line5> this.observerdEvents.add(te); <line6> } <line7> } <line8> "	"<line1>    this.logger.debug(""onProcessUnstructuredSSRequest"");"	task0	
"public class A { <line0> public UberfireRestResponse updateGroupPermissions( <line1> final String groupName, final UpdateSettingRequest permissionsRequest) { <line2> UberfireRestResponse response = new UberfireRestResponse(); <line3> try { <line4> Group group = groupManagerService.get(groupName); <line5> AuthorizationPolicy authzPolicy = permissionManager.getAuthorizationPolicy(); <line6> if (permissionsRequest.getHomePage() != null <line7> && permissionValidator.isValidResourceType( <line8> ActivityResourceType.PERSPECTIVE, permissionsRequest.getHomePage())) { <line9> authzPolicy.setHomePerspective(group, permissionsRequest.getHomePage()); <line10> } <line11> if (permissionsRequest.getPriority() != null) { <line12> authzPolicy.setPriority(group, permissionsRequest.getPriority()); <line13> } <line14> PermissionCollection pc = authzPolicy.getPermissions(group); <line15> generatePermissionCollection(pc, permissionsRequest); <line16> authzPolicy.setPermissions(group, pc); <line17> authorizationService.savePolicy(authzPolicy); <line18> response.setStatus(Response.Status.OK); <line19> response.setMessage(""Group "" + groupName + "" permissions are updated successfully.""); <line20> } catch (GroupNotFoundException e) { <line21> response.setStatus(Response.Status.BAD_REQUEST); <line22> response.setMessage(""Group with name "" + groupName + ""doesn't exists""); <line23> } catch (Exception e) { <line24> String errMsg = <line25> e.getClass().getSimpleName() <line26> + "" thrown when trying to update permissions for  '"" <line27> + groupName <line28> + ""': "" <line29> + e.getMessage(); <line30> logger.error(errMsg, e); <line31> response.setStatus(Response.Status.INTERNAL_SERVER_ERROR); <line32> response.setMessage(errMsg); <line33> } <line34> return response; <line35> } <line36> } <line37> "	<line30>      logger.error(errMsg, e);	task0	
"public class A { <line0> @Override <line1> public void exec(final Agent agent) throws IOException { <line2> final XML before = <line3> new StrictXML(Deck.UPGRADE.transform(new XMLDocument(new File(this.path))), Deck.SCHEMA); <line4> final XML after = new XMLDocument(new Xembler(agent.exec(before)).applyQuietly(before.node())); <line5> FileUtils.write( <line6> new File(this.path), new StrictXML(after, Deck.SCHEMA).toString(), CharEncoding.UTF_8); <line7> Logger.info( <line8> this, ""deck saved to %s (%d bytes):\n%s"", this.path, new File(this.path).length(), after); <line9> } <line10> } <line11> "	"<line7>    Logger.info(this, ""deck saved to %s (%d bytes):\n%s"", this.path, new File(this.path).length(), after);"	task0	
"public class A { <line0> public void setIdleTime(String idleTime) { <line1> log.warn( <line2> ""Parameter 'idleTime' is not supported anymore. "" <line3> + ""Please use 'maxIdleTime' in the repository configuration.""); <line4> this.idleTime = idleTime; <line5> } <line6> } <line7> "	"<line1>    log.warn(""Parameter 'idleTime' is not supported anymore. ""+ ""Please use 'maxIdleTime' in the repository configuration."");"	task0	
"public class A { <line0> @PostConstruct <line1> public void init() { <line2> logger = LoggerFactory.getLogger(getClass()); <line3> logger.debug(""initializing bean "" + getClass().getName()); <line4> attributes = <line5> Attributes.getComponentAttributesFromFacesConfig(UIDragIndicator.class, getClass()); <line6> attributes.setAttribute(""rendered"", true); <line7> } <line8> } <line9> "	"<line3>    logger.debug(""initializing bean "" + getClass().getName());"	task0	
"public class A { <line0> @RestAccessControl(permission = Permission.SUPERUSER) <line1> @RequestMapping( <line2> value = ""/directory"", <line3> method = RequestMethod.DELETE, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<RestResponse<Map, Map>> deleteDirectory( <line6> @RequestParam String currentPath, @RequestParam Boolean protectedFolder) { <line7> logger.debug(""delete directory {} - protected {}"", currentPath, protectedFolder); <line8> this.getFileBrowserService().deleteDirectory(currentPath, protectedFolder); <line9> return this.executeDirectoryRespose(currentPath, protectedFolder); <line10> } <line11> } <line12> "	"<line7>    logger.debug(""delete directory {} - protected {}"", currentPath, protectedFolder);"	task0	
"public class A { <line0> void put(Source<KeyValueSlice> source, long size) throws IOException, InterruptedException { <line1> long t0 = -1; <line2> if (LOG.isDebugEnabled()) { <line3> t0 = System.currentTimeMillis(); <line4> } <line5> File file = createTemporaryFile(); <line6> boolean success = false; <line7> try { <line8> try (DataOutputStream output = createBlockFileOutput(file)) { <line9> while (source.next()) { <line10> KeyValueSlice slice = source.get(); <line11> output.writeInt(slice.getKeyLength()); <line12> output.writeInt(slice.getValueLength()); <line13> output.write(slice.getBytes(), slice.getSliceOffset(), slice.getSliceLength()); <line14> } <line15> output.writeInt(-1); <line16> } <line17> files.add(file); <line18> success = true; <line19> } finally { <line20> if (success == false) { <line21> deleteTemporaryFile(file); <line22> } <line23> } <line24> if (LOG.isDebugEnabled()) { <line25> long t1 = System.currentTimeMillis(); <line26> LOG.debug( <line27> MessageFormat.format( <line28> ""saved block file: {0} (data={1}->{2}bytes, compress={3}, elapsed={4}ms)"", <line29> file, size, file.length(), compress, t1 - t0)); <line30> } <line31> totalSize += size; <line32> } <line33> } <line34> "	"<line26>      LOG.debug(MessageFormat.format(""saved block file: {0} (data={1}->{2}bytes, compress={3}, elapsed={4}ms)"",file, size, file.length(), compress, t1 - t0));"	task0	
"public class A { <line0> @Override <line1> public Collection<InputFile> next(SizeValidator validator) { <line2> int size = inputs.size(); <line3> if (size == 0) return Collections.EMPTY_SET; <line4> Collection<InputFile> list = new HashSet<>(); <line5> if (size < fc.getMaxFlags()) { <line6> list.addAll(inputs); <line7> inputs.clear(); <line8> } else { <line9> int count = 0; <line10> Iterator<InputFile> it = inputs.iterator(); <line11> while (it.hasNext() && (count < fc.getMaxFlags())) { <line12> InputFile inFile = it.next(); <line13> int maps = inFile.getMaps(); <line14> if (maps > fc.getMaxFlags()) { <line15> log.warn( <line16> ""Estimated map count ({}) for file exceeds maxFlags ({}). Consider increasing"" <line17> + "" maxFlags to accommodate larger files, or split this file into smaller chunks."" <line18> + "" File: {}"", <line19> maps, <line20> fc.getMaxFlags(), <line21> inFile.getFileName()); <line22> } <line23> count += maps; <line24> if (count > fc.getMaxFlags()) { <line25> break; <line26> } <line27> list.add(inFile); <line28> if (validator.isValidSize(fc, list) || (list.size() == 1)) { <line29> it.remove(); <line30> } else { <line31> list.remove(inFile); <line32> break; <line33> } <line34> } <line35> } <line36> return list; <line37> } <line38> } <line39> "	"<line15>          log.warn(""Estimated map count ({}) for file exceeds maxFlags ({}). Consider increasing""+ "" maxFlags to accommodate larger files, or split this file into smaller chunks.""+ "" File: {}"",maps,fc.getMaxFlags(),inFile.getFileName());"	task0	
"public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> ResponseList<Status> statuses = twitter.getRetweets(statusId); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.gotRetweets(statuses); <line6> } catch (Exception e) { <line7> logger.warn(""Exception at getRetweets"", e); <line8> } <line9> } <line10> } <line11> } <line12> "	"<line7>        logger.warn(""Exception at getRetweets"", e);"	task0	
"public class A { <line0> private void cancelRefreshJob() { <line1> synchronized (this) { <line2> if (refreshJob != null) { <line3> logger.debug(""Cancelling refresh job""); <line4> refreshJob.cancel(true); <line5> refreshJob = null; <line6> } <line7> } <line8> } <line9> } <line10> "	"<line3>        logger.debug(""Cancelling refresh job"");"	task0	
"public class A { <line0> @Override <line1> public void update(EventBean[] arg0, EventBean[] arg1) { <line2> for (EventBean bean : arg0) { <line3> try { <line4> beanForwardQueue.put(bean); <line5> } catch (InterruptedException e) { <line6> log.error(""Could not update due to '{}', exception '{}'"", e.getMessage(), e); <line7> return; <line8> } <line9> } <line10> } <line11> } <line12> "	"<line6>        log.error(""Could not update due to '{}', exception '{}'"", e.getMessage(), e);"	task0	
"public class A { <line0> protected final synchronized void enterState(final DestState current, final DestState next) <line1> throws IllegalStateException { <line2> verifyState(current); <line3> LOG.debug(""{}: entering state {}"", this, next); <line4> state = next; <line5> } <line6> } <line7> "	"<line3>    LOG.debug(""{}: entering state {}"", this, next);"	task0	
"public class A { <line0> private Class<?> determineExpectedClass(final Node node, final Class<?> fallbackType) { <line1> final NamedNodeMap attributes = node.getAttributes(); <line2> if (attributes != null) { <line3> final Node attribute = attributes.getNamedItem(""class""); <line4> if (attribute != null) { <line5> final String className = attribute.getTextContent(); <line6> if (!StringUtils.isNullOrEmpty(className)) { <line7> try { <line8> return Class.forName(className); <line9> } catch (final ClassNotFoundException e) { <line10> logger.error( <line11> ""Could not load class: "" + className + "". Falling back to String type."", e); <line12> } <line13> } <line14> } <line15> } <line16> return fallbackType; <line17> } <line18> } <line19> "	"<line10>            logger.error(""Could not load class: "" + className + "". Falling back to String type."", e);"	task0	
"public class A { <line0> private ListenableFuture<ResultSet> rollupOneFromChildren( <line1> int rollupLevel, <line2> String agentRollupId, <line3> String gaugeName, <line4> List<String> childAgentRollupIds, <line5> long captureTime, <line6> int adjustedTTL) <line7> throws Exception { <line8> List<ListenableFuture<ResultSet>> futures = new ArrayList<>(); <line9> for (String childAgentRollupId : childAgentRollupIds) { <line10> BoundStatement boundStatement = readValueForRollupFromChildPS.bind(); <line11> int i = 0; <line12> boundStatement.setString(i++, childAgentRollupId); <line13> boundStatement.setString(i++, gaugeName); <line14> boundStatement.setTimestamp(i++, new Date(captureTime)); <line15> futures.add(session.executeAsync(boundStatement)); <line16> } <line17> return Futures.transformAsync( <line18> Futures.allAsList(futures), <line19> new AsyncFunction<List<ResultSet>, ResultSet>() { <line20> @Override <line21> public ListenableFuture<ResultSet> apply(@Nullable List<ResultSet> results) <line22> throws Exception { <line23> checkNotNull(results); <line24> List<Row> rows = new ArrayList<>(); <line25> for (int i = 0; i < results.size(); i++) { <line26> Row row = results.get(i).one(); <line27> if (row == null) { <line28> logger.warn( <line29> ""no gauge value table records found for agentRollupId={},"" <line30> + "" gaugeName={}, captureTime={}, level={}"", <line31> childAgentRollupIds.get(i), <line32> gaugeName, <line33> captureTime, <line34> rollupLevel); <line35> } else { <line36> rows.add(row); <line37> } <line38> } <line39> if (rows.isEmpty()) { <line40> return Futures.immediateFuture(DummyResultSet.INSTANCE); <line41> } <line42> return rollupOneFromRows( <line43> rollupLevel, agentRollupId, gaugeName, captureTime, adjustedTTL, rows); <line44> } <line45> }, <line46> MoreExecutors.directExecutor()); <line47> } <line48> } <line49> "	"<line28>                logger.warn(""no gauge value table records found for agentRollupId={},""+ "" gaugeName={}, captureTime={}, level={}"",childAgentRollupIds.get(i),gaugeName,captureTime,rollupLevel);"	task0	
"public class A { <line0> public Map<String, Class> mapAllClasses(String uri) throws IOException, ClassNotFoundException { <line1> Map<String, String> map = mapAllStrings(uri); <line2> Map<String, Class> classes = new HashMap<>(map != null ? map.size() : 0); <line3> if (map == null) { <line4> LOG.trace(""Null strings map for [{}], should not be possible!"", uri); <line5> throw new IllegalStateException(""Null strings map produced for uri: "" + uri); <line6> } <line7> for (Map.Entry<String, String> entry : map.entrySet()) { <line8> String string = entry.getKey(); <line9> String className = entry.getValue(); <line10> Class clazz = classLoaderInterface.loadClass(className); <line11> classes.put(string, clazz); <line12> } <line13> return classes; <line14> } <line15> } <line16> "	"<line4>      LOG.trace(""Null strings map for [{}], should not be possible!"", uri);"	task0	
public class A { <line0> @Override <line1> public void warn(Object msg) { <line2> try { <line3> log.warn(msg); <line4> } catch (Exception exception) { <line5> printMsg(msg); <line6> } <line7> } <line8> } <line9> 	<line3>      log.warn(msg);	task0	
"public class A { <line0> @RequestMapping( <line1> value = ""/getAllCrisisTypes.action"", <line2> method = {RequestMethod.GET}) <line3> @ResponseBody <line4> public Map<String, Object> getAllCrisis() { <line5> try { <line6> return getUIWrapper(taggerService.getAllCrisisTypes(), true); <line7> } catch (AidrException e) { <line8> logger.error(""Error while fetching all crisisTypes"", e); <line9> return getUIWrapper(false, e.getMessage()); <line10> } <line11> } <line12> } <line13> "	"<line8>      logger.error(""Error while fetching all crisisTypes"", e);"	task0	
"public class A { <line0> @Override <line1> public void visitValue(PValue value, TransformHierarchy.Node producer) { <line2> if (!isStreaming) { <line3> if (value instanceof PCollection <line4> && ((PCollection) value).isBounded() == PCollection.IsBounded.UNBOUNDED) { <line5> LOG.info( <line6> ""Found unbounded PCollection {}. Switching to streaming execution."", value.getName()); <line7> isStreaming = true; <line8> } <line9> } <line10> } <line11> } <line12> "	"<line5>        LOG.info(""Found unbounded PCollection {}. Switching to streaming execution."", value.getName());"	task0	
"public class A { <line0> private TChannelMessage decodeCallFrame(ChannelHandlerContext ctx, CallFrame frame) { <line1> ArgScheme scheme; <line2> if (frame.getType() == FrameType.CallRequest) { <line3> scheme = <line4> ArgScheme.toScheme( <line5> ((CallRequestFrame) frame).getHeaders().get(TransportHeaders.ARG_SCHEME_KEY)); <line6> } else { <line7> scheme = <line8> ArgScheme.toScheme( <line9> ((CallResponseFrame) frame).getHeaders().get(TransportHeaders.ARG_SCHEME_KEY)); <line10> } <line11> if (!ArgScheme.isSupported(scheme)) { <line12> if (frame.getType() == FrameType.CallRequest) { <line13> sendError( <line14> ErrorType.BadRequest, ""Arg Scheme not specified or unsupported"", frame.getId(), ctx); <line15> } else { <line16> logger.error(""Arg Scheme not specified or unsupported: {}"", scheme); <line17> } <line18> return null; <line19> } <line20> List<CallFrame> frames = new ArrayList<>(); <line21> frames.add(frame); <line22> frame.retain(); <line23> final TChannelMessage result; <line24> boolean release = true; <line25> try { <line26> if (!hasMore(frame)) { <line27> result = MessageCodec.decodeCallFrames(frames); <line28> } else { <line29> callFrames.put(frame.getId(), frames); <line30> result = null; <line31> } <line32> release = false; <line33> } finally { <line34> if (release) { <line35> frame.release(); <line36> } <line37> } <line38> if (result != null) { <line39> result.touch(""finished MessageDefragmenter.decodeCallFrame""); <line40> } <line41> return result; <line42> } <line43> } <line44> "	"<line16>        logger.error(""Arg Scheme not specified or unsupported: {}"", scheme);"	task0	
"public class A { <line0> @Test(groups = {""TestScaleService""}) <line1> public void testFindSwapDisk() { <line2> logger.info(""test findSwapDisk""); <line3> DiskEntity swapDisk = scaleService.findSwapDisk(nodeEntity); <line4> Assert.assertTrue( <line5> swapDisk.getName() == SWAP_DISK_NAME, ""swap disk should be "" + SWAP_DISK_NAME); <line6> } <line7> } <line8> "	"<line2>    logger.info(""test findSwapDisk"");"	task0	
"public class A { <line0> public static InetAddress getLocalHost(Properties props) { <line1> String addr = props.getProperty(""jcifs.smb.client.laddr""); <line2> if (addr != null) { <line3> try { <line4> return InetAddress.getByName(addr); <line5> } catch (UnknownHostException uhe) { <line6> log.error(""Ignoring jcifs.smb.client.laddr address: "" + addr, uhe); <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> "	"<line6>        log.error(""Ignoring jcifs.smb.client.laddr address: "" + addr, uhe);"	task0	
"public class A { <line0> public boolean awaitTermination(long timeout, @NotNull TimeUnit unit) <line1> throws InterruptedException { <line2> if (!executor.isShutdown()) <line3> throw new IllegalStateException( <line4> String.format(""AsyncProcessor{%s} hasn't been shut down yet"", name)); <line5> if (executor.awaitTermination(timeout, unit)) { <line6> LOGGER.trace(""AsyncProcessor{{}} is shut down"", name); <line7> return true; <line8> } else { <line9> return false; <line10> } <line11> } <line12> } <line13> "	"<line6>      LOGGER.trace(""AsyncProcessor{{}} is shut down"", name);"	task0	
"public class A { <line0> public void setGiverRelationship(com.secretpal.model.SPPerson value) { <line1> if (_SPSecretPal.LOG.isDebugEnabled()) { <line2> _SPSecretPal.LOG.debug(""updating giver from "" + giver() + "" to "" + value); <line3> } <line4> if (er.extensions.eof.ERXGenericRecord.InverseRelationshipUpdater <line5> .updateInverseRelationships()) { <line6> setGiver(value); <line7> } else if (value == null) { <line8> com.secretpal.model.SPPerson oldValue = giver(); <line9> if (oldValue != null) { <line10> removeObjectFromBothSidesOfRelationshipWithKey(oldValue, _SPSecretPal.GIVER_KEY); <line11> } <line12> } else { <line13> addObjectToBothSidesOfRelationshipWithKey(value, _SPSecretPal.GIVER_KEY); <line14> } <line15> } <line16> } <line17> "	"<line2>      _SPSecretPal.LOG.debug(""updating giver from "" + giver() + "" to "" + value);"	task0	
"public class A { <line0> @Override <line1> public void refresh() { <line2> try { <line3> TokenRefreshResponse refreshResponse = tokenRefresher.getNewToken(refreshToken); <line4> if (refreshResponse == null) { <line5> throw new InvalidOauthTokenException(); <line6> } <line7> apiToken = refreshResponse.getAccessToken(); <line8> tokenExpiration = new TokenExpiration(refreshResponse.getExpiresIn()); <line9> } catch (IOException e) { <line10> LOG.error(""Exception while attempting to refresh access token""); <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> "	"<line10>      LOG.error(""Exception while attempting to refresh access token"");"	task0	
"public class A { <line0> private void handleLinkButtonNotPressed(LinkButtonException ex) { <line1> logger.debug(""Failed creating new user on Hue bridge: {}"", ex.getMessage()); <line2> updateStatus( <line3> ThingStatus.OFFLINE, <line4> ThingStatusDetail.CONFIGURATION_ERROR, <line5> ""@text/offline.conf-error-press-pairing-button""); <line6> } <line7> } <line8> "	"<line1>    logger.debug(""Failed creating new user on Hue bridge: {}"", ex.getMessage());"	task0	
"public class A { <line0> public static void tryDeleteFile(@Nullable File file) { <line1> if (file != null) { <line2> if (!file.delete()) { <line3> log.warn(""unable to remove file {}, marked for delete on exit"", file.getAbsolutePath()); <line4> file.deleteOnExit(); <line5> } <line6> } <line7> } <line8> } <line9> "	"<line3>        log.warn(""unable to remove file {}, marked for delete on exit"", file.getAbsolutePath());"	task0	
"public class A { <line0> private static Value min(Value value) { <line1> if (value.type == ValueType.LIST) { <line2> Value min = null; <line3> for (Value v : value.getList()) { <line4> if (min == null) { <line5> min = v; <line6> } else if (min.type.canBeLong() && v.type.canBeLong()) { <line7> min = min.getLong() <= v.getLong() ? min : v; <line8> } else if (min.type.canBeDouble() && v.type.canBeDouble()) { <line9> min = min.getDouble() <= v.getDouble() ? min : v; <line10> } else { <line11> throw new IllegalArgumentException(""min("" + value + "")""); <line12> } <line13> } <line14> if (min == null) { <line15> throw new IllegalArgumentException(""min of 0 values""); <line16> } <line17> return min; <line18> } else { <line19> log.warn(""Computing min from single value""); <line20> return value; <line21> } <line22> } <line23> } <line24> "	"<line19>      log.warn(""Computing min from single value"");"	task0	
"public class A { <line0> public static com.liferay.layout.page.template.model.LayoutPageTemplateCollection <line1> addLayoutPageTemplateCollection( <line2> HttpPrincipal httpPrincipal, <line3> long groupId, <line4> String name, <line5> String description, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> LayoutPageTemplateCollectionServiceUtil.class, <line12> ""addLayoutPageTemplateCollection"", <line13> _addLayoutPageTemplateCollectionParameterTypes0); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, name, description, serviceContext); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.layout.page.template.model.LayoutPageTemplateCollection) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> log.error(systemException, systemException); <line28> throw systemException; <line29> } <line30> } <line31> } <line32> "	<line27>      log.error(systemException, systemException);	task0	
"public class A { <line0> protected <T> T deserialize(String content, Class<T> type) { <line1> logger.debug(""About to deserialize content: \n '{}' \n into type: '{}'"", content, type); <line2> if (content == null || content.isEmpty()) { <line3> return null; <line4> } <line5> try { <line6> return marshaller.unmarshall(content, type); <line7> } catch (MarshallingException e) { <line8> throw new KieServicesException(""Error while deserializing data received from server!"", e); <line9> } <line10> } <line11> } <line12> "	"<line1>    logger.debug(""About to deserialize content: \n '{}' \n into type: '{}'"", content, type);"	task0	
"public class A { <line0> public void doServeResource( <line1> PortletWindow portletWindow, HttpServletRequest request, HttpServletResponse response) <line2> throws PortletException, IOException, PortletContainerException { <line3> ensureInitialized(); <line4> debugWithName( <line5> ""Resource request received for portlet: "" <line6> + portletWindow.getPortletDefinition().getPortletName()); <line7> PortletRequestContextService rcService = <line8> getContainerServices().getPortletRequestContextService(); <line9> PortletEnvironmentService envService = getContainerServices().getPortletEnvironmentService(); <line10> PortletInvokerService invoker = getContainerServices().getPortletInvokerService(); <line11> PortletResourceRequestContext requestContext = <line12> rcService.getPortletResourceRequestContext(this, request, response, portletWindow); <line13> PortletResourceResponseContext responseContext = <line14> rcService.getPortletResourceResponseContext( <line15> this, request, response, portletWindow, requestContext); <line16> responseContext.setPropsAllowed(true); <line17> ResourceRequest portletRequest = <line18> envService.createResourceRequest(requestContext, responseContext); <line19> ResourceResponse portletResponse = <line20> envService.createResourceResponse(responseContext, requestContext.getCacheability()); <line21> requestContext.setResponse(portletResponse); <line22> FilterManager filterManager = <line23> filterInitialisation(portletWindow, PortletRequest.RESOURCE_PHASE); <line24> try { <line25> invoker.serveResource(requestContext, portletRequest, portletResponse, filterManager); <line26> } finally { <line27> if (!request.isAsyncSupported() || !request.isAsyncStarted()) { <line28> responseContext.close(); <line29> responseContext.release(); <line30> } else { <line31> LOG.debug(""Async started for resource request. responseContext not released.""); <line32> } <line33> } <line34> debugWithName( <line35> ""Portlet resource done for: "" + portletWindow.getPortletDefinition().getPortletName()); <line36> } <line37> } <line38> "	"<line31>        LOG.debug(""Async started for resource request. responseContext not released."");"	task0	
public class A { <line0> public static com.liferay.push.notifications.model.PushNotificationsDeviceSoap <line1> deletePushNotificationsDevice(String token) throws RemoteException { <line2> try { <line3> com.liferay.push.notifications.model.PushNotificationsDevice returnValue = <line4> PushNotificationsDeviceServiceUtil.deletePushNotificationsDevice(token); <line5> return com.liferay.push.notifications.model.PushNotificationsDeviceSoap.toSoapModel( <line6> returnValue); <line7> } catch (Exception exception) { <line8> log.error(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line8>      log.error(exception, exception);	task0	
"public class A { <line0> @Test <line1> public void testCounty() throws Exception { <line2> log.info(""------  testCounty  ------""); <line3> String county = ""'clackamas'""; <line4> String query = GroupedNormalField.LARGE_COUNTIES.name() + EQ_OP + county; <line5> runTest(query, query); <line6> } <line7> } <line8> "	"<line2>    log.info(""------  testCounty  ------"");"	task0	
"public class A { <line0> public String toString( <line1> String tabs, double thresholdEntropy, double thresholdP, int thresholdCount) { <line2> if (getTotalCount() == 0) return """"; <line3> StringBuilder sb = new StringBuilder(); <line4> double p[] = p(); <line5> for (int idx = 0; idx < 4; idx++) { <line6> char base = BASES[idx]; <line7> AcgtTree n = nodes[idx]; <line8> if (n != null) { <line9> sb.append( <line10> String.format( <line11> ""%s%s%s: %d\te:%4.3f\tp:%4.2f\n"", <line12> tabs, name, base, counts[idx], n.entropy(), p[idx])); <line13> if (((n.entropy() <= thresholdEntropy) || (p[idx] >= thresholdP)) <line14> && (counts[idx] >= thresholdCount)) { <line15> Log.debug( <line16> ""Name:"" <line17> + n.name <line18> + ""\tIdx:"" <line19> + +idx <line20> + ""\tEntropy: "" <line21> + n.entropy() <line22> + ""\tP:"" <line23> + p[idx] <line24> + ""\tCount:"" <line25> + counts[idx]); <line26> sb.append(n.toString(tabs + ""\t"", thresholdEntropy, thresholdP, thresholdCount)); <line27> } <line28> } <line29> } <line30> return sb.toString(); <line31> } <line32> } <line33> "	"<line15>          Log.debug(""Name:""+ n.name+ ""\tIdx:""+ +idx+ ""\tEntropy: ""+ n.entropy()+ ""\tP:""+ p[idx]+ ""\tCount:""+ counts[idx]);"	task0	
"public class A { <line0> @Override <line1> public void start() { <line2> try { <line3> Class.forName(this.dbConsumerConfiguration.getDriver()); <line4> connection = <line5> DriverManager.getConnection( <line6> this.dbConsumerConfiguration.getUrl(), <line7> this.dbConsumerConfiguration.getUsername(), <line8> this.dbConsumerConfiguration.getPassword()); <line9> logger.info(""  - Started embedded managed component [DbMessageProvider]""); <line10> } catch (Exception e) { <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> "	"<line9>      logger.info(""  - Started embedded managed component [DbMessageProvider]"");"	task0	
"public class A { <line0> public static Integer getNullLabelID(int attributeID) { <line1> String sql = <line2> ""select nominalLabelID from nominal_label where nominalAttributeID="" <line3> + attributeID <line4> + "" and nominalLabelCode='null'""; <line5> Connection conn = null; <line6> PreparedStatement query = null; <line7> ResultSet result = null; <line8> try { <line9> conn = getMySqlConnection(); <line10> query = conn.prepareStatement(sql); <line11> result = query.executeQuery(); <line12> if (result.next()) { <line13> return result.getInt(1); <line14> } <line15> } catch (SQLException ex) { <line16> logger.error(""Error in executing SQL statement: "" + sql, ex); <line17> } finally { <line18> close(result); <line19> close(query); <line20> close(conn); <line21> } <line22> return null; <line23> } <line24> } <line25> "	"<line16>      logger.error(""Error in executing SQL statement: "" + sql, ex);"	task0	
"public class A { <line0> @Override <line1> public Void call(Object arg) throws Exception { <line2> logger.info(""Shutdown of asynchbase client complete.""); <line3> return null; <line4> } <line5> } <line6> "	"<line2>    logger.info(""Shutdown of asynchbase client complete."");"	task0	
"public class A { <line0> private void jsonError(String message) { <line1> setResponse(""{\""error\"":\"""" + message + ""\""}""); <line2> LOG.debug(""Error message return from RPC call: {}"", message); <line3> } <line4> } <line5> "	"<line2>    LOG.debug(""Error message return from RPC call: {}"", message);"	task0	
"public class A { <line0> private CredentialsProvider determineCredentialsProvider() { <line1> final CredentialsProvider provider = innerBuilder.getCredentialsProvider(); <line2> if (provider == null) { <line3> ensureNotNull(""cluster id"", clusterId); <line4> ensureNotNull(""client id"", clientId); <line5> ensureNotNull(""client secret"", clientSecret); <line6> final OAuthCredentialsProviderBuilder builder = new OAuthCredentialsProviderBuilder(); <line7> return builder <line8> .audience(String.format(""%s.%s"", clusterId, BASE_ADDRESS)) <line9> .clientId(clientId) <line10> .clientSecret(clientSecret) <line11> .authorizationServerUrl(BASE_AUTH_URL) <line12> .build(); <line13> } else { <line14> Loggers.LOGGER.debug( <line15> ""Expected to use 'cluster id', 'client id' and 'client secret' to set credentials"" <line16> + "" provider in the client cloud builder, but overwriting with explicitly defined"" <line17> + "" credentials provider.""); <line18> return provider; <line19> } <line20> } <line21> } <line22> "	"<line14>      Loggers.LOGGER.debug(""Expected to use 'cluster id', 'client id' and 'client secret' to set credentials""+ "" provider in the client cloud builder, but overwriting with explicitly defined""+ "" credentials provider."");"	task0	
public class A { <line0> @Override <line1> public LayoutPageTemplateStructure remove(Serializable primaryKey) <line2> throws NoSuchPageTemplateStructureException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> LayoutPageTemplateStructure layoutPageTemplateStructure = <line7> (LayoutPageTemplateStructure) <line8> session.get(LayoutPageTemplateStructureImpl.class, primaryKey); <line9> if (layoutPageTemplateStructure == null) { <line10> if (log.isDebugEnabled()) { <line11> log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line12> } <line13> throw new NoSuchPageTemplateStructureException( <line14> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line15> } <line16> return remove(layoutPageTemplateStructure); <line17> } catch (NoSuchPageTemplateStructureException noSuchEntityException) { <line18> throw noSuchEntityException; <line19> } catch (Exception exception) { <line20> throw processException(exception); <line21> } finally { <line22> closeSession(session); <line23> } <line24> } <line25> } <line26> 	<line11>          log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey);	task0	
"public class A { <line0> public static PubsubSubscription fromPath(String path) { <line1> if (path.startsWith(SUBSCRIPTION_RANDOM_TEST_PREFIX) <line2> || path.startsWith(SUBSCRIPTION_STARTING_SIGNAL)) { <line3> return new PubsubSubscription(Type.FAKE, """", path); <line4> } <line5> String projectName, subscriptionName; <line6> Matcher v1beta1Match = V1BETA1_SUBSCRIPTION_REGEXP.matcher(path); <line7> if (v1beta1Match.matches()) { <line8> LOG.warn( <line9> ""Saw subscription in v1beta1 format. Subscriptions should be in the format "" <line10> + ""projects/<project_id>/subscriptions/<subscription_name>""); <line11> projectName = v1beta1Match.group(1); <line12> subscriptionName = v1beta1Match.group(2); <line13> } else { <line14> Matcher match = SUBSCRIPTION_REGEXP.matcher(path); <line15> if (!match.matches()) { <line16> throw new IllegalArgumentException( <line17> ""Pubsub subscription is not in "" <line18> + ""projects/<project_id>/subscriptions/<subscription_name> format: "" <line19> + path); <line20> } <line21> projectName = match.group(1); <line22> subscriptionName = match.group(2); <line23> } <line24> validateProjectName(projectName); <line25> validatePubsubName(subscriptionName); <line26> return new PubsubSubscription(Type.NORMAL, projectName, subscriptionName); <line27> } <line28> } <line29> "	"<line8>      LOG.warn(""Saw subscription in v1beta1 format. Subscriptions should be in the format ""+ ""projects/<project_id>/subscriptions/<subscription_name>"");"	task0	
"public class A { <line0> public void shutdown() { <line1> for (int i = 0; i < numberOfPartition; i++) { <line2> executors.get(i).shutdown(); <line3> } <line4> try { <line5> for (int i = 0; i < numberOfPartition; i++) { <line6> executors.get(i).awaitTermination(threadTerminationMaxTime, TimeUnit.NANOSECONDS); <line7> } <line8> } catch (InterruptedException e) { <line9> LOGGER.error(""Error while stopping bootstrap consumer"", e); <line10> } <line11> } <line12> } <line13> "	"<line9>      LOGGER.error(""Error while stopping bootstrap consumer"", e);"	task0	
"public class A { <line0> @Override <line1> public void opening(String table, String shard, BlurIndex index) { <line2> Map<String, String> properties = _configuration.getProperties(); <line3> for (Entry<String, String> entry : properties.entrySet()) { <line4> if (isFilterAlias(entry.getKey())) { <line5> String value = entry.getValue(); <line6> if (value == null || value.isEmpty()) { <line7> continue; <line8> } <line9> String filterAlias = getFilterAlias(entry.getKey()); <line10> String filterQuery = value; <line11> Map<String, String> map = getThisTablesMap(table); <line12> LOG.info( <line13> ""Loading filter alias [{0}] with query [{1}] for table [{2}]"", <line14> filterAlias, filterQuery, table); <line15> map.put(filterAlias, filterQuery); <line16> } <line17> } <line18> } <line19> } <line20> "	"<line12>        LOG.info(""Loading filter alias [{0}] with query [{1}] for table [{2}]"",filterAlias, filterQuery, table);"	task0	
"public class A { <line0> public void activate(BeanManager bm) { <line1> for (Class<?> c : class2Anno.keySet()) { <line2> sortedAnnotatedClassNames.add(c.getCanonicalName()); <line3> } <line4> Collections.sort(sortedAnnotatedClassNames); <line5> for (Class<?> cls : class2Anno.keySet()) { <line6> Set<Bean<?>> beans = bm.getBeans(cls); <line7> Bean<?> bean = bm.resolve(beans); <line8> assert bean != null; <line9> context2Anno.put(bean, class2Anno.get(cls)); <line10> } <line11> if (isTrace) { <line12> StringBuilder txt = new StringBuilder(128); <line13> txt.append(""RedirectScopedBeanHolder configuration.""); <line14> txt.append("" Annotated Beans: ""); <line15> txt.append(getConfigAsString()); <line16> LOG.debug(txt.toString()); <line17> } <line18> } <line19> } <line20> "	<line16>      LOG.debug(txt.toString());	task0	
"public class A { <line0> private void processUndeployRequest(UUID nodeId, GridDeploymentRequest req) { <line1> if (log.isDebugEnabled()) <line2> log.debug(""Received undeploy request [nodeId="" + nodeId + "", req="" + req + ']'); <line3> ctx.deploy().undeployTask(nodeId, req.resourceName()); <line4> } <line5> } <line6> "	"<line2>      log.debug(""Received undeploy request [nodeId="" + nodeId + "", req="" + req + ']');"	task0	
"public class A { <line0> public void add( <line1> Integer columnIndex, Object columnValue, Long columnCount, StructField columnField) { <line2> StandardColumnStatistics newColumnStatistics; <line3> if (!columnStatisticsMap.containsKey(columnIndex)) { <line4> DataType columnDataType = columnField.dataType(); <line5> switch (columnDataType.simpleString()) { <line6> case ""tinyint"": <line7> newColumnStatistics = new ByteColumnStatistics(columnField, profilerConfiguration); <line8> break; <line9> case ""smallint"": <line10> newColumnStatistics = new ShortColumnStatistics(columnField, profilerConfiguration); <line11> break; <line12> case ""int"": <line13> newColumnStatistics = new IntegerColumnStatistics(columnField, profilerConfiguration); <line14> break; <line15> case ""bigint"": <line16> newColumnStatistics = new LongColumnStatistics(columnField, profilerConfiguration); <line17> break; <line18> case ""float"": <line19> newColumnStatistics = new FloatColumnStatistics(columnField, profilerConfiguration); <line20> break; <line21> case ""double"": <line22> newColumnStatistics = new DoubleColumnStatistics(columnField, profilerConfiguration); <line23> break; <line24> case ""string"": <line25> newColumnStatistics = new StringColumnStatistics(columnField, profilerConfiguration); <line26> break; <line27> case ""boolean"": <line28> newColumnStatistics = new BooleanColumnStatistics(columnField, profilerConfiguration); <line29> break; <line30> case ""date"": <line31> newColumnStatistics = new DateColumnStatistics(columnField, profilerConfiguration); <line32> break; <line33> case ""timestamp"": <line34> newColumnStatistics = new TimestampColumnStatistics(columnField, profilerConfiguration); <line35> break; <line36> default: <line37> String decimalTypeRegex = ""decimal\\S+""; <line38> if (columnDataType.simpleString().matches(decimalTypeRegex)) { <line39> newColumnStatistics = <line40> new BigDecimalColumnStatistics(columnField, profilerConfiguration); <line41> } else { <line42> if (log.isWarnEnabled()) { <line43> log.warn(""[PROFILER-INFO] Unsupported data type: {}"", columnDataType.simpleString()); <line44> } <line45> newColumnStatistics = <line46> new UnsupportedColumnStatistics(columnField, profilerConfiguration); <line47> } <line48> } <line49> columnStatisticsMap.put(columnIndex, newColumnStatistics); <line50> } <line51> StandardColumnStatistics currentColumnStatistics = columnStatisticsMap.get(columnIndex); <line52> currentColumnStatistics.accomodate(columnValue, columnCount); <line53> } <line54> } <line55> "	"<line43>              log.warn(""[PROFILER-INFO] Unsupported data type: {}"", columnDataType.simpleString());"	task0	
"public class A { <line0> @Override <line1> public void basicBridgeInvalidate( <line2> Object key, <line3> Object p_callbackArg, <line4> ClientProxyMembershipID memberId, <line5> boolean fromClient, <line6> EntryEventImpl clientEvent) <line7> throws TimeoutException, EntryNotFoundException, CacheWriterException { <line8> Lock lock = getDistributedLockIfGlobal(key); <line9> try { <line10> super.basicBridgeInvalidate(key, p_callbackArg, memberId, fromClient, clientEvent); <line11> } finally { <line12> if (lock != null) { <line13> logger.debug(""releasing distributed lock on {}"", key); <line14> lock.unlock(); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line13>        logger.debug(""releasing distributed lock on {}"", key);"	task0	
"public class A { <line0> public void setDescription(String description) { <line1> if (LOG.isDebugEnabled()) LOG.debug(""{} is {}"", this, description); <line2> } <line3> } <line4> "	"<line1>    if (LOG.isDebugEnabled()) LOG.debug(""{} is {}"", this, description);"	task0	
"public class A { <line0> @Transactional(propagation = Propagation.NOT_SUPPORTED) <line1> @Override <line2> public void markAsDeleted(final O obj) throws AccessException { <line3> Validate.notNull(obj); <line4> if (obj.getId() == null) { <line5> final String msg = ""Could not delete object unless id is not given:"" + obj.toString(); <line6> log.error(msg); <line7> throw new RuntimeException(msg); <line8> } <line9> accessChecker.checkRestrictedOrDemoUser(); <line10> final O dbObj = em.find(clazz, obj.getId()); <line11> checkLoggedInUserDeleteAccess(obj, dbObj); <line12> internalMarkAsDeleted(obj); <line13> } <line14> } <line15> "	<line6>      log.error(msg);	task0	
"public class A { <line0> public static void createWithParents(ZooKeeper zk, String node, byte[] data) <line1> throws KeeperException { <line2> try { <line3> if (node == null) { <line4> return; <line5> } <line6> zk.create(node, data, createACL(zk, node), CreateMode.PERSISTENT); <line7> } catch (KeeperException.NodeExistsException nee) { <line8> return; <line9> } catch (KeeperException.NoNodeException nne) { <line10> createWithParents(zk, getParent(node)); <line11> createWithParents(zk, node, data); <line12> } catch (InterruptedException ie) { <line13> LOG.warn(""Fail to create node: "" + node, ie); <line14> } <line15> } <line16> } <line17> "	"<line13>      LOG.warn(""Fail to create node: "" + node, ie);"	task0	
"public class A { <line0> public void startup() { <line1> log.info(""Start producer manager""); <line2> transientProducerScheduler.start(); <line3> for (CloudJobConfigurationPOJO each : configService.loadAll()) { <line4> schedule(each); <line5> } <line6> } <line7> } <line8> "	"<line1>    log.info(""Start producer manager"");"	task0	
"public class A { <line0> private boolean readCommitsEnabled(String commitEnabled) { <line1> boolean isCommitEnabled = false; <line2> try { <line3> isCommitEnabled = Boolean.parseBoolean(readParameterValue(commitEnabled)); <line4> } catch (ParameterNotFoundException e) { <line5> log.error("" Commits enabled payload parameter is not found""); <line6> } <line7> return isCommitEnabled; <line8> } <line9> } <line10> "	"<line5>      log.error("" Commits enabled payload parameter is not found"");"	task0	
"public class A { <line0> @Override <line1> public void setOutputProperties(final Properties properties) { <line2> super.setOutputProperties(properties); <line3> final String option = outputProperties.getProperty(EXistOutputKeys.INDENT_SPACES, ""4""); <line4> try { <line5> indentAmount = Integer.parseInt(option); <line6> } catch (final NumberFormatException e) { <line7> LOG.warn(""Invalid indentation value: '{}'"", option); <line8> } <line9> indent = ""yes"".equals(outputProperties.getProperty(OutputKeys.INDENT, ""no"")); <line10> } <line11> } <line12> "	"<line7>      LOG.warn(""Invalid indentation value: '{}'"", option);"	task0	
"public class A { <line0> protected TimeoutTask createTimeoutTask() { <line1> if (timeout <= 0) { <line2> return null; <line3> } <line4> return TimeoutManager.getInstance() <line5> .addTimeoutTarget( <line6> () -> { <line7> logger.warn(""Process is terminated due to {} second exceeded."", timeout); <line8> ComponentUtil.getProcessHelper().destroyProcess(sessionId); <line9> processTimeout = true; <line10> }, <line11> timeout, <line12> false); <line13> } <line14> } <line15> "	"<line7>              logger.warn(""Process is terminated due to {} second exceeded."", timeout);"	task0	
"public class A { <line0> private Set<String> getRequestingUserDepts() { <line1> Set<String> requestingUserDepts = Sets.newHashSet(); <line2> ModerationService.Iface client = thriftClients.makeModerationClient(); <line3> try { <line4> requestingUserDepts = client.getRequestingUserDepts(); <line5> } catch (TException e) { <line6> log.error(""Error geeting requesting user departments"", e); <line7> } <line8> return requestingUserDepts; <line9> } <line10> } <line11> "	"<line6>      log.error(""Error geeting requesting user departments"", e);"	task0	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void writeData(Object[] data) throws HyracksDataException { <line3> if (!open) { <line4> throw new HyracksDataException(""Writing to SerializingDataWriter that has not been opened""); <line5> } <line6> tb.reset(); <line7> for (int i = 0; i < data.length; ++i) { <line8> Object instance = data[i]; <line9> if (LOGGER.isTraceEnabled()) { <line10> LOGGER.trace(i + "" "" + LogRedactionUtil.userData(instance.toString())); <line11> } <line12> tb.addField(recordDescriptor.getFields()[i], instance); <line13> } <line14> FrameUtils.appendToWriter( <line15> frameWriter, tupleAppender, tb.getFieldEndOffsets(), tb.getByteArray(), 0, tb.getSize()); <line16> } <line17> } <line18> "	"<line10>        LOGGER.trace(i + "" "" + LogRedactionUtil.userData(instance.toString()));"	task0	
"public class A { <line0> private void writeEventBatchToSerializer() throws InterruptedException, WriteException { <line1> try { <line2> timedCall( <line3> new CallRunner1<Void>() { <line4> @Override <line5> public Void call() throws InterruptedException, StreamingException { <line6> try { <line7> for (Event event : batch) { <line8> try { <line9> serializer.write(txnBatch, event); <line10> } catch (SerializationError err) { <line11> LOG.info( <line12> ""Parse failed : {}  : {}"", err.getMessage(), new String(event.getBody())); <line13> } <line14> } <line15> return null; <line16> } catch (IOException e) { <line17> throw new StreamingIOFailure(e.getMessage(), e); <line18> } <line19> } <line20> }); <line21> batch.clear(); <line22> } catch (StreamingException e) { <line23> throw new WriteException(endPoint, txnBatch.getCurrentTxnId(), e); <line24> } catch (TimeoutException e) { <line25> throw new WriteException(endPoint, txnBatch.getCurrentTxnId(), e); <line26> } <line27> } <line28> } <line29> "	"<line11>                    LOG.info(""Parse failed : {}  : {}"", err.getMessage(), new String(event.getBody()));"	task0	
"public class A { <line0> @Override <line1> @RestAccessControl(permission = Permission.SUPERUSER) <line2> @RequestMapping( <line3> value = ""/{modelId}"", <line4> produces = MediaType.APPLICATION_JSON_VALUE, <line5> method = RequestMethod.DELETE) <line6> public ResponseEntity<SimpleRestResponse<Map<String, String>>> deleteContentModel( <line7> @PathVariable Long modelId) { <line8> logger.info(""deleting content model {}"", modelId); <line9> contentModelService.delete(modelId); <line10> Map<String, String> result = Collections.singletonMap(""modelId"", String.valueOf(modelId)); <line11> return ResponseEntity.ok(new SimpleRestResponse<>(result)); <line12> } <line13> } <line14> "	"<line8>    logger.info(""deleting content model {}"", modelId);"	task0	
"public class A { <line0> private void downloadAndCopyJars(Set<String> jarsToDownload, Path destinationPath) <line1> throws IOException { <line2> Set<String> copiedJars = new HashSet<>(); <line3> for (String jar : jarsToDownload) { <line4> if (!copiedJars.contains(jar)) { <line5> Path jarPath = Paths.get(jar); <line6> if (destinationPath == null || jarPath == null) { <line7> throw new IllegalArgumentException(""null destinationPath or jarPath""); <line8> } <line9> Path jarFileName = jarPath.getFileName(); <line10> if (jarFileName == null) { <line11> throw new IllegalArgumentException(""null farFileName""); <line12> } <line13> File destPath = Paths.get(destinationPath.toString(), jarFileName.toString()).toFile(); <line14> try (InputStream src = fileStorage.download(jar); <line15> FileOutputStream dest = new FileOutputStream(destPath)) { <line16> IOUtils.copy(src, dest); <line17> copiedJars.add(jar); <line18> LOG.debug(""Jar {} copied to {}"", jar, destPath); <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	"<line18>          LOG.debug(""Jar {} copied to {}"", jar, destPath);"	task0	
"public class A { <line0> private void awaitInitializeProxy(IgniteCacheProxyImpl<?, ?> jcache) { <line1> if (jcache != null) { <line2> CountDownLatch initLatch = jcache.getInitLatch(); <line3> try { <line4> while (initLatch.getCount() > 0) { <line5> initLatch.await(2000, TimeUnit.MILLISECONDS); <line6> if (log.isInfoEnabled()) <line7> log.info( <line8> ""Failed to wait proxy initialization, cache="" <line9> + jcache.getName() <line10> + "", localNodeId="" <line11> + ctx.localNodeId()); <line12> } <line13> } catch (InterruptedException e) { <line14> Thread.currentThread().interrupt(); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line7>            log.info(""Failed to wait proxy initialization, cache=""+ jcache.getName()+ "", localNodeId=""+ ctx.localNodeId());"	task0	
"public class A { <line0> public int getSymLinkDepth() { <line1> int value = 0; <line2> try { <line3> value = Integer.parseInt(line.getOptionValue(ARGUMENT.SYM_LINK_DEPTH, ""0"")); <line4> if (value < 0) { <line5> value = 0; <line6> } <line7> } catch (NumberFormatException ex) { <line8> LOGGER.debug(""Symbolic link was not a number""); <line9> } <line10> return value; <line11> } <line12> } <line13> "	"<line8>      LOGGER.debug(""Symbolic link was not a number"");"	task0	
"public class A { <line0> protected Object getRawNodeValue( <line1> final JsonNode fieldNode, final DataType dataType, final String fieldName) <line2> throws IOException { <line3> if (fieldNode == null || fieldNode.isNull()) { <line4> return null; <line5> } <line6> if (fieldNode.isNumber()) { <line7> return fieldNode.getNumberValue(); <line8> } <line9> if (fieldNode.isBinary()) { <line10> return fieldNode.getBinaryValue(); <line11> } <line12> if (fieldNode.isBoolean()) { <line13> return fieldNode.getBooleanValue(); <line14> } <line15> if (fieldNode.isTextual()) { <line16> final String textValue = fieldNode.getTextValue(); <line17> if (dataType == null) { <line18> return textValue; <line19> } <line20> switch (dataType.getFieldType()) { <line21> case DATE: <line22> case TIME: <line23> case TIMESTAMP: <line24> try { <line25> return DataTypeUtils.convertType( <line26> textValue, <line27> dataType, <line28> LAZY_DATE_FORMAT, <line29> LAZY_TIME_FORMAT, <line30> LAZY_TIMESTAMP_FORMAT, <line31> fieldName); <line32> } catch (final Exception e) { <line33> return textValue; <line34> } <line35> default: <line36> return textValue; <line37> } <line38> } <line39> if (fieldNode.isArray()) { <line40> final ArrayNode arrayNode = (ArrayNode) fieldNode; <line41> final int numElements = arrayNode.size(); <line42> final Object[] arrayElements = new Object[numElements]; <line43> int count = 0; <line44> final DataType elementDataType; <line45> if (dataType != null && dataType.getFieldType() == RecordFieldType.ARRAY) { <line46> final ArrayDataType arrayDataType = (ArrayDataType) dataType; <line47> elementDataType = arrayDataType.getElementType(); <line48> } else if (dataType != null && dataType.getFieldType() == RecordFieldType.CHOICE) { <line49> List<DataType> possibleSubTypes = ((ChoiceDataType) dataType).getPossibleSubTypes(); <line50> for (DataType possibleSubType : possibleSubTypes) { <line51> if (possibleSubType.getFieldType() == RecordFieldType.ARRAY) { <line52> ArrayDataType possibleArrayDataType = (ArrayDataType) possibleSubType; <line53> DataType possibleElementType = possibleArrayDataType.getElementType(); <line54> final Object[] possibleArrayElements = new Object[numElements]; <line55> int elementCounter = 0; <line56> for (final JsonNode node : arrayNode) { <line57> final Object value = getRawNodeValue(node, possibleElementType, fieldName); <line58> possibleArrayElements[elementCounter++] = value; <line59> } <line60> if (DataTypeUtils.isArrayTypeCompatible( <line61> possibleArrayElements, possibleElementType, true)) { <line62> return possibleArrayElements; <line63> } <line64> } <line65> } <line66> logger.debug( <line67> ""Couldn't find proper schema for '{}'. This could lead to some fields filtered out."", <line68> fieldName); <line69> elementDataType = dataType; <line70> } else { <line71> elementDataType = dataType; <line72> } <line73> for (final JsonNode node : arrayNode) { <line74> final Object value = getRawNodeValue(node, elementDataType, fieldName); <line75> arrayElements[count++] = value; <line76> } <line77> return arrayElements; <line78> } <line79> if (fieldNode.isObject()) { <line80> RecordSchema childSchema = null; <line81> if (dataType != null && RecordFieldType.MAP == dataType.getFieldType()) { <line82> return getMapFromRawValue(fieldNode, dataType, fieldName); <line83> } <line84> return getRecordFromRawValue(fieldNode, dataType); <line85> } <line86> return null; <line87> } <line88> } <line89> "	"<line66>        logger.debug(""Couldn't find proper schema for '{}'. This could lead to some fields filtered out."",fieldName);"	task0	
"public class A { <line0> @Override <line1> protected final Object getEndpointInternal(MessageContext messageContext) throws Exception { <line2> String key = getLookupKeyForMessage(messageContext); <line3> if (!StringUtils.hasLength(key)) { <line4> return null; <line5> } <line6> if (logger.isDebugEnabled()) { <line7> logger.debug(""Looking up endpoint for ["" + key + ""]""); <line8> } <line9> return lookupEndpoint(key); <line10> } <line11> } <line12> "	"<line7>      logger.debug(""Looking up endpoint for ["" + key + ""]"");"	task0	
"public class A { <line0> @Override <line1> public void destroy() throws Exception { <line2> logger.info(""shutting down thread pool executor""); <line3> executorService.shutdownNow(); <line4> executorService.awaitTermination(10, TimeUnit.SECONDS); <line5> } <line6> } <line7> "	"<line2>    logger.info(""shutting down thread pool executor"");"	task0	
"public class A { <line0> @Override <line1> public void start() { <line2> wdh = new DataWormHoleWorker(""DataWormHoleWorker"", this.feature, ""dwhhandlers""); <line3> wdhThread = Executors.newSingleThreadExecutor(); <line4> wdhThread.execute(wdh); <line5> if (log.isTraceEnable()) { <line6> log.info(this, ""DataWormHoleWorker started""); <line7> } <line8> } <line9> } <line10> "	"<line6>      log.info(this, ""DataWormHoleWorker started"");"	task0	
"public class A { <line0> public static boolean hasLink(WiserMessage emailMessage, LinkType linkType) { <line1> log.info(""Query {} has a {} link"", emailMessage, linkType.name()); <line2> Pattern linkPattern = getLinkRegex(linkType); <line3> Matcher matcher = linkPattern.matcher(HasEmailRule.getEmailContent(emailMessage)); <line4> return matcher.find(); <line5> } <line6> } <line7> "	"<line1>    log.info(""Query {} has a {} link"", emailMessage, linkType.name());"	task0	
"public class A { <line0> private boolean lockMultiple(IgniteInternalTx tx, Iterable<IgniteTxEntry> entries) <line1> throws IgniteCheckedException { <line2> assert tx.optimistic() || !tx.local(); <line3> long remainingTime = tx.remainingTime(); <line4> long timeout = remainingTime < 0 ? 0 : remainingTime; <line5> GridCacheVersion serOrder = (tx.serializable() && tx.optimistic()) ? tx.nearXidVersion() : null; <line6> for (IgniteTxEntry txEntry1 : entries) { <line7> if (!txEntry1.markPrepared() || txEntry1.explicitVersion() != null) continue; <line8> GridCacheContext cacheCtx = txEntry1.context(); <line9> while (true) { <line10> cctx.database().checkpointReadLock(); <line11> try { <line12> GridCacheEntryEx entry1 = txEntry1.cached(); <line13> assert entry1 != null : txEntry1; <line14> assert !entry1.detached() <line15> : ""Expected non-detached entry for near transaction "" <line16> + ""[locNodeId="" <line17> + cctx.localNodeId() <line18> + "", entry="" <line19> + entry1 <line20> + ']'; <line21> GridCacheVersion serReadVer = txEntry1.entryReadVersion(); <line22> assert serReadVer == null || (tx.optimistic() && tx.serializable()) : txEntry1; <line23> boolean read = serOrder != null && txEntry1.op() == READ; <line24> entry1.unswap(); <line25> if (!entry1.tmLock(tx, timeout, serOrder, serReadVer, read)) { <line26> for (IgniteTxEntry txEntry2 : entries) { <line27> if (txEntry2 == txEntry1) break; <line28> txUnlock(tx, txEntry2); <line29> } <line30> return false; <line31> } <line32> break; <line33> } catch (GridCacheEntryRemovedException ignored) { <line34> if (log.isDebugEnabled()) <line35> log.debug(""Got removed entry in TM lockMultiple(..) method (will retry): "" + txEntry1); <line36> try { <line37> txEntry1.cached(cacheCtx.cache().entryEx(txEntry1.key(), tx.topologyVersion())); <line38> } catch (GridDhtInvalidPartitionException e) { <line39> assert tx.dht() <line40> : ""Received invalid partition for non DHT transaction [tx="" <line41> + tx <line42> + "", invalidPart="" <line43> + e.partition() <line44> + ']'; <line45> tx.addInvalidPartition(cacheCtx.cacheId(), e.partition()); <line46> break; <line47> } <line48> } catch (GridDistributedLockCancelledException ignore) { <line49> tx.setRollbackOnly(); <line50> throw new IgniteCheckedException(""Entry lock has been cancelled for transaction: "" + tx); <line51> } finally { <line52> cctx.database().checkpointReadUnlock(); <line53> } <line54> } <line55> } <line56> return true; <line57> } <line58> } <line59> "	"<line35>            log.debug(""Got removed entry in TM lockMultiple(..) method (will retry): "" + txEntry1);"	task0	
"public class A { <line0> @Override <line1> public void start() { <line2> super.start(); <line3> LOG.debug( <line4> ""------------ STARTING THE DATABASE HISTORY! - trackers: {} - config: {}"", <line5> restrictionTrackers, <line6> config.asMap()); <line7> RestrictionTracker<OffsetHolder, ?> tracker = <line8> restrictionTrackers.get(restrictionTrackers.keySet().iterator().next()); <line9> this.history = (List<byte[]>) tracker.currentRestriction().history; <line10> } <line11> } <line12> "	"<line3>    LOG.debug(""------------ STARTING THE DATABASE HISTORY! - trackers: {} - config: {}"",restrictionTrackers,config.asMap());"	task0	
"public class A { <line0> @Override <line1> public MemberRequest findByKey(String key) throws NoSuchMemberRequestException { <line2> MemberRequest memberRequest = fetchByKey(key); <line3> if (memberRequest == null) { <line4> StringBundler sb = new StringBundler(4); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""key=""); <line7> sb.append(key); <line8> sb.append(""}""); <line9> if (log.isDebugEnabled()) { <line10> log.debug(sb.toString()); <line11> } <line12> throw new NoSuchMemberRequestException(sb.toString()); <line13> } <line14> return memberRequest; <line15> } <line16> } <line17> "	<line10>        log.debug(sb.toString());	task0	
"public class A { <line0> @Override <line1> protected String formatQuery(String query) { <line2> try { <line3> Objects.requireNonNull(query); <line4> return this.formatter.format(query); <line5> } catch (Exception e) { <line6> log.error(""Query formatter failed!"", e); <line7> } <line8> return ""FORMATTER ERROR!""; <line9> } <line10> } <line11> "	"<line6>      log.error(""Query formatter failed!"", e);"	task0	
"public class A { <line0> @Override <line1> public boolean isSatisified() throws Exception { <line2> LOG.debug(""Test run waiting for connections to get resumed.. at: "" + resumedCount.get()); <line3> return resumedCount.get() >= WORKER_COUNT; <line4> } <line5> } <line6> "	"<line2>    LOG.debug(""Test run waiting for connections to get resumed.. at: "" + resumedCount.get());"	task0	
"public class A { <line0> private Collection<DataObject> getAllItemsInDatabox(URI databoxUri) throws NotFoundException { <line1> PrivacyPreference databox = this.getResourceStore().get(databoxUri, PrivacyPreference.class); <line2> Collection<Resource> itemUris = databox.getAllAppliesToResource_as().asList(); <line3> Collection<DataObject> items = new ArrayList<DataObject>(); <line4> for (Resource item : itemUris) { <line5> try { <line6> items.add(this.getResourceStore().get(item.asURI(), DataObject.class)); <line7> } catch (NotFoundException e) { <line8> logger.warn( <line9> ""Item "" <line10> + item.asURI() <line11> + "" is in databox "" <line12> + databox.asURI() <line13> + "" but it is does not exist.""); <line14> } <line15> } <line16> return items; <line17> } <line18> } <line19> "	"<line8>        logger.warn(""Item ""+ item.asURI()+ "" is in databox ""+ databox.asURI()+ "" but it is does not exist."");"	task0	
"public class A { <line0> public ServerConfiguration getServerConfiguration() { <line1> if (containsRadiusServerConfiguration() == false) return null; <line2> try { <line3> return persistenceEntryManager.find(ServerConfiguration.class, getServerConfigurationDn()); <line4> } catch (MappingException e) { <line5> log.error(""Failed to load radius server configuration"", e); <line6> } <line7> return null; <line8> } <line9> } <line10> "	"<line5>      log.error(""Failed to load radius server configuration"", e);"	task0	
"public class A { <line0> public static ElideNamespaceConfig stringToElideNamespaceConfigPojo( <line1> String fileName, <line2> String content, <line3> Map<String, Object> variables, <line4> DynamicConfigSchemaValidator schemaValidator) <line5> throws IOException { <line6> ElideNamespaceConfig namespaceconfig = new ElideNamespaceConfig(); <line7> String jsonConfig = hjsonToJson(resolveVariables(content, variables)); <line8> try { <line9> if (schemaValidator.verifySchema(Config.NAMESPACEConfig, jsonConfig, fileName)) { <line10> namespaceconfig = getModelPojo(jsonConfig, ElideNamespaceConfig.class); <line11> } <line12> } catch (ProcessingException e) { <line13> log.error(""Error Validating DB config : "" + e.getMessage()); <line14> throw new IOException(e); <line15> } <line16> return namespaceconfig; <line17> } <line18> } <line19> "	"<line13>      log.error(""Error Validating DB config : "" + e.getMessage());"	task0	
"public class A { <line0> @Override <line1> public Entity add( <line2> PersistencePackage persistencePackage, DynamicEntityDao dynamicEntityDao, RecordHelper helper) <line3> throws ServiceException { <line4> Entity entity = persistencePackage.getEntity(); <line5> try { <line6> PersistencePerspective persistencePerspective = <line7> persistencePackage.getPersistencePerspective(); <line8> OfferCode offerCodeInstance = (OfferCode) Class.forName(entity.getType()[0]).newInstance(); <line9> Map<String, FieldMetadata> offerCodeProperties = <line10> helper.getSimpleMergedProperties(OfferCode.class.getName(), persistencePerspective); <line11> offerCodeInstance = <line12> (OfferCode) <line13> helper.createPopulatedInstance(offerCodeInstance, entity, offerCodeProperties, false); <line14> Entity errorEntity = validateOfferCode(entity, offerCodeInstance); <line15> if (errorEntity != null) { <line16> return errorEntity; <line17> } <line18> offerCodeInstance = dynamicEntityDao.merge(offerCodeInstance); <line19> return helper.getRecord(offerCodeProperties, offerCodeInstance, null, null); <line20> } catch (Exception e) { <line21> LOG.error(""Unable to execute persistence activity"", e); <line22> throw new ServiceException(""Unable to add entity for "" + entity.getType()[0], e); <line23> } <line24> } <line25> } <line26> "	"<line21>      LOG.error(""Unable to execute persistence activity"", e);"	task0	
"public class A { <line0> @Override <line1> public void write(byte[] buf, int off, int len) throws IOException { <line2> if (LOG.isDebugEnabled()) { <line3> LOG.debug(""wrapping token of length:"" + len); <line4> } <line5> byte[] wrapped = cryptoAES.wrap(buf, off, len); <line6> DataOutputStream dob = new DataOutputStream(out); <line7> dob.writeInt(wrapped.length); <line8> dob.write(wrapped, 0, wrapped.length); <line9> dob.flush(); <line10> } <line11> } <line12> "	"<line3>      LOG.debug(""wrapping token of length:"" + len);"	task0	
"public class A { <line0> private void reinitialize() { <line1> logger.debug(""Reinitialize thing handler ({}). haId={}"", getThingLabel(), getThingHaId()); <line2> stopRetryRegistering(); <line3> stopOfflineMonitor1(); <line4> stopOfflineMonitor2(); <line5> unregisterEventListener(); <line6> initialize(); <line7> } <line8> } <line9> "	"<line1>    logger.debug(""Reinitialize thing handler ({}). haId={}"", getThingLabel(), getThingHaId());"	task0	
"public class A { <line0> @Override <line1> public void setSessionTimeout(Integer minutes, HttpContext httpContext) { <line2> serverModel.runSilently( <line3> () -> { <line4> final Batch batch = new Batch(""Session timeout configuration""); <line5> WebContainerContext ctx = unify(httpContext); <line6> OsgiContextModel contextModel = <line7> serverModel.getOrCreateOsgiContextModel( <line8> ctx, serviceBundle, PaxWebConstants.DEFAULT_CONTEXT_PATH, batch); <line9> LOG.info(""Setting session timeout for {}"", contextModel); <line10> contextModel.setSessionTimeout(minutes); <line11> serverController.sendBatch(batch); <line12> return null; <line13> }); <line14> } <line15> } <line16> "	"<line9>          LOG.info(""Setting session timeout for {}"", contextModel);"	task0	
"public class A { <line0> @Override <line1> public void initContext(AgentSession agentSession) { <line2> log.info(""Initializing Thrift agent context""); <line3> } <line4> } <line5> "	"<line2>    log.info(""Initializing Thrift agent context"");"	task0	
"public class A { <line0> @Test <line1> public void testTensorflow() throws InterpreterException { <line2> String callTensorflowFunc = <line3> ""import tensorflow as tf\n"" + ""print('Installed TensorFlow version:' + tf.__version__)""; <line4> InterpreterContext intpContext = getIntpContext(); <line5> InterpreterResult intpResult = pySubmarineIntp.interpret(callTensorflowFunc, intpContext); <line6> assertEquals(InterpreterResult.Code.SUCCESS, intpResult.code()); <line7> String tfVersionInfo = intpContext.out().getCurrentOutput().toString(); <line8> LOGGER.info(tfVersionInfo); <line9> boolean getVersion = tfVersionInfo.contains(""Installed TensorFlow version:""); <line10> assertTrue(tfVersionInfo, getVersion); <line11> } <line12> } <line13> "	<line8>    LOGGER.info(tfVersionInfo);	task0	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Result result; <line4> while (true) { <line5> if ((result = scanner.next()) != null) { <line6> while (running && !resultQueue.offer(result)) { <line7> Thread.sleep(sleepMillis); <line8> } <line9> } <line10> } <line11> } catch (Exception e) { <line12> logger.debug(""Exception in fetching results {}"", e.getMessage()); <line13> threadFailureReason = e.getMessage(); <line14> } finally { <line15> scanner.close(); <line16> } <line17> } <line18> } <line19> "	"<line12>      logger.debug(""Exception in fetching results {}"", e.getMessage());"	task0	
"public class A { <line0> @GET <line1> @Path(""/select"") <line2> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line3> public Response search( <line4> @QueryParam(""q"") final String query, <line5> @QueryParam(""rows"") @DefaultValue(""10"") final String rows, <line6> @QueryParam(""start"") @DefaultValue(""0"") final String start, <line7> @QueryParam(""hl"") @DefaultValue(""false"") final String highlight, <line8> @QueryParam(""hl.simple.pre"") @DefaultValue(""<b>"") final String highlightPre, <line9> @QueryParam(""hl.simple.post"") @DefaultValue(""</b>"") final String highlightPost, <line10> @QueryParam(""wt"") @DefaultValue(""xml"") final String writerType, <line11> @QueryParam(""facet"") @DefaultValue(""false"") final String facet, <line12> @Context final HttpServletRequest request) { <line13> try { <line14> return ok( <line15> search( <line16> new SearchRequest.SearchRequestBuilder() <line17> .setRows(rows) <line18> .setStart(start) <line19> .setQuery(query) <line20> .setHighlight(highlight) <line21> .setHighlightPre(highlightPre) <line22> .setHighlightPost(highlightPost) <line23> .setFormat(writerType) <line24> .setFacet(facet) <line25> .build(), <line26> request)); <line27> } catch (IllegalArgumentException e) { <line28> return badRequest(e.getMessage()); <line29> } catch (QueryException qe) { <line30> throw RestServiceHelper.createWebApplicationException(qe, request); <line31> } catch (Exception e) { <line32> LOGGER.error(e.getMessage(), e); <line33> return internalServerError(""Unexpected error""); <line34> } <line35> } <line36> } <line37> "	<line32>      LOGGER.error(e.getMessage(), e);	task0	
"public class A { <line0> public void setRootLogLevel(String level) { <line1> ch.qos.logback.classic.Logger root = <line2> (ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME); <line3> if (level == null || level.length() == 0) { <line4> stopLogging(); <line5> return; <line6> } else if (""debug"".equalsIgnoreCase(level)) { <line7> root.setLevel(ch.qos.logback.classic.Level.DEBUG); <line8> } else if (""info"".equalsIgnoreCase(level)) { <line9> root.setLevel(ch.qos.logback.classic.Level.INFO); <line10> } else if (""warn"".equalsIgnoreCase(level)) { <line11> root.setLevel(ch.qos.logback.classic.Level.WARN); <line12> } else if (""error"".equalsIgnoreCase(level)) { <line13> root.setLevel(ch.qos.logback.classic.Level.ERROR); <line14> } else { <line15> log.error(""unknown logging level {}"", level); <line16> } <line17> if (!isLogging) { <line18> root.addAppender(this); <line19> } <line20> getLogLevel(); <line21> broadcastState(); <line22> } <line23> } <line24> "	"<line15>      log.error(""unknown logging level {}"", level);"	task0	
"public class A { <line0> private TextUnit getNextTextUnit() throws NoSuchElementException { <line1> TextUnitDTOWithComments textUnitDTO = textUnitsIterator.next(); <line2> if (logger.isDebugEnabled()) { <line3> logger.debug( <line4> ""Get next text unit for tuId: {}, name: {}, locale: {}, source: {}"", <line5> textUnitDTO.getTmTextUnitId(), <line6> textUnitDTO.getName(), <line7> textUnitDTO.getTargetLocale(), <line8> textUnitDTO.getSource()); <line9> } <line10> TextUnit textUnit = new TextUnit(""""); <line11> textUnit.setName(textUnitDTO.getName()); <line12> textUnitUtils.replaceSourceString(textUnit, textUnitDTO.getSource()); <line13> TextContainer targetTextContainer = new TextContainer(textUnitDTO.getTarget()); <line14> textUnit.setTarget(targetLocale, targetTextContainer); <line15> ImportExportNote importExportNote = new ImportExportNote(); <line16> importExportNote.setSourceComment(textUnitDTO.getComment()); <line17> importExportNote.setTargetComment(textUnitDTO.getTargetComment()); <line18> importExportNote.setStatus(textUnitDTO.getStatus()); <line19> importExportNote.setIncludedInLocalizedFile(textUnitDTO.isIncludedInLocalizedFile()); <line20> importExportNote.setCreatedDate(textUnitDTO.getCreatedDate()); <line21> importExportNote.setVariantComments(textUnitDTO.getTmTextUnitVariantComments()); <line22> importExportNote.setPluralForm(textUnitDTO.getPluralForm()); <line23> importExportNote.setPluralFormOther(textUnitDTO.getPluralFormOther()); <line24> importExportTextUnitUtils.setImportExportNote(textUnit, importExportNote); <line25> textUnit.setPreserveWhitespaces(true); <line26> return textUnit; <line27> } <line28> } <line29> "	"<line3>      logger.debug(""Get next text unit for tuId: {}, name: {}, locale: {}, source: {}"",textUnitDTO.getTmTextUnitId(),textUnitDTO.getName(),textUnitDTO.getTargetLocale(),textUnitDTO.getSource());"	task0	
"public class A { <line0> private void processCacheGroup(CacheGroupContext grp) throws IgniteCheckedException { <line1> assert grp.offheap() instanceof GridCacheOffheapManager; <line2> PendingEntriesTree oldPendingTree; <line3> final IgniteCacheDatabaseSharedManager db = grp.shared().database(); <line4> db.checkpointReadLock(); <line5> try { <line6> IndexStorage indexStorage = ((GridCacheOffheapManager) grp.offheap()).getIndexStorage(); <line7> RootPage pendingRootPage = indexStorage.allocateIndex(PENDING_ENTRIES_TREE_NAME); <line8> if (pendingRootPage.isAllocated()) { <line9> log.info( <line10> ""No pending tree found for cache group: [grpId="" <line11> + grp.groupId() <line12> + "", grpName="" <line13> + grp.name() <line14> + ']'); <line15> indexStorage.dropIndex(PENDING_ENTRIES_TREE_NAME); <line16> return; <line17> } <line18> oldPendingTree = <line19> new PendingEntriesTree( <line20> grp, <line21> PENDING_ENTRIES_TREE_NAME, <line22> grp.dataRegion().pageMemory(), <line23> pendingRootPage.pageId().pageId(), <line24> ((GridCacheOffheapManager) grp.offheap()).reuseListForIndex(null), <line25> false, <line26> null, <line27> PageIdAllocator.FLAG_IDX); <line28> } finally { <line29> db.checkpointReadUnlock(); <line30> } <line31> processPendingTree(grp, oldPendingTree); <line32> if (Thread.currentThread().isInterrupted()) return; <line33> db.checkpointReadLock(); <line34> try { <line35> oldPendingTree.destroy(); <line36> } finally { <line37> db.checkpointReadUnlock(); <line38> } <line39> } <line40> } <line41> "	"<line9>        log.info(""No pending tree found for cache group: [grpId=""+ grp.groupId()+ "", grpName=""+ grp.name()+ ']');"	task0	
public class A { <line0> public static void error( <line1> final Logger logger, final String format, final Supplier<Object> supplier) { <line2> if (logger.isErrorEnabled()) { <line3> logger.error(format, supplier.get()); <line4> } <line5> } <line6> } <line7> 	<line3>      logger.error(format, supplier.get());	task0	
"public class A { <line0> public Response addRelease(Release release) throws SW360Exception { <line1> log.debug( <line2> ""create Release { name='"" <line3> + release.getName() <line4> + ""', version='"" <line5> + release.getVersion() <line6> + ""' }""); <line7> final AddDocumentRequestSummary addDocumentRequestSummary = <line8> componentDatabaseHandler.addRelease(release, user); <line9> final String releaseId = addDocumentRequestSummary.getId(); <line10> if (releaseId == null || releaseId.isEmpty()) { <line11> throw new SW360Exception( <line12> ""Id of added release should not be empty. "" + addDocumentRequestSummary.toString()); <line13> } <line14> return new Response( <line15> releaseId, <line16> AddDocumentRequestStatus.SUCCESS.equals(addDocumentRequestSummary.getRequestStatus())); <line17> } <line18> } <line19> "	"<line1>    log.debug(""create Release { name='""+ release.getName()+ ""', version='""+ release.getVersion()+ ""' }"");"	task0	
"public class A { <line0> @Override <line1> public void getRateLimitStatus(final String... resources) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(RATE_LIMIT_STATUS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> Map<String, RateLimitStatus> rateLimitStatus = <line8> twitter.getRateLimitStatus(resources); <line9> for (TwitterListener listener : listeners) { <line10> try { <line11> listener.gotRateLimitStatus(rateLimitStatus); <line12> } catch (Exception e) { <line13> logger.warn(""Exception at getRateLimitStatus"", e); <line14> } <line15> } <line16> } <line17> }); <line18> } <line19> } <line20> "	"<line13>                    logger.warn(""Exception at getRateLimitStatus"", e);"	task0	
"public class A { <line0> private Collection evaluateGetInternal(EventBean event) { <line1> Object value = getter.get(event); <line2> if (value == null) { <line3> return null; <line4> } <line5> if (!(value.getClass().isArray())) { <line6> log.warn( <line7> ""Expected array-type input from property '"" <line8> + propertyName <line9> + ""' but received "" <line10> + value.getClass()); <line11> return null; <line12> } <line13> if (componentType.getType().isPrimitive()) { <line14> return new ArrayWrappingCollection(value); <line15> } <line16> return Arrays.asList((Object[]) value); <line17> } <line18> } <line19> "	"<line6>      log.warn(""Expected array-type input from property '""+ propertyName+ ""' but received ""+ value.getClass());"	task0	
"public class A { <line0> public Future<?> submitCarbondataAutoCleanupTask(ScheduledExecutorService executorService) { <line1> Future<?> result = null; <line2> if (null != executorService) { <line3> result = executorService.submit(new CarbondataAutoCleanerTask()); <line4> log.debug(""Submitting task to Vacuum Cleaner thread pool""); <line5> } <line6> return result; <line7> } <line8> } <line9> "	"<line4>      log.debug(""Submitting task to Vacuum Cleaner thread pool"");"	task0	
"public class A { <line0> @Override <line1> public CompletionStage<?> handleSubscribe( <line2> final String applicationId, <line3> final Topic topic, <line4> final MessageHandler handler, <line5> final ErrorHandler<? extends Throwable> errorHandler) { <line6> return subscribe( <line7> applicationId, <line8> topic, <line9> (messageTopic, payload) -> { <line10> logger.debug(""Received message for: {}"", topic); <line11> try { <line12> handleMessage(handler, payload); <line13> } catch (final Exception e) { <line14> try { <line15> errorHandler.handleError(e, null); <line16> } catch (final Exception e1) { <line17> throw e1; <line18> } catch (final Throwable e1) { <line19> throw new Exception(e1); <line20> } <line21> } <line22> }); <line23> } <line24> } <line25> "	"<line10>          logger.debug(""Received message for: {}"", topic);"	task0	
"public class A { <line0> @Override <line1> public CompletableFuture<Void> stop() { <line2> abortPendingSnapshots(); <line3> if (snapshotListener != null) { <line4> raft.getPersistedSnapshotStore().removeSnapshotListener(snapshotListener); <line5> } <line6> try { <line7> raft.getPersistedSnapshotStore().purgePendingSnapshots().join(); <line8> } catch (final Exception e) { <line9> log.warn( <line10> ""Failed to purge pending snapshots, which may result in unnecessary disk usage and should"" <line11> + "" be monitored"", <line12> e); <line13> } <line14> return super.stop(); <line15> } <line16> } <line17> "	"<line9>      log.warn(""Failed to purge pending snapshots, which may result in unnecessary disk usage and should""+ "" be monitored"",e);"	task0	
"public class A { <line0> private void markOutputPathForDeletion( <line1> final int projectId, <line2> final VirtualFile outputPath, <line3> final String classname, <line4> final String srcUrl) { <line5> final SourceUrlClassNamePair pair = new SourceUrlClassNamePair(srcUrl, classname); <line6> synchronized (myDataLock) { <line7> final Outputs outputs = myOutputsToDelete.get(projectId); <line8> try { <line9> outputs.put(outputPath.getPath(), pair); <line10> if (LOG.isDebugEnabled() || DEBUG_MODE) { <line11> final String message = ""ADD path to delete: "" + outputPath + ""; source: "" + srcUrl; <line12> LOG.debug(message); <line13> if (DEBUG_MODE) { <line14> System.out.println(message); <line15> } <line16> } <line17> } finally { <line18> outputs.release(); <line19> } <line20> } <line21> } <line22> } <line23> "	<line12>          LOG.debug(message);	task0	
"public class A { <line0> public static synchronized void updateAccumuloVersion(VolumeManager fs, int oldVersion) { <line1> for (Volume volume : fs.getVolumes()) { <line2> try { <line3> if (getAccumuloPersistentVersion(volume) == oldVersion) { <line4> log.debug(""Attempting to upgrade {}"", volume); <line5> Path dataVersionLocation = ServerConstants.getDataVersionLocation(volume); <line6> fs.create(new Path(dataVersionLocation, Integer.toString(ServerConstants.DATA_VERSION))) <line7> .close(); <line8> Path prevDataVersionLoc = new Path(dataVersionLocation, Integer.toString(oldVersion)); <line9> if (!fs.delete(prevDataVersionLoc)) { <line10> throw new RuntimeException( <line11> ""Could not delete previous data version location ("" <line12> + prevDataVersionLoc <line13> + "") for "" <line14> + volume); <line15> } <line16> } <line17> } catch (IOException e) { <line18> throw new RuntimeException(""Unable to set accumulo version: an error occurred."", e); <line19> } <line20> } <line21> } <line22> } <line23> "	"<line4>          log.debug(""Attempting to upgrade {}"", volume);"	task0	
"public class A { <line0> @Test <line1> public void testTxLoadFromStore() throws Exception { <line2> Ignite ignite0 = ignite(0); <line3> final IgniteTransactions txs = ignite0.transactions(); <line4> for (CacheConfiguration<Integer, Integer> ccfg : cacheConfigurations()) { <line5> if (ccfg.getCacheStoreFactory() == null) continue; <line6> logCacheInfo(ccfg); <line7> try { <line8> IgniteCache<Integer, Integer> cache = ignite0.createCache(ccfg); <line9> List<Integer> keys = testKeys(cache); <line10> for (Integer key : keys) { <line11> log.info(""Test key: "" + key); <line12> Integer storeVal = -1; <line13> storeMap.put(key, storeVal); <line14> try (Transaction tx = txs.txStart(OPTIMISTIC, SERIALIZABLE)) { <line15> Integer val = cache.get(key); <line16> assertEquals(storeVal, val); <line17> tx.commit(); <line18> } <line19> checkValue(key, storeVal, cache.getName()); <line20> cache.remove(key); <line21> try (Transaction tx = txs.txStart(OPTIMISTIC, SERIALIZABLE)) { <line22> Integer val = cache.get(key); <line23> assertNull(val); <line24> tx.commit(); <line25> } <line26> checkValue(key, null, cache.getName()); <line27> } <line28> } finally { <line29> destroyCache(ccfg.getName()); <line30> } <line31> } <line32> } <line33> } <line34> "	"<line11>          log.info(""Test key: "" + key);"	task0	
"public class A { <line0> public void pushChange(String indexName) { <line1> lock.executeInWriteLock( <line2> () -> { <line3> pushCounter.increment(); <line4> LOGGER.trace(""index added for refresh: %s"", indexName); <line5> indexToMaxRefreshTime.put(indexName, getTime()); <line6> }); <line7> } <line8> } <line9> "	"<line4>          LOGGER.trace(""index added for refresh: %s"", indexName);"	task0	
public class A { <line0> public static void warn(final Object message, final Throwable t) { <line1> Logger logger = Logger.getLogger(getCallerClassName()); <line2> if (verbose) setVerboseLogger(logger); <line3> logger.warn(message, t); <line4> } <line5> } <line6> 	<line3>    logger.warn(message, t);	task0	
"public class A { <line0> public void saveToFile() { <line1> synchronized (voyages) { <line2> VoyageStore voyageStore = new VoyageStore(this); <line3> try { <line4> FileOutputStream fileOut = new FileOutputStream(VOYAGESFILE); <line5> ObjectOutputStream objectOut = new ObjectOutputStream(fileOut); <line6> objectOut.writeObject(voyageStore); <line7> objectOut.close(); <line8> fileOut.close(); <line9> } catch (IOException e) { <line10> LOG.error(""Failed to save routes file: "" + e.getMessage()); <line11> } <line12> } <line13> } <line14> } <line15> "	"<line10>        LOG.error(""Failed to save routes file: "" + e.getMessage());"	task0	
"public class A { <line0> @Test <line1> public void testApplication() throws IOException, Exception { <line2> for (final Locality l : Locality.values()) { <line3> logger.debug(""Running the with {} locality"", l); <line4> LocalMode.runApp( <line5> new Benchmark.AbstractApplication() { <line6> @Override <line7> public Locality getLocality() { <line8> return l; <line9> } <line10> }, <line11> 60000); <line12> } <line13> } <line14> } <line15> "	"<line3>      logger.debug(""Running the with {} locality"", l);"	task0	
"public class A { <line0> @Override <line1> public void reserve( <line2> NicProfile nic, <line3> Network network, <line4> VirtualMachineProfile vm, <line5> DeployDestination dest, <line6> ReservationContext context) <line7> throws InsufficientAddressCapacityException, ConcurrentOperationException, <line8> InsufficientVirtualNetworkCapacityException { <line9> if (dest.getHost().getHypervisorType() != HypervisorType.BareMetal) { <line10> super.reserve(nic, network, vm, dest, context); <line11> return; <line12> } <line13> HostVO host = _hostDao.findById(dest.getHost().getId()); <line14> _hostDao.loadDetails(host); <line15> String intentIp = host.getDetail(ApiConstants.IP_ADDRESS); <line16> if (intentIp == null) { <line17> super.reserve(nic, network, vm, dest, context); <line18> return; <line19> } <line20> String oldIp = nic.getIPv4Address(); <line21> boolean getNewIp = false; <line22> if (oldIp == null) { <line23> getNewIp = true; <line24> } else { <line25> final IPAddressVO ipVO = _ipAddressDao.findByIpAndSourceNetworkId(network.getId(), oldIp); <line26> if (ipVO != null) { <line27> PodVlanMapVO mapVO = _podVlanDao.listPodVlanMapsByVlan(ipVO.getVlanId()); <line28> if (mapVO.getPodId() != dest.getPod().getId()) { <line29> Transaction.execute( <line30> new TransactionCallbackNoReturn() { <line31> @Override <line32> public void doInTransactionWithoutResult(TransactionStatus status) { <line33> _ipAddrMgr.markIpAsUnavailable(ipVO.getId()); <line34> _ipAddressDao.unassignIpAddress(ipVO.getId()); <line35> } <line36> }); <line37> nic.setIPv4Address(null); <line38> getNewIp = true; <line39> } <line40> } <line41> } <line42> if (getNewIp) { <line43> getBaremetalIp(nic, dest.getPod(), vm, network, intentIp); <line44> } <line45> DataCenter dc = _dcDao.findById(network.getDataCenterId()); <line46> nic.setIPv4Dns1(dc.getDns1()); <line47> nic.setIPv4Dns2(dc.getDns2()); <line48> logger.debug(""Allocated a nic "" + nic + "" for "" + vm); <line49> } <line50> } <line51> "	"<line48>    logger.debug(""Allocated a nic "" + nic + "" for "" + vm);"	task0	
"public class A { <line0> @Override <line1> public void commitReservation(UUID reservationId) throws VcProviderException { <line2> removeReservation(reservationId); <line3> logger.info(""current VMs Cloning is done, commit Reservation.""); <line4> } <line5> } <line6> "	"<line3>    logger.info(""current VMs Cloning is done, commit Reservation."");"	task0	
"public class A { <line0> protected void checkSchema(final JsonNode node, final URI uri) <line1> throws JsonModelValidationException { <line2> try { <line3> final String jsonString = objectMapper.writeValueAsString(node); <line4> objectMapper.readValue(jsonString, Schema.class); <line5> } catch (final IOException e) { <line6> ModelTest.log.warn(""The file '"" + uri + ""' did not pass validation."", e); <line7> throw new JsonModelValidationException( <line8> ""Invalid JSON content in resource: "" + uri.toString(), e); <line9> } <line10> } <line11> } <line12> "	"<line6>      ModelTest.log.warn(""The file '"" + uri + ""' did not pass validation."", e);"	task0	
"public class A { <line0> public static String checkHeartbeatNamespace(ServiceUnitId ns) { <line1> Matcher m = HEARTBEAT_NAMESPACE_PATTERN.matcher(ns.getNamespaceObject().toString()); <line2> if (m.matches()) { <line3> LOG.debug( <line4> ""SLAMonitoring namespace matched the lookup namespace {}"", <line5> ns.getNamespaceObject().toString()); <line6> return String.format(""http://%s"", m.group(1)); <line7> } else { <line8> return null; <line9> } <line10> } <line11> } <line12> "	"<line3>      LOG.debug(""SLAMonitoring namespace matched the lookup namespace {}"",ns.getNamespaceObject().toString());"	task0	
"public class A { <line0> public static void reactiveInvoke(Invocation invocation, AsyncResponse asyncResp) { <line1> try { <line2> invocation.onStart(null, System.nanoTime()); <line3> invocation.setSync(false); <line4> ReactiveResponseExecutor respExecutor = new ReactiveResponseExecutor(); <line5> invocation.setResponseExecutor(respExecutor); <line6> invocation.onStartHandlersRequest(); <line7> invocation.next( <line8> ar -> { <line9> ContextUtils.setInvocationContext(invocation.getParentContext()); <line10> try { <line11> invocation.getInvocationStageTrace().finishHandlersResponse(); <line12> invocation.onFinish(ar); <line13> asyncResp.handle(ar); <line14> } finally { <line15> ContextUtils.removeInvocationContext(); <line16> } <line17> }); <line18> } catch (Throwable e) { <line19> invocation.getInvocationStageTrace().finishHandlersResponse(); <line20> Response response = Response.createConsumerFail(e); <line21> invocation.onFinish(response); <line22> LOGGER.error( <line23> ""invoke failed, {}"", invocation.getOperationMeta().getMicroserviceQualifiedName()); <line24> asyncResp.handle(response); <line25> } <line26> } <line27> } <line28> "	"<line22>      LOGGER.error(""invoke failed, {}"", invocation.getOperationMeta().getMicroserviceQualifiedName());"	task0	
"public class A { <line0> protected void upgradeResourcePermission(String name) throws Exception { <line1> StringBundler sb1 = new StringBundler(4); <line2> sb1.append(""select resourceActionId, bitwiseValue from ""); <line3> sb1.append(""ResourceAction where actionId = 'ADD_ENTRY' and name = '""); <line4> sb1.append(name); <line5> sb1.append(""'""); <line6> StringBundler sb2 = new StringBundler(5); <line7> sb2.append(""select resourcePermissionId, companyId, scope, primKey, ""); <line8> sb2.append(""primKeyId, roleId, actionIds from ResourcePermission ""); <line9> sb2.append(""where name = '""); <line10> sb2.append(name); <line11> sb2.append(""'""); <line12> try (PreparedStatement preparedStatement1 = connection.prepareStatement(sb1.toString()); <line13> ResultSet resultSet1 = preparedStatement1.executeQuery()) { <line14> if (!resultSet1.next()) { <line15> if (!_ignoreMissingAddEntryResourceAction) { <line16> log.error( <line17> StringBundler.concat( <line18> ""Unable to upgrade ADD_ENTRY action, "", <line19> ""ResourceAction for "", <line20> name, <line21> "" is not initialized"")); <line22> } <line23> return; <line24> } <line25> long bitwiseValue = resultSet1.getLong(""bitwiseValue""); <line26> try (PreparedStatement preparedStatement2 = connection.prepareStatement(sb2.toString()); <line27> ResultSet resultSet = preparedStatement2.executeQuery()) { <line28> while (resultSet.next()) { <line29> long actionIds = resultSet.getLong(""actionIds""); <line30> if ((bitwiseValue & actionIds) == 0) { <line31> continue; <line32> } <line33> long resourcePermissionId = resultSet.getLong(""resourcePermissionId""); <line34> long companyId = resultSet.getLong(""companyId""); <line35> int scope = resultSet.getInt(""scope""); <line36> String primKey = resultSet.getString(""primKey""); <line37> long primKeyId = resultSet.getLong(""primKeyId""); <line38> updateResourcePermission(resourcePermissionId, actionIds - bitwiseValue); <line39> if (scope == ResourceConstants.SCOPE_INDIVIDUAL) { <line40> if (primKey.contains(""_LAYOUT_"")) { <line41> primKey = String.valueOf(companyId); <line42> primKeyId = companyId; <line43> scope = ResourceConstants.SCOPE_COMPANY; <line44> } else { <line45> continue; <line46> } <line47> } <line48> long roleId = resultSet.getLong(""roleId""); <line49> addAnnouncementsAdminViewResourcePermission(companyId, scope, primKey, primKeyId, roleId); <line50> } <line51> } <line52> long resourceActionId = resultSet1.getLong(""resourceActionId""); <line53> deleteResourceAction(resourceActionId); <line54> } <line55> } <line56> } <line57> "	"<line16>          log.error(StringBundler.concat(""Unable to upgrade ADD_ENTRY action, "",""ResourceAction for "",name,"" is not initialized""));"	task0	
"public class A { <line0> @Nonnull <line1> public static TextDiffType getDiffType(boolean hasDeleted, boolean hasInserted) { <line2> if (hasDeleted && hasInserted) { <line3> return TextDiffType.MODIFIED; <line4> } else if (hasDeleted) { <line5> return TextDiffType.DELETED; <line6> } else if (hasInserted) { <line7> return TextDiffType.INSERTED; <line8> } else { <line9> LOG.error(""Diff fragment should not be empty""); <line10> return TextDiffType.MODIFIED; <line11> } <line12> } <line13> } <line14> "	"<line9>      LOG.error(""Diff fragment should not be empty"");"	task0	
"public class A { <line0> @Override <line1> public MockHost getHost(String guid) { <line2> TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.SIMULATOR_DB); <line3> try { <line4> txn.start(); <line5> MockHost _host = _mockHostDao.findByGuid(guid); <line6> txn.commit(); <line7> if (_host != null) { <line8> return _host; <line9> } else { <line10> logger.error(""Host with guid "" + guid + "" was not found""); <line11> return null; <line12> } <line13> } catch (Exception ex) { <line14> txn.rollback(); <line15> throw new CloudRuntimeException( <line16> ""Unable to get host "" + guid + "" due to "" + ex.getMessage(), ex); <line17> } finally { <line18> txn.close(); <line19> txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB); <line20> txn.close(); <line21> } <line22> } <line23> } <line24> "	"<line10>        logger.error(""Host with guid "" + guid + "" was not found"");"	task0	
"public class A { <line0> @Override <line1> public void initialize() throws InitializationException { <line2> CacheConfiguration cacheConfiguration = new CacheConfiguration(""localization."" + getId()); <line3> try { <line4> this.documentBundlesCache = this.cacheManager.createNewCache(cacheConfiguration); <line5> } catch (CacheException e) { <line6> this.logger.error(""Failed to create cache [{}]"", cacheConfiguration.getConfigurationId(), e); <line7> } <line8> } <line9> } <line10> "	"<line6>      this.logger.error(""Failed to create cache [{}]"", cacheConfiguration.getConfigurationId(), e);"	task0	
"public class A { <line0> private void onNextAttemptCompleted(Boolean success, Throwable error) { <line1> assert executor.inEventLoop(); <line2> if (success) { <line3> LOG.debug(""[{}] Reconnection successful"", logPrefix); <line4> reallyStop(); <line5> } else { <line6> if (error != null && !(error instanceof CancellationException)) { <line7> Loggers.warnWithException( <line8> LOG, ""[{}] Uncaught error while starting reconnection attempt"", logPrefix, error); <line9> } <line10> if (state == State.STOP_AFTER_CURRENT) { <line11> reallyStop(); <line12> } else { <line13> assert state == State.ATTEMPT_IN_PROGRESS; <line14> scheduleNextAttempt(); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line3>      LOG.debug(""[{}] Reconnection successful"", logPrefix);"	task0	
"public class A { <line0> protected void exportPreview( <line1> PortletDataContext portletDataContext, <line2> FileEntry fileEntry, <line3> Element fileEntryElement, <line4> String binPathSuffix, <line5> String previewType, <line6> int fileIndex) <line7> throws Exception { <line8> if (portletDataContext.isPerformDirectBinaryImport()) { <line9> return; <line10> } <line11> FileVersion fileVersion = fileEntry.getFileVersion(); <line12> if (!hasPreview(fileVersion, previewType)) { <line13> if (log.isWarnEnabled()) { <line14> log.warn(""No preview found for file entry "" + fileEntry.getFileEntryId()); <line15> } <line16> return; <line17> } <line18> String binPathSegment = null; <line19> if (fileIndex < 0) { <line20> binPathSegment = previewType; <line21> } else { <line22> binPathSegment = String.valueOf(fileIndex + 1); <line23> } <line24> String binPath = getBinPath(portletDataContext, fileEntry, binPathSegment); <line25> StringBundler sb = new StringBundler(4); <line26> sb.append(""bin-path-preview-""); <line27> sb.append(binPathSegment); <line28> sb.append(""-""); <line29> sb.append(binPathSuffix); <line30> String binPathName = sb.toString(); <line31> fileEntryElement.addAttribute(binPathName, binPath); <line32> if (fileIndex < 0) { <line33> fileIndex = 0; <line34> } else { <line35> fileIndex++; <line36> } <line37> try (InputStream inputStream = doGetPreviewAsStream(fileVersion, fileIndex, previewType)) { <line38> exportBinary( <line39> portletDataContext, fileEntryElement, fileVersion, inputStream, binPath, binPathName); <line40> } <line41> } <line42> } <line43> "	"<line14>        log.warn(""No preview found for file entry "" + fileEntry.getFileEntryId());"	task0	
"public class A { <line0> @Test <line1> public void multipleNamesFirstProfileActive() throws Exception { <line2> this.environment.setActiveProfiles(""production""); <line3> initialize(""multi-profile-names.xml""); <line4> this.logger.trace(""Hello""); <line5> this.out.expect(containsString(""Hello"")); <line6> } <line7> } <line8> "	"<line4>    this.logger.trace(""Hello"");"	task0	
"public class A { <line0> @Override <line1> public void setupProperties() { <line2> oauthClientId.setValue(""""); <line3> oauthClientSecret.setValue(""""); <line4> if (logger.isTraceEnabled()) { <line5> logger.trace(""Properties set "" + System.identityHashCode(this)); <line6> } <line7> } <line8> } <line9> "	"<line5>      logger.trace(""Properties set "" + System.identityHashCode(this));"	task0	
"public class A { <line0> @Transition(to = ""INIT"", from = ""RUNNING"") <line1> public void onBecomeInitFromRunning(Message msg, NotificationContext context) { <line2> String taskPartition = msg.getPartitionName(); <line3> if (_taskRunner == null) { <line4> throw new IllegalStateException( <line5> String.format( <line6> ""Invalid state transition. There is no running task for partition %s."", <line7> taskPartition)); <line8> } <line9> _taskRunner.cancel(); <line10> TaskResult r = _taskRunner.waitTillDone(); <line11> LOG.info(String.format(""Task partition %s returned result %s."", msg.getPartitionName(), r)); <line12> _taskRunner = null; <line13> } <line14> } <line15> "	"<line11>    LOG.info(String.format(""Task partition %s returned result %s."", msg.getPartitionName(), r));"	task0	
"public class A { <line0> public HttpResponse<String> getOperationalEnvById(String id) { <line1> Properties headers = createHeaders(); <line2> String url = <line3> String.format( <line4> ""%s%s%s/%s"", <line5> aaiConfig.getHttpRequestConfig().getServerRootUrl(), <line6> aaiConfig <line7> .getHttpRequestConfig() <line8> .getResourceNamespaces() <line9> .get(OPERATIONAL_ENV_RESOURCE_CONFIG_PARAM), <line10> OPERATIONAL_ENV_RESOURCE, <line11> id); <line12> SupplierThrows<HttpResponse<String>, Exception> httpGet = <line13> () -> HttpRequest.get(url, headers, aaiConfig.getHttpClientConfig()); <line14> long maxRetries = aaiConfig.getHttpClientConfig().getNumOfRetries(); <line15> try { <line16> return FunctionalInterfaces.retryMethodOnException( <line17> httpGet, this::retryOnException, maxRetries); <line18> } catch (Exception e) { <line19> logger.debug(""Request failed with exception {}"", getCause(e).getMessage()); <line20> return Responses.INTERNAL_SERVER_ERROR; <line21> } <line22> } <line23> } <line24> "	"<line19>      logger.debug(""Request failed with exception {}"", getCause(e).getMessage());"	task0	
"public class A { <line0> public void startSelfTest( <line1> @Identification final String deviceIdentification, <line2> @Identification final String organisationIdentification, <line3> final String correlationUid, <line4> final String messageType, <line5> final int messagePriority) <line6> throws FunctionalException { <line7> LOGGER.debug( <line8> ""startSelfTest called with organisation {} and device {}"", <line9> organisationIdentification, <line10> deviceIdentification); <line11> this.findOrganisation(organisationIdentification); <line12> final Device device = this.findActiveDevice(deviceIdentification); <line13> this.osgpCoreRequestMessageSender.send( <line14> new RequestMessage(correlationUid, organisationIdentification, deviceIdentification, null), <line15> messageType, <line16> messagePriority, <line17> device.getIpAddress()); <line18> } <line19> } <line20> "	"<line7>    LOGGER.debug(""startSelfTest called with organisation {} and device {}"",organisationIdentification,deviceIdentification);"	task0	
"public class A { <line0> @Override <line1> public Authentication authenticate(Authentication authentication) throws AuthenticationException { <line2> Authentication authed = null; <line3> Cache userCache = cacheManager.getCache(""UserCache""); <line4> md.reset(); <line5> byte[] hashKey = <line6> md.digest((authentication.getName() + authentication.getCredentials()).getBytes()); <line7> String userKey = Arrays.toString(hashKey); <line8> Element authedUser = userCache.get(userKey); <line9> if (null != authedUser) { <line10> authed = (Authentication) authedUser.getObjectValue(); <line11> SecurityContextHolder.getContext().setAuthentication(authed); <line12> } else { <line13> try { <line14> authed = super.authenticate(authentication); <line15> userCache.put(new Element(userKey, authed)); <line16> } catch (AuthenticationException e) { <line17> logger.error(""Failed to auth user: "" + authentication.getName(), e); <line18> throw e; <line19> } <line20> UserDetails user = <line21> new User(authentication.getName(), ""skippped-ldap"", authed.getAuthorities()); <line22> if (!userService.userExists(authentication.getName())) { <line23> userService.createUser(user); <line24> } else { <line25> userService.updateUser(user); <line26> } <line27> } <line28> return authed; <line29> } <line30> } <line31> "	"<line17>        logger.error(""Failed to auth user: "" + authentication.getName(), e);"	task0	
"public class A { <line0> public static NamedRelatedResourceRep toNamedRelatedResource(NamedURI resource) { <line1> ResourceTypeEnum resourceType = null; <line2> try { <line3> resourceType = ResourceTypeMapping.getResourceType(URIUtil.getModelClass(resource.getURI())); <line4> } catch (Exception e) { <line5> log.error(""Resource Type not found for "" + resource.getURI(), e); <line6> } <line7> return new NamedRelatedResourceRep( <line8> resource.getURI(), toLink(resourceType, resource.getURI()), resource.getName()); <line9> } <line10> } <line11> "	"<line5>      log.error(""Resource Type not found for "" + resource.getURI(), e);"	task0	
"public class A { <line0> public PageResponse getPageDetailResponse() { <line1> PageResponse pageResponse = null; <line2> try { <line3> IPage draftPage = null; <line4> IPage onlinePage = null; <line5> String check = this.checkSelectedNode(this.getPageCode()); <line6> if (null == check) { <line7> draftPage = this.getPage(this.getPageCode()); <line8> onlinePage = this.getOnlinePage(this.getPageCode()); <line9> } <line10> pageResponse = new PageResponse(this, draftPage, onlinePage); <line11> } catch (Throwable t) { <line12> logger.error(""error in getPageJsonResponse"", t); <line13> this.getServletResponse().setStatus(Status.INTERNAL_SERVER_ERROR.getStatusCode()); <line14> return null; <line15> } <line16> return pageResponse; <line17> } <line18> } <line19> "	"<line12>      logger.error(""error in getPageJsonResponse"", t);"	task0	
"public class A { <line0> @Override <line1> public void close() { <line2> liveClosed.set(true); <line3> log.info(""Shutting down live query server. Disabled finding this job from mqm.""); <line4> SearchRunner.shutdownSearchPool(); <line5> super.close(); <line6> } <line7> } <line8> "	"<line3>    log.info(""Shutting down live query server. Disabled finding this job from mqm."");"	task0	
"public class A { <line0> @Test <line1> void profileExpressionMatchFirst() throws Exception { <line2> this.environment.setActiveProfiles(""production""); <line3> initialize(""profile-expression.xml""); <line4> this.logger.trace(""Hello""); <line5> assertThat(this.output).contains(""Hello""); <line6> } <line7> } <line8> "	"<line4>    this.logger.trace(""Hello"");"	task0	
"public class A { <line0> @Override <line1> public final void handleRequest(final Exchange exchange) { <line2> LOG.debug(""running handler for resource [/{}] on vert.x context"", resource.getName()); <line3> adapterContext.runOnContext(s -> resource.handleRequest(exchange)); <line4> } <line5> } <line6> "	"<line2>    LOG.debug(""running handler for resource [/{}] on vert.x context"", resource.getName());"	task0	
"public class A { <line0> @Override <line1> public void afterFireAllRules( <line2> KieSession kieSession, TestGenKieSessionJournal journal, TestGenKieSessionFireAllRules fire) { <line3> KieSession uncorruptedSession = scoreDirector.createKieSession(); <line4> for (TestGenKieSessionInsert insert : journal.getInitialInserts()) { <line5> Object object = insert.getFact().getInstance(); <line6> uncorruptedSession.insert(object); <line7> } <line8> uncorruptedSession.fireAllRules(); <line9> uncorruptedSession.dispose(); <line10> Score<?> uncorruptedScore = extractScore(uncorruptedSession); <line11> Score<?> workingScore = extractScore(kieSession); <line12> if (!workingScore.equals(uncorruptedScore)) { <line13> LOGGER.debug(""    Score: working[{}], uncorrupted[{}]"", workingScore, uncorruptedScore); <line14> throw new TestGenCorruptedScoreException(workingScore, uncorruptedScore); <line15> } <line16> } <line17> } <line18> "	"<line13>      LOGGER.debug(""    Score: working[{}], uncorrupted[{}]"", workingScore, uncorruptedScore);"	task0	
public class A { <line0> public static com.liferay.commerce.model.CPDAvailabilityEstimateSoap <line1> updateCPDAvailabilityEstimate( <line2> long cpdAvailabilityEstimateId, <line3> long cpDefinitionId, <line4> long commerceAvailabilityEstimateId, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws RemoteException { <line7> try { <line8> com.liferay.commerce.model.CPDAvailabilityEstimate returnValue = <line9> CPDAvailabilityEstimateServiceUtil.updateCPDAvailabilityEstimate( <line10> cpdAvailabilityEstimateId, <line11> cpDefinitionId, <line12> commerceAvailabilityEstimateId, <line13> serviceContext); <line14> return com.liferay.commerce.model.CPDAvailabilityEstimateSoap.toSoapModel(returnValue); <line15> } catch (Exception exception) { <line16> log.error(exception, exception); <line17> throw new RemoteException(exception.getMessage()); <line18> } <line19> } <line20> } <line21> 	<line16>      log.error(exception, exception);	task0	
"public class A { <line0> @Disabled <line1> @Test <line2> public void testCancelRelease() throws Exception { <line3> final com.braintreegateway.Result result = requestBody(""direct://CANCELRELEASE"", null); <line4> assertNotNull(result, ""cancelRelease result""); <line5> LOG.debug(""cancelRelease: "" + result); <line6> } <line7> } <line8> "	"<line5>    LOG.debug(""cancelRelease: "" + result);"	task0	
"public class A { <line0> public void release() throws IOException { <line1> logger.debug(""In release for [{}]"", this.getKey()); <line2> try { <line3> if (this.client != null) { <line4> this.client.release(); <line5> } <line6> } catch (Exception e) { <line7> throw new IOException(e.getMessage()); <line8> } finally { <line9> parser = null; <line10> buffer.clear(); <line11> remAllConnectionListener(); <line12> } <line13> } <line14> } <line15> "	"<line1>    logger.debug(""In release for [{}]"", this.getKey());"	task0	
"public class A { <line0> private void addReportingTaskFingerprint( <line1> final StringBuilder builder, final ReportingTaskDTO dto) { <line2> builder.append(dto.getId()); <line3> builder.append(dto.getType()); <line4> builder.append(dto.getName()); <line5> addBundleFingerprint(builder, dto.getBundle()); <line6> builder.append(dto.getComments()); <line7> builder.append(dto.getSchedulingPeriod()); <line8> builder.append(dto.getSchedulingStrategy()); <line9> builder.append(dto.getAnnotationData()); <line10> final BundleCoordinate coordinate = getCoordinate(dto.getType(), dto.getBundle()); <line11> final ConfigurableComponent configurableComponent = <line12> extensionManager.getTempComponent(dto.getType(), coordinate); <line13> if (configurableComponent == null) { <line14> logger.warn( <line15> ""Unable to get ReportingTask of type {}; its default properties will be fingerprinted"" <line16> + "" instead of being ignored."", <line17> dto.getType()); <line18> } <line19> addPropertiesFingerprint(builder, configurableComponent, dto.getProperties()); <line20> } <line21> } <line22> "	"<line14>      logger.warn(""Unable to get ReportingTask of type {}; its default properties will be fingerprinted""+ "" instead of being ignored."",dto.getType());"	task0	
public class A { <line0> public static com.liferay.portal.kernel.model.UserGroupSoap[] getUserGroups( <line1> long companyId, String name, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.portal.kernel.model.UserGroup> returnValue = <line4> UserGroupServiceUtil.getUserGroups(companyId, name, start, end); <line5> return com.liferay.portal.kernel.model.UserGroupSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> log.error(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line7>      log.error(exception, exception);	task0	
"public class A { <line0> @Pollable(message = ""Updating merged asset text units"") <line1> void updateLastSuccessfulAsseteExtraction( <line2> Asset asset, MultiBranchState currentState, @ParentTask PollableTask currentTask) { <line3> logger.trace( <line4> ""Make sure we have a last successful extraction in the Asset (legacy support edge case)""); <line5> AssetExtraction lastSuccessfulAssetExtraction = getOrCreateLastSuccessfulAssetExtraction(asset); <line6> MultiBranchState lastSuccessfulMultiBranchState = <line7> updateAssetExtractionWithState( <line8> lastSuccessfulAssetExtraction.getId(), currentState, AssetContentMd5s.of()); <line9> } <line10> } <line11> "	"<line3>    logger.trace(""Make sure we have a last successful extraction in the Asset (legacy support edge case)"");"	task0	
"public class A { <line0> protected Future<Message> processRemoveCmdHandlingAdapterInstance( <line1> final Message request, <line2> final ResourceIdentifier targetAddress, <line3> final SpanContext spanContext) { <line4> final String tenantId = targetAddress.getTenantId(); <line5> final String deviceId = MessageHelper.getDeviceId(request); <line6> final String adapterInstanceId = <line7> MessageHelper.getApplicationProperty( <line8> request.getApplicationProperties(), <line9> MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, <line10> String.class); <line11> final Span span = <line12> TracingHelper.buildServerChildSpan( <line13> tracer, <line14> spanContext, <line15> SPAN_NAME_REMOVE_CMD_HANDLING_ADAPTER_INSTANCE, <line16> getClass().getSimpleName()) <line17> .start(); <line18> final Future<Message> resultFuture; <line19> if (tenantId == null || deviceId == null || adapterInstanceId == null) { <line20> TracingHelper.logError(span, ""missing tenant, device and/or adapter instance id""); <line21> resultFuture = <line22> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST)); <line23> } else { <line24> TracingHelper.TAG_TENANT_ID.set(span, tenantId); <line25> TracingHelper.TAG_DEVICE_ID.set(span, deviceId); <line26> span.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId); <line27> logger.debug( <line28> ""removing command handling adapter instance for tenant [{}], device [{}] with value {}"", <line29> tenantId, <line30> deviceId, <line31> adapterInstanceId); <line32> resultFuture = <line33> getService() <line34> .removeCommandHandlingAdapterInstance(tenantId, deviceId, adapterInstanceId, span) <line35> .map( <line36> res -> <line37> DeviceConnectionConstants.getAmqpReply( <line38> DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT, <line39> tenantId, <line40> request, <line41> res)); <line42> } <line43> return finishSpanOnFutureCompletion(span, resultFuture); <line44> } <line45> } <line46> "	"<line27>      logger.debug(""removing command handling adapter instance for tenant [{}], device [{}] with value {}"",tenantId,deviceId,adapterInstanceId);"	task0	
"public class A { <line0> @Override <line1> public void stateHasChanged(SharedTriStateReader reader, SharedTriState.STATE value) <line2> throws Exception { <line3> if (log.isTraceEnabled()) { <line4> log.trace( <line5> ""table:"" <line6> + tableName <line7> + "" stateHasChanged("" <line8> + reader <line9> + "", "" <line10> + value <line11> + ""). This listener does nothing""); <line12> } <line13> } <line14> } <line15> "	"<line4>      log.trace(""table:""+ tableName+ "" stateHasChanged(""+ reader+ "", ""+ value+ ""). This listener does nothing"");"	task0	
"public class A { <line0> @Override <line1> public void done(boolean doneSync) { <line2> try { <line3> if (exception == null) { <line4> exchange.removeProperty(ExchangePropertyKey.FAILURE_ENDPOINT); <line5> } else { <line6> exchange.setException(exception); <line7> exchange.setProperty(ExchangePropertyKey.EXCEPTION_CAUGHT, exception); <line8> } <line9> if (!doneSync) { <line10> ExchangeHelper.prepareOutToIn(exchange); <line11> if (LOG.isTraceEnabled()) { <line12> LOG.trace( <line13> ""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange); <line14> } <line15> } <line16> } finally { <line17> callback.done(doneSync); <line18> } <line19> } <line20> } <line21> "	"<line12>          LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);"	task0	
"public class A { <line0> @Override <line1> public void doExceptionAction(final HttpServletResponse httpResponse, final RuntimeException e) <line2> throws IOException { <line3> LOGGER.error(""Error in Authentication"", e); <line4> httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN, ""Error in Authentication""); <line5> } <line6> } <line7> "	"<line3>    LOGGER.error(""Error in Authentication"", e);"	task0	
"public class A { <line0> @Test <line1> public void testSyncCommandBasicExportImportSmallBatchSize() { <line2> try { <line3> createTestNodes(TestOne.class, 100); <line4> app.command(SyncCommand.class).execute(toMap(""mode"", ""export"", ""file"", EXPORT_FILENAME)); <line5> final Path exportFile = Paths.get(EXPORT_FILENAME); <line6> assertTrue(""Export file doesn't exist!"", Files.exists(exportFile)); <line7> cleanDatabaseAndSchema(); <line8> app.command(SyncCommand.class) <line9> .execute(toMap(""mode"", ""import"", ""file"", EXPORT_FILENAME, ""batchSize"", 20L)); <line10> try (final Tx tx = app.tx()) { <line11> assertEquals(100, app.nodeQuery(TestOne.class).getAsList().size()); <line12> } <line13> Files.delete(exportFile); <line14> } catch (Exception ex) { <line15> logger.warn("""", ex); <line16> fail(""Unexpected exception.""); <line17> } <line18> } <line19> } <line20> "	"<line15>      logger.warn("""", ex);"	task0	
"public class A { <line0> static boolean initValidateSchema(ConfigMap configurationMap) { <line1> LOGGER.trace(""Extract 'schema validation enabled' from configuration map""); <line2> return configurationMap.getTypedOr(VALIDATE_SCHEMA, true); <line3> } <line4> } <line5> "	"<line1>    LOGGER.trace(""Extract 'schema validation enabled' from configuration map"");"	task0	
"public class A { <line0> private void unloadModule() { <line1> try { <line2> if (module != null) { <line3> loader.unload(conf.getProjectName(), module); <line4> } <line5> } catch (Exception x) { <line6> logger.debug(""unload module resulted in exception"", x); <line7> } finally { <line8> module = null; <line9> } <line10> } <line11> } <line12> "	"<line6>      logger.debug(""unload module resulted in exception"", x);"	task0	
"public class A { <line0> @Deprecated <line1> public static void executeChangelog(String changelog, Map<String, Object> userInput) <line2> throws DatabaseUpdateException { <line3> log.debug(""Executing changelog: {}"", changelog); <line4> executeChangelog(changelog, (ChangeSetExecutorCallback) null); <line5> } <line6> } <line7> "	"<line3>    log.debug(""Executing changelog: {}"", changelog);"	task0	
"public class A { <line0> @Override <line1> public void start(long checkpointId, CheckpointOptions checkpointOptions) { <line2> LOG.debug(""{} starting checkpoint {} ({})"", taskName, checkpointId, checkpointOptions); <line3> ChannelStateWriteResult result = new ChannelStateWriteResult(); <line4> ChannelStateWriteResult put = <line5> results.computeIfAbsent( <line6> checkpointId, <line7> id -> { <line8> Preconditions.checkState( <line9> results.size() < maxCheckpoints, <line10> String.format( <line11> ""%s can't start %d, results.size() > maxCheckpoints: %d > %d"", <line12> taskName, checkpointId, results.size(), maxCheckpoints)); <line13> enqueue( <line14> new CheckpointStartRequest( <line15> checkpointId, result, checkpointOptions.getTargetLocation()), <line16> false); <line17> return result; <line18> }); <line19> Preconditions.checkArgument( <line20> put == result, taskName + "" result future already present for checkpoint "" + checkpointId); <line21> } <line22> } <line23> "	"<line2>    LOG.debug(""{} starting checkpoint {} ({})"", taskName, checkpointId, checkpointOptions);"	task0	
"public class A { <line0> @ApiOperation(value = ""Returns information about a specified custom query."") <line1> @ApiResponses( <line2> value = { <line3> @ApiResponse(code = 500, message = ""Unexpected error""), <line4> @ApiResponse(code = 404, message = ""Query definition with given name not found""), <line5> @ApiResponse( <line6> code = 200, <line7> response = QueryDefinition.class, <line8> message = ""Successful response"", <line9> examples = <line10> @Example( <line11> value = {@ExampleProperty(mediaType = JSON, value = QUERY_DEF_RESPONSE_JSON)})) <line12> }) <line13> @GET <line14> @Path(QUERY_DEF_GET_URI) <line15> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line16> public Response getQuery( <line17> @Context HttpHeaders headers, <line18> @ApiParam( <line19> value = ""identifier of the query definition to be retrieved"", <line20> required = true, <line21> example = ""customQuery"") <line22> @PathParam(""queryName"") <line23> String queryName) { <line24> Variant v = getVariant(headers); <line25> Header conversationIdHeader = buildConversationIdHeader("""", context, headers); <line26> try { <line27> QueryDefinition queryDefinition = queryDataServiceBase.getQuery(queryName); <line28> return createCorrectVariant( <line29> queryDefinition, headers, Response.Status.OK, conversationIdHeader); <line30> } catch (QueryNotFoundException e) { <line31> return notFound(MessageFormat.format(QUERY_NOT_FOUND, queryName), v, conversationIdHeader); <line32> } catch (Exception e) { <line33> logger.error(""Unexpected error during processing {}"", e.getMessage(), e); <line34> return internalServerError(errorMessage(e), v, conversationIdHeader); <line35> } <line36> } <line37> } <line38> "	"<line33>      logger.error(""Unexpected error during processing {}"", e.getMessage(), e);"	task0	
"public class A { <line0> @Override <line1> public Method addingService(ServiceReference<Method> serviceReference) { <line2> Registry registry = RegistryUtil.getRegistry(); <line3> Method method = registry.getService(serviceReference); <line4> String token = method.getToken(); <line5> Map<String, Method> methods = _methodRegistry.get(token); <line6> if (methods == null) { <line7> methods = new HashMap<>(); <line8> _methodRegistry.put(token, methods); <line9> } <line10> String methodName = method.getMethodName(); <line11> Method registeredMethod = methods.get(methodName); <line12> if (registeredMethod != null) { <line13> if (log.isWarnEnabled()) { <line14> log.warn( <line15> StringBundler.concat( <line16> ""There is already an XML-RPC method registered "", <line17> ""with name "", <line18> methodName, <line19> "" at "", <line20> token)); <line21> } <line22> } else { <line23> methods.put(methodName, method); <line24> } <line25> return method; <line26> } <line27> } <line28> "	"<line14>        log.warn(StringBundler.concat(""There is already an XML-RPC method registered "",""with name "",methodName,"" at "",token));"	task0	
"public class A { <line0> @Override <line1> @SecurityCheck <line2> public StorageResourceDescription getStorageResource( <line3> AuthzToken authzToken, String storageResourceId) <line4> throws InvalidRequestException, AiravataClientException, AiravataSystemException, <line5> AuthorizationException, TException { <line6> RegistryService.Client regClient = registryClientPool.getResource(); <line7> try { <line8> StorageResourceDescription result = regClient.getStorageResource(storageResourceId); <line9> registryClientPool.returnResource(regClient); <line10> return result; <line11> } catch (Exception e) { <line12> logger.error(storageResourceId, ""Error while retrieving storage resource..."", e); <line13> AiravataSystemException exception = new AiravataSystemException(); <line14> exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR); <line15> exception.setMessage( <line16> ""Error while retrieving storage resource. More info : "" + e.getMessage()); <line17> registryClientPool.returnBrokenResource(regClient); <line18> throw exception; <line19> } <line20> } <line21> } <line22> "	"<line12>      logger.error(storageResourceId, ""Error while retrieving storage resource..."", e);"	task0	
"public class A { <line0> public int saveContentDefinition(JsonObject registerContentJson) throws InsightsCustomException { <line1> int contentId = -1; <line2> Gson gson = new Gson(); <line3> try { <line4> InsightsContentConfig contentConfig = new InsightsContentConfig(); <line5> int kpiId = registerContentJson.get(AssessmentReportAndWorkflowConstants.KPIID).getAsInt(); <line6> contentId = <line7> registerContentJson.get(AssessmentReportAndWorkflowConstants.CONTENTID).getAsInt(); <line8> boolean isActive = <line9> registerContentJson.get(AssessmentReportAndWorkflowConstants.ISACTIVE).getAsBoolean(); <line10> String contentName = <line11> registerContentJson.get(AssessmentReportAndWorkflowConstants.CONTENT_NAME).getAsString(); <line12> String contentString = gson.toJson(registerContentJson); <line13> contentConfig.setContentId(contentId); <line14> InsightsKPIConfig kpiConfig = reportConfigDAL.getKPIConfig(kpiId); <line15> if (kpiConfig == null) { <line16> throw new InsightsCustomException(""KPI not exists""); <line17> } <line18> InsightsContentConfig contentDBConfig = reportConfigDAL.getContentConfig(contentId); <line19> if (contentDBConfig != null) { <line20> throw new InsightsCustomException(""Content Definition already exists""); <line21> } <line22> String category = kpiConfig.getCategory(); <line23> contentConfig.setKpiConfig(kpiConfig); <line24> contentConfig.setActive(isActive); <line25> contentConfig.setContentJson(contentString); <line26> contentConfig.setContentName(contentName); <line27> contentConfig.setCategory(category); <line28> reportConfigDAL.saveContentConfig(contentConfig); <line29> } catch (Exception e) { <line30> log.error(e); <line31> throw new InsightsCustomException(e.getMessage()); <line32> } <line33> return contentId; <line34> } <line35> } <line36> "	<line30>      log.error(e);	task0	
"public class A { <line0> private List<String> _getJSPImportNames(String directoryName) { <line1> if (_jspImportNamesMap.containsKey(directoryName)) { <line2> return _jspImportNamesMap.get(directoryName); <line3> } <line4> List<String> importNames = new ArrayList<>(); <line5> String fileName = directoryName + ""/init.jsp""; <line6> File file = new File(fileName); <line7> if (file.exists()) { <line8> try { <line9> List<String> curImportNames = JSPImportsFormatter.getImportNames(FileUtil.read(file)); <line10> importNames.addAll(curImportNames); <line11> } catch (IOException ioException) { <line12> if (log.isDebugEnabled()) { <line13> log.debug(ioException, ioException); <line14> } <line15> } <line16> } <line17> int x = directoryName.lastIndexOf(CharPool.SLASH); <line18> if ((x != -1) && !directoryName.endsWith(""/resources"") && !directoryName.endsWith(""/docroot"")) { <line19> importNames.addAll(_getJSPImportNames(directoryName.substring(0, x))); <line20> } <line21> _jspImportNamesMap.put(directoryName, importNames); <line22> return importNames; <line23> } <line24> } <line25> "	<line13>          log.debug(ioException, ioException);	task0	
"public class A { <line0> @Test <line1> public void testFlushGivenGroupNoData() throws ClassNotFoundException { <line2> Class.forName(Config.JDBC_DRIVER_NAME); <line3> try (Connection connection = <line4> DriverManager.getConnection( <line5> Config.IOTDB_URL_PREFIX + ""127.0.0.1:6667/"", ""root"", ""root""); <line6> Statement statement = connection.createStatement()) { <line7> statement.execute(""SET STORAGE GROUP TO root.nodatagroup1""); <line8> statement.execute(""SET STORAGE GROUP TO root.nodatagroup2""); <line9> statement.execute(""SET STORAGE GROUP TO root.nodatagroup3""); <line10> statement.execute(""FLUSH root.nodatagroup1""); <line11> statement.execute(""FLUSH root.nodatagroup2""); <line12> statement.execute(""FLUSH root.nodatagroup3""); <line13> statement.execute(""FLUSH root.nodatagroup1, root.nodatagroup2""); <line14> } catch (Exception e) { <line15> logger.error(""testFlushGivenGroupNoData failed"", e); <line16> fail(e.getMessage()); <line17> } <line18> } <line19> } <line20> "	"<line15>      logger.error(""testFlushGivenGroupNoData failed"", e);"	task0	
"public class A { <line0> @Override <line1> public Set<Location> getAllItems() { <line2> try { <line3> return locationService.findAll(); <line4> } catch (Exception e) { <line5> LOGGER.warn(""Cannot find directory-objects: "" + e.getMessage()); <line6> showError(e); <line7> } <line8> return Collections.emptySet(); <line9> } <line10> } <line11> "	"<line5>      LOGGER.warn(""Cannot find directory-objects: "" + e.getMessage());"	task0	
"public class A { <line0> private PoxPayloadOut createObjectExitInstance( <line1> String depositorRefName, String exitNumber, String exitDateDisplayDate) throws Exception { <line2> this.exitNumber = exitNumber; <line3> this.depositorRefName = depositorRefName; <line4> this.exitDateGroup.setDateDisplayDate(exitDateDisplayDate); <line5> this.exitDateGroup.setDateDisplayDate(exitDateDisplayDate); <line6> ObjectexitCommon objectexit = new ObjectexitCommon(); <line7> StructuredDateGroup oeExitDateGroup = new StructuredDateGroup(); <line8> objectexit.setDepositor(depositorRefName); <line9> objectexit.setExitNumber(exitNumber); <line10> oeExitDateGroup.setDateDisplayDate(exitDateDisplayDate); <line11> objectexit.setExitDateGroup(oeExitDateGroup); <line12> PoxPayloadOut multipart = new PoxPayloadOut(ObjectExitClient.SERVICE_PAYLOAD_NAME); <line13> PayloadOutputPart commonPart = <line14> multipart.addPart(new ObjectExitClient().getCommonPartName(), objectexit); <line15> logger.debug( <line16> ""to be created, objectexit common: "" <line17> + objectAsXmlString(objectexit, ObjectexitCommon.class)); <line18> return multipart; <line19> } <line20> } <line21> "	"<line15>    logger.debug(""to be created, objectexit common: ""+ objectAsXmlString(objectexit, ObjectexitCommon.class));"	task0	
"public class A { <line0> @Override <line1> public void stop() throws ConnectException { <line2> log.info(""Stopping HDFS Sink Task {}"", connectorNameAndTaskId); <line3> if (hdfsWriter != null) { <line4> hdfsWriter.stop(); <line5> } <line6> } <line7> } <line8> "	"<line2>    log.info(""Stopping HDFS Sink Task {}"", connectorNameAndTaskId);"	task0	
"public class A { <line0> private void constructInstallProposal() throws ProposalException { <line1> try { <line2> createNetModeTransaction(); <line3> } catch (IOException exp) { <line4> logger.error(exp); <line5> throw new ProposalException(""IO Error while creating install proposal"", exp); <line6> } <line7> } <line8> } <line9> "	<line4>      logger.error(exp);	task0	
"public class A { <line0> private boolean lookupQuad(GridSubset grid, long[] idx) { <line1> BufferedImage mat = matrices.get(grid.getName())[(int) idx[2]]; <line2> long[] gridCoverage = grid.getCoverage((int) idx[2]); <line3> int baseX = (int) (idx[0] - gridCoverage[0]); <line4> int baseY = (int) (gridCoverage[3] - idx[1]); <line5> int width = mat.getWidth(); <line6> int height = mat.getHeight(); <line7> int x = baseX; <line8> int y = baseY; <line9> boolean hasData = false; <line10> int[] xOffsets = {0, 1, 0, 1}; <line11> int[] yOffsets = {0, 0, 1, 1}; <line12> synchronized (mat) { <line13> try { <line14> for (int i = 0; i < 4 && !hasData; i++) { <line15> x = baseX + xOffsets[i]; <line16> y = baseY - yOffsets[i]; <line17> if (x > -1 && x < width && y > -1 && y < height) { <line18> if (mat.getRaster().getSample(x, y, 0) == 0) { <line19> hasData = true; <line20> } <line21> } <line22> } <line23> } catch (ArrayIndexOutOfBoundsException aioob) { <line24> log.error(""x:"" + x + ""  y:"" + y + "" ("" + mat.getWidth() + "" "" + mat.getHeight() + "")""); <line25> } <line26> } <line27> return hasData; <line28> } <line29> } <line30> "	"<line24>        log.error(""x:"" + x + ""  y:"" + y + "" ("" + mat.getWidth() + "" "" + mat.getHeight() + "")"");"	task0	
"public class A { <line0> protected void addContentTypeRequestHeader(HttpState state, HttpConnection conn) <line1> throws IOException, HttpException { <line2> LOG.trace( <line3> ""enter EntityEnclosingMethod.addContentTypeRequestHeader("" + ""HttpState, HttpConnection)""); <line4> if (!parameters.isEmpty()) { <line5> StringBuffer buffer = new StringBuffer(MULTIPART_FORM_CONTENT_TYPE); <line6> if (Part.getBoundary() != null) { <line7> buffer.append(""; boundary=""); <line8> buffer.append(Part.getBoundary()); <line9> } <line10> setRequestHeader(""Content-Type"", buffer.toString()); <line11> } <line12> } <line13> } <line14> "	"<line2>    LOG.trace(""enter EntityEnclosingMethod.addContentTypeRequestHeader("" + ""HttpState, HttpConnection)"");"	task0	
"public class A { <line0> public void addDocumentTerms(DocumentPostingList terms) { <line1> TempLex.insert(terms); <line2> DocCount++; <line3> String reason = null; <line4> if (DocCount % 10 == 0 && memCheck.checkMemory()) { <line5> reason = ""memory threshold hit""; <line6> } else if (DocCount % DocumentsPerLexicon == 0) { <line7> reason = ""doc count exceeded""; <line8> } <line9> if (reason != null) { <line10> if (logger.isDebugEnabled()) logger.debug(""flushing lexicon because of "" + reason); <line11> writeTemporaryLexicon(); <line12> TempLexCount++; <line13> TempLex.clear(); <line14> memCheck.reset(); <line15> } <line16> } <line17> } <line18> "	"<line10>      if (logger.isDebugEnabled()) logger.debug(""flushing lexicon because of "" + reason);"	task0	
public class A { <line0> @Override <line1> public void setOutputStream(final OutputStream os) { <line2> if (logger.isTraceEnabled()) { <line3> this.os = <line4> new ByteArrayOutputStream() { <line5> @Override <line6> public void flush() throws IOException { <line7> os.write(buf, 0, size()); <line8> os.flush(); <line9> logger.trace(new String(buf, 0, size(), StandardCharsets.UTF_8)); <line10> } <line11> }; <line12> } else { <line13> this.os = os; <line14> } <line15> jw.reset(this.os); <line16> } <line17> } <line18> 	<line9>              logger.trace(new String(buf, 0, size(), StandardCharsets.UTF_8));	task0	
"public class A { <line0> @Override <line1> public void onMessage(final Message message) { <line2> try { <line3> configureAuthentication(); <line4> updateService.updateDocumentData( <line5> riksdagenApi.getDocumentStatus((String) ((ObjectMessage) message).getObject())); <line6> } catch (final DataFailureException | JMSException e) { <line7> LOGGER.warn(""Error loading riksdagen documentstatus:"", e); <line8> } finally { <line9> clearAuthentication(); <line10> } <line11> } <line12> } <line13> "	"<line7>      LOGGER.warn(""Error loading riksdagen documentstatus:"", e);"	task0	
"public class A { <line0> public void shutdown() { <line1> if (!executorService.isShutdown()) { <line2> LOG.info(""shutting down async handler executor""); <line3> this.executorService.shutdownNow(); <line4> } <line5> } <line6> } <line7> "	"<line2>      LOG.info(""shutting down async handler executor"");"	task0	
"public class A { <line0> private static String getValue(final Configuration configuration, String key, String type) { <line1> String value = configuration.get(key); <line2> Preconditions.checkArgument( <line3> !isNullOrEmpty(value), String.format(""%s must be supplied via %s"", type, key)); <line4> LOG.debug(""%s %s"", type, value); <line5> return value; <line6> } <line7> } <line8> "	"<line4>    LOG.debug(""%s %s"", type, value);"	task0	
"public class A { <line0> @Override <line1> public Schema create(SchemaPlus parentSchema, String name, Map<String, Object> operand) { <line2> Object config = operand.get(""config""); <line3> Validate.notNull(config, ""No configuration file given. Please specify operand 'config'...'""); <line4> ScraperConfiguration configuration; <line5> try { <line6> configuration = <line7> ScraperConfiguration.fromFile(config.toString(), ScraperConfigurationTriggeredImpl.class); <line8> } catch (IOException e) { <line9> throw new IllegalArgumentException(""Unable to load configuration file!"", e); <line10> } <line11> Object limit = operand.get(""limit""); <line12> Validate.notNull( <line13> limit, ""No limit for the number of rows for a table. Please specify operand 'config'...'""); <line14> long parsedLimit; <line15> try { <line16> parsedLimit = Long.parseLong(limit.toString()); <line17> } catch (NumberFormatException e) { <line18> throw new IllegalArgumentException( <line19> ""Given limit '"" + limit + ""' cannot be parsed to valid long!"", e); <line20> } <line21> try { <line22> return new Plc4xSchema(configuration, parsedLimit); <line23> } catch (ScraperException e) { <line24> LOGGER.warn(""Could not evaluate Plc4xSchema"", e); <line25> return null; <line26> } <line27> } <line28> } <line29> "	"<line24>      LOGGER.warn(""Could not evaluate Plc4xSchema"", e);"	task0	
"public class A { <line0> void redoRemoveOverflow(final RemoveOverflowLoggable loggable) { <line1> try { <line2> final Page page = getPage(loggable.pageNum); <line3> page.read(); <line4> final PageHeader pageHeader = page.getPageHeader(); <line5> if ((!pageHeader.getLsn().equals(Lsn.LSN_INVALID)) && requiresRedo(loggable, page)) { <line6> unlinkPages(page); <line7> } <line8> } catch (final IOException e) { <line9> LOG.warn(""Failed to undo {}: {}"", loggable.dump(), e.getMessage(), e); <line10> } <line11> } <line12> } <line13> "	"<line9>      LOG.warn(""Failed to undo {}: {}"", loggable.dump(), e.getMessage(), e);"	task0	
"public class A { <line0> @Override <line1> public Completable processBulk(Collection<? extends Bulkable> entries) { <line2> for (Bulkable entry : entries) { <line3> if (entry instanceof CreateDocumentRequest) { <line4> CreateDocumentRequest request = (CreateDocumentRequest) entry; <line5> storeEvents.put(request.getIndex() + ""-"" + request.getId(), request.getDoc()); <line6> } else if (entry instanceof DeleteDocumentRequest) { <line7> DeleteDocumentRequest request = (DeleteDocumentRequest) entry; <line8> deleteEvents.add(request.getIndex() + ""-"" + request.getId()); <line9> } else if (entry instanceof UpdateDocumentRequest) { <line10> UpdateDocumentRequest request = (UpdateDocumentRequest) entry; <line11> updateEvents.put(request.getIndex() + ""-"" + request.getId(), request.getDoc()); <line12> } else if (entry instanceof BulkRequest) { <line13> BulkRequest request = (BulkRequest) entry; <line14> processBulk(request.getRequests()); <line15> } else { <line16> log.warn(""Unknown bulkable request found: {}"", entry); <line17> } <line18> } <line19> bulkRequests.addAll(entries); <line20> return Completable.complete(); <line21> } <line22> } <line23> "	"<line16>        log.warn(""Unknown bulkable request found: {}"", entry);"	task0	
"public class A { <line0> @Override <line1> public void tearDown() throws Exception { <line2> super.tearDown(); <line3> if (proxy != null) { <line4> log.debug(""stop the proxy server.""); <line5> proxy.stop(); <line6> } <line7> } <line8> } <line9> "	"<line4>      log.debug(""stop the proxy server."");"	task0	
"public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> User user = twitter.verifyCredentials(); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.verifiedCredentials(user); <line6> } catch (Exception e) { <line7> logger.warn(""Exception at verifyCredentials"", e); <line8> } <line9> } <line10> } <line11> } <line12> "	"<line7>        logger.warn(""Exception at verifyCredentials"", e);"	task0	
"public class A { <line0> @Override <line1> public void accept(Channel<Integer> channel) { <line2> if (!(channel instanceof IntegerWriteChannel)) { <line3> this.log.error( <line4> ""Channel ["" <line5> + channel.address() <line6> + ""] is not an IntegerWriteChannel! Unable to register \""onSetNextWrite\""-Listener!""); <line7> return; <line8> } <line9> ((IntegerWriteChannel) channel) <line10> .onSetNextWrite( <line11> value -> { <line12> channel.getComponent().channel(this.targetChannelId).setNextValue(value); <line13> }); <line14> } <line15> } <line16> "	"<line3>      this.log.error(""Channel [""+ channel.address()+ ""] is not an IntegerWriteChannel! Unable to register \""onSetNextWrite\""-Listener!"");"	task0	
"public class A { <line0> private void analyzeFile(ESRIShapefile aFile) { <line1> myColumnTypes.clear(); <line2> myImportConfig.getColumnNames().clear(); <line3> myValuesSet.clear(); <line4> List<String> columnNames = ShapeFileReadUtilities.getHeader(aFile); <line5> if (!CollectionUtilities.hasContent(columnNames)) { <line6> LOGGER.error(""Shapefile header is empty.""); <line7> } <line8> myValuesSet.addAll(ShapeFileReadUtilities.getDataSample(aFile, 200)); <line9> myImportConfig.getColumnNames().clear(); <line10> myImportConfig.getColumnNames().addAll(columnNames); <line11> int numPreviewLines = myValuesSet.size(); <line12> boolean hadError = numPreviewLines == 0; <line13> int lineIndex = -1; <line14> if (numPreviewLines == 0) { <line15> JOptionPane.showMessageDialog( <line16> myMainPanel, <line17> ""Error loading: "" + aFile.getFilePath() + ""\n\nShapefile contains no data"", <line18> ""Shapefile Loading Error"", <line19> JOptionPane.ERROR_MESSAGE); <line20> } <line21> if (hadError) { <line22> myState = ImportState.ERROR; <line23> changeState(); <line24> } else { <line25> myInfoLabel.setText(""Read "" + lineIndex + "" Lines From File. Analyzing...""); <line26> if (myImportConfig.getColumnNames().size() > 0) { <line27> for (int i = 0; i < myImportConfig.getColumnNames().size(); i++) { <line28> myColumnTypes.add(ColumnType.OTHER); <line29> } <line30> myImportConfig.setDateColumn(-1); <line31> myImportConfig.setTimeColumn(-1); <line32> myImportConfig.setLobColumn(-1); <line33> LegacyImportWizardUtil.determineColumns(myImportConfig); <line34> LegacyImportWizardUtil.determineColumnsLiberal(myImportConfig); <line35> LegacyImportWizardUtil.graspAtStraws(myImportConfig); <line36> LegacyImportWizardUtil.setupColumnTypes(myImportConfig, myColumnTypes); <line37> } <line38> myProgressBar.setValue(100); <line39> myProgressBar.setIndeterminate(false); <line40> myInfoLabel.setText(""Analysis Complete""); <line41> } <line42> } <line43> } <line44> "	"<line6>      LOGGER.error(""Shapefile header is empty."");"	task0	
"public class A { <line0> @Override <line1> public T decode(ByteBuf body, ProtocolVersion version) { <line2> if (ProtocolVersion.SUPPORTED.contains(version)) { <line3> logger.error(""Received invalid message for supported protocol version {}"", version); <line4> } <line5> throw new ProtocolException(""Unsupported message""); <line6> } <line7> } <line8> "	"<line3>      logger.error(""Received invalid message for supported protocol version {}"", version);"	task0	
"public class A { <line0> protected void secondPassCompile() throws MappingException { <line1> log.trace(""Starting secondPassCompile() processing""); <line2> { <line3> if (!isDefaultProcessed) { <line4> final Object isDelimited = reflectionManager.getDefaults().get(""delimited-identifier""); <line5> if (isDelimited != null && isDelimited == Boolean.TRUE) { <line6> getProperties().put(Environment.GLOBALLY_QUOTED_IDENTIFIERS, ""true""); <line7> } <line8> AnnotationBinder.bindDefaults(createMappings()); <line9> isDefaultProcessed = true; <line10> } <line11> } <line12> { <line13> metadataSourceQueue.syncAnnotatedClasses(); <line14> metadataSourceQueue.processMetadata(determineMetadataSourcePrecedence()); <line15> } <line16> { <line17> for (CacheHolder holder : caches) { <line18> if (holder.isClass) { <line19> applyCacheConcurrencyStrategy(holder); <line20> } else { <line21> applyCollectionCacheConcurrencyStrategy(holder); <line22> } <line23> } <line24> caches.clear(); <line25> } <line26> try { <line27> inSecondPass = true; <line28> processSecondPassesOfType(PkDrivenByDefaultMapsIdSecondPass.class); <line29> processSecondPassesOfType(SetSimpleValueTypeSecondPass.class); <line30> processSecondPassesOfType(CopyIdentifierComponentSecondPass.class); <line31> processFkSecondPassInOrder(); <line32> processSecondPassesOfType(CreateKeySecondPass.class); <line33> processSecondPassesOfType(SecondaryTableSecondPass.class); <line34> originalSecondPassCompile(); <line35> inSecondPass = false; <line36> } catch (RecoverableException e) { <line37> throw (RuntimeException) e.getCause(); <line38> } <line39> for (Map.Entry<Table, List<UniqueConstraintHolder>> tableListEntry : <line40> uniqueConstraintHoldersByTable.entrySet()) { <line41> final Table table = tableListEntry.getKey(); <line42> final List<UniqueConstraintHolder> uniqueConstraints = tableListEntry.getValue(); <line43> int uniqueIndexPerTable = 0; <line44> for (UniqueConstraintHolder holder : uniqueConstraints) { <line45> uniqueIndexPerTable++; <line46> final String keyName = <line47> StringHelper.isEmpty(holder.getName()) ? ""key"" + uniqueIndexPerTable : holder.getName(); <line48> buildUniqueKeyFromColumnNames(table, keyName, holder.getColumns()); <line49> } <line50> } <line51> applyConstraintsToDDL(); <line52> } <line53> } <line54> "	"<line1>    log.trace(""Starting secondPassCompile() processing"");"	task0	
"public class A { <line0> public void extract() throws IOException { <line1> log.debug(""Extract content of '{}' to '{}'"", source, destination); <line2> if (destination.exists() && destination.isDirectory()) { <line3> FileUtils.delete(destination.toPath()); <line4> } <line5> try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) { <line6> ZipEntry zipEntry; <line7> while ((zipEntry = zipInputStream.getNextEntry()) != null) { <line8> File file = new File(destination, zipEntry.getName()); <line9> File dir = new File(file.getParent()); <line10> mkdirsOrThrow(dir); <line11> if (zipEntry.isDirectory()) { <line12> mkdirsOrThrow(file); <line13> } else { <line14> byte[] buffer = new byte[1024]; <line15> int length; <line16> try (FileOutputStream fos = new FileOutputStream(file)) { <line17> while ((length = zipInputStream.read(buffer)) >= 0) { <line18> fos.write(buffer, 0, length); <line19> } <line20> } <line21> } <line22> } <line23> } <line24> } <line25> } <line26> "	"<line1>    log.debug(""Extract content of '{}' to '{}'"", source, destination);"	task0	
"public class A { <line0> private Remote getRemote(Request baseRequest) { <line1> Remote remote = (Remote) baseRequest.getAttribute(REMOTE); <line2> if (remote != null) return remote; <line3> String ip = getRemoteIP(baseRequest); <line4> LOG.debug(""ip={}"", ip); <line5> if (ip == null) return null; <line6> int limit = getThreadLimit(ip); <line7> if (limit <= 0) return null; <line8> remote = _remotes.get(ip); <line9> if (remote == null) { <line10> Remote r = new Remote(ip, limit); <line11> remote = _remotes.putIfAbsent(ip, r); <line12> if (remote == null) remote = r; <line13> } <line14> baseRequest.setAttribute(REMOTE, remote); <line15> return remote; <line16> } <line17> } <line18> "	"<line4>    LOG.debug(""ip={}"", ip);"	task0	
"public class A { <line0> public static void initLog4j(String defaultFile) throws Exception { <line1> if (!log4jInitialized) { <line2> String log4jPropertiesFileName = null; <line3> if (System.getProperty(""cmb.log4j.propertyFile"") != null) { <line4> log4jPropertiesFileName = System.getProperty(""cmb.log4j.propertyFile""); <line5> } else if (System.getProperty(""log4j.propertyFile"") != null) { <line6> log4jPropertiesFileName = System.getProperty(""log4j.propertyFile""); <line7> } else if (new File(""config/"" + defaultFile).exists()) { <line8> log4jPropertiesFileName = ""config/"" + defaultFile; <line9> } else if (new File(defaultFile).exists()) { <line10> log4jPropertiesFileName = defaultFile; <line11> } else { <line12> throw new IllegalArgumentException(""Missing VM parameter cmb.log4j.propertyFile""); <line13> } <line14> PropertyConfigurator.configure(log4jPropertiesFileName); <line15> logger.info(""event=init_log4j file="" + log4jPropertiesFileName); <line16> log4jInitialized = true; <line17> } <line18> } <line19> } <line20> "	"<line15>      logger.info(""event=init_log4j file="" + log4jPropertiesFileName);"	task0	
"public class A { <line0> public void cleanJobDefaultCheckpointPath() { <line1> String jobCheckpointPath = getJobDefaultCheckpointPath(); <line2> Path notePath = new Path(jobCheckpointPath); <line3> if (notePath.depth() <= 3) { <line4> submarineUI.outputLog(""ERROR"", ""Checkpoint path depth must be greater than 3""); <line5> return; <line6> } <line7> try { <line8> String message = ""Clean up the checkpoint directory: "" + jobCheckpointPath; <line9> submarineUI.outputLog("""", message); <line10> hdfsClient.delete(notePath); <line11> } catch (IOException e) { <line12> LOGGER.error(e.getMessage(), e); <line13> } <line14> } <line15> } <line16> "	<line12>      LOGGER.error(e.getMessage(), e);	task0	
"public class A { <line0> public AbstractListPage deleteSelected() { <line1> getTable().clickButton(""Delete""); <line2> waitUntil(ExpectedConditions.visibilityOfElementLocated(By.id(""dialog""))); <line3> WebElement dialogElement = getDriver().findElements(By.cssSelector(""#dialog *"")).get(0); <line4> clickOk(); <line5> waitUntil(ExpectedConditions.stalenessOf(dialogElement)); <line6> WebElement workingDialogText = findElementIfExists(By.cssSelector(""#dialog p:first-of-type"")); <line7> if (workingDialogText != null) { <line8> waitUntil(ExpectedConditions.stalenessOf(workingDialogText)); <line9> } <line10> WebElement errorDialog = getDriver().findElement(By.id(""dialog"")); <line11> if (errorDialog != null && errorDialog.isDisplayed()) { <line12> log.error(""Error dialog: "" + String.join(""\n\t"", getDialogText())); <line13> clickOk(); <line14> return null; <line15> } <line16> return constructor.apply(getDriver()); <line17> } <line18> } <line19> "	"<line12>      log.error(""Error dialog: "" + String.join(""\n\t"", getDialogText()));"	task0	
"public class A { <line0> @DocPath(method = PUT, path = ""/alert/{alertId}"", name = ""Get an existing Alert."") <line1> @DocParameters( <line2> value = { <line3> @DocParameter( <line4> name = ""alertId"", <line5> required = true, <line6> path = true, <line7> description = ""Get an existing Alert.""), <line8> @DocParameter( <line9> name = ""thin"", <line10> type = Boolean.class, <line11> description = ""Return only a thin alert, do not include: evalSets, resolvedEvalSets."") <line12> }) <line13> @DocResponses( <line14> value = { <line15> @DocResponse(code = 200, message = ""Success, Alert found."", response = Alert.class), <line16> @DocResponse(code = 404, message = ""Alert not found."", response = ApiError.class), <line17> @DocResponse(code = 500, message = ""Internal server error."", response = ApiError.class), <line18> }) <line19> public void getAlert(RoutingContext routing) { <line20> routing <line21> .vertx() <line22> .executeBlocking( <line23> future -> { <line24> String tenantId = checkTenant(routing); <line25> boolean thin = false; <line26> String alertId = routing.request().getParam(""alertId""); <line27> if (routing.request().params().get(PARAM_THIN) != null) { <line28> thin = Boolean.valueOf(routing.request().params().get(PARAM_THIN)); <line29> } <line30> Alert found; <line31> try { <line32> found = alertsService.getAlert(tenantId, alertId, thin); <line33> log.debugf(""Alert: "", found); <line34> } catch (IllegalArgumentException e) { <line35> throw new BadRequestException(""Bad arguments: "" + e.getMessage()); <line36> } catch (Exception e) { <line37> log.debug(e.getMessage(), e); <line38> throw new InternalServerException(e.toString()); <line39> } <line40> if (found == null) { <line41> throw new NotFoundException(""alertId: "" + alertId + "" not found""); <line42> } <line43> future.complete(found); <line44> }, <line45> res -> result(routing, res)); <line46> } <line47> } <line48> "	<line37>                log.debug(e.getMessage(), e);	task0	
"public class A { <line0> @Override <line1> public SortedMap<String, HibernateMetric> getGenericStats() { <line2> logger.debug(""Get general statistics related to Hibernate.""); <line3> return cacheHandlerRepository.getGenericStats(); <line4> } <line5> } <line6> "	"<line2>    logger.debug(""Get general statistics related to Hibernate."");"	task0	
"public class A { <line0> @Test <line1> public void suffixPatternWithTag() throws InterruptedException { <line2> setMockServerAndConfigure(1, ""test/something [%thread] %logger %msg""); <line3> String logMsg = ""hello""; <line4> logger.debug(logMsg); <line5> mockServer.join(8000); <line6> assertTrue(mockServer.isFinished()); <line7> assertEquals(1, mockServer.getMessageList().size()); <line8> String msg = new String(mockServer.getMessageList().get(0)); <line9> String threadName = Thread.currentThread().getName(); <line10> String expected = ""<"" + (SyslogConstants.LOG_MAIL + SyslogConstants.DEBUG_SEVERITY) + "">""; <line11> assertTrue(msg.startsWith(expected)); <line12> checkRegexMatch( <line13> msg, <line14> SYSLOG_PREFIX_REGEX <line15> + ""test/something \\["" <line16> + threadName <line17> + ""\\] "" <line18> + loggerName <line19> + "" "" <line20> + logMsg); <line21> } <line22> } <line23> "	<line4>    logger.debug(logMsg);	task0	
"public class A { <line0> @Override <line1> public String getArcDateStr() { <line2> String dateStr = header.getDate(); <line3> if (bIsWarc) { <line4> try { <line5> Date warcDate = warcDateFormat.parse(dateStr); <line6> dateStr = arcDateFormat.format(warcDate); <line7> return dateStr; <line8> } catch (Exception e) { <line9> log.info(""Archive date could not be parsed: {}."", dateStr); <line10> } <line11> } <line12> return dateStr; <line13> } <line14> } <line15> "	"<line9>        log.info(""Archive date could not be parsed: {}."", dateStr);"	task0	
"public class A { <line0> public void updateCommentInCase( <line1> String containerId, <line2> String caseId, <line3> String commentId, <line4> String author, <line5> List<String> restrictions, <line6> String comment, <line7> String marshallingType) { <line8> verifyContainerId(containerId, caseId); <line9> author = getUser(author); <line10> String actualComment = <line11> marshallerHelper.unmarshal( <line12> containerId, <line13> comment, <line14> marshallingType, <line15> String.class, <line16> new ByCaseIdContainerLocator(caseId)); <line17> logger.debug( <line18> ""Updating comment {} in case {} by {} with text '{}' with restrictions {}"", <line19> commentId, <line20> caseId, <line21> author, <line22> actualComment, <line23> restrictions); <line24> caseService.updateCaseComment( <line25> caseId, <line26> commentId, <line27> author, <line28> actualComment, <line29> restrictions.toArray(new String[restrictions.size()])); <line30> } <line31> } <line32> "	"<line17>    logger.debug(""Updating comment {} in case {} by {} with text '{}' with restrictions {}"",commentId,caseId,author,actualComment,restrictions);"	task0	
"public class A { <line0> private void getLogicalSwitchGroupByName() { <line1> LogicalSwitchGroup logicalSwitchGroup = client.getByName(LOGICAL_SWITCH_GROUP_NAME).get(0); <line2> LOGGER.info(""Logical switch group returned to client: {}"", logicalSwitchGroup.toJsonString()); <line3> } <line4> } <line5> "	"<line2>    LOGGER.info(""Logical switch group returned to client: {}"", logicalSwitchGroup.toJsonString());"	task0	
"public class A { <line0> @Test <line1> public void testByteArrayToStringConversion() throws UnsupportedEncodingException { <line2> ByteArrayToStringConverterOperator testop = new ByteArrayToStringConverterOperator(); <line3> String test1 = ""hello world with UTF8""; <line4> byte[] utf8Bytes = test1.getBytes(""UTF-8""); <line5> String test2 = ""hello world@#'!!!.: with UTF-16""; <line6> byte[] asciiBytes = test2.getBytes(""UTF-16""); <line7> CollectorTestSink<String> testsink = new CollectorTestSink<String>(); <line8> TestUtils.setSink(testop.output, testsink); <line9> testop.beginWindow(0); <line10> testop.setCharacterEncoding(""UTF-8""); <line11> testop.input.put(utf8Bytes); <line12> testop.setCharacterEncoding(""UTF-16""); <line13> testop.input.put(asciiBytes); <line14> testop.endWindow(); <line15> Assert.assertEquals(2, testsink.collectedTuples.size()); <line16> for (String output : testsink.collectedTuples) { <line17> logger.debug(""output is {}"", output); <line18> Assert.assertEquals(test1, output); <line19> test1 = test2; <line20> } <line21> } <line22> } <line23> "	"<line17>      logger.debug(""output is {}"", output);"	task0	
public class A { <line0> private void closeSession(WebSocketSession session) { <line1> try { <line2> session.close(CloseStatus.SERVER_ERROR); <line3> } catch (Exception e) { <line4> LOGGER.warn(e.getMessage(), e); <line5> } <line6> } <line7> } <line8> 	<line4>      LOGGER.warn(e.getMessage(), e);	task0	
"public class A { <line0> void showStage(AnchorPane pane, boolean localTabOpen) { <line1> anchorRoot = pane; <line2> stage = new Stage(); <line3> stage.setTitle(""Merge""); <line4> stage.setScene(new Scene(anchorRoot)); <line5> stage.initModality(Modality.APPLICATION_MODAL); <line6> stage.setOnCloseRequest(event -> logger.info(""Closed merge window"")); <line7> stage.show(); <line8> if (localTabOpen) mergeTypePane.getSelectionModel().select(localBranchTab); <line9> this.notificationPaneController.setAnchor(stage); <line10> } <line11> } <line12> "	"<line6>    stage.setOnCloseRequest(event -> logger.info(""Closed merge window""));"	task0	
"public class A { <line0> @Override <line1> public Option get(int index, Class<?> type, Annotation[] annotations) { <line2> if (this.index >= values.length) { <line3> return Option.empty(); <line4> } <line5> final Object value = values[this.index]; <line6> if (type.isPrimitive()) { <line7> if (value == null) { <line8> return Option.empty(); <line9> } <line10> if (TypeUtils.getWrapperOf(type) == value.getClass()) { <line11> prepareNextCandidate(); <line12> return Option.withValue(value); <line13> } <line14> } else { <line15> if (type.isInstance(value)) { <line16> prepareNextCandidate(); <line17> return Option.withValue(value); <line18> } else { <line19> if (logger.isDebugEnabled()) { <line20> logger.debug( <line21> ""argument miss match index:{}, type:{} value:{} typeCl:{}, valueCl:{}"", <line22> this.index, <line23> type, <line24> value, <line25> type.getClassLoader(), <line26> getClassLoader(value)); <line27> } <line28> } <line29> } <line30> return Option.empty(); <line31> } <line32> } <line33> "	"<line20>          logger.debug(""argument miss match index:{}, type:{} value:{} typeCl:{}, valueCl:{}"",this.index,type,value,type.getClassLoader(),getClassLoader(value));"	task0	
"public class A { <line0> private Transformer createTransformer() { <line1> try { <line2> Transformer transformer = transformerFactory.newTransformer(); <line3> transformer.setOutputProperty(OutputKeys.INDENT, ""yes""); <line4> transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes""); <line5> transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""2""); <line6> return transformer; <line7> } catch (TransformerConfigurationException e) { <line8> logger.error(Markers.APP_LOG, ""Error creating transformer."", e); <line9> throw new IllegalStateException(e.getMessage()); <line10> } <line11> } <line12> } <line13> "	"<line8>      logger.error(Markers.APP_LOG, ""Error creating transformer."", e);"	task0	
"public class A { <line0> @Override <line1> public DatanodeStorageInfo chooseReplicaToDelete( <line2> BlockCollection bc, <line3> Block block, <line4> short replicationFactor, <line5> Collection<DatanodeStorageInfo> first, <line6> Collection<DatanodeStorageInfo> second, <line7> List<StorageType> excessTypes) { <line8> LOG.info(""chooseReplicaToDelete rep ["" + replicationFactor + ""]""); <line9> String path = bc.getName(); <line10> String shardServer = _serverLookup.getShardServer(path); <line11> if (shardServer == null) { <line12> return super.chooseReplicaToDelete(bc, block, replicationFactor, first, second, excessTypes); <line13> } <line14> DatanodeDescriptor shardServerDatanodeDescriptor = <line15> _serverLookup.getDatanodeDescriptor(shardServer); <line16> if (replicationFactor > 1) { <line17> Collection<DatanodeStorageInfo> firstCopy = new ArrayList<DatanodeStorageInfo>(); <line18> for (DatanodeStorageInfo info : first) { <line19> DatanodeDescriptor datanodeDescriptor = info.getDatanodeDescriptor(); <line20> if (!datanodeDescriptor.equals(shardServerDatanodeDescriptor)) { <line21> firstCopy.add(info); <line22> } <line23> } <line24> Collection<DatanodeStorageInfo> secondCopy = new ArrayList<DatanodeStorageInfo>(); <line25> for (DatanodeStorageInfo info : second) { <line26> DatanodeDescriptor datanodeDescriptor = info.getDatanodeDescriptor(); <line27> if (!datanodeDescriptor.equals(shardServerDatanodeDescriptor)) { <line28> secondCopy.add(info); <line29> } <line30> } <line31> return super.chooseReplicaToDelete( <line32> bc, block, replicationFactor, firstCopy, secondCopy, excessTypes); <line33> } else { <line34> for (DatanodeStorageInfo info : first) { <line35> DatanodeDescriptor datanodeDescriptor = info.getDatanodeDescriptor(); <line36> if (!datanodeDescriptor.equals(shardServerDatanodeDescriptor)) { <line37> return info; <line38> } <line39> } <line40> for (DatanodeStorageInfo info : second) { <line41> DatanodeDescriptor datanodeDescriptor = info.getDatanodeDescriptor(); <line42> if (!datanodeDescriptor.equals(shardServerDatanodeDescriptor)) { <line43> return info; <line44> } <line45> } <line46> throw new RuntimeException(""Should never happen!!!""); <line47> } <line48> } <line49> } <line50> "	"<line8>    LOG.info(""chooseReplicaToDelete rep ["" + replicationFactor + ""]"");"	task0	
"public class A { <line0> public long getSize() { <line1> try { <line2> return getDataRecord().getLength(); <line3> } catch (DataStoreException e) { <line4> log.warn(""getSize for "" + identifier + "" failed"", e); <line5> return -1; <line6> } <line7> } <line8> } <line9> "	"<line4>      log.warn(""getSize for "" + identifier + "" failed"", e);"	task0	
"public class A { <line0> public void toMapfishPrintPdf(Exchange ex) <line1> throws JSONException, DocumentException, URISyntaxException, IOException { <line2> String mfprintJsonSpec = ex.getIn().getBody(String.class); <line3> Assert.notNull(this.mapPrinter); <line4> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line5> Message m = ex.getIn(); <line6> try { <line7> PJsonObject mfSpec = MapPrinter.parseSpec(mfprintJsonSpec); <line8> this.mapPrinter.print(mfSpec, baos); <line9> } catch (Exception e) { <line10> log.error(""Error generating PDF, returning a blank pdf with the error message"", e); <line11> baos = generateErrorPdf(e); <line12> } finally { <line13> m.setBody(baos.toByteArray()); <line14> ex.setOut(m); <line15> } <line16> } <line17> } <line18> "	"<line10>      log.error(""Error generating PDF, returning a blank pdf with the error message"", e);"	task0	
"public class A { <line0> private static <T> void assertAttributeEqualsContinually( <line1> Entity x, AttributeSensor<T> sensor, T value) { <line2> try { <line3> EntityTestUtils.assertAttributeEqualsContinually( <line4> ImmutableMap.of(""timeout"", Duration.millis(25)), x, sensor, value); <line5> } catch (Throwable e) { <line6> log.warn(""Expected "" + x + "" continually to have "" + sensor + "" = "" + value + ""; instead:""); <line7> Entities.dumpInfo(x); <line8> throw Exceptions.propagate(e); <line9> } <line10> } <line11> } <line12> "	"<line6>      log.warn(""Expected "" + x + "" continually to have "" + sensor + "" = "" + value + ""; instead:"");"	task0	
"public class A { <line0> @Override <line1> public void processResult(int rc, String path, Object ctx, String name) { <line2> if (rc != KeeperException.Code.OK.intValue()) { <line3> LOG.error( <line4> ""Could not create node for ledger : path = {}, rc = {}"", <line5> path, <line6> KeeperException.Code.get(rc)); <line7> ledgerCb.operationComplete(rc, null); <line8> } else { <line9> metadata.setVersion(new ZkVersion(0)); <line10> ledgerCb.operationComplete(rc, lid); <line11> } <line12> } <line13> } <line14> "	"<line3>      LOG.error(""Could not create node for ledger : path = {}, rc = {}"",path,KeeperException.Code.get(rc));"	task0	
"public class A { <line0> private void deleteFloatingIP(Exchange exchange) throws Exception { <line1> String ipAddress = <line2> exchange.getIn().getHeader(DigitalOceanHeaders.FLOATING_IP_ADDRESS, String.class); <line3> if (ObjectHelper.isEmpty(ipAddress)) { <line4> throw new IllegalArgumentException( <line5> DigitalOceanHeaders.FLOATING_IP_ADDRESS + "" must be specified""); <line6> } <line7> Delete delete = getEndpoint().getDigitalOceanClient().deleteFloatingIP(ipAddress); <line8> LOG.trace(""Delete Floating IP {}"", delete); <line9> exchange.getMessage().setBody(delete); <line10> } <line11> } <line12> "	"<line8>    LOG.trace(""Delete Floating IP {}"", delete);"	task0	
"public class A { <line0> public void registerProvider(String providerName, Class<? extends T> provider) { <line1> if (providerName != null && !isRegistered(providerName)) { <line2> providers.put(providerName.toLowerCase(), provider); <line3> providerInstances.put(providerName.toLowerCase(), newInstance(providerName)); <line4> } else { <line5> logger.warn( <line6> String.format(""Cannot register %s. It's either empty or already registered."", provider)); <line7> } <line8> } <line9> } <line10> "	"<line5>      logger.warn(String.format(""Cannot register %s. It's either empty or already registered."", provider));"	task0	
"public class A { <line0> @Override <line1> public BlogsStatsUser findByG_U(long groupId, long userId) throws NoSuchStatsUserException { <line2> BlogsStatsUser blogsStatsUser = fetchByG_U(groupId, userId); <line3> if (blogsStatsUser == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""groupId=""); <line7> sb.append(groupId); <line8> sb.append("", userId=""); <line9> sb.append(userId); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> log.debug(sb.toString()); <line13> } <line14> throw new NoSuchStatsUserException(sb.toString()); <line15> } <line16> return blogsStatsUser; <line17> } <line18> } <line19> "	<line12>        log.debug(sb.toString());	task0	
public class A { <line0> @Override <line1> public void onUpdateAll(InterpreterOutput out) { <line2> try { <line3> intpEventClient.onInterpreterOutputUpdateAll( <line4> noteId, paragraphId, out.toInterpreterResultMessage()); <line5> } catch (IOException e) { <line6> LOGGER.error(e.getMessage(), e); <line7> } <line8> } <line9> } <line10> 	<line6>      LOGGER.error(e.getMessage(), e);	task0	
"public class A { <line0> @RequestMapping( <line1> path = ""/v1/{assetGroup}/ec2/{resourceId}/aws-notifications/details"", <line2> method = RequestMethod.POST) <line3> public ResponseEntity<Object> getAwsNotificationDetails( <line4> @RequestBody(required = true) PageFilterRequest request, <line5> @PathVariable(name = ""resourceId"", required = true) String instanceId) { <line6> Map<String, Object> response = new HashMap<>(); <line7> if (Strings.isNullOrEmpty(instanceId)) { <line8> return ResponseUtils.buildFailureResponse(new Exception(AssetConstants.ERROR_INSTANCEID)); <line9> } <line10> int from = request.getFrom(); <line11> if (from < 0) { <line12> return ResponseUtils.buildFailureResponse(new Exception(AssetConstants.ERROR_FROM_NEGATIVE)); <line13> } <line14> int size = request.getSize(); <line15> Map<String, String> filter = request.getFilter(); <line16> List<Map<String, Object>> detailInfo = new ArrayList<>(); <line17> try { <line18> detailInfo = assetService.getNotificationDetails(instanceId, filter, request.getSearchText()); <line19> response.put(""response"", detailInfo); <line20> if (detailInfo.isEmpty()) { <line21> throw new NoDataFoundException(""No data found""); <line22> } <line23> if (from >= detailInfo.size()) { <line24> return ResponseUtils.buildFailureResponse(new Exception(AssetConstants.ERROR_FROM_EXCEEDS)); <line25> } <line26> int endIndex = 0; <line27> if ((from + size) > detailInfo.size()) { <line28> endIndex = detailInfo.size(); <line29> } else { <line30> endIndex = from + size; <line31> } <line32> if (endIndex == 0) { <line33> endIndex = detailInfo.size(); <line34> } <line35> List<Map<String, Object>> subDetailList = detailInfo.subList(from, endIndex); <line36> return ResponseUtils.buildSucessResponse(subDetailList); <line37> } catch (Exception e) { <line38> LOGGER.error(""Error in getAwsNotificationDetails "", e); <line39> List<Map<String, Object>> subDetailList = new ArrayList<>(); <line40> return ResponseUtils.buildSucessResponse(subDetailList); <line41> } <line42> } <line43> } <line44> "	"<line38>      LOGGER.error(""Error in getAwsNotificationDetails "", e);"	task0	
"public class A { <line0> public static void sendCommitInfoToOthers(RemoteCommit remoteCommit) { <line1> if (logger.isDebugEnabled()) { <line2> logger.debug(""Send commit info to others: {}"", remoteCommit); <line3> } <line4> ITopic<RemoteCommit> topic = getHazelcastInstance().getTopic(FF_COMMIT_TOPIC_NAME); <line5> topic.publish(remoteCommit); <line6> } <line7> } <line8> "	"<line2>      logger.debug(""Send commit info to others: {}"", remoteCommit);"	task0	
"public class A { <line0> @Override <line1> public void handleReport(VloReport report) { <line2> logger.info( <line3> (noop ? ""NOT sending"" : ""Sending"") + "" reports to statsd server {}:{} with prefix '{}'"", <line4> statsdHost, <line5> statsdPort, <line6> statsdPrefix); <line7> final StatsDClient client = newClient(); <line8> try { <line9> final VloReport previousReport = getPreviousReport(); <line10> try { <line11> client.gauge(""nrRecords"", report.getRecordCount()); <line12> report.getCollections().stream() <line13> .forEach( <line14> (collection) -> { <line15> client.gauge( <line16> COLLECTION_METRIC_PREFIX + normaliseMetricName(collection.getCollection()), <line17> collection.getCount()); <line18> }); <line19> report.getFacets().stream() <line20> .forEach( <line21> (facet) -> { <line22> client.gauge( <line23> FACET_METRIC_PREFIX + normaliseMetricName(facet.getName()), <line24> facet.getValueCount()); <line25> }); <line26> if (previousReport != null) { <line27> resetRemovedCollections(previousReport, report, client); <line28> resetRemovedFacets(previousReport, report, client); <line29> } <line30> } finally { <line31> try { <line32> client.stop(); <line33> } finally { <line34> updateReportHistory(report); <line35> } <line36> } <line37> } catch (JAXBException ex) { <line38> throw new RuntimeException(""Could not (un)marshall report history for statsd"", ex); <line39> } <line40> } <line41> } <line42> "	"<line2>    logger.info((noop ? ""NOT sending"" : ""Sending"") + "" reports to statsd server {}:{} with prefix '{}'"",statsdHost,statsdPort,statsdPrefix);"	task0	
"public class A { <line0> @Override <line1> public void initializeForN(SieveParams sieveParams, int mergedBaseSize) { <line2> this.pMinIndex = sieveParams.pMinIndex; <line3> int pMax = sieveParams.pMax; <line4> this.initializer = sieveParams.initializer; <line5> this.sieveArraySize = sieveParams.sieveArraySize; <line6> int sieveAllocationSize = Math.max(pMax + 1, 2 * sieveArraySize); <line7> sieveArrayAddress = UnsafeUtil.allocateMemory(sieveAllocationSize); <line8> if (DEBUG) <line9> LOG.debug( <line10> ""pMax = "" <line11> + pMax <line12> + "", sieveArraySize = "" <line13> + sieveArraySize <line14> + "" --> sieveAllocationSize = "" <line15> + sieveAllocationSize); <line16> if (ANALYZE) initDuration = sieveDuration = collectDuration = 0; <line17> } <line18> } <line19> "	"<line9>      LOG.debug(""pMax = ""+ pMax+ "", sieveArraySize = ""+ sieveArraySize+ "" --> sieveAllocationSize = ""+ sieveAllocationSize);"	task0	
"public class A { <line0> private void addPeekedEvents(List<GatewaySenderEventImpl> batch, int batchSize) { <line1> if (this.resetLastPeeked) { <line2> Object[] helpArray = peekedEvents.toArray(); <line3> if (helpArray.length > 0) { <line4> for (int i = helpArray.length - 1; i >= 0; i--) { <line5> GatewaySenderEventImpl event = (GatewaySenderEventImpl) helpArray[i]; <line6> final int bucketId = event.getBucketId(); <line7> final PartitionedRegion region = (PartitionedRegion) event.getRegion(); <line8> if (!region.getRegionAdvisor().isPrimaryForBucket(bucketId)) { <line9> peekedEvents.remove(event); <line10> BucketRegionQueue brq = getBucketRegionQueueByBucketId(getRandomShadowPR(), bucketId); <line11> if (brq != null) { <line12> brq.pushKeyIntoQueue(event.getShadowKey()); <line13> } <line14> } <line15> } <line16> } <line17> if (this.peekedEventsProcessingInProgress) { <line18> addPreviouslyPeekedEvents(batch, batchSize); <line19> } else if (peekedEvents.size() <= batchSize) { <line20> batch.addAll(peekedEvents); <line21> this.resetLastPeeked = false; <line22> } else { <line23> this.peekedEventsProcessing.addAll(this.peekedEvents); <line24> this.peekedEventsProcessingInProgress = true; <line25> addPreviouslyPeekedEvents(batch, batchSize); <line26> } <line27> if (logger.isDebugEnabled()) { <line28> StringBuffer buffer = new StringBuffer(); <line29> for (Object ge : batch) { <line30> buffer.append(""event :""); <line31> buffer.append(ge); <line32> } <line33> logger.debug(""Adding already peeked events to the batch {}"", buffer); <line34> } <line35> } <line36> } <line37> } <line38> "	"<line33>        logger.debug(""Adding already peeked events to the batch {}"", buffer);"	task0	
"public class A { <line0> public static String getEffectiveAddress(Exchange exchange, String defaultAddress) { <line1> String retval = exchange.getIn().getHeader(Exchange.DESTINATION_OVERRIDE_URL, String.class); <line2> if (retval == null) { <line3> retval = defaultAddress; <line4> } else { <line5> LOG.trace( <line6> ""Client address is overridden by header '{}' to value '{}'"", <line7> Exchange.DESTINATION_OVERRIDE_URL, <line8> retval); <line9> } <line10> return retval; <line11> } <line12> } <line13> "	"<line5>      LOG.trace(""Client address is overridden by header '{}' to value '{}'"",Exchange.DESTINATION_OVERRIDE_URL,retval);"	task0	
"public class A { <line0> @Override <line1> public void dispose() { <line2> logger.debug(""Handler disposed.""); <line3> cancelJobReference(liveDataPollingJobReference); <line4> cancelJobReference(aggregateDataPollingJobReference); <line5> webInterface.dispose(); <line6> } <line7> } <line8> "	"<line2>    logger.debug(""Handler disposed."");"	task0	
"public class A { <line0> private static RemoteHoodieTableFileSystemView createRemoteFileSystemView( <line1> SerializableConfiguration conf, <line2> FileSystemViewStorageConfig viewConf, <line3> HoodieTableMetaClient metaClient) { <line4> LOG.info( <line5> ""Creating remote view for basePath "" <line6> + metaClient.getBasePath() <line7> + "". Server="" <line8> + viewConf.getRemoteViewServerHost() <line9> + "":"" <line10> + viewConf.getRemoteViewServerPort() <line11> + "", Timeout="" <line12> + viewConf.getRemoteTimelineClientTimeoutSecs()); <line13> return new RemoteHoodieTableFileSystemView( <line14> viewConf.getRemoteViewServerHost(), <line15> viewConf.getRemoteViewServerPort(), <line16> metaClient, <line17> viewConf.getRemoteTimelineClientTimeoutSecs()); <line18> } <line19> } <line20> "	"<line4>    LOG.info(""Creating remote view for basePath ""+ metaClient.getBasePath()+ "". Server=""+ viewConf.getRemoteViewServerHost()+ "":""+ viewConf.getRemoteViewServerPort()+ "", Timeout=""+ viewConf.getRemoteTimelineClientTimeoutSecs());"	task0	
"public class A { <line0> @PostMapping(value = ""/login"") <line1> public String authenticate( <line2> @Valid @ModelAttribute(""loginRequest"") LoginRequest loginRequest, <line3> BindingResult bindingResult, <line4> Model model, <line5> HttpServletRequest request, <line6> HttpServletResponse response) <line7> throws JsonProcessingException, UnsupportedEncodingException { <line8> logger.entry(String.format(""%s request"", request.getRequestURI())); <line9> AuditLogEventRequest auditRequest = AuditEventMapper.fromHttpServletRequest(request); <line10> String tempRegId = cookieHelper.getCookieValue(request, TEMP_REG_ID_COOKIE); <line11> String appId = cookieHelper.getCookieValue(request, APP_ID_COOKIE); <line12> String loginChallenge = cookieHelper.getCookieValue(request, LOGIN_CHALLENGE_COOKIE); <line13> String mobilePlatform = cookieHelper.getCookieValue(request, MOBILE_PLATFORM_COOKIE); <line14> String source = cookieHelper.getCookieValue(request, SOURCE_COOKIE); <line15> String appName = cookieHelper.getCookieValue(request, APP_NAME_COOKIE); <line16> boolean attrsAdded = addAttributesToModel(model, mobilePlatform, source); <line17> if (!attrsAdded) { <line18> return ERROR_VIEW_NAME; <line19> } <line20> if (StringUtils.isNotEmpty(tempRegId)) { <line21> return redirectToLoginOrConsentPage(tempRegId, loginChallenge, response); <line22> } <line23> ValidationErrorResponse errors = validateRequiredParams(request, ""email"", ""password""); <line24> if (bindingResult.hasErrors() || errors.hasErrors()) { <line25> logger.error( <line26> String.format( <line27> ""hasBindingErrors=%b and missing required params=%b, error code=%s"", <line28> bindingResult.hasErrors(), errors.hasErrors(), ErrorCode.INVALID_LOGIN_CREDENTIALS)); <line29> model.addAttribute(ERROR_DESCRIPTION, ErrorCode.INVALID_LOGIN_CREDENTIALS.getDescription()); <line30> return LOGIN_VIEW_NAME; <line31> } <line32> UserRequest user = new UserRequest(); <line33> user.setEmail(loginRequest.getEmail()); <line34> user.setPassword(loginRequest.getPassword()); <line35> user.setAppId(appId); <line36> user.setAppName(appName); <line37> AuthenticationResponse authenticationResponse = userService.authenticate(user, auditRequest); <line38> if (UserAccountStatus.PENDING_CONFIRMATION.getStatus() <line39> == authenticationResponse.getAccountStatus()) { <line40> String redirectUrl = redirectConfig.getAccountActivationUrl(mobilePlatform, source); <line41> String url = String.format(""%s?email=%s"", redirectUrl, loginRequest.getEmail()); <line42> return redirect(response, url); <line43> } <line44> if (authenticationResponse.is2xxSuccessful()) { <line45> logger.exit(""authentication success, redirect to consent page""); <line46> cookieHelper.addCookie(response, USER_ID_COOKIE, authenticationResponse.getUserId()); <line47> cookieHelper.addCookie( <line48> response, <line49> ACCOUNT_STATUS_COOKIE, <line50> String.valueOf(authenticationResponse.getAccountStatus())); <line51> } else { <line52> return LOGIN_VIEW_NAME; <line53> } <line54> return redirectToConsentPage(loginChallenge, authenticationResponse.getUserId(), response); <line55> } <line56> } <line57> "	"<line25>      logger.error(String.format(""hasBindingErrors=%b and missing required params=%b, error code=%s"",bindingResult.hasErrors(), errors.hasErrors(), ErrorCode.INVALID_LOGIN_CREDENTIALS));"	task0	
"public class A { <line0> @Transactional <line1> public void cleanExpiredAuthorizationCodes() { <line2> List<OrcidOauth2AuthoriziationCodeDetail> allAuthorizationCodes = <line3> orcidOauth2AuthoriziationCodeDetailDao.getAll(); <line4> Date now = new Date(); <line5> for (OrcidOauth2AuthoriziationCodeDetail authorizationCode : allAuthorizationCodes) { <line6> Date creationDate = authorizationCode.getDateCreated(); <line7> Calendar c = Calendar.getInstance(); <line8> c.setTime(creationDate); <line9> c.add(Calendar.MINUTE, authorizationCodeExpiration); <line10> Date expirationDate = c.getTime(); <line11> if (expirationDate.before(now)) { <line12> LOG.info(""Authorization code is expired and will be deleted: "" + authorizationCode.getId()); <line13> orcidOauth2AuthoriziationCodeDetailDao.remove(authorizationCode.getId()); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line12>        LOG.info(""Authorization code is expired and will be deleted: "" + authorizationCode.getId());"	task0	
public class A { <line0> public static String getUrlTitleMapAsXML(long cpDefinitionId) throws RemoteException { <line1> try { <line2> String returnValue = CPDefinitionServiceUtil.getUrlTitleMapAsXML(cpDefinitionId); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> log.error(exception, exception); <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line5>      log.error(exception, exception);	task0	
"public class A { <line0> private void putSettings() throws IOException { <line1> ClusterUpdateSettingsRequest request = new ClusterUpdateSettingsRequest(); <line2> String transientSettingKey = <line3> RecoverySettings.INDICES_RECOVERY_MAX_BYTES_PER_SEC_SETTING.getKey(); <line4> int transientSettingValue = 10; <line5> Settings transientSettings = <line6> Settings.builder() <line7> .put(transientSettingKey, transientSettingValue, ByteSizeUnit.BYTES) <line8> .build(); <line9> request.transientSettings(transientSettings); <line10> ClusterUpdateSettingsResponse response = <line11> client.cluster().putSettings(request, RequestOptions.DEFAULT); <line12> if (response == null) { <line13> String message = ""elasticsearch put settings fail.""; <line14> LOGGER.error(message); <line15> throw new RuntimeException(message); <line16> } <line17> } <line18> } <line19> "	<line14>      LOGGER.error(message);	task0	
"public class A { <line0> private boolean updateSuccessfullJobStatus(String objectKey) { <line1> LOG.trace(""Update successful job: for {}"", objectKey); <line2> if (objectKey.endsWith(""/"")) { <line3> objectKey = objectKey.substring(0, objectKey.length() - 1); <line4> } <line5> if (!mCachedSparkJobsStatus.containsKey(objectKey)) { <line6> mCachedSparkJobsStatus.put(objectKey, Boolean.TRUE); <line7> } <line8> return true; <line9> } <line10> } <line11> "	"<line1>    LOG.trace(""Update successful job: for {}"", objectKey);"	task0	
"public class A { <line0> @Override <line1> public List<String> getURLsFromPage(Document doc) { <line2> List<String> imageURLs = new ArrayList<>(); <line3> JSONObject json; <line4> try { <line5> getXAuthToken(); <line6> if (xAuthToken == null || xAuthToken.isEmpty()) { <line7> throw new IOException(""No xAuthToken found.""); <line8> } <line9> json = <line10> Http.url(jsonurl) <line11> .cookies(cookies) <line12> .data(""X-Auth"", xAuthToken) <line13> .data(""hash"", getGID(url)) <line14> .data(""_"", Long.toString(System.currentTimeMillis())) <line15> .getJSON(); <line16> } catch (IOException e) { <line17> LOGGER.error(""Couldnt fetch images."", e.getCause()); <line18> return imageURLs; <line19> } <line20> JSONArray imageArray = json.getJSONArray(""images""); <line21> for (int i = 0; i < imageArray.length(); i++) { <line22> imageURLs.add(""https:"" + imageArray.getJSONObject(i).getString(""imageUrl"")); <line23> } <line24> return imageURLs; <line25> } <line26> } <line27> "	"<line17>      LOGGER.error(""Couldnt fetch images."", e.getCause());"	task0	
"public class A { <line0> public static java.util.List<com.liferay.portal.kernel.model.Group> getUserOrganizationsGroups( <line1> HttpPrincipal httpPrincipal, long userId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> GroupServiceUtil.class, <line7> ""getUserOrganizationsGroups"", <line8> _getUserOrganizationsGroupsParameterTypes22); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, userId, start, end); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.portal.kernel.model.Group>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.error(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line21>      log.error(systemException, systemException);	task0	
"public class A { <line0> public SysUser getUserByName(String name, String password) throws Exception { <line1> SysUser sysUser = null; <line2> try (SqlSession sqlSession = MyBatisUtil.getSqlSession()) { <line3> HashMap<String, Object> mapParams = new HashMap<>(); <line4> mapParams.put(""name"", name); <line5> mapParams.put(""password"", password); <line6> Map<String, Object> params = new HashMap<>(); <line7> params.put(""mapParams"", mapParams); <line8> sysUser = sqlSession.selectOne(GET_USER_BY_NAME_STATEMENT, params); <line9> } catch (Exception e) { <line10> LOG.error(e.getMessage(), e); <line11> throw new Exception(e); <line12> } <line13> return sysUser; <line14> } <line15> } <line16> "	<line10>      LOG.error(e.getMessage(), e);	task0	
"public class A { <line0> public ExoSocialActivity process(ExoSocialActivity i18nActivity, Locale selectedLocale) { <line1> if (i18nActivity.getTitleId() != null) { <line2> if (activityTypeRegistered(i18nActivity)) { <line3> ResourceBundle resourceBundle = getResourceBundle(i18nActivity, selectedLocale); <line4> if (resourceBundle == null) { <line5> LOG.warn( <line6> ""no resource bundle key found registered for: "" <line7> + getResourceBundleKeyFile(i18nActivity)); <line8> return i18nActivity; <line9> } <line10> if (!getMessageBundleKeys(i18nActivity)) { <line11> return i18nActivity; <line12> } <line13> transformKeys(i18nActivity, resourceBundle); <line14> } <line15> } <line16> return i18nActivity; <line17> } <line18> } <line19> "	"<line5>          LOG.warn(""no resource bundle key found registered for: ""+ getResourceBundleKeyFile(i18nActivity));"	task0	
"public class A { <line0> private void writeMenu() throws IOException { <line1> writeln(""<div class='noPrint'> ""); <line2> writeln(""<div id='menuBox' class='menuHide'>""); <line3> writeln( <line4> ""  <ul id='menuTab'><li><a href='javascript:toggleMenuBox();'><img id='menuToggle'"" <line5> + "" src='?resource=menu.png' alt='menu' /></a></li></ul>""); <line6> writeln(""  <div id='menuLinks'><div id='menuDeco'>""); <line7> for (final Map.Entry<String, String> entry : menuTextsByAnchorName.entrySet()) { <line8> final String anchorName = entry.getKey(); <line9> final String menuText = entry.getValue(); <line10> writeDirectly( <line11> ""    <div class='menuButton'><a href='#"" + anchorName + ""'>"" + menuText + ""</a></div>""); <line12> writeln(""""); <line13> } <line14> final String customReports = Parameter.CUSTOM_REPORTS.getValue(); <line15> if (customReports != null) { <line16> for (final String customReport : customReports.split("","")) { <line17> final String customReportName = customReport.trim(); <line18> final String customReportPath = Parameters.getParameterValueByName(customReportName); <line19> if (customReportPath == null) { <line20> LOG.debug(""Parameter not defined in web.xml for custom report: "" + customReportName); <line21> continue; <line22> } <line23> writeDirectly( <line24> ""    <div class='menuButton'><a href='?report="" <line25> + URLEncoder.encode(customReportName, ""UTF-8"") <line26> + ""'>"" <line27> + htmlEncode(customReportName) <line28> + ""</a></div>""); <line29> writeln(""""); <line30> } <line31> } <line32> if (SessionListener.getCurrentSession() != null) { <line33> writeDirectly( <line34> ""    <div class='menuButton'><a href='?action=logout"" <line35> + getCsrfTokenUrlPart() <line36> + ""'>"" <line37> + I18N.getString(""logout"") <line38> + ""</a></div>""); <line39> writeln(""""); <line40> } <line41> writeln(""  </div></div>""); <line42> writeln(""</div></div>""); <line43> } <line44> } <line45> "	"<line20>          LOG.debug(""Parameter not defined in web.xml for custom report: "" + customReportName);"	task0	
"public class A { <line0> protected Entity setupAndCheckTestEntityInBasicYamlWith(String... extras) throws Exception { <line1> managementContextInjected.set(false); <line2> configKeys.clear(); <line3> Entity app = createAndStartApplication(loadYaml(""test-entity-basic-template.yaml"", extras)); <line4> waitForApplicationTasks(app); <line5> Assert.assertEquals(app.getDisplayName(), ""test-entity-basic-template""); <line6> log.info(""App started:""); <line7> Entities.dumpInfo(app); <line8> Assert.assertTrue(app.getChildren().iterator().hasNext(), ""Expected app to have child entity""); <line9> Entity entity = app.getChildren().iterator().next(); <line10> Assert.assertTrue( <line11> entity instanceof TestEntity, ""Expected TestEntity, found "" + entity.getClass()); <line12> return (TestEntity) entity; <line13> } <line14> } <line15> "	"<line6>    log.info(""App started:"");"	task0	
"public class A { <line0> public static String json2xml(String jsonStr, Boolean pretty) { <line1> try { <line2> JSONObject jsonObj = new JSONObject(jsonStr); <line3> if (pretty) { <line4> return XmlTool.normalize(toXMLString(jsonObj, null)); <line5> } else { <line6> return toXMLString(jsonObj, null); <line7> } <line8> } catch (Exception e) { <line9> logger.debug( <line10> ""json2xml(): unable to parse json and convert to xml. Exception was: {}"", <line11> e.toString(), <line12> e); <line13> return null; <line14> } <line15> } <line16> } <line17> "	"<line9>      logger.debug(""json2xml(): unable to parse json and convert to xml. Exception was: {}"",e.toString(),e);"	task0	
"public class A { <line0> public String getEncoding(String fileName) throws Exception { <line1> String path; <line2> if (fileName.endsWith("".tmp"")) { <line3> path = PentahoSystem.getApplicationContext().getSolutionPath(TMP_FILE_PATH); <line4> } else { <line5> String relativePath = <line6> PentahoSystem.getSystemSetting( <line7> ""file-upload-defaults/relative-path"", <line8> String.valueOf(DEFAULT_RELATIVE_UPLOAD_FILE_PATH)); <line9> path = PentahoSystem.getApplicationContext().getSolutionPath(relativePath); <line10> } <line11> String fileLocation = path + fileName; <line12> String encoding; <line13> try { <line14> byte[] bytes = new byte[1024]; <line15> InputStream inputStream = new FileInputStream(new File(fileLocation)); <line16> inputStream.read(bytes); <line17> CharsetDetector charsetDetector = new CharsetDetector(); <line18> charsetDetector.setText(bytes); <line19> CharsetMatch charsetMatch = charsetDetector.detect(); <line20> encoding = charsetMatch.getName(); <line21> inputStream.close(); <line22> } catch (Exception e) { <line23> log.error(e); <line24> throw e; <line25> } <line26> return encoding; <line27> } <line28> } <line29> "	<line23>      log.error(e);	task0	
public class A { <line0> public boolean saveAgentConfigFromUI( <line1> String agentId, <line2> String toolCategory, <line3> String labelName, <line4> String toolName, <line5> JsonObject agentJson, <line6> String agentVersion, <line7> String osversion, <line8> Date updateDate, <line9> boolean vault, <line10> boolean isWebhook) { <line11> AgentConfig agentConfig = new AgentConfig(); <line12> try { <line13> setAgentConfigValues( <line14> agentConfig, <line15> toolCategory, <line16> labelName, <line17> agentId, <line18> toolName, <line19> agentJson, <line20> agentVersion, <line21> osversion, <line22> updateDate, <line23> vault, <line24> isWebhook); <line25> save(agentConfig); <line26> } catch (Exception e) { <line27> log.error(e.getMessage()); <line28> throw e; <line29> } <line30> return Boolean.TRUE; <line31> } <line32> } <line33> 	<line27>      log.error(e.getMessage());	task0	
"public class A { <line0> public void checkProduce(T item) { <line1> if (countdownLatch.getCount() < numWorkers) { <line2> LOG.info(""Fewer workers detected: {}"", countdownLatch.getCount()); <line3> drain(); <line4> start(); <line5> } <line6> produce(item); <line7> } <line8> } <line9> "	"<line2>      LOG.info(""Fewer workers detected: {}"", countdownLatch.getCount());"	task0	
"public class A { <line0> public MatchingResult match(List<HashMap<String, String>> travelers, Set<String> foundDerogIds) { <line1> this.prepareAttributes(travelers); <line2> HashMap<String, DerogResponse> responses = new HashMap<>(); <line3> String gtasId; <line4> DerogResponse thisResponse; <line5> for (HashMap<String, String> trav : travelers) { <line6> thisResponse = matchTraveler(trav, foundDerogIds); <line7> gtasId = thisResponse.getGtasId(); <line8> if (responses.containsKey(gtasId)) { <line9> responses.get(gtasId).addDerogIds(thisResponse.getDerogIds()); <line10> } else { <line11> responses.put(thisResponse.getGtasId(), thisResponse); <line12> } <line13> } <line14> for (HashMap<String, String> trav : travelers) { <line15> if (!responses.containsKey(trav.get(""gtasId""))) { <line16> logger.warn( <line17> ""Valid traveler with gtasId {} was dropped from response list."", trav.get(""gtasId"")); <line18> } <line19> } <line20> int totalHits = 0; <line21> for (DerogResponse resp : responses.values()) { <line22> totalHits += resp.getDerogIds().size(); <line23> } <line24> return new MatchingResult(totalHits, responses); <line25> } <line26> } <line27> "	"<line16>        logger.warn(""Valid traveler with gtasId {} was dropped from response list."", trav.get(""gtasId""));"	task0	
"public class A { <line0> @Override <line1> public void orderBefore( <line2> @NotNull AccessControlEntry srcEntry, @Nullable AccessControlEntry destEntry) <line3> throws RepositoryException { <line4> EntryImpl src = validateEntry(srcEntry); <line5> EntryImpl dest = (destEntry == null) ? null : validateEntry(destEntry); <line6> if (src.equals(dest)) { <line7> log.debug(""'srcEntry' equals 'destEntry' -> no reordering.""); <line8> return; <line9> } <line10> int index = -1; <line11> if (dest != null) { <line12> index = entries.indexOf(dest); <line13> if (index < 0) { <line14> throw new AccessControlException( <line15> ""Destination entry not contained in this AccessControlList.""); <line16> } <line17> } <line18> if (entries.remove(src)) { <line19> if (index != -1) { <line20> entries.add(index, src); <line21> } else { <line22> entries.add(src); <line23> } <line24> } else { <line25> throw new AccessControlException(""Source entry not contained in this AccessControlList""); <line26> } <line27> } <line28> } <line29> "	"<line7>      log.debug(""'srcEntry' equals 'destEntry' -> no reordering."");"	task0	
"public class A { <line0> public boolean deleteAffinityGroup(final String affinityGroupName, final long endTime) <line1> throws MicrosoftAzureException, TimeoutException, InterruptedException { <line2> if (!affinityExists(affinityGroupName)) { <line3> return true; <line4> } <line5> logger.info(""Deleting affinity group : "" + affinityGroupName); <line6> ClientResponse response = doDelete(""/affinitygroups/"" + affinityGroupName); <line7> String requestId = extractRequestId(response); <line8> waitForRequestToFinish(requestId, endTime); <line9> logger.fine(""Deleted affinity group : "" + affinityGroupName); <line10> return true; <line11> } <line12> } <line13> "	"<line5>    logger.info(""Deleting affinity group : "" + affinityGroupName);"	task0	
"public class A { <line0> public RequestStatus deleteObligations(String id, User user) throws SW360Exception { <line1> Obligation oblig = obligRepository.get(id); <line2> assertNotNull(oblig); <line3> if (PermissionUtils.isUserAtLeast(UserGroup.SW360_ADMIN, user)) { <line4> obligRepository.remove(oblig); <line5> return RequestStatus.SUCCESS; <line6> } else { <line7> log.error(user + "" does not have the permission to delete oblig.""); <line8> return RequestStatus.ACCESS_DENIED; <line9> } <line10> } <line11> } <line12> "	"<line7>      log.error(user + "" does not have the permission to delete oblig."");"	task0	
"public class A { <line0> public List<DrugSearchTo1> fullSearch(String s) { <line1> RxDrugRef dr = new RxDrugRef(); <line2> List<DrugSearchTo1> drugs = new ArrayList<DrugSearchTo1>(); <line3> try { <line4> Vector<Hashtable> v = (Vector<Hashtable>) dr.list_drug_element(s); <line5> DrugSearchTo1 temp; <line6> for (Hashtable h : v) { <line7> temp = new DrugSearchTo1(); <line8> temp.setName((String) h.get(""name"")); <line9> if (h.containsKey(""isInactive"")) { <line10> temp.setActive(!((Boolean) h.get(""isInactive""))); <line11> } <line12> temp.setId((Integer) h.get(""id"")); <line13> temp.setCategory((Integer) h.get(""category"")); <line14> drugs.add(temp); <line15> } <line16> } catch (Exception e) { <line17> logger.error(""fullSearch Error"", e); <line18> return null; <line19> } <line20> return drugs; <line21> } <line22> } <line23> "	"<line17>      logger.error(""fullSearch Error"", e);"	task0	
public class A { <line0> @PermitAll <line1> public void updateMetric(BaseQueryMetric metric) throws Exception { <line2> DatawavePrincipal dp = getPrincipal(); <line3> if (metric.getLastWrittenHash() != metric.hashCode()) { <line4> metric.setLastWrittenHash(metric.hashCode()); <line5> try { <line6> metric.setLastUpdated(new Date()); <line7> sendQueryMetric(dp, metric); <line8> Iterator<PageMetric> itr = metric.getPageTimes().iterator(); <line9> while (metric.getPageTimes().size() > 1) { <line10> itr.next(); <line11> itr.remove(); <line12> } <line13> } catch (Exception e) { <line14> log.error(e.getMessage(), e); <line15> } <line16> } <line17> } <line18> } <line19> 	<line14>        log.error(e.getMessage(), e);	task0	
"public class A { <line0> private void process(FileDataObject object) { <line1> URI id = object.getID(); <line2> try { <line3> int minimumArrayLength = mimeTypeIdentifier.getMinArrayLength(); <line4> int bufferSize = Math.max(minimumArrayLength, 8192); <line5> BufferedInputStream buffer = new BufferedInputStream(object.getContent(), bufferSize); <line6> buffer.mark(minimumArrayLength + 10); <line7> byte[] bytes = IOUtil.readBytes(buffer, minimumArrayLength); <line8> String mimeType = mimeTypeIdentifier.identify(bytes, null, id); <line9> if (mimeType != null) { <line10> RDFContainer metadata = object.getMetadata(); <line11> metadata.add(NIE.mimeType, mimeType); <line12> buffer.reset(); <line13> Set extractors = extractorRegistry.get(mimeType); <line14> if (!extractors.isEmpty()) { <line15> ExtractorFactory factory = (ExtractorFactory) extractors.iterator().next(); <line16> Extractor extractor = factory.get(); <line17> extractor.extract(id, buffer, null, mimeType, metadata); <line18> } <line19> } <line20> } catch (Exception e) { <line21> logger.error(""ExtractorException while processing "" + id, e); <line22> } <line23> } <line24> } <line25> "	"<line21>      logger.error(""ExtractorException while processing "" + id, e);"	task0	
"public class A { <line0> @BeforeAll <line1> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line2> public static void startThriftServer() throws Exception { <line3> processor = new Calculator.Processor(new CalculatorSyncServerImpl()); <line4> TSSLTransportFactory.TSSLTransportParameters sslParams = <line5> new TSSLTransportFactory.TSSLTransportParameters(); <line6> sslParams.setKeyStore(KEY_STORE_SOURCE, SECURITY_STORE_PASSWORD); <line7> serverTransport = <line8> TSSLTransportFactory.getServerSocket( <line9> THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT, InetAddress.getByName(""localhost""), sslParams); <line10> TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport); <line11> args.processor(processor); <line12> server = new TThreadPoolServer(args); <line13> Runnable simple = <line14> new Runnable() { <line15> public void run() { <line16> LOG.info(""Thrift secured server started on port: {}"", THRIFT_TEST_PORT); <line17> server.serve(); <line18> } <line19> }; <line20> new Thread(simple).start(); <line21> } <line22> } <line23> "	"<line16>            LOG.info(""Thrift secured server started on port: {}"", THRIFT_TEST_PORT);"	task0	
"public class A { <line0> @Override <line1> public void notifyChannelInactive(Channel channel) { <line2> if (isClosed()) { <line3> RedisException closed = new RedisException(""Connection closed""); <line4> cancelCommands(""Connection closed"", drainCommands(), it -> it.completeExceptionally(closed)); <line5> } <line6> sharedLock.doExclusive( <line7> () -> { <line8> if (debugEnabled) { <line9> logger.debug(""{} deactivating endpoint handler"", logPrefix()); <line10> } <line11> connectionFacade.deactivated(); <line12> }); <line13> if (this.channel == channel) { <line14> this.channel = null; <line15> } <line16> } <line17> } <line18> "	"<line9>            logger.debug(""{} deactivating endpoint handler"", logPrefix());"	task0	
"public class A { <line0> private PercentilesResult queryGraphQueryWithPercentilesAggregation( <line1> String propertyName, <line2> Visibility visibility, <line3> Authorizations authorizations, <line4> double... percents) { <line5> Query q = graph.query(authorizations).limit(0); <line6> PercentilesAggregation agg = <line7> new PercentilesAggregation(""percentiles"", propertyName, visibility); <line8> agg.setPercents(percents); <line9> if (!q.isAggregationSupported(agg)) { <line10> LOGGER.warn(""%s unsupported"", StatisticsAggregation.class.getName()); <line11> return null; <line12> } <line13> q.addAggregation(agg); <line14> return q.vertices().getAggregationResult(""percentiles"", PercentilesResult.class); <line15> } <line16> } <line17> "	"<line10>      LOGGER.warn(""%s unsupported"", StatisticsAggregation.class.getName());"	task0	
"public class A { <line0> public boolean unmount(final SheetCallback callback, final Runnable disconnected) { <line1> if (log.isDebugEnabled()) { <line2> log.debug(String.format(""Unmount session %s"", pool)); <line3> } <line4> if (this.isConnected()) { <line5> if (preferences.getBoolean(""browser.disconnect.confirm"")) { <line6> final NSAlert alert = <line7> NSAlert.alert( <line8> MessageFormat.format( <line9> LocaleFactory.localizedString(""Disconnect from {0}""), <line10> pool.getHost().getHostname()), <line11> LocaleFactory.localizedString(""The connection will be closed.""), <line12> LocaleFactory.localizedString(""Disconnect""), <line13> LocaleFactory.localizedString(""Cancel""), <line14> null); <line15> alert.setShowsSuppressionButton(true); <line16> alert <line17> .suppressionButton() <line18> .setTitle(LocaleFactory.localizedString(""Don't ask again"", ""Configuration"")); <line19> this.alert( <line20> alert, <line21> new SheetCallback() { <line22> @Override <line23> public void callback(int returncode) { <line24> if (alert.suppressionButton().state() == NSCell.NSOnState) { <line25> preferences.setProperty(""browser.disconnect.confirm"", false); <line26> } <line27> callback.callback(returncode); <line28> } <line29> }); <line30> return false; <line31> } <line32> } <line33> this.doUnmount(disconnected); <line34> return true; <line35> } <line36> } <line37> "	"<line2>      log.debug(String.format(""Unmount session %s"", pool));"	task0	
"public class A { <line0> private void setDbUpdateDate(String dateString, String timeString) { <line1> try { <line2> Date date = new SimpleDateFormat(DB_UPDATE_DATE_FORMAT).parse(dateString + "" "" + timeString); <line3> if (this.lastDbUpdateDate == null || date.after(this.lastDbUpdateDate)) { <line4> scanForDevices(); <line5> this.lastDbUpdateDate = date; <line6> } <line7> } catch (ParseException e) { <line8> logger.warn(""Failed to parse DB update date {} {}"", dateString, timeString); <line9> } <line10> } <line11> } <line12> "	"<line8>      logger.warn(""Failed to parse DB update date {} {}"", dateString, timeString);"	task0	
"public class A { <line0> private static ImmutableList<File> getStandaloneDescriptors(@Nullable File pluginsDir) { <line1> if (pluginsDir == null) { <line2> return ImmutableList.of(); <line3> } <line4> File[] pluginDescriptorFiles = <line5> pluginsDir.listFiles( <line6> new FilenameFilter() { <line7> @Override <line8> public boolean accept(File dir, String name) { <line9> return name.endsWith("".json""); <line10> } <line11> }); <line12> if (pluginDescriptorFiles == null) { <line13> logger.warn(""listFiles() returned null on directory: {}"", pluginsDir.getAbsolutePath()); <line14> return ImmutableList.of(); <line15> } <line16> return ImmutableList.copyOf(pluginDescriptorFiles); <line17> } <line18> } <line19> "	"<line13>      logger.warn(""listFiles() returned null on directory: {}"", pluginsDir.getAbsolutePath());"	task0	
"public class A { <line0> public static void logError(final Span span, final Throwable error) { <line1> if (error instanceof NullPointerException <line2> || error instanceof IllegalArgumentException <line3> || error instanceof IllegalStateException) { <line4> LOG.warn(""An unexpected error occurred!"", error); <line5> } <line6> if (span != null) { <line7> logError(span, getErrorLogItems(error)); <line8> } <line9> } <line10> } <line11> "	"<line4>      LOG.warn(""An unexpected error occurred!"", error);"	task0	
"public class A { <line0> public static com.liferay.portal.kernel.repository.model.Folder copyFolder( <line1> HttpPrincipal httpPrincipal, <line2> long repositoryId, <line3> long sourceFolderId, <line4> long parentFolderId, <line5> String name, <line6> String description, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(DLAppServiceUtil.class, ""copyFolder"", _copyFolderParameterTypes15); <line12> MethodHandler methodHandler = <line13> new MethodHandler( <line14> methodKey, <line15> repositoryId, <line16> sourceFolderId, <line17> parentFolderId, <line18> name, <line19> description, <line20> serviceContext); <line21> Object returnObj = null; <line22> try { <line23> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line24> } catch (Exception exception) { <line25> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line26> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line27> } <line28> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line29> } <line30> return (com.liferay.portal.kernel.repository.model.Folder) returnObj; <line31> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line32> log.error(systemException, systemException); <line33> throw systemException; <line34> } <line35> } <line36> } <line37> "	<line32>      log.error(systemException, systemException);	task0	
"public class A { <line0> public void save() { <line1> originalProperties = System.getProperties(); <line2> System.setProperties(copyOf(originalProperties)); <line3> logger.debug(""Set new properties.""); <line4> } <line5> } <line6> "	"<line3>    logger.debug(""Set new properties."");"	task0	
"public class A { <line0> private SocketChannel createAsyncChannel(String host, int port, LRMIMethod lrmiMethod) <line1> throws IOException { <line2> if (logger.isDebugEnabled()) { <line3> logger.debug( <line4> ""connecting new socket channel to "" <line5> + host <line6> + "":"" <line7> + port <line8> + "", connect timeout="" <line9> + _config.getSocketConnectTimeout() <line10> + "" keepalive="" <line11> + LRMIUtilities.KEEP_ALIVE_MODE); <line12> } <line13> Conversation conversation = new Conversation(new InetSocketAddress(host, port)); <line14> if (_protocolValidationEnabled) { <line15> conversation.addChat(new WriteBytesChat(ProtocolValidation.getProtocolHeaderBytes())); <line16> } <line17> RequestPacket requestPacket = <line18> new RequestPacket(new HandshakeRequest(PlatformLogicalVersion.getLogicalVersion())); <line19> requestPacket.operationPriority = <line20> getOperationPriority(lrmiMethod, LRMIInvocationContext.getCurrentContext()); <line21> conversation.addChat(new LRMIChat(requestPacket)); <line22> try { <line23> SettableFuture<Conversation> future = clientConversationRunner.addConversation(conversation); <line24> if (_config.getSocketConnectTimeout() == 0) { <line25> future.get(); <line26> } else { <line27> future.get(_config.getSocketConnectTimeout(), TimeUnit.MILLISECONDS); <line28> } <line29> conversation.channel().configureBlocking(true); <line30> return conversation.channel(); <line31> } catch (Throwable t) { <line32> conversation.close(t); <line33> throw new IOException(t); <line34> } <line35> } <line36> } <line37> "	"<line3>      logger.debug(""connecting new socket channel to ""+ host+ "":""+ port+ "", connect timeout=""+ _config.getSocketConnectTimeout()+ "" keepalive=""+ LRMIUtilities.KEEP_ALIVE_MODE);"	task0	
"public class A { <line0> protected void registerConfigurers(Bundle bundle, List<BaseService> resolvers) { <line1> if (canSee(bundle, GeneratedPropertyConfigurer.class)) { <line2> Map<String, String> configurers = new HashMap<>(); <line3> for (Enumeration<?> e = bundle.getEntryPaths(META_INF_CONFIGURER); <line4> e != null && e.hasMoreElements(); ) { <line5> String path = (String) e.nextElement(); <line6> LOG.debug(""Found configureer: {} in bundle {}"", path, bundle.getSymbolicName()); <line7> String name = path.substring(path.lastIndexOf(""/"") + 1); <line8> configurers.put(name, path); <line9> } <line10> if (!configurers.isEmpty()) { <line11> resolvers.add(new BundleConfigurerResolver(bundle, configurers)); <line12> } <line13> } <line14> } <line15> } <line16> "	"<line6>        LOG.debug(""Found configureer: {} in bundle {}"", path, bundle.getSymbolicName());"	task0	
"public class A { <line0> public void provide(V v) throws Throwable { <line1> if (this.executor == null) { <line2> assert this.exception == null; <line3> this.consumer.accept(v); <line4> } else if (this.exception != null) { <line5> throw this.throwException(); <line6> } else { <line7> try { <line8> this.queue.put(v); <line9> } catch (InterruptedException e) { <line10> LOG.warn(""Interrupted while enqueue"", e); <line11> ; <line12> } <line13> } <line14> } <line15> } <line16> "	"<line10>        LOG.warn(""Interrupted while enqueue"", e);"	task0	
"public class A { <line0> List<URL> getTemplateExportedURLs(URL subscribedURL, List<ServiceInstance> serviceInstances) { <line1> DubboMetadataService dubboMetadataService = getProxy(serviceInstances); <line2> List<URL> templateExportedURLs = emptyList(); <line3> if (dubboMetadataService != null) { <line4> templateExportedURLs = getExportedURLs(dubboMetadataService, subscribedURL); <line5> } else { <line6> if (logger.isWarnEnabled()) { <line7> logger.warn( <line8> ""The metadata of Dubbo service[key : {}] still can't be found, it could effect the"" <line9> + "" further Dubbo service invocation"", <line10> subscribedURL.getServiceKey()); <line11> } <line12> } <line13> return templateExportedURLs; <line14> } <line15> } <line16> "	"<line7>        logger.warn(""The metadata of Dubbo service[key : {}] still can't be found, it could effect the""+ "" further Dubbo service invocation"",subscribedURL.getServiceKey());"	task0	
"public class A { <line0> @SuppressFBWarnings( <line1> value = ""RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE"", <line2> justification = ""False positive by try with resources."") <line3> public Locale[] getAvailableLocales() { <line4> synchronized (LOCKS.get(LocksKeys.LOCALES)) { <line5> if (locales == null) { <line6> List<Locale> l = new ArrayList<>(); <line7> try (InputStream in = SettingsService.class.getResourceAsStream(LOCALES_FILE)) { <line8> String[] lines = StringUtil.readLines(in); <line9> for (String line : lines) { <line10> l.add(StringUtil.parseLocale(line)); <line11> } <line12> } catch (IOException x) { <line13> if (LOG.isErrorEnabled()) { <line14> LOG.error(""Failed to resolve list of locales."", x); <line15> } <line16> l.add(Locale.ENGLISH); <line17> } <line18> locales = l.toArray(new Locale[0]); <line19> } <line20> } <line21> return locales; <line22> } <line23> } <line24> "	"<line14>            LOG.error(""Failed to resolve list of locales."", x);"	task0	
"public class A { <line0> @Override <line1> public long getUpperBound() { <line2> MongoDBAuditBackend auditService = <line3> (MongoDBAuditBackend) Framework.getService(AuditReader.class); <line4> QueryBuilder queryBuilder = <line5> new AuditQueryBuilder().predicate(Predicates.gt(""eventDate"", new Date(0))); <line6> queryBuilder.order(OrderByExprs.desc(LOG_ID)); <line7> queryBuilder.limit(1); <line8> List<LogEntry> entries = auditService.queryLogs(queryBuilder); <line9> if (entries.isEmpty()) { <line10> log.debug(""Found no audit log entries, returning -1""); <line11> return -1; <line12> } <line13> return entries.get(0).getId(); <line14> } <line15> } <line16> "	"<line10>      log.debug(""Found no audit log entries, returning -1"");"	task0	
"public class A { <line0> public Page<DatabaseConnectionDto> findAllDatabaseConnections(final Pageable pageable) { <line1> log.debug(""findAllDatabaseConnections() - pageable: {}"", pageable); <line2> final Page<DatabaseConnection> databaseConnections = <line3> databaseConnectionService.findAll(pageable); <line4> return databaseConnectionToDatabaseConnectionDtoConverter.convertToPage(databaseConnections); <line5> } <line6> } <line7> "	"<line1>    log.debug(""findAllDatabaseConnections() - pageable: {}"", pageable);"	task0	
"public class A { <line0> @Override <line1> public void addStringField(String fieldName, String value) { <line2> if (logger.isTraceEnabled()) { <line3> logger.trace(""addStringField fieldName: {}; value: {}"", fieldName, value); <line4> } <line5> fieldList.add(new JSONFieldHolder(fieldName, value, FieldType.STRING)); <line6> } <line7> } <line8> "	"<line3>      logger.trace(""addStringField fieldName: {}; value: {}"", fieldName, value);"	task0	
"public class A { <line0> private static Map<String, InetAddress> testResolve0( <line1> DnsNameResolver resolver, Set<String> excludedDomains, DnsRecordType cancelledType) <line2> throws InterruptedException { <line3> assertThat(resolver.isRecursionDesired(), is(true)); <line4> final Map<String, InetAddress> results = new HashMap<String, InetAddress>(); <line5> final Map<String, Future<InetAddress>> futures = <line6> new LinkedHashMap<String, Future<InetAddress>>(); <line7> for (String name : DOMAINS) { <line8> if (excludedDomains.contains(name)) { <line9> continue; <line10> } <line11> resolve(resolver, futures, name); <line12> } <line13> for (Entry<String, Future<InetAddress>> e : futures.entrySet()) { <line14> String unresolved = e.getKey(); <line15> InetAddress resolved = e.getValue().sync().getNow(); <line16> logger.info(""{}: {}"", unresolved, resolved.getHostAddress()); <line17> assertThat(resolved.getHostName(), is(unresolved)); <line18> boolean typeMatches = false; <line19> for (InternetProtocolFamily f : resolver.resolvedInternetProtocolFamiliesUnsafe()) { <line20> Class<?> resolvedType = resolved.getClass(); <line21> if (f.addressType().isAssignableFrom(resolvedType)) { <line22> typeMatches = true; <line23> } <line24> } <line25> assertThat(typeMatches, is(true)); <line26> results.put(resolved.getHostName(), resolved); <line27> } <line28> assertQueryObserver(resolver, cancelledType); <line29> return results; <line30> } <line31> } <line32> "	"<line16>      logger.info(""{}: {}"", unresolved, resolved.getHostAddress());"	task0	
"public class A { <line0> private synchronized @Nullable WorkItemServiceState execute(WorkItemStatus status) <line1> throws IOException { <line2> WorkItemServiceState result = workUnitClient.reportWorkItemStatus(status); <line3> if (result != null) { <line4> nextReportIndex = result.getNextReportIndex(); <line5> if (nextReportIndex == null && !status.getCompleted()) { <line6> LOG.error(""Missing next work index in {} when reporting {}."", result, status); <line7> } <line8> commitMetrics(); <line9> } <line10> if (status.getCompleted()) { <line11> checkState(!finalStateSent, ""cannot reportUpdates after sending a final state""); <line12> finalStateSent = true; <line13> } <line14> return result; <line15> } <line16> } <line17> "	"<line6>        LOG.error(""Missing next work index in {} when reporting {}."", result, status);"	task0	
public class A { <line0> public static void revokeAllOAuth2Authorizations(long oAuth2ApplicationId) <line1> throws RemoteException { <line2> try { <line3> OAuth2AuthorizationServiceUtil.revokeAllOAuth2Authorizations(oAuth2ApplicationId); <line4> } catch (Exception exception) { <line5> log.error(exception, exception); <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	<line5>      log.error(exception, exception);	task0	
"public class A { <line0> private void mapTracks(Rep trackRep) throws IOException, URISyntaxException { <line1> Set<String> paths = getVariants(trackRep.origMpfile); <line2> for (String path : paths) { <line3> String name = FilenameUtils.getName(path); <line4> if (repMap.containsKey(name)) { <line5> Rep rep = repMap.get(name); <line6> rep.newMpuri = trackRep.track.getURI().relativize(rep.origMpuri); <line7> rep.newfileName = relativize(trackRep.origMpuri, rep.origMpuri); <line8> fileMap.put(path, rep.newfileName); <line9> rep.relPath = path; <line10> } else { <line11> logger.warn(""Adaptive Playlist referenced track not found in mediapackage""); <line12> } <line13> } <line14> } <line15> } <line16> "	"<line11>        logger.warn(""Adaptive Playlist referenced track not found in mediapackage"");"	task0	
"public class A { <line0> public Object next(EntityMetadata m) { <line1> Object entity = null; <line2> HBaseData result = ((HBaseReader) hbaseReader).next(); <line3> List<HBaseData> results = new ArrayList<HBaseData>(); <line4> List output = new ArrayList(); <line5> results.add(result); <line6> try { <line7> output = <line8> onRead( <line9> m.getSchema(), <line10> m.getEntityClazz(), <line11> m, <line12> output, <line13> gethTable(m.getSchema()), <line14> entity, <line15> m.getRelationNames(), <line16> results); <line17> } catch (IOException e) { <line18> log.error(""Error during finding next record, Caused by: ."", e); <line19> throw new KunderaException(e); <line20> } <line21> return output != null && !output.isEmpty() ? output.get(0) : output; <line22> } <line23> } <line24> "	"<line18>      log.error(""Error during finding next record, Caused by: ."", e);"	task0	
"public class A { <line0> public void checkIn(Pipeline pipeline) { <line1> if (log.isTraceEnabled()) { <line2> log.trace(""checkIn("" + pipeline + ')'); <line3> } <line4> pipeline.clear(); <line5> checkedOut.remove(pipeline); <line6> checkedIn.add(pipeline); <line7> } <line8> } <line9> "	"<line2>      log.trace(""checkIn("" + pipeline + ')');"	task0	
"public class A { <line0> public void close() { <line1> if (pending.isEmpty()) { <line2> try { <line3> if (dir.fileExists(INDEXING_QUEUE_FILE)) { <line4> dir.deleteFile(INDEXING_QUEUE_FILE); <line5> } <line6> } catch (IOException e) { <line7> log.warn(""unable to delete "" + INDEXING_QUEUE_FILE); <line8> } <line9> } <line10> } <line11> } <line12> "	"<line7>        log.warn(""unable to delete "" + INDEXING_QUEUE_FILE);"	task0	
"public class A { <line0> public static long getUserPlacedCommerceOrdersCount( <line1> HttpPrincipal httpPrincipal, long companyId, long groupId, String keywords) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceOrderServiceUtil.class, <line7> ""getUserPlacedCommerceOrdersCount"", <line8> _getUserPlacedCommerceOrdersCountParameterTypes29); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, companyId, groupId, keywords); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Long) returnObj).longValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.error(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	<line21>      log.error(systemException, systemException);	task0	
"public class A { <line0> @Override <line1> protected ServiceTunnelResponse tunnel(final ServiceTunnelRequest serviceRequest) { <line2> if (LOG.isDebugEnabled()) { <line3> LOG.debug( <line4> ""requestSequence {} {}.{}"", <line5> serviceRequest.getRequestSequence(), <line6> serviceRequest.getServiceInterfaceClassName(), <line7> serviceRequest.getOperation()); <line8> } <line9> final long requestSequence = serviceRequest.getRequestSequence(); <line10> final RemoteServiceInvocationCallable remoteInvocationCallable = <line11> createRemoteServiceInvocationCallable(serviceRequest); <line12> final IFuture<ServiceTunnelResponse> future = <line13> Jobs.schedule( <line14> remoteInvocationCallable, <line15> Jobs.newInput() <line16> .withRunContext(RunContext.CURRENT.get().copy()) <line17> .withName(createServiceRequestName(requestSequence)) <line18> .withExceptionHandling(null, false)) <line19> .whenDone( <line20> event -> { <line21> if (event.isCancelled()) { <line22> remoteInvocationCallable.cancel(); <line23> } <line24> }, <line25> RunContext.CURRENT.get().copy().withRunMonitor(BEANS.get(RunMonitor.class))); <line26> try { <line27> return future.awaitDoneAndGet(); <line28> } catch (ThreadInterruptedError e) { <line29> future.cancel(true); <line30> return new ServiceTunnelResponse(new ThreadInterruptedError(""UserInterrupted"")); <line31> } catch (FutureCancelledError e) { <line32> return new ServiceTunnelResponse(new FutureCancelledError(""UserInterrupted"")); <line33> } <line34> } <line35> } <line36> "	"<line3>      LOG.debug(""requestSequence {} {}.{}"",serviceRequest.getRequestSequence(),serviceRequest.getServiceInterfaceClassName(),serviceRequest.getOperation());"	task0	
"public class A { <line0> public synchronized EditorKit createAndSetupNewEditorKit( <line1> EditorKitFactory editorKitFactory, URI uri) throws Exception { <line2> logger.debug( <line3> ""[ProtegeManager] Creating and setting up new EditorKit.  Factory: {}, URI: {}"", <line4> editorKitFactory, <line5> uri); <line6> if (editorKitFactory != null) { <line7> boolean success = false; <line8> EditorKit editorKit = editorKitFactory.createEditorKit(); <line9> try { <line10> if (editorKit.handleLoadFrom(uri)) { <line11> getEditorKitManager().addEditorKit(editorKit); <line12> success = true; <line13> if (getEditorKitManager().getEditorKitCount() == 1) { <line14> firstEditorKit = new WeakReference<>(editorKit); <line15> } <line16> closeFirstEditorKitIfNotModified(); <line17> return editorKit; <line18> } <line19> } finally { <line20> if (!success) { <line21> editorKit.dispose(); <line22> } <line23> } <line24> } <line25> return null; <line26> } <line27> } <line28> "	"<line2>    logger.debug(""[ProtegeManager] Creating and setting up new EditorKit.  Factory: {}, URI: {}"",editorKitFactory,uri);"	task0	
"public class A { <line0> @Override <line1> public Void call(DeleteAssetsOfBranchJobInput input) throws Exception { <line2> logger.debug(""DeleteAssetsOfBranchJob""); <line3> assetService.deleteAssetsOfBranch(input.getAssetIds(), input.getBranchId()); <line4> return null; <line5> } <line6> } <line7> "	"<line2>    logger.debug(""DeleteAssetsOfBranchJob"");"	task0	
"public class A { <line0> private BulkProcessor.Listener buildListener() { <line1> return new Listener() { <line2> @Override <line3> public void beforeBulk(long executionId, BulkRequest request) { <line4> if (requestToRecord != null && inFlightRequests != null) { <line5> List<SinkRecord> sinkRecords = new ArrayList<>(request.requests().size()); <line6> for (DocWriteRequest<?> req : request.requests()) { <line7> sinkRecords.add(requestToRecord.get(req)); <line8> requestToRecord.remove(req); <line9> } <line10> inFlightRequests.put(executionId, sinkRecords); <line11> } <line12> } <line13>  <line14> @Override <line15> public void afterBulk(long executionId, BulkRequest request, BulkResponse response) { <line16> for (BulkItemResponse bulkItemResponse : response) { <line17> handleResponse(bulkItemResponse, executionId); <line18> } <line19> removeFromInFlightRequests(executionId); <line20> numRecords.addAndGet(-response.getItems().length); <line21> } <line22>  <line23> @Override <line24> public void afterBulk(long executionId, BulkRequest request, Throwable failure) { <line25> log.warn(""Bulk request {} failed. Retrying request."", executionId, failure); <line26> try { <line27> BulkResponse bulkResponse = <line28> callWithRetries( <line29> ""retrying bulk request"", () -> client.bulk(request, RequestOptions.DEFAULT)); <line30> afterBulk(executionId, request, bulkResponse); <line31> } catch (ConnectException e) { <line32> removeFromInFlightRequests(executionId); <line33> error.compareAndSet(null, new ConnectException(""Bulk request failed."", e.getCause())); <line34> numRecords.addAndGet(-request.requests().size()); <line35> } <line36> } <line37> }; <line38> } <line39> } <line40> "	"<line25>        log.warn(""Bulk request {} failed. Retrying request."", executionId, failure);"	task0	
public class A { <line0> public static com.liferay.commerce.discount.model.CommerceDiscountAccountRelSoap <line1> addCommerceDiscountAccountRel( <line2> long commerceDiscountId, <line3> long commerceAccountId, <line4> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line5> throws RemoteException { <line6> try { <line7> com.liferay.commerce.discount.model.CommerceDiscountAccountRel returnValue = <line8> CommerceDiscountAccountRelServiceUtil.addCommerceDiscountAccountRel( <line9> commerceDiscountId, commerceAccountId, serviceContext); <line10> return com.liferay.commerce.discount.model.CommerceDiscountAccountRelSoap.toSoapModel( <line11> returnValue); <line12> } catch (Exception exception) { <line13> log.error(exception, exception); <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	<line13>      log.error(exception, exception);	task0	
"public class A { <line0> public static HtmlEmail getHtmlEmail( <line1> String smtpServer, <line2> String smtpPort, <line3> String smtpUser, <line4> String smtpPassword, <line5> String connectionSecurity) <line6> throws EmailException { <line7> logger.debug( <line8> ""smtpServer="" <line9> + smtpServer <line10> + "", smtpSslPort="" <line11> + smtpPort <line12> + "", smtpUser="" <line13> + smtpUser <line14> + "", smtpPassword="" <line15> + smtpPassword <line16> + "",connectionSecurity="" <line17> + connectionSecurity); <line18> HtmlEmail email = null; <line19> if (RECIPIENT_OVERRIDE_KEY != null || printInsteadOfSend) email = new HtmlEmailWrapper(); <line20> else email = new HtmlEmail(); <line21> email.setHostName(smtpServer); <line22> if (smtpUser != null && smtpPassword != null) email.setAuthentication(smtpUser, smtpPassword); <line23> Session session = email.getMailSession(); <line24> if (connectionSecurity != null) { <line25> if (connectionSecurity.equals(CONNECTION_SECURITY_STARTTLS)) { <line26> session.getProperties().setProperty(Email.MAIL_TRANSPORT_TLS, ""true""); <line27> email.setTLS(true); <line28> } else if (connectionSecurity.equals(CONNECTION_SECURITY_SSL)) { <line29> email.setSSL(true); <line30> } <line31> } <line32> if (smtpPort != null) { <line33> email.setSslSmtpPort(smtpPort); <line34> } <line35> Properties properties = session.getProperties(); <line36> properties.setProperty(""mail.smtp.connectiontimeout"", ""20000""); <line37> properties.setProperty(""mail.smtp.timeout"", ""20000""); <line38> return (email); <line39> } <line40> } <line41> "	"<line7>    logger.debug(""smtpServer=""+ smtpServer+ "", smtpSslPort=""+ smtpPort+ "", smtpUser=""+ smtpUser+ "", smtpPassword=""+ smtpPassword+ "",connectionSecurity=""+ connectionSecurity);"	task0	
"public class A { <line0> private void purgeTask(TaskInProgress tip, boolean wasFailure) throws IOException { <line1> if (tip != null) { <line2> LOG.info(""About to purge task: "" + tip.getTask().getTaskID()); <line3> removeTaskFromJob(tip.getTask().getJobID(), tip); <line4> tip.jobHasFinished(wasFailure); <line5> } <line6> } <line7> } <line8> "	"<line2>      LOG.info(""About to purge task: "" + tip.getTask().getTaskID());"	task0	
"public class A { <line0> public static MetricConfigDTO getMetricConfigFromNameAndDataset( <line1> String metricName, String dataset) { <line2> MetricConfigDTO metricConfig = null; <line3> try { <line4> metricConfig = <line5> CACHE_REGISTRY.getMetricConfigCache().get(new MetricDataset(metricName, dataset)); <line6> } catch (ExecutionException e) { <line7> LOG.error( <line8> ""Exception while fetching metric by name {} and dataset {}"", metricName, dataset, e); <line9> } <line10> return metricConfig; <line11> } <line12> } <line13> "	"<line7>      LOG.error(""Exception while fetching metric by name {} and dataset {}"", metricName, dataset, e);"	task0	
"public class A { <line0> @Override <line1> public HmilyTransaction findByTransId(final Long transId) { <line2> String path = node.getHmilyTransactionRealPath(transId); <line3> try { <line4> if (checkPath(path, true)) { <line5> return null; <line6> } <line7> byte[] data = zooKeeper.getData(path, false, null); <line8> if (data == null) { <line9> return null; <line10> } <line11> return hmilySerializer.deSerialize(data, HmilyTransaction.class); <line12> } catch (KeeperException | InterruptedException e) { <line13> LOGGER.error(""findByTransId occur a exception"", e); <line14> } <line15> return null; <line16> } <line17> } <line18> "	"<line13>      LOGGER.error(""findByTransId occur a exception"", e);"	task0	
"public class A { <line0> public void unsetMediator(final SilvercrestWifiSocketMediator mitsubishiMediator) { <line1> logger.debug(""Mediator has been unsetted from discovery service.""); <line2> this.mediator = null; <line3> } <line4> } <line5> "	"<line1>    logger.debug(""Mediator has been unsetted from discovery service."");"	task0	
"public class A { <line0> void handleAReleaseRPCollision() throws IOException { <line1> enterState(State.Sta12); <line2> LOG.info(""{} << A-RELEASE-RP"", name); <line3> encoder.writeAReleaseRP(); <line4> closeSocketDelayed(); <line5> } <line6> } <line7> "	"<line2>    LOG.info(""{} << A-RELEASE-RP"", name);"	task0	
"public class A { <line0> public void onButtonUpJustPressed() { <line1> log.info(""onButtonUpJustPressed""); <line2> } <line3> } <line4> "	"<line1>    log.info(""onButtonUpJustPressed"");"	task0	
"public class A { <line0> private void setupTasks() { <line1> int poolSize = getEndpoint().getConcurrentConsumers(); <line2> if (executor == null) { <line3> executor = <line4> getEndpoint() <line5> .getCamelContext() <line6> .getExecutorServiceManager() <line7> .newFixedThreadPool(this, getEndpoint().getEndpointUri(), poolSize); <line8> } <line9> int tasks = poolSize - taskCount.get(); <line10> LOG.debug(""Creating {} consumer tasks with poll timeout {} ms."", tasks, pollTimeout); <line11> for (int i = 0; i < tasks; i++) { <line12> executor.execute(this); <line13> } <line14> } <line15> } <line16> "	"<line10>    LOG.debug(""Creating {} consumer tasks with poll timeout {} ms."", tasks, pollTimeout);"	task0	
"public class A { <line0> @Override <line1> public Map<K, ICacheElement<K, V>> getCacheElements(Set<K> names) { <line2> if (names == null) { <line3> log.warn(""Bad input names cannot be null.""); <line4> return Collections.emptyMap(); <line5> } <line6> if (!ensureInit()) { <line7> return Collections.emptyMap(); <line8> } <line9> @SuppressWarnings(""unchecked"") <line10> Set<K>[] dividedNames = new Set[this.getNumberOfPartitions()]; <line11> for (K key : names) { <line12> int partition = getPartitionNumberForKey(key); <line13> if (dividedNames[partition] == null) { <line14> dividedNames[partition] = new HashSet<>(); <line15> } <line16> dividedNames[partition].add(key); <line17> } <line18> Map<K, ICacheElement<K, V>> result = new HashMap<>(); <line19> for (int i = 0; i < partitions.length; i++) { <line20> if (dividedNames[i] != null && !dividedNames[i].isEmpty()) { <line21> result.putAll(partitions[i].getCacheElements(dividedNames[i])); <line22> } <line23> } <line24> return result; <line25> } <line26> } <line27> "	"<line3>      log.warn(""Bad input names cannot be null."");"	task0	
"public class A { <line0> @Test <line1> public void oneStringKeyAndValue() throws Exception { <line2> if (LOGGER.isInfoEnabled()) { <line3> LOGGER.info(""BTree "" + getTestOpName() + "" Test With One String Key And Value.""); <line4> } <line5> ISerializerDeserializer[] fieldSerdes = { <line6> new UTF8StringSerializerDeserializer(), new UTF8StringSerializerDeserializer() <line7> }; <line8> ITupleReference lowKey = TupleUtils.createTuple(fieldSerdes, ""cbf""); <line9> ITupleReference highKey = TupleUtils.createTuple(fieldSerdes, ""cc7""); <line10> for (BTreeLeafFrameType leafFrameType : leafFrameTypesToTest) { <line11> runTest(fieldSerdes, 1, leafFrameType, lowKey, highKey, null, null); <line12> } <line13> } <line14> } <line15> "	"<line3>      LOGGER.info(""BTree "" + getTestOpName() + "" Test With One String Key And Value."");"	task0	
"public class A { <line0> public static void stopServerInTransaction() { <line1> if (doByteman.get()) { <line2> new Thread() { <line3> @Override <line4> public void run() { <line5> LOG.info(""Stopping broker in transaction...""); <line6> try { <line7> server.stop(); <line8> } catch (Exception e) { <line9> e.printStackTrace(); <line10> } finally { <line11> brokerStopLatch.countDown(); <line12> } <line13> } <line14> }.start(); <line15> } <line16> } <line17> } <line18> "	"<line5>          LOG.info(""Stopping broker in transaction..."");"	task0	
public class A { <line0> public static com.liferay.bookmarks.model.BookmarksEntrySoap[] getGroupEntries( <line1> long groupId, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.bookmarks.model.BookmarksEntry> returnValue = <line4> BookmarksEntryServiceUtil.getGroupEntries(groupId, start, end); <line5> return com.liferay.bookmarks.model.BookmarksEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> log.error(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	<line7>      log.error(exception, exception);	task0	
"public class A { <line0> @Test <line1> public void testGetInstanceWithClass() { <line2> final VitamUILogger logger = VitamUILoggerFactory.getInstance(VitamUILoggerTest.class); <line3> assertNotNull(""Logger should be created."", logger); <line4> assertEquals( <line5> ""Logger name isn't correctly set."", VitamUILoggerTest.class.getName(), logger.getName()); <line6> assertTrue(""Log messages should be empty."", buf.length() == 0); <line7> logger.info(""Message""); <line8> assertTrue(""Log message should be written."", buf.length() > 0); <line9> } <line10> } <line11> "	"<line7>    logger.info(""Message"");"	task0	
"public class A { <line0> public StingrayRestClient loadSTMRestClient(LoadBalancerEndpointConfiguration config) <line1> throws InsufficientRequestException { <line2> URI restEndpoint = config.getRestEndpoint(); <line3> LOG.debug(""Building new STM client using endpoint: "" + restEndpoint); <line4> return new StingrayRestClient(restEndpoint, config.getUsername(), config.getPassword()); <line5> } <line6> } <line7> "	"<line3>    LOG.debug(""Building new STM client using endpoint: "" + restEndpoint);"	task0	
"public class A { <line0> public void updateSampleOrdinals_v092() { <line1> subjDefs = new HashMap(); <line2> this.unsetTypeExpected(); <line3> this.setTypeExpected(1, TypeNames.INT); <line4> this.setTypeExpected(2, TypeNames.INT); <line5> this.setTypeExpected(3, TypeNames.INT); <line6> this.setTypeExpected(3, TypeNames.INT); <line7> ArrayList rows = <line8> select( <line9> ""SELECT study_event_id, study_event_definition_id, study_subject_id, sample_ordinal"" <line10> + "" FROM study_event ORDER BY study_subject_id ASC, study_event_definition_id ASC,"" <line11> + "" sample_ordinal ASC""); <line12> for (int i = 0; i < rows.size(); i++) { <line13> HashMap row = (HashMap) rows.get(i); <line14> Integer studyEventId = (Integer) row.get(""study_event_id""); <line15> Integer studyEventDefinitionId = (Integer) row.get(""study_event_definition_id""); <line16> Integer studySubjectId = (Integer) row.get(""study_subject_id""); <line17> addEvent(studySubjectId, studyEventDefinitionId, studyEventId); <line18> } <line19> Iterator keysIt = subjDefs.keySet().iterator(); <line20> while (keysIt.hasNext()) { <line21> String key = (String) keysIt.next(); <line22> ArrayList events = (ArrayList) subjDefs.get(key); <line23> for (int i = 0; i < events.size(); i++) { <line24> Integer id = (Integer) events.get(i); <line25> if (id != null) { <line26> int ordinal = i + 1; <line27> logger.debug( <line28> ""UPDATE study_event SET sample_ordinal = "" <line29> + ordinal <line30> + "" WHERE study_event_id = "" <line31> + id); <line32> } <line33> } <line34> } <line35> } <line36> } <line37> "	"<line27>          logger.debug(""UPDATE study_event SET sample_ordinal = ""+ ordinal+ "" WHERE study_event_id = ""+ id);"	task0	
"public class A { <line0> @Override <line1> protected Event handleStartSubDocument(Event event) { <line2> logger.debug(""Handle start sub document""); <line3> overallStopWatch.start(""Starts processing XLIFF""); <line4> StartSubDocument startSubDocument = event.getStartSubDocument(); <line5> initAsset(startSubDocument); <line6> if (!isSourceXliff()) { <line7> initTmTextUnitIdsByMd5ForAsset(); <line8> } <line9> return super.handleStartSubDocument(event); <line10> } <line11> } <line12> "	"<line2>    logger.debug(""Handle start sub document"");"	task0	
"public class A { <line0> @Test <line1> public void testMRIncrementalLoadWithPutSortReducer() throws Exception { <line2> LOG.info(""\nStarting test testMRIncrementalLoadWithPutSortReducer\n""); <line3> doIncrementalLoadTest(false, false, true, ""testMRIncrementalLoadWithPutSortReducer""); <line4> } <line5> } <line6> "	"<line2>    LOG.info(""\nStarting test testMRIncrementalLoadWithPutSortReducer\n"");"	task0	
"public class A { <line0> @Override <line1> public void moveCategory(MCRCategoryID id, MCRCategoryID newParentID, int index) { <line2> withoutFlush( <line3> MCREntityManagerProvider.getCurrentEntityManager(), <line4> true, <line5> e -> { <line6> MCRCategoryImpl subTree = <line7> getByNaturalID(MCREntityManagerProvider.getCurrentEntityManager(), id); <line8> MCRCategoryImpl oldParent = (MCRCategoryImpl) subTree.getParent(); <line9> MCRCategoryImpl newParent = <line10> getByNaturalID(MCREntityManagerProvider.getCurrentEntityManager(), newParentID); <line11> MCRCategoryImpl commonAncestor = <line12> getCommonAncestor( <line13> MCREntityManagerProvider.getCurrentEntityManager(), oldParent, newParent); <line14> subTree.detachFromParent(); <line15> LOGGER.debug(""Add subtree to new Parent at index: {}"", index); <line16> newParent.getChildren().add(index, subTree); <line17> subTree.parent = newParent; <line18> MCREntityManagerProvider.getCurrentEntityManager().flush(); <line19> int left = commonAncestor.getLeft(); <line20> commonAncestor.calculateLeftRightAndLevel( <line21> Integer.MAX_VALUE / 2, commonAncestor.getLevel()); <line22> e.flush(); <line23> commonAncestor.calculateLeftRightAndLevel(left, commonAncestor.getLevel()); <line24> updateTimeStamp(); <line25> updateLastModified(id.getRootID()); <line26> }); <line27> } <line28> } <line29> "	"<line15>          LOGGER.debug(""Add subtree to new Parent at index: {}"", index);"	task0	
"public class A { <line0> public EditorPage translateTargetAtRowIndex(final int rowIndex, String text) { <line1> log.info(""Enter at {} the text {}"", rowIndex, text); <line2> setTargetContent(rowIndex, text, TARGET_ID_FMT, Plurals.SourceSingular); <line3> return new EditorPage(getDriver()); <line4> } <line5> } <line6> "	"<line1>    log.info(""Enter at {} the text {}"", rowIndex, text);"	task0	
"public class A { <line0> private SearchResponse validateAndGetSearchResponse(MultiSearchResponse.Item item, String table) { <line1> if (item.isFailure()) { <line2> logger.info( <line3> ""FailureInDeducingCardinality table:{} failureMessage:{}"", <line4> table, <line5> item.getFailureMessage()); <line6> return null; <line7> } <line8> SearchResponse response = item.getResponse(); <line9> if (null == response.getAggregations()) { <line10> return null; <line11> } <line12> return response; <line13> } <line14> } <line15> "	"<line2>      logger.info(""FailureInDeducingCardinality table:{} failureMessage:{}"",table,item.getFailureMessage());"	task0	
"public class A { <line0> @Override <line1> public void onError(Throwable throwable) { <line2> logger.error(""websocket frame service onError: "" + throwable.toString()); <line3> WebSocketFrameService.removeObserver(streamId); <line4> } <line5> } <line6> "	"<line2>    logger.error(""websocket frame service onError: "" + throwable.toString());"	task0	
"public class A { <line0> private void respondWithError( <line1> ChannelHandlerContext ctx, Throwable error, InputChannelID sourceId) { <line2> LOG.debug(""Responding with error: {}."", error.getClass()); <line3> ctx.writeAndFlush(new NettyMessage.ErrorResponse(error, sourceId)); <line4> } <line5> } <line6> "	"<line2>    LOG.debug(""Responding with error: {}."", error.getClass());"	task0	
public class A { <line0> private ComponentInstance createComponent( <line1> boolean needLock, <line2> Component containerComponent, <line3> Component origComponent, <line4> ComponentInstance resourceInstance, <line5> User user) { <line6> boolean failed = false; <line7> try { <line8> lockIfNeed(needLock, containerComponent); <line9> log.debug(TRY_TO_CREATE_ENTRY_ON_GRAPH); <line10> return createComponentInstanceOnGraph( <line11> containerComponent, origComponent, resourceInstance, user); <line12> } catch (ComponentException e) { <line13> failed = true; <line14> throw e; <line15> } finally { <line16> if (needLock) { <line17> unlockComponent(failed, containerComponent); <line18> } <line19> } <line20> } <line21> } <line22> 	<line9>      log.debug(TRY_TO_CREATE_ENTRY_ON_GRAPH);	task0	
"public class A { <line0> @Override <line1> public @Nullable ThingUID getThingUID(RemoteDevice device) { <line2> if (device.getDetails().getManufacturerDetails().getManufacturer() != null) { <line3> if (device <line4> .getDetails() <line5> .getManufacturerDetails() <line6> .getManufacturer() <line7> .toUpperCase() <line8> .contains(""SONOS"")) { <line9> String modelName = getModelName(device); <line10> switch (modelName) { <line11> case ""ZP80"": <line12> modelName = ""CONNECT""; <line13> break; <line14> case ""ZP100"": <line15> modelName = ""CONNECTAMP""; <line16> break; <line17> case ""One SL"": <line18> modelName = ""OneSL""; <line19> break; <line20> case ""Arc SL"": <line21> modelName = ""ArcSL""; <line22> break; <line23> default: <line24> break; <line25> } <line26> ThingTypeUID thingUID = new ThingTypeUID(SonosBindingConstants.BINDING_ID, modelName); <line27> if (!SonosBindingConstants.SUPPORTED_KNOWN_THING_TYPES_UIDS.contains(thingUID)) { <line28> thingUID = new ThingTypeUID(SonosBindingConstants.BINDING_ID, modelName.toUpperCase()); <line29> if (!SonosBindingConstants.SUPPORTED_KNOWN_THING_TYPES_UIDS.contains(thingUID)) { <line30> thingUID = SonosBindingConstants.ZONEPLAYER_THING_TYPE_UID; <line31> } <line32> } <line33> logger.debug( <line34> ""Discovered a Sonos '{}' thing with UDN '{}'"", <line35> thingUID, <line36> device.getIdentity().getUdn().getIdentifierString()); <line37> return new ThingUID(thingUID, device.getIdentity().getUdn().getIdentifierString()); <line38> } <line39> } <line40> return null; <line41> } <line42> } <line43> "	"<line33>        logger.debug(""Discovered a Sonos '{}' thing with UDN '{}'"",thingUID,device.getIdentity().getUdn().getIdentifierString());"	task0	
"public class A { <line0> @Nullable <line1> public ResolvableInetSocketAddress getRemoteAddress() { <line2> if (msgBuilder.hasRemote()) { <line3> final JournalMessages.RemoteAddress address = msgBuilder.getRemote(); <line4> final InetAddress inetAddr; <line5> try { <line6> inetAddr = <line7> InetAddress.getByAddress(address.getResolved(), address.getAddress().toByteArray()); <line8> } catch (UnknownHostException e) { <line9> log.warn( <line10> ""Malformed InetAddress for message {}, expected 4 or 16 bytes, but got {} bytes"", <line11> id, <line12> address.getAddress().toByteArray()); <line13> return null; <line14> } <line15> final int port = address.hasPort() ? address.getPort() : 0; <line16> return ResolvableInetSocketAddress.wrap(new InetSocketAddress(inetAddr, port)); <line17> } <line18> return null; <line19> } <line20> } <line21> "	"<line9>        log.warn(""Malformed InetAddress for message {}, expected 4 or 16 bytes, but got {} bytes"",id,address.getAddress().toByteArray());"	task0	
"public class A { <line0> public String getName() { <line1> try { <line2> String name = this.getCertificateSubjectDN().getProperty(""CN""); <line3> int pos; <line4> pos = name.indexOf(':'); <line5> if (pos > 0) { <line6> return name.substring(0, pos); <line7> } <line8> return name; <line9> } catch (Exception e) { <line10> logger.info(e.getMessage()); <line11> return null; <line12> } <line13> } <line14> } <line15> "	<line10>      logger.info(e.getMessage());	task0	
"public class A { <line0> @Override <line1> protected boolean selectTargetServer(RouteContext ctx, List<TargetServerInfo> infos) { <line2> TService ts = (TService) ctx.obj; <line3> if (ts == null) { <line4> return false; <line5> } <line6> try { <line7> Instance ins = nacosNamingService.selectOneHealthyInstance(ts.name, group); <line8> if (ins != null) { <line9> ctx.targetHost = ins.getIp(); <line10> ctx.targetPort = ins.getPort(); <line11> return true; <line12> } <line13> } catch (NacosException e) { <line14> log.debug(""selectOneHealthyInstance fail"", e); <line15> } <line16> return false; <line17> } <line18> } <line19> "	"<line14>      log.debug(""selectOneHealthyInstance fail"", e);"	task0	
"public class A { <line0> public static void error(JFrame parent, String message, String title) { <line1> Log.note(""Creating error dialog with title '"" + title + ""'.""); <line2> URL iconURL = Dialog.class.getResource(Config.RES_ICON_ERROR); <line3> if (iconURL == null) { <line4> Log.note(""Unable to get icon from "" + Config.RES_ICON_ERROR + ""; reverting to defaults.""); <line5> } <line6> if (parent == null) { <line7> parent = new JFrame(Config.APP_NAME); <line8> parent.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); <line9> } <line10> try { <line11> if (iconURL != null) { <line12> ImageIcon icon = new ImageIcon(iconURL); <line13> JOptionPane.showMessageDialog( <line14> parent, message, title, JOptionPane.INFORMATION_MESSAGE, icon); <line15> } else { <line16> JOptionPane.showMessageDialog(parent, message, title, JOptionPane.ERROR_MESSAGE); <line17> } <line18> } catch (Exception ex) { <line19> Log.error(""Unable to create error dialog."", ex); <line20> } <line21> } <line22> } <line23> "	"<line19>      Log.error(""Unable to create error dialog."", ex);"	task0	
"public class A { <line0> public void setCstlProfileURL(String cstlProfileURL) { <line1> LOGGER.info(""CSTL Profile page changed to "" + cstlProfileURL); <line2> this.cstlProfileURL = cstlProfileURL; <line3> } <line4> } <line5> "	"<line1>    LOGGER.info(""CSTL Profile page changed to "" + cstlProfileURL);"	task0	
"public class A { <line0> @Override <line1> public void doMonitor(ServiceEmitter emitter) { <line2> final CacheStats oldStats = priorStats.get(); <line3> final CacheStats newStats = cache.stats(); <line4> final CacheStats deltaStats = newStats.minus(oldStats); <line5> final ServiceMetricEvent.Builder builder = ServiceMetricEvent.builder(); <line6> emitter.emit(builder.build(""query/cache/caffeine/delta/requests"", deltaStats.requestCount())); <line7> emitter.emit(builder.build(""query/cache/caffeine/total/requests"", newStats.requestCount())); <line8> emitter.emit(builder.build(""query/cache/caffeine/delta/loadTime"", deltaStats.totalLoadTime())); <line9> emitter.emit(builder.build(""query/cache/caffeine/total/loadTime"", newStats.totalLoadTime())); <line10> emitter.emit( <line11> builder.build(""query/cache/caffeine/delta/evictionBytes"", deltaStats.evictionWeight())); <line12> emitter.emit( <line13> builder.build(""query/cache/caffeine/total/evictionBytes"", newStats.evictionWeight())); <line14> if (!priorStats.compareAndSet(oldStats, newStats)) { <line15> log.warn( <line16> new IllegalStateException(""Multiple monitors""), <line17> ""Multiple monitors on the same cache causing race conditions and unreliable stats"" <line18> + "" reporting""); <line19> } <line20> } <line21> } <line22> "	"<line15>      log.warn(new IllegalStateException(""Multiple monitors""),""Multiple monitors on the same cache causing race conditions and unreliable stats""+ "" reporting"");"	task0	
"public class A { <line0> public org.talend.mdm.webservice.WSDataModelPKArray getDataModelPKs( <line1> org.talend.mdm.webservice.WSRegexDataModelPKs arg0) { <line2> LOG.info(""Executing operation getDataModelPKs""); <line3> System.out.println(arg0); <line4> try { <line5> org.talend.mdm.webservice.WSDataModelPKArray _return = null; <line6> return _return; <line7> } catch (java.lang.Exception ex) { <line8> ex.printStackTrace(); <line9> throw new RuntimeException(ex); <line10> } <line11> } <line12> } <line13> "	"<line2>    LOG.info(""Executing operation getDataModelPKs"");"	task0	
public class A { <line0> @Override <line1> public void loadComponents(final AsyncCallback<List<Component>> callback) { <line2> final List<Component> components = new ArrayList<Component>(); <line3> final ModelNode operation = new ModelNode(); <line4> final ModelNode address = Baseadress.get(); <line5> operation.get(OP).set(READ_CHILDREN_NAMES_OPERATION); <line6> operation.get(CHILD_TYPE).set(MODULE); <line7> address.add(SUBSYSTEM, SWITCHYARD); <line8> operation.get(OP_ADDR).set(address); <line9> _dispatcher.execute( <line10> new DMRAction(operation), <line11> new AsyncCallback<DMRResponse>() { <line12> @Override <line13> public void onFailure(Throwable caught) { <line14> callback.onFailure(caught); <line15> } <line16>  <line17> @Override <line18> public void onSuccess(DMRResponse result) { <line19> final ModelNode response = result.get().get(RESULT); <line20> if (response.isDefined()) { <line21> for (final ModelNode componentNode : response.asList()) { <line22> try { <line23> final Component component = _factory.component().as(); <line24> component.setName(componentNode.asString()); <line25> components.add(component); <line26> } catch (IllegalArgumentException e) { <line27> Log.error(PARSE_ERROR_MESSAGE, e); <line28> } <line29> } <line30> } <line31> callback.onSuccess(components); <line32> } <line33> }); <line34> } <line35> } <line36> 	<line27>                  Log.error(PARSE_ERROR_MESSAGE, e);	task0	
"public class A { <line0> @RequestMapping(value = ""/{token:.+}"", method = RequestMethod.GET) <line1> public ResponseEntity<Space> getSpace( <line2> @PathVariable String token, <line3> @ApiIgnore @RequestHeader(value = Constants.HTTP_TENANT_HEADER, required = false) <line4> String tenant) { <line5> Tenant t = null; <line6> try { <line7> t = this.tenantRepository.getTenant(tenant); <line8> } catch (Exception e) { <line9> log.error(""Error retrieving tenant: "" + e); <line10> return new ResponseEntity<Space>(HttpStatus.NOT_FOUND); <line11> } <line12> try { <line13> final Space s = <line14> SpaceRepository.FILTER.findOne( <line15> this.spaceRepository.findBySecondaryKey(t.getTenantToken(), token)); <line16> return new ResponseEntity<Space>(s, HttpStatus.OK); <line17> } catch (EntityNotFoundException enfe) { <line18> return new ResponseEntity<Space>(HttpStatus.NOT_FOUND); <line19> } <line20> } <line21> } <line22> "	"<line9>      log.error(""Error retrieving tenant: "" + e);"	task0	
"public class A { <line0> void run() { <line1> if (channel.isShutdown() || SERVICE_DISCOVER_FREQ_SECONDS < 1) { <line2> return; <line3> } <line4> if (seviceDiscovery == null) { <line5> seviceDiscovery = <line6> Executors.newSingleThreadScheduledExecutor( <line7> r -> { <line8> Thread t = Executors.defaultThreadFactory().newThread(r); <line9> t.setDaemon(true); <line10> return t; <line11> }) <line12> .scheduleAtFixedRate( <line13> () -> { <line14> logger.debug( <line15> format( <line16> ""Channel %s starting service rediscovery after %d seconds."", <line17> channelName, SERVICE_DISCOVER_FREQ_SECONDS)); <line18> fullNetworkDiscovery(true); <line19> }, <line20> SERVICE_DISCOVER_FREQ_SECONDS, <line21> SERVICE_DISCOVER_FREQ_SECONDS, <line22> TimeUnit.SECONDS); <line23> } <line24> } <line25> } <line26> "	"<line14>                    logger.debug(format(""Channel %s starting service rediscovery after %d seconds."",channelName, SERVICE_DISCOVER_FREQ_SECONDS));"	task0	
public class A { <line0> @Test <line1> public void testError_Object_Object_Object_Object() throws Exception { <line2> ILoggingTool logger = getLoggingTool(); <line3> logger.error(this, this, this, this); <line4> } <line5> } <line6> 	No	task1	
"public class A { <line0> private void runAndTrapExceptions() { <line1> try { <line2> decodedEntities = new ArrayList<>(); <line3> if (""OSMHeader"".equals(blobType)) { <line4> processOsmHeader(readBlobContent()); <line5> } else if (""OSMData"".equals(blobType)) { <line6> processOsmPrimitives(readBlobContent()); <line7> } catch (IOException e) { <line8> throw new RuntimeException(""Unable to process PBF blob"", e); <line9> } <line10> } <line11> } <line12> "	Yes	task1	
"public class A { <line0> private void handleConnectionFailure(int curRetries, Exception ioe) throws Exception { <line1> closeConnection(); <line2> final boolean retry; <line3> try { <line4> retry = connectionRetryPolicy.shouldRetry(ioe, curRetries); <line5> } catch (Exception e) { <line6> throw e instanceof IOException ? (IOException) e : new IOException(e); <line7> } <line8> if (!retry) { <line9> throw ioe; <line10> } <line11> LOG.info( <line12> ""Retrying connect to server: "" <line13> + serverAddress <line14> + "". Already tried "" <line15> + curRetries <line16> + "" time(s); retry policy is "" <line17> + connectionRetryPolicy); <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> @Override <line1> public void completed(final IOSession session) { <line2> final AsyncClientExchangeHandler internalExchangeHandler = <line3> new AsyncClientExchangeHandler() { <line4> @Override <line5> public void releaseResources() { <line6> exchangeHandler.releaseResources(); <line7> } <line8> @Override <line9> public void failed(final Exception cause) { <line10> exchangeHandler.failed(cause); <line11> } <line12> @Override <line13> public void cancel() { <line14> failed(new RequestFailedException(""Request aborted"")); <line15> } <line16> @Override <line17> public void produceRequest(final RequestChannel channel, final HttpContext context1) <line18> throws HttpException, IOException { <line19> channel.sendRequest(request, entityDetails, context1); <line20> } <line21> @Override <line22> public int available() { <line23> return exchangeHandler.available(); <line24> } <line25> @Override <line26> public void produce(final DataStreamChannel channel) throws IOException { <line27> exchangeHandler.produce(channel); <line28> } <line29> @Override <line30> public void consumeInformation(final HttpResponse response, final HttpContext context1) <line31> throws HttpException, IOException { <line32> exchangeHandler.consumeInformation(response, context1); <line33> } <line34> @Override <line35> public void consumeResponse( <line36> final HttpResponse response, <line37> final EntityDetails entityDetails, <line38> final HttpContext context1) <line39> throws HttpException, IOException { <line40> exchangeHandler.consumeResponse(response, entityDetails, context1); <line41> } <line42> @Override <line43> public void updateCapacity(final CapacityChannel capacityChannel) throws IOException { <line44> exchangeHandler.updateCapacity(capacityChannel); <line45> } <line46> @Override <line47> public void consume(final ByteBuffer src) throws IOException { <line48> exchangeHandler.consume(src); <line49> } <line50> @Override <line51> public void streamEnd(final List<? extends Header> trailers) <line52> throws HttpException, IOException { <line53> exchangeHandler.streamEnd(trailers); <line54> } <line55> }; <line56> if (LOG.isDebugEnabled()) { <line57> final String exchangeId = ExecSupport.getNextExchangeId(); <line58> session.enqueue( <line59> new RequestExecutionCommand( <line60> new LoggingAsyncClientExchangeHandler(LOG, exchangeId, internalExchangeHandler), <line61> pushHandlerFactory, <line62> cancellable, <line63> clientContext), <line64> Command.Priority.NORMAL); <line65> } else { <line66> session.enqueue( <line67> new RequestExecutionCommand( <line68> internalExchangeHandler, pushHandlerFactory, cancellable, clientContext), <line69> Command.Priority.NORMAL); <line70> } <line71> } <line72> } <line73> "	Yes	task1	
"public class A { <line0> private void addSegAndJob(CubeInstance cube) { <line1> if (includeSegments) { <line2> addRequired(CubeInstance.concatResourcePath(cube.getName())); <line3> for (CubeSegment segment : cube.getSegments(SegmentStatusEnum.READY)) { <line4> addRequired(CubeSegment.getStatisticsResourcePath(cube.getName(), segment.getUuid())); <line5> if (includeSegmentDetails) { <line6> for (String dictPat : segment.getDictionaryPaths()) { <line7> addRequired(dictPat); <line8> } <line9> for (String snapshotPath : segment.getSnapshotPaths()) { <line10> addRequired(snapshotPath); <line11> } <line12> } <line13> if (includeJobs) { <line14> String lastJobId = segment.getLastBuildJobID(); <line15> if (StringUtils.isEmpty(lastJobId)) { <line16> throw new RuntimeException(""No job exist for segment :"" + segment); <line17> } else { <line18> try { <line19> if (onlyJobOutput) { <line20> addRequired(ResourceStore.EXECUTE_OUTPUT_RESOURCE_ROOT + ""/"" + lastJobId); <line21> } else { <line22> ExecutablePO executablePO = executableDao.getJob(lastJobId); <line23> addRequired(ResourceStore.EXECUTE_RESOURCE_ROOT + ""/"" + lastJobId); <line24> addRequired(ResourceStore.EXECUTE_OUTPUT_RESOURCE_ROOT + ""/"" + lastJobId); <line25> for (ExecutablePO task : executablePO.getTasks()) { <line26> addRequired(ResourceStore.EXECUTE_RESOURCE_ROOT + ""/"" + task.getUuid()); <line27> addRequired(ResourceStore.EXECUTE_OUTPUT_RESOURCE_ROOT + ""/"" + task.getUuid()); <line28> } <line29> } <line30> } catch (PersistentException e) { <line31> throw new RuntimeException(""PersistentException"", e); <line32> } <line33> } <line34> } <line35> } <line36> } else { <line37> if (includeJobs) { <line38> logger.warn(""It's useless to set includeJobs to true when includeSegments is set to false""); <line39> } <line40> cube.setStatus(RealizationStatusEnum.DISABLED); <line41> cubesToTrimAndSave.add(cube); <line42> } <line43> } <line44> } <line45> "	No	task1	
public class A { <line0> @Override <line1> public void run() { <line2> try (AutoLock l = _lock.lock()) { <line3> _task = null; <line4> if (!isRunning()) return; <line5> int rate = _rate.getRate(); <line6> if (rate > _acceptRateLimit) { <line7> schedule(); <line8> return; <line9> } <line10> if (_limiting) { <line11> _limiting = false; <line12> unlimit(); <line13> } <line14> } <line15> } <line16> } <line17> 	Yes	task1	
"public class A { <line0> @Override <line1> protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception { <line2> IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName); <line3> int connections = rnd.nextInt(10) + 1; <line4> log.info(""Node connections [name="" + igniteInstanceName + "", connections="" + connections + ']'); <line5> ((TcpCommunicationSpi) cfg.getCommunicationSpi()).setConnectionsPerNode(connections); <line6> ((TcpCommunicationSpi) cfg.getCommunicationSpi()).setUsePairedConnections(rnd.nextBoolean()); <line7> ((TcpCommunicationSpi) cfg.getCommunicationSpi()).setSharedMemoryPort(-1); <line8> cfg.setClientMode(client); <line9> return cfg; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> private void verifyEndpointsMetrics(final Endpoints endpoints) throws Exception { <line1> for (Endpoint endpoint : endpoints.getEndpoints()) { <line2> if (!endpoint.getLabel().equals(""/users"")) { <line3> continue; <line4> } <line5> for (String metricName : ALL_ENDPOINT_METRICS) { <line6> LOGGER.info(""verifying endpoint {}, metrics: {}"", endpoint, metricName); <line7> verifyMetrics(graphql, metricName, endpoint.getKey(), startTime); <line8> } <line9> for (String metricName : ALL_ENDPOINT_MULTIPLE_LINEAR_METRICS) { <line10> verifyPercentileMetrics(graphql, metricName, endpoint.getKey(), startTime); <line11> } <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> public ValidationResult afterFormFinishTable(Repository<Properties> repo) throws Exception { <line1> connection.BlobSchema = selectedContainerNames.getValue(); <line2> connection.QueueSchema = selectedQueueNames.getValue(); <line3> connection.TableSchema = selectedTableNames.getValue(); <line4> String repoLoc = <line5> repo.storeProperties(connection, connection.name.getValue(), repositoryLocation, null); <line6> String storeId; <line7> if (selectedContainerNames.getValue() != null) { <line8> for (NamedThing nl : selectedContainerNames.getValue()) { <line9> String containerId = nl.getName(); <line10> AzureStorageContainerProperties containerProps = <line11> new AzureStorageContainerProperties(containerId); <line12> containerProps.init(); <line13> containerProps.connection = connection; <line14> containerProps.container.setValue(containerId); <line15> containerProps.schema.schema.setValue(getContainerSchema()); <line16> repo.storeProperties( <line17> containerProps, formatSchemaName(containerId), repoLoc, ""schema.schema""); <line18> } <line19> } <line20> if (selectedQueueNames.getValue() != null) { <line21> for (NamedThing nl : selectedQueueNames.getValue()) { <line22> String queueId = nl.getName(); <line23> AzureStorageQueueProperties queueProps = new AzureStorageQueueProperties(queueId); <line24> queueProps.init(); <line25> queueProps.connection = connection; <line26> queueProps.queueName.setValue(queueId); <line27> queueProps.schema.schema.setValue(getQueueSchema()); <line28> repo.storeProperties(queueProps, formatSchemaName(queueId), repoLoc, ""schema.schema""); <line29> } <line30> } <line31> if (selectedTableNames.getValue() != null) { <line32> for (NamedThing nl : selectedTableNames.getValue()) { <line33> String tableId = nl.getName(); <line34> AzureStorageTableProperties tableProps = new AzureStorageTableProperties(tableId); <line35> tableProps.init(); <line36> tableProps.connection = connection; <line37> tableProps.tableName.setValue(tableId); <line38> try { <line39> Schema schema = AzureStorageTableSourceOrSink.getSchema(null, connection, tableId); <line40> tableProps.schema.schema.setValue(schema); <line41> repo.storeProperties(tableProps, formatSchemaName(tableId), repoLoc, ""schema.schema""); <line42> } catch (IOException e) { <line43> LOGGER.error(e.getLocalizedMessage()); <line44> } <line45> } <line46> } <line47> return ValidationResult.OK; <line48> } <line49> } <line50> "	No	task1	
"public class A { <line0> @Override <line1> public void run() { <line2> FileUtils.deleteQuietly(new File(_tableDataDir, segmentId)); <line3> LOGGER.info(""The index directory for the segment "" + segmentId + "" has been deleted""); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> private Map<String, DimensionEncoding> getDimensionEncodings( <line1> FragmentMetaInfo fragmentMetaInfo, List<DimensionMetaInfo> allDimensions, Path dataPath) <line2> throws IOException { <line3> Map<String, Dictionary> dictionaryMap; <line4> try (FSDataInputStream dictInputStream = fs.open(dataPath)) { <line5> dictionaryMap = readAllDimensionsDictionary(fragmentMetaInfo, dictInputStream); <line6> } <line7> Map<String, DimensionEncoding> result = Maps.newHashMap(); <line8> for (DimensionMetaInfo dimension : allDimensions) { <line9> TblColRef col = cubeDesc.getModel().findColumn(dimension.getName()); <line10> RowKeyColDesc colDesc = cubeDesc.getRowkey().getColDesc(col); <line11> if (colDesc.isUsingDictionary()) { <line12> @SuppressWarnings({""unchecked""}) <line13> Dictionary<String> dict = dictionaryMap.get(dimension.getName()); <line14> if (dict == null) { <line15> logger.error(""No dictionary found for dict-encoding column "" + col); <line16> throw new IllegalStateException(""No dictionary found for dict-encoding column "" + col); <line17> } else { <line18> result.put(dimension.getName(), new DictionaryDimEnc(dict)); <line19> } <line20> } else { <line21> result.put( <line22> dimension.getName(), <line23> DimensionEncodingFactory.create( <line24> colDesc.getEncodingName(), <line25> colDesc.getEncodingArgs(), <line26> colDesc.getEncodingVersion())); <line27> } <line28> } <line29> return result; <line30> } <line31> } <line32> "	No	task1	
public class A { <line0> public void end(Context context, WorkflowAction action) throws ActionExecutorException { <line1> context.setEndData(WorkflowAction.Status.OK, action.getExternalStatus()); <line2> } <line3> } <line4> 	Yes	task1	
public class A { <line0> @Override <line1> public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { <line2> if (bean instanceof SecurityFilterChain && !ignore.contains(beanName)) { <line3> SecurityFilterChain fc = (SecurityFilterChain) bean; <line4> Filter uaaFilter = new HttpsEnforcementFilter(beanName, redirectToHttps.contains(beanName)); <line5> fc.getFilters().add(0, uaaFilter); <line6> if (additionalFilters != null) { <line7> for (Entry<FilterPosition, Filter> entry : additionalFilters.entrySet()) { <line8> int position = entry.getKey().getPosition(fc); <line9> if (position > fc.getFilters().size()) { <line10> fc.getFilters().add(entry.getValue()); <line11> } else { <line12> fc.getFilters().add(position, entry.getValue()); <line13> } <line14> } <line15> } <line16> } <line17> return bean; <line18> } <line19> } <line20> 	Yes	task1	
"public class A { <line0> private String getDeploymentName(File zipFolder) { <line1> File deployment = new File(zipFolder, DEPLOYMENT_DESCRIPTOR_FILE_NAME + "".xml""); <line2> String deploymentName = ""openl_rules_"" + System.currentTimeMillis(); <line3> if (deployment.exists()) { <line4> return deploymentName; <line5> } <line6> deployment = new File(zipFolder, DEPLOYMENT_DESCRIPTOR_FILE_NAME + "".yaml""); <line7> if (deployment.exists()) { <line8> try { <line9> Yaml yaml = new Yaml(); <line10> Map properties = yaml.loadAs(new FileInputStream(deployment), Map.class); <line11> return Optional.ofNullable(properties.get(""name"")) <line12> .map(Object::toString) <line13> .filter(StringUtils::isNotBlank) <line14> .orElse(deploymentName); <line15> } catch (IOException e) { <line16> log.debug(e.getMessage(), e); <line17> } <line18> return deploymentName; <line19> } <line20> return null; <line21> } <line22> } <line23> "	No	task1	
"public class A { <line0> private Tool refreshContainer(final long containerId, final long userId) { <line1> Tool tool = toolDAO.findById(containerId); <line2> String gitUrl = tool.getGitUrl(); <line3> Map<String, String> gitMap = SourceCodeRepoFactory.parseGitUrl(gitUrl); <line4> if (gitMap == null) { <line5> throw new CustomWebApplicationException( <line6> ""Could not parse Git URL:"" + gitUrl + "" Unable to refresh tool!"", <line7> HttpStatus.SC_INTERNAL_SERVER_ERROR); <line8> } <line9> List<Token> tokens = tokenDAO.findByUserId(userId); <line10> Token quayToken = Token.extractToken(tokens, TokenType.QUAY_IO); <line11> Token githubToken = Token.extractToken(tokens, TokenType.GITHUB_COM); <line12> Token gitlabToken = Token.extractToken(tokens, TokenType.GITLAB_COM); <line13> Token bitbucketToken = Token.extractToken(tokens, TokenType.BITBUCKET_ORG); <line14> checkTokens(quayToken, githubToken, bitbucketToken, gitlabToken); <line15> final SourceCodeRepoInterface sourceCodeRepo = <line16> SourceCodeRepoFactory.createSourceCodeRepo( <line17> tool.getGitUrl(), <line18> bitbucketToken == null ? null : bitbucketToken.getContent(), <line19> gitlabToken == null ? null : gitlabToken.getContent(), <line20> githubToken); <line21> ImageRegistryFactory factory = new ImageRegistryFactory(quayToken); <line22> final AbstractImageRegistry abstractImageRegistry = <line23> factory.createImageRegistry(tool.getRegistryProvider()); <line24> if (abstractImageRegistry == null) { <line25> throw new CustomWebApplicationException( <line26> ""unable to establish connection to registry, check that you have linked your accounts"", <line27> HttpStatus.SC_NOT_FOUND); <line28> } <line29> return abstractImageRegistry.refreshTool( <line30> containerId, <line31> userId, <line32> userDAO, <line33> toolDAO, <line34> tagDAO, <line35> fileDAO, <line36> fileFormatDAO, <line37> sourceCodeRepo, <line38> eventDAO, <line39> dashboardPrefix); <line40> } <line41> } <line42> "	Yes	task1	
"public class A { <line0> @Override <line1> public String getObject() { <line2> try { <line3> ExpressionType value = baseModel.getObject(); <line4> if (value == null) { <line5> return null; <line6> } <line7> List<JAXBElement<?>> evaluatros = value.getExpressionEvaluator(); <line8> if (CollectionUtils.isEmpty(evaluatros)) { <line9> return null; <line10> } <line11> if (evaluatros.size() > 1) { <line12> } <line13> JAXBElement<?> evaluator = evaluatros.get(0); <line14> if (evaluator == null) { <line15> return null; <line16> } <line17> return ExpressionUtil.serialize(evaluator, pageBase.getPrismContext()); <line18> } catch (SchemaException e) { <line19> LoggingUtils.logUnexpectedException(LOGGER, ""Cannot serialize filter"", e); <line20> } <line21> return null; <line22> } <line23> } <line24> "	Yes	task1	
public class A { <line0> @Test <line1> public void testWorkerRestartWithBlockInConnectorStop() throws Exception { <line2> createConnectorWithBlock(BlockingConnector.class, CONNECTOR_STOP); <line3> waitForConnectorStart(BLOCKING_CONNECTOR_NAME); <line4> createNormalConnector(); <line5> waitForConnectorStart(NORMAL_CONNECTOR_NAME); <line6> connect.removeWorker(); <line7> Block.waitForBlock(); <line8> connect.addWorker(); <line9> waitForConnectorStart(BLOCKING_CONNECTOR_NAME); <line10> verifyNormalConnector(); <line11> } <line12> } <line13> 	Yes	task1	
"public class A { <line0> public static boolean hasAdministratorAccess( <line1> ServletContext servletContext, HttpServletRequest request, HttpServletResponse response) <line2> throws IOException { <line3> ConfigurationSource conf = <line4> (ConfigurationSource) servletContext.getAttribute(CONF_CONTEXT_ATTRIBUTE); <line5> if (!conf.getBoolean(CommonConfigurationKeys.HADOOP_SECURITY_AUTHORIZATION, false)) { <line6> return true; <line7> } <line8> String remoteUser = request.getRemoteUser(); <line9> if (remoteUser == null) { <line10> response.sendError( <line11> HttpServletResponse.SC_FORBIDDEN, <line12> ""Unauthenticated users are not "" + ""authorized to access this page.""); <line13> return false; <line14> } <line15> if (servletContext.getAttribute(ADMINS_ACL) != null <line16> && !userHasAdministratorAccess(servletContext, remoteUser)) { <line17> response.sendError( <line18> HttpServletResponse.SC_FORBIDDEN, <line19> ""Unauthenticated users are not "" + ""authorized to access this page.""); <line20> LOG.warn( <line21> ""User {} is unauthorized to access the page {}."", remoteUser, request.getRequestURI()); <line22> return false; <line23> } <line24> return true; <line25> } <line26> } <line27> "	No	task1	
"public class A { <line0> @VisibleForTesting <line1> static @Nullable Manifest getManifest(Class<?> clazz) throws IOException { <line2> URL classURL = clazz.getResource(clazz.getSimpleName() + "".class""); <line3> if (classURL == null) { <line4> return null; <line5> } <line6> String externalForm = classURL.toExternalForm(); <line7> if (!externalForm.startsWith(""jar:"")) { <line8> return null; <line9> } <line10> URL manifestURL = <line11> new URL( <line12> externalForm.substring(0, externalForm.lastIndexOf('!')) + ""!/META-INF/MANIFEST.MF""); <line13> Closer closer = Closer.create(); <line14> try { <line15> InputStream manifestIn = closer.register(manifestURL.openStream()); <line16> return new Manifest(manifestIn); <line17> } catch (Throwable t) { <line18> throw closer.rethrow(t); <line19> } finally { <line20> closer.close(); <line21> } <line22> } <line23> } <line24> "	Yes	task1	
public class A { <line0> public static com.liferay.commerce.discount.model.CommerceDiscountRelSoap getCommerceDiscountRel( <line1> long commerceDiscountRelId) throws RemoteException { <line2> try { <line3> com.liferay.commerce.discount.model.CommerceDiscountRel returnValue = <line4> CommerceDiscountRelServiceUtil.getCommerceDiscountRel(commerceDiscountRelId); <line5> return com.liferay.commerce.discount.model.CommerceDiscountRelSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> log.error(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	No	task1	
"public class A { <line0> @Test <line1> public void testAggregateRawList() throws Exception { <line2> String xml1 = read(this.getClass().getResourceAsStream(""/jaxb/raw-list-1.xml"")); <line3> String xml2 = read(this.getClass().getResourceAsStream(""/jaxb/raw-list-2.xml"")); <line4> JaxbXMLResponseAggregator aggregate = new JaxbXMLResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(xml1); <line7> data.add(xml2); <line8> String result = aggregate.aggregate(data); <line9> logger.debug(result); <line10> Document xml = toXml(result); <line11> assertNotNull(xml); <line12> NodeList processes = xml.getElementsByTagName(""value""); <line13> assertNotNull(processes); <line14> assertEquals(5, processes.getLength()); <line15> } <line16> } <line17> "	No	task1	
public class A { <line0> @Deprecated <line1> public Domain generateDomain( <line2> String connectionName, String tableName, String dbType, String query, String datasourceName) <line3> throws Exception { <line4> initKettle(); <line5> try { <line6> DatabaseMeta database = AgileHelper.getDatabaseMeta(); <line7> IModelerSource source; <line8> if (tableName != null) { <line9> source = new TableModelerSource(database, tableName, null, datasourceName); <line10> } else { <line11> source = new InlineSqlModelerSource(connectionName, dbType, query, datasourceName); <line12> } <line13> return source.generateDomain(); <line14> } catch (Exception e) { <line15> logger.error(e); <line16> throw new Exception(e.getLocalizedMessage()); <line17> } <line18> } <line19> } <line20> 	No	task1	
"public class A { <line0> @Override <line1> public void initialize() { <line2> logger.debug(""Initializing handler for panel {}"", getThing().getUID()); <line3> updateStatus(ThingStatus.OFFLINE); <line4> Bridge controller = getBridge(); <line5> if (controller == null) { <line6> initializePanel( <line7> new ThingStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, """")); <line8> } else if (ThingStatus.OFFLINE.equals(controller.getStatus())) { <line9> initializePanel( <line10> new ThingStatusInfo( <line11> ThingStatus.OFFLINE, <line12> ThingStatusDetail.BRIDGE_OFFLINE, <line13> ""@text/error.nanoleaf.panel.controllerOffline"")); <line14> } else { <line15> initializePanel(controller.getStatusInfo()); <line16> } <line17> } <line18> } <line19> "	No	task1	
"public class A { <line0> public static Map<String, Map<String, URL>> processUrlRoot( <line1> boolean ignoreNotFound, String root, URL[] resources) throws IOException { <line2> List<URL> baseUrls = <line3> Collections.list(GenericConfigItemFactory.class.getClassLoader().getResources(root)); <line4> if (baseUrls.size() == 0) { <line5> if (ignoreNotFound) { <line6> return new HashMap<String, Map<String, URL>>(); <line7> } else { <line8> throw new IllegalStateException(""Failed to find ["" + root + ""]""); <line9> } <line10> } <line11> Map<String, Map<String, URL>> config = new TreeMap<String, Map<String, URL>>(); <line12> outer: <line13> for (URL resource : resources) { <line14> String name = null; <line15> String path = null; <line16> for (URL baseUrl : baseUrls) { <line17> String base = baseUrl.toExternalForm(); <line18> String fullUrl = resource.toExternalForm(); <line19> if (!fullUrl.startsWith(base)) { <line20> continue; <line21> } <line22> String part = trimLeading(fullUrl.substring(base.length())); <line23> int idx = StringUtils.indexOfAny(part, ""/"", ""\\""); <line24> if (idx != -1) { <line25> name = part.substring(0, idx); <line26> path = part.substring(idx); <line27> break; <line28> } <line29> } <line30> if (name == null) { <line31> log.error(""Ignoring resource [{}] can not find it realtive to root [{}]"", resource, root); <line32> continue; <line33> } <line34> path = trimLeading(path); <line35> if (StringUtils.isBlank(path) || path.endsWith(""/"") || path.endsWith(""\\"")) { <line36> continue; <line37> } <line38> for (String part : path.split(""[/\\\\]"")) { <line39> if (AbstractCachingResourceRoot.shouldIgnore(null, part)) { <line40> continue outer; <line41> } <line42> } <line43> Map<String, URL> urlMapping = config.get(name); <line44> if (urlMapping == null) { <line45> urlMapping = new TreeMap<String, URL>(); <line46> config.put(name, urlMapping); <line47> } <line48> urlMapping.put(path, resource); <line49> } <line50> return config; <line51> } <line52> } <line53> "	No	task1	
"public class A { <line0> @Test(timeout = 60 * 1000) <line1> public void testRequestReply() throws Exception { <line2> final MessageProducer remoteProducer = remoteSession.createProducer(null); <line3> MessageConsumer remoteConsumer = remoteSession.createConsumer(included); <line4> remoteConsumer.setMessageListener( <line5> new MessageListener() { <line6> @Override <line7> public void onMessage(Message msg) { <line8> try { <line9> TextMessage textMsg = (TextMessage) msg; <line10> String payload = ""REPLY: "" + textMsg.getText(); <line11> Destination replyTo; <line12> replyTo = msg.getJMSReplyTo(); <line13> textMsg.clearBody(); <line14> textMsg.setText(payload); <line15> remoteProducer.send(replyTo, textMsg); <line16> } catch (JMSException e) { <line17> e.printStackTrace(); <line18> } <line19> } <line20> }); <line21> TopicRequestor requestor = new TopicRequestor((TopicSession) localSession, included); <line22> Thread.sleep(5000); <line23> for (int i = 0; i < MESSAGE_COUNT; i++) { <line24> TextMessage msg = localSession.createTextMessage(""test msg: "" + i); <line25> TextMessage result = (TextMessage) requestor.request(msg); <line26> assertNotNull(result); <line27> } <line28> } <line29> } <line30> "	Yes	task1	
"public class A { <line0> public void dispose() { <line1> removeListSelectionListener(selListener); <line2> frame.removeFrameListener(listener); <line3> for (OWLFrameListPopupMenuAction<R> action : actions) { <line4> try { <line5> action.dispose(); <line6> } catch (Exception e) { <line7> logger.debug( <line8> ""An error occurred whilst disposing of a menu item in the popup menu in a Frame List"", <line9> e); <line10> } <line11> } <line12> frame.dispose(); <line13> editorKit.getOWLModelManager().removeListener(modelManagerListener); <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> static Map<String, WalState> _getWals(ServerContext c) throws Exception { <line1> while (true) { <line2> try { <line3> Map<String, WalState> result = new HashMap<>(); <line4> WalStateManager wals = new WalStateManager(c); <line5> for (Entry<Path, WalState> entry : wals.getAllState().entrySet()) { <line6> result.put(entry.getKey().toString(), entry.getValue()); <line7> } <line8> return result; <line9> } catch (WalMarkerException wme) { <line10> if (wme.getCause() instanceof NoNodeException) { <line11> log.debug(""WALs changed while reading, retrying"", wme); <line12> } else { <line13> throw wme; <line14> } <line15> } <line16> } <line17> } <line18> } <line19> "	No	task1	
"public class A { <line0> @Override <line1> public Void call() { <line2> try { <line3> EsriFullLayer fullLayer = <line4> ArcGISDescribeLayerEnvoy.query(myToolbox.getDataRegistry(), myLayer.getFullURL()); <line5> if (fullLayer.getCapabilities().contains(""Query"")) { <line6> DefaultDataTypeInfo dataType = createFeatureType(myLayer); <line7> myLayerInfoProvider.updateDataType(dataType, fullLayer); <line8> myLayerGroup.addMember(dataType, this); <line9> } <line10> } catch (QueryException e) { <line11> LOGGER.error(e.getMessage()); <line12> } <line13> return null; <line14> } <line15> } <line16> "	No	task1	
"public class A { <line0> @Override <line1> protected void init(final VaadinRequest request) { <line2> VaadinSession.getCurrent().setErrorHandler(new UiInstanceErrorHandler(this)); <line3> setSizeFull(); <line4> springNavigator.addView(CRLF_REPLACEMENT, mainView); <line5> setNavigator(springNavigator); <line6> final Page currentPage = Page.getCurrent(); <line7> final String requestUrl = currentPage.getLocation().toString(); <line8> final String language = request.getLocale().getLanguage(); <line9> final UserConfiguration userConfiguration = <line10> configurationManager.getUserConfiguration(requestUrl, language); <line11> currentPage.setTitle( <line12> userConfiguration.getAgency().getAgencyName() <line13> + "":"" <line14> + userConfiguration.getPortal().getPortalName() <line15> + "":"" <line16> + userConfiguration.getLanguage().getLanguageName()); <line17> if (getSession().getUIs().isEmpty()) { <line18> final WebBrowser webBrowser = currentPage.getWebBrowser(); <line19> final CreateApplicationSessionRequest serviceRequest = new CreateApplicationSessionRequest(); <line20> serviceRequest.setSessionId(RequestContextHolder.currentRequestAttributes().getSessionId()); <line21> final String ipInformation = WebBrowserUtil.getIpInformation(webBrowser); <line22> serviceRequest.setIpInformation(ipInformation); <line23> serviceRequest.setTimeZone(webBrowser.getTimeZoneId()); <line24> serviceRequest.setScreenSize( <line25> webBrowser.getScreenWidth() + ""x"" + webBrowser.getScreenHeight()); <line26> serviceRequest.setUserAgentInformation(webBrowser.getBrowserApplication()); <line27> serviceRequest.setLocale(webBrowser.getLocale().toString()); <line28> serviceRequest.setOperatingSystem(WebBrowserUtil.getOperatingSystem(webBrowser)); <line29> serviceRequest.setSessionType(ApplicationSessionType.ANONYMOUS); <line30> final ServiceResponse serviceResponse = applicationManager.service(serviceRequest); <line31> LOGGER.info( <line32> LOG_INFO_BROWSER_ADDRESS_APPLICATION_SESSION_ID_RESULT, <line33> requestUrl.replaceAll(CRLF, CRLF_REPLACEMENT), <line34> language.replaceAll(CRLF, CRLF_REPLACEMENT), <line35> ipInformation.replaceAll(CRLF, CRLF_REPLACEMENT), <line36> webBrowser.getBrowserApplication().replaceAll(CRLF, CRLF_REPLACEMENT), <line37> serviceRequest.getSessionId().replaceAll(CRLF, CRLF_REPLACEMENT), <line38> serviceResponse.getResult().toString().replaceAll(CRLF, CRLF_REPLACEMENT)); <line39> } <line40> } <line41> } <line42> "	No	task1	
"public class A { <line0> public ComputationExceptionBuilder addFileIfExists(@Nullable Path path) { <line1> if (path == null || !Files.exists(path)) { <line2> return this; <line3> } <line4> try { <line5> byte[] bytes = Files.readAllBytes(path); <line6> bytesByFileName.put(path.getFileName().toString(), bytes); <line7> } catch (IOException e) { <line8> LOGGER.warn(""Can not read zip file '{}'"", path); <line9> } <line10> return this; <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> public static void main(String[] args) { <line1> try { <line2> SysPerfBaseliner sysPerfBaseliner = new SysPerfBaseliner(); <line3> Collection<RunResult> jmhResults = sysPerfBaseliner.runBenchmarks(); <line4> logger.info( <line5> ""SysPerfData (selected details for EB):\n"" <line6> + new SysPerfData(jmhResults, SysPerfData.currentVersion).toString()); <line7> } catch (Exception e) { <line8> throw new RuntimeException(e); <line9> } <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> public void handlePushCommand(String command, String payload) { <line1> this.logger.debug(""Handle push command {}"", command); <line2> switch (command) { <line3> case ""PUSH_VOLUME_CHANGE"": <line4> JsonCommandPayloadPushVolumeChange volumeChange = <line5> Objects.requireNonNull( <line6> gson.fromJson(payload, JsonCommandPayloadPushVolumeChange.class)); <line7> Connection connection = this.findConnection(); <line8> Integer volumeSetting = volumeChange.volumeSetting; <line9> Boolean muted = volumeChange.isMuted; <line10> if (muted != null && muted) { <line11> updateState(CHANNEL_VOLUME, new PercentType(0)); <line12> } <line13> if (volumeSetting != null <line14> && connection != null <line15> && !connection.isSequenceNodeQueueRunning()) { <line16> lastKnownVolume = volumeSetting; <line17> updateState(CHANNEL_VOLUME, new PercentType(lastKnownVolume)); <line18> } <line19> break; <line20> case ""PUSH_EQUALIZER_STATE_CHANGE"": <line21> updateEqualizerState(); <line22> break; <line23> default: <line24> AccountHandler account = this.account; <line25> Device device = this.device; <line26> if (account != null && device != null) { <line27> this.disableUpdate = false; <line28> updateState(account, device, null, null, null, null, null, null); <line29> } <line30> } <line31> } <line32> } <line33> "	No	task1	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> @Override <line2> protected Query getQuery(QueryManager qm, ExecutionContext context) throws RepositoryException { <line3> StringBuilder statement = new StringBuilder(""/jcr:root/""); <line4> statement <line5> .append(((String) context.getMap().get(ScalabilityBlobSearchSuite.CTX_ROOT_NODE_NAME_PROP))) <line6> .append(""//element(*, "") <line7> .append(context.getMap().get(ScalabilityBlobSearchSuite.CTX_FILE_NODE_TYPE_PROP)) <line8> .append("")""); <line9> statement.append(""[((""); <line10> for (MimeType mt : MimeType.values()) { <line11> statement <line12> .append(""jcr:content/@"") <line13> .append(NodeTypeConstants.JCR_MIMETYPE) <line14> .append("" = '"") <line15> .append(mt.getValue()) <line16> .append(""' or ""); <line17> } <line18> statement.delete(statement.lastIndexOf("" or ""), statement.length()); <line19> statement.append(""))]""); <line20> LOG.debug(""{}"", statement); <line21> return qm.createQuery(statement.toString(), Query.XPATH); <line22> } <line23> } <line24> "	No	task1	
public class A { <line0> @NotNull <line1> @Override <line2> public Set<Principal> getMembershipPrincipals(@NotNull Principal principal) { <line3> if (!GroupPrincipals.isGroup(principal)) { <line4> try { <line5> if (principal instanceof ItemBasedPrincipal) { <line6> Tree t = root.getTree(((ItemBasedPrincipal) principal).getPath()); <line7> return getGroupPrincipals(t); <line8> } else { <line9> return getGroupPrincipals(userManager.getAuthorizable(principal)); <line10> } <line11> } catch (RepositoryException e) { <line12> log.debug(e.getMessage()); <line13> } <line14> } <line15> return ImmutableSet.of(); <line16> } <line17> } <line18> 	No	task1	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected void setSensor(Object v) { <line2> if (Entities.isNoLongerManaged(entity)) { <line3> if (Tasks.isInterrupted()) return; <line4> log.warn( <line5> """" <line6> + entity <line7> + "" is not managed; feed "" <line8> + this <line9> + "" setting "" <line10> + sensor <line11> + "" to "" <line12> + v <line13> + "" at this time is not supported ("" <line14> + Tasks.current() <line15> + "")""); <line16> } <line17> if (v == FeedConfig.UNCHANGED) { <line18> } else if (v == FeedConfig.REMOVE) { <line19> ((EntityInternal) entity).sensors().remove(sensor); <line20> feed.onRemoveSensor(sensor); <line21> } else if (sensor == FeedConfig.NO_SENSOR) { <line22> } else { <line23> Object coercedV = TypeCoercions.coerce(v, sensor.getType()); <line24> if (suppressDuplicates && Objects.equal(coercedV, entity.getAttribute(sensor))) { <line25> } else { <line26> entity.sensors().set(sensor, coercedV); <line27> feed.onPublishSensor(sensor, coercedV); <line28> } <line29> } <line30> } <line31> } <line32> "	Yes	task1	
"public class A { <line0> private String generateJMXConfig(JmxTransSpec spec, int numOfBrokers) <line1> throws JsonProcessingException { <line2> JmxTransServers servers = new JmxTransServers(); <line3> servers.setServers(new ArrayList<>()); <line4> ObjectMapper mapper = new ObjectMapper(); <line5> String headlessService = KafkaCluster.headlessServiceName(cluster); <line6> for (int brokerNumber = 0; brokerNumber < numOfBrokers; brokerNumber++) { <line7> String brokerServiceName = <line8> KafkaCluster.externalServiceName(clusterName, brokerNumber) + ""."" + headlessService; <line9> servers.getServers().add(convertSpecToServers(spec, brokerServiceName)); <line10> } <line11> try { <line12> return mapper.writeValueAsString(servers); <line13> } catch (JsonProcessingException e) { <line14> throw e; <line15> } <line16> } <line17> } <line18> "	Yes	task1	
"public class A { <line0> @Override <line1> public List<HumanLabeledDocumentDTO> getHumanLabeledDocumentsByCrisisCodeUserName( <line2> String crisisCode, String userName, Integer count) { <line3> try { <line4> CollectionDTO crisis = remoteCrisisEJB.getCrisisByCode(crisisCode); <line5> if (crisis != null) { <line6> return remoteTaskManager.getHumanLabeledDocumentsByCrisisIDUserName( <line7> crisis.getCrisisID(), userName, count); <line8> } else { <line9> return null; <line10> } <line11> } catch (Exception e) { <line12> logger.error(""exception for crisis = "" + crisisCode + "", userName = "" + userName, e); <line13> return null; <line14> } <line15> } <line16> } <line17> "	No	task1	
"public class A { <line0> private void doUpdate(final TimerOptions options) { <line1> shutdownExecutor(); <line2> try { <line3> if (""SIMPLE"".equalsIgnoreCase(options.getType())) { <line4> this.timerExecutor = Optional.of(new SimpleTimerExecutor(options, this.wireSupport)); <line5> } else { <line6> this.timerExecutor = Optional.of(new CronTimerExecutor(options, this.wireSupport)); <line7> } <line8> } catch (final Exception e) { <line9> } <line10> } <line11> } <line12> "	Yes	task1	
public class A { <line0> protected Map<String, Set<Obs>> separateObs(Set<Obs> obsSet, boolean includeImagingStudy) { <line1> Map<String, Set<Obs>> obsSetsMap = new HashMap<>(); <line2> obsSetsMap.put(FHIRConstants.DIAGNOSTIC_REPORT_NAME, new HashSet<Obs>()); <line3> obsSetsMap.put(FHIRConstants.DIAGNOSTIC_REPORT_STATUS, new HashSet<Obs>()); <line4> obsSetsMap.put(FHIRConstants.DIAGNOSTIC_REPORT_RESULT, new HashSet<Obs>()); <line5> obsSetsMap.put(FHIRConstants.DIAGNOSTIC_REPORT_PRESENTED_FORM, new HashSet<Obs>()); <line6> if (includeImagingStudy) { <line7> obsSetsMap.put(FHIRConstants.DIAGNOSTIC_REPORT_IMAGING_STUDY, new HashSet<Obs>()); <line8> } <line9> for (Obs obs : obsSet) { <line10> try { <line11> obsSetsMap.get(getFieldName(obs.getConcept())).add(obs); <line12> } catch (NoSuchFieldException e) { <line13> log.error(e.getMessage()); <line14> } <line15> } <line16> return obsSetsMap; <line17> } <line18> } <line19> 	No	task1	
"public class A { <line0> public Map<String, List<String>> findAnnotationValueWithHostAnnotation( <line1> String annotationType, boolean searchMeta, Set<String> visited) { <line2> if (dimensions > 0) { <line3> return Collections.emptyMap(); <line4> } <line5> if (!visited.add(this.getName())) { <line6> return Collections.emptyMap(); <line7> } <line8> Map<String, List<String>> collectedResults = new LinkedHashMap<>(); <line9> if (node.visibleAnnotations != null) { <line10> for (AnnotationNode an : node.visibleAnnotations) { <line11> if (an.desc.equals(annotationType)) { <line12> List<Object> values = an.values; <line13> if (values != null) { <line14> for (int i = 0; i < values.size(); i += 2) { <line15> if (values.get(i).equals(""value"")) { <line16> List<String> importedReferences = <line17> ((List<org.objectweb.asm.Type>) values.get(i + 1)) <line18> .stream().map(t -> t.getDescriptor()).collect(Collectors.toList()); <line19> collectedResults.put(this.getName().replace(""/"", "".""), importedReferences); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> if (searchMeta) { <line26> for (AnnotationNode an : node.visibleAnnotations) { <line27> Type annoType = null; <line28> try { <line29> annoType = typeSystem.Lresolve(an.desc); <line30> } catch (MissingTypeException mte) { <line31> continue; <line32> } <line33> collectedResults.putAll( <line34> annoType.findAnnotationValueWithHostAnnotation(annotationType, searchMeta, visited)); <line35> } <line36> } <line37> } <line38> return collectedResults; <line39> } <line40> } <line41> "	Yes	task1	
"public class A { <line0> @Override <line1> public MessageListener getMessageListener() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> throw new IllegalStateException(""Method not allowed""); <line5> } <line6> } <line7> "	Yes	task1	
"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> int restartGrid = GRID_CNT - RESTARTED_NODE_CNT; <line3> while (!stopRestartThread.get() && System.currentTimeMillis() < endTime) { <line4> log.info(""Restart grid: "" + restartGrid); <line5> stopGrid(restartGrid); <line6> Thread.sleep(500); <line7> startGrid(restartGrid); <line8> GridTestUtils.waitForCondition( <line9> new GridAbsPredicate() { <line10> @Override <line11> public boolean apply() { <line12> return !stopRestartThread.get(); <line13> } <line14> }, <line15> RESTART_TIMEOUT); <line16> restartGrid++; <line17> if (restartGrid >= GRID_CNT) restartGrid = GRID_CNT - RESTARTED_NODE_CNT; <line18> awaitPartitionMapExchange(); <line19> } <line20> return null; <line21> } <line22> } <line23> "	No	task1	
public class A { <line0> @Override <line1> public void onError(final RaftException e) { <line2> } <line3> } <line4> 	Yes	task1	
"public class A { <line0> @Override <line1> public void windowWillBeginSheet(final NSNotification notification) { <line2> if (log.isDebugEnabled()) { <line3> log.debug(String.format(""Attach sheet for window %s"", window)); <line4> } <line5> } <line6> } <line7> "	No	task1	
"public class A { <line0> @Override <line1> public FileVisitResult visitFile(Path filePath, BasicFileAttributes basicFileAttributes) <line2> throws IOException { <line3> Path fileNamePath = filePath.getFileName(); <line4> String fileName = StringUtil.toLowerCase(fileNamePath.toString()); <line5> if (!fileName.endsWith("".jar"")) { <line6> return FileVisitResult.CONTINUE; <line7> } <line8> if (_isValid(fileName)) { <line9> jarPaths.add(filePath.toAbsolutePath()); <line10> return FileVisitResult.CONTINUE; <line11> } <line12> if (log.isWarnEnabled()) { <line13> } <line14> return FileVisitResult.CONTINUE; <line15> } <line16> } <line17> "	Yes	task1	
public class A { <line0> Future<Void> removeAndUndeploy(String srvcId) { <line1> return deployments <line2> .get(srvcId) <line3> .compose( <line4> res -> { <line5> if (res == null) { <line6> return Future.failedFuture(new OkapiError(ErrorType.NOT_FOUND, srvcId)); <line7> } <line8> return removeAndUndeploy(res); <line9> }); <line10> } <line11> } <line12> 	Yes	task1	
"public class A { <line0> public CassandraPartitionResult getPartitions( <line1> CassandraTableHandle cassandraTableHandle, TupleDomain<ColumnHandle> tupleDomain) { <line2> CassandraTable table = cassandraSession.getTable(cassandraTableHandle.getSchemaTableName()); <line3> List<CassandraColumnHandle> partitionKeys = table.getPartitionKeyColumns(); <line4> List<CassandraPartition> allPartitions = getCassandraPartitions(table, tupleDomain); <line5> log.debug( <line6> ""%s.%s #partitions: %d"", <line7> cassandraTableHandle.getSchemaName(), <line8> cassandraTableHandle.getTableName(), <line9> allPartitions.size()); <line10> List<CassandraPartition> partitions = <line11> allPartitions.stream() <line12> .filter(partition -> tupleDomain.overlaps(partition.getTupleDomain())) <line13> .collect(toList()); <line14> TupleDomain<ColumnHandle> remainingTupleDomain = TupleDomain.none(); <line15> if (!tupleDomain.isNone()) { <line16> if (partitions.size() == 1 && partitions.get(0).isUnpartitioned()) { <line17> remainingTupleDomain = tupleDomain; <line18> } else { <line19> List<ColumnHandle> partitionColumns = ImmutableList.copyOf(partitionKeys); <line20> remainingTupleDomain = <line21> tupleDomain.filter((column, domain) -> !partitionColumns.contains(column)); <line22> } <line23> } <line24> if ((partitions.size() == 1) && partitions.get(0).isUnpartitioned()) { <line25> Map<ColumnHandle, Domain> domains = tupleDomain.getDomains().get(); <line26> List<ColumnHandle> indexedColumns = new ArrayList<>(); <line27> StringBuilder sb = new StringBuilder(); <line28> for (Map.Entry<ColumnHandle, Domain> entry : domains.entrySet()) { <line29> CassandraColumnHandle column = (CassandraColumnHandle) entry.getKey(); <line30> Domain domain = entry.getValue(); <line31> if (column.isIndexed() && domain.isSingleValue()) { <line32> sb.append(CassandraCqlUtils.validColumnName(column.getName())) <line33> .append("" = "") <line34> .append(column.getCassandraType().toCqlLiteral(entry.getValue().getSingleValue())); <line35> indexedColumns.add(column); <line36> break; <line37> } <line38> } <line39> if (sb.length() > 0) { <line40> CassandraPartition partition = partitions.get(0); <line41> TupleDomain<ColumnHandle> filterIndexedColumn = <line42> TupleDomain.withColumnDomains( <line43> Maps.filterKeys(remainingTupleDomain.getDomains().get(), not(in(indexedColumns)))); <line44> partitions = new ArrayList<>(); <line45> partitions.add( <line46> new CassandraPartition(partition.getKey(), sb.toString(), filterIndexedColumn, true)); <line47> return new CassandraPartitionResult(partitions, filterIndexedColumn); <line48> } <line49> } <line50> return new CassandraPartitionResult(partitions, remainingTupleDomain); <line51> } <line52> } <line53> "	Yes	task1	
"public class A { <line0> private void updateContent( <line1> VirtualFileImpl virtualFile, <line2> String mediaType, <line3> InputStream content, <line4> String lockToken, <line5> boolean updateMediaType) <line6> throws ForbiddenException, ServerException { <line7> if (!virtualFile.isFile()) { <line8> throw new ForbiddenException( <line9> String.format(""Unable update content. Item '%s' is not file. "", virtualFile.getPath())); <line10> } <line11> if (systemFilter.accept(workspaceId, virtualFile.getVirtualFilePath())) { <line12> if (!hasPermission(virtualFile, BasicPermissions.WRITE, true)) { <line13> throw new ForbiddenException( <line14> String.format( <line15> ""Unable update content of file '%s'. Operation not permitted. "", <line16> virtualFile.getPath())); <line17> } <line18> } <line19> if (!validateLockTokenIfLocked(virtualFile, lockToken)) { <line20> throw new ForbiddenException( <line21> String.format( <line22> ""Unable update content of file '%s'. File is locked. "", virtualFile.getPath())); <line23> } <line24> if (updateMediaType) { <line25> doUpdateContent(virtualFile, mediaType, content); <line26> } else { <line27> doUpdateContent(virtualFile, content); <line28> } <line29> if (searcherProvider != null) { <line30> try { <line31> searcherProvider.getSearcher(this, true).update(virtualFile); <line32> } catch (ServerException e) { <line33> } <line34> } <line35> eventService.publish(new UpdateContentEvent(workspaceId, virtualFile.getPath())); <line36> } <line37> } <line38> "	Yes	task1	
"public class A { <line0> public void onNodeMovedAsMaster(UDNode node, UDGroup group) { <line1> Freedomotic.logger.info( <line2> ""Insteon device "" <line3> + node.name <line4> + "" is now part of the "" <line5> + group.name <line6> + "" scene as a master/controller""); <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> public void setState(int state) { <line1> LOG.debug().$(""state change [old="").$(this.state).$("", new="").$(state).$(']').$(); <line2> this.state = state; <line3> jsonLexer.clear(); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> private WriteResult tryWriteLockOnce(StaticBuffer key, StaticBuffer del, StoreTransaction txh) { <line1> Throwable t = null; <line2> final Timer writeTimer = times.getTimer().start(); <line3> StaticBuffer newLockCol = serializer.toLockCol(writeTimer.getStartTime(), rid, times); <line4> Entry newLockEntry = StaticArrayEntry.of(newLockCol, zeroBuf); <line5> try { <line6> StoreTransaction newTx = overrideTimestamp(txh, writeTimer.getStartTime()); <line7> store.mutate( <line8> key, <line9> Arrays.asList(newLockEntry), <line10> null == del ? KeyColumnValueStore.NO_DELETIONS : Arrays.asList(del), <line11> newTx); <line12> } catch (BackendException e) { <line13> log.debug(""Lock write attempt failed with exception"", e); <line14> t = e; <line15> } <line16> writeTimer.stop(); <line17> return new WriteResult(writeTimer.elapsed(), writeTimer.getStartTime(), newLockCol, t); <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> @Override <line1> public org.apache.blur.thrift.generated.Response reconnect(long instanceExecutionId) <line2> throws BlurException, TimeoutException, TException { <line3> try { <line4> Response response = _commandManager.reconnect(instanceExecutionId); <line5> return CommandUtil.fromObjectToThrift(response, _serDe); <line6> } catch (Exception e) { <line7> if (e instanceof org.apache.blur.command.TimeoutException) { <line8> throw new TimeoutException( <line9> ((org.apache.blur.command.TimeoutException) e).getInstanceExecutionId()); <line10> } <line11> LOG.error( <line12> ""Unknown error while trying to reconnect to executing command [{0}]"", <line13> e, instanceExecutionId); <line14> if (e instanceof BlurException) { <line15> throw (BlurException) e; <line16> } <line17> throw new BException(e.getMessage(), e); <line18> } <line19> } <line20> } <line21> "	Yes	task1	
"public class A { <line0> @Override <line1> public synchronized Map<NodeId, NodeInfo> getAllNodeInfos(NodeId bigger, int maxCount) <line2> throws ItemStateException { <line3> ResultSet rs = null; <line4> try { <line5> String sql = bundleSelectAllBundlesSQL; <line6> NodeId lowId = null; <line7> Object[] keys = new Object[0]; <line8> if (bigger != null) { <line9> sql = bundleSelectAllBundlesFromSQL; <line10> lowId = bigger; <line11> keys = getKey(bigger); <line12> } <line13> if (getStorageModel() == SM_LONGLONG_KEYS && maxCount > 0) { <line14> maxCount += 10; <line15> } <line16> rs = conHelper.exec(sql, keys, false, maxCount); <line17> Map<NodeId, NodeInfo> result = new LinkedHashMap<NodeId, NodeInfo>(maxCount); <line18> while ((maxCount == 0 || result.size() < maxCount) && rs.next()) { <line19> NodeId current; <line20> if (getStorageModel() == SM_BINARY_KEYS) { <line21> current = new NodeId(rs.getBytes(1)); <line22> } else { <line23> long high = rs.getLong(1); <line24> long low = rs.getLong(2); <line25> current = new NodeId(high, low); <line26> } <line27> if (getStorageModel() == SM_LONGLONG_KEYS && lowId != null) { <line28> if (current.compareTo(lowId) <= 0) { <line29> continue; <line30> } <line31> } <line32> NodePropBundle bundle = <line33> readBundle(current, rs, getStorageModel() == SM_LONGLONG_KEYS ? 3 : 2); <line34> NodeInfo nodeInfo = new NodeInfo(bundle); <line35> result.put(nodeInfo.getId(), nodeInfo); <line36> } <line37> return result; <line38> } catch (SQLException e) { <line39> String msg = ""getAllNodeIds failed.""; <line40> throw new ItemStateException(msg, e); <line41> } finally { <line42> DbUtility.close(rs); <line43> } <line44> } <line45> } <line46> "	Yes	task1	
"public class A { <line0> @Test( <line1> groups = {""wso2.cep""}, <line2> description = ""Testing logger connection"", <line3> expectedExceptions = AxisFault.class) <line4> public void testConnection() throws AxisFault { <line5> BasicOutputAdapterPropertyDto[] outputPropertyConfiguration = <line6> new BasicOutputAdapterPropertyDto[] {}; <line7> try { <line8> eventPublisherAdminServiceClient.testConnection( <line9> ""logger"", ""logger"", outputPropertyConfiguration, ""xml""); <line10> } catch (AxisFault e) { <line11> throw new AxisFault(e.getMessage(), e); <line12> } catch (RemoteException e) { <line13> Assert.fail(""Exception: "" + e.getMessage()); <line14> } <line15> } <line16> } <line17> "	Yes	task1	
"public class A { <line0> private void _validateNetworkHostAddresses(Dictionary<String, Object> properties) <line1> throws Exception { <line2> String[] networkHostAddresses = <line3> GetterUtil.getStringValues(properties.get(""networkHostAddresses"")); <line4> for (String networkHostAddress : networkHostAddresses) { <line5> if (!Validator.isBlank(networkHostAddress)) { <line6> return; <line7> } <line8> } <line9> log.error(""Unable to validate network host addresses""); <line10> throw new Exception(_getMessage(""please-set-at-least-one-network-host-address"")); <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> protected Model getModelFromTdbDS() { <line1> logger.debug(""Retrieving TDB Repo default model from Dataset "" + tdbDS); <line2> Dataset ds = getTdbDS(false); <line3> getTdbDS(true).begin(ReadWrite.READ); <line4> Model m = tdbDS.getDefaultModel(); <line5> tdbDS.end(); <line6> if (ds == null) { <line7> closeTdbDS(); <line8> } <line9> return m; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> private Hashtable<String, String> loadConfigurationSettings(InputStream stream) { <line1> try { <line2> configurationFromFile = new Yaml().loadAs(stream, LinkedHashMap.class); <line3> } catch (Exception e) { <line4> ConfigurationException exception = <line5> new ConfigurationException( <line6> ""Configuration from "" + configurationInputSourceName + "" is not correctly formatted""); <line7> throw exception; <line8> } finally { <line9> IOUtils.closeQuietly(stream); <line10> } <line11> if (configurationFromFile == null) { <line12> configurationFromFile = new LinkedHashMap<>(); <line13> } <line14> return mapToDDoc4JDocConfiguration(); <line15> } <line16> } <line17> "	Yes	task1	
public class A { <line0> private static void usage() { <line1> logger.info(usageString); <line2> System.exit(0); <line3> } <line4> } <line5> 	No	task1	
public class A { <line0> @Override <line1> public boolean isExecutable() { <line2> return file.canExecute(); <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> @Override <line1> public boolean isCommentable() { <line2> try { <line3> Calendar calendar = _calendarBooking.getCalendar(); <line4> return calendar.isEnableComments(); <line5> } catch (Exception exception) { <line6> log.error(""Unable to check commentable"", exception); <line7> } <line8> return false; <line9> } <line10> } <line11> "	No	task1	
public class A { <line0> private Column getTextContentColumn(MutableTable table, String preferredColumnName) { <line1> MutableColumn column = null; <line2> for (Column col : table.getColumns()) { <line3> if (NATIVE_TYPE_TEXT.equals(col.getNativeType())) { <line4> column = (MutableColumn) col; <line5> break; <line6> } <line7> } <line8> if (column == null && preferredColumnName != null) { <line9> column = <line10> new MutableColumn( <line11> preferredColumnName + TEXT_CONTENT_TEMP_SUFFIX, <line12> ColumnType.STRING, <line13> table, <line14> table.getColumnCount(), <line15> true); <line16> column.setNativeType(NATIVE_TYPE_TEXT); <line17> table.addColumn(column); <line18> } <line19> return column; <line20> } <line21> } <line22> 	Yes	task1	
"public class A { <line0> public Object run() throws IOException, URISyntaxException { <line1> Credentials creds = new Credentials(); <line2> collectTokens(FileSystem.get(conf), twrapper, creds, ugi.getShortUserName()); <line3> Collection<String> URIs = conf.getStringCollection(""mapreduce.job.hdfs-servers""); <line4> for (String uri : URIs) { <line5> LOG.debug(""Getting tokens for "" + uri); <line6> collectTokens(FileSystem.get(new URI(uri), conf), twrapper, creds, ugi.getShortUserName()); <line7> } <line8> return null; <line9> } <line10> } <line11> "	No	task1	
"public class A { <line0> public String[] getAccessibleWorkspaceNames() throws RepositoryException { <line1> sanityCheck(); <line2> List<String> names = new ArrayList<String>(); <line3> WorkspaceManager manager = context.getRepositoryContext().getWorkspaceManager(); <line4> for (String name : manager.getWorkspaceNames()) { <line5> try { <line6> if (context.getAccessManager().canAccess(name)) { <line7> names.add(name); <line8> } <line9> } catch (NoSuchWorkspaceException e) { <line10> log.warn(""Workspace disappeared unexpectedly: "" + name, e); <line11> } <line12> } <line13> return names.toArray(new String[names.size()]); <line14> } <line15> } <line16> "	No	task1	
"public class A { <line0> public static String getCanonicalNameForWebAppTmpDir(WebAppContext context) { <line1> StringBuffer canonicalName = new StringBuffer(); <line2> canonicalName.append(""jetty-""); <line3> Server server = context.getServer(); <line4> if (server != null) { <line5> Connector[] connectors = context.getServer().getConnectors(); <line6> if (connectors.length > 0) { <line7> String host = null; <line8> int port = 0; <line9> if (connectors != null && (connectors[0] instanceof NetworkConnector)) { <line10> NetworkConnector connector = (NetworkConnector) connectors[0]; <line11> host = connector.getHost(); <line12> port = connector.getLocalPort(); <line13> if (port < 0) port = connector.getPort(); <line14> } <line15> if (host == null) host = ""0.0.0.0""; <line16> canonicalName.append(host); <line17> canonicalName.append(""-""); <line18> canonicalName.append(port); <line19> canonicalName.append(""-""); <line20> } <line21> } <line22> try { <line23> Resource resource = context.getBaseResource(); <line24> if (resource == null) { <line25> if (context.getWar() == null || context.getWar().length() == 0) <line26> throw new IllegalStateException(""No resourceBase or war set for context""); <line27> resource = context.newResource(context.getWar()); <line28> } <line29> String resourceBaseName = getResourceBaseName(resource); <line30> canonicalName.append(resourceBaseName); <line31> canonicalName.append(""-""); <line32> } catch (Exception e) { <line33> canonicalName.append(""-""); <line34> } <line35> String contextPath = context.getContextPath(); <line36> contextPath = contextPath.replace('/', '_'); <line37> contextPath = contextPath.replace('\\', '_'); <line38> canonicalName.append(contextPath); <line39> canonicalName.append(""-""); <line40> String[] vhosts = context.getVirtualHosts(); <line41> if (vhosts == null || vhosts.length <= 0) canonicalName.append(""any""); <line42> else canonicalName.append(vhosts[0]); <line43> for (int i = 0; i < canonicalName.length(); i++) { <line44> char c = canonicalName.charAt(i); <line45> if (!Character.isJavaIdentifierPart(c) && ""-."".indexOf(c) < 0) <line46> canonicalName.setCharAt(i, '.'); <line47> } <line48> canonicalName.append(""-""); <line49> return StringUtil.sanitizeFileSystemName(canonicalName.toString()); <line50> } <line51> } <line52> "	Yes	task1	
"public class A { <line0> private GridCoverage2D transformResult( <line1> final GridCoverage2D coverage, <line2> final Rectangle pixelDimension, <line3> final GeoWaveRasterReaderState state) { <line4> if (state.getRequestEnvelopeXformed() == state.getRequestedEnvelope()) { <line5> return coverage; <line6> } <line7> GridCoverage2D result = null; <line8> LOGGER.info(""Image reprojection necessary""); <line9> result = <line10> (GridCoverage2D) <line11> RasterUtils.getCoverageOperations() <line12> .resample(coverage, state.getRequestedEnvelope().getCoordinateReferenceSystem()); <line13> return coverageFactory.create( <line14> result.getName(), result.getRenderedImage(), result.getEnvelope()); <line15> } <line16> } <line17> "	No	task1	
"public class A { <line0> @Override <line1> protected void printResult(MetadataListResult res, Logger log) { <line2> for (BinaryMetadata m : res.metadata()) { <line3> log.info( <line4> ""typeId="" <line5> + printInt(m.typeId()) <line6> + "", typeName="" <line7> + m.typeName() <line8> + "", fields="" <line9> + m.fields().size() <line10> + "", schemas="" <line11> + m.schemas().size() <line12> + "", isEnum="" <line13> + m.isEnum()); <line14> } <line15> } <line16> } <line17> "	Yes	task1	
public class A { <line0> private void handleRequest( <line1> final ServerProtocol protocol, final Peer peer, final RequestType requestType) <line2> throws IOException, NotAuthorizedException, BadRequestException, RequestExpiredException { <line3> switch (requestType) { <line4> case NEGOTIATE_FLOWFILE_CODEC: <line5> protocol.negotiateCodec(peer); <line6> break; <line7> case RECEIVE_FLOWFILES: <line8> protocol.getPort().transferFlowFiles(peer, protocol); <line9> break; <line10> case SEND_FLOWFILES: <line11> protocol.getPort().receiveFlowFiles(peer, protocol); <line12> break; <line13> case REQUEST_PEER_LIST: <line14> final Optional<ClusterNodeInformation> nodeInfo = <line15> (nodeInformant == null) <line16> ? Optional.empty() <line17> : Optional.of(nodeInformant.getNodeInformation()); <line18> String remoteInputHostVal = nifiProperties.getRemoteInputHost(); <line19> if (remoteInputHostVal == null) { <line20> remoteInputHostVal = InetAddress.getLocalHost().getHostName(); <line21> } <line22> final Boolean isSiteToSiteSecure = nifiProperties.isSiteToSiteSecure(); <line23> final Integer apiPort = <line24> isSiteToSiteSecure ? nifiProperties.getSslPort() : nifiProperties.getPort(); <line25> final NodeInformation self = <line26> new NodeInformation( <line27> remoteInputHostVal, <line28> nifiProperties.getRemoteInputPort(), <line29> nifiProperties.getRemoteInputHttpPort(), <line30> apiPort != null ? apiPort : 0, <line31> isSiteToSiteSecure, <line32> 0); <line33> protocol.sendPeerList(peer, nodeInfo, self); <line34> break; <line35> case SHUTDOWN: <line36> protocol.shutdown(peer); <line37> break; <line38> } <line39> } <line40> } <line41> 	Yes	task1	
"public class A { <line0> protected static void doMultiUserGets( <line1> final int num, final int numOfUsers, final int[] expectedResults) { <line2> if (numOfUsers != expectedResults.length) { <line3> fail( <line4> ""SecurityTestUtils.doMultiUserGets(): numOfUsers = "" <line5> + numOfUsers <line6> + "", but expected results "" <line7> + expectedResults.length); <line8> } <line9> for (int i = 0; i < numOfUsers; i++) { <line10> doGetsP(num, i, expectedResults[i], false); <line11> } <line12> } <line13> } <line14> "	Yes	task1	
"public class A { <line0> public void rollback( <line1> JmsTransactionInfo transactionInfo, <line2> JmsTransactionInfo nextTransactionInfo, <line3> final AsyncResult request) <line4> throws ProviderException { <line5> if (!transactionInfo.getId().equals(current)) { <line6> if (!transactionInfo.isInDoubt() && current == null) { <line7> throw new ProviderIllegalStateException(""Rollback called with no active Transaction.""); <line8> } else if (!transactionInfo.isInDoubt() && current != null) { <line9> throw new ProviderIllegalStateException( <line10> ""Attempt to rollback a transaction other than the current one""); <line11> } else { <line12> request.onSuccess(); <line13> return; <line14> } <line15> } <line16> preRollback(); <line17> DischargeCompletion completion = new DischargeCompletion(request, nextTransactionInfo, false); <line18> coordinator.discharge(current, completion); <line19> current = null; <line20> if (completion.isPipelined()) { <line21> if (!completion.isComplete()) { <line22> begin(nextTransactionInfo.getId(), completion.getDeclareCompletion()); <line23> } else { <line24> completion.getDeclareCompletion().onFailure(completion.getFailureCause()); <line25> } <line26> } <line27> } <line28> } <line29> "	Yes	task1	
"public class A { <line0> public void convertFormXMLToDb(Integer formId) { <line1> CaisiForm form = caisiFormDao.find(formId); <line2> SurveyDocument model = null; <line3> try { <line4> model = SurveyDocument.Factory.parse(new StringReader(form.getSurveyData())); <line5> } catch (Exception e) { <line6> return; <line7> } <line8> int page = 1; <line9> int section = 0; <line10> String id = """"; <line11> LinkedHashMap<String, String> keyMap = new LinkedHashMap<String, String>(); <line12> List<CaisiFormQuestion> ofqs = new ArrayList<CaisiFormQuestion>(); <line13> for (Page p : model.getSurvey().getBody().getPageArray()) { <line14> section = 0; <line15> for (Page.QContainer container : p.getQContainerArray()) { <line16> if (container.isSetQuestion()) { <line17> Question q = container.getQuestion(); <line18> id = page + ""_"" + section + ""_"" + q.getId(); <line19> CaisiFormQuestion ofq = new CaisiFormQuestion(); <line20> ofq.setDescription(q.getDescription()); <line21> ofq.setFormId(formId); <line22> ofq.setPage(page); <line23> ofq.setSection(section); <line24> ofq.setQuestion(q.getId()); <line25> ofq.setType(getTypeAsString(q)); <line26> ofqs.add(ofq); <line27> keyMap.put(id, q.getDescription()); <line28> } else { <line29> for (Question q : container.getSection().getQuestionArray()) { <line30> Section s = container.getSection(); <line31> section = s.getId(); <line32> id = page + ""_"" + section + ""_"" + q.getId(); <line33> CaisiFormQuestion ofq = new CaisiFormQuestion(); <line34> ofq.setDescription(q.getDescription()); <line35> ofq.setFormId(formId); <line36> ofq.setPage(page); <line37> ofq.setSection(section); <line38> ofq.setQuestion(q.getId()); <line39> ofq.setType(getTypeAsString(q)); <line40> ofqs.add(ofq); <line41> keyMap.put(id, q.getDescription()); <line42> } <line43> } <line44> } <line45> page++; <line46> } <line47> for (CaisiFormQuestion cfq : caisiFormQuestionDao.findByFormId(formId)) { <line48> caisiFormQuestionDao.remove(cfq.getId()); <line49> } <line50> for (CaisiFormQuestion ofq : ofqs) { <line51> caisiFormQuestionDao.persist(ofq); <line52> } <line53> } <line54> } <line55> "	Yes	task1	
"public class A { <line0> public static com.liferay.sync.model.SyncDLObject checkOutFileEntry( <line1> HttpPrincipal httpPrincipal, <line2> long fileEntryId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> SyncDLObjectServiceUtil.class, <line9> ""checkOutFileEntry"", <line10> _checkOutFileEntryParameterTypes4); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, fileEntryId, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.sync.model.SyncDLObject) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> log.error(systemException, systemException); <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	No	task1	
"public class A { <line0> @Override <line1> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line2> public List<JPAObject> getJPAObjectHistory(String oid, long from, long to) throws EDBException { <line3> synchronized (entityManager) { <line4> LOGGER.debug( <line5> ""Loading the history for the object {} from {} to {}"", new Object[] {oid, from, to}); <line6> CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder(); <line7> CriteriaQuery<JPAObject> query = criteriaBuilder.createQuery(JPAObject.class); <line8> Root f = query.from(JPAObject.class); <line9> query.select(f); <line10> Predicate predicate1 = criteriaBuilder.equal(f.get(""oid""), oid); <line11> Predicate predicate2 = criteriaBuilder.between(f.get(""timestamp""), from, to); <line12> query.where(criteriaBuilder.and(predicate1, predicate2)); <line13> query.orderBy(criteriaBuilder.asc(f.get(""timestamp""))); <line14> TypedQuery<JPAObject> typedQuery = entityManager.createQuery(query); <line15> return typedQuery.getResultList(); <line16> } <line17> } <line18> } <line19> "	Yes	task1	
"public class A { <line0> public AnomalyDetectionInputContextBuilder setFunction( <line1> AnomalyFunctionDTO anomalyFunctionSpec, <line2> AnomalyDetectionInputContext anomalyDetectionInputContext) <line3> throws Exception { <line4> this.anomalyFunctionSpec = anomalyFunctionSpec; <line5> this.anomalyFunction = anomalyFunctionFactory.fromSpec(anomalyFunctionSpec); <line6> this.anomalyDetectionInputContext = anomalyDetectionInputContext; <line7> this.dataset = this.anomalyFunctionSpec.getCollection(); <line8> DatasetConfigDTO datasetConfig = DAO_REGISTRY.getDatasetConfigDAO().findByDataset(dataset); <line9> if (datasetConfig == null) { <line10> LOG.error(""Dataset ["" + dataset + ""] is not found""); <line11> throw new IllegalArgumentException( <line12> ""Dataset ["" <line13> + dataset <line14> + ""] is not found with function : "" <line15> + anomalyFunctionSpec.toString()); <line16> } <line17> this.collectionDimensions = datasetConfig.getDimensions(); <line18> return this; <line19> } <line20> } <line21> "	No	task1	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Zip.zipfiles(selectedFile, inputAdapters, progressMon, false); <line4> } catch (final IOException e) { <line5> if (!selectedFile.delete() && LOGGER.isTraceEnabled()) { <line6> LOGGER.trace(""Failed to delete file: "" + selectedFile.getAbsolutePath(), e); <line7> } <line8> JOptionPane.showMessageDialog( <line9> parent, <line10> ""Error encountered while saving export file"", <line11> ""File Save Error"", <line12> JOptionPane.ERROR_MESSAGE); <line13> } <line14> progressMon.close(); <line15> } <line16> } <line17> "	No	task1	
"public class A { <line0> protected void process() throws Exception { <line1> final R4ExamplesDriver driver = new R4ExamplesDriver(); <line2> driver.setValidator(new ValidationProcessor()); <line3> DriverMetrics dm = new DriverMetrics(); <line4> driver.setMetrics(dm); <line5> if (tenantId != null) { <line6> this.properties.setProperty(""fhirclient.tenant.id"", tenantId); <line7> } <line8> TestContext context = new TestContext(); <line9> context.setUp(this.properties); <line10> ExampleRequestProcessor erp = <line11> new ExampleRequestProcessor(context, tenantId, dm, this.readIterations); <line12> driver.setProcessor(erp); <line13> if (pool != null) { <line14> if (maxInflight == 0) { <line15> maxInflight = threads * 2; <line16> } <line17> driver.setPool(pool, maxInflight); <line18> } <line19> long start = System.nanoTime(); <line20> driver.processIndex(this.index); <line21> long elapsed = (System.nanoTime() - start) / DriverMetrics.NANOS_MS; <line22> if (elapsed == 0) { <line23> elapsed = 1; <line24> } <line25> renderReport(dm, elapsed); <line26> } <line27> } <line28> "	Yes	task1	
"public class A { <line0> protected void simulateStep(Game game, Step step) { <line1> if (Thread.interrupted()) { <line2> Thread.currentThread().interrupt(); <line3> logger.debug(""interrupted""); <line4> return; <line5> } <line6> if (!game.checkIfGameIsOver()) { <line7> game.getPhase().setStep(step); <line8> if (!step.skipStep(game, game.getActivePlayerId())) { <line9> step.beginStep(game, game.getActivePlayerId()); <line10> game.checkStateAndTriggered(); <line11> while (!game.getStack().isEmpty()) { <line12> game.getStack().resolve(game); <line13> game.applyEffects(); <line14> } <line15> step.endStep(game, game.getActivePlayerId()); <line16> } <line17> } <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> @Override <line1> public QuestionnairesStepsBo getQuestionnaireStep( <line2> Integer stepId, <line3> String stepType, <line4> String questionnaireShortTitle, <line5> String customStudyId, <line6> Integer questionnaireId) { <line7> logger.entry(""begin getQuestionnaireStep()""); <line8> QuestionnairesStepsBo questionnairesStepsBo = null; <line9> try { <line10> questionnairesStepsBo = <line11> studyQuestionnaireDAO.getQuestionnaireStep( <line12> stepId, stepType, questionnaireShortTitle, customStudyId, questionnaireId); <line13> if ((questionnairesStepsBo != null) <line14> && stepType.equalsIgnoreCase(FdahpStudyDesignerConstants.FORM_STEP) <line15> && (questionnairesStepsBo.getFormQuestionMap() != null)) { <line16> List<QuestionResponseTypeMasterInfoBo> questionResponseTypeMasterInfoList = <line17> studyQuestionnaireDAO.getQuestionReponseTypeList(); <line18> if ((questionResponseTypeMasterInfoList != null) <line19> && !questionResponseTypeMasterInfoList.isEmpty()) { <line20> for (QuestionResponseTypeMasterInfoBo questionResponseTypeMasterInfoBo : <line21> questionResponseTypeMasterInfoList) { <line22> for (Entry<Integer, QuestionnaireStepBean> entry : <line23> questionnairesStepsBo.getFormQuestionMap().entrySet()) { <line24> QuestionnaireStepBean questionnaireStepBean = entry.getValue(); <line25> if ((questionnaireStepBean.getResponseType() != null) <line26> && questionnaireStepBean <line27> .getResponseType() <line28> .equals(questionResponseTypeMasterInfoBo.getId())) { <line29> if (FdahpStudyDesignerConstants.DATE.equalsIgnoreCase( <line30> questionResponseTypeMasterInfoBo.getResponseType())) { <line31> questionnaireStepBean.setResponseTypeText( <line32> questionResponseTypeMasterInfoBo.getResponseType()); <line33> } else { <line34> questionnaireStepBean.setResponseTypeText( <line35> questionResponseTypeMasterInfoBo.getDataType()); <line36> } <line37> } <line38> } <line39> } <line40> } <line41> } <line42> } catch (Exception e) { <line43> } <line44> logger.exit(""getQuestionnaireStep() - Ends""); <line45> return questionnairesStepsBo; <line46> } <line47> } <line48> "	Yes	task1	
"public class A { <line0> public static com.liferay.portal.kernel.model.User updateIncompleteUser( <line1> HttpPrincipal httpPrincipal, <line2> long companyId, <line3> boolean autoPassword, <line4> String password1, <line5> String password2, <line6> boolean autoScreenName, <line7> String screenName, <line8> String emailAddress, <line9> java.util.Locale locale, <line10> String firstName, <line11> String middleName, <line12> String lastName, <line13> long prefixId, <line14> long suffixId, <line15> boolean male, <line16> int birthdayMonth, <line17> int birthdayDay, <line18> int birthdayYear, <line19> String jobTitle, <line20> boolean updateUserInformation, <line21> boolean sendEmail, <line22> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line23> throws com.liferay.portal.kernel.exception.PortalException { <line24> try { <line25> MethodKey methodKey = <line26> new MethodKey( <line27> UserServiceUtil.class, ""updateIncompleteUser"", _updateIncompleteUserParameterTypes59); <line28> MethodHandler methodHandler = <line29> new MethodHandler( <line30> methodKey, <line31> companyId, <line32> autoPassword, <line33> password1, <line34> password2, <line35> autoScreenName, <line36> screenName, <line37> emailAddress, <line38> locale, <line39> firstName, <line40> middleName, <line41> lastName, <line42> prefixId, <line43> suffixId, <line44> male, <line45> birthdayMonth, <line46> birthdayDay, <line47> birthdayYear, <line48> jobTitle, <line49> updateUserInformation, <line50> sendEmail, <line51> serviceContext); <line52> Object returnObj = null; <line53> try { <line54> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line55> } catch (Exception exception) { <line56> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line57> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line58> } <line59> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line60> } <line61> return (com.liferay.portal.kernel.model.User) returnObj; <line62> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line63> throw systemException; <line64> } <line65> } <line66> } <line67> "	Yes	task1	
public class A { <line0> public void stop() { <line1> try { <line2> if (context != null) { <line3> context.stop(); <line4> context.close(); <line5> context = null; <line6> } <line7> } catch (Throwable e) { <line8> logger.error(e.getMessage(), e); <line9> } <line10> } <line11> } <line12> 	No	task1	
"public class A { <line0> public void restartCluster() { <line1> final var brokers = <line2> getBrokers().stream() <line3> .map(b -> b.getConfig().getCluster().getNodeId()) <line4> .collect(Collectors.toList()); <line5> brokers.forEach(this::stopBroker); <line6> brokers.forEach(this::getBroker); <line7> try { <line8> waitUntilBrokersStarted(); <line9> waitForPartitionReplicationFactor(); <line10> waitUntilBrokersInTopology(); <line11> } catch (final Exception e) { <line12> Assert.fail(""Failed to restart cluster""); <line13> } <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> @Override <line1> public AccessControlList updateEventAcl( <line2> String id, AccessControlList acl, AbstractSearchIndex index) <line3> throws IllegalArgumentException, IndexServiceException, SearchIndexException, <line4> NotFoundException, UnauthorizedException { <line5> Opt<Event> optEvent = getEvent(id, index); <line6> if (optEvent.isNone()) throw new NotFoundException(""Cannot find an event with id "" + id); <line7> Event event = optEvent.get(); <line8> MediaPackage mediaPackage = getEventMediapackage(event); <line9> switch (getEventSource(event)) { <line10> case WORKFLOW: <line11> throw new IllegalArgumentException( <line12> ""Unable to update the ACL of this event as it is currently processing.""); <line13> case ARCHIVE: <line14> try { <line15> mediaPackage = authorizationService.setAcl(mediaPackage, AclScope.Episode, acl).getA(); <line16> } catch (MediaPackageException e) { <line17> throw new IndexServiceException(""Unable to update  acl"", e); <line18> } <line19> assetManager.takeSnapshot(mediaPackage); <line20> return acl; <line21> case SCHEDULE: <line22> try { <line23> mediaPackage = authorizationService.setAcl(mediaPackage, AclScope.Episode, acl).getA(); <line24> schedulerService.updateEvent( <line25> id, <line26> Opt.none(), <line27> Opt.none(), <line28> Opt.none(), <line29> Opt.none(), <line30> Opt.some(mediaPackage), <line31> Opt.none(), <line32> Opt.none()); <line33> } catch (SchedulerException | MediaPackageException e) { <line34> throw new IndexServiceException(""Unable to update the acl for the scheduled event"", e); <line35> } <line36> return acl; <line37> default: <line38> throw new IndexServiceException( <line39> String.format( <line40> ""Unable to update the ACL as '%s' is an unknown event source."", <line41> getEventSource(event))); <line42> } <line43> } <line44> } <line45> "	Yes	task1	
public class A { <line0> public void debug(String s, Object... args) { <line1> debugLog.get().push(format(s, args)); <line2> if (logLevel.get().equalOrLessThan(DEBUG)) { <line3> logger.debug(jdiMarker, getRecord(s, args)); <line4> } <line5> } <line6> } <line7> 	No	task1	
"public class A { <line0> public void collectDependentInspections( <line1> @Nonnull InspectionToolWrapper toolWrapper, <line2> @Nonnull Set<InspectionToolWrapper> dependentEntries, <line3> Project project) { <line4> String mainToolId = toolWrapper.getMainToolId(); <line5> if (mainToolId != null) { <line6> InspectionToolWrapper dependentEntryWrapper = getInspectionTool(mainToolId, project); <line7> if (dependentEntryWrapper == null) { <line8> LOG.error( <line9> ""Can't find main tool: '"" + mainToolId + ""' which was specified in "" + toolWrapper); <line10> return; <line11> } <line12> if (!dependentEntries.add(dependentEntryWrapper)) { <line13> collectDependentInspections(dependentEntryWrapper, dependentEntries, project); <line14> } <line15> } <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> protected void awaitTopicConfigInKafka(String topicName, String key, String expectedValue) <line1> throws InterruptedException, ExecutionException, TimeoutException { <line2> waitFor( <line3> () -> { <line4> ConfigResource configResource = topicConfigResource(topicName); <line5> org.apache.kafka.clients.admin.Config config = getTopicConfig(configResource); <line6> String retention = config.get(""retention.ms"").value(); <line7> return expectedValue.equals(retention); <line8> }, <line9> ""Expected the topic "" + topicName + "" to have retention.ms="" + expectedValue + "" in Kafka""); <line10> } <line11> } <line12> "	Yes	task1	
"public class A { <line0> private Runnable createRunnable( <line1> final ExecutionMonitor exec, <line2> final long noOfSets, <line3> final DataCell setIDCell, <line4> final CollectionDataValue setCell, <line5> final boolean appendSetCol, <line6> final Comparator<DataCell> comparator, <line7> final SubsetMatcher[] sortedMatcher, <line8> final int maxMismatches) { <line9> return new Runnable() { <line10> @Override <line11> public void run() { <line12> try { <line13> exec.checkCanceled(); <line14> final long transCounter = m_setCounter.incrementAndGet(); <line15> exec.setMessage(setIDCell.toString() + "" ("" + transCounter + "" of "" + noOfSets + "")""); <line16> if (setCell.size() < 1) { <line17> exec.setProgress(transCounter / (double) noOfSets); <line18> m_skipCounter.incrementAndGet(); <line19> return; <line20> } <line21> final DataCell[] sortedItems = collectionCell2SortedArray(setCell, comparator); <line22> int matcherStartIdx = 0; <line23> int itemIdx = 0; <line24> final Collection<SetMissmatches> matchingSets = new LinkedList<>(); <line25> while (itemIdx < sortedItems.length && matcherStartIdx < sortedMatcher.length) { <line26> final DataCell subItem = sortedItems[itemIdx]; <line27> for (int i = matcherStartIdx; i < sortedMatcher.length; i++) { <line28> final SubsetMatcher matcher = sortedMatcher[i]; <line29> final int result = matcher.compare(subItem); <line30> if (result > 0 && maxMismatches == 0) { <line31> break; <line32> } <line33> matcher.match( <line34> sortedItems, <line35> itemIdx, <line36> matchingSets, <line37> new LinkedList<DataCell>(), <line38> new MismatchCounter(maxMismatches)); <line39> matcherStartIdx++; <line40> } <line41> itemIdx++; <line42> } <line43> if (matchingSets.size() < 1) { <line44> exec.setProgress(transCounter / (double) noOfSets); <line45> m_skipCounter.incrementAndGet(); <line46> return; <line47> } <line48> for (final SetMissmatches matchingSet : matchingSets) { <line49> exec.checkCanceled(); <line50> final List<DataCell> cells = new LinkedList<>(); <line51> cells.add(setIDCell); <line52> if (appendSetCol) { <line53> cells.add((DataCell) setCell); <line54> } <line55> cells.add(matchingSet.getSet()); <line56> if (maxMismatches > 0) { <line57> cells.add(new IntCell(matchingSet.getMismatchCounter())); <line58> } <line59> final RowKey rowKey = RowKey.createRowKey(m_rowId.getAndIncrement()); <line60> final DefaultRow row = new DefaultRow(rowKey, cells); <line61> synchronized (m_dc) { <line62> exec.checkCanceled(); <line63> m_dc.addRowToTable(row); <line64> } <line65> } <line66> exec.setProgress(transCounter / (double) noOfSets); <line67> } catch (final CanceledExecutionException e) { <line68> } catch (final Exception e) { <line69> } <line70> } <line71> }; <line72> } <line73> } <line74> "	Yes	task1	
"public class A { <line0> @Override <line1> public UpdateContainer doIt(Workspace workspace) throws CommandException { <line2> UpdateContainer c = new UpdateContainer(); <line3> c.add( <line4> new AbstractUpdate() { <line5> @Override <line6> public void generateJson(String prefix, PrintWriter pw, VWorkspace vWorkspace) { <line7> try { <line8> JSONObject outputObject = <line9> (new SavedModelURLs()).getSavedModels(vWorkspace.getWorkspace().getContextId()); <line10> JSONArray models = outputObject.getJSONArray(""models""); <line11> JSONArray revModels = new JSONArray(); <line12> for (int i = models.length() - 1; i >= 0; i--) revModels.put(models.get(i)); <line13> outputObject.put(""models"", revModels); <line14> pw.println(outputObject.toString()); <line15> } catch (Exception e) { <line16> e.printStackTrace(); <line17> logger.error(""Error occured while generating JSON!""); <line18> } <line19> } <line20> }); <line21> return c; <line22> } <line23> } <line24> "	No	task1	
"public class A { <line0> @Test <line1> public void testContextualFilterPhraseOnly() { <line2> String searchTerm = ""cat""; <line3> String selector = null; <line4> OpenSearchQuery query = new OpenSearchQuery(0, 10, ""relevance"", ""desc"", 30000, FILTER_BUILDER); <line5> query.addContextualFilter(searchTerm, selector); <line6> Filter filter = query.getFilter(); <line7> VerificationVisitor verificationVisitor = new VerificationVisitor(); <line8> filter.accept(verificationVisitor, null); <line9> HashMap<String, FilterStatus> map = <line10> (HashMap<String, FilterStatus>) verificationVisitor.getMap(); <line11> printFilterStatusMap(map); <line12> List<Filter> filters = getFilters(map, LikeFilterImpl.class.getName()); <line13> assertEquals(1, filters.size()); <line14> LikeFilterImpl likeFilter = (LikeFilterImpl) filters.get(0); <line15> String extractedSearchTerm = likeFilter.getLiteral(); <line16> assertEquals(searchTerm, extractedSearchTerm); <line17> } <line18> } <line19> "	Yes	task1	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> String line; <line4> while ((line = stdoutReader.readLine()) != null) { <line5> stdoutContents.append(line); <line6> stdoutContents.append('\n'); <line7> if (teeTarget.isPresent()) teeTarget.get().println(line); <line8> } <line9> } catch (IOException e) { <line10> throw new UncheckedIOException(e); <line11> } <line12> } <line13> } <line14> 	Yes	task1	
"public class A { <line0> public SearchContext buildStructureSearchContext( <line1> long companyId, <line2> long[] groupIds, <line3> long userId, <line4> long classNameId, <line5> Long classPK, <line6> String name, <line7> String description, <line8> String storageType, <line9> Integer type, <line10> int status, <line11> int start, <line12> int end, <line13> OrderByComparator<DDMStructure> orderByComparator) { <line14> SearchContext searchContext = new SearchContext(); <line15> searchContext.setAttribute(Field.CLASS_NAME_ID, classNameId); <line16> searchContext.setAttribute(Field.CLASS_PK, classPK); <line17> searchContext.setAttribute(Field.DESCRIPTION, description); <line18> searchContext.setAttribute(Field.NAME, name); <line19> searchContext.setAttribute(Field.STATUS, status); <line20> try { <line21> searchContext.setAttribute( <line22> ""resourcePermissionName"", <line23> _ddmPermissionSupport.getStructureModelResourceName(classNameId)); <line24> } catch (PortalException portalException) { <line25> if (log.isDebugEnabled()) { <line26> } <line27> } <line28> searchContext.setAttribute(""storageType"", storageType); <line29> searchContext.setAttribute(""type"", type); <line30> searchContext.setCompanyId(companyId); <line31> searchContext.setEnd(end); <line32> searchContext.setGroupIds(groupIds); <line33> searchContext.setStart(start); <line34> if (userId > 0) { <line35> searchContext.setUserId(userId); <line36> } <line37> if (orderByComparator != null) { <line38> searchContext.setSorts(getSortsFromComparator(orderByComparator)); <line39> } <line40> return searchContext; <line41> } <line42> } <line43> "	Yes	task1	
"public class A { <line0> public void createBB() { <line1> try { <line2> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line3> BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos); <line4> boa.writeInt(-1, ""len""); <line5> if (requestHeader != null) { <line6> requestHeader.serialize(boa, ""header""); <line7> } <line8> if (request instanceof ConnectRequest) { <line9> request.serialize(boa, ""connect""); <line10> boa.writeBool(readOnly, ""readOnly""); <line11> } else if (request != null) { <line12> request.serialize(boa, ""request""); <line13> } <line14> baos.close(); <line15> this.bb = ByteBuffer.wrap(baos.toByteArray()); <line16> this.bb.putInt(this.bb.capacity() - 4); <line17> this.bb.rewind(); <line18> } catch (IOException e) { <line19> } <line20> } <line21> } <line22> "	Yes	task1	
"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> String failure = """"; <line3> try { <line4> worker.taskWorker.stop(platform); <line5> } catch (Exception exception) { <line6> failure = exception.getMessage(); <line7> } <line8> stateChangeExecutor.submit(new CompleteWorker(worker, failure)); <line9> return null; <line10> } <line11> } <line12> "	Yes	task1	
"public class A { <line0> public User saveUser(User user) { <line1> if (log.isDebugEnabled()) { <line2> log.debug(""user's id: "" + user.getId()); <line3> } <line4> getSession().saveOrUpdate(user); <line5> getSession().flush(); <line6> return user; <line7> } <line8> } <line9> "	No	task1	
public class A { <line0> public static com.liferay.journal.model.JournalArticleSoap[] getArticles( <line1> long groupId, long folderId, String locale) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.journal.model.JournalArticle> returnValue = <line4> JournalArticleServiceUtil.getArticles( <line5> groupId, folderId, LocaleUtil.fromLanguageId(locale)); <line6> return com.liferay.journal.model.JournalArticleSoap.toSoapModels(returnValue); <line7> } catch (Exception exception) { <line8> log.error(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	No	task1	
"public class A { <line0> private RelationshipItem createItem(String typeWithUid) { <line1> if (StringUtils.isEmpty(typeWithUid)) { <line2> return new RelationshipItem(); <line3> } <line4> RelationshipItem ri = new RelationshipItem(); <line5> final String type = typeWithUid.split(""\\|"")[0]; <line6> final String uid = typeWithUid.split(""\\|"")[1]; <line7> switch (type) { <line8> case ""tei"": <line9> TrackedEntityInstance tei = new TrackedEntityInstance(); <line10> tei.clear(); <line11> tei.setTrackedEntityInstance(uid); <line12> ri.setTrackedEntityInstance(tei); <line13> break; <line14> case ""pi"": <line15> Enrollment pi = new Enrollment(); <line16> pi.setEnrollment(uid); <line17> ri.setEnrollment(pi); <line18> break; <line19> case ""psi"": <line20> Event psi = new Event(); <line21> psi.setEvent(uid); <line22> ri.setEvent(psi); <line23> break; <line24> default: <line25> } <line26> return ri; <line27> } <line28> } <line29> "	Yes	task1	
public class A { <line0> public static com.liferay.commerce.price.list.model.CommercePriceListSoap addCommercePriceList( <line1> String externalReferenceCode, <line2> long groupId, <line3> long userId, <line4> long commerceCurrencyId, <line5> long parentCommercePriceListId, <line6> String name, <line7> double priority, <line8> int displayDateMonth, <line9> int displayDateDay, <line10> int displayDateYear, <line11> int displayDateHour, <line12> int displayDateMinute, <line13> int expirationDateMonth, <line14> int expirationDateDay, <line15> int expirationDateYear, <line16> int expirationDateHour, <line17> int expirationDateMinute, <line18> boolean neverExpire, <line19> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line20> throws RemoteException { <line21> try { <line22> com.liferay.commerce.price.list.model.CommercePriceList returnValue = <line23> CommercePriceListServiceUtil.addCommercePriceList( <line24> externalReferenceCode, <line25> groupId, <line26> userId, <line27> commerceCurrencyId, <line28> parentCommercePriceListId, <line29> name, <line30> priority, <line31> displayDateMonth, <line32> displayDateDay, <line33> displayDateYear, <line34> displayDateHour, <line35> displayDateMinute, <line36> expirationDateMonth, <line37> expirationDateDay, <line38> expirationDateYear, <line39> expirationDateHour, <line40> expirationDateMinute, <line41> neverExpire, <line42> serviceContext); <line43> return com.liferay.commerce.price.list.model.CommercePriceListSoap.toSoapModel(returnValue); <line44> } catch (Exception exception) { <line45> log.error(exception, exception); <line46> throw new RemoteException(exception.getMessage()); <line47> } <line48> } <line49> } <line50> 	No	task1	
public class A { <line0> @Override <line1> public void restore(BackupInput reader) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> clusterMeta = new ClusterMeta(); <line5> int nServerMeta = reader.readInt(); <line6> for (int i = 0; i < nServerMeta; i++) { <line7> String clusterName = reader.readString(); <line8> int nKVpairs = reader.readInt(); <line9> for (int j = 0; j < nKVpairs; i++) { <line10> String key = reader.readString(); <line11> Object value = reader.readObject(); <line12> clusterMeta.put(ClusterMetaType.SERVER_META, clusterName, Maps.immutableEntry(key, value)); <line13> } <line14> } <line15> int nIntpMeta = reader.readInt(); <line16> for (int i = 0; i < nIntpMeta; i++) { <line17> String intpName = reader.readString(); <line18> int nKVpairs = reader.readInt(); <line19> for (int j = 0; j < nKVpairs; i++) { <line20> String key = reader.readString(); <line21> Object value = reader.readObject(); <line22> clusterMeta.put( <line23> ClusterMetaType.INTP_PROCESS_META, intpName, Maps.immutableEntry(key, value)); <line24> } <line25> } <line26> } <line27> } <line28> 	Yes	task1	
public class A { <line0> private void addCustomExceptionHandlers( <line1> final Map<Class<? extends Throwable>, ExceptionHandler<? extends Throwable>> <line2> exceptionHandlers) { <line3> for (Map.Entry<Class<? extends Throwable>, ExceptionHandler<? extends Throwable>> entry : <line4> exceptionHandlers.entrySet()) { <line5> Class<? extends Throwable> exceptionType = entry.getKey(); <line6> ExceptionHandler<? extends Throwable> oldHandler = <line7> this.exceptionHandlers.put(exceptionType, entry.getValue()); <line8> if (null != oldHandler) { <line9> } <line10> } <line11> } <line12> } <line13> 	Yes	task1	
public class A { <line0> public void registerDatasetRun(JRFillDatasetRun datasetRun) { <line1> if (!trackedDatasetRunsStack.isEmpty()) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> trackedDatasetRunsStack.getFirst().add(datasetRun); <line5> } <line6> } <line7> } <line8> 	Yes	task1	
public class A { <line0> public void loadLogging() { <line1> Platform.runLater( <line2> () -> { <line3> Level storedLevel = getLoggingLevel(); <line4> if (storedLevel == null) { <line5> storedLevel = PopUpWindows.getLoggingPermissions() ? Level.INFO : Level.OFF; <line6> } <line7> changeLogging(storedLevel); <line8> menuController.loggingToggle.setSelected( <line9> storedLevel.equals(org.apache.logging.log4j.Level.INFO)); <line10> }); <line11> } <line12> } <line13> 	Yes	task1	
"public class A { <line0> public String saveAndContinue() { <line1> try { <line2> Content currentContent = this.updateContentOnSession(); <line3> if (null != currentContent) { <line4> String descr = currentContent.getDescription(); <line5> if (StringUtils.isEmpty(descr)) { <line6> this.addFieldError(""descr"", this.getText(""error.content.descr.required"")); <line7> } else if (descr.length() > 250) { <line8> String[] args = {String.valueOf(250)}; <line9> this.addFieldError(""descr"", this.getText(""error.content.descr.wrongMaxLength"", args)); <line10> } else if (StringUtils.isEmpty(currentContent.getMainGroup())) { <line11> this.addFieldError(""mainGroup"", this.getText(""error.content.mainGroup.required"")); <line12> } else { <line13> currentContent.setLastEditor(this.getCurrentUser().getUsername()); <line14> this.getContentManager().saveContent(currentContent); <line15> } <line16> } <line17> } catch (Throwable t) { <line18> return FAILURE; <line19> } <line20> return SUCCESS; <line21> } <line22> } <line23> "	Yes	task1	
"public class A { <line0> @Override <line1> public void init(final FilterConfig config) { <line2> if (LOGGER.isDebugEnabled()) { <line3> LOGGER.info(""In RuleInterceptorFilter init""); <line4> } <line5> } <line6> } <line7> "	No	task1	
"public class A { <line0> String safeGetJCRPath(Path path) { <line1> try { <line2> return session.getJCRPath(path); <line3> } catch (NamespaceException e) { <line4> log.error(""failed to convert "" + path.toString() + "" to JCR path.""); <line5> return path.toString(); <line6> } <line7> } <line8> } <line9> "	No	task1	
public class A { <line0> @Override <line1> public ICalendar fetchInvitation(long uid) throws EmailViewPartsFetcherException { <line2> try { <line3> EmailMetadata emailViewResponse = mailboxService.fetchEmailMetadata(udr, path, uid); <line4> MimeMessage mimeMessage = emailViewResponse.getMimeMessage(); <line5> MimePart parentMessage = mimeMessage.findRootMimePartInTree(); <line6> for (MimePart mp : parentMessage.listLeaves(true, true)) { <line7> if (mp.isInvitation()) { <line8> return fetchICalendar(mp, uid, emailViewResponse); <line9> } <line10> } <line11> return null; <line12> } catch (MailException e) { <line13> throw new EmailViewPartsFetcherException(e); <line14> } catch (IOException e) { <line15> throw new EmailViewPartsFetcherException(e); <line16> } catch (ParserException e) { <line17> throw new EmailViewPartsFetcherException(e); <line18> } catch (EmailViewBuildException e) { <line19> logger.error(e.getMessage(), e); <line20> return null; <line21> } <line22> } <line23> } <line24> 	No	task1	
"public class A { <line0> @Test <line1> public void testRandomAggregationCombine() { <line2> final int numOfItemsPerList = 100; <line3> final int numOfListCombined = 1000; <line4> for (Byte percentile : functionMap.keySet()) { <line5> AggregationFunction aggregationFunction = functionMap.get(percentile); <line6> AggregationFunction aggregationAccurateFunction = accurateFunctionMap.get(percentile); <line7> aggregationFunction.init(_paramsInfo); <line8> aggregationAccurateFunction.init(_paramsInfo); <line9> println( <line10> ""#list_combined, QuantileDigest_time(nano), DoubleArrayList_time(nano), time_ratio,"" <line11> + "" estimate, precise, error""); <line12> StringBuilder sb1 = new StringBuilder(); <line13> StringBuilder sb2 = new StringBuilder(); <line14> for (int i = 1; i <= numOfListCombined; i += numOfListCombined / 17) { <line15> if (i == 1) { <line16> continue; <line17> } <line18> RandomNumberArray arr = new RandomNumberArray(i * numOfItemsPerList, DUPLICATION_PER_ITEM); <line19> List<Serializable> aggregationResults = <line20> getQuantileDigestResultValues(arr, i, numOfItemsPerList); <line21> long t1 = System.nanoTime(); <line22> List<Serializable> combinedResult = <line23> aggregationFunction.combine(aggregationResults, CombineLevel.SEGMENT); <line24> long estimate = <line25> ((QuantileDigest) (combinedResult.get(0))).getQuantile(((double) percentile) / 100); <line26> long t2 = System.nanoTime(); <line27> List<Serializable> aggregationResults2 = <line28> getDoubleArrayListResultValues(arr, i, numOfItemsPerList); <line29> long t3 = System.nanoTime(); <line30> List<Serializable> combinedResult2 = <line31> aggregationAccurateFunction.combine(aggregationResults2, CombineLevel.SEGMENT); <line32> long actual = <line33> (long) <line34> PercentileUtil.getValueOnPercentile( <line35> (DoubleArrayList) combinedResult2.get(0), percentile); <line36> long t4 = System.nanoTime(); <line37> println( <line38> i <line39> + "", "" <line40> + (t2 - t1) <line41> + "", "" <line42> + (t4 - t3) <line43> + "", "" <line44> + (t2 - t1 + 0.0) / (t4 - t3 + 0.0) <line45> + "", "" <line46> + estimate <line47> + "", "" <line48> + actual <line49> + "", "" <line50> + getErrorString(actual, estimate)); <line51> TestUtils.assertApproximation(estimate, actual, threshold); <line52> } <line53> } <line54> } <line55> } <line56> "	Yes	task1	
"public class A { <line0> @Test <line1> public void testMemoryConsumption() { <line2> int objCnt = 100; <line3> ThreadMXBean bean = (ThreadMXBean) ManagementFactory.getThreadMXBean(); <line4> TestClass2 obj = new TestClass2(new String(new char[1_000_000])); <line5> List<TestClass2> arr = new ArrayList<>(objCnt); <line6> for (int i = 1; i <= objCnt; i++) arr.add(new TestClass2(new String(new char[i]))); <line7> GridToStringBuilder.toString(TestClass2.class, obj); <line8> long allocated0 = bean.getThreadAllocatedBytes(Thread.currentThread().getId()); <line9> for (TestClass2 item : arr) GridToStringBuilder.toString(TestClass2.class, item); <line10> long allocated1 = bean.getThreadAllocatedBytes(Thread.currentThread().getId()); <line11> log.info( <line12> ""Memory allocated by GridToStringBuilder for "" <line13> + objCnt <line14> + "" objects: "" <line15> + (allocated1 - allocated0)); <line16> assertTrue( <line17> ""Too much memory allocated by GridToStringBuilder: "" + (allocated1 - allocated0), <line18> allocated1 - allocated0 < 1_000_000); <line19> } <line20> } <line21> "	Yes	task1	
"public class A { <line0> public static com.liferay.portal.kernel.json.JSONArray search( <line1> HttpPrincipal httpPrincipal, long groupId, String name, int start, int end) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey(AssetTagServiceUtil.class, ""search"", _searchParameterTypes22); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, name, start, end); <line6> Object returnObj = null; <line7> try { <line8> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line11> } <line12> return (com.liferay.portal.kernel.json.JSONArray) returnObj; <line13> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line14> throw systemException; <line15> } <line16> } <line17> } <line18> "	Yes	task1	
"public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> String remotePath = DropboxHelper.getRemotePath(configuration, exchange); <line3> DropboxConfigurationValidator.validateGetOp(remotePath); <line4> DropboxFileDownloadResult result = <line5> new DropboxAPIFacade(configuration.getClient(), exchange).get(remotePath); <line6> Map<String, Object> map = result.getEntries(); <line7> if (map.size() == 1) { <line8> for (Map.Entry<String, Object> entry : map.entrySet()) { <line9> exchange.getIn().setHeader(DropboxResultHeader.DOWNLOADED_FILE.name(), entry.getKey()); <line10> exchange.getIn().setBody(entry.getValue()); <line11> } <line12> } else { <line13> StringBuilder pathsExtracted = new StringBuilder(); <line14> for (Map.Entry<String, Object> entry : map.entrySet()) { <line15> pathsExtracted.append(entry.getKey()).append(""\n""); <line16> } <line17> exchange <line18> .getIn() <line19> .setHeader(DropboxResultHeader.DOWNLOADED_FILES.name(), pathsExtracted.toString()); <line20> exchange.getIn().setBody(map); <line21> } <line22> } <line23> } <line24> "	Yes	task1	
"public class A { <line0> @Override <line1> public long getSize() throws MailQueueException { <line2> MessageConsumer consumer = null; <line3> MessageProducer producer = null; <line4> TemporaryQueue replyTo = null; <line5> try { <line6> replyTo = session.createTemporaryQueue(); <line7> consumer = session.createConsumer(replyTo); <line8> Queue myQueue = session.createQueue(queueName.asString()); <line9> producer = session.createProducer(null); <line10> String queueName = ""ActiveMQ.Statistics.Destination."" + myQueue.getQueueName(); <line11> Queue query = session.createQueue(queueName); <line12> Message msg = session.createMessage(); <line13> msg.setJMSReplyTo(replyTo); <line14> producer.send(query, msg); <line15> MapMessage reply = (MapMessage) consumer.receive(2000); <line16> if (reply != null && reply.itemExists(""size"")) { <line17> try { <line18> return reply.getLong(""size""); <line19> } catch (NumberFormatException e) { <line20> return super.getSize(); <line21> } <line22> } <line23> return super.getSize(); <line24> } catch (Exception e) { <line25> throw new MailQueueException(""Unable to remove mails"", e); <line26> } finally { <line27> closeConsumer(consumer); <line28> closeProducer(producer); <line29> if (replyTo != null) { <line30> try { <line31> replyTo.delete(); <line32> } catch (JMSException e) { <line33> LOGGER.error(""Error while deleting temporary queue"", e); <line34> } <line35> } <line36> } <line37> } <line38> } <line39> "	No	task1	
"public class A { <line0> @Override <line1> public HttpResponseResource openResource(URI uri, boolean revalidate) { <line2> if (!_isForcedCacheEnabled()) { <line3> return super.openResource(uri, revalidate); <line4> } <line5> String location = _getLocation(uri); <line6> if (StringUtils.isBlank(location)) { <line7> return super.openResource(uri, revalidate); <line8> } <line9> HttpResponseResource httpResponseResource = null; <line10> try { <line11> if (StringUtils.endsWithIgnoreCase(location, ""/maven-metadata.xml"")) { <line12> httpResponseResource = _getMavenMetadataResponseResource(uri, location); <line13> } else if (StringUtils.endsWithIgnoreCase(location, "".sha1"")) { <line14> httpResponseResource = _getSHA1ResponseResource(uri, location); <line15> } <line16> } catch (Exception exception) { <line17> } <line18> if (httpResponseResource == null) { <line19> httpResponseResource = super.openResource(uri, revalidate); <line20> } <line21> return httpResponseResource; <line22> } <line23> } <line24> "	Yes	task1	
"public class A { <line0> @PutMapping(path = ""{id}"") <line1> public void editProduct(@PathVariable(""id"") String id, @RequestBody Product product) { <line2> ProductUpdated event = <line3> ProductUpdated.newBuilder() <line4> .setProductId(id) <line5> .setColor(product.getColor()) <line6> .setLabel(product.getLabel()) <line7> .build(); <line8> MessageEnvelope envelope = <line9> messageEnvelopeHandler.wrap(MessageTypes.EVENT, ""ProductUpdated"", event, ""json""); <line10> MessageKey messageKey = messageKeyFactory.createMessageKey(); <line11> Message<MessageEnvelope> message = <line12> MessageBuilder.withPayload(envelope) <line13> .setHeader(KafkaHeaders.MESSAGE_KEY, messageKey) <line14> .build(); <line15> productEventsSink.productEvents().send(message); <line16> LOG.info(""Message with UUID {} sent"", event.getProductId()); <line17> } <line18> } <line19> "	No	task1	
"public class A { <line0> @Override <line1> public boolean virtualPut( <line2> final EntryEventImpl event, <line3> final boolean ifNew, <line4> final boolean ifOld, <line5> Object expectedOldValue, <line6> boolean requireOldValue, <line7> final long lastModified, <line8> final boolean overwriteDestroyed, <line9> boolean invokeCallbacks, <line10> boolean throwsConcurrentModification) <line11> throws TimeoutException, CacheWriterException { <line12> if (!MemoryThresholds.isLowMemoryExceptionDisabled()) { <line13> checkIfAboveThreshold(event); <line14> } <line15> Operation originalOp = event.getOperation(); <line16> RegionEntry oldEntry; <line17> try { <line18> oldEntry = <line19> entries.basicPut( <line20> event, <line21> lastModified, <line22> ifNew, <line23> ifOld, <line24> expectedOldValue, <line25> requireOldValue, <line26> overwriteDestroyed); <line27> } catch (ConcurrentCacheModificationException concCacheModException) { <line28> if (logger.isDebugEnabled()) { <line29> logger.debug(""caught concurrent modification attempt when applying {}"", event); <line30> } <line31> if (invokeCallbacks) { <line32> notifyBridgeClients(event); <line33> notifyGatewaySender( <line34> event.getOperation().isUpdate() <line35> ? EnumListenerEvent.AFTER_UPDATE <line36> : EnumListenerEvent.AFTER_CREATE, <line37> event); <line38> } <line39> if (throwsConcurrentModification) { <line40> throw concCacheModException; <line41> } else { <line42> return false; <line43> } <line44> } <line45> ServerRegionProxy mySRP = getServerProxy(); <line46> if (mySRP != null && getDataPolicy() == DataPolicy.EMPTY) { <line47> if (originalOp == Operation.PUT_IF_ABSENT) { <line48> return !event.hasOldValue(); <line49> } <line50> if (originalOp == Operation.REPLACE && !requireOldValue) { <line51> return true; <line52> } <line53> } <line54> return oldEntry != null; <line55> } <line56> } <line57> "	No	task1	
"public class A { <line0> private Map<String, Object> resolverClassAndMethod( <line1> String className, String methodDesc, Map<String, Object> configuration) { <line2> try { <line3> int openParen = methodDesc.indexOf(Constants.LEFT_PARENTHESIS); <line4> int closeParen = methodDesc.indexOf(Constants.RIGHT_PARENTHESIS); <line5> String methodName = methodDesc.substring(0, openParen); <line6> String[] arguments = methodDesc.substring(openParen + 1, closeParen).split(Constants.COMMA); <line7> MethodConfiguration.setClz(configuration, className); <line8> MethodConfiguration.setMethod( <line9> configuration, CustomizeUtil.generateOperationName(className, methodName, arguments)); <line10> MethodConfiguration.setMethodName(configuration, methodName); <line11> MethodConfiguration.setArguments( <line12> configuration, StringUtil.isEmpty(arguments[0]) ? new String[0] : arguments); <line13> if (StringUtil.isEmpty(MethodConfiguration.getOperationName(configuration))) { <line14> MethodConfiguration.setOperationName( <line15> configuration, MethodConfiguration.getMethod(configuration)); <line16> } <line17> return configuration; <line18> } catch (Exception e) { <line19> LOGGER.error( <line20> e, ""Failed to resolver, className is {}, methodDesc is {}."", className, methodDesc); <line21> } <line22> return null; <line23> } <line24> } <line25> "	No	task1	
public class A { <line0> public void awaitTermination(final long mills) { <line1> try { <line2> join(mills); <line3> } catch (final InterruptedException e) { <line4> if (logger.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> 	Yes	task1	
public class A { <line0> public boolean uploadEnvironment(LocalEnvironment env) { <line1> if (!canWorkWithBazaar()) { <line2> return false; <line3> } <line4> if (env.getStatus() != EnvironmentStatus.HEALTHY) { <line5> return false; <line6> } <line7> try { <line8> ObjectNode envJson = environmentToJson(env); <line9> environmentPeersToJson(env, envJson); <line10> environmentContainersToJson(env, envJson); <line11> bazaaarAdapter.uploadEnvironment(envJson.toString()); <line12> return true; <line13> } catch (Exception e) { <line14> return false; <line15> } <line16> } <line17> } <line18> 	Yes	task1	
public class A { <line0> public WorkflowSettings build() { <line1> WorkflowSettings instance = new WorkflowSettings(this); <line2> return instance; <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> @Override <line1> public Map<String, String> getDynamicAttributes() { <line2> Map<String, String> data = new HashMap<>(); <line3> try { <line4> data.put( <line5> ""data-select-layout-master-layout-url"", <line6> PortletURLBuilder.createRenderURL(_renderResponse) <line7> .setMVCPath(""/select_layout_master_layout.jsp"") <line8> .setRedirect(ParamUtil.getString(_httpServletRequest, ""redirect"")) <line9> .setBackURL(themeDisplay.getURLCurrent()) <line10> .setParameter(""collectionPK"", _infoListProvider.getKey()) <line11> .setParameter( <line12> ""collectionType"", InfoListProviderItemSelectorReturnType.class.getName()) <line13> .setParameter(""groupId"", _groupId) <line14> .setParameter( <line15> ""privateLayout"", ParamUtil.getBoolean(_httpServletRequest, ""privateLayout"")) <line16> .setParameter(""selPlid"", ParamUtil.getLong(_httpServletRequest, ""selPlid"")) <line17> .buildString()); <line18> } catch (Exception exception) { <line19> if (log.isDebugEnabled()) { <line20> } <line21> } <line22> data.put(""role"", ""button""); <line23> data.put(""tabIndex"", ""0""); <line24> return data; <line25> } <line26> } <line27> "	Yes	task1	
"public class A { <line0> @Override <line1> public void contextInitialized(ServletContextEvent sce) { <line2> ServletContext context = sce.getServletContext(); <line3> cdiContainer = (CdiContainer) context.getAttribute(CDI_CONTAINER_ATTRIBUTE); <line4> cdiContainer.start(context); <line5> WeldManager manager = cdiContainer.unwrap(WeldManager.class); <line6> Injector injector = new Injector(cdiContainer); <line7> context.setAttribute(JettyDecorator.INJECTOR_KEY, injector); <line8> JettyDecorator.process(context); <line9> log.info(""registered Jetty decorator for JSR-299 injection""); <line10> context.setAttribute(""org.ops4j.pax.cdi.BeanManager"", cdiContainer.getBeanManager()); <line11> JspFactory jspFactory = JspFactory.getDefaultFactory(); <line12> if (jspFactory != null) { <line13> JspApplicationContext jspApplicationContext = jspFactory.getJspApplicationContext(context); <line14> jspApplicationContext.addELResolver(manager.getELResolver()); <line15> jspApplicationContext.addELContextListener(new WeldELContextListener()); <line16> } <line17> super.contextInitialized(sce); <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> public static final void warningMessage() { <line1> LOGGER.info(""Test file not available""); <line2> } <line3> } <line4> "	No	task1	
"public class A { <line0> @RequestMapping( <line1> value = ""/adminStudies/validateconditionalFormula.do"", <line2> method = RequestMethod.POST) <line3> public void validateconditionalFormula(HttpServletRequest request, HttpServletResponse response) { <line4> logger.entry(""begin validateconditionalFormula""); <line5> JSONObject jsonobject = new JSONObject(); <line6> PrintWriter out = null; <line7> ObjectMapper mapper = new ObjectMapper(); <line8> JSONObject formulaResponseJsonObject = null; <line9> FormulaInfoBean formulaInfoBean = null; <line10> String message = FdahpStudyDesignerConstants.FAILURE; <line11> try { <line12> SessionObject sesObj = <line13> (SessionObject) <line14> request.getSession().getAttribute(FdahpStudyDesignerConstants.SESSION_OBJECT); <line15> if (sesObj != null) { <line16> String left_input = <line17> FdahpStudyDesignerUtil.isEmpty(request.getParameter(""left_input"")) <line18> ? """" <line19> : request.getParameter(""left_input""); <line20> String right_input = <line21> FdahpStudyDesignerUtil.isEmpty(request.getParameter(""right_input"")) <line22> ? """" <line23> : request.getParameter(""right_input""); <line24> String oprator_input = <line25> FdahpStudyDesignerUtil.isEmpty(request.getParameter(""oprator_input"")) <line26> ? """" <line27> : request.getParameter(""oprator_input""); <line28> String trialInputVal = <line29> FdahpStudyDesignerUtil.isEmpty(request.getParameter(""trialInput"")) <line30> ? """" <line31> : request.getParameter(""trialInput""); <line32> if (!left_input.isEmpty() <line33> && !right_input.isEmpty() <line34> && !oprator_input.isEmpty() <line35> && !trialInputVal.isEmpty()) { <line36> formulaInfoBean = <line37> studyQuestionnaireService.validateQuestionConditionalBranchingLogic( <line38> left_input, right_input, oprator_input, trialInputVal); <line39> if (formulaInfoBean != null) { <line40> formulaResponseJsonObject = new JSONObject(mapper.writeValueAsString(formulaInfoBean)); <line41> jsonobject.put(""formulaResponseJsonObject"", formulaResponseJsonObject); <line42> if (formulaInfoBean <line43> .getMessage() <line44> .equalsIgnoreCase(FdahpStudyDesignerConstants.SUCCESS)) { <line45> message = FdahpStudyDesignerConstants.SUCCESS; <line46> } <line47> } <line48> } <line49> } <line50> jsonobject.put(""message"", message); <line51> response.setContentType(""application/json""); <line52> out = response.getWriter(); <line53> out.print(jsonobject); <line54> } catch (Exception e) { <line55> } <line56> logger.exit(""validateconditionalFormula - Ends""); <line57> } <line58> } <line59> "	Yes	task1	
"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> @Override <line2> public void onConnectionLocalOpen(Event event) { <line3> log.trace(""Amqp connection opened locally""); <line4> if (this.authenticationType == DeviceClientConfig.AuthType.SAS_TOKEN) { <line5> Session cbsSession = connection.session(); <line6> amqpsCbsSessionHandler = new AmqpsCbsSessionHandler(cbsSession, this); <line7> for (AmqpsSasTokenRenewalHandler sasTokenRenewalHandler : this.sasTokenRenewalHandlers) { <line8> sasTokenRenewalHandler.close(); <line9> } <line10> sasTokenRenewalHandlers.clear(); <line11> for (AmqpsSessionHandler amqpsSessionHandler : this.sessionHandlers) { <line12> amqpsSessionHandler.setSession(connection.session()); <line13> sasTokenRenewalHandlers.add( <line14> new AmqpsSasTokenRenewalHandler(amqpsCbsSessionHandler, amqpsSessionHandler)); <line15> } <line16> } else { <line17> AmqpsSessionHandler amqpsSessionHandler = this.sessionHandlers.peek(); <line18> amqpsSessionHandler.setSession(connection.session()); <line19> } <line20> } <line21> } <line22> "	No	task1	
"public class A { <line0> @Override <line1> public void run() throws Exception { <line2> if (LOG.isDebugEnabled()) { <line3> LOG.debug( <line4> this.taskContext.formatLogString(""Reducer preprocessing done. Running Reducer code."")); <line5> } <line6> final Counter numRecordsIn = <line7> this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsInCounter(); <line8> final Counter numRecordsOut = <line9> this.taskContext.getMetricGroup().getIOMetricGroup().getNumRecordsOutCounter(); <line10> final MutableObjectIterator<T> input = this.input; <line11> final TypeSerializer<T> serializer = this.serializer; <line12> final TypeComparator<T> comparator = this.comparator; <line13> final ReduceFunction<T> function = this.taskContext.getStub(); <line14> final Collector<T> output = <line15> new CountingCollector<>(this.taskContext.getOutputCollector(), numRecordsOut); <line16> if (objectReuseEnabled) { <line17> T reuse1 = input.next(); <line18> T reuse2 = serializer.createInstance(); <line19> T value = reuse1; <line20> while (this.running && value != null) { <line21> numRecordsIn.inc(); <line22> comparator.setReference(value); <line23> while ((reuse2 = input.next(reuse2)) != null) { <line24> numRecordsIn.inc(); <line25> if (comparator.equalToReference(reuse2)) { <line26> value = function.reduce(value, reuse2); <line27> if (value == reuse2) { <line28> T tmp = reuse1; <line29> reuse1 = reuse2; <line30> reuse2 = tmp; <line31> } <line32> } else { <line33> break; <line34> } <line35> } <line36> output.collect(value); <line37> T tmp = reuse1; <line38> reuse1 = reuse2; <line39> reuse2 = tmp; <line40> value = reuse1; <line41> } <line42> } else { <line43> T value = input.next(); <line44> while (this.running && value != null) { <line45> numRecordsIn.inc(); <line46> comparator.setReference(value); <line47> T res = value; <line48> while ((value = input.next()) != null) { <line49> numRecordsIn.inc(); <line50> if (comparator.equalToReference(value)) { <line51> res = function.reduce(res, value); <line52> } else { <line53> break; <line54> } <line55> } <line56> output.collect(res); <line57> } <line58> } <line59> } <line60> } <line61> "	Yes	task1	
"public class A { <line0> @Override <line1> public INDArray getrf(INDArray A) { <line2> if (A.rows() > Integer.MAX_VALUE || A.columns() > Integer.MAX_VALUE) <line3> throw new ND4JArraySizeException(); <line4> int m = (int) A.rows(); <line5> int n = (int) A.columns(); <line6> INDArray INFO = <line7> Nd4j.createArrayFromShapeBuffer( <line8> Nd4j.getDataBufferFactory().createInt(1), <line9> Nd4j.getShapeInfoProvider().createShapeInformation(new int[] {1, 1}).getFirst()); <line10> int mn = Math.min(m, n); <line11> INDArray IPIV = <line12> Nd4j.createArrayFromShapeBuffer( <line13> Nd4j.getDataBufferFactory().createInt(mn), <line14> Nd4j.getShapeInfoProvider().createShapeInformation(new int[] {1, mn}).getFirst()); <line15> if (A.data().dataType() == DataBuffer.Type.DOUBLE) dgetrf(m, n, A, IPIV, INFO); <line16> else if (A.data().dataType() == DataBuffer.Type.FLOAT) sgetrf(m, n, A, IPIV, INFO); <line17> else throw new UnsupportedOperationException(); <line18> if (INFO.getInt(0) < 0) { <line19> throw new Error(""Parameter #"" + INFO.getInt(0) + "" to getrf() was not valid""); <line20> } else if (INFO.getInt(0) > 0) { <line21> log.warn( <line22> ""The matrix is singular - cannot be used for inverse op. Check L matrix at row "" <line23> + INFO.getInt(0)); <line24> } <line25> return IPIV; <line26> } <line27> } <line28> "	Yes	task1	
public class A { <line0> @Override <line1> public void deleteApplication(String applicationName) { <line2> delegate.deleteApplication(applicationName); <line3> } <line4> } <line5> 	Yes	task1	
public class A { <line0> private List<Map<String, Object>> documentListToResultList(SolrDocumentList docs) { <line1> final List<Map<String, Object>> results = new ArrayList<>(); <line2> for (SolrDocument doc : docs) { <line3> final PersistentItem result = new PersistentItem(); <line4> final Collection<String> fieldNames = doc.getFieldNames(); <line5> for (String name : fieldNames) { <line6> Collection<Object> fieldValues = doc.getFieldValues(name); <line7> if (name.endsWith(PersistentItem.TEXT_SUFFIX) && fieldValues.size() > 1) { <line8> result.addProperty( <line9> name, <line10> fieldValues.stream() <line11> .filter(String.class::isInstance) <line12> .map(String.class::cast) <line13> .collect(Collectors.toSet())); <line14> } else { <line15> addPropertyBasedOnSuffix(result, name, doc.getFirstValue(name)); <line16> } <line17> } <line18> results.add(result); <line19> } <line20> return results; <line21> } <line22> } <line23> 	Yes	task1	
"public class A { <line0> @Test <line1> public void noResultResponseTest() { <line2> Response<Void> response = new Response<Void>(1); <line3> response.setSessionId(""xxxxxxx""); <line4> String responseJson = response.toString(); <line5> JsonParser parser = new JsonParser(); <line6> JsonObject expected = <line7> (JsonObject) <line8> parser.parse(""{\""id\"":1,\""result\"":{\""sessionId\"":\""xxxxxxx\""},\""jsonrpc\"":\""2.0\""}""); <line9> JsonObject result = (JsonObject) parser.parse(responseJson); <line10> Assert.assertEquals(expected, result); <line11> Response<Void> newResponse = JsonUtils.fromJsonResponse(responseJson, Void.class); <line12> Assert.assertEquals(newResponse.getSessionId(), ""xxxxxxx""); <line13> } <line14> } <line15> "	Yes	task1	
public class A { <line0> protected final void writeValue(final Page page, final byte[] data) throws IOException { <line1> final PageHeader pageHeader = page.getPageHeader(); <line2> pageHeader.dataLen = fileHeader.workSize; <line3> if (data.length != pageHeader.dataLen) { <line4> if (pageHeader.dataLen != getPageSize() - 64) { <line5> } <line6> pageHeader.dataLen = data.length; <line7> } <line8> page.write(data); <line9> } <line10> } <line11> 	Yes	task1	
"public class A { <line0> public static Binding toBinding(QuerySolution qSolution) { <line1> BindingBuilder builder = Binding.builder(); <line2> for (Iterator<String> iter = qSolution.varNames(); iter.hasNext(); ) { <line3> String n = iter.next(); <line4> RDFNode x = qSolution.get(n); <line5> if (Var.isBlankNodeVarName(n)) continue; <line6> try { <line7> builder.add(Var.alloc(n), x.asNode()); <line8> } catch (ARQInternalErrorException ex) { <line9> Log.warn(BindingUtils.class, ""Attempt to bind "" + n + "" when already bound""); <line10> } <line11> } <line12> return builder.build(); <line13> } <line14> } <line15> "	No	task1	
public class A { <line0> private Optional<JSONObject> executeGETRequestJSON(String url) { <line1> try { <line2> return executeGETRequest(url).map(JSONObject::new); <line3> } catch (JSONException e) { <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	Yes	task1	
"public class A { <line0> @POST <line1> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line2> @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line3> @CheckPermission( <line4> roles = {Role.SYSTEM_MONITOR, Role.TENANT_ADMIN}, <line5> acls = {ACL.ANY}) <line6> public CinderQosDetail createQoS( <line7> @PathParam(""tenant_id"") String openstackTenantId, <line8> CinderQosCreateRequest param, <line9> @Context HttpHeaders header) { <line10> throw new UnsupportedOperationException(); <line11> } <line12> } <line13> "	Yes	task1	
"public class A { <line0> public SpTemplate getApplicationTemplate(String templateName) <line1> throws IdentityApplicationManagementServiceIdentityApplicationManagementClientException { <line2> try { <line3> if (debugEnabled) { <line4> log.debug(""Retrieving Service Provider template: "" + templateName); <line5> } <line6> return stub.getApplicationTemplate(templateName); <line7> } catch (RemoteException e) { <line8> handleException( <line9> e, ""Error occurred when retrieving Service Provider template: "" + templateName); <line10> } <line11> return null; <line12> } <line13> } <line14> "	No	task1	
public class A { <line0> @Override <line1> public DEDataListView remove(Serializable primaryKey) throws NoSuchDataListViewException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> DEDataListView deDataListView = <line6> (DEDataListView) session.get(DEDataListViewImpl.class, primaryKey); <line7> if (deDataListView == null) { <line8> if (log.isDebugEnabled()) { <line9> log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> throw new NoSuchDataListViewException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line12> } <line13> return remove(deDataListView); <line14> } catch (NoSuchDataListViewException noSuchEntityException) { <line15> throw noSuchEntityException; <line16> } catch (Exception exception) { <line17> throw processException(exception); <line18> } finally { <line19> closeSession(session); <line20> } <line21> } <line22> } <line23> 	No	task1	
"public class A { <line0> @Override <line1> public void removeComments(String ideaId, Connection conn) { <line2> PreparedStatement stat = null; <line3> try { <line4> stat = conn.prepareStatement(DELETE_COMMENTS); <line5> stat.setString(1, ideaId); <line6> stat.executeUpdate(); <line7> } catch (Throwable t) { <line8> this.executeRollback(conn); <line9> logger.error(""Error deleting IdeaComments"", t); <line10> throw new RuntimeException(""Error deleting IdeaComments"", t); <line11> } finally { <line12> closeDaoResources(null, stat, null); <line13> } <line14> } <line15> } <line16> "	No	task1	
"public class A { <line0> private Mono<SocketAddress> lookupRedis(RedisURI sentinelUri) { <line1> Duration timeout = getDefaultTimeout(); <line2> return Mono.usingWhen( <line3> Mono.fromCompletionStage( <line4> () -> connectSentinelAsync(newStringStringCodec(), sentinelUri, timeout)), <line5> c -> { <line6> String sentinelMasterId = sentinelUri.getSentinelMasterId(); <line7> return c.reactive() <line8> .getMasterAddrByName(sentinelMasterId) <line9> .map( <line10> it -> { <line11> if (it instanceof InetSocketAddress) { <line12> InetSocketAddress isa = (InetSocketAddress) it; <line13> SocketAddress resolved = <line14> getResources() <line15> .socketAddressResolver() <line16> .resolve(RedisURI.create(isa.getHostString(), isa.getPort())); <line17> logger.debug( <line18> ""Resolved Master {} SocketAddress {}:{} to {}"", <line19> sentinelMasterId, <line20> isa.getHostString(), <line21> isa.getPort(), <line22> resolved); <line23> return resolved; <line24> } <line25> return it; <line26> }) <line27> .timeout(timeout) <line28> .onErrorMap( <line29> e -> { <line30> RedisCommandTimeoutException ex = <line31> ExceptionFactory.createTimeoutException( <line32> ""Cannot obtain master using SENTINEL MASTER"", timeout); <line33> ex.addSuppressed(e); <line34> return ex; <line35> }); <line36> }, <line37> c -> Mono.fromCompletionStage(c::closeAsync), <line38> (c, ex) -> Mono.fromCompletionStage(c::closeAsync), <line39> c -> Mono.fromCompletionStage(c::closeAsync)); <line40> } <line41> } <line42> "	Yes	task1	
"public class A { <line0> @SuppressWarnings(""squid:S3655"") <line1> private ServiceDefinition validateServiceDefinitionName(final String serviceDefinitionName) { <line2> logger.debug(""validateServiceDefinition started...""); <line3> if (Utilities.isEmpty(serviceDefinitionName)) { <line4> throw new InvalidParameterException(""ServiceDefinitionName "" + EMPTY_OR_NULL_ERROR_MESSAGE); <line5> } <line6> final String validServiceDefinitionName = serviceDefinitionName.trim().toLowerCase(); <line7> final Optional<ServiceDefinition> serviceDefinitionOptional = <line8> serviceDefinitionRepository.findByServiceDefinition(validServiceDefinitionName); <line9> if (serviceDefinitionOptional.isEmpty()) { <line10> throw new InvalidParameterException( <line11> ""ServiceDefinition by serviceDefinitionName "" <line12> + validServiceDefinitionName <line13> + NOT_IN_DB_ERROR_MESSAGE); <line14> } <line15> return serviceDefinitionOptional.get(); <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> private void doFailoverHandlesConnectErrorInvalidFieldOnReconnectTestImpl( <line1> boolean includeContainerIdHint) throws Exception { <line2> try (TestAmqpPeer originalPeer = new TestAmqpPeer(); <line3> TestAmqpPeer rejectingPeer = new TestAmqpPeer(); <line4> TestAmqpPeer finalPeer = new TestAmqpPeer(); ) { <line5> final CountDownLatch finalConnected = new CountDownLatch(1); <line6> final String finalURI = createPeerURI(finalPeer); <line7> final DescribedType amqpValueNullContent = new AmqpValueDescribedType(null); <line8> originalPeer.expectSaslAnonymous(); <line9> originalPeer.expectOpen(); <line10> originalPeer.expectBegin(); <line11> originalPeer.dropAfterLastHandler(10); <line12> Map<Symbol, Object> errorInfo = null; <line13> if (includeContainerIdHint) { <line14> errorInfo = new HashMap<Symbol, Object>(); <line15> errorInfo.put(AmqpSupport.INVALID_FIELD, AmqpSupport.CONTAINER_ID); <line16> } <line17> rejectingPeer.rejectConnect(AmqpError.INVALID_FIELD, ""Client ID already in use"", errorInfo); <line18> finalPeer.expectSaslAnonymous(); <line19> finalPeer.expectOpen(); <line20> finalPeer.expectBegin(); <line21> final JmsConnection connection = <line22> establishAnonymousConnecton(originalPeer, rejectingPeer, finalPeer); <line23> connection.addConnectionListener( <line24> new JmsDefaultConnectionListener() { <line25> @Override <line26> public void onConnectionRestored(URI remoteURI) { <line27> LOG.info(""Connection Established: {}"", remoteURI); <line28> if (finalURI.equals(remoteURI.toString())) { <line29> finalConnected.countDown(); <line30> } <line31> } <line32> }); <line33> try { <line34> connection.start(); <line35> } catch (Exception ex) { <line36> fail(""Should not have thrown an Exception: "" + ex); <line37> } <line38> assertTrue(""Should connect to final peer"", finalConnected.await(5, TimeUnit.SECONDS)); <line39> finalPeer.expectBegin(); <line40> finalPeer.expectReceiverAttach(); <line41> finalPeer.expectLinkFlowRespondWithTransfer(null, null, null, null, amqpValueNullContent); <line42> finalPeer.expectDispositionThatIsAcceptedAndSettled(); <line43> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line44> Queue queue = session.createQueue(""myQueue""); <line45> MessageConsumer consumer = session.createConsumer(queue); <line46> Message message = consumer.receive(2000); <line47> assertNotNull(message); <line48> finalPeer.expectClose(); <line49> connection.close(); <line50> finalPeer.waitForAllHandlersToComplete(1000); <line51> } <line52> } <line53> } <line54> "	No	task1	
public class A { <line0> @OnOpen <line1> public void onManagementClientConnect(final Session session, final EndpointConfig config) { <line2> } <line3> } <line4> 	Yes	task1	
public class A { <line0> public static com.liferay.commerce.product.model.CommerceCatalogSoap updateCommerceCatalog( <line1> long commerceCatalogId, <line2> String name, <line3> String commerceCurrencyCode, <line4> String catalogDefaultLanguageId) <line5> throws RemoteException { <line6> try { <line7> com.liferay.commerce.product.model.CommerceCatalog returnValue = <line8> CommerceCatalogServiceUtil.updateCommerceCatalog( <line9> commerceCatalogId, name, commerceCurrencyCode, catalogDefaultLanguageId); <line10> return com.liferay.commerce.product.model.CommerceCatalogSoap.toSoapModel(returnValue); <line11> } catch (Exception exception) { <line12> log.error(exception, exception); <line13> throw new RemoteException(exception.getMessage()); <line14> } <line15> } <line16> } <line17> 	No	task1	
"public class A { <line0> @Test <line1> public void testCompound() { <line2> String q = <line3> ""(hOmE == 'hoMe-2' or Home == 'HOME-3' or 'hOME-1' == HoMe) and (Away == 'aWAy-3' or NuM =="" <line4> + "" 1)""; <line5> QueryJexl p = new QueryJexl(q, manager, date, date); <line6> Set<Map<String, String>> resp = p.evaluate(); <line7> Assert.assertEquals(2, resp.size()); <line8> for (Map<String, String> entry : resp) { <line9> String away = entry.get(TestHeader.away.name()); <line10> Assert.assertTrue(away.equals(""away-3"") || away.equals(""away-1"")); <line11> } <line12> } <line13> } <line14> "	Yes	task1	
public class A { <line0> public static boolean applySecurityGroupsToRedshift( <line1> AmazonRedshift amazonRedshift, Set<String> sgIdToBeAttached, String resourceId) <line2> throws Exception { <line3> boolean applysgFlg = false; <line4> try { <line5> ModifyClusterRequest clusterRequest = new ModifyClusterRequest(); <line6> clusterRequest.setClusterIdentifier(resourceId); <line7> clusterRequest.setVpcSecurityGroupIds(sgIdToBeAttached); <line8> amazonRedshift.modifyCluster(clusterRequest); <line9> applysgFlg = true; <line10> } catch (Exception e) { <line11> throw new Exception(e); <line12> } <line13> return applysgFlg; <line14> } <line15> } <line16> 	Yes	task1	
"public class A { <line0> public String enable() { <line1> if (getPingTarget() != null) { <line2> try { <line3> AutoPingManager autoPingMgr = WebloggerFactory.getWeblogger().getAutopingManager(); <line4> AutoPing autoPing = new AutoPing(null, getPingTarget(), getActionWeblog()); <line5> autoPingMgr.saveAutoPing(autoPing); <line6> WebloggerFactory.getWeblogger().flush(); <line7> } catch (Exception ex) { <line8> log.error(""Error saving auto ping for target - "" + getPingTargetId(), ex); <line9> addError(""Error enabling auto ping""); <line10> } <line11> } <line12> return execute(); <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @Override <line1> public void deleteBlocksFromHeight(int height) { <line2> long blockId; <line3> TransactionalDataSource dataSource = databaseManager.getDataSource(); <line4> try (Connection con = dataSource.getConnection(); <line5> PreparedStatement pstmt = con.prepareStatement(""SELECT id FROM block WHERE height = ?"")) { <line6> pstmt.setInt(1, height); <line7> try (ResultSet rs = pstmt.executeQuery()) { <line8> if (!rs.next()) { <line9> return; <line10> } <line11> blockId = rs.getLong(""id""); <line12> } <line13> } catch (SQLException e) { <line14> throw new RuntimeException(e.toString(), e); <line15> } <line16> deleteBlocksFrom(blockId); <line17> } <line18> } <line19> "	Yes	task1	
"public class A { <line0> private ITypeScriptServiceClient getTypeScriptServiceClient() { <line1> try { <line2> if (typeScriptServiceClient == null) { <line3> String tsserverPath = <line4> ProcessUtil.getGlobalNpmPackageNodeMainFilePath(""typescript"", ""tsserver""); <line5> TypeScriptServiceClient client = <line6> new TypeScriptServiceClient( <line7> new File("".""), <line8> new File(tsserverPath), <line9> null, <line10> false, <line11> false, <line12> null, <line13> null, <line14> new TypeScriptServiceLogConfiguration( <line15> ""/tmp/tss.log"", TypeScriptServiceLogLevel.verbose)); <line16> typeScriptServiceClient = client; <line17> logger.info(""creating TypeScriptServiceClient""); <line18> } <line19> return typeScriptServiceClient; <line20> } catch (TypeScriptException e) { <line21> throw new RuntimeException(e); <line22> } <line23> } <line24> } <line25> "	No	task1	
public class A { <line0> private void buildService( <line1> Map<String, ApiMethod> methods, <line2> Map<String, ApiService> services, <line3> List<String> invalidServices, <line4> ResultSet res) { <line5> String key = null; <line6> try { <line7> key = res.getString(1); <line8> String parentCode = res.getString(2); <line9> ApiMethod masterMethod = methods.get(parentCode); <line10> if (null != masterMethod) { <line11> ApsProperties description = new ApsProperties(); <line12> description.loadFromXml(res.getString(3)); <line13> ApsProperties parameters = new ApsProperties(); <line14> parameters.loadFromXml(res.getString(4)); <line15> String tag = res.getString(5); <line16> String[] freeParameters = null; <line17> String freeParamString = res.getString(6); <line18> if (null != freeParamString && freeParamString.trim().length() > 0) { <line19> ServiceExtraConfigDOM dom = new ServiceExtraConfigDOM(freeParamString); <line20> freeParameters = dom.extractFreeParameters(); <line21> } <line22> boolean isActive = (1 == res.getInt(7)) ? true : false; <line23> boolean isHidden = (1 == res.getInt(8)) ? true : false; <line24> ApiService apiService = <line25> new ApiService( <line26> key, <line27> description, <line28> masterMethod, <line29> parameters, <line30> freeParameters, <line31> tag, <line32> !isHidden, <line33> isActive); <line34> boolean authRequired = (1 == res.getInt(10)) ? true : false; <line35> apiService.setRequiredAuth(authRequired); <line36> String requiredPermission = res.getString(11); <line37> if (null != requiredPermission && requiredPermission.trim().length() > 0) { <line38> apiService.setRequiredPermission(requiredPermission); <line39> } <line40> String requiredGroup = res.getString(12); <line41> if (null != requiredGroup && requiredGroup.trim().length() > 0) { <line42> apiService.setRequiredGroup(requiredGroup); <line43> } <line44> services.put(key, apiService); <line45> } else { <line46> invalidServices.add(key); <line47> } <line48> } catch (Throwable t) { <line49> } <line50> } <line51> } <line52> 	Yes	task1	
public class A { <line0> @Override <line1> public void trace(Marker marker, String format, Object arg) { <line2> traceMessages.add(new LogMessage(marker, format, null, arg)); <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> private void processTemplates(Properties sliProps) { <line2> if (sliProps.containsKey(""bootstrap.app.keys"")) { <line3> String[] appKeys = sliProps.getProperty(""bootstrap.app.keys"").split("",""); <line4> for (String key : appKeys) { <line5> String templateKey = ""bootstrap.app."" + key + "".template""; <line6> if (sliProps.containsKey(templateKey)) { <line7> try { <line8> InputStream is = null; <line9> try { <line10> is = new ClassPathResource(sliProps.getProperty(templateKey)).getInputStream(); <line11> Map appData = loadJsonFile(is, sliProps); <line12> writeApplicationToMongo(appData); <line13> } finally { <line14> is.close(); <line15> } <line16> } catch (IOException e) { <line17> LOG.error(""Problem loading JSON template."", e); <line18> } <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	No	task1	
"public class A { <line0> public boolean isWithIn(EvaluateTermPosition o, int distance, int direction) { <line1> if (isZeroOffset(o)) { <line2> return false; <line3> } <line4> int low, high = -1; <line5> EvaluateTermPosition eval; <line6> switch (direction) { <line7> case FORWARD: <line8> low = termWeightPosition.getLowOffset(); <line9> high = termWeightPosition.getOffset() + distance; <line10> eval = o; <line11> break; <line12> case REVERSE: <line13> low = o.termWeightPosition.getLowOffset(); <line14> high = o.termWeightPosition.getOffset() + distance; <line15> eval = this; <line16> break; <line17> default: <line18> throw new IllegalArgumentException(""Invalid direction option.""); <line19> } <line20> if (log.isTraceEnabled()) { <line21> log.trace( <line22> ""EvaluateTermPosition.isWithIn: "" <line23> + low <line24> + ""<="" <line25> + eval.termWeightPosition.getOffset() <line26> + "" && "" <line27> + eval.termWeightPosition.getLowOffset() <line28> + ""<="" <line29> + high); <line30> } <line31> return (low <= eval.termWeightPosition.getOffset() <line32> && eval.termWeightPosition.getLowOffset() <= high); <line33> } <line34> } <line35> "	Yes	task1	
"public class A { <line0> @Override <line1> public byte[] uncompress(byte[] bytes) { <line2> if (bytes == null) { <line3> return new byte[0]; <line4> } <line5> try { <line6> return Snappy.uncompress(bytes); <line7> } catch (IOException e) { <line8> logger.error( <line9> ""tsfile-compression SnappyUnCompressor: errors occurs when uncompress input byte"", e); <line10> } <line11> return new byte[0]; <line12> } <line13> } <line14> "	Yes	task1	
public class A { <line0> private Response createErrorResponse(int code, Object body, String msg) { <line1> Response rsp = new Response(code, body); <line2> if (body == null) { <line3> rsp = new Response(code, msg); <line4> } <line5> return rsp; <line6> } <line7> } <line8> 	Yes	task1	
public class A { <line0> private void handleDelivered(JmsInboundMessageDispatch envelope, Delivery delivery) { <line1> deliveredCount++; <line2> envelope.setRecovered(false); <line3> envelope.setDelivered(true); <line4> delivery.setDefaultDeliveryState(MODIFIED_FAILED); <line5> } <line6> } <line7> 	Yes	task1	
public class A { <line0> public boolean synchronizeCatalogStudyFromStorage(StudyMetadata study, String sessionId) <line1> throws CatalogException { <line2> boolean modified = synchronizeFiles(study, null, sessionId); <line3> modified |= synchronizeCohorts(study, sessionId); <line4> return modified; <line5> } <line6> } <line7> 	Yes	task1	
"public class A { <line0> public RecordEvent getRcEvent() { <line1> RecordEvent ev = null; <line2> try { <line3> String rcEventClazz = DMUtil.getExtendAttr(this.remark, ""rcEventClass""); <line4> if (rcEventClazz != null) { <line5> ev = (RecordEvent) BeanUtil.newInstanceByName(rcEventClazz); <line6> } <line7> } catch (Exception e) { <line8> log.error(""init "" + this.recordName + "" event error : "", e); <line9> } <line10> return (RecordEvent) EasyUtils.checkNull(ev, new RecordEventN()); <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> public synchronized void start() throws IOException { <line1> if (id != null) { <line2> } <line3> Preconditions.checkState(tomcat == null); <line4> System.setProperty(""org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH"", ""true""); <line5> noSuchBaseDir = Files.createTempDirectory(""Oryx""); <line6> noSuchBaseDir.toFile().deleteOnExit(); <line7> Tomcat tomcat = new Tomcat(); <line8> Connector connector = makeConnector(); <line9> configureTomcat(tomcat, connector); <line10> configureEngine(tomcat.getEngine()); <line11> configureServer(tomcat.getServer()); <line12> configureHost(tomcat.getHost()); <line13> makeContext(tomcat, noSuchBaseDir); <line14> try { <line15> tomcat.start(); <line16> } catch (LifecycleException le) { <line17> throw new IOException(le); <line18> } <line19> this.tomcat = tomcat; <line20> } <line21> } <line22> "	Yes	task1	
"public class A { <line0> @Override <line1> public void onOpen(Connection connection) { <line2> LOG.debug(""onOpen""); <line3> this.connection = connection; <line4> this.connection.setMaxIdleTime(5 * 60 * 1000); <line5> this.connection.setMaxTextMessageSize(8 * 1024 * 1024); <line6> messengerThread.start(); <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> public String flushCache() { <line1> try { <line2> Weblog weblog = getActionWeblog(); <line3> weblog.setLastModified(new Date()); <line4> WebloggerFactory.getWeblogger().getWeblogManager().saveWeblog(weblog); <line5> WebloggerFactory.getWeblogger().flush(); <line6> CacheManager.invalidate(weblog); <line7> addMessage(""maintenance.message.flushed""); <line8> } catch (Exception ex) { <line9> addError(""Error flushing page cache""); <line10> } <line11> return SUCCESS; <line12> } <line13> } <line14> "	Yes	task1	
public class A { <line0> protected final void cancelGroup(TaskAnalyser ta, TaskDispatcher td) { <line1> TaskGroup tg = ta.removeTaskGroup(app, groupName); <line2> if (tg != null) { <line3> List<Task> tasks = tg.getTasks(); <line4> int taskCount = tasks.size(); <line5> StaticMultioperationSemaphore listener = new StaticMultioperationSemaphore(taskCount, sem); <line6> for (Task t : tasks) { <line7> td.cancelTasks(t, listener); <line8> } <line9> } else { <line10> sem.release(); <line11> } <line12> } <line13> } <line14> 	Yes	task1	
"public class A { <line0> @Override <line1> public void setSystemTokenOnClient( <line2> Client client, String clientId, String clientSecret, String discoveryUrl) { <line3> if (client == null <line4> || Strings.isBlank(clientId) <line5> || Strings.isBlank(clientSecret) <line6> || Strings.isBlank(discoveryUrl)) { <line7> return; <line8> } <line9> String encodedClientIdSecret = <line10> Base64.getEncoder().encodeToString((clientId + "":"" + clientSecret).getBytes(UTF_8)); <line11> Map<String, String> queryParameters = Collections.singletonMap(GRANT_TYPE, CLIENT_CREDENTIALS); <line12> String accessToken = <line13> getValidToken( <line14> encodedClientIdSecret, <line15> CLIENT_CREDENTIALS, <line16> clientId, <line17> clientSecret, <line18> discoveryUrl, <line19> CLIENT_CREDENTIALS, <line20> queryParameters); <line21> if (accessToken != null) { <line22> client.header(OAUTH, BEARER + accessToken); <line23> } <line24> } <line25> } <line26> "	Yes	task1	
"public class A { <line0> @Override <line1> public synchronized void disconnectBindings() throws Exception { <line2> logger.debug(ClusterConnectionImpl.this + "" disconnect bindings""); <line3> reset = false; <line4> for (RemoteQueueBinding binding : new HashSet<>(bindings.values())) { <line5> disconnectBinding(binding.getClusterName()); <line6> } <line7> } <line8> } <line9> "	No	task1	
public class A { <line0> public void warn(String mesg) { <line1> } <line2> } <line3> 	Yes	task1	
public class A { <line0> @Override <line1> public void setMaxPhenomenonTimeForProcedure(String procedure, DateTime maxTime) { <line2> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line3> if (maxTime == null) { <line4> this.maxPhenomenonTimeForProcedures.remove(procedure); <line5> } else { <line6> this.maxPhenomenonTimeForProcedures.put(procedure, DateTimeHelper.toUTC(maxTime)); <line7> } <line8> } <line9> } <line10> 	Yes	task1	
"public class A { <line0> private void initCloudServiceTracking() { <line1> String selectedCloudServicePid = this.cloudSubscriberOptions.getCloudServicePid(); <line2> String filterString = <line3> String.format( <line4> ""(&(%s=%s)(kura.service.pid=%s))"", <line5> Constants.OBJECTCLASS, CloudConnectionManager.class.getName(), selectedCloudServicePid); <line6> Filter filter = null; <line7> try { <line8> filter = this.bundleContext.createFilter(filterString); <line9> } catch (InvalidSyntaxException e) { <line10> } <line11> this.cloudServiceTracker = <line12> new ServiceTracker<>(this.bundleContext, filter, this.cloudServiceTrackerCustomizer); <line13> this.cloudServiceTracker.open(); <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> public static void assertContentNotContainsText( <line1> final String url, final String phrase, final String... additionalPhrases) { <line2> try { <line3> String contents = HttpTool.getContent(url); <line4> Asserts.assertTrue(contents != null); <line5> for (String text : Lists.asList(phrase, additionalPhrases)) { <line6> if (contents.contains(text)) { <line7> LOG.warn(""CONTENTS OF URL "" + url + "" HAS TEXT: "" + text + ""\n"" + contents); <line8> Asserts.fail(""URL "" + url + "" contain text: "" + text); <line9> } <line10> } <line11> } catch (Exception e) { <line12> throw propagateAsAssertionError(e); <line13> } <line14> } <line15> } <line16> "	No	task1	
public class A { <line0> @Override <line1> public void flush() { <line2> try { <line3> processChanges(_pendingChanges); <line4> } catch (final Exception e) { <line5> Log.error(_logger, e); <line6> } <line7> _pendingChanges.clear(); <line8> refreshCheck(); <line9> } <line10> } <line11> 	No	task1	
"public class A { <line0> public Date getFormattedEventTime() { <line1> DateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); <line2> Date date = new Date(); <line3> try { <line4> date = dateFormat.parse(dateFormat.format(date)); <line5> } catch (ParseException ex) { <line6> } <line7> return date; <line8> } <line9> } <line10> "	Yes	task1	
public class A { <line0> public org.talend.mdm.webservice.WSBoolean supportStaging( <line1> org.talend.mdm.webservice.WSDataClusterPK arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSBoolean _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	Yes	task1	
"public class A { <line0> @Override <line1> public FrontierReportLine getLineForDomain(String domainName) { <line2> try { <line3> return linesByDomain.get(domainName); <line4> } catch (DatabaseException e) { <line5> LOG.warn(""Failed to get queue for domain "" + domainName, e); <line6> return null; <line7> } <line8> } <line9> } <line10> "	No	task1	
public class A { <line0> public T allocateExecutor(Set<String> dependencies) { <line1> String dependenciesKey = generatedDependenciesKey(dependencies); <line2> T executor; <line3> T candidateForRemove = null; <line4> lock.lock(); <line5> try { <line6> executor = executors.get(dependenciesKey); <line7> if (executor == null) { <line8> int cacheSize = getCacheSize(); <line9> if (executors.size() == cacheSize) { <line10> Iterator<Map.Entry<String, T>> iterator = executors.entrySet().iterator(); <line11> candidateForRemove = iterator.next().getValue(); <line12> iterator.remove(); <line13> } <line14> executor = createNewExecutor(getDependencyService().getDependencies(dependencies)); <line15> } else { <line16> executors.remove(dependenciesKey); <line17> } <line18> executor.allocate(); <line19> executors.put(dependenciesKey, executor); <line20> } finally { <line21> lock.unlock(); <line22> } <line23> if (candidateForRemove != null) { <line24> candidateForRemove.close(); <line25> } <line26> return executor; <line27> } <line28> } <line29> 	Yes	task1	
"public class A { <line0> private void processDisconnectedPeers( <line1> Assignments assignments, BitfieldBasedStatistics statistics) { <line2> ConnectionKey disconnectedPeer; <line3> while ((disconnectedPeer = disconnectedPeers.poll()) != null) { <line4> if (assignments != null) { <line5> Assignment assignment = assignments.get(disconnectedPeer); <line6> if (assignment != null) { <line7> assignments.remove(assignment); <line8> if (LOGGER.isTraceEnabled()) { <line9> LOGGER.trace( <line10> ""Peer assignment removed due to DISCONNECT: peer {}, assignment {}"", <line11> disconnectedPeer, <line12> assignment); <line13> } <line14> } <line15> } <line16> timeoutedPeers.remove(disconnectedPeer); <line17> if (statistics != null) { <line18> statistics.removeBitfield(disconnectedPeer); <line19> } <line20> } <line21> } <line22> } <line23> "	No	task1	
public class A { <line0> @Override <line1> public void execute() throws Exception { <line2> executeInternal(_consumer, _publisher, _lifeCycleHelper); <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> @Override <line1> public RepositoryConfig getRepositoryConfig(String repositoryID) <line2> throws RepositoryConfigException, RepositoryException { <line3> RepositoryConfig result = delegate.getRepositoryConfig(repositoryID); <line4> if (result != null) { <line5> if (!isCorrectType(result)) { <line6> logger.debug( <line7> ""Surpressing retrieval of repository {}: repository type {} did not match expected type"" <line8> + "" {}"", <line9> new Object[] {result.getID(), result.getRepositoryImplConfig().getType(), type}); <line10> result = null; <line11> } <line12> } <line13> return result; <line14> } <line15> } <line16> "	Yes	task1	
public class A { <line0> public boolean isNetworkSetupByName(final String nameTag) <line1> throws XenAPIException, XmlRpcException { <line2> if (nameTag != null) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> final Connection conn = getConnection(); <line6> final XsLocalNetwork network = getNetworkByName(conn, nameTag); <line7> if (network == null) { <line8> return false; <line9> } <line10> } <line11> return true; <line12> } <line13> } <line14> 	Yes	task1	
public class A { <line0> public static com.liferay.journal.model.JournalFeedSoap updateFeed( <line1> long groupId, <line2> String feedId, <line3> String name, <line4> String description, <line5> String ddmStructureKey, <line6> String ddmTemplateKey, <line7> String ddmRendererTemplateKey, <line8> int delta, <line9> String orderByCol, <line10> String orderByType, <line11> String targetLayoutFriendlyUrl, <line12> String targetPortletId, <line13> String contentField, <line14> String feedType, <line15> double feedVersion, <line16> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line17> throws RemoteException { <line18> try { <line19> com.liferay.journal.model.JournalFeed returnValue = <line20> JournalFeedServiceUtil.updateFeed( <line21> groupId, <line22> feedId, <line23> name, <line24> description, <line25> ddmStructureKey, <line26> ddmTemplateKey, <line27> ddmRendererTemplateKey, <line28> delta, <line29> orderByCol, <line30> orderByType, <line31> targetLayoutFriendlyUrl, <line32> targetPortletId, <line33> contentField, <line34> feedType, <line35> feedVersion, <line36> serviceContext); <line37> return com.liferay.journal.model.JournalFeedSoap.toSoapModel(returnValue); <line38> } catch (Exception exception) { <line39> log.error(exception, exception); <line40> throw new RemoteException(exception.getMessage()); <line41> } <line42> } <line43> } <line44> 	No	task1	
"public class A { <line0> public static void logContents(String message) { <line1> if (log.isDebugEnabled()) { <line2> log.debug( <line3> ""{}: {}"", <line4> message, <line5> data.entrySet().stream() <line6> .map( <line7> e -> <line8> e.getKey() <line9> + ""="" <line10> + (e.getValue() != null <line11> ? (e.getValue().stream() <line12> .map(Object::toString) <line13> .collect(Collectors.joining("",\n\t"", ""[\n\t"", ""]""))) <line14> : ""null"")) <line15> .collect(Collectors.joining("",\n""))); <line16> } <line17> } <line18> } <line19> "	Yes	task1	
"public class A { <line0> @PostConstruct <line1> public void configure() { <line2> LOGGER.info(""Kie Server Controller WebSocket Notification service initialized""); <line3> } <line4> } <line5> "	No	task1	
public class A { <line0> @Override <line1> public Version checkin(String absPath) <line2> throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, <line3> LockException, RepositoryException { <line4> return checkin(session.getNode(absPath)); <line5> } <line6> } <line7> 	Yes	task1	
"public class A { <line0> @Override <line1> public void initialize() { <line2> logger.debug(""Initializing DWD Pollenflug bridge handler""); <line3> bridgeConfig = getConfigAs(DWDPollenflugBridgeConfiguration.class); <line4> if (bridgeConfig.isValid()) { <line5> updateStatus(ThingStatus.UNKNOWN); <line6> startPolling(); <line7> } else { <line8> updateStatus( <line9> ThingStatus.OFFLINE, <line10> ThingStatusDetail.CONFIGURATION_ERROR, <line11> ""Refresh interval has to be at least 15 minutes.""); <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> private Map<String, Object> getNodeTypesFromAdp(Map<String, Object> adp) <line1> throws AdpParsingException { <line2> try { <line3> return (Map<String, Object>) adp.get(NODE_TYPES_KEY); <line4> } catch (NullPointerException E) { <line5> throw new AdpParsingException( <line6> ""The parser was not able to retrieve the 'node_types' from the current ADP.""); <line7> } <line8> } <line9> } <line10> "	Yes	task1	
"public class A { <line0> @Test <line1> public void testSimpleRuleGenerationAndCompilation5() { <line2> try { <line3> UdrRule udrRule = <line4> RuleBuilderTestUtils.createSimpleUdrRule(UDR_RULE_AUTHOR, PASSENGER_SEAT_RULE_INDX); <line5> testTarget.addRule(udrRule); <line6> String result = testTarget.build(); <line7> verifyDrl(result, PASSENGER_SEAT_RULE_INDX); <line8> testKnowledgeBaseTest(result); <line9> } catch (Exception ex) { <line10> fail(""Not expecting exception.""); <line11> } <line12> } <line13> } <line14> "	Yes	task1	
"public class A { <line0> private static final Exception checkJson(String _json) { <line1> Exception exception = null; <line2> if (_json != null) { <line3> try { <line4> JsonBuilder.checkJsonValidity(_json); <line5> } catch (JsonSyntaxException jse) { <line6> BasicHttpRequest.log.error(""Invalid JSON syntax: "" + jse.getMessage()); <line7> exception = jse; <line8> } <line9> } <line10> return exception; <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> public static java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> getGroupVocabularies( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator< <line6> com.liferay.asset.kernel.model.AssetVocabulary> <line7> orderByComparator) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> AssetVocabularyServiceUtil.class, <line12> ""getGroupVocabularies"", <line13> _getGroupVocabulariesParameterTypes14); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, start, end, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.asset.kernel.model.AssetVocabulary>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> log.error(systemException, systemException); <line25> throw systemException; <line26> } <line27> } <line28> } <line29> "	No	task1	
"public class A { <line0> @Override <line1> public Set<String> getTableNames() { <line2> try (Admin admin = plugin.getConnection().getAdmin()) { <line3> HTableDescriptor[] tables = admin.listTables(); <line4> Set<String> tableNames = Sets.newHashSet(); <line5> for (HTableDescriptor table : tables) { <line6> tableNames.add(new String(table.getTableName().getNameAsString())); <line7> } <line8> return tableNames; <line9> } catch (Exception e) { <line10> logger.warn(""Failure while loading table names for database '{}'."", getName(), e.getCause()); <line11> return Collections.emptySet(); <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> public List<SubrogationDto> getSubrogationsBySuperUserEmail( <line1> final InternalHttpContext context, final String superUserEmail) { <line2> LOGGER.debug(""getMySubrogationAsSuperuser {}"", superUserEmail); <line3> final HttpEntity request = new HttpEntity(buildHeaders(context)); <line4> final ResponseEntity<List<SubrogationDto>> response = <line5> restTemplate.exchange( <line6> getUrl() + RestApi.CAS_SUBROGATIONS_PATH + ""?superUserEmail="" + superUserEmail, <line7> HttpMethod.GET, <line8> request, <line9> getSubrogationDtoListClass()); <line10> checkResponse(response); <line11> return response.getBody(); <line12> } <line13> } <line14> "	No	task1	
public class A { <line0> @Override <line1> public void putUserInCache(X509Certificate userCert, UserDetails user) { <line2> Element element = new Element(userCert, user); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> cache.put(element); <line6> } <line7> } <line8> 	Yes	task1	
"public class A { <line0> @Override <line1> public FragmentComposition findByG_FCK(long groupId, String fragmentCompositionKey) <line2> throws NoSuchCompositionException { <line3> FragmentComposition fragmentComposition = fetchByG_FCK(groupId, fragmentCompositionKey); <line4> if (fragmentComposition == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""groupId=""); <line8> sb.append(groupId); <line9> sb.append("", fragmentCompositionKey=""); <line10> sb.append(fragmentCompositionKey); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchCompositionException(sb.toString()); <line15> } <line16> return fragmentComposition; <line17> } <line18> } <line19> "	Yes	task1	
"public class A { <line0> private char findAlternative(char c) { <line1> char d; <line2> if (alternativeCodes == null) { <line3> alternativeCodes = new java.util.HashMap<Character, Character>(); <line4> } else { <line5> Character alternative = alternativeCodes.get(c); <line6> if (alternative != null) { <line7> return alternative; <line8> } <line9> } <line10> String charName = Glyphs.charToGlyphName(c); <line11> String[] charNameAlternatives = Glyphs.getCharNameAlternativesFor(charName); <line12> if (charNameAlternatives != null && charNameAlternatives.length > 0) { <line13> for (String charNameAlternative : charNameAlternatives) { <line14> if (log.isDebugEnabled()) { <line15> log.debug( <line16> ""Checking alternative for char "" <line17> + c <line18> + "" (charname="" <line19> + charName <line20> + ""): "" <line21> + charNameAlternative); <line22> } <line23> String s = Glyphs.getUnicodeSequenceForGlyphName(charNameAlternative); <line24> if (s != null) { <line25> d = lookupChar(s.charAt(0)); <line26> if (d != SingleByteEncoding.NOT_FOUND_CODE_POINT) { <line27> alternativeCodes.put(c, d); <line28> return d; <line29> } <line30> } <line31> } <line32> } <line33> return SingleByteEncoding.NOT_FOUND_CODE_POINT; <line34> } <line35> } <line36> "	Yes	task1	
"public class A { <line0> private void validateHeaders() { <line1> HtmlHeaderContainer header = <line2> visitChildren( <line3> new IVisitor<Component, HtmlHeaderContainer>() { <line4> @Override <line5> public void component( <line6> final Component component, final IVisit<HtmlHeaderContainer> visit) { <line7> if (component instanceof HtmlHeaderContainer) { <line8> visit.stop((HtmlHeaderContainer) component); <line9> } else if (component instanceof TransparentWebMarkupContainer == false) { <line10> visit.dontGoDeeper(); <line11> } <line12> } <line13> }); <line14> if (header == null) { <line15> header = new HtmlHeaderContainer(HtmlHeaderSectionHandler.HEADER_ID); <line16> add(header); <line17> RequestCycle requestCycle = getRequestCycle(); <line18> Response orgResponse = requestCycle.getResponse(); <line19> try { <line20> StringResponse tempResponse = new StringResponse(); <line21> requestCycle.setResponse(tempResponse); <line22> AbstractHeaderRenderStrategy.get().renderHeader(header, null, getPage()); <line23> IHeaderResponse headerResponse = header.getHeaderResponse(); <line24> headerResponse.close(); <line25> CharSequence collectedHeaderOutput = tempResponse.getBuffer(); <line26> if (collectedHeaderOutput.length() > 0) { <line27> reportMissingHead(collectedHeaderOutput); <line28> } <line29> } catch (Exception e) { <line30> log.error(""header/body check throws exception"", e); <line31> } finally { <line32> this.remove(header); <line33> requestCycle.setResponse(orgResponse); <line34> } <line35> } <line36> } <line37> } <line38> "	No	task1	
"public class A { <line0> void deleteAccountDetailType( <line1> final List<Accountdetailtype> accountDetailType, final CChartOfAccounts accounts) { <line2> String accountDetail = """"; <line3> if (accounts.getChartOfAccountDetails() == null) return; <line4> chartOfAccountsService.getSession().flush(); <line5> try { <line6> for (final Accountdetailtype row : accountDetailType) { <line7> final Iterator<CChartOfAccountDetail> iterator = <line8> accounts.getChartOfAccountDetails().iterator(); <line9> while (iterator.hasNext()) { <line10> final CChartOfAccountDetail next = iterator.next(); <line11> accountDetail = row.getName(); <line12> if (next == null || next.getDetailTypeId().getId().equals(row.getId())) { <line13> iterator.remove(); <line14> chartOfAccountDetailService.delete( <line15> chartOfAccountDetailService.findById(next.getId(), false)); <line16> persistenceService.getSession().flush(); <line17> } <line18> } <line19> } <line20> } catch (final Exception e) { <line21> populateAccountDetailTypeList(); <line22> final String message = accountDetail.concat("" "").concat(e.toString()); <line23> throw new ValidationException(Arrays.asList(new ValidationError(message, message))); <line24> } <line25> } <line26> } <line27> "	Yes	task1	
"public class A { <line0> private void toggleRight( <line1> IPartialPageRequestHandler handler, Client self, String uid, JSONObject o) { <line2> try { <line3> Right right = Right.valueOf(o.getString(PARAM_RIGHT)); <line4> if (self.hasRight(Right.MODERATOR)) { <line5> Client client = cm.get(uid); <line6> if (client == null) { <line7> return; <line8> } <line9> if (client.hasRight(right)) { <line10> room.denyRight(client, right); <line11> } else { <line12> if (Right.VIDEO == right) { <line13> room.allowRight(client, Right.AUDIO, right); <line14> } else { <line15> room.allowRight(client, right); <line16> } <line17> } <line18> } else { <line19> room.requestRight(right, handler); <line20> } <line21> } catch (Exception e) { <line22> log.error(""Unexpected exception while toggle 'right'"", e); <line23> } <line24> } <line25> } <line26> "	No	task1	
public class A { <line0> @Override <line1> public List<DropdownItem> getActionDropdownItems() { <line2> JournalArticleActionDropdownItemsProvider articleActionDropdownItemsProvider = <line3> new JournalArticleActionDropdownItemsProvider( <line4> _article, <line5> PortalUtil.getLiferayPortletRequest(renderRequest), <line6> PortalUtil.getLiferayPortletResponse(_renderResponse), <line7> _assetDisplayPageFriendlyURLProvider, <line8> _trashHelper); <line9> try { <line10> return articleActionDropdownItemsProvider.getArticleHistoryActionDropdownItems(); <line11> } catch (Exception exception) { <line12> if (log.isDebugEnabled()) { <line13> log.debug(exception, exception); <line14> } <line15> } <line16> return null; <line17> } <line18> } <line19> 	No	task1	
"public class A { <line0> @Override <line1> public synchronized void stop() { <line2> super.stop(); <line3> log.info(""Stopped FileOffsetBackingStore""); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> protected void rollback(boolean isNew) throws Exception { <line1> try { <line2> if (isNew) { <line3> transactionManager.rollback(); <line4> } else { <line5> transactionManager.setRollbackOnly(); <line6> } <line7> } catch (Throwable e) { <line8> LOG.warn(""Could not rollback transaction!"", e); <line9> } <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> public T call(Entity entity, Map parameters) { <line2> Object[] parametersArray = EffectorUtils.prepareArgsForEffector(this, parameters); <line3> if (entity instanceof AbstractEntity) { <line4> return EffectorUtils.invokeMethodEffector(entity, this, parametersArray); <line5> } else { <line6> Method[] methods = entity.getClass().getMethods(); <line7> for (Method method : methods) { <line8> if (method.getName().equals(getName())) { <line9> if (parametersArray.length == method.getParameterTypes().length) { <line10> try { <line11> return (T) method.invoke(entity, parametersArray); <line12> } catch (Exception e) { <line13> throw Exceptions.propagate(e); <line14> } <line15> } <line16> } <line17> } <line18> String msg = <line19> ""Could not find method for effector "" <line20> + getName() <line21> + "" with "" <line22> + parametersArray.length <line23> + "" parameters on "" <line24> + entity; <line25> throw new IllegalStateException(msg); <line26> } <line27> } <line28> } <line29> "	Yes	task1	
public class A { <line0> @Override <line1> public void onConnectionEstablished(URI remoteURI) { <line2> if (isExpectedHost(primaryPeerURI, remoteURI)) { <line3> connectedToPrimary.countDown(); <line4> } <line5> } <line6> } <line7> 	Yes	task1	
public class A { <line0> private void deleteObsoletePendingTasks(SingularityPendingDeploy pendingDeploy) { <line1> List<SingularityPendingTaskId> obsoletePendingTasks = <line2> taskManager <line3> .getPendingTaskIdsForRequest(pendingDeploy.getDeployMarker().getRequestId()) <line4> .stream() <line5> .filter( <line6> taskId -> <line7> !taskId.getDeployId().equals(pendingDeploy.getDeployMarker().getDeployId())) <line8> .collect(Collectors.toList()); <line9> for (SingularityPendingTaskId pendingTaskId : obsoletePendingTasks) { <line10> taskManager.deletePendingTask(pendingTaskId); <line11> } <line12> } <line13> } <line14> 	Yes	task1	
"public class A { <line0> private static void loginGluuServer( <line1> WebDriver driver, <line2> String opHost, <line3> String userId, <line4> String userSecret, <line5> String clientId, <line6> String redirectUrls, <line7> String state, <line8> String nonce, <line9> List<String> responseTypes, <line10> List<String> scopes) { <line11> driver <line12> .navigate() <line13> .to( <line14> getAuthorizationUrl( <line15> opHost, clientId, redirectUrls, state, nonce, responseTypes, scopes)); <line16> Wait<WebDriver> wait = <line17> new FluentWait<WebDriver>(driver) <line18> .withTimeout(Duration.ofSeconds(WAIT_OPERATION_TIMEOUT)) <line19> .pollingEvery(Duration.ofMillis(500)) <line20> .ignoring(NoSuchElementException.class); <line21> WebElement loginButton = <line22> wait.until( <line23> new Function<WebDriver, WebElement>() { <line24> public WebElement apply(WebDriver d) { <line25> return d.findElement(By.id(""loginForm:loginButton"")); <line26> } <line27> }); <line28> LOG.info(""Login page loaded. The current url is: "" + driver.getCurrentUrl()); <line29> WebElement usernameElement = driver.findElement(By.id(""loginForm:username"")); <line30> usernameElement.sendKeys(userId); <line31> WebElement passwordElement = driver.findElement(By.id(""loginForm:password"")); <line32> passwordElement.sendKeys(userSecret); <line33> loginButton.click(); <line34> driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); <line35> } <line36> } <line37> "	No	task1	
"public class A { <line0> public static Optional<ObjectNode> updateNotificationChannel(ObjectNode objContent) { <line1> String newName = null; <line2> if (objContent.get(""name"").asText().equals(""Default e-mail channel"")) { <line3> newName = ""default_email""; <line4> } <line5> if (objContent.get(""name"").asText().equals(""Default SMS channel"")) { <line6> newName = ""default_sms""; <line7> } <line8> if (newName != null) { <line9> log.info( <line10> ""Updating notification channel {}, changing name to {}"", getName(objContent), newName); <line11> objContent.put(""name"", newName); <line12> return Optional.of(objContent); <line13> } <line14> return Optional.empty(); <line15> } <line16> } <line17> "	Yes	task1	
"public class A { <line0> protected String getSummariesXML(List<String> idList) { <line1> String queryList = getSerializedList(idList); <line2> String url = composeURL(TERM_SUMMARY_QUERY_SCRIPT, TERM_SUMMARY_PARAM_NAME, queryList); <line3> try { <line4> Document response = readXML(url); <line5> NodeList nodes = response.getElementsByTagName(""Item""); <line6> for (int i = 0; i < nodes.getLength(); ++i) { <line7> Node n = nodes.item(i); <line8> if (n.getNodeType() == Node.ELEMENT_NODE) { <line9> if (n.getFirstChild() != null) { <line10> n.replaceChild(response.createTextNode(fixCase(n.getTextContent())), n.getFirstChild()); <line11> } <line12> } <line13> } <line14> Source source = new DOMSource(response); <line15> StringWriter stringWriter = new StringWriter(); <line16> Result result = new StreamResult(stringWriter); <line17> TransformerFactory factory = TransformerFactory.newInstance(); <line18> Transformer transformer = factory.newTransformer(); <line19> transformer.transform(source, result); <line20> return stringWriter.getBuffer().toString(); <line21> } catch (Exception ex) { <line22> this.logger.error( <line23> ""Error while trying to retrieve summaries for ids "" <line24> + idList <line25> + "" "" <line26> + ex.getClass().getName() <line27> + "" "" <line28> + ex.getMessage(), <line29> ex); <line30> } <line31> return """"; <line32> } <line33> } <line34> "	Yes	task1	
public class A { <line0> @Nullable <line1> private static Subject getSubject() { <line2> Subject subject = null; <line3> try { <line4> subject = Subject.getSubject(AccessController.getContext()); <line5> } catch (SecurityException e) { <line6> } <line7> return subject; <line8> } <line9> } <line10> 	Yes	task1	
"public class A { <line0> @Override <line1> public void doPut(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> LOG.debug(""Received do PUT request.""); <line4> resp.setStatus(HttpServletResponse.SC_NOT_IMPLEMENTED); <line5> } <line6> } <line7> "	No	task1	
"public class A { <line0> private Map<String, String> generateMachineId(ClusterCreate clusterSpec, NodeEntity node) { <line1> List<NetworkAdd> networkAdds = clusterSpec.getNetworkings(); <line2> GuestMachineIdSpec machineIdSpec = <line3> new GuestMachineIdSpec( <line4> networkAdds, <line5> node.fetchPortGroupToIpMap(), <line6> node.getPrimaryMgtNic().getNetworkEntity().getPortGroup(), <line7> node, <line8> networkMgr); <line9> logger.info(""machine id of vm "" + node.getVmName() + "":\n"" + machineIdSpec.toString()); <line10> Map<String, String> guestVariable = machineIdSpec.toGuestVariable(); <line11> return guestVariable; <line12> } <line13> } <line14> "	No	task1	
"public class A { <line0> protected void stopTarget(String address) { <line1> if (control != null && targets.contains(address)) { <line2> assertTrue(""Failed to start greeter"", control.stopGreeter(address)); <line3> targets.remove(address); <line4> } <line5> } <line6> } <line7> "	Yes	task1	
"public class A { <line0> private void deleteSilently(Path dir) { <line1> try { <line2> fileSystem.deleteRecursively(dir); <line3> } catch (IOException e) { <line4> log.error(""Unable to delete directory: "" + dir, e); <line5> } <line6> } <line7> } <line8> "	No	task1	
"public class A { <line0> @Test(timeout = 20000) <line1> public void testSendWhenLinkCreditIsZeroAndTimeout() throws Exception { <line2> try (TestAmqpPeer testPeer = new TestAmqpPeer(); ) { <line3> JmsConnection connection = (JmsConnection) testFixture.establishConnecton(testPeer); <line4> connection.setSendTimeout(500); <line5> testPeer.expectBegin(); <line6> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line7> String queueName = ""myQueue""; <line8> Queue queue = session.createQueue(queueName); <line9> Message message = session.createTextMessage(""text""); <line10> testPeer.expectSenderAttachWithoutGrantingCredit(); <line11> testPeer.expectClose(); <line12> MessageProducer producer = session.createProducer(queue); <line13> try { <line14> producer.send(message); <line15> fail(""Send should time out.""); <line16> } catch (JmsSendTimedOutException jmsEx) { <line17> LOG.info(""Caught expected error: {}"", jmsEx.getMessage()); <line18> } catch (Throwable error) { <line19> fail(""Send should time out, but got: "" + error.getMessage()); <line20> } <line21> connection.close(); <line22> testPeer.waitForAllHandlersToComplete(1000); <line23> } <line24> } <line25> } <line26> "	No	task1	
"public class A { <line0> @Override <line1> public boolean savePersonName(PersonNameType personname) throws LoadTestDataException { <line2> SavePersonNameRequestMessageType request = new SavePersonNameRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setPersonName(personname); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_SAVEPERSONNAME, request); <line9> logDebug( <line10> AdminWSConstants.ADMIN_LTD_SAVEPERSONNAME, response.isStatus(), response.getMessage()); <line11> return response.isStatus(); <line12> } catch (Exception e) { <line13> LOG.error(""error during save personname: {}"", e.getLocalizedMessage(), e); <line14> } <line15> return false; <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> private void ignore(String cluster, String jobId, int instanceNumber) throws FalconException { <line1> try { <line2> OozieClientFactory.get(cluster).ignore(jobId, String.valueOf(instanceNumber)); <line3> assertStatus( <line4> cluster, <line5> jobId + ""@"" + instanceNumber, <line6> Status.IGNORED, <line7> Status.FAILED, <line8> Status.SUCCEEDED, <line9> Status.DONEWITHERROR); <line10> LOG.info(""Ignored job {} on cluster {}"", jobId, cluster); <line11> } catch (OozieClientException e) { <line12> throw new FalconException(e); <line13> } <line14> } <line15> } <line16> "	No	task1	
"public class A { <line0> @Test <line1> public void test20AnonDelete() { <line2> LOGGER.info(""  test20AnonDelete""); <line3> Thing thing = THINGS.get(0); <line4> try { <line5> serviceAnon.delete(thing); <line6> Assert.fail(ANON_SHOULD_NOT_BE_ABLE_TO_DELETE); <line7> } catch (ServiceFailureException ex) { <line8> expectStatusCodeException( <line9> ANON_SHOULD_NOT_BE_ABLE_TO_DELETE, <line10> ex, <line11> HTTP_CODE_401_UNAUTHORIZED, <line12> HTTP_CODE_403_FORBIDDEN); <line13> } <line14> EntityUtils.filterAndCheck(serviceRead.things(), """", THINGS); <line15> } <line16> } <line17> "	No	task1	
"public class A { <line0> private static List<String> execute( <line1> final String commandLine, CommandExecutorService executorService) throws IOException { <line2> Command command = new Command(commandLine.split(""\\s+"")); <line3> command.setTimeout(60); <line4> command.setOutputStream(new ByteArrayOutputStream()); <line5> CommandStatus status = executorService.execute(command); <line6> return IOUtils.readLines( <line7> new ByteArrayInputStream( <line8> ((ByteArrayOutputStream) command.getOutputStream()).toByteArray())); <line9> } <line10> } <line11> "	Yes	task1	
"public class A { <line0> @Override <line1> public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { <line2> ByteBuf byteBuf = (ByteBuf) msg; <line3> byte[] msgBytes = new byte[byteBuf.readableBytes()]; <line4> byteBuf.readBytes(msgBytes); <line5> ByteBuffer requestMessage = ByteBuffer.wrap(msgBytes); <line6> byteBuf.release(); <line7> InetSocketAddress clientAddress = (InetSocketAddress) ctx.channel().remoteAddress(); <line8> boolean isTcp = true; <line9> try { <line10> ByteBuffer responseMessage = <line11> myKdcHandler.handleMessage(requestMessage, isTcp, clientAddress.getAddress()); <line12> ctx.writeAndFlush(Unpooled.wrappedBuffer(responseMessage)); <line13> } catch (Exception e) { <line14> LOG.error(""Error occurred while processing request:"" + e); <line15> } <line16> } <line17> } <line18> "	No	task1	
public class A { <line0> public void readDB(MongoDBOutputOperator oper) { <line1> for (Object o : oper.getTableList()) { <line2> String table = (String) o; <line3> DBCursor cursor = oper.db.getCollection(table).find(); <line4> while (cursor.hasNext()) { <line5> } <line6> } <line7> } <line8> } <line9> 	Yes	task1	
"public class A { <line0> private void fillNewColWithTransformedData( <line1> final Context context, Set<SystemSetting> systemSettingsToConvert) <line2> throws JsonProcessingException { <line3> ObjectMapper objectMapper = new ObjectMapper(); <line4> ObjectMapper specialObjectMapper = new ObjectMapper(); <line5> specialObjectMapper.setVisibility( <line6> specialObjectMapper <line7> .getSerializationConfig() <line8> .getDefaultVisibilityChecker() <line9> .withFieldVisibility(Visibility.ANY) <line10> .withGetterVisibility(Visibility.NONE) <line11> .withSetterVisibility(Visibility.NONE) <line12> .withCreatorVisibility(Visibility.NONE)); <line13> try (PreparedStatement ps = <line14> context <line15> .getConnection() <line16> .prepareStatement( <line17> ""UPDATE systemsetting SET value_text = ? WHERE systemsettingid = ?"")) { <line18> for (SystemSetting systemSetting : systemSettingsToConvert) { <line19> if (systemSetting.getName().equals(SMS_CONFIGURATION_SETTING_NAME)) { <line20> ps.setString(1, specialObjectMapper.writeValueAsString(systemSetting.getValue())); <line21> } else { <line22> ps.setString(1, objectMapper.writeValueAsString(systemSetting.getValue())); <line23> } <line24> ps.setLong(2, systemSetting.getId()); <line25> ps.execute(); <line26> } <line27> } catch (SQLException e) { <line28> throw new FlywayException(e); <line29> } <line30> } <line31> } <line32> "	Yes	task1	
"public class A { <line0> public synchronized void shutdown() { <line1> this.stopping = true; <line2> this.canceler.cancel(String.format(NAME_FORMAT, volume) + "" is shutting down""); <line3> this.interrupt(); <line4> try { <line5> this.join(); <line6> } catch (InterruptedException ex) { <line7> LOG.warn(""Unexpected exception while stopping data scanner for volume "" + volume, ex); <line8> Thread.currentThread().interrupt(); <line9> } <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> public static AssertionError assertAssertionError(Block block) throws Exception { <line1> AssertionError answer = null; <line2> try { <line3> block.invoke(); <line4> } catch (AssertionError e) { <line5> answer = e; <line6> System.out.println(""Caught expected assertion failure: "" + e); <line7> } catch (Exception e) { <line8> throw e; <line9> } <line10> if (answer == null) { <line11> throw new AssertionError(""Expected an assertion error from block: "" + block); <line12> } <line13> Asserts.LOG.info(""Caught expected assertion failure: "" + answer); <line14> return answer; <line15> } <line16> } <line17> "	No	task1	
public class A { <line0> public static String search(long groupId, String name, int start, int end) <line1> throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.json.JSONArray returnValue = <line4> AssetTagServiceUtil.search(groupId, name, start, end); <line5> return returnValue.toString(); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	Yes	task1	
"public class A { <line0> @Override <line1> protected void stopBackgroundDiscovery() { <line2> if (usbSerialDiscovery != null) { <line3> usbSerialDiscovery.stopBackgroundScanning(); <line4> } else { <line5> logger.info( <line6> ""Could not stop background discovery, as there is no USB-Serial discovery service"" <line7> + "" configured.""); <line8> } <line9> } <line10> } <line11> "	Yes	task1	
"public class A { <line0> private Action toAction() { <line1> try { <line2> return new ActionImpl(getId(), title, description, new URL(constructUrl())); <line3> } catch (MalformedURLException e) { <line4> LOGGER.debug(""Unable to parse the action url: url={}"", url, e); <line5> return null; <line6> } <line7> } <line8> } <line9> "	No	task1	
public class A { <line0> public void doPushNotificationAnswerEvent( <line1> ServerShSession arg0, PushNotificationRequest arg1, PushNotificationAnswer arg2) <line2> throws InternalException, IllegalDiameterStateException, RouteException, OverloadException { <line3> if (log.isEnabledFor(Level.DEBUG)) { <line4> super.dumpMessage(arg1.getMessage(), false); <line5> } <line6> } <line7> } <line8> 	Yes	task1	
public class A { <line0> @Override <line1> public boolean canImport(TransferHandler.TransferSupport info) { <line2> if (info.isDataFlavorSupported(TypeKeyEntry.ourDataFlavor)) { <line3> Transferable t = info.getTransferable(); <line4> TypeKeyEntry data = null; <line5> try { <line6> data = (TypeKeyEntry) t.getTransferData(TypeKeyEntry.ourDataFlavor); <line7> JList.DropLocation dl = (JList.DropLocation) info.getDropLocation(); <line8> DefaultListModel<MappedTypeKeyPanelProxy> listModel = <line9> (DefaultListModel<MappedTypeKeyPanelProxy>) myDestKeyList.getModel(); <line10> int index = dl.getIndex(); <line11> if (index != -1) { <line12> Object obj = listModel.getElementAt(index); <line13> if (obj instanceof MappedTypeKeyPanelProxy) { <line14> MappedTypeKeyPanelProxy pp = (MappedTypeKeyPanelProxy) obj; <line15> return pp.getPanel().allowsTypeKeyEntry(data, null); <line16> } <line17> } <line18> } catch (UnsupportedFlavorException | IOException e) { <line19> LOGGER.warn(e); <line20> } <line21> } <line22> return false; <line23> } <line24> } <line25> 	No	task1	
"public class A { <line0> @Test <line1> public void testInvokingSimpleServerWithParams() throws Exception { <line2> Exchange exchange = sendSimpleMessage(); <line3> org.apache.camel.Message out = exchange.getMessage(); <line4> String result = out.getBody(String.class); <line5> LOG.info(""Received output text: "" + result); <line6> Map<String, Object> responseContext = <line7> CastUtils.cast((Map<?, ?>) out.getHeader(Client.RESPONSE_CONTEXT)); <line8> assertNotNull(responseContext); <line9> assertEquals( <line10> ""UTF-8"", <line11> responseContext.get(org.apache.cxf.message.Message.ENCODING), <line12> ""We should get the response context here""); <line13> assertEquals(""echo "" + TEST_MESSAGE, result, ""reply body on Camel""); <line14> String fileName = out.getHeader(Exchange.FILE_NAME, String.class); <line15> assertEquals(""testFile"", fileName, ""Should get the file name from out message header""); <line16> Object requestObject = out.getHeader(""requestObject""); <line17> assertTrue( <line18> requestObject instanceof DefaultCxfBinding, ""We should get the right requestObject.""); <line19> } <line20> } <line21> "	No	task1	
"public class A { <line0> @Override <line1> public String getData(Gson gson) { <line2> StringBuilder sb = new StringBuilder(); <line3> for (BulkableAction action : bulkableActions) { <line4> Map<String, Map<String, String>> opMap = new LinkedHashMap<String, Map<String, String>>(1); <line5> Map<String, String> opDetails = new LinkedHashMap<String, String>(3); <line6> if (StringUtils.isNotBlank(action.getId())) { <line7> opDetails.put(""_id"", action.getId()); <line8> } <line9> if (StringUtils.isNotBlank(action.getIndex())) { <line10> opDetails.put(""_index"", action.getIndex()); <line11> } <line12> if (StringUtils.isNotBlank(action.getType())) { <line13> opDetails.put(""_type"", action.getType()); <line14> } <line15> for (String parameter : Parameters.ACCEPTED_IN_BULK) { <line16> try { <line17> Collection<Object> values = action.getParameter(parameter); <line18> if (values != null) { <line19> if (values.size() == 1) { <line20> opDetails.put(parameter, values.iterator().next().toString()); <line21> } else if (values.size() > 1) { <line22> throw new IllegalArgumentException( <line23> ""Expecting a single value for '"" <line24> + parameter <line25> + ""' parameter, you provided: "" <line26> + values.size()); <line27> } <line28> } <line29> } catch (NullPointerException e) { <line30> log.debug(""Could not retrieve '"" + parameter + ""' parameter from action."", e); <line31> } <line32> } <line33> opMap.put(action.getBulkMethodName(), opDetails); <line34> sb.append(gson.toJson(opMap, new TypeToken<Map<String, Map<String, String>>>() {}.getType())); <line35> sb.append(""\n""); <line36> Object source = action.getData(gson); <line37> if (source != null) { <line38> sb.append(getJson(gson, source)); <line39> sb.append(""\n""); <line40> } <line41> } <line42> return sb.toString(); <line43> } <line44> } <line45> "	No	task1	
"public class A { <line0> @Override <line1> public void writeTargetValue(AtlasInternalSession session) throws AtlasException { <line2> LOG.debug(""processTargetFieldMapping method""); <line3> } <line4> } <line5> "	No	task1	
public class A { <line0> public Long addPrivateMessageFolder(String folderName, Long userId) { <line1> try { <line2> PrivateMessageFolder privateMessageFolder = new PrivateMessageFolder(); <line3> privateMessageFolder.setFolderName(folderName); <line4> privateMessageFolder.setUserId(userId); <line5> privateMessageFolder.setInserted(new Date()); <line6> privateMessageFolder = em.merge(privateMessageFolder); <line7> return privateMessageFolder.getId(); <line8> } catch (Exception e) { <line9> } <line10> return null; <line11> } <line12> } <line13> 	Yes	task1	
public class A { <line0> public List<List<Values>> batchRetrieve(List<TridentTuple> tridentTuples) { <line1> List<List<Values>> batchRetrieveResult = Lists.newArrayList(); <line2> try { <line3> for (TridentTuple tuple : tridentTuples) { <line4> List<Column> columns = options.jdbcLookupMapper.getColumns(tuple); <line5> List<List<Column>> rows = jdbcClient.select(options.selectQuery, columns); <line6> for (List<Column> row : rows) { <line7> List<Values> values = options.jdbcLookupMapper.toTuple(tuple, row); <line8> batchRetrieveResult.add(values); <line9> } <line10> } <line11> } catch (Exception e) { <line12> throw new FailedException(e); <line13> } <line14> return batchRetrieveResult; <line15> } <line16> } <line17> 	Yes	task1	
"public class A { <line0> void addRow(List<WebElement> tableRows, String title, WebElement dialog) { <line1> for (WebElement tableRow : tableRows) { <line2> if (Browser.getCellDataByRow(tableRow, 0).equals(title)) { <line3> clickLinkOfTableRow(tableRow); <line4> try { <line5> Thread.sleep(3 * 1000); <line6> } catch (InterruptedException e) { <line7> Logger logger = LogManager.getLogger(EditPage.class); <line8> } <line9> Browser.closeDialog(dialog); <line10> return; <line11> } <line12> } <line13> throw new NoSuchElementException(""No row for given value found: "" + title); <line14> } <line15> } <line16> "	Yes	task1	
public class A { <line0> protected EntitySpec<BrooklynNode> newBrooklynNodeSpecForTest() { <line1> return EntitySpec.create(BrooklynNode.class) <line2> .configure(BrooklynNode.WEB_CONSOLE_BIND_ADDRESS, Networking.ANY_NIC) <line3> .configure(BrooklynNode.ON_EXISTING_PROPERTIES_FILE, ExistingFileBehaviour.DO_NOT_USE); <line4> } <line5> } <line6> 	Yes	task1	
public class A { <line0> public void init(ServletContext context) { <line1> } <line2> } <line3> 	Yes	task1	
"public class A { <line0> private AttributeImpl overrideAttributeValue( <line1> AttributeDescriptor attributeDescriptor, Set<String> overrideValue) { <line2> List<Serializable> newValue = new ArrayList<>(); <line3> for (String override : overrideValue) { <line4> try { <line5> switch (attributeDescriptor.getType().getAttributeFormat()) { <line6> case INTEGER: <line7> newValue.add(Integer.parseInt(override)); <line8> break; <line9> case FLOAT: <line10> newValue.add(Float.parseFloat(override)); <line11> break; <line12> case DOUBLE: <line13> newValue.add(Double.parseDouble(override)); <line14> break; <line15> case SHORT: <line16> newValue.add(Short.parseShort(override)); <line17> break; <line18> case LONG: <line19> newValue.add(Long.parseLong(override)); <line20> break; <line21> case DATE: <line22> Calendar calendar = DatatypeConverter.parseDateTime(override); <line23> newValue.add(calendar.getTime()); <line24> break; <line25> case BOOLEAN: <line26> newValue.add(Boolean.parseBoolean(override)); <line27> break; <line28> case BINARY: <line29> newValue.add(override.getBytes(Charset.forName(""UTF-8""))); <line30> break; <line31> case OBJECT: <line32> case STRING: <line33> case GEOMETRY: <line34> case XML: <line35> newValue.add(override); <line36> break; <line37> } <line38> } catch (IllegalArgumentException e) { <line39> LOGGER.debug( <line40> ""IllegalArgument value [{}] for attribute type [{}] found when performing overrides for"" <line41> + "" [{}]"", <line42> override, <line43> attributeDescriptor.getType().getAttributeFormat(), <line44> attributeDescriptor.getName()); <line45> } <line46> } <line47> return new AttributeImpl(attributeDescriptor.getName(), newValue); <line48> } <line49> } <line50> "	Yes	task1	
"public class A { <line0> @Override <line1> public Map<Date, List<WeblogEntryWrapper>> getEntries() { <line2> Date date = parseDate(dateString); <line3> Calendar cal = Calendar.getInstance(weblog.getTimeZoneInstance()); <line4> Date startDate; <line5> Date endDate = date; <line6> startDate = DateUtil.getStartOfDay(endDate, cal); <line7> endDate = DateUtil.getEndOfDay(endDate, cal); <line8> if (entries == null) { <line9> entries = new TreeMap<>(Collections.reverseOrder()); <line10> try { <line11> WeblogEntrySearchCriteria wesc = new WeblogEntrySearchCriteria(); <line12> wesc.setWeblog(weblog); <line13> wesc.setStartDate(startDate); <line14> wesc.setEndDate(endDate); <line15> wesc.setCatName(catName); <line16> wesc.setTags(tags); <line17> wesc.setStatus(WeblogEntry.PubStatus.PUBLISHED); <line18> wesc.setLocale(locale); <line19> wesc.setOffset(offset); <line20> wesc.setMaxResults(length + 1); <line21> Map<Date, List<WeblogEntry>> mmap = <line22> WebloggerFactory.getWeblogger().getWeblogEntryManager().getWeblogEntryObjectMap(wesc); <line23> int count = 0; <line24> for (Map.Entry<Date, List<WeblogEntry>> entry : mmap.entrySet()) { <line25> List<WeblogEntryWrapper> wrapped = new ArrayList<>(); <line26> List<WeblogEntry> unwrapped = entry.getValue(); <line27> for (int i = 0; i < unwrapped.size(); i++) { <line28> if (count++ < length) { <line29> wrapped.add(i, WeblogEntryWrapper.wrap(unwrapped.get(i), urlStrategy)); <line30> } else { <line31> more = true; <line32> } <line33> } <line34> if (!wrapped.isEmpty()) { <line35> entries.put(entry.getKey(), wrapped); <line36> } <line37> } <line38> } catch (Exception e) { <line39> log.error(""ERROR: getting entry month map"", e); <line40> } <line41> } <line42> return entries; <line43> } <line44> } <line45> "	No	task1	
"public class A { <line0> private UsernamePasswordCredentials tryGetCredentialsEncodedInUsername( <line1> final String username, final JsonObject clientContext) { <line2> try { <line3> final String decoded = new String(Base64.getDecoder().decode(username)); <line4> final int colonIdx = decoded.indexOf("":""); <line5> if (colonIdx > -1) { <line6> final String user = decoded.substring(0, colonIdx); <line7> final String pass = decoded.substring(colonIdx + 1); <line8> return UsernamePasswordCredentials.create(user, pass, clientContext); <line9> } else { <line10> return null; <line11> } <line12> } catch (final IllegalArgumentException ex) { <line13> return null; <line14> } <line15> } <line16> } <line17> "	Yes	task1	
"public class A { <line0> @Override <line1> public void replacement(Align align, List<AnnotationBo> annotationBoList) { <line2> AnnotationBo collectionInfo = <line3> findAnnotation(annotationBoList, MongoConstants.MONGO_COLLECTION_INFO.getCode()); <line4> AnnotationBo collectionOption = <line5> findAnnotation(annotationBoList, MongoConstants.MONGO_COLLECTION_OPTION.getCode()); <line6> if (collectionInfo != null) { <line7> StringBuilder stringBuilder = new StringBuilder(); <line8> stringBuilder <line9> .append(align.getDestinationId()) <line10> .append(""."") <line11> .append((String) collectionInfo.getValue()); <line12> if (collectionOption != null) { <line13> stringBuilder.append("" with "").append(((String) collectionOption.getValue()).toUpperCase()); <line14> } <line15> collectionInfo.setValue(stringBuilder); <line16> } <line17> AnnotationBo jsonAnnotation = <line18> findAnnotation(annotationBoList, MongoConstants.MONGO_JSON_DATA.getCode()); <line19> if (jsonAnnotation == null) { <line20> return; <line21> } <line22> final StringStringValue jsonValue = (StringStringValue) jsonAnnotation.getValue(); <line23> final String json = jsonValue.getStringValue1(); <line24> final String jsonbindValue = jsonValue.getStringValue2(); <line25> if (StringUtils.isEmpty(json)) { <line26> } else { <line27> AnnotationBo jsonMeta = new AnnotationBo(MongoConstants.MONGO_JSON.getCode(), json); <line28> annotationBoList.add(jsonMeta); <line29> } <line30> if (StringUtils.isNotEmpty(jsonbindValue)) { <line31> AnnotationBo bindValueAnnotation = <line32> new AnnotationBo(MongoConstants.MONGO_JSON_BINDVALUE.getCode(), jsonbindValue); <line33> annotationBoList.add(bindValueAnnotation); <line34> } <line35> } <line36> } <line37> "	Yes	task1	
"public class A { <line0> public List<ZookeeperRecord> zookeeperInfoList() { <line1> String zookeeperServers = getZookeeperQuorum().replaceAll(""[\\t\\n\\x0B\\f\\r]"", """"); <line2> try { <line3> return zookeeperInfoList(zookeeperServers); <line4> } catch (Exception e) { <line5> LOG.error(e.getMessage(), e); <line6> } <line7> return null; <line8> } <line9> } <line10> "	No	task1	
public class A { <line0> private void registerInterestKeys( <line1> Map regionKeys, <line2> boolean allKey, <line3> LocalRegion region, <line4> CacheClientNotifier ccn, <line5> CacheClientProxy proxy, <line6> boolean isDurable, <line7> boolean updatesAsInvalidates, <line8> int interestType, <line9> Set<String> regionsWithInterest) <line10> throws IOException { <line11> final boolean isDebugEnabled = logger.isDebugEnabled(); <line12> if (regionKeys != null) { <line13> Iterator iter = regionKeys.entrySet().iterator(); <line14> while (iter.hasNext()) { <line15> Map.Entry e = (Map.Entry) iter.next(); <line16> String regionName = (String) e.getKey(); <line17> if (region.getCache().getRegion(regionName) == null) { <line18> if (isDebugEnabled) { <line19> } <line20> } else { <line21> boolean manageEmptyRegions = false; <line22> if (this.emptyRegionMap != null) { <line23> manageEmptyRegions = this.emptyRegionMap.containsKey(regionName); <line24> } <line25> regionsWithInterest.add(regionName); <line26> if (allKey) { <line27> ccn.registerClientInterest( <line28> regionName, <line29> e.getValue(), <line30> proxy.getProxyID(), <line31> interestType, <line32> isDurable, <line33> updatesAsInvalidates, <line34> manageEmptyRegions, <line35> 0, <line36> false); <line37> } else if (InterestType.REGULAR_EXPRESSION == interestType) { <line38> for (Iterator i = ((Set) e.getValue()).iterator(); i.hasNext(); ) { <line39> ccn.registerClientInterest( <line40> regionName, <line41> (String) i.next(), <line42> proxy.getProxyID(), <line43> interestType, <line44> isDurable, <line45> updatesAsInvalidates, <line46> manageEmptyRegions, <line47> 0, <line48> false); <line49> } <line50> } else { <line51> ccn.registerClientInterest( <line52> regionName, <line53> new ArrayList((Set) e.getValue()), <line54> proxy.getProxyID(), <line55> isDurable, <line56> updatesAsInvalidates, <line57> manageEmptyRegions, <line58> interestType, <line59> false); <line60> } <line61> } <line62> } <line63> } <line64> } <line65> } <line66> 	Yes	task1	
"public class A { <line0> private Properties fetchProperties(String filename) { <line1> Properties properties = new Properties(); <line2> InputStream input = null; <line3> try { <line4> input = getClass().getClassLoader().getResourceAsStream(filename); <line5> if (input == null) { <line6> logger.error(""Sorry, unable to find "" + filename); <line7> throw new FileNotFoundException(""Unable to find/open file: "" + filename); <line8> } <line9> properties.load(input); <line10> } catch (IOException ex) { <line11> ex.printStackTrace(); <line12> } finally { <line13> if (input != null) { <line14> try { <line15> input.close(); <line16> } catch (IOException e) { <line17> e.printStackTrace(); <line18> } <line19> } <line20> } <line21> return properties; <line22> } <line23> } <line24> "	No	task1	
"public class A { <line0> public void deleteBulkRequest(String id, String routing, String parent) { <line1> logger.trace( <line2> ""deleteBulkRequest - id: {} - index: {} - type: {} - routing: {} - parent: {}"", <line3> id, <line4> index, <line5> type, <line6> routing, <line7> parent); <line8> bulkProcessor.add(deleteRequest(index).type(type).id(id).routing(routing).parent(parent)); <line9> deletedDocuments.incrementAndGet(); <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> @Override <line1> public Pageable<Path> get() throws JobException, InterruptedException { <line2> if (PcapOptions.PRINT_JOB_STATUS.getOrDefault(configuration, Boolean.class, false) <line3> && mrJob != null) { <line4> try { <line5> mrJob.monitorAndPrintJob(); <line6> } catch (IOException e) { <line7> throw new JobException(""Could not monitor job status"", e); <line8> } <line9> } <line10> for (; ; ) { <line11> JobStatus status = getStatus(); <line12> if (status.getState() == State.SUCCEEDED <line13> || status.getState() == State.KILLED <line14> || status.getState() == State.FAILED) { <line15> return getFinalResults(); <line16> } else { <line17> LOG.info( <line18> ""Percent complete: {}, description: {}"", <line19> status.getPercentComplete(), <line20> status.getDescription()); <line21> } <line22> Thread.sleep(completeCheckInterval); <line23> } <line24> } <line25> } <line26> "	No	task1	
"public class A { <line0> @Override <line1> public Response addEntitlement(UriInfo ui, Entitlement entitlement) { <line2> Entitlement createdEntitlement = entitlementDAO.addEntitlement(entitlement); <line3> UriBuilder uriBuilder = UriBuilder.fromUri(ui.getRequestUri()); <line4> uriBuilder.path(""{index}""); <line5> URI location = uriBuilder.build(createdEntitlement.getName()); <line6> LOG.debug(""Entitlement '"" + createdEntitlement.getName() + ""' added""); <line7> return Response.created(location).entity(entitlement).build(); <line8> } <line9> } <line10> "	No	task1	
"public class A { <line0> public Response wrongPortTypeResponse(String portType, String portId) { <line1> TransactionResultEntity entity = new TransactionResultEntity(); <line2> entity.setResponseCode(ResponseCode.ABORT.getCode()); <line3> entity.setMessage(""Port was not found.""); <line4> entity.setFlowFileSent(0); <line5> return Response.status(NOT_FOUND).entity(entity).type(MediaType.APPLICATION_JSON_TYPE).build(); <line6> } <line7> } <line8> "	Yes	task1	
"public class A { <line0> @Override <line1> public AssetTag findByG_N(long groupId, String name) throws NoSuchTagException { <line2> AssetTag assetTag = fetchByG_N(groupId, name); <line3> if (assetTag == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""groupId=""); <line7> sb.append(groupId); <line8> sb.append("", name=""); <line9> sb.append(name); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchTagException(sb.toString()); <line14> } <line15> return assetTag; <line16> } <line17> } <line18> "	Yes	task1	
"public class A { <line0> @Override <line1> public void markBackedUp() throws CloudRuntimeException { <line2> try { <line3> processEvent(Event.OperationNotPerformed); <line4> } catch (NoTransitionException ex) { <line5> throw new CloudRuntimeException( <line6> ""Error marking snapshot backed up: "" + this.snapshot.getId() + "" "" + ex.getMessage()); <line7> } <line8> } <line9> } <line10> "	Yes	task1	
public class A { <line0> private String[] loadCategoryUtilizers() { <line1> String[] beans = null; <line2> try { <line3> beans = <line4> BeanFactoryUtils.beanNamesForTypeIncludingAncestors( <line5> (ListableBeanFactory) this.getBeanFactory(), CategoryUtilizer.class); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(t); <line8> } <line9> return beans; <line10> } <line11> } <line12> 	Yes	task1	
public class A { <line0> @Override <line1> public void debug(String msg, Object... args) { <line2> } <line3> } <line4> 	Yes	task1	
"public class A { <line0> @JDIAction(value = ""Collapse '{name}' panel by index '{0}'"", timeout = 1) <line1> public void collapse(final int indexNumber) { <line2> List<UIElement> expansionIndicator = getExpansionIndicatorLocator(); <line3> List<UIElement> icons = getIconsLocator(); <line4> if (!expansionIndicator.isEmpty() && isExpanded(indexNumber)) { <line5> expansionIndicator.get(indexNumber).click(); <line6> } else if (!icons.isEmpty() && isExpanded(indexNumber)) { <line7> icons.get(indexNumber).click(); <line8> } else { <line9> } <line10> waitFor().collapsed(indexNumber); <line11> } <line12> } <line13> "	Yes	task1	
"public class A { <line0> private String getSiteID(String tkn, String username) { <line1> Map<String, String> cookies = new HashMap<>(); <line2> cookies.put(""vs"", tkn); <line3> try { <line4> JSONObject j = <line5> Http.url(""https://vsco.co/ajxp/"" + tkn + ""/2.0/sites?subdomain="" + username) <line6> .cookies(cookies) <line7> .getJSON(); <line8> return Integer.toString(j.getJSONArray(""sites"").getJSONObject(0).getInt(""id"")); <line9> } catch (IOException e) { <line10> LOGGER.error(""Could not get site id""); <line11> return null; <line12> } <line13> } <line14> } <line15> "	No	task1	
public class A { <line0> public void run() { <line1> try { <line2> delegate.onItemRemoved(item); <line3> } catch (Throwable t) { <line4> Exceptions.propagate(t); <line5> } <line6> } <line7> } <line8> 	Yes	task1	
"public class A { <line0> @Override <line1> public void validate() throws InvalidConfigurationException { <line2> super.validate(); <line3> if (this.alternateSystemKey == null || this.alternateSystemKey.equals("" "")) { <line4> logger.info( <line5> ""Provided systemKey value ["" <line6> + this.alternateSystemKey <line7> + ""] is invalid. Reverting to default empty String.""); <line8> this.alternateSystemKey = """"; <line9> } <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> public void processDump(MwDumpFile dumpFile) { <line1> if (dumpFile == null) { <line2> return; <line3> } <line4> MwDumpFileProcessor dumpFileProcessor; <line5> switch (dumpFile.getDumpContentType()) { <line6> case CURRENT: <line7> case DAILY: <line8> case FULL: <line9> dumpFileProcessor = getRevisionDumpFileProcessor(); <line10> break; <line11> case JSON: <line12> dumpFileProcessor = getJsonDumpFileProcessor(); <line13> break; <line14> case SITES: <line15> default: <line16> logger.error( <line17> ""Dumps of type "" <line18> + dumpFile.getDumpContentType() <line19> + "" cannot be processed as entity-document dumps.""); <line20> return; <line21> } <line22> processDumpFile(dumpFile, dumpFileProcessor); <line23> } <line24> } <line25> "	Yes	task1	
"public class A { <line0> protected ControllerServiceDTO updateStateByIdWithRetries( <line1> @Nonnull final String id, <line2> @Nonnull final String state, <line3> final int retries, <line4> final int timeout, <line5> @Nonnull final TimeUnit timeUnit) { <line6> ControllerServiceDTO controllerService = new ControllerServiceDTO(); <line7> controllerService.setId(id); <line8> controllerService.setState(state); <line9> controllerService = update(controllerService); <line10> for (int count = 0; <line11> isPendingState(controllerService.getState(), state) && count < retries; <line12> ++count) { <line13> log.debug( <line14> ""Waiting for controller service {} to exit pending state {}. Try {} of {}."", <line15> id, <line16> controllerService.getState(), <line17> count + 1, <line18> retries); <line19> Uninterruptibles.sleepUninterruptibly(timeout, timeUnit); <line20> controllerService = <line21> findById(id) <line22> .orElseThrow( <line23> () -> <line24> new NifiComponentNotFoundException( <line25> id, NifiConstants.NIFI_COMPONENT_TYPE.CONTROLLER_SERVICE, null)); <line26> } <line27> if (state.equals(controllerService.getState())) { <line28> return controllerService; <line29> } else { <line30> String msg = id; <line31> try { <line32> final List<BulletinDTO> bulletins = getClient().getBulletins(id); <line33> if (!bulletins.isEmpty()) { <line34> msg = bulletins.get(0).getMessage(); <line35> } <line36> } catch (final ClientErrorException e) { <line37> } <line38> throw new NifiClientRuntimeException( <line39> ""Timeout waiting for controller service to be "" + state + "": "" + msg); <line40> } <line41> } <line42> } <line43> "	Yes	task1	
"public class A { <line0> public UcteNetwork read(BufferedReader reader, Reporter reporter) throws IOException { <line1> Reporter readReporter = reporter.createSubReporter(""UcteReading"", ""Reading UCTE network file""); <line2> long start = System.currentTimeMillis(); <line3> UcteNetwork network = new UcteNetworkImpl(); <line4> UcteRecordParser parser = new UcteRecordParser(reader); <line5> parseRecords(parser, network, readReporter); <line6> network.fix(readReporter); <line7> return network; <line8> } <line9> } <line10> "	Yes	task1	
"public class A { <line0> @Override <line1> public void run() { <line2> ThingUID thingUID = firmwareUpdateHandler.getThing().getUID(); <line3> FirmwareStatusInfo info = getFirmwareStatusInfo(thingUID); <line4> logger.debug( <line5> ""Firmware status {} for thing {} initialized."", info.getFirmwareStatus(), thingUID); <line6> firmwareStatusInfoMap.put(thingUID, info); <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> @Override <line1> public void close() { <line2> for (TcpProxy proxy : proxies) { <line3> try { <line4> proxy.close(); <line5> } catch (InterruptedException e) { <line6> LOG.error(""Unable to close proxy"", e); <line7> } <line8> } <line9> super.close(); <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> public static com.liferay.trash.kernel.model.TrashEntryList getEntries( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> java.lang.String className, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.trash.kernel.model.TrashEntry> <line7> obc) <line8> throws com.liferay.portal.kernel.security.auth.PrincipalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(TrashEntryServiceUtil.class, ""getEntries"", _getEntriesParameterTypes7); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, groupId, className, start, end, obc); <line14> Object returnObj = null; <line15> try { <line16> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line17> } catch (Exception e) { <line18> if (e instanceof com.liferay.portal.kernel.security.auth.PrincipalException) { <line19> throw (com.liferay.portal.kernel.security.auth.PrincipalException) e; <line20> } <line21> throw new com.liferay.portal.kernel.exception.SystemException(e); <line22> } <line23> return (com.liferay.trash.kernel.model.TrashEntryList) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException se) { <line25> throw se; <line26> } <line27> } <line28> } <line29> "	Yes	task1	
"public class A { <line0> private static void logWarnBoxedToPrimitiveType( <line1> Class declaringClass, String methodName, Method bestMatch, EPType[] paramTypes) { <line2> Class[] parametersMethod = bestMatch.getParameterTypes(); <line3> for (int i = 0; i < parametersMethod.length; i++) { <line4> Class paramMethod = parametersMethod[i]; <line5> if (!paramMethod.isPrimitive()) { <line6> continue; <line7> } <line8> EPType paramType = paramTypes[i]; <line9> boolean paramNull = paramType == null || paramType == EPTypeNull.INSTANCE; <line10> if (paramNull <line11> || (!declaringClass.getClass().getName().startsWith(""java"") <line12> && JavaClassHelper.getBoxedType(paramMethod) <line13> == ((EPTypeClass) paramType).getType())) { <line14> String paramTypeStr = paramNull ? ""null"" : ((EPTypeClass) paramType).toSimpleName(); <line15> log.info( <line16> ""Method '"" <line17> + methodName <line18> + ""' in class '"" <line19> + declaringClass.getName() <line20> + ""' expects primitive type '"" <line21> + parametersMethod[i] <line22> + ""' as parameter "" <line23> + i <line24> + "", but receives a nullable (boxed) type "" <line25> + paramTypeStr <line26> + "". This may cause null pointer exception at runtime if the actual value is null,"" <line27> + "" please consider using boxed types for method parameters.""); <line28> return; <line29> } <line30> } <line31> } <line32> } <line33> "	Yes	task1	
"public class A { <line0> @Override <line1> public void removeProperties(Properties properties) { <line2> try { <line3> CompositeConfiguration compositeConfiguration = <line4> _classLoaderAggregateProperties.getBaseConfiguration(); <line5> Field field2 = CompositeConfiguration.class.getDeclaredField(""configList""); <line6> field2.setAccessible(true); <line7> @SuppressWarnings(""unchecked"") <line8> List<Configuration> configurations = (List<Configuration>) field2.get(compositeConfiguration); <line9> Iterator<Configuration> iterator = configurations.iterator(); <line10> while (iterator.hasNext()) { <line11> Configuration configuration = iterator.next(); <line12> if (!(configuration instanceof MapConfiguration)) { <line13> break; <line14> } <line15> MapConfiguration mapConfiguration = (MapConfiguration) configuration; <line16> if (mapConfiguration.getMap() == (Map<?, ?>) properties) { <line17> iterator.remove(); <line18> _classLoaderAggregateProperties.removeConfiguration(configuration); <line19> } <line20> } <line21> _properties = null; <line22> clearCache(); <line23> } catch (Exception exception) { <line24> } <line25> } <line26> } <line27> "	Yes	task1	
"public class A { <line0> @Override <line1> protected void run(AllocatePrimaryStorageMsg msg, Completion completion) { <line2> if (isAllocateSuccess) { <line3> completion.success(); <line4> return; <line5> } <line6> bus.send( <line7> msg, <line8> new CloudBusCallBack(completion) { <line9> @Override <line10> public void run(MessageReply reply) { <line11> if (!reply.isSuccess() && (msgs.indexOf(msg) + 1 < msgs.size())) { <line12> logger.warn( <line13> String.format( <line14> ""Try to allocate failed, allocate primary storage msg: %s"", <line15> JSONObjectUtil.toJsonString(msg))); <line16> completion.success(); <line17> return; <line18> } else if (!reply.isSuccess()) { <line19> completion.fail(reply.getError()); <line20> return; <line21> } <line22> isAllocateSuccess = true; <line23> VolumeSpec volumeSpec = new VolumeSpec(); <line24> AllocatePrimaryStorageReply ar = reply.castReply(); <line25> volumeSpec.setPrimaryStorageInventory(ar.getPrimaryStorageInventory()); <line26> volumeSpec.setSize(ar.getSize()); <line27> volumeSpec.setType( <line28> msg.getImageUuid() != null <line29> ? VolumeType.Root.toString() <line30> : VolumeType.Data.toString()); <line31> spec.getVolumeSpecs().add(volumeSpec); <line32> completion.success(); <line33> } <line34> }); <line35> } <line36> } <line37> "	No	task1	
"public class A { <line0> private void addToProcessQualifiedName( <line1> StringBuilder processQualifiedName, <line2> Collection<? extends Entity> entities, <line3> boolean ignoreHDFSPaths) { <line4> if (entities == null) { <line5> return; <line6> } <line7> List<? extends Entity> sortedEntities = new ArrayList<>(entities); <line8> Collections.sort(sortedEntities, entityComparator); <line9> Set<String> dataSetsProcessed = new HashSet<>(); <line10> Map<String, Table> tableMap = new HashMap<>(); <line11> for (Entity entity : sortedEntities) { <line12> if (ignoreHDFSPaths <line13> && (Entity.Type.DFS_DIR.equals(entity.getType()) <line14> || Entity.Type.LOCAL_DIR.equals(entity.getType()))) { <line15> continue; <line16> } <line17> String qualifiedName = null; <line18> long createTime = 0; <line19> try { <line20> if (entity.getType() == Entity.Type.PARTITION || entity.getType() == Entity.Type.TABLE) { <line21> String tableKey = entity.getTable().getDbName() + ""."" + entity.getTable().getTableName(); <line22> Table table = tableMap.get(tableKey); <line23> if (table == null) { <line24> table = <line25> getHive().getTable(entity.getTable().getDbName(), entity.getTable().getTableName()); <line26> tableMap.put(tableKey, table); <line27> } <line28> if (table != null) { <line29> createTime = getTableCreateTime(table); <line30> qualifiedName = getQualifiedName(table); <line31> } <line32> } else { <line33> qualifiedName = getQualifiedName(entity); <line34> } <line35> } catch (Exception excp) { <line36> LOG.error(""error while computing qualifiedName for process"", excp); <line37> } <line38> if (qualifiedName == null || !dataSetsProcessed.add(qualifiedName)) { <line39> continue; <line40> } <line41> if (entity instanceof WriteEntity) { <line42> WriteEntity writeEntity = (WriteEntity) entity; <line43> if (writeEntity.getWriteType() != null <line44> && HiveOperation.QUERY.equals(context.getHiveOperation())) { <line45> boolean addWriteType = false; <line46> switch (((WriteEntity) entity).getWriteType()) { <line47> case INSERT: <line48> case INSERT_OVERWRITE: <line49> case UPDATE: <line50> case DELETE: <line51> addWriteType = true; <line52> break; <line53> case PATH_WRITE: <line54> addWriteType = !Entity.Type.LOCAL_DIR.equals(entity.getType()); <line55> break; <line56> } <line57> if (addWriteType) { <line58> processQualifiedName <line59> .append(QNAME_SEP_PROCESS) <line60> .append(writeEntity.getWriteType().name()); <line61> } <line62> } <line63> } <line64> processQualifiedName <line65> .append(QNAME_SEP_PROCESS) <line66> .append(qualifiedName.toLowerCase().replaceAll(""/"", """")); <line67> if (createTime != 0) { <line68> processQualifiedName.append(QNAME_SEP_PROCESS).append(createTime); <line69> } <line70> } <line71> } <line72> } <line73> "	No	task1	
public class A { <line0> @Override <line1> public String get(String basePath, String tmpDir) { <line2> if (_isS3) { <line3> return _s3.get(basePath, tmpDir); <line4> } <line5> return _disk.get(basePath, tmpDir); <line6> } <line7> } <line8> 	Yes	task1	
"public class A { <line0> public static long[] getRoleUserIds(HttpPrincipal httpPrincipal, long roleId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey(UserServiceUtil.class, ""getRoleUserIds"", _getRoleUserIdsParameterTypes34); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, roleId); <line6> Object returnObj = null; <line7> try { <line8> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line11> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line12> } <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return (long[]) returnObj; <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	Yes	task1	
"public class A { <line0> private void checkHoldRequest() { <line1> for (String key : this.pullRequestTable.keySet()) { <line2> String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR); <line3> if (2 == kArray.length) { <line4> String topic = kArray[0]; <line5> int queueId = Integer.parseInt(kArray[1]); <line6> final long offset = <line7> this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId); <line8> try { <line9> this.notifyMessageArriving(topic, queueId, offset); <line10> } catch (Throwable e) { <line11> log.error(""check hold request failed. topic={}, queueId={}"", topic, queueId, e); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> "	No	task1	
"public class A { <line0> @ApiOperation(httpMethod = ""POST"", value = ""Autofix plan details"") <line1> @PostMapping(value = ""/v1/autofix/notifications/detail"") <line2> public ResponseEntity<Object> getAutofixProjectionDetail( <line3> @RequestBody(required = true) Request request) { <line4> try { <line5> String assetGroup = request.getAg(); <line6> Map<String, String> filter = request.getFilter(); <line7> if (Strings.isNullOrEmpty(assetGroup)) { <line8> return ResponseUtils.buildFailureResponse(new Exception(Constants.ASSET_MANDATORY)); <line9> } <line10> if (filter.isEmpty()) { <line11> return ResponseUtils.buildFailureResponse(new Exception(Constants.FILTER_MANDATORY)); <line12> } <line13> return ResponseUtils.buildSucessResponse( <line14> cloudService.getAutofixProjectionDetail(assetGroup, filter)); <line15> } catch (Exception e) { <line16> LOGGER.error(""Error in getAutofixProjectionDetail "" + e); <line17> return ResponseUtils.buildFailureResponse(e); <line18> } <line19> } <line20> } <line21> "	No	task1	
"public class A { <line0> @Override <line1> public void run() { <line2> DataNotificationRequest dataNotificationRequest; <line3> while (!Thread.currentThread().isInterrupted()) { <line4> try { <line5> dataNotificationRequest = delayQueue.take(); <line6> boolean isUnRegistered = isUnRegistered(dataNotificationRequest); <line7> if (isUnRegistered) { <line8> continue; <line9> } <line10> boolean isDataArrived = checkConditions(dataNotificationRequest); <line11> if (isDataArrived) { <line12> notifyHandler(dataNotificationRequest, DataEvent.STATUS.AVAILABLE); <line13> } else { <line14> if (dataNotificationRequest.isTimedout()) { <line15> notifyHandler(dataNotificationRequest, DataEvent.STATUS.UNAVAILABLE); <line16> continue; <line17> } <line18> dataNotificationRequest.accessed(); <line19> delayQueue.offer(dataNotificationRequest); <line20> } <line21> } catch (Throwable e) { <line22> LOG.error(""Error in Data Notification Service EventConsumer"", e); <line23> } <line24> } <line25> } <line26> } <line27> "	No	task1	
"public class A { <line0> private void ripNextAlbum() { <line1> isRipping = true; <line2> Utils.setConfigList(""queue"", (Enumeration<Object>) queueListModel.elements()); <line3> if (queueListModel.isEmpty()) { <line4> isRipping = false; <line5> return; <line6> } <line7> String nextAlbum = (String) queueListModel.remove(0); <line8> updateQueue(); <line9> Thread t = ripAlbum(nextAlbum); <line10> if (t == null) { <line11> try { <line12> Thread.sleep(500); <line13> } catch (InterruptedException ie) { <line14> LOGGER.error(Utils.getLocalizedString(""interrupted.while.waiting.to.rip.next.album""), ie); <line15> } <line16> ripNextAlbum(); <line17> } else { <line18> t.start(); <line19> } <line20> } <line21> } <line22> "	No	task1	
"public class A { <line0> @Test <line1> public void testMapProducePointsWithDifferenSizeInScale1() throws Exception { <line2> final FeatureSource<SimpleFeatureType, SimpleFeature> fs = <line3> testDS.getFeatureSource(""BuildingCenters""); <line4> final ReferencedEnvelope env = new ReferencedEnvelope(fs.getBounds(), WGS84); <line5> final WMSMapContent map = new WMSMapContent(); <line6> map.getViewport().setBounds(env); <line7> map.setMapWidth(mapWidth); <line8> map.setMapHeight(mapHeight); <line9> map.setTransparent(false); <line10> Style basicStyle = getTestStyle(""BuildingCenters3.sld""); <line11> map.addLayer(new FeatureLayer(fs, basicStyle)); <line12> EncodeHTMLImageMap result = mapProducer.produceMap(map); <line13> assertTestResult(""BuildingCenters3"", result); <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> private boolean delete(String key) throws AmazonClientException { <line1> assert !F.isEmpty(key); <line2> if (log.isDebugEnabled()) <line3> log.debug(""Removing data from S3 [bucket="" + bucketName + "", key="" + key + ']'); <line4> if (!hasKey(key)) return false; <line5> s3.deleteObject(bucketName, key); <line6> return true; <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> private void showRefAlreadyExistsNotification() { <line1> notificationPaneController.addNotification(""Looks like that branch already exists locally!""); <line2> } <line3> } <line4> "	Yes	task1	
"public class A { <line0> private String calLocalSegmentCacheDir() { <line1> String kylinHome = KylinConfig.getKylinHome(); <line2> String indexPathStr = KylinConfig.getInstanceFromEnv().getStreamingIndexPath(); <line3> String localSegmentCachePath; <line4> File indexPath = new File(indexPathStr); <line5> if (indexPath.isAbsolute()) { <line6> localSegmentCachePath = indexPathStr; <line7> } else { <line8> if (kylinHome != null && !kylinHome.equals("""")) { <line9> File localSegmentFile = new File(kylinHome, indexPathStr); <line10> localSegmentCachePath = localSegmentFile.getAbsolutePath(); <line11> } else { <line12> localSegmentCachePath = indexPathStr; <line13> } <line14> } <line15> logger.info(""Using {} to store local segment cache."", localSegmentCachePath); <line16> return localSegmentCachePath; <line17> } <line18> } <line19> "	No	task1	
"public class A { <line0> @Override <line1> public List<QuotaUsageVO> getQuotaUsage( <line2> Long accountId, <line3> String accountName, <line4> Long domainId, <line5> Integer usageType, <line6> Date startDate, <line7> Date endDate) { <line8> if ((accountId == null) && (accountName != null) && (domainId != null)) { <line9> Account userAccount = null; <line10> Account caller = CallContext.current().getCallingAccount(); <line11> if (_domainDao.isChildDomain(caller.getDomainId(), domainId)) { <line12> Filter filter = new Filter(AccountVO.class, ""id"", Boolean.FALSE, null, null); <line13> List<AccountVO> accounts = _accountDao.listAccounts(accountName, domainId, filter); <line14> if (!accounts.isEmpty()) { <line15> userAccount = accounts.get(0); <line16> } <line17> if (userAccount != null) { <line18> accountId = userAccount.getId(); <line19> } else { <line20> throw new InvalidParameterValueException( <line21> ""Unable to find account "" + accountName + "" in domain "" + domainId); <line22> } <line23> } else { <line24> throw new PermissionDeniedException(""Invalid Domain Id or Account""); <line25> } <line26> } <line27> if (startDate.after(endDate)) { <line28> throw new InvalidParameterValueException( <line29> ""Incorrect Date Range. Start date: "" + startDate + "" is after end date:"" + endDate); <line30> } <line31> if (endDate.after(_respBldr.startOfNextDay())) { <line32> throw new InvalidParameterValueException( <line33> ""Incorrect Date Range. End date:"" + endDate + "" should not be in future. ""); <line34> } <line35> Date adjustedEndDate = computeAdjustedTime(endDate); <line36> Date adjustedStartDate = computeAdjustedTime(startDate); <line37> if (logger.isDebugEnabled()) { <line38> logger.debug( <line39> ""Getting quota records for account: "" <line40> + accountId <line41> + "", domainId: "" <line42> + domainId <line43> + "", between "" <line44> + adjustedStartDate <line45> + "" and "" <line46> + adjustedEndDate); <line47> } <line48> return _quotaUsageDao.findQuotaUsage( <line49> accountId, domainId, usageType, adjustedStartDate, adjustedEndDate); <line50> } <line51> } <line52> "	Yes	task1	
"public class A { <line0> @Override <line1> protected void validate() throws Exception { <line2> super.validate(); <line3> if (retryPolicyProvider == null) { <line4> retryPolicyProvider = new RetryPolicyProviderImpl(); <line5> } <line6> if (remoteRetryProvider == null) { <line7> remoteRetryProvider = <line8> new RemoteRetryProvider() { <line9> @Override <line10> public Set<String> getUrls() { <line11> List<Broker> brokers = clusterManager.getLocalRetryBroker(); <line12> Set<String> urlSet = new HashSet<>(); <line13> for (Broker broker : brokers) { <line14> urlSet.add(broker.getIp() + "":"" + broker.getBackEndPort()); <line15> } <line16> return urlSet; <line17> } <line18> @Override <line19> public TransportClient createTransportClient() { <line20> ClientConfig clientConfig = <line21> TransportConfigSupport.buildClientConfig(propertySupplier, ""retry.remote.client""); <line22> clientConfig.setIoThreadName(""joyqueue-retry-io-eventLoop""); <line23> return new BrokerTransportClientFactory().create(clientConfig); <line24> } <line25> }; <line26> } <line27> } <line28> } <line29> "	Yes	task1	
"public class A { <line0> @ContinuousQuery(name = ""CustomerCQ"", query = ""SELECT * FROM /Customers"") <line1> public void handleEvent(CqEvent event) { <line2> counter.incrementAndGet(); <line3> } <line4> } <line5> "	Yes	task1	
"public class A { <line0> protected void sendChannelCreatedEvent() { <line1> logger.trace(""Channel was created, firing ChannelCreated Event""); <line2> channel.pipeline().fireUserEventTriggered(new ConnectEvent()); <line3> } <line4> } <line5> "	No	task1	
"public class A { <line0> @Test <line1> public void testMergedVocab1() throws Exception { <line2> AbstractCache<VocabWord> cacheSource = new AbstractCache.Builder<VocabWord>().build(); <line3> AbstractCache<VocabWord> cacheTarget = new AbstractCache.Builder<VocabWord>().build(); <line4> File resource = Resources.asFile(""big/raw_sentences.txt""); <line5> BasicLineIterator underlyingIterator = new BasicLineIterator(resource); <line6> SentenceTransformer transformer = <line7> new SentenceTransformer.Builder().iterator(underlyingIterator).tokenizerFactory(t).build(); <line8> AbstractSequenceIterator<VocabWord> sequenceIterator = <line9> new AbstractSequenceIterator.Builder<>(transformer).build(); <line10> VocabConstructor<VocabWord> vocabConstructor = <line11> new VocabConstructor.Builder<VocabWord>() <line12> .addSource(sequenceIterator, 1) <line13> .setTargetVocabCache(cacheSource) <line14> .build(); <line15> vocabConstructor.buildJointVocabulary(false, true); <line16> int sourceSize = cacheSource.numWords(); <line17> VocabConstructor<VocabWord> vocabTransfer = <line18> new VocabConstructor.Builder<VocabWord>() <line19> .addSource(sequenceIterator, 1) <line20> .setTargetVocabCache(cacheTarget) <line21> .build(); <line22> vocabTransfer.buildMergedVocabulary(cacheSource, false); <line23> assertEquals(sourceSize, cacheTarget.numWords()); <line24> } <line25> } <line26> "	Yes	task1	
public class A { <line0> @Override <line1> public void postCreateTable( <line2> ObserverContext<MasterCoprocessorEnvironment> ctx, TableDescriptor desc, RegionInfo[] regions) <line3> throws IOException { <line4> if (this.createTableStartTime > 0) { <line5> long time = System.currentTimeMillis() - this.createTableStartTime; <line6> createTableTimer.updateMillis(time); <line7> } <line8> } <line9> } <line10> 	Yes	task1	
"public class A { <line0> public boolean isUnwrapped() { <line1> try { <line2> return defNode.hasProperty(""unwrapped"") || defNode.hasProperty(PN_LAST_UNWRAPPED); <line3> } catch (RepositoryException e) { <line4> return false; <line5> } <line6> } <line7> } <line8> "	Yes	task1	
"public class A { <line0> public static String getRemoteIpLocalPort(Channel channel) { <line1> String remoteIpLocalPort = ""unknown""; <line2> try { <line3> String remoteIp = ((InetSocketAddress) channel.remoteAddress()).getAddress().getHostAddress(); <line4> int localPort = ((InetSocketAddress) channel.localAddress()).getPort(); <line5> return remoteIp + ""->"" + localPort; <line6> } catch (Exception e) { <line7> logger.warn(""Error parse remote ip and local port from Channel {}"", channel); <line8> } <line9> return remoteIpLocalPort; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> @Override <line1> public Reader read() { <line2> S3Client s3 = S3ClientFactory.getClient(); <line3> try { <line4> GetObjectRequest.Builder builder = <line5> GetObjectRequest.builder().bucket(bucketName).key(s3ObjectSummary.key()); <line6> GetObjectRequest request = builder.build(); <line7> ResponseInputStream o = s3.getObject(request); <line8> return Channels.newReader(Channels.newChannel(o), encoding.name()); <line9> } catch (AwsServiceException e) { <line10> LOG.error(e.getMessage(), e); <line11> throw new FlywayException(""Failed to get object from s3: "" + e.getMessage(), e); <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @RequestMapping(value = EXTRACTOR_TASKS, method = RequestMethod.GET) <line1> public void getTaskQueue(HttpServletRequest request, HttpServletResponse response) <line2> throws Exception { <line3> List<ExecutionMetadata> taskQueue = extractionManager.getTaskQueue(); <line4> ExtractorGetTaskQueueResponse responseData = <line5> ExtractorGetTaskQueueResponse.newInstance(taskQueue); <line6> response.setCharacterEncoding(responseCharset); <line7> response.setContentType(""application/json""); <line8> PrintWriter out = response.getWriter(); <line9> try { <line10> out.println(responseData.asJsonString()); <line11> } finally { <line12> out.close(); <line13> } <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> @ExceptionHandler <line1> public void mapException(IllegalArgumentException exception, HttpServletResponse response) <line2> throws IOException { <line3> log.info(""Exception"", exception); <line4> response.setStatus(HttpServletResponse.SC_CONFLICT); <line5> response.setContentType(ContextUtils.CONTENT_TYPE_TEXT); <line6> response.getWriter().write(exception.getMessage()); <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> @Override <line1> protected void onRender() { <line2> super.onRender(); <line3> RuntimeConfigurationType configurationType = Application.get().getConfigurationType(); <line4> if (configurationType.equals(RuntimeConfigurationType.DEVELOPMENT) <line5> && !Application.get().getMarkupSettings().getStripWicketTags()) { <line6> log.warn( <line7> ""Application is in DEVELOPMENT mode && Wicket tags are not stripped,"" <line8> + "" Firefox 3.0 will not render the OMap."" <line9> + "" Change to DEPLOYMENT mode  || turn on Wicket tags stripping."" <line10> + "" See:"" <line11> + "" http://www.nabble.com/Gmap2-problem-with-Firefox-3.0-to18137475.html.""); <line12> } <line13> } <line14> } <line15> "	Yes	task1	
"public class A { <line0> private void checkHADeployments() { <line1> try { <line2> if (attainedQuorum) { <line3> deployHADeployments(); <line4> } else { <line5> undeployHADeployments(); <line6> } <line7> } catch (Throwable t) { <line8> log.error(""Failed when checking HA deploymentIDs"", t); <line9> } <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> public void run() { <line1> try { <line2> currentInterval = Time.currentElapsedTime() / INTERVAL; <line3> Thread.sleep(INTERVAL * 2); <line4> long min = 99999; <line5> long max = 0; <line6> long total = 0; <line7> int number = 0; <line8> while (true) { <line9> long now = Time.currentElapsedTime(); <line10> long lastInterval = currentInterval; <line11> currentInterval += 1; <line12> long count = remove(lastInterval); <line13> count = count * 1000 / INTERVAL; <line14> if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) { <line15> if (count < min) { <line16> min = count; <line17> } <line18> if (count > max) { <line19> max = count; <line20> } <line21> total += count; <line22> number++; <line23> Calendar calendar = Calendar.getInstance(); <line24> calendar.setTimeInMillis(lastInterval * INTERVAL); <line25> String report = <line26> lastInterval <line27> + "" "" <line28> + calendar.get(Calendar.HOUR_OF_DAY) <line29> + "":"" <line30> + calendar.get(Calendar.MINUTE) <line31> + "":"" <line32> + calendar.get(Calendar.SECOND) <line33> + "" "" <line34> + percentage <line35> + ""% "" <line36> + count <line37> + "" "" <line38> + min <line39> + "" "" <line40> + ((double) total / (double) number) <line41> + "" "" <line42> + max; <line43> if (sf != null) { <line44> sf.println(report); <line45> } <line46> } else { <line47> max = total = 0; <line48> min = 999999999; <line49> number = 0; <line50> } <line51> Thread.sleep(INTERVAL); <line52> } <line53> } catch (Exception e) { <line54> e.printStackTrace(); <line55> } <line56> } <line57> } <line58> "	Yes	task1	
"public class A { <line0> protected boolean isConsumersExceededOnTopic() { <line1> Integer maxConsumers = <line2> getTopicPolicies().map(TopicPolicies::getMaxConsumerPerTopic).orElse(null); <line3> if (maxConsumers == null) { <line4> Policies policies; <line5> try { <line6> policies = <line7> brokerService <line8> .pulsar() <line9> .getConfigurationCache() <line10> .policiesCache() <line11> .getDataIfPresent( <line12> AdminResource.path(POLICIES, TopicName.get(topic).getNamespace())); <line13> if (policies == null) { <line14> policies = new Policies(); <line15> } <line16> } catch (Exception e) { <line17> log.warn( <line18> ""[{}] Failed to get namespace policies that include max number of consumers: {}"", <line19> topic, <line20> e.getMessage()); <line21> policies = new Policies(); <line22> } <line23> maxConsumers = policies.max_consumers_per_topic; <line24> } <line25> final int maxConsumersPerTopic = <line26> maxConsumers != null <line27> ? maxConsumers <line28> : brokerService.pulsar().getConfiguration().getMaxConsumersPerTopic(); <line29> if (maxConsumersPerTopic > 0 && maxConsumersPerTopic <= getNumberOfConsumers()) { <line30> return true; <line31> } <line32> return false; <line33> } <line34> } <line35> "	Yes	task1	
"public class A { <line0> @Override <line1> public void run(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { <line2> if (!log.isDebugEnabled()) { <line3> return; <line4> } <line5> Runtime runtime = Runtime.getRuntime(); <line6> NumberFormat nf = NumberFormat.getInstance(); <line7> String freeMemory = nf.format(runtime.freeMemory()); <line8> String totalMemory = nf.format(runtime.totalMemory()); <line9> String maxMemory = nf.format(runtime.maxMemory()); <line10> log.debug( <line11> StringBundler.concat(""Memory Usage:\t"", freeMemory, ""\t"", totalMemory, ""\t"", maxMemory)); <line12> } <line13> } <line14> "	Yes	task1	
public class A { <line0> @Override <line1> public boolean isShow(PortletRequest portletRequest) { <line2> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line3> PermissionChecker permissionChecker = themeDisplay.getPermissionChecker(); <line4> if (PortalPermissionUtil.contains(permissionChecker, ActionKeys.EXPORT_USER)) { <line5> return true; <line6> } <line7> try { <line8> return PortletPermissionUtil.contains( <line9> permissionChecker, UsersAdminPortletKeys.USERS_ADMIN, ActionKeys.EXPORT_USER); <line10> } catch (PortalException portalException) { <line11> if (log.isDebugEnabled()) { <line12> } <line13> } <line14> return false; <line15> } <line16> } <line17> 	Yes	task1	
public class A { <line0> @Override <line1> public IplImage process(IplImage image) { <line2> if (net == null) { <line3> if (netError == false) { <line4> netError = true; <line5> } <line6> return image; <line7> } <line8> int h = image.height(); <line9> int w = image.width(); <line10> Mat srcMat = grabberConverter.convertToMat(grabberConverter.convert(image)); <line11> Mat inputMat = new Mat(); <line12> resize(srcMat, inputMat, new Size(300, 300)); <line13> Mat blob = <line14> blobFromImage( <line15> inputMat, <line16> 1.0, <line17> new Size(300, 300), <line18> new Scalar(104.0, 177.0, 123.0, 0), <line19> false, <line20> false, <line21> CV_32F); <line22> if (blob == null) { <line23> return image; <line24> } <line25> net.setInput(blob); <line26> Mat output = net.forward(); <line27> Mat ne = new Mat(new Size(output.size(3), output.size(2)), CV_32F, output.ptr(0, 0)); <line28> FloatIndexer srcIndexer = ne.createIndexer(); <line29> bb.clear(); <line30> classifications.clear(); <line31> for (int i = 0; i < output.size(3); i++) { <line32> float confidence = srcIndexer.get(i, 2); <line33> float f1 = srcIndexer.get(i, 3); <line34> float f2 = srcIndexer.get(i, 4); <line35> float f3 = srcIndexer.get(i, 5); <line36> float f4 = srcIndexer.get(i, 6); <line37> if (confidence > threshold) { <line38> float tx = f1 * w; <line39> float ty = f2 * h; <line40> float bx = f3 * w; <line41> float by = f4 * h; <line42> Rectangle rect = new Rectangle(tx, ty, bx - tx, by - ty); <line43> List<Classification> cl = null; <line44> Classification classification = new Classification(FACE_LABEL, confidence, rect); <line45> if (classifications.containsKey(FACE_LABEL)) { <line46> classifications.get(FACE_LABEL).add(classification); <line47> } else { <line48> cl = new ArrayList<>(); <line49> cl.add(classification); <line50> classifications.put(FACE_LABEL, cl); <line51> } <line52> bb.add(rect); <line53> } <line54> } <line55> publishClassification(classifications); <line56> IplImage result = grabberConverter.convert(converterToIpl.convert(srcMat)); <line57> ne.close(); <line58> return result; <line59> } <line60> } <line61> 	Yes	task1	
public class A { <line0> protected boolean validate( <line1> String remoteAddress, String queryString, SessionHolder holder, boolean isPost) <line2> throws IOException, GeneralSecurityException { <line3> if (holder.samlRequest == null || holder.samlRequest.length() == 0) { <line4> return false; <line5> } <line6> if (!this.ignoreIncomingSignatures && !isPost) { <line7> String sig = holder.signature; <line8> if (sig == null || sig.length() == 0) { <line9> return false; <line10> } <line11> byte[] sigValue = RedirectBindingSignatureUtil.getSignatureValueFromSignedURL(queryString); <line12> if (sigValue == null) return false; <line13> PublicKey validatingKey; <line14> try { <line15> validatingKey = keyManager.getValidatingKey(remoteAddress); <line16> } catch (TrustKeyConfigurationException e) { <line17> throw new GeneralSecurityException(e.getCause()); <line18> } catch (TrustKeyProcessingException e) { <line19> throw new GeneralSecurityException(e.getCause()); <line20> } <line21> return RedirectBindingSignatureUtil.validateSignature(queryString, validatingKey, sigValue); <line22> } else { <line23> return true; <line24> } <line25> } <line26> } <line27> 	Yes	task1	
"public class A { <line0> @Override <line1> public void install(File artifact) throws Exception { <line2> logger.info(""Installing Acl {}"", artifact.getAbsolutePath()); <line3> addAcl(artifact); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> public void recordResponse(long startTimestamp, long responseTime) { <line1> if (responseTime > highestTrackableValue) { <line2> log.warn( <line3> ""Response time {} exceeded maximum trackable response time {}"", <line4> responseTime, <line5> highestTrackableValue); <line6> responseTime = highestTrackableValue; <line7> } <line8> long criticalValueAtEnter = recordingPhaser.writerCriticalSectionEnter(); <line9> try { <line10> StatisticsSnapshot active = active(startTimestamp); <line11> active.histogram.recordValue(responseTime); <line12> active.responseCount++; <line13> } finally { <line14> recordingPhaser.writerCriticalSectionExit(criticalValueAtEnter); <line15> } <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> private void processReturnVariables(final NsWriteResponse<RefT> response) { <line1> if (container != null) { <line2> String internalId = null; <line3> if (response.getRef() != null) { <line4> NsRef ref = NsRef.fromNativeRef(response.getRef()); <line5> internalId = ref.getInternalId(); <line6> } <line7> try { <line8> container.setComponentData( <line9> container.getCurrentComponentId(), <line10> NetSuiteOutputDefinition.RETURN_LEGACY_CURRENT_INTERNAL_ID, <line11> (internalId != null ? Integer.parseInt(internalId) : null)); <line12> } catch (NumberFormatException e) { <line13> logger.error(""Couldn't parse internalId as Integer: {}"", internalId); <line14> } <line15> } <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> private void scanForDeviceThings(final EnvoyBridgeHandler envoyHandler, final ThingUID bridgeID) { <line1> final Map<String, @Nullable DeviceDTO> devices = envoyHandler.getDevices(true); <line2> if (devices == null) { <line3> logger.debug(""No device data for Enphase devices in discovery for Envoy {}."", bridgeID); <line4> } else { <line5> for (final Entry<String, @Nullable DeviceDTO> entry : devices.entrySet()) { <line6> final DeviceDTO dto = entry.getValue(); <line7> final EnphaseDeviceType type = dto == null ? null : EnphaseDeviceType.safeValueOf(dto.type); <line8> if (type == EnphaseDeviceType.NSRB) { <line9> discover(bridgeID, entry.getKey(), THING_TYPE_ENPHASE_RELAY, ""Relay ""); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @VisibleForTesting <line1> public void validateDateRange(Credential credentialObj) throws OS3Exception { <line2> LocalDate date = LocalDate.parse(credentialObj.getDate(), DATE_FORMATTER); <line3> LocalDate now = LocalDate.now(); <line4> if (date.isBefore(now.minus(1, DAYS)) || date.isAfter(now.plus(1, DAYS))) { <line5> LOG.error( <line6> ""AWS date not in valid range. Date:{} should not be older "" <line7> + ""than 1 day(i.e yesterday) and greater than 1 day(i.e "" <line8> + ""tomorrow)."", <line9> date); <line10> throw S3ErrorTable.newError(MALFORMED_HEADER, authHeader); <line11> } <line12> } <line13> } <line14> "	Yes	task1	
public class A { <line0> public static com.liferay.commerce.discount.model.CommerceDiscountSoap addCommerceDiscount( <line1> long userId, <line2> String title, <line3> String target, <line4> boolean useCouponCode, <line5> String couponCode, <line6> boolean usePercentage, <line7> java.math.BigDecimal maximumDiscountAmount, <line8> String level, <line9> java.math.BigDecimal level1, <line10> java.math.BigDecimal level2, <line11> java.math.BigDecimal level3, <line12> java.math.BigDecimal level4, <line13> String limitationType, <line14> int limitationTimes, <line15> boolean rulesConjunction, <line16> boolean active, <line17> int displayDateMonth, <line18> int displayDateDay, <line19> int displayDateYear, <line20> int displayDateHour, <line21> int displayDateMinute, <line22> int expirationDateMonth, <line23> int expirationDateDay, <line24> int expirationDateYear, <line25> int expirationDateHour, <line26> int expirationDateMinute, <line27> boolean neverExpire, <line28> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line29> throws RemoteException { <line30> try { <line31> com.liferay.commerce.discount.model.CommerceDiscount returnValue = <line32> CommerceDiscountServiceUtil.addCommerceDiscount( <line33> userId, <line34> title, <line35> target, <line36> useCouponCode, <line37> couponCode, <line38> usePercentage, <line39> maximumDiscountAmount, <line40> level, <line41> level1, <line42> level2, <line43> level3, <line44> level4, <line45> limitationType, <line46> limitationTimes, <line47> rulesConjunction, <line48> active, <line49> displayDateMonth, <line50> displayDateDay, <line51> displayDateYear, <line52> displayDateHour, <line53> displayDateMinute, <line54> expirationDateMonth, <line55> expirationDateDay, <line56> expirationDateYear, <line57> expirationDateHour, <line58> expirationDateMinute, <line59> neverExpire, <line60> serviceContext); <line61> return com.liferay.commerce.discount.model.CommerceDiscountSoap.toSoapModel(returnValue); <line62> } catch (Exception exception) { <line63> log.error(exception, exception); <line64> throw new RemoteException(exception.getMessage()); <line65> } <line66> } <line67> } <line68> 	No	task1	
"public class A { <line0> @Override <line1> public String uploadPictureByUrl(String itemUrl) { <line2> java.io.File dest = null; <line3> BufferedOutputStream out = null; <line4> FileOutputStream os = null; <line5> InputStream inputStream = null; <line6> String newFileName = System.currentTimeMillis() + "".jpg""; <line7> try { <line8> URL url = new URL(itemUrl); <line9> URLConnection con = url.openConnection(); <line10> con.setRequestProperty( <line11> ""User-agent"", <line12> ""	Mozilla/5.0 (Windows NT 6.1; WOW64; rv:33.0) Gecko/20100101 Firefox/33.0""); <line13> con.setConnectTimeout(10000); <line14> con.setReadTimeout(10000); <line15> inputStream = con.getInputStream(); <line16> byte[] bs = new byte[1024]; <line17> int len; <line18> String tempFiles = ""temp/"" + newFileName; <line19> dest = new java.io.File(tempFiles); <line20> if (!dest.getParentFile().exists()) { <line21> dest.getParentFile().mkdirs(); <line22> } <line23> os = new FileOutputStream(dest, true); <line24> while ((len = inputStream.read(bs)) != -1) { <line25> os.write(bs, 0, len); <line26> } <line27> FileInputStream fileInputStream = new FileInputStream(dest); <line28> MultipartFile fileData = <line29> new MockMultipartFile( <line30> dest.getName(), <line31> dest.getName(), <line32> ContentType.APPLICATION_OCTET_STREAM.toString(), <line33> fileInputStream); <line34> out = new BufferedOutputStream(new FileOutputStream(dest)); <line35> out.write(fileData.getBytes()); <line36> out.flush(); <line37> out.close(); <line38> MultipartFile multipartFile = MoGuFileUtil.fileToMultipartFile(dest); <line39> return minioUtil.uploadFile(multipartFile); <line40> } catch (Exception e) { <line41> log.error(e.getMessage()); <line42> throw new InsertException( <line43> ErrorCode.SYSTEM_CONFIG_NOT_EXIST, MessageConf.SYSTEM_CONFIG_NOT_EXIST); <line44> } finally { <line45> if (dest != null && dest.getParentFile().exists()) { <line46> dest.delete(); <line47> } <line48> } <line49> } <line50> } <line51> "	No	task1	
"public class A { <line0> public static Optional<ServiceBinding> singleMatchingByType( <line1> String type, List<ServiceBinding> all) { <line2> List<ServiceBinding> allMatching = matchingByType(type, all); <line3> if (allMatching.isEmpty()) { <line4> return Optional.empty(); <line5> } <line6> ServiceBinding first = allMatching.get(0); <line7> if (allMatching.size() > 1) { <line8> log.warn( <line9> ""More than one ServiceBinding matches type '"" <line10> + type <line11> + ""', but only "" <line12> + first <line13> + "" will be used""); <line14> } <line15> return Optional.of(first); <line16> } <line17> } <line18> "	Yes	task1	
"public class A { <line0> @Override <line1> public void execute(TupleWindow inputWindow) { <line2> List<Tuple> tuplesInWindow = inputWindow.get(); <line3> List<Tuple> newTuples = inputWindow.getNew(); <line4> List<Tuple> expiredTuples = inputWindow.getExpired(); <line5> LOG.debug(""Events in current window: "" + tuplesInWindow.size()); <line6> for (Tuple tuple : newTuples) { <line7> sum += (int) tuple.getValue(0); <line8> } <line9> for (Tuple tuple : expiredTuples) { <line10> sum -= (int) tuple.getValue(0); <line11> } <line12> collector.emit(new Values(sum)); <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> public boolean delete(Object object) throws DirectoryException { <line1> final TypeMapping tm = defaultMappers.get(object.getClass()); <line2> if (null == tm) throw new IllegalArgumentException(""No mapping for class "" + object.getClass()); <line3> final Transaction tx = new Transaction(this); <line4> try { <line5> return tm.delete(object, tx); <line6> } catch (final DirectoryException e) { <line7> tx.rollback(); <line8> throw e; <line9> } catch (final RuntimeException e) { <line10> tx.rollback(); <line11> throw e; <line12> } finally { <line13> if (!tx.isClosed()) tx.commit(); <line14> } <line15> } <line16> } <line17> "	Yes	task1	
public class A { <line0> private static LocalDateTime getEndTimeOf(Path file) { <line1> try { <line2> long lastModifiedMillis = file.toFile().lastModified(); <line3> return Instant.ofEpochMilli(lastModifiedMillis) <line4> .atZone(ZoneId.systemDefault()) <line5> .toLocalDateTime(); <line6> } catch (Exception e) { <line7> return LocalDateTime.MAX; <line8> } <line9> } <line10> } <line11> 	Yes	task1	
"public class A { <line0> private Path getZombiePath(ItemId itemId, ChangeLogBasedHierarchyMgr hmgr) <line1> throws ItemStateException { <line2> try { <line3> return prefixPath(hmgr.getZombiePath(itemId)); <line4> } catch (RepositoryException e) { <line5> String msg = ""Unable to resolve zombie path for item: "" + itemId; <line6> log.error(msg); <line7> throw new ItemStateException(msg, e); <line8> } <line9> } <line10> } <line11> "	No	task1	
"public class A { <line0> @Test <line1> public void test() throws Exception { <line2> failure = false; <line3> shutdown = false; <line4> LinkedList<Ignite> nodes = new LinkedList<>(); <line5> for (int i = 0; i < NODES; i++) nodes.add(Ignition.start(igniteCfg(false, ""server_"" + i))); <line6> nodes.getFirst().cluster().state(ACTIVE); <line7> Ignite client = Ignition.start(igniteCfg(true, ""client"")); <line8> new Thread( <line9> new Runnable() { <line10> @Override <line11> public void run() { <line12> try { <line13> for (int i = 0; i < CYCLES; i++) { <line14> System.err.println(""*** CYCLE "" + i); <line15> client.cluster().disableWal(CACHE_NAME); <line16> Thread.sleep(800); <line17> client.cluster().enableWal(CACHE_NAME); <line18> Thread.sleep(800); <line19> } <line20> } catch (IgniteException ex) { <line21> if (ex.getMessage() <line22> .contains( <line23> ""Operation result is unknown because nodes reported different results"")) { <line24> log.error(""TEST FAILED"", ex); <line25> failure = true; <line26> } <line27> } catch (InterruptedException ex) { <line28> return; <line29> } catch (Exception ex) { <line30> throw new RuntimeException(ex); <line31> } finally { <line32> shutdown = true; <line33> } <line34> } <line35> }) <line36> .start(); <line37> while (!shutdown) { <line38> Thread.sleep(1_000); <line39> Ignite ignite = nodes.removeFirst(); <line40> String consistentId = (String) ignite.cluster().localNode().consistentId(); <line41> ignite.close(); <line42> Thread.sleep(1_000); <line43> nodes.add(startNodeWithMaintenance(consistentId)); <line44> } <line45> assertFalse(failure); <line46> } <line47> } <line48> "	No	task1	
"public class A { <line0> private void setDefaults() { <line1> try { <line2> this.startIndex( <line3> ApplicationProperties.get().getLong(APPLICATION_PROPERTY_MIGRATION_START_INDEX, 0L)) <line4> .numWorkers( <line5> ApplicationProperties.get() <line6> .getInt(APPLICATION_PROPERTY_MIGRATION_NUMER_OF_WORKERS, 4)) <line7> .batchSize( <line8> ApplicationProperties.get().getInt(APPLICATION_PROPERTY_MIGRATION_BATCH_SIZE, 3000)); <line9> } catch (AtlasException ex) { <line10> LOG.error(""setDefaults: failed!"", ex); <line11> } <line12> } <line13> } <line14> "	No	task1	
"public class A { <line0> private void addIdeaInstanceGroups(String code, List<String> groups, Connection conn) { <line1> if (null == groups || groups.isEmpty()) return; <line2> PreparedStatement stat = null; <line3> try { <line4> stat = conn.prepareStatement(ADD_IDEAINSTANCE_GROUP); <line5> Iterator<String> groupIter = groups.iterator(); <line6> while (groupIter.hasNext()) { <line7> String groupName = groupIter.next(); <line8> int i = 1; <line9> stat.setString(i++, code); <line10> stat.setString(i++, groupName); <line11> stat.addBatch(); <line12> stat.clearParameters(); <line13> } <line14> stat.executeBatch(); <line15> } catch (Throwable t) { <line16> throw new RuntimeException(""Error creating ideainstance-group relation for "" + code, t); <line17> } finally { <line18> this.closeDaoResources(null, stat, null); <line19> } <line20> } <line21> } <line22> "	Yes	task1	
public class A { <line0> @Override <line1> public void apply(final Traversal.Admin<?, ?> traversal) { <line2> try { <line3> verify(traversal); <line4> } catch (VerificationException ve) { <line5> if (logWarning) LOGGER.warn(ve.getMessage()); <line6> if (throwException) throw ve; <line7> } <line8> } <line9> } <line10> 	No	task1	
"public class A { <line0> @Test <line1> public void testSpeculativeReadLACOneReplicaDown() throws Exception { <line2> LedgerHandle lh = getLedgerToWrite(5, 5, 3); <line3> int timeout = 400; <line4> BookKeeper bkspec = createClientForReadLAC(timeout); <line5> LedgerHandle l = bkspec.openLedgerNoRecovery(lh.getId(), digestType, passwd); <line6> lh.addEntry(""Data for test"".getBytes()); <line7> CountDownLatch sleepLatch = new CountDownLatch(1); <line8> long entryId = l.getLastAddConfirmed() + 1; <line9> sleepBookie( <line10> lh.getLedgerMetadata() <line11> .getEnsemble(entryId) <line12> .get(lh.distributionSchedule.getWriteSet(entryId).get(0)), <line13> sleepLatch); <line14> try { <line15> LatchCallback readComplete = new LatchCallback(); <line16> l.asyncReadLastConfirmedAndEntry(entryId, 10000, false, readComplete, null); <line17> readComplete.expectTimeout(timeout); <line18> readComplete.expectSuccess(timeout * 2); <line19> LOG.info(""Timeout {} latch1 duration {}"", timeout, readComplete.getDuration()); <line20> assertTrue( <line21> ""should have taken longer than two timeouts, but less than 3"", <line22> readComplete.getDuration() >= timeout && readComplete.getDuration() < timeout * 2); <line23> } finally { <line24> sleepLatch.countDown(); <line25> l.close(); <line26> bkspec.close(); <line27> } <line28> } <line29> } <line30> "	No	task1	
"public class A { <line0> public static XMLCipher getProviderInstance(String transformation, String provider, String canon) <line1> throws XMLEncryptionException { <line2> if (log.isDebugEnabled()) { <line3> } <line4> if (null == provider) { <line5> throw new NullPointerException(""Provider unexpectedly null..""); <line6> } <line7> validateTransformation(transformation); <line8> return new XMLCipher(transformation, provider, canon, null); <line9> } <line10> } <line11> "	Yes	task1	
public class A { <line0> private void reconnect() { <line1> connected.set(false); <line2> if (log.isDebugEnabled()) { <line3> } <line4> Completable.complete() <line5> .delay(config.getWebsocketReconnectInterval().toMillis(), TimeUnit.MILLISECONDS) <line6> .subscribe(this::connect); <line7> } <line8> } <line9> 	Yes	task1	
"public class A { <line0> @Override <line1> public Map<Long, ContentModel> loadContentModels() { <line2> Connection conn = null; <line3> Statement stat = null; <line4> ResultSet res = null; <line5> Map<Long, ContentModel> models = new HashMap<Long, ContentModel>(); <line6> String query = ALL_CONTENTMODEL; <line7> try { <line8> conn = this.getConnection(); <line9> stat = conn.createStatement(); <line10> res = stat.executeQuery(query); <line11> while (res.next()) { <line12> ContentModel contentModel = loadContentModel(res); <line13> Long wrapLongId = new Long(contentModel.getId()); <line14> models.put(wrapLongId, contentModel); <line15> } <line16> } catch (Throwable t) { <line17> throw new RuntimeException(""Error loading content models"", t); <line18> } finally { <line19> closeDaoResources(res, stat, conn); <line20> } <line21> return models; <line22> } <line23> } <line24> "	Yes	task1	
public class A { <line0> public void close() { <line1> closeSocketAndStreams(); <line2> } <line3> } <line4> 	Yes	task1	
public class A { <line0> public static boolean deleteQuietly(File file) { <line1> if (file == null) { <line2> return false; <line3> } <line4> try { <line5> return file.delete(); <line6> } catch (Exception e) { <line7> log.warn(e.getMessage(), e); <line8> return false; <line9> } <line10> } <line11> } <line12> 	No	task1	
"public class A { <line0> public static synchronized void stopLocalZkServer(final boolean deleteDataDir) { <line1> if (_zookeeperServerMain != null) { <line2> try { <line3> _zookeeperServerMain.shutdown(); <line4> _zookeeperServerMain = null; <line5> if (deleteDataDir) { <line6> org.apache.commons.io.FileUtils.deleteDirectory(new File(_zkDataDir)); <line7> } <line8> } catch (Exception e) { <line9> LOGGER.warn(""Caught exception while stopping ZK server"", e); <line10> throw new RuntimeException(e); <line11> } <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @Override <line1> public int updateHmilyTransactionStatus(final Long transId, final Integer status) <line2> throws HmilyRepositoryException { <line3> String path = node.getHmilyTransactionRealPath(transId); <line4> try { <line5> KeyValue keyValue = getKeyValue(path); <line6> if (null == keyValue) { <line7> return HmilyRepository.FAIL_ROWS; <line8> } <line9> HmilyTransaction hmilyTransaction = <line10> hmilySerializer.deSerialize(keyValue.getValue().getBytes(), HmilyTransaction.class); <line11> hmilyTransaction.setStatus(status); <line12> hmilyTransaction.setVersion(hmilyTransaction.getVersion() + 1); <line13> hmilyTransaction.setUpdateTime(new Date()); <line14> client <line15> .getKVClient() <line16> .put( <line17> ByteSequence.from(path, StandardCharsets.UTF_8), <line18> ByteSequence.from(hmilySerializer.serialize(hmilyTransaction))); <line19> return HmilyRepository.ROWS; <line20> } catch (ExecutionException | InterruptedException e) { <line21> log.error(""updateHmilyTransactionStatus occur a exception"", e); <line22> return HmilyRepository.FAIL_ROWS; <line23> } <line24> } <line25> } <line26> "	No	task1	
public class A { <line0> public String getTaskWorkerGroup(TaskInstance taskInstance) { <line1> String workerGroup = taskInstance.getWorkerGroup(); <line2> if (StringUtils.isNotBlank(workerGroup)) { <line3> return workerGroup; <line4> } <line5> int processInstanceId = taskInstance.getProcessInstanceId(); <line6> ProcessInstance processInstance = findProcessInstanceById(processInstanceId); <line7> if (processInstance != null) { <line8> return processInstance.getWorkerGroup(); <line9> } <line10> return Constants.DEFAULT_WORKER_GROUP; <line11> } <line12> } <line13> 	Yes	task1	
"public class A { <line0> void addTlsCert(String mspid, byte[] cert) { <line1> if (IS_TRACE_LEVEL) { <line2> logger.trace( <line3> format( <line4> ""Channel %s service discovery MSPID %s adding TLSCert %s"", <line5> channelName, mspid, toHexString(cert))); <line6> } <line7> tlsCerts.computeIfAbsent(mspid, k -> new LinkedList<>()).add(cert); <line8> } <line9> } <line10> "	Yes	task1	
"public class A { <line0> public static File createTemporaryDirectory() { <line1> final File file = Files.createTempDir(); <line2> Runtime.getRuntime() <line3> .addShutdownHook( <line4> new Thread( <line5> () -> { <line6> try { <line7> FileUtils.deleteDirectory(file); <line8> } catch (IOException e) { <line9> LOG.warn(""Failed to clean up {} : {}"", file.getAbsolutePath(), e.toString()); <line10> } <line11> })); <line12> return file; <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @SuppressWarnings(""serial"") <line1> @Test <line2> public void godlenRecordTestFivePairs() { <line3> String[][] expectResult = new String[][] {{""1"", ""1""}, {""2"", ""2""}, {""4"", ""4""}, {""3"", ""5"", ""3""}}; <line4> String[][] expectFobiddenList = <line5> new String[][] {{""3"", ""4"", ""5""}, {}, {""1"", ""3"", ""5""}, {""1"", ""4""}}; <line6> List<MatchMergeRule> matchRules = generateMatchMergeRuleList(); <line7> Callback callback = new MatchMergeCallback(10, 2); <line8> Map<String, String[]> forbiddenListMap = <line9> new HashMap<String, String[]>() { <line10> { <line11> put(""4"", new String[] {""3"", ""5""}); <line12> put(""1"", new String[] {""3"", ""4"", ""5""}); <line13> } <line14> }; <line15> Iterator<Record> matchMergeInput = generateForbiddenInputRecord(inputData3, forbiddenListMap); <line16> try { <line17> MatchMergeAlgorithm buildDQMFB = buildDQMFB(matchRules, callback); <line18> ((DQMFB) buildDQMFB).setHandleGoldenRecord(true); <line19> List<Record> matchMergeResults = buildDQMFB.execute(matchMergeInput); <line20> validateResult(matchMergeResults, callback, expectResult, expectFobiddenList); <line21> } catch (Exception e) { <line22> log.error(e.getMessage(), e); <line23> } <line24> } <line25> } <line26> "	No	task1	
"public class A { <line0> protected String getResponseMIMEType(HttpResponse method) throws IOException { <line1> Header[] headers = method.getHeaders(""Content-Type""); <line2> for (Header header : headers) { <line3> HeaderElement[] headerElements = header.getElements(); <line4> for (HeaderElement headerEl : headerElements) { <line5> String mimeType = headerEl.getName(); <line6> if (mimeType != null) { <line7> logger.debug(""response MIME type is {}"", mimeType); <line8> return mimeType; <line9> } <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @Test <line1> public void testRandomApis() throws ParseException { <line2> String apis = <line3> ""UNA:+.? '"" <line4> + ""UNB+UNOA:1+SAMPLAIR:NZ+USCS:US+020131:2359+0201312359++CEDIPAX+A+++0'"" <line5> + ""UNG+PAXLST+SAMPLECOMM:NZ+TECS:US+020131:2359+0201312359+NZ+001:000'"" <line6> + ""UNH+0201312359+PAXLST:001:000:NZ+SA812/020131/2300'"" <line7> + ""CTA+IC+:FRED? SAMPLES+1-703-644-5200:TE+1-703-566-8224:FX'"" <line8> + ""TDT++SA812+40+SA'"" <line9> + ""LOC+005+NZAKL:50'"" <line10> + ""DTM+136+020131+1030+M05'"" <line11> + ""LOC+008+USLAX:50'"" <line12> + ""DTM+132+020131+2200+M05'"" <line13> + ""UNS+D'"" <line14> + ""PDT+P/182345345:990909:US+MANGUS:SIMON:P:590429:M+PAX+NZAKL:USLAX'"" <line15> + ""PDT+P/122222345:970902:US+FEFE:THEODORE:C:560704:U+PAX+NZAKL:USLAX'"" <line16> + ""PDT+P/C76543D:920429:GB+BOYLE:ALVIN::521221:U+PAX+NZAKL:USLAX'"" <line17> + ""PDT+P/E54321A:980831:IE+O?'LEARY:KRIS:ANN:331231:F+PAX+NZAKL:USLAX'"" <line18> + ""UNT+000011+0201312359'"" <line19> + ""UNE+1+0201312359'"" <line20> + ""UNZ+1+0201312359'""; <line21> ApisMessageVo vo = parser.parse(apis); <line22> List<FlightVo> flights = vo.getFlights(); <line23> assertEquals(1, flights.size()); <line24> assertEquals(4, vo.getPassengers().size()); <line25> logger.info(vo.toString()); <line26> } <line27> } <line28> "	No	task1	
"public class A { <line0> @Test <line1> public void testAuthedDatasource() throws Exception { <line2> MultiValueMap<String, String> paramsMap = new LinkedMultiValueMap<>(); <line3> paramsMap.add(""userId"", ""2""); <line4> MvcResult mvcResult = <line5> mockMvc <line6> .perform( <line7> get(""/datasources/authed-datasource"") <line8> .header(""sessionId"", sessionId) <line9> .params(paramsMap)) <line10> .andExpect(status().isOk()) <line11> .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8)) <line12> .andReturn(); <line13> Result result = <line14> JSONUtils.parseObject(mvcResult.getResponse().getContentAsString(), Result.class); <line15> Assert.assertEquals(Status.SUCCESS.getCode(), result.getCode().intValue()); <line16> logger.info(mvcResult.getResponse().getContentAsString()); <line17> } <line18> } <line19> "	No	task1	
"public class A { <line0> @Inject(value = StrutsConstants.STRUTS_OVERRIDE_ACCEPTED_PATTERNS, required = false) <line1> protected void setOverrideAcceptedPatterns(String acceptablePatterns) { <line2> LOG.warn( <line3> ""Overriding accepted patterns [{}] with [{}], be aware that this affects all instances and"" <line4> + "" safety of your application!"", <line5> acceptedPatterns, <line6> acceptablePatterns); <line7> acceptedPatterns = new HashSet<>(); <line8> try { <line9> for (String pattern : TextParseUtil.commaDelimitedStringToSet(acceptablePatterns)) { <line10> acceptedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE)); <line11> } <line12> } finally { <line13> acceptedPatterns = Collections.unmodifiableSet(acceptedPatterns); <line14> } <line15> } <line16> } <line17> "	Yes	task1	
"public class A { <line0> public FileReaderSpout withOutputStream(String outputStream) { <line1> if (outputStream == null || outputStream.isEmpty()) { <line2> String errorString = ""Output stream must not be empty""; <line3> LOG.error(errorString); <line4> throw new RuntimeException(errorString); <line5> } <line6> this.outputStream = outputStream; <line7> return this; <line8> } <line9> } <line10> "	No	task1	
"public class A { <line0> public static <T> T instantiateByKey( <line1> final Properties props, final String key, final T defaultValue) { <line2> final String className = findAndSubst(key, props); <line3> if (className == null) { <line4> log.trace(""Could not find value for key {0}"", key); <line5> return defaultValue; <line6> } <line7> return OptionConverter.instantiateByClassName(className.trim(), defaultValue); <line8> } <line9> } <line10> "	No	task1	
"public class A { <line0> private VaultToken extend(String clientToken) { <line1> VaultRenewSelfAuth auth = vaultInternalTokenAuthMethod.renewSelf(clientToken, null).auth; <line2> VaultToken vaultToken = <line3> new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs); <line4> sanityCheck(vaultToken); <line5> log.debug( <line6> ""extended login token: "" <line7> + vaultToken.getConfidentialInfo(getConfig().logConfidentialityLevel)); <line8> return vaultToken; <line9> } <line10> } <line11> "	No	task1	
"public class A { <line0> private boolean hasTemplate(NotificationInstanceWithTemplate instanceWithTemplate) { <line1> if (Objects.isNull(instanceWithTemplate.getProgramNotificationTemplate())) { <line2> log.warn( <line3> ""Cannot process scheduled notification with id: "" <line4> + instanceWithTemplate.getProgramNotificationInstance().getId() <line5> + "" since it has no associated templates""); <line6> return false; <line7> } <line8> return true; <line9> } <line10> } <line11> "	No	task1	
"public class A { <line0> @Override <line1> public boolean batchUpdateServiceSchemaContext( <line2> String serviceId, ModifySchemasRequest modifySchemasRequest) { <line3> try { <line4> HttpResponse response = <line5> httpClient.postHttpRequest( <line6> ""/registry/microservices/"" + serviceId + ""/schemas"", <line7> null, <line8> HttpUtils.serialize(modifySchemasRequest)); <line9> if (response.getStatusCode() == HttpStatus.SC_OK) { <line10> return true; <line11> } else { <line12> throw new OperationException( <line13> ""update service schema fails, statusCode = "" <line14> + response.getStatusCode() <line15> + ""; message = "" <line16> + response.getMessage() <line17> + ""; content = "" <line18> + response.getContent()); <line19> } <line20> } catch (IOException e) { <line21> throw new OperationException(""update service schema fails"", e); <line22> } <line23> } <line24> } <line25> "	Yes	task1	
"public class A { <line0> public void generateXls(OutputStream out) { <line1> long start = System.currentTimeMillis(); <line2> Workbook wb = new XSSFWorkbook(); <line3> CellStyle titleCellStyle = wb.createCellStyle(); <line4> titleCellStyle.setAlignment(HorizontalAlignment.CENTER); <line5> createSheets(wb, titleCellStyle); <line6> try { <line7> wb.write(out); <line8> } catch (IOException e) { <line9> throw new UncheckedIOException(e); <line10> } <line11> LOGGER.info( <line12> ""XLS comparison file {}/{} generated in {} ms"", <line13> network.getVariantManager().getWorkingVariantId(), <line14> otherState, <line15> System.currentTimeMillis() - start); <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> public static <T> String serializeToString(T obj) { <line1> String json = """"; <line2> try { <line3> json = objectMapper.writeValueAsString(obj); <line4> } catch (JsonProcessingException e) { <line5> logger.error(""serializeToString exception!"", e); <line6> } <line7> return json; <line8> } <line9> } <line10> "	No	task1	
"public class A { <line0> private void clusterIt() { <line1> dendrogram = new LinkedPair[numItems - 1]; <line2> logger.debug(""Initial matrix: \n"" + matrixToString()); <line3> for (int m = 0; m < numItems - 1; m++) { <line4> updateIndicesToCheck(m); <line5> LinkedPair pair = getClosestPair(); <line6> merge(pair); <line7> dendrogram[m] = pair; <line8> } <line9> } <line10> } <line11> "	No	task1	
"public class A { <line0> @Override <line1> public void write(Cache.Entry<? extends K, ? extends V> entry) { <line2> init(); <line3> Transaction tx = transaction(); <line4> K key = entry.getKey(); <line5> V val = entry.getValue(); <line6> if (log.isDebugEnabled()) <line7> log.debug(S.toString(""Store put"", ""key"", key, true, ""val"", val, true, ""tx"", tx, false)); <line8> Connection conn = null; <line9> PreparedStatement stmt = null; <line10> try { <line11> conn = connection(tx); <line12> stmt = conn.prepareStatement(updateQry); <line13> stmt.setObject(1, toBytes(val)); <line14> stmt.setObject(2, toBytes(key)); <line15> if (stmt.executeUpdate() == 0) { <line16> stmt.close(); <line17> stmt = conn.prepareStatement(insertQry); <line18> stmt.setObject(1, toBytes(key)); <line19> stmt.setObject(2, toBytes(val)); <line20> stmt.executeUpdate(); <line21> } <line22> } catch (IgniteCheckedException | SQLException e) { <line23> throw new CacheWriterException(""Failed to put object [key="" + key + "", val="" + val + ']', e); <line24> } finally { <line25> end(tx, conn, stmt); <line26> } <line27> } <line28> } <line29> "	No	task1	
"public class A { <line0> public String disable() { <line1> if (getPingTarget() != null) { <line2> try { <line3> AutoPingManager autoPingMgr = WebloggerFactory.getWeblogger().getAutopingManager(); <line4> autoPingMgr.removeAutoPing(getPingTarget(), getActionWeblog()); <line5> WebloggerFactory.getWeblogger().flush(); <line6> } catch (Exception ex) { <line7> addError(""Error disabling auto ping""); <line8> } <line9> } <line10> return execute(); <line11> } <line12> } <line13> "	Yes	task1	
"public class A { <line0> public void testRunStarted(Description description) throws Exception { <line1> logger.debug(""Configuring Spring MockHTTPServletRequest.""); <line2> RequestAttributes ra = new ServletRequestAttributes(new MockHttpServletRequest()); <line3> RequestContextHolder.setRequestAttributes(ra); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> @Override <line1> public void handleTestExecutionException(ExtensionContext context, Throwable throwable) <line2> throws Throwable { <line3> LOG.warn(""Error in {}"", context.getUniqueId(), throwable); <line4> getResource(context).ifPresent(Cluster::markError); <line5> throw throwable; <line6> } <line7> } <line8> "	No	task1	
"public class A { <line0> @Override <line1> public void onMessage(String message) { <line2> int index = messages.length - (int) messageLatch.getCount(); <line3> assertTrue(equals.apply(messages[index], message)); <line4> messageLatch.countDown(); <line5> if (messageLatch.getCount() == 0) { <line6> try { <line7> session.close(); <line8> } catch (IOException e) { <line9> fail(""Unexpected exception "" + e); <line10> } <line11> } <line12> } <line13> } <line14> "	Yes	task1	
"public class A { <line0> @Override <line1> public void afterJobExecuted(final ShardingContexts shardingContexts) { <line2> log.info(""After job executed. {}"", shardingContexts); <line3> } <line4> } <line5> "	No	task1	
"public class A { <line0> public void testDataSource() throws Exception { <line1> PortalContainer container = PortalContainer.getInstance(); <line2> container.getComponentInstanceOfType(InitialContextInitializer.class); <line3> DataSource ds = (DataSource) new InitialContext().lookup(""jdbcexo""); <line4> assertNotNull(ds); <line5> Connection conn = ds.getConnection(); <line6> DatabaseMetaData databaseMD = conn.getMetaData(); <line7> String db = <line8> databaseMD.getDatabaseProductName() <line9> + "" "" <line10> + databaseMD.getDatabaseProductVersion() <line11> + ""."" <line12> + databaseMD.getDatabaseMajorVersion() <line13> + ""."" <line14> + databaseMD.getDatabaseMinorVersion(); <line15> String driver = <line16> databaseMD.getDriverName() <line17> + "" "" <line18> + databaseMD.getDriverVersion() <line19> + ""."" <line20> + databaseMD.getDriverMajorVersion() <line21> + ""."" <line22> + databaseMD.getDriverMinorVersion(); <line23> log.info(""Using database "" + db + "" with driver "" + driver); <line24> conn.close(); <line25> } <line26> } <line27> "	No	task1	
"public class A { <line0> @Override <line1> public void addRegion(Region region) { <line2> final Region previous = regions.put(region.getId(), region); <line3> if (previous != null) { <line4> logger.warn(""Overwriting zone "" + previous + "" with "" + region); <line5> } <line6> } <line7> } <line8> "	No	task1	
public class A { <line0> @Override <line1> public void onClose(int code, String reason) { <line2> execWait.release(); <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> public static void closeStatement(Statement stmt) { <line1> try { <line2> if (stmt != null) stmt.close(); <line3> } catch (Exception e) { <line4> e.printStackTrace(); <line5> logger.warn(""closeStatement(): "" + e); <line6> } <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> private int listIdentifiers(DataStoreGarbageCollector gc) throws DataStoreException { <line1> DataStore ds = ((GarbageCollector) gc).getDataStore(); <line2> Iterator<DataIdentifier> it = ds.getAllIdentifiers(); <line3> int count = 0; <line4> while (it.hasNext()) { <line5> DataIdentifier id = it.next(); <line6> LOG.debug(""  "" + id); <line7> count++; <line8> } <line9> return count; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> public static void removeAclRefFromIface( <line1> @Nonnull InstanceIdentifier<Node> vppIid, @Nonnull InterfaceKey ifaceKey) { <line2> LOG.debug(""Removing access-lists from interface {}"", ifaceKey.getName()); <line3> GbpNetconfTransaction.netconfSyncedDelete( <line4> vppIid, <line5> VppIidFactory.getAclInterfaceRef(VppIidFactory.getInterfaceIID(ifaceKey)), <line6> GbpNetconfTransaction.RETRY_COUNT); <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> @Override <line1> public Object execute() { <line2> try { <line3> storeCommand(); <line4> } catch (PersistenceException pe) { <line5> console.println( <line6> ""Encountered an error when trying to perform the command. Check log for more details.""); <line7> LOGGER.debug(""Error while performing command."", pe); <line8> } <line9> return null; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> private String getClasspath() { <line1> final String androidJar = config.getAnalysisFileConfig().getAndroidPlatformDir(); <line2> final String apkFileLocation = config.getAnalysisFileConfig().getTargetAPKFile(); <line3> final String additionalClasspath = config.getAnalysisFileConfig().getAdditionalClasspath(); <line4> String classpath = <line5> forceAndroidJar ? androidJar : Scene.v().getAndroidJarPath(androidJar, apkFileLocation); <line6> if (additionalClasspath != null && !additionalClasspath.isEmpty()) <line7> classpath += File.pathSeparator + additionalClasspath; <line8> logger.debug(""soot classpath: "" + classpath); <line9> return classpath; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> protected void registerMbean() { <line1> try { <line2> ObjectName objectName = <line3> new ObjectName(CertificateGenerator.class.getName() + "":service=certgenerator""); <line4> MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer(); <line5> tryRegisterMBean(mBeanServer, objectName); <line6> } catch (MalformedObjectNameException e) { <line7> } <line8> } <line9> } <line10> "	Yes	task1	
"public class A { <line0> @Override <line1> public void onConfigUpdate(Properties updatedConfig) { <line2> if (StringHelper.isEmpty( <line3> (String) updatedConfig.get(""resource.messageproducer.messagesizelimit""))) { <line4> return; <line5> } <line6> long msgSizeLimit = <line7> DataConvertHelper.toLong( <line8> updatedConfig.get(""resource.messageproducer.messagesizelimit""), <line9> MessagingContext.DEFAULT_MSG_SIZE_LIMIT); <line10> msgProducer.setMsgSizeLimit(msgSizeLimit); <line11> if (log.isTraceEnable()) { <line12> } <line13> } <line14> } <line15> "	Yes	task1	
"public class A { <line0> private static Map<String, String> createSystemConfig( <line1> SamzaPipelineOptions options, Map<String, String> config) { <line2> final ImmutableMap.Builder<String, String> configBuilder = <line3> ImmutableMap.<String, String>builder() <line4> .put(""stores.beamStore.key.serde"", ""byteArraySerde"") <line5> .put(""stores.beamStore.msg.serde"", ""stateValueSerde"") <line6> .put( <line7> ""serializers.registry.stateValueSerde.class"", <line8> SamzaStoreStateInternals.StateValueSerdeFactory.class.getName()) <line9> .put( <line10> ""serializers.registry.byteArraySerde.class"", <line11> SamzaStoreStateInternals.ByteArraySerdeFactory.class.getName()); <line12> if (!config.containsKey(BEAM_STORE_FACTORY)) { <line13> options.setStateDurable(false); <line14> configBuilder.put( <line15> BEAM_STORE_FACTORY, <line16> ""org.apache.samza.storage.kv.inmemory.InMemoryKeyValueStorageEngineFactory""); <line17> } <line18> switch (options.getSamzaExecutionEnvironment()) { <line19> case YARN: <line20> configBuilder.putAll(yarnRunConfig()); <line21> break; <line22> case STANDALONE: <line23> configBuilder.putAll(standAloneRunConfig()); <line24> break; <line25> default: <line26> configBuilder.putAll(localRunConfig()); <line27> break; <line28> } <line29> configBuilder.put(""samza.li.task.wrapper.enabled"", ""false""); <line30> return configBuilder.build(); <line31> } <line32> } <line33> "	Yes	task1	
"public class A { <line0> public final Source invoke(Source request) { <line1> QName operationQName = (QName) context.getMessageContext().get(MessageContext.WSDL_OPERATION); <line2> LOG.info(""Invoke operation '"" + operationQName + ""'""); <line3> GenericOperation esbProviderCallback = getESBProviderCallback(operationQName.getLocalPart()); <line4> if (esbProviderCallback == null) { <line5> throw new RuntimeException(""Handler for operation "" + operationQName + "" cannot be found""); <line6> } <line7> try { <line8> Document requestDoc = null; <line9> if (request != null) { <line10> ByteArrayOutputStream os = new ByteArrayOutputStream(); <line11> StaxUtils.copy(request, os); <line12> requestDoc = new SAXReader().read(new ByteArrayInputStream(os.toByteArray())); <line13> } else { <line14> requestDoc = DocumentHelper.createDocument(); <line15> requestDoc.addElement(""root"", """"); <line16> } <line17> Object payload; <line18> if (extractHeaders) { <line19> Map<String, Object> esbRequest = new HashMap<String, Object>(); <line20> esbRequest.put( <line21> ESBProviderCallback.HEADERS_SOAP, context.getMessageContext().get(Header.HEADER_LIST)); <line22> esbRequest.put( <line23> ESBProviderCallback.HEADERS_HTTP, <line24> context.getMessageContext().get(MessageContext.HTTP_REQUEST_HEADERS)); <line25> esbRequest.put(ESBProviderCallback.REQUEST, requestDoc); <line26> esbRequest.put( <line27> CorrelationIDFeature.MESSAGE_CORRELATION_ID, <line28> context.getMessageContext().get(CorrelationIDFeature.MESSAGE_CORRELATION_ID)); <line29> payload = esbRequest; <line30> } else { <line31> payload = requestDoc; <line32> } <line33> LOG.fine(""Generic provider invoked with payload: "" + payload); <line34> Object result = <line35> esbProviderCallback.invoke( <line36> payload, isOperationRequestResponse(operationQName.getLocalPart())); <line37> if (result == null) { <line38> return null; <line39> } <line40> LOG.fine(""Generic provider callback returns: "" + result); <line41> if (result instanceof Map<?, ?>) { <line42> Map<String, Object> map = CastUtils.cast((Map<?, ?>) result); <line43> return processResult(map.get(ESBEndpointConstants.REQUEST_PAYLOAD)); <line44> } else { <line45> return processResult(result); <line46> } <line47> } catch (RuntimeException e) { <line48> throw e; <line49> } catch (Exception e) { <line50> throw new RuntimeException(e); <line51> } <line52> } <line53> } <line54> "	No	task1	
"public class A { <line0> public static int getCategoriesCount( <line1> HttpPrincipal httpPrincipal, long classNameId, long classPK) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> AssetCategoryServiceUtil.class, <line6> ""getCategoriesCount"", <line7> _getCategoriesCountParameterTypes7); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, classNameId, classPK); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> log.error(systemException, systemException); <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	No	task1	
"public class A { <line0> @Test <line1> public void testPointsAreAlwaysRenderedAsCircles() throws Exception { <line2> final String s = ""VariousPoints""; <line3> FeatureSource<SimpleFeatureType, SimpleFeature> fs = testDS.getFeatureSource(s); <line4> ReferencedEnvelope env = new ReferencedEnvelope(fs.getBounds(), WGS84); <line5> WMSMapContent map = new WMSMapContent(); <line6> map.getViewport().setBounds(env); <line7> map.setMapWidth(mapWidth); <line8> map.setMapHeight(mapHeight); <line9> map.setTransparent(false); <line10> Style basicStyle = getTestStyle(String.format(""%s.sld"", s)); <line11> map.addLayer(new FeatureLayer(fs, basicStyle)); <line12> EncodeHTMLImageMap result = mapProducer.produceMap(map); <line13> assertTestResult(s, result); <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> @Test <line1> public void createCredentialStoreAsInEAP() throws Exception { <line2> Security.addProvider(new WildFlyElytronProvider()); <line3> new File(""target/my-cstore-1.p12"").delete(); <line4> CredentialStore cs = <line5> CredentialStore.getInstance(KeyStoreCredentialStore.KEY_STORE_CREDENTIAL_STORE); <line6> assertNotNull(cs); <line7> Field spi = cs.getClass().getDeclaredField(""spi""); <line8> spi.setAccessible(true); <line9> LOG.info(""Store: {}, type: {}"", spi.get(cs).getClass().getName(), cs.getType()); <line10> assertFalse(cs.isInitialized()); <line11> Map<String, String> parameters = new HashMap<>(); <line12> parameters.put(""create"", ""true""); <line13> parameters.put(""keyStoreType"", ""PKCS12""); <line14> parameters.put(""location"", ""target/my-cstore-1.p12""); <line15> ClearPassword clearPassword = <line16> ClearPassword.createRaw(ClearPassword.ALGORITHM_CLEAR, ""STORE_PASSWORD"".toCharArray()); <line17> Credential credential = new PasswordCredential(clearPassword); <line18> CredentialSource source = IdentityCredentials.NONE.withCredential(credential); <line19> CredentialStore.ProtectionParameter protectionParameter = <line20> new CredentialStore.CredentialSourceProtectionParameter(source); <line21> cs.initialize(parameters, protectionParameter); <line22> assertTrue(cs.isInitialized()); <line23> assertTrue(new File(""target/my-cstore-1.p12"").isFile()); <line24> cs.store( <line25> ""my-alias"", <line26> new PasswordCredential( <line27> ClearPassword.createRaw(ClearPassword.ALGORITHM_CLEAR, ""passw0rd"".toCharArray()))); <line28> cs.flush(); <line29> } <line30> } <line31> "	No	task1	
"public class A { <line0> @Path(""/getAllShouldSucceed"") <line1> @POST <line2> public void getAllShouldSucceed() { <line3> LOG.debug(""Calling OpenstackKeystoneUserResource.getAllShouldSucceed()""); <line4> String uri = String.format(URI_FORMAT, OpenstackConstants.GET_ALL); <line5> User[] users = template.requestBody(uri, null, User[].class); <line6> assertNotNull(users); <line7> assertEquals(6, users.length); <line8> assertEquals(""glance"", users[0].getName()); <line9> assertEquals(""default"", users[1].getDomainId()); <line10> assertNull(users[2].getEmail()); <line11> assertEquals(""7afec08993c24bb09df141e513738030"", users[3].getId()); <line12> } <line13> } <line14> "	No	task1	
public class A { <line0> private static <T> T handleProxyException(Request request, ProxyException e) { <line1> throw badRequest(BAD_GATEWAY, e.getMessage()); <line2> } <line3> } <line4> 	Yes	task1	
"public class A { <line0> public void setOutputForAppearance(String appearance, int number) { <line1> if (appearanceToOutput.containsKey(appearance)) { <line2> log.debug( <line3> ""Appearance {} is already defined as {}"", appearance, appearanceToOutput.get(appearance)); <line4> appearanceToOutput.remove(appearance); <line5> } <line6> appearanceToOutput.put(appearance, number); <line7> } <line8> } <line9> "	Yes	task1	
"public class A { <line0> @Override <line1> public ConnectionConsumer createConnectionConsumer( <line2> final Queue queue, <line3> final String messageSelector, <line4> final ServerSessionPool sessionPool, <line5> final int maxMessages) <line6> throws JMSException { <line7> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line8> ActiveMQRALogger.LOGGER.trace( <line9> ""createConnectionConsumer("" <line10> + queue <line11> + "", "" <line12> + messageSelector <line13> + "", "" <line14> + sessionPool <line15> + "", "" <line16> + maxMessages <line17> + "")""); <line18> } <line19> throw new IllegalStateException(ISE); <line20> } <line21> } <line22> "	Yes	task1	
public class A { <line0> public static void setGsServerAuthenticator(GsServerAuthenticator authenticator) { <line1> GsSecurityManager.authenticator = Objects.requireNonNull(authenticator); <line2> } <line3> } <line4> 	Yes	task1	
public class A { <line0> @Test <line1> public void testSnapshot() throws Exception { <line2> if (isSupported(IsolationLevels.SNAPSHOT)) { <line3> snapshot(IsolationLevels.SNAPSHOT); <line4> snapshotRead(IsolationLevels.SNAPSHOT); <line5> repeatableRead(IsolationLevels.SNAPSHOT); <line6> readCommitted(IsolationLevels.SNAPSHOT); <line7> rollbackTriple(IsolationLevels.SNAPSHOT); <line8> readPending(IsolationLevels.SNAPSHOT); <line9> } else { <line10> } <line11> } <line12> } <line13> 	Yes	task1	
public class A { <line0> public static URL getAuthorizationURL(final String authorizationURL) { <line1> if (authorizationURL != null) { <line2> try { <line3> return new URL(authorizationURL.toString()); <line4> } catch (final MalformedURLException e) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	Yes	task1	
public class A { <line0> @Override <line1> public void reload() { <line2> try { <line3> if (this.recordWriter != null) { <line4> this.recordWriter.returnConnector(); <line5> } <line6> recordWriter = new AccumuloRecordWriter(this.connectionFactory, conf); <line7> } catch (AccumuloException | AccumuloSecurityException | IOException e) { <line8> log.error(e.getMessage(), e); <line9> } <line10> } <line11> } <line12> 	No	task1	
"public class A { <line0> public void dumpQuery(String query) throws Exception { <line1> ResultSet rs = getConnection().createStatement().executeQuery(query); <line2> rs.next(); <line3> for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) { <line4> LOGGER.info(""{}: {}"", rs.getMetaData().getColumnName(i), rs.getObject(i)); <line5> } <line6> } <line7> } <line8> "	No	task1	
"public class A { <line0> public static <T> T registInvoke(final ClientInfo clientInfo, final TxInvoker<T> invoker) { <line1> clientInfo.setClientInfo(getClientInfoFactory().getClientInfo()); <line2> TxProducer sd = getSender(); <line3> Object[] args = ArgsSerializationUtil.unserialArgs(clientInfo.getArgs()); <line4> LOGGER.info( <line5> ""registClient|{0}|{1}|{2}|{3}|{4}|{5}"", <line6> clientInfo.getId(), <line7> clientInfo.getMark(), <line8> clientInfo.getContext(), <line9> args == null ? GlobalConstants.BLANK : JSONArray.toJSONString(args), <line10> clientInfo.getMaxRetryTimes(), <line11> clientInfo.getRetryConfigs()); <line12> boolean flag = sd.registClient(clientInfo); <line13> T msg = invoker.invoke(); <line14> if (flag) { <line15> sd.removeClient(clientInfo.getId()); <line16> } <line17> return msg; <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> public static short kafkaExceptionFor(Throwable exception) { <line1> Short code = EXCEPTION_TO_CODE_MAPPER.get(exception.getClass()); <line2> if (code == null) { <line3> logger.warn(""unsupported exception mapper, exception: {}"", exception.getClass()); <line4> return UNKNOWN_SERVER_ERROR.getCode(); <line5> } <line6> return code; <line7> } <line8> } <line9> "	No	task1	
public class A { <line0> private void releaseCheckpoint() { <line1> nodeStore.release(indexerInfo.checkpoint); <line2> } <line3> } <line4> 	Yes	task1	
"public class A { <line0> public void error(SAXParseException se) throws SAXException { <line1> addProcessingException(xmlDoc, ""Error parsing xml doc "" + xmlDoc, se); <line2> throw se; <line3> } <line4> } <line5> "	Yes	task1	
"public class A { <line0> @Override <line1> protected Collection<OArtifact> getData() { <line2> if (downloadedModules == null || downloadedModules.isEmpty()) { <line3> try { <line4> downloadedModules = InternalOModuleManager.get().getOrienteerModules(); <line5> } catch (Exception e) { <line6> LOG.error(""It's not possible to download modules file from the internet"", e); <line7> error(e.getMessage()); <line8> } <line9> } <line10> return downloadedModules; <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> @Test <line1> public void testPut() throws Exception { <line2> try { <line3> HBaseTestHelper.startLocalCluster(); <line4> HBaseTestHelper.clearHBase(); <line5> HBaseNameValueCsvPutOperator propPutOperator = new HBaseNameValueCsvPutOperator(); <line6> propPutOperator.getStore().setTableName(""table1""); <line7> propPutOperator.getStore().setZookeeperQuorum(""127.0.0.1""); <line8> propPutOperator.getStore().setZookeeperClientPort(2181); <line9> String s = ""name=milind,st=patrick,ct=fremont,sa=cali""; <line10> String s1 = ""st=tasman,ct=sancla,name=milinda,sa=cali""; <line11> propPutOperator.setMapping(""name=row,st=colfam0.street,ct=colfam0.city,sa=colfam0.state""); <line12> propPutOperator.setup(mockOperatorContext(0)); <line13> propPutOperator.beginWindow(0); <line14> propPutOperator.input.process(s); <line15> propPutOperator.input.process(s1); <line16> propPutOperator.endWindow(); <line17> HBaseTuple tuple; <line18> tuple = HBaseTestHelper.getHBaseTuple(""milind"", ""colfam0"", ""street""); <line19> Assert.assertNotNull(""Tuple"", tuple); <line20> Assert.assertEquals(""Tuple row"", tuple.getRow(), ""milind""); <line21> Assert.assertEquals(""Tuple column family"", tuple.getColFamily(), ""colfam0""); <line22> Assert.assertEquals(""Tuple column name"", tuple.getColName(), ""street""); <line23> Assert.assertEquals(""Tuple column value"", tuple.getColValue(), ""patrick""); <line24> } catch (IOException e) { <line25> } <line26> } <line27> } <line28> "	Yes	task1	
"public class A { <line0> public long addThesis(Thesis thesis) throws StorageException { <line1> try { <line2> simpleJdbcTemplate <line3> .getJdbcOperations() <line4> .update( <line5> ""INSERT INTO thesis (review_id,  thesis_unique_id, content, frequency, positivity,"" <line6> + "" importance) VALUES(?,?,?,?,?,?)"", <line7> new Object[] { <line8> thesis.getReviewId(), <line9> thesis.getThesisUniqueId(), <line10> thesis.getContent(), <line11> thesis.getFrequency(), <line12> thesis.getPositivity(), <line13> thesis.getImportance() <line14> }, <line15> new int[] { <line16> Types.INTEGER, <line17> Types.INTEGER, <line18> Types.VARCHAR, <line19> Types.INTEGER, <line20> Types.DOUBLE, <line21> Types.DOUBLE <line22> }); <line23> long lastId = simpleJdbcTemplate.getJdbcOperations().queryForLong(""SELECT LAST_INSERT_ID()""); <line24> return lastId; <line25> } catch (DataAccessException e) { <line26> throw new StorageException(); <line27> } <line28> } <line29> } <line30> "	Yes	task1	
public class A { <line0> @Override <line1> public int update(DataCenter model) { <line2> try { <line3> return dataCenterNameServerService.update(model); <line4> } catch (Exception e) { <line5> } <line6> return 0; <line7> } <line8> } <line9> 	Yes	task1	
"public class A { <line0> public synchronized void debug() { <line1> if (LOG.isDebugEnabled()) { <line2> LOG.debug(""Registered UpdateListeners:""); <line3> } <line4> listeners.keySet().forEach(UpdateListener::debug); <line5> } <line6> } <line7> "	No	task1	
"public class A { <line0> private InputStream getReportInputStream() { <line1> ReportDownloaderInterface reportDownloader = <line2> AdWordsServicesUtil.getUtility(session, ReportDownloaderInterface.class); <line3> InputStream result = null; <line4> try { <line5> ReportDownloadResponse reportDownloadResponse = <line6> reportDownloader.downloadReport(reportDefinition); <line7> result = reportDownloadResponse.getInputStream(); <line8> } catch (ReportException | ReportDownloadResponseException e) { <line9> logger.error( <line10> ""Failed to download report stream for {} with account {}."", <line11> reportDefinition.getReportType(), <line12> session.getClientCustomerId(), <line13> e); <line14> } <line15> return result; <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> protected void skipPrincipalClass(int lineNr, Class<?> principalClass) { <line1> log.error( <line2> principalClass.getName() <line3> + ""is not a subclass of "" <line4> + Principal.class.getName() <line5> + "", line nr "" <line6> + lineNr); <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> public static String createCnonce() { <line1> LOG.trace(""enter DigestScheme.createCnonce()""); <line2> String cnonce; <line3> final String digAlg = ""MD5""; <line4> MessageDigest md5Helper; <line5> try { <line6> md5Helper = MessageDigest.getInstance(digAlg); <line7> } catch (NoSuchAlgorithmException e) { <line8> throw new HttpClientError(""Unsupported algorithm in HTTP Digest authentication: "" + digAlg); <line9> } <line10> cnonce = Long.toString(System.currentTimeMillis()); <line11> cnonce = encode(md5Helper.digest(EncodingUtil.getAsciiBytes(cnonce))); <line12> return cnonce; <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> private void testInvalidOptionsDoNotWork(String options, String msg) { <line1> String uri = prefix + bindAddress + postfix + options; <line2> LOG.info(""Connecting via: "" + uri); <line3> try { <line4> connection = new ActiveMQConnectionFactory(uri).createConnection(); <line5> connection.start(); <line6> fail( <line7> ""Invalid options '"" <line8> + options <line9> + ""' on URI '"" <line10> + uri <line11> + ""' should"" <line12> + "" have caused an exception to be thrown. "" <line13> + msg); <line14> } catch (Exception expected) { <line15> } <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> @POST <line1> public Response create(@Context UriInfo uriInfo, PushTopicRegistration registration) { <line2> String genId = sessionCounter.getAndIncrement() + ""-topic-"" + destination + ""-"" + startup; <line3> if (registration.getDestination() == null) { <line4> registration.setDestination(genId); <line5> } <line6> registration.setId(genId); <line7> registration.setTopic(destination); <line8> ClientSession createSession = createSubscription(genId, registration.isDurable()); <line9> try { <line10> PushSubscription consumer = <line11> new PushSubscription(sessionFactory, genId, genId, registration, pushStore, jmsOptions); <line12> try { <line13> consumer.start(); <line14> if (registration.isDurable() && pushStore != null) { <line15> pushStore.add(registration); <line16> } <line17> } catch (Exception e) { <line18> consumer.stop(); <line19> throw new WebApplicationException( <line20> e, <line21> Response.serverError().entity(""Failed to start consumer."").type(""text/plain"").build()); <line22> } <line23> consumers.put(genId, consumer); <line24> UriBuilder location = uriInfo.getAbsolutePathBuilder(); <line25> location.path(genId); <line26> return Response.created(location.build()).build(); <line27> } finally { <line28> closeSession(createSession); <line29> } <line30> } <line31> } <line32> "	Yes	task1	
"public class A { <line0> private BigDecimal getContraReceipt( <line1> final Long bankaccountId, final Date asPerDate, final Long accountGlcodeId) { <line2> final StringBuffer qry = new StringBuffer(100); <line3> if (accountGlcodeId != null) <line4> qry.append( <line5> "" select case when SUM(case when gl.debitamount = NULL then 0 else gl.debitamount end) ="" <line6> + "" null then 0 else SUM(case when gl.debitamount = NULL then 0 else gl.debitamount"" <line7> + "" end) end as receipt from  voucherheader vh, generalledger gl where"" <line8> + "" vh.id=gl.voucherheaderid and gl.glcodeId="" <line9> + accountGlcodeId <line10> + ""  and vh.name in ('"" <line11> + FinancialConstants.CONTRAVOUCHER_NAME_BTOB <line12> + ""','"" <line13> + FinancialConstants.CONTRAVOUCHER_NAME_INTERFUND <line14> + ""')   and vh.fiscalperiodid in (select id from fiscalperiod where"" <line15> + "" financialyearid=(select f.id from financialyear f where CURRENT_DATE between"" <line16> + "" f.startingdate and f.endingdate)) and vh.voucherdate='"" <line17> + sqlformat.format(asPerDate) <line18> + ""'  and vh.status =0""); <line19> else <line20> qry.append( <line21> "" select case when SUM(case when gl.debitamount = NULL then 0 else gl.debitamount end) ="" <line22> + "" null then 0 else SUM(case when gl.debitamount = NULL then 0 else gl.debitamount"" <line23> + "" end) end as receipt from BankAccount acc, voucherheader vh, generalledger gl"" <line24> + "" where vh.id=gl.voucherheaderid and acc.glcodeid= gl.glcodeid   and vh.name in ('"" <line25> + FinancialConstants.CONTRAVOUCHER_NAME_BTOB <line26> + ""','"" <line27> + FinancialConstants.CONTRAVOUCHER_NAME_INTERFUND <line28> + ""') "" <line29> + "" and vh.voucherdate='"" <line30> + sqlformat.format(asPerDate) <line31> + ""'  and acc.id="" <line32> + bankaccountId <line33> + "" and vh.status =0""); <line34> final List list = getSession().createSQLQuery(qry.toString()).list(); <line35> final BigDecimal contraReceipt = (BigDecimal) list.get(0); <line36> if (LOGGER.isDebugEnabled()) <line37> LOGGER.debug( <line38> ""Contra Receipt For BankId "" <line39> + accountGlcodeId <line40> + "" And Date "" <line41> + sqlformat.format(asPerDate) <line42> + "" is : "" <line43> + contraReceipt); <line44> return contraReceipt; <line45> } <line46> } <line47> "	No	task1	
"public class A { <line0> String getValidLocaleFromCookie(String localeCookieValue) { <line1> String validLocale; <line2> try { <line3> Locale localeFromCookie = new Locale.Builder().setLanguageTag(localeCookieValue).build(); <line4> validLocale = localeFromCookie.toLanguageTag(); <line5> } catch (NullPointerException | IllformedLocaleException e) { <line6> validLocale = ""en""; <line7> } <line8> return validLocale; <line9> } <line10> } <line11> "	Yes	task1	
"public class A { <line0> protected static void copyAssetsToWorkingDir( <line1> String webappSourceDir, <line2> String themeBuilderOutputDir, <line3> List<String> additionalThemeDirectories, <line4> List<String> additionalPluginDirectories) <line5> throws IOException { <line6> Assert.hasText(themeBuilderOutputDir, ""Working directory for theme builder not set""); <line7> File webappSource = new File(webappSourceDir); <line8> if (!webappSource.exists()) { <line9> throw new RuntimeException(""Webapp source directory does not exist""); <line10> } <line11> File workingDir = new File(themeBuilderOutputDir); <line12> if (!workingDir.exists()) { <line13> workingDir.mkdir(); <line14> } <line15> workingDir.setWritable(true); <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> ThemeBuilderUtils.copyDirectory( <line19> webappSourceDir + ThemeBuilderConstants.KRAD_SCRIPTS_DIRECTORY, <line20> themeBuilderOutputDir + ThemeBuilderConstants.KRAD_SCRIPTS_DIRECTORY); <line21> ThemeBuilderUtils.copyDirectory( <line22> webappSourceDir + ThemeBuilderConstants.DEFAULT_THEMES_DIRECTORY, <line23> themeBuilderOutputDir + ThemeBuilderConstants.DEFAULT_THEMES_DIRECTORY); <line24> if (additionalThemeDirectories != null) { <line25> for (String additionalThemeDirectory : additionalThemeDirectories) { <line26> ThemeBuilderUtils.copyDirectory( <line27> webappSourceDir + additionalThemeDirectory, <line28> themeBuilderOutputDir + additionalThemeDirectory); <line29> } <line30> } <line31> ThemeBuilderUtils.copyDirectory( <line32> webappSourceDir + ThemeBuilderConstants.DEFAULT_PLUGINS_DIRECTORY, <line33> themeBuilderOutputDir + ThemeBuilderConstants.DEFAULT_PLUGINS_DIRECTORY); <line34> if (additionalPluginDirectories != null) { <line35> for (String additionalPluginDirectory : additionalPluginDirectories) { <line36> ThemeBuilderUtils.copyDirectory( <line37> webappSourceDir + additionalPluginDirectory, <line38> themeBuilderOutputDir + additionalPluginDirectory); <line39> } <line40> } <line41> } <line42> } <line43> "	Yes	task1	
public class A { <line0> @Override <line1> public SolrInputDocument toSolrDocument(DIPFile file, IndexingAdditionalInfo info) <line2> throws RequestNotValidException, GenericException, NotFoundException, <line3> AuthorizationDeniedException { <line4> SolrInputDocument doc = super.toSolrDocument(file, info); <line5> List<String> path = file.getPath(); <line6> doc.addField(RodaConstants.DIPFILE_PATH, path); <line7> if (path != null && !path.isEmpty()) { <line8> List<String> ancestorsPath = getDIPFileAncestorsPath(file.getDipId(), path); <line9> if (!ancestorsPath.isEmpty()) { <line10> doc.addField(RodaConstants.DIPFILE_ANCESTORS_UUIDS, ancestorsPath); <line11> } <line12> doc.addField( <line13> RodaConstants.DIPFILE_PARENT_UUID, <line14> IdUtils.getDIPFileId( <line15> file.getDipId(), path.subList(0, path.size() - 1), path.get(path.size() - 1))); <line16> } <line17> doc.addField(RodaConstants.DIPFILE_DIP_ID, file.getDipId()); <line18> doc.addField(RodaConstants.DIPFILE_IS_DIRECTORY, file.isDirectory()); <line19> doc.addField(RodaConstants.DIPFILE_SIZE, Long.toString(file.getSize())); <line20> try { <line21> StoragePath filePath = ModelUtils.getDIPFileStoragePath(file); <line22> doc.addField( <line23> RodaConstants.DIPFILE_STORAGE_PATH, <line24> RodaCoreFactory.getStorageService().getStoragePathAsString(filePath, false)); <line25> } catch (RequestNotValidException e) { <line26> } <line27> return doc; <line28> } <line29> } <line30> 	Yes	task1	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void init(ServletConfig config) throws ServletException { <line3> super.init(config); <line4> if (driver == null) { <line5> String driverClassName = config.getInitParameter(""Driver""); <line6> Class<? extends Driver> driverClass; <line7> try { <line8> driverClass = <line9> driverClassName == null <line10> ? null <line11> : (Class<? extends Driver>) Class.forName(driverClassName); <line12> driver = driverClass == null ? null : driverClass.newInstance(); <line13> } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) { <line14> throw new ServletException(ex.getMessage(), ex); <line15> } <line16> if (driver == null) throw new ServletException(""Unable to load driver: "" + driverClassName); <line17> } <line18> } <line19> } <line20> "	Yes	task1	
"public class A { <line0> private void executeRegisteredJobs(JobParameters jobParameters) throws JobExecutionException { <line1> if (this.jobRegistry != null && StringUtils.hasText(this.jobNames)) { <line2> String[] jobsToRun = this.jobNames.split("",""); <line3> for (String jobName : jobsToRun) { <line4> try { <line5> Job job = this.jobRegistry.getJob(jobName); <line6> if (this.jobs.contains(job)) { <line7> continue; <line8> } <line9> execute(job, jobParameters); <line10> } catch (NoSuchJobException ex) { <line11> continue; <line12> } <line13> } <line14> } <line15> } <line16> } <line17> "	Yes	task1	
"public class A { <line0> @Override <line1> public String execute() { <line2> try { <line3> _feed = new SyndFeedImpl(); <line4> List<ServiceAlertRssBean> beans = new ArrayList<>(); <line5> String baseUrl = createBaseUrl(ServletActionContext.getRequest()); <line6> setServiceAlerts(beans, baseUrl); <line7> for (Object objBean : beans) { <line8> ServiceAlertRssBean rssBean = (ServiceAlertRssBean) objBean; <line9> _feed.getModules().add(rssBean); <line10> } <line11> _feed.setTitle(""OneBusAway Service Alerts""); <line12> _feed.setLink(""""); <line13> _feed.setDescription(""Service Information - Service Alerts""); <line14> return SUCCESS; <line15> } catch (Throwable t) { <line16> return ERROR; <line17> } <line18> } <line19> } <line20> "	Yes	task1	
"public class A { <line0> @Test <line1> public void iterationScenarioTest() throws Exception { <line2> final Scenario scenario; <line3> System.setProperty(PerfCakeConst.SCENARIO_PROPERTY, ""1chart-scenario$""); <line4> TestSender.resetCounter(); <line5> scenario = ScenarioLoader.load(""test-scenario-chart""); <line6> scenario.init(); <line7> scenario.run(); <line8> scenario.close(); <line9> final ScenarioRetractor retractor = new ScenarioRetractor(scenario); <line10> final Reporter reporter = retractor.getReportManager().getReporters().iterator().next(); <line11> ChartDestination chartDestination = null; <line12> for (final Destination d : reporter.getDestinations()) { <line13> log.info(d.toString()); <line14> if (d instanceof ChartDestination) { <line15> chartDestination = (ChartDestination) d; <line16> break; <line17> } <line18> } <line19> final String correctGroup = ""_1chart_scenario__throughput""; <line20> Assert.assertNotNull(chartDestination); <line21> Assert.assertEquals(chartDestination.getGroup(), correctGroup); <line22> Assert.assertEquals(TestSender.getCounter(), 1_000_000); <line23> final Path dir = Paths.get(""target/test-chart""); <line24> verifyBasicFiles(dir); <line25> Assert.assertTrue( <line26> dir.resolve( <line27> Paths.get( <line28> ""data"", <line29> correctGroup <line30> + System.getProperty(PerfCakeConst.NICE_TIMESTAMP_PROPERTY) <line31> + "".json"")) <line32> .toFile() <line33> .exists()); <line34> Assert.assertTrue( <line35> dir.resolve( <line36> Paths.get( <line37> ""data"", <line38> correctGroup <line39> + System.getProperty(PerfCakeConst.NICE_TIMESTAMP_PROPERTY) <line40> + "".js"")) <line41> .toFile() <line42> .exists()); <line43> Assert.assertTrue( <line44> dir.resolve( <line45> Paths.get( <line46> ""data"", <line47> correctGroup <line48> + System.getProperty(PerfCakeConst.NICE_TIMESTAMP_PROPERTY) <line49> + "".html"")) <line50> .toFile() <line51> .exists()); <line52> final C3ChartData data = new C3ChartData(getBaseName(dir, null), dir); <line53> Assert.assertEquals(data.getData().get(0).size(), 5); <line54> JsonArray array = data.getData().get(0); <line55> try { <line56> Assert.assertNotNull(array.getInteger(0)); <line57> Assert.assertNotNull(array.getDouble(1)); <line58> Assert.assertNotNull(array.getDouble(2)); <line59> Assert.assertNotNull(array.getDouble(3)); <line60> Assert.assertNotNull(array.getDouble(4)); <line61> } catch (ClassCastException cce) { <line62> Assert.fail( <line63> ""Chart array does not contain expected data. Should be [int, double, double, double,"" <line64> + "" double]. "" <line65> + cce); <line66> } <line67> FileUtils.deleteDirectory(dir.toFile()); <line68> } <line69> } <line70> "	No	task1	
"public class A { <line0> public String[] setValues(String name, String... values) { <line1> checkNull(""name"", name); <line2> String[] vals = params.get(name); <line3> if (values == null) { <line4> values = new String[] {null}; <line5> } <line6> params.put(name, values.clone()); <line7> if (urlProvider != null) { <line8> urlProvider.setParameter(windowId, name, type, values.clone()); <line9> } <line10> if (isTrace) { <line11> StringBuilder txt = new StringBuilder(); <line12> txt.append(""Window ID: "") <line13> .append(windowId) <line14> .append("", Name: "") <line15> .append(name) <line16> .append("", Type: "") <line17> .append(type) <line18> .append("", Old Values: "") <line19> .append(Arrays.toString(vals)) <line20> .append("", New Values: "") <line21> .append(Arrays.toString(values)); <line22> } <line23> return vals; <line24> } <line25> } <line26> "	Yes	task1	
"public class A { <line0> @Nullable <line1> protected ClassLoader getCustomClassLoaderForBrooklynObject( <line2> LookupContext lookupContext, BrooklynObjectType type, String objectId) { <line3> BrooklynObject item = lookupContext.peek(type, objectId); <line4> String catalogItemId = (item == null) ? null : item.getCatalogItemId(); <line5> if (catalogItemId == null) { <line6> return null; <line7> } <line8> final ManagementContext managementContext = lookupContext.lookupManagementContext(); <line9> RegisteredType catalogItem = managementContext.getTypeRegistry().get(catalogItemId); <line10> if (catalogItem == null) { <line11> LOG.warn( <line12> ""Unable to load catalog item "" <line13> + catalogItemId <line14> + "" for custom class loader of "" <line15> + type <line16> + "" "" <line17> + objectId <line18> + ""; will use default class loader""); <line19> return null; <line20> } else { <line21> final BrooklynClassLoadingContextSequential ctx = <line22> new BrooklynClassLoadingContextSequential(managementContext); <line23> ctx.add( <line24> CatalogUtils.newClassLoadingContextForCatalogItems( <line25> managementContext, item.getCatalogItemId(), item.getCatalogItemIdSearchPath())); <line26> return ClassLoaderFromBrooklynClassLoadingContext.of(ctx); <line27> } <line28> } <line29> } <line30> "	Yes	task1	
"public class A { <line0> @Override <line1> public List<Authorization> getUserAuthorizations( <line2> String username, Map<String, Group> groups, Map<String, Role> roles) { <line3> Connection conn = null; <line4> List<Authorization> authorizations = new ArrayList<Authorization>(); <line5> PreparedStatement stat = null; <line6> ResultSet res = null; <line7> try { <line8> conn = this.getConnection(); <line9> stat = conn.prepareStatement(GET_USER_AUTHORIZATIONS); <line10> stat.setString(1, username); <line11> res = stat.executeQuery(); <line12> while (res.next()) { <line13> String groupname = res.getString(1); <line14> Group group = (null != groupname) ? groups.get(groupname) : null; <line15> String rolename = res.getString(2); <line16> Role role = (null != rolename) ? roles.get(rolename) : null; <line17> Authorization authorization = new Authorization(group, role); <line18> if (!authorizations.contains(authorization)) { <line19> authorizations.add(authorization); <line20> } <line21> } <line22> } catch (Throwable t) { <line23> logger.error(""Error loading user authorization"", t); <line24> throw new RuntimeException(""Error loading user authorization"", t); <line25> } finally { <line26> closeDaoResources(res, stat, conn); <line27> } <line28> return authorizations; <line29> } <line30> } <line31> "	No	task1	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Files.walkFileTree( <line4> devConsoleFinalDestination, <line5> new SimpleFileVisitor<Path>() { <line6> @Override <line7> public FileVisitResult postVisitDirectory(Path dir, IOException exc) <line8> throws IOException { <line9> Files.delete(dir); <line10> return FileVisitResult.CONTINUE; <line11> } <line12> @Override <line13> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) <line14> throws IOException { <line15> Files.delete(file); <line16> return FileVisitResult.CONTINUE; <line17> } <line18> }); <line19> } catch (IOException e) { <line20> LOG.error( <line21> ""Error cleaning up DEV Console temporary directory: "" + devConsoleFinalDestination, e); <line22> } <line23> } <line24> } <line25> "	No	task1	
"public class A { <line0> public static com.liferay.portal.kernel.model.Group updateGroup( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> long parentGroupId, <line4> java.util.Map<java.util.Locale, String> nameMap, <line5> java.util.Map<java.util.Locale, String> descriptionMap, <line6> int type, <line7> boolean manualMembership, <line8> int membershipRestriction, <line9> String friendlyURL, <line10> boolean inheritContent, <line11> boolean active, <line12> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line13> throws com.liferay.portal.kernel.exception.PortalException { <line14> try { <line15> MethodKey methodKey = <line16> new MethodKey(GroupServiceUtil.class, ""updateGroup"", _updateGroupParameterTypes37); <line17> MethodHandler methodHandler = <line18> new MethodHandler( <line19> methodKey, <line20> groupId, <line21> parentGroupId, <line22> nameMap, <line23> descriptionMap, <line24> type, <line25> manualMembership, <line26> membershipRestriction, <line27> friendlyURL, <line28> inheritContent, <line29> active, <line30> serviceContext); <line31> Object returnObj = null; <line32> try { <line33> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line34> } catch (Exception exception) { <line35> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line36> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line37> } <line38> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line39> } <line40> return (com.liferay.portal.kernel.model.Group) returnObj; <line41> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line42> log.error(systemException, systemException); <line43> throw systemException; <line44> } <line45> } <line46> } <line47> "	No	task1	
"public class A { <line0> @Override <line1> public Map<String, byte[]> getOriginalConfigs() { <line2> Map<String, byte[]> configs = new HashMap<String, byte[]>(); <line3> try { <line4> Utils.loadConfigFile(getJGroupsConfigFile(), configs); <line5> Utils.loadConfigFile(getConfigFile(), configs); <line6> } catch (Exception e) { <line7> log.error(""Error while reading original configuration files"", e); <line8> } <line9> return configs; <line10> } <line11> } <line12> "	No	task1	
"public class A { <line0> private void loadTokenSecretState(OzoneManagerSecretState<OzoneTokenIdentifier> state) <line1> throws IOException { <line2> LOG.info(""Loading token state into token manager.""); <line3> for (Map.Entry<OzoneTokenIdentifier, Long> entry : state.getTokenState().entrySet()) { <line4> addPersistedDelegationToken(entry.getKey(), entry.getValue()); <line5> } <line6> } <line7> } <line8> "	No	task1	
public class A { <line0> protected void onStop() throws PluginShutdownException { <line1> } <line2> } <line3> 	Yes	task1	
"public class A { <line0> public void progressChanged(ProgressEvent progressEvent) { <line1> log.debug(""Progress event: "" + progressEvent); <line2> } <line3> } <line4> "	No	task1	
"public class A { <line0> @Override <line1> public void onPropertyModified( <line2> final PropertyDescriptor descriptor, final String oldValue, final String newValue) { <line3> final ComponentLog logger = getLogger(); <line4> final Processor instance = processor.get(); <line5> if (ScriptingComponentUtils.SCRIPT_FILE.equals(descriptor) <line6> || ScriptingComponentUtils.SCRIPT_BODY.equals(descriptor) <line7> || ScriptingComponentUtils.MODULES.equals(descriptor) <line8> || scriptingComponentHelper.SCRIPT_ENGINE.equals(descriptor)) { <line9> scriptNeedsReload.set(true); <line10> if (scriptingComponentHelper.SCRIPT_ENGINE.equals(descriptor)) { <line11> scriptEngine = null; <line12> } <line13> } else if (instance != null) { <line14> try { <line15> instance.onPropertyModified(descriptor, oldValue, newValue); <line16> } catch (final Exception e) { <line17> final String message = ""Unable to invoke onPropertyModified from script Processor: "" + e; <line18> logger.error(message, e); <line19> } <line20> } <line21> } <line22> } <line23> "	No	task1	
"public class A { <line0> private Connection establishConnecton( <line1> TestAmqpPeer testPeer, <line2> Supplier<ProxyHandler> proxyHandlerSupplier, <line3> boolean ssl, <line4> String optionsString) <line5> throws JMSException { <line6> testPeer.expectSaslPlain(""guest"", ""guest""); <line7> testPeer.expectOpen(); <line8> testPeer.expectBegin(); <line9> String remoteURI = buildURI(testPeer, ssl, optionsString); <line10> LOG.debug(""connect to {}"", remoteURI); <line11> JmsConnectionFactory factory = new JmsConnectionFactory(remoteURI); <line12> factory.setExtension( <line13> JmsConnectionExtensions.PROXY_HANDLER_SUPPLIER.toString(), <line14> (connection1, remote) -> { <line15> return proxyHandlerSupplier; <line16> }); <line17> Connection connection = factory.createConnection(""guest"", ""guest""); <line18> connection.setClientID(""clientName""); <line19> assertNull(testPeer.getThrowable()); <line20> return connection; <line21> } <line22> } <line23> "	No	task1	
public class A { <line0> public void onTraversalDone(final Integer result) { <line1> if (splitToMany) for (final VariantContextWriter writer : writers) writer.close(); <line2> else vcfWriter2.close(); <line3> } <line4> } <line5> 	Yes	task1	
public class A { <line0> public static void deleteRepository(long repositoryId) throws RemoteException { <line1> try { <line2> RepositoryServiceUtil.deleteRepository(repositoryId); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	Yes	task1	
"public class A { <line0> private void refreshAllDevices() { <line1> logger.debug(""Refreshing all devices for bridge {}"", thing.getUID()); <line2> for (Thing ownThing : getThing().getThings()) { <line3> OpenWebNetThingHandler hndlr = (OpenWebNetThingHandler) ownThing.getHandler(); <line4> if (hndlr != null) { <line5> hndlr.refreshDevice(true); <line6> } <line7> } <line8> } <line9> } <line10> "	No	task1	
public class A { <line0> public static com.liferay.knowledge.base.model.KBArticleSoap fetchFirstChildKBArticle( <line1> long groupId, long parentResourcePrimKey) throws RemoteException { <line2> try { <line3> com.liferay.knowledge.base.model.KBArticle returnValue = <line4> KBArticleServiceUtil.fetchFirstChildKBArticle(groupId, parentResourcePrimKey); <line5> return com.liferay.knowledge.base.model.KBArticleSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	Yes	task1	
public class A { <line0> @Override <line1> public void stop(BundleContext context) throws Exception { <line2> DispatchQueueServiceLoader.setBundleContext(null); <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> protected void showFieldLoggingTitle() { <line1> if (logger.isDebugEnabled()) { <line2> logger.debug(""[Multipart Request Parameter]""); <line3> } <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> private void parseColours(String message) { <line1> primaryColor = parseToHSBType(message, ""<cl>""); <line2> updateState(CHANNEL_PRIMARY_COLOR, primaryColor); <line3> secondaryColor = parseToHSBType(message, ""<cs>""); <line4> updateState(CHANNEL_SECONDARY_COLOR, secondaryColor); <line5> try { <line6> primaryWhite = new BigDecimal(WLedHelper.getValue(message, ""<wv>"", ""<"")); <line7> if (primaryWhite.intValue() > -1) { <line8> hasWhite = true; <line9> updateState( <line10> CHANNEL_PRIMARY_WHITE, <line11> new PercentType(primaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP))); <line12> secondaryWhite = new BigDecimal(WLedHelper.getValue(message, ""<ws>"", ""<"")); <line13> updateState( <line14> CHANNEL_SECONDARY_WHITE, <line15> new PercentType(secondaryWhite.divide(BIG_DECIMAL_2_55, RoundingMode.HALF_UP))); <line16> } <line17> } catch (IllegalArgumentException e) { <line18> logger.warn( <line19> ""IllegalArgumentException when parsing the WLED colour and white fields:{}"", <line20> e.getMessage()); <line21> } <line22> } <line23> } <line24> "	No	task1	
"public class A { <line0> private Set<String> buildRoles(UserAuthenticationData userAuthenticationData, UaaUser user) { <line1> boolean requestedRoles = userAuthenticationData.scopes.contains(ROLES_SCOPE); <line2> Set<String> roles = null; <line3> if (requestedRoles <line4> && userAuthenticationData.roles != null <line5> && !userAuthenticationData.roles.isEmpty()) { <line6> roles = userAuthenticationData.roles; <line7> } <line8> if (requestedRoles && roles == null) { <line9> logger.debug( <line10> String.format( <line11> ""Requested id_token containing user roles, but no saved roles available for user with"" <line12> + "" id:%s. Ensure storeCustomAttributes is enabled for origin:%s in zone:%s."", <line13> user.getId(), user.getOrigin(), identityZoneManager.getCurrentIdentityZoneId())); <line14> } <line15> return roles; <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> private void logUnauthorizedRequest(HttpServletRequest request, ResponseStatusException e) { <line1> if (LOGGER.isDebugEnabled()) { <line2> String userName = SecurityContextUtil.getUsername(); <line3> LOGGER.debug( <line4> String.format( <line5> ""User \""%s\"" is not authorized for request to \""%s\""."", <line6> userName, ServletUtil.decodeUri(request)), <line7> e); <line8> } <line9> } <line10> } <line11> "	Yes	task1	
"public class A { <line0> public static void logWarn(Logger logger, String eventInfo, String message) { <line1> logger.warn(String.format(""Event %s : %s"", eventInfo, message)); <line2> } <line3> } <line4> "	No	task1	
"public class A { <line0> private void silentClose(OutputStream s) { <line1> if (s != null) { <line2> try { <line3> s.close(); <line4> } catch (IOException e) { <line5> log.error(logCacheName + ""Failure closing stream"", e); <line6> } <line7> } <line8> } <line9> } <line10> "	No	task1	
"public class A { <line0> @Override <line1> protected void load(String userScope, String nodeId, IPreferences prefsToFill) { <line2> File prefsLocation = getPrefsLocation(userScope, nodeId); <line3> if (!prefsLocation.exists()) { <line4> File legacyPrefsLocation = getLegacyPrefsLocation(nodeId); <line5> if (legacyPrefsLocation.exists()) { <line6> LOG.warn( <line7> ""Legacy preference found: '{}'. Will be stored in the new location ('{}') the next"" <line8> + "" time."", <line9> legacyPrefsLocation.getAbsolutePath(), <line10> prefsLocation.getAbsolutePath()); <line11> } <line12> prefsLocation = legacyPrefsLocation; <line13> } <line14> if (prefsLocation.exists()) { <line15> Properties propertiesFromDisk = loadFromDisk(prefsLocation); <line16> convertToPreferences(propertiesFromDisk, prefsToFill); <line17> } <line18> } <line19> } <line20> "	Yes	task1	
"public class A { <line0> OnlineDetectionDataDTO saveOnlineDetectionData( <line1> JsonNode payloadNode, DatasetConfigDTO datasetConfigDTO, MetricConfigDTO metricConfigDTO) <line2> throws JsonProcessingException { <line3> JsonNode dataNode = payloadNode.get(DATA_FIELD); <line4> String timeColumnName = datasetConfigDTO.getTimeColumn(); <line5> String datasetName = datasetConfigDTO.getDataset(); <line6> String metricName = metricConfigDTO.getName(); <line7> Preconditions.checkArgument( <line8> validateOnlineDetectionData(dataNode, timeColumnName, metricName), <line9> String.format( <line10> ""metric: %s or time: %s not found in adhoc data."", metricName, timeColumnName)); <line11> OnlineDetectionDataDTO onlineDetectionDataDTO = new OnlineDetectionDataDTO(); <line12> onlineDetectionDataDTO.setDataset(datasetName); <line13> onlineDetectionDataDTO.setMetric(metricName); <line14> onlineDetectionDataDTO.setOnlineDetectionData(this.objectMapper.writeValueAsString(dataNode)); <line15> onlineDetectionDataDAO.save(onlineDetectionDataDTO); <line16> LOG.info( <line17> ""Saved online data with dataset: {} and metric: {}"", <line18> onlineDetectionDataDTO.getDataset(), <line19> onlineDetectionDataDTO.getMetric()); <line20> return onlineDetectionDataDTO; <line21> } <line22> } <line23> "	No	task1	
"public class A { <line0> protected void initializeTempComponent(final ConfigurableComponent configurableComponent) { <line1> ConfigurableComponentInitializer initializer = null; <line2> try { <line3> initializer = <line4> ConfigurableComponentInitializerFactory.createComponentInitializer( <line5> this, configurableComponent.getClass()); <line6> initializer.initialize(configurableComponent); <line7> } catch (final InitializationException e) { <line8> logger.warn( <line9> String.format( <line10> ""Unable to initialize component %s due to %s"", <line11> configurableComponent.getClass().getName(), e.getMessage())); <line12> } <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> private static String getHomeCommunityIdFromRequest(RetrieveDocumentSetRequestType request) { <line1> String homeCommunityId = null; <line2> if (request != null <line3> && request.getDocumentRequest() != null <line4> && request.getDocumentRequest().get(0) != null <line5> && request.getDocumentRequest().get(0).getHomeCommunityId() != null) { <line6> homeCommunityId = <line7> HomeCommunityMap.getHomeCommunityIdWithPrefix( <line8> request.getDocumentRequest().get(0).getHomeCommunityId()); <line9> } else { <line10> LOG.error( <line11> ""HomeCommunityId doesn't exist in the received RetrieveDocumentSetRequestType message""); <line12> } <line13> return homeCommunityId; <line14> } <line15> } <line16> "	No	task1	
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { <line2> super.exceptionCaught(ctx, cause); <line3> Channel channel = ctx.channel(); <line4> if (channel.isActive()) ctx.close(); <line5> } <line6> } <line7> 	Yes	task1	
"public class A { <line0> @Override <line1> public int getChildCount(String nodeId) { <line2> EntityReference wikiReference = resolve(nodeId); <line3> if (wikiReference != null && wikiReference.getType() == EntityType.WIKI) { <line4> try { <line5> return getChildCount(new WikiReference(wikiReference)); <line6> } catch (QueryException e) { <line7> this.logger.warn( <line8> ""Failed to count the children of [{}]. Root cause [{}]."", <line9> nodeId, <line10> ExceptionUtils.getRootCauseMessage(e)); <line11> } <line12> } <line13> return 0; <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> private FloatValidRange readFloatValidRangeSet() throws XMLStreamException { <line1> log.trace(XTCE_VALID_RANGE_SET); <line2> StartElement element = xmlEvent.asStartElement(); <line3> boolean calib = readBooleanAttribute(""validRangeAppliesToCalibrated"", element, true); <line4> FloatValidRange fvr = null; <line5> while (true) { <line6> xmlEvent = xmlEventReader.nextEvent(); <line7> if (isStartElementWithName(XTCE_VALID_RANGE)) { <line8> if (fvr != null) { <line9> throw new XMLStreamException(""Only one ValidRange supported. "", xmlEvent.getLocation()); <line10> } <line11> fvr = readFloatValidRange(); <line12> } else if (isEndElementWithName(XTCE_VALID_RANGE_SET)) { <line13> if (fvr == null) { <line14> throw new XMLStreamException(""No ValidRange supecified "", xmlEvent.getLocation()); <line15> } <line16> fvr.setValidRangeAppliesToCalibrated(calib); <line17> return fvr; <line18> } <line19> } <line20> } <line21> } <line22> "	No	task1	
"public class A { <line0> public void visit(BatchMessage msg) throws ArgumentNotValid { <line1> ArgumentNotValid.checkNotNull(ar, ""ar""); <line2> ArgumentNotValid.checkNotNull(msg, ""BatchMessage msg""); <line3> try { <line4> ReplicaClient rc = ar.getReplicaClientFromReplicaId(msg.getReplicaId()); <line5> rc.sendBatchJob(msg); <line6> } catch (Throwable t) { <line7> log.warn(""Failed to handle batch request"", t); <line8> BatchReplyMessage replyMessage = <line9> new BatchReplyMessage( <line10> msg.getReplyTo(), <line11> Channels.getTheRepos(), <line12> msg.getID(), <line13> 0, <line14> Collections.<File>emptyList(), <line15> null); <line16> replyMessage.setNotOk(t); <line17> JMSConnectionFactory.getInstance().send(replyMessage); <line18> } <line19> } <line20> } <line21> "	No	task1	
"public class A { <line0> @Test <line1> public void testSQLSelectsArrayAttributes() throws Exception { <line2> String createTableString = <line3> String.format( <line4> ""CREATE EXTERNAL TABLE message (\n"" <line5> + ""event_timestamp TIMESTAMP, \n"" <line6> + ""attributes ARRAY<ROW<key VARCHAR, `value` VARCHAR>>, \n"" <line7> + ""payload ROW< \n"" <line8> + ""             id INTEGER, \n"" <line9> + ""             name VARCHAR \n"" <line10> + ""           > \n"" <line11> + "") \n"" <line12> + ""TYPE '%s' \n"" <line13> + ""LOCATION '%s' \n"" <line14> + ""TBLPROPERTIES '{ "" <line15> + ""%s"" <line16> + ""\""protoClass\"" : \""%s\"", "" <line17> + ""\""timestampAttributeKey\"" : \""ts\"" }'"", <line18> tableProvider.getTableType(), <line19> eventsTopic.topicPath(), <line20> payloadFormatParam(), <line21> PayloadMessages.SimpleMessage.class.getName()); <line22> String queryString = <line23> ""SELECT message.payload.id, attributes[1].key AS a1, attributes[2].key AS a2 FROM message""; <line24> BeamSqlEnv sqlEnv = BeamSqlEnv.inMemory(new PubsubTableProvider()); <line25> sqlEnv.executeDdl(createTableString); <line26> PCollection<Row> queryOutput = query(sqlEnv, pipeline, queryString); <line27> queryOutput.apply( <line28> ""waitForSuccess"", <line29> resultSignal.signalSuccessWhen( <line30> SchemaCoder.of(PAYLOAD_SCHEMA), <line31> observedRows -> { <line32> Map<Integer, String> entries = new HashMap<>(); <line33> for (Row row : observedRows) { <line34> if (""ts"".equals(row.getString(""a1""))) { <line35> entries.put(row.getInt32(""id""), row.getString(""a2"")); <line36> } else { <line37> entries.put(row.getInt32(""id""), row.getString(""a1"")); <line38> } <line39> } <line40> LOG.info(""Entries: {}"", entries); <line41> return entries.equals(ImmutableMap.of(3, ""foo"", 5, ""bar"", 7, ""baz"")); <line42> })); <line43> pipeline.run(); <line44> eventsTopic.assertSubscriptionEventuallyCreated( <line45> pipeline.getOptions().as(GcpOptions.class).getProject(), Duration.standardMinutes(5)); <line46> eventsTopic.publish( <line47> ImmutableList.of( <line48> objectsProvider.messageIdName(ts(1), 3, ""foo""), <line49> objectsProvider.messageIdName(ts(2), 5, ""bar""), <line50> objectsProvider.messageIdName(ts(3), 7, ""baz""))); <line51> resultSignal.waitForSuccess(timeout); <line52> } <line53> } <line54> "	No	task1	
"public class A { <line0> @Override <line1> public byte[] getData(final String path, final Watcher watcher, final Stat stat) <line2> throws KeeperException, InterruptedException { <line3> return execute( <line4> new ZKExecutor<byte[]>(""getData"") { <line5> @Override <line6> byte[] execute() throws KeeperException, InterruptedException { <line7> LOG.debug(""ZK Call - getData [{0}] [{1}] [{2}]"", path, watcher, stat); <line8> return ZooKeeperClient.super.getData(path, watcher, stat); <line9> } <line10> }); <line11> } <line12> } <line13> "	No	task1	
public class A { <line0> @Override <line1> public void handleAsdu(final Connection connection, final ASdu asdu) throws IOException { <line2> throw new UnsupportedOperationException(); <line3> } <line4> } <line5> 	Yes	task1	
"public class A { <line0> private DataStorageConfiguration configureDataRegionForDefragmentation( <line1> DataStorageConfiguration memCfg) throws IgniteCheckedException { <line2> List<DataRegionConfiguration> regionConfs = new ArrayList<>(); <line3> DataStorageConfiguration dataConf = memCfg; <line4> regionConfs.add(dataConf.getDefaultDataRegionConfiguration()); <line5> if (dataConf.getDataRegionConfigurations() != null) <line6> regionConfs.addAll(Arrays.asList(dataConf.getDataRegionConfigurations())); <line7> long totalDefrRegionSize = 0; <line8> long totalRegionsSize = 0; <line9> for (DataRegionConfiguration regionCfg : regionConfs) { <line10> totalDefrRegionSize = <line11> Math.max( <line12> totalDefrRegionSize, <line13> (long) <line14> (regionCfg.getMaxSize() <line15> * 0.01 <line16> * defragmentationRegionSizePercentageOfConfiguredSize)); <line17> totalRegionsSize += regionCfg.getMaxSize(); <line18> } <line19> double shrinkPercentage = 1d * (totalRegionsSize - totalDefrRegionSize) / totalRegionsSize; <line20> for (DataRegionConfiguration region : regionConfs) { <line21> long newSize = (long) (region.getMaxSize() * shrinkPercentage); <line22> long newInitSize = Math.min(region.getInitialSize(), newSize); <line23> log.info( <line24> ""Region size was reassigned by defragmentation reason: "" <line25> + ""region = '"" <line26> + region.getName() <line27> + ""', "" <line28> + ""oldInitialSize = '"" <line29> + region.getInitialSize() <line30> + ""', "" <line31> + ""newInitialSize = '"" <line32> + newInitSize <line33> + ""', "" <line34> + ""oldMaxSize = '"" <line35> + region.getMaxSize() <line36> + ""', "" <line37> + ""newMaxSize = '"" <line38> + newSize); <line39> region.setMaxSize(newSize); <line40> region.setInitialSize(newInitSize); <line41> region.setCheckpointPageBufferSize(0); <line42> } <line43> long mappingRegionSize = Math.min(GB, (long) (totalDefrRegionSize * 0.1)); <line44> checkpointedDataRegions.remove( <line45> addDataRegion( <line46> memCfg, <line47> createDefragmentationDataRegionConfig(totalDefrRegionSize - mappingRegionSize), <line48> true, <line49> new DefragmentationPageReadWriteManager(cctx.kernalContext(), ""defrgPartitionsStore""))); <line50> checkpointedDataRegions.remove( <line51> addDataRegion( <line52> memCfg, <line53> createDefragmentationMappingRegionConfig(mappingRegionSize), <line54> true, <line55> new DefragmentationPageReadWriteManager( <line56> cctx.kernalContext(), ""defrgLinkMappingStore""))); <line57> return dataConf; <line58> } <line59> } <line60> "	Yes	task1	
"public class A { <line0> private void load() { <line1> if (buffer.length() == 0) { <line2> String path = Packages.absolutePath(scope, fileName); <line3> Application app = Application.get(); <line4> IResourceStream stream = <line5> app.getResourceSettings() <line6> .getResourceStreamLocator() <line7> .locate(scope, path, getStyle(), getVariation(), getLocale(), null, false); <line8> if (stream == null) { <line9> stream = <line10> new ResourceStreamLocator() <line11> .locate(scope, path, getStyle(), getVariation(), getLocale(), null, false); <line12> } <line13> if (stream == null) { <line14> throw new IllegalArgumentException( <line15> ""resource "" + fileName + "" not found for scope "" + scope + "" (path = "" + path + "")""); <line16> } <line17> setLastModified(stream.lastModifiedTime()); <line18> try { <line19> if (encoding != null) { <line20> buffer.append(Streams.readString(stream.getInputStream(), encoding)); <line21> } else { <line22> buffer.append(Streams.readString(stream.getInputStream())); <line23> } <line24> } catch (IOException e) { <line25> throw new RuntimeException(e); <line26> } catch (ResourceStreamNotFoundException e) { <line27> throw new RuntimeException(e); <line28> } finally { <line29> try { <line30> stream.close(); <line31> } catch (IOException e) { <line32> log.error(e.getMessage(), e); <line33> } <line34> } <line35> } <line36> } <line37> } <line38> "	No	task1	
"public class A { <line0> private void updateOtherProperties(IaasProvider updatedIaasProvider, Properties properties) { <line1> for (Object property : properties.keySet()) { <line2> if (property instanceof String) { <line3> String key = (String) property; <line4> updatedIaasProvider.setProperty(key, properties.getProperty(key)); <line5> if (log.isDebugEnabled()) { <line6> log.debug(""Added property "" + key + "" to the IaasProvider.""); <line7> } <line8> } <line9> } <line10> } <line11> } <line12> "	No	task1	
public class A { <line0> private void handleEffect(Command command) throws IOException, CommandUnsuccessfulException { <line1> if (command instanceof StringType) { <line2> String effectName = command.toString(); <line3> Effect effect = new Effect(effectName); <line4> EffectCommand effectCommand = new EffectCommand(effect, priority); <line5> sendCommand(effectCommand); <line6> } else { <line7> } <line8> } <line9> } <line10> 	Yes	task1	
"public class A { <line0> public static AddressPlan jsonToAddressPlan(JsonObject jsonData) throws IOException { <line1> log.info(""Got addressPlan object: {}"", jsonData.toString()); <line2> return new ObjectMapper().readValue(jsonData.toString(), AddressPlan.class); <line3> } <line4> } <line5> "	No	task1	
"public class A { <line0> public static void removeAll(ZooKeeper zooKeeper, String path) <line1> throws KeeperException, InterruptedException { <line2> List<String> list = zooKeeper.getChildren(path, false); <line3> for (String p : list) { <line4> removeAll(zooKeeper, path + ""/"" + p); <line5> } <line6> zooKeeper.delete(path, -1); <line7> } <line8> } <line9> "	Yes	task1	
public class A { <line0> @Test <line1> public void testOneNodeRestartWithTtlCache() throws Exception { <line2> eagerTtl = true; <line3> IgniteEx ignite = startGrid(0); <line4> ignite.cluster().state(ClusterState.ACTIVE); <line5> IgniteCache<Integer, Integer> cache = ignite.cache(DEFAULT_CACHE_NAME); <line6> for (int i = 0; i < ENTRIES; i++) cache.put(i, i); <line7> ignite.close(); <line8> LogListener assertListener = LogListener.matches(ASSERTION_ERR).build(); <line9> listeningLog.registerListener(assertListener); <line10> ignite = startGrid(0); <line11> CountDownLatch exchangeHangLatch = new CountDownLatch(1); <line12> ignite <line13> .context() <line14> .cache() <line15> .context() <line16> .exchange() <line17> .registerExchangeAwareComponent( <line18> new PartitionsExchangeAware() { <line19> @Override <line20> public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) { <line21> try { <line22> exchangeHangLatch.await(); <line23> } catch (InterruptedException e) { <line24> fail(e.getMessage()); <line25> } <line26> } <line27> }); <line28> IgniteInternalFuture<?> activeFut = <line29> GridTestUtils.runAsync(() -> ignite(0).cluster().state(ClusterState.ACTIVE)); <line30> assertFalse(activeFut.isDone()); <line31> assertFalse(GridTestUtils.waitForCondition(assertListener::check, 2_000)); <line32> exchangeHangLatch.countDown(); <line33> activeFut.get(); <line34> awaitPartitionMapExchange(); <line35> } <line36> } <line37> 	Yes	task1	
"public class A { <line0> @Override <line1> public long getModificationDate() { <line2> try { <line3> return Files.getLastModifiedTime(Paths.get(path)).toMillis(); <line4> } catch (IOException e) { <line5> log.warn(String.format(""Failure getting timestamp of %s. %s"", path, e.getMessage())); <line6> return -1L; <line7> } <line8> } <line9> } <line10> "	No	task1	
"public class A { <line0> @Override <line1> public void modifiedAttributes( <line2> ServerSession session, Path path, Map<String, ?> attrs, Throwable thrown) { <line3> modifiedCount.incrementAndGet(); <line4> log.info( <line5> ""modifiedAttributes("" <line6> + session <line7> + "") "" <line8> + path <line9> + ((thrown == null) <line10> ? """" <line11> : ("": "" + thrown.getClass().getSimpleName() + "": "" + thrown.getMessage()))); <line12> } <line13> } <line14> "	No	task1	
"public class A { <line0> private void updateLogicalInterconnectTelemetryConfigurationV200() { <line1> LogicalInterconnect logicalInterconnect = <line2> resourceDtoUtils.getLogicalInterconnectByName(RESOURCE_NAME); <line3> TelemetryConfiguration telemetryConfiguration = <line4> logicalInterconnectClient.getTelemetryConfiguration( <line5> logicalInterconnect.getResourceId(), TELEMETRY_ID); <line6> telemetryConfiguration.setEnableTelemetry(!telemetryConfiguration.getEnableTelemetry()); <line7> TaskResource task = <line8> logicalInterconnectClient.updateTelemetryConfiguration( <line9> logicalInterconnect.getResourceId(), TELEMETRY_ID, telemetryConfiguration); <line10> LOGGER.info(""Task object returned to client : "" + task.toJsonString()); <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> @Override <line1> public void rowEofResponse(byte[] eof, BackendConnection conn) { <line2> LOGGER.warn( <line3> new StringBuilder() <line4> .append(""unexpected packet for "") <line5> .append(conn) <line6> .append("" bound by "") <line7> .append(session.getSource()) <line8> .append("": field's eof"") <line9> .toString()); <line10> conn.quit(); <line11> killee.close(""killed""); <line12> } <line13> } <line14> "	No	task1	
"public class A { <line0> @Override <line1> public void onEvent(EventSource eventSource, String id, String type, String data) { <line2> Exchange exchange = createExchange(false); <line3> try { <line4> SoroushMessage soroushMessage = objectMapper.readValue(data, SoroushMessage.class); <line5> exchange.getIn().setBody(soroushMessage); <line6> if (LOG.isDebugEnabled()) { <line7> LOG.debug(""event data is: "" + data); <line8> } <line9> if (endpoint.isAutoDownload()) { <line10> endpoint.handleDownloadFiles(soroushMessage); <line11> } <line12> sendExchange(exchange); <line13> } catch (Exception ex) { <line14> getExceptionHandler().handleException(ex); <line15> } <line16> } <line17> } <line18> "	No	task1	
public class A { <line0> public final void startIndexing() { <line1> try { <line2> for (IndexType IndexType : IndexType.values()) { <line3> writers.put(IndexType, createIndexWriter(IndexType)); <line4> } <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> 	Yes	task1	
"public class A { <line0> @Override <line1> public void run() { <line2> boolean locked = false; <line3> try { <line4> Profiler p = new Profiler(); <line5> p.start(); <line6> locked = WorkLock.lock(timeoutSeconds); <line7> p.stop(); <line8> System.out.println( <line9> ""Thread "" + id + "" waited "" + p.getDurationInMillis() + "" ms, locked="" + locked); <line10> if (locked) { <line11> Thread.sleep(jobDuration * 1000); <line12> } <line13> } catch (InterruptedException e) { <line14> } finally { <line15> if (locked) { <line16> boolean unlocked = WorkLock.unlock(); <line17> System.out.println(""Thread "" + id + ""  unlocked="" + unlocked); <line18> } <line19> } <line20> } <line21> } <line22> "	Yes	task1	
"public class A { <line0> protected String replaceAll(String strCmd, Map<String, String> mapInputs) { <line1> if (mapInputs.isEmpty()) return strCmd; <line2> String regexp = """"; <line3> for (String input : mapInputs.keySet()) regexp += parameterToPlaceholder(input); <line4> regexp = regexp.substring(0, regexp.length() - 1); <line5> StringBuffer sb = new StringBuffer(); <line6> Pattern p = Pattern.compile(regexp); <line7> Matcher m = p.matcher(strCmd); <line8> while (m.find()) { <line9> String param = placeholderToParameter(m.group()); <line10> m.appendReplacement(sb, mapInputs.get(param)); <line11> } <line12> m.appendTail(sb); <line13> return sb.toString(); <line14> } <line15> } <line16> "	Yes	task1	
"public class A { <line0> public void addDataSourceInformation(DataSourceInformation dataSourceInformation) { <line1> assertDataSourceInformationNull(dataSourceInformation); <line2> String repositoryType = dataSourceInformation.getRepositoryType(); <line3> if (log.isDebugEnabled()) { <line4> log.debug( <line5> ""Registering a datasource in the repository : "" <line6> + repositoryType <line7> + ""."" <line8> + "" DataSource information is : "" <line9> + dataSourceInformation); <line10> } <line11> if (DataSourceConstants.PROP_REGISTRY_JNDI.equals(repositoryType)) { <line12> jndiBasedDataSourceRepository.register(dataSourceInformation); <line13> } else { <line14> inMemoryDataSourceRepository.register(dataSourceInformation); <line15> } <line16> } <line17> } <line18> "	Yes	task1	
"public class A { <line0> @Override <line1> public InvestmentSolution readSolution() throws IOException { <line2> solution = new InvestmentSolution(); <line3> solution.setId(0L); <line4> readParametrization(); <line5> readRegionList(); <line6> readSectorList(); <line7> readAssetClassList(); <line8> createAssetClassAllocationList(); <line9> BigInteger possibleSolutionSize = <line10> BigInteger.valueOf(solution.getAssetClassList().size()) <line11> .multiply(BigInteger.valueOf(InvestmentNumericUtil.MAXIMUM_QUANTITY_MILLIS)); <line12> logger.info( <line13> ""InvestmentAllocation {} has {} regions, {} sectors and {} asset classes"" <line14> + "" with a search space of {}."", <line15> getInputId(), <line16> solution.getRegionList().size(), <line17> solution.getSectorList().size(), <line18> solution.getAssetClassList().size(), <line19> getFlooredPossibleSolutionSize(possibleSolutionSize)); <line20> return solution; <line21> } <line22> } <line23> "	No	task1	
"public class A { <line0> public IngestContractDto create(VitamContext vitamContext, IngestContractDto ingestContractDto) { <line1> try { <line2> LOGGER.info( <line3> ""Create Ingest Contract EvIdAppSession : {} "", vitamContext.getApplicationSessionId()); <line4> RequestResponse requestResponse = <line5> ingestContractService.createIngestContracts( <line6> vitamContext, converter.convertDtosToVitams(Arrays.asList(ingestContractDto))); <line7> final IngestContractModel ingestContractVitamDto = <line8> objectMapper.treeToValue(requestResponse.toJsonNode(), IngestContractModel.class); <line9> return converter.convertVitamToDto(ingestContractVitamDto); <line10> } catch (InvalidParseOperationException | AccessExternalClientException | IOException e) { <line11> throw new InternalServerException(""Can't create ingest contract"", e); <line12> } <line13> } <line14> } <line15> "	Yes	task1	
"public class A { <line0> private static void pushDataSetToS3( <line1> AmazonS3 s3Client, Bucket bucket, List<StaticRifResource> dataResources) { <line2> List<DataSetManifestEntry> manifestEntries = <line3> dataResources.stream() <line4> .map(r -> new DataSetManifestEntry(r.name(), r.getRifFileType())) <line5> .collect(Collectors.toList()); <line6> DataSetManifest manifest = new DataSetManifest(Instant.now(), 0, manifestEntries); <line7> s3Client.putObject(DataSetTestUtilities.createPutRequest(bucket, manifest)); <line8> TransferManager transferManager = <line9> TransferManagerBuilder.standard().withS3Client(s3Client).build(); <line10> for (int i = 0; i < dataResources.size(); i++) { <line11> StaticRifResource dataResource = dataResources.get(i); <line12> URL dataResourceUrl = dataResource.getResourceUrl(); <line13> Pattern s3HttpObjectRegex = Pattern.compile(""http://(.+)\\.s3\\.amazonaws\\.com/(.+)""); <line14> Matcher s3HttpObjectMatcher = s3HttpObjectRegex.matcher(dataResourceUrl.toString()); <line15> if (s3HttpObjectMatcher.matches()) { <line16> String sourceBucketName = s3HttpObjectMatcher.group(1); <line17> String sourceKey = s3HttpObjectMatcher.group(2); <line18> String objectKey = <line19> String.format( <line20> ""%s/%s/%s"", <line21> CcwRifLoadJob.S3_PREFIX_PENDING_DATA_SETS, <line22> manifest.getTimestampText(), <line23> manifest.getEntries().get(i).getName()); <line24> Copy s3CopyOperation = <line25> transferManager.copy( <line26> new CopyObjectRequest(sourceBucketName, sourceKey, bucket.getName(), objectKey)); <line27> try { <line28> s3CopyOperation.waitForCopyResult(); <line29> } catch (InterruptedException e) { <line30> throw new BadCodeMonkeyException(e); <line31> } <line32> } else { <line33> s3Client.putObject( <line34> DataSetTestUtilities.createPutRequest( <line35> bucket, manifest, manifest.getEntries().get(i), dataResourceUrl)); <line36> } <line37> } <line38> transferManager.shutdownNow(false); <line39> } <line40> } <line41> "	Yes	task1	
"public class A { <line0> public DataFileDto findDataFile(final Long id) { <line1> log.debug(""findDataFile() - id: {}"", id); <line2> final DataFile dataFile = dataFileService.find(id); <line3> return dataFileToDataFileDtoConverter.convert(dataFile); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> private String merge(String beanStringValue) { <line1> Map<String, String> map = convertToMap(beanStringValue); <line2> for (Map.Entry<String, String> entry : map.entrySet()) { <line3> String key = entry.getKey(); <line4> String propKey = PROPERTY_PREFIX + key; <line5> if (properties.containsKey(propKey)) { <line6> map.put(key, entry.getValue() + "","" + properties.getProperty(propKey)); <line7> } else { <line8> } <line9> } <line10> return convertToString(map); <line11> } <line12> } <line13> "	Yes	task1	
"public class A { <line0> @Override <line1> public Document addContextualizedValue(String field, String context, Object value) { <line2> checkField(field, value); <line3> FieldDescriptor fieldDescriptor = this.listFieldDescriptors().get(field); <line4> if (!fieldDescriptor.isMultiValue()) { <line5> log.error(""Invalid operation: The field {} is not multivalued."", field); <line6> throw new IllegalArgumentException( <line7> ""Invalid operation: The field "" + field + "" is not multivalued.""); <line8> } <line9> Map<String, Object> contexts = this.values.get(field); <line10> if (contexts == null) { <line11> contexts = new HashMap<>(); <line12> } <line13> Collection<Object> values = (Collection) contexts.get(context); <line14> if (values == null) { <line15> values = new ArrayList<>(); <line16> } <line17> values.add(value); <line18> contexts.put(context, values); <line19> this.values.put(field, contexts); <line20> if (Objects.nonNull(context)) { <line21> fieldDescriptor.setContextualized(true); <line22> } <line23> return this; <line24> } <line25> } <line26> "	No	task1	
"public class A { <line0> @Override <line1> protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) <line2> throws Exception { <line3> CxfRsEndpoint answer; <line4> Object value = parameters.remove(""setDefaultBus""); <line5> if (value != null) { <line6> LOG.warn(""The option setDefaultBus is @deprecated, use name defaultBus instead""); <line7> if (!parameters.containsKey(""defaultBus"")) { <line8> parameters.put(""defaultBus"", value); <line9> } <line10> } <line11> if (remaining.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) { <line12> String beanId = remaining.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length()); <line13> if (beanId.startsWith(""//"")) { <line14> beanId = beanId.substring(2); <line15> } <line16> AbstractJAXRSFactoryBean bean = <line17> CamelContextHelper.mandatoryLookup( <line18> getCamelContext(), beanId, AbstractJAXRSFactoryBean.class); <line19> CxfRsEndpointFactoryBean factory = null; <line20> if (bean.getClass().getName().contains(""blueprint"")) { <line21> Class<CxfRsEndpointFactoryBean> clazz = <line22> getCamelContext() <line23> .getClassResolver() <line24> .resolveMandatoryClass( <line25> ""org.apache.camel.component.cxf.jaxrs.blueprint.CxfRsBlueprintEndpointFactoryBean"", <line26> CxfRsEndpointFactoryBean.class); <line27> factory = getCamelContext().getInjector().newInstance(clazz); <line28> } else { <line29> factory = new DefaultCxfRsEndpointFactoryBean(); <line30> } <line31> answer = factory.createEndpoint(this, remaining, bean); <line32> if (bean.getProperties() != null) { <line33> Map<String, Object> copy = new HashMap<>(); <line34> copy.putAll(bean.getProperties()); <line35> setProperties(answer, copy); <line36> } <line37> answer.setBeanId(beanId); <line38> } else { <line39> answer = new CxfRsEndpoint(remaining, this); <line40> } <line41> String resourceClass = getAndRemoveParameter(parameters, ""resourceClass"", String.class); <line42> if (resourceClass != null) { <line43> Class<?> clazz = getCamelContext().getClassResolver().resolveMandatoryClass(resourceClass); <line44> answer.addResourceClass(clazz); <line45> } <line46> String resourceClasses = getAndRemoveParameter(parameters, ""resourceClasses"", String.class); <line47> Iterator<?> it = ObjectHelper.createIterator(resourceClasses); <line48> while (it.hasNext()) { <line49> String name = (String) it.next(); <line50> Class<?> clazz = getCamelContext().getClassResolver().resolveMandatoryClass(name); <line51> answer.addResourceClass(clazz); <line52> } <line53> setProperties(answer, parameters); <line54> Map<String, String> params = CastUtils.cast(parameters); <line55> answer.setParameters(params); <line56> setEndpointHeaderFilterStrategy(answer); <line57> if (answer.getSslContextParameters() == null) { <line58> answer.setSslContextParameters(retrieveGlobalSslContextParameters()); <line59> } <line60> return answer; <line61> } <line62> } <line63> "	No	task1	
"public class A { <line0> public void setMatchOneMappings(List<String> list) { <line1> String[] values; <line2> matchOneMap.clear(); <line3> if (list != null) { <line4> for (String mapping : list) { <line5> values = mapping.split(""=""); <line6> if (values.length == 2) { <line7> securityLogger.audit( <line8> ""Adding mapping: {} = {} to matchOneMap."", values[1].trim(), values[0].trim()); <line9> matchOneMap.put(values[1].trim(), values[0].trim()); <line10> } else { <line11> LOGGER.warn( <line12> ""Match one mapping ignored: {} doesn't match expected format of"" <line13> + "" metacardAttribute=userAttribute"", <line14> mapping); <line15> } <line16> } <line17> } <line18> } <line19> } <line20> "	Yes	task1	
"public class A { <line0> private int getEscapedWordIndex() { <line1> try { <line2> int caretPos = Math.max(0, getEffectiveCaretPosition() - 1); <line3> String expression = textComponent.getDocument().getText(0, caretPos); <line4> int escapeEnd = -1; <line5> do { <line6> int escapeStart = expression.indexOf(""'"", escapeEnd + 1); <line7> if (escapeStart != -1) { <line8> escapeEnd = expression.indexOf(""'"", escapeStart + 1); <line9> if (escapeEnd == -1) { <line10> return escapeStart; <line11> } <line12> } else { <line13> return -1; <line14> } <line15> } while (true); <line16> } catch (BadLocationException e) { <line17> logger.error( <line18> ""A BadLocationException was thrown when the auto-completer was determining whether or not"" <line19> + "" the caret is in an escaped name"", <line20> e); <line21> } <line22> return -1; <line23> } <line24> } <line25> "	Yes	task1	
"public class A { <line0> private boolean handleSAML2Response(HttpServletRequest request, HttpServletResponse response) <line1> throws IOException { <line2> HttpSession session = request.getSession(true); <line3> String samlResponse = request.getParameter(GeneralConstants.SAML_RESPONSE_KEY); <line4> HTTPContext httpContext = new HTTPContext(request, response, this.servletContext); <line5> Set<SAML2Handler> handlers = chain.handlers(); <line6> Principal principal = request.getUserPrincipal(); <line7> boolean willSendRequest; <line8> try { <line9> ServiceProviderSAMLResponseProcessor responseProcessor = <line10> new ServiceProviderSAMLResponseProcessor( <line11> request.getMethod().equals(""POST""), <line12> serviceURL, <line13> this.picketLinkConfiguration, <line14> this.idpMetadata); <line15> if (auditHelper != null) { <line16> responseProcessor.setAuditHelper(auditHelper); <line17> } <line18> responseProcessor.setTrustKeyManager(keyManager); <line19> SAML2HandlerResponse saml2HandlerResponse = <line20> responseProcessor.process(samlResponse, httpContext, handlers, chainLock); <line21> Document samlResponseDocument = saml2HandlerResponse.getResultingDocument(); <line22> String relayState = saml2HandlerResponse.getRelayState(); <line23> String destination = saml2HandlerResponse.getDestination(); <line24> willSendRequest = saml2HandlerResponse.getSendRequest(); <line25> String destinationQueryStringWithSignature = <line26> saml2HandlerResponse.getDestinationQueryStringWithSignature(); <line27> if (destination != null && samlResponseDocument != null) { <line28> sendRequestToIDP( <line29> destination, <line30> samlResponseDocument, <line31> relayState, <line32> request, <line33> response, <line34> willSendRequest, <line35> destinationQueryStringWithSignature); <line36> } else { <line37> boolean sessionValidity = request.getUserPrincipal() != null; <line38> if (!sessionValidity) { <line39> sendToLogoutPage(request, response, session); <line40> return false; <line41> } <line42> List<String> roles = saml2HandlerResponse.getRoles(); <line43> if (principal == null) { <line44> principal = (Principal) session.getAttribute(GeneralConstants.PRINCIPAL_ID); <line45> } <line46> if (principal == null) { <line47> throw new RuntimeException(ErrorCodes.NULL_VALUE + "" principal""); <line48> } <line49> if (isEnableAudit()) { <line50> PicketLinkAuditEvent auditEvent = new PicketLinkAuditEvent(AuditLevel.INFO); <line51> auditEvent.setType(PicketLinkAuditEventType.RESPONSE_FROM_IDP); <line52> auditEvent.setSubjectName(principal.getName()); <line53> auditEvent.setWhoIsAuditing(getContextPath()); <line54> auditHelper.audit(auditEvent); <line55> } <line56> return true; <line57> } <line58> } catch (ProcessingException pe) { <line59> Throwable t = pe.getCause(); <line60> if (t != null && t instanceof AssertionExpiredException) { <line61> logger.error(""Assertion has expired. Asking IDP for reissue""); <line62> if (isEnableAudit()) { <line63> PicketLinkAuditEvent auditEvent = new PicketLinkAuditEvent(AuditLevel.INFO); <line64> auditEvent.setType(PicketLinkAuditEventType.EXPIRED_ASSERTION); <line65> auditEvent.setAssertionID(((AssertionExpiredException) t).getId()); <line66> auditHelper.audit(auditEvent); <line67> } <line68> return generalUserRequest(request, response); <line69> } <line70> logger.samlSPHandleRequestError(pe); <line71> throw logger.samlSPProcessingExceptionError(pe); <line72> } catch (Exception e) { <line73> logger.samlSPHandleRequestError(e); <line74> throw logger.samlSPProcessingExceptionError(e); <line75> } <line76> return localAuthentication(request, response); <line77> } <line78> } <line79> "	No	task1	
"public class A { <line0> public void terminate() { <line1> if (cf != null) { <line2> cf.terminate(); <line3> } <line4> if (channel != null) { <line5> channel.close(); <line6> } <line7> if (listener == null) { <line8> return; <line9> } <line10> logger.debug(""terminate "" + listener); <line11> listener.setDone(); <line12> try { <line13> while (listener.isAlive()) { <line14> listener.interrupt(); <line15> listener.join(100); <line16> } <line17> } catch (InterruptedException u) { <line18> Thread.currentThread().interrupt(); <line19> } <line20> listener = null; <line21> } <line22> } <line23> "	No	task1	
public class A { <line0> private void setObjectType(URI pred, URI type) { <line1> for (Statement st : ds.match(null, pred, null)) { <line2> if (st.getObject() instanceof Resource) { <line3> Resource subj = (Resource) st.getObject(); <line4> ds.add(subj, RDF.TYPE, type); <line5> } else { <line6> } <line7> } <line8> } <line9> } <line10> 	Yes	task1	
"public class A { <line0> public void testInnerJarFilesOnlyFileSerialization() throws Exception { <line1> VirtualFile outerjar = getVirtualFile(""/vfs/test/outer.jar""); <line2> List<Closeable> mounts = recursiveMount(outerjar); <line3> try { <line4> assertTrue(""outer.jar != null"", outerjar != null); <line5> VirtualFile jar1 = outerjar.getChild(""jar1-filesonly.jar""); <line6> assertTrue(""outer.jar/jar1-filesonly.jar != null"", jar1 != null); <line7> VirtualFile jar1MF = jar1.getChild(""META-INF/MANIFEST.MF""); <line8> assertNotNull(""jar1-filesonly!/META-INF/MANIFEST.MF"", jar1MF); <line9> InputStream mfIS = jar1MF.openStream(); <line10> Manifest mf1 = new Manifest(mfIS); <line11> Attributes mainAttrs1 = mf1.getMainAttributes(); <line12> String title1 = mainAttrs1.getValue(Attributes.Name.SPECIFICATION_TITLE); <line13> assertEquals(""jar1-filesonly"", title1); <line14> mfIS.close(); <line15> VirtualFile jar1DS = serializeDeserialize(jar1, VirtualFile.class); <line16> assertNotNull(""jar1 deserialized"", jar1DS); <line17> VirtualFile jar1DSMF = jar1DS.getChild(""META-INF/MANIFEST.MF""); <line18> assertNotNull(""jar1-filesonly!/META-INF/MANIFEST.MF"", jar1DSMF); <line19> mfIS = jar1DSMF.openStream(); <line20> mf1 = new Manifest(mfIS); <line21> mainAttrs1 = mf1.getMainAttributes(); <line22> title1 = mainAttrs1.getValue(Attributes.Name.SPECIFICATION_TITLE); <line23> assertEquals(""jar1-filesonly"", title1); <line24> mfIS.close(); <line25> } finally { <line26> VFSUtils.safeClose(mounts); <line27> } <line28> } <line29> } <line30> "	Yes	task1	
public class A { <line0> private void logAndAdd(String event) { <line1> logger.trace(event); <line2> eventHistory.add(event); <line3> } <line4> } <line5> 	No	task1	
"public class A { <line0> private void initPropsFromResource() { <line1> var resourceProps = new Properties(); <line2> load(BOOTSTRAP_PROPS_RESOURCE, resourceProps); <line3> loadOverride(BOOTSTRAP_OVERRIDE_PROPS_LOC, resourceProps, fileStreamProvider, log); <line4> Set<String> unrecognizedProps = new HashSet<>(resourceProps.stringPropertyNames()); <line5> unrecognizedProps.removeAll(BOOTSTRAP_PROP_NAMES); <line6> if (!unrecognizedProps.isEmpty()) { <line7> var msg = <line8> String.format( <line9> ""'%s' contains unrecognized properties: %s!"", <line10> BOOTSTRAP_PROPS_RESOURCE, unrecognizedProps); <line11> throw new IllegalStateException(msg); <line12> } <line13> var missingProps = <line14> BOOTSTRAP_PROP_NAMES.stream() <line15> .filter(name -> !resourceProps.containsKey(name)) <line16> .sorted() <line17> .collect(toList()); <line18> if (!missingProps.isEmpty()) { <line19> var msg = <line20> String.format(""'%s' is missing properties: %s!"", BOOTSTRAP_PROPS_RESOURCE, missingProps); <line21> throw new IllegalStateException(msg); <line22> } <line23> bootstrapProps = new HashMap<>(); <line24> BOOTSTRAP_PROP_NAMES.stream() <line25> .forEach( <line26> prop -> <line27> bootstrapProps.put( <line28> prop, transformFor(prop).apply(resourceProps.getProperty(prop)))); <line29> var msg = <line30> ""Resolved bootstrap properties:\n  "" <line31> + BOOTSTRAP_PROP_NAMES.stream() <line32> .sorted() <line33> .map(name -> String.format(""%s=%s"", name, bootstrapProps.get(name))) <line34> .collect(Collectors.joining(""\n  "")); <line35> } <line36> } <line37> "	Yes	task1	
"public class A { <line0> @Test <line1> @Override <line2> public void testWarn_Object() throws Exception { <line3> PrintStream stdout = System.out; <line4> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line5> System.setErr(new PrintStream(out)); <line6> SystemOutLoggingTool logger = new SystemOutLoggingTool(this.getClass()); <line7> logger.setDebugEnabled(true); <line8> Assert.assertTrue(out.toString().contains(""WARN"")); <line9> Assert.assertTrue(out.toString().contains(this.getClass().getName())); <line10> System.setErr(stdout); <line11> } <line12> } <line13> "	Yes	task1	
"public class A { <line0> @Override <line1> public boolean hasNext() { <line2> boolean hasNext; <line3> if (itStack.isEmpty()) { <line4> hasNext = directlyUnder.hasNext(); <line5> } else { <line6> hasNext = false; <line7> do { <line8> if (!itStack.peek().iterator().hasNext()) { <line9> try { <line10> itStack.pop().close(); <line11> } catch (IOException e) { <line12> LOGGER.warn(""Error closing file iterable, possible file leak"", e); <line13> } <line14> } else { <line15> hasNext = true; <line16> } <line17> } while (!hasNext && !itStack.isEmpty()); <line18> if (itStack.isEmpty()) { <line19> hasNext = directlyUnder.hasNext(); <line20> } <line21> } <line22> return hasNext; <line23> } <line24> } <line25> "	No	task1	
public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> instance.cleanUp(); <line3> return null; <line4> } <line5> } <line6> 	Yes	task1	
"public class A { <line0> private RegisterResponse registerOpenIdClient() { <line1> logger.info(""Registering OpenId client""); <line2> String clientName = this.appConfiguration.getApplicationName() + "" client""; <line3> RegisterRequest registerRequest = <line4> new RegisterRequest( <line5> ApplicationType.WEB, <line6> clientName, <line7> Arrays.asList(this.appConfiguration.getOpenIdRedirectUrl())); <line8> registerRequest.setRequestObjectSigningAlg(SignatureAlgorithm.RS256); <line9> registerRequest.setTokenEndpointAuthMethod(AuthenticationMethod.CLIENT_SECRET_BASIC); <line10> RegisterClient registerClient = <line11> new RegisterClient(openIdConfiguration.getRegistrationEndpoint()); <line12> registerClient.setRequest(registerRequest); <line13> RegisterResponse response = registerClient.exec(); <line14> if ((response == null) || (response.getStatus() != 200)) { <line15> throw new ConfigurationException(""Failed to register new client""); <line16> } <line17> return response; <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> @NotNull <line1> private List<String> updateImpersonators( <line2> @NotNull Authorizable a, <line3> @NotNull Impersonation imp, <line4> @NotNull Map<String, Principal> toRemove, <line5> @NotNull List<String> toAdd) <line6> throws RepositoryException { <line7> for (Principal p : toRemove.values()) { <line8> if (!imp.revokeImpersonation(p)) { <line9> String principalName = p.getName(); <line10> handleFailure(""Failed to revoke impersonation for "" + principalName + "" on "" + a); <line11> } <line12> } <line13> List<String> nonExisting = new ArrayList<>(); <line14> for (String principalName : toAdd) { <line15> Principal principal = <line16> (principals.containsKey(principalName)) <line17> ? principals.get(principalName) <line18> : new PrincipalImpl(principalName); <line19> if (!imp.grantImpersonation(principal)) { <line20> handleFailure(""Failed to grant impersonation for "" + principalName + "" on "" + a); <line21> if (importBehavior == ImportBehavior.BESTEFFORT <line22> && getPrincipalManager().getPrincipal(principalName) == null) { <line23> log.debug( <line24> ""ImportBehavior.BESTEFFORT: Remember non-existing impersonator for special"" <line25> + "" processing.""); <line26> nonExisting.add(principalName); <line27> } <line28> } <line29> } <line30> return nonExisting; <line31> } <line32> } <line33> "	Yes	task1	
"public class A { <line0> public static String fetchProviderByOrgId(String orgId, RequestContext context) { <line1> try { <line2> if (StringUtils.isNotBlank(orgId)) { <line3> Future<Map<String, Object>> esOrgResF = <line4> esUtil.getDataByIdentifier( <line5> ProjectUtil.EsType.organisation.getTypeName(), orgId, context); <line6> Map<String, Object> org = <line7> (Map<String, Object>) ElasticSearchHelper.getResponseFromFuture(esOrgResF); <line8> if (null != org && !org.isEmpty()) { <line9> return (String) org.get(JsonKey.CHANNEL); <line10> } <line11> } <line12> } catch (Exception ex) { <line13> logger.error(context, ex.getMessage(), ex); <line14> } <line15> return """"; <line16> } <line17> } <line18> "	No	task1	
"public class A { <line0> private void limitFailedBuffersSize() { <line1> if (failedBuffers.size() >= config.getBatchQueueSizeLimit()) { <line2> failedBuffers.removeFirst(); <line3> approximateFailedBuffersCount.decrementAndGet(); <line4> droppedBuffers.incrementAndGet(); <line5> log.error( <line6> ""failedBuffers queue size reached the limit [%d], dropping the oldest failed buffer"", <line7> config.getBatchQueueSizeLimit()); <line8> } <line9> } <line10> } <line11> "	No	task1	
"public class A { <line0> private static long humanReadableSizeToBytes(final String humanReadableSize) <line1> throws HBaseException { <line2> if (humanReadableSize == null) { <line3> return -1; <line4> } <line5> try { <line6> return Long.parseLong(humanReadableSize); <line7> } catch (NumberFormatException ex) { <line8> LOG.debug(""Given size value is not a number, parsing for human readable format""); <line9> } <line10> String tb = null; <line11> String gb = null; <line12> String mb = null; <line13> String kb = null; <line14> String b = null; <line15> String expectedSize = null; <line16> long size = 0; <line17> Matcher matcher = PrettyPrinter.SIZE_PATTERN.matcher(humanReadableSize); <line18> if (matcher.matches()) { <line19> expectedSize = matcher.group(2); <line20> tb = matcher.group(4); <line21> gb = matcher.group(6); <line22> mb = matcher.group(8); <line23> kb = matcher.group(10); <line24> b = matcher.group(12); <line25> } <line26> size += tb != null ? Long.parseLong(tb) * HConstants.TB_IN_BYTES : 0; <line27> size += gb != null ? Long.parseLong(gb) * HConstants.GB_IN_BYTES : 0; <line28> size += mb != null ? Long.parseLong(mb) * HConstants.MB_IN_BYTES : 0; <line29> size += kb != null ? Long.parseLong(kb) * HConstants.KB_IN_BYTES : 0; <line30> size += b != null ? Long.parseLong(b) : 0; <line31> if (expectedSize != null && Long.parseLong(expectedSize) != size) { <line32> throw new HBaseException( <line33> ""Malformed size string: values in byte and human readable"" + ""format do not match""); <line34> } <line35> return size; <line36> } <line37> } <line38> "	No	task1	
"public class A { <line0> public UserGroup deleteUserGroup(final String identifier) { <line1> verifyUserGroupProviderIsConfigurable(); <line2> final Group group = userGroupProvider.getGroup(identifier); <line3> if (group == null) { <line4> LOGGER.warn(""The specified user group id [{}] does not exist."", group.getIdentifier()); <line5> throw new ResourceNotFoundException( <line6> ""The specified user group ID does not exist in this registry.""); <line7> } <line8> configurableUserGroupProvider().deleteGroup(group); <line9> return userGroupToDTO(group); <line10> } <line11> } <line12> "	No	task1	
public class A { <line0> @Override <line1> public void after(Object target, Object[] args, Object result, Throwable throwable) { <line2> if (isDebug) { <line3> logger.afterInterceptor(target, args, result, throwable); <line4> } <line5> try { <line6> if (Boolean.FALSE == isReceived(args)) { <line7> return; <line8> } <line9> final HttpServerRequest request = (HttpServerRequest) args[0]; <line10> final HttpServerResponse response = (HttpServerResponse) args[0]; <line11> final int statusCode = getStatusCode(response); <line12> this.servletRequestListener.destroyed(request, throwable, statusCode); <line13> } catch (Throwable t) { <line14> if (isInfo) { <line15> } <line16> } <line17> } <line18> } <line19> 	Yes	task1	
public class A { <line0> @Override <line1> public ChangesetCollection findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchCollectionException { <line3> ChangesetCollection changesetCollection = fetchByPrimaryKey(primaryKey); <line4> if (changesetCollection == null) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchCollectionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return changesetCollection; <line10> } <line11> } <line12> 	Yes	task1	
"public class A { <line0> private static <T> Builder<T> newBuilder(Class<T> c) { <line1> if (c.isPrimitive()) <line2> throw new RuntimeException(""Can not create builder for primitive type: "" + c); <line3> Builder<?> builder; <line4> if (c.isArray()) builder = newArrayBuilder(c); <line5> else builder = newObjectBuilder(c); <line6> return (Builder<T>) builder; <line7> } <line8> } <line9> "	Yes	task1	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void run() { <line3> while (!stopped.get() && !Thread.currentThread().isInterrupted()) { <line4> try { <line5> Thread.sleep(1000); <line6> } catch (InterruptedException e) { <line7> } <line8> if (context.getWorkerManager() != null) { <line9> context.getWorkerManager().checkHBTimeOut(); <line10> } <line11> if (context.getParameterServerManager() != null) { <line12> context.getParameterServerManager().checkHBTimeOut(); <line13> } <line14> if (context.getClientManager() != null) { <line15> context.getClientManager().checkHBTimeOut(); <line16> } <line17> if (context.getPSAgentManager() != null) { <line18> context.getPSAgentManager().checkHBTimeOut(); <line19> } <line20> } <line21> } <line22> } <line23> "	Yes	task1	
"public class A { <line0> @Override <line1> public Optional<QuizSubmission> completeQuizSubmission(CompleteQuizSubmissionOptions options) <line2> throws IOException { <line3> LOG.debug( <line4> ""completing quiz submission for user/course/quiz: "" <line5> + masqueradeAs <line6> + ""/"" <line7> + options.getCourseId() <line8> + ""/"" <line9> + options.getQuizId()); <line10> String url = <line11> buildCanvasUrl( <line12> ""courses/"" <line13> + options.getCourseId() <line14> + ""/quizzes/"" <line15> + options.getQuizId() <line16> + ""/submissions/"" <line17> + options.getSubmissionId() <line18> + ""/complete"", <line19> options.getOptionsMap()); <line20> Response response = canvasMessenger.sendToCanvas(oauthToken, url, Collections.emptyMap()); <line21> return Optional.of(parseQuizSubmissionResponse(response).getQuizSubmissions().get(0)); <line22> } <line23> } <line24> "	Yes	task1	
"public class A { <line0> private String resolveSchema(ResultSet result) { <line1> String schema = null; <line2> try { <line3> schema = result.getString(""TABLE_SCHEM""); <line4> if (schema == null) { <line5> schema = dbUnitConfig.getSchema(); <line6> } <line7> } catch (Exception e) { <line8> schema = dbUnitConfig.getSchema(); <line9> } <line10> return schema; <line11> } <line12> } <line13> "	Yes	task1	
"public class A { <line0> @Test <line1> public void testIncludeRegexAnyField() throws Exception { <line2> log.info(""------  testIncludeRegexAnyField  ------""); <line3> String usa = ""'usa'""; <line4> String anyRegex = this.dataManager.convertAnyField(RE_OP + usa); <line5> for (final TestCities city : TestCities.values()) { <line6> String query = <line7> CityField.CITY.name() <line8> + EQ_OP <line9> + ""'"" <line10> + city.name() <line11> + ""'"" <line12> + AND_OP <line13> + IncludeRegex <line14> + Constants.ANY_FIELD <line15> + "","" <line16> + usa <line17> + "")""; <line18> String expectQuery = <line19> CityField.CITY.name() + EQ_OP + ""'"" + city.name() + ""'"" + AND_OP + anyRegex; <line20> runTest(query, expectQuery); <line21> } <line22> } <line23> } <line24> "	No	task1	
"public class A { <line0> private void reindexItemsInContainer(String containerUri) { <line1> ElasticIndexer indexer = new ElasticIndexer(index, ElasticTypes.items, analyser); <line2> ItemController controller = new ItemController(); <line3> try { <line4> List<Item> items = <line5> controller.searchAndRetrieve( <line6> new URI(containerUri), (SearchQuery) null, null, Imeji.adminUser, null, -1, -1); <line7> indexer.indexBatch(items); <line8> } catch (Exception e) { <line9> LOGGER.error(""There has been an error during reindexing of items in a container! "", e); <line10> } <line11> } <line12> } <line13> "	No	task1	
"public class A { <line0> @Override <line1> protected void onActivate(Optional<Object> message) { <line2> WonMessage connectMessage = <line3> WonMessageBuilder.connect() <line4> .sockets() <line5> .sender(URI.create(atomUri3.toString() + ""#holderSocket"")) <line6> .recipient(URI.create(atomUri1.toString() + ""#holdableSocket"")) <line7> .direction() <line8> .fromOwner() <line9> .build(); <line10> connectMessage = ctx.getWonMessageSender().prepareMessage(connectMessage); <line11> EventListener successCallback = <line12> event -> { <line13> deactivate(); <line14> }; <line15> EventListener failureCallback = <line16> makeFailureCallbackToFailTest(bot, ctx, bus, ""Requesting connection holder B -> holdable""); <line17> EventBotActionUtils.makeAndSubscribeResponseListener( <line18> connectMessage, successCallback, failureCallback, ctx); <line19> ctx.getWonMessageSender().sendMessage(connectMessage); <line20> } <line21> } <line22> "	Yes	task1	
"public class A { <line0> private void discoverMeteringServers() { <line1> logger.debug(""SEP Extension: SEP discovery searching for Metering servers""); <line2> discoverServices( <line3> ZigBeeBroadcastDestination.BROADCAST_RX_ON.getKey(), ZclMeteringCluster.CLUSTER_ID); <line4> } <line5> } <line6> "	No	task1	
"public class A { <line0> public Set<String> getReadOnlyJavaNames(Class<?> type, SecurityContext securityContext) { <line1> final Set<String> readonlyJavaNames = new HashSet<String>(); <line2> try { <line3> BeanMetaData beanMetaData = metaData.getBeanMetaData(type); <line4> for (PropertyBinding propBinding : beanMetaData.getProperties()) { <line5> if (!securityContext.getAttributeWritePriviledge(propBinding.getDetypedName()).isGranted() <line6> && !propBinding.isKey()) readonlyJavaNames.add(propBinding.getJavaName()); <line7> } <line8> } catch (Exception e) { <line9> Log.warn(""No meta data for "" + type); <line10> } <line11> return readonlyJavaNames; <line12> } <line13> } <line14> "	No	task1	
public class A { <line0> @Override <line1> public void addConnectionStatusListener(ConnectionStatusListener listener) { <line2> } <line3> } <line4> 	Yes	task1	
"public class A { <line0> private synchronized void submitFlushTask() { <line1> counter.set(0); <line2> latestFlushTime = System.currentTimeMillis(); <line3> final Snapshot<MessageCheckpoint> snapshot = <line4> checkpointManager.createMessageCheckpointSnapshot(); <line5> flushExecutor.submit( <line6> () -> { <line7> final long start = System.currentTimeMillis(); <line8> try { <line9> consumerLogManager.flush(); <line10> checkpointManager.saveMessageCheckpointSnapshot(snapshot); <line11> } catch (Exception e) { <line12> QMon.consumerLogFlusherFlushFailedCountInc(); <line13> LOG.error(""flush consumer log failed. offset: {}"", snapshot.getVersion(), e); <line14> } finally { <line15> QMon.consumerLogFlusherElapsedPerExecute(System.currentTimeMillis() - start); <line16> } <line17> }); <line18> } <line19> } <line20> "	No	task1	
"public class A { <line0> @Override <line1> public void run(TransformContext context, GtfsMutableRelationalDao dao) { <line2> int stop_count = 0; <line3> int route_count = 0; <line4> for (Stop stop : dao.getAllStops()) { <line5> stop.setRegionalFareCardAccepted(1); <line6> stop_count++; <line7> } <line8> for (Route route : dao.getAllRoutes()) { <line9> route.setRegionalFareCardAccepted(1); <line10> route_count++; <line11> } <line12> log.info(""Set {} stops and {} routes to omny_enabled Y"", stop_count, route_count); <line13> } <line14> } <line15> "	No	task1	
"public class A { <line0> @Test <line1> public void testBackupQueueCleanupServerQuery() throws Exception { <line2> Ignite qryClient = startGridsMultiThreaded(2); <line3> CacheEventListener1 lsnr = new CacheEventListener1(false); <line4> ContinuousQuery<Object, Object> qry = new ContinuousQuery<>(); <line5> qry.setLocalListener(lsnr); <line6> IgniteCache<Object, Object> cache = qryClient.cache(DEFAULT_CACHE_NAME); <line7> QueryCursor<?> cur = cache.query(qry); <line8> assertEquals(0, backupQueue(ignite(1)).size()); <line9> List<Integer> keys = primaryKeys(cache, BACKUP_ACK_THRESHOLD); <line10> CountDownLatch latch = new CountDownLatch(keys.size()); <line11> lsnr.latch = latch; <line12> for (Integer key : keys) { <line13> log.info(""Put: "" + key); <line14> cache.put(key, key); <line15> } <line16> GridTestUtils.waitForCondition( <line17> new GridAbsPredicate() { <line18> @Override <line19> public boolean apply() { <line20> return backupQueue(ignite(1)).isEmpty(); <line21> } <line22> }, <line23> 5000); <line24> assertTrue( <line25> ""Backup queue is not cleared: "" + backupQueue(ignite(1)), <line26> backupQueue(ignite(1)).size() < BACKUP_ACK_THRESHOLD); <line27> if (!latch.await(5, SECONDS)) <line28> fail( <line29> ""Failed to wait for notifications [exp="" <line30> + keys.size() <line31> + "", left="" <line32> + lsnr.latch.getCount() <line33> + ']'); <line34> cur.close(); <line35> } <line36> } <line37> "	No	task1	
"public class A { <line0> @Override <line1> public long getSize(Configuration configuration) { <line2> if (view instanceof SizeAccessor) { <line3> return ((SizeAccessor) view).getSize(); <line4> } <line5> LOG.warn(""Cannot determine size for view: "" + toString()); <line6> return 1000L * 1000L * 1000L; <line7> } <line8> } <line9> "	No	task1	
"public class A { <line0> void stop() { <line1> LOGGER.info(""Nar provider task is stopped""); <line2> stopped = true; <line3> } <line4> } <line5> "	No	task1	
"public class A { <line0> public void checkDatabaseConnection(ConfigurationHolder configHolder) <line1> throws ConfigurationException, DatabaseDriverException, SQLException { <line2> String databaseTemplate = configHolder.getIncludedDBTemplateName(); <line3> String dbName = configHolder.getProperty(PARAM_DB_NAME); <line4> String dbUser = configHolder.getProperty(PARAM_DB_USER); <line5> String dbPassword = configHolder.getProperty(PARAM_DB_PWD); <line6> String dbHost = configHolder.getProperty(PARAM_DB_HOST); <line7> String dbPort = configHolder.getProperty(PARAM_DB_PORT); <line8> Path databaseTemplateDir = configHolder.getTemplatesPath().resolve(databaseTemplate); <line9> String classname = configHolder.getProperty(PARAM_DB_DRIVER); <line10> String connectionUrl = configHolder.getProperty(PARAM_DB_JDBC_URL); <line11> Driver driver = lookupDriver(configHolder, databaseTemplateDir, classname); <line12> DriverManager.registerDriver(driver); <line13> Properties ttProps = new Properties(); <line14> ttProps.put(PARAM_DB_HOST, dbHost); <line15> ttProps.put(PARAM_DB_PORT, dbPort); <line16> ttProps.put(PARAM_DB_NAME, dbName); <line17> ttProps.put(PARAM_DB_USER, dbUser); <line18> ttProps.put(PARAM_DB_PWD, dbPassword); <line19> TextTemplate tt = new TextTemplate(ttProps); <line20> String url = tt.processText(connectionUrl); <line21> Properties conProps = new Properties(); <line22> conProps.put(""user"", dbUser); <line23> conProps.put(""password"", dbPassword); <line24> Connection con = driver.connect(url, conProps); <line25> con.close(); <line26> } <line27> } <line28> "	Yes	task1	
public class A { <line0> @Override <line1> public Iterable<Path> files() throws IOException { <line2> try (Stream<Path> stream = Files.walk(this.dir)) { <line3> final List<Path> files = stream.collect(Collectors.toList()); <line4> return files; <line5> } <line6> } <line7> } <line8> 	Yes	task1	
"public class A { <line0> void closeCompactor(boolean isPrepare) { <line1> if (this.oplogCompactor == null) { <line2> return; <line3> } <line4> if (isPrepare) { <line5> acquireCompactorWriteLock(); <line6> } <line7> try { <line8> synchronized (this.lock) { <line9> try { <line10> this.oplogCompactor.stopCompactor(); <line11> } catch (CancelException ignore) { <line12> } catch (RuntimeException e) { <line13> logger.warn(""DiskRegion::close: Exception in stopping compactor"", e); <line14> throw e; <line15> } <line16> } <line17> } finally { <line18> if (isPrepare) { <line19> releaseCompactorWriteLock(); <line20> } <line21> } <line22> } <line23> } <line24> "	No	task1	
"public class A { <line0> public void setEffectiveAuthentication(Authentication effictiveAuthentication) { <line1> if (logger.isTraceEnabled()) { <line2> logger.trace( <line3> ""Setting effective authentication to: "" <line4> + AuthenticationUtil.getMaskedUsername(effictiveAuthentication)); <line5> } <line6> this.effectiveAuthentication = effictiveAuthentication; <line7> } <line8> } <line9> "	Yes	task1	
"public class A { <line0> public void testInitialContext() throws Exception { <line1> InitialContext context = new InitialContext(); <line2> ActiveMQConnectionFactory connectionFactory = <line3> (ActiveMQConnectionFactory) context.lookup(""ConnectionFactory""); <line4> assertTrue(""Should have created a ConnectionFactory"", connectionFactory != null); <line5> } <line6> } <line7> "	Yes	task1	
public class A { <line0> public Insertions execute() throws IOException { <line1> int retryCount = 0; <line2> PreparedStatement preparedStatement = <line3> getPreparedStatement(Optional.of(Statement.RETURN_GENERATED_KEYS)); <line4> while (true) { <line5> try { <line6> return InsertionFetcher.getCreationResults(preparedStatement, rowCount, dbConnection); <line7> } catch (SQLRecoverableException e) { <line8> LOG.error(e.toString()); <line9> if (++retryCount > MAX_CONNECTION_RETRIES) { <line10> throw new IOException(e); <line11> } <line12> } catch (SQLException e) { <line13> throw new IOException(e); <line14> } <line15> } <line16> } <line17> } <line18> 	No	task1	
public class A { <line0> protected void initializeDataSources() { <line1> validateSuppliedReference(); <line2> setReferenceDataSource(argCollection.referenceFile); <line3> validateSuppliedReads(); <line4> initializeReadTransformers(walker); <line5> final Map<String, String> sampleRenameMap = <line6> argCollection.sampleRenameMappingFile != null <line7> ? loadSampleRenameMap(argCollection.sampleRenameMappingFile) <line8> : null; <line9> readsDataSource = <line10> createReadsDataSource( <line11> argCollection, genomeLocParser, referenceDataSource.getReference(), sampleRenameMap); <line12> for (ReadFilter filter : filters) filter.initialize(this); <line13> rodDataSources = <line14> getReferenceOrderedDataSources( <line15> referenceMetaDataFiles, <line16> referenceDataSource.getReference().getSequenceDictionary(), <line17> genomeLocParser, <line18> argCollection.unsafe, <line19> sampleRenameMap); <line20> } <line21> } <line22> 	Yes	task1	
public class A { <line0> @OperationMethod <line1> public Blob run() throws IOException { <line2> boolean canMove = false; <line3> try { <line4> FileSystemItemManager fileSystemItemManager = <line5> Framework.getService(FileSystemItemManager.class); <line6> canMove = fileSystemItemManager.canMove(srcId, destId, ctx.getPrincipal()); <line7> } catch (RootlessItemException e) { <line8> } <line9> return Blobs.createJSONBlobFromValue(canMove); <line10> } <line11> } <line12> 	Yes	task1	
public class A { <line0> public static String search( <line1> long groupId, String name, String[] categoryProperties, int start, int end) <line2> throws RemoteException { <line3> try { <line4> com.liferay.portal.kernel.json.JSONArray returnValue = <line5> AssetCategoryServiceUtil.search(groupId, name, categoryProperties, start, end); <line6> return returnValue.toString(); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	Yes	task1	
public class A { <line0> @Override <line1> public List<String> getServices() { <line2> try { <line3> return serviceDiscovery.getServices(); <line4> } catch (Exception e) { <line5> return Collections.emptyList(); <line6> } <line7> } <line8> } <line9> 	Yes	task1	
"public class A { <line0> @Override <line1> public void blanketApprove( <line2> WorkflowDocument workflowDocument, <line3> String annotation, <line4> List<AdHocRouteRecipient> adHocRecipients) <line5> throws WorkflowException { <line6> if (LOG.isDebugEnabled()) { <line7> LOG.debug( <line8> ""blanket approving document("" <line9> + workflowDocument.getDocumentId() <line10> + "",'"" <line11> + annotation <line12> + ""')""); <line13> } <line14> handleAdHocRouteRequests( <line15> workflowDocument, <line16> annotation, <line17> filterAdHocRecipients( <line18> adHocRecipients, <line19> new String[] { <line20> KewApiConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ, KewApiConstants.ACTION_REQUEST_FYI_REQ <line21> })); <line22> workflowDocument.blanketApprove(annotation); <line23> } <line24> } <line25> "	Yes	task1	
"public class A { <line0> @Override <line1> public boolean load(Element shared, Element perNode) { <line2> boolean result = true; <line3> String className = shared.getAttribute(""name"").getValue(); <line4> PerformActionModel model = new PerformActionModel(); <line5> model.setClassName(className); <line6> shared <line7> .getChildren(""property"") <line8> .forEach( <line9> child -> { <line10> String value = child.getAttributeValue(""value""); <line11> if (child.getAttributeValue(""name"").equals(""systemPrefix"") && value != null) { <line12> try { <line13> Class<?> ac = Class.forName(className); <line14> if (value.isEmpty() && SystemConnectionAction.class.isAssignableFrom(ac)) { <line15> SystemConnectionAction<?> a = <line16> (SystemConnectionAction<?>) ac.getConstructor().newInstance(); <line17> InstanceManager.getList(SystemConnectionMemo.class) <line18> .forEach( <line19> memo -> <line20> a.getSystemConnectionMemoClasses().stream() <line21> .filter(mc -> memo.getClass().isAssignableFrom(mc)) <line22> .forEach(mc -> model.setSystemPrefix(memo.getSystemPrefix()))); <line23> } else { <line24> model.setSystemPrefix(value); <line25> } <line26> } catch (ClassNotFoundException <line27> | InstantiationException <line28> | IllegalAccessException <line29> | IllegalArgumentException <line30> | InvocationTargetException <line31> | NoSuchMethodException <line32> | SecurityException ex) { <line33> log.warn(""While trying to do {}, encountered exception"", className, ex); <line34> } <line35> } <line36> }); <line37> InstanceManager.getDefault(StartupActionsManager.class).addAction(model); <line38> return result; <line39> } <line40> } <line41> "	No	task1	
"public class A { <line0> @Override <line1> @SecurityCheck <line2> public GatewayGroups getGatewayGroups(AuthzToken authzToken) <line3> throws InvalidRequestException, AiravataClientException, AiravataSystemException, <line4> AuthorizationException, TException { <line5> String gatewayId = authzToken.getClaimsMap().get(Constants.GATEWAY_ID); <line6> RegistryService.Client regClient = registryClientPool.getResource(); <line7> try { <line8> GatewayGroups gatewayGroups = retrieveGatewayGroups(regClient, gatewayId); <line9> registryClientPool.returnResource(regClient); <line10> return gatewayGroups; <line11> } catch (Exception e) { <line12> String msg = ""Error retrieving GatewayGroups for gateway: "" + gatewayId; <line13> AiravataSystemException exception = <line14> new AiravataSystemException(AiravataErrorType.INTERNAL_ERROR); <line15> exception.setMessage(msg + "" More info : "" + e.getMessage()); <line16> registryClientPool.returnBrokenResource(regClient); <line17> throw exception; <line18> } <line19> } <line20> } <line21> "	Yes	task1	
"public class A { <line0> public Page<PushablePackageDto> queryAllPullablePackagesV2( <line1> int limit, int offset, String appName, String sortType, String sortItem) { <line2> return pushablePackageRepository.queryAllPushablePackagesV2( <line3> limit, offset, appName, sortType, sortItem, ""pull""); <line4> } <line5> } <line6> "	Yes	task1	
"public class A { <line0> protected static ActorSystem getActorSystem(String host, String port) { <line1> if (null == system) { <line2> Config conf; <line3> if (""remote"".equals(getMode())) { <line4> Config remote = getRemoteConfig(host, port); <line5> conf = remote.withFallback(config.getConfig(name)); <line6> } else { <line7> conf = config.getConfig(name); <line8> } <line9> system = ActorSystem.create(name, conf); <line10> } <line11> return system; <line12> } <line13> } <line14> "	Yes	task1	
"public class A { <line0> @Override <line1> public RepeatStatus executeStep( <line2> ChunkContext chunkContext, JobExecutionStatusHolder jobExecutionStatusHolder) <line3> throws Exception { <line4> String clusterName = <line5> getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM); <line6> if (clusterName == null) { <line7> clusterName = <line8> getJobParameters(chunkContext) <line9> .getString(JobConstants.TARGET_NAME_JOB_PARAM) <line10> .split(""-"")[0]; <line11> } <line12> String nodeName = getJobParameters(chunkContext).getString(JobConstants.SUB_JOB_NODE_NAME); <line13> NodeEntity node = getClusterEntityMgr().findNodeByName(nodeName); <line14> getClusterEntityMgr().syncUpNode(clusterName, nodeName); <line15> Boolean success = <line16> getFromJobExecutionContext( <line17> chunkContext, JobConstants.NODE_OPERATION_SUCCESS, Boolean.class); <line18> if (success != null && !success) { <line19> throw ClusteringServiceException.CLUSTER_OPERATION_FAILED(clusterName); <line20> } <line21> NodeStatus expectedStatus = <line22> getFromJobExecutionContext( <line23> chunkContext, JobConstants.EXPECTED_NODE_STATUS, NodeStatus.class); <line24> if (expectedStatus != null) { <line25> logger.info(""the node should be in status "" + expectedStatus); <line26> JobUtils.verifyNodeStatus(node, expectedStatus, true, getClusterEntityMgr()); <line27> } <line28> String cpuNumberStr = <line29> getJobParameters(chunkContext).getString(JobConstants.NODE_SCALE_CPU_NUMBER); <line30> String memorySizeStr = <line31> getJobParameters(chunkContext).getString(JobConstants.NODE_SCALE_MEMORY_SIZE); <line32> int cpuNumber = 0; <line33> if (cpuNumberStr != null) { <line34> cpuNumber = Integer.parseInt(cpuNumberStr); <line35> } <line36> boolean rollback = <line37> getFromJobExecutionContext(chunkContext, JobConstants.NODE_SCALE_ROLLBACK, Boolean.class); <line38> long memory = 0; <line39> if (memorySizeStr != null) { <line40> memory = Long.parseLong(memorySizeStr); <line41> } <line42> if (cpuNumber > 0 && !rollback) { <line43> node.setCpuNum(cpuNumber); <line44> } <line45> if (memory > 0) { <line46> if (!rollback) { <line47> node.setMemorySize(memory); <line48> } <line49> scaleService.updateSwapDisk(nodeName); <line50> } <line51> getClusterEntityMgr().update(node); <line52> return RepeatStatus.FINISHED; <line53> } <line54> } <line55> "	No	task1	
"public class A { <line0> private void cleanupCredentials(String endpointUrl) throws IOException { <line1> logger.info( <line2> ""Calling cleanupCredentials to remove the credentials we used with Bitbucket server""); <line3> String serverId = DigestUtils.sha256Hex(endpointUrl); <line4> String credentialId = ""bitbucket-server:"" + serverId; <line5> jenkins.deleteUserDomainCredential( <line6> jenkinsUser.username, ""blueocean-bitbucket-server-domain"", credentialId); <line7> } <line8> } <line9> "	Yes	task1	
public class A { <line0> private Future<CommandClient> getOrCreateCommandClient( <line1> final String tenantId, final String replyId, final String cacheKey) { <line2> return connection.executeOnContext( <line3> result -> { <line4> commandClientFactory.getOrCreateClient( <line5> cacheKey, <line6> () -> <line7> CommandClientImpl.create( <line8> connection, <line9> tenantId, <line10> replyId, <line11> samplerFactory.create(CommandConstants.COMMAND_ENDPOINT), <line12> s -> removeCommandClient(cacheKey), <line13> s -> removeCommandClient(cacheKey)), <line14> result); <line15> }); <line16> } <line17> } <line18> 	Yes	task1	
"public class A { <line0> @Override <line1> public boolean process(Exchange exchange, AsyncCallback callback) { <line2> SalesforceEndpoint endpoint = (SalesforceEndpoint) getEndpoint(); <line3> SalesforceSession session = endpoint.getComponent().getSession(); <line4> if (session != null && session.getAccessToken() == null) { <line5> try { <line6> session.login(null); <line7> } catch (SalesforceException e) { <line8> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line9> } <line10> } <line11> LOG.debug(""Processing {}"", endpoint.getOperationName()); <line12> return processor.process(exchange, callback); <line13> } <line14> } <line15> "	No	task1	
public class A { <line0> public void debug(String message, Throwable t) { <line1> } <line2> } <line3> 	Yes	task1	
public class A { <line0> protected boolean authenticate( <line1> ContainerRequestContext requestContext, @Nullable C credentials, String scheme) { <line2> try { <line3> if (credentials == null) { <line4> return false; <line5> } <line6> final Optional<P> principal = authenticator.authenticate(credentials); <line7> if (!principal.isPresent()) { <line8> return false; <line9> } <line10> final P prince = principal.get(); <line11> final SecurityContext securityContext = requestContext.getSecurityContext(); <line12> final boolean secure = securityContext != null && securityContext.isSecure(); <line13> requestContext.setSecurityContext( <line14> new SecurityContext() { <line15> @Override <line16> public Principal getUserPrincipal() { <line17> return prince; <line18> } <line19> @Override <line20> public boolean isUserInRole(String role) { <line21> return authorizer.authorize(prince, role, requestContext); <line22> } <line23> @Override <line24> public boolean isSecure() { <line25> return secure; <line26> } <line27> @Override <line28> public String getAuthenticationScheme() { <line29> return scheme; <line30> } <line31> }); <line32> return true; <line33> } catch (AuthenticationException e) { <line34> throw new InternalServerErrorException(); <line35> } <line36> } <line37> } <line38> 	Yes	task1	
"public class A { <line0> @Override <line1> public synchronized void changeToParentDirectory() throws GenericFileOperationFailedException { <line2> String current = getCurrentDirectory(); <line3> String parent = FileUtil.compactPath(current + ""/..""); <line4> if (!parent.startsWith(""/"")) { <line5> parent = ""/"" + parent; <line6> } <line7> changeCurrentDirectory(parent); <line8> } <line9> } <line10> "	Yes	task1	
"public class A { <line0> @Override <line1> public Functionality find(Account actor, String domainId, String functionalityId, boolean tree) <line2> throws BusinessException { <line3> Validate.notEmpty(domainId); <line4> Validate.notEmpty(functionalityId); <line5> Validate.notNull(actor); <line6> Validate.isTrue(actor.hasAdminRole() || actor.hasSuperAdminRole()); <line7> AbstractDomain domain = getDomain(actor, domainId); <line8> Functionality entity = businessService.getFunctionality(domain, functionalityId); <line9> Set<Functionality> functionalities = businessService.getAllFunctionalities(domain, excludes); <line10> for (Functionality f : functionalities) { <line11> if (f.isParam()) { <line12> if (f.getParentIdentifier().equals(functionalityId)) { <line13> if (f.isDisplayable()) { <line14> entity.setDisplayable(true); <line15> if (tree) { <line16> entity.addChild(f); <line17> } <line18> } <line19> } <line20> } <line21> } <line22> if (!entity.isDisplayable()) { <line23> throw new BusinessException( <line24> BusinessErrorCode.FUNCTIONALITY_NOT_FOUND, <line25> ""Functionality not found : "" + functionalityId); <line26> } <line27> return entity; <line28> } <line29> } <line30> "	Yes	task1	
"public class A { <line0> @Override <line1> public void initialize() { <line2> config = getConfigAs(WLedConfiguration.class); <line3> if (!config.address.contains(""://"")) { <line4> logger.debug( <line5> ""Address was not entered in correct format, it may be the raw IP so adding http:// to"" <line6> + "" start""); <line7> config.address = ""http://"" + config.address; <line8> } <line9> pollingFuture = <line10> scheduler.scheduleWithFixedDelay(this::pollLED, 1, config.pollTime, TimeUnit.SECONDS); <line11> } <line12> } <line13> "	No	task1	
public class A { <line0> @PreDestroy <line1> public void tearDown() { <line2> for (Entry<String, Map<Priority, AccumuloClientPool>> entry : this.pools.entrySet()) { <line3> for (Entry<Priority, AccumuloClientPool> poolEntry : entry.getValue().entrySet()) { <line4> try { <line5> poolEntry.getValue().close(); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> } <line12> 	Yes	task1	
"public class A { <line0> @Bean <line1> public MarshallingPayloadMethodProcessor <line2> microgridsAdHocManagementMarshallingPayloadMethodProcessor() { <line3> LOGGER.debug( <line4> ""Creating Public Lighting Ad Hoc Management Marshalling Payload Method Processor Bean""); <line5> return new MarshallingPayloadMethodProcessor( <line6> this.microgridsAdHocManagementMarshaller(), this.microgridsAdHocManagementMarshaller()); <line7> } <line8> } <line9> "	No	task1	
"<CODE> public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> public T call(Entity entity, Map parameters) { <line2> Object[] parametersArray = EffectorUtils.prepareArgsForEffector(this, parameters); <line3> if (entity instanceof AbstractEntity) { <line4> return EffectorUtils.invokeMethodEffector(entity, this, parametersArray); <line5> } else { <line6> Method[] methods = entity.getClass().getMethods(); <line7> for (Method method : methods) { <line8> if (method.getName().equals(getName())) { <line9> if (parametersArray.length == method.getParameterTypes().length) { <line10> try { <line11> return (T) method.invoke(entity, parametersArray); <line12> } catch (Exception e) { <line13> throw Exceptions.propagate(e); <line14> } <line15> } <line16> } <line17> } <line18> String msg = <line19> ""Could not find method for effector "" <line20> + getName() <line21> + "" with "" <line22> + parametersArray.length <line23> + "" parameters on "" <line24> + entity; <line25> throw new IllegalStateException(msg); <line26> } <line27> } <line28> } <line29>  <LINE> <line25>"	Yes	task2	
"<CODE> public class A { <line0> private ResponseData createResponseDataRecord( <line1> final Map<String, String> settings, final ResponseDataRepository responseDataRepository) { <line2> ResponseData responseData = new ResponseDataBuilder().fromSettings(settings).build(); <line3> responseData = responseDataRepository.save(responseData); <line4> ScenarioContext.current() <line5> .put(PlatformKeys.KEY_CORRELATION_UID, responseData.getCorrelationUid()); <line6> try { <line7> if (settings.containsKey(PlatformKeys.KEY_CREATION_TIME)) { <line8> final Field fld = responseData.getClass().getSuperclass().getDeclaredField(""creationTime""); <line9> fld.setAccessible(true); <line10> fld.set( <line11> responseData, <line12> DateTimeHelper.getDateTime(settings.get(PlatformKeys.KEY_CREATION_TIME)).toDate()); <line13> responseDataRepository.saveAndFlush(responseData); <line14> } <line15> } catch (final Exception e) { <line16> Assertions.fail(""Failed to create response data record.""); <line17> } <line18> return responseData; <line19> } <line20> } <line21>  <LINE> <line16>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> @SuppressFBWarnings(""BC_UNCONFIRMED_CAST_OF_RETURN_VALUE"") <line2> protected NetconfServerSession getSession( <line3> NetconfServerSessionListener sessionListener, Channel channel, NetconfHelloMessage message) { <line4> Optional<NetconfHelloMessageAdditionalHeader> additionalHeader = message.getAdditionalHeader(); <line5> NetconfHelloMessageAdditionalHeader parsedHeader; <line6> if (additionalHeader.isPresent()) { <line7> parsedHeader = additionalHeader.get(); <line8> } else { <line9> parsedHeader = <line10> new NetconfHelloMessageAdditionalHeader( <line11> UNKNOWN, <line12> getHostName(channel.localAddress()).getValue(), <line13> getHostName(channel.localAddress()).getKey(), <line14> ""tcp"", <line15> ""client""); <line16> } <line17> return new NetconfServerSession( <line18> sessionListener, channel, getSessionPreferences().getSessionId(), parsedHeader); <line19> } <line20> } <line21>  <LINE> <line17>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void onServiceSubscribed(@Nullable String service, boolean succeeded) { <line2> if (!succeeded) { <line3> upnpSubscribed = false; <line4> updateStatus( <line5> ThingStatus.OFFLINE, <line6> ThingStatusDetail.COMMUNICATION_ERROR, <line7> ""Could not subscribe to service "" + service + ""for"" + thing.getLabel()); <line8> } <line9> } <line10> } <line11>  <LINE> <line6>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void consume() throws InterruptedException { <line2> DirtyDataEntity dataEntity = queue.take(); <line3> count.incrementAndGet(); <line4> if (count.get() % printLimit == 0) { <line5> } <line6> } <line7> } <line8>  <LINE> <line5>	Yes	task2	
<CODE> public class A { <line0> void addIndexMapping(RegionEntry entry, IndexProtocol index) { <line1> try { <line2> index.addIndexMapping(entry); <line3> } catch (Exception exception) { <line4> index.markValid(false); <line5> setPRIndexAsInvalid((AbstractIndex) index); <line6> } <line7> } <line8> } <line9>  <LINE> <line1>	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void testGetUserInfo() throws Exception { <line2> final com.box.sdk.BoxUser.Info result = requestBody(""direct://GETUSERINFO"", testUser.getID()); <line3> assertNotNull(result, ""getUserInfo result""); <line4> } <line5> } <line6>  <LINE> <line1>"	No	task2	
<CODE> public class A { <line0> public void generateXls(OutputStream out) { <line1> long start = System.currentTimeMillis(); <line2> Workbook wb = new XSSFWorkbook(); <line3> CellStyle titleCellStyle = wb.createCellStyle(); <line4> titleCellStyle.setAlignment(HorizontalAlignment.CENTER); <line5> createSheets(wb, titleCellStyle); <line6> try { <line7> wb.write(out); <line8> } catch (IOException e) { <line9> throw new UncheckedIOException(e); <line10> } <line11> } <line12> } <line13>  <LINE> <line11>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public synchronized void close() throws IOException { <line2> if (closed) { <line3> return; <line4> } <line5> closed = true; <line6> if (connectionFactory != null) { <line7> connectionFactory.shutdown(); <line8> connectionFactory = null; <line9> } <line10> if (zkServer != null) { <line11> zkServer.shutdown(); <line12> zkServer = null; <line13> } <line14> if (transactionLog != null) { <line15> transactionLog.close(); <line16> transactionLog = null; <line17> } <line18> if (purgeManager != null) { <line19> purgeManager.shutdown(); <line20> purgeManager = null; <line21> } <line22> if (dataDir != null) { <line23> IOUtils.deleteRecursively(dataDir); <line24> dataDir = null; <line25> } <line26> } <line27> } <line28>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected List<String> assertReceivedObjectMessageWithListBody(Message message) <line2> throws JMSException { <line3> assertNotNull(""Should have received a message!"", message); <line4> assertEquals(""foo header"", ""abc"", message.getStringProperty(""foo"")); <line5> assertTrue(""Should be an object message but was: "" + message, message instanceof ObjectMessage); <line6> ObjectMessage objectMessage = (ObjectMessage) message; <line7> List<String> body = (List<String>) objectMessage.getObject(); <line8> assertEquals(""Size of list should be 1"", 1, body.size()); <line9> assertEquals(""element 0 of list"", ""First"", body.get(0)); <line10> return body; <line11> } <line12> } <line13>  <LINE> <line8>"	Yes	task2	
"<CODE> public class A { <line0> public void clickDeleteButton() { <line1> WebElement findElement = driver.findElement(By.className(""t-client-remove-btn"")); <line2> findElement.click(); <line3> } <line4> } <line5>  <LINE> <line1>"	Yes	task2	
<CODE> public class A { <line0> private void deleteObsoletePendingTasks(SingularityPendingDeploy pendingDeploy) { <line1> List<SingularityPendingTaskId> obsoletePendingTasks = <line2> taskManager <line3> .getPendingTaskIdsForRequest(pendingDeploy.getDeployMarker().getRequestId()) <line4> .stream() <line5> .filter( <line6> taskId -> <line7> !taskId.getDeployId().equals(pendingDeploy.getDeployMarker().getDeployId())) <line8> .collect(Collectors.toList()); <line9> for (SingularityPendingTaskId pendingTaskId : obsoletePendingTasks) { <line10> taskManager.deletePendingTask(pendingTaskId); <line11> } <line12> } <line13> } <line14>  <LINE> <line10>	Yes	task2	
<CODE> public class A { <line0> public void addImplementsHostInterface( <line1> TypeSpec host, ClassName hostInterfaceName, Map<TypeSpec, TypeSpec> changes) { <line2> TypeSpec currentHost = changes.get(host); <line3> if (currentHost == null) { <line4> currentHost = host; <line5> } <line6> TypeSpec.Builder modifyingBuilder = currentHost.toBuilder(); <line7> modifyingBuilder.addSuperinterface(hostInterfaceName); <line8> changes.put(host, modifyingBuilder.build()); <line9> } <line10> } <line11>  <LINE> <line9>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void applyAsync(final Connection conn, final Consumer<Boolean> function) { <line2> if (conn == null) { <line3> function.accept(false); <line4> } else { <line5> final SearchOperationHandle h = conn.operation(searchRequest); <line6> h.onResult(r -> function.accept(r.getResultCode() != null)); <line7> h.onException( <line8> e -> { <line9> function.accept(false); <line10> }); <line11> h.send(); <line12> } <line13> } <line14> } <line15>  <LINE> <line1>	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void testConcurrencyWithSchemaMigration() throws InterruptedException { <line2> SchemaListResponse schemas = call(() -> clientA.findSchemas()); <line3> SchemaResponse contentSchema = <line4> schemas.getData().stream().filter(s -> s.getName().equals(""content"")).findFirst().get(); <line5> String schemaUuid = contentSchema.getUuid(); <line6> String projectName = randomName(); <line7> ProjectCreateRequest request = new ProjectCreateRequest(); <line8> request.setName(projectName); <line9> request.setSchemaRef(""folder""); <line10> ProjectResponse project = call(() -> clientA.createProject(request)); <line11> call(() -> clientA.assignSchemaToProject(projectName, schemaUuid)); <line12> List<String> uuids = new ArrayList<>(); <line13> NodeCreateRequest nodeCreateRequest = new NodeCreateRequest(); <line14> nodeCreateRequest.setLanguage(""en""); <line15> nodeCreateRequest <line16> .getFields() <line17> .put(""teaser"", FieldUtil.createStringField(""some rorschach teaser"")); <line18> nodeCreateRequest <line19> .getFields() <line20> .put(""content"", FieldUtil.createStringField(""Blessed mealtime again!"")); <line21> nodeCreateRequest.setSchemaName(""content""); <line22> nodeCreateRequest.setParentNodeUuid(project.getRootNode().getUuid()); <line23> for (int i = 0; i < TEST_DATA_SIZE; i++) { <line24> nodeCreateRequest <line25> .getFields() <line26> .put(""slug"", FieldUtil.createStringField(""new-page"" + i + "".html"")); <line27> if (i % 10 == 0) { <line28> } <line29> uuids.add(call(() -> clientA.createNode(projectName, nodeCreateRequest)).getUuid()); <line30> } <line31> SchemaUpdateRequest schemaUpdateRequest = contentSchema.toUpdateRequest(); <line32> schemaUpdateRequest.addField(FieldUtil.createStringFieldSchema(""dummy"")); <line33> Completable opA = <line34> clientA.updateSchema(contentSchema.getUuid(), schemaUpdateRequest).toCompletable(); <line35> Completable opB = <line36> clientB <line37> .deleteNode(projectName, uuids.get(0)) <line38> .toCompletable() <line39> .delay(2000, TimeUnit.MILLISECONDS); <line40> Completable.merge(Arrays.asList(opA, opB)).blockingAwait(); <line41> Thread.sleep(30000); <line42> call(() -> clientA.findSchemaByUuid(contentSchema.getUuid())); <line43> call(() -> clientB.findSchemaByUuid(contentSchema.getUuid())); <line44> } <line45> } <line46>  <LINE> <line28>"	Yes	task2	
<CODE> public class A { <line0> private void setComputationModulus(SrpClientKeyExchangeMessage msg) { <line1> msg.getComputations().setModulus(chooser.getSRPModulus()); <line2> } <line3> } <line4>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> private void createFeatureTypes(Collection<Pair<ArcGISLayer, DataGroupInfo>> layersAndParents) { <line1> List<FeatureCreator> tasks = <line2> layersAndParents.stream() <line3> .filter(lp -> !lp.getFirstObject().isSingleFusedMapCache()) <line4> .map(lp -> new FeatureCreator(lp.getFirstObject(), lp.getSecondObject())) <line5> .collect(Collectors.toList()); <line6> try { <line7> myExecutor.invokeAll(tasks); <line8> } catch (InterruptedException e) { <line9> } <line10> } <line11> } <line12>  <LINE> <line9>	Yes	task2	
<CODE> public class A { <line0> @Deprecated <line1> public static com.liferay.commerce.product.model.CommerceChannelRelSoap[] getCommerceChannelRels( <line2> String className, <line3> long classPK, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.commerce.product.model.CommerceChannelRel> <line8> orderByComparator) <line9> throws RemoteException { <line10> try { <line11> java.util.List<com.liferay.commerce.product.model.CommerceChannelRel> returnValue = <line12> CommerceChannelRelServiceUtil.getCommerceChannelRels( <line13> className, classPK, start, end, orderByComparator); <line14> return com.liferay.commerce.product.model.CommerceChannelRelSoap.toSoapModels(returnValue); <line15> } catch (Exception exception) { <line16> throw new RemoteException(exception.getMessage()); <line17> } <line18> } <line19> } <line20>  <LINE> <line18>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void initContext(AgentSession agentSession) { <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> private void getAllConnectionTemplates() { <line1> ResourceCollection<ConnectionTemplate> connectionTemplates = <line2> this.connectionTemplateClient.getAll(); <line3> } <line4> } <line5>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> private List<JobTaskDirectoryMatch> findOrphansForTask(JobTask task) { <line1> List<JobTaskDirectoryMatch> rv = new ArrayList<>(); <line2> Job job = getJob(task.getJobUUID()); <line3> if (job == null) { <line4> return rv; <line5> } <line6> List<String> expectedTaskHosts = task.getAllTaskHosts(); <line7> for (HostState host : hostManager.listHostStatus(job.getMinionType())) { <line8> if ((host == null) <line9> || !host.isUp() <line10> || host.isDead() <line11> || host.getHostUuid().equals(task.getRebalanceTarget())) { <line12> continue; <line13> } <line14> if (!expectedTaskHosts.contains(host.getHostUuid())) { <line15> JobTaskDirectoryMatch.MatchType type = null; <line16> if (host.hasLive(task.getJobKey()) || host.hasIncompleteReplica(task.getJobKey())) { <line17> type = JobTaskDirectoryMatch.MatchType.ORPHAN_LIVE; <line18> } <line19> if (type != null) { <line20> rv.add(new JobTaskDirectoryMatch(type, task.getJobKey(), host.getHostUuid())); <line21> } <line22> } <line23> } <line24> return rv; <line25> } <line26> } <line27>  <LINE> <line6>	No	task2	
"<CODE> public class A { <line0> private static final String generateServiceBundles(File tenantConfigFile) { <line1> String result = null; <line2> ServiceConfigGeneration xsdMetadata = null; <line3> try { <line4> xsdMetadata = <line5> new ServiceConfigGeneration( <line6> serviceBundlesInfo, <line7> tenantConfigFile, <line8> CommonAPI.GENERATE_BUNDLES, <line9> SERVICE_SCHEMA_VERSION, <line10> getBundlesOutputDir(), <line11> SERVICE_BINDINGS_VERSION, <line12> getBindingsOutputDir()); <line13> serviceBundlesInfo.put(tenantConfigFile.getName(), xsdMetadata); <line14> dumpServiceArtifactMetadata(tenantConfigFile, xsdMetadata); <line15> } catch (Exception e) { <line16> result = <line17> String.format( <line18> ""Error encountered generating service bindings for '%s' tenant configuration."", <line19> tenantConfigFile.getAbsolutePath()); <line20> } <line21> return result; <line22> } <line23> } <line24>  <LINE> <line20>"	Yes	task2	
<CODE> public class A { <line0> private void drawPoint( <line1> PdfContext context, Rectangle iconRect, Color fillColor, Color strokeColor) { <line2> float baseWidth = iconRect.getWidth() / 10; <line3> SymbolInfo symbol = styleInfo.getSymbol(); <line4> if (symbol.getImage() != null) { <line5> try { <line6> Image pointImage = Image.getInstance(symbol.getImage().getHref()); <line7> context.drawImage(pointImage, iconRect, iconRect); <line8> } catch (Exception ex) { <line9> } <line10> } else if (symbol.getRect() != null) { <line11> context.fillRectangle(iconRect, fillColor); <line12> context.strokeRectangle(iconRect, strokeColor, baseWidth / 2); <line13> } else { <line14> context.fillEllipse(iconRect, fillColor); <line15> context.strokeEllipse(iconRect, strokeColor, baseWidth / 2); <line16> } <line17> } <line18> } <line19>  <LINE> <line9>	Yes	task2	
"<CODE> public class A { <line0> @Test( <line1> groups = {""journeyPattern""}, <line2> description = ""3-JourneyPattern-1"", <line3> priority = 3) <line4> public void verifyTest3_1() throws Exception { <line5> Context context = initValidatorContext(); <line6> context.put(VALIDATION, fullparameters); <line7> context.put(VALIDATION_REPORT, new ValidationReport()); <line8> Assert.assertNotNull(fullparameters, ""no parameters for test""); <line9> importLines(""3-JourneyPattern-1.xml"", 1, 1, true); <line10> utx.begin(); <line11> em.joinTransaction(); <line12> List<Line> beans = lineDao.findAll(); <line13> Assert.assertFalse(beans.isEmpty(), ""No data for test""); <line14> Line line1 = beans.get(0); <line15> Route route1 = null; <line16> ValidationData data = new ValidationData(); <line17> for (Route route : line1.getRoutes()) { <line18> data.getJourneyPatterns().addAll(route.getJourneyPatterns()); <line19> if (route.getJourneyPatterns().size() == 2) { <line20> route1 = route; <line21> } <line22> } <line23> route1.setObjectId(""NINOXE:Route:checkedRoute""); <line24> JourneyPattern jp1 = route1.getJourneyPatterns().get(0); <line25> jp1.setObjectId(""NINOXE:JourneyPattern:checkedJP""); <line26> context.put(VALIDATION_DATA, data); <line27> data.getRoutes().addAll(line1.getRoutes()); <line28> checkPoint.validate(context, null); <line29> ValidationReport report = (ValidationReport) context.get(VALIDATION_REPORT); <line30> Assert.assertNotEquals(report.getCheckPoints().size(), 0, "" report must have items""); <line31> CheckPointReport checkPointReport = report.findCheckPointReportByName(""3-JourneyPattern-1""); <line32> Assert.assertNotNull(checkPointReport, ""report must contain a 3-JourneyPattern-1 checkPoint""); <line33> Assert.assertEquals( <line34> checkPointReport.getState(), <line35> ValidationReporter.RESULT.NOK, <line36> "" checkPointReport must be nok""); <line37> Assert.assertEquals( <line38> checkPointReport.getSeverity(), <line39> CheckPointReport.SEVERITY.WARNING, <line40> "" checkPointReport must be on level warning""); <line41> Assert.assertEquals( <line42> checkPointReport.getCheckPointErrorCount(), 1, "" checkPointReport must have 1 item""); <line43> String detailKey = ""3-JourneyPattern-1"".replaceAll(""-"", ""_"").toLowerCase(); <line44> List<CheckPointErrorReport> details = checkReportForTest(report, ""3-JourneyPattern-1"", -1); <line45> for (CheckPointErrorReport detail : details) { <line46> Assert.assertTrue( <line47> detail.getKey().startsWith(detailKey), <line48> ""details key should start with test key : expected "" <line49> + detailKey <line50> + "", found : "" <line51> + detail.getKey()); <line52> Assert.assertEquals( <line53> detail.getSource().getObjectId(), jp1.getObjectId(), ""jp 1 must be source of error""); <line54> } <line55> utx.rollback(); <line56> } <line57> } <line58>  <LINE> <line5>"	Yes	task2	
"<CODE> public class A { <line0> private static ChannelBuilder create( <line1> SecurityProtocol securityProtocol, <line2> Mode mode, <line3> JaasContext.Type contextType, <line4> AbstractConfig config, <line5> ListenerName listenerName, <line6> boolean isInterBrokerListener, <line7> String clientSaslMechanism, <line8> boolean saslHandshakeRequestEnable, <line9> CredentialCache credentialCache, <line10> DelegationTokenCache tokenCache, <line11> Time time, <line12> LogContext logContext, <line13> Supplier<ApiVersionsResponse> apiVersionSupplier) { <line14> Map<String, Object> configs = channelBuilderConfigs(config, listenerName); <line15> ChannelBuilder channelBuilder; <line16> switch (securityProtocol) { <line17> case SSL: <line18> requireNonNullMode(mode, securityProtocol); <line19> channelBuilder = <line20> new SslChannelBuilder(mode, listenerName, isInterBrokerListener, logContext); <line21> break; <line22> case SASL_SSL: <line23> case SASL_PLAINTEXT: <line24> requireNonNullMode(mode, securityProtocol); <line25> Map<String, JaasContext> jaasContexts; <line26> String sslClientAuthOverride = null; <line27> if (mode == Mode.SERVER) { <line28> @SuppressWarnings(""unchecked"") <line29> List<String> enabledMechanisms = <line30> (List<String>) configs.get(BrokerSecurityConfigs.SASL_ENABLED_MECHANISMS_CONFIG); <line31> jaasContexts = new HashMap<>(enabledMechanisms.size()); <line32> for (String mechanism : enabledMechanisms) <line33> jaasContexts.put( <line34> mechanism, JaasContext.loadServerContext(listenerName, mechanism, configs)); <line35> if (listenerName != null && securityProtocol == SecurityProtocol.SASL_SSL) { <line36> String configuredClientAuth = <line37> (String) configs.get(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG); <line38> String listenerClientAuth = <line39> (String) <line40> config <line41> .originalsWithPrefix(listenerName.configPrefix(), true) <line42> .get(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG); <line43> if (listenerClientAuth == null) { <line44> sslClientAuthOverride = SslClientAuth.NONE.name().toLowerCase(Locale.ROOT); <line45> if (configuredClientAuth != null <line46> && !configuredClientAuth.equalsIgnoreCase(SslClientAuth.NONE.name())) { <line47> } <line48> } <line49> } <line50> } else { <line51> JaasContext jaasContext = <line52> contextType == JaasContext.Type.CLIENT <line53> ? JaasContext.loadClientContext(configs) <line54> : JaasContext.loadServerContext(listenerName, clientSaslMechanism, configs); <line55> jaasContexts = Collections.singletonMap(clientSaslMechanism, jaasContext); <line56> } <line57> channelBuilder = <line58> new SaslChannelBuilder( <line59> mode, <line60> jaasContexts, <line61> securityProtocol, <line62> listenerName, <line63> isInterBrokerListener, <line64> clientSaslMechanism, <line65> saslHandshakeRequestEnable, <line66> credentialCache, <line67> tokenCache, <line68> sslClientAuthOverride, <line69> time, <line70> logContext, <line71> apiVersionSupplier); <line72> break; <line73> case PLAINTEXT: <line74> channelBuilder = new PlaintextChannelBuilder(listenerName); <line75> break; <line76> default: <line77> throw new IllegalArgumentException(""Unexpected securityProtocol "" + securityProtocol); <line78> } <line79> channelBuilder.configure(configs); <line80> return channelBuilder; <line81> } <line82> } <line83>  <LINE> <line47>"	Yes	task2	
<CODE> public class A { <line0> public void startSelfTest( <line1> @Identification final String deviceIdentification, <line2> @Identification final String organisationIdentification, <line3> final String correlationUid, <line4> final String messageType, <line5> final int messagePriority) <line6> throws FunctionalException { <line7> this.findOrganisation(organisationIdentification); <line8> final Device device = this.findActiveDevice(deviceIdentification); <line9> this.osgpCoreRequestMessageSender.send( <line10> new RequestMessage(correlationUid, organisationIdentification, deviceIdentification, null), <line11> messageType, <line12> messagePriority, <line13> device.getIpAddress()); <line14> } <line15> } <line16>  <LINE> <line7>	Yes	task2	
<CODE> public class A { <line0> public static <T> T instantiateByKey( <line1> final Properties props, final String key, final T defaultValue) { <line2> final String className = findAndSubst(key, props); <line3> if (className == null) { <line4> return defaultValue; <line5> } <line6> return OptionConverter.instantiateByClassName(className.trim(), defaultValue); <line7> } <line8> } <line9>  <LINE> <line4>	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> public void testExtractParagraphsFromChapterFile_FIL_LRA_faa0d66e() throws IOException { <line2> ResourceLoader resourceLoader = <line3> new ClassRelativeResourceLoader(EPubParagraphExtractionHelper.class); <line4> Resource resource = <line5> resourceLoader.getResource( <line6> ""fil-lra-faa0d66e-564f-4d72-a1d3-ec46fb754205.epub_Page_3.xhtml""); <line7> File xhtmlFile = resource.getFile(); <line8> List<String> storyBookParagraphs = <line9> EPubParagraphExtractionHelper.extractParagraphsFromChapterFile(xhtmlFile); <line10> assertThat(storyBookParagraphs.size(), is(3)); <line11> assertThat(storyBookParagraphs.get(0), is(""WAAAAHHHH!"")); <line12> assertThat( <line13> storyBookParagraphs.get(1), <line14> is(""Ang ibong Brahminy ay umiiyak tulad ng isang gutom na sanggol."")); <line15> assertThat(storyBookParagraphs.get(2), is(""WAAAAHHHH!"")); <line16> } <line17> } <line18>  <LINE> <line9>"	No	task2	
<CODE> public class A { <line0> private void nearReaderUpdate() throws Exception { <line1> Integer key = nearKeys(jcache(0), 1, 500_000).get(0); <line2> IgniteCache<Integer, Integer> cache0 = jcache(0); <line3> assertNotNull(jcache(0).getConfiguration(CacheConfiguration.class).getNearConfiguration()); <line4> cache0.put(key, 1); <line5> checkTtl(key, 60_000L); <line6> IgniteCache<Integer, Integer> cache1 = jcache(1); <line7> if (atomicityMode() == ATOMIC) Thread.sleep(100); <line8> cache1.put(key, 2); <line9> checkTtl(key, 61_000L); <line10> if (atomicityMode() == ATOMIC) Thread.sleep(100); <line11> cache1.withExpiryPolicy(new TestPolicy(null, TTL_FOR_EXPIRE, null)).put(key, 3); <line12> checkTtl(key, TTL_FOR_EXPIRE); <line13> waitExpired(key); <line14> cache0.put(key, 1); <line15> checkTtl(key, 60_000L); <line16> if (atomicityMode() == ATOMIC) Thread.sleep(100); <line17> cache0.withExpiryPolicy(new TestPolicy(null, TTL_FOR_EXPIRE + 1, null)).put(key, 2); <line18> checkTtl(key, TTL_FOR_EXPIRE + 1); <line19> waitExpired(key); <line20> } <line21> } <line22>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> public static synchronized KeyPairGenerator getKeyPairGenerator(String algorithm) <line1> throws NoSuchAlgorithmException, NoSuchProviderException { <line2> KeyPairGenerator result = KeyPairGenerator.getInstance(algorithm); <line3> return result; <line4> } <line5> } <line6>  <LINE> <line1>	No	task2	
"<CODE> public class A { <line0> @Test( <line1> groups = {""Phase 1 Shape""}, <line2> description = ""extra columns"", <line3> priority = 243) <line4> public void verifyTest_2_8() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""shape_8"", GTFS_1_GTFS_Common_11, SEVERITY.WARNING, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 2, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""shapes.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(1), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22>  <LINE> <line18>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void run() { <line2> ThingUID thingUID = firmwareUpdateHandler.getThing().getUID(); <line3> FirmwareStatusInfo info = getFirmwareStatusInfo(thingUID); <line4> firmwareStatusInfoMap.put(thingUID, info); <line5> } <line6> } <line7>  <LINE> <line4>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public T withHandle(Handle handle) throws Exception { <line2> final Connection connection = handle.getConnection(); <line3> final boolean readOnly = connection.isReadOnly(); <line4> connection.setReadOnly(true); <line5> try { <line6> return handle.inTransaction(callback); <line7> } finally { <line8> try { <line9> connection.setReadOnly(readOnly); <line10> } catch (SQLException e) { <line11> } <line12> } <line13> } <line14> } <line15>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> public void start() throws Exception { <line1> if (server == null) { <line2> Vertx vertx = hostConfiguration.getVertx(); <line3> Router router = hostConfiguration.getRouter(); <line4> HttpServerOptions options = hostConfiguration.getServerOptions(); <line5> SSLContextParameters sslContextParameters = hostConfiguration.getSslContextParameters(); <line6> if (sslContextParameters != null) { <line7> if (options == null) { <line8> options = new HttpServerOptions(); <line9> } <line10> VertxWebsocketHelper.setupSSLOptions(sslContextParameters, options); <line11> } <line12> if (options != null) { <line13> server = vertx.createHttpServer(options); <line14> } else { <line15> server = vertx.createHttpServer(); <line16> } <line17> CompletableFuture<Void> future = new CompletableFuture<>(); <line18> server <line19> .requestHandler(router) <line20> .listen( <line21> hostKey.getPort(), <line22> hostKey.getHost(), <line23> result -> { <line24> if (!result.failed()) { <line25> port = result.result().actualPort(); <line26> future.complete(null); <line27> } else { <line28> future.completeExceptionally(result.cause()); <line29> } <line30> }); <line31> future.get(); <line32> } <line33> } <line34> } <line35>  <LINE> <line12>	No	task2	
<CODE> public class A { <line0> private Set<Long> collectGatewayRelayIdsFromCloud(final Cloud cloud) { <line1> final Set<Long> idSet = new HashSet<>(); <line2> for (final CloudGatewayRelay conn : cloud.getGatewayRelays()) { <line3> idSet.add(conn.getRelay().getId()); <line4> } <line5> return idSet; <line6> } <line7> } <line8>  <LINE> <line4>	No	task2	
"<CODE> public class A { <line0> public void initialise() throws InitialisationException { <line1> if (salt == null) { <line2> salt = <line3> new byte[] { <line4> (byte) 0xc7, <line5> (byte) 0x73, <line6> (byte) 0x21, <line7> (byte) 0x8c, <line8> (byte) 0x7e, <line9> (byte) 0xc8, <line10> (byte) 0xee, <line11> (byte) 0x99 <line12> }; <line13> } <line14> if (password == null) { <line15> throw new InitialisationException(CoreMessages.objectIsNull(""Password""), this); <line16> } <line17> super.initialise(); <line18> } <line19> } <line20>  <LINE> <line13>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void listenToTimebase(boolean listen) { <line2> if (!listen && timeListener == null) { <line3> return; <line4> } <line5> if (timeListener == null) { <line6> timeListener = <line7> evt -> { <line8> try { <line9> if (evt.getPropertyName().equals(""minutes"")) { <line10> checkAlarmList(); <line11> } <line12> } catch (IOException ex) { <line13> timebase.removeMinuteChangeListener(timeListener); <line14> } <line15> }; <line16> } <line17> if (listen) { <line18> timebase.addMinuteChangeListener(timeListener); <line19> } else { <line20> timebase.removeMinuteChangeListener(timeListener); <line21> } <line22> } <line23> } <line24>  <LINE> <line14>"	No	task2	
"<CODE> public class A { <line0> public void testGetActionMappingName1() { <line1> String[] paths = { <line2> ""foo"", ""foo.do"", ""foo?foo=bar"", ""foo?foo=bar&bar=baz"", ""foo?foo=bar&amp;bar=baz"" <line3> }; <line4> String[][] prepends = { <line5> {"""", ""/foo""}, {""/"", ""/foo""}, {""bar/"", ""/bar/foo""}, {""/bar/"", ""/bar/foo""} <line6> }; <line7> String[] appends = { <line8> """", ""#anchor"", ""?"", ""?#"", ""?foo=bar"", ""?foo1=bar1&foo2=bar2"", ""?foo1=bar1&amp;foo2=bar2"" <line9> }; <line10> String finalResult = null; <line11> String path = null; <line12> String results = null; <line13> boolean equality = false; <line14> int ct = 0; <line15> for (int i = 0; i < appends.length; i++) { <line16> for (int j = 0; j < prepends.length; j++) { <line17> finalResult = prepends[j][1]; <line18> for (int k = 0; k < paths.length; k++) { <line19> path = prepends[j][0] + paths[k] + appends[i]; <line20> results = tagutils.getActionMappingName(path); <line21> equality = finalResult.equals(results); <line22> if (!equality) { <line23> fail( <line24> ""Path does not return correct result\n"" <line25> + ""\nexpected: "" <line26> + results <line27> + ""\nfound: "" <line28> + path); <line29> } <line30> assertTrue(""Path should translate to result"", equality); <line31> ct++; <line32> } <line33> } <line34> } <line35> } <line36> } <line37>  <LINE> <line35>"	Yes	task2	
<CODE> public class A { <line0> protected void setInitialBuffer(ByteBuffer initialBuffer) { <line1> if (LOG.isDebugEnabled()) <line2> try (AutoLock l = lock.lock()) { <line3> networkBuffer = newNetworkBuffer(initialBuffer.remaining()); <line4> } <line5> ByteBuffer buffer = networkBuffer.getBuffer(); <line6> BufferUtil.clearToFill(buffer); <line7> BufferUtil.put(initialBuffer, buffer); <line8> BufferUtil.flipToFlush(buffer, 0); <line9> } <line10> } <line11>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> private CalculatedDesiredPoolSize calculateDesiredPoolSize(long currentPoolSize) { <line1> long now = System.currentTimeMillis(); <line2> WindowSummary downsizeSummary = <line3> recentDesiredResizes.summarizeWindow(getResizeDownStabilizationDelay()); <line4> WindowSummary upsizeSummary = <line5> recentDesiredResizes.summarizeWindow(getResizeUpStabilizationDelay()); <line6> long maxDesiredPoolSize = upsizeSummary.min; <line7> boolean stableForGrowing = upsizeSummary.stableForGrowth; <line8> long minDesiredPoolSize = downsizeSummary.max; <line9> boolean stableForShrinking = downsizeSummary.stableForShrinking; <line10> long desiredPoolSize; <line11> boolean stable; <line12> if (currentPoolSize < maxDesiredPoolSize) { <line13> desiredPoolSize = maxDesiredPoolSize; <line14> stable = stableForGrowing; <line15> } else if (currentPoolSize > minDesiredPoolSize) { <line16> desiredPoolSize = minDesiredPoolSize; <line17> stable = stableForShrinking; <line18> } else { <line19> desiredPoolSize = currentPoolSize; <line20> stable = stableForGrowing && stableForShrinking; <line21> } <line22> if (LOG.isTraceEnabled()) <line23> return new CalculatedDesiredPoolSize(desiredPoolSize, stable); <line24> } <line25> } <line26>  <LINE> <line25>	No	task2	
<CODE> public class A { <line0> @Override <line1> public Set<BookieId> onClusterChanged( <line2> Set<BookieId> writableBookies, Set<BookieId> readOnlyBookies) { <line3> rwLock.writeLock().lock(); <line4> try { <line5> ImmutableSet<BookieId> joinedBookies, leftBookies, deadBookies; <line6> Set<BookieId> oldBookieSet = knownBookies.keySet(); <line7> leftBookies = Sets.difference(oldBookieSet, writableBookies).immutableCopy(); <line8> joinedBookies = Sets.difference(writableBookies, oldBookieSet).immutableCopy(); <line9> deadBookies = Sets.difference(leftBookies, readOnlyBookies).immutableCopy(); <line10> handleBookiesThatLeft(leftBookies); <line11> handleBookiesThatJoined(joinedBookies); <line12> if (this.isWeighted && (leftBookies.size() > 0 || joinedBookies.size() > 0)) { <line13> this.weightedSelection.updateMap(this.bookieInfoMap); <line14> } <line15> if (!readOnlyBookies.isEmpty()) { <line16> this.readOnlyBookies = ImmutableSet.copyOf(readOnlyBookies); <line17> } <line18> return deadBookies; <line19> } finally { <line20> rwLock.writeLock().unlock(); <line21> } <line22> } <line23> } <line24>  <LINE> <line19>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> readLatch.countDown(); <line4> indexPersistenceMgr.getFileInfo(lid, null); <line5> readRc.set(BKException.Code.OK); <line6> } catch (Bookie.NoLedgerException nle) { <line7> readRc.set(BKException.Code.NoSuchLedgerExistsException); <line8> } catch (IOException e) { <line9> readRc.set(BKException.Code.ReadException); <line10> } <line11> readDoneLatch.countDown(); <line12> } <line13> } <line14>  <LINE> <line9>	Yes	task2	
"<CODE> public class A { <line0> public static List<Property> select( <line1> EntityManager em, final String mediaPackageId, final String namespace) { <line2> TypedQuery<PropertyDto> query = <line3> em.createNamedQuery(""Property.selectByMediaPackageAndNamespace"", PropertyDto.class) <line4> .setParameter(""mediaPackageId"", mediaPackageId) <line5> .setParameter(""namespace"", namespace); <line6> return query.getResultList().parallelStream() <line7> .map(PropertyDto::toProperty) <line8> .collect(Collectors.toList()); <line9> } <line10> } <line11>  <LINE> <line5>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public LSInput resolveResource( <line2> String type, String namespaceURI, String publicId, String systemId, String baseURI) { <line3> LSInputImpl input = new LSInputImpl(); <line4> InputStream stream = null; <line5> try { <line6> stream = new FileInputStream(path + systemId); <line7> } catch (FileNotFoundException e) { <line8> } <line9> input.setPublicId(publicId); <line10> input.setSystemId(systemId); <line11> input.setBaseURI(baseURI); <line12> input.setCharacterStream(new InputStreamReader(stream)); <line13> return input; <line14> } <line15> } <line16>  <LINE> <line13>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> watchForIdleBulkWriters(); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8>  <LINE> <line5>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void shutDownGracefully(GracefulShutdownCallback callback) { <line2> if (this.gracefulShutdown == null) { <line3> callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE); <line4> return; <line5> } <line6> this.gracefulShutdownCallback.set(callback); <line7> this.gracefulShutdown.shutdown(); <line8> this.gracefulShutdown.addShutdownListener((success) -> notifyGracefulCallback(success)); <line9> } <line10> } <line11>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> private void createBroaderRelationship( <line1> RelationClient relationClient, String subjectCSID, String objectCSID, String docType) <line2> throws Exception { <line3> RelationsCommon relationCommon = new RelationsCommon(); <line4> relationCommon.setSubjectCsid(subjectCSID); <line5> relationCommon.setSubjectDocumentType(docType); <line6> relationCommon.setObjectCsid(objectCSID); <line7> relationCommon.setObjectDocumentType(docType); <line8> relationCommon.setRelationshipType(RelationshipType.HAS_BROADER.value()); <line9> relationCommon.setPredicateDisplayName(RelationshipType.HAS_BROADER.value()); <line10> PoxPayloadOut payloadOut = relationClient.createRequestTypeInstance(relationCommon); <line11> Response res = relationClient.create(payloadOut); <line12> try { <line13> if (res.getStatus() == HttpStatus.SC_CREATED) { <line14> String relationCSID = extractId(res); <line15> allRelationResourceIdsCreated.add(relationCSID); <line16> } else { <line17> String errMsg = ""Could not create Relationship.""; <line18> throw new Exception(errMsg); <line19> } <line20> } finally { <line21> res.close(); <line22> } <line23> } <line24> } <line25>  <LINE> <line19>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public Answer execute( <line2> final OvsVpcRoutingPolicyConfigCommand command, <line3> final LibvirtComputingResource libvirtComputingResource) { <line4> try { <line5> final Script scriptCommand = <line6> new Script( <line7> libvirtComputingResource.getOvsTunnelPath(), <line8> libvirtComputingResource.getTimeout(), <line9> s_logger); <line10> scriptCommand.add(""configure_ovs_bridge_for_routing_policies""); <line11> scriptCommand.add(""--bridge"", command.getBridgeName()); <line12> scriptCommand.add(""--config"", command.getVpcConfigInJson()); <line13> final String result = scriptCommand.execute(); <line14> if (result.equalsIgnoreCase(""SUCCESS"")) { <line15> return new Answer(command, true, result); <line16> } else { <line17> return new Answer(command, false, result); <line18> } <line19> } catch (final Exception e) { <line20> return new Answer(command, false, e.getMessage()); <line21> } <line22> } <line23> } <line24>  <LINE> <line10>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void handleLastResult(Result lastResult) { <line2> if (lastResult == null) { <line3> return; <line4> } <line5> Cell[] rawCells = lastResult.rawCells(); <line6> Cell last = rawCells[rawCells.length - 1]; <line7> byte[] row = CellUtil.cloneRow(last); <line8> byte[] originalRow = traceIdRowKeyDistributor.getOriginalKey(row); <line9> long reverseStartTime = <line10> BytesUtils.bytesToLong(originalRow, PinpointConstants.APPLICATION_NAME_MAX_LEN); <line11> this.lastRowTimestamp = TimeUtils.recoveryTimeMillis(reverseStartTime); <line12> byte[] qualifier = CellUtil.cloneQualifier(last); <line13> this.lastTransactionId = <line14> TransactionIdMapper.parseVarTransactionId(qualifier, 0, qualifier.length); <line15> this.lastTransactionElapsed = BytesUtils.bytesToInt(qualifier, 0); <line16> if (logger.isDebugEnabled()) { <line17> } <line18> } <line19> } <line20>  <LINE> <line17>	Yes	task2	
<CODE> public class A { <line0> synchronized void processRemoveRequest(ID mbr) { <line1> if (waiting) { <line2> pendingRemovals.add(mbr); <line3> checkIfDone(); <line4> } <line5> } <line6> } <line7>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> @Override <line1> @Transactional <line2> @Deprecated <line3> public void sendApiRecordCreationEmail(String toEmail, String orcid) { <line4> ProfileEntity record = profileEntityCacheManager.retrieve(orcid); <line5> String creatorName = <line6> record.getSource() == null ? null : sourceEntityUtils.getSourceName(record.getSource()); <line7> Locale userLocale = getUserLocaleFromProfileEntity(record); <line8> String email = emailManager.findPrimaryEmail(orcid).getEmail(); <line9> String emailName = deriveEmailFriendlyName(orcid); <line10> String verificationUrl = createClaimVerificationUrl(email, orcidUrlManager.getBaseUrl()); <line11> String subject = null; <line12> String body = null; <line13> String htmlBody = null; <line14> String sender = null; <line15> subject = getSubject(""email.subject.api_record_creation"", userLocale); <line16> Map<String, Object> templateParams = new HashMap<String, Object>(); <line17> templateParams.put(""emailName"", emailName); <line18> templateParams.put(""orcid"", orcid); <line19> templateParams.put(""subject"", subject); <line20> templateParams.put(""creatorName"", creatorName); <line21> templateParams.put(""baseUri"", orcidUrlManager.getBaseUrl()); <line22> templateParams.put(""baseUriHttp"", orcidUrlManager.getBaseUriHttp()); <line23> templateParams.put(""verificationUrl"", verificationUrl); <line24> addMessageParams(templateParams, userLocale); <line25> body = templateManager.processTemplate(""api_record_creation_email.ftl"", templateParams); <line26> htmlBody = <line27> templateManager.processTemplate(""api_record_creation_email_html.ftl"", templateParams); <line28> if (apiRecordCreationEmailEnabled) { <line29> mailGunManager.sendEmail(CLAIM_NOTIFY_ORCID_ORG, email, subject, body, htmlBody); <line30> } else { <line31> } <line32> } <line33> } <line34>  <LINE> <line31>"	Yes	task2	
<CODE> public class A { <line0> private void onFailure(final Throwable throwable) { <line1> recorder.reportFailedAuth(serverKey); <line2> session.close(true); <line3> } <line4> } <line5>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> void publishRetained( <line1> ClientSession targetSession, Collection<IMessagesStore.StoredMessage> messages) { <line2> for (IMessagesStore.StoredMessage storedMsg : messages) { <line3> MqttPublishMessage publishMsg = retainedPublish(storedMsg); <line4> if (storedMsg.getQos() != MqttQoS.AT_MOST_ONCE) { <line5> int packetID = targetSession.inFlightAckWaiting(storedMsg); <line6> publishMsg = retainedPublish(storedMsg, packetID); <line7> } <line8> this.messageSender.sendPublish(targetSession, publishMsg); <line9> } <line10> } <line11> } <line12>  <LINE> <line2>	No	task2	
"<CODE> public class A { <line0> public String resolve(String input) { <line1> int openPos; <line2> int closePos; <line3> String variable_char = ""ENC(""; <line4> String variable_char_close = "")""; <line5> String midBit; <line6> String replaceValue; <line7> String temp = input; <line8> while (temp.indexOf(variable_char) > 0 || temp.startsWith(variable_char)) { <line9> openPos = temp.indexOf(variable_char); <line10> closePos = temp.indexOf(variable_char_close, openPos + 1); <line11> midBit = temp.substring(openPos + 4, closePos); <line12> replaceValue = this.decrypt(variable_char + midBit + variable_char_close); <line13> if (replaceValue != null) { <line14> input = input.replace(variable_char + midBit + variable_char_close, replaceValue); <line15> } <line16> temp = temp.substring(closePos + 1, temp.length()); <line17> } <line18> return input; <line19> } <line20> } <line21>  <LINE> <line16>"	No	task2	
"<CODE> public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/by-code/{code}"") <line3> public Response getCrisisByCode(@PathParam(""code"") String crisisCode) { <line4> CollectionDTO crisis = null; <line5> try { <line6> crisis = crisisLocalEJB.getCrisisByCode(crisisCode); <line7> return Response.ok(crisis).build(); <line8> } catch (RuntimeException e) { <line9> return Response.ok( <line10> new ResponseWrapper( <line11> TaggerAPIConfigurator.getInstance() <line12> .getProperty(TaggerAPIConfigurationProperty.STATUS_CODE_FAILED), <line13> e.getCause().getCause().getMessage())) <line14> .build(); <line15> } <line16> } <line17> } <line18>  <LINE> <line9>"	Yes	task2	
<CODE> public class A { <line0> private void updateEthernetNetwork() { <line1> Network network = client.getByName(ETHERNET_NETWORK_NAME).get(0); <line2> network.setName(ETHERNET_NETWORK_NAME_UPDATED); <line3> TaskResource task = this.client.update(network.getResourceId(), network); <line4> } <line5> } <line6>  <LINE> <line4>	Yes	task2	
"<CODE> public class A { <line0> @OPTIONS <line1> public Response unsupportedOptionsMethod() { <line2> throw new WebApplicationException( <line3> Response.status(NOT_ALLOWED_STATUS).entity(""OPTIONS Method Not Allowed"").build()); <line4> } <line5> } <line6>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line2> public void testCalculateMethodInvocation() throws Exception { <line3> List requestBody = new ArrayList(); <line4> requestBody.add(1); <line5> requestBody.add(new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY)); <line6> Object responseBody = template.requestBody(""direct:thrift-zlib-calculate"", requestBody); <line7> assertNotNull(responseBody); <line8> assertTrue(responseBody instanceof Integer); <line9> assertEquals(THRIFT_TEST_NUM1 * THRIFT_TEST_NUM2, responseBody); <line10> } <line11> } <line12>  <LINE> <line0>"	No	task2	
<CODE> public class A { <line0> public void setAuthorizationId(final String id) { <line1> checkImmutable(); <line2> authorizationId = id; <line3> } <line4> } <line5>  <LINE> <line1>	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void testF31Miles() { <line2> setup(VehicleType.CONVENTIONAL.toString(), true); <line3> String content = FileReader.readFileInString(""src/test/resources/responses/F31/status.json""); <line4> assertTrue( <line5> testVehicle( <line6> content, <line7> STATUS_CONV + DOORS + RANGE_CONV + POSITION + SERVICE_AVAILABLE + CHECK_EMPTY, <line8> Optional.empty())); <line9> } <line10> } <line11>  <LINE> <line4>"	No	task2	
"<CODE> public class A { <line0> private Map<String, Object> getNodeTypesFromAdp(Map<String, Object> adp) <line1> throws AdpParsingException { <line2> try { <line3> return (Map<String, Object>) adp.get(NODE_TYPES_KEY); <line4> } catch (NullPointerException E) { <line5> throw new AdpParsingException( <line6> ""The parser was not able to retrieve the 'node_types' from the current ADP.""); <line7> } <line8> } <line9> } <line10>  <LINE> <line5>"	Yes	task2	
"<CODE> public class A { <line0> public synchronized void run() { <line1> try { <line2> Map<String, List<Number>> stats = getStatsByKey(); <line3> StringBuilder buf = getCSVBuf(stats); <line4> final FileWriter fw = getFileWriter(); <line5> fw.append(buf.append(""\n"").toString()); <line6> fw.flush(); <line7> } catch (Throwable e) { <line8> } <line9> } <line10> } <line11>  <LINE> <line9>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public String apply(String s) { <line2> try { <line3> return function.call(); <line4> } catch (Exception e) { <line5> return e.getMessage(); <line6> } <line7> } <line8> } <line9>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void doExceptionCaughtListeners(final Throwable cause) { <line2> runManagementTask( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> try { <line7> List<SessionManagementListener> sessionListeners = getManagementListeners(); <line8> for (final SessionManagementListener listener : sessionListeners) { <line9> listener.doExceptionCaught(SessionManagementBeanImpl.this, cause); <line10> } <line11> markChanged(); <line12> } catch (Exception ex) { <line13> } <line14> } <line15> }); <line16> } <line17> } <line18>  <LINE> <line13>	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> public void testRgroupQueryFile7() throws Exception { <line2> String filename = ""data/mdl/rgfile.7.mol""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> RGroupQueryReader reader = new RGroupQueryReader(ins); <line5> RGroupQuery rGroupQuery = <line6> (RGroupQuery) reader.read(new RGroupQuery(DefaultChemObjectBuilder.getInstance())); <line7> reader.close(); <line8> Assert.assertNotNull(rGroupQuery); <line9> Assert.assertEquals(rGroupQuery.getRGroupDefinitions().size(), 1); <line10> Assert.assertEquals(rGroupQuery.getRootStructure().getAtomCount(), 9); <line11> Assert.assertEquals(rGroupQuery.getAllConfigurations().size(), 20); <line12> } <line13> } <line14>  <LINE> <line0>"	No	task2	
<CODE> public class A { <line0> @Test <line1> void preserveSynonyms() { <line2> if (!defaultDatabase.supportsSynonyms()) { <line3> return; <line4> } <line5> assertEquals(2, defaultDatabase.getSynonymNames().size()); <line6> defaultDBClearer.clearDatabase(); <line7> assertEquals(2, defaultDatabase.getSynonymNames().size()); <line8> } <line9> } <line10>  <LINE> <line6>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void onDropSentryRole(TDropSentryRoleRequest request) throws SentryPluginException { <line2> PermissionsUpdate update = new PermissionsUpdate(permSeqNum.incrementAndGet(), false); <line3> update <line4> .addPrivilegeUpdate(PermissionsUpdate.ALL_AUTHZ_OBJ) <line5> .putToDelPrivileges(request.getRoleName(), PermissionsUpdate.ALL_AUTHZ_OBJ); <line6> update.addRoleUpdate(request.getRoleName()).addToDelGroups(PermissionsUpdate.ALL_GROUPS); <line7> permsUpdater.handleUpdateNotification(update); <line8> } <line9> } <line10>  <LINE> <line8>	Yes	task2	
<CODE> public class A { <line0> public void removeResourceFile() { <line1> try { <line2> fsFactory.deleteIfExists(fsFactory.getFile(file.getPath() + RESOURCE_SUFFIX)); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> @Override <line1> public boolean isValid( <line2> SubmissionPayload submissionPayload, ConstraintValidatorContext validatorContext) { <line3> List<TemporaryExposureKey> exposureKeys = submissionPayload.getKeysList(); <line4> validatorContext.disableDefaultConstraintViolation(); <line5> boolean isValidPayload = <line6> checkStartIntervalNumberIsAtMidNight(exposureKeys, validatorContext) <line7> && checkKeyCollectionSize(exposureKeys, validatorContext) <line8> && checkOriginCountryIsValid(submissionPayload, validatorContext) <line9> && checkVisitedCountriesAreValid(submissionPayload, validatorContext) <line10> && checkRequiredFieldsNotMissing(exposureKeys, validatorContext) <line11> && checkTransmissionRiskLevelIsAcceptable(exposureKeys, validatorContext) <line12> && checkDaysSinceOnsetOfSymptomsIsInRange(exposureKeys, validatorContext) <line13> && eventCheckinValidator.verify(submissionPayload, validatorContext); <line14> if (!isValidPayload) { <line15> PrintableSubmissionPayload printableSubmissionPayload = <line16> new PrintableSubmissionPayload(submissionPayload); <line17> } <line18> return isValidPayload; <line19> } <line20> } <line21>  <LINE> <line17>	Yes	task2	
"<CODE> public class A { <line0> private void jsonError(String message) { <line1> setResponse(""{\""error\"":\"""" + message + ""\""}""); <line2> } <line3> } <line4>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> private void downloadAndCopyJars(Set<String> jarsToDownload, Path destinationPath) <line1> throws IOException { <line2> Set<String> copiedJars = new HashSet<>(); <line3> for (String jar : jarsToDownload) { <line4> if (!copiedJars.contains(jar)) { <line5> Path jarPath = Paths.get(jar); <line6> if (destinationPath == null || jarPath == null) { <line7> throw new IllegalArgumentException(""null destinationPath or jarPath""); <line8> } <line9> Path jarFileName = jarPath.getFileName(); <line10> if (jarFileName == null) { <line11> throw new IllegalArgumentException(""null farFileName""); <line12> } <line13> File destPath = Paths.get(destinationPath.toString(), jarFileName.toString()).toFile(); <line14> try (InputStream src = fileStorage.download(jar); <line15> FileOutputStream dest = new FileOutputStream(destPath)) { <line16> IOUtils.copy(src, dest); <line17> copiedJars.add(jar); <line18> } <line19> } <line20> } <line21> } <line22> } <line23>  <LINE> <line18>"	Yes	task2	
"<CODE> public class A { <line0> public void export(Dashboard dashboard, Path path, ExportType type) { <line1> DashboardSerializer serializer = serializerFor(type); <line2> validate(dashboard); <line3> Path temp = createTempDashboardFile(); <line4> try (FileOutputStream fos = new FileOutputStream(temp.toFile())) { <line5> serializer.serialize(dashboard, fos); <line6> Files.move(temp, path, StandardCopyOption.REPLACE_EXISTING); <line7> } catch (FileNotFoundException e) { <line8> throw new IllegalArgumentException(""File not found: "" + path, e); <line9> } catch (IOException e) { <line10> throw new RuntimeException(""Error writing to file "" + path, e); <line11> } finally { <line12> try { <line13> Files.deleteIfExists(temp); <line14> } catch (IOException e) { <line15> } <line16> } <line17> } <line18> } <line19>  <LINE> <line15>"	Yes	task2	
<CODE> public class A { <line0> private InetAddress getAddressByName(String host) { <line1> try { <line2> return InetAddress.getByName(host); <line3> } catch (Exception e) { <line4> return null; <line5> } <line6> } <line7> } <line8>  <LINE> <line4>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void disconnected(SchedulerDriver schedulerDriver) { <line2> } <line3> } <line4>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public int executeBatch() { <line2> List<JsonObject> objectsToPersist = new ArrayList<JsonObject>(); <line3> HttpResponse response = null; <line4> String databaseName = null; <line5> boolean isbulk = false; <line6> try { <line7> for (Node node : nodes) { <line8> if (node.isDirty()) { <line9> node.handlePreEvent(); <line10> if (node.isInState(RemovedState.class)) { <line11> delete(node.getData(), node.getEntityId()); <line12> } else { <line13> EntityMetadata metadata = <line14> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, node.getDataClass()); <line15> databaseName = metadata.getSchema(); <line16> JsonObject asJsonObject = <line17> CouchDBObjectMapper.getJsonOfEntity( <line18> metadata, <line19> node.getData(), <line20> node.getEntityId(), <line21> getRelationHolders(node), <line22> kunderaMetadata); <line23> objectsToPersist.add(asJsonObject); <line24> isbulk = true; <line25> } <line26> node.handlePostEvent(); <line27> } <line28> } <line29> if (isbulk) { <line30> try { <line31> URI uri = <line32> new URI( <line33> CouchDBConstants.PROTOCOL, <line34> null, <line35> httpHost.getHostName(), <line36> httpHost.getPort(), <line37> CouchDBConstants.URL_SEPARATOR <line38> + databaseName.toLowerCase() <line39> + CouchDBConstants.URL_SEPARATOR <line40> + ""_bulk_docs"", <line41> null, <line42> null); <line43> HttpPost post = new HttpPost(uri); <line44> String object = <line45> String.format( <line46> ""{%s%s}"", <line47> ""\""all_or_nothing\"": true,"", ""\""docs\"": "" + gson.toJson(objectsToPersist)); <line48> StringEntity entity = new StringEntity(object, ""UTF-8""); <line49> entity.setContentType(""application/json""); <line50> post.setEntity(entity); <line51> response = httpClient.execute(httpHost, post, CouchDBUtils.getContext(httpHost)); <line52> } catch (Exception e) { <line53> throw new KunderaException(""Error while executing batch. caused by :"" + e); <line54> } <line55> } <line56> } catch (OperationNotSupportedException e) { <line57> throw new KunderaException(e.getMessage()); <line58> } finally { <line59> CouchDBUtils.closeContent(response); <line60> } <line61> return nodes.size(); <line62> } <line63> } <line64>  <LINE> <line53>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void exportTableRowData(ITableRow row, AbstractTableRowData rowData) { <line2> for (IColumn column : m_columnSet.getColumns()) { <line3> if (m_ignoredColumns.contains(column)) { <line4> continue; <line5> } <line6> Object value = column.getValue(row); <line7> FastPropertyDescriptor propertyDesc = m_propertyDescriptorByColumn.get(column); <line8> if (propertyDesc != null) { <line9> try { <line10> Method columnWriteMethod = propertyDesc.getWriteMethod(); <line11> Object dto = getDataContainer(rowData, columnWriteMethod.getDeclaringClass()); <line12> columnWriteMethod.invoke(dto, value); <line13> } catch (Exception t) { <line14> } <line15> } else { <line16> rowData.setCustomValue(column.getColumnId(), value); <line17> } <line18> } <line19> rowData.setRowState(row.getStatus()); <line20> exportCustomValues(row, rowData); <line21> } <line22> } <line23>  <LINE> <line2>	No	task2	
"<CODE> public class A { <line0> private RequestInfo buildRequestInfo(String requestId, String timeout) { <line1> RequestInfo requestInfo = new RequestInfo(); <line2> if (requestId != null) { <line3> String host = env.getProperty(""mso.workflow.message.endpoint""); <line4> String callbackUrl = <line5> host <line6> + ""/"" <line7> + UriUtils.encodePathSegment(""SNIROResponse"", ""UTF-8"") <line8> + ""/"" <line9> + UriUtils.encodePathSegment(requestId, ""UTF-8""); <line10> Duration d = Duration.parse(timeout); <line11> requestInfo.setTransactionId(requestId); <line12> requestInfo.setRequestId(requestId); <line13> requestInfo.setCallbackUrl(callbackUrl); <line14> requestInfo.setRequestType(""create""); <line15> requestInfo.setTimeout(d.getSeconds()); <line16> } else { <line17> throw new BpmnError(UNPROCESSABLE, ""Request Context does not contain: requestId""); <line18> } <line19> return requestInfo; <line20> } <line21> } <line22>  <LINE> <line1>"	Yes	task2	
<CODE> public class A { <line0> private void extractRestCheckUrl() { <line1> Configuration conf = HadoopUtil.getCurrentConfiguration(); <line2> yarnMasterUrlBase = HadoopConfExtractor.extractYarnMasterUrl(conf); <line3> jobHistoryUrlBase = HadoopConfExtractor.extractJobHistoryUrl(yarnMasterUrlBase, conf); <line4> } <line5> } <line6>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void dropDimension(LensSessionHandle sessionid, String dimName) throws LensException { <line2> try (SessionContext ignored = new SessionContext(sessionid)) { <line3> getClient(sessionid).dropDimension(dimName); <line4> } <line5> } <line6> } <line7>  <LINE> <line4>	Yes	task2	
"<CODE> public class A { <line0> public void emitRequiredImport(String requiredImport) { <line1> requiredImports.add('""' + requiredImport + '""'); <line2> } <line3> } <line4>  <LINE> <line1>"	Yes	task2	
"<CODE> public class A { <line0> @Bean(destroyMethod = ""stop"", name = ""domainCoreOutboundOsgpCoreResponsesConnectionFactory"") <line1> public ConnectionFactory connectionFactory() { <line2> return this.jmsConfigurationFactory.getPooledConnectionFactory(); <line3> } <line4> } <line5>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> public AWSError parseAWSErrorFromContent(HttpRequest request, HttpResponse response) { <line1> if (response.getPayload() == null) return null; <line2> if (""text/plain"".equals(response.getPayload().getContentMetadata().getContentType())) <line3> return null; <line4> try { <line5> AWSError error = <line6> factory.create(errorHandlerProvider.get()).setContext(request).apply(response); <line7> if (error.getRequestId() == null) <line8> error.setRequestId(response.getFirstHeaderOrNull(requestId)); <line9> error.setRequestToken(response.getFirstHeaderOrNull(requestToken)); <line10> if (""SignatureDoesNotMatch"".equals(error.getCode())) { <line11> error.setStringSigned(signer.createStringToSign(request)); <line12> error.setSignature(signer.sign(error.getStringSigned())); <line13> } <line14> return error; <line15> } catch (RuntimeException e) { <line16> return null; <line17> } <line18> } <line19> } <line20>  <LINE> <line16>"	Yes	task2	
<CODE> public class A { <line0> void initScheduler() { <line1> if (batchSize > 0) { <line2> scheduledExecutor = Executors.newSingleThreadScheduledExecutor(); <line3> scheduledExecutor.scheduleAtFixedRate( <line4> () -> { <line5> try { <line6> flush(); <line7> } catch (Exception e) { <line8> } <line9> }, <line10> flushIntervalMs, <line11> flushIntervalMs, <line12> TimeUnit.MILLISECONDS); <line13> } <line14> } <line15> } <line16>  <LINE> <line8>	Yes	task2	
"<CODE> public class A { <line0> @VisibleForTesting <line1> static @Nullable Manifest getManifest(Class<?> clazz) throws IOException { <line2> URL classURL = clazz.getResource(clazz.getSimpleName() + "".class""); <line3> if (classURL == null) { <line4> return null; <line5> } <line6> String externalForm = classURL.toExternalForm(); <line7> if (!externalForm.startsWith(""jar:"")) { <line8> return null; <line9> } <line10> URL manifestURL = <line11> new URL( <line12> externalForm.substring(0, externalForm.lastIndexOf('!')) + ""!/META-INF/MANIFEST.MF""); <line13> Closer closer = Closer.create(); <line14> try { <line15> InputStream manifestIn = closer.register(manifestURL.openStream()); <line16> return new Manifest(manifestIn); <line17> } catch (Throwable t) { <line18> throw closer.rethrow(t); <line19> } finally { <line20> closer.close(); <line21> } <line22> } <line23> } <line24>  <LINE> <line4>"	Yes	task2	
<CODE> public class A { <line0> public void segmentIsReady(String segmentName) { <line1> CountDownLatch cdl = _segmentsAreReady.get(segmentName); <line2> if (cdl == null) { <line3> return; <line4> } <line5> long originalCount = cdl.getCount(); <line6> cdl.countDown(); <line7> if (originalCount > 0L) { <line8> } <line9> } <line10> } <line11>  <LINE> <line9>	No	task2	
<CODE> public class A { <line0> public void deleteOAuthClientService() { <line1> String bridgeUID = bridgeHandler.getThing().getUID().getAsString(); <line2> oAuthClientService.removeAccessTokenRefreshListener(this); <line3> oAuthFactory.deleteServiceAndAccessToken(bridgeUID); <line4> } <line5> } <line6>  <LINE> <line5>	No	task2	
"<CODE> public class A { <line0> @RequestMapping( <line1> value = ""/migration/events/{eventId}/clusters/{clusterId}/forceProcess"", <line2> method = RequestMethod.POST) <line3> public void forceProcessMigrationCluster( <line4> @PathVariable Long eventId, @PathVariable Long clusterId) { <line5> migrationService.forceProcessMigrationCluster(eventId, clusterId); <line6> } <line7> } <line8>  <LINE> <line3>"	No	task2	
<CODE> public class A { <line0> @Nullable <line1> protected ClassLoader getCustomClassLoaderForBrooklynObject( <line2> LookupContext lookupContext, BrooklynObjectType type, String objectId) { <line3> BrooklynObject item = lookupContext.peek(type, objectId); <line4> String catalogItemId = (item == null) ? null : item.getCatalogItemId(); <line5> if (catalogItemId == null) { <line6> return null; <line7> } <line8> final ManagementContext managementContext = lookupContext.lookupManagementContext(); <line9> RegisteredType catalogItem = managementContext.getTypeRegistry().get(catalogItemId); <line10> if (catalogItem == null) { <line11> return null; <line12> } else { <line13> final BrooklynClassLoadingContextSequential ctx = <line14> new BrooklynClassLoadingContextSequential(managementContext); <line15> ctx.add( <line16> CatalogUtils.newClassLoadingContextForCatalogItems( <line17> managementContext, item.getCatalogItemId(), item.getCatalogItemIdSearchPath())); <line18> return ClassLoaderFromBrooklynClassLoadingContext.of(ctx); <line19> } <line20> } <line21> } <line22>  <LINE> <line11>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void onEvent(EventSource eventSource, String id, String type, String data) { <line2> Exchange exchange = createExchange(false); <line3> try { <line4> SoroushMessage soroushMessage = objectMapper.readValue(data, SoroushMessage.class); <line5> exchange.getIn().setBody(soroushMessage); <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> if (endpoint.isAutoDownload()) { <line9> endpoint.handleDownloadFiles(soroushMessage); <line10> } <line11> sendExchange(exchange); <line12> } catch (Exception ex) { <line13> getExceptionHandler().handleException(ex); <line14> } <line15> } <line16> } <line17>  <LINE> <line7>	Yes	task2	
<CODE> public class A { <line0> private Object invokeEffectorNamed(Entity target, String effectorName, ConfigBag params) { <line1> Effector<?> effector = EffectorUtils.findEffectorDeclared(target, effectorName).get(); <line2> return target.invoke(effector, params.getAllConfig()).getUnchecked(); <line3> } <line4> } <line5>  <LINE> <line2>	No	task2	
"<CODE> public class A { <line0> private void readContactList(String parentcsid, String itemcsid) throws Exception { <line1> final String testName = ""readContactList""; <line2> setupReadList(); <line3> PersonClient client = new PersonClient(); <line4> AbstractCommonList list = null; <line5> Response res = client.readContactList(parentcsid, itemcsid); <line6> try { <line7> assertStatusCode(res, testName); <line8> list = res.readEntity(AbstractCommonList.class); <line9> } finally { <line10> if (res != null) { <line11> res.close(); <line12> } <line13> } <line14> List<AbstractCommonList.ListItem> listitems = list.getListItem(); <line15> int nItemsReturned = listitems.size(); <line16> int nExpectedItems = MAX_CONTACTS; <line17> if (logger.isDebugEnabled()) { <line18> } <line19> Assert.assertEquals(nItemsReturned, nExpectedItems); <line20> boolean iterateThroughList = false; <line21> if (iterateThroughList && logger.isDebugEnabled()) { <line22> AbstractCommonListUtils.ListItemsInAbstractCommonList(list, logger, testName); <line23> } <line24> } <line25> } <line26>  <LINE> <line18>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void setOutputStream(final OutputStream os) { <line2> if (logger.isTraceEnabled()) { <line3> this.os = <line4> new ByteArrayOutputStream() { <line5> @Override <line6> public void flush() throws IOException { <line7> os.write(buf, 0, size()); <line8> os.flush(); <line9> } <line10> }; <line11> } else { <line12> this.os = os; <line13> } <line14> jw.reset(this.os); <line15> } <line16> } <line17>  <LINE> <line9>	Yes	task2	
<CODE> public class A { <line0> public static MimeType createFromExtension(String fileExtension) throws MimeException { <line1> MimeType mimeType = ImageMime.checkForExtension(fileExtension); <line2> if (mimeType != null) { <line3> return mimeType; <line4> } <line5> mimeType = XMLMime.checkForExtension(fileExtension); <line6> if (mimeType != null) { <line7> return mimeType; <line8> } <line9> mimeType = TextMime.checkForExtension(fileExtension); <line10> if (mimeType != null) { <line11> return mimeType; <line12> } <line13> mimeType = ApplicationMime.checkForExtension(fileExtension); <line14> if (mimeType != null) { <line15> return mimeType; <line16> } <line17> return null; <line18> } <line19> } <line20>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> @Override <line1> public CompletableFuture<Void> stop() { <line2> abortPendingSnapshots(); <line3> if (snapshotListener != null) { <line4> raft.getPersistedSnapshotStore().removeSnapshotListener(snapshotListener); <line5> } <line6> try { <line7> raft.getPersistedSnapshotStore().purgePendingSnapshots().join(); <line8> } catch (final Exception e) { <line9> } <line10> return super.stop(); <line11> } <line12> } <line13>  <LINE> <line9>	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> public void testGetCustomObjectWithCompoundKey() throws Exception { <line2> irProps.customObjectAction.setValue(CustomObjectAction.get); <line3> irProps.customObjectName.setValue(TEST_CO_NAME_CAR); <line4> irProps.validateFetchCustomObjectSchema(); <line5> irProps.useCompoundKey.setValue(true); <line6> irProps.compoundKey.keyName.setValue(Arrays.asList(""customerId"", ""VIN"")); <line7> irProps.compoundKey.keyValue.setValue(Arrays.asList(""4137181"", ""WBA4R7C30HK896061"")); <line8> MarketoSource source = new MarketoSource(); <line9> source.initialize(null, irProps); <line10> MarketoRESTClient client = (MarketoRESTClient) source.getClientService(null); <line11> MarketoRecordResult result = client.getCustomObjects(irProps, null); <line12> assertNotNull(result.getRecords()); <line13> assertEquals(1, result.getRecords().size()); <line14> IndexedRecord record = result.getRecords().get(0); <line15> Schema s = record.getSchema(); <line16> assertEquals(4137181, record.get(s.getField(""customerId"").pos())); <line17> assertEquals(""WBA4R7C30HK896061"", record.get(s.getField(""VIN"").pos())); <line18> assertEquals(""FIT"", record.get(s.getField(""brand"").pos())); <line19> } <line20> } <line21>  <LINE> <line12>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void jbossWSUnableToCreateBinaryToken(Throwable t) { <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> private void reconnect(MockHost host) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> this.agentHost = host; <line4> } <line5> } <line6>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> monitor(JgroupsProbeMonitorStartStage.this.run()); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public Reader read() { <line2> S3Client s3 = S3ClientFactory.getClient(); <line3> try { <line4> GetObjectRequest.Builder builder = <line5> GetObjectRequest.builder().bucket(bucketName).key(s3ObjectSummary.key()); <line6> GetObjectRequest request = builder.build(); <line7> ResponseInputStream o = s3.getObject(request); <line8> return Channels.newReader(Channels.newChannel(o), encoding.name()); <line9> } catch (AwsServiceException e) { <line10> throw new FlywayException(""Failed to get object from s3: "" + e.getMessage(), e); <line11> } <line12> } <line13> } <line14>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public boolean handleResponse(MessageContext messageContext, Object endpoint) <line2> throws IOException, SAXException { <line3> if (validateResponse) { <line4> Source responseSource = getValidationResponseSource(messageContext.getResponse()); <line5> if (responseSource != null) { <line6> SAXParseException[] errors = validator.validate(responseSource, errorHandler); <line7> if (!ObjectUtils.isEmpty(errors)) { <line8> return handleResponseValidationErrors(messageContext, errors); <line9> } else if (logger.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> return true; <line14> } <line15> } <line16>  <LINE> <line10>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public Optional<Account> updateAccount(Account account) throws IOException { <line2> String url = buildCanvasUrl(""accounts/"" + account.getId(), Collections.emptyMap()); <line3> Response response = <line4> canvasMessenger.sendJsonPutToCanvas(oauthToken, url, account.toJsonObject(serializeNulls)); <line5> return responseParser.parseToObject(Account.class, response); <line6> } <line7> } <line8>  <LINE> <line1>"	No	task2	
"<CODE> public class A { <line0> public CouchDBMapping build() { <line1> if (mapping.getDatabaseName() == null) { <line2> throw new IllegalStateException(""A collection is not specified""); <line3> } <line4> return mapping; <line5> } <line6> } <line7>  <LINE> <line3>"	No	task2	
<CODE> public class A { <line0> private static void handleLoopException(Throwable t) { <line1> try { <line2> Thread.sleep(1000); <line3> } catch (InterruptedException e) { <line4> } <line5> } <line6> } <line7>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> private static void extractParamsFromJSON(UIRequest request, JSONObject payloadOut) <line1> throws Exception { <line2> JSONObject payloadIn = null; <line3> try { <line4> payloadIn = request.getJSONBody(); <line5> } catch (UIException e) { <line6> } <line7> if (payloadIn != null) { <line8> JSONObject fields = payloadIn.optJSONObject(""fields""); <line9> setPayloadField(""mode"", payloadOut, fields, payloadIn, ""single""); <line10> setPayloadField(""docType"", payloadOut, fields, payloadIn); <line11> String exceptionMsg = null; <line12> if (payloadOut.getString(""mode"").equals(""single"")) { <line13> if (setPayloadField(""singleCSID"", payloadOut, fields, payloadIn) == false) { <line14> if (fields != null && fields.getString(""csid"").trim().isEmpty() == false) { <line15> payloadOut.put(""singleCSID"", fields.getString(""csid"")); <line16> } else { <line17> exceptionMsg = <line18> String.format( <line19> ""Report invocation context specified '%s' mode but did not provide a '%s'"" <line20> + "" param."", <line21> ""single"", ""singleCSID""); <line22> } <line23> } <line24> } else if (payloadOut.getString(""mode"").equals(""group"")) { <line25> if (setPayloadField(""groupCSID"", payloadOut, fields, payloadIn) == false) { <line26> if (fields != null && fields.getString(""csid"").trim().isEmpty() == false) { <line27> payloadOut.put(""groupCSID"", fields.getString(""csid"")); <line28> } else { <line29> exceptionMsg = <line30> String.format( <line31> ""Report invocation context specified '%s' mode but did not provide a '%s'"" <line32> + "" param."", <line33> ""group"", ""groupCSID""); <line34> } <line35> } <line36> } else { <line37> exceptionMsg = <line38> String.format( <line39> ""The Report invocation mode '%s' is unknown."", payloadOut.getString(""mode"")); <line40> } <line41> if (exceptionMsg != null) { <line42> throw new UIException(exceptionMsg); <line43> } <line44> } <line45> } <line46> } <line47>  <LINE> <line44>"	No	task2	
"<CODE> public class A { <line0> private void transformGefaehrdung( <line1> Group<?> group, List<CnATreeElement> elements, Gefaehrdung gefaehrdung) { <line2> BpThreat bpThreat = new BpThreat(group); <line3> bpThreat.setTitel(gefaehrdung.getId() + "" "" + gefaehrdung.getTitel()); <line4> try { <line5> String description = HtmlWriter.getHtml(gefaehrdung); <line6> bpThreat.setObjectBrowserDescription(description); <line7> } catch (GSServiceException e) { <line8> } <line9> elements.add(bpThreat); <line10> } <line11> } <line12>  <LINE> <line11>"	No	task2	
"<CODE> public class A { <line0> public void convertVideo( <line1> FileItem f, StoredFile sf, ProcessResultList logs, Optional<DoubleConsumer> progress) { <line2> try { <line3> final File mp4 = f.getFile(EXTENSION_MP4); <line4> f.setType(Type.VIDEO); <line5> final String ext = sf.getExt(); <line6> String input = f.getFile(ext).getCanonicalPath(); <line7> boolean sameExt = EXTENSION_MP4.equals(ext); <line8> Path tmp = null; <line9> if (sameExt) { <line10> tmp = Files.createTempFile(""video"", "".mp4""); <line11> input = Files.move(mp4.toPath(), tmp, REPLACE_EXISTING).toFile().getCanonicalPath(); <line12> } <line13> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line14> List<String> args = new ArrayList<>(List.of(getPathToFFMPEG(), ""-y"")); <line15> if (sf.isAudio()) { <line16> args.addAll( <line17> List.of( <line18> ""-loop"", <line19> ""1"", <line20> ""-framerate"", <line21> ""24"", <line22> ""-i"", <line23> new File(getCssImagesDir(), ""audio.jpg"").getCanonicalPath())); <line24> } <line25> args.addAll( <line26> List.of( <line27> ""-i"", <line28> input, <line29> ""-c:v"", <line30> ""h264"", <line31> ""-c:a"", <line32> ""aac"", <line33> ""-pix_fmt"", <line34> ""yuv420p"", <line35> ""-vf"", <line36> ""pad=ceil(iw/2)*2:ceil(ih/2)*2"")); <line37> if (sf.isAudio()) { <line38> args.add(""-shortest""); <line39> } <line40> args.add(mp4.getCanonicalPath()); <line41> ProcessResult res = ProcessHelper.exec(""convert to MP4 :: "" + f.getHash(), args); <line42> logs.add(res); <line43> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line44> if (sameExt && tmp != null) { <line45> if (res.isOk()) { <line46> Files.delete(tmp); <line47> } else { <line48> Files.move(tmp, mp4.toPath(), REPLACE_EXISTING); <line49> } <line50> } <line51> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line52> Dimension dim = getDimension(res.getError(), new Dimension(100, 100)); <line53> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line54> f.setWidth(dim.getWidth()); <line55> f.setHeight(dim.getHeight()); <line56> convertToPng(f, mp4.getCanonicalPath(), logs); <line57> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line58> } catch (Exception err) { <line59> logs.add(new ProcessResult(""convertToMP4"", err.getMessage(), err)); <line60> } <line61> } <line62> } <line63>  <LINE> <line59>"	Yes	task2	
"<CODE> public class A { <line0> @StateMachineAction <line1> public String releaseIPaddress( <line2> String instanceId, ProvisioningSettings settings, InstanceStatus result) { <line3> String eventId = EVENT_FAILED; <line4> VMPropertyHandler ph = new VMPropertyHandler(settings); <line5> try { <line6> ph.releaseManuallyDefinedIPAddresses(); <line7> eventId = EVENT_SUCCESS; <line8> } catch (Exception e) { <line9> String message = Messages.get(ph.getLocale(), ""error_release_ip"", new Object[] {instanceId}); <line10> ph.setSetting(VMPropertyHandler.SM_ERROR_MESSAGE, message); <line11> } <line12> return eventId; <line13> } <line14> } <line15>  <LINE> <line9>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public CompletableFuture<Boolean> releaseSegment(int segmentId) { <line2> try { <line3> if (!(processor instanceof StreamingEventProcessor)) { <line4> return CompletableFuture.completedFuture(false); <line5> } else { <line6> ((StreamingEventProcessor) processor).releaseSegment(segmentId); <line7> } <line8> } catch (Exception e) { <line9> return exceptionallyCompletedFuture(e); <line10> } <line11> return CompletableFuture.completedFuture(true); <line12> } <line13> } <line14>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void updateExperimentRunName(String experimentRunId, String experimentRunName) { <line2> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line3> ExperimentRunEntity experimentRunEntity = <line4> session.load(ExperimentRunEntity.class, experimentRunId, LockMode.PESSIMISTIC_WRITE); <line5> experimentRunEntity.setName(experimentRunName); <line6> long currentTimestamp = Calendar.getInstance().getTimeInMillis(); <line7> experimentRunEntity.setDate_updated(currentTimestamp); <line8> Transaction transaction = session.beginTransaction(); <line9> session.update(experimentRunEntity); <line10> transaction.commit(); <line11> } catch (Exception ex) { <line12> if (ModelDBUtils.needToRetry(ex)) { <line13> updateExperimentRunName(experimentRunId, experimentRunName); <line14> } else { <line15> throw ex; <line16> } <line17> } <line18> } <line19> } <line20>  <LINE> <line11>	Yes	task2	
"<CODE> public class A { <line0> public static java.util.List<com.liferay.commerce.model.CommerceAddress> <line1> getBillingCommerceAddresses( <line2> HttpPrincipal httpPrincipal, <line3> long companyId, <line4> String className, <line5> long classPK, <line6> String keywords, <line7> int start, <line8> int end, <line9> com.liferay.portal.kernel.search.Sort sort) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> CommerceAddressServiceUtil.class, <line15> ""getBillingCommerceAddresses"", <line16> _getBillingCommerceAddressesParameterTypes7); <line17> MethodHandler methodHandler = <line18> new MethodHandler(methodKey, companyId, className, classPK, keywords, start, end, sort); <line19> Object returnObj = null; <line20> try { <line21> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line22> } catch (Exception exception) { <line23> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line24> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line25> } <line26> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line27> } <line28> return (java.util.List<com.liferay.commerce.model.CommerceAddress>) returnObj; <line29> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line30> throw systemException; <line31> } <line32> } <line33> } <line34>  <LINE> <line30>"	Yes	task2	
<CODE> public class A { <line0> protected Map<NodeIDSuffix, WebViewContent> getWizardPageViewValueMapInternal( <line1> final NodeID subnodeID) { <line2> if (subnodeID == null) { <line3> return null; <line4> } <line5> final WorkflowManager manager = m_manager; <line6> assert manager.isLockedByCurrentThread(); <line7> SubNodeContainer subNC = manager.getNodeContainer(subnodeID, SubNodeContainer.class, true); <line8> WorkflowManager subWFM = subNC.getWorkflowManager(); <line9> return subWFM.findExecutedNodes(WizardNode.class, NOT_HIDDEN_FILTER).entrySet().stream() <line10> .filter( <line11> e -> !subWFM.getNodeContainer(e.getKey(), NativeNodeContainer.class, true).isInactive()) <line12> .collect( <line13> Collectors.toMap( <line14> e -> NodeID.NodeIDSuffix.create(manager.getID(), e.getKey()), <line15> e -> e.getValue().getViewValue())); <line16> } <line17> } <line18>  <LINE> <line3>	Yes	task2	
"<CODE> public class A { <line0> private void processAuthenticatedPasswordModify( <line1> LdapSession requestor, PasswordModifyRequest req, Dn userDn) { <line2> byte[] oldPassword = req.getOldPassword(); <line3> byte[] newPassword = req.getNewPassword(); <line4> Entry modifiedEntry = null; <line5> Dn principalDn = requestor.getCoreSession().getEffectivePrincipal().getDn(); <line6> if ((userDn != null) && (!userDn.equals(principalDn))) { <line7> if (requestor.getCoreSession().isAdministrator()) { <line8> modifiedEntry = getModifiedEntry(requestor, req, userDn); <line9> if (modifiedEntry == null) { <line10> return; <line11> } <line12> modifyUserPassword( <line13> requestor.getCoreSession(), modifiedEntry, userDn, oldPassword, newPassword, req); <line14> } else { <line15> writeResult( <line16> requestor, <line17> req, <line18> ResultCodeEnum.INSUFFICIENT_ACCESS_RIGHTS, <line19> ""Non-admin user cannot access another user's password to modify it""); <line20> } <line21> } else { <line22> modifiedEntry = getModifiedEntry(requestor, req, principalDn); <line23> if (modifiedEntry == null) { <line24> return; <line25> } <line26> modifyUserPassword( <line27> requestor.getCoreSession(), modifiedEntry, principalDn, oldPassword, newPassword, req); <line28> } <line29> } <line30> } <line31>  <LINE> <line6>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void startElement(String uri, String localName, String qName, Attributes attributes) { <line2> String name = localName; <line3> if (uri != null && !"""".equals(uri)) name = uri + "":"" + name; <line4> events.start(name); <line5> for (int i = 0; i < attributes.getLength(); i++) { <line6> String k = attributes.getLocalName(i); <line7> String auri = attributes.getURI(i); <line8> if (auri != null && (XMLNS.equals(auri) || XML.equals(auri))) continue; <line9> if (auri != null && !"""".equals(auri)) k = auri + "":"" + k; <line10> events.start(""@"" + k); <line11> events.text(attributes.getValue(i)); <line12> events.end(); <line13> } <line14> } <line15> } <line16>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> @VisibleForTesting <line1> static synchronized File dumpHeap(File directory) <line2> throws MalformedObjectNameException, InstanceNotFoundException, ReflectionException, <line3> MBeanException, IOException { <line4> boolean liveObjectsOnly = false; <line5> File fileName = new File(directory, ""heap_dump.hprof""); <line6> if (fileName.exists() && !fileName.delete()) { <line7> throw new IOException(""heap_dump.hprof already existed and couldn't be deleted!""); <line8> } <line9> MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); <line10> ObjectName oname = new ObjectName(""com.sun.management:type=HotSpotDiagnostic""); <line11> Object[] parameters = {fileName.getPath(), liveObjectsOnly}; <line12> String[] signatures = {String.class.getName(), boolean.class.getName()}; <line13> mbs.invoke(oname, ""dumpHeap"", parameters, signatures); <line14> if (java.nio.file.FileSystems.getDefault().supportedFileAttributeViews().contains(""posix"")) { <line15> Files.setPosixFilePermissions( <line16> fileName.toPath(), <line17> ImmutableSet.of( <line18> PosixFilePermission.OWNER_READ, <line19> PosixFilePermission.GROUP_READ, <line20> PosixFilePermission.OTHERS_READ)); <line21> } else { <line22> fileName.setReadable(true, true); <line23> } <line24> return fileName; <line25> } <line26> } <line27>  <LINE> <line13>"	No	task2	
"<CODE> public class A { <line0> private void analyzeFile(ESRIShapefile aFile) { <line1> myColumnTypes.clear(); <line2> myImportConfig.getColumnNames().clear(); <line3> myValuesSet.clear(); <line4> List<String> columnNames = ShapeFileReadUtilities.getHeader(aFile); <line5> if (!CollectionUtilities.hasContent(columnNames)) { <line6> } <line7> myValuesSet.addAll(ShapeFileReadUtilities.getDataSample(aFile, 200)); <line8> myImportConfig.getColumnNames().clear(); <line9> myImportConfig.getColumnNames().addAll(columnNames); <line10> int numPreviewLines = myValuesSet.size(); <line11> boolean hadError = numPreviewLines == 0; <line12> int lineIndex = -1; <line13> if (numPreviewLines == 0) { <line14> JOptionPane.showMessageDialog( <line15> myMainPanel, <line16> ""Error loading: "" + aFile.getFilePath() + ""\n\nShapefile contains no data"", <line17> ""Shapefile Loading Error"", <line18> JOptionPane.ERROR_MESSAGE); <line19> } <line20> if (hadError) { <line21> myState = ImportState.ERROR; <line22> changeState(); <line23> } else { <line24> myInfoLabel.setText(""Read "" + lineIndex + "" Lines From File. Analyzing...""); <line25> if (myImportConfig.getColumnNames().size() > 0) { <line26> for (int i = 0; i < myImportConfig.getColumnNames().size(); i++) { <line27> myColumnTypes.add(ColumnType.OTHER); <line28> } <line29> myImportConfig.setDateColumn(-1); <line30> myImportConfig.setTimeColumn(-1); <line31> myImportConfig.setLobColumn(-1); <line32> LegacyImportWizardUtil.determineColumns(myImportConfig); <line33> LegacyImportWizardUtil.determineColumnsLiberal(myImportConfig); <line34> LegacyImportWizardUtil.graspAtStraws(myImportConfig); <line35> LegacyImportWizardUtil.setupColumnTypes(myImportConfig, myColumnTypes); <line36> } <line37> myProgressBar.setValue(100); <line38> myProgressBar.setIndeterminate(false); <line39> myInfoLabel.setText(""Analysis Complete""); <line40> } <line41> } <line42> } <line43>  <LINE> <line6>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void finishJob(JobResult result, Class<?> batch, List<Session> sessions) { <line2> super.finishJob(result, batch, sessions); <line3> for (Session session : sessions) { <line4> if (!super.isAdmin(session)) { <line5> return; <line6> } <line7> try { <line8> session.close(); <line9> } catch (IOException e) { <line10> } <line11> } <line12> } <line13> } <line14>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> private void setDefaults() { <line1> try { <line2> this.startIndex( <line3> ApplicationProperties.get().getLong(APPLICATION_PROPERTY_MIGRATION_START_INDEX, 0L)) <line4> .numWorkers( <line5> ApplicationProperties.get() <line6> .getInt(APPLICATION_PROPERTY_MIGRATION_NUMER_OF_WORKERS, 4)) <line7> .batchSize( <line8> ApplicationProperties.get().getInt(APPLICATION_PROPERTY_MIGRATION_BATCH_SIZE, 3000)); <line9> } catch (AtlasException ex) { <line10> } <line11> } <line12> } <line13>  <LINE> <line10>	Yes	task2	
<CODE> public class A { <line0> protected Opt<DublinCoreCatalog> loadDublinCoreCatalog(String seriesId) { <line1> try { <line2> Opt<byte[]> seriesElementData = <line3> getSeriesService().getSeriesElementData(requireNonNull(seriesId), flavor.getType()); <line4> if (seriesElementData.isSome()) { <line5> final DublinCoreCatalog dc = DublinCoreByteFormat.read(seriesElementData.get()); <line6> dc.setFlavor(flavor); <line7> dc.addBindings(config.getXmlNamespaceContext()); <line8> return Opt.some(dc); <line9> } else { <line10> final DublinCoreCatalog dc = DublinCores.mkStandard(); <line11> dc.addBindings(config.getXmlNamespaceContext()); <line12> dc.setRootTag( <line13> new EName(config.getCatalogXmlRootNamespace(), config.getCatalogXmlRootElementName())); <line14> dc.setFlavor(flavor); <line15> return Opt.some(dc); <line16> } <line17> } catch (SeriesException e) { <line18> return Opt.none(); <line19> } <line20> } <line21> } <line22>  <LINE> <line10>	No	task2	
"<CODE> public class A { <line0> @Bean(name = ""protocolMqttOutboundOsgpCoreRequestsJmsTemplate"") <line1> public JmsTemplate jmsTemplate() { <line2> return this.jmsConfigurationFactory.initJmsTemplate(); <line3> } <line4> } <line5>  <LINE> <line1>"	No	task2	
"<CODE> public class A { <line0> @PUT <line1> @Path(""{id}"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @RestQuery( <line4> name = ""updateacl"", <line5> description = ""Update an ACL"", <line6> returnDescription = ""Update an ACL"", <line7> pathParameters = { <line8> @RestParameter( <line9> name = ""id"", <line10> isRequired = true, <line11> description = ""The ACL identifier"", <line12> type = INTEGER) <line13> }, <line14> restParameters = { <line15> @RestParameter( <line16> name = ""name"", <line17> isRequired = true, <line18> description = ""The ACL name"", <line19> type = STRING), <line20> @RestParameter( <line21> name = ""acl"", <line22> isRequired = true, <line23> description = ""The access control list"", <line24> type = STRING) <line25> }, <line26> responses = { <line27> @RestResponse(responseCode = SC_OK, description = ""The ACL has successfully been updated""), <line28> @RestResponse(responseCode = SC_NOT_FOUND, description = ""The ACL has not been found""), <line29> @RestResponse(responseCode = SC_BAD_REQUEST, description = ""Unable to parse the ACL"") <line30> }) <line31> public Response updateAcl( <line32> @PathParam(""id"") long aclId, <line33> @FormParam(""name"") String name, <line34> @FormParam(""acl"") String accessControlList) <line35> throws NotFoundException { <line36> final Organization org = securityService.getOrganization(); <line37> final AccessControlList acl = parseAcl.apply(accessControlList); <line38> final ManagedAclImpl managedAcl = new ManagedAclImpl(aclId, name, org.getId(), acl); <line39> if (!aclService().updateAcl(managedAcl)) { <line40> throw new NotFoundException(); <line41> } <line42> return RestUtils.okJson(full(managedAcl)); <line43> } <line44> } <line45>  <LINE> <line40>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public List<ProxyHostConfig> getProxyServer(URL destination) throws IOException { <line2> List<ProxyHostConfig> results = New.list(1); <line3> try { <line4> for (Proxy prox : ProxySelector.getDefault().select(destination.toURI())) { <line5> ProxyType proxyType; <line6> switch (prox.type()) { <line7> case DIRECT: <line8> proxyType = ProxyType.DIRECT; <line9> break; <line10> case HTTP: <line11> proxyType = ProxyType.PROXY; <line12> break; <line13> case SOCKS: <line14> proxyType = ProxyType.SOCKS; <line15> break; <line16> default: <line17> throw new UnexpectedEnumException(prox.type()); <line18> } <line19> SocketAddress addr = prox.address(); <line20> if (addr instanceof InetSocketAddress) { <line21> results.add( <line22> new ProxyHostConfig( <line23> proxyType, <line24> ((InetSocketAddress) addr).getHostString(), <line25> ((InetSocketAddress) addr).getPort())); <line26> } <line27> } <line28> } catch (URISyntaxException e) { <line29> } <line30> return results; <line31> } <line32> } <line33>  <LINE> <line32>	No	task2	
"<CODE> public class A { <line0> @GET <line1> @Path(""/photos/{UID}/{ConnectorPrettyName}.{ObjectTypeName}/{unixTime}/{count}"") <line2> @ApiOperation(value = ""Get photos at a given time"", response = PhotoItem.class) <line3> @ApiResponses({@ApiResponse(code = 403, message = ""In case of unauthorized access"")}) <line4> @Produces({MediaType.APPLICATION_JSON}) <line5> public Response getPhotosBeforeOrAfterTime( <line6> @ApiParam(value = ""User ID"", required = true) @PathParam(""UID"") long uid, <line7> @ApiParam(value = ""Connector name"", required = true) @PathParam(""ConnectorPrettyName"") <line8> String connectorPrettyName, <line9> @ApiParam(value = ""Object type name"", required = true) @PathParam(""ObjectTypeName"") <line10> String objectTypeName, <line11> @ApiParam(value = ""Timestamp (epoch seconds)"", required = true) @PathParam(""unixTime"") <line12> double unixTimeInSecs, <line13> @ApiParam(value = ""Photo count limit"", required = true) @PathParam(""count"") int desiredCount, <line14> @ApiParam(value = ""Is before time"", required = true) @QueryParam(""isBefore"") <line15> boolean isGetPhotosBeforeTime, <line16> @ApiParam(value = ""Tags for matching"", required = true) @QueryParam(""tags"") String tagsStr, <line17> @ApiParam(value = ""Tag matching strategy"", required = true) @QueryParam(""tag-match"") <line18> String tagMatchingStrategyName) { <line19> try { <line20> final TagFilter.FilteringStrategy tagFilteringStrategy = <line21> TagFilter.FilteringStrategy.findByName(tagMatchingStrategyName); <line22> if (isUnauthorized(uid)) { <line23> return Response.status(Response.Status.UNAUTHORIZED) <line24> .entity(""Invalid User ID (null)"") <line25> .build(); <line26> } <line27> final TagFilter tagFilter = <line28> TagFilter.create( <line29> Tag.parseTagsIntoStrings(tagsStr, Tag.COMMA_DELIMITER), tagFilteringStrategy); <line30> final SortedSet<PhotoService.Photo> photos = <line31> photoService.getPhotos( <line32> uid, <line33> (long) (unixTimeInSecs * 1000), <line34> connectorPrettyName, <line35> objectTypeName, <line36> desiredCount, <line37> isGetPhotosBeforeTime, <line38> tagFilter); <line39> final List<PhotoItem> photoItems = new ArrayList<PhotoItem>(); <line40> for (final PhotoService.Photo photo : photos) { <line41> photoItems.add(new PhotoItem(photo)); <line42> } <line43> return Response.ok(gson.toJson(photoItems)).build(); <line44> } catch (Exception e) { <line45> return Response.status(Response.Status.UNAUTHORIZED).entity(""Access Denied"").build(); <line46> } <line47> } <line48> } <line49>  <LINE> <line30>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void handle(HttpExchange he) throws IOException { <line2> Content content; <line3> if (he.getRemoteAddress().getAddress().isLoopbackAddress()) { <line4> try { <line5> content = handlePath(he); <line6> } catch (HttpErrorException e) { <line7> content = handleError(e.status); <line8> } <line9> } else { <line10> content = handleError(Status.FORBIDDEN); <line11> } <line12> Headers headers = he.getResponseHeaders(); <line13> headers.put(""Content-Type"", Arrays.asList(content.type)); <line14> he.sendResponseHeaders(content.status.code, content.body.length); <line15> try (OutputStream os = he.getResponseBody()) { <line16> os.write(content.body); <line17> } <line18> } <line19> } <line20>  <LINE> <line18>"	Yes	task2	
<CODE> public class A { <line0> public byte[] run() throws SaslException { <line1> return saslClient.evaluateChallenge(saslToken); <line2> } <line3> } <line4>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> private void setValue(boolean bool) { <line1> try { <line2> pin.setValue(bool); <line3> TimeUnit.SECONDS.sleep(1); <line4> } catch (InterruptedException <line5> | KuraUnavailableDeviceException <line6> | IOException <line7> | KuraClosedDeviceException e) { <line8> } <line9> } <line10> } <line11>  <LINE> <line8>	Yes	task2	
<CODE> public class A { <line0> private Map<String, Set<Integer>> parseLicsTodoToLicenseMap(Map<String, InputStream> inputMap) { <line1> List<CSVRecord> licenseTodoRecord = readAsCSVRecords(inputMap.get(LICENSE_TODO_FILE)); <line2> return ConvertRecord.convertRelationalTable(licenseTodoRecord); <line3> } <line4> } <line5>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void run() { <line2> boolean locked = false; <line3> try { <line4> Profiler p = new Profiler(); <line5> p.start(); <line6> locked = WorkLock.lock(timeoutSeconds); <line7> p.stop(); <line8> System.out.println( <line9> ""Thread "" + id + "" waited "" + p.getDurationInMillis() + "" ms, locked="" + locked); <line10> if (locked) { <line11> Thread.sleep(jobDuration * 1000); <line12> } <line13> } catch (InterruptedException e) { <line14> } finally { <line15> if (locked) { <line16> boolean unlocked = WorkLock.unlock(); <line17> System.out.println(""Thread "" + id + ""  unlocked="" + unlocked); <line18> } <line19> } <line20> } <line21> } <line22>  <LINE> <line14>"	Yes	task2	
<CODE> public class A { <line0> private void addToNode(Node node, List<WMSLayerState> layerStates) { <line1> for (WMSLayerState layerState : layerStates) { <line2> try { <line3> XMLUtilities.marshalJAXBObjectToElement(layerState, node); <line4> } catch (JAXBException e) { <line5> } <line6> } <line7> } <line8> } <line9>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> private RouterStatus collectStatus(RouterManagement routerManagement, Pod router) { <line1> try { <line2> int port = 0; <line3> for (Container container : router.getSpec().getContainers()) { <line4> if (container.getName().equals(""router"")) { <line5> for (ContainerPort containerPort : container.getPorts()) { <line6> if (containerPort.getName().equals(""amqps-normal"")) { <line7> port = containerPort.getContainerPort(); <line8> } <line9> } <line10> } <line11> } <line12> if (port != 0) { <line13> Map<RouterEntity, List<List<?>>> response = <line14> routerManagement.query(router.getStatus().getPodIP(), port, entities); <line15> RouterConnections connections = null; <line16> if (response.containsKey(connection)) { <line17> connections = collectConnectionInfo(response.get(connection)); <line18> } <line19> List<String> neighbors = null; <line20> if (response.containsKey(node)) { <line21> neighbors = <line22> filterOnAttribute(String.class, 0, response.get(node)).stream() <line23> .filter(n -> !n.equals(router.getMetadata().getName())) <line24> .collect(Collectors.toList()); <line25> } <line26> long undeliveredTotal = 0; <line27> if (response.containsKey(link)) { <line28> List<String> linkTypes = filterOnAttribute(String.class, 0, response.get(link)); <line29> List<UnsignedLong> undelivered = <line30> filterOnAttribute(UnsignedLong.class, 1, response.get(link)); <line31> for (int i = 0; i < linkTypes.size(); i++) { <line32> if (""inter-router"".equals(linkTypes.get(i))) { <line33> undeliveredTotal += undelivered.get(i) != null ? undelivered.get(i).longValue() : 0; <line34> } <line35> } <line36> } <line37> return new RouterStatus( <line38> router.getMetadata().getName(), connections, neighbors, undeliveredTotal); <line39> } <line40> } catch (Exception e) { <line41> } <line42> return null; <line43> } <line44> } <line45>  <LINE> <line41>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> protected Collection<SolrInputDocument> load(URL url) { <line2> try { <line3> Collection<SolrInputDocument> solrDocuments = new HashSet<>(); <line4> Reader in = <line5> new InputStreamReader(url.openConnection().getInputStream(), Charset.forName(""UTF-8"")); <line6> for (CSVRecord row : CSVFormat.TDF.withHeader().parse(in)) { <line7> SolrInputDocument crtTerm = new SolrInputDocument(); <line8> for (Map.Entry<String, String> item : row.toMap().entrySet()) { <line9> if (""hgnc_id"".equals(item.getKey())) { <line10> crtTerm.addField(ID_FIELD_NAME, item.getValue()); <line11> } else if (StringUtils.isNotBlank(item.getValue())) { <line12> crtTerm.addField(item.getKey(), StringUtils.split(item.getValue(), ""|"")); <line13> } <line14> } <line15> solrDocuments.add(crtTerm); <line16> } <line17> addMetaInfo(solrDocuments); <line18> return solrDocuments; <line19> } catch (IOException ex) { <line20> } <line21> return null; <line22> } <line23> } <line24>  <LINE> <line19>"	No	task2	
<CODE> public class A { <line0> @AfterClass <line1> public static void stopCluster() { <line2> if (null != clusterClient) { <line3> clusterClient.shutdown(); <line4> } <line5> if (null != clusterClient) { <line6> clusterServer.shutdown(); <line7> } <line8> } <line9> } <line10>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void resetPassword(String newPassword, Integer secretPin) { <line2> assert newPassword != null; <line3> } <line4> } <line5>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void validate() { <line2> } <line3> } <line4>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void addStringField(String fieldName, String value) { <line2> if (logger.isTraceEnabled()) { <line3> } <line4> fieldList.add(new JSONFieldHolder(fieldName, value, FieldType.STRING)); <line5> } <line6> } <line7>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> private void copyHDFSJobInfo(String jobId) throws Exception { <line1> String srcDirQualified = srcCluster.getJobWorkingDirQualified(jobId); <line2> String dstDirQualified = dstCluster.getJobWorkingDirQualified(jobId); <line3> if (ifExecute) { <line4> dstCluster.copyInitOnJobCluster(new Path(dstDirQualified)); <line5> copyHDFSPath(srcDirQualified, srcCluster.jobConf, dstDirQualified, dstCluster.jobConf); <line6> } else { <line7> } <line8> } <line9> } <line10>  <LINE> <line7>	Yes	task2	
<CODE> public class A { <line0> public void pushNotification(DimeInternalNotification notification) { <line1> Long tenant = notification.getTenant(); <line2> if (mapFifoLists.containsKey(tenant)) { <line3> mapFifoLists.get(tenant).add(notification); <line4> } else { <line5> ConcurrentLinkedQueue<DimeInternalNotification> newFifo = <line6> new ConcurrentLinkedQueue<DimeInternalNotification>(); <line7> newFifo.add(notification); <line8> mapFifoLists.put(tenant, newFifo); <line9> } <line10> } <line11> } <line12>  <LINE> <line1>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public List<ActivityStreamComment> getActionCommentRecords(int id) { <line2> List<ActivityStreamComment> comments = new ArrayList<>(); <line3> Connection conn = null; <line4> PreparedStatement stat = null; <line5> ResultSet result = null; <line6> try { <line7> conn = this.getConnection(); <line8> stat = conn.prepareStatement(GET_ACTION_COMMENT_RECORDS); <line9> stat.setInt(1, id); <line10> result = stat.executeQuery(); <line11> while (result.next()) { <line12> ActivityStreamComment comment = new ActivityStreamComment(); <line13> comment.setId(result.getInt(1)); <line14> comment.setUsername(result.getString(2)); <line15> comment.setCommentText(result.getString(3)); <line16> Timestamp timestamp = result.getTimestamp(4); <line17> comment.setCommentDate(new Date(timestamp.getTime())); <line18> comments.add(comment); <line19> } <line20> } catch (Throwable t) { <line21> throw new RuntimeException(""Error while loading activity stream comment records"", t); <line22> } finally { <line23> closeDaoResources(result, stat, conn); <line24> } <line25> return comments; <line26> } <line27> } <line28>  <LINE> <line11>"	No	task2	
<CODE> public class A { <line0> public OutputStream createOutputStream(long offset) throws IOException { <line1> postClientAction(ClientActionEvent.ClientAction.UPLOAD); <line2> if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { <line3> Uri uri = DocumentsContract.buildDocumentUriUsingTree(startUrl, documentId); <line4> return new TracingBufferedOutputStream(contentResolver.openOutputStream(uri), logger); <line5> } <line6> return null; <line7> } <line8> } <line9>  <LINE> <line1>	Yes	task2	
"<CODE> public class A { <line0> private <T> ServiceResponse<T> executePost(ServiceRequest request) { <line1> ServiceResponse<T> response = new ServiceResponse<>(); <line2> String urlPath = request.getUrlPath(); <line3> if (urlPath == null || urlPath.equals(""/"")) { <line4> return errorResponse(response, 400, POST_ONLY_ALLOWED_TO_COLLECTIONS); <line5> } <line6> PersistenceManager pm = getPm(); <line7> try { <line8> return handlePost(pm, urlPath, response, request); <line9> } catch (IOException | RuntimeException e) { <line10> if (pm != null) { <line11> pm.rollbackAndClose(); <line12> } <line13> return errorResponse(response, 500, ""Failed to store data.""); <line14> } finally { <line15> maybeRollbackAndClose(); <line16> } <line17> } <line18> } <line19>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> public static NamedRelatedResourceRep toNamedRelatedResource(NamedURI resource) { <line1> ResourceTypeEnum resourceType = null; <line2> try { <line3> resourceType = ResourceTypeMapping.getResourceType(URIUtil.getModelClass(resource.getURI())); <line4> } catch (Exception e) { <line5> } <line6> return new NamedRelatedResourceRep( <line7> resource.getURI(), toLink(resourceType, resource.getURI()), resource.getName()); <line8> } <line9> } <line10>  <LINE> <line5>	Yes	task2	
<CODE> public class A { <line0> private Map<Long, Integer> getPriorityMap(final List<OrchestratorStore> orchestratorStoreList) { <line1> final Map<Long, Integer> priorityMap = new HashMap<>(orchestratorStoreList.size()); <line2> for (final OrchestratorStore orchestratorStore : orchestratorStoreList) { <line3> priorityMap.put(orchestratorStore.getId(), orchestratorStore.getPriority()); <line4> } <line5> return priorityMap; <line6> } <line7> } <line8>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> @Override <line1> protected void handleError(Exception exception) { <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> public static void main(String[] args) throws Exception { <line1> final Terminal terminal = TerminalBuilder.builder().system(true).build(); <line2> History defaultHistory = new DefaultHistory(); <line3> Runtime.getRuntime() <line4> .addShutdownHook( <line5> new Thread( <line6> () -> { <line7> try { <line8> defaultHistory.save(); <line9> } catch (IOException e) { <line10> } <line11> })); <line12> final LineReader lineReader = <line13> LineReaderBuilder.builder() <line14> .terminal(terminal) <line15> .highlighter(new DefaultHighlighter()) <line16> .history(defaultHistory) <line17> .build(); <line18> LogServiceShellOpts opts = new LogServiceShellOpts(); <line19> JCommander.newBuilder().addObject(opts).build().parse(args); <line20> try (LogServiceClient logServiceClient = new LogServiceClient(opts.metaQuorum)) { <line21> LogServiceShell client = new LogServiceShell(terminal, lineReader, logServiceClient); <line22> client.run(); <line23> } <line24> } <line25> } <line26>  <LINE> <line14>	No	task2	
<CODE> public class A { <line0> public String getUserName() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> return raProperties.getUserName(); <line4> } <line5> } <line6>  <LINE> <line4>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public CommercePriceListDiscountRel findByC_C(long commerceDiscountId, long commercePriceListId) <line2> throws NoSuchPriceListDiscountRelException { <line3> CommercePriceListDiscountRel commercePriceListDiscountRel = <line4> fetchByC_C(commerceDiscountId, commercePriceListId); <line5> if (commercePriceListDiscountRel == null) { <line6> StringBundler sb = new StringBundler(6); <line7> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line8> sb.append(""commerceDiscountId=""); <line9> sb.append(commerceDiscountId); <line10> sb.append("", commercePriceListId=""); <line11> sb.append(commercePriceListId); <line12> sb.append(""}""); <line13> if (log.isDebugEnabled()) { <line14> } <line15> throw new NoSuchPriceListDiscountRelException(sb.toString()); <line16> } <line17> return commercePriceListDiscountRel; <line18> } <line19> } <line20>  <LINE> <line3>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public List<CommonMessage> getMessage(Long timeout, TimeUnit unit) { <line2> try { <line3> if (this.lastGetBatchMessage != null) { <line4> throw new CanalClientException(""mq get/ack not support concurrent & async ack""); <line5> } <line6> ConsumerBatchMessage<CommonMessage> batchMessage = messageBlockingQueue.poll(timeout, unit); <line7> if (batchMessage != null) { <line8> this.lastGetBatchMessage = batchMessage; <line9> return batchMessage.getData(); <line10> } <line11> } catch (InterruptedException ex) { <line12> throw new CanalClientException(""Failed to fetch the data after: "" + timeout); <line13> } <line14> return null; <line15> } <line16> } <line17>  <LINE> <line12>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public InputStream getStream() throws DataStoreException { <line2> File cached = null; <line3> try { <line4> cached = store.cache.get(getIdentifier().toString()); <line5> } catch (final Exception e) { <line6> } <line7> try { <line8> if (cached == null || !cached.exists()) { <line9> InputStream in = null; <line10> try { <line11> TransientFileFactory fileFactory = TransientFileFactory.getInstance(); <line12> File tmpFile = fileFactory.createTransientFile(""temp0cache"", null, temp); <line13> in = backend.getRecord(getIdentifier()).getStream(); <line14> copyInputStreamToFile(in, tmpFile); <line15> return new LazyFileInputStream(tmpFile); <line16> } finally { <line17> Closeables.close(in, false); <line18> } <line19> } else { <line20> return new FileInputStream(cached); <line21> } <line22> } catch (final Exception e) { <line23> throw new DataStoreException( <line24> ""Error opening input stream for identifier "" + getIdentifier(), e); <line25> } <line26> } <line27> } <line28>  <LINE> <line5>"	No	task2	
<CODE> public class A { <line0> private void processThermometer(JablotronServiceDetailSegment segment) { <line1> String segmentId = segment.getSegmentId().toLowerCase(); <line2> Channel channel = getThing().getChannel(segmentId); <line3> if (channel == null) { <line4> createTempChannel(segmentId, segment.getSegmentName()); <line5> processThermometer(segment); <line6> return; <line7> } <line8> updateTemperatureChannel(channel, segment); <line9> } <line10> } <line11>  <LINE> <line4>	Yes	task2	
"<CODE> public class A { <line0> @Cacheable(""import-funding-clients"") <line1> public List<ImportWizzardClientForm> findOrcidClientsWithPredefinedOauthScopeFundingImport( <line2> Locale locale) { <line3> updateLocalCacheVersion(); <line4> return generateImportWizzardForm(RedirectUriType.IMPORT_FUNDING_WIZARD, locale); <line5> } <line6> } <line7>  <LINE> <line2>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> protected void include( <line2> String path, PortletRequest portletRequest, PortletResponse portletResponse, String lifecycle) <line3> throws IOException, PortletException { <line4> PortletContext portletContext = getPortletContext(); <line5> String servletContextName = portletContext.getPortletContextName(); <line6> String resourcePath = <line7> StringBundler.concat(servletContextName, TemplateConstants.SERVLET_SEPARATOR, path); <line8> boolean resourceExists = false; <line9> try { <line10> resourceExists = <line11> TemplateResourceLoaderUtil.hasTemplateResource( <line12> TemplateConstants.LANG_TYPE_FTL, resourcePath); <line13> } catch (TemplateException templateException) { <line14> throw new IOException(templateException); <line15> } <line16> if (!resourceExists) { <line17> } else { <line18> try { <line19> TemplateResource templateResource = <line20> TemplateResourceLoaderUtil.getTemplateResource( <line21> TemplateConstants.LANG_TYPE_FTL, resourcePath); <line22> Template template = <line23> TemplateManagerUtil.getTemplate( <line24> TemplateConstants.LANG_TYPE_FTL, templateResource, false); <line25> template.prepareTaglib( <line26> PortalUtil.getHttpServletRequest(portletRequest), <line27> PortalUtil.getHttpServletResponse(portletResponse)); <line28> template.put(""portletContext"", getPortletContext()); <line29> template.put(""userInfo"", portletRequest.getAttribute(PortletRequest.USER_INFO)); <line30> template.prepare(PortalUtil.getHttpServletRequest(portletRequest)); <line31> Writer writer = null; <line32> if (portletResponse instanceof MimeResponse) { <line33> MimeResponse mimeResponse = (MimeResponse) portletResponse; <line34> writer = UnsyncPrintWriterPool.borrow(mimeResponse.getWriter()); <line35> } else { <line36> writer = new UnsyncStringWriter(); <line37> } <line38> template.processTemplate(writer); <line39> } catch (Exception exception) { <line40> throw new PortletException(exception); <line41> } <line42> } <line43> if (clearRequestParameters && lifecycle.equals(PortletRequest.RENDER_PHASE)) { <line44> portletResponse.setProperty(""clear-request-parameters"", ""true""); <line45> } <line46> } <line47> } <line48>  <LINE> <line17>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void apply() { <line2> try { <line3> for (int i = 0; i < TOP_CHANGE_CNT; i++) { <line4> if (failed.get()) return; <line5> Collection<String> names = new GridLeanSet<>(3); <line6> try { <line7> for (int j = 0; j < 3; j++) { <line8> if (failed.get()) return; <line9> String name = UUID.randomUUID().toString(); <line10> Ignite g = startGrid(name); <line11> names.add(name); <line12> cb.apply(g); <line13> } <line14> } finally { <line15> for (String name : names) stopGrid(name); <line16> } <line17> } <line18> } catch (Exception e) { <line19> if (failed.compareAndSet(false, true)) throw F.wrap(e); <line20> } <line21> } <line22> } <line23>  <LINE> <line10>	Yes	task2	
"<CODE> public class A { <line0> @NotNull <line1> private List<String> updateImpersonators( <line2> @NotNull Authorizable a, <line3> @NotNull Impersonation imp, <line4> @NotNull Map<String, Principal> toRemove, <line5> @NotNull List<String> toAdd) <line6> throws RepositoryException { <line7> for (Principal p : toRemove.values()) { <line8> if (!imp.revokeImpersonation(p)) { <line9> String principalName = p.getName(); <line10> handleFailure(""Failed to revoke impersonation for "" + principalName + "" on "" + a); <line11> } <line12> } <line13> List<String> nonExisting = new ArrayList<>(); <line14> for (String principalName : toAdd) { <line15> Principal principal = <line16> (principals.containsKey(principalName)) <line17> ? principals.get(principalName) <line18> : new PrincipalImpl(principalName); <line19> if (!imp.grantImpersonation(principal)) { <line20> handleFailure(""Failed to grant impersonation for "" + principalName + "" on "" + a); <line21> if (importBehavior == ImportBehavior.BESTEFFORT <line22> && getPrincipalManager().getPrincipal(principalName) == null) { <line23> nonExisting.add(principalName); <line24> } <line25> } <line26> } <line27> return nonExisting; <line28> } <line29> } <line30>  <LINE> <line23>"	Yes	task2	
"<CODE> public class A { <line0> @SuppressFBWarnings( <line1> value = ""RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE"", <line2> justification = ""False positive by try with resources."") <line3> public Locale[] getAvailableLocales() { <line4> synchronized (LOCKS.get(LocksKeys.LOCALES)) { <line5> if (locales == null) { <line6> List<Locale> l = new ArrayList<>(); <line7> try (InputStream in = SettingsService.class.getResourceAsStream(LOCALES_FILE)) { <line8> String[] lines = StringUtil.readLines(in); <line9> for (String line : lines) { <line10> l.add(StringUtil.parseLocale(line)); <line11> } <line12> } catch (IOException x) { <line13> if (LOG.isErrorEnabled()) { <line14> } <line15> l.add(Locale.ENGLISH); <line16> } <line17> locales = l.toArray(new Locale[0]); <line18> } <line19> } <line20> return locales; <line21> } <line22> } <line23>  <LINE> <line14>"	Yes	task2	
<CODE> public class A { <line0> @Transactional <line1> private void importXLIFF(ImportExportedXliffStep importExportedXliffStep, String xliffContent) { <line2> IPipelineDriver driver = new PipelineDriver(); <line3> XLIFFFilter xliffFilter = new XLIFFFilter(); <line4> driver.addStep(new RawDocumentToFilterEventsStep(xliffFilter)); <line5> importExportedXliffStep.setXliffFilter(xliffFilter); <line6> driver.addStep(importExportedXliffStep); <line7> RawDocument rawDocument = new RawDocument(xliffContent, LocaleId.ENGLISH); <line8> driver.addBatchItem(rawDocument); <line9> driver.processBatch(); <line10> } <line11> } <line12>  <LINE> <line9>	Yes	task2	
"<CODE> public class A { <line0> protected void reloadContentTypeConfigForChildren( <line1> String site, RepositoryItem node, List<ContentTypeConfigTO> contentTypes) { <line2> String contentTypesRootPath = getConfigPath().replaceAll(StudioConstants.PATTERN_SITE, site); <line3> String fullPath = node.path + FILE_SEPARATOR + node.name; <line4> RepositoryItem[] folders = contentRepository.getContentChildren(site, fullPath); <line5> if (folders != null) { <line6> for (int i = 0; i < folders.length; i++) { <line7> if (folders[i].isFolder) { <line8> String configPath = <line9> folders[i].path <line10> + FILE_SEPARATOR <line11> + folders[i].name <line12> + FILE_SEPARATOR <line13> + getConfigFileName(); <line14> if (contentService.contentExists(site, configPath)) { <line15> ContentTypeConfigTO config = <line16> contentTypesConfig.reloadConfiguration( <line17> site, <line18> configPath <line19> .replace(contentTypesRootPath, """") <line20> .replace(FILE_SEPARATOR + getConfigFileName(), """")); <line21> if (config != null) { <line22> contentTypes.add(config); <line23> } <line24> } <line25> reloadContentTypeConfigForChildren(site, folders[i], contentTypes); <line26> } <line27> } <line28> } <line29> } <line30> } <line31>  <LINE> <line4>"	Yes	task2	
"<CODE> public class A { <line0> private Response doAdvancedSearch(String propertyName, String propertyValue, String operator) <line1> throws Exception { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> String whereClause = propertyName + operator + ""'"" + propertyValue + ""'""; <line5> CollectionObjectClient client = new CollectionObjectClient(); <line6> Response res = client.advancedSearchIncludeDeleted(whereClause, false); <line7> return res; <line8> } <line9> } <line10>  <LINE> <line8>"	No	task2	
<CODE> public class A { <line0> @Override <line1> protected String encodeAndEncrypt(MethodCallMessage secureRequest, SecretKey sessionKey) <line2> throws Exception { <line3> byte[] content = mapper.writeValueAsBytes(secureRequest); <line4> byte[] encryptedContent = CipherUtils.encrypt(content, sessionKey); <line5> EncryptedMessage encryptedMessage = new EncryptedMessage(); <line6> encryptedMessage.setEncryptedContent(encryptedContent); <line7> byte[] encryptedKey = CipherUtils.encrypt(sessionKey.getEncoded(), serverPublicKey); <line8> encryptedMessage.setEncryptedKey(encryptedKey); <line9> return mapper.writeValueAsString(encryptedMessage); <line10> } <line11> } <line12>  <LINE> <line10>	No	task2	
"<CODE> public class A { <line0> public String getCGN(final String id) throws TaskFailedException { <line1> String cgn = """"; <line2> pstmt = null; <line3> List<Object[]> rsCgn = null; <line4> if (!id.equals("""")) <line5> try { <line6> final String queryCgn = ""select CGN from VOUCHERHEADER where id=?""; <line7> pstmt = persistenceService.getSession().createSQLQuery(queryCgn); <line8> pstmt.setString(0, id); <line9> rsCgn = pstmt.list(); <line10> for (final Object[] element : rsCgn) cgn = element[0].toString(); <line11> } catch (final Exception sqlex) { <line12> throw taskExc; <line13> } <line14> return cgn; <line15> } <line16> } <line17>  <LINE> <line4>"	No	task2	
<CODE> public class A { <line0> public Set<String> getOpenInstancesInternal() { <line1> Set<String> openInstances = <line2> Sets.newHashSet(modifyConfig.getContainedNamespaces(REGISTRATION_NS)); <line3> return openInstances; <line4> } <line5> } <line6>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> private void checkFileTTL(TsFileResource resource, long timeLowerBound, boolean isSeq) { <line1> if (resource.isMerging() <line2> || !resource.isClosed() <line3> || !resource.isDeleted() && resource.stillLives(timeLowerBound)) { <line4> return; <line5> } <line6> writeLock(); <line7> try { <line8> resource.setDeleted(true); <line9> if (resource.isMerging()) { <line10> return; <line11> } <line12> if (resource.tryWriteLock()) { <line13> try { <line14> resource.remove(); <line15> if (logger.isInfoEnabled()) { <line16> } <line17> tsFileManagement.remove(resource, isSeq); <line18> } finally { <line19> resource.writeUnlock(); <line20> } <line21> } <line22> } finally { <line23> writeUnlock(); <line24> } <line25> } <line26> } <line27>  <LINE> <line16>	Yes	task2	
"<CODE> public class A { <line0> public static void executeApiTask( <line1> BlockService blockService, <line2> ExecutorService executorService, <line3> DbClient dbClient, <line4> VirtualArray varray, <line5> Project project, <line6> VirtualPool vpool, <line7> VirtualPoolCapabilityValuesWrapper capabilities, <line8> TaskList taskList, <line9> String task, <line10> BlockConsistencyGroup consistencyGroup, <line11> ArrayList<String> requestedTypes, <line12> VolumeCreate param, <line13> BlockServiceApi blockServiceImpl) { <line14> CreateVolumeSchedulingThread schedulingThread = <line15> new CreateVolumeSchedulingThread( <line16> blockService, <line17> varray, <line18> project, <line19> vpool, <line20> capabilities, <line21> taskList, <line22> task, <line23> consistencyGroup, <line24> requestedTypes, <line25> param, <line26> blockServiceImpl); <line27> try { <line28> executorService.execute(schedulingThread); <line29> } catch (Exception e) { <line30> for (TaskResourceRep taskObj : taskList.getTaskList()) { <line31> String message = <line32> ""Failed to execute volume creation API task for resource "" <line33> + taskObj.getResource().getId(); <line34> taskObj.setMessage(message); <line35> Volume volume = dbClient.queryObject(Volume.class, taskObj.getResource().getId()); <line36> volume.setInactive(true); <line37> dbClient.updateObject(volume); <line38> } <line39> } <line40> } <line41> } <line42>  <LINE> <line34>"	Yes	task2	
<CODE> public class A { <line0> public String getPrivateKey() { <line1> RSAPrivateKeyHolder keyHolder = keyProvider.getPrivateKey(); <line2> if (keyHolder == null) { <line3> return null; <line4> } <line5> try { <line6> return SshKeyGen.toPEM(keyProvider.getPrivateKey().getKey()); <line7> } catch (Exception e) { <line8> return null; <line9> } <line10> } <line11> } <line12>  <LINE> <line10>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void logError(Throwable e) { <line2> ILogger logger = getLogger(); <line3> if (e instanceof PartitionStateVersionMismatchException) { <line4> if (logger.isFineEnabled()) { <line5> logger.fine(e.getMessage(), e); <line6> } else { <line7> } <line8> return; <line9> } <line10> if (!nodeStartCompleted && e instanceof IllegalStateException) { <line11> logger.warning(e.getMessage()); <line12> if (logger.isFineEnabled()) { <line13> logger.fine(e); <line14> } <line15> return; <line16> } <line17> super.logError(e); <line18> } <line19> } <line20>  <LINE> <line7>	Yes	task2	
<CODE> public class A { <line0> private void tryResetWorkerCreationCoolDown() { <line1> if (startWorkerCoolDown.isDone()) { <line2> startWorkerCoolDown = new CompletableFuture<>(); <line3> scheduleRunAsync(() -> startWorkerCoolDown.complete(null), startWorkerRetryInterval); <line4> } <line5> } <line6> } <line7>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> private void submit(Runnable action) { <line1> boolean empty; <line2> synchronized (this) { <line3> empty = actions.isEmpty(); <line4> actions.offer(action); <line5> } <line6> if (empty && process()) { <line7> synchronized (this) { <line8> if (logger.isDebugEnabled()) { <line9> } <line10> notifyAll(); <line11> } <line12> } <line13> } <line14> } <line15>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> public boolean removeMessageListener(Object topic, @Nullable GridMessageListener lsnr) { <line1> assert topic != null; <line2> boolean rmv = true; <line3> Collection<GridCommunicationMessageSet> msgSets = null; <line4> if (lsnr == null) { <line5> closedTopics.add(topic); <line6> lsnr = listenerRemove0(topic); <line7> rmv = lsnr != null; <line8> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line9> if (map != null) msgSets = map.values(); <line10> } else { <line11> for (; ; ) { <line12> GridMessageListener lsnrs = listenerGet0(topic); <line13> if (lsnrs == null) { <line14> closedTopics.add(topic); <line15> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line16> if (map != null) msgSets = map.values(); <line17> rmv = false; <line18> break; <line19> } else { <line20> boolean empty = false; <line21> if (!(lsnrs instanceof ArrayListener)) { <line22> if (lsnrs.equals(lsnr)) { <line23> if (!listenerRemove0(topic, lsnrs)) continue; <line24> empty = true; <line25> } else rmv = false; <line26> } else { <line27> ArrayListener arrLsnr = (ArrayListener) lsnrs; <line28> if (arrLsnr.remove(lsnr)) empty = arrLsnr.isEmpty(); <line29> else rmv = false; <line30> if (empty) listenerRemove0(topic, lsnrs); <line31> } <line32> if (empty) { <line33> closedTopics.add(topic); <line34> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line35> if (map != null) msgSets = map.values(); <line36> } <line37> break; <line38> } <line39> } <line40> } <line41> if (msgSets != null) <line42> for (GridCommunicationMessageSet msgSet : msgSets) ctx.timeout().removeTimeoutObject(msgSet); <line43> if (rmv && log.isDebugEnabled()) <line44> if (lsnr instanceof ArrayListener) { <line45> for (GridMessageListener childLsnr : ((ArrayListener) lsnr).arr) closeListener(childLsnr); <line46> } else closeListener(lsnr); <line47> return rmv; <line48> } <line49> } <line50>  <LINE> <line13>	No	task2	
<CODE> public class A { <line0> protected void postStartCustom() { <line1> boolean result = false; <line2> result |= tryCheckStartPid(); <line3> result |= tryCheckStartService(); <line4> result |= tryCheckStartWindowsService(); <line5> if (!result) { <line6> } <line7> entity().sensors().set(SoftwareProcess.SERVICE_UP, true); <line8> } <line9> } <line10>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void remotelyClosed(AmqpConnection connection) { <line2> Exception error = AmqpSupport.convertToException(getEndpoint().getRemoteCondition()); <line3> if (endpoint != null) { <line4> endpoint.close(); <line5> } <line6> connection.fireClientException(error); <line7> } <line8> } <line9>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> public int run() { <line1> String scriptContents = toScript(props, commands, env); <line2> if (LOG.isTraceEnabled()) <line3> copyTempFileToServer( <line4> ImmutableMap.of(""permissions"", ""0700""), writeTempFile(scriptContents), scriptPath); <line5> String cmd = Strings.join(buildRunScriptCommand(), separator); <line6> return asInt(sshExec(props, cmd), -1); <line7> } <line8> } <line9>  <LINE> <line3>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void configure() { <line2> if (context.getRoute(""direct.route"") == null) { <line3> from(""direct:start"").id(""direct.route"").to(destinationName); <line4> } <line5> from(destinationName + ""?transacted=true&concurrentConsumers="" + concurrentConsumers) <line6> .id(""consumer.route."" + routeNumber) <line7> .choice() <line8> .when(header(""JMSRedelivered"").isEqualTo(""false"")) <line9> .log( <line10> ""Route "" <line11> + routeNumber <line12> + "" 1st attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}"") <line13> .to(""mock:test.before."" + routeNumber) <line14> .process( <line15> new Processor() { <line16> private final AtomicInteger counter = new AtomicInteger(); <line17>  <line18> @Override <line19> public void process(Exchange exchange) throws Exception { <line20> if (counter.incrementAndGet() == maxAttemptsCount) { <line21> throw new IllegalArgumentException(""Forced rollback""); <line22> } <line23> latch.countDown(); <line24> } <line25> }) <line26> .when(header(""JMSRedelivered"").isEqualTo(""true"")) <line27> .log( <line28> ""Route "" <line29> + routeNumber <line30> + "" 2nd attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}"") <line31> .to(""mock:test.after."" + routeNumber) <line32> .process( <line33> new Processor() { <line34> @Override <line35> public void process(Exchange exchange) throws Exception { <line36> latch.countDown(); <line37> } <line38> }) <line39> .otherwise() <line40> .to(""mock:test.after""); <line41> } <line42> } <line43>  <LINE> <line35>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void deleteCategory(String code) throws ApsSystemException { <line2> Category cat = this.getCategory(code); <line3> if (cat == null || cat.getChildrenCodes().length > 0) { <line4> throw new ApsSystemException(""Error detected while removing a category""); <line5> } <line6> try { <line7> this.getCategoryDAO().deleteCategory(code); <line8> this.getCacheWrapper().deleteCategory(code); <line9> } catch (Throwable t) { <line10> throw new ApsSystemException(""Error detected while removing a category"", t); <line11> } <line12> } <line13> } <line14>  <LINE> <line6>"	No	task2	
<CODE> public class A { <line0> private ListenableFuture<ResultSet> rollupOneFromChildren( <line1> int rollupLevel, <line2> String agentRollupId, <line3> String gaugeName, <line4> List<String> childAgentRollupIds, <line5> long captureTime, <line6> int adjustedTTL) <line7> throws Exception { <line8> List<ListenableFuture<ResultSet>> futures = new ArrayList<>(); <line9> for (String childAgentRollupId : childAgentRollupIds) { <line10> BoundStatement boundStatement = readValueForRollupFromChildPS.bind(); <line11> int i = 0; <line12> boundStatement.setString(i++, childAgentRollupId); <line13> boundStatement.setString(i++, gaugeName); <line14> boundStatement.setTimestamp(i++, new Date(captureTime)); <line15> futures.add(session.executeAsync(boundStatement)); <line16> } <line17> return Futures.transformAsync( <line18> Futures.allAsList(futures), <line19> new AsyncFunction<List<ResultSet>, ResultSet>() { <line20> @Override <line21> public ListenableFuture<ResultSet> apply(@Nullable List<ResultSet> results) <line22> throws Exception { <line23> checkNotNull(results); <line24> List<Row> rows = new ArrayList<>(); <line25> for (int i = 0; i < results.size(); i++) { <line26> Row row = results.get(i).one(); <line27> if (row == null) { <line28> } else { <line29> rows.add(row); <line30> } <line31> } <line32> if (rows.isEmpty()) { <line33> return Futures.immediateFuture(DummyResultSet.INSTANCE); <line34> } <line35> return rollupOneFromRows( <line36> rollupLevel, agentRollupId, gaugeName, captureTime, adjustedTTL, rows); <line37> } <line38> }, <line39> MoreExecutors.directExecutor()); <line40> } <line41> } <line42>  <LINE> <line28>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> synchronized (this) { <line4> wait(timeoutSeconds * 1000); <line5> } <line6> if (!interrupted) { <line7> process.destroy(); <line8> } <line9> } catch (InterruptedException e) { <line10> } <line11> } <line12> } <line13>  <LINE> <line4>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void saveState(Node node) { <line2> Document doc = node instanceof Document ? (Document) node : node.getOwnerDocument(); <line3> try { <line4> Node timeNode = <line5> (Node) <line6> StateXML.newXPath() <line7> .evaluate( <line8> ""/"" + ModuleStateController.STATE_QNAME + ""/:time"", <line9> node, <line10> XPathConstants.NODE); <line11> if (timeNode == null) { <line12> timeNode = StateXML.createElement(doc, ""time""); <line13> node.appendChild(timeNode); <line14> } <line15> saveCurrentState(timeNode); <line16> saveHeldState(timeNode); <line17> saveFadeState(timeNode); <line18> } catch (XPathExpressionException e) { <line19> } <line20> } <line21> } <line22>  <LINE> <line10>"	No	task2	
"<CODE> public class A { <line0> protected void awaitTopicConfigInKafka(String topicName, String key, String expectedValue) <line1> throws InterruptedException, ExecutionException, TimeoutException { <line2> waitFor( <line3> () -> { <line4> ConfigResource configResource = topicConfigResource(topicName); <line5> org.apache.kafka.clients.admin.Config config = getTopicConfig(configResource); <line6> String retention = config.get(""retention.ms"").value(); <line7> return expectedValue.equals(retention); <line8> }, <line9> ""Expected the topic "" + topicName + "" to have retention.ms="" + expectedValue + "" in Kafka""); <line10> } <line11> } <line12>  <LINE> <line7>"	Yes	task2	
<CODE> public class A { <line0> public void onNewMessage(ChannelHandlerContext ctx, Message message) { <line1> } <line2> } <line3>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> private void forwardRequestWithoutAuthorizationCheck( <line1> HttpServletRequest req, HttpServletResponse res, FilterChain chain) <line2> throws IOException, ServletException { <line3> chain.doFilter(req, res); <line4> } <line5> } <line6>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> public void checkProduce(T item) { <line1> if (countdownLatch.getCount() < numWorkers) { <line2> drain(); <line3> start(); <line4> } <line5> produce(item); <line6> } <line7> } <line8>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> public void setJUnitResultDir(String dir) { <line1> jUnitResult.setDir(dir); <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> protected void doStop() throws Exception { <line2> if (LOG.isDebugEnabled() && statisticsEnabled) { <line3> } <line4> } <line5> } <line6>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> public static void createWithParents(ZooKeeper zk, String node, byte[] data) <line1> throws KeeperException { <line2> try { <line3> if (node == null) { <line4> return; <line5> } <line6> zk.create(node, data, createACL(zk, node), CreateMode.PERSISTENT); <line7> } catch (KeeperException.NodeExistsException nee) { <line8> return; <line9> } catch (KeeperException.NoNodeException nne) { <line10> createWithParents(zk, getParent(node)); <line11> createWithParents(zk, node, data); <line12> } catch (InterruptedException ie) { <line13> } <line14> } <line15> } <line16>  <LINE> <line13>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void getRateLimitStatus(final String... resources) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(RATE_LIMIT_STATUS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> Map<String, RateLimitStatus> rateLimitStatus = <line8> twitter.getRateLimitStatus(resources); <line9> for (TwitterListener listener : listeners) { <line10> try { <line11> listener.gotRateLimitStatus(rateLimitStatus); <line12> } catch (Exception e) { <line13> } <line14> } <line15> } <line16> }); <line17> } <line18> } <line19>  <LINE> <line13>	Yes	task2	
<CODE> public class A { <line0> long findConflict(List<Log> entries) { <line1> for (Log entry : entries) { <line2> if (!matchTerm(entry.getCurrLogTerm(), entry.getCurrLogIndex())) { <line3> if (entry.getCurrLogIndex() <= getLastLogIndex()) { <line4> } <line5> return entry.getCurrLogIndex(); <line6> } <line7> } <line8> return -1; <line9> } <line10> } <line11>  <LINE> <line6>	No	task2	
<CODE> public class A { <line0> @Override <line1> public CommerceAddressRestriction findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchAddressRestrictionException { <line3> CommerceAddressRestriction commerceAddressRestriction = fetchByPrimaryKey(primaryKey); <line4> if (commerceAddressRestriction == null) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchAddressRestrictionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return commerceAddressRestriction; <line10> } <line11> } <line12>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> @Override <line1> public List<SingularityRequestHistory> getRequestHistory( <line2> String requestId, <line3> Optional<Long> createdBefore, <line4> Optional<Long> createdAfter, <line5> Optional<OrderDirection> orderDirection, <line6> Integer limitStart, <line7> Integer limitCount) { <line8> List<SingularityRequestHistory> singularityRequestHistoryList = <line9> history.getRequestHistory( <line10> requestId, <line11> createdBefore, <line12> createdAfter, <line13> getOrderDirection(orderDirection), <line14> limitStart, <line15> limitCount); <line16> if (LOG.isTraceEnabled()) { <line17> } <line18> return singularityRequestHistoryList; <line19> } <line20> } <line21>  <LINE> <line14>	No	task2	
<CODE> public class A { <line0> private static void updateOnImageFile(Document mets, String fileId, String path) { <line1> List<String> customFileGroups = getFileGroups(mets); <line2> PhysicalSubDiv div = <line3> new PhysicalSubDiv(PhysicalSubDiv.ID_PREFIX + fileId, PhysicalSubDiv.TYPE_PAGE); <line4> div.add(new Fptr(fileId)); <line5> customFileGroups.stream() <line6> .map(customFileGroup -> searchFileInGroup(mets, path, customFileGroup)) <line7> .filter(Objects::nonNull) <line8> .map(Fptr::new) <line9> .forEach(div::add); <line10> Element structMapPhys = getPhysicalStructmap(mets); <line11> structMapPhys.addContent(div.asElement()); <line12> SmLink smLink = getDefaultSmLink(mets, div); <line13> Element structLink = getStructLink(mets); <line14> structLink.addContent(smLink.asElement()); <line15> } <line16> } <line17>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> private void logNamespaces(Exchange exchange) { <line1> InputStream is = null; <line2> NodeList answer = null; <line3> XPathExpression xpathExpression = null; <line4> try { <line5> xpathExpression = poolLogNamespaces.poll(); <line6> if (xpathExpression == null) { <line7> xpathExpression = createTraceNamespaceExpression(); <line8> } <line9> Object document; <line10> if (isInputStreamNeeded(exchange)) { <line11> is = exchange.getIn().getBody(InputStream.class); <line12> document = getDocument(exchange, is); <line13> } else { <line14> Object body = exchange.getIn().getBody(); <line15> document = getDocument(exchange, body); <line16> } <line17> if (document instanceof InputSource) { <line18> InputSource inputSource = (InputSource) document; <line19> answer = (NodeList) xpathExpression.evaluate(inputSource, XPathConstants.NODESET); <line20> } else if (document instanceof DOMSource) { <line21> DOMSource source = (DOMSource) document; <line22> answer = (NodeList) xpathExpression.evaluate(source.getNode(), XPathConstants.NODESET); <line23> } else if (document instanceof SAXSource) { <line24> SAXSource source = (SAXSource) document; <line25> Object result = xpathExpression.evaluate(source.getInputSource(), XPathConstants.NODESET); <line26> if (result instanceof NodeList) { <line27> answer = (NodeList) result; <line28> } else { <line29> answer = null; <line30> } <line31> } else { <line32> answer = (NodeList) xpathExpression.evaluate(document, XPathConstants.NODESET); <line33> } <line34> } catch (Exception e) { <line35> } finally { <line36> IOHelper.close(is); <line37> poolLogNamespaces.add(xpathExpression); <line38> } <line39> if (answer != null) { <line40> logDiscoveredNamespaces(answer); <line41> } <line42> } <line43> } <line44>  <LINE> <line35>	Yes	task2	
"<CODE> public class A { <line0> private void index() { <line1> try { <line2> Model dbpedia = ModelFactory.createDefaultModel(); <line3> dbpedia.read( <line4> this.getClass().getClassLoader().getResource(""dbpedia_2015-10.owl"").getPath(), ""RDF/XML""); <line5> StmtIterator stmts = dbpedia.listStatements(null, RDFS.label, (RDFNode) null); <line6> while (stmts.hasNext()) { <line7> final Statement stmt = stmts.next(); <line8> RDFNode label = stmt.getObject(); <line9> if (label.asLiteral().getLanguage().equals(""en"")) { <line10> addDocumentToIndex(stmt.getSubject(), ""rdfs:label"", label.asLiteral().getString()); <line11> NodeIterator comment = dbpedia.listObjectsOfProperty(stmt.getSubject(), RDFS.comment); <line12> while (comment.hasNext()) { <line13> RDFNode next = comment.next(); <line14> if (next.asLiteral().getLanguage().equals(""en"")) { <line15> addDocumentToIndex(stmt.getSubject(), ""rdfs:comment"", next.asLiteral().getString()); <line16> } <line17> } <line18> } <line19> } <line20> iwriter.commit(); <line21> iwriter.close(); <line22> } catch (IOException e) { <line23> } <line24> } <line25> } <line26>  <LINE> <line16>"	No	task2	
<CODE> public class A { <line0> protected EntitySpec<BrooklynNode> newBrooklynNodeSpecForTest() { <line1> return EntitySpec.create(BrooklynNode.class) <line2> .configure(BrooklynNode.WEB_CONSOLE_BIND_ADDRESS, Networking.ANY_NIC) <line3> .configure(BrooklynNode.ON_EXISTING_PROPERTIES_FILE, ExistingFileBehaviour.DO_NOT_USE); <line4> } <line5> } <line6>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void setOnline(boolean didGII, boolean wasAtomicCreation, PersistentMemberID newId) <line2> throws ReplyException { <line3> if (atomicCreation) { <line4> if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR_VERBOSE)) { <line5> } <line6> } else { <line7> super.setOnline(didGII, wasAtomicCreation, newId); <line8> } <line9> } <line10> } <line11>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> @Path(""/deleteShouldSucceed"") <line1> @POST <line2> public void deleteShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.DELETE); <line4> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, DOMAIN_ID); <line5> } <line6> } <line7>  <LINE> <line6>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public LocalSolvablePolynomial<C> parse(Reader r) { <line3> GenPolynomialTokenizer pt = new GenPolynomialTokenizer(this, r); <line4> LocalSolvablePolynomial<C> p = null; <line5> try { <line6> GenSolvablePolynomial<SolvableLocal<C>> s = pt.nextSolvablePolynomial(); <line7> p = new LocalSolvablePolynomial<C>(this, s); <line8> } catch (IOException e) { <line9> p = ZERO; <line10> } <line11> return p; <line12> } <line13> } <line14>  <LINE> <line6>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void beforeProcessing(ListenerContext listenerContext) { <line2> WorkflowInstance instance = listenerContext.instance; <line3> MDC.put( <line4> logContext, <line5> format( <line6> LOG_CONTEXT_FORMAT, <line7> instance.type, <line8> instance.id, <line9> instance.externalId, <line10> instance.businessKey)); <line11> if (LOG.isDebugEnabled() && !instance.stateVariables.isEmpty()) { <line12> } <line13> } <line14> } <line15>  <LINE> <line14>	No	task2	
<CODE> public class A { <line0> public void close() { <line1> if (pending.isEmpty()) { <line2> try { <line3> if (dir.fileExists(INDEXING_QUEUE_FILE)) { <line4> dir.deleteFile(INDEXING_QUEUE_FILE); <line5> } <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> } <line11>  <LINE> <line7>	Yes	task2	
"<CODE> public class A { <line0> public ChannelFuture send() { <line1> ChannelFuture channelFuture; <line2> if (content instanceof File) { <line3> File file = (File) content; <line4> try { <line5> channelFuture = sendFile(file); <line6> } catch (IOException e) { <line7> channelFuture = sendError(HttpResponseStatus.FORBIDDEN, """"); <line8> } <line9> } else { <line10> channelFuture = sendFull(); <line11> } <line12> this.isSent = true; <line13> return channelFuture; <line14> } <line15> } <line16>  <LINE> <line14>"	No	task2	
<CODE> public class A { <line0> public void close() { <line1> for (FilterHolder filterHolder : _filtersRepository.values()) { <line2> try { <line3> filterHolder.getFilter().close(); <line4> } catch (RuntimeException ex) { <line5> if (logger.isErrorEnabled()) { <line6> } <line7> } <line8> } <line9> } <line10> } <line11>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> public void testInitialContext() throws Exception { <line1> InitialContext context = new InitialContext(); <line2> ActiveMQConnectionFactory connectionFactory = <line3> (ActiveMQConnectionFactory) context.lookup(""ConnectionFactory""); <line4> assertTrue(""Should have created a ConnectionFactory"", connectionFactory != null); <line5> } <line6> } <line7>  <LINE> <line5>"	Yes	task2	
<CODE> public class A { <line0> private void processMatchedGroupMembers( <line1> ComparableGroupItem group, Collection<ComparableMemberItem> matchedMembers, boolean dryRun) { <line2> for (ComparableMemberItem member : matchedMembers) { <line3> if (!dryRun) { <line4> edu.internet2.middleware.grouper.Member grouperMember = member.getGrouperMember(); <line5> try { <line6> connector.updateGooMember( <line7> group.getGrouperGroup(), <line8> grouperMember.getSubject(), <line9> connector.determineRole(grouperMember, group.getGrouperGroup())); <line10> } catch (IOException e) { <line11> } <line12> } <line13> } <line14> } <line15> } <line16>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> @Override <line1> public FrontierReportLine getLineForDomain(String domainName) { <line2> try { <line3> return linesByDomain.get(domainName); <line4> } catch (DatabaseException e) { <line5> return null; <line6> } <line7> } <line8> } <line9>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> public void format() throws IOException { <line1> URI location = getLocation(); <line2> if (mUfs.isDirectory(location.toString())) { <line3> for (UfsStatus status : mUfs.listStatus(location.toString())) { <line4> String childPath = URIUtils.appendPathOrDie(location, status.getName()).toString(); <line5> if (status.isDirectory() <line6> && !mUfs.deleteDirectory(childPath, DeleteOptions.defaults().setRecursive(true)) <line7> || status.isFile() && !mUfs.deleteFile(childPath)) { <line8> throw new IOException(String.format(""Failed to delete %s"", childPath)); <line9> } <line10> } <line11> } else if (!mUfs.mkdirs(location.toString())) { <line12> throw new IOException(String.format(""Failed to create %s"", location)); <line13> } <line14> UnderFileSystemUtils.touch( <line15> mUfs, <line16> URIUtils.appendPathOrDie( <line17> location, <line18> ServerConfiguration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX) <line19> + System.currentTimeMillis()) <line20> .toString()); <line21> } <line22> } <line23>  <LINE> <line2>"	Yes	task2	
<CODE> public class A { <line0> private SessionRecord convert(Session session) { <line1> SimpleSession ssession = (SimpleSession) session; <line2> SessionRecord sessionRecord = new SessionRecord(); <line3> sessionRecord.setIdsession(session.getId().toString()); <line4> sessionRecord.setStarttimestamp(new Timestamp(session.getStartTimestamp().getTime())); <line5> sessionRecord.setLastaccesstime(new Timestamp(session.getLastAccessTime().getTime())); <line6> sessionRecord.setTimeout(session.getTimeout()); <line7> sessionRecord.setHost(session.getHost()); <line8> if (ssession.getAttributes() != null) { <line9> HashMap<Object, Object> attributes = (HashMap<Object, Object>) ssession.getAttributes(); <line10> sessionRecord.setAttributes(SerializationUtils.serialize(attributes)); <line11> } <line12> return sessionRecord; <line13> } <line14> } <line15>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> public static void connected(String chargeBoxId, WebSocketSession session) { <line1> } <line2> } <line3>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> private int addGeneralizedPattern(OWLAxiom axiom) { <line1> String axiomString = render(axiom); <line2> Integer patternID = getGeneralizedPatternID(axiom); <line3> if (patternID != null) { <line4> return patternID; <line5> } <line6> try { <line7> insertPatternGeneralizationPs.setString(1, axiomString); <line8> insertPatternGeneralizationPs.setString(2, axiomRenderer.render(axiom)); <line9> insertPatternGeneralizationPs.setString(3, getAxiomType(axiom)); <line10> insertPatternGeneralizationPs.execute(); <line11> } catch (SQLException e) { <line12> } <line13> return getGeneralizedPatternID(axiom); <line14> } <line15> } <line16>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> public SysUser getUserByName(String name, String password) throws Exception { <line1> SysUser sysUser = null; <line2> try (SqlSession sqlSession = MyBatisUtil.getSqlSession()) { <line3> HashMap<String, Object> mapParams = new HashMap<>(); <line4> mapParams.put(""name"", name); <line5> mapParams.put(""password"", password); <line6> Map<String, Object> params = new HashMap<>(); <line7> params.put(""mapParams"", mapParams); <line8> sysUser = sqlSession.selectOne(GET_USER_BY_NAME_STATEMENT, params); <line9> } catch (Exception e) { <line10> throw new Exception(e); <line11> } <line12> return sysUser; <line13> } <line14> } <line15>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> @Measure <line2> public void indexTransferIn(Transfer transfer, StoreKey... topKeys) { <line3> if (!config.isEnabled()) { <line4> return; <line5> } <line6> if (transfer != null && transfer.exists()) { <line7> StoreKey key = LocationUtils.getKey(transfer); <line8> String path = getStrategyPath(key, transfer.getPath()); <line9> indexPathInStores(path, key, topKeys); <line10> } <line11> } <line12> } <line13>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> @Override <line1> public Connection call() throws Exception { <line2> return createConnection(settings, jdbcUrl, user, pass, kerberos, d); <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> public ActionForward submitChangeDiagnosis( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> if (request.getSession().getAttribute(""userrole"") == null) <line6> return mapping.findForward(""expired""); <line7> request.setAttribute(""change_flag"", ""true""); <line8> CaseManagementEntryFormBean cform = (CaseManagementEntryFormBean) form; <line9> request.setAttribute(""from"", request.getParameter(""from"")); <line10> String demono = getDemographicNo(request); <line11> request.setAttribute(""demoName"", getDemoName(demono)); <line12> request.setAttribute(""demoAge"", getDemoAge(demono)); <line13> request.setAttribute(""demoDOB"", getDemoDOB(demono)); <line14> String strIndex = request.getParameter(""change_diagnosis_id""); <line15> int index = Integer.parseInt(strIndex); <line16> CheckBoxBean[] oldList = cform.getIssueCheckList(); <line17> CheckIssueBoxBean[] issueList = cform.getNewIssueCheckList(); <line18> CheckIssueBoxBean substitution = null; <line19> String origIssueDesc = null; <line20> String newIssueDesc = null; <line21> for (CheckIssueBoxBean curr : issueList) { <line22> if (curr.isChecked()) { <line23> substitution = curr; <line24> break; <line25> } <line26> } <line27> if (substitution != null) { <line28> for (int x = 0; x < oldList.length; x++) { <line29> if (x == index) { <line30> Issue oldIssue = oldList[x].getIssue().getIssue(); <line31> origIssueDesc = oldIssue.getDescription(); <line32> Issue newIssue = <line33> caseManagementMgr.getIssue( <line34> String.valueOf(substitution.getIssue().getId().longValue())); <line35> newIssueDesc = newIssue.getDescription(); <line36> oldList[x].getIssue().setIssue(newIssue); <line37> oldList[x].getIssue().setIssue_id(substitution.getIssue().getId().longValue()); <line38> oldList[x].getIssue().setType(newIssue.getType()); <line39> oldList[x].getIssueDisplay().setCode(newIssue.getCode()); <line40> oldList[x].getIssueDisplay().setCodeType(newIssue.getType()); <line41> oldList[x].getIssueDisplay().setDescription(newIssue.getDescription()); <line42> caseManagementMgr.saveCaseIssue(oldList[x].getIssue()); <line43> } <line44> } <line45> } <line46> cform.setIssueCheckList(oldList); <line47> if (substitution != null && origIssueDesc != null) <line48> this.caseManagementMgr.changeIssueInCPP(demono, origIssueDesc, newIssueDesc); <line49> return mapping.findForward(""view""); <line50> } <line51> } <line52>  <LINE> <line46>"	No	task2	
<CODE> public class A { <line0> private static void loadJsonEnv() { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> try { <line3> File jsonFile = new File(Environment.getInstance().getScaleConfig()).getAbsoluteFile(); <line4> jsonEnv = mapper.readTree(jsonFile); <line5> } catch (Exception e) { <line6> jsonEnv = mapper.createObjectNode(); <line7> } <line8> } <line9> } <line10>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> public void trace(final Marker marker, final String message, final Object object) { <line1> } <line2> } <line3>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public DelegationTokenIssuer[] getAdditionalTokenIssuers() throws IOException { <line2> KeyProvider keyProvider; <line3> try { <line4> keyProvider = getKeyProvider(); <line5> } catch (IOException ioe) { <line6> return null; <line7> } <line8> if (keyProvider instanceof DelegationTokenIssuer) { <line9> return new DelegationTokenIssuer[] {(DelegationTokenIssuer) keyProvider}; <line10> } <line11> return null; <line12> } <line13> } <line14>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public Pair<SaslClientAuthenticationProvider, Token<? extends TokenIdentifier>> selectProvider( <line2> String clusterId, User user) { <line3> requireNonNull(clusterId, ""Null clusterId was given""); <line4> requireNonNull(user, ""Null user was given""); <line5> if (!User.isHBaseSecurityEnabled(conf)) { <line6> return new Pair<>(simpleAuth, null); <line7> } <line8> final Text clusterIdAsText = new Text(clusterId); <line9> for (Token<? extends TokenIdentifier> token : user.getTokens()) { <line10> if (clusterIdAsText.equals(token.getService()) <line11> && digestAuthTokenKind.equals(token.getKind())) { <line12> return new Pair<>(digestAuth, token); <line13> } <line14> } <line15> final UserGroupInformation currentUser = user.getUGI(); <line16> final UserGroupInformation realUser = currentUser.getRealUser(); <line17> if (currentUser.hasKerberosCredentials() <line18> || (realUser != null && realUser.hasKerberosCredentials())) { <line19> return new Pair<>(krbAuth, null); <line20> } <line21> return null; <line22> } <line23> } <line24>  <LINE> <line5>"	No	task2	
"<CODE> public class A { <line0> private void setDbUpdateDate(String dateString, String timeString) { <line1> try { <line2> Date date = new SimpleDateFormat(DB_UPDATE_DATE_FORMAT).parse(dateString + "" "" + timeString); <line3> if (this.lastDbUpdateDate == null || date.after(this.lastDbUpdateDate)) { <line4> scanForDevices(); <line5> this.lastDbUpdateDate = date; <line6> } <line7> } catch (ParseException e) { <line8> } <line9> } <line10> } <line11>  <LINE> <line8>"	Yes	task2	
<CODE> public class A { <line0> private boolean handle(List<ZookeeperJob> zookeeperJobList) { <line1> if (CollectionUtils.isEmpty(zookeeperJobList)) { <line2> return false; <line3> } <line4> ZookeeperJob defaultJob = ListUtils.getFirst(zookeeperJobList); <line5> ZookeeperJob.Type type = defaultJob.getType(); <line6> switch (type) { <line7> case ADD: <line8> return handleUpdate(zookeeperJobList); <line9> case REMOVE: <line10> return handleDelete(zookeeperJobList); <line11> case CLEAR: <line12> return handleClear(zookeeperJobList); <line13> } <line14> return false; <line15> } <line16> } <line17>  <LINE> <line10>	No	task2	
<CODE> public class A { <line0> private String toScript(List<String> paths, SparkCommandBuilder commandBuilder) { <line1> StringBuffer sb = new StringBuffer(); <line2> if (paths.size() > 1) { <line3> sb.append(commandBuilder.build(paths)); <line4> } else { <line5> sb.append(commandBuilder.build(paths.get(0))); <line6> } <line7> return sb.toString(); <line8> } <line9> } <line10>  <LINE> <line7>	Yes	task2	
"<CODE> public class A { <line0> private void loadDomain() { <line1> if (null == domain) throw new RuntimeException(""No security domain specified""); <line2> missingContainer.clear(); <line3> getView().reset(); <line4> ModelNode operation = new ModelNode(); <line5> operation.get(OP).set(READ_RESOURCE_OPERATION); <line6> operation.get(ADDRESS).set(Baseadress.get()); <line7> operation.get(ADDRESS).add(""subsystem"", ""security""); <line8> operation.get(ADDRESS).add(""security-domain"", domain); <line9> operation.get(RECURSIVE).set(true); <line10> operation.get(""recursive-depth"").set(2); <line11> dispatcher.execute( <line12> new DMRAction(operation), <line13> new SimpleCallback<DMRResponse>() { <line14> @Override <line15> public void onSuccess(DMRResponse result) { <line16> ModelNode response = result.get(); <line17> if (response.isFailure()) { <line18> } else { <line19> ModelNode payload = response.get(RESULT); <line20> for (SubResource subResource : SubResource.values()) { <line21> String type = subResource.getType(); <line22> if (payload.hasDefined(type)) { <line23> List<Property> modules = <line24> payload <line25> .get(type) <line26> .get(""classic"") <line27> .get(subResource.getModuleDef()) <line28> .asPropertyList(); <line29> getView().updateSubResource(subResource, modules); <line30> } else { <line31> missingContainer.add(subResource); <line32> } <line33> } <line34> } <line35> } <line36> }); <line37> } <line38> } <line39>  <LINE> <line2>"	No	task2	
<CODE> public class A { <line0> private HttpClientRequest requestClient() { <line1> if (CollectionUtils.isNotEmpty(interceptors)) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> return new InterceptingHttpClientRequest(requestClient, interceptors.iterator()); <line5> } <line6> return requestClient; <line7> } <line8> } <line9>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> public static com.liferay.fragment.model.FragmentCompositionSoap[] getFragmentCompositions( <line1> long fragmentCollectionId, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.fragment.model.FragmentComposition> returnValue = <line4> FragmentCompositionServiceUtil.getFragmentCompositions(fragmentCollectionId, start, end); <line5> return com.liferay.fragment.model.FragmentCompositionSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11>  <LINE> <line7>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public String execute(final Context context, final Map<String, String> params) <line2> throws PluginException { <line3> final String include = params.get(PARAM_INCLUDE); <line4> final String exclude = params.get(PARAM_EXCLUDE); <line5> final Element masterDiv = getElement(""div"", ""index""); <line6> final Element indexDiv = getElement(""div"", ""header""); <line7> masterDiv.addContent(indexDiv); <line8> try { <line9> final List<String> pages = listPages(context, include, exclude); <line10> context.getEngine().getManager(PageManager.class).getPageSorter().sort(pages); <line11> char initialChar = ' '; <line12> Element currentDiv = new Element(""div"", xmlns_XHTML); <line13> for (final String name : pages) { <line14> if (StringUtils.isNotBlank(name) && name.charAt(0) != initialChar) { <line15> if (initialChar != ' ') { <line16> indexDiv.addContent("" - ""); <line17> } <line18> initialChar = name.charAt(0); <line19> masterDiv.addContent(makeHeader(String.valueOf(initialChar))); <line20> currentDiv = getElement(""div"", ""body""); <line21> masterDiv.addContent(currentDiv); <line22> indexDiv.addContent(getLink(""#"" + initialChar, String.valueOf(initialChar))); <line23> } else { <line24> currentDiv.addContent("", ""); <line25> } <line26> currentDiv.addContent( <line27> getLink(context.getURL(ContextEnum.PAGE_VIEW.getRequestContext(), name), name)); <line28> } <line29> } catch (final ProviderException e) { <line30> throw new PluginException(e.getMessage()); <line31> } <line32> final XMLOutputter out = new XMLOutputter(Format.getRawFormat()); <line33> return out.outputString(masterDiv); <line34> } <line35> } <line36>  <LINE> <line30>"	Yes	task2	
<CODE> public class A { <line0> public void config(String message) { <line1> } <line2> } <line3>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> private void internalInitialize(Properties props) { <line1> if (this.initialized) { <line2> return; <line3> } <line4> this.initialized = true; <line5> if (logger.isDebugEnabled()) { <line6> } <line7> auditor.init(props); <line8> String schedule = null; <line9> if (props != null) { <line10> schedule = props.getProperty(SCHEDULE); <line11> } <line12> scheduler.init(schedule); <line13> } <line14> } <line15>  <LINE> <line6>	Yes	task2	
<CODE> public class A { <line0> private String createKvpDescribeSensorOrReturnIdentifier(String identifier, String format) <line1> throws CodedException { <line2> if (getProcedureCreationContext() <line3> .getBindingRepository() <line4> .isBindingSupported(MediaTypes.APPLICATION_KVP)) { <line5> final String version = <line6> getProcedureCreationContext() <line7> .getServiceOperatorRepository() <line8> .isVersionSupported(SosConstants.SOS, Sos2Constants.SERVICEVERSION) <line9> ? Sos2Constants.SERVICEVERSION <line10> : Sos1Constants.SERVICEVERSION; <line11> try { <line12> return SosHelper.getDescribeSensorUrl( <line13> version, getProcedureCreationContext().getServiceURL(), identifier, format) <line14> .toString(); <line15> } catch (MalformedURLException murle) { <line16> } <line17> } <line18> return identifier; <line19> } <line20> } <line21>  <LINE> <line6>	No	task2	
<CODE> public class A { <line0> public void tryGenerate(IMontageGenerator generator) { <line1> ValidationErrors errors = new ValidationErrors(); <line2> generator.validateSourceMontage(montage, errors); <line3> if (errors.hasErrors()) { <line4> errorsDialog.showDialog(errors); <line5> return; <line6> } <line7> try { <line8> generator.createMontage(montage); <line9> } catch (MontageException ex) { <line10> Dialogs.showExceptionDialog(this, ex); <line11> } <line12> } <line13> } <line14>  <LINE> <line8>	No	task2	
"<CODE> public class A { <line0> @ParallelTest <line1> @OpenShiftOnly <line2> void testConnectS2ILogSetting(ExtensionContext extensionContext) { <line3> String clusterName = mapWithClusterNames.get(extensionContext.getDisplayName()); <line4> String connectS2IClusterName = clusterName + ""-connect-s2i""; <line5> resourceManager.createResource( <line6> extensionContext, <line7> KafkaConnectS2ITemplates.kafkaConnectS2I( <line8> extensionContext, connectS2IClusterName, LOG_SETTING_CLUSTER_NAME, 1) <line9> .editSpec() <line10> .withNewInlineLogging() <line11> .withLoggers(CONNECT_LOGGERS) <line12> .endInlineLogging() <line13> .withNewJvmOptions() <line14> .withGcLoggingEnabled(true) <line15> .endJvmOptions() <line16> .endSpec() <line17> .build()); <line18> String connectS2IDepName = KafkaConnectS2IResources.deploymentName(connectS2IClusterName); <line19> Map<String, String> connectS2IPods = <line20> DeploymentConfigUtils.depConfigSnapshot(NAMESPACE, connectS2IDepName); <line21> String connectS2IMap = <line22> KafkaConnectS2IResources.metricsAndLogConfigMapName(connectS2IClusterName); <line23> assertThat( <line24> ""KafkaConnectS2I's log level is set properly"", <line25> checkLoggersLevel(NAMESPACE, CONNECT_LOGGERS, connectS2IMap), <line26> is(true)); <line27> assertThat( <line28> ""ConnectS2I GC logging is enabled"", <line29> checkGcLoggingDeploymentConfig(NAMESPACE, connectS2IDepName), <line30> is(true)); <line31> KafkaConnectS2IResource.replaceConnectS2IResourceInSpecificNamespace( <line32> connectS2IClusterName, cs2i -> cs2i.getSpec().setJvmOptions(JVM_OPTIONS), NAMESPACE); <line33> DeploymentConfigUtils.waitTillDepConfigHasRolled(NAMESPACE, connectS2IDepName, connectS2IPods); <line34> assertThat( <line35> ""ConnectS2I GC logging is disabled"", <line36> checkGcLoggingDeploymentConfig(NAMESPACE, connectS2IDepName), <line37> is(false)); <line38> kubectlGetStrimziUntilOperationIsSuccessful(NAMESPACE, connectS2IClusterName); <line39> checkContainersHaveProcessOneAsTini(NAMESPACE, connectS2IClusterName); <line40> } <line41> } <line42>  <LINE> <line33>"	No	task2	
<CODE> public class A { <line0> private void reloadCatalogModelFromDatabasePrivate() { <line1> if (isModernizedBpCatalogLoaded()) { <line2> CatalogModel newModel = loadCatalogModel(); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> catalogModel.modelReload(newModel); <line6> catalogModel.moveListener(newModel); <line7> catalogModel = newModel; <line8> fireLoad(catalogModel); <line9> } <line10> } <line11> } <line12>  <LINE> <line4>	Yes	task2	
"<CODE> public class A { <line0> protected void logAndRegister(PigServer server, String query, int lineNumber) throws IOException { <line1> assert lineNumber > 0 : ""(lineNumber > 0) is false""; <line2> server.registerQuery(query, lineNumber); <line3> } <line4> } <line5>  <LINE> <line3>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public Part getPart(String name) { <line2> Optional<FileUpload> upload = <line3> context.fileUploads().stream() <line4> .filter(fileUpload -> fileUpload.name().equals(name)) <line5> .findFirst(); <line6> if (!upload.isPresent()) { <line7> return null; <line8> } <line9> final FileUpload fileUpload = upload.get(); <line10> return new FileUploadPart(fileUpload); <line11> } <line12> } <line13>  <LINE> <line6>	No	task2	
"<CODE> public class A { <line0> protected String render(String valueString, Locale locale) { <line1> if (Validator.isNotNull(valueString)) { <line2> try { <line3> return DateUtil.formatDate(""yyyy-MM-dd"", valueString, locale); <line4> } catch (ParseException parseException) { <line5> } <line6> } <line7> return StringPool.BLANK; <line8> } <line9> } <line10>  <LINE> <line0>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void init(ServletConfig servletConfig) throws ServletException { <line2> super.init(servletConfig); <line3> this.planetCache = PlanetCache.getInstance(); <line4> } <line5> } <line6>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> void updateDeleteTransaction( <line1> final DatanodeDetails datanodeDetails, <line2> final List<ContainerReplicaProto> replicas, <line3> final EventPublisher publisher) { <line4> final PendingDeleteStatusList pendingDeleteStatusList = <line5> new PendingDeleteStatusList(datanodeDetails); <line6> for (ContainerReplicaProto replica : replicas) { <line7> try { <line8> final ContainerInfo containerInfo = <line9> containerManager.getContainer(ContainerID.valueOf(replica.getContainerID())); <line10> if (containerInfo.getDeleteTransactionId() > replica.getDeleteTransactionId()) { <line11> pendingDeleteStatusList.addPendingDeleteStatus( <line12> replica.getDeleteTransactionId(), <line13> containerInfo.getDeleteTransactionId(), <line14> containerInfo.getContainerID()); <line15> } <line16> } catch (ContainerNotFoundException cnfe) { <line17> } <line18> } <line19> if (pendingDeleteStatusList.getNumPendingDeletes() > 0) { <line20> publisher.fireEvent(SCMEvents.PENDING_DELETE_STATUS, pendingDeleteStatusList); <line21> } <line22> } <line23> } <line24>  <LINE> <line15>	No	task2	
<CODE> public class A { <line0> private void configureWfsFeatures() { <line1> WFSCapabilitiesType capabilities = getCapabilities(); <line2> if (capabilities != null) { <line3> wfsVersion = capabilities.getVersion(); <line4> List<FeatureTypeType> featureTypes = getFeatureTypes(capabilities); <line5> List<String> supportedGeo = getSupportedGeo(capabilities); <line6> buildFeatureFilters(featureTypes, supportedGeo); <line7> } else { <line8> } <line9> } <line10> } <line11>  <LINE> <line2>	No	task2	
"<CODE> public class A { <line0> @Override <line1> protected Result check() { <line2> List<String> inactive = new ArrayList<>(); <line3> for (Bundle bundle : context.getBundles()) { <line4> if (bundle.getState() != Bundle.ACTIVE) { <line5> inactive.add(bundle.getSymbolicName()); <line6> } <line7> } <line8> if (inactive.isEmpty()) { <line9> return Result.healthy(""All bundles active""); <line10> } else { <line11> return Result.unhealthy(""Inactive bundles: "" + inactive); <line12> } <line13> } <line14> } <line15>  <LINE> <line7>"	No	task2	
<CODE> public class A { <line0> protected Map<Address, byte[]> unserializeKeys( <line1> Address sender, byte[] buf, int offset, int length) { <line2> Map<Address, byte[]> map = new HashMap<>(); <line3> ByteArrayDataInputStream in = new ByteArrayDataInputStream(buf, offset, length); <line4> try { <line5> int num_keys = in.readInt(); <line6> for (int i = 0; i < num_keys; i++) { <line7> Address mbr = Util.readAddress(in); <line8> int len = in.readInt(); <line9> byte[] key = new byte[len]; <line10> in.readFully(key, 0, key.length); <line11> map.put(mbr, key); <line12> } <line13> } catch (Exception ex) { <line14> } <line15> return map; <line16> } <line17> } <line18>  <LINE> <line14>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> Optional<FROM> decodeFromRawInternal(Object o) { <line2> if (LOGGER.isTraceEnabled()) { <line3> } <line4> final FROM decoded = aProperty.decodeFromRawInternal(o); <line5> if (decoded == null) { <line6> return Optional.empty(); <line7> } else { <line8> return Optional.of(decoded); <line9> } <line10> } <line11> } <line12>  <LINE> <line3>	Yes	task2	
"<CODE> public class A { <line0> public boolean shouldUse() { <line1> return new File(serverHome + ""/hqdb"").exists(); <line2> } <line3> } <line4>  <LINE> <line3>"	No	task2	
"<CODE> public class A { <line0> public void testDataSource() throws Exception { <line1> PortalContainer container = PortalContainer.getInstance(); <line2> container.getComponentInstanceOfType(InitialContextInitializer.class); <line3> DataSource ds = (DataSource) new InitialContext().lookup(""jdbcexo""); <line4> assertNotNull(ds); <line5> Connection conn = ds.getConnection(); <line6> DatabaseMetaData databaseMD = conn.getMetaData(); <line7> String db = <line8> databaseMD.getDatabaseProductName() <line9> + "" "" <line10> + databaseMD.getDatabaseProductVersion() <line11> + ""."" <line12> + databaseMD.getDatabaseMajorVersion() <line13> + ""."" <line14> + databaseMD.getDatabaseMinorVersion(); <line15> String driver = <line16> databaseMD.getDriverName() <line17> + "" "" <line18> + databaseMD.getDriverVersion() <line19> + ""."" <line20> + databaseMD.getDriverMajorVersion() <line21> + ""."" <line22> + databaseMD.getDriverMinorVersion(); <line23> conn.close(); <line24> } <line25> } <line26>  <LINE> <line23>"	Yes	task2	
<CODE> public class A { <line0> @Modified <line1> protected void modified(Map<String, Object> config) { <line2> configuration.update(new Configuration(config).as(UpnpControlBindingConfiguration.class)); <line3> } <line4> } <line5>  <LINE> <line3>	Yes	task2	
"<CODE> public class A { <line0> private void printXML(String message, Node xmlNode) { <line1> TransformerProperties transformerProperties = new TransformerProperties(); <line2> transformerProperties.addOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes""); <line3> if (LOGGER.isTraceEnabled()) { <line4> } <line5> } <line6> } <line7>  <LINE> <line2>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void onMessage(String message) { <line2> int index = messages.length - (int) messageLatch.getCount(); <line3> assertTrue(equals.apply(messages[index], message)); <line4> messageLatch.countDown(); <line5> if (messageLatch.getCount() == 0) { <line6> try { <line7> session.close(); <line8> } catch (IOException e) { <line9> fail(""Unexpected exception "" + e); <line10> } <line11> } <line12> } <line13> } <line14>  <LINE> <line2>"	Yes	task2	
<CODE> public class A { <line0> public synchronized void setBitstring(@Nonnull String aspect, @Nonnull String bitString) { <line1> if (aspectToOutput.containsKey(aspect)) { <line2> aspectToOutput.remove(aspect); <line3> } <line4> char[] bitArray = bitString.toCharArray(); <line5> aspectToOutput.put(aspect, bitArray); <line6> } <line7> } <line8>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> private void getLogicalSwitchGroupByName() { <line1> LogicalSwitchGroup logicalSwitchGroup = client.getByName(LOGICAL_SWITCH_GROUP_NAME).get(0); <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> private void initPersistence() { <line1> long ts1 = System.currentTimeMillis(); <line2> CassandraHostConfigurator cassandraHostConfigurator = new CassandraHostConfigurator(); <line3> cassandraHostConfigurator.setHosts(CLUSTER_URL); <line4> cassandraHostConfigurator.setMaxActive(hectorPoolSize); <line5> cassandraHostConfigurator.setCassandraThriftSocketTimeout( <line6> CMBProperties.getInstance().getCassandraThriftSocketTimeOutMS()); <line7> cassandraHostConfigurator.setAutoDiscoverHosts( <line8> CMBProperties.getInstance().isHectorAutoDiscovery()); <line9> cassandraHostConfigurator.setAutoDiscoveryDelayInSeconds( <line10> CMBProperties.getInstance().getHectorAutoDiscoveryDelaySeconds()); <line11> String dataCenter = CMBProperties.getInstance().getCassandraDataCenter(); <line12> if (dataCenter != null && !dataCenter.equals("""")) { <line13> cassandraHostConfigurator.setAutoDiscoveryDataCenter(dataCenter); <line14> } <line15> if (hectorBalancingPolicy != null) { <line16> if (hectorBalancingPolicy.equals(""LeastActiveBalancingPolicy"")) { <line17> cassandraHostConfigurator.setLoadBalancingPolicy(new LeastActiveBalancingPolicy()); <line18> } else if (hectorBalancingPolicy.equals(""RoundRobinBalancingPolicy"")) { <line19> cassandraHostConfigurator.setLoadBalancingPolicy(new RoundRobinBalancingPolicy()); <line20> } else if (hectorBalancingPolicy.equals(""DynamicLoadBalancingPolicy"")) { <line21> cassandraHostConfigurator.setLoadBalancingPolicy(new DynamicLoadBalancingPolicy()); <line22> } <line23> } <line24> cluster = <line25> HFactory.getOrCreateCluster( <line26> AbstractDurablePersistence.CLUSTER_NAME, cassandraHostConfigurator, credentials); <line27> keyspaces = new HashMap<String, Keyspace>(); <line28> List<String> keyspaceNames = new ArrayList<String>(); <line29> keyspaceNames.add(CMBProperties.getInstance().getCMBKeyspace()); <line30> keyspaceNames.add(CMBProperties.getInstance().getCNSKeyspace()); <line31> keyspaceNames.add(CMBProperties.getInstance().getCQSKeyspace()); <line32> for (String k : keyspaceNames) { <line33> Keyspace keyspace = <line34> HFactory.createKeyspace( <line35> k, <line36> cluster, <line37> new SimpleConsistencyPolicy( <line38> HConsistencyLevel.valueOf( <line39> CMBProperties.getInstance().getWriteConsistencyLevel()))); <line40> keyspaces.put(k, keyspace); <line41> } <line42> long ts2 = System.currentTimeMillis(); <line43> CMBControllerServlet.valueAccumulator.addToCounter(AccumulatorName.CassandraTime, (ts2 - ts1)); <line44> } <line45> } <line46>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> public static com.liferay.commerce.bom.model.CommerceBOMFolder updateCommerceBOMFolder( <line1> HttpPrincipal httpPrincipal, <line2> long commerceBOMFolderId, <line3> String name, <line4> boolean logo, <line5> byte[] logoBytes) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> CommerceBOMFolderServiceUtil.class, <line11> ""updateCommerceBOMFolder"", <line12> _updateCommerceBOMFolderParameterTypes7); <line13> MethodHandler methodHandler = <line14> new MethodHandler(methodKey, commerceBOMFolderId, name, logo, logoBytes); <line15> Object returnObj = null; <line16> try { <line17> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line18> } catch (Exception exception) { <line19> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line20> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line21> } <line22> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line23> } <line24> return (com.liferay.commerce.bom.model.CommerceBOMFolder) returnObj; <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> throw systemException; <line27> } <line28> } <line29> } <line30>  <LINE> <line16>"	No	task2	
<CODE> public class A { <line0> private MethodResult makeExceptionResult(Exception e) { <line1> return new MethodResult(Throwables.getStackTraceAsString(e), ReturnType.Exception); <line2> } <line3> } <line4>  <LINE> <line1>	Yes	task2	
"<CODE> public class A { <line0> private void persistTasks() { <line1> Dictionary<String, Object> configProperties = new Hashtable<>(); <line2> try { <line3> persistTasks(configProperties, dataFile); <line4> configuration.updateIfDifferent(configProperties); <line5> } catch (RepositoryException | IOException e) { <line6> throw new IllegalStateException(""Could not persist tasks"", e); <line7> } <line8> } <line9> } <line10>  <LINE> <line2>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void close() { <line2> if (shpFile != null) { <line3> try { <line4> shpFile.close(); <line5> } catch (IOException e) { <line6> } <line7> shpFile = null; <line8> } <line9> } <line10> } <line11>  <LINE> <line4>	No	task2	
"<CODE> public class A { <line0> public String[] setValues(String name, String... values) { <line1> checkNull(""name"", name); <line2> String[] vals = params.get(name); <line3> if (values == null) { <line4> values = new String[] {null}; <line5> } <line6> params.put(name, values.clone()); <line7> if (urlProvider != null) { <line8> urlProvider.setParameter(windowId, name, type, values.clone()); <line9> } <line10> if (isTrace) { <line11> StringBuilder txt = new StringBuilder(); <line12> txt.append(""Window ID: "") <line13> .append(windowId) <line14> .append("", Name: "") <line15> .append(name) <line16> .append("", Type: "") <line17> .append(type) <line18> .append("", Old Values: "") <line19> .append(Arrays.toString(vals)) <line20> .append("", New Values: "") <line21> .append(Arrays.toString(values)); <line22> } <line23> return vals; <line24> } <line25> } <line26>  <LINE> <line22>"	Yes	task2	
"<CODE> public class A { <line0> public void setAsText(String text) throws IllegalArgumentException { <line1> ConceptService cs = Context.getConceptService(); <line2> if (StringUtils.hasText(text)) { <line3> try { <line4> setValue(cs.getConceptNumeric(Integer.valueOf(text))); <line5> } catch (Exception ex) { <line6> ConceptNumeric conceptNumeric = cs.getConceptNumericByUuid(text); <line7> setValue(conceptNumeric); <line8> if (conceptNumeric == null) { <line9> throw new IllegalArgumentException(""Concept not found: "" + ex.getMessage()); <line10> } <line11> } <line12> } else { <line13> setValue(null); <line14> } <line15> } <line16> } <line17>  <LINE> <line3>"	No	task2	
<CODE> public class A { <line0> private void retry(MessageQueryIndex failMessage, Consumer<MessageQueryIndex> fi) { <line1> final int tryStoreNum = failMessage.getBackupRetryTimes(); <line2> if (tryStoreNum < retryNum()) { <line3> monitorStoreRetry(failMessage.getSubject()); <line4> failMessage.setBackupRetryTimes(tryStoreNum + 1); <line5> add(failMessage, fi); <line6> } else { <line7> monitorStoreDiscard(failMessage.getSubject()); <line8> } <line9> } <line10> } <line11>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> private GridCoverage2D transformResult( <line1> final GridCoverage2D coverage, <line2> final Rectangle pixelDimension, <line3> final GeoWaveRasterReaderState state) { <line4> if (state.getRequestEnvelopeXformed() == state.getRequestedEnvelope()) { <line5> return coverage; <line6> } <line7> GridCoverage2D result = null; <line8> result = <line9> (GridCoverage2D) <line10> RasterUtils.getCoverageOperations() <line11> .resample(coverage, state.getRequestedEnvelope().getCoordinateReferenceSystem()); <line12> return coverageFactory.create( <line13> result.getName(), result.getRenderedImage(), result.getEnvelope()); <line14> } <line15> } <line16>  <LINE> <line8>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void doRender( <line2> RenderContext rc, <line3> Collection<? extends T> input, <line4> Collection<? super T> rejected, <line5> PickManager pickManager, <line6> MapContext<?> mapContext, <line7> ModelDataRetriever<T> dataRetriever) { <line8> int listId = -1; <line9> boolean compileList = false; <line10> if (rc.getRenderMode() == AbstractGeometry.RenderMode.DRAW) { <line11> Set<Geometry> pickedGeometries = pickManager.getPickedGeometries(); <line12> if (!myLastPicked.equals(pickedGeometries)) { <line13> myDrawDirty = true; <line14> myLastPicked = new WeakHashSet<>(pickedGeometries); <line15> } <line16> if (myDrawDirty) { <line17> compileList = true; <line18> if (myDrawDisplayListId == 0) { <line19> myDrawDisplayListId = rc.getGL().getGL2().glGenLists(1); <line20> } <line21> myDrawDirty = false; <line22> } <line23> listId = myDrawDisplayListId; <line24> } else if (rc.getRenderMode() == AbstractGeometry.RenderMode.PICK) { <line25> if (myPickDirty) { <line26> compileList = true; <line27> if (myPickDisplayListId == 0) { <line28> myPickDisplayListId = rc.getGL().getGL2().glGenLists(1); <line29> } <line30> myPickDirty = false; <line31> } <line32> listId = myPickDisplayListId; <line33> } else { <line34> throw new UnexpectedEnumException(rc.getRenderMode()); <line35> } <line36> myRenderer.initializeShaders(rc, input); <line37> if (compileList) { <line38> rc.getGL().getGL2().glNewList(listId, GL2.GL_COMPILE); <line39> try { <line40> doRender(rc, input, pickManager, mapContext, rejected, dataRetriever); <line41> } finally { <line42> rc.getGL().getGL2().glEndList(); <line43> } <line44> } <line45> if (listId != -1) { <line46> if (rc.getGL().glGetError() != GL.GL_NO_ERROR) { <line47> } <line48> rc.getGL().getGL2().glCallList(listId); <line49> } <line50> myRenderer.cleanupShaders(rc, input); <line51> } <line52> } <line53>  <LINE> <line47>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public COREEnvelopeRealTimeResponse realTimeTransaction( <line2> COREEnvelopeRealTimeRequest msg, AssertionType assertion) { <line3> return new AdapterX12RealTimeOrchImpl().realTimeTransaction(msg); <line4> } <line5> } <line6>  <LINE> <line3>	Yes	task2	
"<CODE> public class A { <line0> private void handleTestConnectivityFailure( <line1> String name, <line2> ReconnectionConfig reconnectionConfig, <line3> RetryContext context, <line4> ConnectionValidationResult result) <line5> throws ConnectionException { <line6> if ((reconnectionConfig.isFailsDeployment())) { <line7> context.setFailed(result.getException()); <line8> throw new ConnectionException( <line9> format(""Connectivity test failed for config '%s'"", name), result.getException()); <line10> } else { <line11> if (LOGGER.isInfoEnabled()) { <line12> } <line13> } <line14> } <line15> } <line16>  <LINE> <line6>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public synchronized boolean freshIndex(KCluster cluster) { <line2> boolean containsKey = batchLocks.containsKey(cluster); <line3> boolean isFreshIndex = this.provider.isFreshIndex(cluster) && !containsKey; <line4> if (logger.isDebugEnabled()) { <line5> } <line6> return isFreshIndex; <line7> } <line8> } <line9>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void disconnect() throws IOException { <line2> try { <line3> batchwriter.close(); <line4> } catch (MutationsRejectedException e) { <line5> DTThrowable.rethrow(e); <line6> } <line7> } <line8> } <line9>  <LINE> <line8>	No	task2	
<CODE> public class A { <line0> @Override <line1> public Boolean get(SpeciesCheck key) { <line2> try { <line3> return sdsService.isSensitive(key); <line4> } catch (Exception ex) { <line5> throw new RuntimeException(ex); <line6> } <line7> } <line8> } <line9>  <LINE> <line5>	Yes	task2	
<CODE> public class A { <line0> public boolean areIsolationPoliciesPresent(NamespaceName namespace) { <line1> try { <line2> Optional<NamespaceIsolationPolicies> policies = <line3> getIsolationPolicies(pulsar.getConfiguration().getClusterName()); <line4> return policies <line5> .filter(isolationPolicies -> isolationPolicies.getPolicyByNamespace(namespace) != null) <line6> .isPresent(); <line7> } catch (Exception e) { <line8> return false; <line9> } <line10> } <line11> } <line12>  <LINE> <line11>	No	task2	
"<CODE> public class A { <line0> private void ripNextAlbum() { <line1> isRipping = true; <line2> Utils.setConfigList(""queue"", (Enumeration<Object>) queueListModel.elements()); <line3> if (queueListModel.isEmpty()) { <line4> isRipping = false; <line5> return; <line6> } <line7> String nextAlbum = (String) queueListModel.remove(0); <line8> updateQueue(); <line9> Thread t = ripAlbum(nextAlbum); <line10> if (t == null) { <line11> try { <line12> Thread.sleep(500); <line13> } catch (InterruptedException ie) { <line14> } <line15> ripNextAlbum(); <line16> } else { <line17> t.start(); <line18> } <line19> } <line20> } <line21>  <LINE> <line14>"	Yes	task2	
"<CODE> public class A { <line0> UserToken findByUserId(final long userId) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> UserToken tk = null; <line3> try { <line4> List<UserTokenEntity> result; <line5> TypedQuery<UserTokenEntity> qr = <line6> em.createQuery( <line7> ""select h from UserTokenEntity h where h.userId=:userId order by h.validDate desc"", <line8> UserTokenEntity.class); <line9> qr.setParameter(""userId"", userId); <line10> result = qr.getResultList(); <line11> if (result != null && !result.isEmpty()) { <line12> tk = result.get(0); <line13> } <line14> } catch (Exception e) { <line15> } finally { <line16> daoManager.closeEntityManager(em); <line17> } <line18> return tk; <line19> } <line20> } <line21>  <LINE> <line15>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public List<Authorization> getUserAuthorizations( <line2> String username, Map<String, Group> groups, Map<String, Role> roles) { <line3> Connection conn = null; <line4> List<Authorization> authorizations = new ArrayList<Authorization>(); <line5> PreparedStatement stat = null; <line6> ResultSet res = null; <line7> try { <line8> conn = this.getConnection(); <line9> stat = conn.prepareStatement(GET_USER_AUTHORIZATIONS); <line10> stat.setString(1, username); <line11> res = stat.executeQuery(); <line12> while (res.next()) { <line13> String groupname = res.getString(1); <line14> Group group = (null != groupname) ? groups.get(groupname) : null; <line15> String rolename = res.getString(2); <line16> Role role = (null != rolename) ? roles.get(rolename) : null; <line17> Authorization authorization = new Authorization(group, role); <line18> if (!authorizations.contains(authorization)) { <line19> authorizations.add(authorization); <line20> } <line21> } <line22> } catch (Throwable t) { <line23> throw new RuntimeException(""Error loading user authorization"", t); <line24> } finally { <line25> closeDaoResources(res, stat, conn); <line26> } <line27> return authorizations; <line28> } <line29> } <line30>  <LINE> <line23>"	Yes	task2	
"<CODE> public class A { <line0> private String calLocalSegmentCacheDir() { <line1> String kylinHome = KylinConfig.getKylinHome(); <line2> String indexPathStr = KylinConfig.getInstanceFromEnv().getStreamingIndexPath(); <line3> String localSegmentCachePath; <line4> File indexPath = new File(indexPathStr); <line5> if (indexPath.isAbsolute()) { <line6> localSegmentCachePath = indexPathStr; <line7> } else { <line8> if (kylinHome != null && !kylinHome.equals("""")) { <line9> File localSegmentFile = new File(kylinHome, indexPathStr); <line10> localSegmentCachePath = localSegmentFile.getAbsolutePath(); <line11> } else { <line12> localSegmentCachePath = indexPathStr; <line13> } <line14> } <line15> return localSegmentCachePath; <line16> } <line17> } <line18>  <LINE> <line15>"	Yes	task2	
"<CODE> public class A { <line0> private void testThreading(int nTables, int nIterations, double[] lf) throws Exception { <line1> if (null == lf) { <line2> lf = new double[nTables]; <line3> Arrays.fill(lf, 1d); <line4> } else { <line5> assert lf.length == nTables; <line6> } <line7> for (int n = 1; n < nTables; n++) { <line8> lf[n] += lf[n - 1]; <line9> } <line10> final double[] loadFactors = lf; <line11> final double accLoadFactors = loadFactors[nTables - 1]; <line12> Random random = new Random(0); <line13> int[] countByTable = new int[nTables]; <line14> long[] maxTimestampByTable = new long[nTables]; <line15> final long initialTimestampNanos = 1465839830100400200L; <line16> final long timestampIncrementInNanos = 1000; <line17> Arrays.fill(maxTimestampByTable, initialTimestampNanos); <line18> runInContext( <line19> () -> { <line20> int nTablesSelected = 0; <line21> int nTotalUpdates = 0; <line22> for (int nIter = 0; nIter < nIterations; nIter++) { <line23> int nLines = random.nextInt(50) + 1; <line24> recvBuffer = """"; <line25> for (int nLine = 0; nLine < nLines; nLine++) { <line26> int nTable; <line27> if (nTablesSelected < nTables) { <line28> nTable = nTablesSelected++; <line29> } else { <line30> double tableSelector = random.nextDouble() * accLoadFactors; <line31> nTable = nTables; <line32> while (--nTable > 0) { <line33> if (tableSelector > loadFactors[nTable - 1]) { <line34> break; <line35> } <line36> } <line37> } <line38> long timestamp = maxTimestampByTable[nTable]; <line39> maxTimestampByTable[nTable] += timestampIncrementInNanos; <line40> double temperature = 50.0 + (random.nextInt(500) / 10.0); <line41> recvBuffer += <line42> ""weather"" <line43> + nTable <line44> + "",location=us-midwest temperature="" <line45> + temperature <line46> + "" "" <line47> + timestamp <line48> + ""\n""; <line49> countByTable[nTable]++; <line50> nTotalUpdates++; <line51> } <line52> do { <line53> handleContextIO(); <line54> } while (recvBuffer.length() > 0); <line55> } <line56> waitForIOCompletion(); <line57> rebalanceNLoadCheckCycles = scheduler.getNLoadCheckCycles(); <line58> rebalanceNRebalances = scheduler.getNRebalances(); <line59> rebalanceLoadByThread = scheduler.getLoadByThread(); <line60> closeContext(); <line61> .$(""Completed "") <line62> .$(nTotalUpdates) <line63> .$("" measurements with "") <line64> .$(nTables) <line65> .$("" measurement types processed by "") <line66> .$(nWriterThreads) <line67> .$("" threads. "") <line68> .$(rebalanceNLoadCheckCycles) <line69> .$("" load checks lead to "") <line70> .$(rebalanceNRebalances) <line71> .$("" load rebalancing operations"") <line72> .$(); <line73> for (int nTable = 0; nTable < nTables; nTable++) { <line74> assertTableCount( <line75> ""weather"" + nTable, <line76> countByTable[nTable], <line77> maxTimestampByTable[nTable] - timestampIncrementInNanos); <line78> } <line79> }); <line80> } <line81> } <line82>  <LINE> <line60>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void commit(Xid xid, boolean flag) throws XAException { <line2> if (this.xid == null || !this.xid.equals(xid)) { <line3> throw newXAException(XAER_INVAL, ""Invalid Xid""); <line4> } <line5> this.xid = null; <line6> try { <line7> owner.connection.commit(); <line8> } catch (SQLException e) { <line9> throw newXAException(XAER_RMERR, ""Cannot commit"", e); <line10> } finally { <line11> try { <line12> owner.connection.setAutoCommit(true); <line13> } catch (SQLException e) { <line14> } <line15> } <line16> } <line17> } <line18>  <LINE> <line13>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public String removeUser(Map<String, Object> request, RequestContext context) { <line2> Keycloak keycloak = KeyCloakConnectionProvider.getConnection(); <line3> String userId = (String) request.get(JsonKey.USER_ID); <line4> try { <line5> String fedUserId = getFederatedUserId(userId); <line6> UserResource resource = <line7> keycloak.realm(KeyCloakConnectionProvider.SSO_REALM).users().get(fedUserId); <line8> if (isNotNull(resource)) { <line9> resource.remove(); <line10> } <line11> } catch (Exception ex) { <line12> ProjectUtil.createAndThrowInvalidUserDataException(); <line13> } <line14> return JsonKey.SUCCESS; <line15> } <line16> } <line17>  <LINE> <line12>	Yes	task2	
<CODE> public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap[] getFileEntries( <line1> long repositoryId, long folderId, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.portal.kernel.repository.model.FileEntry> returnValue = <line4> DLAppServiceUtil.getFileEntries(repositoryId, folderId, start, end); <line5> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11>  <LINE> <line4>	No	task2	
"<CODE> public class A { <line0> @JDIAction(value = ""Collapse '{name}' panel by index '{0}'"", timeout = 1) <line1> public void collapse(final int indexNumber) { <line2> List<UIElement> expansionIndicator = getExpansionIndicatorLocator(); <line3> List<UIElement> icons = getIconsLocator(); <line4> if (!expansionIndicator.isEmpty() && isExpanded(indexNumber)) { <line5> expansionIndicator.get(indexNumber).click(); <line6> } else if (!icons.isEmpty() && isExpanded(indexNumber)) { <line7> icons.get(indexNumber).click(); <line8> } else { <line9> } <line10> waitFor().collapsed(indexNumber); <line11> } <line12> } <line13>  <LINE> <line9>"	Yes	task2	
"<CODE> public class A { <line0> private void sendObject(final Object object, final Logger logger) { <line1> if (logger.isInfoEnabled()) { <line2> final JsonObject log = new JsonObject(); <line3> log.addProperty(""appName"", appName); <line4> log.addProperty(""host"", localHostName); <line5> log.add(""event"", GSON.toJsonTree(object)); <line6> } <line7> } <line8> } <line9>  <LINE> <line2>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public Answer execute( <line2> final OvsDestroyBridgeCommand command, <line3> final LibvirtComputingResource libvirtComputingResource) { <line4> final boolean result = libvirtComputingResource.destroyTunnelNetwork(command.getBridgeName()); <line5> if (!result) { <line6> } <line7> return new Answer(command, result, null); <line8> } <line9> } <line10>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> public void cleanMetisIndexingDataset( <line1> String topologyName, long taskId, DataSetCleanerParameters dataSetCleanerParameters) <line2> throws DpsException { <line3> Response resp = null; <line4> try { <line5> resp = <line6> client <line7> .target(dpsUrl) <line8> .path(TASK_CLEAN_DATASET_URL) <line9> .resolveTemplate(TOPOLOGY_NAME, topologyName) <line10> .resolveTemplate(TASK_ID, taskId) <line11> .request() <line12> .post(Entity.json(dataSetCleanerParameters)); <line13> if (resp.getStatus() != Response.Status.OK.getStatusCode()) { <line14> throw handleException(resp); <line15> } <line16> } finally { <line17> closeResponse(resp); <line18> } <line19> } <line20> } <line21>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> private void notifyConnectionFailure(int error, String reason) { <line1> try { <line2> listener.onConnectionFailure(error, reason); <line3> } catch (Throwable x) { <line4> } <line5> } <line6> } <line7>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> public static void updateLatestStatus(String index, String type, String loaddate) { <line1> String updateJson = <line2> ""{\""script\"":{\""inline\"": \""ctx._source.latest=false\""},\""query\"": {\""bool\"": {\""must\"": [{"" <line3> + "" \""match\"": {\""latest\"":true}}], \""must_not\"": [{\""match\"":"" <line4> + "" {\""_loaddate.keyword\"":\"""" <line5> + loaddate <line6> + ""\""}}]}}}""; <line7> try { <line8> invokeAPI(""POST"", index + ""/"" + type + ""/"" + ""_update_by_query"", updateJson); <line9> } catch (IOException e) { <line10> } <line11> } <line12> } <line13>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public AccumuloResource makeObject() { <line2> AccumuloResource scannerResource = new AccumuloResource(client); <line3> return scannerResource; <line4> } <line5> } <line6>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> @Override <line1> public Method addingService(ServiceReference<Method> serviceReference) { <line2> Registry registry = RegistryUtil.getRegistry(); <line3> Method method = registry.getService(serviceReference); <line4> String token = method.getToken(); <line5> Map<String, Method> methods = _methodRegistry.get(token); <line6> if (methods == null) { <line7> methods = new HashMap<>(); <line8> _methodRegistry.put(token, methods); <line9> } <line10> String methodName = method.getMethodName(); <line11> Method registeredMethod = methods.get(methodName); <line12> if (registeredMethod != null) { <line13> if (log.isWarnEnabled()) { <line14> } <line15> } else { <line16> methods.put(methodName, method); <line17> } <line18> return method; <line19> } <line20> } <line21>  <LINE> <line14>	Yes	task2	
"<CODE> public class A { <line0> protected void createFlatHiveTable(KylinConfig config) throws IOException { <line1> final HiveCmdBuilder hiveCmdBuilder = <line2> new HiveCmdBuilder(getName() + "" "" + getCubeName() + "" "" + getId()); <line3> hiveCmdBuilder.overwriteHiveProps(config.getHiveConfigOverride()); <line4> hiveCmdBuilder.addStatement(getInitStatement()); <line5> hiveCmdBuilder.addStatement(getCreateTableStatement()); <line6> final String cmd = hiveCmdBuilder.toString(); <line7> stepLogger.log(""Create and distribute table, cmd: ""); <line8> stepLogger.log(cmd); <line9> Pair<Integer, String> response = config.getCliCommandExecutor().execute(cmd, stepLogger); <line10> Map<String, String> info = stepLogger.getInfo(); <line11> Matcher matcher = HDFS_LOCATION.matcher(cmd); <line12> if (matcher.find()) { <line13> String hiveFlatTableHdfsUrl = matcher.group(1); <line14> long size = getFileSize(hiveFlatTableHdfsUrl); <line15> info.put(ExecutableConstants.HDFS_BYTES_WRITTEN, """" + size); <line16> } <line17> getManager().addJobInfo(getId(), info); <line18> if (response.getFirst() != 0) { <line19> throw new RuntimeException( <line20> ""Failed to create flat hive table, error code "" + response.getFirst()); <line21> } <line22> } <line23> } <line24>  <LINE> <line16>"	Yes	task2	
"<CODE> public class A { <line0> public void deletePath(final String path) { <line1> Objects.requireNonNull(path, ""Path cannot be null""); <line2> if (path.length() == 0) { <line3> throw new IllegalArgumentException(""Invalid path: "" + path); <line4> } <line5> final String[] pathComponents = split(path); <line6> writeLock.lock(); <line7> try { <line8> TrieNode parent = rootNode; <line9> for (final String part : pathComponents) { <line10> if (parent.getChild(part) == null) { <line11> return; <line12> } <line13> parent = parent.getChild(part); <line14> } <line15> final TrieNode realParent = parent.getParent(); <line16> realParent.deleteChild(parent.getValue()); <line17> } finally { <line18> writeLock.unlock(); <line19> } <line20> } <line21> } <line22>  <LINE> <line17>"	No	task2	
<CODE> public class A { <line0> @Override <line1> protected long nextPartitionCounter(IgniteInternalTx tx, @Nullable Long primaryCntr) { <line2> try { <line3> return locPart.nextUpdateCounter(cctx.cacheId(), tx, primaryCntr); <line4> } catch (Throwable t) { <line5> throw t; <line6> } <line7> } <line8> } <line9>  <LINE> <line2>	No	task2	
"<CODE> public class A { <line0> public SearchContext buildStructureSearchContext( <line1> long companyId, <line2> long[] groupIds, <line3> long userId, <line4> long classNameId, <line5> Long classPK, <line6> String name, <line7> String description, <line8> String storageType, <line9> Integer type, <line10> int status, <line11> int start, <line12> int end, <line13> OrderByComparator<DDMStructure> orderByComparator) { <line14> SearchContext searchContext = new SearchContext(); <line15> searchContext.setAttribute(Field.CLASS_NAME_ID, classNameId); <line16> searchContext.setAttribute(Field.CLASS_PK, classPK); <line17> searchContext.setAttribute(Field.DESCRIPTION, description); <line18> searchContext.setAttribute(Field.NAME, name); <line19> searchContext.setAttribute(Field.STATUS, status); <line20> try { <line21> searchContext.setAttribute( <line22> ""resourcePermissionName"", <line23> _ddmPermissionSupport.getStructureModelResourceName(classNameId)); <line24> } catch (PortalException portalException) { <line25> if (log.isDebugEnabled()) { <line26> } <line27> } <line28> searchContext.setAttribute(""storageType"", storageType); <line29> searchContext.setAttribute(""type"", type); <line30> searchContext.setCompanyId(companyId); <line31> searchContext.setEnd(end); <line32> searchContext.setGroupIds(groupIds); <line33> searchContext.setStart(start); <line34> if (userId > 0) { <line35> searchContext.setUserId(userId); <line36> } <line37> if (orderByComparator != null) { <line38> searchContext.setSorts(getSortsFromComparator(orderByComparator)); <line39> } <line40> return searchContext; <line41> } <line42> } <line43>  <LINE> <line26>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void notifyElementExpired(Ehcache cache, Element element) { <line2> _cache.remove(element.getKey()); <line3> } <line4> } <line5>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> public Long getCallTimeout() { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> return raProperties.getCallTimeout(); <line4> } <line5> } <line6>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void start() { <line2> if (pool == null) { <line3> this.pool = <line4> IoTDBThreadPoolFactory.newCachedThreadPool(ThreadName.FLUSH_SUB_TASK_SERVICE.getName()); <line5> } <line6> } <line7> } <line8>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> protected Answer execute(CreateObjectCommand cmd) { <line1> DataTO data = cmd.getData(); <line2> try { <line3> if (data.getObjectType() == DataObjectType.VOLUME) { <line4> return processor.createVolume(cmd); <line5> } else if (data.getObjectType() == DataObjectType.SNAPSHOT) { <line6> return processor.createSnapshot(cmd); <line7> } <line8> return new CreateObjectAnswer(""not supported type""); <line9> } catch (Exception e) { <line10> return new CreateObjectAnswer(e.toString()); <line11> } <line12> } <line13> } <line14>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> public org.talend.mdm.webservice.WSRoutingOrderV2PK executeRoutingOrderV2Asynchronously( <line1> org.talend.mdm.webservice.WSExecuteRoutingOrderV2Asynchronously arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSRoutingOrderV2PK _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12>  <LINE> <line4>	No	task2	
"<CODE> public class A { <line0> public static void incrementFailedLoginAttemptsCounter(final Principal principal) { <line1> try { <line2> final PropertyKey<Integer> passwordAttemptsKey = <line3> StructrApp.key(Principal.class, ""passwordAttempts""); <line4> Integer failedAttempts = principal.getProperty(passwordAttemptsKey); <line5> if (failedAttempts == null) { <line6> failedAttempts = 0; <line7> } <line8> failedAttempts++; <line9> principal.setProperty(passwordAttemptsKey, failedAttempts); <line10> } catch (FrameworkException fex) { <line11> } <line12> } <line13> } <line14>  <LINE> <line11>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void onFailure( <line2> final Throwable throwable, final HttpServerResponse response, final Span span) { <line3> TracingHelper.logError(span, throwable); <line4> } <line5> } <line6>  <LINE> <line4>	No	task2	
<CODE> public class A { <line0> private Map<String, Object> getTemplateVariables(Locale locale) { <line1> Map<String, Object> templateVariables = Maps.newHashMap(); <line2> Map<String, Object> sharedVariables = templateVariablesByLocale.get(null); <line3> if (sharedVariables != null) { <line4> templateVariables.putAll(sharedVariables); <line5> } <line6> Map<String, Object> localeDependentVariables = templateVariablesByLocale.get(locale); <line7> if (localeDependentVariables != null) { <line8> templateVariables.putAll(localeDependentVariables); <line9> } <line10> if (!attachments.isEmpty()) { <line11> if (!templateVariables.containsKey(ATTACHMENT_NAMES_VARIABLE_NAME)) { <line12> Collection<String> labels = Lists.newArrayList(); <line13> for (LabelValue<String, ?> labelValue : attachments) { <line14> labels.add(labelValue.getLabel()); <line15> } <line16> templateVariables.put(ATTACHMENT_NAMES_VARIABLE_NAME, labels); <line17> } else { <line18> } <line19> } <line20> return templateVariables; <line21> } <line22> } <line23>  <LINE> <line6>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void onScanEnded() { <line2> if (createdMethodCount > 0) { <line3> } <line4> } <line5> } <line6>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> public GroupStructuralData getGroupStructuralContents(String group) throws EngineException { <line1> Stopwatch watch = Stopwatch.createStarted(); <line2> GroupStructuralDataImpl ret = <line3> GroupStructuralDataImpl.builder() <line4> .withGroup(group) <line5> .withGroups(groupDAO.getAllAsMap()) <line6> .build(); <line7> return ret; <line8> } <line9> } <line10>  <LINE> <line7>	Yes	task2	
<CODE> public class A { <line0> public WorkflowSettings build() { <line1> WorkflowSettings instance = new WorkflowSettings(this); <line2> return instance; <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> protected Map<Long, Long> copyDocumentBatch( <line1> Long versionId, Long newVersionId, int batchStart, int batchLength) { <line2> try { <line3> return transactionUtil.call( <line4> () -> copyDocument(versionId, newVersionId, batchStart, batchLength)); <line5> } catch (Exception e) { <line6> return Collections.emptyMap(); <line7> } <line8> } <line9> } <line10>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> @OnWebSocketClose <line1> public void onClose(int statusCode, String reason) { <line2> if (statusCode != StatusCode.NORMAL) { <line3> } <line4> if (session != null) { <line5> if (!session.isOpen()) { <line6> if (session != null) { <line7> session.close(); <line8> } <line9> } <line10> session = null; <line11> } <line12> if (websocketHandler != null) { <line13> websocketHandler.onClose(); <line14> } <line15> } <line16> } <line17>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public RepositoryConfig getRepositoryConfig(String repositoryID) <line2> throws RepositoryConfigException, RepositoryException { <line3> RepositoryConfig result = delegate.getRepositoryConfig(repositoryID); <line4> if (result != null) { <line5> if (!isCorrectType(result)) { <line6> result = null; <line7> } <line8> } <line9> return result; <line10> } <line11> } <line12>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> protected static String getDoasUser(HttpServletRequest request) { <line1> String doAsUser = """"; <line2> String queryString = request.getQueryString(); <line3> if (queryString != null) { <line4> String[] pairs = queryString.split(QUERY_STRING_DELIMITER); <line5> try { <line6> for (String pair : pairs) { <line7> if (pair.startsWith(DOAS_QUERY_STRING)) { <line8> doAsUser = <line9> URLDecoder.decode(pair.substring(DOAS_QUERY_STRING.length()), ""UTF-8"").trim(); <line10> } <line11> } <line12> } catch (UnsupportedEncodingException ex) { <line13> } <line14> } <line15> return doAsUser.isEmpty() ? null : doAsUser; <line16> } <line17> } <line18>  <LINE> <line12>"	No	task2	
<CODE> public class A { <line0> private void runRestore() { <line1> try { <line2> backupManager.restoreWorkspaceBackup(WORKSPACE_ID, CONTAINER_ID, NODE_HOST); <line3> } catch (ServerException | EnvironmentException e) { <line4> } <line5> } <line6> } <line7>  <LINE> <line4>	Yes	task2	
<CODE> public class A { <line0> private URI buildResourceUri(final String... path) { <line1> final UriBuilder uriBuilder = uriInfo.getBaseUriBuilder(); <line2> uriBuilder.segment(path); <line3> URI uri = uriBuilder.build(); <line4> try { <line5> final String scheme = <line6> getFirstHeaderValue(PROXY_SCHEME_HTTP_HEADER, FORWARDED_PROTO_HTTP_HEADER); <line7> final String hostHeaderValue = <line8> getFirstHeaderValue(PROXY_HOST_HTTP_HEADER, FORWARDED_HOST_HTTP_HEADER); <line9> final String portHeaderValue = <line10> getFirstHeaderValue(PROXY_PORT_HTTP_HEADER, FORWARDED_PORT_HTTP_HEADER); <line11> final String host = WebUtils.determineProxiedHost(hostHeaderValue); <line12> final String port = WebUtils.determineProxiedPort(hostHeaderValue, portHeaderValue); <line13> String allowedContextPaths = properties.getAllowedContextPaths(); <line14> String resourcePath = WebUtils.getResourcePath(uri, httpServletRequest, allowedContextPaths); <line15> int uriPort = uri.getPort(); <line16> if (port != null) { <line17> if (StringUtils.isWhitespace(port)) { <line18> uriPort = -1; <line19> } else { <line20> try { <line21> uriPort = Integer.parseInt(port); <line22> } catch (final NumberFormatException nfe) { <line23> } <line24> } <line25> } <line26> uri = <line27> new URI( <line28> (StringUtils.isBlank(scheme)) ? uri.getScheme() : scheme, <line29> uri.getUserInfo(), <line30> (StringUtils.isBlank(host)) ? uri.getHost() : host, <line31> uriPort, <line32> resourcePath, <line33> uri.getQuery(), <line34> uri.getFragment()); <line35> } catch (final URISyntaxException use) { <line36> throw new UriBuilderException(use); <line37> } <line38> return uri; <line39> } <line40> } <line41>  <LINE> <line23>	Yes	task2	
"<CODE> public class A { <line0> public static byte[] compute( <line1> PRFAlgorithm prfAlgorithm, byte[] secret, String label, byte[] seed, int size) <line2> throws CryptoException { <line3> if (prfAlgorithm == null) { <line4> prfAlgorithm = PRFAlgorithm.TLS_PRF_LEGACY; <line5> } <line6> switch (prfAlgorithm) { <line7> case TLS_PRF_SHA256: <line8> case TLS_PRF_SHA384: <line9> case TLS_PRF_GOSTR3411: <line10> case TLS_PRF_GOSTR3411_2012_256: <line11> return computeTls12( <line12> secret, label, seed, size, prfAlgorithm.getMacAlgorithm().getJavaName()); <line13> case TLS_PRF_LEGACY: <line14> return TlsUtils.PRF_legacy(secret, label, seed, size); <line15> default: <line16> throw new UnsupportedOperationException( <line17> ""PRF computation for different"" + "" protocol versions is not supported yet""); <line18> } <line19> } <line20> } <line21>  <LINE> <line13>"	No	task2	
"<CODE> public class A { <line0> @Disabled <line1> @Test <line2> public void testCancelRelease() throws Exception { <line3> final com.braintreegateway.Result result = requestBody(""direct://CANCELRELEASE"", null); <line4> assertNotNull(result, ""cancelRelease result""); <line5> } <line6> } <line7>  <LINE> <line5>"	Yes	task2	
<CODE> public class A { <line0> private void unloadModule() { <line1> try { <line2> if (module != null) { <line3> loader.unload(conf.getProjectName(), module); <line4> } <line5> } catch (Exception x) { <line6> } finally { <line7> module = null; <line8> } <line9> } <line10> } <line11>  <LINE> <line6>	Yes	task2	
<CODE> public class A { <line0> public void verifyDigest() { <line1> try { <line2> final DigestVerifierEnumerator dv = new DigestVerifierEnumerator(); <line3> final List<LibraryId> verified = dv.verify(this); <line4> if (verified != null) { <line5> this.setDigestVerificationUrl(dv.getVerificationUrl()); <line6> this.setWellknownDigest(verified.size() > 0); <line7> this.setDigestTimestamp(dv.getReleaseTimestamp()); <line8> if (this.getLibraryId() != null <line9> && verified.size() > 0 <line10> && !verified.contains(this.getLibraryId())) { <line11> this.setLibraryId(verified.get(0)); <line12> } <line13> } <line14> } catch (VerificationException e) { <line15> } <line16> } <line17> } <line18>  <LINE> <line13>	No	task2	
<CODE> public class A { <line0> public void deleteAssetById(Long assetId) { <line1> authenticatedRestTemplate.delete(getBasePathForResource(assetId)); <line2> } <line3> } <line4>  <LINE> <line1>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public @Nullable ThingUID getThingUID(RemoteDevice device) { <line2> if (device.getDetails().getManufacturerDetails().getManufacturer() != null) { <line3> if (device <line4> .getDetails() <line5> .getManufacturerDetails() <line6> .getManufacturer() <line7> .toUpperCase() <line8> .contains(""SONOS"")) { <line9> String modelName = getModelName(device); <line10> switch (modelName) { <line11> case ""ZP80"": <line12> modelName = ""CONNECT""; <line13> break; <line14> case ""ZP100"": <line15> modelName = ""CONNECTAMP""; <line16> break; <line17> case ""One SL"": <line18> modelName = ""OneSL""; <line19> break; <line20> case ""Arc SL"": <line21> modelName = ""ArcSL""; <line22> break; <line23> default: <line24> break; <line25> } <line26> ThingTypeUID thingUID = new ThingTypeUID(SonosBindingConstants.BINDING_ID, modelName); <line27> if (!SonosBindingConstants.SUPPORTED_KNOWN_THING_TYPES_UIDS.contains(thingUID)) { <line28> thingUID = new ThingTypeUID(SonosBindingConstants.BINDING_ID, modelName.toUpperCase()); <line29> if (!SonosBindingConstants.SUPPORTED_KNOWN_THING_TYPES_UIDS.contains(thingUID)) { <line30> thingUID = SonosBindingConstants.ZONEPLAYER_THING_TYPE_UID; <line31> } <line32> } <line33> return new ThingUID(thingUID, device.getIdentity().getUdn().getIdentifierString()); <line34> } <line35> } <line36> return null; <line37> } <line38> } <line39>  <LINE> <line33>"	Yes	task2	
<CODE> public class A { <line0> private String[] loadCategoryUtilizers() { <line1> String[] beans = null; <line2> try { <line3> beans = <line4> BeanFactoryUtils.beanNamesForTypeIncludingAncestors( <line5> (ListableBeanFactory) this.getBeanFactory(), CategoryUtilizer.class); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(t); <line8> } <line9> return beans; <line10> } <line11> } <line12>  <LINE> <line7>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> protected void execute() throws Exception { <line2> final String MATCH_RESULT = ""The current EC policy is replication already.""; <line3> final String DIR_RESULT = <line4> ""The replication EC policy is set successfully for the given directory.""; <line5> final String CONVERT_RESULT = ""The file is converted successfully with replication EC policy.""; <line6> this.setDfsClient(HadoopUtil.getDFSClient(HadoopUtil.getNameNodeUri(conf), conf)); <line7> HdfsFileStatus fileStatus = dfsClient.getFileInfo(srcPath); <line8> if (fileStatus == null) { <line9> throw new ActionException(""File doesn't exist!""); <line10> } <line11> ErasureCodingPolicy srcEcPolicy = fileStatus.getErasureCodingPolicy(); <line12> if (srcEcPolicy == null) { <line13> this.progress = 1.0F; <line14> appendLog(MATCH_RESULT); <line15> return; <line16> } <line17> if (fileStatus.isDir()) { <line18> dfsClient.setErasureCodingPolicy(srcPath, ecPolicyName); <line19> progress = 1.0F; <line20> appendLog(DIR_RESULT); <line21> return; <line22> } <line23> try { <line24> convert(fileStatus); <line25> setAttributes(srcPath, fileStatus, ecTmpPath); <line26> dfsClient.rename(ecTmpPath, srcPath, Options.Rename.OVERWRITE); <line27> appendLog(CONVERT_RESULT); <line28> appendLog(String.format(""The previous EC policy is %s."", srcEcPolicy.getName())); <line29> appendLog(String.format(""The current EC policy is %s."", REPLICATION_POLICY_NAME)); <line30> } catch (ActionException ex) { <line31> try { <line32> if (dfsClient.getFileInfo(ecTmpPath) != null) { <line33> dfsClient.delete(ecTmpPath, false); <line34> } <line35> } catch (IOException e) { <line36> } <line37> throw new ActionException(ex); <line38> } <line39> } <line40> } <line41>  <LINE> <line25>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public Functionality find(Account actor, String domainId, String functionalityId, boolean tree) <line2> throws BusinessException { <line3> Validate.notEmpty(domainId); <line4> Validate.notEmpty(functionalityId); <line5> Validate.notNull(actor); <line6> Validate.isTrue(actor.hasAdminRole() || actor.hasSuperAdminRole()); <line7> AbstractDomain domain = getDomain(actor, domainId); <line8> Functionality entity = businessService.getFunctionality(domain, functionalityId); <line9> Set<Functionality> functionalities = businessService.getAllFunctionalities(domain, excludes); <line10> for (Functionality f : functionalities) { <line11> if (f.isParam()) { <line12> if (f.getParentIdentifier().equals(functionalityId)) { <line13> if (f.isDisplayable()) { <line14> entity.setDisplayable(true); <line15> if (tree) { <line16> entity.addChild(f); <line17> } <line18> } <line19> } <line20> } <line21> } <line22> if (!entity.isDisplayable()) { <line23> throw new BusinessException( <line24> BusinessErrorCode.FUNCTIONALITY_NOT_FOUND, <line25> ""Functionality not found : "" + functionalityId); <line26> } <line27> return entity; <line28> } <line29> } <line30>  <LINE> <line7>"	Yes	task2	
<CODE> public class A { <line0> @FinishBundle <line1> public void finishBundle(FinishBundleContext c) { <line2> if (bundleTaskContextMap == null) { <line3> return; <line4> } <line5> for (Map.Entry<KV<BoundedWindow, Integer>, TaskContext<KeyT, ValueT>> entry : <line6> bundleTaskContextMap.entrySet()) { <line7> TaskContext<KeyT, ValueT> taskContext = entry.getValue(); <line8> try { <line9> taskContext.getRecordWriter().close(taskContext.getTaskAttemptContext()); <line10> taskContext.getOutputCommitter().commitTask(taskContext.getTaskAttemptContext()); <line11> } catch (Exception e) { <line12> processTaskException(taskContext, e); <line13> } <line14> BoundedWindow window = entry.getKey().getKey(); <line15> c.output(taskContext.getTaskId(), Objects.requireNonNull(window).maxTimestamp(), window); <line16> } <line17> } <line18> } <line19>  <LINE> <line11>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void deleteUploadPart(String objectId, String uploadId, Part part) throws IOException { <line2> retry.execute( <line3> ctx -> { <line4> serviceTemplate.exchange( <line5> endpoint + ""/upload/{object-id}/parts?uploadId={upload-id}&partNumber={partNumber}"", <line6> DELETE, <line7> defaultEntity(), <line8> Void.class, <line9> objectId, <line10> uploadId, <line11> part.getPartNumber()); <line12> return null; <line13> }); <line14> } <line15> } <line16>  <LINE> <line3>"	No	task2	
"<CODE> public class A { <line0> @GET <line1> @Path(""{transactionId}"") <line2> public Response getTransactionStatus(@PathParam(""transactionId"") final String txId) { <line3> final Transaction tx; <line4> try { <line5> tx = txManager.get(txId); <line6> } catch (final TransactionNotFoundException e) { <line7> return Response.status(Status.NOT_FOUND).build(); <line8> } catch (final TransactionClosedException e) { <line9> return Response.status(Status.GONE) <line10> .entity(e.getMessage()) <line11> .type(TEXT_PLAIN_WITH_CHARSET) <line12> .build(); <line13> } <line14> return Response.status(Status.NO_CONTENT) <line15> .header(ATOMIC_EXPIRES_HEADER, EXPIRES_RFC_1123_FORMATTER.format(tx.getExpires())) <line16> .build(); <line17> } <line18> } <line19>  <LINE> <line15>"	No	task2	
"<CODE> public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public void stop() { <line2> executor.shutdown(); <line3> thread.interrupt(); <line4> try { <line5> thread.join(3000); <line6> if (thread.isAlive()) { <line7> thread.stop(); <line8> } <line9> } catch (InterruptedException e) { <line10> } <line11> } <line12> } <line13>  <LINE> <line7>"	Yes	task2	
"<CODE> public class A { <line0> public static void testAddClassName_Rollback(HttpPrincipal httpPrincipal, String classNameValue) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> PortalServiceUtil.class, <line5> ""testAddClassName_Rollback"", <line6> _testAddClassName_RollbackParameterTypes3); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, classNameValue); <line8> try { <line9> TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line14> throw systemException; <line15> } <line16> } <line17> } <line18>  <LINE> <line11>"	No	task2	
<CODE> public class A { <line0> protected void checkResponseEntity(Response response) { <line1> if (!response.hasEntity()) { <line2> } <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> public void createSecureConfiguration() throws InterpreterException { <line1> Properties properties = getProperties(); <line2> CommandLine cmdLine = CommandLine.parse(shell); <line3> cmdLine.addArgument(""-c"", false); <line4> String kinitCommand = <line5> String.format( <line6> ""kinit -k -t %s %s"", <line7> properties.getProperty(SUBMARINE_HADOOP_KEYTAB), <line8> properties.getProperty(SUBMARINE_HADOOP_PRINCIPAL)); <line9> cmdLine.addArgument(kinitCommand, false); <line10> DefaultExecutor executor = new DefaultExecutor(); <line11> try { <line12> executor.execute(cmdLine); <line13> } catch (Exception e) { <line14> throw new InterpreterException(e); <line15> } <line16> } <line17> } <line18>  <LINE> <line8>"	No	task2	
"<CODE> public class A { <line0> @Reference( <line1> cardinality = ReferenceCardinality.MULTIPLE, <line2> policy = ReferencePolicy.DYNAMIC, <line3> policyOption = ReferencePolicyOption.GREEDY) <line4> protected synchronized void setConfigurationProvider( <line5> ConfigurationProvider<?> configurationProvider, Map<String, Object> properties) { <line6> String factoryPid = MapUtil.getString(properties, ""factoryPid""); <line7> if (Validator.isNull(factoryPid)) { <line8> throw new IllegalArgumentException( <line9> ""No factory PID specified for configuration provider "" + configurationProvider); <line10> } <line11> _configurationProviders.put(factoryPid, configurationProvider); <line12> try { <line13> Configuration[] configurations = <line14> _configurationAdmin.listConfigurations(""(service.factoryPid="" + factoryPid + ""*)""); <line15> if (configurations != null) { <line16> for (Configuration configuration : configurations) { <line17> configurationProvider.registerConfiguration(configuration); <line18> } <line19> } <line20> } catch (Exception exception) { <line21> if (log.isWarnEnabled()) { <line22> } <line23> } <line24> } <line25> } <line26>  <LINE> <line22>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void onEvent(SensorEvent<Object> event) { <line2> AttributeSensor<Boolean> sensor = config().get(START_SENSOR); <line3> if (event.getSensor().getName().equals(sensor.getName())) { <line4> boolean start = Boolean.TRUE.equals(event.getValue()); <line5> if (start && running.compareAndSet(false, true)) { <line6> config().set(RUNNING, true); <line7> highlightConfirmation(""Starting effector invocation schedule""); <line8> start(); <line9> } <line10> } <line11> AttributeSensor<Boolean> sensor2 = config().get(ENABLED_SENSOR); <line12> if (sensor2 != null && event.getSensor().getName().equals(sensor2.getName())) { <line13> boolean enable = Boolean.TRUE.equals(event.getValue()); <line14> if (running.compareAndSet(!enable, enable)) { <line15> config().set(RUNNING, enable); <line16> if (enable) { <line17> highlightConfirmation(""Resuming effector invocation schedule""); <line18> resume(); <line19> } else { <line20> highlightViolation(""Suspending effector invocation""); <line21> suspend(); <line22> } <line23> } <line24> } <line25> } <line26> } <line27>  <LINE> <line24>"	No	task2	
<CODE> public class A { <line0> private void validateInConfigWithExplicitTotalFlinkMem( <line1> Configuration customConfig, Consumer<JobManagerProcessSpec> validateFunc) { <line2> Configuration config = configWithExplicitTotalFlinkMem(); <line3> config.addAll(customConfig); <line4> JobManagerProcessSpec jobManagerProcessSpec = <line5> JobManagerProcessUtils.processSpecFromConfig(config); <line6> assertThat(jobManagerProcessSpec.getTotalFlinkMemorySize(), is(TOTAL_FLINK_MEM_SIZE)); <line7> validateFunc.accept(jobManagerProcessSpec); <line8> } <line9> } <line10>  <LINE> <line9>	No	task2	
<CODE> public class A { <line0> public static com.liferay.commerce.currency.model.CommerceCurrencySoap getCommerceCurrency( <line1> long commerceCurrencyId) throws RemoteException { <line2> try { <line3> com.liferay.commerce.currency.model.CommerceCurrency returnValue = <line4> CommerceCurrencyServiceUtil.getCommerceCurrency(commerceCurrencyId); <line5> return com.liferay.commerce.currency.model.CommerceCurrencySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> protected Map<String, Object> ingest( <line1> final AccessResult<String> accessResult, final Map<String, Object> map) { <line2> if (ingestFactory == null) { <line3> return map; <line4> } <line5> Map<String, Object> target = map; <line6> for (final Ingester ingester : ingestFactory.getIngesters()) { <line7> try { <line8> target = ingester.process(target, accessResult); <line9> } catch (final Exception e) { <line10> } <line11> } <line12> return target; <line13> } <line14> } <line15>  <LINE> <line9>	No	task2	
<CODE> public class A { <line0> private void parseSignatureLength(CertificateVerifyMessage msg) { <line1> msg.setSignatureLength(parseIntField(HandshakeByteLength.SIGNATURE_LENGTH)); <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> public void createTable(HTableDescriptor tableDesc, byte[][] splitKeys) throws IOException { <line1> hbaseAdmin.createTable(tableDesc, splitKeys); <line2> } <line3> } <line4>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> @Override <line1> public boolean contains(IMolecularFormula formula) { <line2> return super.contains(formula); <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> private Duration getControllerClientSslHandshakeTimeoutFromEnvironment() { <line1> Integer value = <line2> environment.getPositiveInteger( <line3> CFG_CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS, <line4> DEFAULT_CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS); <line5> return Duration.ofSeconds(value); <line6> } <line7> } <line8>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> @Override <line1> public Map<String, String> getServerOpOptions( <line2> final String index, final String serverOpName, final ServerOpScope scope) { <line3> try { <line4> final IteratorSetting setting = <line5> connector <line6> .tableOperations() <line7> .getIteratorSetting(getQualifiedTableName(index), serverOpName, toAccumulo(scope)); <line8> if (setting != null) { <line9> return setting.getOptions(); <line10> } <line11> } catch (AccumuloSecurityException | AccumuloException | TableNotFoundException e) { <line12> } <line13> return Collections.emptyMap(); <line14> } <line15> } <line16>  <LINE> <line14>	No	task2	
<CODE> public class A { <line0> public void visitDenyUncoveredHttpMethods( <line1> WebAppContext context, Descriptor descriptor, XmlParser.Node node) { <line2> if (context.getSecurityHandler() == null) { <line3> return; <line4> } <line5> ((ConstraintAware) context.getSecurityHandler()).setDenyUncoveredHttpMethods(true); <line6> } <line7> } <line8>  <LINE> <line4>	No	task2	
<CODE> public class A { <line0> private void _generateImages(FileVersion sourceFileVersion, FileVersion destinationFileVersion) <line1> throws Exception { <line2> try { <line3> if (sourceFileVersion != null) { <line4> copy(sourceFileVersion, destinationFileVersion); <line5> return; <line6> } <line7> if (!PropsValues.DL_FILE_ENTRY_THUMBNAIL_ENABLED <line8> && !PropsValues.DL_FILE_ENTRY_PREVIEW_ENABLED) { <line9> return; <line10> } <line11> try (InputStream inputStream = destinationFileVersion.getContentStream(false)) { <line12> byte[] bytes = FileUtil.getBytes(inputStream); <line13> ImageBag imageBag = ImageToolUtil.read(bytes); <line14> RenderedImage renderedImage = imageBag.getRenderedImage(); <line15> if (renderedImage == null) { <line16> _fileVersionPreviewEventListener.onFailure(destinationFileVersion); <line17> return; <line18> } <line19> ColorModel colorModel = renderedImage.getColorModel(); <line20> if (colorModel.getNumColorComponents() == 4) { <line21> Future<RenderedImage> future = ImageToolUtil.convertCMYKtoRGB(bytes, imageBag.getType()); <line22> if (future == null) { <line23> _fileVersionPreviewEventListener.onFailure(destinationFileVersion); <line24> return; <line25> } <line26> String processIdentity = String.valueOf(destinationFileVersion.getFileVersionId()); <line27> futures.put(processIdentity, future); <line28> RenderedImage convertedRenderedImage = future.get(); <line29> if (convertedRenderedImage != null) { <line30> renderedImage = convertedRenderedImage; <line31> } <line32> } <line33> if (!_hasPreview(destinationFileVersion)) { <line34> _storePreviewImage(destinationFileVersion, renderedImage); <line35> } <line36> if (!hasThumbnails(destinationFileVersion)) { <line37> storeThumbnailImages(destinationFileVersion, renderedImage); <line38> } <line39> _fileVersionPreviewEventListener.onSuccess(destinationFileVersion); <line40> } <line41> } catch (NoSuchFileEntryException noSuchFileEntryException) { <line42> if (log.isDebugEnabled()) { <line43> } <line44> _fileVersionPreviewEventListener.onFailure(destinationFileVersion); <line45> } finally { <line46> _fileVersionIds.remove(destinationFileVersion.getFileVersionId()); <line47> } <line48> } <line49> } <line50>  <LINE> <line43>	Yes	task2	
<CODE> public class A { <line0> private CSVRecordReader getCSVRecordReader(String file) throws IOException, URISyntaxException { <line1> InputSplit split = ColumnBasedHandlerTestUtil.getSplit(file); <line2> TaskAttemptContext ctx = new TaskAttemptContextImpl(conf, new TaskAttemptID()); <line3> TypeRegistry.reset(); <line4> TypeRegistry.getInstance(ctx.getConfiguration()); <line5> CSVRecordReader reader = new CSVRecordReader(); <line6> reader.initialize(split, ctx); <line7> return reader; <line8> } <line9> } <line10>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> private Class<?> determineExpectedClass(final Node node, final Class<?> fallbackType) { <line1> final NamedNodeMap attributes = node.getAttributes(); <line2> if (attributes != null) { <line3> final Node attribute = attributes.getNamedItem(""class""); <line4> if (attribute != null) { <line5> final String className = attribute.getTextContent(); <line6> if (!StringUtils.isNullOrEmpty(className)) { <line7> try { <line8> return Class.forName(className); <line9> } catch (final ClassNotFoundException e) { <line10> } <line11> } <line12> } <line13> } <line14> return fallbackType; <line15> } <line16> } <line17>  <LINE> <line10>"	Yes	task2	
"<CODE> public class A { <line0> public void validateScopeExpression(String scopeExpression) { <line1> if (StringUtils.isNotBlank(scopeExpression) <line2> && !expressionService.isExpressionValid(scopeExpression)) { <line3> throw errorResponseFactory.createWebApplicationException( <line4> BAD_REQUEST, <line5> UmaErrorResponseType.INVALID_SCOPE, <line6> ""Scope expression is invalid. Expression: "" + scopeExpression); <line7> } <line8> } <line9> } <line10>  <LINE> <line1>"	No	task2	
"<CODE> public class A { <line0> private void saveCriteria( <line1> final NiFiWebConfigurationRequestContext requestContext, final Criteria criteria) { <line2> final String annotationData = CriteriaSerDe.serialize(criteria); <line3> final NiFiWebConfigurationContext configurationContext = <line4> (NiFiWebConfigurationContext) servletContext.getAttribute(""nifi-web-configuration-context""); <line5> try { <line6> configurationContext.updateComponent(requestContext, annotationData, null); <line7> } catch (final InvalidRevisionException ire) { <line8> throw new WebApplicationException(ire, invalidRevision(ire.getMessage())); <line9> } catch (final IllegalArgumentException iae) { <line10> throw new WebApplicationException(iae, badRequest(iae.getMessage())); <line11> } catch (final Exception e) { <line12> final String message = <line13> String.format( <line14> ""Unable to save UpdateAttribute[id=%s] criteria: %s"", requestContext.getId(), e); <line15> throw new WebApplicationException(e, error(message)); <line16> } <line17> } <line18> } <line19>  <LINE> <line15>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void destroy() throws Exception { <line2> sslCtx = null; <line3> ssl = null; <line4> updateThreadRunning.compareAndSet(true, false); <line5> nodeRefreshThread.interrupt(); <line6> try { <line7> nodeRefreshThread.join(); <line8> } catch (InterruptedException e) { <line9> Thread.currentThread().interrupt(); <line10> } <line11> nodeRefreshThread = null; <line12> } <line13> } <line14>  <LINE> <line13>	No	task2	
"<CODE> public class A { <line0> private Command executeCommandWithRetries(String command) <line1> throws TransportException, ConnectionException { <line2> int currentRetryCount = 0; <line3> Command cmd = null; <line4> while (true) { <line5> cmd = executeCommand(command); <line6> if (cmd == null) { <line7> if (currentRetryCount >= SSH_MAX_RETRY_COUNT) { <line8> throw new RuntimeException(""Retry limit exceeded when trying to execute ssh command.""); <line9> } <line10> ++currentRetryCount; <line11> try { <line12> Thread.sleep(1000 * SSH_RETRY_COOLDOWN_IN_SEC); <line13> } catch (InterruptedException e1) { <line14> throw new RuntimeException(e1); <line15> } <line16> continue; <line17> } <line18> break; <line19> } <line20> return cmd; <line21> } <line22> } <line23>  <LINE> <line14>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void afterMessageProcessed( <line2> PipeLineResult processResult, Object rawMessageOrWrapper, Map<String, Object> context) <line3> throws ListenerException { <line4> FS fileSystem = getFileSystem(); <line5> if ((rawMessageOrWrapper instanceof MessageWrapper)) { <line6> MessageWrapper<?> wrapper = (MessageWrapper<?>) rawMessageOrWrapper; <line7> if (StringUtils.isNotEmpty(getLogFolder()) <line8> || StringUtils.isNotEmpty(getErrorFolder()) <line9> || StringUtils.isNotEmpty(getProcessedFolder())) { <line10> } <line11> } else { <line12> @SuppressWarnings(""unchecked"") <line13> F rawMessage = (F) rawMessageOrWrapper; <line14> try { <line15> if (StringUtils.isNotEmpty(getLogFolder())) { <line16> FileSystemUtils.copyFile( <line17> fileSystem, <line18> rawMessage, <line19> getLogFolder(), <line20> isOverwrite(), <line21> getNumberOfBackups(), <line22> isCreateFolders()); <line23> } <line24> if (isDelete() && (processResult.isSuccessful() || StringUtils.isEmpty(getErrorFolder()))) { <line25> fileSystem.deleteFile(rawMessage); <line26> return; <line27> } <line28> } catch (FileSystemException e) { <line29> throw new ListenerException( <line30> ""Could not move or delete file ["" + fileSystem.getName(rawMessage) + ""]"", e); <line31> } <line32> } <line33> } <line34> } <line35>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> private void translationDocumentUpdated(XWikiDocument document) { <line1> if (!document.getOriginalDocument().isNew()) { <line2> unregisterTranslationBundle(document.getOriginalDocument()); <line3> } <line4> if (!document.isNew()) { <line5> try { <line6> registerTranslationBundle(document); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> } <line12>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void onSuccess(Request result) { <line2> if (callback != null) { <line3> callback.onSuccess(t); <line4> } <line5> } <line6> } <line7>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> public Future<CommandResult> writeAttribute( <line1> final int attributeId, final ZclDataType dataType, final Object value) { <line2> final WriteAttributeRecord attributeIdentifier = new WriteAttributeRecord(); <line3> attributeIdentifier.setAttributeIdentifier(attributeId); <line4> attributeIdentifier.setAttributeDataType(dataType); <line5> attributeIdentifier.setAttributeValue(value); <line6> return writeAttributes(Collections.singletonList(attributeIdentifier)); <line7> } <line8> } <line9>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> protected void handleSessionEvent(ISessionListener listener, SessionEvent event) { <line1> try { <line2> listener.sessionChanged(event); <line3> } catch (RuntimeException e) { <line4> if (event.getType() != SessionEvent.TYPE_STOPPED <line5> && event.getType() != SessionEvent.TYPE_STOPPING) { <line6> throw e; <line7> } <line8> } <line9> } <line10> } <line11>  <LINE> <line8>	Yes	task2	
<CODE> public class A { <line0> private void onFinish(SingularityExecutorTask task, Protos.TaskState taskState) { <line1> processKiller.cancelDestroyFuture(task.getTaskId()); <line2> tasks.remove(task.getTaskId()); <line3> processRunningTasks.remove(task.getTaskId()); <line4> processBuildingTasks.remove(task.getTaskId()); <line5> task.cleanup(taskState); <line6> ListeningExecutorService executorService = taskToShellCommandPool.remove(task.getTaskId()); <line7> if (executorService != null) { <line8> executorService.shutdownNow(); <line9> try { <line10> executorService.awaitTermination(5, TimeUnit.MILLISECONDS); <line11> } catch (InterruptedException e) { <line12> } <line13> } <line14> logging.stopTaskLogger(task.getTaskId(), task.getLogbackLog()); <line15> checkIdleExecutorShutdown(task.getDriver()); <line16> } <line17> } <line18>  <LINE> <line12>	Yes	task2	
"<CODE> public class A { <line0> private void load( <line1> final Source source, final String localCacheKey, final Map<String, Object> attributes) { <line2> final SAXTransformerFactory transformerFactory; <line3> if (attributes == null || attributes.isEmpty()) { <line4> transformerFactory = TRAX_FACTORY; <line5> } else { <line6> transformerFactory = createNewSAXTransformerFactory(); <line7> attributes.forEach(transformerFactory::setAttribute); <line8> } <line9> try { <line10> this.templates = transformerFactory.newTemplates(source); <line11> } catch (TransformerConfigurationException e) { <line12> throw new SetupException( <line13> ""Impossible to read XSLT from '"" + source + ""', see nested exception"", e); <line14> } <line15> } <line16> } <line17>  <LINE> <line7>"	No	task2	
<CODE> public class A { <line0> @Override <line1> protected void writeMultipleRecordsInternal() throws Exception { <line2> if (batchSize > 1) { <line3> BoundStatement boundStatement = pstmt.bind(); <line4> for (int rowIndex = 0; rowIndex < rows.size(); rowIndex++) { <line5> for (int columnIndex = 0; columnIndex < columnMeta.size(); columnIndex++) { <line6> Object value = rows.get(rowIndex).getField(columnIndex); <line7> CassandraUtil.bindColumn( <line8> boundStatement, columnIndex, columnTypes.get(columnIndex), value); <line9> } <line10> if ((rowIndex % 1000) == 0) { <line11> } <line12> if (asyncWrite) { <line13> unConfirmedWrite.add(session.executeAsync(boundStatement)); <line14> if (unConfirmedWrite.size() >= batchSize) { <line15> for (ResultSetFuture write : unConfirmedWrite) { <line16> write.getUninterruptibly(10000, TimeUnit.MILLISECONDS); <line17> } <line18> unConfirmedWrite.clear(); <line19> } <line20> } else { <line21> bufferedWrite.add(boundStatement); <line22> if (bufferedWrite.size() >= batchSize) { <line23> BatchStatement batchStatement = new BatchStatement(BatchStatement.Type.UNLOGGED); <line24> batchStatement.addAll(bufferedWrite); <line25> session.execute(batchStatement); <line26> bufferedWrite.clear(); <line27> } <line28> } <line29> } <line30> if (unConfirmedWrite != null && unConfirmedWrite.size() > 0) { <line31> for (ResultSetFuture write : unConfirmedWrite) { <line32> write.getUninterruptibly(10000, TimeUnit.MILLISECONDS); <line33> } <line34> unConfirmedWrite.clear(); <line35> } <line36> if (bufferedWrite != null && bufferedWrite.size() > 0) { <line37> BatchStatement batchStatement = new BatchStatement(BatchStatement.Type.UNLOGGED); <line38> batchStatement.addAll(bufferedWrite); <line39> session.execute(batchStatement); <line40> bufferedWrite.clear(); <line41> } <line42> } <line43> } <line44> } <line45>  <LINE> <line26>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void closeFailure(CommandContext commandContext) { <line2> if (commandContext.getEventDispatcher().isEnabled()) { <line3> commandContext <line4> .getEventDispatcher() <line5> .dispatchEvent( <line6> ActivitiEventBuilder.createEntityExceptionEvent( <line7> ActivitiEventType.JOB_EXECUTION_FAILURE, job, commandContext.getException())); <line8> } <line9> CommandConfig commandConfig = commandExecutor.getDefaultConfig().transactionRequiresNew(); <line10> FailedJobCommandFactory failedJobCommandFactory = commandContext.getFailedJobCommandFactory(); <line11> Command<Object> cmd = <line12> failedJobCommandFactory.getCommand(job.getId(), commandContext.getException()); <line13> commandExecutor.execute(commandConfig, cmd); <line14> } <line15> } <line16>  <LINE> <line10>	No	task2	
<CODE> public class A { <line0> @NotNull <line1> private LoadedStream loadEpisode( <line2> @NotNull EpisodeId id, <line3> @NotNull AudioQualityPicker audioQualityPicker, <line4> boolean preload, <line5> @Nullable HaltListener haltListener) <line6> throws IOException, MercuryClient.MercuryException, CdnManager.CdnException { <line7> Metadata.Episode episode = session.api().getMetadata4Episode(id); <line8> if (episode.hasExternalUrl()) { <line9> return CdnFeedHelper.loadEpisodeExternal(session, episode, haltListener); <line10> } else { <line11> Metadata.AudioFile file = audioQualityPicker.getFile(episode.getAudioList()); <line12> if (file == null) { <line13> throw new FeederException(); <line14> } <line15> return loadStream(file, null, episode, preload, haltListener); <line16> } <line17> } <line18> } <line19>  <LINE> <line15>	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void testConversionRuleSupportInPatternLayout() throws JoranException { <line2> configure(ClassicTestConstants.JORAN_INPUT_PREFIX + ""conversionRule/patternLayout0.xml""); <line3> root.getAppender(""LIST""); <line4> String msg = ""Simon says""; <line5> StringListAppender<ILoggingEvent> sla = <line6> (StringListAppender<ILoggingEvent>) root.getAppender(""LIST""); <line7> assertNotNull(sla); <line8> assertEquals(1, sla.strList.size()); <line9> assertEquals(SampleConverter.SAMPLE_STR + "" - "" + msg, sla.strList.get(0)); <line10> } <line11> } <line12>  <LINE> <line1>"	No	task2	
<CODE> public class A { <line0> public static void sendCommitInfoToOthers(RemoteCommit remoteCommit) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> ITopic<RemoteCommit> topic = getHazelcastInstance().getTopic(FF_COMMIT_TOPIC_NAME); <line4> topic.publish(remoteCommit); <line5> } <line6> } <line7>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> private void moveExistingContentInOutputPathToOldPath(Path oldPath) throws IOException { <line1> if (!fs.rename(outputPath, oldPath)) { <line2> fs.delete(tmpPath, true); <line3> throw new RuntimeException(""Error: cannot rename "" + outputPath + "" to "" + oldPath); <line4> } <line5> } <line6> } <line7>  <LINE> <line6>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void info(String arg0) { <line2> } <line3> } <line4>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) <line2> throws IOException { <line3> String toWrite = ""<REMOVED>""; <line4> if (value instanceof Optional) { <line5> Optional optional = (Optional) value; <line6> toWrite = optional.isPresent() ? ""<REMOVED>"" : ""<NOTSET>""; <line7> } <line8> gen.writeString(toWrite); <line9> } <line10> } <line11>  <LINE> <line10>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void contribute(Document document, DDMFormInstanceRecord ddmFormInstanceRecord) { <line2> try { <line3> DDMFormInstanceRecordVersion ddmFormInstanceRecordVersion = <line4> ddmFormInstanceRecord.getFormInstanceRecordVersion(); <line5> DDMFormInstance ddmFormInstance = ddmFormInstanceRecordVersion.getFormInstance(); <line6> document.addKeyword( <line7> Field.CLASS_NAME_ID, classNameLocalService.getClassNameId(DDMFormInstance.class)); <line8> document.addKeyword(Field.CLASS_PK, ddmFormInstance.getFormInstanceId()); <line9> document.addKeyword(Field.CLASS_TYPE_ID, ddmFormInstanceRecordVersion.getFormInstanceId()); <line10> document.addKeyword(Field.RELATED_ENTRY, true); <line11> document.addKeyword(Field.STATUS, ddmFormInstanceRecordVersion.getStatus()); <line12> document.addKeyword(Field.VERSION, ddmFormInstanceRecordVersion.getVersion()); <line13> document.addKeyword(""formInstanceId"", ddmFormInstance.getFormInstanceId()); <line14> DDMStructure ddmStructure = ddmFormInstance.getStructure(); <line15> DDMFormValues ddmFormValues = ddmFormInstanceRecordVersion.getDDMFormValues(); <line16> addContent(ddmFormInstanceRecordVersion, ddmFormValues, document); <line17> ddmIndexer.addAttributes(document, ddmStructure, ddmFormValues); <line18> } catch (Exception exception) { <line19> if (log.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> } <line24>  <LINE> <line20>"	Yes	task2	
"<CODE> public class A { <line0> @org.junit.Test <line1> public void testValidateRedeliveryFlagAfterRecovery() throws Exception { <line2> ConnectionFactory connectionFactory = <line3> new ActiveMQConnectionFactory( <line4> broker.getTransportConnectors().get(0).getPublishableConnectString() <line5> + ""?jms.prefetchPolicy.all=0""); <line6> connection = (ActiveMQConnection) connectionFactory.createConnection(); <line7> connection.start(); <line8> Session session = connection.createSession(true, Session.SESSION_TRANSACTED); <line9> Destination destination = session.createQueue(queueName); <line10> populateDestination(1, destination, connection); <line11> MessageConsumer consumer = session.createConsumer(destination); <line12> TextMessage msg = (TextMessage) consumer.receive(5000); <line13> assertNotNull(""got the message"", msg); <line14> assertEquals(""first delivery"", 1, msg.getLongProperty(""JMSXDeliveryCount"")); <line15> assertEquals(""not a redelivery"", false, msg.getJMSRedelivered()); <line16> stopBrokerWithStoreFailure(broker, persistenceAdapterChoice); <line17> broker = createRestartedBroker(); <line18> broker.start(); <line19> connection.close(); <line20> connectionFactory = <line21> new ActiveMQConnectionFactory( <line22> broker.getTransportConnectors().get(0).getPublishableConnectString()); <line23> connection = (ActiveMQConnection) connectionFactory.createConnection(); <line24> connection.start(); <line25> session = connection.createSession(true, Session.SESSION_TRANSACTED); <line26> consumer = session.createConsumer(destination); <line27> msg = (TextMessage) consumer.receive(10000); <line28> assertNotNull(""got the message again"", msg); <line29> assertEquals(""redelivery count survives restart"", 2, msg.getLongProperty(""JMSXDeliveryCount"")); <line30> assertEquals(""re delivery flag"", true, msg.getJMSRedelivered()); <line31> session.commit(); <line32> connection.close(); <line33> } <line34> } <line35>  <LINE> <line13>"	Yes	task2	
<CODE> public class A { <line0> public void close() { <line1> for (ZipFile openArchive : this.openArchives) { <line2> try { <line3> openArchive.close(); <line4> } catch (IOException ioe) { <line5> } <line6> } <line7> this.openArchives.clear(); <line8> } <line9> } <line10>  <LINE> <line5>	Yes	task2	
<CODE> public class A { <line0> public static ParsedField<LatLng> reproject(double lat, double lon, String datum) { <line1> Preconditions.checkArgument(lat >= -90d && lat <= 90d); <line2> Preconditions.checkArgument(lon >= -180d && lon <= 180d); <line3> Set<String> issues = new TreeSet<>(); <line4> if (Strings.isNullOrEmpty(datum)) { <line5> issues.add(GEODETIC_DATUM_ASSUMED_WGS84.name()); <line6> return ParsedField.success(new LatLng(lat, lon), issues); <line7> } <line8> try { <line9> CoordinateReferenceSystem crs = SpatialReferenceSystemParser.parseCRS(datum); <line10> if (crs == null) { <line11> issues.add(GEODETIC_DATUM_INVALID.name()); <line12> issues.add(GEODETIC_DATUM_ASSUMED_WGS84.name()); <line13> } else { <line14> MathTransform transform = CRS.findMathTransform(crs, DefaultGeographicCRS.WGS84, true); <line15> double[] srcPt; <line16> double[] dstPt = new double[3]; <line17> if (CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST) { <line18> srcPt = new double[] {lat, lon, 0}; <line19> } else { <line20> srcPt = new double[] {lon, lat, 0}; <line21> } <line22> transform.transform(srcPt, 0, dstPt, 0, 1); <line23> double lat2 = dstPt[1]; <line24> double lon2 = dstPt[0]; <line25> if (Math.abs(lat - lat2) > SUSPICIOUS_SHIFT || Math.abs(lon - lon2) > SUSPICIOUS_SHIFT) { <line26> issues.add(COORDINATE_REPROJECTION_SUSPICIOUS.name()); <line27> return ParsedField.fail(new LatLng(lat, lon), issues); <line28> } <line29> if (lat != lat2 || lon != lon2) { <line30> issues.add(COORDINATE_REPROJECTED.name()); <line31> } <line32> return ParsedField.success(new LatLng(lat2, lon2), issues); <line33> } <line34> } catch (Exception ex) { <line35> issues.add(COORDINATE_REPROJECTION_FAILED.name()); <line36> } <line37> return ParsedField.fail(new LatLng(lat, lon), issues); <line38> } <line39> } <line40>  <LINE> <line23>	No	task2	
"<CODE> public class A { <line0> protected void logLife(Game game) { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(game.getTurn().getValue(game.getTurnNum())); <line3> for (Player player : game.getPlayers().values()) { <line4> sb.append(""[player "") <line5> .append(player.getName()) <line6> .append(':') <line7> .append(player.getLife()) <line8> .append(']'); <line9> } <line10> } <line11> } <line12>  <LINE> <line10>"	Yes	task2	
<CODE> public class A { <line0> @Bean <line1> public MarshallingPayloadMethodProcessor <line2> microgridsAdHocManagementMarshallingPayloadMethodProcessor() { <line3> return new MarshallingPayloadMethodProcessor( <line4> this.microgridsAdHocManagementMarshaller(), this.microgridsAdHocManagementMarshaller()); <line5> } <line6> } <line7>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void write(byte[] buf, int off, int len) throws IOException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> byte[] wrapped = cryptoAES.wrap(buf, off, len); <line5> DataOutputStream dob = new DataOutputStream(out); <line6> dob.writeInt(wrapped.length); <line7> dob.write(wrapped, 0, wrapped.length); <line8> dob.flush(); <line9> } <line10> } <line11>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> protected static void writeWarn(String msg) { <line1> if (LOG.isWarnEnabled()) { <line2> } <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> private void load() { <line1> if (buffer.length() == 0) { <line2> String path = Packages.absolutePath(scope, fileName); <line3> Application app = Application.get(); <line4> IResourceStream stream = <line5> app.getResourceSettings() <line6> .getResourceStreamLocator() <line7> .locate(scope, path, getStyle(), getVariation(), getLocale(), null, false); <line8> if (stream == null) { <line9> stream = <line10> new ResourceStreamLocator() <line11> .locate(scope, path, getStyle(), getVariation(), getLocale(), null, false); <line12> } <line13> if (stream == null) { <line14> throw new IllegalArgumentException( <line15> ""resource "" + fileName + "" not found for scope "" + scope + "" (path = "" + path + "")""); <line16> } <line17> setLastModified(stream.lastModifiedTime()); <line18> try { <line19> if (encoding != null) { <line20> buffer.append(Streams.readString(stream.getInputStream(), encoding)); <line21> } else { <line22> buffer.append(Streams.readString(stream.getInputStream())); <line23> } <line24> } catch (IOException e) { <line25> throw new RuntimeException(e); <line26> } catch (ResourceStreamNotFoundException e) { <line27> throw new RuntimeException(e); <line28> } finally { <line29> try { <line30> stream.close(); <line31> } catch (IOException e) { <line32> } <line33> } <line34> } <line35> } <line36> } <line37>  <LINE> <line32>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void processLine(String line) { <line2> String[] tokens = line.split(""\\t""); <line3> String id = tokens[0]; <line4> String active = tokens[2]; <line5> String conceptId = tokens[4]; <line6> String typeId = tokens[6]; <line7> String term = tokens[7]; <line8> Vertex v = vertexMap.get(conceptId); <line9> if (""1"".equals(active) && v != null) { <line10> if (preferred.contains(id) && !FULLY_SPECIFIED_NAME.equals(typeId)) { <line11> g.V(v).property(""display"", term).next(); <line12> } <line13> Vertex w = <line14> g.addV(""Designation"") <line15> .property(""language"", ""en"") <line16> .property(""use"", typeId) <line17> .property(""value"", term) <line18> .next(); <line19> g.V(v).addE(""designation"").to(w).next(); <line20> } <line21> if ((counter.get() % 10000) == 0) { <line22> g.tx().commit(); <line23> } <line24> counter.getAndIncrement(); <line25> } <line26> } <line27>  <LINE> <line12>"	No	task2	
"<CODE> public class A { <line0> public void deploy(final BeanContext beanContext) throws OpenEJBException { <line1> final Data data = new Data(beanContext); <line2> beanContext.setContainerData(data); <line3> beanContext.set(EJBContext.class, this.sessionContext); <line4> if (StatsInterceptor.isStatsActivated()) { <line5> final StatsInterceptor stats = new StatsInterceptor(beanContext.getBeanClass()); <line6> beanContext.addFirstSystemInterceptor(stats); <line7> final ObjectNameBuilder jmxName = new ObjectNameBuilder(""openejb.management""); <line8> jmxName.set(""J2EEServer"", ""openejb""); <line9> jmxName.set(""J2EEApplication"", null); <line10> jmxName.set(""EJBModule"", beanContext.getModuleID()); <line11> jmxName.set(""SingletonSessionBean"", beanContext.getEjbName()); <line12> jmxName.set(""name"", beanContext.getEjbName()); <line13> jmxName.set(""j2eeType"", ""Invocations""); <line14> final MBeanServer server = LocalMBeanServer.get(); <line15> try { <line16> final ObjectName objectName = jmxName.build(); <line17> if (server.isRegistered(objectName)) { <line18> server.unregisterMBean(objectName); <line19> } <line20> server.registerMBean(new ManagedMBean(stats), objectName); <line21> data.add(objectName); <line22> } catch (final Exception e) { <line23> } <line24> } <line25> try { <line26> final Context context = beanContext.getJndiEnc(); <line27> context.bind(""comp/EJBContext"", sessionContext); <line28> context.bind(""comp/WebServiceContext"", webServiceContext); <line29> context.bind(""comp/TimerService"", new TimerServiceWrapper()); <line30> } catch (final NamingException e) { <line31> throw new OpenEJBException(""Failed to bind EJBContext/WebServiceContext/TimerService"", e); <line32> } <line33> } <line34> } <line35>  <LINE> <line10>"	No	task2	
<CODE> public class A { <line0> public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) { <line1> Password pass = (Password) value; <line2> try { <line3> if (pass.password != null) { <line4> writer.setValue(encrypter.encrypt(pass.password)); <line5> } <line6> } catch (EncryptionException e) { <line7> } <line8> } <line9> } <line10>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> private List<Map<String, Object>> documentListToResultList(SolrDocumentList docs) { <line1> final List<Map<String, Object>> results = new ArrayList<>(); <line2> for (SolrDocument doc : docs) { <line3> final PersistentItem result = new PersistentItem(); <line4> final Collection<String> fieldNames = doc.getFieldNames(); <line5> for (String name : fieldNames) { <line6> Collection<Object> fieldValues = doc.getFieldValues(name); <line7> if (name.endsWith(PersistentItem.TEXT_SUFFIX) && fieldValues.size() > 1) { <line8> result.addProperty( <line9> name, <line10> fieldValues.stream() <line11> .filter(String.class::isInstance) <line12> .map(String.class::cast) <line13> .collect(Collectors.toSet())); <line14> } else { <line15> addPropertyBasedOnSuffix(result, name, doc.getFirstValue(name)); <line16> } <line17> } <line18> results.add(result); <line19> } <line20> return results; <line21> } <line22> } <line23>  <LINE> <line6>	Yes	task2	
<CODE> public class A { <line0> private void undeploy(ClassLoader ldr) { <line1> Collection<GridDeployment> doomed = new HashSet<>(); <line2> synchronized (mux) { <line3> for (Iterator<Deque<GridDeployment>> i1 = cache.values().iterator(); i1.hasNext(); ) { <line4> Deque<GridDeployment> deps = i1.next(); <line5> for (Iterator<GridDeployment> i2 = deps.iterator(); i2.hasNext(); ) { <line6> GridDeployment dep = i2.next(); <line7> if (dep.classLoader() == ldr) { <line8> dep.undeploy(); <line9> i2.remove(); <line10> doomed.add(dep); <line11> } <line12> } <line13> if (deps.isEmpty()) i1.remove(); <line14> } <line15> } <line16> for (GridDeployment dep : doomed) { <line17> if (dep.obsolete()) { <line18> ctx.resource().onUndeployed(dep); <line19> if (ctx.config().getMarshaller() instanceof AbstractMarshaller) <line20> ((AbstractMarshaller) ctx.config().getMarshaller()).onUndeploy(ldr); <line21> clearSerializationCaches(); <line22> GridAnnotationsCache.onUndeployed(ldr); <line23> GridClassLoaderCache.onUndeployed(ldr); <line24> } <line25> recordUndeploy(dep); <line26> } <line27> } <line28> } <line29>  <LINE> <line10>	No	task2	
<CODE> public class A { <line0> @Test <line1> public void testSerializeData() throws Exception { <line2> Writer serializeData = <line3> bindingSerializer.serializeData(this.effectiveModelContext, testedToasterNormalizedNodes); <line4> Assert.assertFalse(Strings.isNullOrEmpty(serializeData.toString())); <line5> } <line6> } <line7>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> public void testFillWalAndReadRecords() throws Exception { <line2> setWalAndArchiveToSameVal = false; <line3> Ignite ignite0 = startGrid(); <line4> ignite0.cluster().active(true); <line5> Serializable consistentId = (Serializable) ignite0.cluster().localNode().consistentId(); <line6> String subfolderName = genNewStyleSubfolderName(0, (UUID) consistentId); <line7> int cacheObjectsToWrite = 10_000; <line8> putDummyRecords(ignite0, cacheObjectsToWrite); <line9> stopGrid(); <line10> String workDir = U.defaultWorkDirectory(); <line11> File db = U.resolveWorkDirectory(workDir, DFLT_STORE_DIR, false); <line12> IgniteWalIteratorFactory factory = new IgniteWalIteratorFactory(log); <line13> IteratorParametersBuilder params = <line14> createIteratorParametersBuilder(workDir, subfolderName).filesOrDirs(db); <line15> int cntArchiveDir = iterateAndCount(factory.iterator(params)); <line16> assertTrue(cntArchiveDir > 0); <line17> int[] checkKeyIterArr = new int[cacheObjectsToWrite]; <line18> fill(checkKeyIterArr, 0); <line19> iterateAndCountDataRecord( <line20> factory.iterator(params), (o1, o2) -> checkKeyIterArr[(Integer) o1]++, null); <line21> for (int i = 0; i < cacheObjectsToWrite; i++) <line22> assertTrue(""Iterator didn't find key="" + i, checkKeyIterArr[i] > 0); <line23> } <line24> } <line25>  <LINE> <line12>"	No	task2	
"<CODE> public class A { <line0> public List<DrugSearchTo1> fullSearch(String s) { <line1> RxDrugRef dr = new RxDrugRef(); <line2> List<DrugSearchTo1> drugs = new ArrayList<DrugSearchTo1>(); <line3> try { <line4> Vector<Hashtable> v = (Vector<Hashtable>) dr.list_drug_element(s); <line5> DrugSearchTo1 temp; <line6> for (Hashtable h : v) { <line7> temp = new DrugSearchTo1(); <line8> temp.setName((String) h.get(""name"")); <line9> if (h.containsKey(""isInactive"")) { <line10> temp.setActive(!((Boolean) h.get(""isInactive""))); <line11> } <line12> temp.setId((Integer) h.get(""id"")); <line13> temp.setCategory((Integer) h.get(""category"")); <line14> drugs.add(temp); <line15> } <line16> } catch (Exception e) { <line17> return null; <line18> } <line19> return drugs; <line20> } <line21> } <line22>  <LINE> <line17>"	Yes	task2	
<CODE> public class A { <line0> public void completed(final HttpResponse response) { <line1> int statusCode = response.getStatusLine().getStatusCode(); <line2> if (statusCode >= 200 && statusCode < 300) { <line3> callback.onSuccess(); <line4> } else { <line5> callback.onFailure(statusCode); <line6> } <line7> } <line8> } <line9>  <LINE> <line7>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public String getAmilAvailDate(int year, int quarter) { <line2> try { <line3> String query = <line4> ""select Date(createdDate) from cf_SystemConfiguration where keyname ="" <line5> + "" 'pacman.kernel.compliance.map."" <line6> + year <line7> + "".q"" <line8> + quarter <line9> + ""'""; <line10> return rdsrepository.queryForString(query); <line11> } catch (Exception e) { <line12> return null; <line13> } <line14> } <line15> } <line16>  <LINE> <line12>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void close() { <line2> handler.close(); <line3> try { <line4> classLoader.close(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> public static URL getAuthorizationURL(final String authorizationURL) { <line1> if (authorizationURL != null) { <line2> try { <line3> return new URL(authorizationURL.toString()); <line4> } catch (final MalformedURLException e) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> private Map<String, DimensionEncoding> getDimensionEncodings( <line1> FragmentMetaInfo fragmentMetaInfo, List<DimensionMetaInfo> allDimensions, Path dataPath) <line2> throws IOException { <line3> Map<String, Dictionary> dictionaryMap; <line4> try (FSDataInputStream dictInputStream = fs.open(dataPath)) { <line5> dictionaryMap = readAllDimensionsDictionary(fragmentMetaInfo, dictInputStream); <line6> } <line7> Map<String, DimensionEncoding> result = Maps.newHashMap(); <line8> for (DimensionMetaInfo dimension : allDimensions) { <line9> TblColRef col = cubeDesc.getModel().findColumn(dimension.getName()); <line10> RowKeyColDesc colDesc = cubeDesc.getRowkey().getColDesc(col); <line11> if (colDesc.isUsingDictionary()) { <line12> @SuppressWarnings({""unchecked""}) <line13> Dictionary<String> dict = dictionaryMap.get(dimension.getName()); <line14> if (dict == null) { <line15> throw new IllegalStateException(""No dictionary found for dict-encoding column "" + col); <line16> } else { <line17> result.put(dimension.getName(), new DictionaryDimEnc(dict)); <line18> } <line19> } else { <line20> result.put( <line21> dimension.getName(), <line22> DimensionEncodingFactory.create( <line23> colDesc.getEncodingName(), <line24> colDesc.getEncodingArgs(), <line25> colDesc.getEncodingVersion())); <line26> } <line27> } <line28> return result; <line29> } <line30> } <line31>  <LINE> <line15>"	Yes	task2	
"<CODE> public class A { <line0> void importRooms(File base) throws Exception { <line1> Class<Room> eClazz = Room.class; <line2> JAXBContext jc = JAXBContext.newInstance(eClazz); <line3> Unmarshaller unmarshaller = jc.createUnmarshaller(); <line4> unmarshaller.setAdapter(new UserAdapter(userDao, userMap)); <line5> readList( <line6> unmarshaller, <line7> base, <line8> ""rooms.xml"", <line9> ROOM_LIST_NODE, <line10> ROOM_NODE, <line11> eClazz, <line12> r -> { <line13> Long roomId = r.getId(); <line14> if (r.getOwnerId() != null) { <line15> Long newOwnerId = userMap.get(r.getOwnerId()); <line16> if (newOwnerId == null) { <line17> return; <line18> } <line19> r.setOwnerId(newOwnerId); <line20> } <line21> r.setId(null); <line22> if (r.getModerators() != null) { <line23> for (Iterator<RoomModerator> i = r.getModerators().iterator(); i.hasNext(); ) { <line24> RoomModerator rm = i.next(); <line25> if (rm.getUser().getId() == null) { <line26> i.remove(); <line27> } <line28> } <line29> } <line30> r = roomDao.update(r, null); <line31> roomMap.put(roomId, r.getId()); <line32> }); <line33> } <line34> } <line35>  <LINE> <line1>"	Yes	task2	
"<CODE> public class A { <line0> private void debug( <line1> CSpaceResource res, <line2> Authentication authToken, <line3> Serializable objectIdId, <line4> String objectIdType, <line5> Permission perm) { <line6> if (log.isTraceEnabled() == true) { <line7> String resourceTarget = <line8> ""["" <line9> + res.getId() <line10> + ""]"" <line11> + "" | "" <line12> + ""["" <line13> + ""objectIdId: "" <line14> + objectIdType <line15> + ""("" <line16> + objectIdId <line17> + "")]""; <line18> System.out.println(""PERMISSION CHECK FOR: "" + resourceTarget); <line19> System.out.println( <line20> ""\tPrincipal: "" + authToken.getName() + ""\tTenant ID: "" + res.getTenantId()); <line21> System.out.println(""\tRoles: "" + authToken.getAuthorities()); <line22> System.out.println( <line23> ""\tPermission Mask: "" + perm.getMask() + "" - Permission Pattern: "" + perm.getPattern()); <line24> System.out.println(""""); <line25> } <line26> } <line27> } <line28>  <LINE> <line7>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public boolean isCommentable() { <line2> try { <line3> Calendar calendar = _calendarBooking.getCalendar(); <line4> return calendar.isEnableComments(); <line5> } catch (Exception exception) { <line6> } <line7> return false; <line8> } <line9> } <line10>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> protected static void doMultiUserGets( <line1> final int num, final int numOfUsers, final int[] expectedResults) { <line2> if (numOfUsers != expectedResults.length) { <line3> fail( <line4> ""SecurityTestUtils.doMultiUserGets(): numOfUsers = "" <line5> + numOfUsers <line6> + "", but expected results "" <line7> + expectedResults.length); <line8> } <line9> for (int i = 0; i < numOfUsers; i++) { <line10> doGetsP(num, i, expectedResults[i], false); <line11> } <line12> } <line13> } <line14>  <LINE> <line10>"	Yes	task2	
"<CODE> public class A { <line0> @RequestMapping(value = ""/skipTask.action"", method = RequestMethod.GET) <line1> @ResponseBody <line2> public Map<String, Object> skipTask(@RequestParam Integer id) throws Exception { <line3> try { <line4> String userName = getAuthenticatedUserName(); <line5> String sVar = taggerService.skipTask(id, userName); <line6> return getUIWrapper(sVar, true); <line7> } catch (AidrException e) { <line8> return getUIWrapper(e.getMessage(), false); <line9> } <line10> } <line11> } <line12>  <LINE> <line3>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public JAXBContext getJAXBContext() throws KapuaException { <line2> if (context == null) { <line3> Map<String, Object> properties = new HashMap<>(1); <line4> properties.put(MarshallerProperties.JSON_WRAPPER_AS_ARRAY_NAME, true); <line5> Class<?>[] classes = <line6> new Class<?>[] { <line7> KapuaTmetadata.class, <line8> KapuaTocd.class, <line9> KapuaTad.class, <line10> KapuaTicon.class, <line11> TscalarImpl.class, <line12> KapuaToption.class, <line13> KapuaTdesignate.class, <line14> KapuaTobject.class, <line15> MetatypeXmlRegistry.class, <line16> EndPointContainer.class, <line17> SimpleEndPoint.class, <line18> ParentEndPoint.class, <line19> EndChainEndPoint.class, <line20> ServiceEvent.class, <line21> EventStoreRecordCreator.class, <line22> EventStoreRecordListResult.class, <line23> EventStoreRecordQuery.class, <line24> EventStoreXmlRegistry.class, <line25> JobStartOptions.class, <line26> ThrowableInfo.class, <line27> ExceptionInfo.class, <line28> CleanJobDataExceptionInfo.class, <line29> JobAlreadyRunningExceptionInfo.class, <line30> JobEngineExceptionInfo.class, <line31> JobExecutionEnqueuedExceptionInfo.class, <line32> JobInvalidTargetExceptionInfo.class, <line33> JobMissingStepExceptionInfo.class, <line34> JobMissingTargetExceptionInfo.class, <line35> JobNotRunningExceptionInfo.class, <line36> JobResumingExceptionInfo.class, <line37> JobRunningExceptionInfo.class, <line38> JobStartingExceptionInfo.class, <line39> JobStoppingExceptionInfo.class <line40> }; <line41> try { <line42> context = JAXBContextFactory.createContext(classes, properties); <line43> } catch (JAXBException jaxbException) { <line44> throw KapuaException.internalError(jaxbException, ""Error creating JAXBContext!""); <line45> } <line46> } <line47> return context; <line48> } <line49> } <line50>  <LINE> <line29>"	No	task2	
<CODE> public class A { <line0> private void cancelRefreshJob() { <line1> synchronized (this) { <line2> if (refreshJob != null) { <line3> refreshJob.cancel(true); <line4> refreshJob = null; <line5> } <line6> } <line7> } <line8> } <line9>  <LINE> <line3>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public List<RestDefinition> getRestDefinitions(CamelContext camelContext, String camelId) <line2> throws Exception { <line3> ObjectName found = null; <line4> MBeanServer server = ManagementFactory.getPlatformMBeanServer(); <line5> Set<ObjectName> names = <line6> server.queryNames(new ObjectName(""org.apache.camel:type=context,*""), null); <line7> for (ObjectName on : names) { <line8> String id = on.getKeyProperty(""name""); <line9> if (id.startsWith(""\"""") && id.endsWith(""\"""")) { <line10> id = id.substring(1, id.length() - 1); <line11> } <line12> if (camelId == null || camelId.equals(id)) { <line13> found = on; <line14> } <line15> } <line16> if (found != null) { <line17> String xml = <line18> (String) <line19> server.invoke(found, ""dumpRestsAsXml"", new Object[] {true}, new String[] {""boolean""}); <line20> if (xml != null) { <line21> InputStream xmlis = camelContext.getTypeConverter().convertTo(InputStream.class, xml); <line22> ExtendedCamelContext ecc = camelContext.adapt(ExtendedCamelContext.class); <line23> RestsDefinition rests = <line24> (RestsDefinition) <line25> ecc.getXMLRoutesDefinitionLoader().loadRestsDefinition(camelContext, xmlis); <line26> if (rests != null) { <line27> return rests.getRests(); <line28> } <line29> } <line30> } <line31> return null; <line32> } <line33> } <line34>  <LINE> <line18>"	No	task2	
"<CODE> public class A { <line0> protected void logError( <line1> long lineNumber, String message, String localizedMessage, String... params) { <line2> importLogs.add( <line3> new CSVImportLog( <line4> lineNumber, <line5> ERROR, <line6> String.format(message, (Object[]) params), <line7> localizedMessage, <line8> params)); <line9> String lineMessage = String.format(""Line %d"", lineNumber); <line10> String errorMessage = String.format(message, (Object[]) params); <line11> getStore() <line12> .putParameter( <line13> id, <line14> ""status"", <line15> new CSVImportStatus(CSVImportStatus.State.ERROR, docsCreatedCount, docsCreatedCount)); <line16> } <line17> } <line18>  <LINE> <line11>"	Yes	task2	
<CODE> public class A { <line0> private byte[] pack(InputStream stream) { <line1> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line2> try { <line3> StreamUtils.copyStream(stream, out, true); <line4> } catch (IOException e) { <line5> } <line6> return out.toByteArray(); <line7> } <line8> } <line9>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> public void onProcessUnstructuredSSRequest(ProcessUnstructuredSSRequest procUnstrReqInd) { <line1> TestEvent te = <line2> TestEvent.createReceivedEvent( <line3> EventType.ProcessUnstructuredSSRequestIndication, procUnstrReqInd, sequence++); <line4> this.observerdEvents.add(te); <line5> } <line6> } <line7>  <LINE> <line1>	Yes	task2	
"<CODE> public class A { <line0> protected void logStatusMessage(int status) { <line1> switch (status) { <line2> case EXIT_OK: <line3> break; <line4> case EXIT_BAD_ARGS: <line5> logger.severe(""SCHEMA CHANGE: BAD ARGS""); <line6> break; <line7> case EXIT_RUNTIME_ERROR: <line8> logger.severe(""SCHEMA CHANGE: RUNTIME ERROR""); <line9> break; <line10> case EXIT_VALIDATION_FAILED: <line11> logger.warning(""SCHEMA CHANGE: FAILED""); <line12> break; <line13> default: <line14> logger.severe(""SCHEMA CHANGE: RUNTIME ERROR""); <line15> break; <line16> } <line17> } <line18> } <line19>  <LINE> <line2>"	No	task2	
<CODE> public class A { <line0> @Test <line1> public void alertDetailsThreadIdMatchesLoggingThreadId() { <line2> long threadId = <line3> memberVM.invoke( <line4> () -> { <line5> return Thread.currentThread().getId(); <line6> }); <line7> managerVM.invoke( <line8> () -> { <line9> assertThat(captureAlertDetails().getTid()).isEqualTo(threadId); <line10> }); <line11> } <line12> } <line13>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> public void onPageDrop(DragDropEvent event) { <line1> int toStripeIndex = getDropStripeIndex(event); <line2> if (toStripeIndex == -1 || !dragStripeIndexMatches(event)) { <line3> return; <line4> } <line5> GalleryStripe toStripe = stripes.get(toStripeIndex); <line6> List<Pair<View, IncludedStructuralElement>> viewsToBeMoved = new ArrayList<>(); <line7> for (Pair<MediaUnit, IncludedStructuralElement> selectedElement : <line8> dataEditor.getSelectedMedia()) { <line9> for (View view : selectedElement.getValue().getViews()) { <line10> if (Objects.equals(view.getMediaUnit(), selectedElement.getKey())) { <line11> viewsToBeMoved.add(new ImmutablePair<>(view, selectedElement.getValue())); <line12> } <line13> } <line14> } <line15> int toMediaIndex = getMediaIndex(event); <line16> try { <line17> updateData(toStripe, viewsToBeMoved, toMediaIndex); <line18> } catch (Exception e) { <line19> PrimeFaces.current().executeScript(""$('#loadingScreen').hide();""); <line20> PrimeFaces.current().executeScript(""PF('corruptDataWarning').show();""); <line21> } <line22> dataEditor.getStructurePanel().show(); <line23> dataEditor.getPaginationPanel().show(); <line24> updateAffectedStripes(toStripe, viewsToBeMoved); <line25> } <line26> } <line27>  <LINE> <line3>"	Yes	task2	
"<CODE> public class A { <line0> @Nullable <line1> public String postRequest(String ipAddress, String contentString) { <line2> String url = ""http://"" + ipAddress + ""/api.cgi""; <line3> try { <line4> Request request = httpClient.POST(url); <line5> request.header(HttpHeader.CONTENT_TYPE, ""application/json""); <line6> request.content(new StringContentProvider(contentString), ""application/json""); <line7> ContentResponse contentResponse = request.timeout(5, TimeUnit.SECONDS).send(); <line8> String response = <line9> contentResponse.getContentAsString().replace(""\t"", """").replace(""\r\n"", """").trim(); <line10> if (response != null && !response.isEmpty()) { <line11> return response; <line12> } else { <line13> return null; <line14> } <line15> } catch (TimeoutException | InterruptedException | ExecutionException e) { <line16> } <line17> return null; <line18> } <line19> } <line20>  <LINE> <line12>"	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void testGetServiceByDcIgnoreCase() throws Exception { <line2> when(consoleConfig.getConsoleDomains()) <line3> .thenReturn( <line4> new HashMap<String, String>() { <line5> { <line6> put(""jq"", ""http://127.0.0.1:8080""); <line7> put(""OY"", ""http://127.0.0.1:8081""); <line8> } <line9> }); <line10> ConsoleServiceManager manager = new ConsoleServiceManager(consoleConfig); <line11> Method method = ConsoleServiceManager.class.getDeclaredMethod(""getServiceByDc"", String.class); <line12> method.setAccessible(true); <line13> ConsoleService consoleService = (ConsoleService) method.invoke(manager, ""jq""); <line14> Assert.assertNotNull(consoleService); <line15> consoleService = (ConsoleService) method.invoke(manager, ""oy""); <line16> Assert.assertNotNull(consoleService); <line17> try { <line18> method.invoke(manager, ""rb""); <line19> Assert.fail(); <line20> } catch (Exception e) { <line21> } <line22> } <line23> } <line24>  <LINE> <line5>"	No	task2	
<CODE> public class A { <line0> void startPeonsForNewServers(List<ImmutableDruidServer> currentServers) { <line1> for (ImmutableDruidServer server : currentServers) { <line2> loadManagementPeons.computeIfAbsent( <line3> server.getName(), <line4> serverName -> { <line5> LoadQueuePeon loadQueuePeon = taskMaster.giveMePeon(server); <line6> loadQueuePeon.start(); <line7> return loadQueuePeon; <line8> }); <line9> } <line10> } <line11> } <line12>  <LINE> <line7>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void addConnectionStatusListener(ConnectionStatusListener listener) { <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> public static TestServer createAndStartServer(Class<?>... configClasses) { <line1> int port = NEXT_PORT.incrementAndGet(); <line2> Server server = new Server(port); <line3> AnnotationConfigWebApplicationContext applicationContext = <line4> new AnnotationConfigWebApplicationContext(); <line5> applicationContext.register(configClasses); <line6> applicationContext.refresh(); <line7> try { <line8> server.setHandler(getServletContextHandler(applicationContext)); <line9> server.start(); <line10> } catch (Exception e) { <line11> } <line12> return new TestServer(server, applicationContext, port); <line13> } <line14> } <line15>  <LINE> <line11>	Yes	task2	
<CODE> public class A { <line0> private long[] _updateDDMStructure( <line1> long userId, <line2> String fileEntryTypeUuid, <line3> long fileEntryTypeId, <line4> long groupId, <line5> Map<Locale, String> nameMap, <line6> Map<Locale, String> descriptionMap, <line7> long[] ddmStructureIds, <line8> ServiceContext serviceContext) <line9> throws PortalException { <line10> DDMStructure ddmStructure = null; <line11> try { <line12> fixDDMStructureKey(fileEntryTypeUuid, fileEntryTypeId, groupId); <line13> String ddmStructureKey = DLUtil.getDDMStructureKey(fileEntryTypeUuid); <line14> ddmStructure = <line15> DDMStructureManagerUtil.fetchStructure( <line16> groupId, <line17> classNameLocalService.getClassNameId(DLFileEntryMetadata.class), <line18> ddmStructureKey); <line19> DDMForm ddmForm = _getDDMForm(ddmStructure, serviceContext); <line20> if (_isEmptyDDMForm(ddmForm)) { <line21> if (ddmStructure != null) { <line22> _deleteDDMStructure(fileEntryTypeId, ddmStructure.getStructureId()); <line23> return ArrayUtil.remove(ddmStructureIds, ddmStructure.getStructureId()); <line24> } <line25> return ddmStructureIds; <line26> } <line27> if (ddmStructure == null) { <line28> ddmStructure = <line29> DDMStructureManagerUtil.addStructure( <line30> userId, <line31> groupId, <line32> null, <line33> classNameLocalService.getClassNameId(DLFileEntryMetadata.class), <line34> ddmStructureKey, <line35> nameMap, <line36> descriptionMap, <line37> ddmForm, <line38> StorageEngineManager.STORAGE_TYPE_DEFAULT, <line39> DDMStructureManager.STRUCTURE_TYPE_AUTO, <line40> serviceContext); <line41> } else { <line42> ddmStructure = <line43> DDMStructureManagerUtil.updateStructure( <line44> userId, <line45> ddmStructure.getStructureId(), <line46> ddmStructure.getParentStructureId(), <line47> nameMap, <line48> descriptionMap, <line49> ddmForm, <line50> serviceContext); <line51> } <line52> return ArrayUtil.append(ddmStructureIds, ddmStructure.getStructureId()); <line53> } catch (StructureDefinitionException structureDefinitionException) { <line54> if (log.isWarnEnabled()) { <line55> } <line56> if (ddmStructure != null) { <line57> long ddmStructureId = ddmStructure.getStructureId(); <line58> _deleteDDMStructure(fileEntryTypeId, ddmStructureId); <line59> return ArrayUtil.remove(ddmStructureIds, ddmStructureId); <line60> } <line61> return ddmStructureIds; <line62> } <line63> } <line64> } <line65>  <LINE> <line18>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void onError(final RaftException e) { <line2> } <line3> } <line4>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> private URI buildUri(final UUID interactionId) { <line1> final UriBuilder uriBuilder = <line2> UriBuilder.fromUri( <line3> interactionId != null <line4> ? String.format( <line5> ""%s%s?interactionId=%s&batchSize=%d"", <line6> secondaryConfig.getPrimaryBaseUrlRestful(), <line7> URL_SUFFIX, <line8> interactionId, <line9> secondaryConfig.getBatchSize()) <line10> : String.format( <line11> ""%s%s?batchSize=%d"", <line12> secondaryConfig.getPrimaryBaseUrlRestful(), <line13> URL_SUFFIX, <line14> secondaryConfig.getBatchSize())); <line15> final URI uri = uriBuilder.build(); <line16> return uri; <line17> } <line18> } <line19>  <LINE> <line8>"	No	task2	
<CODE> public class A { <line0> public void handleException(Exception e, Logger log, String name) { <line1> } <line2> } <line3>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> @Then(""^I wait (\\d+) seconds$"") <line1> public void iWaitXSeconds(final Integer seconds) { <line2> try { <line3> Thread.sleep(seconds * 1000); <line4> } catch (final InterruptedException e) { <line5> Thread.currentThread().interrupt(); <line6> } <line7> } <line8> } <line9>  <LINE> <line5>"	Yes	task2	
"<CODE> public class A { <line0> private static void initSpark() { <line1> staticFiles.location(""/static""); <line2> } <line3> } <line4>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> protected boolean retryCausedOnServerlessDB(Exception e) { <line1> if (e instanceof SQLException <line2> && ((SQLException) e).getSQLState() != null <line3> && (((SQLException) e).getSQLState().equalsIgnoreCase(""57014"") <line4> || ((SQLException) e).getSQLState().equalsIgnoreCase(""57P01"") <line5> || ((SQLException) e).getSQLState().equalsIgnoreCase(""08003"") <line6> || ((SQLException) e).getSQLState().equalsIgnoreCase(""08006""))) { <line7> int remainingSeconds = context.getRemainingTimeInMillis() / 1000; <line8> if (!isRemainingTimeSufficient(remainingSeconds)) { <line9> return false; <line10> } <line11> if (!retryAttempted) { <line12> return true; <line13> } <line14> } <line15> return false; <line16> } <line17> } <line18>  <LINE> <line4>"	No	task2	
<CODE> public class A { <line0> public boolean synchronizeCatalogStudyFromStorage(StudyMetadata study, String sessionId) <line1> throws CatalogException { <line2> boolean modified = synchronizeFiles(study, null, sessionId); <line3> modified |= synchronizeCohorts(study, sessionId); <line4> return modified; <line5> } <line6> } <line7>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void pushTaskLog(final String taskid, final File logFile) throws IOException { <line2> final String taskKey = getTaskLogKey(taskid); <line3> pushTaskFile(logFile, taskKey); <line4> } <line5> } <line6>  <LINE> <line5>	No	task2	
"<CODE> public class A { <line0> protected void insertGuiFragment(GuiFragment guiFragment, Connection conn) { <line1> PreparedStatement stat = null; <line2> try { <line3> stat = conn.prepareStatement(ADD_GUIFRAGMENT); <line4> int index = 1; <line5> stat.setString(index++, guiFragment.getCode()); <line6> if (StringUtils.isNotBlank(guiFragment.getWidgetTypeCode())) { <line7> stat.setString(index++, guiFragment.getWidgetTypeCode()); <line8> } else { <line9> stat.setNull(index++, Types.VARCHAR); <line10> } <line11> if (StringUtils.isNotBlank(guiFragment.getPluginCode())) { <line12> stat.setString(index++, guiFragment.getPluginCode()); <line13> } else { <line14> stat.setNull(index++, Types.VARCHAR); <line15> } <line16> stat.setString(index++, guiFragment.getGui()); <line17> stat.setInt(index++, 0); <line18> stat.executeUpdate(); <line19> } catch (Throwable t) { <line20> throw new RuntimeException(""Error on insert guiFragment"", t); <line21> } finally { <line22> this.closeDaoResources(null, stat); <line23> } <line24> } <line25> } <line26>  <LINE> <line1>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void appendJsonLog(ActionData actionData) { <line2> if (isJsonLogActive()) { <line3> String dir = ""gamelogsJson""; <line4> File saveDir = new File(dir); <line5> if (!saveDir.exists()) { <line6> saveDir.mkdirs(); <line7> } <line8> actionData.sessionId = getSessionId(); <line9> String logFileName = dir + File.separator + ""game-"" + actionData.gameId + "".json""; <line10> try (PrintWriter out = <line11> new PrintWriter(new BufferedWriter(new FileWriter(logFileName, true)))) { <line12> out.println(actionData.toJson()); <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> } <line18>  <LINE> <line14>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public List<ContextKeyValue> getValues(ContextID contextID, String keyword, ContextType csType) { <line2> if (null == contextID || StringUtils.isBlank(keyword)) { <line3> return null; <line4> } <line5> try { <line6> ContextIDValue contextIDValue = contextCache.getContextIDValue(contextID); <line7> return contextIDValue.getContextKeyValueContext().getValues(keyword, csType); <line8> } catch (Exception e) { <line9> } <line10> return null; <line11> } <line12> } <line13>  <LINE> <line12>	No	task2	
<CODE> public class A { <line0> protected static Option addCodeCoverageOption() { <line1> String coverageCommand = System.getProperty(COVERAGE_COMMAND); <line2> if (coverageCommand != null) { <line3> return CoreOptions.vmOption(coverageCommand); <line4> } <line5> return null; <line6> } <line7> } <line8>  <LINE> <line5>	No	task2	
<CODE> public class A { <line0> private void executeDatanode(HddsDatanodeService hdds, String[] args) { <line1> CommandLine cmd = hdds.getCmd(); <line2> IExceptionHandler2<List<Object>> exceptionHandler = <line3> new IExceptionHandler2<List<Object>>() { <line4> @Override <line5> public List<Object> handleParseException(ParameterException ex, String[] args) { <line6> throw ex; <line7> } <line8>  <line9> @Override <line10> public List<Object> handleExecutionException( <line11> ExecutionException ex, ParseResult parseResult) { <line12> throw ex; <line13> } <line14> }; <line15> cmd.parseWithHandlers(new RunLast(), exceptionHandler, args); <line16> } <line17> } <line18>  <LINE> <line5>	No	task2	
"<CODE> public class A { <line0> @Override <line1> void onPreviousNodeFail() { <line2> joinErrorWatcher.checkJoinError(); <line3> if (rtState.errForClose != null || rtState.joined) return; <line4> synchronized (stateMux) { <line5> if (connState != STARTED) return; <line6> } <line7> localNodeFail(""Local node was forced to stop."", true); <line8> } <line9> } <line10>  <LINE> <line7>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> @RequiredUIAccess <line2> protected void onBeforeDocumentChange(@Nonnull DocumentEvent e) { <line3> super.onBeforeDocumentChange(e); <line4> if (myDiffChanges.isEmpty()) return; <line5> List<Document> documents = ContainerUtil.map(getEditors(), Editor::getDocument); <line6> Side side = Side.fromValue(documents, e.getDocument()); <line7> if (side == null) { <line8> return; <line9> } <line10> LineRange lineRange = DiffUtil.getAffectedLineRange(e); <line11> int shift = DiffUtil.countLinesShift(e); <line12> List<SimpleDiffChange> invalid = new ArrayList<>(); <line13> for (SimpleDiffChange change : myDiffChanges) { <line14> if (change.processChange(lineRange.start, lineRange.end, shift, side)) { <line15> invalid.add(change); <line16> } <line17> } <line18> if (!invalid.isEmpty()) { <line19> myDiffChanges.removeAll(invalid); <line20> myInvalidDiffChanges.addAll(invalid); <line21> } <line22> } <line23> } <line24>  <LINE> <line8>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public LayoutPageTemplateStructure remove(Serializable primaryKey) <line2> throws NoSuchPageTemplateStructureException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> LayoutPageTemplateStructure layoutPageTemplateStructure = <line7> (LayoutPageTemplateStructure) <line8> session.get(LayoutPageTemplateStructureImpl.class, primaryKey); <line9> if (layoutPageTemplateStructure == null) { <line10> if (log.isDebugEnabled()) { <line11> } <line12> throw new NoSuchPageTemplateStructureException( <line13> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line14> } <line15> return remove(layoutPageTemplateStructure); <line16> } catch (NoSuchPageTemplateStructureException noSuchEntityException) { <line17> throw noSuchEntityException; <line18> } catch (Exception exception) { <line19> throw processException(exception); <line20> } finally { <line21> closeSession(session); <line22> } <line23> } <line24> } <line25>  <LINE> <line11>	Yes	task2	
"<CODE> public class A { <line0> public StringApiResponse deleteIdeaInstance(Properties properties) throws Throwable { <line1> StringApiResponse response = new StringApiResponse(); <line2> try { <line3> String code = properties.getProperty(""code""); <line4> if (StringUtils.isNotBlank(code)) { <line5> code = URLDecoder.decode(code, ""UTF-8""); <line6> } <line7> IdeaInstance clone = this.getIdeaInstanceManager().getIdeaInstance(code); <line8> if (null == clone) { <line9> throw new ApiException( <line10> IApiErrorCodes.API_VALIDATION_ERROR, <line11> ""No ideaInstance found with id "" + code, <line12> Response.Status.CONFLICT); <line13> } <line14> IPage page = this.getPageWithInstance(code); <line15> if (null != page) { <line16> throw new ApiException( <line17> IApiErrorCodes.API_VALIDATION_ERROR, <line18> ""Cannod dete the intance with code '"" <line19> + code <line20> + ""'. It's published in page "" <line21> + page.getCode(), <line22> Response.Status.CONFLICT); <line23> } <line24> this.getIdeaInstanceManager().deleteIdeaInstance(code); <line25> response.setResult(IResponseBuilder.SUCCESS, null); <line26> } catch (ApiException ae) { <line27> response.addErrors(ae.getErrors()); <line28> response.setResult(IResponseBuilder.FAILURE, null); <line29> } catch (Throwable t) { <line30> throw t; <line31> } <line32> return response; <line33> } <line34> } <line35>  <LINE> <line2>"	No	task2	
"<CODE> public class A { <line0> private void throwExceptionForNullOrganization(Organization organization) { <line1> if (organization == null) { <line2> String msg = ""Organization not found""; <line3> throw new CustomWebApplicationException(msg, HttpStatus.SC_NOT_FOUND); <line4> } <line5> } <line6> } <line7>  <LINE> <line1>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void releasePodIpAddress(long id) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> DataCenterIpAddressVO vo = this.findById(id); <line5> vo.setTakenAt(null); <line6> vo.setInstanceId(null); <line7> vo.setReservationId(null); <line8> persist(vo); <line9> } <line10> } <line11>  <LINE> <line9>	No	task2	
<CODE> public class A { <line0> protected void fetchRelationship( <line1> MetadataChild relationship, <line2> boolean useForeignKeyAttribute, <line3> boolean nullifyDanglingRelationship) { <line4> Class<?> relatedType = relationship.getRelatedType(); <line5> if (!dataObjectService.supports(relatedType)) { <line6> return; <line7> } <line8> if (useForeignKeyAttribute) { <line9> fetchRelationshipUsingAttributes(relationship, nullifyDanglingRelationship); <line10> } else { <line11> fetchRelationshipUsingIdentity(relationship, nullifyDanglingRelationship); <line12> } <line13> } <line14> } <line15>  <LINE> <line4>	No	task2	
<CODE> public class A { <line0> @Override <line1> public DSLQueryEntry findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchDSLQueryEntryException { <line3> DSLQueryEntry dslQueryEntry = fetchByPrimaryKey(primaryKey); <line4> if (dslQueryEntry == null) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchDSLQueryEntryException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return dslQueryEntry; <line10> } <line11> } <line12>  <LINE> <line2>	No	task2	
<CODE> public class A { <line0> void abortMultipartUpload(String uploadId) throws AmazonClientException { <line1> mClient.abortMultipartUpload(new AbortMultipartUploadRequest(mBucket, key, uploadId)); <line2> } <line3> } <line4>  <LINE> <line2>	No	task2	
"<CODE> public class A { <line0> private Class<?> getMessageDTOClass(final String messageType, final boolean request) { <line1> switch (messageType) { <line2> case CoreCommonConstants.RELAY_MESSAGE_TYPE_GSD_POLL: <line3> return request ? GSDPollRequestDTO.class : GSDPollResponseDTO.class; <line4> case CoreCommonConstants.RELAY_MESSAGE_TYPE_ICN_PROPOSAL: <line5> return request ? ICNProposalRequestDTO.class : ICNProposalResponseDTO.class; <line6> case CoreCommonConstants.RELAY_MESSAGE_TYPE_ACCESS_TYPE: <line7> return request ? GeneralRelayRequestDTO.class : AccessTypeRelayResponseDTO.class; <line8> case CoreCommonConstants.RELAY_MESSAGE_TYPE_SYSTEM_ADDRESS_LIST: <line9> return request ? GeneralRelayRequestDTO.class : SystemAddressSetRelayResponseDTO.class; <line10> case CoreCommonConstants.RELAY_MESSAGE_TYPE_QOS_RELAY_TEST: <line11> return request <line12> ? QoSRelayTestProposalRequestDTO.class <line13> : QoSRelayTestProposalResponseDTO.class; <line14> default: <line15> throw new ArrowheadException(""Invalid message type: "" + messageType); <line16> } <line17> } <line18> } <line19>  <LINE> <line1>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void setPermission(INodeAuthorizationInfo node, FsPermission permission) { <line2> if (isSentryManaged(node)) { <line3> } <line4> defaultAuthzProvider.setPermission(node, permission); <line5> } <line6> } <line7>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public ConnectionFactory getConnectionFactory(Properties configuration) { <line2> final String _brokerURI = config.getConfiguration(BrokerConfiguration.BROKER_URL_KEY); <line3> final boolean changed = checkBrokerURI(_brokerURI); <line4> if (LOGGER.isLoggable(Level.INFO)) { <line5> } <line6> if (cf == null) { <line7> cf = new PooledConnectionFactory(brokerURI); <line8> } else { <line9> if (changed) { <line10> try { <line11> destroyConnectionFactory(); <line12> } catch (Exception e) { <line13> } <line14> cf = new PooledConnectionFactory(brokerURI); <line15> } <line16> } <line17> return cf; <line18> } <line19> } <line20>  <LINE> <line11>	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void testInsertTransformedWhere() throws Exception { <line2> StringBuilder update = new StringBuilder(); <line3> update.append(getNamespaceDeclarations()); <line4> update.append(""INSERT {?x rdfs:label [] . } WHERE {?y ex:containsPerson ?x.  }""); <line5> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update.toString()); <line6> assertFalse(con.hasStatement(bob, RDFS.LABEL, null, true)); <line7> assertFalse(con.hasStatement(alice, RDFS.LABEL, null, true)); <line8> operation.execute(); <line9> assertTrue(con.hasStatement(bob, RDFS.LABEL, null, true)); <line10> assertTrue(con.hasStatement(alice, RDFS.LABEL, null, true)); <line11> } <line12> } <line13>  <LINE> <line10>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> if (!registerPromise.isDone()) { <line3> registerPromise.setFailure(cause); <line4> } <line5> ctx.close(); <line6> } <line7> } <line8>  <LINE> <line2>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void doLaunch(MessageInput input) throws MisfireException { <line2> int heartbeatTimeout = ConnectionFactory.DEFAULT_HEARTBEAT; <line3> if (configuration.intIsSet(CK_HEARTBEAT_TIMEOUT)) { <line4> heartbeatTimeout = configuration.getInt(CK_HEARTBEAT_TIMEOUT); <line5> if (heartbeatTimeout < 0) { <line6> heartbeatTimeout = ConnectionFactory.DEFAULT_HEARTBEAT; <line7> } <line8> } <line9> consumer = <line10> new AmqpConsumer( <line11> configuration.getString(CK_HOSTNAME), <line12> configuration.getInt(CK_PORT), <line13> configuration.getString(CK_VHOST), <line14> configuration.getString(CK_USERNAME), <line15> configuration.getString(CK_PASSWORD), <line16> configuration.getInt(CK_PREFETCH), <line17> configuration.getString(CK_QUEUE), <line18> configuration.getString(CK_EXCHANGE), <line19> configuration.getBoolean(CK_EXCHANGE_BIND), <line20> configuration.getString(CK_ROUTING_KEY), <line21> configuration.getInt(CK_PARALLEL_QUEUES), <line22> configuration.getBoolean(CK_TLS), <line23> configuration.getBoolean(CK_REQUEUE_INVALID_MESSAGES), <line24> heartbeatTimeout, <line25> input, <line26> scheduler, <line27> this); <line28> eventBus.register(this); <line29> try { <line30> consumer.run(); <line31> } catch (IOException e) { <line32> eventBus.unregister(this); <line33> throw new MisfireException(""Could not launch AMQP consumer."", e); <line34> } <line35> } <line36> } <line37>  <LINE> <line6>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public Set<RegisteredCredential> lookupAll(final ByteArray credentialId) { <line2> return Collections.emptySet(); <line3> } <line4> } <line5>  <LINE> <line1>	No	task2	
<CODE> public class A { <line0> public void phaseEnded(ConstructionHeuristicPhaseScope<Solution_> phaseScope) { <line1> super.phaseEnded(phaseScope); <line2> if (skipBestSolutionCloningInSteps) { <line3> bestSolutionRecaller.updateBestSolution(phaseScope.getSolverScope()); <line4> } <line5> entityPlacer.phaseEnded(phaseScope); <line6> decider.phaseEnded(phaseScope); <line7> phaseScope.endingNow(); <line8> } <line9> } <line10>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> @Override <line1> public boolean isSatisified() throws Exception { <line2> return resumedCount.get() >= WORKER_COUNT; <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public long getSize(Configuration configuration) { <line2> if (view instanceof SizeAccessor) { <line3> return ((SizeAccessor) view).getSize(); <line4> } <line5> return 1000L * 1000L * 1000L; <line6> } <line7> } <line8>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public <T extends Entity> T get(EntityType type, String name) throws FalconException { <line2> ConcurrentHashMap<String, Entity> entityMap = dictionary.get(type); <line3> if (entityMap.containsKey(name)) { <line4> if (updatesInProgress.get() != null <line5> && updatesInProgress.get().getEntityType() == type <line6> && updatesInProgress.get().getName().equals(name)) { <line7> return (T) updatesInProgress.get(); <line8> } <line9> T entity = (T) entityMap.get(name); <line10> if (entity == NULL && shouldPersist) { <line11> try { <line12> entity = this.restore(type, name); <line13> } catch (IOException e) { <line14> throw new StoreAccessException(e); <line15> } <line16> entityMap.put(name, entity); <line17> return entity; <line18> } else { <line19> return entity; <line20> } <line21> } else { <line22> return null; <line23> } <line24> } <line25> } <line26>  <LINE> <line10>"	No	task2	
<CODE> public class A { <line0> private Destination resolveDestination(String destinationName) throws JMSException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> return resolveDestinationName(destinationName, session); <line4> } <line5> } <line6>  <LINE> <line3>	No	task2	
<CODE> public class A { <line0> public void sendReply(long transactionId, String message) { <line1> if (routeModified) { <line2> sendModifiedReply(transactionId, message); <line3> } else { <line4> sendAgreeMsg(transactionId, message); <line5> } <line6> routeModified = false; <line7> } <line8> } <line9>  <LINE> <line8>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void start() throws GridException { <line2> Map<GridPredicate<? extends GridEvent>, int[]> evtLsnrs = ctx.config().getLocalEventListeners(); <line3> if (evtLsnrs != null) { <line4> for (GridPredicate<? extends GridEvent> lsnr : evtLsnrs.keySet()) <line5> addLocalEventListener(lsnr, evtLsnrs.get(lsnr)); <line6> } <line7> startSpi(); <line8> msgLsnr = new RequestListener(); <line9> ctx.io().addMessageListener(TOPIC_EVENT, msgLsnr); <line10> } <line11> } <line12>  <LINE> <line10>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public JsonArray fetchVisualizationResults(long executionId, int kpiId, int assessmentId) { <line2> String vQuery = """"; <line3> vQuery = QueryEnum.valueOf(QueryEnum.NEO4J_VCONTENTQUERY.name()).toString(); <line4> vQuery = <line5> vQuery <line6> .replace("":kpiId"", String.valueOf(kpiId)) <line7> .replace("":executionId"", String.valueOf(executionId)) <line8> .replace("":assessmentId"", String.valueOf(assessmentId)); <line9> return fetchVisualizationResults(vQuery); <line10> } <line11> } <line12>  <LINE> <line9>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> @Deprecated <line2> public <T> T setAttribute(AttributeSensor<T> attribute, T val) { <line3> if (LOG.isDebugEnabled()) <line4> return super.sensors().set(attribute, val); <line5> } <line6> } <line7>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> public void getData(File toFile) throws IOFailure, ArgumentNotValid { <line1> ArgumentNotValid.checkNotNull(toFile, ""toFile""); <line2> if (theRemoteFile == null) { <line3> throw new IOFailure(""No remoteFile in this message.""); <line4> } <line5> theRemoteFile.copyTo(toFile); <line6> try { <line7> theRemoteFile.cleanup(); <line8> } catch (IOFailure e) { <line9> } <line10> theRemoteFile = null; <line11> } <line12> } <line13>  <LINE> <line9>"	Yes	task2	
"<CODE> public class A { <line0> private Long getEthGasPrice() throws AplException.ExecutiveProcessException { <line1> Long gasPrice; <line2> try { <line3> gasPrice = dexEthService.getEthPriceInfo().getFastSpeedPrice(); <line4> } catch (ExecutionException e) { <line5> throw new AplException.ExecutiveProcessException( <line6> ""Third service is not available, try later.""); <line7> } <line8> if (gasPrice == null) { <line9> throw new AplException.ThirdServiceIsNotAvailable(""Eth Price Info is not available.""); <line10> } <line11> return gasPrice; <line12> } <line13> } <line14>  <LINE> <line1>"	No	task2	
"<CODE> public class A { <line0> public void cleanIntpContext(String nodeId) { <line1> String keyPrex = nodeId + ""@""; <line2> for (Map.Entry<String, InterpreterContext> entity : noteParagraphId2IntpContext.entrySet()) { <line3> String key = entity.getKey(); <line4> if (key.contains(keyPrex)) { <line5> noteParagraphId2IntpContext.remove(key); <line6> } <line7> } <line8> } <line9> } <line10>  <LINE> <line6>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void entriesDeleted(Collection<String> entries) { <line2> } <line3> } <line4>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> public ImportLocalizedAssetBody importLocalizedAssetForContent( <line1> Long assetId, <line2> Long localeId, <line3> String content, <line4> ImportLocalizedAssetBody.StatusForEqualTarget statusForEqualTarget, <line5> FilterConfigIdOverride filterConfigIdOverride, <line6> List<String> filterOptions) { <line7> UriComponentsBuilder uriBuilder = <line8> UriComponentsBuilder.fromPath( <line9> getBasePathForResource(assetId, ""localized"", localeId, ""import"")); <line10> ImportLocalizedAssetBody importLocalizedAssetBody = new ImportLocalizedAssetBody(); <line11> importLocalizedAssetBody.setContent(content); <line12> importLocalizedAssetBody.setStatusForEqualTarget(statusForEqualTarget); <line13> importLocalizedAssetBody.setFilterConfigIdOverride(filterConfigIdOverride); <line14> importLocalizedAssetBody.setFilterOptions(filterOptions); <line15> return authenticatedRestTemplate.postForObject( <line16> uriBuilder.toUriString(), importLocalizedAssetBody, ImportLocalizedAssetBody.class); <line17> } <line18> } <line19>  <LINE> <line7>"	Yes	task2	
<CODE> public class A { <line0> public static XTextField findAnnotationFieldRecursive(Object element) { <line1> if (UNO.XEnumerationAccess(element) != null) { <line2> UnoCollection<Object> children = UnoCollection.getCollection(element, Object.class); <line3> for (Object child : children) { <line4> try { <line5> XTextField found = findAnnotationFieldRecursive(child); <line6> if (found != null) { <line7> return found; <line8> } <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> Object textField = Utils.getProperty(element, UnoProperty.TEXT_FIELD); <line14> if (textField != null <line15> && UnoService.supportsService(textField, UnoService.CSS_TEXT_TEXT_FIELD_ANNOTATION)) { <line16> return UNO.XTextField(textField); <line17> } <line18> return null; <line19> } <line20> } <line21>  <LINE> <line8>	No	task2	
<CODE> public class A { <line0> @PostConstruct <line1> public void init() { <line2> marshallerInstance <line3> .iterator() <line4> .forEachRemaining( <line5> marshaller -> { <line6> register(marshaller.getType(), marshaller); <line7> }); <line8> } <line9> } <line10>  <LINE> <line6>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public int countSharedProjectsByUser(Long idUser) { <line2> Condition conditions = Tables.PROJECT.SHARED.equal(Boolean.TRUE); <line3> if (idUser != null) { <line4> conditions = conditions.and(Tables.PROJECT.ID_USER.eq(idUser)); <line5> } <line6> return create.fetchCount(Tables.PROJECT, conditions); <line7> } <line8> } <line9>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> void append(final List<AckEntry> batch) { <line1> if (batch == null || batch.isEmpty()) return; <line2> updateLock.lock(); <line3> try { <line4> if (lastAppendOffset != -1 && lastAppendOffset + 1 != batch.get(0).pullOffset()) { <line5> appendErrorCount.inc(); <line6> } <line7> if (head == null) { <line8> beginScanPosition = head = batch.get(0); <line9> minPullOffset.set(head.pullOffset()); <line10> } <line11> if (tail != null) { <line12> tail.setNext(batch.get(0)); <line13> } <line14> tail = batch.get(batch.size() - 1); <line15> lastAppendOffset = tail.pullOffset(); <line16> maxPullOffset.set(tail.pullOffset()); <line17> toSendNum.getAndAdd(batch.size()); <line18> } finally { <line19> updateLock.unlock(); <line20> } <line21> } <line22> } <line23>  <LINE> <line11>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void onPostUpdate(final PostUpdateEvent event) { <line2> Object entity = event.getEntity(); <line3> if (!(entity instanceof HTextFlowTarget)) { <line4> return; <line5> } <line6> final HTextFlowTarget target = HTextFlowTarget.class.cast(event.getEntity()); <line7> try { <line8> runInTransaction( <line9> () -> { <line10> ContentState oldContentState = <line11> (ContentState) <line12> Iterables.find( <line13> Lists.newArrayList(event.getOldState()), <line14> Predicates.instanceOf(ContentState.class)); <line15> prepareTransUnitUpdatedEvent(target.getVersionNum() - 1, oldContentState, target); <line16> }); <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21>  <LINE> <line18>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void memberDeparted( <line2> DistributionManager distributionManager, InternalDistributedMember id, boolean crashed) { <line3> synchronized (this.hostedTXStates) { <line4> Iterator<Map.Entry<TXId, TXStateProxy>> iterator = this.hostedTXStates.entrySet().iterator(); <line5> while (iterator.hasNext()) { <line6> Map.Entry<TXId, TXStateProxy> me = iterator.next(); <line7> TXId txId = me.getKey(); <line8> if (txId.getMemberId().equals(id)) { <line9> me.getValue().close(); <line10> if (logger.isDebugEnabled()) { <line11> } <line12> iterator.remove(); <line13> } <line14> } <line15> } <line16> expireClientTransactionsSentFromDepartedProxy(id); <line17> } <line18> } <line19>  <LINE> <line11>	Yes	task2	
"<CODE> public class A { <line0> @RequestMapping(value = ""/{id}"", method = RequestMethod.DELETE) <line1> public ResponseEntity<Boolean> delete(@PathVariable(""id"") long id) { <line2> roleManagementService.deleteRole(id); <line3> return new ResponseEntity<>(Boolean.TRUE, HttpStatus.OK); <line4> } <line5> } <line6>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> public static java.util.List<com.liferay.journal.model.JournalArticle> getLatestArticles( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> int status, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.journal.model.JournalArticle> <line7> orderByComparator) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> JournalArticleServiceUtil.class, <line12> ""getLatestArticles"", <line13> _getLatestArticlesParameterTypes48); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, status, start, end, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.journal.model.JournalArticle>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28>  <LINE> <line24>"	Yes	task2	
<CODE> public class A { <line0> private static boolean startEsClient(FsCrawlerImpl fsCrawler) { <line1> try { <line2> fsCrawler.start(); <line3> return true; <line4> } catch (Exception t) { <line5> return false; <line6> } <line7> } <line8> } <line9>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> private void init() throws Exception { <line1> String originalAppId = propertiesBuilder.conf.get(ORIGINAL_APP_ID); <line2> if (originalAppId == null) { <line3> throw new AssertionError(""Need original app id if launching without apa or appjar""); <line4> } <line5> Path appsBasePath = <line6> new Path(StramClientUtils.getApexDFSRootDir(fs, conf), StramClientUtils.SUBDIR_APPS); <line7> Path origAppPath = new Path(appsBasePath, originalAppId); <line8> StringWriter writer = new StringWriter(); <line9> try (FSDataInputStream in = fs.open(new Path(origAppPath, ""meta.json""))) { <line10> IOUtils.copy(in, writer); <line11> } <line12> JSONObject metaJson = new JSONObject(writer.toString()); <line13> String originalLibJars = null; <line14> try { <line15> JSONObject attributes = metaJson.getJSONObject(""attributes""); <line16> originalLibJars = attributes.getString(Context.DAGContext.LIBRARY_JARS.getSimpleName()); <line17> recoveryAppName = attributes.getString(Context.DAGContext.APPLICATION_NAME.getSimpleName()); <line18> } catch (JSONException ex) { <line19> recoveryAppName = ""Recovery App From "" + originalAppId; <line20> } <line21> LinkedHashSet<URL> clUrls = new LinkedHashSet<>(); <line22> String libjars = propertiesBuilder.conf.get(LIBJARS_CONF_KEY_NAME); <line23> if (StringUtils.isBlank(libjars)) { <line24> libjars = originalLibJars; <line25> } else if (StringUtils.isNotBlank(originalLibJars)) { <line26> libjars = libjars + "","" + originalLibJars; <line27> } <line28> propertiesBuilder.conf.set(LIBJARS_CONF_KEY_NAME, libjars); <line29> processLibJars(libjars, clUrls); <line30> for (URL baseURL : clUrls) { <line31> } <line32> this.launchDependencies = clUrls; <line33> } <line34> } <line35>  <LINE> <line31>"	Yes	task2	
<CODE> public class A { <line0> private String getApplicationId(AgentInfo agentInfo, String agentId) { <line1> if (agentInfo == null) { <line2> return NOT_FOUND_APP_ID; <line3> } <line4> return agentInfo.getApplicationName(); <line5> } <line6> } <line7>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> protected SequenceFile.Writer createNewFile( <line1> Path filepath, <line2> Class<? extends WritableComparable> keyClass, <line3> Class<? extends Writable> valueClass) <line4> throws IOException { <line5> SequenceFile.Writer writer = <line6> new SequenceFile.Writer(getFileSystem(), getJobConf(), filepath, keyClass, valueClass); <line7> return writer; <line8> } <line9> } <line10>  <LINE> <line0>	No	task2	
<CODE> public class A { <line0> private void deleteWithRetriesSilent(final String s3Bucket, final String s3Path) { <line1> try { <line2> deleteWithRetries(s3Bucket, s3Path); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7>  <LINE> <line4>	Yes	task2	
"<CODE> public class A { <line0> public static void createTermFrequencyVectors( <line1> Path input, <line2> Path output, <line3> String tfVectorsFolderName, <line4> Configuration baseConf, <line5> int minSupport, <line6> int maxNGramSize, <line7> float minLLRValue, <line8> float normPower, <line9> boolean logNormalize, <line10> int numReducers, <line11> int chunkSizeInMegabytes, <line12> boolean sequentialAccess, <line13> boolean namedVectors) <line14> throws IOException, InterruptedException, ClassNotFoundException { <line15> Preconditions.checkArgument( <line16> normPower == PartialVectorMerger.NO_NORMALIZING || normPower >= 0, <line17> ""If specified normPower must be nonnegative"", <line18> normPower); <line19> Preconditions.checkArgument( <line20> normPower == PartialVectorMerger.NO_NORMALIZING <line21> || (normPower > 1 && !Double.isInfinite(normPower)) <line22> || !logNormalize, <line23> ""normPower must be > 1 and not infinite if log normalization is chosen"", <line24> normPower); <line25> if (chunkSizeInMegabytes < MIN_CHUNKSIZE) { <line26> chunkSizeInMegabytes = MIN_CHUNKSIZE; <line27> } else if (chunkSizeInMegabytes > MAX_CHUNKSIZE) { <line28> chunkSizeInMegabytes = MAX_CHUNKSIZE; <line29> } <line30> if (minSupport < 0) { <line31> minSupport = DEFAULT_MIN_SUPPORT; <line32> } <line33> Path dictionaryJobPath = new Path(output, DICTIONARY_JOB_FOLDER); <line34> int[] maxTermDimension = new int[1]; <line35> List<Path> dictionaryChunks; <line36> if (maxNGramSize == 1) { <line37> startWordCounting(input, dictionaryJobPath, baseConf, minSupport); <line38> dictionaryChunks = <line39> createDictionaryChunks( <line40> dictionaryJobPath, output, baseConf, chunkSizeInMegabytes, maxTermDimension); <line41> } else { <line42> CollocDriver.generateAllGrams( <line43> input, dictionaryJobPath, baseConf, maxNGramSize, minSupport, minLLRValue, numReducers); <line44> dictionaryChunks = <line45> createDictionaryChunks( <line46> new Path( <line47> new Path(output, DICTIONARY_JOB_FOLDER), CollocDriver.NGRAM_OUTPUT_DIRECTORY), <line48> output, <line49> baseConf, <line50> chunkSizeInMegabytes, <line51> maxTermDimension); <line52> } <line53> int partialVectorIndex = 0; <line54> Collection<Path> partialVectorPaths = Lists.newArrayList(); <line55> for (Path dictionaryChunk : dictionaryChunks) { <line56> Path partialVectorOutputPath = new Path(output, VECTOR_OUTPUT_FOLDER + partialVectorIndex++); <line57> partialVectorPaths.add(partialVectorOutputPath); <line58> makePartialVectors( <line59> input, <line60> baseConf, <line61> maxNGramSize, <line62> dictionaryChunk, <line63> partialVectorOutputPath, <line64> maxTermDimension[0], <line65> sequentialAccess, <line66> namedVectors, <line67> numReducers); <line68> } <line69> Configuration conf = new Configuration(baseConf); <line70> Path outputDir = new Path(output, tfVectorsFolderName); <line71> PartialVectorMerger.mergePartialVectors( <line72> partialVectorPaths, <line73> outputDir, <line74> conf, <line75> normPower, <line76> logNormalize, <line77> maxTermDimension[0], <line78> sequentialAccess, <line79> namedVectors, <line80> numReducers); <line81> HadoopUtil.delete(conf, partialVectorPaths); <line82> } <line83> } <line84>  <LINE> <line22>"	No	task2	
"<CODE> public class A { <line0> public ImportStorage<BuchungssatzDO> importBuchungsdaten( <line1> final InputStream is, final String filename) throws Exception { <line2> checkLoggeinUserRight(accessChecker); <line3> ExcelWorkbook workbook = new ExcelWorkbook(is, filename, ThreadLocalUserContext.getLocale()); <line4> final ImportStorage<BuchungssatzDO> storage = <line5> new ImportStorage<>( <line6> Type.BUCHUNGSSAETZE, workbook, ImportLogger.Level.INFO, ""'"" + filename + ""':"", log); <line7> final BuchungssatzExcelImporter imp = <line8> new BuchungssatzExcelImporter(storage, kontoDao, kost1Dao, kost2Dao); <line9> imp.doImport(workbook); <line10> return storage; <line11> } <line12> } <line13>  <LINE> <line11>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public ActionLogRecord getActionRecord(int id) { <line2> Connection conn = null; <line3> PreparedStatement stat = null; <line4> ResultSet res = null; <line5> ActionLogRecord actionRecord = null; <line6> try { <line7> conn = this.getConnection(); <line8> conn.setAutoCommit(false); <line9> stat = conn.prepareStatement(GET_ACTION_RECORD); <line10> stat.setInt(1, id); <line11> res = stat.executeQuery(); <line12> if (res.next()) { <line13> actionRecord = new ActionLogRecord(); <line14> actionRecord.setId(id); <line15> Timestamp actionDate = res.getTimestamp(""actiondate""); <line16> actionRecord.setActionDate(new Date(actionDate.getTime())); <line17> Timestamp updateDate = res.getTimestamp(""updatedate""); <line18> actionRecord.setUpdateDate(new Date(updateDate.getTime())); <line19> actionRecord.setActionName(res.getString(""actionname"")); <line20> actionRecord.setNamespace(res.getString(""namespace"")); <line21> actionRecord.setParameters(res.getString(""parameters"")); <line22> actionRecord.setUsername(res.getString(""username"")); <line23> String asiXml = res.getString(""activitystreaminfo""); <line24> if (null != asiXml && asiXml.trim().length() > 0) { <line25> ActivityStreamInfo asi = ActivityStreamInfoDOM.unmarshalInfo(asiXml); <line26> actionRecord.setActivityStreamInfo(asi); <line27> } <line28> } <line29> conn.commit(); <line30> } catch (Throwable t) { <line31> this.executeRollback(conn); <line32> throw new RuntimeException(""Error loading actionlogger record with id: "" + id, t); <line33> } finally { <line34> closeDaoResources(res, stat, conn); <line35> } <line36> return actionRecord; <line37> } <line38> } <line39>  <LINE> <line32>"	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void setThingOffline(ThingStatusDetail detail, String messageKey) { <line2> if (!isThingOffline()) { <line3> updateStatus(ThingStatus.OFFLINE, detail, ""@text/"" + messageKey); <line4> watchdog = 0; <line5> channelsCreated = false; <line6> } <line7> } <line8> } <line9>  <LINE> <line8>"	No	task2	
"<CODE> public class A { <line0> public static AssertionError assertAssertionError(Block block) throws Exception { <line1> AssertionError answer = null; <line2> try { <line3> block.invoke(); <line4> } catch (AssertionError e) { <line5> answer = e; <line6> System.out.println(""Caught expected assertion failure: "" + e); <line7> } catch (Exception e) { <line8> throw e; <line9> } <line10> if (answer == null) { <line11> throw new AssertionError(""Expected an assertion error from block: "" + block); <line12> } <line13> return answer; <line14> } <line15> } <line16>  <LINE> <line13>"	Yes	task2	
<CODE> public class A { <line0> public Invitation get(InvitationDTO dto, Long userId) { <line1> Invitation i = new Invitation(); <line2> i.setHash(randomUUID().toString()); <line3> i.setPasswordProtected(dto.isPasswordProtected()); <line4> if (dto.isPasswordProtected()) { <line5> i.setPassword(CryptProvider.get().hash(dto.getPassword())); <line6> } <line7> i.setUsed(false); <line8> i.setValid(dto.getValid()); <line9> try { <line10> switch (dto.getValid()) { <line11> case PERIOD: <line12> i.setValidFrom(new Date(SDF.parse(dto.getValidFrom()).getTime() - (5 * 60 * 1000))); <line13> i.setValidTo(SDF.parse(dto.getValidTo())); <line14> break; <line15> case ENDLESS: <line16> case ONE_TIME: <line17> default: <line18> break; <line19> } <line20> } catch (ParseException e) { <line21> throw new RuntimeException(e); <line22> } <line23> i.setDeleted(false); <line24> i.setInvitedBy(userDao.get(userId)); <line25> i.setInvitee(userDao.getContact(dto.getEmail(), dto.getFirstname(), dto.getLastname(), userId)); <line26> if (Type.CONTACT == i.getInvitee().getType()) { <line27> i.getInvitee().setLanguageId(dto.getLanguageId()); <line28> } <line29> i.setRoom(roomDao.get(dto.getRoomId())); <line30> i.setInserted(new Date()); <line31> i.setAppointment(null); <line32> return i; <line33> } <line34> } <line35>  <LINE> <line21>	Yes	task2	
<CODE> public class A { <line0> protected final void cancelGroup(TaskAnalyser ta, TaskDispatcher td) { <line1> TaskGroup tg = ta.removeTaskGroup(app, groupName); <line2> if (tg != null) { <line3> List<Task> tasks = tg.getTasks(); <line4> int taskCount = tasks.size(); <line5> StaticMultioperationSemaphore listener = new StaticMultioperationSemaphore(taskCount, sem); <line6> for (Task t : tasks) { <line7> td.cancelTasks(t, listener); <line8> } <line9> } else { <line10> sem.release(); <line11> } <line12> } <line13> } <line14>  <LINE> <line6>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void flush() { <line2> try { <line3> xDMA.storeMetadataToStorage(UNO.XStorageBasedDocument(doc).getDocumentStorage()); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8>  <LINE> <line5>	Yes	task2	
"<CODE> public class A { <line0> private <R> void coprocssorService( <line1> String serviceName, byte[] startKey, byte[] endKey, Callback<R> callback, StubCall<R> call) <line2> throws Throwable { <line3> ExecutorService pool = this.poolSupplier.get(); <line4> List<byte[]> keys = getStartKeysInRange(startKey, endKey); <line5> Map<byte[], Future<R>> futures = new TreeMap<>(Bytes.BYTES_COMPARATOR); <line6> try { <line7> for (byte[] r : keys) { <line8> RegionCoprocessorRpcChannel channel = coprocessorService(r); <line9> Future<R> future = <line10> pool.submit( <line11> new Callable<R>() { <line12> @Override <line13> public R call() throws Exception { <line14> R result = call.call(channel); <line15> byte[] region = channel.getLastRegion(); <line16> if (callback != null) { <line17> callback.update(region, r, result); <line18> } <line19> return result; <line20> } <line21> }); <line22> futures.put(r, future); <line23> } <line24> } catch (RejectedExecutionException e) { <line25> if (conn.isClosed()) { <line26> throw new DoNotRetryIOException(""Connection is closed"", e); <line27> } else { <line28> throw new HBaseIOException(""Coprocessor operation is rejected"", e); <line29> } <line30> } <line31> for (Map.Entry<byte[], Future<R>> e : futures.entrySet()) { <line32> try { <line33> e.getValue().get(); <line34> } catch (ExecutionException ee) { <line35> throw ee.getCause(); <line36> } catch (InterruptedException ie) { <line37> throw new InterruptedIOException( <line38> ""Interrupted calling coprocessor service "" <line39> + serviceName <line40> + "" for row "" <line41> + Bytes.toStringBinary(e.getKey())) <line42> .initCause(ie); <line43> } <line44> } <line45> } <line46> } <line47>  <LINE> <line35>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public boolean hasNext() { <line2> boolean hasNext; <line3> if (itStack.isEmpty()) { <line4> hasNext = directlyUnder.hasNext(); <line5> } else { <line6> hasNext = false; <line7> do { <line8> if (!itStack.peek().iterator().hasNext()) { <line9> try { <line10> itStack.pop().close(); <line11> } catch (IOException e) { <line12> } <line13> } else { <line14> hasNext = true; <line15> } <line16> } while (!hasNext && !itStack.isEmpty()); <line17> if (itStack.isEmpty()) { <line18> hasNext = directlyUnder.hasNext(); <line19> } <line20> } <line21> return hasNext; <line22> } <line23> } <line24>  <LINE> <line12>	Yes	task2	
<CODE> public class A { <line0> private void readRateSet() throws Throwable { <line1> File f = new File(setup.clientExchangeRatesPath()); <line2> byte[] bytes = Files.readAllBytes(f.toPath()); <line3> rateSet = ExchangeRateSet.parseFrom(bytes); <line4> } <line5> } <line6>  <LINE> <line4>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void cancel(ServiceContext ctx) { <line2> clusterMgr.stopClusterIfExists(clusterId); <line3> } <line4> } <line5>  <LINE> <line3>	Yes	task2	
<CODE> public class A { <line0> protected FinancialSystemMaintenanceDocument getParentMaintDoc() { <line1> DocumentService documentService = SpringContext.getBean(DocumentService.class); <line2> try { <line3> return (FinancialSystemMaintenanceDocument) <line4> documentService.getByDocumentHeaderId(getDocumentNumber()); <line5> } catch (WorkflowException e) { <line6> } <line7> return null; <line8> } <line9> } <line10>  <LINE> <line7>	No	task2	
"<CODE> public class A { <line0> private CredentialsProvider determineCredentialsProvider() { <line1> final CredentialsProvider provider = innerBuilder.getCredentialsProvider(); <line2> if (provider == null) { <line3> ensureNotNull(""cluster id"", clusterId); <line4> ensureNotNull(""client id"", clientId); <line5> ensureNotNull(""client secret"", clientSecret); <line6> final OAuthCredentialsProviderBuilder builder = new OAuthCredentialsProviderBuilder(); <line7> return builder <line8> .audience(String.format(""%s.%s"", clusterId, BASE_ADDRESS)) <line9> .clientId(clientId) <line10> .clientSecret(clientSecret) <line11> .authorizationServerUrl(BASE_AUTH_URL) <line12> .build(); <line13> } else { <line14> return provider; <line15> } <line16> } <line17> } <line18>  <LINE> <line14>"	Yes	task2	
"<CODE> public class A { <line0> protected void initKettle() { <line1> try { <line2> KettleSystemListener.environmentInit(PentahoSessionHolder.getSession()); <line3> if (Props.isInitialized() == false) { <line4> Props.init(Props.TYPE_PROPERTIES_EMPTY); <line5> } <line6> } catch (KettleException e) { <line7> throw new IllegalStateException(""Failed to initialize Kettle system""); <line8> } <line9> } <line10> } <line11>  <LINE> <line2>"	No	task2	
<CODE> public class A { <line0> public void terminate() { <line1> if (cf != null) { <line2> cf.terminate(); <line3> } <line4> if (channel != null) { <line5> channel.close(); <line6> } <line7> if (listener == null) { <line8> return; <line9> } <line10> listener.setDone(); <line11> try { <line12> while (listener.isAlive()) { <line13> listener.interrupt(); <line14> listener.join(100); <line15> } <line16> } catch (InterruptedException u) { <line17> Thread.currentThread().interrupt(); <line18> } <line19> listener = null; <line20> } <line21> } <line22>  <LINE> <line10>	Yes	task2	
<CODE> public class A { <line0> private void forceClose() { <line1> assert adminExecutor.inEventLoop(); <line2> if (forceCloseWasCalled) { <line3> return; <line4> } <line5> forceCloseWasCalled = true; <line6> if (closeWasCalled) { <line7> for (AsyncAutoCloseable closeable : internalComponentsToClose()) { <line8> closeable.forceCloseAsync(); <line9> } <line10> } else { <line11> closePolicies(); <line12> List<CompletionStage<Void>> childrenCloseStages = new ArrayList<>(); <line13> for (AsyncAutoCloseable closeable : internalComponentsToClose()) { <line14> childrenCloseStages.add(closeable.forceCloseAsync()); <line15> } <line16> CompletableFutures.whenAllDone( <line17> childrenCloseStages, () -> onChildrenClosed(childrenCloseStages), adminExecutor); <line18> } <line19> } <line20> } <line21>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> public static String serialize(Object obj) { <line1> String json = null; <line2> try { <line3> json = getMapper().writeValueAsString(obj); <line4> } catch (JsonProcessingException e) { <line5> throw new RuntimeException(""Error serializing object"", e); <line6> } <line7> return json; <line8> } <line9> } <line10>  <LINE> <line5>"	Yes	task2	
"<CODE> public class A { <line0> public int getSymLinkDepth() { <line1> int value = 0; <line2> try { <line3> value = Integer.parseInt(line.getOptionValue(ARGUMENT.SYM_LINK_DEPTH, ""0"")); <line4> if (value < 0) { <line5> value = 0; <line6> } <line7> } catch (NumberFormatException ex) { <line8> } <line9> return value; <line10> } <line11> } <line12>  <LINE> <line8>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public Set<String> getTableNames() { <line2> try (Admin admin = plugin.getConnection().getAdmin()) { <line3> HTableDescriptor[] tables = admin.listTables(); <line4> Set<String> tableNames = Sets.newHashSet(); <line5> for (HTableDescriptor table : tables) { <line6> tableNames.add(new String(table.getTableName().getNameAsString())); <line7> } <line8> return tableNames; <line9> } catch (Exception e) { <line10> return Collections.emptySet(); <line11> } <line12> } <line13> } <line14>  <LINE> <line10>	Yes	task2	
"<CODE> public class A { <line0> @POST <line1> @Path(""generate"") <line2> @Produces(MediaType.TEXT_XML) <line3> @RestQuery( <line4> name = ""generate"", <line5> description = ""Generates a cover image based on the given metadata"", <line6> restParameters = { <line7> @RestParameter( <line8> description = ""Metadata XML"", <line9> isRequired = false, <line10> name = ""xml"", <line11> type = Type.TEXT), <line12> @RestParameter( <line13> description = ""XSLT stylesheet"", <line14> isRequired = true, <line15> name = ""xsl"", <line16> type = Type.TEXT), <line17> @RestParameter( <line18> description = ""Width of the cover image"", <line19> isRequired = true, <line20> name = ""width"", <line21> type = Type.INTEGER, <line22> defaultValue = ""1600""), <line23> @RestParameter( <line24> description = ""Height of the cover image"", <line25> isRequired = true, <line26> name = ""height"", <line27> type = Type.INTEGER, <line28> defaultValue = ""900""), <line29> @RestParameter( <line30> description = ""URI of poster image"", <line31> isRequired = false, <line32> name = ""posterimage"", <line33> type = Type.STRING), <line34> @RestParameter( <line35> description = ""Flavor of target cover image"", <line36> isRequired = true, <line37> name = ""targetflavor"", <line38> type = Type.STRING, <line39> defaultValue = ""image/cover"") <line40> }, <line41> responses = { <line42> @RestResponse( <line43> description = <line44> ""Results in an xml document containing the job for the cover image generation task"", <line45> responseCode = HttpServletResponse.SC_OK), <line46> @RestResponse( <line47> description = ""If required parameters aren't set or not valid"", <line48> responseCode = HttpServletResponse.SC_BAD_REQUEST) <line49> }, <line50> returnDescription = """") <line51> public Response generateCoverImage( <line52> @FormParam(""xml"") String xml, <line53> @FormParam(""xsl"") String xsl, <line54> @FormParam(""width"") String width, <line55> @FormParam(""height"") String height, <line56> @FormParam(""posterimage"") String posterFlavor, <line57> @FormParam(""targetflavor"") String targetFlavor) { <line58> try { <line59> Job job = <line60> coverImageService.generateCoverImage(xml, xsl, width, height, posterFlavor, targetFlavor); <line61> return Response.ok().entity(new JaxbJob(job)).build(); <line62> } catch (CoverImageException e) { <line63> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line64> } <line65> } <line66> } <line67>  <LINE> <line14>"	No	task2	
<CODE> public class A { <line0> public boolean initDevice( <line1> boolean enableAccelerometer, boolean enableGyroscope, boolean enableMagnetometer) { <line2> boolean result = false; <line3> try { <line4> if ((read(ACC_DEVICE, WHO_AM_I_XG) & 0x000000FF) == WHO_AM_I_AG_ID <line5> && (read(MAG_DEVICE, WHO_AM_I_M) & 0x000000FF) == WHO_AM_I_M_ID) { <line6> result = true; <line7> if (enableAccelerometer) { <line8> enableAccelerometer(); <line9> } else { <line10> disableAccelerometer(); <line11> } <line12> if (enableGyroscope) { <line13> enableGyroscope(); <line14> } else { <line15> disableGyroscope(); <line16> } <line17> if (enableMagnetometer) { <line18> enableMagnetometer(); <line19> } else { <line20> disableMagnetometer(); <line21> } <line22> } <line23> } catch (KuraException e) { <line24> } <line25> return result; <line26> } <line27> } <line28>  <LINE> <line24>	Yes	task2	
<CODE> public class A { <line0> private State getDynamicChannelState(final Channel channel, final @Nullable String value) { <line1> final @Nullable String acceptedItemType = channel.getAcceptedItemType(); <line2> if (value == null || acceptedItemType == null) { <line3> return UnDefType.UNDEF; <line4> } <line5> switch (acceptedItemType) { <line6> case CoreItemFactory.NUMBER: <line7> return new DecimalType(value); <line8> case CoreItemFactory.STRING: <line9> return StringType.valueOf(value); <line10> case CoreItemFactory.SWITCH: <line11> return OnOffType.from(value); <line12> default: <line13> return UnDefType.UNDEF; <line14> } <line15> } <line16> } <line17>  <LINE> <line7>	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void stopMonitoring( <line2> final String handlerId, <line3> final AlertHandlerPriority handlerPriority, <line4> final String environmentId) <line5> throws EnvironmentManagerException { <line6> Preconditions.checkArgument(!StringUtils.isBlank(handlerId), ""Invalid alert handler id.""); <line7> Preconditions.checkNotNull(handlerPriority, ""Invalid alert priority.""); <line8> try { <line9> LocalEnvironment environment = environmentService.find(environmentId); <line10> environment.removeAlertHandler(new EnvironmentAlertHandlerImpl(handlerId, handlerPriority)); <line11> update(environment); <line12> } catch (Exception e) { <line13> throw new EnvironmentManagerException(e.getMessage(), e); <line14> } <line15> } <line16> } <line17>  <LINE> <line9>"	No	task2	
"<CODE> public class A { <line0> @Test <line1> public void proxyApiAccess() { <line2> ProxyConfig.ProxyConfigBuilder proxy = new ProxyConfig.ProxyConfigBuilder(); <line3> proxy.useSSL(true); <line4> proxy.setHost(""localhost""); <line5> proxy.setPort(proxyPort); <line6> proxy.setUser(PROXY_USER); <line7> proxy.setPassword(PROXY_PASS); <line8> TDClient client = TDClient.newBuilder().setProxy(proxy.createProxyConfig()).build(); <line9> try { <line10> client.serverStatus(); <line11> List<TDTable> tableList = client.listTables(""sample_datasets""); <line12> assertTrue(tableList.size() >= 2); <line13> TDJobList jobList = client.listJobs(); <line14> assertTrue(jobList.getJobs().size() > 0); <line15> } finally { <line16> assertEquals(1, proxyAccessCount.get()); <line17> } <line18> } <line19> } <line20>  <LINE> <line2>"	No	task2	
<CODE> public class A { <line0> @Override <line1> public void endTable() throws DataSetException { <line2> try { <line3> out.write(NEW_LINE); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8>  <LINE> <line7>	No	task2	
<CODE> public class A { <line0> @Override <line1> public void setMaxPhenomenonTimeForProcedure(String procedure, DateTime maxTime) { <line2> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line3> if (maxTime == null) { <line4> this.maxPhenomenonTimeForProcedures.remove(procedure); <line5> } else { <line6> this.maxPhenomenonTimeForProcedures.put(procedure, DateTimeHelper.toUTC(maxTime)); <line7> } <line8> } <line9> } <line10>  <LINE> <line3>	Yes	task2	
"<CODE> public class A { <line0> @Test( <line1> groups = {""wso2.cep""}, <line2> description = ""Testing logger connection"", <line3> expectedExceptions = AxisFault.class) <line4> public void testConnection() throws AxisFault { <line5> BasicOutputAdapterPropertyDto[] outputPropertyConfiguration = <line6> new BasicOutputAdapterPropertyDto[] {}; <line7> try { <line8> eventPublisherAdminServiceClient.testConnection( <line9> ""logger"", ""logger"", outputPropertyConfiguration, ""xml""); <line10> } catch (AxisFault e) { <line11> throw new AxisFault(e.getMessage(), e); <line12> } catch (RemoteException e) { <line13> Assert.fail(""Exception: "" + e.getMessage()); <line14> } <line15> } <line16> } <line17>  <LINE> <line13>"	Yes	task2	
"<CODE> public class A { <line0> protected void loadQrelsFile() { <line1> List<QrelsHashSet> vector = new ArrayList<QrelsHashSet>(); <line2> int linenumber = 0; <line3> String file = null; <line4> try { <line5> int qrelsCounter = 0; <line6> BufferedReader br = Files.openFileReader(file = fqrels[0].toString()); <line7> String preQueryid = ""1st""; <line8> linenumber = 0; <line9> QrelsHashSet qrelsHashSet = null; <line10> String str = null; <line11> while ((str = br.readLine()) != null || qrelsCounter != fqrels.length - 1) { <line12> if (str == null) { <line13> br.close(); <line14> br = Files.openFileReader(file = fqrels[++qrelsCounter].toString()); <line15> linenumber = 0; <line16> continue; <line17> } <line18> linenumber++; <line19> if (str.startsWith(""#"")) continue; <line20> if (str.trim().length() == 0) continue; <line21> StringTokenizer stk = new StringTokenizer(str); <line22> String queryid = parseTRECQueryNo(stk.nextToken()); <line23> stk.nextToken(); <line24> String docno = stk.nextToken(); <line25> int relGrade = Integer.parseInt(stk.nextToken()); <line26> boolean relevant = (relGrade > 0); <line27> if (!queryid.equals(preQueryid)) { <line28> if (preQueryid.equals(""1st"")) { <line29> qrelsHashSet = new QrelsHashSet(queryid); <line30> if (relevant) { <line31> qrelsHashSet.insertRelDocno(docno, relGrade); <line32> } else qrelsHashSet.insertNonRelDocno(docno); <line33> preQueryid = queryid; <line34> } else { <line35> vector.add((QrelsHashSet) qrelsHashSet.clone()); <line36> qrelsHashSet = new QrelsHashSet(queryid); <line37> if (relevant) qrelsHashSet.insertRelDocno(docno, relGrade); <line38> else qrelsHashSet.insertNonRelDocno(docno); <line39> preQueryid = queryid; <line40> } <line41> } else { <line42> if (relevant) qrelsHashSet.insertRelDocno(docno, relGrade); <line43> else qrelsHashSet.insertNonRelDocno(docno); <line44> } <line45> } <line46> vector.add((QrelsHashSet) qrelsHashSet.clone()); <line47> br.close(); <line48> } catch (Exception t) { <line49> throw new Error(t); <line50> } <line51> this.qrelsPerQuery = vector.toArray(new QrelsHashSet[vector.size()]); <line52> this.totalNumberOfRelevantDocs = 0; <line53> for (QrelsHashSet querySet : this.qrelsPerQuery) { <line54> this.qid2qrels.put(querySet.queryid, querySet); <line55> this.totalNumberOfRelevantDocs += querySet.getAllRelevantDocuments().size(); <line56> } <line57> } <line58> } <line59>  <LINE> <line49>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public synchronized void validate() throws ValidationException { <line2> try { <line3> super.validate(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8>  <LINE> <line4>	No	task2	
<CODE> public class A { <line0> public synchronized void stopAgent() { <line1> if (!this.running) { <line2> return; <line3> } <line4> if (logger.isDebugEnabled()) { <line5> } <line6> try { <line7> jmxConnectorServer.stop(); <line8> UnicastRemoteObject.unexportObject(registry, true); <line9> } catch (Exception e) { <line10> throw new ManagementException(e); <line11> } <line12> this.running = false; <line13> } <line14> } <line15>  <LINE> <line12>	No	task2	
<CODE> public class A { <line0> private boolean readCommitsEnabled(String commitEnabled) { <line1> boolean isCommitEnabled = false; <line2> try { <line3> isCommitEnabled = Boolean.parseBoolean(readParameterValue(commitEnabled)); <line4> } catch (ParameterNotFoundException e) { <line5> } <line6> return isCommitEnabled; <line7> } <line8> } <line9>  <LINE> <line5>	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void render(RenderRequest renderRequest, RenderResponse renderResponse) <line2> throws IOException, PortletException { <line3> try { <line4> CPAssetCategoriesNavigationDisplayContext cpAssetCategoryNavigationDisplayContext = <line5> new CPAssetCategoriesNavigationDisplayContext( <line6> _portal.getHttpServletRequest(renderRequest), <line7> _assetCategoryService, <line8> _assetVocabularyService, <line9> _commerceMediaResolver, <line10> _cpAttachmentFileEntryService, <line11> _cpFriendlyURL, <line12> _friendlyURLEntryLocalService, <line13> _portal); <line14> renderRequest.setAttribute( <line15> WebKeys.PORTLET_DISPLAY_CONTEXT, cpAssetCategoryNavigationDisplayContext); <line16> } catch (Exception exception) { <line17> } <line18> super.render(renderRequest, renderResponse); <line19> } <line20> } <line21>  <LINE> <line17>	Yes	task2	
<CODE> public class A { <line0> private void rollback(Connection connection) { <line1> try { <line2> connection.rollback(); <line3> } catch (Exception rollbackException) { <line4> } <line5> } <line6> } <line7>  <LINE> <line0>	No	task2	
"<CODE> public class A { <line0> private void initPropsFromResource() { <line1> var resourceProps = new Properties(); <line2> load(BOOTSTRAP_PROPS_RESOURCE, resourceProps); <line3> loadOverride(BOOTSTRAP_OVERRIDE_PROPS_LOC, resourceProps, fileStreamProvider, log); <line4> Set<String> unrecognizedProps = new HashSet<>(resourceProps.stringPropertyNames()); <line5> unrecognizedProps.removeAll(BOOTSTRAP_PROP_NAMES); <line6> if (!unrecognizedProps.isEmpty()) { <line7> var msg = <line8> String.format( <line9> ""'%s' contains unrecognized properties: %s!"", <line10> BOOTSTRAP_PROPS_RESOURCE, unrecognizedProps); <line11> throw new IllegalStateException(msg); <line12> } <line13> var missingProps = <line14> BOOTSTRAP_PROP_NAMES.stream() <line15> .filter(name -> !resourceProps.containsKey(name)) <line16> .sorted() <line17> .collect(toList()); <line18> if (!missingProps.isEmpty()) { <line19> var msg = <line20> String.format(""'%s' is missing properties: %s!"", BOOTSTRAP_PROPS_RESOURCE, missingProps); <line21> throw new IllegalStateException(msg); <line22> } <line23> bootstrapProps = new HashMap<>(); <line24> BOOTSTRAP_PROP_NAMES.stream() <line25> .forEach( <line26> prop -> <line27> bootstrapProps.put( <line28> prop, transformFor(prop).apply(resourceProps.getProperty(prop)))); <line29> var msg = <line30> ""Resolved bootstrap properties:\n  "" <line31> + BOOTSTRAP_PROP_NAMES.stream() <line32> .sorted() <line33> .map(name -> String.format(""%s=%s"", name, bootstrapProps.get(name))) <line34> .collect(Collectors.joining(""\n  "")); <line35> } <line36> } <line37>  <LINE> <line35>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void deleteApplication(String applicationName) { <line2> delegate.deleteApplication(applicationName); <line3> } <line4> } <line5>  <LINE> <line2>	Yes	task2	
<CODE> public class A { <line0> public DIP createDIP(DIP dip, boolean notify) <line1> throws GenericException, AuthorizationDeniedException { <line2> RodaCoreFactory.checkIfWriteIsAllowedAndIfFalseThrowException(nodeType); <line3> try { <line4> Directory directory; <line5> if (StringUtils.isNotBlank(dip.getId())) { <line6> try { <line7> directory = <line8> storage.createDirectory( <line9> DefaultStoragePath.parse(RodaConstants.STORAGE_CONTAINER_DIP, dip.getId())); <line10> } catch (AlreadyExistsException | GenericException | AuthorizationDeniedException e) { <line11> directory = <line12> storage.createRandomDirectory( <line13> DefaultStoragePath.parse(RodaConstants.STORAGE_CONTAINER_DIP)); <line14> dip.setId(directory.getStoragePath().getName()); <line15> } <line16> } else { <line17> directory = <line18> storage.createRandomDirectory( <line19> DefaultStoragePath.parse(RodaConstants.STORAGE_CONTAINER_DIP)); <line20> dip.setId(directory.getStoragePath().getName()); <line21> } <line22> dip.setDateCreated(new Date()); <line23> dip.setLastModified(new Date()); <line24> createDIPMetadata(dip, directory.getStoragePath()); <line25> if (notify) { <line26> notifyDIPCreated(dip, false).failOnError(); <line27> } <line28> return dip; <line29> } catch (NotFoundException | RequestNotValidException | AlreadyExistsException e) { <line30> throw new GenericException(e); <line31> } <line32> } <line33> } <line34>  <LINE> <line30>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public String getSubEquipmentConfigXML(final SubEquipmentCacheObject subEquipmentCacheObject) { <line2> StringBuilder str = new StringBuilder(""    <SubEquipmentUnit  id=\""""); <line3> str.append(subEquipmentCacheObject.getId()); <line4> str.append(""\"" name=\""""); <line5> str.append(subEquipmentCacheObject.getName()); <line6> str.append(""\"">\n""); <line7> str.append(""      <commfault-tag-id>""); <line8> str.append(subEquipmentCacheObject.getCommFaultTagId()); <line9> str.append(""</commfault-tag-id>\n""); <line10> str.append(""      <commfault-tag-value>""); <line11> str.append(subEquipmentCacheObject.getCommFaultTagValue()); <line12> str.append(""</commfault-tag-value>\n""); <line13> str.append(""      <alive-tag-id>""); <line14> str.append(subEquipmentCacheObject.getAliveTagId()); <line15> str.append(""</alive-tag-id>\n""); <line16> str.append(""      <alive-interval>""); <line17> str.append(subEquipmentCacheObject.getAliveInterval()); <line18> str.append(""</alive-interval>\n""); <line19> str.append(""    </SubEquipmentUnit>\n""); <line20> return str.toString(); <line21> } <line22> } <line23>  <LINE> <line2>"	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> public void testLogin() throws Exception { <line2> LoginContext context = <line3> new LoginContext( <line4> ""LDAPLogin"", <line5> new CallbackHandler() { <line6> @Override <line7> public void handle(Callback[] callbacks) <line8> throws IOException, UnsupportedCallbackException { <line9> for (int i = 0; i < callbacks.length; i++) { <line10> if (callbacks[i] instanceof NameCallback) { <line11> ((NameCallback) callbacks[i]).setName(""first""); <line12> } else if (callbacks[i] instanceof PasswordCallback) { <line13> ((PasswordCallback) callbacks[i]).setPassword(""secret"".toCharArray()); <line14> } else { <line15> throw new UnsupportedCallbackException(callbacks[i]); <line16> } <line17> } <line18> } <line19> }); <line20> context.login(); <line21> context.logout(); <line22> assertTrue( <line23> ""sessions still active after logout"", <line24> waitFor(() -> ldapServer.getLdapSessionManager().getSessions().length == 0)); <line25> } <line26> } <line27>  <LINE> <line2>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public void update(EventBean[] arg0, EventBean[] arg1) { <line2> for (EventBean bean : arg0) { <line3> try { <line4> beanForwardQueue.put(bean); <line5> } catch (InterruptedException e) { <line6> return; <line7> } <line8> } <line9> } <line10> } <line11>  <LINE> <line6>	Yes	task2	
"<CODE> public class A { <line0> @Override <line1> public void onSubscriptionTransferFailed( <line2> final UaSubscription subscription, final StatusCode statusCode) { <line3> handleConnectionFailue(new RuntimeException(""Subscription failed to reconnect"")); <line4> } <line5> } <line6>  <LINE> <line2>"	No	task2	
"<CODE> public class A { <line0> @Override <line1> public void doMonitor(ServiceEmitter emitter) { <line2> final CacheStats oldStats = priorStats.get(); <line3> final CacheStats newStats = cache.stats(); <line4> final CacheStats deltaStats = newStats.minus(oldStats); <line5> final ServiceMetricEvent.Builder builder = ServiceMetricEvent.builder(); <line6> emitter.emit(builder.build(""query/cache/caffeine/delta/requests"", deltaStats.requestCount())); <line7> emitter.emit(builder.build(""query/cache/caffeine/total/requests"", newStats.requestCount())); <line8> emitter.emit(builder.build(""query/cache/caffeine/delta/loadTime"", deltaStats.totalLoadTime())); <line9> emitter.emit(builder.build(""query/cache/caffeine/total/loadTime"", newStats.totalLoadTime())); <line10> emitter.emit( <line11> builder.build(""query/cache/caffeine/delta/evictionBytes"", deltaStats.evictionWeight())); <line12> emitter.emit( <line13> builder.build(""query/cache/caffeine/total/evictionBytes"", newStats.evictionWeight())); <line14> if (!priorStats.compareAndSet(oldStats, newStats)) { <line15> } <line16> } <line17> } <line18>  <LINE> <line15>"	Yes	task2	
<CODE> public class A { <line0> @Override <line1> public List<Notification> getNotifications(List<String> notificationIds) { <line2> return notificationStore <line3> .map(s -> s.getNotifications(notificationIds)) <line4> .orElse(Collections.emptyList()); <line5> } <line6> } <line7>  <LINE> <line3>	No	task2	
"<CODE> public class A { <line0> public List<ActivityFrequencyScheduleBean> getQuestionnaireFrequencyDetailsForWeekly( <line1> QuestionnairesDto questionaire, List<ActivityFrequencyScheduleBean> runDetailsBean) <line2> throws DAOException { <line3> LOGGER.entry(""begin getQuestionnaireFrequencyDetailsForWeekly()""); <line4> try { <line5> if (StringUtils.isNotEmpty(questionaire.getStudyLifetimeStart()) <line6> && StringUtils.isNotEmpty(questionaire.getStudyLifetimeEnd()) <line7> && StringUtils.isNotEmpty(questionaire.getDayOfTheWeek())) { <line8> Integer repeatCount = <line9> ((questionaire.getRepeatQuestionnaire() == null) <line10> || (questionaire.getRepeatQuestionnaire() == 0)) <line11> ? 1 <line12> : questionaire.getRepeatQuestionnaire(); <line13> String questionaireDay = questionaire.getDayOfTheWeek(); <line14> String questionaireStartDate = questionaire.getStudyLifetimeStart(); <line15> while (repeatCount > 0) { <line16> ActivityFrequencyScheduleBean weeklyBean = new ActivityFrequencyScheduleBean(); <line17> String questionaireEndDate; <line18> String day = """"; <line19> String weekEndDate; <line20> boolean flag = false; <line21> boolean skipLoop = false; <line22> if (questionaireDay.equalsIgnoreCase( <line23> StudyMetaDataUtil.getDayByDate(questionaireStartDate))) { <line24> day = questionaireDay; <line25> } <line26> if (!questionaireDay.equalsIgnoreCase(day)) { <line27> while (!questionaireDay.equalsIgnoreCase(day)) { <line28> questionaireStartDate = StudyMetaDataUtil.addDaysToDate(questionaireStartDate, 1); <line29> day = StudyMetaDataUtil.getDayByDate(questionaireStartDate); <line30> } <line31> } <line32> weekEndDate = StudyMetaDataUtil.addWeeksToDate(questionaireStartDate, 1); <line33> if ((StudyMetaDataConstants.SDF_DATE <line34> .parse(StudyMetaDataUtil.getCurrentDate()) <line35> .equals(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate))) <line36> || (StudyMetaDataConstants.SDF_DATE <line37> .parse(StudyMetaDataUtil.getCurrentDate()) <line38> .before(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate)))) { <line39> flag = true; <line40> } <line41> if (flag) { <line42> questionaireEndDate = weekEndDate; <line43> if ((StudyMetaDataConstants.SDF_DATE <line44> .parse(weekEndDate) <line45> .equals( <line46> StudyMetaDataConstants.SDF_DATE.parse(questionaire.getStudyLifetimeEnd()))) <line47> || (StudyMetaDataConstants.SDF_DATE <line48> .parse(weekEndDate) <line49> .after( <line50> StudyMetaDataConstants.SDF_DATE.parse( <line51> questionaire.getStudyLifetimeEnd())))) { <line52> questionaireEndDate = questionaire.getStudyLifetimeEnd(); <line53> skipLoop = true; <line54> } <line55> weeklyBean.setStartTime(questionaireStartDate); <line56> weeklyBean.setEndTime(questionaireEndDate); <line57> runDetailsBean.add(weeklyBean); <line58> if (skipLoop) { <line59> break; <line60> } <line61> } <line62> questionaireStartDate = weekEndDate; <line63> questionaireDay = day; <line64> repeatCount--; <line65> } <line66> } <line67> } catch (Exception e) { <line68> } <line69> LOGGER.exit(""getQuestionnaireFrequencyDetailsForWeekly() :: Ends""); <line70> return runDetailsBean; <line71> } <line72> } <line73>  <LINE> <line0>"	No	task2	
<CODE> public class A { <line0> public void startup() { <line1> transientProducerScheduler.start(); <line2> for (CloudJobConfigurationPOJO each : configService.loadAll()) { <line3> schedule(each); <line4> } <line5> } <line6> } <line7>  <LINE> <line1>	Yes	task2	
<CODE> public class A { <line0> private String[] resolvePlaceholders(String value) { <line1> String resolved = resolver.resolvePlaceholders(value); <line2> if (StringUtils.isBlank(resolved)) { <line3> return StringUtils.EMPTY_STRING_ARRAY; <line4> } <line5> return StringUtils.split(resolved, ','); <line6> } <line7> } <line8>  <LINE> <line6>	No	task2	
"<CODE> public class A { <line0> private Transformer createTransformer() { <line1> try { <line2> Transformer transformer = transformerFactory.newTransformer(); <line3> transformer.setOutputProperty(OutputKeys.INDENT, ""yes""); <line4> transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes""); <line5> transformer.setOutputProperty(""{http://xml.apache.org/xslt}indent-amount"", ""2""); <line6> return transformer; <line7> } catch (TransformerConfigurationException e) { <line8> throw new IllegalStateException(e.getMessage()); <line9> } <line10> } <line11> } <line12>  <LINE> <line8>"	Yes	task2	
"<CODE> public class A { <line0> @Test <line1> public void testPut() throws Exception { <line2> try { <line3> HBaseTestHelper.startLocalCluster(); <line4> HBaseTestHelper.clearHBase(); <line5> HBaseNameValueCsvPutOperator propPutOperator = new HBaseNameValueCsvPutOperator(); <line6> propPutOperator.getStore().setTableName(""table1""); <line7> propPutOperator.getStore().setZookeeperQuorum(""127.0.0.1""); <line8> propPutOperator.getStore().setZookeeperClientPort(2181); <line9> String s = ""name=milind,st=patrick,ct=fremont,sa=cali""; <line10> String s1 = ""st=tasman,ct=sancla,name=milinda,sa=cali""; <line11> propPutOperator.setMapping(""name=row,st=colfam0.street,ct=colfam0.city,sa=colfam0.state""); <line12> propPutOperator.setup(mockOperatorContext(0)); <line13> propPutOperator.beginWindow(0); <line14> propPutOperator.input.process(s); <line15> propPutOperator.input.process(s1); <line16> propPutOperator.endWindow(); <line17> HBaseTuple tuple; <line18> tuple = HBaseTestHelper.getHBaseTuple(""milind"", ""colfam0"", ""street""); <line19> Assert.assertNotNull(""Tuple"", tuple); <line20> Assert.assertEquals(""Tuple row"", tuple.getRow(), ""milind""); <line21> Assert.assertEquals(""Tuple column family"", tuple.getColFamily(), ""colfam0""); <line22> Assert.assertEquals(""Tuple column name"", tuple.getColName(), ""street""); <line23> Assert.assertEquals(""Tuple column value"", tuple.getColValue(), ""patrick""); <line24> } catch (IOException e) { <line25> } <line26> } <line27> } <line28>  <LINE> <line25>"	Yes	task2	
<CODE> public class A { <line0> private int cacheMessages(FacesContext context) { <line1> int cachedCount = 0; <line2> Iterator<String> clientIdsWithMessages = context.getClientIdsWithMessages(); <line3> while (clientIdsWithMessages.hasNext()) { <line4> String clientId = clientIdsWithMessages.next(); <line5> Iterator<FacesMessage> iterator = context.getMessages(clientId); <line6> Collection<FacesMessage> cachedMessages = getMessageCache(context).get(clientId); <line7> if (cachedMessages == null) { <line8> cachedMessages = new ArrayList<FacesMessage>(); <line9> getMessageCache(context).put(clientId, cachedMessages); <line10> } <line11> while (iterator.hasNext()) { <line12> FacesMessage facesMessage = iterator.next(); <line13> if (cachedMessages.add(facesMessage)) { <line14> cachedCount++; <line15> } <line16> } <line17> } <line18> return cachedCount; <line19> } <line20> } <line21>  <LINE> <line14>	No	task2	
"<CODE> public class A { <line0> private void updateInternalConfig(AjaxRequestTarget target) { <line1> getModelObject().saveInternalsConfig(); <line2> success( <line3> getString( <line4> ""PageInternals.message.internalsConfigUpdate"", <line5> InternalsConfig.consistencyChecks, <line6> InternalsConfig.encryptionChecks, <line7> InternalsConfig.readEncryptionChecks, <line8> QNameUtil.isTolerateUndeclaredPrefixes())); <line9> target.add(getPageBase().getFeedbackPanel(), getForm()); <line10> } <line11> } <line12>  <LINE> <line4>"	No	task2	
"public class A { <line0> @Test <line1> public void testEchoMethodInvocation() throws Exception { <line2> Work echoResult = <line3> thriftClient.echo(new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY)); <line4> MockEndpoint mockEndpoint = getMockEndpoint(""mock:thrift-secure-service""); <line5> mockEndpoint.expectedMessageCount(1); <line6> mockEndpoint.expectedHeaderValuesReceivedInAnyOrder( <line7> ThriftConstants.THRIFT_METHOD_NAME_HEADER, ""echo""); <line8> mockEndpoint.assertIsSatisfied(); <line9> assertNotNull(echoResult); <line10> assertTrue(echoResult instanceof Work); <line11> assertEquals(THRIFT_TEST_NUM1, echoResult.num1); <line12> assertEquals(Operation.MULTIPLY, echoResult.op); <line13> } <line14> } <line15> "	1	task3	
"public class A { <line0> private void createCache2(Ignite ig, CacheAtomicityMode mode) { <line1> final CacheConfiguration<Integer, Organization> cfg = new CacheConfiguration<>(""Org"" + ""11""); <line2> cfg.setAtomicityMode(mode); <line3> final IgniteCache<Integer, Organization> cache = <line4> ig.getOrCreateCache(cfg).withKeepBinary().withAllowAtomicOpsInTx(); <line5> try (Transaction tx = ig.transactions().txStart()) { <line6> for (int i = 0; i < 10; i++) { <line7> cache.put(i, new Organization(i, ""Organization-"" + i)); <line8> if (i % 2 == 0) cache.put(i, new Organization(i, ""Organization-updated-"" + i)); <line9> if (i % 5 == 0) cache.remove(i); <line10> } <line11> tx.commit(); <line12> } <line13> } <line14> } <line15> "	1	task3	
public class A { <line0> @Override <line1> public void stop() { <line2> dockerClient.stopContainerCmd(getContainerId()).exec(); <line3> super.stop(); <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> @Override <line1> public AnnouncementsEntry findByPrimaryKey(Serializable primaryKey) throws NoSuchEntryException { <line2> AnnouncementsEntry announcementsEntry = fetchByPrimaryKey(primaryKey); <line3> if (announcementsEntry == null) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchEntryException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return announcementsEntry; <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> public String delete() throws Exception { <line1> if (update) { <line2> try { <line3> groupService.removeGroup(this.group); <line4> oxTrustAuditService.audit( <line5> ""GROUP "" + this.group.getInum() + "" **"" + this.group.getDisplayName() + ""** REMOVED"", <line6> identity.getUser(), <line7> (HttpServletRequest) <line8> FacesContext.getCurrentInstance().getExternalContext().getRequest()); <line9> facesMessages.add( <line10> FacesMessage.SEVERITY_INFO, <line11> ""Group '#{updateGroupAction.group.displayName}' removed successfully""); <line12> conversationService.endConversation(); <line13> return OxTrustConstants.RESULT_SUCCESS; <line14> } catch (BasePersistenceException ex) { <line15> } <line16> } <line17> facesMessages.add( <line18> FacesMessage.SEVERITY_ERROR, <line19> ""Failed to remove group '#{updateGroupAction.group.displayName}'""); <line20> return OxTrustConstants.RESULT_FAILURE; <line21> } <line22> } <line23> "	1	task3	
public class A { <line0> private static void tryDimensionAsMeasures( <line1> Collection<FunctionDesc> unmatchedAggregations, <line2> CapabilityResult result, <line3> Set<TblColRef> dimCols) { <line4> Iterator<FunctionDesc> it = unmatchedAggregations.iterator(); <line5> while (it.hasNext()) { <line6> FunctionDesc functionDesc = it.next(); <line7> if (functionDesc.isCount()) { <line8> it.remove(); <line9> continue; <line10> } <line11> ParameterDesc parameterDesc = functionDesc.getParameter(); <line12> if (parameterDesc == null) { <line13> continue; <line14> } <line15> List<TblColRef> neededCols = <line16> functionDesc instanceof ExpressionDynamicFunctionDesc <line17> ? Lists.newArrayList( <line18> ExpressionColCollector.collectColumns( <line19> ((ExpressionDynamicFunctionDesc) functionDesc).getTupleExpression())) <line20> : parameterDesc.getColRefs(); <line21> if (neededCols.size() > 0 <line22> && dimCols.containsAll(neededCols) <line23> && FunctionDesc.BUILT_IN_AGGREGATIONS.contains(functionDesc.getExpression())) { <line24> result.influences.add(new CapabilityResult.DimensionAsMeasure(functionDesc)); <line25> it.remove(); <line26> continue; <line27> } <line28> } <line29> } <line30> } <line31> 	1	task3	
"public class A { <line0> private void capabilitiesAndRespond( <line1> CentralRequest request, StreamObserver<AgentResponse> responseObserver) { <line2> Capabilities capabilities; <line3> try { <line4> capabilities = liveJvmService.getCapabilities(""""); <line5> } catch (Exception e) { <line6> sendExceptionResponse(request, responseObserver); <line7> return; <line8> } <line9> responseObserver.onNext( <line10> AgentResponse.newBuilder() <line11> .setRequestId(request.getRequestId()) <line12> .setCapabilitiesResponse( <line13> CapabilitiesResponse.newBuilder().setCapabilities(capabilities)) <line14> .build()); <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> private void runRestore() { <line1> try { <line2> backupManager.restoreWorkspaceBackup(WORKSPACE_ID, CONTAINER_ID, NODE_HOST); <line3> } catch (ServerException | EnvironmentException e) { <line4> } <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> @Deprecated <line1> public void setPdfOcr(boolean pdfOcr) { <line2> String strategy; <line3> if (pdfOcr) { <line4> strategy = ""ocr_and_text""; <line5> } else { <line6> strategy = ""no_ocr""; <line7> } <line8> if (this.ocr == null) { <line9> this.ocr = new Ocr(); <line10> } <line11> this.ocr.setPdfStrategy(strategy); <line12> } <line13> } <line14> "	1	task3	
"public class A { <line0> @ApiOperation(value = ""delete securityProfile"") <line1> @DeleteMapping(CommonConstants.PATH_ID) <line2> public void delete(final @PathVariable String id) { <line3> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line4> service.delete(buildUiHttpContext(), id); <line5> } <line6> } <line7> "	1	task3	
"public class A { <line0> private void handleCommand(MetaCommand cmd) throws IOException { <line1> if (cmd == null) { <line2> return; <line3> } <line4> switch (cmd) { <line5> case MetaCommand_Nothing: <line6> break; <line7> case MetaCommand_Register: <line8> setIdAndRegister(); <line9> break; <line10> case MetaCommand_Unknown: <line11> break; <line12> default: <line13> throw new RuntimeException(""Un-recognized command from leader master "" + cmd); <line14> } <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> public static Object object(Class<?> type, byte[] bytes) { <line1> try { <line2> if (Long.class.isAssignableFrom(type)) { <line3> return getLong(bytes); <line4> } else if (UUID.class.isAssignableFrom(type)) { <line5> return uuid(bytes); <line6> } else if (String.class.isAssignableFrom(type)) { <line7> return string(bytes); <line8> } else if (Boolean.class.isAssignableFrom(type)) { <line9> return getBoolean(bytes); <line10> } else if (Integer.class.isAssignableFrom(type)) { <line11> return getInt(bytes); <line12> } else if (Double.class.isAssignableFrom(type)) { <line13> return getDouble(bytes); <line14> } else if (Float.class.isAssignableFrom(type)) { <line15> return getFloat(bytes); <line16> } else if (byte[].class.isAssignableFrom(type)) { <line17> return bytes; <line18> } <line19> } catch (Exception e) { <line20> } <line21> return null; <line22> } <line23> } <line24> 	1	task3	
public class A { <line0> private InetAddress getAddressByName(String host) { <line1> try { <line2> return InetAddress.getByName(host); <line3> } catch (Exception e) { <line4> return null; <line5> } <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> private static final String generateServiceBundles(File tenantConfigFile) { <line1> String result = null; <line2> ServiceConfigGeneration xsdMetadata = null; <line3> try { <line4> xsdMetadata = <line5> new ServiceConfigGeneration( <line6> serviceBundlesInfo, <line7> tenantConfigFile, <line8> CommonAPI.GENERATE_BUNDLES, <line9> SERVICE_SCHEMA_VERSION, <line10> getBundlesOutputDir(), <line11> SERVICE_BINDINGS_VERSION, <line12> getBindingsOutputDir()); <line13> serviceBundlesInfo.put(tenantConfigFile.getName(), xsdMetadata); <line14> dumpServiceArtifactMetadata(tenantConfigFile, xsdMetadata); <line15> } catch (Exception e) { <line16> result = <line17> String.format( <line18> ""Error encountered generating service bindings for '%s' tenant configuration."", <line19> tenantConfigFile.getAbsolutePath()); <line20> } <line21> return result; <line22> } <line23> } <line24> "	1	task3	
"public class A { <line0> @Override <line1> public boolean updateState( <line2> com.cloud.storage.Volume.State currentState, <line3> Event event, <line4> com.cloud.storage.Volume.State nextState, <line5> Volume vo, <line6> Object data) { <line7> Long oldUpdated = vo.getUpdatedCount(); <line8> Date oldUpdatedTime = vo.getUpdated(); <line9> SearchCriteria<VolumeVO> sc = AllFieldsSearch.create(); <line10> sc.setParameters(""id"", vo.getId()); <line11> sc.setParameters(""state"", currentState); <line12> sc.setParameters(""updatedCount"", vo.getUpdatedCount()); <line13> vo.incrUpdatedCount(); <line14> UpdateBuilder builder = getUpdateBuilder(vo); <line15> builder.set(vo, ""state"", nextState); <line16> builder.set(vo, ""updated"", new Date()); <line17> int rows = update((VolumeVO) vo, sc); <line18> if (rows == 0 && logger.isDebugEnabled()) { <line19> VolumeVO dbVol = findByIdIncludingRemoved(vo.getId()); <line20> if (dbVol != null) { <line21> StringBuilder str = new StringBuilder(""Unable to update "").append(vo.toString()); <line22> str.append("": DB Data={id="") <line23> .append(dbVol.getId()) <line24> .append(""; state="") <line25> .append(dbVol.getState()) <line26> .append(""; updatecount="") <line27> .append(dbVol.getUpdatedCount()) <line28> .append("";updatedTime="") <line29> .append(dbVol.getUpdated()); <line30> str.append("": New Data={id="") <line31> .append(vo.getId()) <line32> .append(""; state="") <line33> .append(nextState) <line34> .append(""; event="") <line35> .append(event) <line36> .append(""; updatecount="") <line37> .append(vo.getUpdatedCount()) <line38> .append(""; updatedTime="") <line39> .append(vo.getUpdated()); <line40> str.append("": stale Data={id="") <line41> .append(vo.getId()) <line42> .append(""; state="") <line43> .append(currentState) <line44> .append(""; event="") <line45> .append(event) <line46> .append(""; updatecount="") <line47> .append(oldUpdated) <line48> .append(""; updatedTime="") <line49> .append(oldUpdatedTime); <line50> } else { <line51> } <line52> } <line53> return rows > 0; <line54> } <line55> } <line56> "	1	task3	
"public class A { <line0> public void sendEndStatus(int exit, String rebalanceSource, String rebalanceTarget) { <line1> TaskExitState exitState = new TaskExitState(); <line2> File jobExit = new File(jobDir, ""job.exit""); <line3> if (jobExit.exists() && jobExit.canRead()) { <line4> try { <line5> CodecJSON.INSTANCE.decode(exitState, LessFiles.read(jobExit)); <line6> } catch (Exception ex) { <line7> ex.printStackTrace(); <line8> } <line9> } <line10> exitState.setWasStopped(wasStopped()); <line11> StatusTaskEnd end = new StatusTaskEnd(minion.uuid, id, node, exit, fileCount, fileBytes); <line12> end.setRebalanceSource(rebalanceSource); <line13> end.setRebalanceTarget(rebalanceTarget); <line14> end.setWasQueued(wasQueued); <line15> end.setExitState(exitState); <line16> setRebalanceSource(null); <line17> setRebalanceTarget(null); <line18> Minion.tasksCompletedPerHour.mark(); <line19> minion.sendStatusMessage(end); <line20> try { <line21> minion.kickNextJob(); <line22> } catch (Exception e) { <line23> } <line24> } <line25> } <line26> "	1	task3	
public class A { <line0> private OAuthPluginException createNoAuthException( <line1> OAuthFederatedSource oauthSource, <line2> String sessionId, <line3> OIDCProviderMetadata metadata, <line4> String reason) <line5> throws StopProcessingException { <line6> String state = UUID.randomUUID().toString(); <line7> Map<String, Object> stateMap = new HashMap<>(); <line8> stateMap.put(SOURCE_ID, oauthSource.getId()); <line9> stateMap.put(CLIENT_ID, oauthSource.getOauthClientId()); <line10> stateMap.put(SECRET, oauthSource.getOauthClientSecret()); <line11> stateMap.put(DISCOVERY_URL, oauthSource.getOauthDiscoveryUrl()); <line12> stateMap.put(EXPIRES_AT, Instant.now().plus(STATE_EXP, ChronoUnit.MINUTES).getEpochSecond()); <line13> tokenStorage.getStateMap().put(state, stateMap); <line14> Map<String, String> parameters = new HashMap<>(); <line15> parameters.put(RESPONSE_TYPE, CODE_FLOW); <line16> parameters.put(CLIENT_ID_PARAM, oauthSource.getOauthClientId()); <line17> parameters.put(SCOPE, OPENID_SCOPE); <line18> parameters.put(REDIRECT_URI, OAUTH_REDIRECT_URL); <line19> parameters.put(STATE, state); <line20> String url = metadata.getAuthorizationEndpointURI().toString(); <line21> return new OAuthPluginException( <line22> oauthSource.getId(), buildUrl(url, parameters), url, parameters, NO_AUTH); <line23> } <line24> } <line25> 	1	task3	
"public class A { <line0> @Reference( <line1> cardinality = ReferenceCardinality.MULTIPLE, <line2> policy = ReferencePolicy.DYNAMIC, <line3> policyOption = ReferencePolicyOption.GREEDY) <line4> protected synchronized void setConfigurationProvider( <line5> ConfigurationProvider<?> configurationProvider, Map<String, Object> properties) { <line6> String factoryPid = MapUtil.getString(properties, ""factoryPid""); <line7> if (Validator.isNull(factoryPid)) { <line8> throw new IllegalArgumentException( <line9> ""No factory PID specified for configuration provider "" + configurationProvider); <line10> } <line11> _configurationProviders.put(factoryPid, configurationProvider); <line12> try { <line13> Configuration[] configurations = <line14> _configurationAdmin.listConfigurations(""(service.factoryPid="" + factoryPid + ""*)""); <line15> if (configurations != null) { <line16> for (Configuration configuration : configurations) { <line17> configurationProvider.registerConfiguration(configuration); <line18> } <line19> } <line20> } catch (Exception exception) { <line21> if (log.isWarnEnabled()) { <line22> } <line23> } <line24> } <line25> } <line26> "	1	task3	
public class A { <line0> protected void removeChild(String child) { <line1> this.children.remove(child); <line2> zk.unwatchData(getPath(child)); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> public static boolean isAccessAllowed(AtlasRelationshipAccessRequest request) { <line1> MetricRecorder metric = RequestContext.get().startMetricRecord(""isAccessAllowed""); <line2> boolean ret = false; <line3> String userName = getCurrentUserName(); <line4> if (StringUtils.isNotEmpty(userName) && !RequestContext.get().isImportInProgress()) { <line5> try { <line6> AtlasAuthorizer authorizer = AtlasAuthorizerFactory.getAtlasAuthorizer(); <line7> request.setUser(getCurrentUserName(), getCurrentUserGroups()); <line8> request.setClientIPAddress(RequestContext.get().getClientIPAddress()); <line9> request.setForwardedAddresses(RequestContext.get().getForwardedAddresses()); <line10> request.setRemoteIPAddress(RequestContext.get().getClientIPAddress()); <line11> ret = authorizer.isAccessAllowed(request); <line12> } catch (AtlasAuthorizationException e) { <line13> } <line14> } else { <line15> ret = true; <line16> } <line17> RequestContext.get().endMetricRecord(metric); <line18> return ret; <line19> } <line20> } <line21> "	1	task3	
"public class A { <line0> @Override <line1> public JsonArray fetchVisualizationResults(long executionId, int kpiId, int assessmentId) { <line2> String vQuery = """"; <line3> vQuery = QueryEnum.valueOf(QueryEnum.NEO4J_VCONTENTQUERY.name()).toString(); <line4> vQuery = <line5> vQuery <line6> .replace("":kpiId"", String.valueOf(kpiId)) <line7> .replace("":executionId"", String.valueOf(executionId)) <line8> .replace("":assessmentId"", String.valueOf(assessmentId)); <line9> return fetchVisualizationResults(vQuery); <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> private boolean _isSkipEvent(Calendar calendar) { <line1> CalendarResource guestCalendarResource = null; <line2> try { <line3> guestCalendarResource = <line4> CalendarResourceUtil.fetchGuestCalendarResource(calendar.getCompanyId()); <line5> } catch (PortalException portalException) { <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> if ((guestCalendarResource != null) <line10> && (guestCalendarResource.getCalendarResourceId() == calendar.getCalendarResourceId())) { <line11> return true; <line12> } <line13> return false; <line14> } <line15> } <line16> 	1	task3	
public class A { <line0> public static com.liferay.portal.kernel.model.AddressSoap addAddress( <line1> String className, <line2> long classPK, <line3> String street1, <line4> String street2, <line5> String street3, <line6> String city, <line7> String zip, <line8> long regionId, <line9> long countryId, <line10> long typeId, <line11> boolean mailing, <line12> boolean primary, <line13> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line14> throws RemoteException { <line15> try { <line16> com.liferay.portal.kernel.model.Address returnValue = <line17> AddressServiceUtil.addAddress( <line18> className, <line19> classPK, <line20> street1, <line21> street2, <line22> street3, <line23> city, <line24> zip, <line25> regionId, <line26> countryId, <line27> typeId, <line28> mailing, <line29> primary, <line30> serviceContext); <line31> return com.liferay.portal.kernel.model.AddressSoap.toSoapModel(returnValue); <line32> } catch (Exception exception) { <line33> throw new RemoteException(exception.getMessage()); <line34> } <line35> } <line36> } <line37> 	1	task3	
public class A { <line0> @Override <line1> public void handleSignalInternal(EPDataFlowSignal signal) throws InvocationTargetException { <line2> try { <line3> method.invoke(target, new Object[] {streamNum, signal}); <line4> } catch (IllegalAccessException e) { <line5> } <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> @GET <line1> @Path(""/tags"") <line2> @Produces(APPLICATION_JSON) <line3> @ApiOperation(value = ""Returns a Map of Applications to their tags"", response = Map.class) <line4> @Timed <line5> public Response getAllExperimentTags( <line6> @HeaderParam(AUTHORIZATION) @ApiParam(value = EXAMPLE_AUTHORIZATION_HEADER, required = true) <line7> final String authorizationHeader) { <line8> try { <line9> UserInfo.Username userName = authorization.getUser(authorizationHeader); <line10> Set<Application.Name> allowed = new HashSet<>(); <line11> List<UserPermissions> authorized = <line12> authorization.getUserPermissionsList(userName).getPermissionsList(); <line13> for (UserPermissions perm : authorized) { <line14> allowed.add(perm.getApplicationName()); <line15> } <line16> Map<Application.Name, Set<String>> allTags = experiments.getTagsForApplications(allowed); <line17> return httpHeader.headers().entity(allTags).build(); <line18> } catch (Exception exception) { <line19> throw exception; <line20> } <line21> } <line22> } <line23> "	1	task3	
public class A { <line0> @Test <line1> public void testLinkloadingTwoScopes() throws CommandException { <line2> ItNetwork itNetwork = createNewBPOrganization(); <line3> ApplicationGroup applicationGroup = createGroup(itNetwork, ApplicationGroup.class); <line4> Application application = createElement(applicationGroup, Application.class); <line5> int baseGraph = itNetwork.getChildren().size() + 2; <line6> ItNetwork itNetwork1 = createNewBPOrganization(); <line7> ApplicationGroup applicationGroup1 = createGroup(itNetwork1, ApplicationGroup.class); <line8> Application application1 = createElement(applicationGroup1, Application.class); <line9> baseGraph += itNetwork1.getChildren().size() + 2; <line10> ItNetwork itNetwork2 = createNewBPOrganization(); <line11> ApplicationGroup applicationGroup2 = createGroup(itNetwork2, ApplicationGroup.class); <line12> Application application2 = createElement(applicationGroup2, Application.class); <line13> ItNetwork itNetwork3 = createNewBPOrganization(); <line14> ApplicationGroup applicationGroup3 = createGroup(itNetwork3, ApplicationGroup.class); <line15> Application application3 = createElement(applicationGroup3, Application.class); <line16> elementsToClear.add(itNetwork); <line17> elementsToClear.add(itNetwork1); <line18> elementsToClear.add(itNetwork2); <line19> elementsToClear.add(itNetwork3); <line20> createLink(application, application1, null); <line21> createLink(application1, application2, null); <line22> createLink(application2, application3, null); <line23> VeriniceGraph veriniceGraph = <line24> createGraphWithLoader( <line25> new FirstLinkedElementsLoader(), itNetwork.getScopeId(), itNetwork1.getScopeId()); <line26> Set<CnATreeElement> connectedSetOf = veriniceGraph.getElements(); <line27> assertTrue(connectedSetOf.contains(itNetwork)); <line28> assertTrue(connectedSetOf.contains(application1)); <line29> assertTrue(connectedSetOf.contains(application2)); <line30> assertFalse(connectedSetOf.contains(application3)); <line31> assertEquals(baseGraph + 1, connectedSetOf.size()); <line32> } <line33> } <line34> 	1	task3	
public class A { <line0> @BeforeClass <line1> public static void setupClient() { <line2> S3Client = getS3Client(); <line3> if (S3Client.doesBucketExistV2(TEST_BUCKET_NAME)) { <line4> clearBucket(TEST_BUCKET_NAME); <line5> } else { <line6> S3Client.createBucket(TEST_BUCKET_NAME); <line7> } <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> @Transactional <line1> private void importXLIFF(ImportExportedXliffStep importExportedXliffStep, String xliffContent) { <line2> IPipelineDriver driver = new PipelineDriver(); <line3> XLIFFFilter xliffFilter = new XLIFFFilter(); <line4> driver.addStep(new RawDocumentToFilterEventsStep(xliffFilter)); <line5> importExportedXliffStep.setXliffFilter(xliffFilter); <line6> driver.addStep(importExportedXliffStep); <line7> RawDocument rawDocument = new RawDocument(xliffContent, LocaleId.ENGLISH); <line8> driver.addBatchItem(rawDocument); <line9> driver.processBatch(); <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> protected MediaType getBinaryResourceMediaType(final FedoraResource resource) { <line1> try { <line2> return MediaType.valueOf(((Binary) resource).getMimeType()); <line3> } catch (final IllegalArgumentException e) { <line4> return MediaType.APPLICATION_OCTET_STREAM_TYPE; <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> public Invitation get(InvitationDTO dto, Long userId) { <line1> Invitation i = new Invitation(); <line2> i.setHash(randomUUID().toString()); <line3> i.setPasswordProtected(dto.isPasswordProtected()); <line4> if (dto.isPasswordProtected()) { <line5> i.setPassword(CryptProvider.get().hash(dto.getPassword())); <line6> } <line7> i.setUsed(false); <line8> i.setValid(dto.getValid()); <line9> try { <line10> switch (dto.getValid()) { <line11> case PERIOD: <line12> i.setValidFrom(new Date(SDF.parse(dto.getValidFrom()).getTime() - (5 * 60 * 1000))); <line13> i.setValidTo(SDF.parse(dto.getValidTo())); <line14> break; <line15> case ENDLESS: <line16> case ONE_TIME: <line17> default: <line18> break; <line19> } <line20> } catch (ParseException e) { <line21> throw new RuntimeException(e); <line22> } <line23> i.setDeleted(false); <line24> i.setInvitedBy(userDao.get(userId)); <line25> i.setInvitee(userDao.getContact(dto.getEmail(), dto.getFirstname(), dto.getLastname(), userId)); <line26> if (Type.CONTACT == i.getInvitee().getType()) { <line27> i.getInvitee().setLanguageId(dto.getLanguageId()); <line28> } <line29> i.setRoom(roomDao.get(dto.getRoomId())); <line30> i.setInserted(new Date()); <line31> i.setAppointment(null); <line32> return i; <line33> } <line34> } <line35> 	1	task3	
"public class A { <line0> private String buildUrl( <line1> InetSocketAddress node, String rootPath, String username, String password) { <line2> StringBuilder s = new StringBuilder(); <line3> s.append(protocol).append(""://""); <line4> if (username != null) { <line5> try { <line6> s.append(URLEncoder.encode(username, ""UTF-8"")) <line7> .append("":"") <line8> .append(URLEncoder.encode(password, ""UTF-8"")) <line9> .append(""@""); <line10> } catch (UnsupportedEncodingException e) { <line11> throw new RuntimeException(""Could not encode the supplied username and password"", e); <line12> } <line13> } <line14> s.append(node.getHostName()).append("":"").append(node.getPort()).append(""/""); <line15> if (rootPath != null) { <line16> s.append(rootPath).append(""/""); <line17> } <line18> if (log.isTraceEnabled()) { <line19> } <line20> return s.toString(); <line21> } <line22> } <line23> "	1	task3	
public class A { <line0> @Override <line1> public void afterJobScheduled(AsynchronousJobEvent event) { <line2> Long data = event.getJob().getId(); <line3> clusterService.addData( <line4> ClusterAwareService.CLUSTER_JOBS_KEY, clusterService.getThisNode().toKey(), data); <line5> } <line6> } <line7> 	1	task3	
public class A { <line0> private Key unwrapKey(PrivateKey wrappingKey, byte[] wrappedKey) throws GeneralSecurityException { <line1> Cipher unwrapper = Cipher.getInstance(RSA); <line2> unwrapper.init(Cipher.UNWRAP_MODE, wrappingKey); <line3> try { <line4> return unwrapper.unwrap(wrappedKey, DES, Cipher.SECRET_KEY); <line5> } catch (InvalidKeyException e) { <line6> throw e; <line7> } <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> @Override <line1> public void memoryUsageLow(final long usedMemory, final long maxMemory) { <line2> m_lock.lock(); <line3> try { <line4> m_cond.signalAll(); <line5> } finally { <line6> m_lock.unlock(); <line7> } <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> private void doWakeup() { <line1> try { <line2> nextResync = Instant.MIN; <line3> queue.wakeup(); <line4> } catch (InterruptedException ex) { <line5> Thread.currentThread().interrupt(); <line6> } <line7> } <line8> } <line9> 	1	task3	
"public class A { <line0> private ImmutableSortedMap<String, ImmutableSet<String>> readMap(final String mapPath) { <line1> String fileContent; <line2> String actualPath = mapPath; <line3> try { <line4> if (Strings.isNullOrEmpty(mapPath)) { <line5> URL resource = this.getClass().getClassLoader().getResource(""defaultWhiteListMap.json""); <line6> actualPath = resource.getFile(); <line7> fileContent = Resources.toString(resource, Charset.defaultCharset()); <line8> } else { <line9> fileContent = Files.asCharSource(new File(mapPath), StandardCharsets.UTF_8).read(); <line10> } <line11> return mapper <line12> .readerFor(new TypeReference<ImmutableSortedMap<String, ImmutableSet<String>>>() {}) <line13> .readValue(fileContent); <line14> } catch (IOException e) { <line15> throw new ISE(e, ""Got an exception while parsing file [%s]"", actualPath); <line16> } <line17> } <line18> } <line19> "	1	task3	
"public class A { <line0> private void parse(String commandOutput) { <line1> boolean associated = false; <line2> for (String line : commandOutput.split(""\n"")) { <line3> line = line.trim(); <line4> if (line.contains(MODE)) { <line5> associated = parseMode(line); <line6> } else if (line.contains(BIT_RATE)) { <line7> parseBitrate(line); <line8> } else if (line.contains(SIGNAL_LEVEL)) { <line9> int sig = parseSignalLevel(line); <line10> if (associated && sig > -100) { <line11> setSignal(sig); <line12> setLinkDetected(true); <line13> } <line14> } <line15> if (!associated) { <line16> break; <line17> } <line18> } <line19> } <line20> } <line21> "	1	task3	
"public class A { <line0> void checkSystemMergeRequest( <line1> final SystemRequestDTO request, final long systemId, final String origin) { <line2> if (systemId <= 0) { <line3> throw new BadPayloadException(ID_NOT_VALID_ERROR_MESSAGE, HttpStatus.SC_BAD_REQUEST, origin); <line4> } <line5> boolean needChange = false; <line6> if (!Utilities.isEmpty(request.getAddress())) { <line7> needChange = true; <line8> } <line9> if (!Utilities.isEmpty(request.getSystemName())) { <line10> needChange = true; <line11> for (final CoreSystem coreSysteam : CoreSystem.values()) { <line12> if (coreSysteam.name().equalsIgnoreCase(request.getSystemName().trim())) { <line13> throw new BadPayloadException( <line14> ""System name '"" <line15> + request.getSystemName() <line16> + ""' is a reserved arrowhead core system name."", <line17> HttpStatus.SC_BAD_REQUEST, <line18> origin); <line19> } <line20> } <line21> } <line22> if (request.getPort() != null) { <line23> final int validatedPort = request.getPort(); <line24> if (validatedPort < CommonConstants.SYSTEM_PORT_RANGE_MIN <line25> || validatedPort > CommonConstants.SYSTEM_PORT_RANGE_MAX) { <line26> throw new BadPayloadException( <line27> ""Port must be between "" <line28> + CommonConstants.SYSTEM_PORT_RANGE_MIN <line29> + "" and "" <line30> + CommonConstants.SYSTEM_PORT_RANGE_MAX <line31> + ""."", <line32> HttpStatus.SC_BAD_REQUEST, <line33> origin); <line34> } <line35> needChange = true; <line36> } <line37> if (request.getAuthenticationInfo() != null) { <line38> needChange = true; <line39> } <line40> if (!needChange) { <line41> throw new BadPayloadException(""Patch request is empty."", HttpStatus.SC_BAD_REQUEST, origin); <line42> } <line43> } <line44> } <line45> "	1	task3	
public class A { <line0> private void halt(String reason) { <line1> GoAwayFrame goAwayFrame = null; <line2> GoAwayFrame goAwayFrameEvent; <line3> try (AutoLock l = lock.lock()) { <line4> switch (closed) { <line5> case NOT_CLOSED: <line6> case REMOTELY_CLOSED: <line7> case LOCALLY_CLOSED: <line8> case CLOSING: <line9> { <line10> if (goAwaySent == null || goAwaySent.isGraceful()) <line11> goAwaySent = goAwayFrame = newGoAwayFrame(ErrorCode.NO_ERROR.code, reason); <line12> goAwayFrameEvent = goAwayRecv != null ? goAwayRecv : goAwaySent; <line13> closed = CloseState.CLOSED; <line14> zeroStreamsAction = null; <line15> if (failure != null) failure = toFailure(ErrorCode.NO_ERROR.code, reason); <line16> break; <line17> } <line18> default: <line19> { <line20> return; <line21> } <line22> } <line23> } <line24> failStreams(stream -> true, reason, true); <line25> if (goAwayFrame != null) sendGoAwayAndTerminate(goAwayFrame, goAwayFrameEvent); <line26> else terminate(goAwayFrameEvent); <line27> } <line28> } <line29> 	1	task3	
public class A { <line0> private void prepareServerNameType(ServerNamePair pair) { <line1> pair.setServerNameType(pair.getServerNameTypeConfig()); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> private void saveCriteria( <line1> final NiFiWebConfigurationRequestContext requestContext, final Criteria criteria) { <line2> final String annotationData = CriteriaSerDe.serialize(criteria); <line3> final NiFiWebConfigurationContext configurationContext = <line4> (NiFiWebConfigurationContext) servletContext.getAttribute(""nifi-web-configuration-context""); <line5> try { <line6> configurationContext.updateComponent(requestContext, annotationData, null); <line7> } catch (final InvalidRevisionException ire) { <line8> throw new WebApplicationException(ire, invalidRevision(ire.getMessage())); <line9> } catch (final IllegalArgumentException iae) { <line10> throw new WebApplicationException(iae, badRequest(iae.getMessage())); <line11> } catch (final Exception e) { <line12> final String message = <line13> String.format( <line14> ""Unable to save UpdateAttribute[id=%s] criteria: %s"", requestContext.getId(), e); <line15> throw new WebApplicationException(e, error(message)); <line16> } <line17> } <line18> } <line19> "	1	task3	
public class A { <line0> public static com.liferay.asset.kernel.model.AssetCategorySoap moveCategory( <line1> long categoryId, <line2> long parentCategoryId, <line3> long vocabularyId, <line4> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line5> throws RemoteException { <line6> try { <line7> com.liferay.asset.kernel.model.AssetCategory returnValue = <line8> AssetCategoryServiceUtil.moveCategory( <line9> categoryId, parentCategoryId, vocabularyId, serviceContext); <line10> return com.liferay.asset.kernel.model.AssetCategorySoap.toSoapModel(returnValue); <line11> } catch (Exception exception) { <line12> throw new RemoteException(exception.getMessage()); <line13> } <line14> } <line15> } <line16> 	1	task3	
"public class A { <line0> static MCRContent getMetsSource(MCRServletJob job, boolean useExistingMets, String derivate) <line1> throws Exception { <line2> MCRPath metsPath = MCRPath.getPath(derivate, ""/mets.xml""); <line3> try { <line4> job.getRequest().setAttribute(""XSL.derivateID"", derivate); <line5> String objectid = MCRLinkTableManager.instance().getSourceOf(derivate).iterator().next(); <line6> if (objectid == null || objectid.length() == 0) { <line7> MCRDerivate derObj = <line8> MCRMetadataManager.retrieveMCRDerivate(MCRObjectID.getInstance(derivate)); <line9> MCRObjectID ownerID = derObj.getOwnerID(); <line10> objectid = ownerID.toString(); <line11> } <line12> job.getRequest().setAttribute(""XSL.objectID"", objectid); <line13> } catch (Exception x) { <line14> } <line15> boolean metsExists = Files.exists(metsPath); <line16> if (metsExists && useExistingMets) { <line17> MCRContent content = new MCRPathContent(metsPath); <line18> content.setDocType(""mets""); <line19> return content; <line20> } else { <line21> Document mets = <line22> MCRMETSGeneratorFactory.create(MCRPath.getPath(derivate, ""/"")).generate().asDocument(); <line23> if (!metsExists && STORE_METS_ON_GENERATE) { <line24> MCRMetsSave.saveMets(mets, MCRObjectID.getInstance(derivate)); <line25> } <line26> return new MCRJDOMContent(mets); <line27> } <line28> } <line29> } <line30> "	1	task3	
public class A { <line0> @Override <line1> public void shutDownGracefully(GracefulShutdownCallback callback) { <line2> if (this.gracefulShutdown == null) { <line3> callback.shutdownComplete(GracefulShutdownResult.IMMEDIATE); <line4> return; <line5> } <line6> this.gracefulShutdownCallback.set(callback); <line7> this.gracefulShutdown.shutdown(); <line8> this.gracefulShutdown.addShutdownListener((success) -> notifyGracefulCallback(success)); <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> public static java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> deleteVocabularies( <line1> HttpPrincipal httpPrincipal, <line2> long[] vocabularyIds, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> AssetVocabularyServiceUtil.class, <line9> ""deleteVocabularies"", <line10> _deleteVocabulariesParameterTypes4); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, vocabularyIds, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (java.util.List<com.liferay.asset.kernel.model.AssetVocabulary>) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	1	task3	
public class A { <line0> protected void setValue(ITableRow r, VALUE value, boolean updateValidDisplayText) { <line1> try { <line2> Cell cell = r.getCellForUpdate(this); <line3> cell.removeErrorStatus(ValidationFailedStatus.class); <line4> VALUE newValue = validateValue(r, value); <line5> if (!cell.hasError()) { <line6> r.setCellValue(getColumnIndex(), newValue); <line7> if (this instanceof ITableRowCustomValueContributor) { <line8> ((ITableRowCustomValueContributor) this).enrichCustomValues(r, r.getCustomValues()); <line9> } <line10> } <line11> ensureVisibileIfInvalid(r); <line12> if (updateValidDisplayText) { <line13> updateDisplayText(r, newValue); <line14> } <line15> } catch (ProcessingException e) { <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> Cell cell = r.getCellForUpdate(this); <line19> cell.addErrorStatus(new ValidationFailedStatus<>(e, value)); <line20> updateDisplayText(r, value); <line21> } <line22> } <line23> } <line24> 	1	task3	
public class A { <line0> private String convertToBytes(String value, String unit) { <line1> BigDecimal resourceSize = new BigDecimal(value); <line2> resourceSize = resourceSize.setScale(1, BigDecimal.ROUND_HALF_UP); <line3> switch (unit) { <line4> case B: <line5> break; <line6> case KB: <line7> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_KB)); <line8> break; <line9> case MB: <line10> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_MB)); <line11> break; <line12> case GB: <line13> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_GB)); <line14> break; <line15> case TB: <line16> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_TB)); <line17> break; <line18> case PB: <line19> resourceSize = resourceSize.multiply(new BigDecimal(BYTES_PER_PB)); <line20> break; <line21> default: <line22> break; <line23> } <line24> String resourceSizeAsString = resourceSize.toPlainString(); <line25> return resourceSizeAsString; <line26> } <line27> } <line28> 	1	task3	
public class A { <line0> @Override <line1> public URI getNodeURI() { <line2> if (this.nodeURIs == null || this.nodeURIs.isEmpty()) return null; <line3> int index = lastIndex + 1; <line4> if (index >= this.nodeURIs.size()) { <line5> index = 0; <line6> } <line7> URI nodeUri = this.nodeURIs.get(index); <line8> this.lastIndex = index; <line9> return nodeUri; <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> protected void exportPortletPreferences( <line1> PortletDataContext portletDataContext, <line2> long ownerId, <line3> int ownerType, <line4> boolean defaultUser, <line5> Layout layout, <line6> long plid, <line7> String portletId, <line8> Element parentElement) <line9> throws Exception { <line10> PortletPreferences portletPreferences = null; <line11> try { <line12> portletPreferences = getPortletPreferences(ownerId, ownerType, plid, portletId); <line13> } catch (NoSuchPortletPreferencesException noSuchPortletPreferencesException) { <line14> if (log.isDebugEnabled()) { <line15> } <line16> return; <line17> } <line18> if (_hasPortletId(layout, portletId, ownerType)) { <line19> exportPortletPreference( <line20> portletDataContext, <line21> ownerId, <line22> ownerType, <line23> defaultUser, <line24> portletPreferences, <line25> portletId, <line26> plid, <line27> parentElement); <line28> } <line29> } <line30> } <line31> 	1	task3	
public class A { <line0> public Optional<Method> getGetter(Class<?> originatingClass) { <line1> try { <line2> return Optional.ofNullable(_Reflect.getGetter(originatingClass, field.getName())); <line3> } catch (IntrospectionException e) { <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> protected String assertTableIsRegistered( <line1> String fullTableName, AssertPredicate assertPredicate, boolean isTemporary) throws Exception { <line2> String tableQualifiedName = <line3> (fullTableName + AtlasImpalaHookContext.QNAME_SEP_METADATA_NAMESPACE).toLowerCase() <line4> + CLUSTER_NAME; <line5> return assertEntityIsRegistered( <line6> HIVE_TYPE_TABLE, REFERENCEABLE_ATTRIBUTE_NAME, tableQualifiedName, assertPredicate); <line7> } <line8> } <line9> 	1	task3	
"public class A { <line0> @BeforeClass <line1> public static void setUp() throws Exception { <line2> File outdir = new File(PATH_ACTUAL); <line3> outdir.mkdirs(); <line4> File externalTestsJar = <line5> Objects.requireNonNull( <line6> new File(joinPath("".."", ""asterix-external-data"", ""target"")) <line7> .listFiles((dir, name) -> name.matches(""asterix-external-data-.*-tests.jar"")))[0]; <line8> asterixInstallerPath = new File(System.getProperty(""user.dir"")); <line9> installerTargetPath = <line10> new File(new File(asterixInstallerPath.getParentFile(), ""asterix-server""), ""target""); <line11> reportPath = new File(installerTargetPath, ""failsafe-reports"").getAbsolutePath(); <line12> ncServiceSubDirName = <line13> Objects.requireNonNull( <line14> installerTargetPath.list( <line15> (dir, name) -> name.matches(""asterix-server.*binary-assembly"")))[0]; <line16> ncServiceSubPath = new File(installerTargetPath, ncServiceSubDirName).getAbsolutePath(); <line17> ncServiceHomeDirName = <line18> Objects.requireNonNull( <line19> new File(ncServiceSubPath).list(((dir, name) -> name.matches(""apache-asterixdb.*""))))[ <line20> 0]; <line21> ncServiceHomePath = new File(ncServiceSubPath, ncServiceHomeDirName).getAbsolutePath(); <line22> FileUtils.copyFile( <line23> externalTestsJar, new File(ncServiceHomePath + ""/repo"", externalTestsJar.getName())); <line24> pb = new ProcessBuilder(); <line25> env = pb.environment(); <line26> env.put(""NCSERVICE_HOME"", ncServiceHomePath); <line27> env.put(""JAVA_HOME"", System.getProperty(""java.home"")); <line28> scriptHomePath = <line29> joinPath( <line30> asterixInstallerPath.getPath(), ""src"", ""test"", ""resources"", ""transactionts"", ""scripts""); <line31> env.put(""SCRIPT_HOME"", scriptHomePath); <line32> TestExecutor.executeScript( <line33> pb, joinPath(scriptHomePath, ""setup_teardown"", ""configure_and_validate.sh"")); <line34> TestExecutor.executeScript( <line35> pb, joinPath(scriptHomePath, ""setup_teardown"", ""stop_and_delete.sh"")); <line36> HDFSCluster.getInstance().setup(HDFS_BASE); <line37> } <line38> } <line39> "	1	task3	
public class A { <line0> @Override <line1> public void jbossWSUnableToCreateBinaryToken(Throwable t) { <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @Override <line1> public GetVersionedInput.Response getVersionedInputs(GetVersionedInput request) <line2> throws InvalidProtocolBufferException { <line3> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line4> ExperimentRunEntity experimentRunObj = <line5> session.get(ExperimentRunEntity.class, request.getId()); <line6> if (experimentRunObj != null) { <line7> ExperimentRun experimentRun = experimentRunObj.getProtoObject(); <line8> if (experimentRun.getVersionedInputs() != null <line9> && experimentRun.getVersionedInputs().getRepositoryId() != 0 <line10> && config.populateConnectionsBasedOnPrivileges) { <line11> experimentRun = <line12> checkVersionInputBasedOnPrivileges(experimentRun, new HashSet<>(), new HashSet<>()); <line13> } <line14> return GetVersionedInput.Response.newBuilder() <line15> .setVersionedInputs(experimentRun.getVersionedInputs()) <line16> .build(); <line17> } else { <line18> String errorMessage = ""ExperimentRun not found for given ID : "" + request.getId(); <line19> throw new NotFoundException(errorMessage); <line20> } <line21> } catch (Exception ex) { <line22> if (ModelDBUtils.needToRetry(ex)) { <line23> return getVersionedInputs(request); <line24> } else { <line25> throw ex; <line26> } <line27> } <line28> } <line29> } <line30> "	1	task3	
"public class A { <line0> public synchronized WorkItemServiceState reportSuccess() throws IOException { <line1> checkState(!finalStateSent, ""cannot reportSuccess after sending a final state""); <line2> checkState(worker != null, ""setWorker should be called before reportSuccess""); <line3> WorkItemStatus status = createStatusUpdate(true); <line4> if (worker instanceof SourceOperationExecutor) { <line5> SourceOperationResponse response = ((SourceOperationExecutor) worker).getResponse(); <line6> if (response != null) { <line7> status.setSourceOperationResponse(response); <line8> } <line9> } <line10> return execute(status); <line11> } <line12> } <line13> "	1	task3	
public class A { <line0> public static void log(final String message) { <line1> } <line2> } <line3> 	1	task3	
"public class A { <line0> private IncompleteType readFloatParameterType(SpaceSystem spaceSystem) throws XMLStreamException { <line1> StartElement element = checkStartElementPreconditions(); <line2> FloatParameterType.Builder typeBuilder = new FloatParameterType.Builder(); <line3> IncompleteType incompleteType = new IncompleteType(spaceSystem, typeBuilder); <line4> readParameterBaseTypeAttributes(spaceSystem, element, incompleteType); <line5> String value = readAttribute(""sizeInBits"", element, null); <line6> if (value != null) { <line7> int sizeInBits = Integer.parseInt(value); <line8> if (sizeInBits != 32 && sizeInBits != 64) { <line9> throw new XMLStreamException( <line10> ""Float encoding "" <line11> + sizeInBits <line12> + "" not supported;"" <line13> + "" Only 32 and 64 bits are supported"", <line14> xmlEvent.getLocation()); <line15> } <line16> typeBuilder.setSizeInBits(sizeInBits); <line17> } <line18> value = readAttribute(""initialValue"", element, null); <line19> if (value != null) { <line20> typeBuilder.setInitialValue(value); <line21> } <line22> while (true) { <line23> xmlEvent = xmlEventReader.nextEvent(); <line24> if (readBaseTypeProperties(typeBuilder)) { <line25> continue; <line26> } else if (isStartElementWithName(XTCE_INTEGER_DATA_ENCODING)) { <line27> typeBuilder.setEncoding(readIntegerDataEncoding(spaceSystem)); <line28> } else if (isStartElementWithName(XTCE_FLOAT_DATA_ENCODING)) { <line29> typeBuilder.setEncoding(readFloatDataEncoding(spaceSystem)); <line30> } else if (isStartElementWithName(XTCE_STRING_DATA_ENCODING)) { <line31> typeBuilder.setEncoding(readStringDataEncoding(spaceSystem)); <line32> } else if (isStartElementWithName(XTCE_BINARY_DATA_ENCODING)) { <line33> throw new XMLStreamException(""Cannot use a binary data encoding for float parameter type""); <line34> } else if (isStartElementWithName(XTCE_DEFAULT_ALARM)) { <line35> typeBuilder.setDefaultAlarm(readDefaultAlarm()); <line36> } else if (isStartElementWithName(XTCE_CONTEXT_ALARM_LIST)) { <line37> typeBuilder.setContextAlarmList(readNumericContextAlarmList(spaceSystem)); <line38> } else if (isStartElementWithName(XTCE_VALID_RANGE)) { <line39> typeBuilder.setValidRange(readFloatValidRange()); <line40> } else if (isEndElementWithName(XTCE_FLOAT_PARAMETER_TYPE)) { <line41> return incompleteType; <line42> } else { <line43> logUnknown(); <line44> } <line45> } <line46> } <line47> } <line48> "	1	task3	
public class A { <line0> @Override <line1> public boolean isMembershipAllowed(long userId, long userGroupId) throws PortalException { <line2> try { <line3> checkMembership(new long[] {userId}, new long[] {userGroupId}, null); <line4> } catch (Exception exception) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> return false; <line8> } <line9> return true; <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> @Override <line1> public void initialize() { <line2> AirVisualNodeConfig config = getConfigAs(AirVisualNodeConfig.class); <line3> if (config.address == null) { <line4> updateStatus( <line5> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Node address must be set""); <line6> return; <line7> } <line8> this.nodeAddress = config.address; <line9> this.nodeUsername = config.username; <line10> if (config.password == null) { <line11> updateStatus( <line12> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Node password must be set""); <line13> return; <line14> } <line15> this.nodePassword = config.password; <line16> this.nodeShareName = config.share; <line17> this.refreshInterval = config.refresh * 1000L; <line18> try { <line19> var jsonData = gson.fromJson(getNodeJsonData(), Map.class); <line20> this.isProVersion = jsonData.get(""measurements"") instanceof ArrayList; <line21> } catch (IOException e) { <line22> updateStatus( <line23> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Can't get node json""); <line24> return; <line25> } <line26> if (!this.isProVersion) { <line27> removeProChannels(); <line28> } <line29> schedulePoll(); <line30> } <line31> } <line32> "	1	task3	
"public class A { <line0> @Override <line1> public void deleteHistoryEventsByTaskIds(List<String> taskIds) <line2> throws InvalidArgumentException, NotAuthorizedException { <line3> taskanaHistoryEngine.checkRoleMembership(TaskanaRole.ADMIN); <line4> if (taskIds == null) { <line5> throw new InvalidArgumentException(""List of taskIds must not be null.""); <line6> } <line7> try { <line8> taskanaHistoryEngine.openConnection(); <line9> taskHistoryEventMapper.deleteMultipleByTaskIds(taskIds); <line10> } catch (SQLException e) { <line11> } finally { <line12> taskanaHistoryEngine.returnConnection(); <line13> } <line14> } <line15> } <line16> "	1	task3	
"public class A { <line0> public String runSSMDocument( <line1> String documentName, String targetEc2InstanceId, Map<String, List<String>> commandParameters) <line2> throws S3SyncFileSystemDownloader.CannotLaunchCommandException { <line3> SsmClient client = clientFactory.get(); <line4> final String migrationS3BucketName; <line5> try { <line6> migrationS3BucketName = migrationHelperDeploymentService.getMigrationS3BucketName(); <line7> } catch (InfrastructureDeploymentError infrastructureDeploymentError) { <line8> throw new S3SyncFileSystemDownloader.CannotLaunchCommandException( <line9> ""cannot get migration bucket for publishing SSM command logs"", <line10> infrastructureDeploymentError); <line11> } <line12> SendCommandRequest request = <line13> SendCommandRequest.builder() <line14> .documentName(documentName) <line15> .documentVersion(""$LATEST"") <line16> .instanceIds(targetEc2InstanceId) <line17> .parameters(commandParameters) <line18> .timeoutSeconds(600) <line19> .comment(""Command run by Jira DC Migration Assistant"") <line20> .outputS3BucketName(migrationS3BucketName) <line21> .outputS3KeyPrefix(ssmS3KeyPrefix) <line22> .build(); <line23> SendCommandResponse response = client.sendCommand(request); <line24> return response.command().commandId(); <line25> } <line26> } <line27> "	1	task3	
"public class A { <line0> @Override <line1> public void onWebSocketText(String data) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> Object event = javaScript.evaluate(""event"", ""({data:'"" + data + ""'})""); <line5> javaScript.invoke(false, jsWebSocket, ""onmessage"", event); <line6> } <line7> } <line8> "	1	task3	
"public class A { <line0> public void copyDmlToClipboard() { <line1> try { <line2> XulTextbox dmlField = (XulTextbox) document.getElementById(ELEM_ID_DML_FIELD); <line3> Assert.notNull(dmlField, ""could not find element with id '"" + ELEM_ID_DML_FIELD + ""'""); <line4> ((XulWindow) document.getRootElement()).copy(dmlField.getValue()); <line5> } catch (XulException e) { <line6> if (logger.isErrorEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> "	1	task3	
public class A { <line0> public void log(String msg) { <line1> } <line2> } <line3> 	1	task3	
public class A { <line0> protected void onIdleExpired(TimeoutException timeout) { <line1> if (notifyIdleTimeout(this, timeout)) { <line2> reset(new ResetFrame(getId(), ErrorCode.CANCEL_STREAM_ERROR.code), Callback.NOOP); <line3> } <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> public void logout() { <line1> PFUserDO user = userContext != null ? userContext.getUser() : null; <line2> if (user != null) { <line3> user = null; <line4> } <line5> ThreadLocalUserContext.clear(); <line6> userContext = null; <line7> super.clear(); <line8> super.invalidateNow(); <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> @Ignore <line1> @Test <line2> public void testReadProjects() throws IOException { <line3> JiraProjectsReader jiraReader = new JiraProjectsReader(source); <line4> List<Object> entities = new ArrayList<>(); <line5> for (boolean hasNext = jiraReader.start(); hasNext; hasNext = jiraReader.advance()) { <line6> Object entity = jiraReader.getCurrent().get(0); <line7> entities.add(entity); <line8> } <line9> jiraReader.close(); <line10> assertThat(entities, hasSize(3)); <line11> assertThat(entities, containtEntityWithName(""Public Project 1"")); <line12> assertThat(entities, containtEntityWithName(""Public Project 2"")); <line13> assertThat(entities, containtEntityWithName(""Test Project"")); <line14> } <line15> } <line16> "	1	task3	
public class A { <line0> @Override <line1> public void addEntitlementToRole(Role role, Entitlement entitlement) { <line2> final RoleEntity roleEntity; <line3> if (role.getId() != 0) { <line4> roleEntity = em.find(RoleEntity.class, role.getId()); <line5> } else { <line6> roleEntity = getRoleEntity(role.getName(), em); <line7> } <line8> final EntitlementEntity entitlementEntity; <line9> if (entitlement.getId() != 0) { <line10> entitlementEntity = em.find(EntitlementEntity.class, entitlement.getId()); <line11> } else { <line12> entitlementEntity = EntitlementDAOJPAImpl.getEntitlementEntity(entitlement.getName(), em); <line13> } <line14> roleEntity.getEntitlements().add(entitlementEntity); <line15> } <line16> } <line17> 	1	task3	
"public class A { <line0> @Test <line1> public void testTransformMetacardNoProducerInputTransformerRegistered() throws Exception { <line2> MimeTypeToTransformerMapper matchingService = mock(MimeTypeToTransformerMapper.class); <line3> catalogComponent.setMimeTypeToTransformerMapper(matchingService); <line4> List list = new ArrayList<InputTransformer>(); <line5> when(matchingService.findMatches(eq(InputTransformer.class), isA(MimeType.class))) <line6> .thenReturn(list); <line7> InputStream input = IOUtils.toInputStream(xmlInput); <line8> InputTransformer transformer = getTransformer(""text/xml"", ""identity""); <line9> assertNotNull(""InputTransformer for text/xml;id=identity not found"", transformer); <line10> try { <line11> transformer.transform(input); <line12> fail(""Should have thrown a CatalogTransformerException""); <line13> } catch (CatalogTransformerException e) { <line14> assertEquals( <line15> ""Did not find an InputTransformer for MIME Type [text/xml] and id [xml]"", e.getMessage()); <line16> } <line17> } <line18> } <line19> "	1	task3	
"public class A { <line0> public void streamData( <line1> PID pid, <line2> String dsName, <line3> AccessGroupSet principals, <line4> boolean asAttachment, <line5> HttpServletResponse response) <line6> throws IOException { <line7> String datastream = dsName == null ? ORIGINAL_FILE.getId() : dsName; <line8> DatastreamType dsType = DatastreamType.getByIdentifier(datastream); <line9> if (dsType == null) { <line10> throw new NotFoundException(""Provided value is not the name of a known datastream type""); <line11> } <line12> if (dsType.getStoragePolicy().equals(StoragePolicy.EXTERNAL)) { <line13> throw new IllegalArgumentException(""Cannot stream external datastream "" + datastream); <line14> } <line15> accessControlService.assertHasAccess( <line16> ""Insufficient permissions to access "" + datastream + "" for object "" + pid, <line17> pid, <line18> principals, <line19> getPermissionForDatastream(datastream)); <line20> BinaryObject binObj; <line21> if (ORIGINAL_FILE.getId().equals(datastream)) { <line22> FileObject fileObj = repositoryObjectLoader.getFileObject(pid); <line23> binObj = fileObj.getOriginalFile(); <line24> } else { <line25> String dsPath = URIUtil.join(pid.getQualifiedId(), dsType.getContainer(), dsType.getId()); <line26> PID dsPid = PIDs.get(dsPath); <line27> binObj = repositoryObjectLoader.getBinaryObject(dsPid); <line28> } <line29> response.setHeader(CONTENT_LENGTH, Long.toString(binObj.getFilesize())); <line30> response.setHeader(CONTENT_TYPE, binObj.getMimetype()); <line31> String binaryName = binObj.getFilename(); <line32> String filename = binaryName == null ? pid.getId() : binaryName; <line33> if (asAttachment) { <line34> response.setHeader(CONTENT_DISPOSITION, ""attachment; filename=\"""" + filename + ""\""""); <line35> } else { <line36> response.setHeader(CONTENT_DISPOSITION, ""inline; filename=\"""" + filename + ""\""""); <line37> } <line38> try (InputStream binStream = binObj.getBinaryStream()) { <line39> OutputStream outStream = response.getOutputStream(); <line40> IOUtils.copy(binStream, outStream, BUFFER_SIZE); <line41> } <line42> } <line43> } <line44> "	1	task3	
"public class A { <line0> @Override <line1> protected void decode( <line2> ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) <line3> throws Exception { <line4> byteBuf.markReaderIndex(); <line5> StringBuilder sb = new StringBuilder(); <line6> for (int i = 1; i <= byteBuf.readableBytes(); i++) { <line7> sb.append(byteBuf.readByte()).append("", ""); <line8> } <line9> byteBuf.resetReaderIndex(); <line10> } <line11> } <line12> "	1	task3	
"public class A { <line0> private void process(final SynchronizedExchange synchronizedExchange) { <line1> try { <line2> Exchange exchange = synchronizedExchange.getExchange(); <line3> final boolean ignore = <line4> exchange.hasProperties() <line5> && exchange.getProperties().containsKey(DisruptorEndpoint.DISRUPTOR_IGNORE_EXCHANGE); <line6> if (ignore) { <line7> return; <line8> } <line9> final Exchange result = prepareExchange(exchange); <line10> result <line11> .adapt(ExtendedExchange.class) <line12> .addOnCompletion( <line13> new Synchronization() { <line14> @Override <line15> public void onComplete(Exchange exchange) { <line16> synchronizedExchange.consumed(result); <line17> } <line18>  <line19> @Override <line20> public void onFailure(Exchange exchange) { <line21> synchronizedExchange.consumed(result); <line22> } <line23> }); <line24> processor.process(result, NOOP_ASYNC_CALLBACK); <line25> } catch (Exception e) { <line26> Exchange exchange = synchronizedExchange.getExchange(); <line27> if (exchange != null) { <line28> getExceptionHandler().handleException(""Error processing exchange"", exchange, e); <line29> } else { <line30> getExceptionHandler().handleException(e); <line31> } <line32> } <line33> } <line34> } <line35> "	1	task3	
"public class A { <line0> private void resetHosts(long managementServerId, long lastPingSecondsAfter) { <line1> SearchCriteria<HostVO> sc = HostsForReconnectSearch.create(); <line2> sc.setParameters(""server"", managementServerId); <line3> sc.setParameters(""lastPinged"", lastPingSecondsAfter); <line4> sc.setParameters(""status"", Status.Disconnected, Status.Down, Status.Alert); <line5> StringBuilder sb = new StringBuilder(); <line6> List<HostVO> hosts = lockRows(sc, null, true); <line7> for (HostVO host : hosts) { <line8> host.setManagementServerId(null); <line9> update(host.getId(), host); <line10> sb.append(host.getId()); <line11> sb.append("" ""); <line12> } <line13> if (logger.isTraceEnabled()) { <line14> } <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> private void enrich( <line1> RoutePart routePart, EnricherContext context, List<RoutePartEnricher> routePartEnrichers) <line2> throws CriticalEnricherException { <line3> for (RoutePartEnricher routePartEnricher : routePartEnrichers) { <line4> routePartEnricher.enrich(routePart, context); <line5> } <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> private String generateNextAuditEventId() { <line1> final String ret; <line2> if (auditIdStrictUUID) { <line3> ret = MiscUtil.generateGuid(); <line4> } else { <line5> int nextId = counter.getAndIncrement(); <line6> if (nextId == Integer.MAX_VALUE) { <line7> UUID = MiscUtil.generateUniqueId(); <line8> counter = new AtomicInteger(0); <line9> } <line10> ret = UUID + ""-"" + Integer.toString(nextId); <line11> } <line12> if (LOG.isDebugEnabled()) { <line13> } <line14> return ret; <line15> } <line16> } <line17> "	1	task3	
"public class A { <line0> @Test <line1> public void testConcurrencyWithSchemaMigration() throws InterruptedException { <line2> SchemaListResponse schemas = call(() -> clientA.findSchemas()); <line3> SchemaResponse contentSchema = <line4> schemas.getData().stream().filter(s -> s.getName().equals(""content"")).findFirst().get(); <line5> String schemaUuid = contentSchema.getUuid(); <line6> String projectName = randomName(); <line7> ProjectCreateRequest request = new ProjectCreateRequest(); <line8> request.setName(projectName); <line9> request.setSchemaRef(""folder""); <line10> ProjectResponse project = call(() -> clientA.createProject(request)); <line11> call(() -> clientA.assignSchemaToProject(projectName, schemaUuid)); <line12> List<String> uuids = new ArrayList<>(); <line13> NodeCreateRequest nodeCreateRequest = new NodeCreateRequest(); <line14> nodeCreateRequest.setLanguage(""en""); <line15> nodeCreateRequest <line16> .getFields() <line17> .put(""teaser"", FieldUtil.createStringField(""some rorschach teaser"")); <line18> nodeCreateRequest <line19> .getFields() <line20> .put(""content"", FieldUtil.createStringField(""Blessed mealtime again!"")); <line21> nodeCreateRequest.setSchemaName(""content""); <line22> nodeCreateRequest.setParentNodeUuid(project.getRootNode().getUuid()); <line23> for (int i = 0; i < TEST_DATA_SIZE; i++) { <line24> nodeCreateRequest <line25> .getFields() <line26> .put(""slug"", FieldUtil.createStringField(""new-page"" + i + "".html"")); <line27> if (i % 10 == 0) { <line28> } <line29> uuids.add(call(() -> clientA.createNode(projectName, nodeCreateRequest)).getUuid()); <line30> } <line31> SchemaUpdateRequest schemaUpdateRequest = contentSchema.toUpdateRequest(); <line32> schemaUpdateRequest.addField(FieldUtil.createStringFieldSchema(""dummy"")); <line33> Completable opA = <line34> clientA.updateSchema(contentSchema.getUuid(), schemaUpdateRequest).toCompletable(); <line35> Completable opB = <line36> clientB <line37> .deleteNode(projectName, uuids.get(0)) <line38> .toCompletable() <line39> .delay(2000, TimeUnit.MILLISECONDS); <line40> Completable.merge(Arrays.asList(opA, opB)).blockingAwait(); <line41> Thread.sleep(30000); <line42> call(() -> clientA.findSchemaByUuid(contentSchema.getUuid())); <line43> call(() -> clientB.findSchemaByUuid(contentSchema.getUuid())); <line44> } <line45> } <line46> "	1	task3	
public class A { <line0> public Map<String, String> toMap() { <line1> Map<String, String> configMap = new HashMap<>(); <line2> configMap.put(Segment.SEGMENT_NAME, _segmentName); <line3> configMap.put(Segment.SEGMENT_TYPE, _segmentType.toString()); <line4> configMap.put(Segment.START_TIME, Long.toString(_startTime)); <line5> configMap.put(Segment.END_TIME, Long.toString(_endTime)); <line6> configMap.put(Segment.TIME_UNIT, _timeUnit != null ? _timeUnit.name() : null); <line7> configMap.put(Segment.INDEX_VERSION, _indexVersion); <line8> configMap.put(Segment.TOTAL_DOCS, Long.toString(_totalDocs)); <line9> configMap.put(Segment.CRC, Long.toString(_crc)); <line10> configMap.put(Segment.CREATION_TIME, Long.toString(_creationTime)); <line11> if (_partitionMetadata != null) { <line12> try { <line13> String partitionMetadataJson = _partitionMetadata.toJsonString(); <line14> configMap.put(Segment.PARTITION_METADATA, partitionMetadataJson); <line15> } catch (IOException e) { <line16> } <line17> } <line18> if (_segmentUploadStartTime > 0) { <line19> configMap.put(Segment.SEGMENT_UPLOAD_START_TIME, Long.toString(_segmentUploadStartTime)); <line20> } <line21> if (_crypterName != null) { <line22> configMap.put(Segment.CRYPTER_NAME, _crypterName); <line23> } <line24> if (_customMap != null) { <line25> try { <line26> configMap.put(Segment.CUSTOM_MAP, JsonUtils.objectToString(_customMap)); <line27> } catch (JsonProcessingException e) { <line28> throw new RuntimeException(e); <line29> } <line30> } <line31> if (_rawTableName != null) { <line32> configMap.put(Segment.TABLE_NAME, _rawTableName); <line33> } <line34> return configMap; <line35> } <line36> } <line37> 	1	task3	
"public class A { <line0> private void updateThreadCounts(final Element rootElement, final FlowController controller) { <line1> final Integer maxThreadCount = getInteger(rootElement, ""maxThreadCount""); <line2> if (maxThreadCount == null) { <line3> controller.setMaxTimerDrivenThreadCount(getInt(rootElement, ""maxTimerDrivenThreadCount"")); <line4> controller.setMaxEventDrivenThreadCount(getInt(rootElement, ""maxEventDrivenThreadCount"")); <line5> } else { <line6> controller.setMaxTimerDrivenThreadCount(maxThreadCount * 2 / 3); <line7> controller.setMaxEventDrivenThreadCount(maxThreadCount / 3); <line8> } <line9> } <line10> } <line11> "	1	task3	
public class A { <line0> @Override <line1> public void doFilter( <line2> ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) <line3> throws IOException, ServletException { <line4> Collection<String> globalAllowedOrigins = null; <line5> if (this.filterEnabled) { <line6> try { <line7> globalAllowedOrigins = doFilterImpl(servletRequest); <line8> } catch (Exception ex) { <line9> } <line10> super.doFilter(servletRequest, servletResponse, filterChain); <line11> setAllowedOrigins(globalAllowedOrigins); <line12> } else { <line13> filterChain.doFilter(servletRequest, servletResponse); <line14> } <line15> } <line16> } <line17> 	1	task3	
public class A { <line0> @JDebug <line1> public String getAction(Field field, Object element, Object parent) { <line2> return GET_ACTION.execute(field, element, parent); <line3> } <line4> } <line5> 	1	task3	
public class A { <line0> private static boolean cleanupFilesWithRetry(String[] filesToClean, int maxRetries) <line1> throws Exception { <line2> boolean allCleaned = false; <line3> while (!allCleaned && maxRetries-- > 0) { <line4> allCleaned = true; <line5> for (String f : filesToClean) { <line6> if (!f.trim().isEmpty()) { <line7> URI url = new URI(f); <line8> File file = new File(url); <line9> if (file.exists()) { <line10> deleteFolder(file); <line11> allCleaned = false; <line12> } <line13> } <line14> } <line15> Thread.sleep(200); <line16> } <line17> if (!allCleaned) { <line18> } <line19> return allCleaned; <line20> } <line21> } <line22> 	1	task3	
"public class A { <line0> @Test <line1> public void testALSServingModel() throws Exception { <line2> Map<String, Object> overlayConfig = new HashMap<>(); <line3> overlayConfig.put( <line4> ""oryx.serving.application-resources"", <line5> ""\""com.cloudera.oryx.app.serving,com.cloudera.oryx.app.serving.als\""""); <line6> overlayConfig.put(""oryx.serving.model-manager-class"", ALSServingModelManager.class.getName()); <line7> Config config = ConfigUtils.overlayOn(overlayConfig, getConfig()); <line8> startMessaging(); <line9> startServer(config); <line10> startUpdateTopics(new MockALSModelUpdateGenerator(), 10); <line11> sleepSeconds(5); <line12> ALSServingModelManager manager = <line13> (ALSServingModelManager) <line14> getServingLayer() <line15> .getContext() <line16> .getServletContext() <line17> .getAttribute(OryxResource.MODEL_MANAGER_KEY); <line18> assertNotNull(""Manager must initialize in web context"", manager); <line19> ALSServingModel model = manager.getModel(); <line20> assertNotNull(model); <line21> assertEquals(2, model.getFeatures()); <line22> assertTrue(model.isImplicit()); <line23> assertContainsSame(MockALSModelUpdateGenerator.Y.keySet(), model.getAllItemIDs()); <line24> assertNotNull(model.getYTYSolver()); <line25> MockALSModelUpdateGenerator.X.forEach( <line26> (id, vector) -> assertArrayEquals(vector, model.getUserVector(id))); <line27> MockALSModelUpdateGenerator.Y.forEach( <line28> (id, vector) -> assertArrayEquals(vector, model.getItemVector(id))); <line29> MockALSModelUpdateGenerator.A.forEach( <line30> (id, expected) -> assertContainsSame(expected, model.getKnownItems(id))); <line31> } <line32> } <line33> "	1	task3	
public class A { <line0> @Override <line1> public void setPermissions(final Set<PosixFilePermission> perms) throws IOException { <line2> if (file == null) { <line3> return; <line4> } <line5> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line6> file.setProperty( <line7> AbstractNode.visibleToAuthenticatedUsers, perms.contains(PosixFilePermission.GROUP_READ)); <line8> file.setProperty( <line9> AbstractNode.visibleToPublicUsers, perms.contains(PosixFilePermission.OTHERS_READ)); <line10> tx.success(); <line11> } catch (FrameworkException fex) { <line12> } <line13> } <line14> } <line15> 	1	task3	
public class A { <line0> public static void unsubscribeKBArticle(long resourcePrimKey) throws RemoteException { <line1> try { <line2> KBArticleServiceUtil.unsubscribeKBArticle(resourcePrimKey); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> @Override <line1> public void link(String linkPath, String targetPath, boolean symbolic) throws IOException { <line2> if (!isOpen()) { <line3> throw new IOException( <line4> ""link("" <line5> + linkPath <line6> + "" => "" <line7> + targetPath <line8> + "")[symbolic="" <line9> + symbolic <line10> + ""] client is closed""); <line11> } <line12> if (log.isDebugEnabled()) { <line13> } <line14> Buffer buffer = new ByteArrayBuffer(linkPath.length() + targetPath.length() + Long.SIZE, false); <line15> int version = getVersion(); <line16> if (version < SftpConstants.SFTP_V6) { <line17> if (!symbolic) { <line18> throw new UnsupportedOperationException(""Hard links are not supported in sftp v"" + version); <line19> } <line20> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, targetPath, 0); <line21> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, linkPath, 1); <line22> checkCommandStatus(SftpConstants.SSH_FXP_SYMLINK, buffer); <line23> } else { <line24> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, targetPath, 0); <line25> buffer = putReferencedName(SftpConstants.SSH_FXP_SYMLINK, buffer, linkPath, 1); <line26> buffer.putBoolean(symbolic); <line27> checkCommandStatus(SftpConstants.SSH_FXP_LINK, buffer); <line28> } <line29> } <line30> } <line31> "	1	task3	
public class A { <line0> protected boolean isStagingUseVirtualHostForRemoteSite() { <line1> try { <line2> StagingConfiguration stagingConfiguration = <line3> _configurationProvider.getCompanyConfiguration( <line4> StagingConfiguration.class, CompanyThreadLocal.getCompanyId()); <line5> return stagingConfiguration.stagingUseVirtualHostForRemoteSite(); <line6> } catch (Exception exception) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> private void initHttpPipeline(ChannelHandlerContext ctx) { <line1> ctx.pipeline() <line2> .addLast(letsEncryptHandler) <line3> .addLast(""HttpChunkedWrite"", new ChunkedWriteHandler()) <line4> .addLast(""HttpUrlMapper"", new UrlReWriterHandler(""/favicon.ico"", ""/static/favicon.ico"")) <line5> .addLast( <line6> ""HttpStaticFile"", <line7> new StaticFileHandler( <line8> holder.props, <line9> new StaticFile(""/static""), <line10> new StaticFileEdsWith(FileUtils.CSV_DIR, "".gz""), <line11> new StaticFileEdsWith(FileUtils.CSV_DIR, "".zip""))) <line12> .addLast(resetPasswordLogic) <line13> .addLast(httpAPILogic) <line14> .addLast(noMatchHandler) <line15> .remove(this); <line16> if (log.isTraceEnabled()) { <line17> } <line18> } <line19> } <line20> "	1	task3	
"public class A { <line0> protected void resetCacheMap(Collection<?> resources) { <line1> Collection<String> toDelete = Collections.emptySet(); <line2> synchronized (cacheMap) { <line3> if (cacheMap.size() <= 0) { <line4> return; <line5> } <line6> if (GenericUtils.isEmpty(resources)) { <line7> cacheMap.clear(); <line8> return; <line9> } <line10> for (Object r : resources) { <line11> String resourceKey = <line12> ValidateUtils.checkNotNullAndNotEmpty( <line13> Objects.toString(r, null), ""No resource key value""); <line14> if (cacheMap.containsKey(resourceKey)) { <line15> continue; <line16> } <line17> if (toDelete.isEmpty()) { <line18> toDelete = new TreeSet<>(String.CASE_INSENSITIVE_ORDER); <line19> } <line20> if (!toDelete.add(resourceKey)) { <line21> continue; <line22> } <line23> } <line24> if (GenericUtils.size(toDelete) > 0) { <line25> toDelete.forEach(cacheMap::remove); <line26> } <line27> } <line28> if (log.isDebugEnabled()) { <line29> } <line30> } <line31> } <line32> "	1	task3	
"public class A { <line0> private boolean _isBundleInstalled(Bundle bundle, URL url, String location) throws IOException { <line1> try (InputStream inputStream = url.openStream(); <line2> JarInputStream jarInputStream = new JarInputStream(inputStream)) { <line3> Manifest manifest = jarInputStream.getManifest(); <line4> Attributes attributes = manifest.getMainAttributes(); <line5> String symbolicName = attributes.getValue(Constants.BUNDLE_SYMBOLICNAME); <line6> Version version = new Version(attributes.getValue(Constants.BUNDLE_VERSION)); <line7> for (Bundle installedBundle : _bundleContext.getBundles()) { <line8> if (symbolicName.equals(installedBundle.getSymbolicName()) <line9> && version.equals(installedBundle.getVersion()) <line10> && !location.equals(installedBundle.getLocation())) { <line11> if (log.isInfoEnabled()) { <line12> StringBundler sb = new StringBundler(7); <line13> sb.append(""Skipping installation of ""); <line14> sb.append(symbolicName); <line15> sb.append("" with version ""); <line16> sb.append(version.toString()); <line17> sb.append("" in ""); <line18> sb.append(bundle.getSymbolicName()); <line19> sb.append("" because an identical bundle exists""); <line20> } <line21> return true; <line22> } <line23> } <line24> } <line25> return false; <line26> } <line27> } <line28> "	1	task3	
"public class A { <line0> @Test <line1> public void testSearchByUrl() throws Exception { <line2> String url = ""Patient?given=Vincent&family=Freeman&_format=json""; <line3> Bundle result = requestBody(""direct://SEARCH_BY_URL"", url); <line4> assertNotNull(result, ""searchByUrl result""); <line5> Patient patient = (Patient) result.getEntry().get(0).getResource(); <line6> assertNotNull(patient); <line7> assertEquals(""Freeman"", patient.getName().get(0).getFamily()); <line8> } <line9> } <line10> "	1	task3	
"public class A { <line0> public void verifyTest_2_6() throws Exception { <line1> Context context = new Context(); <line2> CheckPointReport result = <line3> verifyValidation( <line4> log, context, ""trip_6"", ""2-GTFS-Trip-6"", SEVERITY.WARNING, RESULT.NOK, true); <line5> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line6> for (CheckPointErrorReport detail : getDetails(context, result)) { <line7> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line8> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line9> Assert.assertEquals( <line10> detail.getSource().getFile().getFilename(), ""trips.txt"", ""detail must refer bad file""); <line11> Assert.assertEquals( <line12> detail.getSource().getFile().getLineNumber(), <line13> Integer.valueOf(2), <line14> ""detail must refer bad line""); <line15> } <line16> } <line17> } <line18> "	1	task3	
"public class A { <line0> @Override <line1> protected void doGet(HttpServletRequest request, HttpServletResponse response) <line2> throws ServletException, IOException { <line3> try { <line4> GwtXSRFToken token = new GwtXSRFToken(request.getParameter(""xsrfToken"")); <line5> KuraRemoteServiceServlet.checkXSRFToken(request, token); <line6> } catch (Exception e) { <line7> throw new ServletException(""Security error: please retry this operation correctly."", e); <line8> } <line9> try { <line10> final List<ComponentConfiguration> result = new ArrayList<>(); <line11> ServiceLocator.applyToServiceOptionally( <line12> CryptoService.class, <line13> cryptoService -> { <line14> ServiceLocator.applyToServiceOptionally( <line15> WireGraphService.class, <line16> wireGraphService -> { <line17> wireGraphService.get().getWireComponentConfigurations().stream() <line18> .map(WireComponentConfiguration::getConfiguration) <line19> .map(config -> removeDefinition(processPasswords(config, cryptoService))) <line20> .forEach(result::add); <line21> return null; <line22> }); <line23> final Set<String> driverPids = findReferencedDrivers(result); <line24> ServiceLocator.applyToServiceOptionally( <line25> ConfigurationService.class, <line26> configurationService -> { <line27> configurationService.getComponentConfigurations().stream() <line28> .filter(config -> driverPids.contains(config.getPid())) <line29> .map(config -> removeDefinition(processPasswords(config, cryptoService))) <line30> .forEach(result::add); <line31> result.add( <line32> removeDefinition( <line33> configurationService.getComponentConfiguration(WIRE_GRAPH_SERVICE_PID))); <line34> return null; <line35> }); <line36> return null; <line37> }); <line38> final XmlComponentConfigurations xmlConfigs = new XmlComponentConfigurations(); <line39> xmlConfigs.setConfigurations(result); <line40> final String marshalled = toSnapshot(xmlConfigs); <line41> final String snapshotName = ""graph_snapshot_"" + System.currentTimeMillis() + "".xml""; <line42> response.setCharacterEncoding(""UTF-8""); <line43> response.setContentType(""application/xml""); <line44> response.setHeader(""Content-Disposition"", ""attachment; filename="" + snapshotName); <line45> response.setHeader(""Cache-Control"", ""no-transform, max-age=0""); <line46> try (PrintWriter writer = response.getWriter()) { <line47> writer.write(marshalled); <line48> } <line49> } catch (Exception e) { <line50> throw new ServletException(""Failed to download snapshot""); <line51> } <line52> } <line53> } <line54> "	1	task3	
public class A { <line0> @Override <line1> public void remoteDeviceAdded(Registry registry, RemoteDevice device) { <line2> for (UpnpDiscoveryParticipant participant : participants) { <line3> try { <line4> DiscoveryResult result = participant.createResult(device); <line5> if (result != null) { <line6> if (participant.getRemovalGracePeriodSeconds(device) > 0) { <line7> cancelRemovalTask(device.getIdentity().getUdn()); <line8> } <line9> thingDiscovered(result); <line10> } <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> 	1	task3	
"public class A { <line0> private Class<?> getMessageDTOClass(final String messageType, final boolean request) { <line1> switch (messageType) { <line2> case CoreCommonConstants.RELAY_MESSAGE_TYPE_GSD_POLL: <line3> return request ? GSDPollRequestDTO.class : GSDPollResponseDTO.class; <line4> case CoreCommonConstants.RELAY_MESSAGE_TYPE_ICN_PROPOSAL: <line5> return request ? ICNProposalRequestDTO.class : ICNProposalResponseDTO.class; <line6> case CoreCommonConstants.RELAY_MESSAGE_TYPE_ACCESS_TYPE: <line7> return request ? GeneralRelayRequestDTO.class : AccessTypeRelayResponseDTO.class; <line8> case CoreCommonConstants.RELAY_MESSAGE_TYPE_SYSTEM_ADDRESS_LIST: <line9> return request ? GeneralRelayRequestDTO.class : SystemAddressSetRelayResponseDTO.class; <line10> case CoreCommonConstants.RELAY_MESSAGE_TYPE_QOS_RELAY_TEST: <line11> return request <line12> ? QoSRelayTestProposalRequestDTO.class <line13> : QoSRelayTestProposalResponseDTO.class; <line14> default: <line15> throw new ArrowheadException(""Invalid message type: "" + messageType); <line16> } <line17> } <line18> } <line19> "	1	task3	
"public class A { <line0> @Override <line1> public String getSubEquipmentConfigXML(final SubEquipmentCacheObject subEquipmentCacheObject) { <line2> StringBuilder str = new StringBuilder(""    <SubEquipmentUnit  id=\""""); <line3> str.append(subEquipmentCacheObject.getId()); <line4> str.append(""\"" name=\""""); <line5> str.append(subEquipmentCacheObject.getName()); <line6> str.append(""\"">\n""); <line7> str.append(""      <commfault-tag-id>""); <line8> str.append(subEquipmentCacheObject.getCommFaultTagId()); <line9> str.append(""</commfault-tag-id>\n""); <line10> str.append(""      <commfault-tag-value>""); <line11> str.append(subEquipmentCacheObject.getCommFaultTagValue()); <line12> str.append(""</commfault-tag-value>\n""); <line13> str.append(""      <alive-tag-id>""); <line14> str.append(subEquipmentCacheObject.getAliveTagId()); <line15> str.append(""</alive-tag-id>\n""); <line16> str.append(""      <alive-interval>""); <line17> str.append(subEquipmentCacheObject.getAliveInterval()); <line18> str.append(""</alive-interval>\n""); <line19> str.append(""    </SubEquipmentUnit>\n""); <line20> return str.toString(); <line21> } <line22> } <line23> "	1	task3	
"public class A { <line0> @POST <line1> @Path(""/@merge"") <line2> @Consumes(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line3> @Produces(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line4> public Response<Resource> mergeContacts( <line5> @PathParam(""said"") String said, Request<Resource> request) { <line6> Data<Resource> returnData = null; <line7> Resource entry = request.getMessage().getData().entry.iterator().next(); <line8> ArrayList items = (ArrayList) entry.get(""items""); <line9> try { <line10> Collection<URIImpl[]> collectionUris = toUriCollection(items); <line11> returnData = new Data<Resource>(0, collectionUris.size(), collectionUris.size()); <line12> for (URIImpl[] personUri : collectionUris) { <line13> Person person = null; <line14> URI master = personUri[0]; <line15> URI[] targets = (URI[]) ArrayUtils.remove(personUri, 0); <line16> person = personManager.merge(master, targets); <line17> returnData.getEntries().add(new Resource(person, personManager.getMe().asURI())); <line18> } <line19> } catch (InfosphereException e) { <line20> return Response.badRequest(e.getMessage(), e); <line21> } catch (Exception e) { <line22> return Response.serverError(e.getMessage(), e); <line23> } <line24> return Response.ok(returnData); <line25> } <line26> } <line27> "	1	task3	
"public class A { <line0> private static InputStreamReader loadConfig() <line1> throws AgentPackageNotFoundException, ConfigNotFoundException { <line2> String specifiedConfigPath = System.getProperty(SPECIFIED_CONFIG_PATH); <line3> File configFile = <line4> StringUtil.isEmpty(specifiedConfigPath) <line5> ? new File(AgentPackagePath.getPath(), DEFAULT_CONFIG_FILE_NAME) <line6> : new File(specifiedConfigPath); <line7> if (configFile.exists() && configFile.isFile()) { <line8> try { <line9> return new InputStreamReader(new FileInputStream(configFile), StandardCharsets.UTF_8); <line10> } catch (FileNotFoundException e) { <line11> throw new ConfigNotFoundException(""Failed to load agent.config"", e); <line12> } <line13> } <line14> throw new ConfigNotFoundException(""Failed to load agent.config.""); <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> void onConsumedSubpartition(int subpartitionIndex) { <line1> if (isReleased.get()) { <line2> return; <line3> } <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> @Override <line1> public void run() { <line2> for (ImageryFileSource src : mySources) { <line3> if (src.isCreateOverviews() && mySourceToDsMap.get(src) != null) { <line4> myTotalFileCount++; <line5> } <line6> } <line7> myCurrentFileCount = 0; <line8> EventQueueUtilities.runOnEDT( <line9> new Runnable() { <line10> @Override <line11> public void run() { <line12> myProcFilePB.setMaximum(myTotalFileCount); <line13> myProcFilePB.setValue(0); <line14> myProcFileNoteLB.setText(""Processing File 1 of "" + myTotalFileCount); <line15> myFileOVGenPB.setMaximum(100); <line16> myFileOVGenPB.setValue(0); <line17> myConsoleOutputTA.setText( <line18> myConsoleOutputTA.getText() + ""Beginning Overview Generation...\n""); <line19> } <line20> }); <line21> for (ImageryFileSource src : mySources) { <line22> if (src.isCreateOverviews() && mySourceToDsMap.get(src) != null) { <line23> final String fileName = src.getName(); <line24> EventQueueUtilities.runOnEDT( <line25> new Runnable() { <line26> @Override <line27> public void run() { <line28> myProcFileNoteLB.setText( <line29> ""Processing File "" + (myCurrentFileCount + 1) + "" of "" + myTotalFileCount); <line30> myProcFilePB.setMaximum(myTotalFileCount); <line31> myFileOVGenPB.setValue(0); <line32> myGenOvNoteLB.setText(""Generating Overview Files For: "" + fileName); <line33> myConsoleOutputTA.setText( <line34> myConsoleOutputTA.getText() + ""Processing File: "" + fileName + ""\n""); <line35> } <line36> }); <line37> Dataset ds = mySourceToDsMap.get(src); <line38> int[] levels = {2, 4, 8, 16, 32, 64, 128}; <line39> try { <line40> if (ds.BuildOverviews(""NEAREST"", levels, myProgressCallback) != gdalconst.CE_None) { <line41> EventQueueUtilities.runOnEDT( <line42> () -> <line43> myConsoleOutputTA.setText( <line44> myConsoleOutputTA.getText() + ""ERROR: Failed to create overview\n"")); <line45> } else { <line46> src.setHasOverviews(true); <line47> } <line48> } catch (RuntimeException e) { <line49> final Exception fExc = e; <line50> EventQueueUtilities.runOnEDT( <line51> () -> <line52> myConsoleOutputTA.setText( <line53> myConsoleOutputTA.getText() <line54> + ""ERROR: Exception while creating overview:\n"" <line55> + fExc.getMessage() <line56> + ""\n"")); <line57> } <line58> myCurrentFileCount++; <line59> EventQueueUtilities.runOnEDT( <line60> new Runnable() { <line61> @Override <line62> public void run() { <line63> myProcFilePB.setValue(myCurrentFileCount); <line64> myConsoleOutputTA.setText( <line65> myConsoleOutputTA.getText() + ""Done With File: "" + fileName + ""\n""); <line66> } <line67> }); <line68> } <line69> } <line70> finishStuff(); <line71> } <line72> } <line73> "	1	task3	
"public class A { <line0> private EntitySpec<?> resolve( <line1> Collection<EntitySpecResolver> resolvers, <line2> String localType, <line3> BrooklynClassLoadingContext loader, <line4> Set<String> encounteredTypes) { <line5> Collection<String> resolversWhoDontSupport = new ArrayList<String>(); <line6> Collection<Exception> otherProblemsFromResolvers = new ArrayList<Exception>(); <line7> for (EntitySpecResolver resolver : resolvers) { <line8> if (resolver.accepts(localType, loader)) { <line9> try { <line10> EntitySpec<?> spec = resolver.resolve(localType, loader, encounteredTypes); <line11> if (spec != null) { <line12> return spec; <line13> } else { <line14> resolversWhoDontSupport.add(resolver.getName() + "" (returned null)""); <line15> } <line16> } catch (Exception e) { <line17> otherProblemsFromResolvers.add( <line18> new PropagatedRuntimeException( <line19> ""Transformer for "" + resolver.getName() + "" gave an error creating this plan: "", <line20> Exceptions.collapseText(e), <line21> e)); <line22> } <line23> } <line24> } <line25> if (!otherProblemsFromResolvers.isEmpty()) { <line26> throw otherProblemsFromResolvers.size() == 1 <line27> ? Exceptions.create(null, otherProblemsFromResolvers) <line28> : Exceptions.create(""ServiceSpecResolvers all failed"", otherProblemsFromResolvers); <line29> } <line30> return null; <line31> } <line32> } <line33> "	1	task3	
"public class A { <line0> @Override <line1> public DLFileShortcut findByUUID_G(String uuid, long groupId) throws NoSuchFileShortcutException { <line2> DLFileShortcut dlFileShortcut = fetchByUUID_G(uuid, groupId); <line3> if (dlFileShortcut == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""uuid=""); <line7> sb.append(uuid); <line8> sb.append("", groupId=""); <line9> sb.append(groupId); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchFileShortcutException(sb.toString()); <line14> } <line15> return dlFileShortcut; <line16> } <line17> } <line18> "	1	task3	
"public class A { <line0> public Date rescheduleJob(Long scheduleJobId) throws Exception { <line1> ScheduleJob scheduleJob = this.schedulerService.loadScheduleJob(scheduleJobId); <line2> if (scheduleJob == null) { <line3> return null; <line4> } <line5> Date nextDate; <line6> CronTrigger trigger = <line7> (CronTrigger) <line8> this.scheduler.getTrigger( <line9> triggerKey(scheduleJob.getTriggerName(), scheduleJob.getGroupn())); <line10> if (null == trigger) { <line11> throw new CoreException(""trigger not exist:scheduleJobId="" + scheduleJobId); <line12> } else { <line13> TriggerKey key = trigger.getKey(); <line14> trigger = <line15> newTrigger().withIdentity(key).withSchedule(cronSchedule(scheduleJob.getCron())).build(); <line16> nextDate = this.scheduler.rescheduleJob(key, trigger); <line17> } <line18> if (scheduleJob.getStatus() != BCConstants.STATUS_ENABLED) { <line19> scheduleJob.setStatus(BCConstants.STATUS_ENABLED); <line20> this.schedulerService.saveScheduleJob(scheduleJob); <line21> } <line22> return nextDate; <line23> } <line24> } <line25> "	1	task3	
"public class A { <line0> private void addSingleResourceToHive( <line1> HiveDriver driver, ResourceEntry res, LensSessionHandle sessionHandle) throws LensException { <line2> String sessionIdentifier = sessionHandle.getPublicId().toString(); <line3> String uri = res.getUri(); <line4> uri = removePrefixBeforeURI(uri); <line5> String command = ""add "" + res.getType().toLowerCase() + "" "" + uri; <line6> driver.execute(createResourceQuery(command, sessionHandle, driver)); <line7> } <line8> } <line9> "	1	task3	
public class A { <line0> public static <T> T fromJson(String jsonStr, Class<T> type) { <line1> T ret = null; <line2> if (jsonStr != null) { <line3> try { <line4> ret = mapper.readValue(jsonStr, type); <line5> if (ret instanceof Struct) { <line6> ((Struct) ret).normalize(); <line7> } <line8> } catch (IOException e) { <line9> ret = null; <line10> } <line11> } <line12> return ret; <line13> } <line14> } <line15> 	1	task3	
"public class A { <line0> private MassnahmeInformationTransfer processMassnahme( <line1> MbMassn mbMassn, <line2> String encoding, <line3> List<?> hqlResult, <line4> MassnahmeInformationTransfer massnahmeinformation) { <line5> MbMassnTxt mTxt = (MbMassnTxt) hqlResult.get(0); <line6> massnahmeinformation.setAbstract_(mTxt.getAbstract_()); <line7> massnahmeinformation.setTitel(mTxt.getName()); <line8> try { <line9> if (mTxt.getBeschreibung() != null) { <line10> massnahmeinformation.setDescription( <line11> convertClobToStringEncodingSave(mTxt.getBeschreibung(), encoding)); <line12> } <line13> if (mTxt.getHtmltext() != null) { <line14> massnahmeinformation.setHtmltext( <line15> convertClobToStringEncodingSave(mTxt.getHtmltext(), encoding)); <line16> } <line17> } catch (IOException e) { <line18> } <line19> String prefix = """"; <line20> if (mbMassn.getUserdef() == GSDBConstants.USERDEF_YES) { <line21> prefix = USER_DEFINED_CONTROL_IDENTIFIER; <line22> } <line23> massnahmeinformation.setId(prefix + mbMassn.getMskId().intValue() + ""."" + mbMassn.getNr()); <line24> massnahmeinformation.setSiegelstufe('A'); <line25> massnahmeinformation.setZyklus(""-1""); <line26> return massnahmeinformation; <line27> } <line28> } <line29> "	1	task3	
"public class A { <line0> private int readdirInternal(String path, long buff, long filter, long offset, FuseFileInfo fi) { <line1> final AlluxioURI uri = mPathResolverCache.getUnchecked(path); <line2> try { <line3> FuseFillDir.apply(filter, buff, ""."", null, 0); <line4> FuseFillDir.apply(filter, buff, "".."", null, 0); <line5> mFileSystem.iterateStatus( <line6> uri, <line7> file -> { <line8> FuseFillDir.apply(filter, buff, file.getName(), null, 0); <line9> }); <line10> } catch (Throwable e) { <line11> return -ErrorCodes.EIO(); <line12> } <line13> return 0; <line14> } <line15> } <line16> "	1	task3	
public class A { <line0> @Override <line1> public TSStatus testInsertTablets(TSInsertTabletsReq req) { <line2> return RpcUtils.getStatus(TSStatusCode.SUCCESS_STATUS); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> private void loadStoppableInstance() { <line1> try { <line2> Method getInstanceMethod = <line3> injectorClassInstance.getClass().getMethod(""getInstance"", Class.class); <line4> Class stoppableClass = <line5> deploymentUnitClassLoader.loadClass(""com.flipkart.flux.client.runtime.Stoppable""); <line6> stoppableInstance = getInstanceMethod.invoke(injectorClassInstance, stoppableClass); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	1	task3	
"public class A { <line0> public void convertVideo( <line1> FileItem f, StoredFile sf, ProcessResultList logs, Optional<DoubleConsumer> progress) { <line2> try { <line3> final File mp4 = f.getFile(EXTENSION_MP4); <line4> f.setType(Type.VIDEO); <line5> final String ext = sf.getExt(); <line6> String input = f.getFile(ext).getCanonicalPath(); <line7> boolean sameExt = EXTENSION_MP4.equals(ext); <line8> Path tmp = null; <line9> if (sameExt) { <line10> tmp = Files.createTempFile(""video"", "".mp4""); <line11> input = Files.move(mp4.toPath(), tmp, REPLACE_EXISTING).toFile().getCanonicalPath(); <line12> } <line13> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line14> List<String> args = new ArrayList<>(List.of(getPathToFFMPEG(), ""-y"")); <line15> if (sf.isAudio()) { <line16> args.addAll( <line17> List.of( <line18> ""-loop"", <line19> ""1"", <line20> ""-framerate"", <line21> ""24"", <line22> ""-i"", <line23> new File(getCssImagesDir(), ""audio.jpg"").getCanonicalPath())); <line24> } <line25> args.addAll( <line26> List.of( <line27> ""-i"", <line28> input, <line29> ""-c:v"", <line30> ""h264"", <line31> ""-c:a"", <line32> ""aac"", <line33> ""-pix_fmt"", <line34> ""yuv420p"", <line35> ""-vf"", <line36> ""pad=ceil(iw/2)*2:ceil(ih/2)*2"")); <line37> if (sf.isAudio()) { <line38> args.add(""-shortest""); <line39> } <line40> args.add(mp4.getCanonicalPath()); <line41> ProcessResult res = ProcessHelper.exec(""convert to MP4 :: "" + f.getHash(), args); <line42> logs.add(res); <line43> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line44> if (sameExt && tmp != null) { <line45> if (res.isOk()) { <line46> Files.delete(tmp); <line47> } else { <line48> Files.move(tmp, mp4.toPath(), REPLACE_EXISTING); <line49> } <line50> } <line51> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line52> Dimension dim = getDimension(res.getError(), new Dimension(100, 100)); <line53> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line54> f.setWidth(dim.getWidth()); <line55> f.setHeight(dim.getHeight()); <line56> convertToPng(f, mp4.getCanonicalPath(), logs); <line57> progress.ifPresent(theProgress -> theProgress.accept(STEP)); <line58> } catch (Exception err) { <line59> logs.add(new ProcessResult(""convertToMP4"", err.getMessage(), err)); <line60> } <line61> } <line62> } <line63> "	1	task3	
public class A { <line0> protected final void handleClosed(AmqpProvider provider, ProviderException cause) { <line1> provider.removeFromFailOnConnectionDropTracking(request); <line2> resourceInfo.setState(ResourceState.REMOTELY_CLOSED); <line3> afterClosed(getResource(), getResourceInfo()); <line4> ProviderException openError; <line5> if (hasRemoteError()) { <line6> openError = getOpenAbortExceptionFromRemote(); <line7> } else if (cause != null) { <line8> openError = cause; <line9> } else { <line10> openError = getDefaultOpenAbortException(); <line11> } <line12> if (requestTimeoutTask != null) { <line13> requestTimeoutTask.cancel(false); <line14> } <line15> getEndpoint().close(); <line16> getEndpoint().free(); <line17> getEndpoint().setContext(null); <line18> getRequest().onFailure(openError); <line19> } <line20> } <line21> 	1	task3	
public class A { <line0> @Override <line1> public void onPostUpdate(final PostUpdateEvent event) { <line2> Object entity = event.getEntity(); <line3> if (!(entity instanceof HTextFlowTarget)) { <line4> return; <line5> } <line6> final HTextFlowTarget target = HTextFlowTarget.class.cast(event.getEntity()); <line7> try { <line8> runInTransaction( <line9> () -> { <line10> ContentState oldContentState = <line11> (ContentState) <line12> Iterables.find( <line13> Lists.newArrayList(event.getOldState()), <line14> Predicates.instanceOf(ContentState.class)); <line15> prepareTransUnitUpdatedEvent(target.getVersionNum() - 1, oldContentState, target); <line16> }); <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> 	1	task3	
public class A { <line0> @Override <line1> public List<? extends IContainer> getSourceFolders(IProject project) { <line2> List<IContainer> sourceFolders = Lists.newArrayList(); <line3> IJavaProject javaProject = JavaCore.create(project); <line4> IClasspathEntry[] classpath; <line5> if (!javaProject.exists()) { <line6> return Collections.emptyList(); <line7> } <line8> try { <line9> classpath = javaProject.getRawClasspath(); <line10> } catch (JavaModelException e) { <line11> return Collections.emptyList(); <line12> } <line13> for (IClasspathEntry entry : classpath) { <line14> if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE) { <line15> IPath path = entry.getPath(); <line16> if (path.segmentCount() == 1) { <line17> sourceFolders.add(project); <line18> } else { <line19> sourceFolders.add(project.getWorkspace().getRoot().getFolder(entry.getPath())); <line20> } <line21> } <line22> } <line23> return sourceFolders; <line24> } <line25> } <line26> 	1	task3	
"public class A { <line0> protected List<Range<Long>> parseRangeHeader(String value) { <line1> Iterator<Range<Long>> i; <line2> String byteRangesSpecifier[], bytesUnit, byteRangeSet[]; <line3> List<Range<Long>> res; <line4> long lastEnd = -1; <line5> if (value == null) { <line6> return null; <line7> } <line8> res = new ArrayList<Range<Long>>(); <line9> byteRangesSpecifier = value.split(""=""); <line10> if (byteRangesSpecifier.length != 2) { <line11> return null; <line12> } <line13> bytesUnit = byteRangesSpecifier[0]; <line14> byteRangeSet = byteRangesSpecifier[1].split("",""); <line15> if (!bytesUnit.equals(""bytes"")) { <line16> return null; <line17> } <line18> for (String byteRangeSpec : byteRangeSet) { <line19> String[] bytePos; <line20> Long firstBytePos = null, lastBytePos = null; <line21> bytePos = byteRangeSpec.split(""-"", -1); <line22> try { <line23> if (bytePos[0].trim().length() > 0) { <line24> firstBytePos = Long.valueOf(bytePos[0].trim()); <line25> } <line26> if (bytePos[1].trim().length() > 0) { <line27> lastBytePos = Long.valueOf(bytePos[1].trim()); <line28> } <line29> } catch (NumberFormatException e) { <line30> } <line31> if ((firstBytePos == null) && (lastBytePos == null)) { <line32> return null; <line33> } else if (firstBytePos == null) { <line34> firstBytePos = length - lastBytePos; <line35> lastBytePos = length - 1; <line36> } else if (lastBytePos == null) { <line37> lastBytePos = length - 1; <line38> } <line39> if (firstBytePos > lastBytePos) { <line40> return null; <line41> } <line42> if (firstBytePos < 0) { <line43> return null; <line44> } <line45> if (lastBytePos >= length) { <line46> return null; <line47> } <line48> res.add(new Range<Long>(firstBytePos, lastBytePos)); <line49> } <line50> Collections.sort(res); <line51> i = res.listIterator(); <line52> while (i.hasNext()) { <line53> Range<Long> range; <line54> range = i.next(); <line55> if (lastEnd >= range.getStart()) { <line56> range.setStart(lastEnd + 1); <line57> if ((range.getStart() >= length) || (range.getStart() > range.getEnd())) { <line58> i.remove(); <line59> } else { <line60> lastEnd = range.getEnd(); <line61> } <line62> } else { <line63> lastEnd = range.getEnd(); <line64> } <line65> } <line66> if (res.isEmpty()) { <line67> return null; <line68> } else { <line69> return res; <line70> } <line71> } <line72> } <line73> "	1	task3	
"public class A { <line0> @Override <line1> public FileVirtualPoolBulkRep queryBulkResourceReps(List<URI> ids) { <line2> if (!ids.iterator().hasNext()) { <line3> return new FileVirtualPoolBulkRep(); <line4> } <line5> String shortVdcId = VdcUtil.getVdcId(VirtualArray.class, ids.iterator().next()).toString(); <line6> Iterator<VirtualPool> dbIterator; <line7> if (shortVdcId.equals(VdcUtil.getLocalShortVdcId())) { <line8> dbIterator = _dbClient.queryIterativeObjects(getResourceClass(), ids); <line9> } else { <line10> GeoServiceClient geoClient = _geoHelper.getClient(shortVdcId); <line11> try { <line12> dbIterator = geoClient.queryObjects(getResourceClass(), ids); <line13> } catch (Exception ex) { <line14> throw APIException.internalServerErrors.genericApisvcError( <line15> ""error retrieving remote virtual pool"", ex); <line16> } <line17> } <line18> return new FileVirtualPoolBulkRep( <line19> BulkList.wrapping( <line20> dbIterator, <line21> new mapFileVirtualPoolWithResources(), <line22> new BulkList.VirtualPoolFilter(Type.file))); <line23> } <line24> } <line25> "	1	task3	
public class A { <line0> @Override <line1> public void startStream() { <line2> executor.submit(task); <line3> running.set(true); <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> @Test <line1> public void test_06_MixedVep() { <line2> compareVep(""testHg3775Chr7"", path(""mixed_chr7.vcf"")); <line3> } <line4> } <line5> "	1	task3	
"public class A { <line0> private void debug( <line1> CSpaceResource res, <line2> Authentication authToken, <line3> Serializable objectIdId, <line4> String objectIdType, <line5> Permission perm) { <line6> if (log.isTraceEnabled() == true) { <line7> String resourceTarget = <line8> ""["" <line9> + res.getId() <line10> + ""]"" <line11> + "" | "" <line12> + ""["" <line13> + ""objectIdId: "" <line14> + objectIdType <line15> + ""("" <line16> + objectIdId <line17> + "")]""; <line18> System.out.println(""PERMISSION CHECK FOR: "" + resourceTarget); <line19> System.out.println( <line20> ""\tPrincipal: "" + authToken.getName() + ""\tTenant ID: "" + res.getTenantId()); <line21> System.out.println(""\tRoles: "" + authToken.getAuthorities()); <line22> System.out.println( <line23> ""\tPermission Mask: "" + perm.getMask() + "" - Permission Pattern: "" + perm.getPattern()); <line24> System.out.println(""""); <line25> } <line26> } <line27> } <line28> "	1	task3	
public class A { <line0> private void error(String message) { <line1> } <line2> } <line3> 	1	task3	
public class A { <line0> @Override <line1> public boolean engineIsCertificateEntry(String alias) { <line2> return false; <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> static Collection<Path> toMappings( <line1> File contractFile, Collection<Contract> contracts, File mappingsFolder) { <line2> StubGeneratorProvider provider = new StubGeneratorProvider(); <line3> Collection<StubGenerator> stubGenerators = <line4> provider.allOrDefault(new DslToWireMockClientConverter()); <line5> if (log.isDebugEnabled()) { <line6> } <line7> Collection<Path> mappings = new LinkedList<>(); <line8> for (StubGenerator stubGenerator : stubGenerators) { <line9> Map<Contract, String> map = <line10> stubGenerator.convertContents( <line11> contractFile.getName(), <line12> new ContractMetadata( <line13> contractFile.toPath(), false, contracts.size(), null, contracts)); <line14> for (Map.Entry<Contract, String> entry : map.entrySet()) { <line15> String value = entry.getValue(); <line16> File mapping = <line17> new File( <line18> mappingsFolder, <line19> StringUtils.stripFilenameExtension(contractFile.getName()) <line20> + ""_"" <line21> + Math.abs(entry.getKey().hashCode()) <line22> + stubGenerator.fileExtension()); <line23> mappings.add(storeFile(mapping.toPath(), value.getBytes())); <line24> } <line25> } <line26> return mappings; <line27> } <line28> } <line29> "	1	task3	
"public class A { <line0> @Override <line1> public void onNodeDeletion() { <line2> super.onNodeDeletion(); <line3> final String thisName = getName(); <line4> for (SchemaView view : getProperty(SchemaProperty.schemaViews)) { <line5> final String sortOrder = view.getProperty(SchemaView.sortOrder); <line6> if (sortOrder != null) { <line7> try { <line8> view.setProperty( <line9> SchemaView.sortOrder, <line10> StringUtils.join( <line11> Arrays.stream(sortOrder.split("","")) <line12> .filter(propertyName -> !thisName.equals(propertyName)) <line13> .toArray(), <line14> "","")); <line15> } catch (FrameworkException ex) { <line16> } <line17> } <line18> } <line19> final AbstractSchemaNode parent = getProperty(SchemaProperty.schemaNode); <line20> if (parent != null) { <line21> final ConfigurationProvider conf = StructrApp.getConfiguration(); <line22> final Class type = conf.getNodeEntityClass(parent.getName()); <line23> if (type != null) { <line24> conf.unregisterProperty(type, conf.getPropertyKeyForJSONName(type, getPropertyName())); <line25> } <line26> } <line27> } <line28> } <line29> "	1	task3	
public class A { <line0> protected void prepareScalarElement(PWDServerKeyExchangeMessage msg) { <line1> EllipticCurve curve = CurveFactory.getCurve(selectNamedGroup(msg)); <line2> PWDComputations.PWDKeyMaterial keyMaterial = <line3> PWDComputations.generateKeyMaterial( <line4> curve, msg.getComputations().getPasswordElement(), chooser); <line5> msg.getComputations().setPrivateKeyScalar(keyMaterial.privateKeyScalar); <line6> prepareScalar(msg, keyMaterial.scalar); <line7> prepareScalarLength(msg); <line8> prepareElement(msg, keyMaterial.element); <line9> prepareElementLength(msg); <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> void writeNoPasswordViolation(final String accountId, final CSVReportEntry csvReportEntry) { <line1> violationSink.put( <line2> new ViolationBuilder() <line3> .withEventId(""check-iam-user_"" + csvReportEntry.getUser()) <line4> .withAccountId(accountId) <line5> .withRegion(NO_REGION) <line6> .withPluginFullyQualifiedClassName(NoPasswordsJob.class) <line7> .withType(PASSWORD_USED) <line8> .withMetaInfo(singletonMap(""user_name"", csvReportEntry.getUser())) <line9> .build()); <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> public StatementAgentInstanceFactoryResult newContext( <line1> AgentInstanceContext agentInstanceContext, boolean isRecoveringResilient) { <line2> TableInstance tableState = <line3> agentInstanceContext <line4> .getTableManagementService() <line5> .allocateTableInstance(table, agentInstanceContext); <line6> TableInstanceViewable finalView = new TableInstanceViewable(table, tableState); <line7> AgentInstanceMgmtCallback stop = <line8> new AgentInstanceMgmtCallback() { <line9> public void stop(AgentInstanceStopServices services) { <line10> TableInstance instance = <line11> table.getTableInstance(agentInstanceContext.getAgentInstanceId()); <line12> if (instance == null) { <line13> } else { <line14> instance.destroy(); <line15> } <line16> } <line17> }; <line18> return new StatementAgentInstanceFactoryCreateTableResult( <line19> finalView, stop, agentInstanceContext, tableState); <line20> } <line21> } <line22> 	1	task3	
public class A { <line0> @Override <line1> public PdfPTable createTableWithHeader( <line2> final int numOfColumns, <line3> final List<String> header, <line4> final boolean lastColumnAlignmentToLeft, <line5> final int[] columnWidths) { <line6> PdfPTable table = new PdfPTable(numOfColumns); <line7> try { <line8> table.setWidths(columnWidths); <line9> } catch (DocumentException e) { <line10> } <line11> return setTableProperties(header, table, null); <line12> } <line13> } <line14> 	1	task3	
"public class A { <line0> protected void reloadContentTypeConfigForChildren( <line1> String site, RepositoryItem node, List<ContentTypeConfigTO> contentTypes) { <line2> String contentTypesRootPath = getConfigPath().replaceAll(StudioConstants.PATTERN_SITE, site); <line3> String fullPath = node.path + FILE_SEPARATOR + node.name; <line4> RepositoryItem[] folders = contentRepository.getContentChildren(site, fullPath); <line5> if (folders != null) { <line6> for (int i = 0; i < folders.length; i++) { <line7> if (folders[i].isFolder) { <line8> String configPath = <line9> folders[i].path <line10> + FILE_SEPARATOR <line11> + folders[i].name <line12> + FILE_SEPARATOR <line13> + getConfigFileName(); <line14> if (contentService.contentExists(site, configPath)) { <line15> ContentTypeConfigTO config = <line16> contentTypesConfig.reloadConfiguration( <line17> site, <line18> configPath <line19> .replace(contentTypesRootPath, """") <line20> .replace(FILE_SEPARATOR + getConfigFileName(), """")); <line21> if (config != null) { <line22> contentTypes.add(config); <line23> } <line24> } <line25> reloadContentTypeConfigForChildren(site, folders[i], contentTypes); <line26> } <line27> } <line28> } <line29> } <line30> } <line31> "	1	task3	
public class A { <line0> @Override <line1> public Boolean call() throws Exception { <line2> ExoContainerContext.setCurrentContainer(portalContainer); <line3> boolean migrationProceededWithoutErrors = true; <line4> for (Space space : spaces) { <line5> if (space == null || StringUtils.isBlank(space.getGroupId())) { <line6> continue; <line7> } <line8> RequestLifeCycle.begin(portalContainer); <line9> try { <line10> migrateSpace(space, migrationResult); <line11> } catch (Exception ex) { <line12> migrationProceededWithoutErrors = false; <line13> } finally { <line14> RequestLifeCycle.end(); <line15> } <line16> } <line17> return migrationProceededWithoutErrors; <line18> } <line19> } <line20> 	1	task3	
public class A { <line0> @Override <line1> protected void onNodeAdded(final String networkId, final Node node) { <line2> String connType = conversionTable().getConnectionType(networkId); <line3> if (connType != null && connType.equals(AGGREGATED)) { <line4> return; <line5> } <line6> String aggNetworkId = getNetworkIdByType(AGGREGATED); <line7> if (aggNetworkId == null) { <line8> return; <line9> } <line10> NetworkInterface aggNetworkIf = networkInterfaces().get(aggNetworkId); <line11> if (getConvNodeId(aggNetworkId, this.getObjectId()) == null) { <line12> node.putAttribute(AttrElements.PHYSICAL_ID, this.getObjectId()); <line13> Node aggNodeMsg = <line14> new Node( <line15> node.getVersion(), <line16> this.getObjectId(), <line17> new HashMap<String, Port>(), <line18> node.getAttributes()); <line19> aggNetworkIf.putNode(aggNodeMsg); <line20> } <line21> Map<String, String> updateAttr = new HashMap<>(); <line22> updateAttr.put(Logic.AttrElements.OPER_STATUS, STATUS_DOWN); <line23> aggNetworkIf.putAttributeOfNode(updateAttr); <line24> conversionTable().addEntryNode(networkId, node.getId(), aggNetworkId, this.getObjectId()); <line25> } <line26> } <line27> 	1	task3	
"public class A { <line0> public void parse(XMLStreamReader xtr, BpmnModel model) throws Exception { <line1> Interface interfaceObject = new Interface(); <line2> BpmnXMLUtil.addXMLLocation(interfaceObject, xtr); <line3> interfaceObject.setId( <line4> model.getTargetNamespace() + "":"" + xtr.getAttributeValue(null, ATTRIBUTE_ID)); <line5> interfaceObject.setName(xtr.getAttributeValue(null, ATTRIBUTE_NAME)); <line6> interfaceObject.setImplementationRef( <line7> parseMessageRef(xtr.getAttributeValue(null, ATTRIBUTE_IMPLEMENTATION_REF), model)); <line8> boolean readyWithInterface = false; <line9> Operation operation = null; <line10> try { <line11> while (!readyWithInterface && xtr.hasNext()) { <line12> xtr.next(); <line13> if (xtr.isStartElement() && ELEMENT_OPERATION.equals(xtr.getLocalName())) { <line14> operation = new Operation(); <line15> BpmnXMLUtil.addXMLLocation(operation, xtr); <line16> operation.setId( <line17> model.getTargetNamespace() + "":"" + xtr.getAttributeValue(null, ATTRIBUTE_ID)); <line18> operation.setName(xtr.getAttributeValue(null, ATTRIBUTE_NAME)); <line19> operation.setImplementationRef( <line20> parseMessageRef(xtr.getAttributeValue(null, ATTRIBUTE_IMPLEMENTATION_REF), model)); <line21> } else if (xtr.isStartElement() && ELEMENT_IN_MESSAGE.equals(xtr.getLocalName())) { <line22> String inMessageRef = xtr.getElementText(); <line23> if (operation != null && StringUtils.isNotEmpty(inMessageRef)) { <line24> operation.setInMessageRef(parseMessageRef(inMessageRef.trim(), model)); <line25> } <line26> } else if (xtr.isStartElement() && ELEMENT_OUT_MESSAGE.equals(xtr.getLocalName())) { <line27> String outMessageRef = xtr.getElementText(); <line28> if (operation != null && StringUtils.isNotEmpty(outMessageRef)) { <line29> operation.setOutMessageRef(parseMessageRef(outMessageRef.trim(), model)); <line30> } <line31> } else if (xtr.isEndElement() && ELEMENT_OPERATION.equalsIgnoreCase(xtr.getLocalName())) { <line32> if (operation != null && StringUtils.isNotEmpty(operation.getImplementationRef())) { <line33> interfaceObject.getOperations().add(operation); <line34> } <line35> } else if (xtr.isEndElement() && ELEMENT_INTERFACE.equals(xtr.getLocalName())) { <line36> readyWithInterface = true; <line37> } <line38> } <line39> } catch (Exception e) { <line40> } <line41> model.getInterfaces().add(interfaceObject); <line42> } <line43> } <line44> "	1	task3	
public class A { <line0> public static Charset sniffEncodingFromHttpHeaders(final List<NameValuePair> headers) { <line1> for (final NameValuePair pair : headers) { <line2> final String name = pair.getName(); <line3> if (HttpHeader.CONTENT_TYPE_LC.equalsIgnoreCase(name)) { <line4> final Charset encoding = extractEncodingFromContentType(pair.getValue()); <line5> if (encoding != null) { <line6> if (LOG.isDebugEnabled()) { <line7> } <line8> return encoding; <line9> } <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	1	task3	
public class A { <line0> protected void singleTagChanged(PluginTagEvent event, PluginTagListener listener) { <line1> try { <line2> listener.tagChanged(event); <line3> } catch (Exception ex) { <line4> } <line5> } <line6> } <line7> 	1	task3	
public class A { <line0> @Override <line1> protected void channelRead0(ChannelHandlerContext ctx, ShareLoginMessage message) { <line2> String[] messageParts = message.body.split(StringUtils.BODY_SEPARATOR_STRING); <line3> if (messageParts.length < 2) { <line4> ctx.writeAndFlush(illegalCommand(message.id), ctx.voidPromise()); <line5> } else { <line6> var version = <line7> messageParts.length > 3 <line8> ? new Version(messageParts[2], messageParts[3]) <line9> : Version.UNKNOWN_VERSION; <line10> appLogin(ctx, message.id, messageParts[0], messageParts[1], version); <line11> } <line12> } <line13> } <line14> 	1	task3	
public class A { <line0> @Override <line1> public void onProcessingTime(long timestamp) throws Exception { <line2> try { <line3> output.emitLatencyMarker( <line4> new LatencyMarker( <line5> processingTimeService.getCurrentProcessingTime(), operatorId, subtaskIndex)); <line6> } catch (Throwable t) { <line7> } <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> private void _configure(String[] args) { <line1> GnuParser parser = new GnuParser(); <line2> CommandLine cmd; <line3> try { <line4> cmd = parser.parse(new MetricsOptions(), args); <line5> } catch (ParseException e) { <line6> return; <line7> } <line8> Configuration conf = getConf(); <line9> URL metricsConfig = MetricsIngester.class.getClassLoader().getResource(""metrics.xml""); <line10> if (metricsConfig != null) { <line11> conf.addResource(metricsConfig); <line12> } <line13> for (Option opt : cmd.getOptions()) { <line14> conf.set(MetricsConfig.MTX + opt.getOpt(), opt.getValue()); <line15> } <line16> } <line17> } <line18> "	1	task3	
public class A { <line0> public static Map<String, Object> postProcessReconnectBackoffConfigs( <line1> AbstractConfig config, Map<String, Object> parsedValues) { <line2> HashMap<String, Object> rval = new HashMap<>(); <line3> if ((!config.originals().containsKey(RECONNECT_BACKOFF_MAX_MS_CONFIG)) <line4> && config.originals().containsKey(RECONNECT_BACKOFF_MS_CONFIG)) { <line5> rval.put(RECONNECT_BACKOFF_MAX_MS_CONFIG, parsedValues.get(RECONNECT_BACKOFF_MS_CONFIG)); <line6> } <line7> return rval; <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> @Override <line1> public boolean handleSync(DocumentWrapper<Object> wrapDoc) throws Exception { <line2> boolean result = false; <line3> ServiceContext<PoxPayloadIn, PoxPayloadOut> ctx = getServiceContext(); <line4> Specifier specifier = (Specifier) wrapDoc.getWrappedObject(); <line5> DocumentModel docModel = <line6> NuxeoUtils.getDocFromSpecifier( <line7> ctx, getRepositorySession(), authorityCommonSchemaName, specifier); <line8> if (docModel != null) { <line9> String authorityCsid = docModel.getName(); <line10> Long localRev = (Long) NuxeoUtils.getProperyValue(docModel, AuthorityJAXBSchema.REV); <line11> String shortId = <line12> (String) NuxeoUtils.getProperyValue(docModel, AuthorityJAXBSchema.SHORT_IDENTIFIER); <line13> String remoteClientConfigName = <line14> (String) <line15> NuxeoUtils.getProperyValue(docModel, AuthorityJAXBSchema.REMOTECLIENT_CONFIG_NAME); <line16> Specifier sasSpecifier = new Specifier(SpecifierForm.URN_NAME, shortId); <line17> PoxPayloadIn sasPayloadIn = <line18> AuthorityServiceUtils.requestPayloadInFromRemoteServer( <line19> ctx, remoteClientConfigName, sasSpecifier, getEntityResponseType()); <line20> Long sasRev = getRevision(sasPayloadIn); <line21> if (sasRev > localRev || true) { <line22> syncAllItems(ctx, authorityCsid, sasSpecifier); <line23> AuthorityResource authorityResource = (AuthorityResource) ctx.getResource(); <line24> ctx.setProperty( <line25> AuthorityServiceUtils.SHOULD_UPDATE_REV_PROPERTY, <line26> AuthorityServiceUtils.DONT_UPDATE_REV); <line27> PoxPayloadOut payloadOut = <line28> authorityResource.update( <line29> ctx, ctx.getResourceMap(), ctx.getUriInfo(), docModel.getName(), sasPayloadIn); <line30> if (payloadOut != null) { <line31> ctx.setOutput(payloadOut); <line32> result = true; <line33> } <line34> String workflowState = docModel.getCurrentLifeCycleState(); <line35> if (workflowState.contains(WorkflowClient.WORKFLOWSTATE_REPLICATED) == false) { <line36> authorityResource.updateWorkflowWithTransition( <line37> ctx, ctx.getUriInfo(), authorityCsid, WorkflowClient.WORKFLOWTRANSITION_REPLICATE); <line38> } <line39> } <line40> } else { <line41> String errMsg = <line42> String.format( <line43> ""Authority of type '%s' with identifier '%s' does not exist."", <line44> getServiceContext().getServiceName(), specifier.getURNValue()); <line45> throw new DocumentException(errMsg); <line46> } <line47> return result; <line48> } <line49> } <line50> "	1	task3	
"public class A { <line0> @Override <line1> public String getAmilAvailDate(int year, int quarter) { <line2> try { <line3> String query = <line4> ""select Date(createdDate) from cf_SystemConfiguration where keyname ="" <line5> + "" 'pacman.kernel.compliance.map."" <line6> + year <line7> + "".q"" <line8> + quarter <line9> + ""'""; <line10> return rdsrepository.queryForString(query); <line11> } catch (Exception e) { <line12> return null; <line13> } <line14> } <line15> } <line16> "	1	task3	
"public class A { <line0> @Test(description = ""This test case tests converting a pem file to X509 Certificate"") <line1> public void testPemToX509Certificate() throws IOException, KeystoreException { <line2> File caCert = new File(CA_CERT_PEM); <line3> BASE64Encoder encoder = new BASE64Encoder(); <line4> byte[] caBytes = FileUtils.readFileToByteArray(caCert); <line5> X509Certificate certificate = managementService.pemToX509Certificate(encoder.encode(caBytes)); <line6> Assert.assertNotNull(certificate); <line7> Assert.assertEquals(certificate.getType(), CertificateManagementConstants.X_509); <line8> } <line9> } <line10> "	1	task3	
"public class A { <line0> @Override <line1> public String JSON2(boolean isArray, boolean isEmbed) { <line2> Map<String, String> valueMap = new HashMap<>(); <line3> valueMap.put( <line4> ""id"", <line5> null == resourceRecipe || null == resourceRecipe.getId() <line6> ? StringUtils.EMPTY <line7> : String.valueOf(resourceRecipe.getId())); <line8> valueMap.put( <line9> ""action"", <line10> null == resourceRecipe || null == resourceRecipe.getAction() <line11> ? StringUtils.EMPTY <line12> : resourceRecipe.getAction()); <line13> valueMap.put( <line14> ""orchestrationUri"", <line15> null == resourceRecipe || null == resourceRecipe.getOrchestrationUri() <line16> ? StringUtils.EMPTY <line17> : resourceRecipe.getOrchestrationUri()); <line18> valueMap.put( <line19> ""recipeTimeout"", <line20> null == resourceRecipe || null == resourceRecipe.getRecipeTimeout() <line21> ? StringUtils.EMPTY <line22> : String.valueOf(resourceRecipe.getRecipeTimeout())); <line23> valueMap.put( <line24> ""paramXSD"", <line25> null == resourceRecipe || null == resourceRecipe.getParamXsd() <line26> ? StringUtils.EMPTY <line27> : resourceRecipe.getParamXsd()); <line28> valueMap.put( <line29> ""description"", <line30> null == resourceRecipe || null == resourceRecipe.getDescription() <line31> ? StringUtils.EMPTY <line32> : resourceRecipe.getDescription()); <line33> ObjectMapper mapper = new ObjectMapper(); <line34> mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, false); <line35> String jsonStr = """"; <line36> try { <line37> jsonStr = mapper.writeValueAsString(valueMap); <line38> } catch (JsonProcessingException e) { <line39> } <line40> return jsonStr; <line41> } <line42> } <line43> "	1	task3	
"public class A { <line0> public String register() { <line1> personController.registerUser(userName, password, name, surname, age, admin); <line2> JSFUtility.addInfoMessage(""User with name : "" + userName + "" is registered successfully."", """"); <line3> return ""login""; <line4> } <line5> } <line6> "	1	task3	
"public class A { <line0> @OPTIONS <line1> public Response unsupportedOptionsMethod() { <line2> throw new WebApplicationException( <line3> Response.status(NOT_ALLOWED_STATUS).entity(""OPTIONS Method Not Allowed"").build()); <line4> } <line5> } <line6> "	1	task3	
public class A { <line0> @Override <line1> public List<TriggerInfo> getTriggerInfos(TriggerInfoContext context) { <line2> for (Notification notification : context.getNotifications()) { <line3> if (!isSatisfied(context.getSchedule(), notification)) { <line4> continue; <line5> } <line6> Long logicalStartTime = getLogicalStartTime(notification); <line7> if (logicalStartTime == null) { <line8> continue; <line9> } <line10> TriggerInfo triggerInfo = new DefaultTimeTriggerInfo(getCronExpression(), logicalStartTime); <line11> return Collections.singletonList(triggerInfo); <line12> } <line13> return Collections.emptyList(); <line14> } <line15> } <line16> 	1	task3	
public class A { <line0> private UriComponents createEchoUri(final String scheme) { <line1> final String echoUriStr = CommonConstants.SERVICE_REGISTRY_URI + CommonConstants.ECHO_URI; <line2> return Utilities.createURI( <line3> scheme, <line4> coreSystemRegistrationProperties.getServiceRegistryAddress(), <line5> coreSystemRegistrationProperties.getServiceRegistryPort(), <line6> echoUriStr); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> @Override <line1> protected AuthorizationDecision combineDecisions( <line2> AuthorizationDecision[] decisions, boolean errorsInTarget) { <line3> if (decisions.length == 0) return AuthorizationDecision.DENY; <line4> var entitlement = DENY; <line5> var collector = new ObligationAdviceCollector(); <line6> Optional<JsonNode> resource = Optional.empty(); <line7> for (var decision : decisions) { <line8> if (decision.getDecision() == PERMIT) { <line9> entitlement = PERMIT; <line10> } <line11> collector.add(decision); <line12> if (decision.getResource().isPresent()) { <line13> if (resource.isPresent()) { <line14> entitlement = DENY; <line15> } else { <line16> resource = decision.getResource(); <line17> } <line18> } <line19> } <line20> var finalDecision = <line21> new AuthorizationDecision( <line22> entitlement, <line23> resource, <line24> collector.getObligations(entitlement), <line25> collector.getAdvices(entitlement)); <line26> return finalDecision; <line27> } <line28> } <line29> 	1	task3	
public class A { <line0> @Override <line1> public synchronized void close() throws IOException { <line2> if (closed) { <line3> return; <line4> } <line5> closed = true; <line6> if (connectionFactory != null) { <line7> connectionFactory.shutdown(); <line8> connectionFactory = null; <line9> } <line10> if (zkServer != null) { <line11> zkServer.shutdown(); <line12> zkServer = null; <line13> } <line14> if (transactionLog != null) { <line15> transactionLog.close(); <line16> transactionLog = null; <line17> } <line18> if (purgeManager != null) { <line19> purgeManager.shutdown(); <line20> purgeManager = null; <line21> } <line22> if (dataDir != null) { <line23> IOUtils.deleteRecursively(dataDir); <line24> dataDir = null; <line25> } <line26> } <line27> } <line28> 	1	task3	
"public class A { <line0> private static void publishGlobalAPI(String id) throws APIException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> RequestProcessor requestProcessor = new RequestProcessor(); <line4> String apiPublishResponse; <line5> String apiPublishPath = <line6> restConfig.getApimBaseUrl() <line7> + Constants.Utils.PATH_PUBLISHER <line8> + restConfig.getApiVersion() <line9> + Constants.Utils.PATH_LIFECYCLE <line10> + ""apiId="" <line11> + id <line12> + ""&action=Publish""; <line13> apiPublishResponse = <line14> requestProcessor.doPost( <line15> apiPublishPath, <line16> Constants.Utils.CONTENT_TYPE_APPLICATION_JSON, <line17> Constants.Utils.CONTENT_TYPE_APPLICATION_JSON, <line18> Constants.Utils.BEARER + apimConfig.getApiToken(), <line19> Constants.Utils.EMPTY_STRING); <line20> if (apiPublishResponse == null) { <line21> throw new APIException(""Error while publishing the global API with URL: "" + apiPublishPath); <line22> } <line23> } <line24> } <line25> "	1	task3	
public class A { <line0> @Test <line1> public void testSerializeData() throws Exception { <line2> Writer serializeData = <line3> bindingSerializer.serializeData(this.effectiveModelContext, testedToasterNormalizedNodes); <line4> Assert.assertFalse(Strings.isNullOrEmpty(serializeData.toString())); <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> private static InputStream getConfigInputStream(Context context) { <line1> InputStream is = getJSONFromServletContext(context.getServletContext()); <line2> if (is == null) { <line3> String path = context.getServletContext().getInitParameter(""keycloak.config.file""); <line4> if (path == null) { <line5> is = context.getServletContext().getResourceAsStream(""/WEB-INF/keycloak.json""); <line6> } else { <line7> try { <line8> is = new FileInputStream(path); <line9> } catch (FileNotFoundException e) { <line10> log.errorv(""NOT FOUND {0}"", path); <line11> throw new RuntimeException(e); <line12> } <line13> } <line14> } <line15> return is; <line16> } <line17> } <line18> "	1	task3	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> readLatch.countDown(); <line4> indexPersistenceMgr.getFileInfo(lid, null); <line5> readRc.set(BKException.Code.OK); <line6> } catch (Bookie.NoLedgerException nle) { <line7> readRc.set(BKException.Code.NoSuchLedgerExistsException); <line8> } catch (IOException e) { <line9> readRc.set(BKException.Code.ReadException); <line10> } <line11> readDoneLatch.countDown(); <line12> } <line13> } <line14> 	1	task3	
public class A { <line0> private void closePrewarmDagClient() { <line1> if (prewarmDagClient == null) { <line2> return; <line3> } <line4> try { <line5> prewarmDagClient.close(); <line6> } catch (Exception e) { <line7> } <line8> prewarmDagClient = null; <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> @Override <line1> protected PowermaxState handleMessageInternal(PowermaxCommManager commManager) { <line2> if (commManager == null) { <line3> return null; <line4> } <line5> PowermaxState updatedState = commManager.createNewState(); <line6> byte[] message = getRawData(); <line7> byte panelTypeNr = message[7]; <line8> String panelTypeStr; <line9> PowermaxPanelType panelType = null; <line10> try { <line11> panelType = PowermaxPanelType.fromCode(panelTypeNr); <line12> panelTypeStr = panelType.toString(); <line13> } catch (IllegalArgumentException e) { <line14> panelType = null; <line15> panelTypeStr = ""UNKNOWN""; <line16> } <line17> debug(""Panel type"", panelTypeNr, panelTypeStr); <line18> updatedState.downloadMode.setValue(true); <line19> commManager.sendMessage(PowermaxSendType.DL_PANELFW); <line20> commManager.sendMessage(PowermaxSendType.DL_SERIAL); <line21> commManager.sendMessage(PowermaxSendType.DL_ZONESTR); <line22> commManager.sendSetTime(); <line23> if ((panelType != null) && panelType.isPowerMaster()) { <line24> commManager.sendMessage(PowermaxSendType.DL_MR_SIRKEYZON); <line25> } <line26> commManager.sendMessage(PowermaxSendType.START); <line27> commManager.sendMessage(PowermaxSendType.EXIT); <line28> return updatedState; <line29> } <line30> } <line31> "	1	task3	
public class A { <line0> protected final void putPercentType( <line1> Map<Channel, State> targetMap, <line2> @Nullable Channel channel, <line3> @Nullable Double value, <line4> int factor) { <line5> if (channel != null) { <line6> State result = UnDefType.UNDEF; <line7> if (value != null) { <line8> result = new QuantityType<>(value * factor, Units.PERCENT); <line9> } else { <line10> } <line11> targetMap.put(channel, result); <line12> } <line13> } <line14> } <line15> 	1	task3	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public static SimpleFeatureType configureType(final SimpleFeatureType type) { <line2> final String configFileName = System.getProperty(SIMPLE_FEATURE_CONFIG_FILE_PROP); <line3> if (configFileName != null) { <line4> final File configFile = new File(configFileName); <line5> if (configFile.exists() && configFile.canRead()) { <line6> try (FileInputStream input = new FileInputStream(configFile); <line7> Reader reader = new InputStreamReader(input, ""UTF-8"")) { <line8> final ObjectMapper mapper = <line9> new ObjectMapper().disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); <line10> final SimpleFeatureUserDataConfigurationSet instance = <line11> mapper.readValue(reader, SimpleFeatureUserDataConfigurationSet.class); <line12> instance.updateType(type); <line13> } catch (final IOException e) { <line14> } <line15> } <line16> } <line17> return type; <line18> } <line19> } <line20> "	1	task3	
"public class A { <line0> private void initPersistence() { <line1> long ts1 = System.currentTimeMillis(); <line2> CassandraHostConfigurator cassandraHostConfigurator = new CassandraHostConfigurator(); <line3> cassandraHostConfigurator.setHosts(CLUSTER_URL); <line4> cassandraHostConfigurator.setMaxActive(hectorPoolSize); <line5> cassandraHostConfigurator.setCassandraThriftSocketTimeout( <line6> CMBProperties.getInstance().getCassandraThriftSocketTimeOutMS()); <line7> cassandraHostConfigurator.setAutoDiscoverHosts( <line8> CMBProperties.getInstance().isHectorAutoDiscovery()); <line9> cassandraHostConfigurator.setAutoDiscoveryDelayInSeconds( <line10> CMBProperties.getInstance().getHectorAutoDiscoveryDelaySeconds()); <line11> String dataCenter = CMBProperties.getInstance().getCassandraDataCenter(); <line12> if (dataCenter != null && !dataCenter.equals("""")) { <line13> cassandraHostConfigurator.setAutoDiscoveryDataCenter(dataCenter); <line14> } <line15> if (hectorBalancingPolicy != null) { <line16> if (hectorBalancingPolicy.equals(""LeastActiveBalancingPolicy"")) { <line17> cassandraHostConfigurator.setLoadBalancingPolicy(new LeastActiveBalancingPolicy()); <line18> } else if (hectorBalancingPolicy.equals(""RoundRobinBalancingPolicy"")) { <line19> cassandraHostConfigurator.setLoadBalancingPolicy(new RoundRobinBalancingPolicy()); <line20> } else if (hectorBalancingPolicy.equals(""DynamicLoadBalancingPolicy"")) { <line21> cassandraHostConfigurator.setLoadBalancingPolicy(new DynamicLoadBalancingPolicy()); <line22> } <line23> } <line24> cluster = <line25> HFactory.getOrCreateCluster( <line26> AbstractDurablePersistence.CLUSTER_NAME, cassandraHostConfigurator, credentials); <line27> keyspaces = new HashMap<String, Keyspace>(); <line28> List<String> keyspaceNames = new ArrayList<String>(); <line29> keyspaceNames.add(CMBProperties.getInstance().getCMBKeyspace()); <line30> keyspaceNames.add(CMBProperties.getInstance().getCNSKeyspace()); <line31> keyspaceNames.add(CMBProperties.getInstance().getCQSKeyspace()); <line32> for (String k : keyspaceNames) { <line33> Keyspace keyspace = <line34> HFactory.createKeyspace( <line35> k, <line36> cluster, <line37> new SimpleConsistencyPolicy( <line38> HConsistencyLevel.valueOf( <line39> CMBProperties.getInstance().getWriteConsistencyLevel()))); <line40> keyspaces.put(k, keyspace); <line41> } <line42> long ts2 = System.currentTimeMillis(); <line43> CMBControllerServlet.valueAccumulator.addToCounter(AccumulatorName.CassandraTime, (ts2 - ts1)); <line44> } <line45> } <line46> "	1	task3	
"public class A { <line0> @GetMapping(""/pauseAllGlobalTransactions"") <line1> public ResponseEntity<ReturnValue> pauseAllGlobalTransactions() { <line2> ReturnValue rv = new ReturnValue(); <line3> try { <line4> if (consistencyCache.getBooleanValue(null, null, ConfigCenterType.PauseGlobalTx)) { <line5> return ResponseEntity.ok(rv); <line6> } <line7> String ipPort = request.getRemoteAddr() + "":"" + request.getRemotePort(); <line8> configCenterService.createConfigCenter( <line9> new ConfigCenter( <line10> null, <line11> null, <line12> null, <line13> ConfigCenterStatus.Normal, <line14> 1, <line15> ConfigCenterType.PauseGlobalTx, <line16> TxleConstants.ENABLED, <line17> ipPort + "" - pauseAllTransaction"")); <line18> List<TxEvent> unendedTxEventList = <line19> eventRepository.selectUnendedTxEvents(EventScanner.getUnendedMinEventId()); <line20> if (unendedTxEventList != null && !unendedTxEventList.isEmpty()) { <line21> List<String> globalTxIdList = new ArrayList<>(); <line22> unendedTxEventList.forEach( <line23> event -> { <line24> if (!globalTxIdList.contains(event.globalTxId())) { <line25> globalTxIdList.add(event.globalTxId()); <line26> } <line27> }); <line28> unendedTxEventList.forEach( <line29> event -> { <line30> List<TxEvent> pauseContinueEventList = <line31> eventRepository.selectPausedAndContinueEvent(event.globalTxId()); <line32> if (pauseContinueEventList != null && !pauseContinueEventList.isEmpty()) { <line33> TxEvent pausedEvent = pauseContinueEventList.get(0); <line34> if (AdditionalEventType.SagaPausedEvent.name().equals(pausedEvent.type()) <line35> || AdditionalEventType.SagaAutoContinuedEvent.name() <line36> .equals(pausedEvent.type())) { <line37> globalTxIdList.remove(event.globalTxId()); <line38> } <line39> } <line40> }); <line41> if (globalTxIdList.isEmpty()) { <line42> return ResponseEntity.ok(rv); <line43> } <line44> unendedTxEventList.forEach( <line45> event -> { <line46> if (globalTxIdList.contains(event.globalTxId())) { <line47> globalTxIdList.remove(event.globalTxId()); <line48> TxEvent pausedEvent = <line49> new TxEvent( <line50> ipPort, <line51> ipPort, <line52> event.globalTxId(), <line53> event.localTxId(), <line54> event.parentTxId(), <line55> AdditionalEventType.SagaPausedEvent.name(), <line56> """", <line57> 0, <line58> """", <line59> 0, <line60> event.category(), <line61> null); <line62> eventRepository.save(pausedEvent); <line63> txleMetrics.countTxNumber(event); <line64> } <line65> }); <line66> } <line67> } catch (Exception e) { <line68> rv.setMessage(""Failed to pause all global transactions.""); <line69> return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(rv); <line70> } <line71> return ResponseEntity.ok(rv); <line72> } <line73> } <line74> "	1	task3	
public class A { <line0> void enqueue(Handler<Void> event) { <line1> vertx.runOnContext(event); <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> private void copyHDFSJobInfo(String jobId) throws Exception { <line1> String srcDirQualified = srcCluster.getJobWorkingDirQualified(jobId); <line2> String dstDirQualified = dstCluster.getJobWorkingDirQualified(jobId); <line3> if (ifExecute) { <line4> dstCluster.copyInitOnJobCluster(new Path(dstDirQualified)); <line5> copyHDFSPath(srcDirQualified, srcCluster.jobConf, dstDirQualified, dstCluster.jobConf); <line6> } else { <line7> } <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> public static java.util.List<com.liferay.journal.model.JournalArticle> getLatestArticles( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> int status, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.journal.model.JournalArticle> <line7> orderByComparator) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> JournalArticleServiceUtil.class, <line12> ""getLatestArticles"", <line13> _getLatestArticlesParameterTypes48); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, status, start, end, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.journal.model.JournalArticle>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	1	task3	
public class A { <line0> public static com.liferay.portal.kernel.model.ContactSoap getContact(long contactId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Contact returnValue = <line4> ContactServiceUtil.getContact(contactId); <line5> return com.liferay.portal.kernel.model.ContactSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> protected DfSqlFileRunner getSqlFileRunner4TakeFinally(final DfRunnerInformation runInfo) { <line1> final DfReplaceSchemaProperties prop = getReplaceSchemaProperties(); <line2> final DfSqlFileRunnerExecute runnerExecute = <line3> new DfSqlFileRunnerExecute(runInfo, _dataSource) { <line4> @Override <line5> protected String filterSql(String sql) { <line6> sql = super.filterSql(sql); <line7> sql = prop.resolveFilterVariablesIfNeeds(sql); <line8> return sql; <line9> } <line10>  <line11> @Override <line12> protected boolean isHandlingCommentOnLineSeparator() { <line13> return true; <line14> } <line15>  <line16> @Override <line17> protected boolean isDbCommentLine(String line) { <line18> final boolean commentLine = super.isDbCommentLine(line); <line19> if (commentLine) { <line20> return commentLine; <line21> } <line22> return isDbCommentLineForIrregularPattern(line); <line23> } <line24>  <line25> @Override <line26> protected String getTerminator4Tool() { <line27> return resolveTerminator4Tool(); <line28> } <line29>  <line30> @Override <line31> protected boolean isTargetFile(String sql) { <line32> return getReplaceSchemaProperties().isTargetRepsFile(sql); <line33> } <line34> }; <line35> final String loadType = getReplaceSchemaProperties().getRepsEnvType(); <line36> final DfDataAssertProvider dataAssertProvider = new DfDataAssertProvider(loadType); <line37> runnerExecute.setDispatcher( <line38> new DfSqlFileRunnerDispatcher() { <line39> public DfRunnerDispatchResult dispatch(File sqlFile, Statement st, String sql) <line40> throws SQLException { <line41> final DfDataAssertHandler dataAssertHandler = <line42> dataAssertProvider.provideDataAssertHandler(sql); <line43> if (dataAssertHandler == null) { <line44> if (_skipIfNonAssetionSql) { <line45> return DfRunnerDispatchResult.SKIPPED; <line46> } else if (_restrictIfNonAssetionSql) { <line47> throwTakeFinallyNonAssertionSqlFoundException(sqlFile, sql); <line48> } else { <line49> return DfRunnerDispatchResult.NONE; <line50> } <line51> } <line52> try { <line53> dataAssertHandler.handle(sqlFile, st, sql); <line54> } catch (DfTakeFinallyAssertionFailureException e) { <line55> handleAssertionFailureException(e); <line56> } <line57> return DfRunnerDispatchResult.DISPATCHED; <line58> } <line59> }); <line60> return runnerExecute; <line61> } <line62> } <line63> 	1	task3	
public class A { <line0> public static String getUptime() { <line1> Date now = new Date(); <line2> Platform platform = Platform.getLocalInstance(); <line3> String uptime = getDiffTime(now.getTime() - platform.getStartTime().getTime()); <line4> return uptime; <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> public void cancel(final Path file, final String uploadToken) throws BackgroundException { <line1> try { <line2> new UploadsApi(session.getClient()).cancelFileUploadByToken(uploadToken); <line3> } catch (ApiException e) { <line4> throw new SDSExceptionMappingService().map(""Upload {0} failed"", e, file); <line5> } <line6> } <line7> } <line8> "	1	task3	
"public class A { <line0> public static java.util.List<com.liferay.social.kernel.model.SocialActivity> getGroupActivities( <line1> HttpPrincipal httpPrincipal, long groupId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SocialActivityServiceUtil.class, <line7> ""getGroupActivities"", <line8> _getGroupActivitiesParameterTypes10); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, start, end); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (java.util.List<com.liferay.social.kernel.model.SocialActivity>) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	1	task3	
public class A { <line0> @Override <line1> protected void doCommit(DefaultTransactionStatus status) { <line2> MolgenisTransaction transaction = (MolgenisTransaction) status.getTransaction(); <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> DefaultTransactionStatus jpaTransactionStatus = <line6> new DefaultTransactionStatus( <line7> transaction.getDataSourceTransaction(), <line8> status.isNewTransaction(), <line9> status.isNewSynchronization(), <line10> status.isReadOnly(), <line11> status.isDebug(), <line12> status.getSuspendedResources()); <line13> if (!status.isReadOnly()) { <line14> transactionListeners.forEach(j -> j.commitTransaction(transaction.getId())); <line15> } <line16> try { <line17> super.doCommit(jpaTransactionStatus); <line18> } catch (TransactionException e) { <line19> throw translateTransactionException(e); <line20> } <line21> if (!status.isReadOnly()) { <line22> transactionListeners.forEach(j -> j.afterCommitTransaction(transaction.getId())); <line23> } <line24> } <line25> } <line26> 	1	task3	
"public class A { <line0> private void init() throws Exception { <line1> String originalAppId = propertiesBuilder.conf.get(ORIGINAL_APP_ID); <line2> if (originalAppId == null) { <line3> throw new AssertionError(""Need original app id if launching without apa or appjar""); <line4> } <line5> Path appsBasePath = <line6> new Path(StramClientUtils.getApexDFSRootDir(fs, conf), StramClientUtils.SUBDIR_APPS); <line7> Path origAppPath = new Path(appsBasePath, originalAppId); <line8> StringWriter writer = new StringWriter(); <line9> try (FSDataInputStream in = fs.open(new Path(origAppPath, ""meta.json""))) { <line10> IOUtils.copy(in, writer); <line11> } <line12> JSONObject metaJson = new JSONObject(writer.toString()); <line13> String originalLibJars = null; <line14> try { <line15> JSONObject attributes = metaJson.getJSONObject(""attributes""); <line16> originalLibJars = attributes.getString(Context.DAGContext.LIBRARY_JARS.getSimpleName()); <line17> recoveryAppName = attributes.getString(Context.DAGContext.APPLICATION_NAME.getSimpleName()); <line18> } catch (JSONException ex) { <line19> recoveryAppName = ""Recovery App From "" + originalAppId; <line20> } <line21> LinkedHashSet<URL> clUrls = new LinkedHashSet<>(); <line22> String libjars = propertiesBuilder.conf.get(LIBJARS_CONF_KEY_NAME); <line23> if (StringUtils.isBlank(libjars)) { <line24> libjars = originalLibJars; <line25> } else if (StringUtils.isNotBlank(originalLibJars)) { <line26> libjars = libjars + "","" + originalLibJars; <line27> } <line28> propertiesBuilder.conf.set(LIBJARS_CONF_KEY_NAME, libjars); <line29> processLibJars(libjars, clUrls); <line30> for (URL baseURL : clUrls) { <line31> } <line32> this.launchDependencies = clUrls; <line33> } <line34> } <line35> "	1	task3	
public class A { <line0> public String delete() { <line1> try { <line2> String check = this.checkDelete(); <line3> if (null != check) { <line4> return check; <line5> } <line6> long modelId = this.getModelId().longValue(); <line7> DataObjectModel model = this.getDataObjectModelManager().getDataObjectModel(modelId); <line8> this.getDataObjectModelManager().removeDataObjectModel(model); <line9> } catch (Throwable t) { <line10> return FAILURE; <line11> } <line12> return SUCCESS; <line13> } <line14> } <line15> 	1	task3	
public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordSoap[] <line1> getFormInstanceRecords(long ddmFormInstanceId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecord> returnValue = <line4> DDMFormInstanceRecordServiceUtil.getFormInstanceRecords(ddmFormInstanceId); <line5> return com.liferay.dynamic.data.mapping.model.DDMFormInstanceRecordSoap.toSoapModels( <line6> returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> public void modelReload(CatalogModel newModel) { <line1> for (ICatalogModelListener listener : getListeners()) { <line2> listener.modelReload(newModel); <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> public int getRowCount() { <line1> if (!isScrollable()) { <line2> return -1; <line3> } <line4> if (rowCount != SQLResultSet.COUNT_NEVER_OBTAINED) { <line5> return rowCount; <line6> } <line7> if (nativeResultSet == null) { <line8> return 0; <line9> } <line10> try { <line11> int curRow = nativeResultSet.getRow(); <line12> try { <line13> if (nativeResultSet.last()) { <line14> rowCount = nativeResultSet.getRow(); <line15> if (rowCount <= 0) { <line16> rowCount = 0; <line17> } <line18> } else { <line19> rowCount = 0; <line20> } <line21> } finally { <line22> if (curRow == 0) { <line23> nativeResultSet.beforeFirst(); <line24> } else { <line25> nativeResultSet.absolute(curRow); <line26> } <line27> } <line28> } catch (SQLException sqle) { <line29> rowCount = 0; <line30> } <line31> return rowCount; <line32> } <line33> } <line34> 	1	task3	
"public class A { <line0> private static void tryCustomMeasureTypes( <line1> Collection<TblColRef> unmatchedDimensions, <line2> Collection<FunctionDesc> unmatchedAggregations, <line3> SQLDigest digest, <line4> CubeInstance cube, <line5> CapabilityResult result) { <line6> CubeDesc cubeDesc = cube.getDescriptor(); <line7> List<String> influencingMeasures = Lists.newArrayList(); <line8> for (MeasureDesc measure : cubeDesc.getMeasures()) { <line9> MeasureType<?> measureType = measure.getFunction().getMeasureType(); <line10> if (measureType instanceof BasicMeasureType) continue; <line11> CapabilityInfluence inf = <line12> measureType.influenceCapabilityCheck( <line13> unmatchedDimensions, unmatchedAggregations, digest, measure); <line14> if (inf != null) { <line15> result.influences.add(inf); <line16> influencingMeasures.add(measure.getName() + ""@"" + measureType.getClass()); <line17> } <line18> } <line19> if (influencingMeasures.size() != 0) <line20> } <line21> } <line22> "	1	task3	
public class A { <line0> public static BufferedImage getImage(CardView card, int width, int height) { <line1> if (Constants.THUMBNAIL_SIZE_FULL.width + 10 > width) { <line2> return getThumbnail(card); <line3> } <line4> String key = getKey(card, card.getName(), Integer.toString(width)); <line5> BufferedImage original = getImage(key); <line6> if (original == null) { <line7> return null; <line8> } <line9> double scale = <line10> Math.min((double) width / original.getWidth(), (double) height / original.getHeight()); <line11> if (scale >= 1) { <line12> return original; <line13> } <line14> return TransformedImageCache.getResizedImage( <line15> original, (int) (original.getWidth() * scale), (int) (original.getHeight() * scale)); <line16> } <line17> } <line18> 	1	task3	
"public class A { <line0> private @Nullable List<SonosMusicService> getAvailableMusicServices() { <line1> if (musicServices == null) { <line2> Map<String, String> result = <line3> service.invokeAction(this, ""MusicServices"", ""ListAvailableServices"", null); <line4> String serviceList = result.get(""AvailableServiceDescriptorList""); <line5> if (serviceList != null) { <line6> List<SonosMusicService> services = SonosXMLParser.getMusicServicesFromXML(serviceList); <line7> musicServices = services; <line8> String[] servicesTypes = new String[0]; <line9> String serviceTypeList = result.get(""AvailableServiceTypeList""); <line10> if (serviceTypeList != null) { <line11> servicesTypes = serviceTypeList.split("",""); <line12> } <line13> int idx = 0; <line14> for (SonosMusicService service : services) { <line15> if (!""TuneIn"".equals(service.getName())) { <line16> if (idx < servicesTypes.length) { <line17> try { <line18> Integer serviceType = Integer.parseInt(servicesTypes[idx]); <line19> service.setType(serviceType); <line20> } catch (NumberFormatException e) { <line21> } <line22> idx++; <line23> } <line24> } else { <line25> service.setType(TUNEIN_DEFAULT_SERVICE_TYPE); <line26> } <line27> } <line28> } <line29> } <line30> return musicServices; <line31> } <line32> } <line33> "	1	task3	
public class A { <line0> @Deprecated <line1> public static void updateFragmentEntryLinks( <line2> long groupId, <line3> long classNameId, <line4> long classPK, <line5> long[] fragmentEntryIds, <line6> String editableValues, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws RemoteException { <line9> try { <line10> FragmentEntryLinkServiceUtil.updateFragmentEntryLinks( <line11> groupId, classNameId, classPK, fragmentEntryIds, editableValues, serviceContext); <line12> } catch (Exception exception) { <line13> throw new RemoteException(exception.getMessage()); <line14> } <line15> } <line16> } <line17> 	1	task3	
"public class A { <line0> @Override <line1> public void onAudioFocusChange(int focusChange) { <line2> try { <line3> switch (focusChange) { <line4> case AudioManager.AUDIOFOCUS_GAIN: <line5> if (playOnFocusGain) { <line6> requestAudioFocus(); <line7> if (player != null) { <line8> player.start(); <line9> updateController(""audio focus gained""); <line10> } <line11> } <line12> playOnFocusGain = false; <line13> break; <line14> case AudioManager.AUDIOFOCUS_LOSS: <line15> if (player != null) { <line16> if (player.isPlaying()) { <line17> player.pause(); <line18> updateController(""audio focus lost""); <line19> playOnFocusGain = true; <line20> } else { <line21> playOnFocusGain = false; <line22> } <line23> } <line24> break; <line25> } <line26> } catch (Exception ex) { <line27> } <line28> } <line29> } <line30> "	1	task3	
"public class A { <line0> @Override <line1> @Receiver <line2> public EngineStopResponse dealEngineConnStop(EngineStopRequest engineStopRequest) { <line3> EngineConn engineConn = getEngineConnByServiceInstance(engineStopRequest.getServiceInstance()); <line4> EngineStopResponse response = new EngineStopResponse(); <line5> if (null != engineConn) { <line6> if (!killEngineConnByPid(engineConn)) { <line7> response.setStopStatus(false); <line8> response.setMsg(""Kill engine "" + engineConn.getServiceInstance().toString() + "" failed.""); <line9> } else { <line10> response.setStopStatus(true); <line11> response.setMsg(""Kill engine "" + engineConn.getServiceInstance().toString() + "" succeed.""); <line12> } <line13> } else { <line14> response.setStopStatus(false); <line15> response.setMsg( <line16> ""EngineConn "" <line17> + engineStopRequest.getServiceInstance().toString() <line18> + "" was not found in this engineConnManager.""); <line19> } <line20> if (!response.getStopStatus()) { <line21> EngineSuicideRequest request = <line22> new EngineSuicideRequest( <line23> engineStopRequest.getServiceInstance(), engineStopRequest.getUser()); <line24> try { <line25> Sender.getSender(engineStopRequest.getServiceInstance()).send(request); <line26> response.setStopStatus(true); <line27> response.setMsg(response.getMsg() + "" Now send suicide request to engine.""); <line28> } catch (Exception e) { <line29> response.setMsg( <line30> response.getMsg() + "" Sended suicide request to engine error, "" + e.getMessage()); <line31> } <line32> } <line33> return response; <line34> } <line35> } <line36> "	1	task3	
public class A { <line0> @Override <line1> public CompletableFuture<Void> enableControllerService(final ControllerServiceNode service) { <line2> return service.enable(componentLifeCycleThreadPool, ADMINISTRATIVE_YIELD_MILLIS); <line3> } <line4> } <line5> 	1	task3	
public class A { <line0> public Integer getDupsOKBatchSize() { <line1> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line2> } <line3> return dupsOKBatchSize; <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> private void forceClose() { <line1> assert adminExecutor.inEventLoop(); <line2> if (forceCloseWasCalled) { <line3> return; <line4> } <line5> forceCloseWasCalled = true; <line6> if (closeWasCalled) { <line7> for (AsyncAutoCloseable closeable : internalComponentsToClose()) { <line8> closeable.forceCloseAsync(); <line9> } <line10> } else { <line11> closePolicies(); <line12> List<CompletionStage<Void>> childrenCloseStages = new ArrayList<>(); <line13> for (AsyncAutoCloseable closeable : internalComponentsToClose()) { <line14> childrenCloseStages.add(closeable.forceCloseAsync()); <line15> } <line16> CompletableFutures.whenAllDone( <line17> childrenCloseStages, () -> onChildrenClosed(childrenCloseStages), adminExecutor); <line18> } <line19> } <line20> } <line21> 	1	task3	
"public class A { <line0> private void valueTag(Document doc, Board board, Integer nl, String tag, int startingRelay) { <line1> for (int i = startingRelay; i < nl; i++) { <line2> try { <line3> String tagName = tag + i; <line4> if (tag.equalsIgnoreCase(""led"")) { <line5> if (!(board.getRelayStatus(i) <line6> == Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent()))) { <line7> sendChanges(i, board, doc.getElementsByTagName(tagName).item(0).getTextContent(), tag); <line8> board.setRelayStatus( <line9> i, Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent())); <line10> } <line11> } else if (tag.equalsIgnoreCase(""btn"")) { <line12> if (!(board <line13> .getDigitalInputValue(i) <line14> .equalsIgnoreCase(doc.getElementsByTagName(tagName).item(0).getTextContent()))) { <line15> sendChanges(i, board, doc.getElementsByTagName(tagName).item(0).getTextContent(), tag); <line16> board.setDigitalInputValue( <line17> i, doc.getElementsByTagName(tagName).item(0).getTextContent()); <line18> } <line19> } else if (tag.equalsIgnoreCase(""an"") || tag.equalsIgnoreCase(""analog"")) { <line20> if (!(board.getAnalogInputValue(i) <line21> == Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent()))) { <line22> sendChanges(i, board, doc.getElementsByTagName(tagName).item(0).getTextContent(), tag); <line23> board.setAnalogInputValue( <line24> i, Integer.parseInt(doc.getElementsByTagName(tagName).item(0).getTextContent())); <line25> } <line26> } <line27> } catch (DOMException domException) { <line28> } <line29> } <line30> } <line31> } <line32> "	1	task3	
public class A { <line0> private <T> T mutableField( <line1> final String fieldName, <line2> @Nullable final T existingValue, <line3> @Nullable final T updatedValue, <line4> final InvoicePluginApi invoicePlugin) { <line5> if (updatedValue != null) { <line6> return updatedValue; <line7> } else { <line8> return existingValue; <line9> } <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> private List<SmallCategory> getCategoryLeaf( <line1> String nodeRootCode, String langCode, boolean completeTitle) { <line2> List<SmallCategory> categories = new ArrayList<SmallCategory>(); <line3> try { <line4> Category root = this.getCategoryManager().getCategory(nodeRootCode); <line5> this.addSmallCategory(categories, root, langCode, completeTitle); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Errore loading categories leafs""); <line8> } <line9> return categories; <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> public static ByteString serializeRawScans(List<RawScan> rawScans) { <line1> ByteString rawScanByteString; <line2> int rawScanBufferSize = BytesSerializer.SERIALIZE_BUFFER_SIZE; <line3> while (true) { <line4> try { <line5> ByteBuffer rawScanBuffer = ByteBuffer.allocate(rawScanBufferSize); <line6> BytesUtil.writeVInt(rawScans.size(), rawScanBuffer); <line7> for (RawScan rs : rawScans) { <line8> RawScan.serializer.serialize(rs, rawScanBuffer); <line9> } <line10> rawScanBuffer.flip(); <line11> rawScanByteString = <line12> HBaseZeroCopyByteString.wrap( <line13> rawScanBuffer.array(), rawScanBuffer.position(), rawScanBuffer.limit()); <line14> break; <line15> } catch (BufferOverflowException boe) { <line16> rawScanBufferSize *= 4; <line17> } <line18> } <line19> return rawScanByteString; <line20> } <line21> } <line22> 	1	task3	
public class A { <line0> private MethodResult makeExceptionResult(Exception e) { <line1> return new MethodResult(Throwables.getStackTraceAsString(e), ReturnType.Exception); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @Override <line1> public void deleteCapabilities(final String providerName) { <line2> em.getTransaction().begin(); <line3> TypedQuery<Capability> query = em.createNamedQuery(Capability.byProvider, Capability.class); <line4> query.setParameter(""providerName"", providerName); <line5> for (ProviderType providerType : ProviderType.values()) { <line6> query.setParameter(""providerType"", providerType); <line7> query.getResultList().forEach(em::remove); <line8> } <line9> em.getTransaction().commit(); <line10> } <line11> } <line12> "	1	task3	
"public class A { <line0> @Override <line1> public void prepare(Object configurationObject) { <line2> try { <line3> connectToCassandra(); <line4> client.start(); <line5> } catch (Exception e) { <line6> return; <line7> } <line8> String selectStatement = getSelectStatement(); <line9> ResultSet rs = client.client().execute(selectStatement); <line10> rowIterator = rs.iterator(); <line11> if (!rowIterator.hasNext()) { <line12> throw new RuntimeException(""Table"" + config.getTable() + ""is empty!""); <line13> } <line14> persistQueue = constructQueue(); <line15> executor = Executors.newSingleThreadExecutor(); <line16> } <line17> } <line18> "	1	task3	
"public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryReplenishmentItem <line1> getCommerceInventoryReplenishmentItem( <line2> HttpPrincipal httpPrincipal, long commerceInventoryReplenishmentItemId) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CommerceInventoryReplenishmentItemServiceUtil.class, <line8> ""getCommerceInventoryReplenishmentItem"", <line9> _getCommerceInventoryReplenishmentItemParameterTypes2); <line10> MethodHandler methodHandler = <line11> new MethodHandler(methodKey, commerceInventoryReplenishmentItemId); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.commerce.inventory.model.CommerceInventoryReplenishmentItem) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	1	task3	
"public class A { <line0> @Override <line1> public void kill(TopologyLayout topology, String asUser) throws Exception { <line2> String stormTopologyId = getRuntimeTopologyId(topology, asUser); <line3> boolean killed = client.killTopology(stormTopologyId, asUser, DEFAULT_WAIT_TIME_SEC); <line4> if (!killed) { <line5> throw new Exception(""Topology could not be killed "" + ""successfully.""); <line6> } <line7> File artifactsDir = getArtifactsLocation(topology).toFile(); <line8> if (artifactsDir.exists() && artifactsDir.isDirectory()) { <line9> FileUtils.cleanDirectory(artifactsDir); <line10> } <line11> } <line12> } <line13> "	1	task3	
"public class A { <line0> private void loadResource( <line1> Map<String, Class<?>> extensionClasses, <line2> ClassLoader classLoader, <line3> java.net.URL resourceURL, <line4> boolean overridden, <line5> String... excludedPackages) { <line6> try { <line7> try (BufferedReader reader = <line8> new BufferedReader( <line9> new InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) { <line10> String line; <line11> String clazz = null; <line12> while ((line = reader.readLine()) != null) { <line13> final int ci = line.indexOf('#'); <line14> if (ci >= 0) { <line15> line = line.substring(0, ci); <line16> } <line17> line = line.trim(); <line18> if (line.length() > 0) { <line19> try { <line20> String name = null; <line21> int i = line.indexOf('='); <line22> if (i > 0) { <line23> name = line.substring(0, i).trim(); <line24> clazz = line.substring(i + 1).trim(); <line25> } else { <line26> clazz = line; <line27> } <line28> if (StringUtils.isNotEmpty(clazz) && !isExcluded(clazz, excludedPackages)) { <line29> loadClass( <line30> extensionClasses, <line31> resourceURL, <line32> Class.forName(clazz, true, classLoader), <line33> name, <line34> overridden); <line35> } <line36> } catch (Throwable t) { <line37> IllegalStateException e = <line38> new IllegalStateException( <line39> ""Failed to load extension class (interface: "" <line40> + type <line41> + "", class line: "" <line42> + line <line43> + "") in "" <line44> + resourceURL <line45> + "", cause: "" <line46> + t.getMessage(), <line47> t); <line48> exceptions.put(line, e); <line49> } <line50> } <line51> } <line52> } <line53> } catch (Throwable t) { <line54> } <line55> } <line56> } <line57> "	1	task3	
"public class A { <line0> protected void exportData(ActionRequest actionRequest, Portlet portlet) throws Exception { <line1> try { <line2> ThemeDisplay themeDisplay = (ThemeDisplay) actionRequest.getAttribute(WebKeys.THEME_DISPLAY); <line3> long plid = ParamUtil.getLong(actionRequest, ""plid""); <line4> long groupId = ParamUtil.getLong(actionRequest, ""groupId""); <line5> String fileName = ParamUtil.getString(actionRequest, ""exportFileName""); <line6> Map<String, Serializable> exportPortletSettingsMap = <line7> _exportImportConfigurationSettingsMapFactory.buildExportPortletSettingsMap( <line8> themeDisplay.getUserId(), <line9> plid, <line10> groupId, <line11> portlet.getPortletId(), <line12> actionRequest.getParameterMap(), <line13> themeDisplay.getLocale(), <line14> themeDisplay.getTimeZone(), <line15> fileName); <line16> ExportImportConfiguration exportImportConfiguration = <line17> _exportImportConfigurationLocalService.addDraftExportImportConfiguration( <line18> themeDisplay.getUserId(), <line19> ExportImportConfigurationConstants.TYPE_EXPORT_PORTLET, <line20> exportPortletSettingsMap); <line21> _exportImportService.exportPortletInfoAsFileInBackground(exportImportConfiguration); <line22> } catch (Exception exception) { <line23> if (exception instanceof LARFileNameException) { <line24> throw exception; <line25> } <line26> if (log.isDebugEnabled()) { <line27> } <line28> SessionErrors.add(actionRequest, exception.getClass(), exception); <line29> } <line30> } <line31> } <line32> "	1	task3	
public class A { <line0> void startPeonsForNewServers(List<ImmutableDruidServer> currentServers) { <line1> for (ImmutableDruidServer server : currentServers) { <line2> loadManagementPeons.computeIfAbsent( <line3> server.getName(), <line4> serverName -> { <line5> LoadQueuePeon loadQueuePeon = taskMaster.giveMePeon(server); <line6> loadQueuePeon.start(); <line7> return loadQueuePeon; <line8> }); <line9> } <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> @Override <line1> public SegmentsExperiment remove(Serializable primaryKey) throws NoSuchExperimentException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> SegmentsExperiment segmentsExperiment = <line6> (SegmentsExperiment) session.get(SegmentsExperimentImpl.class, primaryKey); <line7> if (segmentsExperiment == null) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> throw new NoSuchExperimentException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(segmentsExperiment); <line13> } catch (NoSuchExperimentException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	1	task3	
"public class A { <line0> private Object resolveInterfaceAndClassLoader( <line1> OpenLService service, <line2> ServiceDescription serviceDescription, <line3> RulesInstantiationStrategy instantiationStrategy) <line4> throws RuleServiceInstantiationException, RulesInstantiationException { <line5> String serviceClassName = service.getServiceClassName(); <line6> Class<?> serviceClass; <line7> if (serviceClassName != null) { <line8> try { <line9> serviceClass = service.getClassLoader().loadClass(serviceClassName.trim()); <line10> if (serviceClass.isInterface()) { <line11> Class<?> interfaceForInstantiationStrategy = <line12> RuleServiceInstantiationFactoryHelper.buildInterfaceForInstantiationStrategy( <line13> serviceClass, <line14> instantiationStrategy.getClassLoader(), <line15> serviceDescription.isProvideRuntimeContext(), <line16> serviceDescription.isProvideVariations()); <line17> instantiationStrategy.setServiceClass(interfaceForInstantiationStrategy); <line18> service.setServiceClass(serviceClass); <line19> return instantiationStrategy.instantiate(); <line20> } <line21> throw new RuleServiceRuntimeException( <line22> String.format( <line23> ""Failed to apply service class '%s'. Interface is expected, but class is found."", <line24> serviceClass)); <line25> } catch (ClassNotFoundException | NoClassDefFoundError e) { <line26> throw new RuleServiceRuntimeException( <line27> String.format(""Failed to load a service class '%s'."", serviceClassName), e); <line28> } <line29> } <line30> Class<?> instanceClass = instantiationStrategy.getInstanceClass(); <line31> Object serviceTarget = instantiationStrategy.instantiate(); <line32> serviceClass = <line33> processGeneratedServiceClass( <line34> serviceDescription, service.getOpenClass(), instanceClass, service.getClassLoader()); <line35> service.setServiceClassName(null); <line36> service.setServiceClass(serviceClass); <line37> return serviceTarget; <line38> } <line39> } <line40> "	1	task3	
"public class A { <line0> @Override <line1> protected void service(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> resp.setContentType(""text/plain""); <line4> resp.setCharacterEncoding(""UTF-8""); <line5> String response = <line6> String.format( <line7> ""| %s | %s | %s |"", req.getContextPath(), req.getServletPath(), req.getPathInfo()); <line8> resp.getWriter().write(response); <line9> resp.getWriter().close(); <line10> } <line11> } <line12> "	1	task3	
"public class A { <line0> @Test <line1> public void test_05_hgvs_frameshift() { <line2> checkHgvs(""testHg19Chr19"", path(""hgvs_frameshifts_syn_chr19.vcf""), 2); <line3> } <line4> } <line5> "	1	task3	
"public class A { <line0> private void mergeNextUUIDLookups(final EventQueryResponseBase mergedResponse) { <line1> final String queryId = mergedResponse.getQueryId(); <line2> final List<EventBase> mergedEvents = new LinkedList<>(mergedResponse.getEvents()); <line3> try { <line4> EventQueryResponseBase eventResponse = null; <line5> do { <line6> final BaseQueryResponse nextResponse = this.queryExecutor.next(queryId); <line7> eventResponse = this.validatePagedResponse(nextResponse); <line8> final List<EventBase> nextEvents = <line9> this.removeIrrelevantEventInformation(eventResponse.getEvents()); <line10> mergedEvents.addAll(nextEvents); <line11> } while (null != eventResponse); <line12> } catch (final NoResultsException e) { <line13> } finally { <line14> try { <line15> this.queryExecutor.close(queryId); <line16> } catch (final Exception e) { <line17> final String message = <line18> ""Unable to close UUID lookup query "" + queryId + "" while performing a content lookup""; <line19> } <line20> } <line21> mergedResponse.setEvents(mergedEvents); <line22> } <line23> } <line24> "	1	task3	
"public class A { <line0> @Test <line1> public void testF35() { <line2> setup(VehicleType.CONVENTIONAL.toString(), false); <line3> String content = FileReader.readFileInString(""src/test/resources/responses/F35/status.json""); <line4> assertTrue( <line5> testVehicle( <line6> content, <line7> STATUS_CONV + DOORS + RANGE_CONV + POSITION + SERVICE_EMPTY + CHECK_EMPTY, <line8> Optional.empty())); <line9> } <line10> } <line11> "	1	task3	
public class A { <line0> public Comparison compare(final TransferItem item) { <line1> if (null == comparison) { <line2> return Comparison.equal; <line3> } <line4> return comparison.get(item); <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception { <line3> CopyOnWriteArraySet<SubscriptionInfo> commandSubscriptions = <line4> (CopyOnWriteArraySet) session.getAttributes().get(CommandHandlers.SUBSCRIPTION_SET_NAME); <line5> commandService.sendUnsubscribeRequest( <line6> commandSubscriptions.stream() <line7> .map(SubscriptionInfo::getSubscriptionId) <line8> .collect(Collectors.toSet())); <line9> CopyOnWriteArraySet<SubscriptionInfo> notificationSubscriptions = <line10> (CopyOnWriteArraySet) <line11> session.getAttributes().get(NotificationHandlers.SUBSCRIPTION_SET_NAME); <line12> notificationService.unsubscribe( <line13> notificationSubscriptions.stream() <line14> .map(SubscriptionInfo::getSubscriptionId) <line15> .collect(Collectors.toSet())); <line16> sessionMonitor.removeSession(session.getId()); <line17> if (session.isOpen()) { <line18> session.close(); <line19> } <line20> } <line21> } <line22> "	1	task3	
public class A { <line0> @Override <line1> public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) <line2> throws IOException { <line3> CALL_COUNT++; <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> public static com.liferay.commerce.product.model.CommerceChannelSoap deleteCommerceChannel( <line1> long commerceChannelId) throws RemoteException { <line2> try { <line3> com.liferay.commerce.product.model.CommerceChannel returnValue = <line4> CommerceChannelServiceUtil.deleteCommerceChannel(commerceChannelId); <line5> return com.liferay.commerce.product.model.CommerceChannelSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> private void register(Bundle bundle, CdiContainer cdiContainer) { <line1> CdiServletContainerInitializer initializer = <line2> new CdiServletContainerInitializer(cdiContainer, this); <line3> WebAppDependencyHolder dependencyHolder = <line4> new CdiWebAppDependencyHolder(bundle.getBundleContext(), initializer); <line5> Dictionary<String, String> props = new Hashtable<String, String>(); <line6> props.put(""bundle.id"", Long.toString(bundle.getBundleId())); <line7> ServiceRegistration<WebAppDependencyHolder> registration = <line8> bundle <line9> .getBundleContext() <line10> .registerService(WebAppDependencyHolder.class, dependencyHolder, props); <line11> registrations.put(bundle, registration); <line12> } <line13> } <line14> "	1	task3	
public class A { <line0> @Override <line1> protected void beforeTopologyInstalled( <line2> int topologyId, <line3> boolean startRebalance, <line4> ConsistentHash previousWriteCh, <line5> ConsistentHash newWriteCh) { <line6> for (int segment = 0; segment < newWriteCh.getNumSegments(); ++segment) { <line7> if (!newWriteCh.isSegmentLocalToNode(rpcManager.getAddress(), segment)) { <line8> cancelTransfers(IntSets.immutableSet(segment)); <line9> svm.unregisterSegment(segment); <line10> } <line11> } <line12> IntSet addedSegments = getOwnedSegments(newWriteCh); <line13> if (previousWriteCh != null && !addedSegments.isEmpty()) { <line14> addedSegments.removeAll(getOwnedSegments(previousWriteCh)); <line15> } <line16> svm.setTopologyId(topologyId); <line17> if (previousWriteCh == null || !isFetchEnabled) { <line18> svm.setOwnedSegments(addedSegments); <line19> return; <line20> } <line21> if (!addedSegments.isEmpty()) { <line22> svm.setValuesTransferTopology(topologyId); <line23> for (PrimitiveIterator.OfInt segmentIterator = addedSegments.iterator(); <line24> segmentIterator.hasNext(); ) { <line25> svm.registerSegment(segmentIterator.nextInt()); <line26> } <line27> } <line28> } <line29> } <line30> 	1	task3	
public class A { <line0> private void writeConfigFile(String tmpFileName, String dstFileName, StringBuilder sb) <line1> throws KuraException { <line2> File srcFile = new File(tmpFileName); <line3> File dstFile = new File(dstFileName); <line4> try (FileOutputStream fos = new FileOutputStream(srcFile); <line5> PrintWriter pw = new PrintWriter(fos)) { <line6> pw.write(sb.toString()); <line7> pw.flush(); <line8> fos.getFD().sync(); <line9> } catch (Exception e) { <line10> throw KuraException.internalError(e.getMessage()); <line11> } <line12> copyConfigFile(srcFile, dstFile); <line13> } <line14> } <line15> 	1	task3	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> while (running.get()) { <line4> getMessagesAdded(queue); <line5> getMessageCount(queue); <line6> Thread.sleep(10); <line7> } <line8> } catch (InterruptedException e) { <line9> } <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> public String fetchUserIdByMobile(String mobile) throws Exception { <line1> OapiUserGetByMobileRequest request = new OapiUserGetByMobileRequest(); <line2> request.setMobile(mobile); <line3> OapiUserGetByMobileResponse execute = userIdClient.execute(request, accessToken); <line4> if (execute.isSuccess()) { <line5> return execute.getUserid(); <line6> } <line7> throw new PowerJobException( <line8> ""fetch userId by phone number failed, reason is "" + execute.getErrmsg()); <line9> } <line10> } <line11> "	1	task3	
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> if (!registerPromise.isDone()) { <line3> registerPromise.setFailure(cause); <line4> } <line5> ctx.close(); <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> public void stop() { <line1> if (log.isDebugEnabled()) { <line2> } <line3> if (runInfo.getDuration().getPeriodType() == PeriodType.TIME) { <line4> runInfo.stop(); <line5> waitForReportingTasks(); <line6> } else { <line7> waitForReportingTasks(); <line8> runInfo.stop(); <line9> } <line10> reportFinalTimeResults(); <line11> reporters.forEach(org.perfcake.reporting.reporter.Reporter::stop); <line12> if (periodicThread != null) { <line13> periodicThread.interrupt(); <line14> } <line15> periodicThread = null; <line16> } <line17> } <line18> 	1	task3	
public class A { <line0> @Override <line1> public void resolveLinks(ContentRenderizationInfo renderizationInfo, RequestContext reqCtx) { <line2> if (null == renderizationInfo) { <line3> return; <line4> } <line5> try { <line6> String finalRenderedContent = <line7> this.getLinkResolverManager() <line8> .resolveLinks( <line9> renderizationInfo.getCachedRenderedContent(), <line10> renderizationInfo.getContentId(), <line11> reqCtx); <line12> renderizationInfo.setRenderedContent(finalRenderedContent); <line13> } catch (Throwable t) { <line14> } <line15> } <line16> } <line17> 	1	task3	
"public class A { <line0> @Test <line1> public void testReading() throws Exception { <line2> String filename = ""data/vasp/LiMoS2_optimisation_ISIF3.vasp""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> VASPReader reader = new VASPReader(ins); <line5> ChemFile chemFile = (ChemFile) reader.read(new ChemFile()); <line6> Assert.assertNotNull(chemFile); <line7> org.openscience.cdk.interfaces.IChemSequence sequence = chemFile.getChemSequence(0); <line8> Assert.assertNotNull(sequence); <line9> Assert.assertEquals(6, sequence.getChemModelCount()); <line10> org.openscience.cdk.interfaces.IChemModel model = sequence.getChemModel(0); <line11> Assert.assertNotNull(model); <line12> org.openscience.cdk.interfaces.ICrystal crystal = model.getCrystal(); <line13> Assert.assertNotNull(crystal); <line14> Assert.assertEquals(16, crystal.getAtomCount()); <line15> org.openscience.cdk.interfaces.IAtom atom = crystal.getAtom(0); <line16> Assert.assertNotNull(atom); <line17> Assert.assertNotNull(atom.getFractionalPoint3d()); <line18> } <line19> } <line20> "	1	task3	
public class A { <line0> @Override <line1> public void receivedSuccessMessage(Request request, Answer answer) { <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> @JsxFunction <line1> public boolean confirm(final String message) { <line2> final ConfirmHandler handler = getWebWindow().getWebClient().getConfirmHandler(); <line3> if (handler == null) { <line4> if (LOG.isWarnEnabled()) { <line5> } <line6> return true; <line7> } <line8> return handler.handleConfirm(document_.getPage(), message); <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> public void updateLastTimeSMPPLinkUpdated() { <line1> lastTimeSMPPLinkUpdated = System.currentTimeMillis(); <line2> if (logger.isDebugEnabled()) <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> @Override <line1> public Collection<SchemaVersionInfo> getAllVersions(String schemaName) <line2> throws SchemaNotFoundException { <line3> try { <line4> return atlasClient.getAllSchemaVersions(schemaName); <line5> } catch (AtlasUncheckedException npex) { <line6> throw new SchemaNotFoundException(""Schema not found with name "" + schemaName, npex); <line7> } <line8> } <line9> } <line10> "	1	task3	
"public class A { <line0> @Override <line1> public void safeProcessResult(int rc, String path, Object ctx, byte[] data, Stat stat) { <line2> if (Code.NONODE.intValue() == rc) { <line3> callback.operationFinished(ctx, null); <line4> return; <line5> } <line6> if (Code.OK.intValue() != rc) { <line7> KeeperException e = <line8> ZkUtils.logErrorAndCreateZKException( <line9> ""Could not read ownership for topic: "" + topic.toStringUtf8(), path, rc); <line10> callback.operationFailed(ctx, new PubSubException.ServiceDownException(e)); <line11> return; <line12> } <line13> HubInfo owner = null; <line14> try { <line15> owner = HubInfo.parse(new String(data)); <line16> } catch (HubInfo.InvalidHubInfoException ihie) { <line17> } <line18> int version = stat.getVersion(); <line19> callback.operationFinished(ctx, new Versioned<HubInfo>(owner, new ZkVersion(version))); <line20> return; <line21> } <line22> } <line23> "	1	task3	
"public class A { <line0> @Override <line1> void onPreviousNodeFail() { <line2> joinErrorWatcher.checkJoinError(); <line3> if (rtState.errForClose != null || rtState.joined) return; <line4> synchronized (stateMux) { <line5> if (connState != STARTED) return; <line6> } <line7> localNodeFail(""Local node was forced to stop."", true); <line8> } <line9> } <line10> "	1	task3	
public class A { <line0> protected boolean parse( <line1> final Path workdir, <line2> final ListProgressListener listener, <line3> final AttributedList<Path> list, <line4> final SearchV2Result result) <line5> throws ConnectionCanceledException { <line6> final List<SearchMatchV2> matches = result.getMatches(); <line7> for (SearchMatchV2 match : matches) { <line8> final Metadata metadata = match.getMetadata().getMetadataValue(); <line9> final EnumSet<Path.Type> type; <line10> if (metadata instanceof FileMetadata) { <line11> type = EnumSet.of(Path.Type.file); <line12> } else if (metadata instanceof FolderMetadata) { <line13> type = EnumSet.of(Path.Type.directory); <line14> } else { <line15> return true; <line16> } <line17> list.add(new Path(metadata.getPathDisplay(), type, attributes.toAttributes(metadata))); <line18> listener.chunk(workdir, list); <line19> } <line20> return false; <line21> } <line22> } <line23> 	1	task3	
"public class A { <line0> @Override <line1> public void setServletContext(ServletContext servletContext) { <line2> if (servletContext != null) { <line3> String accessKey = servletContext.getInitParameter(""cw.user""); <line4> String secretKey = servletContext.getInitParameter(""cw.password""); <line5> String environment = servletContext.getInitParameter(""obanyc.environment""); <line6> String endPoint = <line7> _configurationService.getConfigurationValueAsString( <line8> ""aws.endPoint"", ""monitoring.us-east-1.amazonaws.com""); <line9> if (StringUtils.isNotBlank(accessKey) && StringUtils.isNotBlank(secretKey)) { <line10> AmazonCloudWatchClient cloudWatch = <line11> new AmazonCloudWatchClient(new BasicAWSCredentials(accessKey, secretKey)); <line12> cloudWatch.setEndpoint(endPoint); <line13> this.cloudWatch = cloudWatch; <line14> } else { <line15> } <line16> if (StringUtils.isNotBlank(environment)) { <line17> this.environmentName = environment; <line18> this.nameSpace = ""Obanyc:"" + environment; <line19> } <line20> } <line21> } <line22> } <line23> "	1	task3	
public class A { <line0> @Test <line1> public void testPlatformIncludesList() { <line2> PlatformDto p = load(PlatformRestResource.CAMP_URI_PATH, PlatformDto.class); <line3> PlatformComponentTemplateDto pct = <line4> load( <line5> p.getPlatformComponentTemplates().get(0).getHref(), PlatformComponentTemplateDto.class); <line6> Assert.assertNotNull(pct.getName()); <line7> } <line8> } <line9> 	1	task3	
"public class A { <line0> @Override <line1> protected void execute() throws Exception { <line2> if (srcPath == null) { <line3> throw new IllegalArgumentException(""File parameter is missing.""); <line4> } <line5> if (attName == null) { <line6> throw new IllegalArgumentException(""attName parameter is missing.""); <line7> } <line8> if (attValue == null) { <line9> throw new IllegalArgumentException(""attValue parameter is missing.""); <line10> } <line11> if (!dfsClient.exists(srcPath)) { <line12> throw new ActionException(""SetXAttr Action fails, file doesn't exist!""); <line13> } <line14> appendLog(String.format(""SetXattr path=%s name=%s value=%s"", srcPath, attName, attValue)); <line15> dfsClient.setXAttr( <line16> srcPath, <line17> attName, <line18> attValue.getBytes(), <line19> EnumSet.of(XAttrSetFlag.CREATE, XAttrSetFlag.REPLACE)); <line20> appendLog(""SetXattr Successfully!!""); <line21> } <line22> } <line23> "	1	task3	
"public class A { <line0> @Override <line1> public JavaRDD<HoodieRecord<T>> handleUpdate(JavaRDD<HoodieRecord<T>> taggedRecordsRDD) { <line2> List<HoodieFileGroupId> fileGroupIdsWithRecordUpdate = getGroupIdsWithUpdate(taggedRecordsRDD); <line3> fileGroupIdsWithRecordUpdate.forEach( <line4> fileGroupIdWithRecordUpdate -> { <line5> if (fileGroupsInPendingClustering.contains(fileGroupIdWithRecordUpdate)) { <line6> String msg = <line7> String.format( <line8> ""Not allowed to update the clustering file group %s. For pending clustering"" <line9> + "" operations, we are not going to support update for now."", <line10> fileGroupIdWithRecordUpdate.toString()); <line11> throw new HoodieClusteringUpdateException(msg); <line12> } <line13> }); <line14> return taggedRecordsRDD; <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> public static boolean deleteQuietly(final Path path) { <line1> try { <line2> if (!Files.isDirectory(path)) { <line3> return Files.deleteIfExists(path); <line4> } else { <line5> Files.walkFileTree(path, deleteDirVisitor); <line6> } <line7> return true; <line8> } catch (final IOException ioe) { <line9> return false; <line10> } <line11> } <line12> } <line13> 	1	task3	
public class A { <line0> public synchronized void updateRatio(double currentCompressionRatio) throws IOException { <line1> File oldFile = <line2> SystemFileFactory.INSTANCE.getFile( <line3> directory, <line4> String.format(Locale.ENGLISH, RATIO_FILE_PATH_FORMAT, compressionRatioSum, calcTimes)); <line5> compressionRatioSum += currentCompressionRatio; <line6> calcTimes++; <line7> File newFile = <line8> SystemFileFactory.INSTANCE.getFile( <line9> directory, <line10> String.format(Locale.ENGLISH, RATIO_FILE_PATH_FORMAT, compressionRatioSum, calcTimes)); <line11> persist(oldFile, newFile); <line12> compressionRatio.set(compressionRatioSum / calcTimes); <line13> if (LOGGER.isInfoEnabled()) { <line14> } <line15> } <line16> } <line17> 	1	task3	
public class A { <line0> @Override <line1> public void configurePipeline(PipelineConfigurer pipelineConfigurer) { <line2> FailureCollector collector = pipelineConfigurer.getStageConfigurer().getFailureCollector(); <line3> config.validate(collector); <line4> collector.getOrThrowException(); <line5> if (config.containsMacro(NAME_FORMAT)) { <line6> for (FileFormat f : FileFormat.values()) { <line7> try { <line8> pipelineConfigurer.usePlugin( <line9> ValidatingOutputFormat.PLUGIN_TYPE, <line10> f.name().toLowerCase(), <line11> f.name().toLowerCase(), <line12> config.getRawProperties()); <line13> } catch (InvalidPluginConfigException e) { <line14> } <line15> } <line16> return; <line17> } <line18> String format = config.getFormatName(); <line19> ValidatingOutputFormat validatingOutputFormat = getValidatingOutputFormat(pipelineConfigurer); <line20> FormatContext context = <line21> new FormatContext(collector, pipelineConfigurer.getStageConfigurer().getInputSchema()); <line22> validateOutputFormatProvider(context, format, validatingOutputFormat); <line23> } <line24> } <line25> 	1	task3	
public class A { <line0> public static List<Job.Status> getBundleStatuses(List<BundleJob> bundles) { <line1> List<Job.Status> statuses = new ArrayList<>(); <line2> for (BundleJob bundle : bundles) { <line3> statuses.add(bundle.getStatus()); <line4> } <line5> return statuses; <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> @org.junit.Test <line1> public void testValidateRedeliveryFlagAfterRecovery() throws Exception { <line2> ConnectionFactory connectionFactory = <line3> new ActiveMQConnectionFactory( <line4> broker.getTransportConnectors().get(0).getPublishableConnectString() <line5> + ""?jms.prefetchPolicy.all=0""); <line6> connection = (ActiveMQConnection) connectionFactory.createConnection(); <line7> connection.start(); <line8> Session session = connection.createSession(true, Session.SESSION_TRANSACTED); <line9> Destination destination = session.createQueue(queueName); <line10> populateDestination(1, destination, connection); <line11> MessageConsumer consumer = session.createConsumer(destination); <line12> TextMessage msg = (TextMessage) consumer.receive(5000); <line13> assertNotNull(""got the message"", msg); <line14> assertEquals(""first delivery"", 1, msg.getLongProperty(""JMSXDeliveryCount"")); <line15> assertEquals(""not a redelivery"", false, msg.getJMSRedelivered()); <line16> stopBrokerWithStoreFailure(broker, persistenceAdapterChoice); <line17> broker = createRestartedBroker(); <line18> broker.start(); <line19> connection.close(); <line20> connectionFactory = <line21> new ActiveMQConnectionFactory( <line22> broker.getTransportConnectors().get(0).getPublishableConnectString()); <line23> connection = (ActiveMQConnection) connectionFactory.createConnection(); <line24> connection.start(); <line25> session = connection.createSession(true, Session.SESSION_TRANSACTED); <line26> consumer = session.createConsumer(destination); <line27> msg = (TextMessage) consumer.receive(10000); <line28> assertNotNull(""got the message again"", msg); <line29> assertEquals(""redelivery count survives restart"", 2, msg.getLongProperty(""JMSXDeliveryCount"")); <line30> assertEquals(""re delivery flag"", true, msg.getJMSRedelivered()); <line31> session.commit(); <line32> connection.close(); <line33> } <line34> } <line35> "	1	task3	
"public class A { <line0> @Test <line1> public void testProcessing_event_to_task_group() { <line2> int processingID = 4923; <line3> int[] parentIDs = {30, 32}; <line4> int[] childIDs = {34, 36}; <line5> String algorithm = ""MetadataWS testProcessing_event_to_task_group ""; <line6> String description = ""testProcessing_event_to_task_group""; <line7> int expResult = ReturnValue.SUCCESS; <line8> ReturnValue result = <line9> instance.processing_event_to_task_group( <line10> processingID, parentIDs, childIDs, algorithm, description); <line11> Assert.assertEquals(expResult, result.getExitStatus()); <line12> testCount( <line13> ""select count(*) from processing_relationship "" <line14> + ""where (parent_id=4923 AND child_id IN (34,36)) "" <line15> + ""OR (child_id=4923 AND parent_id IN (30,32));"", <line16> 4); <line17> } <line18> } <line19> "	1	task3	
"public class A { <line0> @POST(path = ""/backend/config/gauges/add"", permission = ""agent:config:edit:gauge"") <line1> String addGauge(@BindAgentId String agentId, @BindRequest GaugeConfigDto gaugeConfigDto) <line2> throws Exception { <line3> GaugeConfig gaugeConfig = gaugeConfigDto.convert(); <line4> try { <line5> configRepository.insertGaugeConfig(agentId, gaugeConfig); <line6> } catch (DuplicateMBeanObjectNameException e) { <line7> throw new JsonServiceException(CONFLICT, ""mbeanObjectName""); <line8> } <line9> return getGaugeResponse(agentId, gaugeConfig); <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> private SessionRecord convert(Session session) { <line1> SimpleSession ssession = (SimpleSession) session; <line2> SessionRecord sessionRecord = new SessionRecord(); <line3> sessionRecord.setIdsession(session.getId().toString()); <line4> sessionRecord.setStarttimestamp(new Timestamp(session.getStartTimestamp().getTime())); <line5> sessionRecord.setLastaccesstime(new Timestamp(session.getLastAccessTime().getTime())); <line6> sessionRecord.setTimeout(session.getTimeout()); <line7> sessionRecord.setHost(session.getHost()); <line8> if (ssession.getAttributes() != null) { <line9> HashMap<Object, Object> attributes = (HashMap<Object, Object>) ssession.getAttributes(); <line10> sessionRecord.setAttributes(SerializationUtils.serialize(attributes)); <line11> } <line12> return sessionRecord; <line13> } <line14> } <line15> 	1	task3	
"public class A { <line0> @Override <line1> public void createTable(final TableLayoutDesc tableLayout) throws IOException { <line2> final State state = mState.get(); <line3> Preconditions.checkState( <line4> state == State.OPEN, ""Cannot create table in Kiji instance %s in state %s."", this, state); <line5> final KijiURI tableURI = KijiURI.newBuilder(mURI).withTableName(tableLayout.getName()).build(); <line6> ensureValidationCompatibility(tableLayout); <line7> if (isSecurityEnabled()) { <line8> getSecurityManager().lock(); <line9> try { <line10> createTableUnchecked(tableLayout); <line11> getSecurityManager().applyPermissionsToNewTable(tableURI); <line12> } finally { <line13> getSecurityManager().unlock(); <line14> } <line15> } else { <line16> createTableUnchecked(tableLayout); <line17> } <line18> } <line19> } <line20> "	1	task3	
"public class A { <line0> private static Future<String> extractVersionForUpdate( <line1> final ResultSet device, final Optional<String> resourceVersion) { <line2> final Optional<String> version = <line3> device.getRows(true).stream().map(o -> o.getString(""version"")).findAny(); <line4> if (version.isEmpty()) { <line5> return Future.failedFuture(new EntityNotFoundException()); <line6> } <line7> final var currentVersion = version.get(); <line8> return resourceVersion <line9> .<Future<String>>map( <line10> expected -> { <line11> if (expected.equals(currentVersion)) { <line12> return Future.succeededFuture(currentVersion); <line13> } else { <line14> return Future.failedFuture(new OptimisticLockingException()); <line15> } <line16> }) <line17> .orElseGet(() -> Future.succeededFuture(currentVersion)); <line18> } <line19> } <line20> "	1	task3	
public class A { <line0> @Override <line1> public void doStateTransition() { <line2> var op = txnCtx.accessor().getTxn().getFileCreate(); <line3> try { <line4> var validity = assessedValidity(op); <line5> if (validity != OK) { <line6> txnCtx.setStatus(validity); <line7> return; <line8> } <line9> var attr = asAttr(op); <line10> var sponsor = txnCtx.activePayer(); <line11> var created = hfs.create(op.getContents().toByteArray(), attr, sponsor); <line12> txnCtx.setCreated(created); <line13> txnCtx.setStatus(SUCCESS); <line14> } catch (IllegalArgumentException iae) { <line15> mapToStatus(iae, txnCtx); <line16> } catch (Exception unknown) { <line17> txnCtx.setStatus(FAIL_INVALID); <line18> } <line19> } <line20> } <line21> 	1	task3	
public class A { <line0> void handleStart(Exchange exchange, MetricRegistry registry, String metricsName) { <line1> String propertyName = getPropertyName(metricsName); <line2> Timer.Context context = getTimerContextFromExchange(exchange, propertyName); <line3> if (context == null) { <line4> Timer timer = registry.timer(metricsName); <line5> context = timer.time(); <line6> exchange.setProperty(propertyName, context); <line7> } else { <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> protected Map<NodeIDSuffix, WebViewContent> getWizardPageViewValueMapInternal( <line1> final NodeID subnodeID) { <line2> if (subnodeID == null) { <line3> return null; <line4> } <line5> final WorkflowManager manager = m_manager; <line6> assert manager.isLockedByCurrentThread(); <line7> SubNodeContainer subNC = manager.getNodeContainer(subnodeID, SubNodeContainer.class, true); <line8> WorkflowManager subWFM = subNC.getWorkflowManager(); <line9> return subWFM.findExecutedNodes(WizardNode.class, NOT_HIDDEN_FILTER).entrySet().stream() <line10> .filter( <line11> e -> !subWFM.getNodeContainer(e.getKey(), NativeNodeContainer.class, true).isInactive()) <line12> .collect( <line13> Collectors.toMap( <line14> e -> NodeID.NodeIDSuffix.create(manager.getID(), e.getKey()), <line15> e -> e.getValue().getViewValue())); <line16> } <line17> } <line18> 	1	task3	
public class A { <line0> public VersionLanguagesTab filterEnabledLanguages(String localeQuery) { <line1> readyElement(activeLocalesFilter).clear(); <line2> enterText(readyElement(activeLocalesFilter), localeQuery); <line3> return new VersionLanguagesTab(getDriver()); <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> @Override <line1> public void removeBpmWidgetInfo(String pageCode) { <line2> PreparedStatement stat = null; <line3> Connection conn = null; <line4> try { <line5> conn = this.getConnection(); <line6> conn.setAutoCommit(false); <line7> this.removeBpmWidgetInfoByPageCode(pageCode, conn); <line8> conn.commit(); <line9> } catch (Throwable t) { <line10> this.executeRollback(conn); <line11> throw new RuntimeException(""Error deleting bpmWidgetInfo"", t); <line12> } finally { <line13> this.closeDaoResources(null, stat, conn); <line14> } <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> @Override <line1> public void init(ServletConfig servletConfig) throws ServletException { <line2> super.init(servletConfig); <line3> this.planetCache = PlanetCache.getInstance(); <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> public IIdeaComment getComment(int id) { <line1> IIdeaComment comment = null; <line2> try { <line3> comment = this.getIdeaCommentManager().getComment(id); <line4> if (null != comment && comment.getStatus() != IIdea.STATUS_APPROVED) { <line5> return null; <line6> } <line7> } catch (Throwable t) { <line8> throw new RuntimeException(""Errore in caricamento commento "" + id); <line9> } <line10> return comment; <line11> } <line12> } <line13> "	1	task3	
public class A { <line0> public static Set<IdentifierExtractionResult> extractIdentifiers( <line1> UUID datasetKey, <line2> byte[] xml, <line3> OccurrenceSchemaType schemaType, <line4> boolean useTriplet, <line5> boolean useOccurrenceId) { <line6> Set<IdentifierExtractionResult> results = Sets.newHashSet(); <line7> List<RawOccurrenceRecord> records = parseRecord(xml, schemaType); <line8> if (records != null && !records.isEmpty()) { <line9> for (RawOccurrenceRecord record : records) { <line10> Set<UniqueIdentifier> ids = Sets.newHashSet(); <line11> if (useTriplet) { <line12> Triplet triplet = null; <line13> try { <line14> triplet = <line15> new Triplet( <line16> datasetKey, <line17> record.getInstitutionCode(), <line18> record.getCollectionCode(), <line19> record.getCatalogueNumber(), <line20> record.getUnitQualifier()); <line21> } catch (IllegalArgumentException e) { <line22> } <line23> if (triplet != null) { <line24> ids.add(triplet); <line25> } <line26> } <line27> if (useOccurrenceId <line28> && record.getIdentifierRecords() != null <line29> && !record.getIdentifierRecords().isEmpty()) { <line30> for (IdentifierRecord idRecord : record.getIdentifierRecords()) { <line31> if ((idRecord.getIdentifierType() == 1 || idRecord.getIdentifierType() == 7) <line32> && idRecord.getIdentifier() != null) { <line33> ids.add(new PublisherProvidedUniqueIdentifier(datasetKey, idRecord.getIdentifier())); <line34> } <line35> } <line36> } <line37> if (!ids.isEmpty()) { <line38> results.add(new IdentifierExtractionResult(ids, record.getUnitQualifier())); <line39> } <line40> } <line41> } <line42> return results; <line43> } <line44> } <line45> 	1	task3	
public class A { <line0> @Deprecated <line1> public static com.liferay.commerce.price.list.model.CommercePriceEntrySoap <line2> updateExternalReferenceCode( <line3> com.liferay.commerce.price.list.model.CommercePriceEntrySoap commercePriceEntry, <line4> String externalReferenceCode) <line5> throws RemoteException { <line6> try { <line7> com.liferay.commerce.price.list.model.CommercePriceEntry returnValue = <line8> CommercePriceEntryServiceUtil.updateExternalReferenceCode( <line9> com.liferay.commerce.price.list.model.impl.CommercePriceEntryModelImpl.toModel( <line10> commercePriceEntry), <line11> externalReferenceCode); <line12> return com.liferay.commerce.price.list.model.CommercePriceEntrySoap.toSoapModel(returnValue); <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	1	task3	
public class A { <line0> @Override <line1> public boolean blockUntilEnded(Duration timeout) { <line2> Long endTime = <line3> timeout == null ? null : System.currentTimeMillis() + timeout.toMillisecondsRoundingUp(); <line4> try { <line5> boolean started = blockUntilStarted(timeout); <line6> if (!started) return false; <line7> if (timeout == null) { <line8> internalFuture.get(); <line9> } else { <line10> long remaining = endTime - System.currentTimeMillis(); <line11> if (remaining > 0) internalFuture.get(remaining, TimeUnit.MILLISECONDS); <line12> } <line13> return isDone(); <line14> } catch (Throwable t) { <line15> Exceptions.propagateIfFatal(t); <line16> if (!(t instanceof TimeoutException) && log.isDebugEnabled()) <line17> return isDone(); <line18> } <line19> } <line20> } <line21> 	1	task3	
"public class A { <line0> public String modifyImpl() { <line1> if (this.initialized) { <line2> return OxTrustConstants.RESULT_SUCCESS; <line3> } <line4> try { <line5> GluuConfiguration configuration = configurationService.getConfiguration(); <line6> if (configuration == null) { <line7> return OxTrustConstants.RESULT_FAILURE; <line8> } <line9> this.passportEnable = configuration.isPassportEnabled(); <line10> this.customScripts = <line11> customScriptService.findCustomScripts( <line12> Arrays.asList(CustomScriptType.PERSON_AUTHENTICATION), <line13> ""displayName"", <line14> ""oxLevel"", <line15> ""oxEnabled""); <line16> List<OxIDPAuthConf> list = getIDPAuthConfOrNull(configuration); <line17> this.sourceConfigs = new ArrayList<GluuLdapConfiguration>(); <line18> if (list != null) { <line19> for (OxIDPAuthConf oxIDPAuthConf : list) { <line20> GluuLdapConfiguration oxldapConfig = oxIDPAuthConf.getConfig(); <line21> this.sourceConfigs.add(oxldapConfig); <line22> } <line23> } <line24> getAuthenticationRecaptcha(); <line25> this.authenticationMode = configuration.getAuthenticationMode(); <line26> this.oxTrustAuthenticationMode = configuration.getOxTrustAuthenticationMode(); <line27> } catch (Exception ex) { <line28> return OxTrustConstants.RESULT_FAILURE; <line29> } <line30> this.initialized = true; <line31> return OxTrustConstants.RESULT_SUCCESS; <line32> } <line33> } <line34> "	1	task3	
"public class A { <line0> public void setInitProject(String currentProjectName) { <line1> try { <line2> this.currentProjectName = currentProjectName; <line3> newProjectName = null; <line4> projectFolder = """"; <line5> comment = null; <line6> copyOldRevisions = Boolean.FALSE; <line7> revisionsCount = null; <line8> separateProject = false; <line9> errorMessage = null; <line10> if (isSupportsBranches()) { <line11> RulesProject project = getCurrentProject(); <line12> currentBranchName = project.getBranch(); <line13> String userName = getUserWorkspace().getUser().getUserName(); <line14> String date = new SimpleDateFormat(""yyyyMMdd"").format(new Date()); <line15> newBranchName = designRepoComments.newBranch(getBusinessName(), userName, date); <line16> } <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> "	1	task3	
public class A { <line0> @Override <line1> public void stop() { <line2> delegate.stop(); <line3> super.stop(); <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> public void onComplete(Void o) { <line1> createInterpreter_result result = new createInterpreter_result(); <line2> try { <line3> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line4> return; <line5> } catch (Exception e) { <line6> } <line7> fb.close(); <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> private void setValue(boolean bool) { <line1> try { <line2> pin.setValue(bool); <line3> TimeUnit.SECONDS.sleep(1); <line4> } catch (InterruptedException <line5> | KuraUnavailableDeviceException <line6> | IOException <line7> | KuraClosedDeviceException e) { <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> private void updateChannelState(Channel channel) { <line1> if (!isLinked(channel.getUID())) { <line2> return; <line3> } <line4> if (comfoAirConnector != null) { <line5> boolean isActive = !comfoAirConnector.getIsSuspended(); <line6> String commandKey = channel.getUID().getId(); <line7> if (commandKey.equals(ACTIVATE_CHANNEL_ID)) { <line8> State state = OnOffType.from(isActive); <line9> updateState(channel.getUID(), state); <line10> return; <line11> } <line12> if (!isActive) { <line13> return; <line14> } <line15> ComfoAirCommand readCommand = ComfoAirCommandType.getReadCommand(commandKey); <line16> if (readCommand != null && readCommand.getRequestCmd() != null) { <line17> scheduler.submit( <line18> () -> { <line19> State state = sendCommand(readCommand, commandKey); <line20> updateState(channel.getUID(), state); <line21> }); <line22> } <line23> } <line24> } <line25> } <line26> 	1	task3	
"public class A { <line0> @Override <line1> public void dispose() { <line2> if (em != null) { <line3> try { <line4> em.getClass().getMethod(""close"", new Class[] {}).invoke(em, new Object[] {}); <line5> } catch (Exception ex) { <line6> } <line7> } <line8> } <line9> } <line10> "	1	task3	
public class A { <line0> public void run() { <line1> byte[] buf = new byte[1024]; <line2> try { <line3> InputStream in = src.getInputStream(); <line4> OutputStream out = destination.getOutputStream(); <line5> while (true) { <line6> int len = in.read(buf); <line7> if (len == -1) { <line8> break; <line9> } <line10> pause.get().await(); <line11> out.write(buf, 0, len); <line12> } <line13> } catch (Exception e) { <line14> try { <line15> close(); <line16> } catch (Exception ignore) { <line17> } <line18> } <line19> } <line20> } <line21> 	1	task3	
public class A { <line0> public GroupStructuralData getGroupStructuralContents(String group) throws EngineException { <line1> Stopwatch watch = Stopwatch.createStarted(); <line2> GroupStructuralDataImpl ret = <line3> GroupStructuralDataImpl.builder() <line4> .withGroup(group) <line5> .withGroups(groupDAO.getAllAsMap()) <line6> .build(); <line7> return ret; <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> private ProductCertificate createCertForProduct(Product product) <line1> throws GeneralSecurityException, IOException { <line2> KeyPair keyPair = this.pki.generateNewKeyPair(); <line3> Set<X509ExtensionWrapper> extensions = this.extensionUtil.productExtensions(product); <line4> BigInteger serial = BigInteger.valueOf(product.getId().hashCode()).abs(); <line5> Calendar future = Calendar.getInstance(); <line6> future.add(Calendar.YEAR, 10); <line7> X509Certificate x509Cert = <line8> this.pki.createX509Certificate( <line9> ""CN="" + product.getId(), <line10> extensions, <line11> null, <line12> new Date(), <line13> future.getTime(), <line14> keyPair, <line15> serial, <line16> null); <line17> ProductCertificate cert = new ProductCertificate(); <line18> cert.setKeyAsBytes(this.pki.getPemEncoded(keyPair.getPrivate())); <line19> cert.setCertAsBytes(this.pki.getPemEncoded(x509Cert)); <line20> cert.setProduct(product); <line21> return cert; <line22> } <line23> } <line24> "	1	task3	
"public class A { <line0> public void testGetActionMappingName1() { <line1> String[] paths = { <line2> ""foo"", ""foo.do"", ""foo?foo=bar"", ""foo?foo=bar&bar=baz"", ""foo?foo=bar&amp;bar=baz"" <line3> }; <line4> String[][] prepends = { <line5> {"""", ""/foo""}, {""/"", ""/foo""}, {""bar/"", ""/bar/foo""}, {""/bar/"", ""/bar/foo""} <line6> }; <line7> String[] appends = { <line8> """", ""#anchor"", ""?"", ""?#"", ""?foo=bar"", ""?foo1=bar1&foo2=bar2"", ""?foo1=bar1&amp;foo2=bar2"" <line9> }; <line10> String finalResult = null; <line11> String path = null; <line12> String results = null; <line13> boolean equality = false; <line14> int ct = 0; <line15> for (int i = 0; i < appends.length; i++) { <line16> for (int j = 0; j < prepends.length; j++) { <line17> finalResult = prepends[j][1]; <line18> for (int k = 0; k < paths.length; k++) { <line19> path = prepends[j][0] + paths[k] + appends[i]; <line20> results = tagutils.getActionMappingName(path); <line21> equality = finalResult.equals(results); <line22> if (!equality) { <line23> fail( <line24> ""Path does not return correct result\n"" <line25> + ""\nexpected: "" <line26> + results <line27> + ""\nfound: "" <line28> + path); <line29> } <line30> assertTrue(""Path should translate to result"", equality); <line31> ct++; <line32> } <line33> } <line34> } <line35> } <line36> } <line37> "	1	task3	
"public class A { <line0> @GetMapping(CommonConstants.PATH_LOGBOOK) <line1> public JsonNode findHistoryById(final @PathVariable(""id"") String id) { <line2> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line3> final VitamContext vitamContext = <line4> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line5> return operationInternalService.findHistoryByIdentifier(vitamContext, id); <line6> } <line7> } <line8> "	1	task3	
"public class A { <line0> void loadSpring() { <line1> try { <line2> SpringApplicationContext.getInstance() <line3> .initializeSpring(""classpath:provenance-application-context.xml""); <line4> } catch (BeansException | IllegalStateException e) { <line5> } <line6> } <line7> } <line8> "	1	task3	
public class A { <line0> boolean containsUuidIdentifiersOnly() { <line1> if (hasQueryPredicates()) { <line2> return false; <line3> } <line4> if ((identifiers == null) || identifiers.isEmpty()) { <line5> return false; <line6> } <line7> for (Identifier identifier : identifiers) { <line8> if (identifier == null) { <line9> return false; <line10> } <line11> if (!identifier.isUUID()) { <line12> return false; <line13> } <line14> } <line15> return true; <line16> } <line17> } <line18> 	1	task3	
"public class A { <line0> @Override <line1> public String reorderEligibilityTestQusAns( <line2> Integer eligibilityId, int oldOrderNumber, int newOrderNumber, Integer studyId) { <line3> logger.entry(""StudyServiceImpl - reorderEligibilityTestQusAns - Starts""); <line4> String message = FdahpStudyDesignerConstants.SUCCESS; <line5> try { <line6> message = <line7> studyDAO.reorderEligibilityTestQusAns( <line8> eligibilityId, oldOrderNumber, newOrderNumber, studyId); <line9> } catch (Exception e) { <line10> } <line11> logger.exit(""StudyServiceImpl - reorderEligibilityTestQusAns - Ends""); <line12> return message; <line13> } <line14> } <line15> "	1	task3	
public class A { <line0> private boolean performTaskFixes( <line1> JobTask task, <line2> Set<String> expectedHostsWithTask, <line3> Set<String> expectedHostsMissingTask, <line4> Set<String> unexpectedHostsWithTask) { <line5> if (expectedHostsWithTask.isEmpty()) { <line6> if (unexpectedHostsWithTask.isEmpty()) { <line7> recreateTask(task); <line8> return true; <line9> } <line10> Iterator<String> unexpectedHostsIter = unexpectedHostsWithTask.iterator(); <line11> List<JobTaskReplica> newReplicas = new ArrayList<>(); <line12> task.setHostUUID(unexpectedHostsIter.next()); <line13> while (unexpectedHostsIter.hasNext()) { <line14> newReplicas.add(new JobTaskReplica(unexpectedHostsIter.next(), task.getJobUUID(), 0, 0)); <line15> } <line16> task.setReplicas(newReplicas); <line17> return true; <line18> } else { <line19> boolean changed = false; <line20> if (!expectedHostsMissingTask.isEmpty()) { <line21> swapTask(task, expectedHostsWithTask.iterator().next(), false, 0); <line22> copyTaskToReplicas(task); <line23> changed = true; <line24> } <line25> for (String unexpectedHost : unexpectedHostsWithTask) { <line26> deleteTask(task.getJobUUID(), unexpectedHost, task.getTaskID(), false); <line27> } <line28> return changed; <line29> } <line30> } <line31> } <line32> 	1	task3	
public class A { <line0> public void handleFailedResponse(int requestId, @Nullable Throwable cause) { <line1> synchronized (lock) { <line2> if (isShutDown) { <line3> return; <line4> } <line5> PendingStatsRequest<T, V> pendingRequest = pendingRequests.remove(requestId); <line6> if (pendingRequest != null) { <line7> pendingRequest.discard(cause); <line8> rememberRecentRequestId(requestId); <line9> } <line10> } <line11> } <line12> } <line13> 	1	task3	
"public class A { <line0> protected <K, V> boolean addNoWait(final LateralCacheNoWait<K, V> noWait) { <line1> @SuppressWarnings(""unchecked"") <line2> final LateralCacheNoWaitFacade<K, V> facade = <line3> (LateralCacheNoWaitFacade<K, V>) facades.get(noWait.getCacheName()); <line4> return addNoWait(noWait, facade); <line5> } <line6> } <line7> "	1	task3	
"public class A { <line0> @Test(groups = {""wso2.mb"", ""queue""}) <line1> public void allUnacknowledgeMessageListenerPerAckTestCase() <line2> throws AndesClientConfigurationException, XPathExpressionException, IOException, JMSException, <line3> AndesClientException, NamingException { <line4> long sendCount = 10; <line5> final List<String> receivedMessages = new ArrayList<>(); <line6> AndesJMSConsumerClientConfiguration consumerConfig = <line7> new AndesJMSConsumerClientConfiguration( <line8> getAMQPPort(), ExchangeType.QUEUE, ""allUnacknowledgePerAckQueue""); <line9> consumerConfig.setAcknowledgeMode(JMSAcknowledgeMode.PER_MESSAGE_ACKNOWLEDGE); <line10> consumerConfig.setAsync(false); <line11> AndesJMSPublisherClientConfiguration publisherConfig = <line12> new AndesJMSPublisherClientConfiguration( <line13> getAMQPPort(), ExchangeType.QUEUE, ""allUnacknowledgePerAckQueue""); <line14> publisherConfig.setNumberOfMessagesToSend(sendCount); <line15> AndesClient consumerClient = new AndesClient(consumerConfig, true); <line16> final AndesJMSConsumer andesJMSConsumer = consumerClient.getConsumers().get(0); <line17> MessageConsumer receiver = andesJMSConsumer.getReceiver(); <line18> receiver.setMessageListener( <line19> new MessageListener() { <line20> @Override <line21> public void onMessage(Message message) { <line22> try { <line23> TextMessage textMessage = (TextMessage) message; <line24> if (receivedMessages.contains(textMessage.getText())) { <line25> message.acknowledge(); <line26> } <line27> receivedMessages.add(textMessage.getText()); <line28> andesJMSConsumer.getReceivedMessageCount().incrementAndGet(); <line29> } catch (JMSException e) { <line30> throw new RuntimeException(""Exception occurred when receiving messages."", e); <line31> } <line32> } <line33> }); <line34> AndesClient publisherClient = new AndesClient(publisherConfig, true); <line35> MessageProducer sender = publisherClient.getPublishers().get(0).getSender(); <line36> for (int i = 0; i < sendCount; i++) { <line37> TextMessage textMessage = <line38> publisherClient <line39> .getPublishers() <line40> .get(0) <line41> .getSession() <line42> .createTextMessage(""#"" + Integer.toString(i)); <line43> sender.send(textMessage); <line44> } <line45> AndesClientUtils.waitForMessagesAndShutdown( <line46> consumerClient, AndesClientConstants.DEFAULT_RUN_TIME); <line47> for (int i = 0; i < sendCount * 2; i++) { <line48> if (i < sendCount) { <line49> Assert.assertEquals( <line50> receivedMessages.get(i), <line51> ""#"" + Integer.toString(i), <line52> ""Invalid messages received. "" + ""#"" + Integer.toString(i) + """" + "" expected.""); <line53> } else { <line54> Assert.assertEquals( <line55> receivedMessages.get(i), <line56> ""#"" + Integer.toString(i - 10), <line57> ""Invalid messages "" + ""received. #"" + Integer.toString(i - 10) + "" expected.""); <line58> } <line59> } <line60> Assert.assertEquals(receivedMessages.size(), sendCount * 2, ""Message receiving failed.""); <line61> } <line62> } <line63> "	1	task3	
"public class A { <line0> protected String getCamelEndpointId(WorkItem workItem) { <line1> String workItemCamelEndpointId = <line2> (String) workItem.getParameter(JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM); <line3> if (camelEndpointId != null && !camelEndpointId.isEmpty()) { <line4> if (workItemCamelEndpointId != null && !workItemCamelEndpointId.isEmpty()) { <line5> } else { <line6> workItemCamelEndpointId = camelEndpointId; <line7> } <line8> } <line9> if (workItemCamelEndpointId == null || workItemCamelEndpointId.isEmpty()) { <line10> throw new IllegalArgumentException( <line11> ""No Camel Endpoint ID specified. Please configure the '"" <line12> + JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM <line13> + ""' in either the constructor of this WorkItemHandler, or pass it via the "" <line14> + JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM <line15> + ""' WorkItem parameter.""); <line16> } <line17> return workItemCamelEndpointId; <line18> } <line19> } <line20> "	1	task3	
"public class A { <line0> @Override <line1> protected DataSource retrieve(String dsName) throws DBDatasourceServiceException { <line2> DataSource ds = null; <line3> requestedDatasourceName = dsName; <line4> try { <line5> IDatasourceMgmtService datasourceMgmtSvc = getDatasourceMgmtService(); <line6> IDatabaseConnection databaseConnection = datasourceMgmtSvc.getDatasourceByName(dsName); <line7> if (databaseConnection != null <line8> && !databaseConnection.getAccessType().equals(DatabaseAccessType.JNDI)) { <line9> ds = resolveDatabaseConnection(databaseConnection); <line10> } else { <line11> try { <line12> ds = getJndiDataSource(dsName); <line13> } catch (DBDatasourceServiceException e) { <line14> } <line15> } <line16> if (ds == null && databaseConnection != null) { <line17> ds = getJndiDataSource(databaseConnection.getDatabaseName()); <line18> } <line19> if (ds != null) { <line20> cacheManager.putInRegionCache(IDBDatasourceService.JDBC_DATASOURCE, dsName, ds); <line21> } <line22> } catch (DatasourceMgmtServiceException daoe) { <line23> try { <line24> return getJndiDataSource(dsName); <line25> } catch (DBDatasourceServiceException dse) { <line26> throw new DBDatasourceServiceException( <line27> Messages.getInstance() <line28> .getErrorString(""DatasourceService.ERROR_0003_UNABLE_TO_GET_JNDI_DATASOURCE""), <line29> dse); <line30> } <line31> } <line32> return ds; <line33> } <line34> } <line35> "	1	task3	
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> cleanup(); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> @Bean(destroyMethod = ""stop"", name = ""domainCoreOutboundOsgpCoreResponsesConnectionFactory"") <line1> public ConnectionFactory connectionFactory() { <line2> return this.jmsConfigurationFactory.getPooledConnectionFactory(); <line3> } <line4> } <line5> "	1	task3	
"public class A { <line0> private List<Component> getFilteredComponentList(PortletRequest request) throws IOException { <line1> List<Component> componentList; <line2> Map<String, Set<String>> filterMap = new HashMap<>(); <line3> for (Component._Fields filteredField : componentFilteredFields) { <line4> String parameter = request.getParameter(filteredField.toString()); <line5> if (!isNullOrEmpty(parameter) <line6> && !(filteredField.equals(Component._Fields.COMPONENT_TYPE) <line7> && parameter.equals(PortalConstants.NO_FILTER))) { <line8> Set<String> values = CommonUtils.splitToSet(parameter); <line9> if (filteredField.equals(Component._Fields.NAME)) { <line10> values = values.stream().map(v -> v + ""*"").collect(Collectors.toSet()); <line11> } <line12> filterMap.put(filteredField.getFieldName(), values); <line13> } <line14> request.setAttribute(filteredField.getFieldName(), nullToEmpty(parameter)); <line15> } <line16> try { <line17> final User user = UserCacheHolder.getUserFromRequest(request); <line18> int limit = <line19> CustomFieldHelper.loadAndStoreStickyViewSize( <line20> request, user, CUSTOM_FIELD_COMPONENTS_VIEW_SIZE); <line21> ComponentService.Iface componentClient = thriftClients.makeComponentClient(); <line22> request.setAttribute( <line23> PortalConstants.TOTAL_ROWS, componentClient.getTotalComponentsCount(user)); <line24> if (filterMap.isEmpty()) { <line25> componentList = componentClient.getRecentComponentsSummary(limit, user); <line26> } else { <line27> componentList = componentClient.refineSearch(null, filterMap); <line28> } <line29> } catch (TException e) { <line30> componentList = Collections.emptyList(); <line31> } <line32> return componentList; <line33> } <line34> } <line35> "	1	task3	
"public class A { <line0> public Document getServiceTemplateInstanceRawProperties(final Long id) throws NotFoundException { <line1> final ServiceTemplateInstance service = getServiceTemplateInstance(id, false); <line2> final Optional<ServiceTemplateInstanceProperty> firstProp = <line3> service.getProperties().stream().findFirst(); <line4> if (firstProp.isPresent()) { <line5> return convertPropertyToDocument(firstProp.get()); <line6> } <line7> final String msg = <line8> String.format(""No properties are found for the service template instance <%s>"", id); <line9> return null; <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> protected ConnectionFactory getConnectionFactory() { <line1> return connectionFactoryBuilder.buildConnectionFactory(); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @Override <line1> public void apply( <line2> @SuppressWarnings(""deprecation"") final org.apache.brooklyn.api.entity.EntityLocal entity) { <line3> final AttributeSensor<ReleaseableLatch> sensor = <line4> Sensors.newSensor(ReleaseableLatch.class, sensorName); <line5> ((EntityInternal) entity).getMutableEntityType().addSensor(sensor); <line6> final Task<ReleaseableLatch> resolveValueTask = <line7> DependentConfiguration.maxConcurrency(maxConcurrency); <line8> class SetValue implements Runnable { <line9> @Override <line10> public void run() { <line11> ReleaseableLatch releaseableLatch = resolveValueTask.getUnchecked(); <line12> entity.sensors().set(sensor, releaseableLatch); <line13> } <line14> } <line15> Task<ReleaseableLatch> setValueTask = <line16> Tasks.<ReleaseableLatch>builder() <line17> .displayName(""Setting "" + sensor + "" on "" + entity) <line18> .body(new SetValue()) <line19> .build(); <line20> Entities.submit( <line21> entity, <line22> Tasks.sequential( <line23> ""Resolving and setting "" + sensor + "" on "" + entity, resolveValueTask, setValueTask)); <line24> } <line25> } <line26> "	1	task3	
"public class A { <line0> @Override <line1> protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) <line2> throws AuthenticationException { <line3> if (token instanceof CertificateToken) { <line4> if (!((CertificateToken) token) <line5> .getUserName() <line6> .equals(info.getPrincipals().getPrimaryPrincipal())) { <line7> throw new IncorrectCredentialsException( <line8> ""certificate presented did not match the awaited username""); <line9> } <line10> return; <line11> } <line12> super.assertCredentialsMatch(token, info); <line13> } <line14> } <line15> "	1	task3	
"public class A { <line0> private static void initSpark() { <line1> staticFiles.location(""/static""); <line2> } <line3> } <line4> "	1	task3	
public class A { <line0> public static com.liferay.commerce.model.CommerceAddressSoap[] getShippingCommerceAddresses( <line1> long companyId, String className, long classPK) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.commerce.model.CommerceAddress> returnValue = <line4> CommerceAddressServiceUtil.getShippingCommerceAddresses(companyId, className, classPK); <line5> return com.liferay.commerce.model.CommerceAddressSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> void queueMutations(final MutationSet mutationsToSend) { <line1> if (mutationsToSend == null) return; <line2> binningThreadPool.execute( <line3> Trace.wrap( <line4> () -> { <line5> if (mutationsToSend != null) { <line6> try { <line7> addMutations(mutationsToSend); <line8> } catch (Exception e) { <line9> updateUnknownErrors(""Error processing mutation set"", e); <line10> } <line11> } <line12> })); <line13> } <line14> } <line15> "	1	task3	
"public class A { <line0> @Override <line1> public void doLaunch(MessageInput input) throws MisfireException { <line2> int heartbeatTimeout = ConnectionFactory.DEFAULT_HEARTBEAT; <line3> if (configuration.intIsSet(CK_HEARTBEAT_TIMEOUT)) { <line4> heartbeatTimeout = configuration.getInt(CK_HEARTBEAT_TIMEOUT); <line5> if (heartbeatTimeout < 0) { <line6> heartbeatTimeout = ConnectionFactory.DEFAULT_HEARTBEAT; <line7> } <line8> } <line9> consumer = <line10> new AmqpConsumer( <line11> configuration.getString(CK_HOSTNAME), <line12> configuration.getInt(CK_PORT), <line13> configuration.getString(CK_VHOST), <line14> configuration.getString(CK_USERNAME), <line15> configuration.getString(CK_PASSWORD), <line16> configuration.getInt(CK_PREFETCH), <line17> configuration.getString(CK_QUEUE), <line18> configuration.getString(CK_EXCHANGE), <line19> configuration.getBoolean(CK_EXCHANGE_BIND), <line20> configuration.getString(CK_ROUTING_KEY), <line21> configuration.getInt(CK_PARALLEL_QUEUES), <line22> configuration.getBoolean(CK_TLS), <line23> configuration.getBoolean(CK_REQUEUE_INVALID_MESSAGES), <line24> heartbeatTimeout, <line25> input, <line26> scheduler, <line27> this); <line28> eventBus.register(this); <line29> try { <line30> consumer.run(); <line31> } catch (IOException e) { <line32> eventBus.unregister(this); <line33> throw new MisfireException(""Could not launch AMQP consumer."", e); <line34> } <line35> } <line36> } <line37> "	1	task3	
"public class A { <line0> public String formatRevisionDisplay(final Revision revision) { <line1> final String defaultFormattedRevision = <line2> revision.getAuthor() + "" @ "" + revision.getDate() + "" ("" + revision.getRevision() + "")""; <line3> final ServletContext servletContext = pageContext.getServletContext(); <line4> final WebApplicationContext context = <line5> WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); <line6> try { <line7> final Map<String, DefinitionRevisionDisplayFormatter> formatterBeans = <line8> BeanFactoryUtils.beansOfTypeIncludingAncestors( <line9> context, DefinitionRevisionDisplayFormatter.class); <line10> if (formatterBeans.isEmpty()) { <line11> return StringEscapeUtils.escapeHtml4(defaultFormattedRevision); <line12> } else if (formatterBeans.size() == 1) { <line13> final DefinitionRevisionDisplayFormatter formatter = <line14> formatterBeans.values().iterator().next(); <line15> return formatter.formatRevision(revision); <line16> } else { <line17> throw new IllegalArgumentException( <line18> ""Multiple beans of type "" <line19> + DefinitionRevisionDisplayFormatter.class.getSimpleName() <line20> + "" found, expected 0 or 1.""); <line21> } <line22> } catch (final Exception e) { <line23> return defaultFormattedRevision; <line24> } <line25> } <line26> } <line27> "	1	task3	
"public class A { <line0> public void initialise() throws InitialisationException { <line1> if (salt == null) { <line2> salt = <line3> new byte[] { <line4> (byte) 0xc7, <line5> (byte) 0x73, <line6> (byte) 0x21, <line7> (byte) 0x8c, <line8> (byte) 0x7e, <line9> (byte) 0xc8, <line10> (byte) 0xee, <line11> (byte) 0x99 <line12> }; <line13> } <line14> if (password == null) { <line15> throw new InitialisationException(CoreMessages.objectIsNull(""Password""), this); <line16> } <line17> super.initialise(); <line18> } <line19> } <line20> "	1	task3	
public class A { <line0> @Override <line1> public int hashCode() { <line2> int result = 1; <line3> try { <line4> final int prime = 31; <line5> result = prime * result + ((cnaTreeElement == null) ? 0 : cnaTreeElement.hashCode()); <line6> result = prime * result + ((role == null) ? 0 : role.hashCode()); <line7> } catch (Exception t) { <line8> } <line9> return result; <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> @Override <line1> public void updateService(ApiService service) throws ApsSystemException { <line2> try { <line3> if (null == service) { <line4> throw new ApsSystemException(""Null api service to update""); <line5> } <line6> ApiService masterService = <line7> this.getServiceCacheWrapper().getMasterServices().get(service.getKey()); <line8> if (null == masterService) { <line9> throw new ApsSystemException(""Api service '"" + service.getKey() + ""' does not exist""); <line10> } <line11> masterService.setActive(service.isActive()); <line12> masterService.setHidden(service.isHidden()); <line13> this.getApiCatalogDAO().updateService(masterService); <line14> this.getServiceCacheWrapper().updateService(service); <line15> } catch (Throwable t) { <line16> throw new ApsSystemException(""Error updating service '"" + service.getKey() + ""'"", t); <line17> } <line18> } <line19> } <line20> "	1	task3	
public class A { <line0> private void reconnect(MockHost host) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> this.agentHost = host; <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> private boolean matchUserGroupRole(RangerAccessRequest request) { <line1> boolean ret = matchAnyUser; <line2> if (!ret) { <line3> if (auditPolicyItem.getUsers() != null && request.getUser() != null) { <line4> ret = auditPolicyItem.getUsers().contains(request.getUser()); <line5> if (!ret && hasResourceOwner) { <line6> String owner = <line7> request.getResource() != null ? request.getResource().getOwnerUser() : null; <line8> ret = request.getUser().equals(owner); <line9> } <line10> } <line11> if (!ret && auditPolicyItem.getGroups() != null && request.getUserGroups() != null) { <line12> ret = CollectionUtils.containsAny(auditPolicyItem.getGroups(), request.getUserGroups()); <line13> } <line14> if (!ret && auditPolicyItem.getRoles() != null) { <line15> ret = <line16> CollectionUtils.containsAny( <line17> auditPolicyItem.getRoles(), <line18> RangerAccessRequestUtil.getCurrentUserRolesFromContext(request.getContext())); <line19> } <line20> } <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> return ret; <line24> } <line25> } <line26> 	1	task3	
public class A { <line0> public void setValue(String value) { <line1> if (componentDao != null) { <line2> Component component = componentDao.getComponent(); <line3> component.setProperty(name, value); <line4> componentDao.saveOrUpdate(component); <line5> } else { <line6> } <line7> } <line8> } <line9> 	1	task3	
"public class A { <line0> @Override <line1> public CommerceAccountGroupRel findByC_C_C( <line2> long classNameId, long classPK, long commerceAccountGroupId) <line3> throws NoSuchAccountGroupRelException { <line4> CommerceAccountGroupRel commerceAccountGroupRel = <line5> fetchByC_C_C(classNameId, classPK, commerceAccountGroupId); <line6> if (commerceAccountGroupRel == null) { <line7> StringBundler sb = new StringBundler(8); <line8> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line9> sb.append(""classNameId=""); <line10> sb.append(classNameId); <line11> sb.append("", classPK=""); <line12> sb.append(classPK); <line13> sb.append("", commerceAccountGroupId=""); <line14> sb.append(commerceAccountGroupId); <line15> sb.append(""}""); <line16> if (log.isDebugEnabled()) { <line17> } <line18> throw new NoSuchAccountGroupRelException(sb.toString()); <line19> } <line20> return commerceAccountGroupRel; <line21> } <line22> } <line23> "	1	task3	
public class A { <line0> private CounterMetric _createAndRegisterCounterMXBean(Metric m, Counter c) { <line1> CounterMetric b = new CounterMetric(m, c); <line2> _registerMBean(b); <line3> return b; <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> @Override <line1> protected RowMap evict() throws IOException { <line2> RowMap r = super.evict(); <line3> this.memorySize -= r.getApproximateSize(); <line4> this.outputStreamCacheSize += r.getApproximateSize(); <line5> if (this.outputStreamCacheSize > FlushOutputStreamBytes) { <line6> resetOutputStreamCaches(); <line7> this.outputStreamCacheSize = 0; <line8> } <line9> return r; <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> public void trace(final Marker marker, final String message, final Object object) { <line1> } <line2> } <line3> 	1	task3	
public class A { <line0> public void setOffStatus() { <line1> if (mgrOK()) { <line2> try { <line3> p.setPower(PowerManager.OFF); <line4> } catch (JmriException e) { <line5> try { <line6> sendErrorStatus(); <line7> } catch (IOException ie) { <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	1	task3	
"public class A { <line0> @Override <line1> public List<String> getCategoryUtilizers(String categoryCode) { <line2> List<String> dataids = null; <line3> try { <line4> dataids = this.getUtilizers(categoryCode, LOAD_REFERENCED_DATAOBJECTS_FOR_CATEGORY); <line5> } catch (Throwable t) { <line6> throw new RuntimeException( <line7> ""Error loading referenced datatypes for category "" + categoryCode, t); <line8> } <line9> return dataids; <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> private void generateInventoryPythonClass(StringBuilder sb, List<String> basePkgs) { <line1> List<String> inventoryPython = new ArrayList<>(); <line2> ClassPathScanningCandidateComponentProvider scanner = <line3> new ClassPathScanningCandidateComponentProvider(false); <line4> scanner.addIncludeFilter(new AnnotationTypeFilter(PythonClassInventory.class)); <line5> scanner.addExcludeFilter(new AnnotationTypeFilter(Component.class)); <line6> for (String pkg : basePkgs) { <line7> for (BeanDefinition bd : <line8> scanner.findCandidateComponents(pkg).stream() <line9> .sorted( <line10> (bd1, bd2) -> { <line11> return bd1.getBeanClassName().compareTo(bd2.getBeanClassName()); <line12> }) <line13> .collect(Collectors.toList())) { <line14> try { <line15> Class<?> clazz = Class.forName(bd.getBeanClassName()); <line16> if (isPythonClassGenerated(clazz)) { <line17> continue; <line18> } <line19> inventoryPython.add(classToInventoryPythonClass(clazz)); <line20> } catch (Exception e) { <line21> } <line22> } <line23> } <line24> for (String invstr : inventoryPython) { <line25> sb.append(invstr); <line26> } <line27> } <line28> } <line29> 	1	task3	
"public class A { <line0> @Override <line1> public Representation get() { <line2> StringRepresentation presentation = null; <line3> try { <line4> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line5> String instanceName = (String) getRequest().getAttributes().get(""instanceName""); <line6> presentation = getInstanceErrorsRepresentation(clusterName, instanceName); <line7> } catch (Exception e) { <line8> String error = ClusterRepresentationUtil.getErrorAsJsonStringFromException(e); <line9> presentation = new StringRepresentation(error, MediaType.APPLICATION_JSON); <line10> } <line11> return presentation; <line12> } <line13> } <line14> "	1	task3	
"public class A { <line0> public static void addPasswordPolicyOrganizations( <line1> HttpPrincipal httpPrincipal, long passwordPolicyId, long[] organizationIds) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> OrganizationServiceUtil.class, <line7> ""addPasswordPolicyOrganizations"", <line8> _addPasswordPolicyOrganizationsParameterTypes3); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, passwordPolicyId, organizationIds); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	1	task3	
"public class A { <line0> @Override <line1> public AnomalyDetectionFunction getFunction( <line2> StarTreeConfig starTreeConfig, <line3> AnomalyDatabaseConfig dbconfig, <line4> FunctionTableRow functionTableRow) <line5> throws IllegalFunctionException, ClassCastException { <line6> RuleBasedFunctionTableRow ruleBasedFunctionTableRow = <line7> (RuleBasedFunctionTableRow) functionTableRow; <line8> TimeGranularity aggregateGranularity = <line9> new TimeGranularity( <line10> ruleBasedFunctionTableRow.getAggregateSize(), <line11> ruleBasedFunctionTableRow.getAggregateUnit()); <line12> if (aggregateGranularity.getSize() <= 0) { <line13> throw new IllegalFunctionException(""aggregate size must be positive""); <line14> } <line15> TimeGranularity baselineGranularity = <line16> new TimeGranularity( <line17> ruleBasedFunctionTableRow.getBaselineSize(), <line18> ruleBasedFunctionTableRow.getBaselineUnit()); <line19> if (baselineGranularity.getSize() <= 0) { <line20> throw new IllegalFunctionException(""baseline size must be positive""); <line21> } <line22> DimensionKeyMatchTable<Double> deltaTable = null; <line23> if (ruleBasedFunctionTableRow.getDeltaTableName() != null <line24> && ruleBasedFunctionTableRow.getDeltaTableName().length() > 0) { <line25> deltaTable = <line26> DeltaTable.load(dbconfig, starTreeConfig, ruleBasedFunctionTableRow.getDeltaTableName()); <line27> } <line28> AnomalyDetectionFunction func; <line29> switch (RuleTypes.valueOf(ruleBasedFunctionTableRow.getFunctionName().toUpperCase())) { <line30> case PERCENTCHANGE: <line31> { <line32> func = <line33> new AnomalyDetectionFunctionPercentChange( <line34> baselineGranularity, <line35> aggregateGranularity, <line36> ruleBasedFunctionTableRow.getMetricName(), <line37> ruleBasedFunctionTableRow.getDelta()) <line38> .setDeltaTable(deltaTable); <line39> break; <line40> } <line41> case ABSOLUTECHANGE: <line42> { <line43> func = <line44> new AnomalyDetectionFunctionAbsoluteChange( <line45> baselineGranularity, <line46> aggregateGranularity, <line47> ruleBasedFunctionTableRow.getMetricName(), <line48> ruleBasedFunctionTableRow.getDelta()) <line49> .setDeltaTable(deltaTable); <line50> break; <line51> } <line52> default: <line53> { <line54> throw new IllegalFunctionException( <line55> ""no rule of type "" + ruleBasedFunctionTableRow.getFunctionName()); <line56> } <line57> } <line58> int consecutiveBuckets = ruleBasedFunctionTableRow.getConsecutiveBuckets(); <line59> if (consecutiveBuckets > 1) { <line60> func = new AnomalyDetectionFunctionConsecutive(func, consecutiveBuckets); <line61> } <line62> String cronDefinition = ruleBasedFunctionTableRow.getCronDefinition(); <line63> if (cronDefinition != null && cronDefinition.length() > 0) { <line64> func = new AnomalyDetectionFunctionCronDefinition(func, cronDefinition); <line65> } <line66> func.init(starTreeConfig, new FunctionProperties()); <line67> return func; <line68> } <line69> } <line70> "	1	task3	
"public class A { <line0> private Path sendSingleDocument(ObjectOutputStream out, EDoc eDoc, Integer demographicId) <line1> throws IOException, ParseException { <line2> Path documentPath = <line3> Paths.get( <line4> OscarProperties.getInstance().getProperty(""DOCUMENT_DIR"") <line5> + File.separator <line6> + eDoc.getFileName()); <line7> if (!Files.exists(documentPath)) { <line8> return null; <line9> } <line10> CachedDemographicDocument cachedDemographicDocument = new CachedDemographicDocument(); <line11> FacilityIdIntegerCompositePk facilityIdIntegerCompositePk = new FacilityIdIntegerCompositePk(); <line12> facilityIdIntegerCompositePk.setCaisiItemId(Integer.parseInt(eDoc.getDocId())); <line13> cachedDemographicDocument.setFacilityIntegerPk(facilityIdIntegerCompositePk); <line14> if (eDoc.getAppointmentNo() != null) { <line15> cachedDemographicDocument.setAppointmentNo(eDoc.getAppointmentNo()); <line16> } <line17> cachedDemographicDocument.setCaisiDemographicId(demographicId); <line18> cachedDemographicDocument.setContentType(eDoc.getContentType()); <line19> cachedDemographicDocument.setDocCreator(eDoc.getCreatorId()); <line20> cachedDemographicDocument.setDocFilename(eDoc.getFileName()); <line21> cachedDemographicDocument.setDocType(eDoc.getType()); <line22> cachedDemographicDocument.setDocXml(eDoc.getHtml()); <line23> cachedDemographicDocument.setNumberOfPages(eDoc.getNumberOfPages()); <line24> cachedDemographicDocument.setObservationDate( <line25> org.oscarehr.util.DateUtils.parseIsoDateAsCalendar(eDoc.getObservationDate()).getTime()); <line26> cachedDemographicDocument.setProgramId(eDoc.getProgramId()); <line27> cachedDemographicDocument.setPublic1(Integer.parseInt(eDoc.getDocPublic())); <line28> cachedDemographicDocument.setResponsible(eDoc.getResponsibleId()); <line29> cachedDemographicDocument.setReviewDateTime(eDoc.getReviewDateTimeDate()); <line30> cachedDemographicDocument.setReviewer(eDoc.getReviewerId()); <line31> cachedDemographicDocument.setSource(eDoc.getSource()); <line32> cachedDemographicDocument.setStatus("""" + eDoc.getStatus()); <line33> cachedDemographicDocument.setUpdateDateTime(eDoc.getDateTimeStampAsDate()); <line34> cachedDemographicDocument.setDescription(eDoc.getDescription()); <line35> out.writeUnshared(cachedDemographicDocument); <line36> return documentPath; <line37> } <line38> } <line39> "	1	task3	
"public class A { <line0> public static java.util.List<com.liferay.commerce.model.CommerceAddress> <line1> getBillingCommerceAddresses( <line2> HttpPrincipal httpPrincipal, <line3> long companyId, <line4> String className, <line5> long classPK, <line6> String keywords, <line7> int start, <line8> int end, <line9> com.liferay.portal.kernel.search.Sort sort) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> CommerceAddressServiceUtil.class, <line15> ""getBillingCommerceAddresses"", <line16> _getBillingCommerceAddressesParameterTypes7); <line17> MethodHandler methodHandler = <line18> new MethodHandler(methodKey, companyId, className, classPK, keywords, start, end, sort); <line19> Object returnObj = null; <line20> try { <line21> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line22> } catch (Exception exception) { <line23> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line24> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line25> } <line26> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line27> } <line28> return (java.util.List<com.liferay.commerce.model.CommerceAddress>) returnObj; <line29> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line30> throw systemException; <line31> } <line32> } <line33> } <line34> "	1	task3	
"public class A { <line0> public void outputNPMResource(String npmResourcePath) { <line1> try (NPMResolverRef npmResolverRef = new NPMResolverRef(_tagAccessor)) { <line2> NPMResolver npmResolver = npmResolverRef.getNPMResolver(); <line3> String resourcePath = npmResolver.resolveModuleName(npmResourcePath); <line4> URL url = _bundle.getEntry(""META-INF/resources/node_modules/"" + resourcePath); <line5> outputResource(Position.BOTTOM, StringUtil.read(url.openStream())); <line6> } catch (Exception exception) { <line7> } <line8> } <line9> } <line10> "	1	task3	
public class A { <line0> private List<File> collectMappings(File descriptorsDirectory) { <line1> final List<File> mappingDescriptors = new ArrayList<>(); <line2> try { <line3> Files.walkFileTree( <line4> Paths.get(descriptorsDirectory.toURI()), <line5> new SimpleFileVisitor<Path>() { <line6> @Override <line7> public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) <line8> throws IOException { <line9> File file = path.toFile(); <line10> if (httpServerStubAccepts(file) && isStubPerConsumerPathMatching(file)) { <line11> mappingDescriptors.add(file); <line12> } <line13> return super.visitFile(path, attrs); <line14> } <line15> }); <line16> } catch (IOException e) { <line17> } <line18> return mappingDescriptors; <line19> } <line20> } <line21> 	1	task3	
"public class A { <line0> private ListenableFuture<Void> stopTask(final String id, final boolean publish) { <line1> return Futures.transform( <line2> taskClient.stopAsync(id, publish), <line3> new Function<Boolean, Void>() { <line4> @Nullable <line5> @Override <line6> public Void apply(@Nullable Boolean result) { <line7> if (result == null || !result) { <line8> killTask(id, ""Task [%s] failed to stop in a timely manner, killing task"", id); <line9> } <line10> return null; <line11> } <line12> }); <line13> } <line14> } <line15> "	1	task3	
public class A { <line0> private void parseCertificatesListLength(CertificateMessage msg) { <line1> msg.setCertificatesListLength(parseIntField(HandshakeByteLength.CERTIFICATES_LENGTH)); <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> public void init(EmbeddedCacheManager cacheManager) { <line1> this.cacheManager = cacheManager; <line2> cacheManager.addListener(this); <line3> Cache<Address, ClusterNode> nodes = <line4> cacheManager.<Address, ClusterNode>getCache(CLUSTER_NODES_KEY); <line5> nodes.addListener(this); <line6> nodes.put(cacheManager.getAddress(), getThisNode()); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> private OrchestratorStore saveWithPriorityCheck(final OrchestratorStore orchestratorStore) { <line1> final System consumerSystem = orchestratorStore.getConsumerSystem(); <line2> final ServiceDefinition serviceDefinition = orchestratorStore.getServiceDefinition(); <line3> final ServiceInterface serviceInterface = orchestratorStore.getServiceInterface(); <line4> final int priority = orchestratorStore.getPriority(); <line5> final List<OrchestratorStore> orchestratorStoreList = <line6> orchestratorStoreRepository.findAllByConsumerSystemAndServiceDefinitionAndServiceInterface( <line7> consumerSystem, serviceDefinition, serviceInterface); <line8> if (orchestratorStoreList.isEmpty()) { <line9> orchestratorStore.setPriority(CoreCommonConstants.TOP_PRIORITY); <line10> return orchestratorStoreRepository.saveAndFlush(orchestratorStore); <line11> } else { <line12> final Map<Long, Integer> priorityMap = getPriorityMap(orchestratorStoreList); <line13> if (priorityMap.containsValue(priority)) { <line14> orchestratorStore.setPriority(priority); <line15> return insertOrchestratorStoreWithPriority( <line16> orchestratorStoreList, orchestratorStore, priority); <line17> } else { <line18> orchestratorStore.setPriority(orchestratorStoreList.size() + 1); <line19> return orchestratorStoreRepository.saveAndFlush(orchestratorStore); <line20> } <line21> } <line22> } <line23> } <line24> 	1	task3	
"public class A { <line0> private RestResponse<FacetField> stats() throws ClientException { <line1> SampleCommandOptions.StatsCommandOptions commandOptions = <line2> samplesCommandOptions.statsCommandOptions; <line3> ObjectMap params = new ObjectMap(); <line4> params.putIfNotEmpty(SampleDBAdaptor.QueryParams.STUDY.key(), commandOptions.study); <line5> params.putIfNotEmpty(""creationYear"", commandOptions.creationYear); <line6> params.putIfNotEmpty(""creationMonth"", commandOptions.creationMonth); <line7> params.putIfNotEmpty(""creationDay"", commandOptions.creationDay); <line8> params.putIfNotEmpty(""creationDayOfWeek"", commandOptions.creationDayOfWeek); <line9> params.putIfNotEmpty(""status"", commandOptions.status); <line10> params.putIfNotEmpty(""source"", commandOptions.source); <line11> params.putIfNotEmpty(""type"", commandOptions.type); <line12> params.putIfNotEmpty(""phenotypes"", commandOptions.phenotypes); <line13> params.putIfNotEmpty(""release"", commandOptions.release); <line14> params.putIfNotEmpty(""version"", commandOptions.version); <line15> params.putIfNotNull(""somatic"", commandOptions.somatic); <line16> params.putIfNotEmpty(Constants.ANNOTATION, commandOptions.annotation); <line17> params.put(""default"", commandOptions.defaultStats); <line18> params.putIfNotNull(""field"", commandOptions.field); <line19> return openCGAClient.getSampleClient().aggregationStats(params); <line20> } <line21> } <line22> "	1	task3	
"public class A { <line0> @Secured(ServicesData.ROLE_IMPORT_AGENCIES) <line1> @PostMapping(CommonConstants.PATH_IMPORT) <line2> public JsonNode importAgencies( <line3> @RequestParam(""fileName"") String fileName, @RequestParam(""file"") MultipartFile file) { <line4> ParameterChecker.checkParameter(""The fileName is mandatory parameter : "", fileName); <line5> SafeFileChecker.checkSafeFilePath(file.getOriginalFilename()); <line6> return agencyExternalService.importAgencies(fileName, file); <line7> } <line8> } <line9> "	1	task3	
"public class A { <line0> private String createMemberInSalesForce(String accessToken, Member member) { <line1> WebResource resource = createObjectsResource(""/Account/""); <line2> JSONObject memberJson = salesForceAdapter.createSaleForceRecordFromMember(member); <line3> ClientResponse response = doPostRequest(resource, memberJson, accessToken); <line4> checkAuthorization(response); <line5> JSONObject result = checkResponse(response, 201, ""Error creating member in SalesForce""); <line6> return result.optString(""id""); <line7> } <line8> } <line9> "	1	task3	
public class A { <line0> private void deleteWithRetriesSilent(final String s3Bucket, final String s3Path) { <line1> try { <line2> deleteWithRetries(s3Bucket, s3Path); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> public void returnLease(JdbcCompiledQueryLease lease) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> try { <line4> _pool.returnObject(lease); <line5> } catch (Exception e) { <line6> throw handleError(e, ""return lease""); <line7> } <line8> } <line9> } <line10> "	1	task3	
public class A { <line0> public void setAllowMultipleDns(final boolean b) { <line1> allowMultipleDns = b; <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> public void onConnectionClose(ChannelHandlerContext ctx) { <line1> } <line2> } <line3> 	1	task3	
public class A { <line0> private void setOptions(Map options) throws NoSuchFieldException, IllegalAccessException { <line1> this.options = options; <line2> for (Iterator iterator = options.keySet().iterator(); iterator.hasNext(); ) { <line3> String attribute = (String) iterator.next(); <line4> Object value = options.get(attribute); <line5> try { <line6> Field field = getClass().getField(attribute); <line7> field.set(this, value); <line8> } catch (Throwable e) { <line9> } <line10> } <line11> } <line12> } <line13> 	1	task3	
"public class A { <line0> public String getFunctionDesc(String function_code) { <line1> try { <line2> String queryString = <line3> ""select description from Secobjectname obj where obj.objectname='"" + function_code + ""'""; <line4> List lst = getHibernateTemplate().find(queryString); <line5> if (lst.size() > 0 && lst.get(0) != null) return lst.get(0).toString(); <line6> else return """"; <line7> } catch (RuntimeException re) { <line8> throw re; <line9> } <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> public boolean detachShader(GL gl, int shaderId) { <line1> boolean result = false; <line2> if (isShaderIdValid(gl, shaderId)) { <line3> gl.glDetachShader(oglProgramId, shaderId); <line4> result = true; <line5> } else { <line6> } <line7> return result; <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected List<String> assertReceivedObjectMessageWithListBody(Message message) <line2> throws JMSException { <line3> assertNotNull(""Should have received a message!"", message); <line4> assertEquals(""foo header"", ""abc"", message.getStringProperty(""foo"")); <line5> assertTrue(""Should be an object message but was: "" + message, message instanceof ObjectMessage); <line6> ObjectMessage objectMessage = (ObjectMessage) message; <line7> List<String> body = (List<String>) objectMessage.getObject(); <line8> assertEquals(""Size of list should be 1"", 1, body.size()); <line9> assertEquals(""element 0 of list"", ""First"", body.get(0)); <line10> return body; <line11> } <line12> } <line13> "	1	task3	
public class A { <line0> public void push(Object obj) { <line1> if (logger.isTraceEnabled()) { <line2> } <line3> this.stack.push(obj); <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> private String createURL( <line1> String apiKey, String text, String locale, String voice, String audioFormat) { <line2> String encodedMsg; <line3> try { <line4> encodedMsg = URLEncoder.encode(text, ""UTF-8""); <line5> } catch (UnsupportedEncodingException ex) { <line6> encodedMsg = text; <line7> } <line8> String url = ""http://api.voicerss.org/?key="" + apiKey + ""&hl="" + locale + ""&c="" + audioFormat; <line9> if (!DEFAULT_VOICE.equals(voice)) { <line10> url += ""&v="" + voice; <line11> } <line12> url += ""&f=44khz_16bit_mono&src="" + encodedMsg; <line13> return url; <line14> } <line15> } <line16> "	1	task3	
public class A { <line0> @Override <line1> public void shutdown() { <line2> cleanScheduler.shutdown(); <line3> try { <line4> cleanScheduler.awaitTermination(10, TimeUnit.SECONDS); <line5> } catch (InterruptedException e) { <line6> } <line7> } <line8> } <line9> 	1	task3	
"public class A { <line0> private <X> TypedValue<X> convertToType( <line1> final XQueryContext xqueryContext, <line2> final String argumentName, <line3> final TypedValue typedValue, <line4> final org.exquery.xquery.Type destinationType, <line5> final Class<X> underlyingDestinationClass) <line6> throws RestXqServiceException { <line7> final Item convertedValue; <line8> try { <line9> final int existDestinationType = TypeAdapter.toExistType(destinationType); <line10> final Item value; <line11> if (typedValue instanceof org.exquery.xdm.type.StringTypedValue) { <line12> value = new StringValue(((org.exquery.xdm.type.StringTypedValue) typedValue).getValue()); <line13> } else if (typedValue instanceof org.exquery.xdm.type.Base64BinaryTypedValue) { <line14> value = <line15> BinaryValueFromInputStream.getInstance( <line16> xqueryContext, <line17> new Base64BinaryValueType(), <line18> ((org.exquery.xdm.type.Base64BinaryTypedValue) typedValue).getValue()); <line19> } else { <line20> value = (Item) typedValue.getValue(); <line21> } <line22> if (existDestinationType == value.getType()) { <line23> convertedValue = value; <line24> } else if (value instanceof AtomicValue) { <line25> convertedValue = value.convertTo(existDestinationType); <line26> } else { <line27> convertedValue = value; <line28> } <line29> } catch (final XPathException xpe) { <line30> throw new RestXqServiceException( <line31> ""TODO need to implement error code for problem with parameter conversion!: "" <line32> + xpe.getMessage(), <line33> xpe); <line34> } <line35> return new TypedValue<X>() { <line36> @Override <line37> public org.exquery.xquery.Type getType() { <line38> return TypeAdapter.toExQueryType(convertedValue.getType()); <line39> } <line40>  <line41> @Override <line42> public X getValue() { <line43> return (X) convertedValue; <line44> } <line45> }; <line46> } <line47> } <line48> "	1	task3	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> action.perform(); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> private void storeToken(TrackingToken token) { <line1> tokenStore.storeToken(token, name, segment.getSegmentId()); <line2> lastStoredToken = token; <line3> lastClaimExtension = clock.instant().toEpochMilli(); <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> @Deprecated <line1> public static com.liferay.portal.kernel.model.CountrySoap getCountryByA2(String a2) <line2> throws RemoteException { <line3> try { <line4> com.liferay.portal.kernel.model.Country returnValue = CountryServiceUtil.getCountryByA2(a2); <line5> return com.liferay.portal.kernel.model.CountrySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	1	task3	
"public class A { <line0> @DeleteMapping(""/delete.json"") <line1> @AuthAction(PrivilegeType.WRITE_RULE) <line2> public Result<Long> apiDeleteFlowRule(Long id) { <line3> if (id == null) { <line4> return Result.ofFail(-1, ""id can't be null""); <line5> } <line6> FlowRuleEntity oldEntity = repository.findById(id); <line7> if (oldEntity == null) { <line8> return Result.ofSuccess(null); <line9> } <line10> try { <line11> repository.delete(id); <line12> } catch (Exception e) { <line13> return Result.ofFail(-1, e.getMessage()); <line14> } <line15> try { <line16> publishRules(oldEntity.getApp(), oldEntity.getIp(), oldEntity.getPort()) <line17> .get(5000, TimeUnit.MILLISECONDS); <line18> return Result.ofSuccess(id); <line19> } catch (Throwable t) { <line20> Throwable e = t instanceof ExecutionException ? t.getCause() : t; <line21> return Result.ofFail(-1, e.getMessage()); <line22> } <line23> } <line24> } <line25> "	1	task3	
public class A { <line0> private void stop() throws Exception { <line1> jettyServer.stop(); <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> public double[] readTemperatureByUuid() { <line1> double[] temperatures = new double[2]; <line2> try { <line3> temperatures = <line4> calculateTemperature( <line5> this.bluetoothGatt.readCharacteristicValueByUuid( <line6> TiSensorTagGatt.UUID_TEMP_SENSOR_VALUE)); <line7> } catch (KuraException e) { <line8> } <line9> return temperatures; <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> private ReferenceTime readReferenceTime(SpaceSystem spaceSystem) throws XMLStreamException { <line1> checkStartElementPreconditions(); <line2> ReferenceTime referenceTime = null; <line3> while (true) { <line4> xmlEvent = xmlEventReader.nextEvent(); <line5> if (isStartElementWithName(XTCE_OFFSET_FROM)) { <line6> referenceTime = new ReferenceTime(readParameterInstanceRef(spaceSystem, null)); <line7> } else if (isStartElementWithName(XTCE_EPOCH)) { <line8> referenceTime = new ReferenceTime(readEpoch()); <line9> } else if (isEndElementWithName(XTCE_REFERENCE_TIME)) { <line10> return referenceTime; <line11> } else { <line12> logUnknown(); <line13> } <line14> } <line15> } <line16> } <line17> 	1	task3	
"public class A { <line0> @Override <line1> public Iterator<? extends KBHandle> getRoots() { <line2> try { <line3> return kbService <line4> .listRootConcepts(kbModel.getObject(), preferences.getObject().showAllConcepts) <line5> .iterator(); <line6> } catch (QueryEvaluationException e) { <line7> error(getString(""listRootConceptsErrorMsg"") + "": "" + e.getLocalizedMessage()); <line8> return Collections.emptyIterator(); <line9> } <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> public void dropDatabase() { <line1> mongoDatabase().drop(); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @Test <line1> void changeTemplate() throws Exception { <line2> final String name = ""test-ui-config-2""; <line3> assertTrue(graphql.addTemplate(emptySetting(name).type(TemplateType.DASHBOARD)).isStatus()); <line4> TimeUnit.SECONDS.sleep(2L); <line5> TemplateChangeStatus templateChangeStatus = <line6> graphql.changeTemplate(emptySetting(name).type(TemplateType.TOPOLOGY_SERVICE)); <line7> assertTrue(templateChangeStatus.isStatus()); <line8> TimeUnit.SECONDS.sleep(2L); <line9> verifyTemplates(""expected/storage/dashboardConfiguration-change.yml""); <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> private boolean ensureNotNull(Class<?> c) { <line1> UserTask userTask = c.getAnnotation(UserTask.class); <line2> boolean isNull = userTask == null; <line3> if (isNull) { <line4> } <line5> return !isNull; <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> @Test <line1> public void testFileToCxfMessageDataFormat() throws Exception { <line2> MockEndpoint mock = getMockEndpoint(""mock:result""); <line3> mock.expectedMessageCount(1); <line4> template.sendBodyAndHeader( <line5> ""file:target/filetocxf"", createBody(), Exchange.FILE_NAME, ""payload.xml""); <line6> assertMockEndpointsSatisfied(); <line7> String out = mock.getReceivedExchanges().get(0).getIn().getBody(String.class); <line8> assertNotNull(out); <line9> assertTrue(out.contains(""echo Camel""), ""Should invoke the echo operation""); <line10> } <line11> } <line12> "	1	task3	
"public class A { <line0> @Override <line1> public void notify( <line2> XWikiNotificationRule rule, XWikiDocument doc, String action, XWikiContext context) { <line3> try { <line4> String notifpages = context.getWiki().getXWikiPreference(""notification_pages"", context); <line5> if ((notifpages != null) && (!notifpages.equals(""""))) { <line6> String[] notifpages2 = StringUtils.split(notifpages, "" ,""); <line7> for (int i = 0; i < notifpages2.length; i++) { <line8> notifyPage(notifpages2[i], rule, doc, action, context); <line9> } <line10> } <line11> String xnotif = <line12> (context.getRequest() != null) <line13> ? context.getRequest().getParameter(""xnotification"") <line14> : null; <line15> if ((xnotif != null) && (!xnotif.equals(""""))) { <line16> notifyPage(xnotif, rule, doc, action, context); <line17> } <line18> } catch (Throwable e) { <line19> XWikiException e2 = <line20> new XWikiException( <line21> XWikiException.MODULE_XWIKI_NOTIFICATION, <line22> XWikiException.ERROR_XWIKI_NOTIFICATION, <line23> ""Error executing notifications"", <line24> e); <line25> if (LOGGER.isErrorEnabled()) { <line26> } <line27> } <line28> } <line29> } <line30> "	1	task3	
public class A { <line0> @Override <line1> public boolean isDisabled(Object object) { <line2> DDMStructure structure = (DDMStructure) object; <line3> PermissionChecker permissionChecker = PermissionThreadLocal.getPermissionChecker(); <line4> try { <line5> if (!DDMStructurePermission.contains(permissionChecker, structure, ActionKeys.DELETE)) { <line6> return true; <line7> } <line8> } catch (Exception exception) { <line9> } <line10> return super.isDisabled(object); <line11> } <line12> } <line13> 	1	task3	
public class A { <line0> @Override <line1> public String getVersion() { <line2> createTable(AbstractGeoWavePersistence.METADATA_TABLE, true, true); <line3> try { <line4> final Scanner scanner = createScanner(AbstractGeoWavePersistence.METADATA_TABLE); <line5> scanner.addScanIterator(new IteratorSetting(25, VersionIterator.class)); <line6> return StringUtils.stringFromBinary(scanner.iterator().next().getValue().get()); <line7> } catch (final TableNotFoundException e) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> @GetMapping(COLLECTION_CODE_PATH) <line1> @ResponseBody <line2> public List<String> suggestCollectionCodes( <line3> @RequestParam(QUERY_PARAM) String prefix, @RequestParam(PARAM_LIMIT) int limit) { <line4> return searchService.suggestCollectionCodes(prefix, limit); <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> public synchronized void configure(Configuration configuration, String changeLogFile) <line1> throws ConfigurationException { <line2> AppConstants appConstants = AppConstants.getInstance(configuration.getClassLoader()); <line3> setName(""JdbcMigrator for configuration["" + configuration.getName() + ""]""); <line4> if (StringUtils.isEmpty(getDatasourceName())) { <line5> setDatasourceName(appConstants.getString(""jdbc.migrator.dataSource"", null)); <line6> } <line7> super.configure(); <line8> if (changeLogFile == null) <line9> changeLogFile = appConstants.getString(""liquibase.changeLogFile"", ""DatabaseChangelog.xml""); <line10> LiquibaseClassLoaderWrapper cl = <line11> new LiquibaseClassLoaderWrapper(configuration.getClassLoader()); <line12> if (cl.getResource(changeLogFile) == null) { <line13> String msg = ""unable to find database changelog file ["" + changeLogFile + ""]""; <line14> msg += "" classLoader ["" + ClassUtils.nameOf(configuration.getClassLoader()) + ""]""; <line15> } else { <line16> try { <line17> JdbcConnection connection = new JdbcConnection(getConnection()); <line18> instance = new LiquibaseImpl(ibisContext, connection, configuration, changeLogFile); <line19> } catch (ValidationFailedException e) { <line20> ConfigurationWarnings.add( <line21> configuration, log, ""liquibase validation failed: "" + e.getMessage(), e); <line22> } catch (LiquibaseException e) { <line23> ConfigurationWarnings.add(configuration, log, ""liquibase failed to initialize"", e); <line24> } catch (Throwable e) { <line25> ConfigurationWarnings.add( <line26> configuration, <line27> log, <line28> ""liquibase failed to initialize, error connecting to database ["" <line29> + getDatasourceName() <line30> + ""]"", <line31> e); <line32> } <line33> } <line34> } <line35> } <line36> "	1	task3	
public class A { <line0> protected synchronized void rollSecret() { <line1> if (!isDestroyed) { <line2> byte[] newSecret = generateNewSecret(); <line3> secrets = new byte[][] {newSecret, secrets[0]}; <line4> } <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> @Override <line1> public synchronized void unregister(String resourcePath) throws HyracksDataException { <line2> validateDatasetLifecycleManagerState(); <line3> int did = getDIDfromResourcePath(resourcePath); <line4> long resourceID = getResourceIDfromResourcePath(resourcePath); <line5> DatasetResource dsr = datasets.get(did); <line6> IndexInfo iInfo = dsr == null ? null : dsr.getIndexInfo(resourceID); <line7> if (dsr == null || iInfo == null) { <line8> throw HyracksDataException.create(ErrorCode.INDEX_DOES_NOT_EXIST); <line9> } <line10> PrimaryIndexOperationTracker opTracker = dsr.getOpTracker(iInfo.getPartition()); <line11> if (iInfo.getReferenceCount() != 0 <line12> || (opTracker != null && opTracker.getNumActiveOperations() != 0)) { <line13> if (LOGGER.isErrorEnabled()) { <line14> final String logMsg = <line15> String.format( <line16> ""Failed to drop in-use index %s. Ref count (%d), Operation tracker active ops (%d)"", <line17> resourcePath, iInfo.getReferenceCount(), opTracker.getNumActiveOperations()); <line18> } <line19> throw HyracksDataException.create( <line20> ErrorCode.CANNOT_DROP_IN_USE_INDEX, StoragePathUtil.getIndexNameFromPath(resourcePath)); <line21> } <line22> DatasetInfo dsInfo = dsr.getDatasetInfo(); <line23> dsInfo.waitForIO(); <line24> closeIndex(iInfo); <line25> dsInfo.removeIndex(resourceID); <line26> synchronized (dsInfo) { <line27> if (dsInfo.getReferenceCount() == 0 <line28> && dsInfo.isOpen() <line29> && dsInfo.getIndexes().isEmpty() <line30> && !dsInfo.isExternal()) { <line31> removeDatasetFromCache(dsInfo.getDatasetID()); <line32> } <line33> } <line34> } <line35> } <line36> "	1	task3	
public class A { <line0> public boolean recallThreadLocalOutRequestIsEntryCall() { <line1> final Boolean curIsEntryCall = this.threadLocalOutRequestIsEntryCall.get(); <line2> if (curIsEntryCall == null) { <line3> return true; <line4> } <line5> return curIsEntryCall; <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> @SuppressWarnings(""rawtypes"") <line1> @Test <line2> public void testGetPendingCollaborations() throws Exception { <line3> final java.util.Collection result = requestBody(""direct://GETPENDINGCOLLABORATIONS"", null); <line4> assertNotNull(result, ""getPendingCollaborations result""); <line5> } <line6> } <line7> "	1	task3	
"public class A { <line0> @Test(timeout = 60000) <line1> public void testEmptyIndexPage() throws Exception { <line2> SyncThread syncThread = bs.get(0).getBookie().syncThread; <line3> assertNotNull(""Not found SyncThread."", syncThread); <line4> syncThread.suspendSync(); <line5> LedgerHandle lh1 = bkc.createLedger(1, 1, digestType, """".getBytes()); <line6> String dummyMsg = ""NoSuchLedger""; <line7> int numMsgs = 2 * pageSize / 8; <line8> LedgerHandle lh2 = bkc.createLedger(1, 1, digestType, """".getBytes()); <line9> for (int i = 0; i < numMsgs; i++) { <line10> lh2.addEntry(dummyMsg.getBytes()); <line11> } <line12> syncThread.resumeSync(); <line13> syncThread.requestFlush().get(); <line14> syncThread.suspendSync(); <line15> LedgerHandle newLh1 = bkc.openLedger(lh1.getId(), digestType, """".getBytes()); <line16> for (int i = 0; i < 3; i++) { <line17> lh2.addEntry(dummyMsg.getBytes()); <line18> } <line19> syncThread.resumeSync(); <line20> syncThread.requestFlush().get(); <line21> restartBookies(); <line22> numMsgs += 3; <line23> Enumeration<LedgerEntry> seq = lh2.readEntries(0, numMsgs - 1); <line24> assertTrue(""Enumeration of ledger entries has no element"", seq.hasMoreElements() == true); <line25> int entryId = 0; <line26> while (seq.hasMoreElements()) { <line27> LedgerEntry e = seq.nextElement(); <line28> assertEquals(entryId, e.getEntryId()); <line29> Assert.assertArrayEquals(dummyMsg.getBytes(), e.getEntry()); <line30> ++entryId; <line31> } <line32> assertEquals(entryId, numMsgs); <line33> } <line34> } <line35> "	1	task3	
"public class A { <line0> protected void verifyReceivedFields(Map<Object, Object> valueMap) { <line1> _receivedFields = valueMap; <line2> for (Map.Entry<Object, Matcher<?>> entry : _fieldMatchers.entrySet()) { <line3> @SuppressWarnings(""unchecked"") <line4> Matcher<Object> matcher = (Matcher<Object>) entry.getValue(); <line5> Object field = entry.getKey(); <line6> assertThat(""Field "" + field + "" value should match"", valueMap.get(field), matcher); <line7> } <line8> } <line9> } <line10> "	1	task3	
"public class A { <line0> public boolean isExpired() { <line1> Date expDate = this.expDate; <line2> if (expDate == null) { <line3> try { <line4> expDate = new SimpleDateFormat(""EEE, dd MMM yyyy HH:mm:ss z"").parse(expires); <line5> } catch (ParseException e) { <line6> Calendar calendar = Calendar.getInstance(); <line7> calendar.setTime(new Date()); <line8> calendar.add(Calendar.DAY_OF_YEAR, 1); <line9> expDate = calendar.getTime(); <line10> } <line11> } <line12> return (expDate == null || expDate.before(new Date())); <line13> } <line14> } <line15> "	1	task3	
public class A { <line0> protected void removeCachedInstance( <line1> LaunchConfiguration configuration, ChromeInstance chromeInstance) { <line2> ChromeInstance cachedInstance = instances.get(configuration); <line3> if (cachedInstance == chromeInstance) { <line4> instances.remove(configuration); <line5> } else { <line6> if (log.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> public void modelReload(ISO27KModel newModel) { <line1> for (IISO27KModelListener listener : getListeners()) { <line2> listener.modelReload(newModel); <line3> if (log.isDebugEnabled()) { <line4> } <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> @Override <line1> public String removeUser(Map<String, Object> request, RequestContext context) { <line2> Keycloak keycloak = KeyCloakConnectionProvider.getConnection(); <line3> String userId = (String) request.get(JsonKey.USER_ID); <line4> try { <line5> String fedUserId = getFederatedUserId(userId); <line6> UserResource resource = <line7> keycloak.realm(KeyCloakConnectionProvider.SSO_REALM).users().get(fedUserId); <line8> if (isNotNull(resource)) { <line9> resource.remove(); <line10> } <line11> } catch (Exception ex) { <line12> ProjectUtil.createAndThrowInvalidUserDataException(); <line13> } <line14> return JsonKey.SUCCESS; <line15> } <line16> } <line17> 	1	task3	
public class A { <line0> @Override <line1> protected TAIResult createPrincipal( <line2> HttpServletRequest request, HttpServletResponse response, FedizResponse federationResponse) { <line3> HttpSession session = request.getSession(true); <line4> session.setAttribute(Constants.SECURITY_TOKEN_SESSION_ATTRIBUTE_KEY, federationResponse); <line5> String username = federationResponse.getUsername(); <line6> try { <line7> return TAIResult.create(HttpServletResponse.SC_FOUND); <line8> } catch (WebTrustAssociationFailedException e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	1	task3	
"public class A { <line0> public static void deleteWebsite(HttpPrincipal httpPrincipal, long websiteId) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey(WebsiteServiceUtil.class, ""deleteWebsite"", _deleteWebsiteParameterTypes1); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, websiteId); <line6> try { <line7> TunnelUtil.invoke(httpPrincipal, methodHandler); <line8> } catch (Exception exception) { <line9> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line10> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line11> } <line12> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line13> } <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	1	task3	
"public class A { <line0> @Test <line1> public void testMultiple() throws Exception { <line2> String filename = ""data/hin/multiple.hin""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> HINReader reader = new HINReader(ins); <line5> ChemFile chemFile = (ChemFile) reader.read((ChemObject) new ChemFile()); <line6> reader.close(); <line7> Assert.assertNotNull(chemFile); <line8> Assert.assertEquals(1, chemFile.getChemSequenceCount()); <line9> org.openscience.cdk.interfaces.IChemSequence seq = chemFile.getChemSequence(0); <line10> Assert.assertNotNull(seq); <line11> Assert.assertEquals(1, seq.getChemModelCount()); <line12> org.openscience.cdk.interfaces.IChemModel model = seq.getChemModel(0); <line13> Assert.assertNotNull(model); <line14> IAtomContainerSet som = model.getMoleculeSet(); <line15> Assert.assertNotNull(som); <line16> Assert.assertEquals(3, som.getAtomContainerCount()); <line17> } <line18> } <line19> "	1	task3	
public class A { <line0> public void writeToXML(File f, XStream streamer) throws IOException { <line1> XMLUtils.objectToFile(this, f, streamer); <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> @Transactional <line1> public void regenerateCertificatesOf(Consumer consumer, boolean lazy) { <line2> Owner owner = ownerCurator.findOwnerById(consumer.getOwnerId()); <line3> if (owner.isUsingSimpleContentAccess()) { <line4> this.contentAccessManager.removeContentAccessCert(consumer); <line5> } <line6> this.regenerateCertificatesOf(consumer.getEntitlements(), lazy); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> public void pushNotification(DimeInternalNotification notification) { <line1> Long tenant = notification.getTenant(); <line2> if (mapFifoLists.containsKey(tenant)) { <line3> mapFifoLists.get(tenant).add(notification); <line4> } else { <line5> ConcurrentLinkedQueue<DimeInternalNotification> newFifo = <line6> new ConcurrentLinkedQueue<DimeInternalNotification>(); <line7> newFifo.add(notification); <line8> mapFifoLists.put(tenant, newFifo); <line9> } <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> @Disabled <line1> @Test <line2> public void testFind() throws Exception { <line3> final com.braintreegateway.Subscription result = requestBody(""direct://FIND"", null); <line4> assertNotNull(result, ""find result""); <line5> } <line6> } <line7> "	1	task3	
public class A { <line0> private void logServerInfo() { <line1> } <line2> } <line3> 	1	task3	
"public class A { <line0> public boolean backupOldConfig(String resourceId, String configType, String oldConfig) <line1> throws AutoFixException { <line2> String url = <line3> CommonUtils.getPropValue(com.tmobile.pacman.common.PacmanSdkConstants.BACKUP_ASSET_CONFIG); <line4> url = url.concat(""?resourceId="").concat(resourceId).concat(""&configType="").concat(configType); <line5> try { <line6> String resp = CommonUtils.doHttpPost(url, oldConfig, Maps.newHashMap()); <line7> if (!Strings.isNullOrEmpty(resp)) { <line8> return true; <line9> } else { <line10> throw new AutoFixException(); <line11> } <line12> } catch (Exception exception) { <line13> throw new AutoFixException(exception); <line14> } <line15> } <line16> } <line17> "	1	task3	
public class A { <line0> public Set<String> getOpenInstancesInternal() { <line1> Set<String> openInstances = <line2> Sets.newHashSet(modifyConfig.getContainedNamespaces(REGISTRATION_NS)); <line3> return openInstances; <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> public static File switchClusterRolesToRolesIfNeeded(File oldFile) { <line1> if (Environment.isNamespaceRbacScope()) { <line2> try { <line3> File tmpFile = <line4> File.createTempFile(""rbac-"" + oldFile.getName().replace("".yaml"", """"), "".yaml""); <line5> TestUtils.writeFile( <line6> tmpFile.getAbsolutePath(), TestUtils.readFile(oldFile).replace(""ClusterRole"", ""Role"")); <line7> return tmpFile; <line8> } catch (IOException e) { <line9> throw new RuntimeException(e); <line10> } <line11> } else { <line12> return oldFile; <line13> } <line14> } <line15> } <line16> "	1	task3	
public class A { <line0> public void task() throws Exception { <line1> FromDefinition from = route.getInput(); <line2> from.setUri(null); <line3> from.setEndpoint(endpoint); <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> void remove(final String id) { <line1> EntityManager em = daoManager.getEntityManagerFromFactory(); <line2> try { <line3> daoManager.startTransaction(em); <line4> UserTokenEntity item = em.find(UserTokenEntity.class, id); <line5> em.remove(item); <line6> daoManager.commitTransaction(em); <line7> } catch (Exception e) { <line8> daoManager.rollBackTransaction(em); <line9> } finally { <line10> daoManager.closeEntityManager(em); <line11> } <line12> } <line13> } <line14> 	1	task3	
"public class A { <line0> private static void registerLifecycleHandlers( <line1> Configuration configuration, <line2> Object component, <line3> Class<? extends Annotation> lifecycleAnnotation, <line4> LifecycleRegistration registrationMethod) { <line5> for (Method method : ReflectionUtils.methodsOf(component.getClass())) { <line6> AnnotationUtils.findAnnotationAttributes(method, lifecycleAnnotation) <line7> .ifPresent( <line8> lifecycleAnnotationAttributes -> { <line9> if (method.getParameterCount() > 0) { <line10> throw new AxonConfigurationException( <line11> format( <line12> ""The @%s annotated method [%s] should not contain any parameters"" <line13> + "" as none are allowed on lifecycle handlers"", <line14> lifecycleAnnotation.getSimpleName(), method)); <line15> } <line16> method.setAccessible(true); <line17> int phase = (int) lifecycleAnnotationAttributes.get(LIFECYCLE_PHASE_ATTRIBUTE_NAME); <line18> LifecycleHandler lifecycleHandler = <line19> () -> <line20> invokeAndReturn( <line21> component, method, lifecycleAnnotation.getSimpleName(), phase); <line22> registrationMethod.registerLifecycleHandler(configuration, phase, lifecycleHandler); <line23> }); <line24> } <line25> } <line26> } <line27> "	1	task3	
public class A { <line0> public final boolean updateOutputCondition(int newDataCount, int oldDataCount) { <line1> if (optionalVariableReader != null) { <line2> Object value = optionalVariableReader.getValue(); <line3> if (value != null) { <line4> state.setEventRate(((Number) value).longValue()); <line5> } <line6> } <line7> state.setNewEventsCount(state.getNewEventsCount() + newDataCount); <line8> state.setOldEventsCount(state.getOldEventsCount() + oldDataCount); <line9> if (isSatisfied() || state.isFirst()) { <line10> if ((ExecutionPathDebugLog.isDebugEnabled) && (log.isDebugEnabled())) { <line11> } <line12> state.setIsFirst(false); <line13> state.setNewEventsCount(0); <line14> state.setOldEventsCount(0); <line15> return true; <line16> } <line17> return false; <line18> } <line19> } <line20> 	1	task3	
"public class A { <line0> @Test <line1> public void linearringQueryTest() throws IOException { <line2> final String linearring = ""LINEARRING (12 12, 14 10, 13 14, 12 12)""; <line3> OccurrenceSearchRequest searchRequest = new OccurrenceSearchRequest(); <line4> searchRequest.addGeometryFilter(linearring); <line5> QueryBuilder query = <line6> EsSearchRequestBuilder.buildQueryNode(searchRequest) <line7> .orElseThrow(IllegalArgumentException::new); <line8> JsonNode jsonQuery = MAPPER.readTree(query.toString()); <line9> assertTrue( <line10> jsonQuery <line11> .path(BOOL) <line12> .path(FILTER) <line13> .get(0) <line14> .path(BOOL) <line15> .path(SHOULD) <line16> .get(0) <line17> .path(GEO_SHAPE) <line18> .path(COORDINATE_SHAPE.getFieldName()) <line19> .has(SHAPE)); <line20> JsonNode shape = <line21> jsonQuery <line22> .path(BOOL) <line23> .path(FILTER) <line24> .get(0) <line25> .path(BOOL) <line26> .path(SHOULD) <line27> .get(0) <line28> .path(GEO_SHAPE) <line29> .path(COORDINATE_SHAPE.getFieldName()) <line30> .path(SHAPE); <line31> assertEquals(""LineString"", shape.get(TYPE).asText()); <line32> assertTrue(shape.get(COORDINATES).isArray()); <line33> assertEquals(4, shape.get(COORDINATES).size()); <line34> assertEquals(12, shape.get(COORDINATES).get(0).get(0).asDouble(), 0); <line35> } <line36> } <line37> "	1	task3	
public class A { <line0> @Override <line1> public void init() { <line2> this.checkOpened(); <line3> for (RaftBackendStore store : this.stores()) { <line4> store.init(); <line5> } <line6> this.notifyAndWaitEvent(Events.STORE_INITED); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> @BeforeAll <line1> public static void doCollectionSetup() { <line2> EmbedMongoConfiguration.DATABASE.createCollection(COLLECTION); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> public static String getConfigFilePath() { <line1> String configResource = GsEnv.property(""com.gigaspaces.metrics.config.resource"").get(); <line2> if (StringUtils.hasLength(configResource)) { <line3> URL systemResource = ClassLoader.getSystemResource(configResource); <line4> if (systemResource != null) { <line5> return systemResource.getFile(); <line6> } <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> String result = GsEnv.property(""com.gigaspaces.metrics.config"").get(); <line11> if (!StringUtils.hasLength(result)) { <line12> result = SystemLocations.singleton().config(""metrics"").resolve(""metrics.xml"").toString(); <line13> } <line14> return result; <line15> } <line16> } <line17> "	1	task3	
"public class A { <line0> protected void syncSourceVersion(final boolean initial) { <line1> lockManager.lock( <line2> new SyncSourceVersionLock(), <line3> new LockCallbackNoReturn() { <line4> @Override <line5> public void doWithLockNoResult() { <line6> for (ConfigItem item : itemRegistry.getConfigItems()) { <line7> if (!initial) { <line8> if (item instanceof RefreshableConfigItem) { <line9> try { <line10> ((RefreshableConfigItem) item).refresh(); <line11> } catch (IOException e) { <line12> continue; <line13> } <line14> } else { <line15> continue; <line16> } <line17> } <line18> versionManager.setItemSourceVersion(item.getName(), item.getSourceRevision()); <line19> } <line20> for (String item : PRELOAD.get()) { <line21> versionManager.setItemSourceVersion(item, """"); <line22> } <line23> } <line24> }); <line25> } <line26> } <line27> "	1	task3	
"public class A { <line0> protected void writeContentType(final StreamResponse response, final ResponseData responseData) { <line1> final String mimeType = responseData.getMimeType(); <line2> if (logger.isDebugEnabled()) { <line3> } <line4> if (mimeType == null) { <line5> response.contentTypeOctetStream(); <line6> return; <line7> } <line8> if (mimeType.startsWith(""text/"")) { <line9> final String charset = LaResponseUtil.getResponse().getCharacterEncoding(); <line10> if (charset != null) { <line11> response.contentType(mimeType + ""; charset="" + charset); <line12> return; <line13> } <line14> } <line15> response.contentType(mimeType); <line16> } <line17> } <line18> "	1	task3	
"public class A { <line0> private void buildRedisClient(RedisSideTableInfo tableInfo) { <line1> String url = redisSideTableInfo.getUrl(); <line2> String password = <line3> Objects.isNull(redisSideTableInfo.getPassword()) ? """" : redisSideTableInfo.getPassword(); <line4> String database = redisSideTableInfo.getDatabase(); <line5> if (Objects.isNull(database)) { <line6> database = ""0""; <line7> } <line8> switch (RedisType.parse(tableInfo.getRedisType())) { <line9> case STANDALONE: <line10> RedisURI redisUri = RedisURI.create(""redis://"" + url); <line11> redisUri.setPassword(password); <line12> redisUri.setDatabase(Integer.parseInt(database)); <line13> redisClient = RedisClient.create(redisUri); <line14> connection = redisClient.connect(); <line15> async = connection.async(); <line16> break; <line17> case SENTINEL: <line18> RedisURI redisSentinelUri = RedisURI.create(""redis-sentinel://"" + url); <line19> redisSentinelUri.setPassword(password); <line20> redisSentinelUri.setDatabase(Integer.parseInt(database)); <line21> redisSentinelUri.setSentinelMasterId(redisSideTableInfo.getMasterName()); <line22> redisClient = RedisClient.create(redisSentinelUri); <line23> connection = redisClient.connect(); <line24> async = connection.async(); <line25> break; <line26> case CLUSTER: <line27> RedisURI clusterUri = RedisURI.create(""redis://"" + url); <line28> clusterUri.setPassword(password); <line29> clusterClient = RedisClusterClient.create(clusterUri); <line30> clusterConnection = clusterClient.connect(); <line31> async = clusterConnection.async(); <line32> default: <line33> break; <line34> } <line35> } <line36> } <line37> "	1	task3	
"public class A { <line0> private FlowResponseMessage handleFlowRequest(final FlowRequestMessage request) <line1> throws ProtocolException { <line2> readLock.lock(); <line3> try { <line4> final FlowResponseMessage response = new FlowResponseMessage(); <line5> response.setDataFlow(createDataFlow()); <line6> return response; <line7> } catch (final Exception ex) { <line8> throw new ProtocolException( <line9> ""Failed serializing flow controller state for flow request due to: "" + ex, ex); <line10> } finally { <line11> readLock.unlock(); <line12> } <line13> } <line14> } <line15> "	1	task3	
"public class A { <line0> public void runNext(WorkFlowContext ctx) { <line1> if (!isInitialized) { <line2> throw new CloudRuntimeException( <line3> String.format(""runNext() can only be called from AysncWorkFlow"")); <line4> } <line5> WorkFlowVO vo = getFlowVOByPosition(currentPosition); <line6> vo.setState(flowState.getNextState(vo.getState(), WorkFlowStateEvent.done)); <line7> vo.setContext(ctx.toBytes()); <line8> dbf.update(vo); <line9> currentPosition++; <line10> if (currentPosition < flows.size()) { <line11> chainvo.setCurrentPosition(currentPosition); <line12> chainvo = dbf.updateAndRefresh(chainvo); <line13> AsyncWorkFlow flow = flows.get(currentPosition); <line14> processFlow(flow, ctx, null, currentPosition); <line15> } else { <line16> chainvo.setState(WorkFlowChainState.ProcessDone); <line17> chainvo = dbf.updateAndRefresh(chainvo); <line18> tellCallbackSuccess(ctx); <line19> } <line20> } <line21> } <line22> "	1	task3	
public class A { <line0> @Override <line1> public void onReceiveCommand(String channelId, LGWebOSHandler handler, Command command) { <line2> final PercentType percent; <line3> if (RefreshType.REFRESH == command) { <line4> handler.getSocket().getVolume(createResponseListener(channelId, handler)); <line5> return; <line6> } <line7> if (command instanceof PercentType) { <line8> percent = (PercentType) command; <line9> } else if (command instanceof DecimalType) { <line10> percent = new PercentType(((DecimalType) command).toBigDecimal()); <line11> } else if (command instanceof StringType) { <line12> percent = new PercentType(((StringType) command).toString()); <line13> } else { <line14> percent = null; <line15> } <line16> if (percent != null) { <line17> handler.getSocket().setVolume(percent.floatValue() / 100.0f, objResponseListener); <line18> } else if (IncreaseDecreaseType.INCREASE == command) { <line19> handler.getSocket().volumeUp(objResponseListener); <line20> } else if (IncreaseDecreaseType.DECREASE == command) { <line21> handler.getSocket().volumeDown(objResponseListener); <line22> } else if (OnOffType.OFF == command || OnOffType.ON == command) { <line23> handler.getSocket().setMute(OnOffType.OFF == command, objResponseListener); <line24> } else { <line25> } <line26> } <line27> } <line28> 	1	task3	
public class A { <line0> protected void loadAegisTypeClassAndRegister( <line1> String typeClassName, Class<?> aegisTypeClass, QName qName, TypeMapping typeMapping) { <line2> try { <line3> Class<?> typeClazz = Thread.currentThread().getContextClassLoader().loadClass(typeClassName); <line4> AegisType aegisType = instantiateAegisType(aegisTypeClass); <line5> typeMapping.register(typeClazz, qName, aegisType); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> public static TestServer createAndStartServer(Class<?>... configClasses) { <line1> int port = NEXT_PORT.incrementAndGet(); <line2> Server server = new Server(port); <line3> AnnotationConfigWebApplicationContext applicationContext = <line4> new AnnotationConfigWebApplicationContext(); <line5> applicationContext.register(configClasses); <line6> applicationContext.refresh(); <line7> try { <line8> server.setHandler(getServletContextHandler(applicationContext)); <line9> server.start(); <line10> } catch (Exception e) { <line11> } <line12> return new TestServer(server, applicationContext, port); <line13> } <line14> } <line15> 	1	task3	
public class A { <line0> public static EncryptionCipher getEncryptionCipher( <line1> CipherSuite cipherSuite, ConnectionEndType connectionEndType, KeySet keySet) { <line2> CipherAlgorithm cipherAlg = AlgorithmResolver.getCipher(cipherSuite); <line3> if (cipherAlg == CipherAlgorithm.GOST_28147_CNT) { <line4> return new GOST28147Cipher( <line5> GOSTUtils.getGostSpec(cipherSuite), <line6> keySet.getWriteKey(connectionEndType), <line7> keySet.getWriteIv(connectionEndType)); <line8> } else if (cipherAlg == CipherAlgorithm.ChaCha20Poly1305) { <line9> return new ChaCha20Poly1305Cipher(keySet.getWriteKey(connectionEndType)); <line10> } else if (cipherAlg.getJavaName() != null) { <line11> return new JavaCipher(cipherAlg, keySet.getWriteKey(connectionEndType)); <line12> } else if (cipherAlg == CipherAlgorithm.NULL) { <line13> return new NullCipher(); <line14> } else { <line15> return new NullCipher(); <line16> } <line17> } <line18> } <line19> 	1	task3	
public class A { <line0> private void resolveReferencesForRootTypes() { <line1> try { <line2> AtlasEntityType.ENTITY_ROOT.resolveReferences(this); <line3> AtlasClassificationType.CLASSIFICATION_ROOT.resolveReferences(this); <line4> } catch (AtlasBaseException e) { <line5> throw new RuntimeException(e); <line6> } <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> @Override <line1> protected void runTask(BlockTask task) { <line2> try { <line3> task.run(); <line4> } catch (Moka7Exception e) { <line5> handleMoka7IOException(e); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> private StorageSummary putObject( <line1> Table table, <line2> String blobId, <line3> Supplier<? extends InputStream> in, <line4> Map<String, String> attributes) { <line5> long timestamp = _storageProvider.getCurrentTimestamp(table); <line6> int chunkSize = _storageProvider.getDefaultChunkSize(); <line7> checkArgument(chunkSize > 0); <line8> DigestInputStream md5In = new DigestInputStream(in.get(), getMessageDigest(""MD5"")); <line9> DigestInputStream sha1In = new DigestInputStream(md5In, getMessageDigest(""SHA-1"")); <line10> byte[] bytes = new byte[chunkSize]; <line11> long length = 0; <line12> int chunkCount = 0; <line13> for (; ; ) { <line14> int chunkLength; <line15> try { <line16> chunkLength = ByteStreams.read(sha1In, bytes, 0, bytes.length); <line17> } catch (IOException e) { <line18> throw Throwables.propagate(e); <line19> } <line20> if (chunkLength == 0) { <line21> break; <line22> } <line23> ByteBuffer buffer = ByteBuffer.wrap(bytes, 0, chunkLength); <line24> _storageProvider.writeChunk(table, blobId, chunkCount, buffer, timestamp); <line25> length += chunkLength; <line26> chunkCount++; <line27> } <line28> String md5 = Hex.encodeHexString(md5In.getMessageDigest().digest()); <line29> String sha1 = Hex.encodeHexString(sha1In.getMessageDigest().digest()); <line30> return new StorageSummary(length, chunkCount, chunkSize, md5, sha1, attributes, timestamp); <line31> } <line32> } <line33> "	1	task3	
public class A { <line0> private void addRemote(ThingUID bridge, String remote) { <line1> ThingTypeUID uid = LIRCBindingConstants.THING_TYPE_REMOTE; <line2> ThingUID thingUID = new ThingUID(uid, bridge, remote); <line3> Map<String, Object> properties = new HashMap<>(1); <line4> properties.put(LIRCBindingConstants.PROPERTY_REMOTE, remote); <line5> DiscoveryResult discoveryResult = <line6> DiscoveryResultBuilder.create(thingUID) <line7> .withLabel(remote) <line8> .withBridge(bridge) <line9> .withProperties(properties) <line10> .build(); <line11> thingDiscovered(discoveryResult); <line12> } <line13> } <line14> 	1	task3	
public class A { <line0> private void execute(GenericCli shell, String[] args) { <line1> CommandLine cmd = shell.getCmd(); <line2> IExceptionHandler2<List<Object>> exceptionHandler = <line3> new IExceptionHandler2<List<Object>>() { <line4> @Override <line5> public List<Object> handleParseException(ParameterException ex, String[] args) { <line6> throw ex; <line7> } <line8>  <line9> @Override <line10> public List<Object> handleExecutionException( <line11> ExecutionException ex, ParseResult parseRes) { <line12> throw ex; <line13> } <line14> }; <line15> String[] argsWithHAConf = getHASetConfStrings(args); <line16> cmd.parseWithHandlers(new RunLast(), exceptionHandler, argsWithHAConf); <line17> } <line18> } <line19> 	1	task3	
public class A { <line0> protected void checkResponseEntity(Response response) { <line1> if (!response.hasEntity()) { <line2> } <line3> } <line4> } <line5> 	1	task3	
public class A { <line0> @Override <line1> public void run() { <line2> while (this.running) { <line3> try { <line4> processService(); <line5> } catch (Exception exception) { <line6> hasError = true; <line7> } <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> private boolean checkSkip(String cubingJobId, int level) { <line1> if (cubingJobId == null) return false; <line2> ExecutableManager execMgr = ExecutableManager.getInstance(KylinConfig.getInstanceFromEnv()); <line3> CubingJob cubingJob = (CubingJob) execMgr.getJob(cubingJobId); <line4> skipped = cubingJob.isLayerCubing() == false; <line5> if (!skipped) { <line6> skipped = (level > cuboidScheduler.getBuildLevel()); <line7> if (skipped) { <line8> } <line9> } <line10> return skipped; <line11> } <line12> } <line13> 	1	task3	
"public class A { <line0> protected void addPublicContentSearchRecord(String id, IApsEntity entity, Connection conn) <line1> throws ApsSystemException { <line2> PreparedStatement stat = null; <line3> try { <line4> stat = conn.prepareStatement(ADD_CONTENT_SEARCH_RECORD); <line5> this.addEntitySearchRecord(id, entity, stat); <line6> } catch (Throwable t) { <line7> throw new RuntimeException(""Error on adding public content search records"", t); <line8> } finally { <line9> closeDaoResources(null, stat); <line10> } <line11> } <line12> } <line13> "	1	task3	
public class A { <line0> public final void setProperty(String key, String value) { <line1> properties.setProperty(BCC.check(key), value); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @Override <line1> public void login(final Proxy proxy, final LoginCallback prompt, final CancelCallback cancel) <line2> throws BackgroundException { <line3> try { <line4> final IRODSAccount account = client.getIRODSAccount(); <line5> final Credentials credentials = host.getCredentials(); <line6> account.setUserName(credentials.getUsername()); <line7> account.setPassword(credentials.getPassword()); <line8> final AuthResponse response = <line9> client.getIRODSAccessObjectFactory().authenticateIRODSAccount(account); <line10> if (log.isDebugEnabled()) { <line11> } <line12> if (!response.isSuccessful()) { <line13> throw new LoginFailureException( <line14> MessageFormat.format( <line15> LocaleFactory.localizedString( <line16> ""Login {0} with username and password"", ""Credentials""), <line17> BookmarkNameProvider.toString(host))); <line18> } <line19> } catch (JargonException e) { <line20> throw new IRODSExceptionMappingService().map(e); <line21> } <line22> } <line23> } <line24> "	1	task3	
public class A { <line0> protected void runAnyPendingCompactions(HoodieTable<T, I, K, O> table) { <line1> table <line2> .getActiveTimeline() <line3> .getWriteTimeline() <line4> .filterPendingCompactionTimeline() <line5> .getInstants() <line6> .forEach( <line7> instant -> { <line8> compact(instant.getTimestamp(), true); <line9> }); <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> @Override <line1> public void handle(final Callback[] callbacks) throws UnsupportedCallbackException { <line2> AuthorizeCallback ac = null; <line3> for (Callback callback : callbacks) { <line4> if (callback instanceof AuthorizeCallback) { <line5> ac = (AuthorizeCallback) callback; <line6> } else { <line7> throw new UnsupportedCallbackException(callback, ""Unrecognized SASL GSSAPI Callback""); <line8> } <line9> } <line10> if (ac != null) { <line11> final String authid = ac.getAuthenticationID(); <line12> final String authzid = ac.getAuthorizationID(); <line13> if (authid.equals(authzid)) { <line14> ac.setAuthorized(true); <line15> } else { <line16> ac.setAuthorized(false); <line17> } <line18> if (ac.isAuthorized()) { <line19> final String[] authidParts = authid.split(""@""); <line20> ac.setAuthorizedID(authidParts[0]); <line21> } <line22> } <line23> } <line24> } <line25> "	1	task3	
public class A { <line0> @Override <line1> public void info(final String desc) { <line2> call( <line3> new Runnable() { <line4> public void run() { <line5> } <line6> }); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> @Override <line1> public void onSuccess(ResultSet result) { <line2> concurrentQueries.release(); <line3> if (executedQueries.incrementAndGet() % 1000 == 0) <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> private void sendGivenCommandAndNextInQueueIfPossible( <line1> final KafkaBasedCommandContext commandContext, <line2> final Supplier<Future<Void>> sendActionSupplier, <line3> final Promise<Void> sendActionCompletedPromise, <line4> final boolean completedPromiseJustCreated) { <line5> final Future<Void> sendActionFuture = sendActionSupplier.get(); <line6> sendActionFuture.onComplete(sendActionCompletedPromise); <line7> if (!queue.isEmpty()) { <line8> if (sendActionFuture.isComplete() && completedPromiseJustCreated) { <line9> vertxContext.runOnContext(v -> sendNextCommandInQueueIfPossible()); <line10> } else { <line11> sendNextCommandInQueueIfPossible(); <line12> } <line13> } <line14> } <line15> } <line16> 	1	task3	
public class A { <line0> public void startBlocking() throws InterruptedException { <line1> this.ws.connectBlocking(); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @Override <line1> public List<Artifact> getProjectArtifacts(String projectId) <line2> throws InvalidProtocolBufferException, ExecutionException, InterruptedException { <line3> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line4> Query query = session.createQuery(GET_PROJECT_BY_ID_HQL); <line5> query.setParameter(""id"", projectId); <line6> ProjectEntity projectEntity = (ProjectEntity) query.uniqueResult(); <line7> if (projectEntity == null) { <line8> String errorMessage = ""Project not found for given ID: "" + projectId; <line9> throw new NotFoundException(errorMessage); <line10> } <line11> Project project = <line12> projectEntity.getProtoObject(roleService, authService, new HashMap<>(), new HashMap<>()); <line13> if (project.getArtifactsList() != null && !project.getArtifactsList().isEmpty()) { <line14> return project.getArtifactsList(); <line15> } else { <line16> String errorMessage = ""Artifacts not found in the Project""; <line17> throw new NotFoundException(errorMessage); <line18> } <line19> } catch (Exception ex) { <line20> if (ModelDBUtils.needToRetry(ex)) { <line21> return getProjectArtifacts(projectId); <line22> } else { <line23> throw ex; <line24> } <line25> } <line26> } <line27> } <line28> "	1	task3	
public class A { <line0> public static void pushAuthentication() { <line1> Authentication originalFullAuthentication = AuthenticationUtil.getFullAuthentication(); <line2> Authentication originalRunAsAuthentication = AuthenticationUtil.getRunAsAuthentication(); <line3> threadLocalFullAuthenticationStack.get().push(originalFullAuthentication); <line4> threadLocalRunAsAuthenticationStack.get().push(originalRunAsAuthentication); <line5> threadLocalTenantDomainStack.get().push(TenantContextHolder.getTenantDomain()); <line6> if (logger.isTraceEnabled()) { <line7> } <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> @Modified <line1> protected void modified(final ComponentContext componentContext) { <line2> bindingConfig.updateFromProperties(componentContext.getProperties()); <line3> } <line4> } <line5> 	1	task3	
public class A { <line0> @Override <line1> public Set<DiscoveredResourceDetails> discoverResources( <line2> final ResourceDiscoveryContext<ApplicationResourceComponent> context) { <line3> final HashSet<DiscoveredResourceDetails> discoveredResources = <line4> new HashSet<DiscoveredResourceDetails>(); <line5> final ApplicationResourceComponent parent = context.getParentResourceComponent(); <line6> final Map<String, Reference> references = parent.getReferences(); <line7> for (Reference reference : references.values()) { <line8> final Configuration pluginConfig = context.getDefaultPluginConfiguration(); <line9> final QName name = reference.getName(); <line10> final DiscoveredResourceDetails resource = <line11> new DiscoveredResourceDetails( <line12> context.getResourceType(), <line13> name.toString(), <line14> name.getLocalPart(), <line15> name.getNamespaceURI(), <line16> null, <line17> pluginConfig, <line18> null); <line19> discoveredResources.add(resource); <line20> } <line21> return discoveredResources; <line22> } <line23> } <line24> 	1	task3	
"public class A { <line0> public static long reserveNamespace( <line1> Manager env, <line2> NamespaceId namespaceId, <line3> long id, <line4> boolean writeLock, <line5> boolean mustExist, <line6> TableOperation op) <line7> throws Exception { <line8> if (getLock(env.getContext(), namespaceId, id, writeLock).tryLock()) { <line9> if (mustExist) { <line10> ZooReaderWriter zk = env.getContext().getZooReaderWriter(); <line11> if (!zk.exists( <line12> env.getContext().getZooKeeperRoot() + Constants.ZNAMESPACES + ""/"" + namespaceId)) <line13> throw new AcceptableThriftTableOperationException( <line14> namespaceId.canonical(), <line15> """", <line16> op, <line17> TableOperationExceptionType.NAMESPACE_NOTFOUND, <line18> ""Namespace does not exist""); <line19> } <line20> return 0; <line21> } else return 100; <line22> } <line23> } <line24> "	1	task3	
public class A { <line0> public void start(Client c) { <line1> Long roomId = c.getRoomId(); <line2> if (!c.hasRight(Room.Right.PRESENTER) || isStarted(roomId)) { <line3> return; <line4> } <line5> IMap<Long, Map<Long, Boolean>> polls = map(); <line6> polls.lock(roomId); <line7> polls.putIfAbsent(roomId, new ConcurrentHashMap<>()); <line8> polls.unlock(roomId); <line9> WebSocketHelper.sendRoom(new TextRoomMessage(roomId, c, Type.QUICK_POLL_UPDATED, c.getUid())); <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> private void renameTempFile(File source) { <line1> File destination = <line2> new File(StringUtils.removeEnd(source.getAbsolutePath(), TEMP_FILE_EXTENSION)); <line3> boolean success = source.renameTo(destination); <line4> if (!success) { <line5> } <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public void stop() { <line2> executor.shutdown(); <line3> thread.interrupt(); <line4> try { <line5> thread.join(3000); <line6> if (thread.isAlive()) { <line7> thread.stop(); <line8> } <line9> } catch (InterruptedException e) { <line10> } <line11> } <line12> } <line13> "	1	task3	
public class A { <line0> @Override <line1> public void flush() { <line2> try { <line3> xDMA.storeMetadataToStorage(UNO.XStorageBasedDocument(doc).getDocumentStorage()); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> private NaturalLanguage deriveNaturalLanguage( <line1> ObjectContext context, PkgDumpExportJobSpecification specification) { <line2> if (StringUtils.isNotBlank(specification.getNaturalLanguageCode())) { <line3> return NaturalLanguage.tryGetByCode(context, specification.getNaturalLanguageCode()) <line4> .orElseGet( <line5> () -> { <line6> return NaturalLanguage.getEnglish(context); <line7> }); <line8> } <line9> return NaturalLanguage.getEnglish(context); <line10> } <line11> } <line12> 	1	task3	
public class A { <line0> private void parsePskIdentityHintLength(PskEcDheServerKeyExchangeMessage msg) { <line1> msg.setIdentityHintLength(parseIntField(HandshakeByteLength.PSK_IDENTITY_LENGTH)); <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> private ResourceResponse processPostResourcePlugins(ResourceResponse resourceResponse) <line1> throws StopProcessingException { <line2> for (PostResourcePlugin plugin : frameworkProperties.getPostResource()) { <line3> try { <line4> resourceResponse = plugin.process(resourceResponse); <line5> } catch (PluginExecutionException e) { <line6> } <line7> } <line8> return resourceResponse; <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> private void executeCommit() throws SQLException { <line1> if (useCommit) { <line2> if (commitCount < commitEvery) { <line3> commitCount++; <line4> } else { <line5> commitCount = 0; <line6> conn.commit(); <line7> } <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> @Override <line1> public synchronized void stop() throws KrbException { <line2> super.stop(); <line3> try { <line4> krb5Conf.deleteKrb5conf(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> 	1	task3	
"public class A { <line0> @Test <line1> public void testCounterLimitExceeded() throws Exception { <line2> int expectedMax = (COUNTER_LIMIT - 2) / 2; <line3> File f = setUpFlagDir(); <line4> LongRange range = createTestFiles(2, expectedMax + 20, true); <line5> int total = 2 * 2 * (expectedMax + 20); <line6> fmc.setSetFlagFileTimestamp(true); <line7> fmc.setUseFolderTimestamp(true); <line8> fmc.getDefaultCfg().setMaxFlags(expectedMax + 15); <line9> FlagMaker instance = new TestWrappedFlagMaker(fmc); <line10> instance.processFlags(); <line11> int a = f.listFiles().length; <line12> int expectedFlagCount = 0; <line13> for (File file : f.listFiles()) { <line14> if (file.getName().endsWith(""+"" + expectedMax + "".flag"")) { <line15> expectedFlagCount++; <line16> } <line17> } <line18> assertEquals( <line19> ""Unexpected number of flag files with size "" + expectedMax, <line20> (total / expectedMax), <line21> expectedFlagCount); <line22> } <line23> } <line24> "	1	task3	
"public class A { <line0> public void testSelectionRange3() throws Exception { <line1> String req = <line2> ""{\""selections\"":[{\""range\"":{\""groupid_range\"":{\""from\"":\""0\"", \""to\"":\""10\""}}}]}""; <line3> JSONObject res = TestSensei.search(new JSONObject(req)); <line4> assertEquals(""numhits is wrong"", 11, res.getInt(""numhits"")); <line5> } <line6> } <line7> "	1	task3	
public class A { <line0> @Override <line1> protected void onEntityChange(Entity member) { <line2> ((CassandraFabricImpl) entity).update(); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> public void remove(String typeName) { <line1> logEnter(""ClientTypeDescRepository.remove"", ""typeName"", typeName); <line2> synchronized (_lock) { <line3> _typeMap.remove(typeName); <line4> if (logger.isDebugEnabled()) <line5> } <line6> logExit(""ClientTypeDescRepository.remove"", ""typeName"", typeName); <line7> } <line8> } <line9> "	1	task3	
"public class A { <line0> private RouterStatus collectStatus(RouterManagement routerManagement, Pod router) { <line1> try { <line2> int port = 0; <line3> for (Container container : router.getSpec().getContainers()) { <line4> if (container.getName().equals(""router"")) { <line5> for (ContainerPort containerPort : container.getPorts()) { <line6> if (containerPort.getName().equals(""amqps-normal"")) { <line7> port = containerPort.getContainerPort(); <line8> } <line9> } <line10> } <line11> } <line12> if (port != 0) { <line13> Map<RouterEntity, List<List<?>>> response = <line14> routerManagement.query(router.getStatus().getPodIP(), port, entities); <line15> RouterConnections connections = null; <line16> if (response.containsKey(connection)) { <line17> connections = collectConnectionInfo(response.get(connection)); <line18> } <line19> List<String> neighbors = null; <line20> if (response.containsKey(node)) { <line21> neighbors = <line22> filterOnAttribute(String.class, 0, response.get(node)).stream() <line23> .filter(n -> !n.equals(router.getMetadata().getName())) <line24> .collect(Collectors.toList()); <line25> } <line26> long undeliveredTotal = 0; <line27> if (response.containsKey(link)) { <line28> List<String> linkTypes = filterOnAttribute(String.class, 0, response.get(link)); <line29> List<UnsignedLong> undelivered = <line30> filterOnAttribute(UnsignedLong.class, 1, response.get(link)); <line31> for (int i = 0; i < linkTypes.size(); i++) { <line32> if (""inter-router"".equals(linkTypes.get(i))) { <line33> undeliveredTotal += undelivered.get(i) != null ? undelivered.get(i).longValue() : 0; <line34> } <line35> } <line36> } <line37> return new RouterStatus( <line38> router.getMetadata().getName(), connections, neighbors, undeliveredTotal); <line39> } <line40> } catch (Exception e) { <line41> } <line42> return null; <line43> } <line44> } <line45> "	1	task3	
public class A { <line0> @Override <line1> public Authenticator<BasicCredentials, User> build(DSLContext dslContext) { <line2> LdapConnectionFactory connectionFactory = <line3> new LdapConnectionFactory( <line4> getServer(), <line5> getPort(), <line6> getUserDN(), <line7> getPassword(), <line8> getTrustStorePath(), <line9> getTrustStorePassword(), <line10> getTrustStoreType()); <line11> return new LdapAuthenticator(connectionFactory, getLookup()); <line12> } <line13> } <line14> 	1	task3	
"public class A { <line0> @Override <line1> public void handle(HttpExchange he) throws IOException { <line2> Content content; <line3> if (he.getRemoteAddress().getAddress().isLoopbackAddress()) { <line4> try { <line5> content = handlePath(he); <line6> } catch (HttpErrorException e) { <line7> content = handleError(e.status); <line8> } <line9> } else { <line10> content = handleError(Status.FORBIDDEN); <line11> } <line12> Headers headers = he.getResponseHeaders(); <line13> headers.put(""Content-Type"", Arrays.asList(content.type)); <line14> he.sendResponseHeaders(content.status.code, content.body.length); <line15> try (OutputStream os = he.getResponseBody()) { <line16> os.write(content.body); <line17> } <line18> } <line19> } <line20> "	1	task3	
public class A { <line0> @After <line1> public void teardownTest() { <line2> try { <line3> if (configurationProvider != null) configurationProvider.close(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> @Override <line1> public synchronized void error(SchedulerDriver schedulerDriver, String s) { <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> public Boolean getModified(String property) { <line1> return isModified.get(property); <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> protected void onAfterLoadFromMemcached( <line1> @Nonnull final MemcachedBackupSession session, @Nullable final LockStatus lockStatus) { <line2> session.setLockStatus(lockStatus); <line3> final long start = System.currentTimeMillis(); <line4> final SessionValidityInfo info = loadSessionValidityInfo(session.getIdInternal()); <line5> if (info != null) { <line6> _stats.registerSince(NON_STICKY_AFTER_LOAD_FROM_MEMCACHED, start); <line7> session.setLastAccessedTimeInternal(info.getLastAccessedTime()); <line8> session.setThisAccessedTimeInternal(info.getThisAccessedTime()); <line9> } else { <line10> } <line11> } <line12> } <line13> 	1	task3	
public class A { <line0> private void finishSplitAtRecord( <line1> TopicPartition tp, <line2> long stoppingOffset, <line3> long currentOffset, <line4> List<TopicPartition> finishedPartitions, <line5> KafkaPartitionSplitRecords<Tuple3<T, Long, Long>> recordsBySplits) { <line6> finishedPartitions.add(tp); <line7> recordsBySplits.addFinishedSplit(KafkaPartitionSplit.toSplitId(tp)); <line8> } <line9> } <line10> 	1	task3	
public class A { <line0> private void doStartAutoTask() { <line1> if (scheduledFuture != null) { <line2> scheduledFuture.cancel(false); <line3> scheduledFuture = null; <line4> } <line5> int interval = autoCheckIntervalProperty.get(); <line6> if (interval <= 0) { <line7> return; <line8> } <line9> scheduledFuture = taskPool.scheduleAtFixedRate(this::runTask, interval, interval, timeUnit); <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> private <T extends WithId<T>> void validateNoDuplicateName( <line1> final T entity, final String ignoreSelfId) { <line2> if (entity instanceof Connection) { <line3> Connection c = (Connection) entity; <line4> Set<String> ids = fetchIdsByPropertyValue(Connection.class, ""name"", c.getName()); <line5> if (ids != null) { <line6> ids.remove(ignoreSelfId); <line7> if (!ids.isEmpty()) { <line8> throw new EntityExistsException( <line9> ""There already exists a Connection with name "" + c.getName()); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> "	1	task3	
"public class A { <line0> @ExceptionHandler(value = {UpdateException.class}) <line1> protected ResponseEntity<ExceptionInfo> handleUpdateException(UpdateException ex) { <line2> String error = ""An error occurred while updating or getting update infos: "" + ex.getMessage(); <line3> return new ResponseEntity<>( <line4> new ExceptionInfo( <line5> 500, error, ex.getClass().getName(), error, SessionStorage.requestUrl.get()), <line6> HttpStatus.valueOf(500)); <line7> } <line8> } <line9> "	1	task3	
public class A { <line0> @Override <line1> public String toString() { <line2> try { <line3> return toString(getCharacterEncoding()); <line4> } catch (UnsupportedEncodingException unsupportedEncodingException) { <line5> } <line6> return StringPool.BLANK; <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> public BadQueryHistory getBadQueriesForProject(String project) throws IOException { <line1> BadQueryHistory badQueryHistory = <line2> getStore().getResource(getResourcePathForProject(project), BAD_QUERY_INSTANCE_SERIALIZER); <line3> if (badQueryHistory == null) { <line4> badQueryHistory = new BadQueryHistory(project); <line5> } <line6> return badQueryHistory; <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> private int processSingle( <line1> SCE_LFE scelfe, FilterBank filterBank, int channel, Profile profile, SampleFrequency sf) <line2> throws AACException { <line3> final ICStream ics = scelfe.getICStream(); <line4> final ICSInfo info = ics.getInfo(); <line5> final LTPrediction ltp = info.getLTPrediction1(); <line6> final int elementID = scelfe.getElementInstanceTag(); <line7> final float[] iqData = ics.getInvQuantData(); <line8> if (profile.equals(Profile.AAC_MAIN) && info.isICPredictionPresent()) <line9> info.getICPrediction().process(ics, iqData, sf); <line10> if (LTPrediction.isLTPProfile(profile) && info.isLTPrediction1Present()) <line11> ltp.process(ics, iqData, filterBank, sf); <line12> processDependentCoupling(false, elementID, CCE.BEFORE_TNS, iqData, null); <line13> if (ics.isTNSDataPresent()) ics.getTNS().process(ics, iqData, sf, false); <line14> processDependentCoupling(false, elementID, CCE.AFTER_TNS, iqData, null); <line15> filterBank.process( <line16> info.getWindowSequence(), <line17> info.getWindowShape(ICSInfo.CURRENT), <line18> info.getWindowShape(ICSInfo.PREVIOUS), <line19> iqData, <line20> data[channel], <line21> channel); <line22> if (LTPrediction.isLTPProfile(profile)) <line23> ltp.updateState(data[channel], filterBank.getOverlap(channel), profile); <line24> processIndependentCoupling(false, elementID, data[channel], null); <line25> if (ics.isGainControlPresent()) <line26> ics.getGainControl() <line27> .process( <line28> iqData, <line29> info.getWindowShape(ICSInfo.CURRENT), <line30> info.getWindowShape(ICSInfo.PREVIOUS), <line31> info.getWindowSequence()); <line32> int chs = 1; <line33> if (sbrPresent && config.isSBREnabled()) { <line34> if (data[channel].length == config.getFrameLength()) <line35> final SBR sbr = scelfe.getSBR(); <line36> if (sbr.isPSUsed()) { <line37> chs = 2; <line38> scelfe.getSBR()._process(data[channel], data[channel + 1], false); <line39> } else scelfe.getSBR().process(data[channel], false); <line40> } <line41> return chs; <line42> } <line43> } <line44> 	1	task3	
public class A { <line0> @Override <line1> protected void execute(final IMonitoringRecord record) { <line2> this.count++; <line3> this.ctrl.newMonitoringRecord(record); <line4> if ((this.count % 100000) == 0) { <line5> } <line6> } <line7> } <line8> 	1	task3	
"public class A { <line0> public boolean match(final Cookie cookie, final CookieOrigin origin) { <line1> if (cookie == null) { <line2> throw new IllegalArgumentException(""Cookie may not be null""); <line3> } <line4> if (origin == null) { <line5> throw new IllegalArgumentException(""Cookie origin may not be null""); <line6> } <line7> if (cookie instanceof Cookie2) { <line8> Cookie2 cookie2 = (Cookie2) cookie; <line9> int port = origin.getPort(); <line10> if (cookie2.isPortAttributeSpecified()) { <line11> if (cookie2.getPorts() == null) { <line12> return false; <line13> } <line14> if (!portMatch(port, cookie2.getPorts())) { <line15> return false; <line16> } <line17> } <line18> return true; <line19> } else { <line20> return false; <line21> } <line22> } <line23> } <line24> "	1	task3	
"public class A { <line0> @Override <line1> public DistrictInfo extractData(ResultSet rs) throws SQLException { <line2> DistrictInfo districtInfo = new DistrictInfo(); <line3> while (rs.next()) { <line4> DistrictType type = DistrictType.resolveType(rs.getString(""type"")); <line5> if (type != null) { <line6> districtInfo.setDistName(type, rs.getString(""name"")); <line7> districtInfo.setDistCode(type, getDistrictCode(rs)); <line8> districtInfo.setDistMap(type, getDistrictMapFromJson(rs.getString(""map""))); <line9> districtInfo.setDistProximity(type, rs.getDouble(""proximity"")); <line10> } else { <line11> } <line12> } <line13> return districtInfo; <line14> } <line15> } <line16> "	1	task3	
"public class A { <line0> @SuppressWarnings(""squid:S1166"") <line1> public Charset getPartCharset(Part part) throws MessagingException { <line2> String charset = getPartCharsetInternal(part); <line3> try { <line4> return charset == null ? null : Charset.forName(charset); <line5> } catch (UnsupportedCharsetException e) { <line6> return null; <line7> } <line8> } <line9> } <line10> "	1	task3	
public class A { <line0> public Object[] retrieveActivityContextIDByResourceAdaptorEntityName(String entityName) { <line1> return listWithCriteria(false, true, LIST_BY_RAENTITY, entityName); <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @RequestMapping(path = ""/v1/network-utilization"", method = RequestMethod.GET) <line1> public ResponseEntity<Object> getNetworkUtilization(@RequestParam(""ag"") String assetGroup) { <line2> if (Strings.isNullOrEmpty(assetGroup)) { <line3> return ResponseUtils.buildFailureResponse(new Exception(StatsConstants.ERR_MSG_AG_MANDATORY)); <line4> } <line5> ResponseVO response; <line6> try { <line7> response = new ResponseVO(statsService.getNetworkUtilization(assetGroup)); <line8> } catch (Exception e) { <line9> return ResponseUtils.buildFailureResponse(e); <line10> } <line11> return ResponseUtils.buildSucessResponse(response); <line12> } <line13> } <line14> "	1	task3	
"public class A { <line0> @RequestMapping( <line1> value = ""/getCrisesByUserId.action"", <line2> method = {RequestMethod.GET}) <line3> @ResponseBody <line4> public Map<String, Object> getCrisesByUserId() { <line5> try { <line6> String userName = getAuthenticatedUserName(); <line7> Integer taggerUserId = taggerService.isUserExistsByUsername(userName); <line8> if (taggerUserId != null) { <line9> return getUIWrapper(taggerService.getCrisesByUserId(taggerUserId), true); <line10> } else { <line11> return getUIWrapper(false, ""Error while getting all crisis for user in Tagger""); <line12> } <line13> } catch (Exception e) { <line14> return getUIWrapper(false, e.getMessage()); <line15> } <line16> } <line17> } <line18> "	1	task3	
"public class A { <line0> @Override <line1> public void initActivity() { <line2> stride = activityDef.getParams().getOptionalInteger(""stride"").orElse(1); <line3> cluster = createCluster(); <line4> session = createSession(); <line5> bindTimer = ActivityMetrics.timer(activityDef, ""bind""); <line6> executeTimer = ActivityMetrics.timer(activityDef, ""execute""); <line7> resultTimer = ActivityMetrics.timer(activityDef, ""result""); <line8> triesHisto = ActivityMetrics.histogram(activityDef, ""tries""); <line9> logicalGraphOps = ActivityMetrics.timer(activityDef, ""graphops""); <line10> this.opsequence = initSequencer(); <line11> setDefaultsFromOpSequence(this.opsequence); <line12> onActivityDefUpdate(activityDef); <line13> } <line14> } <line15> "	1	task3	
public class A { <line0> private static <S extends Service> void stop(S s) { <line1> try { <line2> s.stop(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	1	task3	
public class A { <line0> @Override <line1> public void doAuthenticationInformationRequestEvent( <line2> ServerS6aSession appSession, JAuthenticationInformationRequest request) <line3> throws InternalException, IllegalDiameterStateException, RouteException, OverloadException { <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> @Override <line1> public void clearProceduresForFeatureOfInterest() { <line2> this.proceduresForFeaturesOfInterest.clear(); <line3> } <line4> } <line5> 	1	task3	
public class A { <line0> public void messageReceived(IoSession session, Readable message) throws Exception { <line1> if (isClosing()) { <line2> } else { <line3> Buffer buffer = new Buffer(); <line4> buffer.putBuffer(message); <line5> out.write(buffer.array(), buffer.rpos(), buffer.available()); <line6> out.flush(); <line7> } <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> @RequestMapping(value = ""/{id}"", method = RequestMethod.DELETE) <line1> public ResponseEntity<Boolean> delete(@PathVariable(""id"") long id) { <line2> roleManagementService.deleteRole(id); <line3> return new ResponseEntity<>(Boolean.TRUE, HttpStatus.OK); <line4> } <line5> } <line6> "	1	task3	
"public class A { <line0> public static TriggerConfiguration createConfiguration( <line1> String jobTriggerStrategy, TriggeredScrapeJobImpl triggeredScrapeJob) <line2> throws ScraperConfigurationException { <line3> Matcher matcher = TRIGGER_STRATEGY_PATTERN.matcher(jobTriggerStrategy); <line4> if (matcher.matches()) { <line5> String triggerStrategy = matcher.group(""strategy""); <line6> String scheduledMs = matcher.group(""scheduledInterval""); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> String triggerVar = matcher.group(""triggerVar""); <line10> String comparatorString = matcher.group(""comp""); <line11> String comparatorVariable = matcher.group(""compVar""); <line12> switch (triggerStrategy) { <line13> case TRIGGER: <line14> if (triggerVar == null || comparatorString == null || comparatorVariable == null) { <line15> throw new ScraperConfigurationException( <line16> ""TRIGGER_VAR trigger strategy needs the trigger-condition - information missing!"" <line17> + "" given configString: "" <line18> + jobTriggerStrategy); <line19> } <line20> List<TriggerElement> triggerElements = new ArrayList<>(); <line21> String connectionString = <line22> triggeredScrapeJob <line23> .getSourceConnections() <line24> .get(triggeredScrapeJob.getSourceConnections().keySet().iterator().next()); <line25> TriggerElement triggerElement = <line26> new TriggerElement( <line27> comparatorString, <line28> null, <line29> comparatorVariable, <line30> triggerVar, <line31> triggerStrategy, <line32> connectionString); <line33> triggerElement.setTriggerJob(triggeredScrapeJob.getJobName()); <line34> triggerElements.add(triggerElement); <line35> String concatConn = matcher.group(""concatConn""); <line36> String triggerVar2 = matcher.group(""triggerVar2""); <line37> String comparatorString2 = matcher.group(""comp2""); <line38> String comparatorVariable2 = matcher.group(""compVar2""); <line39> if (triggerVar2 != null <line40> && comparatorString2 != null <line41> && comparatorVariable2 != null <line42> && concatConn != null) { <line43> TriggerElement triggerElement2 = <line44> new TriggerElement( <line45> comparatorString2, <line46> concatConn, <line47> comparatorVariable2, <line48> triggerVar2, <line49> triggerStrategy, <line50> connectionString); <line51> triggerElement2.setTriggerJob(triggeredScrapeJob.getJobName()); <line52> triggerElements.add(triggerElement2); <line53> } <line54> return new TriggerConfiguration( <line55> TriggerType.TRIGGER_VAR, scheduledMs, triggerElements, triggeredScrapeJob); <line56> case SCHEDULED: <line57> if (triggerVar != null || comparatorString != null || comparatorVariable != null) { <line58> throw new ScraperConfigurationException( <line59> ""SCHEDULED trigger strategy must only be used with scheduled interval - nothing"" <line60> + "" more!  given configString: "" <line61> + jobTriggerStrategy); <line62> } <line63> return new TriggerConfiguration(TriggerType.SCHEDULED, scheduledMs); <line64> default: <line65> throw new ScraperConfigurationException(""Unknown Trigger Strategy "" + triggerStrategy); <line66> } <line67> } <line68> throw new ScraperConfigurationException( <line69> ""Invalid trigger strategy string description: "" + jobTriggerStrategy); <line70> } <line71> } <line72> "	1	task3	
"public class A { <line0> private PlacementDemand buildDemand(String id, ModelInfoMetadata metadata) { <line1> PlacementDemand placementDemand = new PlacementDemand(); <line2> if (isNotBlank(id) && isNotBlank(metadata.getModelInstanceName())) { <line3> placementDemand.setServiceResourceId(id); <line4> placementDemand.setResourceModuleName(metadata.getModelInstanceName()); <line5> placementDemand.setResourceModelInfo(buildModelInfo(metadata)); <line6> } else { <line7> throw new BpmnError(UNPROCESSABLE, RESOURCE_MISSING_DATA + ""modelInstanceName""); <line8> } <line9> return placementDemand; <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> @Override <line1> public void onExpansionEvent(ExpansionEvent arg0) { <line2> } <line3> } <line4> 	1	task3	
"public class A { <line0> @POST <line1> @Path(""{csid}/accountroles"") <line2> public Response createAccountRole( <line3> @Context UriInfo uriInfo, <line4> @QueryParam(""_method"") String method, <line5> @PathParam(""csid"") String accCsid, <line6> AccountRole input) { <line7> if (method != null) { <line8> if (""delete"".equalsIgnoreCase(method)) { <line9> return deleteAccountRole(accCsid, input); <line10> } <line11> } <line12> ensureCSID(accCsid, ServiceMessages.POST_FAILED + ""accountroles account ""); <line13> try { <line14> AccountsCommon account = (AccountsCommon) get(accCsid, AccountsCommon.class); <line15> if (AccountClient.IMMUTABLE.equals(account.getRolesProtection())) { <line16> Response response = <line17> Response.status(Response.Status.FORBIDDEN) <line18> .entity(""Roles for Account: "" + accCsid + "" are immutable."") <line19> .type(""text/plain"") <line20> .build(); <line21> return response; <line22> } <line23> ServiceContext<AccountsCommon, AccountsCommon> ctx = <line24> createServiceContext((AccountsCommon) null, AccountsCommon.class, uriInfo); <line25> ctx.openConnection(); <line26> try { <line27> AccountRoleSubResource subResource = <line28> new AccountRoleSubResource(AccountRoleSubResource.ACCOUNT_ACCOUNTROLE_SERVICE); <line29> String accrolecsid = subResource.createAccountRole(ctx, input, SubjectType.ROLE); <line30> UriBuilder path = UriBuilder.fromResource(AccountResource.class); <line31> path.path(accCsid + ""/accountroles/"" + accrolecsid); <line32> Response response = Response.created(path.build()).build(); <line33> return response; <line34> } finally { <line35> ctx.closeConnection(); <line36> } <line37> } catch (Exception e) { <line38> throw bigReThrow(e, ServiceMessages.POST_FAILED, accCsid); <line39> } <line40> } <line41> } <line42> "	1	task3	
public class A { <line0> public static void addResource(Binder binder, Class<?> resourceClazz) { <line1> Multibinder.newSetBinder(binder, new TypeLiteral<Class<?>>() {}, JSR311Resource.class) <line2> .addBinding() <line3> .toInstance(resourceClazz); <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> public boolean initDevice( <line1> boolean enableAccelerometer, boolean enableGyroscope, boolean enableMagnetometer) { <line2> boolean result = false; <line3> try { <line4> if ((read(ACC_DEVICE, WHO_AM_I_XG) & 0x000000FF) == WHO_AM_I_AG_ID <line5> && (read(MAG_DEVICE, WHO_AM_I_M) & 0x000000FF) == WHO_AM_I_M_ID) { <line6> result = true; <line7> if (enableAccelerometer) { <line8> enableAccelerometer(); <line9> } else { <line10> disableAccelerometer(); <line11> } <line12> if (enableGyroscope) { <line13> enableGyroscope(); <line14> } else { <line15> disableGyroscope(); <line16> } <line17> if (enableMagnetometer) { <line18> enableMagnetometer(); <line19> } else { <line20> disableMagnetometer(); <line21> } <line22> } <line23> } catch (KuraException e) { <line24> } <line25> return result; <line26> } <line27> } <line28> 	1	task3	
"public class A { <line0> public static void warn(Logger log, Object... args) { <line1> if (log.isWarnEnabled()) { <line2> StringBuilder sb = new StringBuilder(); <line3> for (Object o : args) { <line4> sb.append(o).append("", ""); <line5> } <line6> } <line7> } <line8> } <line9> "	1	task3	
public class A { <line0> private void saveChangedElements() { <line1> int number = changedElements.size(); <line2> int i = 0; <line3> for (CnATreeElement element : changedElements) { <line4> getDao().merge(element); <line5> if (i % 50 == 0) { <line6> flushAndClearHibernateSession(); <line7> } <line8> i++; <line9> if (log.isDebugEnabled()) { <line10> } <line11> } <line12> } <line13> } <line14> 	1	task3	
public class A { <line0> @Override <line1> public DetailedGarbageCollectorMetric get() { <line2> DetailedGarbageCollectorMetric detailedGarbageCollectorMetric = null; <line3> Map<String, GarbageCollectorMXBean> garbageCollectorMap = createGarbageCollectorMap(); <line4> for (GarbageCollectorType garbageCollectorType : GarbageCollectorType.values()) { <line5> if (garbageCollectorMap.containsKey(garbageCollectorType.newGenName())) { <line6> GarbageCollectorMXBean garbageCollectorMXBean = <line7> garbageCollectorMap.get(garbageCollectorType.newGenName()); <line8> detailedGarbageCollectorMetric = <line9> new DefaultDetailedGarbageCollectorMetric(garbageCollectorType, garbageCollectorMXBean); <line10> break; <line11> } <line12> } <line13> if (detailedGarbageCollectorMetric == null) { <line14> detailedGarbageCollectorMetric = new UnknownDetailedGarbageCollectorMetric(); <line15> } <line16> return detailedGarbageCollectorMetric; <line17> } <line18> } <line19> 	1	task3	
"public class A { <line0> public static int getFragmentCollectionsCount( <line1> HttpPrincipal httpPrincipal, long groupId, String name) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> FragmentCollectionServiceUtil.class, <line6> ""getFragmentCollectionsCount"", <line7> _getFragmentCollectionsCountParameterTypes17); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, name); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> throw systemException; <line18> } <line19> } <line20> } <line21> "	1	task3	
"public class A { <line0> private void userLoggerInfo(HttpServletRequest request) { <line1> if (!checkUserIsLogin(request)) { <line2> return; <line3> } <line4> String requesturl = getRequestSource(request); <line5> String actiontype = getReqValueByGetUrl(request, ""urltype""); <line6> String actionurl = getReqValueByGetUrl(request, ""url""); <line7> String actiondesc = getReqValueByGetUrl(request, ""desc""); <line8> if (!""menuclick"".equals(actiontype) <line9> && !""jumpmain"".equals(actiontype) <line10> && !""jumpapp"".equals(actiontype)) { <line11> return; <line12> } <line13> String ip = request.getRemoteAddr(); <line14> String xip = request.getHeader(""X-Forwarded-For""); <line15> String time = sdf.format(new Date()); <line16> String userid = getUserIdBySession(request); <line17> String userip = getClientIP(ip, xip); <line18> Map<String, String> userInfo = new HashMap<String, String>(); <line19> userInfo.put(""key"", ""ulog""); <line20> userInfo.put(""time"", time); <line21> userInfo.put(""uid"", userid); <line22> userInfo.put(""uip"", userip); <line23> userInfo.put(""rs"", requesturl); <line24> userInfo.put(""type"", actiontype); <line25> userInfo.put(""url"", actionurl); <line26> userInfo.put(""desc"", actiondesc); <line27> userInfo.put( <line28> ""authemails"", <line29> String.valueOf( <line30> request <line31> .getSession(false) <line32> .getAttribute(""apphub.gui.session.login.user.authorize.emailList""))); <line33> userInfo.put( <line34> ""authsystems"", <line35> String.valueOf( <line36> request <line37> .getSession(false) <line38> .getAttribute(""apphub.gui.session.login.user.authorize.systems""))); <line39> } <line40> } <line41> "	1	task3	
"public class A { <line0> private DDMFormField _getDDMFormField( <line1> BiFunction<List<DDMFormField>, String, DDMFormField> biFunction, <line2> String identifier, <line3> UnsafeBiFunction<DDMStructure, String, DDMFormField, PortalException> unsafeBiFunction) <line4> throws PortalException { <line5> DDMForm ddmForm = _getDDMForm(); <line6> DDMFormField ddmFormField = biFunction.apply(ddmForm.getDDMFormFields(), identifier); <line7> if (ddmFormField != null) { <line8> return ddmFormField; <line9> } <line10> try { <line11> DDMStructure parentDDMStructure = getParentDDMStructure(); <line12> if (parentDDMStructure != null) { <line13> return unsafeBiFunction.apply(parentDDMStructure, identifier); <line14> } <line15> } catch (PortalException portalException) { <line16> } <line17> throw new StructureFieldException(""Unable to find field "" + identifier); <line18> } <line19> } <line20> "	1	task3	
public class A { <line0> private StatementWrapper getInternalBoundStatementWrapper() { <line1> if (LOGGER.isTraceEnabled()) { <line2> } <line3> final PreparedStatement ps = getInternalPreparedStatement(); <line4> BoundValuesWrapper wrapper = <line5> updateStatic == true <line6> ? meta.extractPartitionKeysAndStaticColumnsFromEntity(instance, options) <line7> : meta.extractAllValuesFromEntity(instance, options); <line8> StatementWrapper statementWrapper = wrapper.bindForUpdate(ps); <line9> statementWrapper.applyOptions(options); <line10> return statementWrapper; <line11> } <line12> } <line13> 	1	task3	
public class A { <line0> protected long await(long timeout) throws InterruptedException { <line1> completionLock.lock(); <line2> try { <line3> while (timeout > 0 && scheduledOrRunning.get() > 0) { <line4> timeout = completion.awaitNanos(timeout); <line5> } <line6> } finally { <line7> if (log.isTraceEnabled()) { <line8> } <line9> completionLock.unlock(); <line10> } <line11> return timeout; <line12> } <line13> } <line14> 	1	task3	
"public class A { <line0> public ItemsVO deleteItemsEntry(ItemsVO vo) { <line1> long timerStart = System.currentTimeMillis(); <line2> conf.getDBDAO().doDeleteItemsEntry(vo); <line3> logTime(""deleteItemsEntry"", timerStart, System.currentTimeMillis()); <line4> return vo; <line5> } <line6> } <line7> "	1	task3	
public class A { <line0> @Override <line1> public void resetOrderBy() throws DatabaseException { <line2> this.setOrderByField(this.defaultOrderByField); <line3> this.setOrderByOperator(Operator.SORTASC); <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> private void kmsSigKill() { <line1> if (isKmsRemote) { <line2> String kmsPid = <line3> remoteKmsSshConnection.execAndWaitCommandNoBr( <line4> ""cat"", remoteKmsSshConnection.getTmpFolder() + ""/kms-pid""); <line5> remoteKmsSshConnection.runAndWaitCommand(""sh"", ""-c"", ""kill -9 "" + kmsPid); <line6> } else { <line7> Shell.runAndWait(""sh"", ""-c"", ""kill -9 `cat "" + workspace + File.separator + ""kms-pid`""); <line8> } <line9> } <line10> } <line11> "	1	task3	
public class A { <line0> public void setIsCADIUp(HealthCheckInfo.HealthCheckStatus cadiStatus) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> isCADIUpOrDown = cadiStatus; <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> @Override <line1> public void destroy() { <line2> try { <line3> doSendUnregister(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	1	task3	
public class A { <line0> public long readData(InputStream is, long startPosition, long maxReadSize) throws IOException { <line1> OutputStream out = null; <line2> BufferedInputStream in = null; <line3> setPartStartPosition((int) startPosition); <line4> long readSize = 0; <line5> try { <line6> long skippedBytes = is.skip(startPosition); <line7> if (skippedBytes != startPosition) { <line8> } <line9> in = new BufferedInputStream(is); <line10> out = getCompressedOutputStream(); <line11> int bufferSize = ONE_HUNDRED_KILO_BYTE; <line12> byte[] b = new byte[bufferSize]; <line13> int len; <line14> int maxBufferBoundary; <line15> while ((readSize < maxReadSize || maxReadSize == -1) && (len = in.read(b)) > 0) { <line16> maxBufferBoundary = len; <line17> if (maxReadSize > -1 && readSize + len > maxReadSize) { <line18> maxBufferBoundary = (int) (maxReadSize - readSize); <line19> } <line20> if (maxBufferBoundary < len) { <line21> len = maxBufferBoundary; <line22> } <line23> out.write(b, 0, len); <line24> readSize += len; <line25> } <line26> out.flush(); <line27> m_exists = true; <line28> } finally { <line29> if (out != null) { <line30> out.close(); <line31> } <line32> if (in != null) { <line33> in.close(); <line34> } <line35> } <line36> return getCRC(); <line37> } <line38> } <line39> 	1	task3	
"public class A { <line0> public static String getSyncDLObjectUpdate( <line1> HttpPrincipal httpPrincipal, long repositoryId, long parentFolderId, long lastAccessTime) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SyncDLObjectServiceUtil.class, <line7> ""getSyncDLObjectUpdate"", <line8> _getSyncDLObjectUpdateParameterTypes18); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, repositoryId, parentFolderId, lastAccessTime); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (String) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	1	task3	
public class A { <line0> protected boolean isCustomField(String className, long tableId) { <line1> long classNameId = classNameLocalService.getClassNameId(className); <line2> try { <line3> ExpandoTable expandoTable = expandoTableLocalService.getTable(tableId); <line4> if (Objects.equals(ExpandoTableConstants.DEFAULT_TABLE_NAME, expandoTable.getName()) <line5> && (expandoTable.getClassNameId() == classNameId)) { <line6> return true; <line7> } <line8> } catch (Exception exception) { <line9> if (log.isWarnEnabled()) { <line10> } <line11> } <line12> return false; <line13> } <line14> } <line15> 	1	task3	
public class A { <line0> @Override <line1> public ResponseEntity<PagedRestResponse<ResourceDTO>> listTrashedResources( <line2> String resourceTypeCode, RestListRequest requestList) { <line3> UserDetails userDetails = HttpSessionHelper.extractCurrentUser(httpSession); <line4> PagedMetadata<ResourceDTO> result = <line5> resourcesVersioningService.getTrashedResources(resourceTypeCode, requestList, userDetails); <line6> return new ResponseEntity<>(new PagedRestResponse<>(result), HttpStatus.OK); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> private ErrorCode extractErrorCode(final XPathException xpe) { <line1> final String message = xpe.getMessage(); <line2> if (':' == message.charAt(8)) { <line3> final String[] data = extractLocalName(xpe.getMessage()); <line4> final ErrorCode errorCode = new ErrorCode(data[0], data[1]); <line5> return errorCode; <line6> } <line7> Throwable retVal = xpe; <line8> Throwable cause = xpe.getCause(); <line9> if (cause != null && !(cause instanceof XPathException)) { <line10> retVal = cause; <line11> } <line12> return new ErrorCodes.JavaErrorCode(retVal); <line13> } <line14> } <line15> 	1	task3	
"public class A { <line0> private void readContactList(String parentcsid, String itemcsid) throws Exception { <line1> final String testName = ""readContactList""; <line2> setupReadList(); <line3> PersonClient client = new PersonClient(); <line4> AbstractCommonList list = null; <line5> Response res = client.readContactList(parentcsid, itemcsid); <line6> try { <line7> assertStatusCode(res, testName); <line8> list = res.readEntity(AbstractCommonList.class); <line9> } finally { <line10> if (res != null) { <line11> res.close(); <line12> } <line13> } <line14> List<AbstractCommonList.ListItem> listitems = list.getListItem(); <line15> int nItemsReturned = listitems.size(); <line16> int nExpectedItems = MAX_CONTACTS; <line17> if (logger.isDebugEnabled()) { <line18> } <line19> Assert.assertEquals(nItemsReturned, nExpectedItems); <line20> boolean iterateThroughList = false; <line21> if (iterateThroughList && logger.isDebugEnabled()) { <line22> AbstractCommonListUtils.ListItemsInAbstractCommonList(list, logger, testName); <line23> } <line24> } <line25> } <line26> "	1	task3	
"public class A { <line0> private <R> void coprocssorService( <line1> String serviceName, byte[] startKey, byte[] endKey, Callback<R> callback, StubCall<R> call) <line2> throws Throwable { <line3> ExecutorService pool = this.poolSupplier.get(); <line4> List<byte[]> keys = getStartKeysInRange(startKey, endKey); <line5> Map<byte[], Future<R>> futures = new TreeMap<>(Bytes.BYTES_COMPARATOR); <line6> try { <line7> for (byte[] r : keys) { <line8> RegionCoprocessorRpcChannel channel = coprocessorService(r); <line9> Future<R> future = <line10> pool.submit( <line11> new Callable<R>() { <line12> @Override <line13> public R call() throws Exception { <line14> R result = call.call(channel); <line15> byte[] region = channel.getLastRegion(); <line16> if (callback != null) { <line17> callback.update(region, r, result); <line18> } <line19> return result; <line20> } <line21> }); <line22> futures.put(r, future); <line23> } <line24> } catch (RejectedExecutionException e) { <line25> if (conn.isClosed()) { <line26> throw new DoNotRetryIOException(""Connection is closed"", e); <line27> } else { <line28> throw new HBaseIOException(""Coprocessor operation is rejected"", e); <line29> } <line30> } <line31> for (Map.Entry<byte[], Future<R>> e : futures.entrySet()) { <line32> try { <line33> e.getValue().get(); <line34> } catch (ExecutionException ee) { <line35> throw ee.getCause(); <line36> } catch (InterruptedException ie) { <line37> throw new InterruptedIOException( <line38> ""Interrupted calling coprocessor service "" <line39> + serviceName <line40> + "" for row "" <line41> + Bytes.toStringBinary(e.getKey())) <line42> .initCause(ie); <line43> } <line44> } <line45> } <line46> } <line47> "	1	task3	
"public class A { <line0> private static boolean isOsx0() { <line1> String osname = <line2> SystemPropertyUtil.get(""os.name"", """").toLowerCase(Locale.US).replaceAll(""[^a-z0-9]+"", """"); <line3> boolean osx = osname.startsWith(""macosx"") || osname.startsWith(""osx""); <line4> if (osx) { <line5> } <line6> return osx; <line7> } <line8> } <line9> "	1	task3	
public class A { <line0> @Override <line1> public void dropDimension(LensSessionHandle sessionid, String dimName) throws LensException { <line2> try (SessionContext ignored = new SessionContext(sessionid)) { <line3> getClient(sessionid).dropDimension(dimName); <line4> } <line5> } <line6> } <line7> 	1	task3	
"public class A { <line0> public void reportFailedApiCall( <line1> ApiKey apiKey, int objectTypes, long then, String query, String stackTrace, String reason) { <line2> StringBuilder sb = <line3> new StringBuilder(""module=updateQueue component=updater action=countFailedApiCall"") <line4> .append("" connector="" + connector().getName()) <line5> .append("" objectTypes="" + objectTypes) <line6> .append("" apiKeyId="") <line7> .append(apiKey.getId()) <line8> .append("" guestId="") <line9> .append(apiKey.getGuestId()) <line10> .append("" time="") <line11> .append(ISODateTimeFormat.dateTimeNoMillis().print(then)) <line12> .append("" query="") <line13> .append(query) <line14> .append("" reason=\"""") <line15> .append(reason) <line16> .append(""\"""") <line17> .append("" stackTrace=<![CDATA["") <line18> .append(stackTrace) <line19> .append(""]]>""); <line20> } <line21> } <line22> "	1	task3	
public class A { <line0> private List<TimeSeriesRequestContainer> makeRequests( <line1> Collection<MetricEntity> metrics, long start, long end, Multimap<String, String> filters) { <line2> List<TimeSeriesRequestContainer> requests = new ArrayList<>(); <line3> for (MetricEntity me : metrics) { <line4> Multimap<String, String> jointFilters = ArrayListMultimap.create(); <line5> jointFilters.putAll(filters); <line6> jointFilters.putAll(me.getFilters()); <line7> MetricSlice slice = MetricSlice.from(me.getId(), start, end, jointFilters, this.granularity); <line8> try { <line9> requests.add( <line10> DataFrameUtils.makeTimeSeriesRequestAligned( <line11> slice, me.getUrn(), this.metricDAO, this.datasetDAO)); <line12> } catch (Exception ex) { <line13> } <line14> } <line15> return requests; <line16> } <line17> } <line18> 	1	task3	
public class A { <line0> public String addCommentToCase( <line1> String containerId, <line2> String caseId, <line3> String author, <line4> List<String> restrictions, <line5> String comment, <line6> String marshallingType) { <line7> verifyContainerId(containerId, caseId); <line8> author = getUser(author); <line9> String actualComment = <line10> marshallerHelper.unmarshal( <line11> containerId, <line12> comment, <line13> marshallingType, <line14> String.class, <line15> new ByCaseIdContainerLocator(caseId)); <line16> String commentId = <line17> caseService.addCaseComment( <line18> caseId, author, actualComment, restrictions.toArray(new String[restrictions.size()])); <line19> return marshallerHelper.marshal(containerId, marshallingType, commentId); <line20> } <line21> } <line22> 	1	task3	
public class A { <line0> @Action() <line1> public Turnover $$() { <line2> turnoverAggregationService.aggregate(turnover); <line3> return turnover; <line4> } <line5> } <line6> 	1	task3	
public class A { <line0> public static List<Map<String, Double>> getTopWords(File modelFile, int nWords, boolean normalize) <line1> throws IOException { <line2> ParallelTopicModel model; <line3> try { <line4> model = ParallelTopicModel.read(modelFile); <line5> } catch (Exception e) { <line6> throw new IOException(e); <line7> } <line8> Alphabet alphabet = model.getAlphabet(); <line9> List<Map<String, Double>> topics = new ArrayList<>(model.getNumTopics()); <line10> for (TreeSet<IDSorter> topic : model.getSortedWords()) { <line11> Map<String, Double> topicWords = new HashMap<>(nWords); <line12> for (IDSorter id : topic) { <line13> double weight = normalize ? id.getWeight() / alphabet.size() : id.getWeight(); <line14> String word = (String) alphabet.lookupObject(id.getID()); <line15> topicWords.put(word, weight); <line16> if (topicWords.size() >= nWords) { <line17> break; <line18> } <line19> } <line20> topics.add(topicWords); <line21> } <line22> return topics; <line23> } <line24> } <line25> 	1	task3	
public class A { <line0> public org.talend.mdm.webservice.WSBoolean existsStoredProcedure( <line1> org.talend.mdm.webservice.WSExistsStoredProcedure arg0) { <line2> System.out.println(arg0); <line3> try { <line4> org.talend.mdm.webservice.WSBoolean _return = null; <line5> return _return; <line6> } catch (java.lang.Exception ex) { <line7> ex.printStackTrace(); <line8> throw new RuntimeException(ex); <line9> } <line10> } <line11> } <line12> 	1	task3	
"public class A { <line0> public String fetchSystemConfiguration(final String keyname) { <line1> String query = ""SELECT value FROM cf_SystemConfiguration WHERE keyname =\"""" + keyname + ""\""""; <line2> try { <line3> return rdsepository.queryForString(query); <line4> } catch (Exception exception) { <line5> return StringUtils.EMPTY; <line6> } <line7> } <line8> } <line9> "	1	task3	
public class A { <line0> private boolean nullLockGrantorId(LockGrantorId oldLockGrantorId) { <line1> Assert.assertHoldsLock(this.destroyLock, false); <line2> Assert.assertHoldsLock(this.lockGrantorIdLock, false); <line3> if (oldLockGrantorId == null) { <line4> return false; <line5> } <line6> DLockGrantor grantorToDestroy = null; <line7> try { <line8> synchronized (this.lockGrantorIdLock) { <line9> if (equalsLockGrantorId(oldLockGrantorId) <line10> || (oldLockGrantorId.isLocal(getSerialNumber()) && isMakingLockGrantor())) { <line11> if (oldLockGrantorId.isLocal(getSerialNumber()) <line12> && isLockGrantorVersion(this.grantor, oldLockGrantorId.getLockGrantorVersion())) { <line13> grantorToDestroy = this.grantor; <line14> this.grantor = null; <line15> } <line16> this.lockGrantorId = null; <line17> return true; <line18> } else { <line19> return false; <line20> } <line21> } <line22> } finally { <line23> if (grantorToDestroy != null) { <line24> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line25> } <line26> grantorToDestroy.destroy(); <line27> } <line28> } <line29> } <line30> } <line31> 	1	task3	
"public class A { <line0> @Override <line1> public CollectedUpdateMetrics parse(ContentResponse entity) throws IOException { <line2> String content = entity.getContentAsString(); <line3> String[] lines = content.split(""\\r?\\n""); <line4> CollectedUpdateMetrics collectedUpdateMetrics = extractMetrics(lines); <line5> return collectedUpdateMetrics; <line6> } <line7> } <line8> "	1	task3	
"public class A { <line0> @Test <line1> public void testDeleteWhereOptional() throws Exception { <line2> StringBuilder update = new StringBuilder(); <line3> update.append(getNamespaceDeclarations()); <line4> update.append("" DELETE { ?x foaf:name ?y; foaf:mbox ?mbox. } ""); <line5> update.append("" WHERE {?x foaf:name ?y. ""); <line6> update.append("" OPTIONAL { ?x foaf:mbox ?mbox. FILTER (str(?mbox) = \""bob@example.org\"") } }""); <line7> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update.toString()); <line8> Literal mboxBob = f.createLiteral(""bob@example.org""); <line9> Literal mboxAlice = f.createLiteral(""alice@example.org""); <line10> assertTrue(con.hasStatement(bob, FOAF.MBOX, mboxBob, true)); <line11> assertTrue(con.hasStatement(alice, FOAF.MBOX, mboxAlice, true)); <line12> assertTrue(con.hasStatement(bob, FOAF.NAME, f.createLiteral(""Bob""), true)); <line13> assertTrue(con.hasStatement(alice, FOAF.NAME, f.createLiteral(""Alice""), true)); <line14> operation.execute(); <line15> assertFalse(con.hasStatement(bob, FOAF.MBOX, mboxBob, true)); <line16> assertTrue(con.hasStatement(alice, FOAF.MBOX, mboxAlice, true)); <line17> assertFalse(con.hasStatement(bob, FOAF.NAME, f.createLiteral(""Bob""), true)); <line18> assertFalse(con.hasStatement(alice, FOAF.NAME, f.createLiteral(""Alice""), true)); <line19> } <line20> } <line21> "	1	task3	
public class A { <line0> private void checkFileTTL(TsFileResource resource, long timeLowerBound, boolean isSeq) { <line1> if (resource.isMerging() <line2> || !resource.isClosed() <line3> || !resource.isDeleted() && resource.stillLives(timeLowerBound)) { <line4> return; <line5> } <line6> writeLock(); <line7> try { <line8> resource.setDeleted(true); <line9> if (resource.isMerging()) { <line10> return; <line11> } <line12> if (resource.tryWriteLock()) { <line13> try { <line14> resource.remove(); <line15> if (logger.isInfoEnabled()) { <line16> } <line17> tsFileManagement.remove(resource, isSeq); <line18> } finally { <line19> resource.writeUnlock(); <line20> } <line21> } <line22> } finally { <line23> writeUnlock(); <line24> } <line25> } <line26> } <line27> 	1	task3	
public class A { <line0> @Override <line1> @PreDestroy <line2> public void close() { <line3> super.close(); <line4> try { <line5> indexWriter.close(); <line6> } catch (IOException e) { <line7> } <line8> } <line9> } <line10> 	1	task3	
"public class A { <line0> @Scheduled(fixedDelayString = ""${execInterval}000"") <line1> public void loadDataToNeo4j() { <line2> syncTaskExecutor.execute(runnableTask); <line3> } <line4> } <line5> "	1	task3	
public class A { <line0> @Override <line1> public void protocolReplyReceived(ProtocolCommandEvent event) { <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> @Override <line1> public void afterInvocation(IInvokedMethod iInvokedMethod, ITestResult iTestResult) { <line2> } <line3> } <line4> 	1	task3	
public class A { <line0> @Override <line1> public void close() { <line2> if (statusThread != null) { <line3> statusThread.interrupt(); <line4> statusThread = null; <line5> } <line6> internalStopRiver(); <line7> } <line8> } <line9> 	1	task3	
public class A { <line0> @Override <line1> public void info(I18nResource message, Object... params) { <line2> if (!isInfoEnabled()) return; <line3> if (message == null) return; <line4> } <line5> } <line6> 	1	task3	
"public class A { <line0> @Path(""/getShouldSucceed"") <line1> @POST <line2> public void getShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET); <line4> Region out = <line5> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, REGION_ID, Region.class); <line6> assertNotNull(out); <line7> assertEquals(REGION_ID, out.getId()); <line8> assertEquals(REGION_DESCRIPTION, out.getDescription()); <line9> assertEquals(REGION_PARENTREGIONID, out.getParentRegionId()); <line10> } <line11> } <line12> "	1	task3	
public class A { <line0> public static com.liferay.fragment.model.FragmentCompositionSoap[] getFragmentCompositions( <line1> long fragmentCollectionId, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.fragment.model.FragmentComposition> returnValue = <line4> FragmentCompositionServiceUtil.getFragmentCompositions(fragmentCollectionId, start, end); <line5> return com.liferay.fragment.model.FragmentCompositionSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> @Override <line1> public void onEvent(EndOfStreamEvent event) { <line2> eosLatch.countDown(); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> public static java.util.List<Object> getFileEntriesAndFileShortcuts( <line1> HttpPrincipal httpPrincipal, long repositoryId, long folderId, int status, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLAppServiceUtil.class, <line7> ""getFileEntriesAndFileShortcuts"", <line8> _getFileEntriesAndFileShortcutsParameterTypes32); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, repositoryId, folderId, status, start, end); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<Object>) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	1	task3	
public class A { <line0> public void export( <line1> String surveyName, <line2> String rootEntityName, <line3> Step step, <line4> String targetSchemaName, <line5> Connection targetConn, <line6> RelationalSchemaConfig config, <line7> ProgressListener progressListener) <line8> throws CollectRdbException { <line9> try { <line10> targetConn.setAutoCommit(false); <line11> } catch (SQLException e) { <line12> } <line13> try { <line14> CollectSurvey survey = surveyManager.get(surveyName); <line15> RelationalSchemaGenerator schemaGenerator = new RelationalSchemaGenerator(config); <line16> RelationalSchema relationalSchema = schemaGenerator.generateSchema(survey, targetSchemaName); <line17> RelationalSchemaCreator relationalSchemaCreator = createRelationalSchemaCreator(); <line18> relationalSchemaCreator.createRelationalSchema(relationalSchema, targetConn); <line19> relationalSchemaCreator.addConstraints(relationalSchema, targetConn); <line20> relationalSchemaCreator.addIndexes(relationalSchema, targetConn); <line21> insertData(survey, rootEntityName, step, targetConn, relationalSchema, progressListener); <line22> targetConn.commit(); <line23> if (LOG.isInfoEnabled()) { <line24> } <line25> } catch (Exception e) { <line26> try { <line27> targetConn.rollback(); <line28> } catch (SQLException e1) { <line29> } <line30> throw new RuntimeException(e); <line31> } <line32> } <line33> } <line34> 	1	task3	
public class A { <line0> @Override <line1> public CompletableFuture<Void> leave(final Node localNode) { <line2> return CompletableFuture.completedFuture(null); <line3> } <line4> } <line5> 	1	task3	
"public class A { <line0> @Test <line1> public void testMultipleGatewaysProcess() throws Exception { <line2> kruntime = createKogitoProcessRuntime(""BPMN2-MultipleGatewaysProcess.bpmn2""); <line3> kruntime <line4> .getProcessEventManager() <line5> .addEventListener( <line6> new DefaultKogitoProcessEventListener() { <line7> KogitoProcessInstance pi; <line8>  <line9> @Override <line10> public void afterNodeTriggered(ProcessNodeTriggeredEvent event) { <line11> if (event.getNodeInstance().getNodeName().equals(""CreateAgent"")) { <line12> pi.signalEvent(""Signal_1"", null); <line13> } <line14> } <line15>  <line16> @Override <line17> public void beforeNodeTriggered(ProcessNodeTriggeredEvent event) { <line18> } <line19>  <line20> @Override <line21> public void beforeProcessStarted(ProcessStartedEvent event) { <line22> pi = (KogitoProcessInstance) event.getProcessInstance(); <line23> } <line24> }); <line25> Map<String, Object> params = new HashMap<>(); <line26> params.put(""action"", ""CreateAgent""); <line27> KogitoProcessInstance processInstance = kruntime.startProcess(""multiplegateways"", params); <line28> assertProcessInstanceCompleted(processInstance); <line29> } <line30> } <line31> "	1	task3	
"public class A { <line0> @Override <line1> public void registerWikiComponent(WikiComponent component) throws WikiComponentException { <line2> DocumentReference currentUserReference = <line3> this.wikiComponentManagerContext.getCurrentUserReference(); <line4> EntityReference currentEntityReference = <line5> this.wikiComponentManagerContext.getCurrentEntityReference(); <line6> try { <line7> Type roleType = component.getRoleType(); <line8> Class<?> roleTypeClass = ReflectionUtils.getTypeClass(roleType); <line9> ComponentDescriptor componentDescriptor = <line10> createComponentDescriptor(roleType, component.getRoleHint()); <line11> this.wikiComponentManagerContext.setCurrentUserReference(component.getAuthorReference()); <line12> this.wikiComponentManagerContext.setCurrentEntityReference(component.getEntityReference()); <line13> if (this.isInitializable(component.getClass().getInterfaces())) { <line14> try { <line15> ((Initializable) component).initialize(); <line16> } catch (InitializationException e) { <line17> } <line18> } <line19> getComponentManager(component.getScope()) <line20> .registerComponent(componentDescriptor, roleTypeClass.cast(component)); <line21> cacheWikiComponent(component); <line22> } catch (ComponentLookupException e) { <line23> throw new WikiComponentException( <line24> String.format( <line25> ""Failed to find a component manager for scope [%s] wiki "" <line26> + ""component registration failed"", <line27> component.getScope()), <line28> e); <line29> } catch (ComponentRepositoryException e) { <line30> throw new WikiComponentException( <line31> ""Failed to register wiki component against component repository"", e); <line32> } finally { <line33> this.wikiComponentManagerContext.setCurrentUserReference(currentUserReference); <line34> this.wikiComponentManagerContext.setCurrentEntityReference(currentEntityReference); <line35> } <line36> } <line37> } <line38> "	1	task3	
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void compareAfterWrite(Nd4jBackend backend) throws Exception { <line3> int[] ranksToCheck = new int[] {0, 1, 2, 3, 4}; <line4> for (int i = 0; i < ranksToCheck.length; i++) { <line5> compareArrays(ranksToCheck[i], ordering(), testDir); <line6> } <line7> } <line8> } <line9> "	1	task3	
"public class A { <line0> @Test <line1> public void testNotEqual() throws Exception { <line2> String state = ""'Missouri'""; <line3> String query = <line4> CityField.STATE.name() <line5> + NE_OP <line6> + state <line7> + AND_OP <line8> + CityField.CONTINENT.name() <line9> + RE_OP <line10> + ""'north.*'""; <line11> runCountTest(query); <line12> } <line13> } <line14> "	1	task3	
public class A { <line0> @Override <line1> public void handleLastResult(Result lastResult) { <line2> if (lastResult == null) { <line3> return; <line4> } <line5> Cell[] rawCells = lastResult.rawCells(); <line6> Cell last = rawCells[rawCells.length - 1]; <line7> byte[] row = CellUtil.cloneRow(last); <line8> byte[] originalRow = traceIdRowKeyDistributor.getOriginalKey(row); <line9> long reverseStartTime = <line10> BytesUtils.bytesToLong(originalRow, PinpointConstants.APPLICATION_NAME_MAX_LEN); <line11> this.lastRowTimestamp = TimeUtils.recoveryTimeMillis(reverseStartTime); <line12> byte[] qualifier = CellUtil.cloneQualifier(last); <line13> this.lastTransactionId = <line14> TransactionIdMapper.parseVarTransactionId(qualifier, 0, qualifier.length); <line15> this.lastTransactionElapsed = BytesUtils.bytesToInt(qualifier, 0); <line16> if (logger.isDebugEnabled()) { <line17> } <line18> } <line19> } <line20> 	1	task3	
"public class A { <line0> public static void sendRoom( <line1> final Long roomId, <line2> final JSONObject m, <line3> Predicate<Client> check, <line4> BiFunction<JSONObject, Client, JSONObject> func) { <line5> sendRoom(roomId, (t, c) -> doSend(t, c, m, func, ""room""), check); <line6> } <line7> } <line8> "	1	task3	
"public class A { <line0> public static void configureIndexAndTypes(String ds, List<Map<String, String>> errorList) { <line1> String _payLoad = <line2> ""{\""settings\"" : { \""number_of_shards\"" : 3,\""number_of_replicas\"" : 1 },\""mappings\"": {""; <line3> Set<String> types = ConfigManager.getTypes(ds); <line4> Iterator<String> it = types.iterator(); <line5> while (it.hasNext()) { <line6> String _type = it.next(); <line7> String indexName = ds + ""_"" + _type; <line8> if (!indexExists(indexName)) { <line9> StringBuilder payLoad = new StringBuilder(_payLoad); <line10> payLoad.append( <line11> ""\"""" <line12> + _type <line13> + ""\"":{},\""issue_"" <line14> + _type <line15> + ""\"": { \""_parent\"": {\""type\"": \"""" <line16> + _type <line17> + ""\""}},\""issue_"" <line18> + _type <line19> + ""_audit\"": { \""_parent\"": {\""type\"": \""issue_"" <line20> + _type <line21> + ""\""}},\""issue_"" <line22> + _type <line23> + ""_comment\"": { \""_parent\"": {\""type\"": \""issue_"" <line24> + _type <line25> + ""\""}},\""issue_"" <line26> + _type <line27> + ""_exception\"": { \""_parent\"": {\""type\"": \""issue_"" <line28> + _type <line29> + ""\""}}""); <line30> payLoad.append(""}}""); <line31> try { <line32> invokeAPI(""PUT"", indexName, payLoad.toString()); <line33> } catch (IOException e) { <line34> Map<String, String> errorMap = new HashMap<>(); <line35> errorMap.put(ERROR, ""Error in configureIndexAndTypes""); <line36> errorMap.put(ERROR_TYPE, WARN); <line37> errorMap.put(EXCEPTION, e.getMessage()); <line38> errorList.add(errorMap); <line39> } <line40> } <line41> try { <line42> invokeAPI(""PUT"", ""/"" + indexName + ""/_alias/"" + ds, null); <line43> invokeAPI(""PUT"", ""/"" + indexName + ""/_alias/"" + ""ds-all"", null); <line44> } catch (IOException e) { <line45> } <line46> } <line47> } <line48> } <line49> "	1	task3	
public class A { <line0> @Override <line1> public MBeanServer addingService(ServiceReference<MBeanServer> serviceReference) { <line2> mbeanServerReference = serviceReference; <line3> MBeanServer server = context.getService(serviceReference); <line4> try { <line5> installFilteringRuntimeBean(context, server); <line6> } catch (JMException e) { <line7> } <line8> return server; <line9> } <line10> } <line11> 	1	task3	
public class A { <line0> @Override <line1> public BulkOperationResults<String, TaskanaException> setOwnerOfTasks( <line2> String owner, List<String> argTaskIds) { <line3> BulkOperationResults<String, TaskanaException> bulkLog = new BulkOperationResults<>(); <line4> if (argTaskIds == null || argTaskIds.isEmpty()) { <line5> return bulkLog; <line6> } <line7> List<String> taskIds = argTaskIds.stream().distinct().collect(Collectors.toList()); <line8> final int requestSize = taskIds.size(); <line9> try { <line10> taskanaEngine.openConnection(); <line11> Pair<List<MinimalTaskSummary>, BulkLog> resultsPair = getMinimalTaskSummaries(taskIds); <line12> List<MinimalTaskSummary> existingMinimalTaskSummaries = resultsPair.getLeft(); <line13> taskIds = <line14> existingMinimalTaskSummaries.stream() <line15> .map(MinimalTaskSummary::getTaskId) <line16> .collect(Collectors.toList()); <line17> bulkLog.addAllErrors(resultsPair.getRight()); <line18> if (!taskIds.isEmpty()) { <line19> final int numberOfAffectedTasks = taskMapper.setOwnerOfTasks(owner, taskIds, Instant.now()); <line20> if (numberOfAffectedTasks != taskIds.size()) { <line21> existingMinimalTaskSummaries = taskMapper.findExistingTasks(taskIds, null); <line22> bulkLog.addAllErrors( <line23> addExceptionsForTasksWhoseOwnerWasNotSet(owner, existingMinimalTaskSummaries)); <line24> if (LOGGER.isDebugEnabled()) { <line25> } <line26> } <line27> } <line28> return bulkLog; <line29> } finally { <line30> taskanaEngine.returnConnection(); <line31> } <line32> } <line33> } <line34> 	1	task3	
"public class A { <line0> protected static void checkConnection(int numRetries, Iterable<? extends Entity> nodes) <line1> throws ConnectionException { <line2> CassandraNode first = (CassandraNode) Iterables.get(nodes, 0); <line3> String uniqueName = Identifiers.makeRandomId(8); <line4> AstyanaxSample astyanaxFirst = <line5> AstyanaxSample.builder().node(first).columnFamilyName(uniqueName).build(); <line6> Map<String, List<String>> versions; <line7> AstyanaxContext<Cluster> context = astyanaxFirst.newAstyanaxContextForCluster(); <line8> try { <line9> versions = context.getEntity().describeSchemaVersions(); <line10> } finally { <line11> context.shutdown(); <line12> } <line13> if (versions.size() > 1) { <line14> Assert.fail(""Inconsistent versions on Cassandra start: "" + versions); <line15> } <line16> String keyspacePrefix = ""BrooklynTests_"" + Identifiers.makeRandomId(8); <line17> String keyspaceName = astyanaxFirst.writeData(keyspacePrefix, numRetries); <line18> for (Entity node : nodes) { <line19> AstyanaxSample astyanaxSecond = <line20> AstyanaxSample.builder().node((CassandraNode) node).columnFamilyName(uniqueName).build(); <line21> astyanaxSecond.readData(keyspaceName, numRetries); <line22> } <line23> } <line24> } <line25> "	1	task3	
"public class A { <line0> protected ClientResource sendRegistrationRequest(User user, Boolean dryRun) { <line1> ClientResource clientResource = createClientResource(regUrl, true); <line2> addCredentialsIfAny(clientResource); <line3> if (dryRun) { <line4> addHeaderAttribute(clientResource, ""dryRun"", ""true""); <line5> } <line6> writeRequestInfoToLog(clientResource); <line7> try { <line8> clientResource.post(user); <line9> } catch (ResourceException e) { <line10> } <line11> return clientResource; <line12> } <line13> } <line14> "	<line10>	task4	
"public class A { <line0> protected void loadQrelsFile() { <line1> List<QrelsHashSet> vector = new ArrayList<QrelsHashSet>(); <line2> int linenumber = 0; <line3> String file = null; <line4> try { <line5> int qrelsCounter = 0; <line6> BufferedReader br = Files.openFileReader(file = fqrels[0].toString()); <line7> String preQueryid = ""1st""; <line8> linenumber = 0; <line9> QrelsHashSet qrelsHashSet = null; <line10> String str = null; <line11> while ((str = br.readLine()) != null || qrelsCounter != fqrels.length - 1) { <line12> if (str == null) { <line13> br.close(); <line14> br = Files.openFileReader(file = fqrels[++qrelsCounter].toString()); <line15> linenumber = 0; <line16> continue; <line17> } <line18> linenumber++; <line19> if (str.startsWith(""#"")) continue; <line20> if (str.trim().length() == 0) continue; <line21> StringTokenizer stk = new StringTokenizer(str); <line22> String queryid = parseTRECQueryNo(stk.nextToken()); <line23> stk.nextToken(); <line24> String docno = stk.nextToken(); <line25> int relGrade = Integer.parseInt(stk.nextToken()); <line26> boolean relevant = (relGrade > 0); <line27> if (!queryid.equals(preQueryid)) { <line28> if (preQueryid.equals(""1st"")) { <line29> qrelsHashSet = new QrelsHashSet(queryid); <line30> if (relevant) { <line31> qrelsHashSet.insertRelDocno(docno, relGrade); <line32> } else qrelsHashSet.insertNonRelDocno(docno); <line33> preQueryid = queryid; <line34> } else { <line35> vector.add((QrelsHashSet) qrelsHashSet.clone()); <line36> qrelsHashSet = new QrelsHashSet(queryid); <line37> if (relevant) qrelsHashSet.insertRelDocno(docno, relGrade); <line38> else qrelsHashSet.insertNonRelDocno(docno); <line39> preQueryid = queryid; <line40> } <line41> } else { <line42> if (relevant) qrelsHashSet.insertRelDocno(docno, relGrade); <line43> else qrelsHashSet.insertNonRelDocno(docno); <line44> } <line45> } <line46> vector.add((QrelsHashSet) qrelsHashSet.clone()); <line47> br.close(); <line48> } catch (Exception t) { <line49> throw new Error(t); <line50> } <line51> this.qrelsPerQuery = vector.toArray(new QrelsHashSet[vector.size()]); <line52> this.totalNumberOfRelevantDocs = 0; <line53> for (QrelsHashSet querySet : this.qrelsPerQuery) { <line54> this.qid2qrels.put(querySet.queryid, querySet); <line55> this.totalNumberOfRelevantDocs += querySet.getAllRelevantDocuments().size(); <line56> } <line57> } <line58> } <line59> "	<line49>	task4	
"public class A { <line0> @Then(""^I wait (\\d+) seconds$"") <line1> public void iWaitXSeconds(final Integer seconds) { <line2> try { <line3> Thread.sleep(seconds * 1000); <line4> } catch (final InterruptedException e) { <line5> Thread.currentThread().interrupt(); <line6> } <line7> } <line8> } <line9> "	<line5>	task4	
"public class A { <line0> public static void fail(Exception e) { <line1> Assert.fail(""Failing because of exception.""); <line2> } <line3> } <line4> "	<line1>	task4	
public class A { <line0> @Override <line1> public void onScanEnded() { <line2> if (createdMethodCount > 0) { <line3> } <line4> } <line5> } <line6> 	<line3>	task4	
public class A { <line0> private static org.apache.hadoop.fs.Path getSystemDir(Configuration conf) throws IOException { <line1> try { <line2> return HadoopDataSourceUtil.getSystemDir(conf, true); <line3> } catch (IOException e) { <line4> org.apache.hadoop.fs.Path raw = HadoopDataSourceUtil.getSystemDir(conf, false); <line5> return raw; <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
"public class A { <line0> @Override <line1> @PutMapping(CommonConstants.PATH_ID) <line2> @Secured(ServicesData.ROLE_UPDATE_USERS) <line3> public UserDto update( <line4> final @PathVariable(""id"") String id, final @Valid @RequestBody UserDto dto) { <line5> SanityChecker.check(id); <line6> Assert.isTrue( <line7> StringUtils.equals(id, dto.getId()), <line8> ""Unable to update user : the DTO id must match the path id""); <line9> return userExternalService.update(dto); <line10> } <line11> } <line12> "	<line5>	task4	
public class A { <line0> @Override <line1> public void setPermission(INodeAuthorizationInfo node, FsPermission permission) { <line2> if (isSentryManaged(node)) { <line3> } <line4> defaultAuthzProvider.setPermission(node, permission); <line5> } <line6> } <line7> 	<line3>	task4	
"public class A { <line0> private String createUrl() { <line1> try { <line2> String scopeIdParam = ""scopeId="" + itNetwork.getScopeId(); <line3> String titleParam = ""itNetwork="" + URLEncoder.encode(itNetwork.getTitle(), ""UTF-8""); <line4> return ""/dashboard/"" <line5> + getTemplateFile() <line6> + ""?"" <line7> + scopeIdParam <line8> + ""&"" <line9> + titleParam <line10> + getStrategyParam(); <line11> } catch (UnsupportedEncodingException e) { <line12> } <line13> return """"; <line14> } <line15> } <line16> "	<line12>	task4	
public class A { <line0> private static void checkConnection(String dbFile) { <line1> try { <line2> Connection connection = connections.get(dbFile); <line3> if (connection.isClosed()) initializeConnection(dbFile); <line4> } catch (SQLException e) { <line5> throw new RuntimeException(e); <line6> } <line7> } <line8> } <line9> 	<line3>	task4	
public class A { <line0> @Override <line1> public void setProcessor(Processor newProcessor) throws ProcessorException { <line2> Processor oldProcessor = getProcessor(); <line3> super.setProcessor(newProcessor); <line4> for (WebSocketResource resource : resources) { <line5> if (oldProcessor != null) { <line6> resource.unselectProcessor(); <line7> } <line8> if (newProcessor != null) { <line9> resource.selectProcessor(newProcessor); <line10> } <line11> } <line12> } <line13> } <line14> 	<line2>	task4	
public class A { <line0> @Override <line1> public void write(Message message) throws Exception { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> write(Collections.singletonList(message)); <line5> } <line6> } <line7> 	<line3>	task4	
public class A { <line0> public static String generateCidFromAddrSpec(String addrSpec) { <line1> String cid = CID_URL_SCHEME; <line2> try { <line3> cid += URLEncoder.encode(addrSpec, StandardCharsets.UTF_8.name()); <line4> } catch (UnsupportedEncodingException e) { <line5> } <line6> return cid; <line7> } <line8> } <line9> 	<line5>	task4	
"public class A { <line0> public EntityManager load(UUID appId) { <line1> EntityManager entityManager = _getEntityManager(appId); <line2> Application app = null; <line3> Throwable throwable = null; <line4> try { <line5> app = entityManager.getApplication(); <line6> } catch (Throwable t) { <line7> throwable = t; <line8> } <line9> if (CpNamingUtils.MANAGEMENT_APPLICATION_ID.equals(appId)) { <line10> if (app != null) { <line11> managementAppEntityManager = entityManager; <line12> } else if (managementAppEntityManager != null) { <line13> entityManager = managementAppEntityManager; <line14> } <line15> } <line16> final boolean isBootstrapping; <line17> if (throwable instanceof CollectionRuntimeException) { <line18> CollectionRuntimeException cre = (CollectionRuntimeException) throwable; <line19> isBootstrapping = cre.isBootstrapping(); <line20> } else { <line21> isBootstrapping = false; <line22> } <line23> if (app != null && app.getName() == null) { <line24> throw new RuntimeException(""Name is null for application "" + appId, throwable); <line25> } <line26> if (app == null && !isBootstrapping) { <line27> throw new RuntimeException(""Error getting application "" + appId, throwable); <line28> } <line29> return entityManager; <line30> } <line31> } <line32> "	<line14>	task4	
public class A { <line0> public void onNewMessage(ChannelHandlerContext ctx, Message message) { <line1> } <line2> } <line3> 	<line1>	task4	
"public class A { <line0> private static synchronized void checkIfNeeded() { <line1> if (Time.hasElapsedSince(lastSudoCheckTime, Duration.FIVE_MINUTES)) { <line2> try { <line3> lastSudoResult = <line4> new ProcessTool() <line5> .execCommands( <line6> MutableMap.<String, Object>of(), Arrays.asList(BashCommands.sudo(""date""))) <line7> == 0; <line8> } catch (Exception e) { <line9> lastSudoResult = false; <line10> } <line11> lastSudoCheckTime = System.currentTimeMillis(); <line12> } <line13> } <line14> } <line15> "	<line10>	task4	
public class A { <line0> @Override <line1> public String toString() { <line2> try { <line3> final long pos = m_offset * 8 + m_pos; <line4> final StringBuilder sb = new StringBuilder(); <line5> setPosition(0); <line6> for (long l = 0; l < m_length; l++) { <line7> sb.append(getBit()); <line8> } <line9> setPosition(pos); <line10> return sb.toString(); <line11> } catch (IOException e) { <line12> return (e.getMessage()); <line13> } <line14> } <line15> } <line16> 	<line12>	task4	
public class A { <line0> public String getPath() { <line1> String clusterName = _params[0]; <line2> String[] subKeys = Arrays.copyOfRange(_params, 1, _params.length); <line3> String path = PropertyPathBuilder.getPath(_type, clusterName, subKeys); <line4> if (path == null) { <line5> } <line6> return path; <line7> } <line8> } <line9> 	<line5>	task4	
"public class A { <line0> @Override <line1> public void render(DriverRequest originalRequest, String content, Writer outWriter) <line2> throws IOException, HttpErrorPage { <line3> if (name != null) { <line4> } <line5> this.out = outWriter; <line6> if (content == null) { <line7> return; <line8> } <line9> StringBuilder contentWithoutComments = new StringBuilder(Parameters.DEFAULT_BUFFER_SIZE); <line10> parserComments.setHttpRequest(originalRequest); <line11> parserComments.parse(content, contentWithoutComments); <line12> parser.setHttpRequest(originalRequest); <line13> parser.parse(contentWithoutComments, this); <line14> if (name != null && !this.found) { <line15> throw new HttpErrorPage( <line16> HttpStatus.SC_BAD_GATEWAY, <line17> ""Fragment "" + name + "" not found"", <line18> ""Fragment "" + name + "" not found""); <line19> } <line20> } <line21> } <line22> "	<line4>	task4	
"public class A { <line0> @RequestMapping(""/statistics"") <line1> @ResponseBody <line2> public String getCollectionStatistics() throws Exception { <line3> Map<String, Object> result = new HashMap<>(); <line4> ObjectMapper mapper = new ObjectMapper(); <line5> try { <line6> result = getUIWrapper(collectionService.getCollectionStatistics(), true); <line7> } catch (Exception e) { <line8> result = <line9> getUIWrapper( <line10> false, <line11> ""System is down or under maintenance. For further inquiries please contact admin.""); <line12> } <line13> return ""jsonp("" + mapper.writeValueAsString(result) + "")""; <line14> } <line15> } <line16> "	<line8>	task4	
"public class A { <line0> @Override <line1> public void delete(PostgresPersistenceManager<J> pm, J entityId) throws NoSuchEntityException { <line2> AbstractTableMultiDatastreams<J> tMd = tableCollection.getTableMultiDatastreams(); <line3> AbstractTableMultiDatastreamsObsProperties<J> tMdOp = <line4> tableCollection.getTableMultiDatastreamsObsProperties(); <line5> long count = <line6> pm.getDslContext() <line7> .delete(tMd) <line8> .where( <line9> tMd.getId() <line10> .in( <line11> DSL.select(tMdOp.getMultiDatastreamId()) <line12> .from(tMdOp) <line13> .where(tMdOp.getObsPropertyId().eq(entityId)))) <line14> .execute(); <line15> count = pm.getDslContext().delete(table).where(table.getId().eq(entityId)).execute(); <line16> if (count == 0) { <line17> throw new NoSuchEntityException(""ObservedProperty "" + entityId + "" not found.""); <line18> } <line19> } <line20> } <line21> "	<line15>	task4	
"public class A { <line0> @Path(""/group/{groupPath}/meta"") <line1> @GET <line2> public String getGroupMeta(@PathParam(""groupPath"") String group) <line3> throws EngineException, JsonProcessingException { <line4> if (!group.startsWith(""/"")) group = ""/"" + group; <line5> GroupContents contents = groupsMan.getContents(group, GroupContents.METADATA); <line6> return mapper.writeValueAsString(contents.getGroup()); <line7> } <line8> } <line9> "	<line4>	task4	
public class A { <line0> @Override <line1> public void delete(ScriptVersionKey scriptVersionKey) { <line2> String deleteStatement = deleteStatement(scriptVersionKey); <line3> getMetadataRepository().executeUpdate(deleteStatement); <line4> } <line5> } <line6> 	<line2>	task4	
public class A { <line0> @Override <line1> public Response toResponse(CloudConfigurationNotFoundException e) { <line2> RequestError error = new RequestError(); <line3> ServiceException value = new ServiceException(); <line4> value.setMessageId(ErrorNumbers.SVC_GENERAL_SERVICE_ERROR); <line5> value.setText(e.getMessage()); <line6> error.setServiceException(value); <line7> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(error).build(); <line8> } <line9> } <line10> 	<line2>	task4	
public class A { <line0> private Iterable<Result<TitanElement>> execute(ElementCategory resultType) { <line1> Preconditions.checkNotNull(indexName); <line2> Preconditions.checkNotNull(query); <line3> if (tx.hasModifications()) <line4> Iterable<RawQuery.Result> result = <line5> serializer.executeQuery(this, resultType, tx.getTxHandle(), tx); <line6> final Function<Object, ? extends TitanElement> conversionFct = <line7> tx.getConversionFunction(resultType); <line8> return Iterables.filter( <line9> Iterables.transform( <line10> result, <line11> new Function<RawQuery.Result, Result<TitanElement>>() { <line12> @Nullable <line13> @Override <line14> public Result<TitanElement> apply(@Nullable RawQuery.Result result) { <line15> return new ResultImpl<TitanElement>( <line16> conversionFct.apply(result.getResult()), result.getScore()); <line17> } <line18> }), <line19> new Predicate<Result<TitanElement>>() { <line20> @Override <line21> public boolean apply(@Nullable Result<TitanElement> r) { <line22> return !r.getElement().isRemoved(); <line23> } <line24> }); <line25> } <line26> } <line27> 	<line4>	task4	
"public class A { <line0> public void listen( <line1> String address, <line2> int mqttPort, <line3> int wsPort, <line4> String username, <line5> String password, <line6> boolean allow_zero_byte_client_id) { <line7> try { <line8> this.address = (address == null) ? ""0.0.0.0"" : address; <line9> this.mqttPort = mqttPort; <line10> this.wsPort = wsPort; <line11> this.username = username; <line12> this.password = password; <line13> this.allow_zero_byte_client_id = allow_zero_byte_client_id; <line14> if (listening) { <line15> info(""broker already started - stop first to start again""); <line16> return; <line17> } <line18> Properties props = new Properties(); <line19> props.setProperty(""port"", mqttPort + """"); <line20> props.setProperty(""websocket_port"", wsPort + """"); <line21> props.setProperty(""host"", address); <line22> props.setProperty(""password_file"", passwordFilePath); <line23> if (username != null && username.length() > 0) { <line24> saveIdentities(); <line25> props.setProperty(""allow_anonymous"", ""false""); <line26> } else { <line27> props.setProperty(""allow_anonymous"", ""true""); <line28> } <line29> props.setProperty( <line30> ""allow_zero_byte_client_id"", String.format(""%b"", allow_zero_byte_client_id)); <line31> props.setProperty(""netty.mqtt.message_size"", ""1048576""); <line32> MemoryConfig mc = new MemoryConfig(props); <line33> Collections.singletonList(this); <line34> mqttBroker.startServer(mc, Collections.singletonList(this)); <line35> listening = true; <line36> broadcastState(); <line37> } catch (Exception e) { <line38> error(e); <line39> } <line40> } <line41> } <line42> "	<line37>	task4	
"public class A { <line0> public String appRes(String mesgKey) { <line1> String value = """"; <line2> try { <line3> ResourceBundle res = rcontext_.getApplicationResourceBundle(); <line4> value = res.getString(mesgKey); <line5> } catch (MissingResourceException ex) { <line6> if (PropertyManager.isDevelopping()) <line7> if (mesgKey != null) value = mesgKey.substring(mesgKey.lastIndexOf('.') + 1); <line8> } <line9> return value; <line10> } <line11> } <line12> "	<line7>	task4	
"public class A { <line0> @PreAuthorize(""hasRole('"" + IdRepoEntitlement.ANYTYPE_UPDATE + ""')"") <line1> public AnyTypeTO update(final AnyTypeTO anyTypeTO) { <line2> AnyType anyType = anyTypeDAO.find(anyTypeTO.getKey()); <line3> if (anyType == null) { <line4> throw new NotFoundException(anyTypeTO.getKey()); <line5> } <line6> binder.update(anyType, anyTypeTO); <line7> return binder.getAnyTypeTO(anyTypeDAO.save(anyType)); <line8> } <line9> } <line10> "	<line4>	task4	
"public class A { <line0> private RequestInfo buildRequestInfo(String requestId, String timeout) { <line1> RequestInfo requestInfo = new RequestInfo(); <line2> if (requestId != null) { <line3> String host = env.getProperty(""mso.workflow.message.endpoint""); <line4> String callbackUrl = <line5> host <line6> + ""/"" <line7> + UriUtils.encodePathSegment(""SNIROResponse"", ""UTF-8"") <line8> + ""/"" <line9> + UriUtils.encodePathSegment(requestId, ""UTF-8""); <line10> Duration d = Duration.parse(timeout); <line11> requestInfo.setTransactionId(requestId); <line12> requestInfo.setRequestId(requestId); <line13> requestInfo.setCallbackUrl(callbackUrl); <line14> requestInfo.setRequestType(""create""); <line15> requestInfo.setTimeout(d.getSeconds()); <line16> } else { <line17> throw new BpmnError(UNPROCESSABLE, ""Request Context does not contain: requestId""); <line18> } <line19> return requestInfo; <line20> } <line21> } <line22> "	<line1>	task4	
"public class A { <line0> public boolean assignVariableValueFromInput( <line1> final String variableName, final String inputVariableLocalName, final BPELPlan buildPlan) { <line2> final Element propertyAssignElement = buildPlan.getBpelMainSequencePropertyAssignElement(); <line3> final Element copyElement = <line4> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""copy""); <line5> final Element fromElement = <line6> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""from""); <line7> fromElement.setAttribute(""part"", ""payload""); <line8> fromElement.setAttribute(""variable"", ""input""); <line9> final Element queryElement = <line10> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""query""); <line11> queryElement.setAttribute(""queryLanguage"", ""urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0""); <line12> queryElement.appendChild( <line13> buildPlan <line14> .getBpelDocument() <line15> .createCDATASection(""//*[local-name()='"" + inputVariableLocalName + ""']/text()"")); <line16> fromElement.appendChild(queryElement); <line17> final Element toElement = <line18> buildPlan.getBpelDocument().createElementNS(BPELPlan.bpelNamespace, ""to""); <line19> toElement.setAttribute(""variable"", variableName); <line20> copyElement.appendChild(fromElement); <line21> copyElement.appendChild(toElement); <line22> propertyAssignElement.appendChild(copyElement); <line23> return true; <line24> } <line25> } <line26> "	<line23>	task4	
public class A { <line0> public boolean finished() { <line1> if (caller.isShutdown() && log.isTraceEnabled()) { <line2> } <line3> return caller.isShutdown() || (currentRange == null && lastSeenKey == null); <line4> } <line5> } <line6> 	<line2>	task4	
public class A { <line0> @Override <line1> public void onSuccess(Void obj, HttpHeaders responseHeaders) { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> protected static void writeError(String msg) { <line1> if (LOG.isErrorEnabled()) { <line2> } <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> @Override <line1> public void removeSystemProperty(TInfo info, TCredentials c, String property) <line2> throws ThriftSecurityException { <line3> if (!manager.security.canPerformSystemActions(c)) <line4> throw new ThriftSecurityException(c.getPrincipal(), SecurityErrorCode.PERMISSION_DENIED); <line5> try { <line6> SystemPropUtil.removeSystemProperty(manager.getContext(), property); <line7> updatePlugins(property); <line8> } catch (Exception e) { <line9> throw new RuntimeException(e.getMessage()); <line10> } <line11> } <line12> } <line13> 	<line9>	task4	
public class A { <line0> protected void startRegion(int i) throws Exception { <line1> String regionName = REGION_PREFIX + i; <line2> regionNameToIndexMap.put(regionName, i); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> List<PubSubServer> serversList = new LinkedList<PubSubServer>(); <line6> for (int j = 0; j < numServersPerRegion; j++) { <line7> HedwigSocketAddress a = regionHubAddresses.get(i).get(j); <line8> PubSubServer s = <line9> new PubSubServer( <line10> getServerConfiguration(a.getPort(), a.getSSLPort(), regionName), <line11> getRegionClientConfiguration()); <line12> serversList.add(s); <line13> s.start(); <line14> } <line15> regionServersMap.put(regionName, serversList); <line16> HedwigClient regionClient = <line17> new HedwigClient( <line18> getClientConfiguration( <line19> regionHubAddresses.get(i).get(0).getPort(), <line20> regionHubAddresses.get(i).get(0).getSSLPort())); <line21> regionClientsMap.put(regionName, regionClient); <line22> } <line23> } <line24> 	<line4>	task4	
public class A { <line0> @Override <line1> public void close() throws IOException { <line2> checkJournalWriterOpen(); <line3> mOutputStream.close(); <line4> completeLog(mCurrentLog, mNextSequenceNumber); <line5> } <line6> } <line7> 	<line4>	task4	
public class A { <line0> public void run() { <line1> TLSServer.serve(); <line2> setStatus(ServerStatus.STOPPED); <line3> } <line4> } <line5> 	<line3>	task4	
"public class A { <line0> private void initializeServantsFromProperties(Properties ejbServants) throws ResourceException { <line1> deregisterServants(bus); <line2> try { <line3> Enumeration<?> keys = ejbServants.keys(); <line4> while (keys.hasMoreElements()) { <line5> String theJNDIName = (String) keys.nextElement(); <line6> String value = (String) ejbServants.get(theJNDIName); <line7> EJBServantConfig config = new EJBServantConfig(theJNDIName, value); <line8> EJBEndpoint ejbEndpoint = new EJBEndpoint(config); <line9> ejbEndpoint.setEjbServantBaseURL(mcf.getEJBServantBaseURL()); <line10> ejbEndpoint.setWorkManager(getWorkManager()); <line11> Server servant = ejbEndpoint.publish(); <line12> synchronized (servantsCache) { <line13> if (servant != null) { <line14> servantsCache.add(servant); <line15> } <line16> } <line17> } <line18> } catch (Exception e) { <line19> e.printStackTrace(); <line20> throw new ResourceException(new Message(""FAIL_TO_START_EJB_SERVANTS"", BUNDLE).toString(), e); <line21> } <line22> } <line23> } <line24> "	<line2>	task4	
public class A { <line0> private void checkInstalled(boolean force) { <line1> if (!force && userDao.count() > 0) { <line2> } <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> private void statisticJob(final int runningCount) { <line1> Optional<JobRunningStatistics> latestOne = repository.findLatestJobRunningStatistics(); <line2> latestOne.ifPresent(this::fillBlankIfNeeded); <line3> JobRunningStatistics jobRunningStatistics = <line4> new JobRunningStatistics( <line5> runningCount, StatisticTimeUtils.getCurrentStatisticTime(EXECUTE_INTERVAL)); <line6> repository.add(jobRunningStatistics); <line7> } <line8> } <line9> 	<line6>	task4	
"public class A { <line0> void createIndex(SqlgGraph sqlgGraph, SchemaTable schemaTable, String name) { <line1> StringBuilder sql = new StringBuilder(""CREATE ""); <line2> if (IndexType.UNIQUE.equals(getIndexType())) { <line3> sql.append(""UNIQUE ""); <line4> } <line5> sql.append(""INDEX ""); <line6> SqlDialect sqlDialect = sqlgGraph.getSqlDialect(); <line7> sql.append(sqlDialect.maybeWrapInQoutes(name)); <line8> sql.append("" ON ""); <line9> sql.append(sqlDialect.maybeWrapInQoutes(schemaTable.getSchema())); <line10> sql.append("".""); <line11> sql.append(sqlDialect.maybeWrapInQoutes(schemaTable.getTable())); <line12> if (this.indexType.isGIN()) { <line13> sql.append("" USING GIN""); <line14> } <line15> sql.append("" (""); <line16> List<PropertyColumn> props = getProperties(); <line17> if (IndexType.GIN_FULLTEXT.equals(getIndexType().getName())) { <line18> sql.append(""to_tsvector(""); <line19> String conf = indexType.getProperties().get(IndexType.GIN_CONFIGURATION); <line20> if (conf != null) { <line21> sql.append(""'"").append(conf).append(""'""); <line22> sql.append("",""); <line23> } <line24> int count = 1; <line25> for (PropertyColumn property : props) { <line26> sql.append(sqlDialect.maybeWrapInQoutes(property.getName())); <line27> if (count++ < props.size()) { <line28> sql.append("" || ' ' || ""); <line29> } <line30> } <line31> sql.append("")""); <line32> } else { <line33> int count = 1; <line34> for (PropertyColumn property : props) { <line35> sql.append(sqlDialect.maybeWrapInQoutes(property.getName())); <line36> if (property.getPropertyType().isString() <line37> && sqlgGraph.getSqlDialect().requiresIndexLengthLimit()) { <line38> sql.append(""(191)""); <line39> } <line40> if (count++ < props.size()) { <line41> sql.append("", ""); <line42> } <line43> } <line44> } <line45> sql.append("")""); <line46> if (sqlDialect.needsSemicolon()) { <line47> sql.append("";""); <line48> } <line49> if (logger.isDebugEnabled()) { <line50> } <line51> Connection conn = sqlgGraph.tx().getConnection(); <line52> try (Statement stmt = conn.createStatement()) { <line53> stmt.execute(sql.toString()); <line54> } catch (SQLException e) { <line55> throw new RuntimeException(e); <line56> } <line57> } <line58> } <line59> "	<line50>	task4	
public class A { <line0> private CellMappingStrategy loadStrategyFromClassName(String strategyClassName) { <line1> ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); <line2> if (classLoader != null) { <line3> try { <line4> Class<?> clazz = classLoader.loadClass(strategyClassName); <line5> return (CellMappingStrategy) clazz.newInstance(); <line6> } catch (Throwable e) { <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	<line7>	task4	
"public class A { <line0> @Override <line1> public String description() { <line2> try { <line3> return this.delegate.description(); <line4> } catch (Exception e) { <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> return """"; <line9> } <line10> } <line11> "	<line6>	task4	
public class A { <line0> private void sendBatch(List<QueuedRequest> requests) { <line1> StreamingGetDataRequest batchedRequest = flushToBatch(requests); <line2> synchronized (this) { <line3> for (QueuedRequest request : requests) { <line4> Verify.verify(pending.put(request.id, request.responseStream) == null); <line5> } <line6> try { <line7> send(batchedRequest); <line8> } catch (IllegalStateException e) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>	task4	
public class A { <line0> protected void serializeContextToSoapHeader( <line1> final WebServiceMessage message, final Channel channel) { <line2> if (message instanceof SoapMessage) { <line3> final SoapMessage soapMessage = (SoapMessage) message; <line4> final TraceeFilterConfiguration filterConfiguration = backend.getConfiguration(profile); <line5> if (!backend.isEmpty() && filterConfiguration.shouldProcessContext(channel)) { <line6> final SoapHeader soapHeader = soapMessage.getSoapHeader(); <line7> if (soapHeader != null) { <line8> final Map<String, String> context = <line9> filterConfiguration.filterDeniedParams(backend.copyToMap(), channel); <line10> soapHeaderTransport.renderSoapHeader(context, soapHeader.getResult()); <line11> } <line12> } <line13> } else { <line14> } <line15> } <line16> } <line17> 	<line14>	task4	
public class A { <line0> @Test <line1> public void alertDetailsThreadIdMatchesLoggingThreadId() { <line2> long threadId = <line3> memberVM.invoke( <line4> () -> { <line5> return Thread.currentThread().getId(); <line6> }); <line7> managerVM.invoke( <line8> () -> { <line9> assertThat(captureAlertDetails().getTid()).isEqualTo(threadId); <line10> }); <line11> } <line12> } <line13> 	<line5>	task4	
public class A { <line0> public void stepEnded(ConstructionHeuristicStepScope<Solution_> stepScope) { <line1> super.stepEnded(stepScope); <line2> entityPlacer.stepEnded(stepScope); <line3> decider.stepEnded(stepScope); <line4> if (logger.isDebugEnabled()) { <line5> long timeMillisSpent = stepScope.getPhaseScope().calculateSolverTimeMillisSpentUpToNow(); <line6> } <line7> } <line8> } <line9> 	<line6>	task4	
"public class A { <line0> private void _initializeJasperVersion() { <line1> Class<?> clazz = getClass(); <line2> URL url = clazz.getResource(""/org/apache/jasper/JasperException.class""); <line3> if (url == null) { <line4> return; <line5> } <line6> String path = url.getPath(); <line7> int pos = path.indexOf(CharPool.EXCLAMATION); <line8> if (pos == -1) { <line9> return; <line10> } <line11> try (JarFile jarFile = new JarFile(new File(new URI(path.substring(0, pos))))) { <line12> Manifest manifest = jarFile.getManifest(); <line13> Attributes attributes = manifest.getMainAttributes(); <line14> if (attributes.containsKey(Attributes.Name.SPECIFICATION_VERSION)) { <line15> _jasperVersion = <line16> GetterUtil.getString(attributes.getValue(Attributes.Name.SPECIFICATION_VERSION)); <line17> if (_isValidJasperVersion(_jasperVersion)) { <line18> return; <line19> } <line20> } <line21> if (attributes.containsKey(Attributes.Name.IMPLEMENTATION_VERSION)) { <line22> _jasperVersion = <line23> GetterUtil.getString(attributes.get(Attributes.Name.IMPLEMENTATION_VERSION)); <line24> if (_isValidJasperVersion(_jasperVersion)) { <line25> return; <line26> } <line27> } <line28> Attributes.Name bundleVersionAttributesName = new Attributes.Name(""Bundle-Version""); <line29> if (attributes.containsKey(bundleVersionAttributesName)) { <line30> _jasperVersion = GetterUtil.getString(attributes.get(bundleVersionAttributesName)); <line31> if (_isValidJasperVersion(_jasperVersion)) { <line32> return; <line33> } <line34> _jasperVersion = StringPool.BLANK; <line35> } <line36> } catch (Exception exception) { <line37> } <line38> } <line39> } <line40> "	<line37>	task4	
public class A { <line0> @Override <line1> public void eventOccurred(RetryingEvent eventArg) { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Override <line1> public boolean start() throws IOException { <line2> try { <line3> drive = source.getDriveService(); <line4> utils = source.getDriveUtils(); <line5> } catch (GeneralSecurityException e) { <line6> result.toMap().put(GoogleDriveCopyDefinition.RETURN_ERROR_MESSAGE, e.getMessage()); <line7> throw new ComponentException(e); <line8> } <line9> return true; <line10> } <line11> } <line12> 	<line6>	task4	
public class A { <line0> @Override <line1> public void run() { <line2> putMsg.resetRecipients(); <line3> putMsg.setRecipient(msg.getSender()); <line4> putMsg.setSendDelta(false); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> dm.putOutgoing(putMsg); <line8> try { <line9> PartitionedRegion.getPRFromId(putMsg.regionId).getCachePerfStats().incDeltaFullValuesSent(); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	<line6>	task4	
public class A { <line0> public void setTorsoSpeed(Double topStom, Double midStom, Double lowStom) { <line1> if (torso != null) { <line2> torso.setSpeed(topStom, midStom, lowStom); <line3> } else { <line4> } <line5> } <line6> } <line7> 	<line4>	task4	
public class A { <line0> @Override <line1> public void initChannel(Channel connectedChannel) throws Exception { <line2> if (initRoutine != null) { <line3> try { <line4> initRoutine.run(); <line5> } catch (Throwable initError) { <line6> connectionFailed(connectedChannel, IOExceptionSupport.create(initError)); <line7> throw initError; <line8> } <line9> } <line10> configureChannel(connectedChannel); <line11> } <line12> } <line13> 	<line6>	task4	
public class A { <line0> private void registerSystemMBeans() { <line1> try { <line2> addMBean(new ObjectName(SystemInfo.OBJECT_NAME), new org.exist.management.impl.SystemInfo()); <line3> } catch (final MalformedObjectNameException | DatabaseConfigurationException e) { <line4> } <line5> } <line6> } <line7> 	<line4>	task4	
public class A { <line0> @Override <line1> public BrokerResponse get() throws InterruptedException, ExecutionException { <line2> try { <line3> return get(1000L, TimeUnit.DAYS); <line4> } catch (TimeoutException e) { <line5> throw new InterruptedException(); <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
"public class A { <line0> @PostConstruct <line1> public void init() { <line2> attributes = Attributes.getComponentAttributesFromFacesConfig(UINotify.class, getClass()); <line3> attributes.setAttribute(""detail"", DEFAULT_DETAIL); <line4> attributes.setAttribute(""rendered"", true); <line5> attributes.setAttribute(""showCloseButton"", true); <line6> attributes.setAttribute(""stayTime"", 100000); <line7> attributes.setAttribute(""summary"", DEFAULT_SUMMARY); <line8> } <line9> } <line10> "	<line2>	task4	
"public class A { <line0> public void onPageDrop(DragDropEvent event) { <line1> int toStripeIndex = getDropStripeIndex(event); <line2> if (toStripeIndex == -1 || !dragStripeIndexMatches(event)) { <line3> return; <line4> } <line5> GalleryStripe toStripe = stripes.get(toStripeIndex); <line6> List<Pair<View, IncludedStructuralElement>> viewsToBeMoved = new ArrayList<>(); <line7> for (Pair<MediaUnit, IncludedStructuralElement> selectedElement : <line8> dataEditor.getSelectedMedia()) { <line9> for (View view : selectedElement.getValue().getViews()) { <line10> if (Objects.equals(view.getMediaUnit(), selectedElement.getKey())) { <line11> viewsToBeMoved.add(new ImmutablePair<>(view, selectedElement.getValue())); <line12> } <line13> } <line14> } <line15> int toMediaIndex = getMediaIndex(event); <line16> try { <line17> updateData(toStripe, viewsToBeMoved, toMediaIndex); <line18> } catch (Exception e) { <line19> PrimeFaces.current().executeScript(""$('#loadingScreen').hide();""); <line20> PrimeFaces.current().executeScript(""PF('corruptDataWarning').show();""); <line21> } <line22> dataEditor.getStructurePanel().show(); <line23> dataEditor.getPaginationPanel().show(); <line24> updateAffectedStripes(toStripe, viewsToBeMoved); <line25> } <line26> } <line27> "	<line3>	task4	
"public class A { <line0> private void flush(Batch batch) throws IOException { <line1> if (batch == null) { <line2> return; <line3> } <line4> batch.seal(); <line5> try { <line6> emittedBatchCounter.awaitBatchEmitted( <line7> batch.batchNumber, config.getFlushTimeOut(), TimeUnit.MILLISECONDS); <line8> } catch (TimeoutException e) { <line9> String message = <line10> String.format(""Timed out after [%d] millis during flushing"", config.getFlushTimeOut()); <line11> throw new IOException(message, e); <line12> } catch (InterruptedException e) { <line13> Thread.currentThread().interrupt(); <line14> throw new IOException(""Thread Interrupted while flushing"", e); <line15> } <line16> } <line17> } <line18> "	<line13>	task4	
public class A { <line0> private ArrayList<RefCCDAValidationResult> validateFileImplementation( <line1> String validationObjective, <line2> String referenceFileName, <line3> String ccdaFile, <line4> String vocabularyConfig, <line5> SeverityLevel severityLevel) <line6> throws SAXException { <line7> ArrayList<RefCCDAValidationResult> results = null; <line8> if (ccdaFile != null) { <line9> final XPathIndexer xpathIndexer = new XPathIndexer(); <line10> trackXPathsInXML(xpathIndexer, ccdaFile); <line11> try { <line12> results = doValidation(ccdaFile, xpathIndexer, vocabularyConfig, severityLevel); <line13> } catch (IOException e) { <line14> e.printStackTrace(); <line15> } <line16> } <line17> return results; <line18> } <line19> } <line20> 	<line12>	task4	
"public class A { <line0> @RequestMapping(method = RequestMethod.DELETE, value = ""/api/textunits/{textUnitId}"") <line1> public void deleteTMTextUnitCurrentVariant(@PathVariable Long textUnitId) { <line2> tmTextUnitCurrentVariantService.removeCurrentVariant(textUnitId); <line3> } <line4> } <line5> "	<line2>	task4	
public class A { <line0> public Object[] retrieveActivityContextIDByActivityType(String fullQualifiedActivityClassName) { <line1> return listWithCriteria(true, true, LIST_BY_ACTIVITY_CLASS, fullQualifiedActivityClassName); <line2> } <line3> } <line4> 	<line1>	task4	
"public class A { <line0> private void updateReportTime() { <line1> reportModulo = activityDef.getParams().getOptionalLong(""modulo"").orElse(10000000L); <line2> lastUpdate = System.currentTimeMillis() - calculateOffset(slot, activityDef); <line3> quantizedInterval = calculateInterval(activityDef); <line4> } <line5> } <line6> "	<line4>	task4	
public class A { <line0> protected Map<Address, byte[]> unserializeKeys( <line1> Address sender, byte[] buf, int offset, int length) { <line2> Map<Address, byte[]> map = new HashMap<>(); <line3> ByteArrayDataInputStream in = new ByteArrayDataInputStream(buf, offset, length); <line4> try { <line5> int num_keys = in.readInt(); <line6> for (int i = 0; i < num_keys; i++) { <line7> Address mbr = Util.readAddress(in); <line8> int len = in.readInt(); <line9> byte[] key = new byte[len]; <line10> in.readFully(key, 0, key.length); <line11> map.put(mbr, key); <line12> } <line13> } catch (Exception ex) { <line14> } <line15> return map; <line16> } <line17> } <line18> 	<line14>	task4	
public class A { <line0> protected synchronized void addRecord(String id) throws IOException { <line1> writer.append(id); <line2> writer.newLine(); <line3> writer.flush(); <line4> } <line5> } <line6> 	<line4>	task4	
public class A { <line0> @Override <line1> public int run(final Configuration config, final PropertyManagement runTimeProperties) <line2> throws Exception { <line3> for (int i = 0; i < runners.length; i++) { <line4> final MapReduceJobRunner runner = runners[i]; <line5> final int status = runner.run(config, runTimeProperties); <line6> if (status != 0) { <line7> return status; <line8> } <line9> runSetUpTasks[i].runTask(config, runner); <line10> } <line11> return 0; <line12> } <line13> } <line14> 	<line5>	task4	
"public class A { <line0> private static RestconfDocumentedException dataMissing(final String identifier) { <line1> return new RestconfDocumentedException( <line2> ""Request could not be completed because the relevant data model content "" <line3> + ""does not exist"", <line4> ErrorType.APPLICATION, <line5> ErrorTag.DATA_MISSING); <line6> } <line7> } <line8> "	<line1>	task4	
public class A { <line0> private void stopSystem() { <line1> EnumWriteChannel contactorControlChannel = this.channel(ChannelId.BMS_CONTACTOR_CONTROL); <line2> Optional<Integer> contactorControlOpt = contactorControlChannel.value().asOptional(); <line3> if (contactorControlOpt.isPresent() <line4> && contactorControlOpt.get() == ContactorControl.CUT_OFF.getValue()) { <line5> return; <line6> } <line7> try { <line8> contactorControlChannel.setNextWriteValue(SYSTEM_OFF); <line9> this.isStopping = true; <line10> } catch (OpenemsNamedException e) { <line11> } <line12> } <line13> } <line14> 	<line11>	task4	
public class A { <line0> public void loadAll(List<Contract> contracts, List<MappedContract> mpContracts) { <line1> if (mpContracts != null) { <line2> for (MappedContract mpContract : mpContracts) { <line3> mappedContracts.putIfAbsent( <line4> mpContract.getGbpContractId(), mpContract.getFaasSecurityRulesId()); <line5> } <line6> } <line7> if (contracts != null) { <line8> for (Contract contract : contracts) { <line9> ulnDatastoreUtil.submitSecurityGroupsToDs(initSecurityGroupBuilder(contract).build()); <line10> } <line11> } <line12> } <line13> } <line14> 	<line9>	task4	
public class A { <line0> @Override <line1> public void cacheOffer(long timestamp, Offer offer) { <line2> if (!useOfferCache.get()) { <line3> schedulerClient.decline(Collections.singletonList(offer.getId())); <line4> return; <line5> } <line6> offerCache.put(offer.getId().getValue(), new CachedOffer(offer)); <line7> } <line8> } <line9> 	<line6>	task4	
public class A { <line0> public static com.liferay.document.library.kernel.model.DLFileEntryTypeSoap getFileEntryType( <line1> long fileEntryTypeId) throws RemoteException { <line2> try { <line3> com.liferay.document.library.kernel.model.DLFileEntryType returnValue = <line4> DLFileEntryTypeServiceUtil.getFileEntryType(fileEntryTypeId); <line5> return com.liferay.document.library.kernel.model.DLFileEntryTypeSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>	task4	
public class A { <line0> public int getIntProperty(String key) { <line1> String s = getProperty(key); <line2> int value = -1; <line3> if (!isBlank(s)) { <line4> try { <line5> value = Integer.parseInt(s.trim()); <line6> } catch (NumberFormatException e) { <line7> } <line8> } <line9> return value; <line10> } <line11> } <line12> 	<line7>	task4	
public class A { <line0> protected Result greedyPvalue(Result prevResult, int minGeneSetSize, int maxGeneSetSize) { <line1> Apfloat pValue = Apfloat.ONE; <line2> int geneSetCount = 0; <line3> HashSet<GeneSet> genesetSet = new HashSet<GeneSet>(); <line4> if (prevResult.getGeneSets() != null) genesetSet.addAll(prevResult.getGeneSets()); <line5> start = new Date(); <line6> latest = new Date(); <line7> Result best = new Result(prevResult); <line8> best.setPvalue(1.0); <line9> for (GeneSet geneSet : geneSets) { <line10> if ((geneSet.getGeneCount() > 0) <line11> && ((genesetSet == null) || (!genesetSet.contains(geneSet))) <line12> && (geneSet.getGeneCount() >= minGeneSetSize) <line13> && (geneSet.getGeneCount() <= maxGeneSetSize)) { <line14> List<GeneSet> geneSetListNew = new LinkedList<GeneSet>(); <line15> if (genesetSet != null) geneSetListNew.addAll(genesetSet); <line16> geneSetListNew.add(geneSet); <line17> pValue = pValue(geneSetListNew); <line18> if ((pValue.compareTo(Apfloat.ZERO) > 0) && (pValue.compareTo(best.getPvalue()) < 0)) <line19> best.set(geneSetListNew, pValue); <line20> showProgress(geneSetListNew, pValue, best); <line21> geneSetCount++; <line22> } <line23> } <line24> best.addGeneSetCount(geneSetCount); <line25> return best; <line26> } <line27> } <line28> 	<line25>	task4	
public class A { <line0> public static JsonNode validateIfNodeIsTextual(JsonNode node) { <line1> if (node != null <line2> && !node.isNull() <line3> && node.isTextual() <line4> && StringUtils.isNotEmpty(node.asText())) { <line5> try { <line6> node = validateIfNodeIsTextual(objectMapper.readTree(node.asText())); <line7> } catch (Exception e) { <line8> } <line9> } <line10> return node; <line11> } <line12> } <line13> 	<line8>	task4	
"public class A { <line0> private void rewritePropertiesToFile(Properties props, File propsFile) throws IOException { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(""#Generated by the VcapPropertyLoader\n""); <line3> sb.append(""#"").append(new Date().toString()).append(""\n""); <line4> for (Object key : props.keySet()) { <line5> sb.append(key).append(""="").append(props.getProperty(key.toString())).append(""\n""); <line6> } <line7> FileUtils.writeStringToFile(propsFile, sb + ""\n"", false); <line8> } <line9> } <line10> "	<line8>	task4	
"public class A { <line0> public String generateId(String p_idType, String p_idPrefix) { <line1> final IdType idType = IdType.fromString(p_idType); <line2> if (idType != null) { <line3> return generateId(idType, p_idPrefix); <line4> } else { <line5> } <line6> return """"; <line7> } <line8> } <line9> "	<line5>	task4	
public class A { <line0> @VisibleForTesting <line1> public static void registerGauges(final UfsManager ufsManager, final InodeTree inodeTree) { <line2> MetricsSystem.registerGaugeIfAbsent( <line3> MetricKey.MASTER_FILES_PINNED.getName(), inodeTree::getPinnedSize); <line4> MetricsSystem.registerGaugeIfAbsent( <line5> MetricKey.MASTER_FILES_TO_PERSIST.getName(), () -> inodeTree.getToBePersistedIds().size()); <line6> MetricsSystem.registerGaugeIfAbsent( <line7> MetricKey.MASTER_TOTAL_PATHS.getName(), inodeTree::getInodeCount); <line8> MetricsSystem.registerGaugeIfAbsent( <line9> MetricKey.MASTER_FILE_SIZE.getName(), <line10> () -> <line11> StreamSupport.stream( <line12> inodeTree <line13> .getFileSizeHistogram() <line14> .logarithmicBucketValues(1024, 1024) <line15> .spliterator(), <line16> false) <line17> .map( <line18> x -> <line19> new Pair<>( <line20> new Pair<>( <line21> x.getDoubleValueIteratedFrom(), x.getDoubleValueIteratedTo()), <line22> x.getCountAddedInThisIterationStep())) <line23> .collect(Collectors.toMap(Pair::getFirst, Pair::getSecond))); <line24> final String ufsDataFolder = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS); <line25> MetricsSystem.registerGaugeIfAbsent( <line26> MetricKey.CLUSTER_ROOT_UFS_CAPACITY_TOTAL.getName(), <line27> () -> { <line28> try (CloseableResource<UnderFileSystem> ufsResource = <line29> ufsManager.getRoot().acquireUfsResource()) { <line30> UnderFileSystem ufs = ufsResource.get(); <line31> return ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_TOTAL); <line32> } catch (IOException e) { <line33> LOG.error(e.getMessage(), e); <line34> return Stream.empty(); <line35> } <line36> }); <line37> MetricsSystem.registerGaugeIfAbsent( <line38> MetricKey.CLUSTER_ROOT_UFS_CAPACITY_USED.getName(), <line39> () -> { <line40> try (CloseableResource<UnderFileSystem> ufsResource = <line41> ufsManager.getRoot().acquireUfsResource()) { <line42> UnderFileSystem ufs = ufsResource.get(); <line43> return ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_USED); <line44> } catch (IOException e) { <line45> LOG.error(e.getMessage(), e); <line46> return Stream.empty(); <line47> } <line48> }); <line49> MetricsSystem.registerGaugeIfAbsent( <line50> MetricKey.CLUSTER_ROOT_UFS_CAPACITY_FREE.getName(), <line51> () -> { <line52> long ret = 0L; <line53> try (CloseableResource<UnderFileSystem> ufsResource = <line54> ufsManager.getRoot().acquireUfsResource()) { <line55> UnderFileSystem ufs = ufsResource.get(); <line56> ret = ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_FREE); <line57> } catch (IOException e) { <line58> } <line59> return ret; <line60> }); <line61> } <line62> } <line63> 	<line58>	task4	
public class A { <line0> public static Map<String, String> parseReplicas(Optional<String> json) { <line1> try { <line2> return json.isPresent() ? MAP_READER.readValue(json.get()) : Collections.emptyMap(); <line3> } catch (IOException e) { <line4> throw new IllegalArgumentException(e); <line5> } <line6> } <line7> } <line8> 	<line4>	task4	
"public class A { <line0> public void getData(File toFile) throws IOFailure, ArgumentNotValid { <line1> ArgumentNotValid.checkNotNull(toFile, ""toFile""); <line2> if (theRemoteFile == null) { <line3> throw new IOFailure(""No remoteFile in this message.""); <line4> } <line5> theRemoteFile.copyTo(toFile); <line6> try { <line7> theRemoteFile.cleanup(); <line8> } catch (IOFailure e) { <line9> } <line10> theRemoteFile = null; <line11> } <line12> } <line13> "	<line9>	task4	
public class A { <line0> public static String[] trimAll(String[] v) { <line1> String[] t = new String[v.length]; <line2> for (int i = 0; i < v.length; i++) { <line3> t[i] = v[i].trim(); <line4> if (t[i].length() == 0) { <line5> } <line6> } <line7> return t; <line8> } <line9> } <line10> 	<line5>	task4	
"public class A { <line0> @Override <line1> public void onError(final Throwable th) { <line2> myInstance.setStatus(InstanceStatus.ERROR); <line3> if (th != null) { <line4> myInstance.updateErrors(TypedCloudErrorInfo.fromException(th)); <line5> LOG.warnAndDebugDetails( <line6> ""An error occurred: "" <line7> + th.getLocalizedMessage() <line8> + "" during processing "" <line9> + myInstance.getName(), <line10> th); <line11> th.printStackTrace(); <line12> } else { <line13> myInstance.updateErrors( <line14> new TypedCloudErrorInfo( <line15> ""Unknown error during processing instance "" + myInstance.getName())); <line16> } <line17> } <line18> } <line19> "	<line16>	task4	
public class A { <line0> public boolean checkExists(SchedulerJobHandle handle) throws LensException { <line1> try { <line2> return scheduler.checkExists(JobKey.jobKey(handle.getHandleIdString(), LENS_JOBS)); <line3> } catch (SchedulerException e) { <line4> return false; <line5> } <line6> } <line7> } <line8> 	<line4>	task4	
"public class A { <line0> @SneakyThrows <line1> public static boolean metricsAvailable( <line2> FileSystem fs, String filePath, String datasetId, Integer attempt, String metricsFile) { <line3> String path = String.join(""/"", filePath, datasetId, attempt.toString(), metricsFile); <line4> Path metrics = new Path(path); <line5> return fs.exists(metrics); <line6> } <line7> } <line8> "	<line5>	task4	
public class A { <line0> private void putApnsClientForVariantID(final String variantID, final ApnsClient apnsClient) { <line1> final ApnsClient client = apnsClientExpiringMap.putIfAbsent(variantID, apnsClient); <line2> if (client != null) { <line3> tearDownApnsHttp2Connection(apnsClient); <line4> } <line5> } <line6> } <line7> 	<line3>	task4	
"public class A { <line0> public void addGridSet(GridSet gridSet) { <line1> getConfigurations().stream() <line2> .filter(c -> c.canSave(gridSet)) <line3> .findFirst() <line4> .orElseThrow( <line5> () -> <line6> new UnsupportedOperationException( <line7> ""No Configuration is able to save gridset "" + gridSet.getName())) <line8> .addGridSet(gridSet); <line9> } <line10> } <line11> "	<line1>	task4	
public class A { <line0> public static com.liferay.portal.kernel.model.UserSoap updateScreenName( <line1> long userId, String screenName) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.User returnValue = <line4> UserServiceUtil.updateScreenName(userId, screenName); <line5> return com.liferay.portal.kernel.model.UserSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	<line7>	task4	
"public class A { <line0> @Override <line1> public void finish() { <line2> try { <line3> os.write(appendXmlStartTag(rootNode).getBytes()); <line4> for (String xml : xmlRecords) { <line5> os.write(appendXmlStartTag(recordNode).getBytes()); <line6> os.write(xml.getBytes()); <line7> os.write(appendXmlEndingTag(rootNode).getBytes()); <line8> } <line9> os.write(appendXmlEndingTag(rootNode).getBytes()); <line10> os.write(""\n"".getBytes()); <line11> } catch (IOException e) { <line12> } <line13> } <line14> } <line15> "	<line12>	task4	
public class A { <line0> @Override <line1> public ResourceModel processResourceModel( <line2> ResourceModel resourceModel, Configuration configuration) { <line3> final List<Resource> resources = new ArrayList<>(); <line4> for (Resource resource : resourceModel.getResources()) { <line5> resources.add(resource); <line6> resources.addAll(findChildResources(resource)); <line7> } <line8> logResources(resources); <line9> return resourceModel; <line10> } <line11> } <line12> 	<line3>	task4	
"public class A { <line0> @DELETE <line1> @Timed <line2> @Path(""{id}"") <line3> @Consumes(APPLICATION_JSON) <line4> @RolesAllowed({""admin"", ""$owner=$graph $action=vertex_delete""}) <line5> public void delete( <line6> @Context GraphManager manager, <line7> @PathParam(""graph"") String graph, <line8> @PathParam(""id"") String idValue, <line9> @QueryParam(""label"") String label) { <line10> Id id = checkAndParseVertexId(idValue); <line11> HugeGraph g = graph(manager, graph); <line12> commit( <line13> g, <line14> () -> { <line15> try { <line16> g.removeVertex(label, id); <line17> } catch (NotFoundException e) { <line18> throw new IllegalArgumentException( <line19> String.format(""No such vertex with id: '%s', %s"", id, e)); <line20> } catch (NoSuchElementException e) { <line21> throw new IllegalArgumentException(String.format(""No such vertex with id: '%s'"", id)); <line22> } <line23> }); <line24> } <line25> } <line26> "	<line10>	task4	
public class A { <line0> private void log(String msg) { <line1> } <line2> } <line3> 	<line1>	task4	
public class A { <line0> public void removeFilterByKey(Object key) { <line1> IUserFilterState filter = m_filterMap.remove(key); <line2> fireFilterRemoved(filter); <line3> } <line4> } <line5> 	<line3>	task4	
"public class A { <line0> @Bean(destroyMethod = ""stop"", name = ""wsCoreInboundDomainResponsesConnectionFactory"") <line1> public ConnectionFactory connectionFactory() { <line2> return this.jmsConfigurationFactory.getPooledConnectionFactory(); <line3> } <line4> } <line5> "	<line2>	task4	
"public class A { <line0> private static NativeImageBuildRunner getNativeImageBuildRunner( <line1> NativeConfig nativeConfig, <line2> Path outputDir, <line3> String nativeImageName, <line4> String resultingExecutableName) { <line5> if (!isContainerBuild(nativeConfig)) { <line6> NativeImageBuildLocalRunner localRunner = <line7> getNativeImageBuildLocalRunner(nativeConfig, outputDir.toFile()); <line8> if (localRunner != null) { <line9> return localRunner; <line10> } <line11> String executableName = getNativeImageExecutableName(); <line12> String errorMessage = <line13> ""Cannot find the `"" <line14> + executableName <line15> + ""` in the GRAALVM_HOME, JAVA_HOME and System PATH. Install it using `gu install"" <line16> + "" native-image`""; <line17> if (!SystemUtils.IS_OS_LINUX) { <line18> throw new RuntimeException(errorMessage); <line19> } <line20> } <line21> if (nativeConfig.remoteContainerBuild) { <line22> return new NativeImageBuildRemoteContainerRunner( <line23> nativeConfig, outputDir, nativeImageName, resultingExecutableName); <line24> } <line25> return new NativeImageBuildLocalContainerRunner(nativeConfig, outputDir); <line26> } <line27> } <line28> "	<line20>	task4	
"public class A { <line0> private String createBitarchiveAppId() throws UnknownID { <line1> String id; <line2> id = SystemUtils.getLocalIP(); <line3> try { <line4> String applicationInstanceId = Settings.get(CommonSettings.APPLICATION_INSTANCE_ID); <line5> if (!applicationInstanceId.isEmpty()) { <line6> id += ""_"" + applicationInstanceId; <line7> } <line8> } catch (UnknownID e) { <line9> } <line10> return id; <line11> } <line12> } <line13> "	<line9>	task4	
"public class A { <line0> protected void logLife(Game game) { <line1> StringBuilder sb = new StringBuilder(); <line2> sb.append(game.getTurn().getValue(game.getTurnNum())); <line3> for (Player player : game.getPlayers().values()) { <line4> sb.append(""[player "") <line5> .append(player.getName()) <line6> .append(':') <line7> .append(player.getLife()) <line8> .append(']'); <line9> } <line10> } <line11> } <line12> "	<line10>	task4	
public class A { <line0> public void start(BundleContext bundleContext) throws Exception { <line1> } <line2> } <line3> 	<line1>	task4	
"public class A { <line0> @Managed(description = ""Sets time in nanoseconds"") <line1> public void setKeepAliveTime(final long time) { <line2> getThreadPool().setKeepAliveTime(time, TimeUnit.NANOSECONDS); <line3> if (log.isInfoEnabled()) { <line4> } <line5> } <line6> } <line7> "	<line4>	task4	
public class A { <line0> @Override <line1> protected void doStart() throws Exception { <line2> super.doStart(); <line3> for (Lifecycle lifecycle : lifecycleCallable()) { <line4> if (lifecycle.getLifecycleState().canStart()) { <line5> try { <line6> lifecycle.start(); <line7> } catch (Throwable th) { <line8> if (!logpass(th)) { <line9> throw th; <line10> } <line11> } <line12> } <line13> } <line14> } <line15> } <line16> 	<line11>	task4	
public class A { <line0> @BeforeClass <line1> public void logMyRunning() { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> public void fatalError(String message, Throwable throwable) { <line1> setMdc(); <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> private void openFolder(File file) { <line1> if (myCommand == null) { <line2> return; <line3> } <line4> try { <line5> ProcessBuilder pb = new ProcessBuilder(myCommand, file.getCanonicalPath()); <line6> if (myWorkingDirectory != null) { <line7> pb.directory(new File(myWorkingDirectory)); <line8> } <line9> pb.start(); <line10> } catch (final IOException e1) { <line11> } <line12> } <line13> } <line14> 	<line11>	task4	
"public class A { <line0> @Transactional <line1> public Paymentheader createDirectBankPayment( <line2> Paymentheader paymentheader, <line3> CVoucherHeader voucherHeader, <line4> CVoucherHeader billVhId, <line5> CommonBean commonBean, <line6> List<VoucherDetails> billDetailslist, <line7> List<VoucherDetails> subLedgerlist, <line8> WorkflowBean workflowBean) { <line9> try { <line10> voucherHeader = <line11> createVoucherAndledger(voucherHeader, commonBean, billDetailslist, subLedgerlist); <line12> paymentheader = <line13> paymentService.createPaymentHeader( <line14> voucherHeader, <line15> Integer.valueOf(commonBean.getAccountNumberId()), <line16> commonBean.getModeOfPayment(), <line17> commonBean.getAmount()); <line18> if (commonBean.getDocumentId() != null) <line19> billVhId = <line20> (CVoucherHeader) <line21> persistenceService <line22> .getSession() <line23> .load(CVoucherHeader.class, commonBean.getDocumentId()); <line24> createMiscBillDetail(billVhId, commonBean, voucherHeader); <line25> paymentheader = sendForApproval(paymentheader, workflowBean); <line26> } catch (final ValidationException e) { <line27> final List<ValidationError> errors = new ArrayList<ValidationError>(); <line28> errors.add(new ValidationError(""exp"", e.getErrors().get(0).getMessage())); <line29> throw new ValidationException(errors); <line30> } catch (final Exception e) { <line31> final List<ValidationError> errors = new ArrayList<ValidationError>(); <line32> errors.add(new ValidationError(""exp"", e.getMessage())); <line33> throw new ValidationException(errors); <line34> } <line35> return paymentheader; <line36> } <line37> } <line38> "	<line27>	task4	
public class A { <line0> private SingleRegionBlocker.SingleRegionBlockerConfiguration toSingleRegionBlockerConfig( <line1> String jsonConfiguration) { <line2> try { <line3> return mapper.readValue( <line4> jsonConfiguration, SingleRegionBlocker.SingleRegionBlockerConfiguration.class); <line5> } catch (IOException e) { <line6> throw new UncheckedIOException(e); <line7> } <line8> } <line9> } <line10> 	<line6>	task4	
public class A { <line0> public static H2Configuration asH2Configuration(OxdServerConfiguration configuration) { <line1> try { <line2> JsonNode node = configuration.getStorageConfiguration(); <line3> if (node != null) { <line4> return Jackson2.createJsonMapper().treeToValue(node, H2Configuration.class); <line5> } <line6> } catch (Exception e) { <line7> } <line8> return new H2Configuration(); <line9> } <line10> } <line11> 	<line7>	task4	
public class A { <line0> @Override <line1> protected Object doGetTransaction() throws TransactionException { <line2> HazelcastTransactionObject txObject = new HazelcastTransactionObject(); <line3> TransactionContextHolder transactionContextHolder = <line4> (TransactionContextHolder) TransactionSynchronizationManager.getResource(hazelcastInstance); <line5> if (transactionContextHolder != null) { <line6> if (logger.isDebugEnabled()) { <line7> } <line8> txObject.setTransactionContextHolder(transactionContextHolder, false); <line9> } <line10> return txObject; <line11> } <line12> } <line13> 	<line7>	task4	
"public class A { <line0> @Test <line1> public void testDelayedClosed() throws Exception { <line2> BlockingQueue<Callback> receivedCallbacks = new BlockingArrayQueue<>(); <line3> TestFrameHandler serverHandler = <line4> new TestFrameHandler() { <line5> @Override <line6> public void onOpen(CoreSession coreSession, Callback callback) { <line7> super.onOpen(coreSession); <line8> callback.succeeded(); <line9> coreSession.demand(2); <line10> } <line11>  <line12> @Override <line13> public boolean isDemanding() { <line14> return true; <line15> } <line16>  <line17> @Override <line18> public void onFrame(Frame frame, Callback callback) { <line19> receivedFrames.offer(frame); <line20> receivedCallbacks.offer(callback); <line21> } <line22> }; <line23> server = new WebSocketServer(serverHandler); <line24> server.start(); <line25> try (Socket client = newClient(server.getLocalPort())) { <line26> ByteBuffer buffer = BufferUtil.allocate(4096); <line27> BufferUtil.append(buffer, RawFrameBuilder.buildText(""Hello"", true)); <line28> BufferUtil.append(buffer, RawFrameBuilder.buildClose(CloseStatus.NORMAL_STATUS, true)); <line29> client.getOutputStream().write(BufferUtil.toArray(buffer)); <line30> long end = System.nanoTime() + TimeUnit.SECONDS.toNanos(10); <line31> while (serverHandler.receivedFrames.size() < 2) { <line32> assertThat(System.nanoTime(), Matchers.lessThan(end)); <line33> Thread.sleep(10); <line34> } <line35> assertThat(serverHandler.receivedFrames.size(), is(2)); <line36> assertThat(receivedCallbacks.size(), is(2)); <line37> assertThat(serverHandler.receivedFrames.poll().getPayloadAsUTF8(), is(""Hello"")); <line38> receivedCallbacks.poll().succeeded(); <line39> serverHandler <line40> .getCoreSession() <line41> .sendFrame(new Frame(OpCode.TEXT, ""Ciao""), Callback.NOOP, false); <line42> Frame frame = receiveFrame(client.getInputStream()); <line43> assertNotNull(frame); <line44> assertThat(frame.getPayloadAsUTF8(), is(""Ciao"")); <line45> assertThat(serverHandler.receivedFrames.poll().getOpCode(), is(OpCode.CLOSE)); <line46> receivedCallbacks.poll().succeeded(); <line47> frame = receiveFrame(client.getInputStream()); <line48> assertNotNull(frame); <line49> assertThat(frame.getOpCode(), is(OpCode.CLOSE)); <line50> } <line51> } <line52> } <line53> "	<line19>	task4	
public class A { <line0> protected boolean isScrollTimedOut(String scrollId, CursorResult<C, O> cursorResult) { <line1> if (cursorResult.timedOut()) { <line2> if (unregisterCursor(scrollId)) { <line3> } <line4> return true; <line5> } <line6> return false; <line7> } <line8> } <line9> 	<line3>	task4	
public class A { <line0> private void getAllConnectionTemplates() { <line1> ResourceCollection<ConnectionTemplate> connectionTemplates = <line2> this.connectionTemplateClient.getAll(); <line3> } <line4> } <line5> 	<line3>	task4	
public class A { <line0> private void logMessage(Exchange exchange, Document inDoc) throws Exception { <line1> DomConverter converter = new DomConverter(); <line2> String xmlStr = converter.toString(inDoc, exchange); <line3> } <line4> } <line5> 	<line3>	task4	
"public class A { <line0> public WPSResponseHandler getResponseHandler(WPSResponse response, Toolbox toolbox) { <line1> WPSResponseHandler ret = null; <line2> if (response.getResponseType().contains(""vnd.ogc.se"")) { <line3> ret = new WPSServiceErrorHandler(response); <line4> } else if (response.getResponseType().contains(""image"")) { <line5> ret = new WPSImageResponseHandler(response); <line6> } else if (response.getResponseType().contains(""xml"")) { <line7> WpsToolbox wpsToolbox = toolbox.getPluginToolboxRegistry().getPluginToolbox(WpsToolbox.class); <line8> ret = wpsToolbox.createGmlResponseHandler(response); <line9> } else if (response.getResponseType().contains(""zip"") <line10> && response.getResponseType().contains(""shape"")) { <line11> ret = new WPSShapefileResponseHandler(response); <line12> } else { <line13> ret = new WPSTextResponseHandler(response); <line14> } <line15> return ret; <line16> } <line17> } <line18> "	<line13>	task4	
"public class A { <line0> @Override <line1> protected void configureComponents(@Nullable String model) { <line2> String mod = model == null ? MODEL_OPTION_OTHER : model; <line3> boolean caseta = mod.equalsIgnoreCase(MODEL_OPTION_CASETA); <line4> for (int x = 1; x <= 100; x++) { <line5> buttonList.add( <line6> new Component(x, String.format(""button%d"", x), ""Virtual Button"", ComponentType.BUTTON)); <line7> if (!caseta) { <line8> ledList.add( <line9> new Component(x + 100, String.format(""led%d"", x), ""Virtual LED"", ComponentType.LED)); <line10> } <line11> } <line12> } <line13> } <line14> "	<line3>	task4	
"public class A { <line0> @POST(path = ""/backend/admin/users/remove"", permission = ""admin:edit:user"") <line1> String removeUser(@BindRequest UserConfigRequest request) throws Exception { <line2> try { <line3> configRepository.deleteUserConfig(request.username().get()); <line4> } catch (CannotDeleteLastUserException e) { <line5> return ""{\""errorCannotDeleteLastUser\"":true}""; <line6> } <line7> return ""{}""; <line8> } <line9> } <line10> "	<line5>	task4	
public class A { <line0> @Override <line1> public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Test <line1> public void testBlockInSourceTaskStop() throws Exception { <line2> createConnectorWithBlock(BlockingSourceConnector.class, TASK_STOP); <line3> waitForConnectorStart(BLOCKING_CONNECTOR_NAME); <line4> connect.deleteConnector(BLOCKING_CONNECTOR_NAME); <line5> Block.waitForBlock(); <line6> createNormalConnector(); <line7> verifyNormalConnector(); <line8> } <line9> } <line10> 	<line2>	task4	
public class A { <line0> public void setActionMap(Map<String, String> actions) { <line1> for (String from : actions.keySet()) { <line2> URI key; <line3> String to = actions.get(from); <line4> try { <line5> key = new URI(from); <line6> URI value = new URI(actions.get(from)); <line7> actionMap.put(key, value); <line8> } catch (URISyntaxException e) { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>	task4	
public class A { <line0> public static <I extends WritableComparable, V extends Writable, E extends Writable> <line1> Piece<I, V, E, NoMessage, Object> removeVertices( <line2> final String pieceName, final SupplierFromVertex<I, V, E, Boolean> shouldRemoveVertex) { <line3> return new Piece<I, V, E, NoMessage, Object>() { <line4> private ReducerHandle<LongWritable, LongWritable> countRemovedAgg; <line5>  <line6> @Override <line7> public void registerReducers(CreateReducersApi reduceApi, Object executionStage) { <line8> countRemovedAgg = reduceApi.createLocalReducer(SumReduce.LONG); <line9> } <line10>  <line11> @Override <line12> public VertexSender<I, V, E> getVertexSender( <line13> final BlockWorkerSendApi<I, V, E, NoMessage> workerApi, Object executionStage) { <line14> return new InnerVertexSender() { <line15> @Override <line16> public void vertexSend(Vertex<I, V, E> vertex) { <line17> if (shouldRemoveVertex.get(vertex)) { <line18> workerApi.removeVertexRequest(vertex.getId()); <line19> reduceLong(countRemovedAgg, 1); <line20> } <line21> } <line22> }; <line23> } <line24>  <line25> @Override <line26> public void masterCompute(BlockMasterApi master, Object executionStage) { <line27> } <line28>  <line29> @Override <line30> public String toString() { <line31> return pieceName; <line32> } <line33> }; <line34> } <line35> } <line36> 	<line27>	task4	
public class A { <line0> @Override <line1> public synchronized void initialize( <line2> final EventReporter eventReporter, <line3> final Authorizer authorizer, <line4> final ProvenanceAuthorizableFactory resourceFactory, <line5> final IdentifierLookup idLookup) <line6> throws IOException { <line7> final RecordWriterFactory recordWriterFactory = <line8> (file, idGenerator, compressed, createToc) -> { <line9> final TocWriter tocWriter = <line10> createToc ? new StandardTocWriter(TocUtil.getTocFile(file), false, false) : null; <line11> return new EventIdFirstSchemaRecordWriter( <line12> file, idGenerator, tocWriter, compressed, BLOCK_SIZE, idLookup); <line13> }; <line14> final EventFileManager fileManager = new EventFileManager(); <line15> final RecordReaderFactory recordReaderFactory = <line16> (file, logs, maxChars) -> { <line17> fileManager.obtainReadLock(file); <line18> try { <line19> return RecordReaders.newRecordReader(file, logs, maxChars); <line20> } finally { <line21> fileManager.releaseReadLock(file); <line22> } <line23> }; <line24> eventStore = <line25> new PartitionedWriteAheadEventStore( <line26> config, recordWriterFactory, recordReaderFactory, eventReporter, fileManager); <line27> final IndexManager indexManager = new SimpleIndexManager(config); <line28> eventIndex = new LuceneEventIndex(config, indexManager, eventReporter); <line29> this.eventReporter = eventReporter; <line30> this.authorizer = authorizer; <line31> this.resourceFactory = resourceFactory; <line32> eventStore.initialize(); <line33> eventIndex.initialize(eventStore); <line34> try { <line35> eventStore.reindexLatestEvents(eventIndex); <line36> } catch (final Exception e) { <line37> } <line38> } <line39> } <line40> 	<line37>	task4	
public class A { <line0> public RemoteObservationManager getRemoteObservationManager() { <line1> if (this.remoteObservationManager == null) { <line2> try { <line3> this.remoteObservationManager = <line4> this.componentManager.getInstance(RemoteObservationManager.class); <line5> } catch (ComponentLookupException e) { <line6> } <line7> } <line8> return this.remoteObservationManager; <line9> } <line10> } <line11> 	<line6>	task4	
public class A { <line0> private void ethPendingTransactionHashObservable(String x) { <line1> Exchange exchange = this.getEndpoint().createExchange(); <line2> exchange.getIn().setBody(x); <line3> processEvent(exchange); <line4> } <line5> } <line6> 	<line1>	task4	
"public class A { <line0> private void handshakeCompleted(PendingHandshakeConnection conn) { <line1> try { <line2> if (conn.handshakeSuccess) { <line3> final SelectionKey key = conn.socketChannel.getSocketChannel().register(selector, 0); <line4> final TCPConnection tcpConn = <line5> new TCPConnection(TCPEndpoint.this, conn.socketChannel, key, selector, conn.type); <line6> key.attach(tcpConn); <line7> switch (conn.type) { <line8> case INCOMING: <line9> connectionAccepted(tcpConn); <line10> break; <line11> case OUTGOING: <line12> connectionEstablished(tcpConn); <line13> break; <line14> default: <line15> throw new IllegalStateException(""Unknown connection type: "" + conn.type); <line16> } <line17> } else { <line18> handleHandshakeFailure(conn); <line19> } <line20> } catch (Exception e) { <line21> handleHandshakeFailure(conn); <line22> } <line23> } <line24> } <line25> "	<line21>	task4	
public class A { <line0> @Override <line1> public void initialize( <line2> AnnotatorCompatible walker, GenomeAnalysisEngine toolkit, Set<VCFHeaderLine> headerLines) { <line3> if (founderIds == null && walker != null) { <line4> founderIds = ((Walker) walker).getSampleDB().getFounderIds(); <line5> } <line6> if (walker != null <line7> && (((Walker) walker).getSampleDB().getSamples().size() < MIN_SAMPLES <line8> || (!founderIds.isEmpty() && founderIds.size() < MIN_SAMPLES))) <line9> heterozygosityUtils = new HeterozygosityUtils(RETURN_ROUNDED); <line10> } <line11> } <line12> 	<line9>	task4	
"public class A { <line0> void importRooms(File base) throws Exception { <line1> Class<Room> eClazz = Room.class; <line2> JAXBContext jc = JAXBContext.newInstance(eClazz); <line3> Unmarshaller unmarshaller = jc.createUnmarshaller(); <line4> unmarshaller.setAdapter(new UserAdapter(userDao, userMap)); <line5> readList( <line6> unmarshaller, <line7> base, <line8> ""rooms.xml"", <line9> ROOM_LIST_NODE, <line10> ROOM_NODE, <line11> eClazz, <line12> r -> { <line13> Long roomId = r.getId(); <line14> if (r.getOwnerId() != null) { <line15> Long newOwnerId = userMap.get(r.getOwnerId()); <line16> if (newOwnerId == null) { <line17> return; <line18> } <line19> r.setOwnerId(newOwnerId); <line20> } <line21> r.setId(null); <line22> if (r.getModerators() != null) { <line23> for (Iterator<RoomModerator> i = r.getModerators().iterator(); i.hasNext(); ) { <line24> RoomModerator rm = i.next(); <line25> if (rm.getUser().getId() == null) { <line26> i.remove(); <line27> } <line28> } <line29> } <line30> r = roomDao.update(r, null); <line31> roomMap.put(roomId, r.getId()); <line32> }); <line33> } <line34> } <line35> "	<line1>	task4	
public class A { <line0> public static List<Place> getPlaceListFromRespond(String xml) <line1> throws ParserConfigurationException, SAXException, IOException { <line2> List<Place> pList = new ArrayList<Place>(); <line3> DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); <line4> DocumentBuilder documentBuilder; <line5> InputSource is = new InputSource(new StringReader(xml)); <line6> documentBuilder = builderFactory.newDocumentBuilder(); <line7> Document doc = documentBuilder.parse(is); <line8> NodeList placeNodes = doc.getElementsByTagName(XML_PLACE); <line9> for (int i = 0; i < placeNodes.getLength(); i++) { <line10> try { <line11> pList.add(getPlace(doc, (Element) placeNodes.item(i))); <line12> } catch (Exception e) { <line13> } <line14> } <line15> return pList; <line16> } <line17> } <line18> 	<line13>	task4	
public class A { <line0> public void unregisterClient(int id) { <line1> ConnectedClient client = clients.remove(id); <line2> if (client == null) { <line3> return; <line4> } <line5> Processor processor = client.getProcessor(); <line6> if (processor != null) { <line7> processor.disconnect(client); <line8> } <line9> try { <line10> managementListeners.forEach(l -> l.clientUnregistered(client)); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> 	<line12>	task4	
"public class A { <line0> @Test <line1> public void testGetString() { <line2> String result = PropertyUtils.getString(""alert.type""); <line3> assertEquals(""EMAIL"", result); <line4> result = PropertyUtils.getString(""mail.server.host""); <line5> assertEquals(""xxx.xxx.test"", result); <line6> result = PropertyUtils.getString(""abc""); <line7> assertNull(result); <line8> result = PropertyUtils.getString(null); <line9> assertNull(result); <line10> } <line11> } <line12> "	<line3>	task4	
public class A { <line0> public void testExecute() { <line1> try { <line2> ActionResponse response = action.execute(protocolSessionManager); <line3> } catch (ActionException e) { <line4> e.printStackTrace(); <line5> Assert.fail(); <line6> } <line7> org.opennaas.extensions.router.model.System routerModel = <line8> (org.opennaas.extensions.router.model.System) action.getModelToUpdate(); <line9> Assert.assertNotNull(routerModel); <line10> List<LogicalDevice> ld = routerModel.getLogicalDevices(); <line11> for (LogicalDevice device : ld) { <line12> EthernetPort ep = (EthernetPort) device; <line13> } <line14> } <line15> } <line16> 	<line13>	task4	
public class A { <line0> private void applySecurityIdentityToSubject(SecurityIdentity securityIdentity) { <line1> Roles roles = securityIdentity.getRoles(); <line2> Subject subject = obtainSubject(); <line3> if (subject != null) { <line4> if (subject.getPrincipals().size() == 0) { <line5> subject.getPrincipals().add(securityIdentity.getPrincipal()); <line6> } <line7> if (subject.getPrincipals(GroupPrincipal.class).size() == 0) { <line8> roles.forEach(role -> subject.getPrincipals().add(new GroupPrincipal(role))); <line9> } <line10> if (logger.isDebugEnabled()) { <line11> } <line12> } <line13> } <line14> } <line15> 	<line11>	task4	
public class A { <line0> @Override <line1> public void handleStreamClosePacket(ServerStreamChannel streamChannel, StreamClosePacket packet) { <line2> } <line3> } <line4> 	<line2>	task4	
"public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture future) throws Exception { <line2> handleReconnectDisconnection(1001, ""Channel closed""); <line3> } <line4> } <line5> "	<line2>	task4	
public class A { <line0> public void greetMeOneWay(String me) { <line1> } <line2> } <line3> 	<line1>	task4	
public class A { <line0> @Deprecated <line1> public void saveBed(Bed bed) { <line2> if (bed == null) return; <line3> updateHistory(bed); <line4> if (bed.getId() == null || bed.getId().intValue() == 0) persist(bed); <line5> else merge(bed); <line6> } <line7> } <line8> 	<line6>	task4	
"public class A { <line0> @Override <line1> public TimeSeries getValues( <line2> String resourceId, Instant from, Instant to, DataResolution resolution, ZoneId zoneId) { <line3> final String influxGrouping = dataResolutionToInfluxGrouping(resolution); <line4> final List<Tuple<Instant, Instant>> periods = getPeriods(from, to, resolution, zoneId); <line5> final List<String> labels = new ArrayList<>(); <line6> final List<Double> values = new ArrayList<>(); <line7> final InfluxProviderConfiguration.InfluxProviderSource source = getSource(resolution); <line8> for (final Tuple<Instant, Instant> period : periods) { <line9> final Query query = <line10> BoundParameterQuery.QueryBuilder.newQuery( <line11> ""SELECT "" <line12> + source.getAggregation() <line13> + ""("" <line14> + source.getAggregationVariable() <line15> + "") FROM "" <line16> + source.getMeasurement() <line17> + "" WHERE "" <line18> + source.getResourceIdName() <line19> + ""=$resourceId AND time>=$from AND time<=$to"" <line20> + influxGrouping) <line21> .bind(""resourceId"", resourceId) <line22> .bind(""from"", period.getA()) <line23> .bind(""to"", period.getB()) <line24> .create(); <line25> try { <line26> final QueryResult results = service.getInfluxDB().query(query); <line27> final TimeSeries currentViews = queryResultToTimeSeries(results); <line28> labels.addAll(currentViews.getLabels()); <line29> values.addAll(currentViews.getValues()); <line30> } catch (InfluxDBIOException e) { <line31> if (e.getCause() instanceof ConnectException) { <line32> } else { <line33> throw e; <line34> } <line35> } <line36> } <line37> final Double total = <line38> ""SUM"".equalsIgnoreCase(source.getAggregation()) <line39> ? values.stream().mapToDouble(v -> v).sum() <line40> : null; <line41> return new TimeSeries(labels, values, total); <line42> } <line43> } <line44> "	<line32>	task4	
public class A { <line0> private static boolean startEsClient(FsCrawlerImpl fsCrawler) { <line1> try { <line2> fsCrawler.start(); <line3> return true; <line4> } catch (Exception t) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
"public class A { <line0> private void formatMonitorUrl(String monitorUrlStr) { <line1> if (monitorUrlStr.startsWith(ConstantValue.KEY_HTTP)) { <line2> String url; <line3> if (monitorUrlStr.endsWith(ConstantValue.SINGLE_SLASH_SYMBOL)) { <line4> url = monitorUrlStr + ""jobs/"" + jobId + ""/accumulators""; <line5> } else { <line6> url = monitorUrlStr + ""/jobs/"" + jobId + ""/accumulators""; <line7> } <line8> monitorUrls.add(url); <line9> } else { <line10> String[] monitor = monitorUrlStr.split("",""); <line11> for (int i = 0; i < monitor.length; ++i) { <line12> String url = ""http://"" + monitor[i] + ""/jobs/"" + jobId + ""/accumulators""; <line13> monitorUrls.add(url); <line14> } <line15> } <line16> if (DtLogger.isEnableDebug()) { <line17> } <line18> } <line19> } <line20> "	<line17>	task4	
"public class A { <line0> private SearchResult performFTPRequest( <line1> String filenamepart, String catalog, int startIndex, int rows) { <line2> if (StringUtils.isBlank(ftpUsername) || StringUtils.isBlank(ftpPassword)) { <line3> throw new CatalogException( <line4> ""Incomplete credentials configured for FTP import in OPAC configuration for "" <line5> + ""catalog '"" <line6> + catalog <line7> + ""'""); <line8> } <line9> SearchResult searchResult = new SearchResult(); <line10> FTPFileFilter searchFilter = file -> file.isFile() && file.getName().contains(filenamepart); <line11> try { <line12> ftpLogin(); <line13> FTPFile[] files = ftpClient.listFiles(path, searchFilter); <line14> searchResult.setNumberOfHits(files.length); <line15> LinkedList<SingleHit> hits = new LinkedList<>(); <line16> for (int i = startIndex; i < Math.min(startIndex + rows, files.length); i++) { <line17> hits.add(new SingleHit(files[i].getName(), files[i].getName())); <line18> } <line19> searchResult.setHits(hits); <line20> ftpLogout(); <line21> } catch (IOException e) { <line22> throw new CatalogException(e.getMessage()); <line23> } finally { <line24> if (ftpClient.isConnected()) { <line25> try { <line26> ftpClient.disconnect(); <line27> } catch (IOException e) { <line28> } <line29> } <line30> } <line31> return searchResult; <line32> } <line33> } <line34> "	<line28>	task4	
"public class A { <line0> @POST <line1> @Path(""run/{noteId}/{paragraphId}"") <line2> @ZeppelinApi <line3> public Response runParagraphSynchronously( <line4> @PathParam(""noteId"") String noteId, <line5> @PathParam(""paragraphId"") String paragraphId, <line6> @QueryParam(""sessionId"") String sessionId, <line7> String message) <line8> throws IOException, IllegalArgumentException { <line9> Note note = notebook.getNote(noteId); <line10> checkIfNoteIsNotNull(note, noteId); <line11> Paragraph paragraph = note.getParagraph(paragraphId); <line12> checkIfParagraphIsNotNull(paragraph, paragraphId); <line13> Map<String, Object> params = new HashMap<>(); <line14> if (!StringUtils.isEmpty(message)) { <line15> ParametersRequest request = ParametersRequest.fromJson(message); <line16> params = request.getParams(); <line17> } <line18> if (notebookService.runParagraph( <line19> noteId, <line20> paragraphId, <line21> paragraph.getTitle(), <line22> paragraph.getText(), <line23> params, <line24> new HashMap<>(), <line25> sessionId, <line26> false, <line27> true, <line28> getServiceContext(), <line29> new RestServiceCallback<>())) { <line30> note = notebookService.getNote(noteId, getServiceContext(), new RestServiceCallback<>()); <line31> Paragraph p = note.getParagraph(paragraphId); <line32> InterpreterResult result = p.getReturn(); <line33> return new JsonResponse<>(Status.OK, result).build(); <line34> } else { <line35> return new JsonResponse<>(Status.INTERNAL_SERVER_ERROR, ""Fail to run paragraph"").build(); <line36> } <line37> } <line38> } <line39> "	<line9>	task4	
"public class A { <line0> void remove(Suffix se) throws RemoveException { <line1> LdapConnection ld = null; <line2> String nodeDn = getDn(se); <line3> try { <line4> ld = getAdminConnection(); <line5> deleteRecursive(ld, nodeDn); <line6> } catch (CursorException e) { <line7> String error = <line8> ""remove suffix node dn ["" + nodeDn + ""] caught CursorException="" + e.getMessage(); <line9> throw new RemoveException(GlobalErrIds.SUFX_DELETE_FAILED, error, e); <line10> } catch (LdapException e) { <line11> String error = ""remove suffix node dn ["" + nodeDn + ""] caught LDAPException="" + e; <line12> throw new RemoveException(GlobalErrIds.SUFX_DELETE_FAILED, error, e); <line13> } finally { <line14> closeAdminConnection(ld); <line15> } <line16> } <line17> } <line18> "	<line3>	task4	
public class A { <line0> public boolean completedIsDisplayed() { <line1> return readyElement(completedLabel).isDisplayed(); <line2> } <line3> } <line4> 	<line1>	task4	
"public class A { <line0> @Test <line1> public void errorDuringRun() throws Exception { <line2> BasicTask<Void> t = <line3> new BasicTask<Void>( <line4> new Callable<Void>() { <line5> public Void call() throws Exception { <line6> throw new IllegalStateException(""Simulating failure in errorDuringRun""); <line7> } <line8> }); <line9> em.submit(MutableMap.of(""tag"", ""A""), t); <line10> try { <line11> t.get(); <line12> fail(""get should have failed due to error""); <line13> } catch (Exception eo) { <line14> Throwable e = Throwables.getRootCause(eo); <line15> assertEquals(""Simulating failure in errorDuringRun"", e.getMessage()); <line16> } <line17> assertFalse(t.isCancelled()); <line18> assertTrue(t.isError()); <line19> assertTrue(t.isDone()); <line20> assertTrue( <line21> t.getStatusDetail(false).contains(""Simulating failure in errorDuringRun""), <line22> ""details="" + t.getStatusDetail(false)); <line23> } <line24> } <line25> "	<line20>	task4	
public class A { <line0> @Override <line1> public void start() { <line2> if (pool == null) { <line3> this.pool = <line4> IoTDBThreadPoolFactory.newCachedThreadPool(ThreadName.FLUSH_SUB_TASK_SERVICE.getName()); <line5> } <line6> } <line7> } <line8> 	<line6>	task4	
public class A { <line0> @Override <line1> public void importData( <line2> ProjectImportRequest aRequest, Project aProject, ExportedProject aExProject, ZipFile aZip) { <line3> ExportedDocumentRepository[] exportedDocumentRepositories = <line4> aExProject.getArrayProperty(KEY, ExportedDocumentRepository.class); <line5> for (ExportedDocumentRepository exportedDocumentRepository : exportedDocumentRepositories) { <line6> DocumentRepository documentRepository = new DocumentRepository(); <line7> documentRepository.setName(exportedDocumentRepository.getName()); <line8> documentRepository.setProperties(exportedDocumentRepository.getProperties()); <line9> documentRepository.setType(exportedDocumentRepository.getType()); <line10> documentRepository.setProject(aProject); <line11> externalSearchService.createOrUpdateDocumentRepository(documentRepository); <line12> } <line13> int n = exportedDocumentRepositories.length; <line14> } <line15> } <line16> 	<line14>	task4	
"public class A { <line0> @OnError <line1> public void onError(Session session, Throwable cause) throws IOException { <line2> session.getBasicRemote().sendText(""Exception: "" + StackUtils.toString(cause)); <line3> } <line4> } <line5> "	<line2>	task4	
public class A { <line0> @Override <line1> public void resultChanged(LookupEvent e) { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> public void setMaxWait(long maxWaitMillis) { <line1> if (maxWaitMillis == this.maxWait) { <line2> return; <line3> } <line4> if (maxWaitMillis > 0 && useUnfairLock == null && !this.inited) { <line5> final ReentrantLock lock = this.lock; <line6> lock.lock(); <line7> try { <line8> if ((!this.inited) && (!lock.isFair())) { <line9> this.lock = new ReentrantLock(true); <line10> this.notEmpty = this.lock.newCondition(); <line11> this.empty = this.lock.newCondition(); <line12> } <line13> } finally { <line14> lock.unlock(); <line15> } <line16> } <line17> if (inited) { <line18> } <line19> this.maxWait = maxWaitMillis; <line20> } <line21> } <line22> 	<line18>	task4	
public class A { <line0> @Override <line1> public List<SourceRecord> poll() throws InterruptedException { <line2> try { <line3> long deadline = System.currentTimeMillis() + interval.toMillis(); <line4> while (!stopping && System.currentTimeMillis() < deadline) { <line5> offsetSyncStore.update(pollTimeout); <line6> } <line7> List<SourceRecord> records = new ArrayList<>(); <line8> for (String group : consumerGroups) { <line9> records.addAll(sourceRecordsForGroup(group)); <line10> } <line11> if (records.isEmpty()) { <line12> return null; <line13> } else { <line14> return records; <line15> } <line16> } catch (Throwable e) { <line17> return null; <line18> } <line19> } <line20> } <line21> 	<line17>	task4	
"public class A { <line0> @BeforeClass <line1> public static void beforeClass() throws Exception { <line2> ClassUtil.addClasspath(new File(HBaseMetadataTestCase.SANDBOX_TEST_DATA).getAbsolutePath()); <line3> System.setProperty(""hdp.version"", ""2.2.0.0-2041""); <line4> } <line5> } <line6> "	<line2>	task4	
public class A { <line0> @Override <line1> public List<DataTreeNode> getNextNodeList(final TreeMapState state) { <line2> List<DataTreeNode> result = TreeMapState.empty(); <line3> long now = JitterClock.globalTime(); <line4> DataTreeNode root = state.current(); <line5> if (preempt && (state.processorClosing() || expensiveShutdownTest())) { <line6> return result; <line7> } <line8> findAndPruneChildren(state, root, now, relativeDown, treePath); <line9> return result; <line10> } <line11> } <line12> 	<line6>	task4	
"public class A { <line0> @Override <line1> public void run() { <line2> MixedOperation<Pod, PodList, PodResource<Pod>> w = getEndpoint().getKubernetesClient().pods(); <line3> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getNamespace())) { <line4> w.inNamespace(getEndpoint().getKubernetesConfiguration().getNamespace()); <line5> } <line6> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getLabelKey()) <line7> && ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getLabelValue())) { <line8> w.withLabel( <line9> getEndpoint().getKubernetesConfiguration().getLabelKey(), <line10> getEndpoint().getKubernetesConfiguration().getLabelValue()); <line11> } <line12> if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getResourceName())) { <line13> w.withName(getEndpoint().getKubernetesConfiguration().getResourceName()); <line14> } <line15> watch = <line16> w.watch( <line17> new Watcher<Pod>() { <line18> @Override <line19> public void eventReceived( <line20> io.fabric8.kubernetes.client.Watcher.Action action, Pod resource) { <line21> PodEvent pe = new PodEvent(action, resource); <line22> Exchange exchange = createExchange(false); <line23> exchange.getIn().setBody(pe.getPod()); <line24> exchange <line25> .getIn() <line26> .setHeader(KubernetesConstants.KUBERNETES_EVENT_ACTION, pe.getAction()); <line27> exchange <line28> .getIn() <line29> .setHeader( <line30> KubernetesConstants.KUBERNETES_EVENT_TIMESTAMP, System.currentTimeMillis()); <line31> try { <line32> processor.process(exchange); <line33> } catch (Exception e) { <line34> getExceptionHandler().handleException(""Error during processing"", exchange, e); <line35> } finally { <line36> releaseExchange(exchange, false); <line37> } <line38> } <line39>  <line40> @Override <line41> public void onClose(WatcherException cause) { <line42> if (cause != null) { <line43> } <line44> } <line45> }); <line46> } <line47> } <line48> "	<line43>	task4	
"public class A { <line0> @Path(""/getShouldSucceed"") <line1> @POST <line2> public void getShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET); <line4> Subnet out = <line5> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, SUBNET_ID, Subnet.class); <line6> assertNotNull(out); <line7> assertEquals(SUBNET_NAME, out.getName()); <line8> assertEquals(Ipv6AddressMode.DHCPV6_STATEFUL, out.getIpv6AddressMode()); <line9> assertEquals(Ipv6RaMode.DHCPV6_STATEFUL, out.getIpv6RaMode()); <line10> assertNotNull(out.getDnsNames()); <line11> assertTrue(out.getDnsNames().isEmpty()); <line12> } <line13> } <line14> "	<line3>	task4	
public class A { <line0> @Override <line1> public void injectCacheResult(Object result) { <line2> results = (ArrayList<List<String>>) result; <line3> resultInjectedFromCache = true; <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> 	<line5>	task4	
"public class A { <line0> @Override <line1> public String getTimeDescription(Locale locale, long milliseconds, boolean approximate) { <line2> String description = Time.getDescription(milliseconds, approximate); <line3> String value = null; <line4> try { <line5> String[] parts = description.split(StringPool.SPACE, 2); <line6> String unit = StringUtil.toLowerCase(parts[1]); <line7> if (unit.equals(""second"")) { <line8> unit += ""[time]""; <line9> } <line10> value = format(locale, ""x-"" + unit, parts[0]); <line11> } catch (Exception exception) { <line12> if (log.isWarnEnabled()) { <line13> } <line14> } <line15> return value; <line16> } <line17> } <line18> "	<line13>	task4	
public class A { <line0> @Override <line1> public ResponseTime mapRow(Result result, int rowNum) throws Exception { <line2> if (result.isEmpty()) { <line3> return null; <line4> } <line5> final byte[] rowKey = getOriginalKey(result.getRow()); <line6> ResponseTime responseTime = createResponseTime(rowKey); <line7> for (Cell cell : result.rawCells()) { <line8> if (CellUtil.matchingFamily( <line9> cell, HbaseColumnFamily.MAP_STATISTICS_SELF_VER2_COUNTER.getName())) { <line10> recordColumn(responseTime, cell); <line11> } <line12> if (logger.isTraceEnabled()) { <line13> String columnFamily = <line14> Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength()); <line15> } <line16> } <line17> return responseTime; <line18> } <line19> } <line20> 	<line15>	task4	
public class A { <line0> private void processDispose(final String cacheName, final long requesterId) throws IOException { <line1> final CacheListeners<K, V> cacheDesc = cacheListenersMap.get(cacheName); <line2> if (cacheDesc != null) { <line3> synchronized (cacheDesc) { <line4> final ICacheEventQueue<K, V>[] qlist = getEventQList(cacheDesc, requesterId); <line5> for (final ICacheEventQueue<K, V> element : qlist) { <line6> element.addDisposeEvent(); <line7> } <line8> cacheManager.freeCache(cacheName); <line9> } <line10> } <line11> } <line12> } <line13> 	<line1>	task4	
public class A { <line0> @Activate <line1> void activate() { <line2> enabled = getSystemPropertyOrEnvVar(FABRIC8_CONFIG_PLUGIN_ENABLED, enabled); <line3> } <line4> } <line5> 	<line3>	task4	
"public class A { <line0> @BeforeEach <line1> public void configureServiceClients(final TestInfo testInfo) { <line2> createClients(); <line3> prepareClients(); <line4> setServiceClients(adapter); <line5> final CommandConsumer commandConsumer = mock(CommandConsumer.class); <line6> when(commandConsumer.close(any())).thenReturn(Future.succeededFuture()); <line7> when(commandConsumerFactory.createCommandConsumer( <line8> anyString(), anyString(), VertxMockSupport.anyHandler(), any(), any())) <line9> .thenReturn(Future.succeededFuture(commandConsumer)); <line10> doAnswer( <line11> invocation -> { <line12> final Handler<AsyncResult<User>> resultHandler = invocation.getArgument(2); <line13> resultHandler.handle( <line14> Future.failedFuture( <line15> new ClientErrorException( <line16> HttpURLConnection.HTTP_UNAUTHORIZED, ""bad credentials""))); <line17> return null; <line18> }) <line19> .when(usernamePasswordAuthProvider) <line20> .authenticate(any(UsernamePasswordCredentials.class), any(), VertxMockSupport.anyHandler()); <line21> doAnswer( <line22> invocation -> { <line23> final JsonObject authInfo = invocation.getArgument(0); <line24> final String username = <line25> JsonHelper.getValue( <line26> authInfo, CredentialsConstants.FIELD_USERNAME, String.class, null); <line27> final String password = <line28> JsonHelper.getValue( <line29> authInfo, CredentialsConstants.FIELD_PASSWORD, String.class, null); <line30> if (username == null || password == null) { <line31> return null; <line32> } else { <line33> return UsernamePasswordCredentials.create(username, password); <line34> } <line35> }) <line36> .when(usernamePasswordAuthProvider) <line37> .getCredentials(any(JsonObject.class)); <line38> } <line39> } <line40> "	<line2>	task4	
"public class A { <line0> @DELETE <line1> @Timed <line2> @Path(""{id}"") <line3> @Consumes(APPLICATION_JSON) <line4> public void delete( <line5> @Context GraphManager manager, @PathParam(""graph"") String graph, @PathParam(""id"") String id) { <line6> @SuppressWarnings(""unused"") <line7> HugeGraph g = graph(manager, graph); <line8> try { <line9> manager.authManager().deleteTarget(UserAPI.parseId(id)); <line10> } catch (NotFoundException e) { <line11> throw new IllegalArgumentException(""Invalid target id: "" + id); <line12> } <line13> } <line14> } <line15> "	<line6>	task4	
public class A { <line0> @Override <line1> public void handleReturn( <line2> int replyCode, <line3> String replyText, <line4> String exchange, <line5> String routingKey, <line6> AMQP.BasicProperties properties, <line7> byte[] body) <line8> throws IOException { <line9> basicReturnReceived = true; <line10> } <line11> } <line12> 	<line9>	task4	
public class A { <line0> @Verify(global = false) <line1> public void verify() { <line2> EventCount total = new EventCount(); <line3> for (EventCount eventCount : eventCounts) { <line4> total.add(eventCount); <line5> } <line6> total.waitWhileListenerEventsIncrease(listener, 10); <line7> total.assertEventsEquals(listener); <line8> } <line9> } <line10> 	<line7>	task4	
"public class A { <line0> @Override <line1> public void pushTaskReports(String taskid, File reportFile) throws IOException { <line2> final String taskKey = getTaskLogKey(taskid, ""report.json""); <line3> pushTaskFile(reportFile, taskKey); <line4> } <line5> } <line6> "	<line3>	task4	
public class A { <line0> public static <T> T getClassInstance(String context, String clazzName, Class<T> base) <line1> throws IOException, ReflectiveOperationException { <line2> T instance; <line3> Class<? extends T> clazz = ClassLoaderUtil.loadClass(context, clazzName, base); <line4> instance = clazz.getDeclaredConstructor().newInstance(); <line5> return instance; <line6> } <line7> } <line8> 	<line5>	task4	
public class A { <line0> @Override <line1> public void debug(String arg0, Throwable arg1) { <line2> if (debug) { <line3> } <line4> } <line5> } <line6> 	<line3>	task4	
public class A { <line0> private void notifyNoActivity() { <line1> enquireLinkSender.enquireLink(); <line2> } <line3> } <line4> 	<line1>	task4	
public class A { <line0> public void start() throws Exception { <line1> tioServer = appContext.getIoc().getByType(TioServer.class); <line2> String ip = appContext.getServerHost(PROP_IP); <line3> int port = appContext.getServerPort(PROP_PORT, 9420); <line4> tioServer.start(ip, port); <line5> } <line6> } <line7> 	<line1>	task4	
"public class A { <line0> public String getReferenceCheckSum() { <line1> Map<String, Integer> checksumCounts = new HashMap<String, Integer>(); <line2> checksumCounts.put(adminStatus.getChecksum(), 1); <line3> for (Replica baReplica : Replica.getKnown()) { <line4> String checksum = getUniqueChecksum(baReplica); <line5> if (checksumCounts.containsKey(checksum)) { <line6> checksumCounts.put(checksum, checksumCounts.get(checksum) + 1); <line7> } else { <line8> checksumCounts.put(checksum, 1); <line9> } <line10> } <line11> int majorityCount = (Replica.getKnown().size() + 1) / 2 + 1; <line12> for (Map.Entry<String, Integer> entry : checksumCounts.entrySet()) { <line13> if (entry.getValue() >= majorityCount) { <line14> return entry.getKey(); <line15> } <line16> } <line17> return """"; <line18> } <line19> } <line20> "	<line13>	task4	
public class A { <line0> public void fillTile(InternalTile tile, Envelope maxTileExtent) throws GeomajasException { <line1> List<InternalFeature> origFeatures = tile.getFeatures(); <line2> tile.setFeatures(new ArrayList<InternalFeature>()); <line3> for (InternalFeature feature : origFeatures) { <line4> if (!addTileCode(tile, maxTileExtent, feature.getGeometry())) { <line5> tile.addFeature(feature); <line6> } <line7> } <line8> } <line9> } <line10> 	<line5>	task4	
"public class A { <line0> public static void main(String[] args) { <line1> ToolDependencies.wireDeployers(); <line2> List<String> wars = new ArrayList<>(); <line3> List<String> jars = new ArrayList<>(); <line4> for (String arg : args) { <line5> if (arg.endsWith("".war"")) { <line6> wars.add(arg); <line7> } else if (arg.endsWith("".jar"")) { <line8> jars.add(arg); <line9> } <line10> } <line11> try (HookDeployer hookDeployer = new HookDeployer(wars, jars)) { <line12> } catch (IOException ioException) { <line13> if (log.isWarnEnabled()) { <line14> } <line15> } <line16> } <line17> } <line18> "	<line14>	task4	
public class A { <line0> protected void assertRangeStatistic(RangeStatisticImpl stat) throws InterruptedException { <line1> assertEquals(0, stat.getCurrent()); <line2> assertEquals(0, stat.getLowWaterMark()); <line3> assertEquals(0, stat.getHighWaterMark()); <line4> stat.setCurrent(100); <line5> assertEquals(100, stat.getCurrent()); <line6> assertEquals(100, stat.getLowWaterMark()); <line7> assertEquals(100, stat.getHighWaterMark()); <line8> stat.setCurrent(50); <line9> assertEquals(50, stat.getCurrent()); <line10> assertEquals(50, stat.getLowWaterMark()); <line11> assertEquals(100, stat.getHighWaterMark()); <line12> stat.setCurrent(200); <line13> assertEquals(200, stat.getCurrent()); <line14> assertEquals(50, stat.getLowWaterMark()); <line15> assertEquals(200, stat.getHighWaterMark()); <line16> Thread.sleep(500); <line17> stat.setCurrent(10); <line18> assertEquals(10, stat.getCurrent()); <line19> assertEquals(10, stat.getLowWaterMark()); <line20> assertEquals(200, stat.getHighWaterMark()); <line21> assertLastTimeNotStartTime(stat); <line22> stat.reset(); <line23> assertEquals(0, stat.getCurrent()); <line24> assertEquals(0, stat.getLowWaterMark()); <line25> assertEquals(0, stat.getHighWaterMark()); <line26> stat.setCurrent(100); <line27> assertEquals(100, stat.getCurrent()); <line28> assertEquals(100, stat.getLowWaterMark()); <line29> assertEquals(100, stat.getHighWaterMark()); <line30> } <line31> } <line32> 	<line22>	task4	
public class A { <line0> public Identity getOrCreateIdentity( <line1> String providerId, String remoteId, boolean forceLoadOrReloadProfile) { <line2> Identity returnIdentity = null; <line3> IdentityProvider<?> identityProvider = this.getIdentityProvider(providerId); <line4> Identity identityFoundByRemoteProvider = identityProvider.getIdentityByRemoteId(remoteId); <line5> Identity result = this.getIdentityStorage().findIdentity(providerId, remoteId); <line6> if (result == null) { <line7> if (identityFoundByRemoteProvider != null) { <line8> saveIdentity(identityFoundByRemoteProvider); <line9> this.getIdentityStorage().saveProfile(identityFoundByRemoteProvider.getProfile()); <line10> result = identityFoundByRemoteProvider; <line11> if (OrganizationIdentityProvider.NAME.equals(providerId)) { <line12> profileLifeCycle.createProfile(result.getProfile()); <line13> } <line14> } else { <line15> return result; <line16> } <line17> } else { <line18> if (identityFoundByRemoteProvider == null && !result.isDeleted()) { <line19> } <line20> Profile profile = this.getIdentityStorage().loadProfile(result.getProfile()); <line21> profile.setIdentity(result); <line22> result.setProfile(profile); <line23> } <line24> returnIdentity = result; <line25> return returnIdentity; <line26> } <line27> } <line28> 	<line19>	task4	
public class A { <line0> @Override <line1> public void onMouseDown(Event event) { <line2> super.onMouseDown(event); <line3> if (writing) { <line4> return; <line5> } <line6> if (processing) { <line7> divElement.getParentElement().removeChild(divElement); <line8> } <line9> image = getRootImage(event); <line10> int[] absoluteTopLeft = Utils.getAbsoluteTopLeft(image, Document.get()); <line11> ax = event.getClientX() - absoluteTopLeft[1] + Window.getScrollLeft(); <line12> ay = event.getClientY() - absoluteTopLeft[0] + Window.getScrollTop(); <line13> bx = ax; <line14> by = ay; <line15> writing = true; <line16> processing = true; <line17> controller.disablePopupListeners(); <line18> addMap(ax, ay, bx, by, image); <line19> } <line20> } <line21> 	<line4>	task4	
public class A { <line0> @VisibleForTesting <line1> boolean isMessageMovedToSpamMailbox(MessageMoveEvent event) { <line2> try { <line3> MailboxId spamMailboxId = <line4> systemMailboxesProvider.findMailbox(Role.SPAM, event.getUsername()).getId(); <line5> return event.getMessageMoves().addedMailboxIds().contains(spamMailboxId); <line6> } catch (MailboxException e) { <line7> return false; <line8> } <line9> } <line10> } <line11> 	<line7>	task4	
"public class A { <line0> protected void checkConcurrentUpdate(Throwable e) throws ConcurrentUpdateException { <line1> if (dialect.isConcurrentUpdateException(e)) { <line2> throw new ConcurrentUpdateException(""Concurrent update"", e); <line3> } <line4> } <line5> } <line6> "	<line2>	task4	
public class A { <line0> public static List<NamedThing> getSchemaNames(PartnerConnection connection) throws IOException { <line1> List<NamedThing> returnList = new ArrayList<>(); <line2> DescribeGlobalResult result = null; <line3> try { <line4> result = connection.describeGlobal(); <line5> } catch (ConnectionException e) { <line6> throw new ComponentException(e); <line7> } <line8> DescribeGlobalSObjectResult[] objects = result.getSobjects(); <line9> for (DescribeGlobalSObjectResult obj : objects) { <line10> returnList.add(new SimpleNamedThing(obj.getName(), obj.getLabel())); <line11> } <line12> return returnList; <line13> } <line14> } <line15> 	<line10>	task4	
public class A { <line0> public boolean isFirstCustomization() { <line1> try { <line2> return (WebloggerFactory.getWeblogger() <line3> .getWeblogManager() <line4> .getTemplateByAction(getActionWeblog(), ComponentType.WEBLOG) <line5> == null); <line6> } catch (WebloggerException ex) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	<line7>	task4	
"public class A { <line0> @POST <line1> @Path(""/shutdown"") <line2> @Consumes({MediaType.APPLICATION_JSON, SmileMediaTypes.APPLICATION_JACKSON_SMILE}) <line3> @Produces({MediaType.APPLICATION_JSON, SmileMediaTypes.APPLICATION_JACKSON_SMILE}) <line4> public Response shutdown( <line5> @QueryParam(""shutoffTime"") final String shutoffTimeMillis, <line6> @Context final HttpServletRequest req) { <line7> Access accessResult = <line8> AuthorizationUtils.authorizeResourceAction( <line9> req, new ResourceAction(Resource.STATE_RESOURCE, Action.WRITE), authorizerMapper); <line10> if (!accessResult.isAllowed()) { <line11> return Response.status(403).build(); <line12> } <line13> try { <line14> DateTime shutoffAt = <line15> shutoffTimeMillis == null ? DateTimes.nowUtc() : DateTimes.of(shutoffTimeMillis); <line16> long shutoffTimeoutMillis = Math.max(shutoffAt.getMillis() - System.currentTimeMillis(), 0); <line17> requestedShutdownTimeNs = <line18> System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(shutoffTimeoutMillis); <line19> Thread delayedCloseExecutor; <line20> boolean needToInterruptDelayedCloseExecutor = true; <line21> synchronized (this) { <line22> delayedCloseExecutor = this.delayedCloseExecutor; <line23> if (delayedCloseExecutor == null) { <line24> delayedCloseExecutor = createDelayedCloseExecutor(); <line25> needToInterruptDelayedCloseExecutor = false; <line26> } <line27> } <line28> if (needToInterruptDelayedCloseExecutor) { <line29> delayedCloseExecutor.interrupt(); <line30> } <line31> return Response.ok().build(); <line32> } catch (IllegalArgumentException e) { <line33> return Response.status(Response.Status.BAD_REQUEST) <line34> .entity(ImmutableMap.<String, Object>of(""error"", e.getMessage())) <line35> .build(); <line36> } <line37> } <line38> } <line39> "	<line16>	task4	
"public class A { <line0> private void validateRelayResponseDTO(final RelayResponseDTO dto) { <line1> if (dto == null) { <line2> throw new InvalidParameterException(""RelayResponseDTO"" + NULL_ERROR_MESSAGE); <line3> } <line4> if (Utilities.isEmpty(dto.getAddress())) { <line5> throw new InvalidParameterException(""Relay address"" + EMPTY_OR_NULL_ERROR_MESSAGE); <line6> } <line7> if (dto.getType() == RelayType.GATEKEEPER_RELAY) { <line8> throw new InvalidParameterException(dto.getType().name() + NOT_APPLICABLE_RELAY_TYPE); <line9> } <line10> } <line11> } <line12> "	<line1>	task4	
"public class A { <line0> @Schedule(hour = ""*"", minute = ""*"", second = ""*/30"", persistent = false) <line1> public void removeIdleOrExpired() { <line2> if (log.isDebugEnabled()) { <line3> } <line4> long now = System.currentTimeMillis(); <line5> clearQueries(now); <line6> qlCache.clearQueryLogics(now, conf.getCallTimeInMS()); <line7> } <line8> } <line9> "	<line3>	task4	
public class A { <line0> private Folder _getParentFolder() { <line1> try { <line2> if (_parentFolder != null) { <line3> return _parentFolder; <line4> } <line5> if (getParentFolderId() == DLFolderConstants.DEFAULT_PARENT_FOLDER_ID) { <line6> return null; <line7> } <line8> _parentFolder = DLAppServiceUtil.getFolder(getParentFolderId()); <line9> return _parentFolder; <line10> } catch (Exception exception) { <line11> if (log.isDebugEnabled()) { <line12> } <line13> return null; <line14> } <line15> } <line16> } <line17> 	<line12>	task4	
public class A { <line0> @Override <line1> public String explain(String query, String language) throws RepositoryException { <line2> final org.modeshape.jcr.api.query.Query jcrQuery = <line3> (org.modeshape.jcr.api.query.Query) <line4> getLocalSession() <line5> .getSession() <line6> .getWorkspace() <line7> .getQueryManager() <line8> .createQuery(query, language); <line9> return jcrQuery.explain().getPlan(); <line10> } <line11> } <line12> 	<line2>	task4	
"public class A { <line0> public EtherRainStatusResponse commandStatus() throws EtherRainException, IOException { <line1> commandLogin(); <line2> List<String> responseList = sendGet(""result.cgi?xs""); <line3> if (responseList.isEmpty()) { <line4> throw new EtherRainException(""Empty Response""); <line5> } <line6> EtherRainStatusResponse response = new EtherRainStatusResponse(); <line7> for (String line : responseList) { <line8> Matcher m = responseStatusPattern.matcher(line); <line9> if (m.matches()) { <line10> String command = m.replaceAll(""$1""); <line11> String status = m.replaceAll(""$2""); <line12> switch (command) { <line13> case ""un"": <line14> response.setUniqueName(status); <line15> break; <line16> case ""ma"": <line17> response.setMacAddress(status); <line18> break; <line19> case ""ac"": <line20> response.setServiceAccount(status); <line21> break; <line22> case ""os"": <line23> response.setOperatingStatus(EtherRainOperatingStatus.valueOf(status.toUpperCase())); <line24> break; <line25> case ""cs"": <line26> response.setLastCommandStatus(EtherRainCommandStatus.valueOf(status.toUpperCase())); <line27> break; <line28> case ""rz"": <line29> response.setLastCommandResult(EtherRainCommandResult.valueOf(status.toUpperCase())); <line30> break; <line31> case ""ri"": <line32> response.setLastActiveValue(Integer.parseInt(status)); <line33> break; <line34> case ""rn"": <line35> response.setRainSensor(Integer.parseInt(status) == 1); <line36> break; <line37> default: <line38> } <line39> } <line40> } <line41> return response; <line42> } <line43> } <line44> "	<line38>	task4	
"public class A { <line0> @Override <line1> protected void include( <line2> String path, PortletRequest portletRequest, PortletResponse portletResponse, String lifecycle) <line3> throws IOException, PortletException { <line4> PortletContext portletContext = getPortletContext(); <line5> String servletContextName = portletContext.getPortletContextName(); <line6> String resourcePath = <line7> StringBundler.concat(servletContextName, TemplateConstants.SERVLET_SEPARATOR, path); <line8> boolean resourceExists = false; <line9> try { <line10> resourceExists = <line11> TemplateResourceLoaderUtil.hasTemplateResource( <line12> TemplateConstants.LANG_TYPE_FTL, resourcePath); <line13> } catch (TemplateException templateException) { <line14> throw new IOException(templateException); <line15> } <line16> if (!resourceExists) { <line17> } else { <line18> try { <line19> TemplateResource templateResource = <line20> TemplateResourceLoaderUtil.getTemplateResource( <line21> TemplateConstants.LANG_TYPE_FTL, resourcePath); <line22> Template template = <line23> TemplateManagerUtil.getTemplate( <line24> TemplateConstants.LANG_TYPE_FTL, templateResource, false); <line25> template.prepareTaglib( <line26> PortalUtil.getHttpServletRequest(portletRequest), <line27> PortalUtil.getHttpServletResponse(portletResponse)); <line28> template.put(""portletContext"", getPortletContext()); <line29> template.put(""userInfo"", portletRequest.getAttribute(PortletRequest.USER_INFO)); <line30> template.prepare(PortalUtil.getHttpServletRequest(portletRequest)); <line31> Writer writer = null; <line32> if (portletResponse instanceof MimeResponse) { <line33> MimeResponse mimeResponse = (MimeResponse) portletResponse; <line34> writer = UnsyncPrintWriterPool.borrow(mimeResponse.getWriter()); <line35> } else { <line36> writer = new UnsyncStringWriter(); <line37> } <line38> template.processTemplate(writer); <line39> } catch (Exception exception) { <line40> throw new PortletException(exception); <line41> } <line42> } <line43> if (clearRequestParameters && lifecycle.equals(PortletRequest.RENDER_PHASE)) { <line44> portletResponse.setProperty(""clear-request-parameters"", ""true""); <line45> } <line46> } <line47> } <line48> "	<line17>	task4	
public class A { <line0> @Override <line1> public void run() { <line2> updateStateFromCurrentKeys(); <line3> initialized = true; <line4> while (keepRunning) { <line5> long now = System.currentTimeMillis(); <line6> _run(now); <line7> try { <line8> Thread.sleep(5000); <line9> } catch (InterruptedException ie) { <line10> } <line11> } <line12> } <line13> } <line14> 	<line10>	task4	
"public class A { <line0> private Message sendMessageForActionUpdate(Session cmisSession, Message message) <line1> throws SenderException, TimeOutException { <line2> String objectId = null; <line3> Map<String, Object> props = new HashMap<String, Object>(); <line4> Element cmisElement; <line5> try { <line6> if (XmlUtils.isWellFormed(message, ""cmis"")) { <line7> cmisElement = XmlUtils.buildElement(message); <line8> } else { <line9> cmisElement = XmlUtils.buildElement(""<cmis/>""); <line10> } <line11> objectId = XmlUtils.getChildTagAsString(cmisElement, ""id""); <line12> Element propertiesElement = XmlUtils.getFirstChildTag(cmisElement, ""properties""); <line13> if (propertiesElement != null) { <line14> processProperties(propertiesElement, props); <line15> } <line16> } catch (DomBuilderException e) { <line17> throw new SenderException(getLogPrefix() + ""exception parsing ["" + message + ""]"", e); <line18> } <line19> CmisObject object = null; <line20> try { <line21> object = cmisSession.getObject(cmisSession.createObjectId(objectId)); <line22> } catch (CmisObjectNotFoundException e) { <line23> if (StringUtils.isNotEmpty(getResultOnNotFound())) { <line24> return new Message(getResultOnNotFound()); <line25> } else { <line26> throw new SenderException(e); <line27> } <line28> } <line29> object.updateProperties(props); <line30> return new Message(object.getId()); <line31> } <line32> } <line33> "	<line24>	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected Object resolveType(ClassLoader classLoader, Class pluginClass, Class type) { <line2> if (type.isAssignableFrom(PluginManager.class)) { <line3> return pluginManager; <line4> } else if (type.isAssignableFrom(Watcher.class)) { <line5> return pluginManager.getWatcher(); <line6> } else if (type.isAssignableFrom(Scheduler.class)) { <line7> return pluginManager.getScheduler(); <line8> } else if (type.isAssignableFrom(HotswapTransformer.class)) { <line9> return pluginManager.getHotswapTransformer(); <line10> } else if (type.isAssignableFrom(PluginConfiguration.class)) { <line11> return pluginManager.getPluginConfiguration(classLoader); <line12> } else if (type.isAssignableFrom(ClassLoader.class)) { <line13> return classLoader; <line14> } else if (type.isAssignableFrom(Instrumentation.class)) { <line15> return pluginManager.getInstrumentation(); <line16> } else { <line17> return null; <line18> } <line19> } <line20> } <line21> "	<line17>	task4	
public class A { <line0> protected boolean isValidDate(LocalDate date) { <line1> try { <line2> if (date != null) { <line3> IsoChronology.INSTANCE.date(date); <line4> } <line5> return true; <line6> } catch (DateTimeException ex) { <line7> return false; <line8> } <line9> } <line10> } <line11> 	<line7>	task4	
"public class A { <line0> public void updateStatusLabel() { <line1> boolean executeable = false; <line2> if (_datastore == null) { <line3> setStatusLabelText(""Welcome to DataCleaner "" + Version.getDistributionVersion()); <line4> _statusLabel.setIcon( <line5> imageManager.getImageIcon(IconUtils.APPLICATION_ICON, IconUtils.ICON_SIZE_SMALL)); <line6> } else { <line7> if (!_analysisJobBuilder.getSourceColumns().isEmpty()) { <line8> executeable = true; <line9> } <line10> try { <line11> if (_analysisJobBuilder.isConfigured(true)) { <line12> setStatusLabelText(""Job is correctly configured""); <line13> setStatusLabelValid(); <line14> } else { <line15> setStatusLabelText(""Job is not correctly configured""); <line16> setStatusLabelWarning(); <line17> } <line18> } catch (final Exception ex) { <line19> executeable = false; <line20> final String errorMessage; <line21> if (ex instanceof UnconfiguredConfiguredPropertyException) { <line22> final UnconfiguredConfiguredPropertyException unconfiguredConfiguredPropertyException = <line23> (UnconfiguredConfiguredPropertyException) ex; <line24> final ConfiguredPropertyDescriptor configuredProperty = <line25> unconfiguredConfiguredPropertyException.getConfiguredProperty(); <line26> final ComponentBuilder componentBuilder = <line27> unconfiguredConfiguredPropertyException.getComponentBuilder(); <line28> errorMessage = <line29> ""Property '"" <line30> + configuredProperty.getName() <line31> + ""' in "" <line32> + LabelUtils.getLabel(componentBuilder) <line33> + "" is not set!""; <line34> } else if (ex instanceof ComponentValidationException) { <line35> final ComponentValidationException componentValidationException = <line36> (ComponentValidationException) ex; <line37> errorMessage = <line38> componentValidationException.getComponentDescriptor().getDisplayName() <line39> + "" validation failed: "" <line40> + ex.getMessage(); <line41> } else { <line42> errorMessage = ex.getMessage(); <line43> } <line44> setStatusLabelText(""Job error status: "" + errorMessage); <line45> setStatusLabelError(); <line46> } <line47> } <line48> _executeButton.setEnabled(executeable); <line49> } <line50> } <line51> "	<line20>	task4	
public class A { <line0> public static String toJson(Object obj, Class<?> model) { <line1> ObjectWriter writer = mapper.writer(); <line2> if (null != obj) { <line3> try { <line4> if (null != model) { <line5> writer = writer.withView(model); <line6> } <line7> return writer.writeValueAsString(obj); <line8> } catch (JsonProcessingException e) { <line9> throw new RuntimeException(e); <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line9>	task4	
public class A { <line0> @Override <line1> public void create(User user, Device device, FolderSyncKey folderSyncKey, FolderSnapshot snapshot) <line2> throws DaoException { <line3> BatchStatement batch = new BatchStatement(Type.LOGGED); <line4> insertSnapshot(batch, user, device, folderSyncKey, snapshot); <line5> insertMapping(batch, user, device, snapshot.getFolders()); <line6> getSession().execute(batch); <line7> } <line8> } <line9> 	<line6>	task4	
public class A { <line0> @Override <line1> public void run() { <line2> Collection<SingleWMSService> workers = getTiles(job); <line3> OMGraphicList result = new OMGraphicList(); <line4> ExecutorService pool = Executors.newFixedThreadPool(Math.max(workers.size(), 4)); <line5> ExecutorCompletionService<OMGraphicList> completionService = <line6> new ExecutorCompletionService<>(pool); <line7> for (SingleWMSService w : workers) { <line8> completionService.submit(w); <line9> } <line10> boolean allSuccess = true; <line11> for (int i = 0; i < workers.size(); i++) { <line12> Future<OMGraphicList> future; <line13> try { <line14> future = completionService.poll(Math.max(100, 5000 / (i + 1)), TimeUnit.MILLISECONDS); <line15> OMGraphicList tile = future.get(); <line16> result.addAll(tile); <line17> tmpCache.putIfAbsent(getID(job), new OMGraphicList()); <line18> tmpCache.get(getID(job)).addAll(tile); <line19> fireWMSEvent(); <line20> } catch (InterruptedException | ExecutionException | NullPointerException e) { <line21> allSuccess = false; <line22> } <line23> } <line24> if (allSuccess) { <line25> tmpCache.remove(getID(job)); <line26> cache.put(getID(job), result); <line27> fireWMSEvent(); <line28> } else { <line29> queue(job); <line30> } <line31> } <line32> } <line33> 	<line29>	task4	
"public class A { <line0> private void getAuxThreadProfileAndRespond( <line1> CentralRequest request, StreamObserver<AgentResponse> responseObserver) throws Exception { <line2> Profile profile; <line3> try { <line4> profile = <line5> liveTraceRepository.getAuxThreadProfile( <line6> """", request.getAuxThreadProfileRequest().getTraceId()); <line7> } catch (Exception e) { <line8> sendExceptionResponse(request, responseObserver); <line9> return; <line10> } <line11> AuxThreadProfileResponse response; <line12> if (profile == null) { <line13> response = AuxThreadProfileResponse.getDefaultInstance(); <line14> } else { <line15> response = AuxThreadProfileResponse.newBuilder().setProfile(profile).build(); <line16> } <line17> responseObserver.onNext( <line18> AgentResponse.newBuilder() <line19> .setRequestId(request.getRequestId()) <line20> .setAuxThreadProfileResponse(response) <line21> .build()); <line22> } <line23> } <line24> "	<line8>	task4	
"public class A { <line0> @Override <line1> public void close() { <line2> closeStream(fileReaderShp, ""ESRI Shapefile""); <line3> closeStream(fileReaderDbf, ""DBF Shapefile""); <line4> closeStream(fileReaderPrj, ""PRJ Shapefile""); <line5> try { <line6> if (dbfReader != null) { <line7> dbfReader.close(); <line8> } <line9> } catch (Exception e) { <line10> } <line11> dbfReader = null; <line12> } <line13> } <line14> "	<line10>	task4	
"public class A { <line0> protected Span getSpanFromContext(byte[] traceContext) { <line1> if (traceContext == null || traceContext.length == 0) { <line2> return BlankSpan.INSTANCE; <line3> } <line4> Tracer tracer = Tracing.getTracer(); <line5> BinaryFormat binaryFormat = Tracing.getPropagationComponent().getBinaryFormat(); <line6> try { <line7> SpanContext spanContext = binaryFormat.fromByteArray(traceContext); <line8> Span span = <line9> tracer <line10> .spanBuilderWithRemoteParent(""work/"" + getClass().getSimpleName(), spanContext) <line11> .startSpan(); <line12> span.addLink(Link.fromSpanContext(spanContext, Link.Type.PARENT_LINKED_SPAN)); <line13> HashMap<String, AttributeValue> map = new HashMap<>(); <line14> map.put(""tx.thread"", AttributeValue.stringAttributeValue(Thread.currentThread().getName())); <line15> map.put(""work.id"", AttributeValue.stringAttributeValue(getId())); <line16> map.put(""work.category"", AttributeValue.stringAttributeValue(getCategory())); <line17> String title = getTitle(); <line18> if (title != null) { <line19> map.put(""work.title"", AttributeValue.stringAttributeValue(title)); <line20> } <line21> map.put( <line22> ""work.parent_path"", <line23> AttributeValue.stringAttributeValue(getSchedulePath().getParentPath())); <line24> map.put(""work.caller_thread"", AttributeValue.stringAttributeValue(callerThread)); <line25> map.put(""work.to_string"", AttributeValue.stringAttributeValue(toString())); <line26> if (docId != null) { <line27> map.put(""work.doc_id"", AttributeValue.stringAttributeValue(docId)); <line28> } <line29> if (docIds != null && !docIds.isEmpty()) { <line30> map.put(""work.doc_count"", AttributeValue.longAttributeValue(docIds.size())); <line31> } <line32> span.putAttributes(map); <line33> return span; <line34> } catch (SpanContextParseException e) { <line35> return BlankSpan.INSTANCE; <line36> } <line37> } <line38> } <line39> "	<line35>	task4	
public class A { <line0> public static List<String[]> getCoresDataArray() { <line1> return coresDataArray; <line2> } <line3> } <line4> 	<line1>	task4	
"public class A { <line0> public static int getMountFoldersCount( <line1> HttpPrincipal httpPrincipal, long repositoryId, long parentFolderId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLAppServiceUtil.class, <line7> ""getMountFoldersCount"", <line8> _getMountFoldersCountParameterTypes76); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, repositoryId, parentFolderId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>	task4	
public class A { <line0> @Authorized <line1> public <T extends Definition> T getDefinitionByUuid(Class<T> definitionType, String uuid) { <line2> SerializedObject so = dao.getSerializedObjectByUuid(uuid); <line3> try { <line4> return dao.convertSerializedObject(definitionType, so); <line5> } catch (Exception e) { <line6> ExceptionUtil.rethrowAuthenticationException(e); <line7> return null; <line8> } <line9> } <line10> } <line11> 	<line7>	task4	
public class A { <line0> @Override <line1> public Connection call() throws Exception { <line2> return createConnection(settings, jdbcUrl, user, pass, kerberos, d); <line3> } <line4> } <line5> 	<line2>	task4	
"public class A { <line0> @Override <line1> public void deleteUserConfig(String username) throws ApsSystemException { <line2> try { <line3> this.getUserShortcutDAO().deleteUserConfig(username); <line4> } catch (Throwable t) { <line5> throw new ApsSystemException(""Error deleting user config by user "" + username, t); <line6> } <line7> } <line8> } <line9> "	<line5>	task4	
"public class A { <line0> public void clickDeleteButton() { <line1> WebElement findElement = driver.findElement(By.className(""t-client-remove-btn"")); <line2> findElement.click(); <line3> } <line4> } <line5> "	<line1>	task4	
public class A { <line0> @Test <line1> public void minimumWireComponentExists() throws KuraException { <line2> WireGraphConfiguration wgc; <line3> try { <line4> wgc = wireGraphService.get(); <line5> } catch (KuraException e) { <line6> throw e; <line7> } <line8> assertTrue( <line9> wgc.getWireComponentConfigurations().stream() <line10> .anyMatch(wcc -> UNDER_TEST_PID.equals(wcc.getConfiguration().getPid()))); <line11> } <line12> } <line13> 	<line6>	task4	
"public class A { <line0> @Override <line1> public Status update(String tableName, String key, Map<String, ByteIterator> values) { <line2> try { <line3> StatementType type = new StatementType(StatementType.Type.UPDATE, tableName, null); <line4> PreparedStatement updateStatement = cachedStatements.get(type); <line5> if (updateStatement == null) { <line6> updateStatement = createAndCacheUpdateStatement(type); <line7> } <line8> JSONObject jsonObject = new JSONObject(); <line9> for (Map.Entry<String, ByteIterator> entry : values.entrySet()) { <line10> jsonObject.put(entry.getKey(), entry.getValue().toString()); <line11> } <line12> PGobject object = new PGobject(); <line13> object.setType(""jsonb""); <line14> object.setValue(jsonObject.toJSONString()); <line15> updateStatement.setObject(1, object); <line16> updateStatement.setString(2, key); <line17> int result = updateStatement.executeUpdate(); <line18> if (result == 1) { <line19> return Status.OK; <line20> } <line21> return Status.UNEXPECTED_STATE; <line22> } catch (SQLException e) { <line23> return Status.ERROR; <line24> } <line25> } <line26> } <line27> "	<line23>	task4	
public class A { <line0> public MarketoRecordResult describeCustomObject(TMarketoInputProperties parameters) { <line1> String customObjectName = parameters.customObjectName.getValue(); <line2> current_uri = <line3> new StringBuilder(basicPath) <line4> .append(API_PATH_CUSTOMOBJECTS) <line5> .append(customObjectName) <line6> .append(API_PATH_URI_DESCRIBE) <line7> .append(fmtParams(FIELD_ACCESS_TOKEN, accessToken, true)); <line8> return getRecordResultForFromRequestBySchema( <line9> parameters.schemaInput.schema.getValue(), false, null); <line10> } <line11> } <line12> 	<line8>	task4	
public class A { <line0> private void readRateSet() throws Throwable { <line1> File f = new File(setup.clientExchangeRatesPath()); <line2> byte[] bytes = Files.readAllBytes(f.toPath()); <line3> rateSet = ExchangeRateSet.parseFrom(bytes); <line4> } <line5> } <line6> 	<line4>	task4	
"public class A { <line0> private synchronized void onUpdate() { <line1> ScheduledFuture<?> job = refreshJob; <line2> if (job == null || job.isCancelled()) { <line3> Configuration config = getThing().getConfiguration(); <line4> int refreshInterval = DEFAULT_REFRESH_INTERVALL_SECONDS; <line5> Object refreshConfig = config.get(""pollingInterval""); <line6> if (refreshConfig != null) { <line7> refreshInterval = ((BigDecimal) refreshConfig).intValue(); <line8> } <line9> refreshJob = <line10> scheduler.scheduleWithFixedDelay(refreshRunnable, 0, refreshInterval, TimeUnit.SECONDS); <line11> } <line12> } <line13> } <line14> "	<line8>	task4	
"public class A { <line0> @Test <line1> public void test_20() { <line2> CompareEffects comp = new CompareEffects(genomeName, randSeed, verbose); <line3> String trId = ""ENST00000382673""; <line4> comp.snpEffect(path(trId + "".snps""), trId, true); <line5> } <line6> } <line7> "	<line2>	task4	
"public class A { <line0> public static java.util.List<com.liferay.social.kernel.model.SocialActivity> getActivities( <line1> HttpPrincipal httpPrincipal, long classNameId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SocialActivityServiceUtil.class, ""getActivities"", _getActivitiesParameterTypes0); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, classNameId, start, end); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (java.util.List<com.liferay.social.kernel.model.SocialActivity>) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	<line19>	task4	
public class A { <line0> @Override <line1> protected AuthorizationDecision combineDecisions( <line2> AuthorizationDecision[] decisions, boolean errorsInTarget) { <line3> if (decisions.length == 0) return AuthorizationDecision.PERMIT; <line4> var entitlement = PERMIT; <line5> var collector = new ObligationAdviceCollector(); <line6> Optional<JsonNode> resource = Optional.empty(); <line7> for (var decision : decisions) { <line8> if (decision.getDecision() == DENY) { <line9> entitlement = DENY; <line10> } <line11> collector.add(decision); <line12> if (decision.getResource().isPresent()) { <line13> if (resource.isPresent()) { <line14> entitlement = DENY; <line15> } else { <line16> resource = decision.getResource(); <line17> } <line18> } <line19> } <line20> var finalDecision = <line21> new AuthorizationDecision( <line22> entitlement, <line23> resource, <line24> collector.getObligations(entitlement), <line25> collector.getAdvices(entitlement)); <line26> return finalDecision; <line27> } <line28> } <line29> 	<line26>	task4	
public class A { <line0> public byte[] run() throws SaslException { <line1> return saslClient.evaluateChallenge(saslToken); <line2> } <line3> } <line4> 	<line1>	task4	
"public class A { <line0> protected long parseRfc3164Time(String ts) { <line1> DateTime now = DateTime.now(); <line2> int year = now.getYear(); <line3> ts = TWO_SPACES.matcher(ts).replaceFirst("" ""); <line4> DateTime date; <line5> try { <line6> date = rfc3164Format.parseDateTime(ts); <line7> } catch (IllegalArgumentException e) { <line8> return 0; <line9> } <line10> if (date != null) { <line11> DateTime fixed = date.withYear(year); <line12> if (fixed.isAfter(now) && fixed.minusMonths(1).isAfter(now)) { <line13> fixed = date.minusYears(1); <line14> } else if (fixed.isBefore(now) && fixed.plusMonths(1).isBefore(now)) { <line15> fixed = date.plusYears(1); <line16> } <line17> date = fixed; <line18> } <line19> if (date == null) { <line20> return 0; <line21> } <line22> return date.getMillis(); <line23> } <line24> } <line25> "	<line8>	task4	
"public class A { <line0> public FileDownloadInfo getFileDownloadInfo(String fileId) { <line1> Objects.requireNonNull(fileId, ""fileId is NULL""); <line2> FileDownloadInfo fdi = fdiCache.get(fileId); <line3> if (fdi == null) { <line4> fdi = createFileDownloadInfo(fileId); <line5> } <line6> return fdi; <line7> } <line8> } <line9> "	<line3>	task4	
public class A { <line0> private void reloadCatalogModelFromDatabasePrivate() { <line1> if (isModernizedBpCatalogLoaded()) { <line2> CatalogModel newModel = loadCatalogModel(); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> catalogModel.modelReload(newModel); <line6> catalogModel.moveListener(newModel); <line7> catalogModel = newModel; <line8> fireLoad(catalogModel); <line9> } <line10> } <line11> } <line12> 	<line4>	task4	
public class A { <line0> public static void connected(String chargeBoxId, WebSocketSession session) { <line1> } <line2> } <line3> 	<line1>	task4	
public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSession session) <line2> throws ProcessException { <line3> updateMapping(context); <line4> final List<FlowFile> flowFiles = session.get(5); <line5> if (flowFiles.isEmpty()) { <line6> return; <line7> } <line8> final ComponentLog logger = getLogger(); <line9> final int maxBufferSize = <line10> context.getProperty(MAX_BUFFER_SIZE).asDataSize(DataUnit.B).intValue(); <line11> for (FlowFile flowFile : flowFiles) { <line12> if (flowFile.getSize() > maxBufferSize) { <line13> session.transfer(flowFile, REL_FAILURE); <line14> continue; <line15> } <line16> final StopWatch stopWatch = new StopWatch(true); <line17> flowFile = session.write(flowFile, new ReplaceTextCallback(context, flowFile, maxBufferSize)); <line18> session <line19> .getProvenanceReporter() <line20> .modifyContent(flowFile, stopWatch.getElapsed(TimeUnit.MILLISECONDS)); <line21> session.transfer(flowFile, REL_SUCCESS); <line22> } <line23> } <line24> } <line25> 	<line18>	task4	
public class A { <line0> private void onFinish(SingularityExecutorTask task, Protos.TaskState taskState) { <line1> processKiller.cancelDestroyFuture(task.getTaskId()); <line2> tasks.remove(task.getTaskId()); <line3> processRunningTasks.remove(task.getTaskId()); <line4> processBuildingTasks.remove(task.getTaskId()); <line5> task.cleanup(taskState); <line6> ListeningExecutorService executorService = taskToShellCommandPool.remove(task.getTaskId()); <line7> if (executorService != null) { <line8> executorService.shutdownNow(); <line9> try { <line10> executorService.awaitTermination(5, TimeUnit.MILLISECONDS); <line11> } catch (InterruptedException e) { <line12> } <line13> } <line14> logging.stopTaskLogger(task.getTaskId(), task.getLogbackLog()); <line15> checkIdleExecutorShutdown(task.getDriver()); <line16> } <line17> } <line18> 	<line12>	task4	
"public class A { <line0> public StudyResponse studyList(String authorization, String applicationId) <line1> throws OrchestrationException { <line2> LOGGER.entry(""begin studyList()""); <line3> StudyResponse studyResponse = new StudyResponse(); <line4> try { <line5> studyResponse = studyMetaDataDao.studyList(authorization, applicationId); <line6> } catch (Exception e) { <line7> } <line8> LOGGER.exit(""studyList() :: Ends""); <line9> return studyResponse; <line10> } <line11> } <line12> "	<line7>	task4	
public class A { <line0> private void processThermometer(JablotronServiceDetailSegment segment) { <line1> String segmentId = segment.getSegmentId().toLowerCase(); <line2> Channel channel = getThing().getChannel(segmentId); <line3> if (channel == null) { <line4> createTempChannel(segmentId, segment.getSegmentName()); <line5> processThermometer(segment); <line6> return; <line7> } <line8> updateTemperatureChannel(channel, segment); <line9> } <line10> } <line11> 	<line4>	task4	
public class A { <line0> @Override <line1> public String compare() { <line2> if (filesToCompare.size() >= MAX_FILES_COUNT) { <line3> File file1 = filesToCompare.get(0); <line4> File file2 = filesToCompare.get(1); <line5> filesToCompare.clear(); <line6> try { <line7> setDiffTree(null); <line8> XlsDiff2 x = new XlsDiff2(); <line9> DiffTreeNode diffTree = x.diffFiles(file1, file2); <line10> setDiffTree(diffTree); <line11> defineChangesStatus(diffTree); <line12> } catch (Exception e) { <line13> WebStudioUtils.addErrorMessage(e.getMessage()); <line14> } <line15> } <line16> return null; <line17> } <line18> } <line19> 	<line13>	task4	
"public class A { <line0> @Override <line1> public Map<String, List<String>> getMetadataMapping() { <line2> Map<String, List<String>> cachedMapping = this.getCacheWrapper().getMetadataMapping(); <line3> if (null != cachedMapping) { <line4> return cachedMapping; <line5> } <line6> Map<String, List<String>> mapping = new HashMap<>(); <line7> try { <line8> String xmlConfig = <line9> this.getConfigManager() <line10> .getConfigItem(JacmsSystemConstants.CONFIG_ITEM_RESOURCE_METADATA_MAPPING); <line11> InputStream stream = new ByteArrayInputStream(xmlConfig.getBytes(StandardCharsets.UTF_8)); <line12> JAXBContext context = JAXBContext.newInstance(JaxbMetadataMapping.class); <line13> Unmarshaller unmarshaller = context.createUnmarshaller(); <line14> JaxbMetadataMapping jaxbMapping = (JaxbMetadataMapping) unmarshaller.unmarshal(stream); <line15> jaxbMapping.getFields().stream() <line16> .forEach( <line17> m -> { <line18> String key = m.getKey(); <line19> String csv = m.getValue(); <line20> List<String> metadatas = <line21> (!StringUtils.isBlank(csv)) ? Arrays.asList(csv.split("","")) : new ArrayList<>(); <line22> mapping.put(key, metadatas); <line23> }); <line24> this.getCacheWrapper().updateMetadataMapping(mapping); <line25> } catch (Exception e) { <line26> throw new RuntimeException(""Error Extracting resource metadata mapping"", e); <line27> } <line28> return mapping; <line29> } <line30> } <line31> "	<line26>	task4	
public class A { <line0> private static void readComposite(Element element, TemplateWidget parent) <line1> throws TemplateIOException { <line2> TemplateComposite templateComposite = new TemplateComposite(parent); <line3> readWidgetCommonProperties(element, templateComposite, false, ELEMENT_COMPOSITE); <line4> Attribute numberOfColumnsAttribute = element.attribute(ATTRIBUTE_NUMBEROFCOLUMNS); <line5> if ((numberOfColumnsAttribute != null) && (numberOfColumnsAttribute.getText() != null)) { <line6> templateComposite.setNumberOfColumns(readInteger(numberOfColumnsAttribute.getText())); <line7> } <line8> Attribute equalColumnsAttribute = element.attribute(ATTRIBUTE_EQUALCOLUMNS); <line9> if ((equalColumnsAttribute != null) && (equalColumnsAttribute.getText() != null)) { <line10> templateComposite.setEqualColumns(readBoolean(equalColumnsAttribute.getText())); <line11> } <line12> for (Iterator<?> i = element.elementIterator(); i.hasNext(); ) { <line13> Element childElement = (Element) i.next(); <line14> readWidget(childElement, templateComposite); <line15> } <line16> } <line17> } <line18> 	<line2>	task4	
"public class A { <line0> protected Answer execute(CreateObjectCommand cmd) { <line1> DataTO data = cmd.getData(); <line2> try { <line3> if (data.getObjectType() == DataObjectType.VOLUME) { <line4> return processor.createVolume(cmd); <line5> } else if (data.getObjectType() == DataObjectType.SNAPSHOT) { <line6> return processor.createSnapshot(cmd); <line7> } <line8> return new CreateObjectAnswer(""not supported type""); <line9> } catch (Exception e) { <line10> return new CreateObjectAnswer(e.toString()); <line11> } <line12> } <line13> } <line14> "	<line10>	task4	
"public class A { <line0> Optional<Map<String, String>> loadViewHashes(Schema schema) { <line1> if (!schema.tableExists(DEPLOYED_VIEWS_NAME)) { <line2> return Optional.empty(); <line3> } <line4> Map<String, String> result = Maps.newHashMap(); <line5> SelectStatement upgradeAuditSelect = <line6> select(field(""name""), field(""hash"")).from(tableRef(DEPLOYED_VIEWS_NAME)); <line7> String sql = dialect.convertStatementToSQL(upgradeAuditSelect); <line8> if (log.isDebugEnabled()) <line9> try (Connection connection = dataSource.getConnection(); <line10> java.sql.Statement statement = connection.createStatement(); <line11> ResultSet resultSet = statement.executeQuery(sql)) { <line12> while (resultSet.next()) { <line13> String dbViewName = resultSet.getString(1); <line14> String viewName = dbViewName.toUpperCase(); <line15> if (!result.containsKey(viewName) || dbViewName.equals(viewName)) { <line16> result.put(viewName, resultSet.getString(2)); <line17> } <line18> } <line19> } catch (SQLException e) { <line20> throw new RuntimeSqlException(""Failed to load deployed views. SQL: ["" + sql + ""]"", e); <line21> } <line22> return Optional.of(Collections.unmodifiableMap(result)); <line23> } <line24> } <line25> "	<line9>	task4	
"public class A { <line0> @Override <line1> public String getStagingDirectory(String key) { <line2> return ""/tmp/"" + key.replaceAll("" "", ""_""); <line3> } <line4> } <line5> "	<line2>	task4	
public class A { <line0> protected void setInitialBuffer(ByteBuffer initialBuffer) { <line1> if (LOG.isDebugEnabled()) <line2> try (AutoLock l = lock.lock()) { <line3> networkBuffer = newNetworkBuffer(initialBuffer.remaining()); <line4> } <line5> ByteBuffer buffer = networkBuffer.getBuffer(); <line6> BufferUtil.clearToFill(buffer); <line7> BufferUtil.put(initialBuffer, buffer); <line8> BufferUtil.flipToFlush(buffer, 0); <line9> } <line10> } <line11> 	<line2>	task4	
"public class A { <line0> @Override <line1> public Optional<Account> getSingleAccount(String accountId) throws IOException { <line2> String url = buildCanvasUrl(""accounts/"" + accountId, Collections.emptyMap()); <line3> Response response = canvasMessenger.getSingleResponseFromCanvas(oauthToken, url); <line4> if (response.getErrorHappened() || response.getResponseCode() != 200) { <line5> return Optional.empty(); <line6> } <line7> return responseParser.parseToObject(Account.class, response); <line8> } <line9> } <line10> "	<line2>	task4	
"public class A { <line0> @Override <line1> public int executeBatch() { <line2> List<JsonObject> objectsToPersist = new ArrayList<JsonObject>(); <line3> HttpResponse response = null; <line4> String databaseName = null; <line5> boolean isbulk = false; <line6> try { <line7> for (Node node : nodes) { <line8> if (node.isDirty()) { <line9> node.handlePreEvent(); <line10> if (node.isInState(RemovedState.class)) { <line11> delete(node.getData(), node.getEntityId()); <line12> } else { <line13> EntityMetadata metadata = <line14> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, node.getDataClass()); <line15> databaseName = metadata.getSchema(); <line16> JsonObject asJsonObject = <line17> CouchDBObjectMapper.getJsonOfEntity( <line18> metadata, <line19> node.getData(), <line20> node.getEntityId(), <line21> getRelationHolders(node), <line22> kunderaMetadata); <line23> objectsToPersist.add(asJsonObject); <line24> isbulk = true; <line25> } <line26> node.handlePostEvent(); <line27> } <line28> } <line29> if (isbulk) { <line30> try { <line31> URI uri = <line32> new URI( <line33> CouchDBConstants.PROTOCOL, <line34> null, <line35> httpHost.getHostName(), <line36> httpHost.getPort(), <line37> CouchDBConstants.URL_SEPARATOR <line38> + databaseName.toLowerCase() <line39> + CouchDBConstants.URL_SEPARATOR <line40> + ""_bulk_docs"", <line41> null, <line42> null); <line43> HttpPost post = new HttpPost(uri); <line44> String object = <line45> String.format( <line46> ""{%s%s}"", <line47> ""\""all_or_nothing\"": true,"", ""\""docs\"": "" + gson.toJson(objectsToPersist)); <line48> StringEntity entity = new StringEntity(object, ""UTF-8""); <line49> entity.setContentType(""application/json""); <line50> post.setEntity(entity); <line51> response = httpClient.execute(httpHost, post, CouchDBUtils.getContext(httpHost)); <line52> } catch (Exception e) { <line53> throw new KunderaException(""Error while executing batch. caused by :"" + e); <line54> } <line55> } <line56> } catch (OperationNotSupportedException e) { <line57> throw new KunderaException(e.getMessage()); <line58> } finally { <line59> CouchDBUtils.closeContent(response); <line60> } <line61> return nodes.size(); <line62> } <line63> } <line64> "	<line53>	task4	
"public class A { <line0> @Override <line1> protected void doHealthCheck(Builder builder) throws Exception { <line2> try { <line3> ClusterHealthRequest request = new ClusterHealthRequest(); <line4> ClusterHealthResponse response = client.cluster().health(request, RequestOptions.DEFAULT); <line5> if (response.getStatus().equals(ClusterHealthStatus.GREEN) <line6> || response.getStatus().equals(ClusterHealthStatus.YELLOW)) { <line7> builder.up(); <line8> } else { <line9> builder.down(); <line10> } <line11> builder.withDetail( <line12> ""Number of Update Queue Items"", elasticsearchUpdateQueueItemRepository.count()); <line13> } catch (Exception e) { <line14> builder.down(e); <line15> } <line16> } <line17> } <line18> "	<line14>	task4	
"public class A { <line0> @Override <line1> public void contribute(Document document, DDMFormInstanceRecord ddmFormInstanceRecord) { <line2> try { <line3> DDMFormInstanceRecordVersion ddmFormInstanceRecordVersion = <line4> ddmFormInstanceRecord.getFormInstanceRecordVersion(); <line5> DDMFormInstance ddmFormInstance = ddmFormInstanceRecordVersion.getFormInstance(); <line6> document.addKeyword( <line7> Field.CLASS_NAME_ID, classNameLocalService.getClassNameId(DDMFormInstance.class)); <line8> document.addKeyword(Field.CLASS_PK, ddmFormInstance.getFormInstanceId()); <line9> document.addKeyword(Field.CLASS_TYPE_ID, ddmFormInstanceRecordVersion.getFormInstanceId()); <line10> document.addKeyword(Field.RELATED_ENTRY, true); <line11> document.addKeyword(Field.STATUS, ddmFormInstanceRecordVersion.getStatus()); <line12> document.addKeyword(Field.VERSION, ddmFormInstanceRecordVersion.getVersion()); <line13> document.addKeyword(""formInstanceId"", ddmFormInstance.getFormInstanceId()); <line14> DDMStructure ddmStructure = ddmFormInstance.getStructure(); <line15> DDMFormValues ddmFormValues = ddmFormInstanceRecordVersion.getDDMFormValues(); <line16> addContent(ddmFormInstanceRecordVersion, ddmFormValues, document); <line17> ddmIndexer.addAttributes(document, ddmStructure, ddmFormValues); <line18> } catch (Exception exception) { <line19> if (log.isDebugEnabled()) { <line20> } <line21> } <line22> } <line23> } <line24> "	<line20>	task4	
public class A { <line0> public WeblogTheme getTheme() { <line1> try { <line2> ThemeManager themeMgr = WebloggerFactory.getWeblogger().getThemeManager(); <line3> return themeMgr.getTheme(this); <line4> } catch (WebloggerException ex) { <line5> } <line6> return null; <line7> } <line8> } <line9> 	<line5>	task4	
"public class A { <line0> @Override <line1> public Router createGlobalRouter() { <line2> Router router = Router.router(vertx()); <line3> router <line4> .route(""/scope"") <line5> .handler( <line6> rc -> { <line7> rc.response().end(ConflictingClass.scope); <line8> }); <line9> router <line10> .route(""/check"") <line11> .handler( <line12> rc -> { <line13> rc.response().end(ConflictingClass.check()); <line14> }); <line15> return router; <line16> } <line17> } <line18> "	<line3>	task4	
public class A { <line0> private void executeEvent(final Collection<DataTreeModification<Subnet>> changes) { <line1> for (DataTreeModification<Subnet> change : changes) { <line2> DataObjectModification<Subnet> rootNode = change.getRootNode(); <line3> switch (rootNode.getModificationType()) { <line4> case SUBTREE_MODIFIED: <line5> case WRITE: <line6> Subnet updatedSubnet = rootNode.getDataAfter(); <line7> ulnDatastoreUtil.submitSubnetToDs(initSubnetBuilder(updatedSubnet).build()); <line8> break; <line9> case DELETE: <line10> Subnet deletedSubnet = rootNode.getDataBefore(); <line11> ReadWriteTransaction rwTx = dataProvider.newReadWriteTransaction(); <line12> Optional<MappedSubnet> op = <line13> DataStoreHelper.removeIfExists( <line14> LogicalDatastoreType.OPERATIONAL, <line15> FaasIidFactory.mappedSubnetIid(gbpTenantId, deletedSubnet.getId()), <line16> rwTx); <line17> if (op.isPresent()) { <line18> DataStoreHelper.submitToDs(rwTx); <line19> } <line20> Uuid faasSubnetId = mappedSubnets.remove(deletedSubnet.getId()); <line21> if (faasSubnetId != null) { <line22> ulnDatastoreUtil.removeSubnetFromDsIfExists(faasTenantId, faasSubnetId); <line23> } <line24> break; <line25> default: <line26> break; <line27> } <line28> } <line29> } <line30> } <line31> 	<line7>	task4	
public class A { <line0> public Configuration configure(String resource) throws EPException { <line1> if (log.isDebugEnabled()) { <line2> } <line3> InputStream stream = getConfigurationInputStream(resource); <line4> ConfigurationParser.doConfigure(this, stream, resource); <line5> return this; <line6> } <line7> } <line8> 	<line2>	task4	
"public class A { <line0> private String _writeDataFile(String dat) { <line1> String fn = """"; <line2> StringReader stringReader = null; <line3> PrintWriter printWriter = null; <line4> try { <line5> String home = System.getProperty(""user.home""); <line6> home = home.replace('\\', '/'); <line7> fn = home + ""/"" + _getUniqueFileName(""dat"") + _counter; <line8> stringReader = new StringReader(dat); <line9> File dataFile = new File(fn); <line10> OutputStreamWriter w = new OutputStreamWriter(new FileOutputStream(dataFile), ""UTF-8""); <line11> printWriter = new PrintWriter(w); <line12> int c; <line13> while ((c = stringReader.read()) != -1) { <line14> printWriter.write(c); <line15> } <line16> } catch (Exception exc) { <line17> } finally { <line18> try { <line19> if (stringReader != null) { <line20> stringReader.close(); <line21> } <line22> } finally { <line23> if (printWriter != null) { <line24> printWriter.close(); <line25> } <line26> } <line27> } <line28> _counter++; <line29> return fn; <line30> } <line31> } <line32> "	<line17>	task4	
public class A { <line0> @Override <line1> public void activateObject(PooledObject<LdapConnection> pooledObject) throws LdapException { <line2> LdapConnection connection = pooledObject.getObject(); <line3> if (LOG.isDebugEnabled()) { <line4> } <line5> super.activateObject(pooledObject); <line6> ((MonitoringLdapConnection) connection).resetMonitors(); <line7> } <line8> } <line9> 	<line4>	task4	
public class A { <line0> @Teardown <line1> public void closeMqttClient() throws Exception { <line2> if (connection != null) { <line3> connection.disconnect(); <line4> } <line5> } <line6> } <line7> 	<line3>	task4	
"public class A { <line0> protected void addOnEntryActionToServiceCheckState(final Flow flow) { <line1> final DecisionState state = (DecisionState) flow.getState(STATE_DEFINITION_ID_SERVICE_CHECK); <line2> final EvaluateAction action = createEvaluateAction(""removeHostnameServiceInContextAction""); <line3> state.getEntryActionList().add(action); <line4> } <line5> } <line6> "	<line4>	task4	
"public class A { <line0> @Test <line1> public void test07InvalidPatchEntities() { <line2> Object thingId = THING_IDS.get(0); <line3> String urlParameters = <line4> ""{\""Locations\"": [\n"" <line5> + ""    {\n"" <line6> + ""      \""name\"": \""West Roof\"",\n"" <line7> + ""      \""description\"": \""West Roof\"",\n"" <line8> + ""      \""location\"": { \""type\"": \""Point\"", \""coordinates\"": [-117.05, 51.05] },\n"" <line9> + ""      \""encodingType\"": \""application/vnd.geo+json\""\n"" <line10> + ""    }\n"" <line11> + ""  ]}""; <line12> invalidPatchEntity(EntityType.THING, urlParameters, thingId); <line13> urlParameters = <line14> ""{\""Datastreams\"": [\n"" <line15> + ""    {\n"" <line16> + ""      \""unitOfMeasurement\"": {\n"" <line17> + ""        \""name\"": \""Lumen\"",\n"" <line18> + ""        \""symbol\"": \""lm\"",\n"" <line19> + ""        \""definition\"":"" <line20> + "" \""http://www.qudt.org/qudt/owl/1.0.0/unit/Instances.html#Lumen\""\n"" <line21> + ""      }}]}""; <line22> invalidPatchEntity(EntityType.THING, urlParameters, thingId); <line23> Object sensorId = SENSOR_IDS.get(0); <line24> urlParameters = <line25> ""{\""Datastreams\"": [\n"" <line26> + ""    {\n"" <line27> + ""      \""unitOfMeasurement\"": {\n"" <line28> + ""        \""name\"": \""Lumen\"",\n"" <line29> + ""        \""symbol\"": \""lm\"",\n"" <line30> + ""        \""definition\"":"" <line31> + "" \""http://www.qudt.org/qudt/owl/1.0.0/unit/Instances.html#Lumen\""}\n"" <line32> + ""        ,\""Thing\"":{\""@iot.id\"":"" <line33> + quoteIdForJson(thingId) <line34> + ""}"" <line35> + ""      }]}""; <line36> invalidPatchEntity(EntityType.SENSOR, urlParameters, sensorId); <line37> Object obsPropId = OBSPROP_IDS.get(0); <line38> urlParameters = <line39> ""{\""Datastreams\"": [\n"" <line40> + ""    {\n"" <line41> + ""      \""unitOfMeasurement\"": {\n"" <line42> + ""        \""name\"": \""Lumen\"",\n"" <line43> + ""        \""symbol\"": \""lm\"",\n"" <line44> + ""        \""definition\"":"" <line45> + "" \""http://www.qudt.org/qudt/owl/1.0.0/unit/Instances.html#Lumen\""}\n"" <line46> + ""        ,\""Thing\"":{\""@iot.id\"":"" <line47> + quoteIdForJson(thingId) <line48> + ""}"" <line49> + ""      }]}""; <line50> invalidPatchEntity(EntityType.OBSERVED_PROPERTY, urlParameters, obsPropId); <line51> Object datastreamId = DATASTREAM_IDS.get(0); <line52> urlParameters = <line53> ""{\""ObservedProperty\"": {\n"" <line54> + ""  \t\""name\"": \""Count\"",\n"" <line55> + ""\t\""definition\"": \""http://qudt.org/vocab/unit#Dimensionless\"",\n"" <line56> + ""\t\""name\"": \""Count is a dimensionless property.\"",\n"" <line57> + ""\t\""description\"": \""Count is a dimensionless property.\""\n"" <line58> + ""  } }""; <line59> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line60> urlParameters = <line61> ""{\""Sensor\"": {\n"" <line62> + ""  \t\""name\"": \""Acme Traffic 2000\"",  \n"" <line63> + ""  \t\""description\"": \""Acme Traffic 2000\"",  \n"" <line64> + ""  \t\""encodingType\"": \""application/pdf\"",\n"" <line65> + ""  \t\""metadata\"": \""Traffic counting device\""\n"" <line66> + ""  }}""; <line67> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line68> urlParameters = <line69> ""{"" + ""\""Thing\"": {"" + ""  \""name\"": \""test\"","" + ""  \""description\"": \""test\"""" + "" }"" + ""}""; <line70> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line71> urlParameters = <line72> ""{\""Observations\"": [\n"" <line73> + ""    {\n"" <line74> + ""      \""phenomenonTime\"": \""2015-03-01T00:00:00Z\"",\n"" <line75> + ""      \""result\"": 92122,\n"" <line76> + ""      \""resultQuality\"": \""High\""\n"" <line77> + ""    }\n"" <line78> + ""  ]}""; <line79> invalidPatchEntity(EntityType.DATASTREAM, urlParameters, datastreamId); <line80> } <line81> } <line82> "	<line2>	task4	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public static long getTotalDocumentCountForIndexAndType( <line2> String url, <line3> String index, <line4> String type, <line5> Map<String, Object> filter, <line6> Map<String, Object> mustNotFilter, <line7> HashMultimap<String, Object> shouldFilter) { <line8> String urlToQuery = buildURL(url, index, type); <line9> Map<String, Object> requestBody = new HashMap<String, Object>(); <line10> Map<String, Object> matchFilters = Maps.newHashMap(); <line11> if (filter == null) { <line12> matchFilters.put(""match_all"", new HashMap<String, String>()); <line13> } else { <line14> matchFilters.putAll(filter); <line15> } <line16> if (null != filter) { <line17> requestBody.put(QUERY, CommonUtils.buildQuery(matchFilters, mustNotFilter, shouldFilter)); <line18> } else { <line19> requestBody.put(QUERY, matchFilters); <line20> } <line21> String responseDetails = null; <line22> Gson gson = new GsonBuilder().create(); <line23> try { <line24> String requestJson = gson.toJson(requestBody, Object.class); <line25> responseDetails = CommonUtils.doHttpPost(urlToQuery, requestJson, new HashMap<>()); <line26> Map<String, Object> response = <line27> (Map<String, Object>) gson.fromJson(responseDetails, Object.class); <line28> return (long) (Double.parseDouble(response.get(""count"").toString())); <line29> } catch (Exception e) { <line30> ; <line31> } <line32> return -1; <line33> } <line34> } <line35> "	<line30>	task4	
"public class A { <line0> @Bean <line1> @Conditional(InsightsSAMLBeanInitializationCondition.class) <line2> public FilterChainProxy samlFilter() throws Exception { <line3> AuthenticationUtils.setSecurityFilterchain( <line4> new DefaultSecurityFilterChain( <line5> new AntPathRequestMatcher(""/metadata/**""), metadataDisplayFilter())); <line6> AuthenticationUtils.setSecurityFilterchain( <line7> new DefaultSecurityFilterChain( <line8> new AntPathRequestMatcher(""/saml/login/**""), samlEntryPoint())); <line9> AuthenticationUtils.setSecurityFilterchain( <line10> new DefaultSecurityFilterChain( <line11> new AntPathRequestMatcher(""/saml/SSO/**""), samlWebSSOProcessingFilter())); <line12> AuthenticationUtils.setSecurityFilterchain( <line13> new DefaultSecurityFilterChain( <line14> new AntPathRequestMatcher(""/saml/logout/**""), samlLogoutFilter())); <line15> AuthenticationUtils.setSecurityFilterchain( <line16> new DefaultSecurityFilterChain( <line17> new AntPathRequestMatcher(""/saml/SingleLogout/**""), samlLogoutProcessingFilter())); <line18> AuthenticationUtils.setSecurityFilterchain( <line19> new DefaultSecurityFilterChain( <line20> new AntPathRequestMatcher(""/user/insightsso/**""), insightsSSOProcessingFilter())); <line21> List<Filter> filters = new ArrayList<>(); <line22> filters.add(0, new InsightsCustomCsrfFilter()); <line23> filters.add(1, new InsightsCrossScriptingFilter()); <line24> filters.add(2, insightsServiceProcessingFilter()); <line25> filters.add(3, new InsightsResponseHeaderWriterFilter()); <line26> AuthenticationUtils.setSecurityFilterchain( <line27> new DefaultSecurityFilterChain(new AntPathRequestMatcher(""/**""), filters)); <line28> return new FilterChainProxy(AuthenticationUtils.getSecurityFilterchains()); <line29> } <line30> } <line31> "	<line3>	task4	
public class A { <line0> private ByteBuffer allocate(int length) { <line1> if (length > SUSPICIOUS_THRESHOLD) <line2> return DIRECT_BUFFERS ? ByteBuffer.allocateDirect(length) : ByteBuffer.allocate(length); <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> @Override <line1> public void inform(Event event) { <line2> if (event instanceof InsertBreak) { <line3> InsertBreak insertActivity = (InsertBreak) event; <line4> if (!insertActivity.getNewVehicle().isReturnToDepot()) { <line5> if (insertActivity.getIndex() >= insertActivity.getVehicleRoute().getActivities().size()) { <line6> insertActivity <line7> .getVehicleRoute() <line8> .getEnd() <line9> .setLocation(insertActivity.getActivity().getLocation()); <line10> } <line11> } <line12> VehicleRoute vehicleRoute = ((InsertBreak) event).getVehicleRoute(); <line13> if (!vehicleRoute.isEmpty()) { <line14> if (vehicleRoute.getVehicle() != ((InsertBreak) event).getNewVehicle()) { <line15> if (vehicleRoute.getVehicle().getBreak() != null) { <line16> boolean removed = <line17> vehicleRoute.getTourActivities().removeJob(vehicleRoute.getVehicle().getBreak()); <line18> } <line19> } <line20> } <line21> insertActivity <line22> .getVehicleRoute() <line23> .getTourActivities() <line24> .addActivity(insertActivity.getIndex(), ((InsertBreak) event).getActivity()); <line25> } <line26> } <line27> } <line28> 	<line18>	task4	
public class A { <line0> private long readLongInitParameter( <line1> final ServletContext c, final String paramName, final long defaultValue) { <line2> long val = -1; <line3> final String valStr = c.getInitParameter(paramName); <line4> if (valStr != null) { <line5> try { <line6> val = Long.parseLong(valStr); <line7> } catch (final NumberFormatException exc) { <line8> val = -1; <line9> } <line10> } <line11> if (val < 0) { <line12> val = defaultValue; <line13> } <line14> return val; <line15> } <line16> } <line17> 	<line12>	task4	
"public class A { <line0> public static Class<?> undecorateClass(Class<?> clazz, ClassLoader classLoader) throws Exception { <line1> if (!clazz.isInterface()) { <line2> throw new IllegalArgumentException(""Only interface classes are supported""); <line3> } <line4> final String className = clazz.getName() + UNDECORATED_CLASS_NAME_SUFFIX; <line5> try { <line6> return classLoader.loadClass(className); <line7> } catch (ClassNotFoundException e) { <line8> Logger log = LoggerFactory.getLogger(RuntimeContextInstantiationStrategyEnhancerHelper.class); <line9> return innerUndecorateInterface(className, clazz, classLoader); <line10> } <line11> } <line12> } <line13> "	<line9>	task4	
"public class A { <line0> public String getParticipantId( <line1> String applicationId, <line2> String hashedTokenValue, <line3> String studyId, <line4> Float studyVersion, <line5> AuditLogEventRequest auditRequest) { <line6> logger.entry(""Begin getParticipantId()""); <line7> HttpHeaders headers = null; <line8> EnrollmentBodyProvider bodyProvider = null; <line9> HttpEntity<EnrollmentBodyProvider> requestBody = null; <line10> ResponseEntity<?> responseEntity = null; <line11> String participantId = """"; <line12> try { <line13> headers = new HttpHeaders(); <line14> headers.setContentType(MediaType.APPLICATION_JSON); <line15> headers.set(""Authorization"", ""Bearer "" + oAuthService.getAccessToken()); <line16> AuditEventMapper.addAuditEventHeaderParams(headers, auditRequest); <line17> bodyProvider = new EnrollmentBodyProvider(); <line18> bodyProvider.setTokenIdentifier(hashedTokenValue); <line19> bodyProvider.setCustomStudyId(studyId); <line20> bodyProvider.setStudyVersion(String.valueOf(studyVersion)); <line21> requestBody = new HttpEntity<>(bodyProvider, headers); <line22> responseEntity = <line23> restTemplate.postForEntity(appConfig.getAddParticipantId(), requestBody, String.class); <line24> if (responseEntity.getStatusCode() == HttpStatus.OK) { <line25> participantId = (String) responseEntity.getBody(); <line26> auditRequest.setParticipantId(participantId); <line27> enrollAuditEventHelper.logEvent(PARTICIPANT_ID_RECEIVED, auditRequest); <line28> } <line29> } catch (Exception e) { <line30> enrollAuditEventHelper.logEvent(PARTICIPANT_ID_NOT_RECEIVED, auditRequest); <line31> throw e; <line32> } <line33> logger.exit(""getParticipantId() - Ends ""); <line34> return participantId; <line35> } <line36> } <line37> "	<line31>	task4	
"public class A { <line0> protected void loadResource(String resourceUri, XsltBuilder xslt) <line1> throws TransformerException, IOException { <line2> Source source = xslt.getUriResolver().resolve(resourceUri, null); <line3> if (source == null) { <line4> throw new IOException(""Cannot load schema resource "" + resourceUri); <line5> } else { <line6> xslt.setTransformerSource(source); <line7> } <line8> cacheCleared = false; <line9> } <line10> } <line11> "	<line2>	task4	
"public class A { <line0> @PUT <line1> @Path(""/{id}"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Consumes(MediaType.TEXT_PLAIN) <line4> @PermitAll <line5> @ApiOperation(""Edit a detection pipeline using a YAML config"") <line6> public Response updateDetectionPipelineApi( <line7> @Auth ThirdEyePrincipal user, <line8> @ApiParam(""yaml config"") String payload, <line9> @ApiParam(""the detection config id to edit"") @PathParam(""id"") long id, <line10> @ApiParam(""tuning window start time for tunable components"") @QueryParam(""startTime"") <line11> long startTime, <line12> @ApiParam(""tuning window end time for tunable components"") @QueryParam(""endTime"") <line13> long endTime) { <line14> Map<String, String> responseMessage = new HashMap<>(); <line15> try { <line16> validatePayload(payload); <line17> updateDetectionConfig(user, id, payload, startTime, endTime); <line18> } catch (ConfigValidationException e) { <line19> return processValidationErrorResponse( <line20> PROP_DETECTION, YamlOperations.UPDATING.name(), payload, e); <line21> } catch (NotAuthorizedException e) { <line22> return processBadAuthorizationResponse( <line23> PROP_DETECTION, YamlOperations.UPDATING.name(), payload, e); <line24> } catch (Exception e) { <line25> return processServerErrorResponse(PROP_DETECTION, YamlOperations.UPDATING.name(), payload, e); <line26> } <line27> responseMessage.put(""message"", ""Alert was updated successfully.""); <line28> responseMessage.put(""more-info"", ""Record updated id "" + id); <line29> responseMessage.put(PROP_DETECTION_ID, String.valueOf(id)); <line30> return Response.ok().entity(responseMessage).build(); <line31> } <line32> } <line33> "	<line27>	task4	
public class A { <line0> @Override <line1> public void preallocateSpace(StoreChannel storeChannel, long version) { <line2> int fileDescriptor = fileSystem.getFileDescriptor(storeChannel); <line3> var result = nativeAccess.tryPreallocateSpace(fileDescriptor, rotationThreshold.get()); <line4> if (result.isError()) { <line5> } <line6> } <line7> } <line8> 	<line5>	task4	
"public class A { <line0> @Test <line1> public void testAsynchronous() throws Exception { <line2> MockEndpoint mock = getMockEndpoint(""mock:result""); <line3> mock.expectedMessageCount(100); <line4> mock.expectsNoDuplicates(body()); <line5> StopWatch watch = new StopWatch(); <line6> for (int i = 0; i < 100; i++) { <line7> template.sendBody(""seda:start"", """" + i); <line8> } <line9> assertMockEndpointsSatisfied(20, TimeUnit.SECONDS); <line10> } <line11> } <line12> "	<line10>	task4	
"public class A { <line0> @Override <line1> public List<Account> listAccounts(ListAccountOptions options) throws IOException { <line2> String url = buildCanvasUrl(""accounts"", options.getOptionsMap()); <line3> return getListFromCanvas(url); <line4> } <line5> } <line6> "	<line2>	task4	
"public class A { <line0> @BeforeAll <line1> void setUp(ExtensionContext extensionContext) { <line2> super.beforeAllMayOverride(extensionContext); <line3> super.setupCoAndKeycloak(extensionContext, NAMESPACE); <line4> keycloakInstance.setRealm(""internal"", true); <line5> resourceManager.createResource( <line6> extensionContext, <line7> KafkaTemplates.kafkaEphemeral(oauthClusterName, 3) <line8> .editSpec() <line9> .editKafka() <line10> .withNewListeners() <line11> .addNewGenericKafkaListener() <line12> .withName(Constants.TLS_LISTENER_DEFAULT_NAME) <line13> .withPort(9093) <line14> .withType(KafkaListenerType.INTERNAL) <line15> .withTls(true) <line16> .withNewKafkaListenerAuthenticationOAuth() <line17> .withValidIssuerUri(keycloakInstance.getValidIssuerUri()) <line18> .withJwksExpirySeconds(keycloakInstance.getJwksExpireSeconds()) <line19> .withJwksRefreshSeconds(keycloakInstance.getJwksRefreshSeconds()) <line20> .withJwksEndpointUri(keycloakInstance.getJwksEndpointUri()) <line21> .withUserNameClaim(keycloakInstance.getUserNameClaim()) <line22> .withTlsTrustedCertificates( <line23> new CertSecretSourceBuilder() <line24> .withSecretName(KeycloakInstance.KEYCLOAK_SECRET_NAME) <line25> .withCertificate(KeycloakInstance.KEYCLOAK_SECRET_CERT) <line26> .build()) <line27> .withDisableTlsHostnameVerification(true) <line28> .endKafkaListenerAuthenticationOAuth() <line29> .endGenericKafkaListener() <line30> .endListeners() <line31> .endKafka() <line32> .endSpec() <line33> .build()); <line34> resourceManager.createResource( <line35> extensionContext, KafkaUserTemplates.tlsUser(oauthClusterName, OAUTH_CLIENT_NAME).build()); <line36> } <line37> } <line38> "	<line5>	task4	
public class A { <line0> @Override <line1> public void accept(Response response) { <line2> if (response == null) { <line3> context.setResponse(DEFAULT_RESPONSE); <line4> } else { <line5> context.setResponse(response); <line6> } <line7> context.resume(); <line8> } <line9> } <line10> 	<line3>	task4	
"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> final SQLException checkException(SQLException sqle) { <line2> boolean evict = false; <line3> SQLException nse = sqle; <line4> final SQLExceptionOverride exceptionOverride = poolEntry.getPoolBase().exceptionOverride; <line5> for (int depth = 0; <line6> delegate != ClosedConnection.CLOSED_CONNECTION && nse != null && depth < 10; <line7> depth++) { <line8> final String sqlState = nse.getSQLState(); <line9> if (sqlState != null && sqlState.startsWith(""08"") <line10> || nse instanceof SQLTimeoutException <line11> || ERROR_STATES.contains(sqlState) <line12> || ERROR_CODES.contains(nse.getErrorCode())) { <line13> if (exceptionOverride != null && exceptionOverride.adjudicate(nse) == DO_NOT_EVICT) { <line14> break; <line15> } <line16> evict = true; <line17> break; <line18> } else { <line19> nse = nse.getNextException(); <line20> } <line21> } <line22> if (evict) { <line23> SQLException exception = (nse != null) ? nse : sqle; <line24> leakTask.cancel(); <line25> poolEntry.evict(""(connection is broken)""); <line26> delegate = ClosedConnection.CLOSED_CONNECTION; <line27> } <line28> return sqle; <line29> } <line30> } <line31> "	<line24>	task4	
public class A { <line0> public static Optional<String> createIndexIfNotExists(EsConfig config, IndexParams indexParams) { <line1> try (EsClient esClient = EsClient.from(config)) { <line2> if (!EsService.existsIndex(esClient, indexParams.getIndexName())) { <line3> return Optional.of(EsService.createIndex(esClient, indexParams)); <line4> } <line5> } <line6> return Optional.empty(); <line7> } <line8> } <line9> 	<line1>	task4	
public class A { <line0> @Override <line1> @Transactional(readOnly = true) <line2> public List<Alert> getAlerts(User user, boolean includeRead, boolean includeExpired) <line3> throws APIException { <line4> return dao.getAlerts(user, includeRead, includeExpired); <line5> } <line6> } <line7> 	<line4>	task4	
public class A { <line0> protected void handleSessionEvent(ISessionListener listener, SessionEvent event) { <line1> try { <line2> listener.sessionChanged(event); <line3> } catch (RuntimeException e) { <line4> if (event.getType() != SessionEvent.TYPE_STOPPED <line5> && event.getType() != SessionEvent.TYPE_STOPPING) { <line6> throw e; <line7> } <line8> } <line9> } <line10> } <line11> 	<line8>	task4	
public class A { <line0> @Override <line1> public void cancel(ServiceContext ctx) { <line2> clusterMgr.stopClusterIfExists(clusterId); <line3> } <line4> } <line5> 	<line3>	task4	
public class A { <line0> @Override <line1> public void rollback() { <line2> try { <line3> tm.rollback(); <line4> } catch (Exception e) { <line5> throw new RuntimeException(e); <line6> } <line7> } <line8> } <line9> 	<line3>	task4	
"public class A { <line0> public static List<NamedAggregationOperator> loadOperators( <line1> final NodeSettingsRO settings, final DataTableSpec spec) throws InvalidSettingsException { <line2> final String[] resultColNames = settings.getStringArray(CNFG_RESULT_COL_NAMES); <line3> final String[] aggrMethods = settings.getStringArray(CNFG_AGGR_METHODS); <line4> final boolean[] inclMissingVals = settings.getBooleanArray(CNFG_INCL_MISSING_VALS); <line5> final List<NamedAggregationOperator> colAggrList = new LinkedList<>(); <line6> if (aggrMethods.length != resultColNames.length) { <line7> throw new InvalidSettingsException( <line8> ""Name array and "" + ""aggregation method array should be of equal size""); <line9> } <line10> for (int i = 0, length = aggrMethods.length; i < length; i++) { <line11> final String resultColName = resultColNames[i]; <line12> final AggregationMethod method = AggregationMethods.getMethod4Id(aggrMethods[i]); <line13> final boolean inclMissingVal = inclMissingVals[i]; <line14> NamedAggregationOperator operator = <line15> new NamedAggregationOperator(resultColName, method, inclMissingVal); <line16> if (operator.hasOptionalSettings()) { <line17> try { <line18> NodeSettingsRO operatorSettings = settings.getNodeSettings(createSettingsKey(operator)); <line19> if (spec != null) { <line20> operator.loadSettingsFrom(operatorSettings, spec); <line21> } else { <line22> operator.loadValidatedSettings(operatorSettings); <line23> } <line24> } catch (Exception e) { <line25> } <line26> } <line27> colAggrList.add(operator); <line28> } <line29> return colAggrList; <line30> } <line31> } <line32> "	<line25>	task4	
public class A { <line0> @Override <line1> public void accept(Range t, Long u) { <line2> if (t.getLower() == -4.0) { <line3> Assert.assertEquals(2, u, 0.0); <line4> } <line5> if (t.getLower() == 0.0) { <line6> Assert.assertEquals(1, u, 0.0); <line7> } <line8> if (t.getLower() == 4.0) { <line9> Assert.assertEquals(2, u, 0.0); <line10> } <line11> } <line12> } <line13> 	<line2>	task4	
public class A { <line0> @Override <line1> public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { <line2> if (!(msg instanceof DecodedStreamData)) { <line3> return; <line4> } <line5> DecodedStreamData decodedStreamData = (DecodedStreamData) msg; <line6> decodedStreamData.accept( <line7> new DecodedStreamData.Visitor() { <line8> @Override <line9> public void visit(Mpeg2DecodedStreamData decodedStreamData) { <line10> handleMpeg2(decodedStreamData.getListOfTypes()); <line11> } <line12>  <line13> @Override <line14> public void visit(Mpeg4DecodedStreamData decodedStreamData) { <line15> handleNALUnits(decodedStreamData.getNalUnits()); <line16> } <line17> }); <line18> } <line19> } <line20> 	<line3>	task4	
public class A { <line0> private void populateFieldInfosFromPojo(ColumnDefinitions rsMetaData) { <line1> fieldInfos = Lists.newArrayList(); <line2> Field[] fields = pojoClass.getDeclaredFields(); <line3> for (int i = 0; i < rsMetaData.size(); i++) { <line4> String columnName = rsMetaData.getName(i); <line5> String pojoField = getMatchingField(fields, columnName); <line6> if (pojoField != null && pojoField.length() != 0) { <line7> fieldInfos.add(new FieldInfo(columnName, pojoField, null)); <line8> } else { <line9> } <line10> } <line11> } <line12> } <line13> 	<line9>	task4	
"public class A { <line0> public SCMGetCrlsResponseProto getCrls(SCMGetCrlsRequestProto request) throws IOException { <line1> List<CRLInfo> crls = impl.getCrls(request.getCrlIdList()); <line2> SCMGetCrlsResponseProto.Builder builder = SCMGetCrlsResponseProto.newBuilder(); <line3> for (CRLInfo crl : crls) { <line4> try { <line5> builder.addCrlInfos(crl.getProtobuf()); <line6> } catch (SCMSecurityException e) { <line7> throw new SCMSecurityException(""Fail in parsing CRL info"", e); <line8> } <line9> } <line10> return builder.build(); <line11> } <line12> } <line13> "	<line7>	task4	
public class A { <line0> @Override <line1> public DeleteResponse delete(DeleteRequest request) { <line2> try { <line3> Thread.sleep(deleteDelayMillis); <line4> } catch (InterruptedException e) { <line5> } <line6> return provider.delete(request); <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> @Override <line1> public void entriesDeleted(Collection<String> entries) { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Override <line1> public DocumentDTO addDocument(DocumentDTO doc) { <line2> try { <line3> Document d = doc.toEntity(); <line4> em.persist(d); <line5> em.flush(); <line6> em.refresh(d); <line7> return new DocumentDTO(d); <line8> } catch (Exception e) { <line9> return null; <line10> } <line11> } <line12> } <line13> 	<line9>	task4	
"public class A { <line0> public JobRunnable SubmitConcurrentJobs( <line1> final int threadCount, <line2> AppConfig config, <line3> final boolean killThreads, <line4> boolean interruptThreads, <line5> final Answer<Integer> responseAnswer, <line6> final Answer<QueueStatusBean> timeoutResponseAnswer, <line7> final String jobIdResponse) <line8> throws IOException, InterruptedException, QueueException, NotAuthorizedException, <line9> BusyException, TimeoutException, Exception { <line10> LauncherDelegator delegator = new LauncherDelegator(config); <line11> final LauncherDelegator mockDelegator = Mockito.spy(delegator); <line12> final List<String> listArgs = new ArrayList<String>(); <line13> TempletonControllerJob mockCtrl = Mockito.mock(TempletonControllerJob.class); <line14> doReturn(jobIdResponse).when(mockCtrl).getSubmittedId(); <line15> doReturn(mockCtrl).when(mockDelegator).getTempletonController(); <line16> doAnswer(responseAnswer) <line17> .when(mockDelegator) <line18> .runTempletonControllerJob(any(TempletonControllerJob.class), any(List.class)); <line19> doAnswer(timeoutResponseAnswer) <line20> .when(mockDelegator) <line21> .killJob(any(String.class), any(String.class)); <line22> doNothing() <line23> .when(mockDelegator) <line24> .registerJob(any(String.class), any(String.class), any(String.class), any()); <line25> JobRunnable submitJobRunnable = <line26> new JobRunnable() { <line27> @Override <line28> public void run() { <line29> try { <line30> int threadId = waitForAllThreadsToStart(this, threadCount); <line31> mockDelegator.enqueueController(""admin"", null, """", listArgs); <line32> } catch (Throwable ex) { <line33> exception = ex; <line34> } <line35> } <line36> }; <line37> executeJobOperations(submitJobRunnable, threadCount, killThreads, interruptThreads); <line38> return submitJobRunnable; <line39> } <line40> } <line41> "	<line31>	task4	
public class A { <line0> private void extractRestCheckUrl() { <line1> Configuration conf = HadoopUtil.getCurrentConfiguration(); <line2> yarnMasterUrlBase = HadoopConfExtractor.extractYarnMasterUrl(conf); <line3> jobHistoryUrlBase = HadoopConfExtractor.extractJobHistoryUrl(yarnMasterUrlBase, conf); <line4> } <line5> } <line6> 	<line4>	task4	
public class A { <line0> private CharSequence getString(long lo, long hi, CharSequence errorMessage) <line1> throws BadProtocolException { <line2> CharacterStoreEntry e = characterStore.newEntry(); <line3> if (Chars.utf8Decode(lo, hi, e)) { <line4> return characterStore.toImmutable(); <line5> } else { <line6> throw BadProtocolException.INSTANCE; <line7> } <line8> } <line9> } <line10> 	<line6>	task4	
public class A { <line0> public static int getItemCount(ResultModel model) { <line1> if (model instanceof Countable) { <line2> return ((Countable) model).size(); <line3> } <line4> Class modelClass = model.getClass(); <line5> List<Field> fields = modelFieldMap.get(modelClass.getName()); <line6> if (fields == null) { <line7> fields = new ArrayList<Field>(); <line8> Field[] declaredFields = modelClass.getDeclaredFields(); <line9> for (int i = 0; i < declaredFields.length; i++) { <line10> Field field = declaredFields[i]; <line11> Class<?> fieldClass = field.getType(); <line12> if (Collection.class.isAssignableFrom(fieldClass) <line13> || Map.class.isAssignableFrom(fieldClass) <line14> || Countable.class.isAssignableFrom(fieldClass) <line15> || fieldClass.isArray()) { <line16> field.setAccessible(true); <line17> fields.add(field); <line18> } <line19> } <line20> List<Field> old_fields = modelFieldMap.putIfAbsent(modelClass.getName(), fields); <line21> if (old_fields != null) { <line22> fields = old_fields; <line23> } <line24> } <line25> int count = 0; <line26> try { <line27> for (int i = 0; i < fields.size(); i++) { <line28> Field field = fields.get(i); <line29> if (!field.isAccessible()) { <line30> field.setAccessible(true); <line31> } <line32> Object value = field.get(model); <line33> if (value != null) { <line34> if (value instanceof Collection) { <line35> count += ((Collection) value).size(); <line36> } else if (value.getClass().isArray()) { <line37> count += Array.getLength(value); <line38> } else if (value instanceof Map) { <line39> count += ((Map) value).size(); <line40> } else if (value instanceof Countable) { <line41> count += ((Countable) value).size(); <line42> } <line43> } <line44> } <line45> } catch (Exception e) { <line46> } <line47> return count > 0 ? count : 1; <line48> } <line49> } <line50> 	<line46>	task4	
"public class A { <line0> public <O extends ObjectType> ObjectWrapper<O> createObjectWrapper( <line1> String displayName, <line2> String description, <line3> PrismObject<O> object, <line4> ContainerStatus status, <line5> AuthorizationPhaseType authorizationPhase, <line6> Task task) { <line7> if (authorizationPhase == null) { <line8> authorizationPhase = AuthorizationPhaseType.REQUEST; <line9> } <line10> try { <line11> OperationResult result = task.getResult(); <line12> PrismObjectDefinition<O> objectDefinitionForEditing = <line13> modelServiceLocator <line14> .getModelInteractionService() <line15> .getEditObjectDefinition(object, authorizationPhase, task, result); <line16> if (LOGGER.isTraceEnabled()) { <line17> } <line18> RefinedObjectClassDefinition objectClassDefinitionForEditing = null; <line19> if (isShadow(object)) { <line20> PrismReference resourceRef = object.findReference(ShadowType.F_RESOURCE_REF); <line21> PrismObject<ResourceType> resource = resourceRef.getValue().getObject(); <line22> Validate.notNull(resource, ""No resource object in the resourceRef""); <line23> objectClassDefinitionForEditing = <line24> modelServiceLocator <line25> .getModelInteractionService() <line26> .getEditObjectClassDefinition( <line27> (PrismObject<ShadowType>) object, resource, authorizationPhase); <line28> } <line29> return createObjectWrapper( <line30> displayName, <line31> description, <line32> object, <line33> objectDefinitionForEditing, <line34> objectClassDefinitionForEditing, <line35> status, <line36> result); <line37> } catch (SchemaException | ConfigurationException | ObjectNotFoundException ex) { <line38> throw new SystemException(ex); <line39> } <line40> } <line41> } <line42> "	<line17>	task4	
public class A { <line0> @Override <line1> public int getSupplementalCount(int year) { <line2> try { <line3> return calendarDao.getCalendarSupplementalCount(year); <line4> } catch (DataAccessException ex) { <line5> return 0; <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> private void removeSubscription() { <line1> synchronized (upnpLock) { <line2> if (service.isRegistered(this)) { <line3> for (String subscription : SERVICE_SUBSCRIPTIONS) { <line4> Boolean state = subscriptionState.get(subscription); <line5> if (state != null && state) { <line6> service.removeSubscription(this, subscription); <line7> } <line8> } <line9> } <line10> subscriptionState = new HashMap<>(); <line11> } <line12> } <line13> } <line14> 	<line6>	task4	
"public class A { <line0> @Test <line1> public void sendBatchedEventsUsingJavaLogging() throws Exception { <line2> String token = TestUtil.createHttpEventCollectorToken(httpEventCollectorName); <line3> String loggerName = ""splunkBatchLogger""; <line4> HashMap<String, String> userInputs = new HashMap<String, String>(); <line5> userInputs.put(""user_httpEventCollector_token"", token); <line6> userInputs.put(""user_batch_interval"", ""0""); <line7> userInputs.put(""user_batch_size_bytes"", ""0""); <line8> userInputs.put(""user_batch_size_count"", ""0""); <line9> userInputs.put(""user_logger_name"", loggerName); <line10> TestUtil.resetJavaLoggingConfiguration( <line11> ""logging_template.properties"", ""logging.properties"", userInputs); <line12> Date date = new Date(); <line13> String jsonMsg = <line14> String.format( <line15> ""{EventDate:%s, EventMsg:'this is a test event for java logging"" <line16> + "" sendBatchedEventsUsingJavaLogging}"", <line17> date.toString()); <line18> Logger logger = Logger.getLogger(loggerName); <line19> TestUtil.verifyOneAndOnlyOneEventSentToSplunk(jsonMsg); <line20> TestUtil.deleteHttpEventCollectorToken(httpEventCollectorName); <line21> } <line22> } <line23> "	<line19>	task4	
"public class A { <line0> @Override <line1> public void commit(Xid xid, boolean flag) throws XAException { <line2> if (this.xid == null || !this.xid.equals(xid)) { <line3> throw newXAException(XAER_INVAL, ""Invalid Xid""); <line4> } <line5> this.xid = null; <line6> try { <line7> owner.connection.commit(); <line8> } catch (SQLException e) { <line9> throw newXAException(XAER_RMERR, ""Cannot commit"", e); <line10> } finally { <line11> try { <line12> owner.connection.setAutoCommit(true); <line13> } catch (SQLException e) { <line14> } <line15> } <line16> } <line17> } <line18> "	<line14>	task4	
public class A { <line0> @After <line1> public void teardownShell() { <line2> if (config.exists()) { <line3> if (!config.delete()) { <line4> } <line5> } <line6> shell.shutdown(); <line7> } <line8> } <line9> 	<line4>	task4	
public class A { <line0> @Override <line1> public synchronized void hostsChanged(Set<Host> hosts) { <line2> hosts.remove(localHost); <line3> createForwarders(hosts); <line4> deleteForwarders(hosts); <line5> } <line6> } <line7> 	<line3>	task4	
public class A { <line0> private void addDeprecatedAnnotationAssertion(@Nonnull List<OWLOntologyChange> changes) { <line1> OWLAnnotationAxiom ax = <line2> dataFactory.getOWLAnnotationAssertionAxiom( <line3> dataFactory.getOWLDeprecated(), <line4> info.getEntityToDeprecate().getIRI(), <line5> dataFactory.getOWLLiteral(true)); <line6> changes.add(new AddAxiom(getHomeOntology(), ax)); <line7> } <line8> } <line9> 	<line6>	task4	
"public class A { <line0> @Override <line1> public void createFrontierReportMonitorTable() { <line2> HarvestDBConnection.updateTable(""frontierreportmonitor"", 1); <line3> } <line4> } <line5> "	<line2>	task4	
public class A { <line0> public void visitDenyUncoveredHttpMethods( <line1> WebAppContext context, Descriptor descriptor, XmlParser.Node node) { <line2> if (context.getSecurityHandler() == null) { <line3> return; <line4> } <line5> ((ConstraintAware) context.getSecurityHandler()).setDenyUncoveredHttpMethods(true); <line6> } <line7> } <line8> 	<line3>	task4	
public class A { <line0> public static com.liferay.commerce.application.model.CommerceApplicationModelSoap[] <line1> getCommerceApplicationModels(long commerceApplicationBrandId, int start, int end) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.commerce.application.model.CommerceApplicationModel> returnValue = <line5> CommerceApplicationModelServiceUtil.getCommerceApplicationModels( <line6> commerceApplicationBrandId, start, end); <line7> return com.liferay.commerce.application.model.CommerceApplicationModelSoap.toSoapModels( <line8> returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	<line10>	task4	
"public class A { <line0> public static java.util.List<com.liferay.asset.kernel.model.AssetCategory> getChildCategories( <line1> HttpPrincipal httpPrincipal, <line2> long parentCategoryId, <line3> int start, <line4> int end, <line5> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.asset.kernel.model.AssetCategory> <line6> orderByComparator) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> AssetCategoryServiceUtil.class, <line12> ""getChildCategories"", <line13> _getChildCategoriesParameterTypes11); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, parentCategoryId, start, end, orderByComparator); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (java.util.List<com.liferay.asset.kernel.model.AssetCategory>) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	<line27>	task4	
public class A { <line0> @Override <line1> public void onSuccess(Request result) { <line2> if (callback != null) { <line3> callback.onSuccess(t); <line4> } <line5> } <line6> } <line7> 	<line2>	task4	
public class A { <line0> public void recompileRules(final String kbName, String userId) { <line1> List<UdrRule> ruleList = rulePersistenceService.findAll(); <line2> if (!CollectionUtils.isEmpty(ruleList)) { <line3> ruleManagementService.createKnowledgeBaseFromUdrRules(kbName, ruleList, userId); <line4> } else { <line5> KnowledgeBase kb = rulePersistenceService.findUdrKnowledgeBase(kbName); <line6> if (kb != null) { <line7> List<Rule> rules = rulePersistenceService.findRulesByKnowledgeBaseId(kb.getId()); <line8> if (CollectionUtils.isEmpty(rules)) { <line9> ruleManagementService.deleteKnowledgeBase(kbName); <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	<line10>	task4	
"public class A { <line0> private void throwExceptionForNullOrganization(Organization organization) { <line1> if (organization == null) { <line2> String msg = ""Organization not found""; <line3> throw new CustomWebApplicationException(msg, HttpStatus.SC_NOT_FOUND); <line4> } <line5> } <line6> } <line7> "	<line3>	task4	
"public class A { <line0> public void loadCards(ExileView exile, BigCard bigCard, UUID gameId) { <line1> boolean changed = cards.loadCards(exile, bigCard, gameId, true); <line2> String titel = name + "" ("" + exile.size() + ')'; <line3> setTitle(titel); <line4> this.setTitelBarToolTip(titel); <line5> if (!exile.isEmpty()) { <line6> show(); <line7> if (changed) { <line8> try { <line9> this.setIcon(false); <line10> } catch (PropertyVetoException ex) { <line11> } <line12> } <line13> } else { <line14> this.hideDialog(); <line15> } <line16> } <line17> } <line18> "	<line11>	task4	
public class A { <line0> @Override <line1> public CompletableFuture<Message> query(Message request) { <line2> Timer.Context timerContext = null; <line3> MetaServiceProtos.MetaServiceRequestProto.TypeCase type = null; <line4> if (currentGroup == null) { <line5> try { <line6> List<RaftGroup> x = <line7> StreamSupport.stream(raftServer.getGroups().spliterator(), false) <line8> .filter(group -> group.getGroupId().equals(metadataGroupId)) <line9> .collect(Collectors.toList()); <line10> if (x.size() == 1) { <line11> currentGroup = x.get(0); <line12> } <line13> } catch (IOException e) { <line14> e.printStackTrace(); <line15> } <line16> } <line17> MetaServiceProtos.MetaServiceRequestProto req; <line18> try { <line19> req = MetaServiceProtos.MetaServiceRequestProto.parseFrom(request.getContent()); <line20> } catch (InvalidProtocolBufferException e) { <line21> e.printStackTrace(); <line22> return null; <line23> } <line24> type = req.getTypeCase(); <line25> try { <line26> timerContext = logServiceMetaDataMetrics.getTimer(type.name()).time(); <line27> switch (type) { <line28> case CREATELOG: <line29> return processCreateLogRequest(req); <line30> case LISTLOGS: <line31> return processListLogsRequest(); <line32> case GETLOG: <line33> return processGetLogRequest(req); <line34> case DELETELOG: <line35> return processDeleteLog(req); <line36> default: <line37> CompletableFuture<Message> reply = super.query(request); <line38> return reply; <line39> } <line40> } catch (Exception e) { <line41> throw e; <line42> } finally { <line43> if (timerContext != null) { <line44> timerContext.stop(); <line45> } <line46> } <line47> } <line48> } <line49> 	<line41>	task4	
public class A { <line0> @Override <line1> protected void doBeginRead() throws Exception { <line2> if (readInProgress) { <line3> return; <line4> } <line5> ChannelPipeline pipeline = pipeline(); <line6> Queue<Object> inboundBuffer = this.inboundBuffer; <line7> if (inboundBuffer.isEmpty()) { <line8> readInProgress = true; <line9> return; <line10> } <line11> final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get(); <line12> final Integer stackDepth = threadLocals.localChannelReaderStackDepth(); <line13> if (stackDepth < MAX_READER_STACK_DEPTH) { <line14> threadLocals.setLocalChannelReaderStackDepth(stackDepth + 1); <line15> try { <line16> for (; ; ) { <line17> Object received = inboundBuffer.poll(); <line18> if (received == null) { <line19> break; <line20> } <line21> pipeline.fireChannelRead(received); <line22> } <line23> pipeline.fireChannelReadComplete(); <line24> } finally { <line25> threadLocals.setLocalChannelReaderStackDepth(stackDepth); <line26> } <line27> } else { <line28> try { <line29> eventLoop().execute(readTask); <line30> } catch (Throwable cause) { <line31> close(); <line32> peer.close(); <line33> PlatformDependent.throwException(cause); <line34> } <line35> } <line36> } <line37> } <line38> 	<line31>	task4	
public class A { <line0> private void checkTimeElapsedSinceLastExec(int sinceLastModified) { <line1> if (sinceLastModified > tickFrequencyInSeconds) { <line2> } <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> protected ResultSet doQueryResult(PreparedStatement ps) throws SQLException { <line1> final ResultSet rs = executeQuery(ps); <line2> if (!isUseFunctionalResultSet()) { <line3> return rs; <line4> } <line5> if (isInternalDebugEnabled()) { <line6> } <line7> final FetchBean selbean = FetchAssistContext.getFetchBeanOnThread(); <line8> final TnFetchAssistResultSet wrapper; <line9> if (OutsideSqlContext.isExistOutsideSqlContextOnThread()) { <line10> final OutsideSqlContext context = OutsideSqlContext.getOutsideSqlContextOnThread(); <line11> final boolean offsetByCursorForcedly = context.isOffsetByCursorForcedly(); <line12> final boolean limitByCursorForcedly = context.isLimitByCursorForcedly(); <line13> wrapper = <line14> createFunctionalResultSet(rs, selbean, offsetByCursorForcedly, limitByCursorForcedly); <line15> } else { <line16> wrapper = createFunctionalResultSet(rs, selbean, false, false); <line17> } <line18> return wrapper; <line19> } <line20> } <line21> 	<line6>	task4	
public class A { <line0> @Override <line1> public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) <line2> throws IOException { <line3> DELEGATE.createSymbolicLink(link, target, attrs); <line4> } <line5> } <line6> 	<line3>	task4	
public class A { <line0> public static Date resolveAbsoluteDate(final String str) throws LensException { <line1> try { <line2> return stringToDateCache.get( <line3> str, () -> ABSDATE_PARSER.get().parse(getAbsDateFormatString(str))); <line4> } catch (Exception e) { <line5> throw new LensException( <line6> LensCubeErrorCode.WRONG_TIME_RANGE_FORMAT.getLensErrorInfo(), ABSDATE_FMT, str); <line7> } <line8> } <line9> } <line10> 	<line5>	task4	
"public class A { <line0> private void sendReplyFromPostmaster(Mail mail, String stringContent) { <line1> try { <line2> MailAddress notifier = getMailetContext().getPostmaster(); <line3> MailAddress senderMailAddress = mail.getMaybeSender().get(); <line4> MimeMessage message = mail.getMessage(); <line5> MimeMessage reply = new MimeMessage(Session.getDefaultInstance(System.getProperties(), null)); <line6> InternetAddress[] rcptAddr = new InternetAddress[1]; <line7> rcptAddr[0] = senderMailAddress.toInternetAddress(); <line8> reply.setRecipients(Message.RecipientType.TO, rcptAddr); <line9> reply.setFrom(notifier.toInternetAddress()); <line10> MimeMultipart multipart = new MimeMultipart(); <line11> MimeBodyPart part = new MimeBodyPart(); <line12> part.setContent(stringContent, ""text/plain""); <line13> part.setHeader(RFC2822Headers.CONTENT_TYPE, ""text/plain""); <line14> multipart.addBodyPart(part); <line15> reply.setContent(multipart); <line16> reply.setHeader(RFC2822Headers.CONTENT_TYPE, multipart.getContentType()); <line17> Set<MailAddress> recipients = new HashSet<>(); <line18> recipients.add(senderMailAddress); <line19> if (reply.getHeader(RFC2822Headers.DATE) == null) { <line20> reply.setHeader( <line21> RFC2822Headers.DATE, DateFormats.RFC822_DATE_FORMAT.format(LocalDateTime.now())); <line22> } <line23> String subject = message.getSubject(); <line24> if (subject == null) { <line25> subject = """"; <line26> } <line27> if (subject.indexOf(""Re:"") == 0) { <line28> reply.setSubject(subject); <line29> } else { <line30> reply.setSubject(""Re:"" + subject); <line31> } <line32> reply.setHeader(RFC2822Headers.IN_REPLY_TO, message.getMessageID()); <line33> getMailetContext().sendMail(notifier, recipients, reply); <line34> } catch (Exception e) { <line35> } <line36> } <line37> } <line38> "	<line35>	task4	
"public class A { <line0> private void loadDomain() { <line1> if (null == domain) throw new RuntimeException(""No security domain specified""); <line2> missingContainer.clear(); <line3> getView().reset(); <line4> ModelNode operation = new ModelNode(); <line5> operation.get(OP).set(READ_RESOURCE_OPERATION); <line6> operation.get(ADDRESS).set(Baseadress.get()); <line7> operation.get(ADDRESS).add(""subsystem"", ""security""); <line8> operation.get(ADDRESS).add(""security-domain"", domain); <line9> operation.get(RECURSIVE).set(true); <line10> operation.get(""recursive-depth"").set(2); <line11> dispatcher.execute( <line12> new DMRAction(operation), <line13> new SimpleCallback<DMRResponse>() { <line14> @Override <line15> public void onSuccess(DMRResponse result) { <line16> ModelNode response = result.get(); <line17> if (response.isFailure()) { <line18> } else { <line19> ModelNode payload = response.get(RESULT); <line20> for (SubResource subResource : SubResource.values()) { <line21> String type = subResource.getType(); <line22> if (payload.hasDefined(type)) { <line23> List<Property> modules = <line24> payload <line25> .get(type) <line26> .get(""classic"") <line27> .get(subResource.getModuleDef()) <line28> .asPropertyList(); <line29> getView().updateSubResource(subResource, modules); <line30> } else { <line31> missingContainer.add(subResource); <line32> } <line33> } <line34> } <line35> } <line36> }); <line37> } <line38> } <line39> "	<line18>	task4	
"public class A { <line0> public void deleteMachine(final MrMachine machine) { <line1> doProblemFactChange( <line2> scoreDirector -> { <line3> MachineReassignment machineReassignment = scoreDirector.getWorkingSolution(); <line4> MrMachine workingMachine = scoreDirector.lookUpWorkingObject(machine); <line5> if (workingMachine == null) { <line6> return; <line7> } <line8> for (MrProcessAssignment processAssignment : <line9> machineReassignment.getProcessAssignmentList()) { <line10> if (processAssignment.getOriginalMachine() == workingMachine) { <line11> scoreDirector.beforeProblemPropertyChanged(processAssignment); <line12> processAssignment.setOriginalMachine(null); <line13> scoreDirector.afterProblemPropertyChanged(processAssignment); <line14> } <line15> if (processAssignment.getMachine() == workingMachine) { <line16> scoreDirector.beforeVariableChanged(processAssignment, ""machine""); <line17> processAssignment.setMachine(null); <line18> scoreDirector.afterVariableChanged(processAssignment, ""machine""); <line19> } <line20> } <line21> ArrayList<MrMachine> machineList = new ArrayList<>(machineReassignment.getMachineList()); <line22> machineReassignment.setMachineList(machineList); <line23> scoreDirector.beforeProblemFactRemoved(workingMachine); <line24> machineList.remove(workingMachine); <line25> scoreDirector.afterProblemFactRemoved(workingMachine); <line26> scoreDirector.triggerVariableListeners(); <line27> }); <line28> } <line29> } <line30> "	<line1>	task4	
public class A { <line0> @Deprecated <line1> public static com.liferay.commerce.product.model.CommerceChannelRelSoap[] getCommerceChannelRels( <line2> String className, <line3> long classPK, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.commerce.product.model.CommerceChannelRel> <line8> orderByComparator) <line9> throws RemoteException { <line10> try { <line11> java.util.List<com.liferay.commerce.product.model.CommerceChannelRel> returnValue = <line12> CommerceChannelRelServiceUtil.getCommerceChannelRels( <line13> className, classPK, start, end, orderByComparator); <line14> return com.liferay.commerce.product.model.CommerceChannelRelSoap.toSoapModels(returnValue); <line15> } catch (Exception exception) { <line16> throw new RemoteException(exception.getMessage()); <line17> } <line18> } <line19> } <line20> 	<line16>	task4	
public class A { <line0> @Override <line1> protected synchronized void startScan() { <line2> Future<?> scanTask = this.scanTask; <line3> if (scanTask == null || scanTask.isDone()) { <line4> scanTask = scheduler.submit(this::discoverDevices); <line5> } <line6> } <line7> } <line8> 	<line4>	task4	
public class A { <line0> @Override <line1> public void resetHttpClient() { <line2> destroy(); <line3> try { <line4> afterPropertiesSet(); <line5> } catch (IOReactorException ioReactorException) { <line6> } <line7> } <line8> } <line9> 	<line6>	task4	
"public class A { <line0> public static List<SourceOutput> parseSourceOutputs(String raw, PulseaudioClient client) { <line1> List<SourceOutput> items = new ArrayList<>(); <line2> String[] parts = raw.split(""index: ""); <line3> if (parts.length <= 1) { <line4> return items; <line5> } <line6> for (int i = 1; i < parts.length; i++) { <line7> String[] lines = parts[i].split(""\n""); <line8> Hashtable<String, String> properties = new Hashtable<>(); <line9> int id = 0; <line10> try { <line11> id = Integer.valueOf(lines[0].trim()); <line12> } catch (NumberFormatException e) { <line13> Matcher matcher = FALL_BACK_PATTERN.matcher(lines[0].trim()); <line14> if (matcher.find()) { <line15> id = Integer.valueOf(matcher.group(1)); <line16> properties.put(matcher.group(2).trim(), matcher.group(3).trim()); <line17> } <line18> } <line19> for (int j = 1; j < lines.length; j++) { <line20> Matcher matcher = PATTERN.matcher(lines[j]); <line21> if (matcher.find()) { <line22> properties.put(matcher.group(1).trim(), matcher.group(2).trim()); <line23> } <line24> } <line25> if (properties.containsKey(""source"")) { <line26> SourceOutput item = <line27> new SourceOutput( <line28> id, <line29> properties.get(""source""), <line30> client.getModule(getNumberValue(properties.get(""module"")))); <line31> if (properties.containsKey(""state"")) { <line32> try { <line33> item.setState(AbstractAudioDeviceConfig.State.valueOf(properties.get(""state""))); <line34> } catch (IllegalArgumentException e) { <line35> } <line36> } <line37> if (properties.containsKey(""muted"")) { <line38> item.setMuted(""yes"".equalsIgnoreCase(properties.get(""muted""))); <line39> } <line40> if (properties.containsKey(""volume"")) { <line41> item.setVolume(Integer.valueOf(parseVolume(properties.get(""volume"")))); <line42> } <line43> if (properties.containsKey(""source"")) { <line44> item.setSource( <line45> client.getSource(Integer.valueOf(getNumberValue(properties.get(""source""))))); <line46> } <line47> items.add(item); <line48> } <line49> } <line50> return items; <line51> } <line52> } <line53> "	<line35>	task4	
public class A { <line0> @Override <line1> public void caseAAssignmentStmIR(AAssignmentStmIR node) throws AnalysisException { <line2> SStmIR newNode = null; <line3> if (node.getTarget() instanceof AMapSeqStateDesignatorIR) { <line4> AMapSeqStateDesignatorIR target = (AMapSeqStateDesignatorIR) node.getTarget(); <line5> SExpIR col = target.getMapseq().apply(converter); <line6> SExpIR index = target.getExp(); <line7> SExpIR value = node.getExp(); <line8> AMapSeqUpdateStmIR mapSeqUpd = new AMapSeqUpdateStmIR(); <line9> mapSeqUpd.setCol(col); <line10> mapSeqUpd.setIndex(index.clone()); <line11> mapSeqUpd.setValue(value.clone()); <line12> mapSeqUpd.setSourceNode(node.getSourceNode()); <line13> mapSeqUpd.setTag(node.getTag()); <line14> newNode = mapSeqUpd; <line15> } else { <line16> AAssignToExpStmIR assign = new AAssignToExpStmIR(); <line17> assign.setTarget(node.getTarget().apply(converter)); <line18> assign.setExp(node.getExp().clone()); <line19> assign.setSourceNode(node.getSourceNode()); <line20> assign.setTag(node.getTag()); <line21> newNode = assign; <line22> } <line23> if (node.parent() != null) { <line24> node.parent().replaceChild(node, newNode); <line25> } else { <line26> } <line27> } <line28> } <line29> 	<line26>	task4	
"public class A { <line0> @Override <line1> public void cancelContinuous(String originNodeId, String routineId) { <line2> A.notNullOrEmpty(originNodeId, ""originNodeId""); <line3> A.notNullOrEmpty(routineId, ""routineId""); <line4> if (log.isInfoEnabled()) <line5> cancelContinuous(UUID.fromString(originNodeId), UUID.fromString(routineId)); <line6> } <line7> } <line8> "	<line5>	task4	
"public class A { <line0> private void putEvent( <line1> final HRPlanningEntryDO entry, <line2> final DateTime start, <line3> final String suffix, <line4> final int durationDays, <line5> final BigDecimal hours) { <line6> if (NumberHelper.isGreaterZero(hours) == false) { <line7> return; <line8> } <line9> if (log.isDebugEnabled() == true) { <line10> } <line11> final Event event = new Event().setAllDay(true); <line12> event.setClassName(EVENT_CLASS_NAME); <line13> final String id = """" + entry.getId() + ""-"" + suffix; <line14> event.setId(id); <line15> event.setStart(start); <line16> if (durationDays > 0) { <line17> event.setEnd(start.plusDays(durationDays)); <line18> } else { <line19> event.setEnd(start); <line20> } <line21> final StringBuffer buf = new StringBuffer(); <line22> buf.append(NumberHelper.formatFraction2(hours)) <line23> .append(getString(""calendar.unit.hour"")) <line24> .append("" "") <line25> .append(entry.getProjektNameOrStatus()); <line26> if (StringUtils.isNotBlank(entry.getDescription()) == true) { <line27> buf.append("": ""); <line28> if (durationDays > 2) { <line29> buf.append(StringUtils.abbreviate(entry.getDescription(), 100)); <line30> } else if (durationDays > 1) { <line31> buf.append(StringUtils.abbreviate(entry.getDescription(), 50)); <line32> } else { <line33> buf.append(StringUtils.abbreviate(entry.getDescription(), 20)); <line34> } <line35> } <line36> event.setTitle(buf.toString()); <line37> events.put(id, event); <line38> } <line39> } <line40> "	<line10>	task4	
public class A { <line0> @Override <line1> public void onClose(int code, String reason) { <line2> execLatch.countDown(); <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> @Override <line1> public List<TableMutation> tableMutations(Notification notification) { <line2> List<TableMutation> tableMutations = super.tableMutations(notification); <line3> for (NotificationIndexMapper im : indexMappers) { <line4> tableMutations.addAll(im.tableMutations(notification)); <line5> } <line6> return tableMutations; <line7> } <line8> } <line9> 	<line6>	task4	
public class A { <line0> public static XTextField findAnnotationFieldRecursive(Object element) { <line1> if (UNO.XEnumerationAccess(element) != null) { <line2> UnoCollection<Object> children = UnoCollection.getCollection(element, Object.class); <line3> for (Object child : children) { <line4> try { <line5> XTextField found = findAnnotationFieldRecursive(child); <line6> if (found != null) { <line7> return found; <line8> } <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> Object textField = Utils.getProperty(element, UnoProperty.TEXT_FIELD); <line14> if (textField != null <line15> && UnoService.supportsService(textField, UnoService.CSS_TEXT_TEXT_FIELD_ANNOTATION)) { <line16> return UNO.XTextField(textField); <line17> } <line18> return null; <line19> } <line20> } <line21> 	<line10>	task4	
public class A { <line0> @Override <line1> public void onRemoval(RemovalNotification<String, ExtTableSnapshotInfo> notification) { <line2> } <line3> } <line4> 	<line2>	task4	
"public class A { <line0> private void initState() { <line1> final HashMap<String, Object> properties = new HashMap<>(); <line2> getPropertiesHelper().getEndpointProperties(getCamelContext(), configuration, properties); <line3> this.endpointProperties = Collections.unmodifiableMap(properties); <line4> this.endpointPropertyNames = Collections.unmodifiableSet(properties.keySet()); <line5> final Set<String> arguments = new HashSet<>(endpointPropertyNames); <line6> if (inBody != null) { <line7> arguments.add(inBody); <line8> } <line9> interceptPropertyNames(arguments); <line10> candidates = new ArrayList<>(); <line11> candidates.addAll(methodHelper.getCandidateMethods(methodName, arguments)); <line12> candidates = Collections.unmodifiableList(candidates); <line13> if (candidates.isEmpty()) { <line14> throw new IllegalArgumentException( <line15> String.format( <line16> ""No matching method for %s/%s, with arguments %s"", <line17> apiName.getName(), methodName, arguments)); <line18> } <line19> if (log.isDebugEnabled()) { <line20> final Set<String> missing = methodHelper.getMissingProperties(methodName, arguments); <line21> if (!missing.isEmpty()) { <line22> } <line23> } <line24> } <line25> } <line26> "	<line22>	task4	
public class A { <line0> @Override <line1> public GetSnapshotRepositoriesResponse execute( <line2> GetSnapshotRepositoriesRequest getSnapshotRepositoriesRequest) { <line3> GetRepositoriesRequest getRepositoriesRequest = <line4> createGetRepositoriesRequest(getSnapshotRepositoriesRequest); <line5> GetSnapshotRepositoriesResponse getSnapshotRepositoriesResponse = <line6> new GetSnapshotRepositoriesResponse(); <line7> try { <line8> GetRepositoriesResponse elasticsearchGetRepositoriesResponse = <line9> getGetRepositoriesResponse(getRepositoriesRequest, getSnapshotRepositoriesRequest); <line10> List<RepositoryMetadata> repositoriesMetadatas = <line11> elasticsearchGetRepositoriesResponse.repositories(); <line12> repositoriesMetadatas.forEach( <line13> repositoryMetadata -> { <line14> Settings repositoryMetadataSettings = repositoryMetadata.settings(); <line15> SnapshotRepositoryDetails snapshotRepositoryDetails = <line16> new SnapshotRepositoryDetails( <line17> repositoryMetadata.name(), <line18> repositoryMetadata.type(), <line19> repositoryMetadataSettings.toString()); <line20> getSnapshotRepositoriesResponse.addSnapshotRepositoryMetadata( <line21> snapshotRepositoryDetails); <line22> }); <line23> } catch (RepositoryMissingException repositoryMissingException) { <line24> if (log.isDebugEnabled()) { <line25> } <line26> } <line27> return getSnapshotRepositoriesResponse; <line28> } <line29> } <line30> 	<line25>	task4	
public class A { <line0> public void populateLuceneIdToIdMap() throws IOException { <line1> ids = new int[reader.maxDoc()]; <line2> NumericDocValues ndv = atomicReader.getNumericDocValues(IndexItem.ID); <line3> for (int i = 0; i < reader.maxDoc(); i++) { <line4> ids[i] = (int) ndv.get(i); <line5> if (ids[i] > lastId) lastId = ids[i]; <line6> } <line7> } <line8> } <line9> 	<line1>	task4	
public class A { <line0> public static void analyzeForUtilizedColumns(Analysis analysis, Node node) { <line1> UtilizedColumnsAnalyzer analyzer = new UtilizedColumnsAnalyzer(analysis); <line2> try { <line3> analyzer.analyze(node); <line4> } catch (Exception e) { <line5> analysis.getTableColumnReferences().forEach(analysis::addUtilizedTableColumnReferences); <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> public void navigateTo() { <line1> driver.get(url); <line2> waitForElement(expectedElement, DEFAULT_TIMEOUT, notFoundMsg); <line3> } <line4> } <line5> 	<line1>	task4	
public class A { <line0> public void updateResources(BrokerCluster upgradedCluster, StandardInfraConfig infraConfig) <line1> throws Exception { <line2> if (upgradedCluster != null) { <line3> PersistentVolumeClaim existingClaim = null; <line4> StatefulSet existingBroker = null; <line5> for (HasMetadata item : resources.getItems()) { <line6> if (item instanceof PersistentVolumeClaim) { <line7> existingClaim = (PersistentVolumeClaim) item; <line8> } <line9> if (item instanceof StatefulSet) { <line10> existingBroker = (StatefulSet) item; <line11> } <line12> } <line13> KubernetesList newResources = upgradedCluster.getResources(); <line14> StatefulSet newBroker = null; <line15> for (HasMetadata item : newResources.getItems()) { <line16> if (item instanceof StatefulSet) { <line17> newBroker = (StatefulSet) item; <line18> Kubernetes.addObjectAnnotation( <line19> item, AnnotationKeys.APPLIED_INFRA_CONFIG, mapper.writeValueAsString(infraConfig)); <line20> break; <line21> } <line22> } <line23> if (newBroker == null) { <line24> return; <line25> } <line26> if (existingClaim != null && existingBroker != null) { <line27> Map<String, Quantity> newRequests = <line28> newBroker <line29> .getSpec() <line30> .getVolumeClaimTemplates() <line31> .get(0) <line32> .getSpec() <line33> .getResources() <line34> .getRequests(); <line35> newBroker <line36> .getSpec() <line37> .setVolumeClaimTemplates(existingBroker.getSpec().getVolumeClaimTemplates()); <line38> existingClaim.getSpec().getResources().setRequests(newRequests); <line39> newResources = <line40> new KubernetesListBuilder() <line41> .withItems(newResources.getItems()) <line42> .addToItems(existingClaim) <line43> .build(); <line44> } <line45> this.resources = newResources; <line46> } <line47> } <line48> } <line49> 	<line24>	task4	
public class A { <line0> @Override <line1> public Map<String, String> discoverLocalMetadata() { <line2> if (memberMetadata.isEmpty()) { <line3> String availabilityZone = awsClient.getAvailabilityZone(); <line4> memberMetadata.put(PartitionGroupMetaData.PARTITION_GROUP_ZONE, availabilityZone); <line5> getPlacementGroup() <line6> .ifPresent( <line7> pg -> memberMetadata.put(PARTITION_GROUP_PLACEMENT, availabilityZone + '-' + pg)); <line8> } <line9> return memberMetadata; <line10> } <line11> } <line12> 	<line4>	task4	
"public class A { <line0> private int receiveFlowFiles( <line1> final Transaction transaction, final ProcessContext context, final ProcessSession session) <line2> throws IOException, ProtocolException { <line3> final String userDn = transaction.getCommunicant().getDistinguishedName(); <line4> final StopWatch stopWatch = new StopWatch(true); <line5> final Set<FlowFile> flowFilesReceived = new HashSet<>(); <line6> long bytesReceived = 0L; <line7> while (true) { <line8> final long start = System.nanoTime(); <line9> final DataPacket dataPacket = transaction.receive(); <line10> if (dataPacket == null) { <line11> break; <line12> } <line13> FlowFile flowFile = session.create(); <line14> flowFile = session.putAllAttributes(flowFile, dataPacket.getAttributes()); <line15> final Communicant communicant = transaction.getCommunicant(); <line16> final String host = <line17> StringUtils.isEmpty(communicant.getHost()) ? ""unknown"" : communicant.getHost(); <line18> final String port = <line19> communicant.getPort() < 0 ? ""unknown"" : String.valueOf(communicant.getPort()); <line20> final Map<String, String> attributes = new HashMap<>(2); <line21> attributes.put(SiteToSiteAttributes.S2S_HOST.key(), host); <line22> attributes.put(SiteToSiteAttributes.S2S_ADDRESS.key(), host + "":"" + port); <line23> flowFile = session.putAllAttributes(flowFile, attributes); <line24> flowFile = session.importFrom(dataPacket.getData(), flowFile); <line25> final long receiveNanos = System.nanoTime() - start; <line26> flowFilesReceived.add(flowFile); <line27> String sourceFlowFileIdentifier = dataPacket.getAttributes().get(CoreAttributes.UUID.key()); <line28> if (sourceFlowFileIdentifier == null) { <line29> sourceFlowFileIdentifier = ""<Unknown Identifier>""; <line30> } <line31> final String transitUri = <line32> transaction.getCommunicant().createTransitUri(sourceFlowFileIdentifier); <line33> session <line34> .getProvenanceReporter() <line35> .receive( <line36> flowFile, <line37> transitUri, <line38> ""urn:nifi:"" + sourceFlowFileIdentifier, <line39> ""Remote DN="" + userDn, <line40> TimeUnit.NANOSECONDS.toMillis(receiveNanos)); <line41> session.transfer(flowFile, Relationship.ANONYMOUS); <line42> bytesReceived += dataPacket.getSize(); <line43> } <line44> transaction.confirm(); <line45> session.commit(); <line46> transaction.complete(); <line47> if (!flowFilesReceived.isEmpty()) { <line48> stopWatch.stop(); <line49> final String flowFileDescription = <line50> flowFilesReceived.size() < 20 <line51> ? flowFilesReceived.toString() <line52> : flowFilesReceived.size() + "" FlowFiles""; <line53> final String uploadDataRate = stopWatch.calculateDataRate(bytesReceived); <line54> final long uploadMillis = stopWatch.getDuration(TimeUnit.MILLISECONDS); <line55> final String dataSize = FormatUtils.formatDataSize(bytesReceived); <line56> } <line57> return flowFilesReceived.size(); <line58> } <line59> } <line60> "	<line56>	task4	
public class A { <line0> private boolean ensureUserIsAuthorized( <line1> UriAuthorizationFilter uriAuthorizationFilter, <line2> HttpServletRequest request, <line3> HttpServletResponse response) <line4> throws IOException { <line5> return uriAuthorizationFilter.ensureUserIsAuthorized(request, response); <line6> } <line7> } <line8> 	<line5>	task4	
"public class A { <line0> @DELETE <line1> @JacksonSerialized <line2> @Path(""/{id}"") <line3> @Produces(MediaType.APPLICATION_JSON) <line4> public Response deleteAdapter( <line5> @PathParam(""id"") String id, @PathParam(""username"") String userName) { <line6> try { <line7> managementService.deleteAdapterTemplates(id); <line8> return ok(true); <line9> } catch (AdapterException e) { <line10> return fail(); <line11> } <line12> } <line13> } <line14> "	<line10>	task4	
public class A { <line0> public static boolean deleteOnExitSilently( <line1> @Nonnull final Path path, @Nonnull final FileSystem fs) { <line2> try { <line3> return fs.deleteOnExit(path); <line4> } catch (final IOException e) { <line5> return false; <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> public void sent(Channel channel, Object message) { <line1> for (ChannelHandler listener : channelHandlers) { <line2> try { <line3> listener.sent(channel, message); <line4> } catch (Throwable t) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> @Override <line1> public void run() { <line2> while (terminate == false) { <line3> synchronized (this) { <line4> try { <line5> this.wait(checkIntervalMsec); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> if (terminate) { <line10> break; <line11> } <line12> Status newStatus = getStatus(); <line13> if (newStatus == Status.RUNNING <line14> || newStatus == Status.FINISHED <line15> || newStatus == Status.ERROR <line16> || newStatus == Status.ABORT) { <line17> break; <line18> } <line19> } <line20> terminate = true; <line21> } <line22> } <line23> 	<line7>	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.EmailAddress fetchEmailAddress( <line1> HttpPrincipal httpPrincipal, long emailAddressId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> EmailAddressServiceUtil.class, <line7> ""fetchEmailAddress"", <line8> _fetchEmailAddressParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, emailAddressId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.portal.kernel.model.EmailAddress) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>	task4	
public class A { <line0> private List<JobTaskDirectoryMatch> findOrphansForTask(JobTask task) { <line1> List<JobTaskDirectoryMatch> rv = new ArrayList<>(); <line2> Job job = getJob(task.getJobUUID()); <line3> if (job == null) { <line4> return rv; <line5> } <line6> List<String> expectedTaskHosts = task.getAllTaskHosts(); <line7> for (HostState host : hostManager.listHostStatus(job.getMinionType())) { <line8> if ((host == null) <line9> || !host.isUp() <line10> || host.isDead() <line11> || host.getHostUuid().equals(task.getRebalanceTarget())) { <line12> continue; <line13> } <line14> if (!expectedTaskHosts.contains(host.getHostUuid())) { <line15> JobTaskDirectoryMatch.MatchType type = null; <line16> if (host.hasLive(task.getJobKey()) || host.hasIncompleteReplica(task.getJobKey())) { <line17> type = JobTaskDirectoryMatch.MatchType.ORPHAN_LIVE; <line18> } <line19> if (type != null) { <line20> rv.add(new JobTaskDirectoryMatch(type, task.getJobKey(), host.getHostUuid())); <line21> } <line22> } <line23> } <line24> return rv; <line25> } <line26> } <line27> 	<line4>	task4	
public class A { <line0> public List<CapabilityState> getCapabilityStates() <line1> throws IOException, ApiException, AuthenticationException { <line2> return executeGetList(API_URL_CAPABILITY_STATES, CapabilityState[].class); <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> private void triggerBeforeBegin() { <line1> for (TransactionHook hook : getCurrentHooks()) { <line2> try { <line3> hook.beforeBegin(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> public static void importIfExist( <line1> String linterName, <line2> SensorContext sensorContext, <line3> File reportFile, <line4> BiConsumer<File, SensorContext> importFunction) { <line5> if (!reportFile.exists()) { <line6> return; <line7> } <line8> importFunction.accept(reportFile, sensorContext); <line9> } <line10> } <line11> 	<line6>	task4	
"public class A { <line0> private void downloadFile( <line1> InstallProgressTracker installTracker, <line2> String urlPrefix, <line3> FileDescriptor fileDescriptor, <line4> String newFilePath) { <line5> int downloadAttempts = 0; <line6> String downloadFileChecksum = null; <line7> do { <line8> try (TaskActivity ta = <line9> TaskActivity.createActive(""Downloading "" + fileDescriptor.getFileName())) { <line10> myToolbox.getUIRegistry().getMenuBarRegistry().addTaskActivity(ta); <line11> URL downloadUrl = getDownloadUrl(urlPrefix, fileDescriptor); <line12> downloadUpdateFile(downloadUrl, newFilePath); <line13> downloadAttempts++; <line14> installTracker.incrementRetrievedFiles(); <line15> File file = new File(newFilePath); <line16> installTracker.addToBytesDownloaded(FileUtils.sizeOf(file)); <line17> downloadFileChecksum = DescriptorUtils.createChecksum(file); <line18> ta.setComplete(true); <line19> } <line20> } while (!fileDescriptor.getChecksum().equals(downloadFileChecksum) <line21> && downloadAttempts <= DEFAULT_DOWNLOAD_ATTEMPTS); <line22> } <line23> } <line24> "	<line5>	task4	
public class A { <line0> private static void dumpAllThreads(String message) { <line1> } <line2> } <line3> 	<line1>	task4	
public class A { <line0> public AnomalyDetectionInputContextBuilder fetchTimeSeriesData( <line1> List<Pair<Long, Long>> startEndTimeRanges, boolean endTimeInclusive) <line2> throws JobExecutionException, ExecutionException { <line3> Map<DimensionKey, MetricTimeSeries> dimensionKeyMetricTimeSeriesMap = <line4> getTimeSeriesForAnomalyDetection(anomalyFunctionSpec, startEndTimeRanges, endTimeInclusive); <line5> Map<DimensionMap, MetricTimeSeries> dimensionMapMetricTimeSeriesMap = new HashMap<>(); <line6> for (Map.Entry<DimensionKey, MetricTimeSeries> entry : <line7> dimensionKeyMetricTimeSeriesMap.entrySet()) { <line8> DimensionKey dimensionKey = entry.getKey(); <line9> String[] dimensionValues = dimensionKey.getDimensionValues(); <line10> boolean isOTHERDimension = false; <line11> for (String dimensionValue : dimensionValues) { <line12> if (dimensionValue.equalsIgnoreCase(ResponseParserUtils.OTHER) <line13> || dimensionValue.equalsIgnoreCase(ResponseParserUtils.UNKNOWN)) { <line14> isOTHERDimension = true; <line15> break; <line16> } <line17> } <line18> if (isOTHERDimension) { <line19> continue; <line20> } <line21> DimensionMap dimensionMap = DimensionMap.fromDimensionKey(dimensionKey, collectionDimensions); <line22> dimensionMapMetricTimeSeriesMap.put(dimensionMap, entry.getValue()); <line23> if (entry.getValue().getTimeWindowSet().size() < 1) { <line24> } <line25> } <line26> this.anomalyDetectionInputContext.setDimensionMapMetricTimeSeriesMap( <line27> dimensionMapMetricTimeSeriesMap); <line28> return this; <line29> } <line30> } <line31> 	<line24>	task4	
public class A { <line0> public static com.liferay.dispatch.model.DispatchTriggerSoap updateDispatchTrigger( <line1> long dispatchTriggerId, <line2> boolean active, <line3> String cronExpression, <line4> com.liferay.dispatch.executor.DispatchTaskClusterMode dispatchTaskClusterMode, <line5> int endDateMonth, <line6> int endDateDay, <line7> int endDateYear, <line8> int endDateHour, <line9> int endDateMinute, <line10> boolean neverEnd, <line11> boolean overlapAllowed, <line12> int startDateMonth, <line13> int startDateDay, <line14> int startDateYear, <line15> int startDateHour, <line16> int startDateMinute) <line17> throws RemoteException { <line18> try { <line19> com.liferay.dispatch.model.DispatchTrigger returnValue = <line20> DispatchTriggerServiceUtil.updateDispatchTrigger( <line21> dispatchTriggerId, <line22> active, <line23> cronExpression, <line24> dispatchTaskClusterMode, <line25> endDateMonth, <line26> endDateDay, <line27> endDateYear, <line28> endDateHour, <line29> endDateMinute, <line30> neverEnd, <line31> overlapAllowed, <line32> startDateMonth, <line33> startDateDay, <line34> startDateYear, <line35> startDateHour, <line36> startDateMinute); <line37> return com.liferay.dispatch.model.DispatchTriggerSoap.toSoapModel(returnValue); <line38> } catch (Exception exception) { <line39> throw new RemoteException(exception.getMessage()); <line40> } <line41> } <line42> } <line43> 	<line39>	task4	
"public class A { <line0> private void checkBlockchainState() { <line1> BlockchainState state = <line2> propertiesHolder.isLightClient() <line3> ? BlockchainState.LIGHT_CLIENT <line4> : (lookupBlockchainProcessor().isDownloading() <line5> || blockchain.getLastBlockTimestamp() < timeService.getEpochTime() - 600) <line6> ? BlockchainState.DOWNLOADING <line7> : (blockchain.getLastBlock().getBaseTarget() <line8> / blockchainConfig.getCurrentConfig().getInitialBaseTarget() <line9> > 10) <line10> ? BlockchainState.FORK <line11> : BlockchainState.UP_TO_DATE; <line12> if (state != currentBlockchainState) { <line13> JSONObject json = new JSONObject(myPeerInfo); <line14> json.put(""blockchainState"", state.ordinal()); <line15> myPeerInfoResponse = JSON.prepare(json); <line16> json.put(""requestType"", ""getInfo""); <line17> myPeerInfoRequest = JSON.prepareRequest(json); <line18> currentBlockchainState = state; <line19> } <line20> } <line21> } <line22> "	<line19>	task4	
"public class A { <line0> @Override <line1> public boolean acquireTieLock() { <line2> holdingTieLock = distributedLockService.lock(""PERSISTENCE_"" + regionPath, 0, -1); <line3> if (!holdingTieLock) { <line4> if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR_VERBOSE)) { <line5> } <line6> } <line7> return holdingTieLock; <line8> } <line9> } <line10> "	<line5>	task4	
public class A { <line0> @Deprecated(forRemoval = true) <line1> public Builder disableEmbeddedIndexes(boolean disableEmbeddedIndexes) { <line2> assertNotLocked(); <line3> return this; <line4> } <line5> } <line6> 	<line3>	task4	
"public class A { <line0> @Test <line1> public void testQueryBboxLatLongEPSGCode() { <line2> Document doc = getAsDOM(WFS_GET_FEATURE + LATLONG + "",EPSG:4326""); <line3> assertXpathEvaluatesTo(""0"", ""/wfs:FeatureCollection/@numberOfFeatures"", doc); <line4> assertXpathCount(0, ""//ex:geomContainer"", doc); <line5> } <line6> } <line7> "	<line3>	task4	
"public class A { <line0> private static String formatUndefined(String formatPattern) { <line1> String undefinedFormatPattern = <line2> formatPattern.replaceAll(IDENTIFY_FORMAT_PATTERN_PATTERN, ""%1\\$s""); <line3> try { <line4> return String.format(undefinedFormatPattern, ""-""); <line5> } catch (IllegalArgumentException e) { <line6> final Logger logger = LoggerFactory.getLogger(NeeoItemValueConverter.class); <line7> return ""(Error)""; <line8> } <line9> } <line10> } <line11> "	<line7>	task4	
public class A { <line0> public void propagateLine(String line) throws IOException { <line1> connectionListener.handleInput(line); <line2> } <line3> } <line4> 	<line1>	task4	
public class A { <line0> public void registerDiscoveryService(CaddxDiscoveryService discoveryService) { <line1> this.discoveryService = discoveryService; <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> closeable.close(); <line4> } catch (Throwable e) { <line5> Throwables.propagate(e); <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> public GpioPinDigitalOutput getOutputPin(ChannelUID channel) { <line1> GpioPinDigitalOutput outputPin = outputPins.get(channel); <line2> if (outputPin == null) { <line3> outputPin = initializeOutputPin(channel); <line4> outputPins.put(channel, outputPin); <line5> } <line6> return outputPin; <line7> } <line8> } <line9> 	<line1>	task4	
"public class A { <line0> @GuardedBy(""lock"") <line1> private void createNewJobMasterServiceProcess(UUID leaderSessionId) throws FlinkException { <line2> Preconditions.checkState(jobMasterServiceProcess.closeAsync().isDone()); <line3> try { <line4> runningJobsRegistry.setJobRunning(getJobID()); <line5> } catch (IOException e) { <line6> throw new FlinkException( <line7> String.format( <line8> ""Failed to set the job %s to running in the running jobs registry."", getJobID()), <line9> e); <line10> } <line11> jobMasterServiceProcess = jobMasterServiceProcessFactory.create(leaderSessionId); <line12> forwardIfValidLeader( <line13> leaderSessionId, <line14> jobMasterServiceProcess.getJobMasterGatewayFuture(), <line15> jobMasterGatewayFuture, <line16> ""JobMasterGatewayFuture from JobMasterServiceProcess""); <line17> forwardResultFuture(leaderSessionId, jobMasterServiceProcess.getResultFuture()); <line18> confirmLeadership(leaderSessionId, jobMasterServiceProcess.getLeaderAddressFuture()); <line19> } <line20> } <line21> "	<line3>	task4	
public class A { <line0> public void printInfo(Logger logger) { <line1> for (VQSRRange r : points) { <line2> } <line3> } <line4> } <line5> 	<line2>	task4	
"public class A { <line0> @Override <line1> public void sgetrf(int M, int N, INDArray A, INDArray IPIV, INDArray INFO) { <line2> INDArray a = A; <line3> if (A.ordering() == 'c') a = A.dup('f'); <line4> if (Nd4j.getExecutioner() instanceof GridExecutioner) <line5> ((GridExecutioner) Nd4j.getExecutioner()).flushQueue(); <line6> val ctx = allocator.getDeviceContext(); <line7> cusolverDnHandle_t handle = ctx.getSolverHandle(); <line8> cusolverDnContext solverDn = new cusolverDnContext(handle); <line9> synchronized (handle) { <line10> int result = <line11> cusolverDnSetStream( <line12> new cusolverDnContext(handle), new CUstream_st(ctx.getCublasStream())); <line13> if (result != 0) throw new BlasException(""solverSetStream failed""); <line14> CublasPointer xAPointer = new CublasPointer(a, ctx); <line15> val worksizeBuffer = (BaseCudaDataBuffer) Nd4j.getDataBufferFactory().createInt(1); <line16> worksizeBuffer.lazyAllocateHostPointer(); <line17> int stat = <line18> cusolverDnSgetrf_bufferSize( <line19> solverDn, <line20> M, <line21> N, <line22> (FloatPointer) xAPointer.getDevicePointer(), <line23> M, <line24> (IntPointer) worksizeBuffer.addressPointer()); <line25> if (stat != CUSOLVER_STATUS_SUCCESS) { <line26> throw new BlasException(""cusolverDnSgetrf_bufferSize failed"", stat); <line27> } <line28> int worksize = worksizeBuffer.getInt(0); <line29> Pointer workspace = new Workspace(worksize * Nd4j.sizeOfDataType()); <line30> stat = <line31> cusolverDnSgetrf( <line32> solverDn, <line33> M, <line34> N, <line35> (FloatPointer) xAPointer.getDevicePointer(), <line36> M, <line37> new CudaPointer(workspace).asFloatPointer(), <line38> new CudaPointer(allocator.getPointer(IPIV, ctx)).asIntPointer(), <line39> new CudaPointer(allocator.getPointer(INFO, ctx)).asIntPointer()); <line40> if (stat != CUSOLVER_STATUS_SUCCESS) { <line41> throw new BlasException(""cusolverDnSgetrf failed"", stat); <line42> } <line43> } <line44> allocator.registerAction(ctx, a); <line45> allocator.registerAction(ctx, INFO); <line46> allocator.registerAction(ctx, IPIV); <line47> if (a != A) A.assign(a); <line48> } <line49> } <line50> "	<line3>	task4	
"public class A { <line0> @Override <line1> public boolean processAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws PortletException { <line3> long oAuth2ApplicationId = ParamUtil.getLong(actionRequest, ""oAuth2ApplicationId"", -1); <line4> long[] oAuth2AuthorizationIds = <line5> StringUtil.split(ParamUtil.getString(actionRequest, ""oAuth2AuthorizationIds""), 0L); <line6> try { <line7> if ((oAuth2AuthorizationIds.length == 0) && (oAuth2ApplicationId != -1)) { <line8> _oAuth2AuthorizationService.revokeAllOAuth2Authorizations(oAuth2ApplicationId); <line9> } else { <line10> for (long oAuth2AuthorizationId : oAuth2AuthorizationIds) { <line11> _oAuth2AuthorizationService.revokeOAuth2Authorization(oAuth2AuthorizationId); <line12> } <line13> } <line14> } catch (PortalException portalException) { <line15> if (log.isDebugEnabled()) { <line16> } <line17> SessionErrors.add(actionRequest, portalException.getClass()); <line18> } <line19> String backURL = ParamUtil.get(actionRequest, ""backURL"", StringPool.BLANK); <line20> if (Validator.isNotNull(backURL)) { <line21> actionResponse.setRenderParameter(""redirect"", backURL); <line22> } <line23> return true; <line24> } <line25> } <line26> "	<line16>	task4	
public class A { <line0> public static Node getNodeWithXpath(Object obj, String expression) { <line1> Object root = null; <line2> if (obj instanceof Document) { <line3> Document doc = (Document) obj; <line4> root = doc.getDocumentElement(); <line5> } else { <line6> root = (Node) obj; <line7> } <line8> XPath xpath = XPathFactory.newInstance().newXPath(); <line9> xpath.setNamespaceContext(new MetadataNamespaceContext()); <line10> Node result = null; <line11> try { <line12> result = ((Node) xpath.evaluate(expression, root, XPathConstants.NODE)); <line13> return result; <line14> } catch (XPathExpressionException e) { <line15> return null; <line16> } <line17> } <line18> } <line19> 	<line15>	task4	
public class A { <line0> @Override <line1> public void onExit(Controller controller) { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> static List<List<Pair<SnapshotFileInfo, Long>>> getBalancedSplits( <line1> final List<Pair<SnapshotFileInfo, Long>> files, final int ngroups) { <line2> Collections.sort( <line3> files, <line4> new Comparator<Pair<SnapshotFileInfo, Long>>() { <line5> public int compare(Pair<SnapshotFileInfo, Long> a, Pair<SnapshotFileInfo, Long> b) { <line6> long r = a.getSecond() - b.getSecond(); <line7> return (r < 0) ? -1 : ((r > 0) ? 1 : 0); <line8> } <line9> }); <line10> List<List<Pair<SnapshotFileInfo, Long>>> fileGroups = new LinkedList<>(); <line11> long[] sizeGroups = new long[ngroups]; <line12> int hi = files.size() - 1; <line13> int lo = 0; <line14> List<Pair<SnapshotFileInfo, Long>> group; <line15> int dir = 1; <line16> int g = 0; <line17> while (hi >= lo) { <line18> if (g == fileGroups.size()) { <line19> group = new LinkedList<>(); <line20> fileGroups.add(group); <line21> } else { <line22> group = fileGroups.get(g); <line23> } <line24> Pair<SnapshotFileInfo, Long> fileInfo = files.get(hi--); <line25> sizeGroups[g] += fileInfo.getSecond(); <line26> group.add(fileInfo); <line27> g += dir; <line28> if (g == ngroups) { <line29> dir = -1; <line30> g = ngroups - 1; <line31> } else if (g < 0) { <line32> dir = 1; <line33> g = 0; <line34> } <line35> } <line36> if (LOG.isDebugEnabled()) { <line37> for (int i = 0; i < sizeGroups.length; ++i) { <line38> } <line39> } <line40> return fileGroups; <line41> } <line42> } <line43> 	<line38>	task4	
public class A { <line0> private static void disable(SingletonService service) { <line1> try { <line2> service.disable(); <line3> } catch (RuntimeException e) { <line4> } <line5> } <line6> } <line7> 	<line4>	task4	
public class A { <line0> public String evaluateAsString(Exchange exchange) throws Exception { <line1> StringWriter buffer = new StringWriter(); <line2> SequenceIterator iter = getExpression().iterator(createDynamicContext(exchange)); <line3> for (Item item = iter.next(); item != null; item = iter.next()) { <line4> buffer.append(item.getStringValueCS()); <line5> } <line6> String answer = buffer.toString(); <line7> buffer.close(); <line8> return answer; <line9> } <line10> } <line11> 	<line1>	task4	
public class A { <line0> private void removeFloatingIpFromNodeifAny(RegionAndId regionAndId) { <line1> try { <line2> removeFloatingIpFromNodeAndDeallocate.apply(regionAndId); <line3> } catch (RuntimeException e) { <line4> } <line5> } <line6> } <line7> 	<line4>	task4	
"public class A { <line0> @Override <line1> public JAXBContext getJAXBContext() throws KapuaException { <line2> if (context == null) { <line3> Map<String, Object> properties = new HashMap<>(1); <line4> properties.put(MarshallerProperties.JSON_WRAPPER_AS_ARRAY_NAME, true); <line5> Class<?>[] classes = <line6> new Class<?>[] { <line7> KapuaTmetadata.class, <line8> KapuaTocd.class, <line9> KapuaTad.class, <line10> KapuaTicon.class, <line11> TscalarImpl.class, <line12> KapuaToption.class, <line13> KapuaTdesignate.class, <line14> KapuaTobject.class, <line15> MetatypeXmlRegistry.class, <line16> EndPointContainer.class, <line17> SimpleEndPoint.class, <line18> ParentEndPoint.class, <line19> EndChainEndPoint.class, <line20> ServiceEvent.class, <line21> EventStoreRecordCreator.class, <line22> EventStoreRecordListResult.class, <line23> EventStoreRecordQuery.class, <line24> EventStoreXmlRegistry.class, <line25> JobStartOptions.class, <line26> ThrowableInfo.class, <line27> ExceptionInfo.class, <line28> CleanJobDataExceptionInfo.class, <line29> JobAlreadyRunningExceptionInfo.class, <line30> JobEngineExceptionInfo.class, <line31> JobExecutionEnqueuedExceptionInfo.class, <line32> JobInvalidTargetExceptionInfo.class, <line33> JobMissingStepExceptionInfo.class, <line34> JobMissingTargetExceptionInfo.class, <line35> JobNotRunningExceptionInfo.class, <line36> JobResumingExceptionInfo.class, <line37> JobRunningExceptionInfo.class, <line38> JobStartingExceptionInfo.class, <line39> JobStoppingExceptionInfo.class <line40> }; <line41> try { <line42> context = JAXBContextFactory.createContext(classes, properties); <line43> } catch (JAXBException jaxbException) { <line44> throw KapuaException.internalError(jaxbException, ""Error creating JAXBContext!""); <line45> } <line46> } <line47> return context; <line48> } <line49> } <line50> "	<line43>	task4	
public class A { <line0> private String fieldsValue(List<Criteria.Field> fields) { <line1> StringBuilder sb = new StringBuilder(); <line2> if (fields != null) { <line3> for (int i = 0; i < fields.size(); i++) { <line4> if (i > 0) { <line5> sb.append(Mapper.ROWKEY_SEP); <line6> } <line7> sb.append(fields.get(i).getValue()); <line8> } <line9> } <line10> return sb.toString(); <line11> } <line12> } <line13> 	<line10>	task4	
public class A { <line0> private boolean handle(List<ZookeeperJob> zookeeperJobList) { <line1> if (CollectionUtils.isEmpty(zookeeperJobList)) { <line2> return false; <line3> } <line4> ZookeeperJob defaultJob = ListUtils.getFirst(zookeeperJobList); <line5> ZookeeperJob.Type type = defaultJob.getType(); <line6> switch (type) { <line7> case ADD: <line8> return handleUpdate(zookeeperJobList); <line9> case REMOVE: <line10> return handleDelete(zookeeperJobList); <line11> case CLEAR: <line12> return handleClear(zookeeperJobList); <line13> } <line14> return false; <line15> } <line16> } <line17> 	<line2>	task4	
"public class A { <line0> @Override <line1> public void updateWidgetPosition(String pageCode, Integer frameToMove, Integer destFrame) { <line2> Connection conn = null; <line3> int TEMP_FRAME_POSITION = -9999; <line4> try { <line5> conn = this.getConnection(); <line6> conn.setAutoCommit(false); <line7> this.updateWidgetPosition(pageCode, frameToMove, TEMP_FRAME_POSITION, conn); <line8> this.updateWidgetPosition(pageCode, destFrame, frameToMove, conn); <line9> this.updateWidgetPosition(pageCode, TEMP_FRAME_POSITION, destFrame, conn); <line10> this.updatePageMetadataDraftLastUpdate(pageCode, new Date(), conn); <line11> conn.commit(); <line12> } catch (Throwable t) { <line13> this.executeRollback(conn); <line14> throw new RuntimeException(""Error while updating widget position"", t); <line15> } finally { <line16> closeConnection(conn); <line17> } <line18> } <line19> } <line20> "	<line14>	task4	
public class A { <line0> @Override <line1> public Object jobRun() { <line2> start = System.currentTimeMillis(); <line3> while (abort == false) { <line4> count++; <line5> try { <line6> Thread.sleep(10); <line7> } catch (InterruptedException e) { <line8> } <line9> if (System.currentTimeMillis() - start > time) break; <line10> } <line11> return System.currentTimeMillis() - start; <line12> } <line13> } <line14> 	<line8>	task4	
public class A { <line0> public void syncNewCards() { <line1> int rowAffected = queries.syncNewCards(); <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Override <line1> public String getImageSrc() { <line2> if (user.getPortraitId() <= 0) { <line3> return null; <line4> } <line5> try { <line6> return user.getPortraitURL(themeDisplay); <line7> } catch (Exception exception) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	<line9>	task4	
public class A { <line0> @Override <line1> public void run() { <line2> for (JDBCJournalRecord record : records) { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> record.complete(success); <line6> } <line7> } <line8> } <line9> 	<line4>	task4	
"public class A { <line0> @Test <line1> public void testListEndpoints() throws Exception { <line2> template.sendBody(""browse:foo"", body1); <line3> template.sendBody(""browse:foo"", body2); <line4> Collection<Endpoint> list = context.getEndpoints(); <line5> assertEquals(2, list.size(), ""number of endpoints""); <line6> for (Endpoint endpoint : list) { <line7> List<Exchange> exchanges = ((BrowseEndpoint) endpoint).getExchanges(); <line8> assertEquals(2, exchanges.size(), ""Exchanges received on "" + endpoint); <line9> assertInMessageBodyEquals(exchanges.get(0), body1); <line10> assertInMessageBodyEquals(exchanges.get(1), body2); <line11> } <line12> } <line13> } <line14> "	<line8>	task4	
public class A { <line0> private Callable<Void> getTaskStartingCallable(final ConnectorTaskId taskId) { <line1> return () -> { <line2> try { <line3> startTask(taskId); <line4> } catch (Throwable t) { <line5> onFailure(taskId, t); <line6> } <line7> return null; <line8> }; <line9> } <line10> } <line11> 	<line5>	task4	
"public class A { <line0> void bindTo(final MetricRegistry registry) { <line1> final MemoryMXBean platformMXBean = ManagementFactory.getPlatformMXBean(MemoryMXBean.class); <line2> registry.add( <line3> ""jvm.memory.heap.used"", <line4> Labels.EMPTY, <line5> new DoubleSupplier() { <line6> @Override <line7> public double get() { <line8> return platformMXBean.getHeapMemoryUsage().getUsed(); <line9> } <line10> }); <line11> registry.add( <line12> ""jvm.memory.heap.committed"", <line13> Labels.EMPTY, <line14> new DoubleSupplier() { <line15> @Override <line16> public double get() { <line17> return platformMXBean.getHeapMemoryUsage().getCommitted(); <line18> } <line19> }); <line20> registry.add( <line21> ""jvm.memory.heap.max"", <line22> Labels.EMPTY, <line23> new DoubleSupplier() { <line24> @Override <line25> public double get() { <line26> return platformMXBean.getHeapMemoryUsage().getMax(); <line27> } <line28> }); <line29> registry.add( <line30> ""jvm.memory.non_heap.used"", <line31> Labels.EMPTY, <line32> new DoubleSupplier() { <line33> @Override <line34> public double get() { <line35> return platformMXBean.getNonHeapMemoryUsage().getUsed(); <line36> } <line37> }); <line38> registry.add( <line39> ""jvm.memory.non_heap.committed"", <line40> Labels.EMPTY, <line41> new DoubleSupplier() { <line42> @Override <line43> public double get() { <line44> return platformMXBean.getNonHeapMemoryUsage().getCommitted(); <line45> } <line46> }); <line47> registry.add( <line48> ""jvm.memory.non_heap.max"", <line49> Labels.EMPTY, <line50> new DoubleSupplier() { <line51> @Override <line52> public double get() { <line53> return platformMXBean.getNonHeapMemoryUsage().getMax(); <line54> } <line55> }); <line56> List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans(); <line57> for (final MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) { <line58> if (memoryPoolMXBean.getType() != MemoryType.HEAP) { <line59> continue; <line60> } <line61> final Labels memoryPoolTags = Labels.Mutable.of(""name"", memoryPoolMXBean.getName()); <line62> try { <line63> registry.add( <line64> ""jvm.memory.heap.pool.used"", <line65> memoryPoolTags, <line66> new DoubleSupplier() { <line67> @Override <line68> public double get() { <line69> return memoryPoolMXBean.getUsage().getUsed(); <line70> } <line71> }); <line72> registry.add( <line73> ""jvm.memory.heap.pool.committed"", <line74> memoryPoolTags, <line75> new DoubleSupplier() { <line76> @Override <line77> public double get() { <line78> return memoryPoolMXBean.getUsage().getCommitted(); <line79> } <line80> }); <line81> registry.add( <line82> ""jvm.memory.heap.pool.max"", <line83> memoryPoolTags, <line84> new DoubleSupplier() { <line85> @Override <line86> public double get() { <line87> return memoryPoolMXBean.getUsage().getMax(); <line88> } <line89> }); <line90> } catch (Exception e) { <line91> } <line92> } <line93> } <line94> } <line95> "	<line91>	task4	
"public class A { <line0> @Override <line1> public void stop() { <line2> if (log.isTraceEnable()) { <line3> } <line4> this.getTimerWorkManager().cancel(""NotificaitonScheduleWorker""); <line5> } <line6> } <line7> "	<line3>	task4	
public class A { <line0> private boolean lostReliability(final InternalDistributedMember id, final Set newlyMissingRoles) { <line1> if (DistributedRegion.ignoreReconnect) { <line2> return false; <line3> } <line4> boolean async = false; <line5> try { <line6> if (getMembershipAttributes().getLossAction().isReconnect()) { <line7> async = true; <line8> doLostReliability(isInitializingThread, id, newlyMissingRoles); <line9> } <line10> } catch (CancelException cce) { <line11> throw cce; <line12> } catch (Exception e) { <line13> } <line14> return async; <line15> } <line16> } <line17> 	<line13>	task4	
public class A { <line0> public void setInputStream(String body) { <line1> try (ByteArrayInputStream stream = new ByteArrayInputStream(body.getBytes(DEFAULT_CHARSET))) { <line2> cachedInputStream = new ByteArrayOutputStream(); <line3> IOUtils.copy(stream, cachedInputStream); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line5>	task4	
public class A { <line0> @Override <line1> public String forkGroup(JsonCluster definition, ClusterRuntime runtime, String groupName) <line2> throws KaramelException { <line3> return groupName; <line4> } <line5> } <line6> 	<line3>	task4	
public class A { <line0> public static Builder newWriteChunkRequestBuilder( <line1> Pipeline pipeline, BlockID blockID, int datalen, int seq) throws IOException { <line2> ContainerProtos.WriteChunkRequestProto.Builder writeRequest = <line3> ContainerProtos.WriteChunkRequestProto.newBuilder(); <line4> writeRequest.setBlockID(blockID.getDatanodeBlockIDProtobuf()); <line5> ChunkBuffer data = getData(datalen); <line6> ChunkInfo info = getChunk(blockID.getLocalID(), seq, 0, datalen); <line7> setDataChecksum(info, data); <line8> writeRequest.setChunkData(info.getProtoBufMessage()); <line9> writeRequest.setData(data.toByteString()); <line10> Builder request = ContainerCommandRequestProto.newBuilder(); <line11> request.setCmdType(ContainerProtos.Type.WriteChunk); <line12> request.setContainerID(blockID.getContainerID()); <line13> request.setWriteChunk(writeRequest); <line14> request.setDatanodeUuid(pipeline.getFirstNode().getUuidString()); <line15> return request; <line16> } <line17> } <line18> 	<line2>	task4	
public class A { <line0> public List<UserWrapper> getNewUsers(int sinceDays, int length) { <line1> List<UserWrapper> results = new ArrayList<>(); <line2> try { <line3> Weblogger roller = WebloggerFactory.getWeblogger(); <line4> UserManager umgr = roller.getUserManager(); <line5> List<User> users = umgr.getUsers(Boolean.TRUE, null, null, 0, length); <line6> for (User user : users) { <line7> results.add(UserWrapper.wrap(user)); <line8> } <line9> } catch (Exception e) { <line10> } <line11> return results; <line12> } <line13> } <line14> 	<line10>	task4	
"public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntry addFileEntry( <line1> HttpPrincipal httpPrincipal, <line2> long repositoryId, <line3> long folderId, <line4> String sourceFileName, <line5> String mimeType, <line6> String title, <line7> String description, <line8> String changeLog, <line9> byte[] bytes, <line10> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line11> throws com.liferay.portal.kernel.exception.PortalException { <line12> try { <line13> MethodKey methodKey = <line14> new MethodKey(DLAppServiceUtil.class, ""addFileEntry"", _addFileEntryParameterTypes0); <line15> MethodHandler methodHandler = <line16> new MethodHandler( <line17> methodKey, <line18> repositoryId, <line19> folderId, <line20> sourceFileName, <line21> mimeType, <line22> title, <line23> description, <line24> changeLog, <line25> bytes, <line26> serviceContext); <line27> Object returnObj = null; <line28> try { <line29> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line30> } catch (Exception exception) { <line31> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line32> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line33> } <line34> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line35> } <line36> return (com.liferay.portal.kernel.repository.model.FileEntry) returnObj; <line37> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line38> throw systemException; <line39> } <line40> } <line41> } <line42> "	<line38>	task4	
"public class A { <line0> public ConnectorStateInfo connectorStatus(String connectorName) { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> String url = endpointForResource(String.format(""connectors/%s/status"", connectorName)); <line3> Response response = requestGet(url); <line4> try { <line5> if (response.getStatus() < Response.Status.BAD_REQUEST.getStatusCode()) { <line6> return mapper.readerFor(ConnectorStateInfo.class).readValue(responseToString(response)); <line7> } <line8> } catch (IOException e) { <line9> throw new ConnectException(""Could not not parse connector state"", e); <line10> } <line11> throw new ConnectRestException( <line12> response.getStatus(), <line13> ""Could not read connector state. Error response: "" + responseToString(response)); <line14> } <line15> } <line16> "	<line9>	task4	
"public class A { <line0> @Test <line1> public void testExtractParagraphsFromChapterFile_FIL_LRA_faa0d66e() throws IOException { <line2> ResourceLoader resourceLoader = <line3> new ClassRelativeResourceLoader(EPubParagraphExtractionHelper.class); <line4> Resource resource = <line5> resourceLoader.getResource( <line6> ""fil-lra-faa0d66e-564f-4d72-a1d3-ec46fb754205.epub_Page_3.xhtml""); <line7> File xhtmlFile = resource.getFile(); <line8> List<String> storyBookParagraphs = <line9> EPubParagraphExtractionHelper.extractParagraphsFromChapterFile(xhtmlFile); <line10> assertThat(storyBookParagraphs.size(), is(3)); <line11> assertThat(storyBookParagraphs.get(0), is(""WAAAAHHHH!"")); <line12> assertThat( <line13> storyBookParagraphs.get(1), <line14> is(""Ang ibong Brahminy ay umiiyak tulad ng isang gutom na sanggol."")); <line15> assertThat(storyBookParagraphs.get(2), is(""WAAAAHHHH!"")); <line16> } <line17> } <line18> "	<line8>	task4	
public class A { <line0> public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) { <line1> Password pass = (Password) value; <line2> try { <line3> if (pass.password != null) { <line4> writer.setValue(encrypter.encrypt(pass.password)); <line5> } <line6> } catch (EncryptionException e) { <line7> } <line8> } <line9> } <line10> 	<line7>	task4	
public class A { <line0> @Override <line1> public void bind() { <line2> InterceptorRegistry.bind(interceptorRegistryAdaptor, lock); <line3> } <line4> } <line5> 	<line2>	task4	
"public class A { <line0> @Mock <line1> public static ExecutionResult[] executeStoredProcedures( <line2> Priority priority, Callable<Void>[] storedProcedures, ProgressCallback callback) <line3> throws InterruptedException { <line4> if (resultIsNull) { <line5> return null; <line6> } <line7> ExecutionResult[] result = new ExecutionResult[storedProcedures.length]; <line8> for (int i = 0; i < result.length; i++) { <line9> VmOperation operation = getOperation(storedProcedures[i]); <line10> boolean flag = getFlag(operation); <line11> ExecutionResult r = null; <line12> if (flag) { <line13> r = new ExecutionResult(true, null); <line14> if (operation == VmOperation.CREATE_FOLDER) { <line15> CreateVMFolderSP sp = (CreateVMFolderSP) storedProcedures[i]; <line16> setReturnFolder(sp); <line17> } else if (operation == VmOperation.CREATE_VM) { <line18> CreateVmSP sp = (CreateVmSP) storedProcedures[i]; <line19> setReturnVM(sp); <line20> } <line21> r = new ExecutionResult(true, null); <line22> } else { <line23> r = new ExecutionResult(true, new Throwable(""test failure"")); <line24> } <line25> result[i] = r; <line26> } <line27> return result; <line28> } <line29> } <line30> "	<line4>	task4	
"public class A { <line0> public HostAndPort findOpenSocketOnNode( <line1> final Iterable<? extends HostAndPort> sockets, Duration timeout) { <line2> checkNotNull(sockets, ""sockets""); <line3> checkState(!Iterables.isEmpty(sockets), ""No hostAndPort sockets supplied""); <line4> checkNotNull(timeout, ""timeout""); <line5> Iterable<HostAndPort> reachable = <line6> Optional.presentInstances(tryReachable(sockets, timeout, false)); <line7> Iterator<HostAndPort> iter = reachable.iterator(); <line8> if (iter.hasNext()) { <line9> return iter.next(); <line10> } else { <line11> throw new NoSuchElementException(""Could not connect to any socket in "" + sockets); <line12> } <line13> } <line14> } <line15> "	<line11>	task4	
"public class A { <line0> protected void waitForAllNodesConnected(final int expectedNumberOfNodes, final long sleepMillis) { <line1> final NiFiClient client = getNifiClient(); <line2> final long maxTime = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(60); <line3> while (true) { <line4> try { <line5> final ClusteSummaryEntity clusterSummary = client.getFlowClient().getClusterSummary(); <line6> final int connectedNodeCount = clusterSummary.getClusterSummary().getConnectedNodeCount(); <line7> if (connectedNodeCount == expectedNumberOfNodes) { <line8> return; <line9> } <line10> logEverySecond( <line11> ""Waiting for {} nodes to connect but currently only {} nodes are connected"", <line12> expectedNumberOfNodes, <line13> connectedNodeCount); <line14> if (System.currentTimeMillis() > maxTime) { <line15> throw new RuntimeException( <line16> ""Waited up to 60 seconds for both nodes to connect but only "" <line17> + connectedNodeCount <line18> + "" nodes connected""); <line19> } <line20> } catch (final Exception e) { <line21> e.printStackTrace(); <line22> } <line23> try { <line24> Thread.sleep(sleepMillis); <line25> } catch (final InterruptedException ie) { <line26> Thread.currentThread().interrupt(); <line27> return; <line28> } <line29> } <line30> } <line31> } <line32> "	<line1>	task4	
"public class A { <line0> @Override <line1> protected void createOSLocalKillAllScript(File directory) throws IOFailure { <line2> File killAllScript = new File(directory, Constants.SCRIPT_NAME_KILL_ALL + scriptExtension); <line3> try { <line4> PrintWriter killPrinter = new PrintWriter(killAllScript, getTargetEncoding()); <line5> try { <line6> killPrinter.println( <line7> ScriptConstants.ECHO_KILL_ALL_APPS <line8> + Constants.COLON <line9> + Constants.SPACE <line10> + Constants.APOSTROPHE <line11> + hostname <line12> + Constants.APOSTROPHE); <line13> killPrinter.println( <line14> ScriptConstants.CD <line15> + Constants.SPACE <line16> + Constants.QUOTE_MARK <line17> + getConfDirPath() <line18> + Constants.QUOTE_MARK); <line19> for (Application app : applications) { <line20> String appScript = <line21> Constants.SCRIPT_NAME_LOCAL_KILL + app.getIdentification() + scriptExtension; <line22> killPrinter.print(ScriptConstants.OPERATING_SYSTEM_WINDOWS_RUN_BATCH_FILE); <line23> killPrinter.print(Constants.QUOTE_MARK); <line24> killPrinter.print(appScript); <line25> killPrinter.print(Constants.QUOTE_MARK); <line26> killPrinter.println(); <line27> } <line28> killPrinter.print(ScriptConstants.OPERATING_SYSTEM_WINDOWS_10_SECONDS_WAIT); <line29> killPrinter.println(); <line30> } finally { <line31> killPrinter.close(); <line32> } <line33> } catch (IOException e) { <line34> String msg = ""Problems creating local kill all script. ""; <line35> throw new IOFailure(msg, e); <line36> } <line37> } <line38> } <line39> "	<line35>	task4	
"public class A { <line0> @Test <line1> public void testParseToDate() throws Exception { <line2> Date date1 = ParserUtils.parseToDate(""1988-02-30"", ""yyyy-MM-dd"", true); <line3> assertEquals(""1988-03-01"", FormatterUtils.formatDate(date1, ""yyyy-MM-dd"")); <line4> try { <line5> ParserUtils.parseToDate(""1988-20"", ""yyyy-MM"", false); <line6> fail(""Except get exception: Unparseable date: \""1988-20\""""); <line7> } catch (Exception e) { <line8> assertEquals(RuntimeException.class, e.getClass()); <line9> } <line10> Date date2 = ParserUtils.parseToDate(""1987-06-21"", ""yyyy-MM-dd"", true); <line11> assertEquals(""1987-06-21"", FormatterUtils.formatDate(date2, ""yyyy-MM-dd"")); <line12> Date date3 = ParserUtils.parseToDate(""1987-06-21 12:21:22"", ""yyyy-MM-dd hh:mm:ss"", true); <line13> assertEquals(""1987-06-21 12:21:22"", FormatterUtils.formatDate(date3, ""yyyy-MM-dd hh:mm:ss"")); <line14> Date date4 = <line15> ParserUtils.parseToDate(""1987-06-21 12:21:22.123"", ""yyyy-MM-dd hh:mm:ss.SSS"", true); <line16> assertEquals( <line17> ""1987-06-21 12:21:22.123"", FormatterUtils.formatDate(date4, ""yyyy-MM-dd hh:mm:ss.SSS"")); <line18> } <line19> } <line20> "	<line9>	task4	
"public class A { <line0> public <T> T execute(CommandConfig config, Command<T> command) { <line1> if (config.getTransactionPropagation() == TransactionPropagation.NOT_SUPPORTED) { <line2> return next.execute(config, command); <line3> } <line4> boolean requiresNew = config.getTransactionPropagation() == TransactionPropagation.REQUIRES_NEW; <line5> Transaction oldTx = null; <line6> try { <line7> boolean existing = isExisting(); <line8> boolean isNew = !existing || requiresNew; <line9> if (existing && requiresNew) { <line10> oldTx = doSuspend(); <line11> } <line12> if (isNew) { <line13> doBegin(); <line14> } <line15> T result; <line16> try { <line17> result = next.execute(config, command); <line18> } catch (RuntimeException ex) { <line19> doRollback(isNew, ex); <line20> throw ex; <line21> } catch (Error err) { <line22> doRollback(isNew, err); <line23> throw err; <line24> } catch (Exception ex) { <line25> doRollback(isNew, ex); <line26> throw new UndeclaredThrowableException( <line27> ex, ""TransactionCallback threw undeclared checked exception""); <line28> } <line29> if (isNew) { <line30> doCommit(); <line31> } <line32> return result; <line33> } finally { <line34> doResume(oldTx); <line35> } <line36> } <line37> } <line38> "	<line1>	task4	
public class A { <line0> @Override <line1> protected int readDataWireFormat(byte[] buffer, int bufferIndex, int len) { <line2> int start = bufferIndex; <line3> ServerInfo1 e = null; <line4> ServerInfo1[] results = new ServerInfo1[getNumEntries()]; <line5> for (int i = 0; i < getNumEntries(); i++) { <line6> results[i] = e = new ServerInfo1(); <line7> e.name = readString(buffer, bufferIndex, 16, false); <line8> bufferIndex += 16; <line9> e.versionMajor = buffer[bufferIndex++] & 0xFF; <line10> e.versionMinor = buffer[bufferIndex++] & 0xFF; <line11> e.type = SMBUtil.readInt4(buffer, bufferIndex); <line12> bufferIndex += 4; <line13> int off = SMBUtil.readInt4(buffer, bufferIndex); <line14> bufferIndex += 4; <line15> off = (off & 0xFFFF) - this.converter; <line16> off = start + off; <line17> e.commentOrMasterBrowser = readString(buffer, off, 48, false); <line18> if (log.isTraceEnabled()) { <line19> } <line20> } <line21> setResults(results); <line22> this.lastName = e == null ? null : e.name; <line23> return bufferIndex - start; <line24> } <line25> } <line26> 	<line19>	task4	
"public class A { <line0> public Object invokeMethodFromMessage(Message message) { <line1> @SuppressWarnings(""unchecked"") <line2> final List<Object> parms = message.get(List.class, ""MethodParms""); <line3> if ((parms == null && targetTypes.length != 0) <line4> || (parms != null && parms.size() != targetTypes.length)) { <line5> throw new MessageDeliveryFailure( <line6> ""wrong number of arguments sent to endpoint. (received: "" <line7> + (parms == null ? 0 : parms.size()) <line8> + ""; required: "" <line9> + targetTypes.length <line10> + "")""); <line11> } <line12> try { <line13> RpcContext.set(message); <line14> return method.invoke( <line15> serviceProvider.get(message), <line16> (parms != null) ? parms.toArray(new Object[parms.size()]) : new Object[0]); <line17> } catch (final QueueUnavailableException e) { <line18> throw e; <line19> } catch (final MessageDeliveryFailure e) { <line20> throw e; <line21> } catch (final InvocationTargetException e) { <line22> throw new MessageDeliveryFailure(""error invoking RPC endpoint "" + method, e.getCause(), true); <line23> } catch (final Exception e) { <line24> throw new MessageDeliveryFailure(""error invoking endpoint"", e); <line25> } finally { <line26> RpcContext.remove(); <line27> } <line28> } <line29> } <line30> "	<line22>	task4	
"public class A { <line0> @GET <line1> @Path(""/{start}/{end}"") <line2> public List<AppointmentDTO> range( <line3> @QueryParam(""sid"") @WebParam(name = ""sid"") String sid, <line4> @PathParam(""start"") @WebParam(name = ""start"") Calendar start, <line5> @PathParam(""end"") @WebParam(name = ""end"") Calendar end) <line6> throws ServiceException { <line7> return performCall( <line8> sid, <line9> User.Right.ROOM, <line10> sd -> AppointmentDTO.list(dao.getInRange(sd.getUserId(), start.getTime(), end.getTime()))); <line11> } <line12> } <line13> "	<line7>	task4	
public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> for (NodeManager nodeManager : nodeManagers.values()) { <line3> nodeManager.beginShutdown(stopAgents); <line4> } <line5> for (NodeManager nodeManager : nodeManagers.values()) { <line6> nodeManager.waitForShutdown(); <line7> } <line8> executor.shutdown(); <line9> return null; <line10> } <line11> } <line12> 	<line2>	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public LocalSolvablePolynomial<C> parse(Reader r) { <line3> GenPolynomialTokenizer pt = new GenPolynomialTokenizer(this, r); <line4> LocalSolvablePolynomial<C> p = null; <line5> try { <line6> GenSolvablePolynomial<SolvableLocal<C>> s = pt.nextSolvablePolynomial(); <line7> p = new LocalSolvablePolynomial<C>(this, s); <line8> } catch (IOException e) { <line9> p = ZERO; <line10> } <line11> return p; <line12> } <line13> } <line14> "	<line9>	task4	
public class A { <line0> @Nullable <line1> @VisibleForTesting <line2> SecurityGroup getSecurityGroupForPublicIpNetwork(Client client, String publicIpInstanceId) <line3> throws UnauthorizedRequestException, InstanceNotFoundException, InvalidParameterException { <line4> VirtualNetwork virtualNetwork = <line5> OpenNebulaClientUtil.getVirtualNetwork(client, publicIpInstanceId); <line6> String securityGroupIdsStr = virtualNetwork.xpath(SECURITY_GROUPS_PATH); <line7> if (securityGroupIdsStr == null || securityGroupIdsStr.isEmpty()) { <line8> return null; <line9> } <line10> String[] securityGroupIds = securityGroupIdsStr.split(SECURITY_GROUP_SEPARATOR); <line11> String securityGroupName = generateSecurityGroupName(publicIpInstanceId); <line12> for (String securityGroupId : securityGroupIds) { <line13> SecurityGroup securityGroup = OpenNebulaClientUtil.getSecurityGroup(client, securityGroupId); <line14> if (securityGroup.getName().equals(securityGroupName)) { <line15> return securityGroup; <line16> } <line17> } <line18> return null; <line19> } <line20> } <line21> 	<line8>	task4	
"public class A { <line0> public static com.liferay.portal.kernel.model.Role getRole( <line1> HttpPrincipal httpPrincipal, long companyId, String name) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(RoleServiceUtil.class, ""getRole"", _getRoleParameterTypes8); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, companyId, name); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.portal.kernel.model.Role) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	<line18>	task4	
"public class A { <line0> private String getPublicUrlPrefix() { <line1> try { <line2> PrismObject<SystemConfigurationType> systemConfig = <line3> systemObjectCache.getSystemConfiguration( <line4> new OperationResult(""load system configuration"")); <line5> return SystemConfigurationTypeUtil.getPublicHttpUrlPattern( <line6> systemConfig.asObjectable(), getRequest().getServerName()); <line7> } catch (SchemaException e) { <line8> return null; <line9> } <line10> } <line11> } <line12> "	<line8>	task4	
public class A { <line0> @Override <line1> public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException { <line2> if (user == null) { <line3> return; <line4> } <line5> for (Callback callback : callbacks) { <line6> if (callback instanceof WSPasswordCallback) { <line7> WSPasswordCallback pc = (WSPasswordCallback) callback; <line8> if (user.equals(pc.getIdentifier())) { <line9> pc.setPassword(pass); <line10> break; <line11> } <line12> } <line13> } <line14> } <line15> } <line16> 	<line3>	task4	
public class A { <line0> public boolean clickNextButton() { <line1> boolean res = nextButton.clickIfPresent(SHORT_TIMEOUT); <line2> return res; <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> private int abortAbandonedRunningJobs(Date cutoff) { <line1> Set<JobState> jobStates = Util.asSet(JobState.RUNNING); <line2> AsyncJobStatusQueryArguments queryArgs = <line3> new AsyncJobStatusQueryArguments().setJobStates(jobStates).setEndDate(cutoff); <line4> int aborted = this.jobManager.abortNonTerminalJobs(queryArgs); <line5> return aborted; <line6> } <line7> } <line8> 	<line5>	task4	
"public class A { <line0> @SuppressWarnings({""NullableProblems""}) <line1> @Override <line2> public void loadAll( <line3> @Nullable GridCacheTx tx, @Nullable Collection<? extends K> keys, GridBiInClosure<K, V> c) <line4> throws GridException { <line5> Collection<K> remaining = new LinkedList<>(); <line6> for (K key : keys) { <line7> StatefulValue<V> val = writeCache.get(key); <line8> if (val != null) { <line9> val.readLock().lock(); <line10> try { <line11> switch (val.operation()) { <line12> case PUT: <line13> c.apply(key, val.value()); <line14> break; <line15> case RMV: <line16> c.apply(key, null); <line17> break; <line18> default: <line19> assert false : ""Unexpected operation: "" + val.status(); <line20> } <line21> } finally { <line22> val.readLock().unlock(); <line23> } <line24> } else remaining.add(key); <line25> } <line26> if (!remaining.isEmpty()) store.loadAll(null, remaining, c); <line27> } <line28> } <line29> "	<line5>	task4	
"public class A { <line0> @Test <line1> public void testRgroupQueryFile7() throws Exception { <line2> String filename = ""data/mdl/rgfile.7.mol""; <line3> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line4> RGroupQueryReader reader = new RGroupQueryReader(ins); <line5> RGroupQuery rGroupQuery = <line6> (RGroupQuery) reader.read(new RGroupQuery(DefaultChemObjectBuilder.getInstance())); <line7> reader.close(); <line8> Assert.assertNotNull(rGroupQuery); <line9> Assert.assertEquals(rGroupQuery.getRGroupDefinitions().size(), 1); <line10> Assert.assertEquals(rGroupQuery.getRootStructure().getAtomCount(), 9); <line11> Assert.assertEquals(rGroupQuery.getAllConfigurations().size(), 20); <line12> } <line13> } <line14> "	<line3>	task4	
"public class A { <line0> protected void checkKafkaConfiguration( <line1> String namespaceName, String podNamePrefix, Map<String, Object> config, String clusterName) { <line2> List<Pod> pods = kubeClient(namespaceName).listPodsByPrefixInName(namespaceName, podNamePrefix); <line3> Properties properties = <line4> configMap2Properties( <line5> kubeClient(namespaceName).getConfigMap(namespaceName, clusterName + ""-kafka-config"")); <line6> for (Map.Entry<String, Object> property : config.entrySet()) { <line7> String key = property.getKey(); <line8> Object val = property.getValue(); <line9> assertThat(properties.keySet().contains(key), is(true)); <line10> assertThat(properties.getProperty(key), is(val)); <line11> } <line12> for (Pod pod : pods) { <line13> ExecResult result = <line14> cmdKubeClient(namespaceName) <line15> .execInPod( <line16> pod.getMetadata().getName(), ""/bin/bash"", ""-c"", ""cat /tmp/strimzi.properties""); <line17> Properties execProperties = stringToProperties(result.out()); <line18> for (Map.Entry<String, Object> property : config.entrySet()) { <line19> String key = property.getKey(); <line20> Object val = property.getValue(); <line21> assertThat(execProperties.keySet().contains(key), is(true)); <line22> assertThat(execProperties.getProperty(key), is(val)); <line23> } <line24> } <line25> } <line26> } <line27> "	<line2>	task4	
public class A { <line0> public static void close(final Closeable closeable, final Logger logger) { <line1> try { <line2> closeable.close(); <line3> } catch (final IOException e) { <line4> } <line5> } <line6> } <line7> 	<line4>	task4	
"public class A { <line0> @After <line1> public void removeAllRecord() throws Exception { <line2> List<Project> projectList = projectService.queryPageList(null, ""create_time"", ""desc"", 0, 100); <line3> for (Project project : projectList) { <line4> projectService.delete(project.getId()); <line5> } <line6> } <line7> } <line8> "	<line3>	task4	
public class A { <line0> @Override <line1> public Boolean apply(String s) { <line2> return true; <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> private State getDynamicChannelState(final Channel channel, final @Nullable String value) { <line1> final @Nullable String acceptedItemType = channel.getAcceptedItemType(); <line2> if (value == null || acceptedItemType == null) { <line3> return UnDefType.UNDEF; <line4> } <line5> switch (acceptedItemType) { <line6> case CoreItemFactory.NUMBER: <line7> return new DecimalType(value); <line8> case CoreItemFactory.STRING: <line9> return StringType.valueOf(value); <line10> case CoreItemFactory.SWITCH: <line11> return OnOffType.from(value); <line12> default: <line13> return UnDefType.UNDEF; <line14> } <line15> } <line16> } <line17> 	<line13>	task4	
public class A { <line0> public static boolean updateRecord( <line1> Map<String, Object> propertiesMap, String channel, String userExtId, RequestContext context) { <line2> Map<String, Object> compositeKeysMap = new HashMap<>(); <line3> compositeKeysMap.put(JsonKey.USER_EXT_ID, userExtId); <line4> compositeKeysMap.put(JsonKey.CHANNEL, channel); <line5> Response response = <line6> cassandraOperation.updateRecord( <line7> JsonKey.SUNBIRD, JsonKey.SHADOW_USER, propertiesMap, compositeKeysMap, context); <line8> return true; <line9> } <line10> } <line11> 	<line8>	task4	
public class A { <line0> public <EO extends EventObject, FC extends FlowConfiguration> void save( <line1> final FlowManager<EO, FC> resource) { <line2> } <line3> } <line4> 	<line2>	task4	
"public class A { <line0> public List<User> getAllUsers() throws RemoteException { <line1> int maxResults = 100; <line2> int startIndex = 0; <line3> List<User> results = new ArrayList<>(); <line4> StringBuilder request = <line5> new StringBuilder(""search?entity-type=user&expand=user&restriction=active%3dtrue"") <line6> .append(""&max-results="") <line7> .append(maxResults) <line8> .append(""&start-index=""); <line9> try { <line10> while (true) { <line11> final HttpUriRequest getRequest = <line12> RequestBuilder.get(crowdServer.resolve(request.toString() + startIndex)) <line13> .setConfig(requestConfig) <line14> .addHeader(HEADER_ACCEPT_APPLICATION_XML) <line15> .addHeader(HEADER_ACCEPT_CHARSET_UTF8) <line16> .build(); <line17> try (final CloseableHttpResponse response = client.execute(getRequest, clientContext)) { <line18> if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) { <line19> handleHTTPError(response); <line20> } <line21> final Users users = JAXB.unmarshal(response.getEntity().getContent(), Users.class); <line22> if (users != null && users.user != null) { <line23> for (final User user : users.user) { <line24> user.name = JID.escapeNode(user.name); <line25> results.add(user); <line26> } <line27> if (users.user.size() != maxResults) { <line28> break; <line29> } else { <line30> startIndex += maxResults; <line31> } <line32> } else { <line33> break; <line34> } <line35> } <line36> } <line37> } catch (IOException ioe) { <line38> handleError(ioe); <line39> } <line40> return results; <line41> } <line42> } <line43> "	<line1>	task4	
"public class A { <line0> @Test <line1> public void testFixedWidthRecords() throws Exception { <line2> FixedWidthApplication app = new FixedWidthApplication(); <line3> LocalMode lma = LocalMode.newInstance(); <line4> Configuration conf = new Configuration(false); <line5> conf.set(""dt.operator.HDFSRecordReaderModule.prop.files"", inputDir); <line6> conf.set(""dt.operator.HDFSRecordReaderModule.prop.recordLength"", ""8""); <line7> conf.set(""dt.operator.HDFSRecordReaderModule.prop.blocksThreshold"", ""1""); <line8> conf.set(""dt.operator.HDFSRecordReaderModule.prop.scanIntervalMillis"", ""10000""); <line9> lma.prepareDAG(app, conf); <line10> LocalMode.Controller lc = lma.getController(); <line11> lc.setHeartbeatMonitoringEnabled(true); <line12> lc.runAsync(); <line13> Thread.sleep(1000 * 1); <line14> lc.shutdown(); <line15> } <line16> } <line17> "	<line13>	task4	
public class A { <line0> @Override <line1> public void close() { <line2> if (shpFile != null) { <line3> try { <line4> shpFile.close(); <line5> } catch (IOException e) { <line6> } <line7> shpFile = null; <line8> } <line9> } <line10> } <line11> 	<line6>	task4	
"public class A { <line0> private void prepareBaseDir() throws IOException { <line1> String property = ""java.io.tmpdir""; <line2> String tempDir = System.getProperty(property); <line3> base = new File(tempDir + File.separator + ""joyqueue-data""); <line4> if (!base.exists()) { <line5> base.mkdirs(); <line6> } <line7> file = new File(base, ""329369803896""); <line8> } <line9> } <line10> "	<line7>	task4	
"public class A { <line0> protected void basicProcessVersionTag( <line1> InternalRegion region, <line2> VersionTag tag, <line3> boolean isTombstoneFromGII, <line4> boolean deltaCheck, <line5> VersionSource dmId, <line6> InternalDistributedMember sender, <line7> boolean checkForConflict) { <line8> if (tag != null) { <line9> VersionStamp stamp = getVersionStamp(); <line10> StringBuilder verbose = null; <line11> if (logger.isTraceEnabled(LogMarker.TOMBSTONE_VERBOSE)) { <line12> VersionTag stampTag = stamp.asVersionTag(); <line13> if (stampTag.hasValidVersion() && checkForConflict) { <line14> verbose = new StringBuilder(); <line15> verbose <line16> .append(""processing tag for key "") <line17> .append(getKey()) <line18> .append("", stamp="") <line19> .append(stamp.asVersionTag()) <line20> .append("", tag="") <line21> .append(tag) <line22> .append("", checkForConflict="") <line23> .append(checkForConflict); <line24> } <line25> } <line26> if (stamp == null) { <line27> throw new IllegalStateException( <line28> ""message contained a version tag but this region has no version storage""); <line29> } <line30> boolean apply = true; <line31> try { <line32> if (checkForConflict) { <line33> apply = <line34> checkForConflict( <line35> region, stamp, tag, isTombstoneFromGII, deltaCheck, dmId, sender, verbose); <line36> } <line37> } catch (ConcurrentCacheModificationException e) { <line38> if (!tag.isGatewayTag() <line39> && stamp.getDistributedSystemId() == tag.getDistributedSystemId() <line40> && tag.getVersionTimeStamp() > stamp.getVersionTimeStamp()) { <line41> stamp.setVersionTimeStamp(tag.getVersionTimeStamp()); <line42> tag.setTimeStampApplied(true); <line43> if (verbose != null) { <line44> verbose.append( <line45> ""\nThough in conflict the tag timestamp was more recent and was recorded.""); <line46> } <line47> } <line48> throw e; <line49> } finally { <line50> if (verbose != null) { <line51> } <line52> } <line53> if (apply) { <line54> applyVersionTag(region, stamp, tag, sender); <line55> } <line56> } <line57> } <line58> } <line59> "	<line51>	task4	
public class A { <line0> @PostMapping(CommonConstants.PATH_CHECK) <line1> public ResponseEntity<Void> checkExist( <line2> @RequestBody FileFormatDto fileFormat, <line3> @RequestHeader(value = CommonConstants.X_TENANT_ID_HEADER) Integer tenant) { <line4> final VitamContext vitamContext = <line5> securityService.buildVitamContext(securityService.getTenantIdentifier()); <line6> final boolean exist = fileFormatInternalService.check(vitamContext, fileFormat); <line7> return RestUtils.buildBooleanResponse(exist); <line8> } <line9> } <line10> 	<line4>	task4	
public class A { <line0> @Override <line1> public void endTable() throws DataSetException { <line2> try { <line3> out.write(NEW_LINE); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> 	<line5>	task4	
public class A { <line0> @Override <line1> protected void doBeginRead() throws Exception { <line2> if (readInProgress) { <line3> return; <line4> } <line5> Queue<Object> inboundBuffer = this.inboundBuffer; <line6> if (inboundBuffer.isEmpty()) { <line7> readInProgress = true; <line8> return; <line9> } <line10> final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get(); <line11> final Integer stackDepth = threadLocals.localChannelReaderStackDepth(); <line12> if (stackDepth < MAX_READER_STACK_DEPTH) { <line13> threadLocals.setLocalChannelReaderStackDepth(stackDepth + 1); <line14> try { <line15> readInbound(); <line16> } finally { <line17> threadLocals.setLocalChannelReaderStackDepth(stackDepth); <line18> } <line19> } else { <line20> try { <line21> eventLoop().execute(readTask); <line22> } catch (Throwable cause) { <line23> close(); <line24> virtualConnection.close(); <line25> PlatformDependent.throwException(cause); <line26> } <line27> } <line28> } <line29> } <line30> 	<line23>	task4	
"public class A { <line0> public static Module readResource(String resource, ClassLoader classLoader) <line1> throws IOException, ParseException { <line2> String stripped = resource.startsWith(""/"") ? resource.substring(1) : resource; <line3> InputStream stream = null; <line4> if (classLoader != null) { <line5> stream = classLoader.getResourceAsStream(stripped); <line6> } <line7> if (stream == null) { <line8> stream = EPLModuleUtil.class.getResourceAsStream(resource); <line9> } <line10> if (stream == null) { <line11> stream = EPLModuleUtil.class.getClassLoader().getResourceAsStream(stripped); <line12> } <line13> if (stream == null) { <line14> throw new IOException(""Failed to find resource '"" + resource + ""' in classpath""); <line15> } <line16> try { <line17> return EPLModuleUtil.readInternal(stream, resource); <line18> } finally { <line19> try { <line20> stream.close(); <line21> } catch (IOException e) { <line22> } <line23> } <line24> } <line25> } <line26> "	<line22>	task4	
public class A { <line0> public void debug(Marker marker, String format, Object arg1, Object arg2) { <line1> if (!logger.isDebugEnabled(marker)) return; <line2> if (instanceofLAL) { <line3> String formattedMessage = MessageFormatter.format(format, arg1, arg2).getMessage(); <line4> ((LocationAwareLogger) logger) <line5> .log( <line6> marker, <line7> fqcn, <line8> LocationAwareLogger.DEBUG_INT, <line9> formattedMessage, <line10> new Object[] {arg1, arg2}, <line11> null); <line12> } else { <line13> } <line14> } <line15> } <line16> 	<line13>	task4	
public class A { <line0> public void cleanup() { <line1> if (this.listenSock != null) { <line2> try { <line3> this.listenSock.close(); <line4> } catch (IOException exc) { <line5> } <line6> this.listenSock = null; <line7> } <line8> } <line9> } <line10> 	<line2>	task4	
public class A { <line0> public void parse(File wordpressXml) { <line1> try { <line2> SAXParserFactory factory = SAXParserFactory.newInstance(); <line3> SAXParser parser = factory.newSAXParser(); <line4> parser.parse(wordpressXml, this); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	<line6>	task4	
"public class A { <line0> @Override <line1> public ResourcePermissions getPermissions() { <line2> try { <line3> Map permissions = getResourceResolver().resolve(location, ""permissions"", Map.class); <line4> if (permissions != null) { <line5> Map<String, List<String>> allow = (Map<String, List<String>>) permissions.get(""allow""); <line6> Map<String, List<String>> deny = (Map<String, List<String>>) permissions.get(""deny""); <line7> return new ResourcePermissions( <line8> this, translatePermissions(allow), translatePermissions(deny)); <line9> } else { <line10> return getEmptyResourcePermissions(); <line11> } <line12> } catch (Exception e) { <line13> return getEmptyResourcePermissions(); <line14> } <line15> } <line16> } <line17> "	<line13>	task4	
public class A { <line0> private Long forwardRemoveNode(Node node) { <line1> SyncMetaClient client = <line2> (SyncMetaClient) metaGroupMember.getSyncClient(metaGroupMember.getLeader()); <line3> if (client != null) { <line4> try { <line5> return client.removeNode(node); <line6> } catch (TException e) { <line7> client.getInputProtocol().getTransport().close(); <line8> } finally { <line9> ClientUtils.putBackSyncClient(client); <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	<line8>	task4	
public class A { <line0> @Override <line1> public void add(String nodeKey, String propertyName, T value) { <line2> keysByValue.put(value, nodeKey); <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> @Override <line1> public void asyncReadEntry( <line2> ReadHandle lh, PositionImpl position, final ReadEntryCallback callback, final Object ctx) { <line3> try { <line4> asyncReadEntry0(lh, position, callback, ctx); <line5> } catch (Throwable t) { <line6> invalidateAllEntries(lh.getId()); <line7> callback.readEntryFailed(createManagedLedgerException(t), ctx); <line8> } <line9> } <line10> } <line11> 	<line6>	task4	
"public class A { <line0> public void execute() { <line1> String url = ""http://www.google.com:80/index.html""; <line2> try { <line3> URLConnection connection = new URL(url).openConnection(); <line4> connection.connect(); <line5> } catch (IOException ioe) { <line6> try { <line7> String text = <line8> ""At "" <line9> + new Date() <line10> + "" there was an error reported connecting to the internet address "" <line11> + url <line12> + "": "" <line13> + ioe; <line14> Role role = Context.getUserService().getRole(""System Developer""); <line15> Collection<User> users = Context.getUserService().getUsersByRole(role); <line16> Context.getAlertService().saveAlert(new Alert(text, users)); <line17> } catch (Exception e) { <line18> } <line19> } <line20> } <line21> } <line22> "	<line18>	task4	
public class A { <line0> @Override <line1> protected void doSessionCreated(IoSessionEx session) throws Exception { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	<line3>	task4	
"public class A { <line0> private void vaildateHostPort(String host, String port) { <line1> if (host == null || !StringUtils.isNumeric(port) || port.isEmpty()) { <line2> throw new IllegalArgumentException( <line3> ""Host or port should not be null / port should be numeric""); <line4> } <line5> } <line6> } <line7> "	<line2>	task4	
public class A { <line0> @Override <line1> public boolean remove(String key) { <line2> Object[] idValues = getPKValues(key); <line3> return isApplied(getSession().execute(deleteStatement.bind(idValues))); <line4> } <line5> } <line6> 	<line3>	task4	
public class A { <line0> private Object invokeEffectorNamed(Entity target, String effectorName, ConfigBag params) { <line1> Effector<?> effector = EffectorUtils.findEffectorDeclared(target, effectorName).get(); <line2> return target.invoke(effector, params.getAllConfig()).getUnchecked(); <line3> } <line4> } <line5> 	<line1>	task4	
public class A { <line0> private void validateInConfigWithExplicitTotalFlinkMem( <line1> Configuration customConfig, Consumer<JobManagerProcessSpec> validateFunc) { <line2> Configuration config = configWithExplicitTotalFlinkMem(); <line3> config.addAll(customConfig); <line4> JobManagerProcessSpec jobManagerProcessSpec = <line5> JobManagerProcessUtils.processSpecFromConfig(config); <line6> assertThat(jobManagerProcessSpec.getTotalFlinkMemorySize(), is(TOTAL_FLINK_MEM_SIZE)); <line7> validateFunc.accept(jobManagerProcessSpec); <line8> } <line9> } <line10> 	<line2>	task4	
"public class A { <line0> private void initializeFetchedSequenceNumbers() { <line1> for (String shardId : toEmitPerShard.keySet()) { <line2> Map<Object, Object> state = zkConnection.readState(kinesisConfig.getStreamName(), shardId); <line3> if (state != null) { <line4> Object committedSequenceNumber = state.get(""committedSequenceNumber""); <line5> if (committedSequenceNumber != null) { <line6> fetchedSequenceNumberPerShard.put(shardId, (String) committedSequenceNumber); <line7> } <line8> } <line9> } <line10> } <line11> } <line12> "	<line5>	task4	
public class A { <line0> public void start() { <line1> if (delay_time > 0) { <line2> executor = Executors.newSingleThreadScheduledExecutor(); <line3> executor.scheduleWithFixedDelay( <line4> new Runnable() { <line5> public void run() { <line6> try { <line7> AbstractTokenService.this.cleanExpiredTokens(); <line8> } catch (Throwable t) { <line9> } <line10> } <line11> }, <line12> 0, <line13> delay_time, <line14> TimeUnit.SECONDS); <line15> } <line16> } <line17> } <line18> 	<line9>	task4	
"public class A { <line0> public Map<String, Object> dataByNativeQuery(int pageNo, int pageSize, String search) { <line1> pageNo = Math.max(1, pageNo); <line2> pageSize = Math.max(25, pageSize); <line3> Map<String, Object> o = new HashMap<>(); <line4> o.put(""pageNo"", pageNo); <line5> o.put(""pageSize"", pageSize); <line6> String countSql = ""select count(*) from bc_identity_duty""; <line7> String rowsSql = ""select id, code, name from bc_identity_duty""; <line8> String orderSql = "" order by code""; <line9> boolean hasSearch = search != null && !search.isEmpty(); <line10> Condition c = null; <line11> Query countQuery; <line12> Query rowsQuery; <line13> if (hasSearch) { <line14> String[] strings = new String[] {""code"", ""name""}; <line15> c = ConditionUtils.toFuzzyCondition(search, strings, true); <line16> countSql += "" where "" + c.getExpression(); <line17> rowsSql += "" where "" + c.getExpression() + orderSql; <line18> } else { <line19> rowsSql += orderSql; <line20> } <line21> countQuery = em.createNativeQuery(countSql); <line22> rowsQuery = <line23> em.createNativeQuery(rowsSql) <line24> .setFirstResult((pageNo - 1) * pageSize) <line25> .setMaxResults(pageSize); <line26> if (c != null) { <line27> int i = 0; <line28> for (Object value : c.getValues()) { <line29> i++; <line30> countQuery.setParameter(i, value); <line31> rowsQuery.setParameter(i, value); <line32> } <line33> } <line34> if (logger.isDebugEnabled()) { <line35> } <line36> o.put(""count"", countQuery.getSingleResult()); <line37> o.put(""rows"", arrayListToMapList(rowsQuery.getResultList())); <line38> return o; <line39> } <line40> } <line41> "	<line35>	task4	
public class A { <line0> @Override <line1> public void onFailedMessageSend(JmsOutboundMessageDispatch envelope, ProviderException cause) { <line2> JmsSession session = sessions.get(envelope.getProducerId().getParentId()); <line3> if (session != null) { <line4> session.onFailedMessageSend(envelope, cause); <line5> } else { <line6> } <line7> } <line8> } <line9> 	<line6>	task4	
public class A { <line0> @Override <line1> public CacheState getCacheState(ExtTableSnapshotInfo extTableSnapshotInfo) { <line2> String resourcePath = extTableSnapshotInfo.getResourcePath(); <line3> if (inBuildingTables.containsKey(resourcePath)) { <line4> return CacheState.IN_BUILDING; <line5> } <line6> File stateFile = <line7> getCacheStateFile( <line8> getSnapshotCachePath( <line9> extTableSnapshotInfo.getTableName(), extTableSnapshotInfo.getId())); <line10> if (!stateFile.exists()) { <line11> return CacheState.NONE; <line12> } <line13> try { <line14> String stateString = Files.toString(stateFile, Charsets.UTF_8); <line15> return CacheState.valueOf(stateString); <line16> } catch (IOException e) { <line17> } <line18> return CacheState.NONE; <line19> } <line20> } <line21> 	<line17>	task4	
"public class A { <line0> @Override <line1> public Boolean isAlreadyAnUser(String mailAddress) throws ApsSystemException { <line2> try { <line3> Collection<IApsEntity> profileTypes = this.getProfileManager().getEntityPrototypes().values(); <line4> if (null == profileTypes || profileTypes.isEmpty()) { <line5> return false; <line6> } <line7> Iterator<IApsEntity> iter = profileTypes.iterator(); <line8> while (iter.hasNext()) { <line9> IUserProfile type = (IUserProfile) iter.next(); <line10> if (null != type.getMailAttributeName()) { <line11> EntitySearchFilter filterByEmail = <line12> new EntitySearchFilter(type.getMailAttributeName(), true, mailAddress, true); <line13> EntitySearchFilter[] filters = {filterByEmail}; <line14> List<String> usernames = ((IEntityManager) this.getProfileManager()).searchId(filters); <line15> if (null != usernames && usernames.size() > 0) { <line16> return true; <line17> } <line18> } <line19> } <line20> } catch (Throwable t) { <line21> throw new ApsSystemException(""Error on 'isAlreadyAnUser' method"", t); <line22> } <line23> return false; <line24> } <line25> } <line26> "	<line21>	task4	
"public class A { <line0> @Override <line1> protected List<Properties> buildCoords(Cluster cluster, Path buildPath) throws FalconException { <line2> List<Properties> props = new ArrayList<>(); <line3> boolean isLifeCycleEnabled = FeedHelper.isLifecycleEnabled(this.entity, cluster.getName()); <line4> if (isLifeCycleEnabled) { <line5> for (String name : FeedHelper.getPolicies(this.entity, cluster.getName())) { <line6> LifecyclePolicy policy = LifecyclePolicyMap.get().get(name); <line7> if (policy == null) { <line8> throw new FalconException(""Invalid policy name "" + name); <line9> } <line10> Properties appProps = policy.build(cluster, buildPath, this.entity); <line11> if (appProps != null) { <line12> props.add(appProps); <line13> } <line14> } <line15> } else { <line16> List<Properties> evictionProps = <line17> OozieCoordinatorBuilder.get(entity, Tag.RETENTION).buildCoords(cluster, buildPath); <line18> if (evictionProps != null) { <line19> props.addAll(evictionProps); <line20> } <line21> } <line22> List<Properties> replicationProps = <line23> OozieCoordinatorBuilder.get(entity, Tag.REPLICATION).buildCoords(cluster, buildPath); <line24> if (replicationProps != null) { <line25> props.addAll(replicationProps); <line26> } <line27> List<Properties> importProps = <line28> OozieCoordinatorBuilder.get(entity, Tag.IMPORT).buildCoords(cluster, buildPath); <line29> if (importProps != null) { <line30> props.addAll(importProps); <line31> } <line32> List<Properties> exportProps = <line33> OozieCoordinatorBuilder.get(entity, Tag.EXPORT).buildCoords(cluster, buildPath); <line34> if (exportProps != null) { <line35> props.addAll(exportProps); <line36> } <line37> if (!props.isEmpty()) { <line38> copySharedLibs(cluster, new Path(getLibPath(buildPath))); <line39> } <line40> return props; <line41> } <line42> } <line43> "	<line8>	task4	
"public class A { <line0> @Override <line1> public Object visit(ASTwait_cmd node, Object data) { <line2> if (((SimpleNode) node.jjtGetChild(1)).jjtGetValue().equals(""TIME"")) { <line3> long julday = Long.parseLong((String) ((SimpleNode) node.jjtGetChild(2)).jjtGetValue()); <line4> int Hour = Integer.parseInt((String) ((SimpleNode) node.jjtGetChild(3)).jjtGetValue()); <line5> int Minute = Integer.parseInt((String) ((SimpleNode) node.jjtGetChild(4)).jjtGetValue()); <line6> int Second = Integer.parseInt((String) ((SimpleNode) node.jjtGetChild(5)).jjtGetValue()); <line7> ((jmri.jmris.srcp.JmriSRCPTimeServer) ((jmri.jmris.ServiceHandler) data).getTimeServer()) <line8> .setAlarm(julday, Hour, Minute, Second); <line9> } else if (((SimpleNode) node.jjtGetChild(1)).jjtGetValue().equals(""FB"")) { <line10> outputString = ""425 ERROR not supported""; <line11> } else { <line12> outputString = ""423 ERROR unsupported operation""; <line13> } <line14> return data; <line15> } <line16> } <line17> "	<line2>	task4	
"public class A { <line0> @Test <line1> void testCreateCustomerProfile() { <line2> CustomerCreateRequest customerDto = <line3> CustomerCreateRequest.builder() <line4> .firstName(""pratik"") <line5> .lastName(""das"") <line6> .phoneNumber(""657576"") <line7> .email(""prat@gmail.co"") <line8> .gender(""M"") <line9> .build(); <line10> String customerID = customerProfileStore.createProfile(customerDto); <line11> assertTrue(customerID != null, ""Item created""); <line12> CustomerDto dto = customerProfileStore.fetchProfile(customerID); <line13> assertEquals(""pratik"", dto.getFirstName(), ""first name matched""); <line14> assertEquals(""das"", dto.getLastName(), ""last name matched""); <line15> } <line16> } <line17> "	<line11>	task4	
"public class A { <line0> @Test <line1> public void testNonPersistentSetServerAndClient() throws InitializationException, IOException { <line2> Assume.assumeFalse( <line3> ""test is skipped due to build environment being OS X with JDK 1.8. See"" <line4> + "" https://issues.apache.org/jira/browse/NIFI-437"", <line5> SystemUtils.IS_OS_MAC && SystemUtils.IS_JAVA_1_8); <line6> final TestRunner runner = TestRunners.newTestRunner(Mockito.mock(Processor.class)); <line7> final DistributedSetCacheServer server = new SetServer(); <line8> runner.addControllerService(""server"", server); <line9> runner.enableControllerService(server); <line10> final DistributedSetCacheClientService client = createClient(server.getPort()); <line11> final Serializer<String> serializer = new StringSerializer(); <line12> final boolean added = client.addIfAbsent(""test"", serializer); <line13> assertTrue(added); <line14> final boolean contains = client.contains(""test"", serializer); <line15> assertTrue(contains); <line16> final boolean addedAgain = client.addIfAbsent(""test"", serializer); <line17> assertFalse(addedAgain); <line18> final boolean removed = client.remove(""test"", serializer); <line19> assertTrue(removed); <line20> final boolean containedAfterRemove = client.contains(""test"", serializer); <line21> assertFalse(containedAfterRemove); <line22> server.shutdownServer(); <line23> } <line24> } <line25> "	<line6>	task4	
public class A { <line0> protected void fail(Exception ex) { <line1> disconnect(true, CallCompleteEvent.Cause.ERROR, ex, null); <line2> } <line3> } <line4> 	<line1>	task4	
public class A { <line0> private void shutdown() { <line1> for (SamsungTvService service : services) { <line2> stopService(service); <line3> } <line4> services.clear(); <line5> } <line6> } <line7> 	<line1>	task4	
public class A { <line0> private void writeRecordDigestLength(EncryptedServerNameIndicationExtensionMessage msg) { <line1> appendInt(msg.getRecordDigestLength().getValue(), ExtensionByteLength.RECORD_DIGEST_LENGTH); <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @ExceptionHandler(value = ValidationUpdateSelfException.class) <line1> @ResponseStatus(HttpStatus.FORBIDDEN) <line2> @ResponseBody <line3> public ErrorRestResponse processValidationError(ValidationUpdateSelfException ex) { <line4> BindingResult result = ex.getBindingResult(); <line5> return processAllErrors(result); <line6> } <line7> } <line8> 	<line4>	task4	
public class A { <line0> @Override <line1> public <T extends ElementFrame> T checkIndexUniqueness(String indexName, T element, Object key) { <line2> FramedGraph graph = Tx.getActive().getGraph(); <line3> OrientBaseGraph orientBaseGraph = db.get().unwrapCurrentGraph(); <line4> OrientElementType elementType = null; <line5> if (element instanceof EdgeFrame) { <line6> String label = ((EdgeFrame) element).getLabel(); <line7> elementType = orientBaseGraph.getEdgeType(label); <line8> } else { <line9> elementType = orientBaseGraph.getVertexType(element.getClass().getSimpleName()); <line10> } <line11> if (elementType != null) { <line12> OIndex index = elementType.getClassIndex(indexName); <line13> if (index != null) { <line14> Object recordId = index.get(key); <line15> if (recordId != null) { <line16> if (recordId.equals(element.getElement().getId())) { <line17> return null; <line18> } else { <line19> if (element instanceof EdgeFrame) { <line20> Edge edge = graph.getEdge(recordId); <line21> if (edge == null) { <line22> if (log.isDebugEnabled()) { <line23> } <line24> return null; <line25> } else { <line26> return (T) graph.frameElementExplicit(edge, element.getClass()); <line27> } <line28> } else { <line29> return (T) graph.getFramedVertexExplicit(element.getClass(), recordId); <line30> } <line31> } <line32> } <line33> } <line34> } <line35> return null; <line36> } <line37> } <line38> 	<line23>	task4	
"public class A { <line0> private Set<Bundle> _deployStaticBundlesFromFile(File file, Set<String> overrideStaticFileNames) <line1> throws Exception { <line2> Set<Bundle> bundles = new HashSet<>(); <line3> String path = _getLPKGLocation(file); <line4> try (ZipFile zipFile = new ZipFile(file)) { <line5> Enumeration<? extends ZipEntry> enumeration = zipFile.entries(); <line6> List<ZipEntry> zipEntries = new ArrayList<>(); <line7> while (enumeration.hasMoreElements()) { <line8> ZipEntry zipEntry = enumeration.nextElement(); <line9> String name = StringUtil.toLowerCase(zipEntry.getName()); <line10> if (!name.endsWith("".jar"")) { <line11> continue; <line12> } <line13> if (!overrideStaticFileNames.isEmpty()) { <line14> String fileName = _extractFileName(name); <line15> fileName = fileName.concat("".jar""); <line16> if (overrideStaticFileNames.contains(fileName)) { <line17> if (log.isInfoEnabled()) { <line18> StringBundler sb = new StringBundler(7); <line19> sb.append(zipFile.getName()); <line20> sb.append(StringPool.COLON); <line21> sb.append(zipEntry); <line22> sb.append("" is overridden by ""); <line23> sb.append(PropsValues.MODULE_FRAMEWORK_BASE_DIR); <line24> sb.append(""/static/""); <line25> sb.append(fileName); <line26> } <line27> continue; <line28> } <line29> } <line30> zipEntries.add(zipEntry); <line31> } <line32> Collections.sort( <line33> zipEntries, <line34> new Comparator<ZipEntry>() { <line35> @Override <line36> public int compare(ZipEntry zipEntry1, ZipEntry zipEntry2) { <line37> String name1 = zipEntry1.getName(); <line38> String name2 = zipEntry2.getName(); <line39> return name1.compareTo(name2); <line40> } <line41> }); <line42> for (ZipEntry zipEntry : zipEntries) { <line43> String zipEntryName = zipEntry.getName(); <line44> String location = <line45> StringBundler.concat(zipEntryName, ""?lpkgPath="", path, ""&protocol=lpkg&static=true""); <line46> try (InputStream inputStream = zipFile.getInputStream(zipEntry)) { <line47> Bundle bundle = _installInitialBundle(location, inputStream); <line48> if (bundle != null) { <line49> bundles.add(bundle); <line50> } <line51> } <line52> } <line53> } <line54> return bundles; <line55> } <line56> } <line57> "	<line26>	task4	
"public class A { <line0> @Override <line1> public CommercePriceListDiscountRel findByC_C(long commerceDiscountId, long commercePriceListId) <line2> throws NoSuchPriceListDiscountRelException { <line3> CommercePriceListDiscountRel commercePriceListDiscountRel = <line4> fetchByC_C(commerceDiscountId, commercePriceListId); <line5> if (commercePriceListDiscountRel == null) { <line6> StringBundler sb = new StringBundler(6); <line7> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line8> sb.append(""commerceDiscountId=""); <line9> sb.append(commerceDiscountId); <line10> sb.append("", commercePriceListId=""); <line11> sb.append(commercePriceListId); <line12> sb.append(""}""); <line13> if (log.isDebugEnabled()) { <line14> } <line15> throw new NoSuchPriceListDiscountRelException(sb.toString()); <line16> } <line17> return commercePriceListDiscountRel; <line18> } <line19> } <line20> "	<line14>	task4	
"public class A { <line0> public static com.liferay.asset.list.model.AssetListEntry getAssetListEntryByUuidAndGroupId( <line1> HttpPrincipal httpPrincipal, String uuid, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> AssetListEntryServiceUtil.class, <line7> ""getAssetListEntryByUuidAndGroupId"", <line8> _getAssetListEntryByUuidAndGroupIdParameterTypes28); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, uuid, groupId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.asset.list.model.AssetListEntry) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>	task4	
"public class A { <line0> @Test <line1> public void testExplainAndPrepareQuery() throws Exception { <line2> QueryPlan queryPlan = qHelper.explainAndPrepareQuery(QueryInventory.HIVE_CUBE_QUERY); <line3> Assert.assertNotNull(queryPlan.getPrepareHandle(), ""not returning queryhandle""); <line4> } <line5> } <line6> "	<line3>	task4	
"public class A { <line0> @Override <line1> public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) <line2> throws IOException { <line3> String toWrite = ""<REMOVED>""; <line4> if (value instanceof Optional) { <line5> Optional optional = (Optional) value; <line6> toWrite = optional.isPresent() ? ""<REMOVED>"" : ""<NOTSET>""; <line7> } <line8> gen.writeString(toWrite); <line9> } <line10> } <line11> "	<line8>	task4	
"public class A { <line0> @Test <line1> public void test05CdUp() { <line2> FTPClient ftp = setupFTPClient(""ftpuser1""); <line3> try (final Tx tx = StructrApp.getInstance(securityContext).tx()) { <line4> assertEmptyDirectory(ftp); <line5> String name1 = ""/FTPdir1""; <line6> ftp.makeDirectory(name1); <line7> ftp.changeWorkingDirectory(name1); <line8> String name2 = name1.concat(""/"").concat(""FTPdir2""); <line9> ftp.makeDirectory(name2); <line10> ftp.changeWorkingDirectory(name2); <line11> boolean success = ftp.changeToParentDirectory(); <line12> assertTrue(success); <line13> String newWorkingDirectory = ftp.printWorkingDirectory(); <line14> assertEquals(name1, newWorkingDirectory); <line15> ftp.disconnect(); <line16> tx.success(); <line17> } catch (IOException | FrameworkException ex) { <line18> fail(""Unexpected exception: "" + ex.getMessage()); <line19> } <line20> } <line21> } <line22> "	<line18>	task4	
public class A { <line0> private static Class<?> erase(Type type) { <line1> if (type instanceof Class) { <line2> return (Class<?>) type; <line3> } else if (type instanceof ParameterizedType) { <line4> return (Class<?>) ((ParameterizedType) type).getRawType(); <line5> } else if (type instanceof TypeVariable) { <line6> TypeVariable<?> tv = (TypeVariable<?>) type; <line7> return tv.getBounds().length == 0 ? Object.class : erase(tv.getBounds()[0]); <line8> } else if (type instanceof GenericArrayType) { <line9> return Array.newInstance(erase(((GenericArrayType) type).getGenericComponentType()), 0) <line10> .getClass(); <line11> } <line12> return Object.class; <line13> } <line14> } <line15> 	<line12>	task4	
public class A { <line0> public Set<TableName> getIncrementalBackupTableSet(String backupRoot) throws IOException { <line1> TreeSet<TableName> set = new TreeSet<>(); <line2> try (Table table = connection.getTable(tableName)) { <line3> Get get = createGetForIncrBackupTableSet(backupRoot); <line4> Result res = table.get(get); <line5> if (res.isEmpty()) { <line6> return set; <line7> } <line8> List<Cell> cells = res.listCells(); <line9> for (Cell cell : cells) { <line10> set.add(TableName.valueOf(CellUtil.cloneQualifier(cell))); <line11> } <line12> return set; <line13> } <line14> } <line15> } <line16> 	<line1>	task4	
public class A { <line0> private void doWork(Map entries) { <line1> try { <line2> process(igniteCache, entries); <line3> updateMetrics(entries.size()); <line4> } catch (Throwable e) { <line5> updateErrorMetrics(entries.size()); <line6> } <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> @Override <line1> public void destroy() { <line2> try { <line3> dataSource.close(); <line4> } catch (final Exception e) { <line5> } <line6> } <line7> } <line8> 	<line5>	task4	
public class A { <line0> @Test <line1> public final void testPublisherNodeGenerator() { <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Override <line1> public AnswerItem<AppService> readByKeyWithDependency(String key, String activedetail) { <line2> AnswerItem<AppService> answerAppService = this.readByKey(key); <line3> AppService appService = (AppService) answerAppService.getItem(); <line4> try { <line5> if (appService != null) { <line6> AnswerList<AppServiceContent> content = <line7> appServiceContentService.readByVarious(key, activedetail); <line8> if (content != null) { <line9> appService.setContentList((List<AppServiceContent>) content.getDataList()); <line10> } <line11> AnswerList<AppServiceHeader> header = <line12> appServiceHeaderService.readByVarious(key, activedetail); <line13> if (header != null) { <line14> appService.setHeaderList((List<AppServiceHeader>) header.getDataList()); <line15> } <line16> answerAppService.setItem(appService); <line17> } <line18> } catch (Exception e) { <line19> } <line20> return answerAppService; <line21> } <line22> } <line23> 	<line19>	task4	
public class A { <line0> @Override <line1> public void restore(Map<String, Serializable> contextStore) { <line2> String iconSetName = (String) contextStore.get(PROP_ICON_THEME); <line3> if (iconSetName != null) { <line4> try { <line5> this.iconSetContext.setIconSet(this.iconSetManager.getIconSet(iconSetName)); <line6> } catch (IconException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	<line7>	task4	
"public class A { <line0> public void createSecureConfiguration() throws InterpreterException { <line1> Properties properties = getProperties(); <line2> CommandLine cmdLine = CommandLine.parse(shell); <line3> cmdLine.addArgument(""-c"", false); <line4> String kinitCommand = <line5> String.format( <line6> ""kinit -k -t %s %s"", <line7> properties.getProperty(SUBMARINE_HADOOP_KEYTAB), <line8> properties.getProperty(SUBMARINE_HADOOP_PRINCIPAL)); <line9> cmdLine.addArgument(kinitCommand, false); <line10> DefaultExecutor executor = new DefaultExecutor(); <line11> try { <line12> executor.execute(cmdLine); <line13> } catch (Exception e) { <line14> throw new InterpreterException(e); <line15> } <line16> } <line17> } <line18> "	<line14>	task4	
public class A { <line0> private void removeFolderIfEmpty(String folderId) { <line1> if (!hasFolder(folderId)) return; <line2> Folder folder = getFolder(folderId); <line3> if (folder.countNotes() == 0 && !folder.hasChild()) { <line4> removeFolder(folderId); <line5> } <line6> } <line7> } <line8> 	<line4>	task4	
public class A { <line0> private static MonitoredCallStructure getMonitoredCallStructure( <line1> StopBean stopBean, <line2> PresentationService presentationService, <line3> double distanceOfCallAlongTrip, <line4> double distanceOfVehicleFromCall, <line5> int visitNumber, <line6> int index, <line7> TimepointPredictionRecord prediction, <line8> boolean hasRealtimeData, <line9> long responseTimestamp, <line10> long scheduledArrivalTime, <line11> long scheduledDepartureTime, <line12> double scheduleDeviation) { <line13> boolean hasPrediction = prediction != null; <line14> Long predictedArrivalTime = null; <line15> Long predictedDepartureTime = null; <line16> if (hasPrediction) { <line17> predictedArrivalTime = prediction.getTimepointPredictedArrivalTime(); <line18> predictedDepartureTime = prediction.getTimepointPredictedDepartureTime(); <line19> } <line20> if (prediction != null <line21> && prediction.getScheduleRelationship() != null <line22> && prediction.isSkipped()) { <line23> return null; <line24> } <line25> MonitoredCallStructure monitoredCallStructure = new MonitoredCallStructure(); <line26> monitoredCallStructure.setVisitNumber(BigInteger.valueOf(visitNumber)); <line27> StopPointRefStructure stopPointRef = new StopPointRefStructure(); <line28> stopPointRef.setValue(stopBean.getId()); <line29> monitoredCallStructure.setStopPointRef(stopPointRef); <line30> NaturalLanguageStringStructure stopPoint = new NaturalLanguageStringStructure(); <line31> stopPoint.setValue(stopBean.getName()); <line32> monitoredCallStructure.setStopPointName(stopPoint); <line33> Date expectedArrivalTime = <line34> getExpectedTime( <line35> hasRealtimeData, <line36> hasPrediction, <line37> predictedArrivalTime, <line38> scheduledArrivalTime, <line39> scheduleDeviation, <line40> responseTimestamp); <line41> Date expectedDepartureTime = <line42> getExpectedTime( <line43> hasRealtimeData, <line44> hasPrediction, <line45> predictedDepartureTime, <line46> scheduledDepartureTime, <line47> scheduleDeviation, <line48> responseTimestamp); <line49> if (expectedArrivalTime.after(expectedDepartureTime)) { <line50> expectedDepartureTime = expectedArrivalTime; <line51> } <line52> monitoredCallStructure.setExpectedArrivalTime(expectedArrivalTime); <line53> monitoredCallStructure.setExpectedDepartureTime(expectedDepartureTime); <line54> if (monitoredCallStructure.getExpectedArrivalTime() != null) { <line55> monitoredCallStructure.setAimedArrivalTime(new Date(scheduledArrivalTime)); <line56> } <line57> SiriExtensionWrapper wrapper = new SiriExtensionWrapper(); <line58> ExtensionsStructure distancesExtensions = new ExtensionsStructure(); <line59> SiriDistanceExtension distances = new SiriDistanceExtension(); <line60> DecimalFormat df = new DecimalFormat(); <line61> df.setMaximumFractionDigits(2); <line62> df.setGroupingUsed(false); <line63> distances.setStopsFromCall(index); <line64> distances.setCallDistanceAlongRoute(NumberUtils.toDouble(df.format(distanceOfCallAlongTrip))); <line65> distances.setDistanceFromCall(NumberUtils.toDouble(df.format(distanceOfVehicleFromCall))); <line66> distances.setPresentableDistance(presentationService.getPresentableDistance(distances)); <line67> long deviation = 0L; <line68> if (monitoredCallStructure.getExpectedArrivalTime() != null <line69> && monitoredCallStructure.getAimedArrivalTime() != null) { <line70> long deviationSeconds = <line71> monitoredCallStructure.getExpectedArrivalTime().getTime() <line72> - monitoredCallStructure.getAimedArrivalTime().getTime(); <line73> deviation = Math.round(deviationSeconds / (1000.0 * 60.0)); <line74> } <line75> wrapper.setDeviation(String.valueOf(deviation)); <line76> wrapper.setDistances(distances); <line77> distancesExtensions.setAny(wrapper); <line78> monitoredCallStructure.setExtensions(distancesExtensions); <line79> return monitoredCallStructure; <line80> } <line81> } <line82> 	<line23>	task4	
"public class A { <line0> public void setQueryString(NameValuePair[] params) { <line1> queryString = EncodingUtil.formUrlEncode(params, ""UTF-8""); <line2> } <line3> } <line4> "	<line1>	task4	
"public class A { <line0> public void reportBegin(final Reportable source) { <line1> assert source != null; <line2> logFile = source.getLogFile(); <line3> testName = source.getName(); <line4> startTime = source.getStartTime().getTime(); <line5> try { <line6> FileUtils.forceMkdir(reportsDirectory); <line7> } catch (IOException e) { <line8> } <line9> outputFile = new File(reportsDirectory, testName + "".txt""); <line10> reportFile = new File(reportsDirectory, ""TEST-"" + testName + "".xml""); <line11> if (reportFile.exists()) { <line12> reportFile.delete(); <line13> } <line14> } <line15> } <line16> "	<line8>	task4	
"public class A { <line0> private List<RoutingConfig> loadRoutingInfo(final NodeList list) { <line1> final ArrayList<RoutingConfig> result = new ArrayList<>(); <line2> final Node channels = list.item(0); <line3> for (int s = 0; s < channels.getChildNodes().getLength(); s++) { <line4> final Node node = channels.getChildNodes().item(s); <line5> if (node.getNodeType() == Node.ELEMENT_NODE) { <line6> final Element element = (Element) node; <line7> if (""RoutingConfig"".equalsIgnoreCase(element.getNodeName())) { <line8> final RoutingConfig item = new RoutingConfig(); <line9> for (int x = 0; x < element.getChildNodes().getLength(); x++) { <line10> final String nodeName = element.getChildNodes().item(x).getNodeName(); <line11> final String nodeValue = element.getChildNodes().item(x).getTextContent(); <line12> if (""Recipient"".equalsIgnoreCase(nodeName)) { <line13> item.setRecepient(nodeValue); <line14> } else if (""Bean"".equalsIgnoreCase(nodeName)) { <line15> item.setBean(nodeValue); <line16> } <line17> } <line18> result.add(item); <line19> } <line20> } <line21> } <line22> return result; <line23> } <line24> } <line25> "	<line3>	task4	
"public class A { <line0> @Override <line1> public byte[] encode() { <line2> byte[] resourceIdBytes = resourceId != null ? resourceId.getBytes() : null; <line3> byte[] lockKeyBytes = lockKey != null ? lockKey.getBytes() : null; <line4> byte[] clientIdBytes = clientId != null ? clientId.getBytes() : null; <line5> byte[] applicationDataBytes = applicationData != null ? applicationData.getBytes() : null; <line6> byte[] xidBytes = xid != null ? xid.getBytes() : null; <line7> byte branchTypeByte = branchType != null ? (byte) branchType.ordinal() : -1; <line8> int size = <line9> calBranchSessionSize( <line10> resourceIdBytes, lockKeyBytes, clientIdBytes, applicationDataBytes, xidBytes); <line11> if (size > MAX_BRANCH_SESSION_SIZE) { <line12> if (lockKeyBytes == null) { <line13> throw new RuntimeException( <line14> ""branch session size exceeded, size : "" <line15> + size <line16> + "" maxBranchSessionSize : "" <line17> + MAX_BRANCH_SESSION_SIZE); <line18> } <line19> try { <line20> size -= lockKeyBytes.length; <line21> lockKeyBytes = CompressUtil.compress(lockKeyBytes); <line22> } catch (IOException e) { <line23> } finally { <line24> size += lockKeyBytes.length; <line25> } <line26> if (size > MAX_BRANCH_SESSION_SIZE) { <line27> throw new RuntimeException( <line28> ""compress branch session size exceeded, compressSize : "" <line29> + size <line30> + "" maxBranchSessionSize : "" <line31> + MAX_BRANCH_SESSION_SIZE); <line32> } <line33> } <line34> ByteBuffer byteBuffer = byteBufferThreadLocal.get(); <line35> byteBuffer.clear(); <line36> byteBuffer.putLong(transactionId); <line37> byteBuffer.putLong(branchId); <line38> if (resourceIdBytes != null) { <line39> byteBuffer.putInt(resourceIdBytes.length); <line40> byteBuffer.put(resourceIdBytes); <line41> } else { <line42> byteBuffer.putInt(0); <line43> } <line44> if (lockKeyBytes != null) { <line45> byteBuffer.putInt(lockKeyBytes.length); <line46> byteBuffer.put(lockKeyBytes); <line47> } else { <line48> byteBuffer.putInt(0); <line49> } <line50> if (clientIdBytes != null) { <line51> byteBuffer.putShort((short) clientIdBytes.length); <line52> byteBuffer.put(clientIdBytes); <line53> } else { <line54> byteBuffer.putShort((short) 0); <line55> } <line56> if (applicationDataBytes != null) { <line57> byteBuffer.putInt(applicationDataBytes.length); <line58> byteBuffer.put(applicationDataBytes); <line59> } else { <line60> byteBuffer.putInt(0); <line61> } <line62> if (xidBytes != null) { <line63> byteBuffer.putInt(xidBytes.length); <line64> byteBuffer.put(xidBytes); <line65> } else { <line66> byteBuffer.putInt(0); <line67> } <line68> byteBuffer.put(branchTypeByte); <line69> byteBuffer.put((byte) status.getCode()); <line70> byteBuffer.flip(); <line71> byte[] result = new byte[byteBuffer.limit()]; <line72> byteBuffer.get(result); <line73> return result; <line74> } <line75> } <line76> "	<line23>	task4	
"public class A { <line0> private static boolean determinePatchedItext() { <line1> try { <line2> PdfContentByte.class.getMethod(""showText"", GlyphVector.class); <line3> return true; <line4> } catch (NoSuchMethodException e) { <line5> return false; <line6> } catch (SecurityException e) { <line7> throw new JRRuntimeException(e); <line8> } <line9> } <line10> } <line11> "	<line5>	task4	
"public class A { <line0> @ParallelTest <line1> @OpenShiftOnly <line2> void testConnectS2ILogSetting(ExtensionContext extensionContext) { <line3> String clusterName = mapWithClusterNames.get(extensionContext.getDisplayName()); <line4> String connectS2IClusterName = clusterName + ""-connect-s2i""; <line5> resourceManager.createResource( <line6> extensionContext, <line7> KafkaConnectS2ITemplates.kafkaConnectS2I( <line8> extensionContext, connectS2IClusterName, LOG_SETTING_CLUSTER_NAME, 1) <line9> .editSpec() <line10> .withNewInlineLogging() <line11> .withLoggers(CONNECT_LOGGERS) <line12> .endInlineLogging() <line13> .withNewJvmOptions() <line14> .withGcLoggingEnabled(true) <line15> .endJvmOptions() <line16> .endSpec() <line17> .build()); <line18> String connectS2IDepName = KafkaConnectS2IResources.deploymentName(connectS2IClusterName); <line19> Map<String, String> connectS2IPods = <line20> DeploymentConfigUtils.depConfigSnapshot(NAMESPACE, connectS2IDepName); <line21> String connectS2IMap = <line22> KafkaConnectS2IResources.metricsAndLogConfigMapName(connectS2IClusterName); <line23> assertThat( <line24> ""KafkaConnectS2I's log level is set properly"", <line25> checkLoggersLevel(NAMESPACE, CONNECT_LOGGERS, connectS2IMap), <line26> is(true)); <line27> assertThat( <line28> ""ConnectS2I GC logging is enabled"", <line29> checkGcLoggingDeploymentConfig(NAMESPACE, connectS2IDepName), <line30> is(true)); <line31> KafkaConnectS2IResource.replaceConnectS2IResourceInSpecificNamespace( <line32> connectS2IClusterName, cs2i -> cs2i.getSpec().setJvmOptions(JVM_OPTIONS), NAMESPACE); <line33> DeploymentConfigUtils.waitTillDepConfigHasRolled(NAMESPACE, connectS2IDepName, connectS2IPods); <line34> assertThat( <line35> ""ConnectS2I GC logging is disabled"", <line36> checkGcLoggingDeploymentConfig(NAMESPACE, connectS2IDepName), <line37> is(false)); <line38> kubectlGetStrimziUntilOperationIsSuccessful(NAMESPACE, connectS2IClusterName); <line39> checkContainersHaveProcessOneAsTini(NAMESPACE, connectS2IClusterName); <line40> } <line41> } <line42> "	<line23>	task4	
public class A { <line0> @Override <line1> public String publishText(String text) { <line2> return text; <line3> } <line4> } <line5> 	<line2>	task4	
"public class A { <line0> @Test <line1> public void testInsertTransformedWhere() throws Exception { <line2> StringBuilder update = new StringBuilder(); <line3> update.append(getNamespaceDeclarations()); <line4> update.append(""INSERT {?x rdfs:label [] . } WHERE {?y ex:containsPerson ?x.  }""); <line5> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update.toString()); <line6> assertFalse(con.hasStatement(bob, RDFS.LABEL, null, true)); <line7> assertFalse(con.hasStatement(alice, RDFS.LABEL, null, true)); <line8> operation.execute(); <line9> assertTrue(con.hasStatement(bob, RDFS.LABEL, null, true)); <line10> assertTrue(con.hasStatement(alice, RDFS.LABEL, null, true)); <line11> } <line12> } <line13> "	<line2>	task4	
public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final ApplicationTO ignore) { <line2> try { <line3> ApplicationRestClient.delete(model.getObject().getKey()); <line4> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line5> target.add(container); <line6> } catch (SyncopeClientException e) { <line7> SyncopeConsoleSession.get().onException(e); <line8> } <line9> ((BaseWebPage) pageRef.getPage()).getNotificationPanel().refresh(target); <line10> } <line11> } <line12> 	<line7>	task4	
public class A { <line0> @Test <line1> void preserveSynonyms() { <line2> if (!defaultDatabase.supportsSynonyms()) { <line3> return; <line4> } <line5> assertEquals(2, defaultDatabase.getSynonymNames().size()); <line6> defaultDBClearer.clearDatabase(); <line7> assertEquals(2, defaultDatabase.getSynonymNames().size()); <line8> } <line9> } <line10> 	<line3>	task4	
"public class A { <line0> @Override <line1> public PageModelDto getPageModel(String code) { <line2> PageModel pageModel = this.pageModelManager.getPageModel(code); <line3> if (null == pageModel) { <line4> throw new ResourceNotFoundException( <line5> PageModelValidator.ERRCODE_PAGEMODEL_NOT_FOUND, ""pageModel"", code); <line6> } <line7> PageModelDto dto = this.dtoBuilder.convert(pageModel); <line8> dto.setReferences(this.getReferencesInfo(pageModel)); <line9> return dto; <line10> } <line11> } <line12> "	<line4>	task4	
"public class A { <line0> @Transactional(readOnly = true) <line1> private void getInterdependentImagesByL3NetworkUuids( <line2> APIGetInterdependentL3NetworksImagesMsg msg) { <line3> APIGetInterdependentL3NetworkImageReply reply = new APIGetInterdependentL3NetworkImageReply(); <line4> List<List<BackupStorageVO>> bss = new ArrayList<>(); <line5> for (String l3uuid : msg.getL3NetworkUuids()) { <line6> String sql = <line7> ""select ps"" <line8> + "" from PrimaryStorageVO ps, L2NetworkClusterRefVO l2ref,"" <line9> + "" L3NetworkVO l3, PrimaryStorageClusterRefVO psref"" <line10> + "" where ps.uuid = psref.primaryStorageUuid"" <line11> + "" and psref.clusterUuid = l2ref.clusterUuid"" <line12> + "" and l2ref.l2NetworkUuid = l3.l2NetworkUuid"" <line13> + "" and l3.uuid = :l3uuid""; <line14> TypedQuery<PrimaryStorageVO> psq = <line15> dbf.getEntityManager().createQuery(sql, PrimaryStorageVO.class); <line16> psq.setParameter(""l3uuid"", l3uuid); <line17> List<PrimaryStorageVO> pss = psq.getResultList(); <line18> List<BackupStorageVO> lst = new ArrayList<>(); <line19> for (PrimaryStorageVO ps : pss) { <line20> PrimaryStorageType psType = PrimaryStorageType.valueOf(ps.getType()); <line21> List<String> bsUuids = psType.findBackupStorage(ps.getUuid()); <line22> if (!bsUuids.isEmpty()) { <line23> sql = ""select bs from BackupStorageVO bs where bs.uuid in (:uuids)""; <line24> TypedQuery<BackupStorageVO> bq = <line25> dbf.getEntityManager().createQuery(sql, BackupStorageVO.class); <line26> bq.setParameter(""uuids"", bsUuids); <line27> lst.addAll(bq.getResultList()); <line28> } else { <line29> } <line30> } <line31> bss.add(lst); <line32> } <line33> List<BackupStorageVO> selectedBss = new ArrayList<>(); <line34> for (List<BackupStorageVO> lst : bss) { <line35> selectedBss.addAll(lst); <line36> } <line37> for (List<BackupStorageVO> l : bss) { <line38> selectedBss = listIntersection(selectedBss, l); <line39> } <line40> if (selectedBss.isEmpty()) { <line41> reply.setInventories(new ArrayList()); <line42> bus.reply(msg, reply); <line43> return; <line44> } <line45> List<String> bsUuids = <line46> selectedBss.stream().map(BackupStorageVO::getUuid).collect(Collectors.toList()); <line47> String sql = <line48> ""select img from ImageVO img, ImageBackupStorageRefVO iref, BackupStorageZoneRefVO zref,"" <line49> + "" BackupStorageVO bs where img.uuid = iref.imageUuid and iref.backupStorageUuid ="" <line50> + "" zref.backupStorageUuid and bs.uuid = zref.backupStorageUuid and bs.uuid in (:uuids)"" <line51> + "" and zref.zoneUuid = :zoneUuid group by img.uuid""; <line52> TypedQuery<ImageVO> iq = dbf.getEntityManager().createQuery(sql, ImageVO.class); <line53> iq.setParameter(""uuids"", bsUuids); <line54> iq.setParameter(""zoneUuid"", msg.getZoneUuid()); <line55> List<ImageVO> vos = iq.getResultList(); <line56> reply.setInventories(ImageInventory.valueOf(vos)); <line57> bus.reply(msg, reply); <line58> } <line59> } <line60> "	<line29>	task4	
public class A { <line0> public void updateVertexPartialStatus(MigrationImportStatus status) { <line1> try { <line2> setEncodedProperty(vertex, PROPERTY_KEY_STATUS, status.getOperationStatus()); <line3> } catch (Exception e) { <line4> } finally { <line5> graph.commit(); <line6> } <line7> } <line8> } <line9> 	<line4>	task4	
public class A { <line0> protected void addCalendarValue(Document doc, String fieldName, Calendar internalValue) { <line1> try { <line2> doc.add( <line3> createFieldWithoutNorms( <line4> fieldName, <line5> DateField.timeToString(internalValue.getTimeInMillis()), <line6> PropertyType.DATE)); <line7> } catch (IllegalArgumentException e) { <line8> } <line9> } <line10> } <line11> 	<line8>	task4	
public class A { <line0> @Override <line1> public synchronized boolean freshIndex(KCluster cluster) { <line2> boolean containsKey = batchLocks.containsKey(cluster); <line3> boolean isFreshIndex = this.provider.isFreshIndex(cluster) && !containsKey; <line4> if (logger.isDebugEnabled()) { <line5> } <line6> return isFreshIndex; <line7> } <line8> } <line9> 	<line5>	task4	
public class A { <line0> private boolean equals( <line1> final Field field, <line2> final Collection<?> col1, <line3> final Collection<?> col2, <line4> final boolean logDifference) { <line5> for (final Object colVal1 : col1) { <line6> boolean equals = false; <line7> for (final Object colVal2 : col2) { <line8> if (equals(colVal1, colVal2, false)) { <line9> equals = true; <line10> break; <line11> } <line12> } <line13> if (!equals) { <line14> if (logDifference) { <line15> } <line16> return false; <line17> } <line18> } <line19> return true; <line20> } <line21> } <line22> 	<line15>	task4	
"public class A { <line0> @Override <line1> @SuppressWarnings(""null"") <line2> public synchronized void initialize() { <line3> Bridge tradfriGateway = getBridge(); <line4> this.id = getConfigAs(TradfriDeviceConfig.class).id; <line5> TradfriGatewayHandler handler = (TradfriGatewayHandler) tradfriGateway.getHandler(); <line6> active = true; <line7> updateStatus(ThingStatus.UNKNOWN); <line8> switch (tradfriGateway.getStatus()) { <line9> case ONLINE: <line10> String uriString = handler.getGatewayURI() + ""/"" + id; <line11> try { <line12> URI uri = new URI(uriString); <line13> coapClient = new TradfriCoapClient(uri); <line14> coapClient.setEndpoint(handler.getEndpoint()); <line15> } catch (URISyntaxException e) { <line16> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage()); <line17> return; <line18> } <line19> scheduler.schedule( <line20> () -> { <line21> observeRelation = coapClient.startObserve(this); <line22> }, <line23> 3, <line24> TimeUnit.SECONDS); <line25> break; <line26> case OFFLINE: <line27> default: <line28> updateStatus( <line29> ThingStatus.OFFLINE, <line30> ThingStatusDetail.BRIDGE_OFFLINE, <line31> String.format(""Gateway offline '%s'"", tradfriGateway.getStatusInfo())); <line32> break; <line33> } <line34> } <line35> } <line36> "	<line16>	task4	
"public class A { <line0> @Test <line1> public void testExpandWildcardWithMultipleResources() { <line2> final WroModel model = new WroModel(); <line3> final String uri = <line4> String.format( <line5> ClasspathUriLocator.PREFIX + ""%s/expander/*.js"", WroUtil.toPackageAsFolder(getClass())); <line6> model.addGroup(new Group(""group"").addResource(Resource.create(uri, ResourceType.JS))); <line7> Mockito.when(decoratedFactory.create()).thenReturn(model); <line8> final WroModel changedModel = transformer.transform(model); <line9> Assert.assertEquals(3, changedModel.getGroupByName(""group"").getResources().size()); <line10> } <line11> } <line12> "	<line9>	task4	
public class A { <line0> @Test <line1> public void testListeners() { <line2> for (HealthCheckActionListener listener : listeners) { <line3> } <line4> } <line5> } <line6> 	<line3>	task4	
public class A { <line0> private HttpClientConfigCallback httpClientConfig( <line1> Optional<HttpHost> proxy, HttpRequestInterceptor interceptor) { <line2> return (httpClientBuilder) -> { <line3> httpClientBuilder.addInterceptorLast(interceptor); <line4> if (proxy.isPresent()) { <line5> httpClientBuilder.setProxy(proxy.get()); <line6> Optional<CredentialsProvider> credentialProvider = getCredentialsProvider(proxy.get()); <line7> if (credentialProvider.isPresent()) { <line8> httpClientBuilder.setDefaultCredentialsProvider(credentialProvider.get()); <line9> } <line10> } <line11> if (skipSslVerification) { <line12> try { <line13> SSLContext sslContext = <line14> new SSLContextBuilder() <line15> .loadTrustMaterial(null, (x509Certificates, s) -> true) <line16> .build(); <line17> httpClientBuilder.setSSLContext(sslContext); <line18> httpClientBuilder.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE); <line19> } catch (Exception e) { <line20> } <line21> } <line22> return httpClientBuilder; <line23> }; <line24> } <line25> } <line26> 	<line20>	task4	
public class A { <line0> @Override <line1> public void onHalfClose() { <line2> delegate().onHalfClose(); <line3> } <line4> } <line5> 	<line2>	task4	
public class A { <line0> private Map<Long, Integer> getPriorityMap(final List<OrchestratorStore> orchestratorStoreList) { <line1> final Map<Long, Integer> priorityMap = new HashMap<>(orchestratorStoreList.size()); <line2> for (final OrchestratorStore orchestratorStore : orchestratorStoreList) { <line3> priorityMap.put(orchestratorStore.getId(), orchestratorStore.getPriority()); <line4> } <line5> return priorityMap; <line6> } <line7> } <line8> 	<line1>	task4	
public class A { <line0> public void processPreQuery(QueryRequest request, SolrQuery query) { <line1> if (userHighlightIsOn(request)) { <line2> boolean isAnyText = false; <line3> try { <line4> isAnyText = <line5> filterAdapter.adapt(request.getQuery(), new PropertyExistsDelegate(Metacard.ANY_TEXT)); <line6> } catch (UnsupportedQueryException e) { <line7> } <line8> enableHighlighter(query, isAnyText); <line9> } <line10> } <line11> } <line12> 	<line7>	task4	
public class A { <line0> public void backOff() { <line1> numRetries++; <line2> final long now = ticker.read(); <line3> this.waitingTimeMs = getWaitingTimeMs(); <line4> try { <line5> Thread.sleep(this.waitingTimeMs); <line6> } catch (InterruptedException e) { <line7> Thread.currentThread().interrupt(); <line8> } <line9> this.expiryTimeMs = Math.max(now, now + waitingTimeMs); <line10> } <line11> } <line12> 	<line9>	task4	
"public class A { <line0> @Override <line1> public void onCommandReceived(EthernetBridgeHandler bridge, IrCommand command) { <line2> IrCommand thingCompatibleCommand = new IrCommand(); <line3> thingCompatibleCommand.setRemote((String) getConfig().get(REMOTE)); <line4> thingCompatibleCommand.setCommand((String) getConfig().get(COMMAND)); <line5> if (command.matches(thingCompatibleCommand)) { <line6> StringType stringType = new StringType(command.getRemote() + "","" + command.getCommand()); <line7> updateState(CHANNEL_IO, stringType); <line8> } <line9> } <line10> } <line11> "	<line2>	task4	
"public class A { <line0> public static void main(String[] args) { <line1> String objectStoreServiceLocation = <line2> ""http://beta.services.openaire.eu:8280/is/services/objectStore""; <line3> W3CEndpointReferenceBuilder eprBuilder = new W3CEndpointReferenceBuilder(); <line4> eprBuilder.address(objectStoreServiceLocation); <line5> eprBuilder.build(); <line6> ObjectStoreService objectStore = <line7> new JaxwsServiceResolverImpl().getService(ObjectStoreService.class, eprBuilder.build()); <line8> } <line9> } <line10> "	<line8>	task4	
public class A { <line0> public static boolean relationshipTypeHasInstanceEdges(AtlasGraph graph, String typeName) <line1> throws AtlasBaseException { <line2> AtlasGraphQuery query = <line3> graph <line4> .query() <line5> .has(TYPE_NAME_PROPERTY_KEY, AtlasGraphQuery.ComparisionOperator.EQUAL, typeName); <line6> Iterator<AtlasEdge> results = query.edges().iterator(); <line7> boolean hasInstanceEdges = results != null && results.hasNext(); <line8> if (LOG.isDebugEnabled()) { <line9> } <line10> return hasInstanceEdges; <line11> } <line12> } <line13> 	<line9>	task4	
public class A { <line0> @Override <line1> public ConnectionFactory getConnectionFactory(Properties configuration) { <line2> final String _brokerURI = config.getConfiguration(BrokerConfiguration.BROKER_URL_KEY); <line3> final boolean changed = checkBrokerURI(_brokerURI); <line4> if (LOGGER.isLoggable(Level.INFO)) { <line5> } <line6> if (cf == null) { <line7> cf = new PooledConnectionFactory(brokerURI); <line8> } else { <line9> if (changed) { <line10> try { <line11> destroyConnectionFactory(); <line12> } catch (Exception e) { <line13> } <line14> cf = new PooledConnectionFactory(brokerURI); <line15> } <line16> } <line17> return cf; <line18> } <line19> } <line20> 	<line5>	task4	
public class A { <line0> protected <T> T makeHttpGetRequestAndCreateCustomResponse(String uri, Class<T> resultType) { <line1> KieServerHttpRequest request = <line2> invoke( <line3> uri, <line4> new RemoteHttpOperation() { <line5> @Override <line6> public KieServerHttpRequest doOperation(String url) { <line7> return newRequest(url).get(); <line8> } <line9> }); <line10> KieServerHttpResponse response = request.response(); <line11> owner.setConversationId(response.header(KieServerConstants.KIE_CONVERSATION_ID_TYPE_HEADER)); <line12> if (response.code() == Response.Status.OK.getStatusCode()) { <line13> return deserialize(response.body(), resultType); <line14> } else { <line15> throw createExceptionForUnexpectedResponseCode(request, response); <line16> } <line17> } <line18> } <line19> 	<line1>	task4	
"public class A { <line0> private Set<DataSegment> announceHistoricalSegmentBatch( <line1> final Handle handle, final Set<DataSegment> segments, final Set<DataSegment> usedSegments) <line2> throws IOException { <line3> final Set<DataSegment> toInsertSegments = new HashSet<>(); <line4> try { <line5> Set<String> existedSegments = segmentExistsBatch(handle, segments); <line6> for (DataSegment segment : segments) { <line7> if (!existedSegments.contains(segment.getId().toString())) { <line8> toInsertSegments.add(segment); <line9> } <line10> } <line11> final List<List<DataSegment>> partitionedSegments = <line12> Lists.partition(new ArrayList<>(toInsertSegments), MAX_NUM_SEGMENTS_TO_ANNOUNCE_AT_ONCE); <line13> PreparedBatch preparedBatch = <line14> handle.prepareBatch( <line15> StringUtils.format( <line16> ""INSERT INTO %1$s (id, dataSource, created_date, start, %2$send%2$s, partitioned,"" <line17> + "" version, used, payload) VALUES (:id, :dataSource, :created_date, :start,"" <line18> + "" :end, :partitioned, :version, :used, :payload)"", <line19> dbTables.getSegmentsTable(), connector.getQuoteString())); <line20> for (List<DataSegment> partition : partitionedSegments) { <line21> for (DataSegment segment : partition) { <line22> preparedBatch <line23> .add() <line24> .bind(""id"", segment.getId().toString()) <line25> .bind(""dataSource"", segment.getDataSource()) <line26> .bind(""created_date"", DateTimes.nowUtc().toString()) <line27> .bind(""start"", segment.getInterval().getStart().toString()) <line28> .bind(""end"", segment.getInterval().getEnd().toString()) <line29> .bind(""partitioned"", (segment.getShardSpec() instanceof NoneShardSpec) ? false : true) <line30> .bind(""version"", segment.getVersion()) <line31> .bind(""used"", usedSegments.contains(segment)) <line32> .bind(""payload"", jsonMapper.writeValueAsBytes(segment)); <line33> } <line34> final int[] affectedRows = preparedBatch.execute(); <line35> final boolean succeeded = <line36> Arrays.stream(affectedRows).allMatch(eachAffectedRows -> eachAffectedRows == 1); <line37> if (succeeded) { <line38> log.infoSegments(partition, ""Published segments to DB""); <line39> } else { <line40> final List<DataSegment> failedToPublish = <line41> IntStream.range(0, partition.size()) <line42> .filter(i -> affectedRows[i] != 1) <line43> .mapToObj(partition::get) <line44> .collect(Collectors.toList()); <line45> throw new ISE( <line46> ""Failed to publish segments to DB: %s"", <line47> SegmentUtils.commaSeparatedIdentifiers(failedToPublish)); <line48> } <line49> } <line50> } catch (Exception e) { <line51> log.errorSegments(segments, ""Exception inserting segments""); <line52> throw e; <line53> } <line54> return toInsertSegments; <line55> } <line56> } <line57> "	<line6>	task4	
"public class A { <line0> public static com.liferay.expando.kernel.model.ExpandoColumn updateTypeSettings( <line1> HttpPrincipal httpPrincipal, long columnId, String typeSettings) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> ExpandoColumnServiceUtil.class, <line7> ""updateTypeSettings"", <line8> _updateTypeSettingsParameterTypes6); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, columnId, typeSettings); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.expando.kernel.model.ExpandoColumn) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	<line21>	task4	
public class A { <line0> private void writeCipherSuite(StatePlaintext statePlaintext) { <line1> appendInt(statePlaintext.getCipherSuite().getValue(), HandshakeByteLength.CIPHER_SUITE); <line2> } <line3> } <line4> 	<line2>	task4	
public class A { <line0> @Test <line1> public void testPublisherFansout() throws Exception { <line2> StubConnection connection1 = createConnection(); <line3> ConnectionInfo connectionInfo1 = createConnectionInfo(); <line4> SessionInfo sessionInfo1 = createSessionInfo(connectionInfo1); <line5> ConsumerInfo consumerInfo1 = createConsumerInfo(sessionInfo1, destination); <line6> connection1.send(connectionInfo1); <line7> connection1.send(sessionInfo1); <line8> connection1.request(consumerInfo1); <line9> StubConnection connection2 = createRemoteConnection(); <line10> ConnectionInfo connectionInfo2 = createConnectionInfo(); <line11> SessionInfo sessionInfo2 = createSessionInfo(connectionInfo2); <line12> ConsumerInfo consumerInfo2 = createConsumerInfo(sessionInfo2, destination); <line13> connection2.send(connectionInfo2); <line14> connection2.send(sessionInfo2); <line15> connection2.request(consumerInfo2); <line16> StubConnection connection3 = createFanoutConnection(); <line17> ConnectionInfo connectionInfo3 = createConnectionInfo(); <line18> SessionInfo sessionInfo3 = createSessionInfo(connectionInfo3); <line19> ProducerInfo producerInfo3 = createProducerInfo(sessionInfo3); <line20> connection3.send(connectionInfo3); <line21> connection3.send(sessionInfo3); <line22> connection3.send(producerInfo3); <line23> connection3.request(createMessage(producerInfo3, destination, deliveryMode)); <line24> Assert.assertNotNull(receiveMessage(connection1)); <line25> assertNoMessagesLeft(connection1); <line26> Assert.assertNotNull(receiveMessage(connection2)); <line27> assertNoMessagesLeft(connection2); <line28> } <line29> } <line30> 	<line16>	task4	
"public class A { <line0> @Override <line1> public boolean apply(Application app) { <line2> VanillaWindowsProcess entity = <line3> Iterables.getOnlyElement(Entities.descendants(app, VanillaWindowsProcess.class)); <line4> String winRMAddress = entity.getAttribute(AdvertiseWinrmLoginPolicy.VM_USER_CREDENTIALS); <line5> String ipPort = Strings.getFirstWordAfter(winRMAddress, ""@""); <line6> String user = Strings.getFirstWord(winRMAddress); <line7> String password = Strings.getFirstWordAfter(winRMAddress, "":""); <line8> WinRmTool winRmTool = WinRmTool.connect(ipPort, user, password); <line9> WinRmToolResponse winRmResponse = <line10> winRmTool.executePs( <line11> ImmutableList.of(""(Get-Item \""C:\\\\Program Files\\\\7-Zip\\\\7z.exe\"").name"")); <line12> return ""7z.exe\r\n"".equals(winRmResponse.getStdOut()); <line13> } <line14> } <line15> "	<line12>	task4	
"public class A { <line0> private void createValuesAsPrimitives(VM vm, final String regionName, final int size) { <line1> vm.invoke( <line2> new CacheSerializableRunnable(""Create values"") { <line3> @Override <line4> public void run2() throws CacheException { <line5> Region region1 = getRootRegion().getSubregion(regionName); <line6> for (int i = 1; i <= size; i++) { <line7> switch (i % 5) { <line8> case 0: <line9> region1.put(""key"" + i, ""seeded""); <line10> break; <line11> case 1: <line12> region1.put(""key"" + i, ""seeding""); <line13> break; <line14> case 2: <line15> region1.put(""key"" + i, (double) i); <line16> break; <line17> case 3: <line18> region1.put(""key"" + i, i); <line19> break; <line20> case 4: <line21> region1.put(""key"" + i, new Portfolio(i)); <line22> break; <line23> default: <line24> region1.put(""key"" + i, i); <line25> break; <line26> } <line27> } <line28> } <line29> }); <line30> } <line31> } <line32> "	<line28>	task4	
"public class A { <line0> @Test <line1> public void testGetServiceByDcIgnoreCase() throws Exception { <line2> when(consoleConfig.getConsoleDomains()) <line3> .thenReturn( <line4> new HashMap<String, String>() { <line5> { <line6> put(""jq"", ""http://127.0.0.1:8080""); <line7> put(""OY"", ""http://127.0.0.1:8081""); <line8> } <line9> }); <line10> ConsoleServiceManager manager = new ConsoleServiceManager(consoleConfig); <line11> Method method = ConsoleServiceManager.class.getDeclaredMethod(""getServiceByDc"", String.class); <line12> method.setAccessible(true); <line13> ConsoleService consoleService = (ConsoleService) method.invoke(manager, ""jq""); <line14> Assert.assertNotNull(consoleService); <line15> consoleService = (ConsoleService) method.invoke(manager, ""oy""); <line16> Assert.assertNotNull(consoleService); <line17> try { <line18> method.invoke(manager, ""rb""); <line19> Assert.fail(); <line20> } catch (Exception e) { <line21> } <line22> } <line23> } <line24> "	<line21>	task4	
"public class A { <line0> @Override <line1> public void initialize() { <line2> config = getConfigAs(HandlerConfiguration.class); <line3> if (config.deviceid.isEmpty()) { <line4> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Object ID unknown""); <line5> return; <line6> } <line7> device.initialize(config.basetopic, config.deviceid, thing.getChannels()); <line8> super.initialize(); <line9> } <line10> } <line11> "	<line2>	task4	
public class A { <line0> private Future<Map<String, Object>> userSearchDetails(Request request) { <line1> Map<String, Object> searchMap = new WeakHashMap<>(); <line2> String value = (String) request.get(JsonKey.VALUE); <line3> String encryptedValue = null; <line4> try { <line5> encryptedValue = <line6> encryptionService.encryptData(StringUtils.lowerCase(value), request.getRequestContext()); <line7> } catch (Exception var11) { <line8> throw new ProjectCommonException( <line9> ResponseCode.userDataEncryptionError.getErrorCode(), <line10> ResponseCode.userDataEncryptionError.getErrorMessage(), <line11> ResponseCode.SERVER_ERROR.getResponseCode()); <line12> } <line13> searchMap.put((String) request.get(JsonKey.KEY), encryptedValue); <line14> SearchDTO searchDTO = new SearchDTO(); <line15> searchDTO.getAdditionalProperties().put(JsonKey.FILTERS, searchMap); <line16> Future<Map<String, Object>> esFuture = <line17> esUtil.search(searchDTO, EsType.user.getTypeName(), request.getRequestContext()); <line18> return esFuture; <line19> } <line20> } <line21> 	<line14>	task4	
public class A { <line0> @Override <line1> public SuiteStatusResult process() { <line2> return null; <line3> } <line4> } <line5> 	<line2>	task4	
"public class A { <line0> @Test <line1> public void testAggregateTaskSummariesTargetEmpty() throws Exception { <line2> String json1 = read(this.getClass().getResourceAsStream(""/json/task-summary-1.json"")); <line3> String json2 = read(this.getClass().getResourceAsStream(""/json/task-summary-empty.json"")); <line4> JSONResponseAggregator aggregate = new JSONResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(json1); <line7> data.add(json2); <line8> String result = aggregate.aggregate(data); <line9> JSONObject aggregated = new JSONObject(result); <line10> assertNotNull(aggregated); <line11> Object processes = aggregated.get(""task-summary""); <line12> assertNotNull(processes); <line13> assertTrue(processes instanceof JSONArray); <line14> JSONArray processDefs = (JSONArray) processes; <line15> assertEquals(3, processDefs.length()); <line16> } <line17> } <line18> "	<line9>	task4	
public class A { <line0> protected void singleTagRemoved(PluginTagEvent event, PluginTagListener listener) { <line1> try { <line2> listener.tagRemoved(event); <line3> } catch (Exception ex) { <line4> } <line5> } <line6> } <line7> 	<line4>	task4	
public class A { <line0> @Override <line1> public void configure( <line2> @NonNull VocabCache<T> vocabCache, <line3> @NonNull WeightLookupTable<T> lookupTable, <line4> @NonNull VectorsConfiguration configuration) { <line5> this.vocabCache = vocabCache; <line6> this.lookupTable = lookupTable; <line7> this.configuration = configuration; <line8> if (configuration.getNegative() > 0) { <line9> if (((InMemoryLookupTable<T>) lookupTable).getSyn1Neg() == null) { <line10> ((InMemoryLookupTable<T>) lookupTable).setUseHS(configuration.isUseHierarchicSoftmax()); <line11> ((InMemoryLookupTable<T>) lookupTable).setNegative(configuration.getNegative()); <line12> ((InMemoryLookupTable<T>) lookupTable).resetWeights(false); <line13> } <line14> } <line15> this.syn0 = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getSyn0()); <line16> this.syn1 = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getSyn1()); <line17> this.syn1Neg = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getSyn1Neg()); <line18> this.expTable = <line19> new DeviceLocalNDArray( <line20> Nd4j.create( <line21> ((InMemoryLookupTable<T>) lookupTable).getExpTable(), <line22> new long[] {((InMemoryLookupTable<T>) lookupTable).getExpTable().length}, <line23> syn0.get().dataType())); <line24> this.table = new DeviceLocalNDArray(((InMemoryLookupTable<T>) lookupTable).getTable()); <line25> this.window = configuration.getWindow(); <line26> this.useAdaGrad = configuration.isUseAdaGrad(); <line27> this.negative = configuration.getNegative(); <line28> this.sampling = configuration.getSampling(); <line29> this.variableWindows = configuration.getVariableWindows(); <line30> this.vectorLength = configuration.getLayersSize(); <line31> } <line32> } <line33> 	<line10>	task4	
"public class A { <line0> public void deployArtifact( <line1> final InputStream jarStream, <line2> final GAV gav, <line3> final boolean includeAdditionalRepositories, <line4> final Predicate<ArtifactRepository> filter) { <line5> File jarFile = new File(System.getProperty(""java.io.tmpdir""), toFileName(gav, ""jar"")); <line6> try { <line7> inputStreamToFile(jarStream, jarFile); <line8> String pomXML = loadPomFromJar(new File(jarFile.getPath())); <line9> if (pomXML == null) { <line10> pomXML = generatePOM(gav); <line11> jarFile = appendFileToJar(pomXML, getPomXmlPath(gav), jarFile.getPath()); <line12> } <line13> String pomProperties = loadGAVFromJarInternal(new File(jarFile.getPath())); <line14> if (pomProperties == null) { <line15> pomProperties = generatePomProperties(gav); <line16> jarFile = appendFileToJar(pomProperties, getPomPropertiesPath(gav), jarFile.getPath()); <line17> } <line18> deployArtifact(gav, pomXML, jarFile, includeAdditionalRepositories, filter); <line19> } finally { <line20> try { <line21> jarFile.delete(); <line22> } catch (Exception e) { <line23> } <line24> } <line25> } <line26> } <line27> "	<line23>	task4	
"public class A { <line0> @Test(timeout = 1000 * 60 * 10) <line1> public void run() { <line2> final String kafkaAddress = kafka.getBootstrapServers(); <line3> final Producer<String, Invoke> invokeProducer = kafkaKeyedInvokesProducer(kafkaAddress); <line4> final Consumer<String, InvokeResult> invokeResultConsumer = <line5> kafkaInvokeResultsConsumer(kafkaAddress); <line6> final KafkaIOVerifier<String, Invoke, String, InvokeResult> verifier = <line7> new KafkaIOVerifier<>(invokeProducer, invokeResultConsumer); <line8> assertThat( <line9> verifier.sending(invoke(""foo""), invoke(""foo""), invoke(""bar"")), <line10> verifier.resultsInAnyOrder( <line11> is(invokeResult(""foo"", 1)), is(invokeResult(""foo"", 2)), is(invokeResult(""bar"", 1)))); <line12> verificationApp.restartWorker(randomWorkerIndex()); <line13> assertThat( <line14> verifier.sending(invoke(""foo""), invoke(""foo""), invoke(""bar"")), <line15> verifier.resultsInAnyOrder( <line16> is(invokeResult(""foo"", 3)), is(invokeResult(""foo"", 4)), is(invokeResult(""bar"", 2)))); <line17> } <line18> } <line19> "	<line12>	task4	
public class A { <line0> public void onExecutionFinish() { <line1> } <line2> } <line3> 	<line1>	task4	
public class A { <line0> @Override <line1> public void warn(String fqcn, Throwable t, String format, Object... arguments) { <line2> if (isWarnEnabled()) { <line3> if (this.isLocationAwareLogger) { <line4> locationAwareLog( <line5> (LocationAwareLogger) this.logger, <line6> fqcn, <line7> LocationAwareLogger.WARN_INT, <line8> t, <line9> format, <line10> arguments); <line11> } else { <line12> } <line13> } <line14> } <line15> } <line16> 	<line12>	task4	
public class A { <line0> @Override <line1> public void reregistered(ExecutorDriver driver, SlaveInfo slaveInfo) { <line2> } <line3> } <line4> 	<line2>	task4	
"public class A { <line0> @Override <line1> public boolean tryAppendDeleteRecord( <line2> final long id, final boolean sync, final IOCompletion callback) throws Exception { <line3> if (logger.isTraceEnabled()) { <line4> logger.UNKNOWN(""scheduling appendDeleteRecord::id="" + id); <line5> } <line6> checkJournalIsLoaded(); <line7> lineUpContext(callback); <line8> if (!checkKnownRecordID(id, false)) { <line9> if (callback != null) { <line10> callback.done(); <line11> } <line12> return false; <line13> } <line14> internalAppendDeleteRecord(id, sync, callback); <line15> return true; <line16> } <line17> } <line18> "	trace	task5	
"public class A { <line0> @Override <line1> @Beta <line2> public Collection<RegisteredType> addTypesAndValidateAllowInconsistent( <line3> String catalogYaml, <line4> @Nullable Map<RegisteredType, RegisteredType> result, <line5> boolean forceUpdate) { <line6> checkNotNull(catalogYaml, ""catalogYaml""); <line7> Maybe<OsgiManager> osgiManager = ((ManagementContextInternal) mgmt).getOsgiManager(); <line8> if (osgiManager.isPresent() && AUTO_WRAP_CATALOG_YAML_AS_BUNDLE) { <line9> return addItemsOsgi(catalogYaml, forceUpdate, osgiManager.get()).getTypesInstalled(); <line10> } <line11> log.UNKNOWN(""Catalog load, adding registered types to "" + mgmt + "": "" + catalogYaml); <line12> if (result == null) result = MutableMap.of(); <line13> collectCatalogItemsFromCatalogBomRoot( <line14> ""unbundled catalog definition"", <line15> catalogYaml, <line16> null, <line17> null, <line18> result, <line19> false, <line20> MutableMap.of(), <line21> 0, <line22> forceUpdate, <line23> true); <line24> Map<RegisteredType, Collection<Throwable>> validation = validateTypes(result.keySet()); <line25> if (Iterables.concat(validation.values()).iterator().hasNext()) { <line26> throw new IllegalStateException(""Could not validate one or more items: "" + validation); <line27> } <line28> return validation.keySet(); <line29> } <line30> } <line31> "	debug	task5	
"public class A { <line0> private boolean _isIndexedRecord(Object object) throws IOException { <line1> if (object instanceof IndexedRecord) { <line2> return true; <line3> } <line4> IllegalArgumentException illegalArgumentException = <line5> new IllegalArgumentException(""Indexed record is null""); <line6> if (object != null) { <line7> illegalArgumentException = <line8> new IllegalArgumentException( <line9> String.format( <line10> ""Expected record instance of %s but actual instance "" + ""passed was %s"", <line11> IndexedRecord.class, object.getClass())); <line12> } <line13> if (_dieOnError) { <line14> throw new IOException(illegalArgumentException); <line15> } <line16> if (logger.isWarnEnabled()) { <line17> logger.UNKNOWN(""Unable to process record"", illegalArgumentException); <line18> } <line19> return false; <line20> } <line21> } <line22> "	warn	task5	
"public class A { <line0> @Override <line1> public void safeProcessResult(int rc, String path, Object ctx, String name) { <line2> if (rc == Code.OK.intValue()) { <line3> if (logger.isDebugEnabled()) { <line4> logger.UNKNOWN(""claimed topic: "" + topic.toStringUtf8()); <line5> } <line6> notifyListenersAndAddToOwnedTopics(topic, cb, ctx); <line7> hubManager.notifyClaimedTopic(); <line8> } else if (rc == Code.NODEEXISTS.intValue()) { <line9> read(); <line10> } else { <line11> KeeperException e = <line12> ZkUtils.logErrorAndCreateZKException( <line13> ""Failed to create ephemeral node to claim ownership of topic: "" <line14> + topic.toStringUtf8(), <line15> path, <line16> rc); <line17> cb.operationFailed(ctx, new PubSubException.ServiceDownException(e)); <line18> } <line19> } <line20> } <line21> "	debug	task5	
"public class A { <line0> @Override <line1> public boolean annotate(VcfEntry vcfEntry) { <line2> boolean printed = false; <line3> boolean filteredOut = false; <line4> VcfFileIterator vcfFile = vcfEntry.getVcfFileIterator(); <line5> try { <line6> countInputLines++; <line7> countVcfEntries++; <line8> if (vcfFile.isHeadeSection()) { <line9> if (cancer) { <line10> pedigree = readPedigree(vcfFile); <line11> anyCancerSample = pedigree.anyDerived(); <line12> } <line13> } <line14> if (createSummaryHtml || createSummaryCsv) vcfStats.sample(vcfEntry); <line15> if ((filterIntervals != null) && (filterIntervals.query(vcfEntry).isEmpty())) { <line16> filteredOut = true; <line17> return false; <line18> } <line19> outputFormatter.startSection(vcfEntry); <line20> boolean impactLowOrHigher = false; <line21> List<Variant> variants = vcfEntry.variants(); <line22> for (Variant variant : variants) { <line23> showProgress(); <line24> impactLowOrHigher |= annotateVariant(variant); <line25> } <line26> if (anyCancerSample && impactLowOrHigher) annotateVariantCancer(variants, vcfEntry); <line27> outputFormatter.printSection(vcfEntry); <line28> printed = true; <line29> } catch (Throwable t) { <line30> totalErrs++; <line31> Log.UNKNOWN( <line32> t, <line33> ""Error while processing VCF entry (line "" <line34> + vcfFile.getLineNum() <line35> + "") :\n\t"" <line36> + vcfEntry <line37> + ""\n"" <line38> + t); <line39> } finally { <line40> if (!printed && !filteredOut) outputFormatter.printSection(vcfEntry); <line41> } <line42> return true; <line43> } <line44> } <line45> "	error	task5	
"public class A { <line0> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line1> @Test <line2> public void testSqlGroupBy() throws Exception { <line3> GroupByHavingOperator oper = new GroupByHavingOperator(); <line4> oper.addColumnGroupByIndex(new ColumnIndex(""b"", null)); <line5> FunctionIndex sum = new SumFunction(""c"", null); <line6> oper.addAggregateIndex(sum); <line7> HavingCondition having = new HavingCompareValue<Double>(sum, 6.0, 0); <line8> oper.addHavingCondition(having); <line9> EqualValueCondition condition = new EqualValueCondition(); <line10> condition.addEqualValue(""a"", 1); <line11> oper.setCondition(condition); <line12> CollectorTestSink sink = new CollectorTestSink(); <line13> oper.outport.setSink(sink); <line14> oper.setup(null); <line15> oper.beginWindow(1); <line16> HashMap<String, Object> tuple = new HashMap<String, Object>(); <line17> tuple.put(""a"", 1); <line18> tuple.put(""b"", 1); <line19> tuple.put(""c"", 2); <line20> oper.inport.process(tuple); <line21> tuple = new HashMap<String, Object>(); <line22> tuple.put(""a"", 1); <line23> tuple.put(""b"", 1); <line24> tuple.put(""c"", 4); <line25> oper.inport.process(tuple); <line26> tuple = new HashMap<String, Object>(); <line27> tuple.put(""a"", 1); <line28> tuple.put(""b"", 2); <line29> tuple.put(""c"", 6); <line30> oper.inport.process(tuple); <line31> tuple = new HashMap<String, Object>(); <line32> tuple.put(""a"", 1); <line33> tuple.put(""b"", 2); <line34> tuple.put(""c"", 7); <line35> oper.inport.process(tuple); <line36> oper.endWindow(); <line37> oper.teardown(); <line38> LOG.UNKNOWN(""{}"", sink.collectedTuples); <line39> } <line40> } <line41> "	debug	task5	
"public class A { <line0> @Override <line1> protected void doHealthCheck(Health.Builder builder) throws Exception { <line2> File path = this.properties.getPath(); <line3> long diskFreeInBytes = path.getFreeSpace(); <line4> if (diskFreeInBytes >= this.properties.getThreshold()) { <line5> builder.up(); <line6> } else { <line7> logger.UNKNOWN( <line8> String.format( <line9> ""Free disk space below threshold. "" + ""Available: %d bytes (threshold: %d bytes)"", <line10> diskFreeInBytes, this.properties.getThreshold())); <line11> builder.down(); <line12> } <line13> builder <line14> .withDetail(""total"", path.getTotalSpace()) <line15> .withDetail(""free"", diskFreeInBytes) <line16> .withDetail(""threshold"", this.properties.getThreshold()); <line17> } <line18> } <line19> "	warn	task5	
public class A { <line0> protected String getExportDataRootElementString(Element rootElement) { <line1> if (rootElement == null) { <line2> return StringPool.BLANK; <line3> } <line4> try { <line5> Document document = rootElement.getDocument(); <line6> return document.formattedString(); <line7> } catch (IOException ioException) { <line8> if (log.isDebugEnabled()) { <line9> log.UNKNOWN(ioException, ioException); <line10> } <line11> return StringPool.BLANK; <line12> } <line13> } <line14> } <line15> 	debug	task5	
"public class A { <line0> private void printXML(String message, Node xmlNode) { <line1> TransformerProperties transformerProperties = new TransformerProperties(); <line2> transformerProperties.addOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes""); <line3> if (LOGGER.isTraceEnabled()) { <line4> LOGGER.UNKNOWN(message, XML_UTILS.format(xmlNode, transformerProperties)); <line5> } <line6> } <line7> } <line8> "	trace	task5	
"public class A { <line0> public static void testAddClassName_Rollback(HttpPrincipal httpPrincipal, String classNameValue) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> PortalServiceUtil.class, <line5> ""testAddClassName_Rollback"", <line6> _testAddClassName_RollbackParameterTypes3); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, classNameValue); <line8> try { <line9> TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line14> log.UNKNOWN(systemException, systemException); <line15> throw systemException; <line16> } <line17> } <line18> } <line19> "	error	task5	
"public class A { <line0> @Override <line1> public AttributedList<Path> list(final Path directory, final ListProgressListener listener) <line2> throws BackgroundException { <line3> try { <line4> final AttributedList<Path> children = new AttributedList<Path>(); <line5> for (final DavResource resource : this.list(directory)) { <line6> final String href = PathNormalizer.normalize(resource.getHref().getPath(), true); <line7> if (href.equals(directory.getAbsolute())) { <line8> log.UNKNOWN(String.format(""Ignore resource %s"", href)); <line9> if (resource.isDirectory()) { <line10> continue; <line11> } <line12> throw new NotfoundException(directory.getAbsolute()); <line13> } <line14> final PathAttributes attr = attributes.toAttributes(resource); <line15> final Path file = <line16> new Path( <line17> directory, <line18> PathNormalizer.name(href), <line19> resource.isDirectory() <line20> ? EnumSet.of(Path.Type.directory) <line21> : EnumSet.of(Path.Type.file), <line22> attr); <line23> children.add(file); <line24> listener.chunk(directory, children); <line25> } <line26> return children; <line27> } catch (SardineException e) { <line28> throw new DAVExceptionMappingService().map(""Listing directory {0} failed"", e, directory); <line29> } catch (IOException e) { <line30> throw new HttpExceptionMappingService().map(e, directory); <line31> } <line32> } <line33> } <line34> "	warn	task5	
"public class A { <line0> @Override <line1> public boolean validateStudyActions(String studyId) { <line2> logger.entry(""begin validateStudyAction()""); <line3> String message = FdahpStudyDesignerConstants.SUCCESS; <line4> Session session = null; <line5> StudySequenceBo studySequenceBo = null; <line6> StudyBo studyBo = null; <line7> boolean markedAsCompleted = false; <line8> try { <line9> session = hibernateTemplate.getSessionFactory().openSession(); <line10> if (StringUtils.isNotEmpty(studyId)) { <line11> studyBo = <line12> (StudyBo) <line13> session <line14> .getNamedQuery(FdahpStudyDesignerConstants.STUDY_LIST_BY_ID) <line15> .setInteger(""id"", Integer.parseInt(studyId)) <line16> .uniqueResult(); <line17> studySequenceBo = <line18> (StudySequenceBo) <line19> session <line20> .getNamedQuery(FdahpStudyDesignerConstants.STUDY_SEQUENCE_BY_ID) <line21> .setInteger(FdahpStudyDesignerConstants.STUDY_ID, studyBo.getId()) <line22> .uniqueResult(); <line23> if (studySequenceBo != null) { <line24> markedAsCompleted = getErrorForAction(studySequenceBo); <line25> if (markedAsCompleted) { <line26> return markedAsCompleted; <line27> } else { <line28> markedAsCompleted = false; <line29> } <line30> } <line31> } else { <line32> message = ""Action is missing""; <line33> } <line34> } catch (Exception e) { <line35> logger.UNKNOWN(""StudyDAOImpl - validateStudyAction() - ERROR "", e); <line36> } finally { <line37> if ((null != session) && session.isOpen()) { <line38> session.close(); <line39> } <line40> } <line41> logger.exit(""validateStudyAction() - Ends""); <line42> return markedAsCompleted; <line43> } <line44> } <line45> "	error	task5	
"public class A { <line0> private MessageValidator<? extends ValidationContext> getMessageValidator() { <line1> if (messageValidator != null) { <line2> return messageValidator; <line3> } <line4> Optional<MessageValidator<? extends ValidationContext>> defaultMessageValidator = <line5> getTestContextFactory() <line6> .getMessageValidatorRegistry() <line7> .findMessageValidator(DEFAULT_XML_MESSAGE_VALIDATOR); <line8> if (defaultMessageValidator.isEmpty()) { <line9> try { <line10> defaultMessageValidator = <line11> Optional.of( <line12> getTestContextFactory() <line13> .getReferenceResolver() <line14> .resolve(DEFAULT_XML_MESSAGE_VALIDATOR, MessageValidator.class)); <line15> } catch (CitrusRuntimeException e) { <line16> LOG.UNKNOWN(""Unable to find default XML message validator in message validator registry""); <line17> } <line18> } <line19> if (defaultMessageValidator.isEmpty()) { <line20> defaultMessageValidator = MessageValidator.lookup(""xml""); <line21> } <line22> if (defaultMessageValidator.isPresent()) { <line23> messageValidator = defaultMessageValidator.get(); <line24> return messageValidator; <line25> } <line26> throw new CitrusRuntimeException( <line27> ""Unable to locate proper XML message validator - please add validator to project""); <line28> } <line29> } <line30> "	warn	task5	
"public class A { <line0> @Test <line1> public void testMaxIvaratorResults() throws Exception { <line2> log.UNKNOWN(""------  testMaxIvaratorResults  ------""); <line3> String regex = RE_OP + ""'b.*'""; <line4> String city = EQ_OP + ""'b-city'""; <line5> String query = Constants.ANY_FIELD + regex + AND_OP + Constants.ANY_FIELD + city; <line6> String anyRegex = this.dataManager.convertAnyField(regex); <line7> String anyCity = this.dataManager.convertAnyField(city); <line8> String expect = anyRegex + AND_OP + anyCity; <line9> List<String> dirs = ivaratorConfig(); <line10> this.logic.setCollapseUids(true); <line11> this.logic.setMaxValueExpansionThreshold(1); <line12> this.logic.setIvaratorCacheBufferSize(2); <line13> runTest(query, expect); <line14> assertTrue(countComplete(dirs) >= 1); <line15> dirs.clear(); <line16> dirs = ivaratorConfig(); <line17> this.logic.setMaxIvaratorResults(1); <line18> runTest(query, expect); <line19> assertEquals(0, countComplete(dirs)); <line20> } <line21> } <line22> "	info	task5	
"public class A { <line0> @Override <line1> public void triggerCheckpointOnBarrier( <line2> CheckpointMetaData checkpointMetaData, <line3> CheckpointOptions checkpointOptions, <line4> CheckpointMetricsBuilder checkpointMetrics) <line5> throws IOException { <line6> FlinkSecurityManager.monitorUserSystemExitForCurrentThread(); <line7> try { <line8> if (performCheckpoint(checkpointMetaData, checkpointOptions, checkpointMetrics)) { <line9> if (isSynchronousSavepointId(checkpointMetaData.getCheckpointId())) { <line10> runSynchronousSavepointMailboxLoop(); <line11> } <line12> } <line13> } catch (CancelTaskException e) { <line14> LOG.UNKNOWN( <line15> ""Operator {} was cancelled while performing checkpoint {}."", <line16> getName(), <line17> checkpointMetaData.getCheckpointId()); <line18> throw e; <line19> } catch (Exception e) { <line20> throw new IOException( <line21> ""Could not perform checkpoint "" <line22> + checkpointMetaData.getCheckpointId() <line23> + "" for operator "" <line24> + getName() <line25> + '.', <line26> e); <line27> } finally { <line28> FlinkSecurityManager.unmonitorUserSystemExitForCurrentThread(); <line29> } <line30> } <line31> } <line32> "	info	task5	
"public class A { <line0> @Override <line1> public void onUnhandled(Event event) { <line2> try { <line3> super.onUnhandled(event); <line4> } catch (NullPointerException e) { <line5> logger.UNKNOWN(""Exception occurred when handling event in super."", e); <line6> } <line7> } <line8> } <line9> "	error	task5	
public class A { <line0> @Override <line1> public boolean isSkip() { <line2> try { <line3> String type = filtered.optString(SenseiSchema.EVENT_TYPE_FIELD, null); <line4> if (type == null) return filtered.optBoolean(_skipField); <line5> else return SenseiSchema.EVENT_TYPE_SKIP.equalsIgnoreCase(type); <line6> } catch (Exception e) { <line7> logger.UNKNOWN(e.getMessage(), e); <line8> return false; <line9> } <line10> } <line11> } <line12> 	error	task5	
"public class A { <line0> @Override <line1> public boolean acceptRemoteIpAddress(final String remoteIpAddress) { <line2> try { <line3> final InetAddress address = InetAddress.getByName(remoteIpAddress); <line4> for (final NetworkPatternEntry entry : this.patterns) { <line5> final byte[] patternMask = this.applyMask(entry.getIpAddress(), entry.getMask()); <line6> final byte[] addressMask = this.applyMask(address.getAddress(), entry.getMask()); <line7> if (Arrays.equals(patternMask, addressMask)) { <line8> return true; <line9> } <line10> } <line11> } catch (final UnknownHostException e) { <line12> LOGGER.UNKNOWN(""Ip address or hostname {} is not found."", remoteIpAddress); <line13> } <line14> return false; <line15> } <line16> } <line17> "	error	task5	
"public class A { <line0> public boolean removeFromTempQueueEvents(Object tailKey) { <line1> synchronized (this.queuedEventsSync) { <line2> Iterator<TmpQueueEvent> itr = this.tmpQueuedEvents.iterator(); <line3> while (itr.hasNext()) { <line4> TmpQueueEvent event = itr.next(); <line5> if (tailKey.equals(event.getEvent().getTailKey())) { <line6> if (logger.isDebugEnabled()) { <line7> logger.UNKNOWN( <line8> ""shadowKey {} is found in tmpQueueEvents at AbstractGatewaySender level. Removing"" <line9> + "" from there.."", <line10> tailKey); <line11> } <line12> event.release(); <line13> itr.remove(); <line14> return true; <line15> } <line16> } <line17> return false; <line18> } <line19> } <line20> } <line21> "	debug	task5	
"public class A { <line0> @Override <line1> protected Set<Pair<MetricNameDto, List<PlotSingleDto>>> fetchData( <line2> List<MetricNameDto> metricNames) { <line3> if (metricNames.isEmpty()) { <line4> return Collections.emptySet(); <line5> } <line6> Collection<AbstractMetricPlotFetcher.MetricRawData> allRawData = <line7> abstractMetricPlotFetcher.getAllRawData(metricNames); <line8> if (allRawData.isEmpty()) { <line9> log.UNKNOWN(""No plot data found for metrics : {}"", metricNames); <line10> return Collections.emptySet(); <line11> } <line12> return getResult(allRawData, metricNames); <line13> } <line14> } <line15> "	warn	task5	
"public class A { <line0> @Override <line1> public synchronized void updateSize() { <line2> super.updateSize(); <line3> LOGGER.UNKNOWN(""update size""); <line4> updateAxesPosition(); <line5> m_lines = calculateLines(); <line6> ((ParallelCoordinateDrawingPane) getDrawingPane()).setLines(m_lines); <line7> getDrawingPane().repaint(); <line8> } <line9> } <line10> "	debug	task5	
"public class A { <line0> @Override <line1> public Response toResponse(NotFoundException exception) { <line2> LOGGER.UNKNOWN(""Resource not found."", exception); <line3> Map<String, Object> errorResponse = new HashMap<>(); <line4> errorResponse.put(""message"", exception.getMessage()); <line5> return Response.status(Response.Status.NOT_FOUND) <line6> .entity(errorResponse) <line7> .type(MediaType.APPLICATION_JSON_TYPE) <line8> .build(); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> void grabAndStoreActiveStreams(Optional<Node> maybeNode) <line1> throws JsonProcessingException, ReaperException { <line2> Preconditions.checkState( <line3> context.config.getDatacenterAvailability().isInCollocatedMode(), <line4> ""grabAndStoreActiveStreams() can only be called in sidecar""); <line5> Node node = getNode(maybeNode); <line6> List<StreamSession> activeStreams = ClusterFacade.create(context).listStreamsDirect(node); <line7> ((IDistributedStorage) context.storage) <line8> .storeOperations( <line9> node.getClusterName(), <line10> OpType.OP_STREAMING, <line11> node.getHostname(), <line12> objectMapper.writeValueAsString(activeStreams)); <line13> LOG.UNKNOWN(""Grabbing and storing streams for {}"", node.getHostname()); <line14> } <line15> } <line16> "	debug	task5	
"public class A { <line0> @Override <line1> public void configure(TestElement te) { <line2> super.configure(te); <line3> DbMonCollector dmte = (DbMonCollector) te; <line4> JMeterProperty dbmonValues = dmte.getSamplerSettings(); <line5> if (!(dbmonValues instanceof NullProperty)) { <line6> JMeterPluginsUtils.collectionPropertyToTableModelRows( <line7> (CollectionProperty) dbmonValues, tableModel, columnClasses); <line8> } else { <line9> log.UNKNOWN(""Received null property instead of collection""); <line10> } <line11> } <line12> } <line13> "	warn	task5	
"public class A { <line0> public Map<String, AttributeInterface> extractAttributes( <line1> BeanFactory beanFactory, String entityManagerName) { <line2> Map<String, AttributeInterface> attributes = null; <line3> try { <line4> attributes = this.loadExtraAttributes(beanFactory, entityManagerName); <line5> } catch (Throwable t) { <line6> logger.UNKNOWN(""Error loading extra attributes. entityManager: {}"", entityManagerName, t); <line7> } <line8> return attributes; <line9> } <line10> } <line11> "	error	task5	
"public class A { <line0> @Test <line1> @WithMockUser(username = ""fbristow"", password = ""password1"", roles = ""ADMIN"") <line2> public void testAddDetachedRunToSequenceFile() throws IOException, InterruptedException { <line3> final String SEQUENCE = ""ACGTACGTN""; <line4> final byte[] FASTQ_FILE_CONTENTS = <line5> (""@testread\n"" + SEQUENCE + ""\n+\n?????????\n@testread2\n"" + SEQUENCE + ""\n+\n?????????"") <line6> .getBytes(); <line7> Path p = Files.createTempFile(null, null); <line8> Files.write(p, FASTQ_FILE_CONTENTS); <line9> SequenceFile sf = new SequenceFile(); <line10> sf.setFile(p); <line11> SingleEndSequenceFile so = new SingleEndSequenceFile(sf); <line12> Sample sample = sampleService.read(1L); <line13> SequencingRun run = miseqRunService.read(2L); <line14> objectService.createSequencingObjectInSample(so, sample); <line15> miseqRunService.addSequencingObjectToSequencingRun(run, so); <line16> AnalysisFastQC analysis = null; <line17> do { <line18> try { <line19> analysis = analysisService.getFastQCAnalysisForSequenceFile(so, sf.getId()); <line20> } catch (final EntityNotFoundException e) { <line21> logger.UNKNOWN(""Fastqc still isn't finished, sleeping a bit.""); <line22> Thread.sleep(1000); <line23> } <line24> } while (analysis == null); <line25> assertNotNull(""FastQC analysis should have been created for sequence file."", analysis); <line26> } <line27> } <line28> "	info	task5	
"public class A { <line0> private void addData( <line1> @Nullable final SolrInputDocument doc, <line2> @Nonnull final String fieldName, <line3> @Nonnull final String fieldValue) { <line4> if (doc != null) { <line5> doc.addField(fieldName, fieldValue); <line6> } else { <line7> this.logger.UNKNOWN( <line8> ""The field name {} and field value {} being processed are not associated with any "" <line9> + ""cancer."", <line10> fieldName, <line11> fieldValue); <line12> } <line13> } <line14> } <line15> "	error	task5	
"public class A { <line0> protected <T extends MessageInput> void installInput( <line1> MapBinder<String, MessageInput.Factory<? extends MessageInput>> inputMapBinder, <line2> Class<T> target) { <line3> Class<? extends MessageInput.Factory<T>> factoryClass = <line4> (Class<? extends MessageInput.Factory<T>>) <line5> findInnerClassAnnotatedWith(FactoryClass.class, target, MessageInput.Factory.class); <line6> if (factoryClass == null) { <line7> LOG.UNKNOWN( <line8> ""Unable to find an inner class annotated with @FactoryClass in input {}. This input will"" <line9> + "" not be available!"", <line10> target); <line11> return; <line12> } <line13> installInput(inputMapBinder, target, factoryClass); <line14> } <line15> } <line16> "	error	task5	
"public class A { <line0> private List<Pattern> buildPatternList(String propertyName) { <line1> List<String> values = configService.getListProperty(propertyName).value(); <line2> List<Pattern> patterns = new ArrayList<Pattern>(); <line3> for (String value : values) { <line4> try { <line5> patterns.add(Pattern.compile(value.trim(), Pattern.DOTALL)); <line6> } catch (PatternSyntaxException e) { <line7> logger.UNKNOWN( <line8> ""the jdbc plugin configuration property {} contains an invalid"" <line9> + "" regular expression: {}\n{}"", <line10> propertyName, <line11> value.trim(), <line12> e.getMessage()); <line13> } <line14> } <line15> return ImmutableList.copyOf(patterns); <line16> } <line17> } <line18> "	warn	task5	
"public class A { <line0> @Override <line1> public Object apply(final ActionContext ctx, final Object caller, final Object[] sources) <line2> throws FrameworkException { <line3> try { <line4> assertArrayHasLengthAndAllElementsNotNull(sources, 1); <line5> final String cacheKey = sources[0].toString(); <line6> logger.UNKNOWN(""has_cache_value() is deprecated and will be removed in a future version.""); <line7> return CacheExpression.hasCachedValue(cacheKey); <line8> } catch (ArgumentNullException | ArgumentCountException pe) { <line9> logParameterError(caller, sources, pe.getMessage(), ctx.isJavaScriptContext()); <line10> return false; <line11> } <line12> } <line13> } <line14> "	warn	task5	
public class A { <line0> @Override <line1> protected void actualDelivery( <line2> AMQPMessage message, Delivery delivery, Receiver receiver, Transaction tx) { <line3> try { <line4> if (sessionSPI != null) { <line5> if (address == null && message != null) { <line6> validateAddressOnAnonymousLink(message); <line7> } <line8> sessionSPI.serverSend(this, tx, receiver, delivery, address, routingContext, message); <line9> } <line10> } catch (Exception e) { <line11> log.UNKNOWN(e.getMessage(), e); <line12> deliveryFailed(delivery, receiver, e); <line13> } <line14> } <line15> } <line16> 	warn	task5	
"public class A { <line0> void append(final List<AckEntry> batch) { <line1> if (batch == null || batch.isEmpty()) return; <line2> updateLock.lock(); <line3> try { <line4> if (lastAppendOffset != -1 && lastAppendOffset + 1 != batch.get(0).pullOffset()) { <line5> LOGGER.UNKNOWN( <line6> ""{}/{} append ack entry not continous. last: {}, new: {}"", <line7> subject, <line8> group, <line9> lastAppendOffset, <line10> batch.get(0).pullOffset()); <line11> appendErrorCount.inc(); <line12> } <line13> if (head == null) { <line14> beginScanPosition = head = batch.get(0); <line15> minPullOffset.set(head.pullOffset()); <line16> } <line17> if (tail != null) { <line18> tail.setNext(batch.get(0)); <line19> } <line20> tail = batch.get(batch.size() - 1); <line21> lastAppendOffset = tail.pullOffset(); <line22> maxPullOffset.set(tail.pullOffset()); <line23> toSendNum.getAndAdd(batch.size()); <line24> } finally { <line25> updateLock.unlock(); <line26> } <line27> } <line28> } <line29> "	warn	task5	
"public class A { <line0> public void valueHasChanged(SharedValueReader sharedValue, byte[] newValue) throws Exception { <line1> if (log.isDebugEnabled()) { <line2> log.UNKNOWN( <line3> ""valueHasChanged in "" <line4> + Arrays.toString(sharedValue.getValue()) <line5> + "" to "" <line6> + Arrays.toString(newValue)); <line7> } <line8> listener.stateHasChanged(SharedTriState.this, SharedTriState.fromBytes(newValue)); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> private void parseCSVLines() { <line1> long currentRowNumber = 0; <line2> try { <line3> CollectSurvey survey = (CollectSurvey) codeList.getSurvey(); <line4> List<String> languages = survey.getLanguages(); <line5> String defaultLanguage = survey.getDefaultLanguage(); <line6> File file = OpenForisIOUtils.copyToTempFile(inputStream); <line7> reader = new CodeListCSVReader(file, csvFileOptions, languages, defaultLanguage); <line8> reader.init(); <line9> levels = reader.getLevels(); <line10> addProcessedRow(1); <line11> currentRowNumber = 2; <line12> while (isRunning()) { <line13> try { <line14> CodeListLine line = reader.readNextLine(); <line15> if (line != null) { <line16> CodeListItem currentParentItem = null; <line17> List<String> levelCodes = line.getLevelCodes(); <line18> for (int levelIdx = 0; levelIdx < levelCodes.size(); levelIdx++) { <line19> boolean lastLevel = levelIdx == levelCodes.size() - 1; <line20> CodeListItem item = processLevel(currentParentItem, line, levelIdx, lastLevel); <line21> currentParentItem = item; <line22> } <line23> addProcessedRow(currentRowNumber); <line24> } <line25> if (!reader.isReady()) { <line26> break; <line27> } <line28> } catch (ParsingException e) { <line29> addParsingError(currentRowNumber, e.getError()); <line30> } finally { <line31> currentRowNumber++; <line32> } <line33> } <line34> } catch (ParsingException e) { <line35> changeStatus(Status.FAILED); <line36> addParsingError(1, e.getError()); <line37> } catch (Exception e) { <line38> changeStatus(Status.FAILED); <line39> addParsingError(currentRowNumber, new ParsingError(ErrorType.IOERROR, e.toString())); <line40> LOG.UNKNOWN(""Error importing code list CSV file"", e); <line41> } finally { <line42> IOUtils.closeQuietly(reader); <line43> } <line44> } <line45> } <line46> "	error	task5	
"public class A { <line0> public static com.liferay.portal.kernel.model.Website addWebsite( <line1> HttpPrincipal httpPrincipal, <line2> String className, <line3> long classPK, <line4> String url, <line5> long typeId, <line6> boolean primary, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(WebsiteServiceUtil.class, ""addWebsite"", _addWebsiteParameterTypes0); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, className, classPK, url, typeId, primary, serviceContext); <line14> Object returnObj = null; <line15> try { <line16> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line17> } catch (Exception exception) { <line18> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line19> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line20> } <line21> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line22> } <line23> return (com.liferay.portal.kernel.model.Website) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line25> log.UNKNOWN(systemException, systemException); <line26> throw systemException; <line27> } <line28> } <line29> } <line30> "	error	task5	
"public class A { <line0> @Override <line1> public void disconnect() throws IOException { <line2> try { <line3> batchwriter.close(); <line4> } catch (MutationsRejectedException e) { <line5> logger.UNKNOWN(""mutation rejected during batchwriter close"", e); <line6> DTThrowable.rethrow(e); <line7> } <line8> } <line9> } <line10> "	error	task5	
"public class A { <line0> @Override <line1> public void open(Configuration configuration) throws Exception { <line2> if (logFailuresOnly) { <line3> callback = <line4> new Callback() { <line5> @Override <line6> public void onCompletion(RecordMetadata metadata, Exception e) { <line7> if (e != null) { <line8> LOG.UNKNOWN(""Error while sending record to Kafka: "" + e.getMessage(), e); <line9> } <line10> acknowledgeMessage(); <line11> } <line12> }; <line13> } else { <line14> callback = <line15> new Callback() { <line16> @Override <line17> public void onCompletion(RecordMetadata metadata, Exception exception) { <line18> if (exception != null && asyncException == null) { <line19> asyncException = exception; <line20> } <line21> acknowledgeMessage(); <line22> } <line23> }; <line24> } <line25> RuntimeContext ctx = getRuntimeContext(); <line26> if (flinkKafkaPartitioner != null) { <line27> flinkKafkaPartitioner.open(ctx.getIndexOfThisSubtask(), ctx.getNumberOfParallelSubtasks()); <line28> } <line29> if (kafkaSchema instanceof KafkaContextAware) { <line30> KafkaContextAware<IN> contextAwareSchema = (KafkaContextAware<IN>) kafkaSchema; <line31> contextAwareSchema.setParallelInstanceId(ctx.getIndexOfThisSubtask()); <line32> contextAwareSchema.setNumParallelInstances(ctx.getNumberOfParallelSubtasks()); <line33> } <line34> if (kafkaSchema != null) { <line35> kafkaSchema.open( <line36> RuntimeContextInitializationContextAdapters.serializationAdapter( <line37> getRuntimeContext(), metricGroup -> metricGroup.addGroup(""user""))); <line38> } <line39> super.open(configuration); <line40> } <line41> } <line42> "	error	task5	
"public class A { <line0> @Override <line1> public final Enumeration<URL> getResources(String name) throws IOException { <line2> if (name.startsWith(""META-INF/"")) { <line3> return getParent().getResources(name); <line4> } <line5> Vector<URL> urls = new Vector<URL>(); <line6> URL localResource = getResource(name, false); <line7> if (localResource != null) { <line8> urls.add(localResource); <line9> } <line10> urls.addAll(Collections.list(getParent().getResources(name))); <line11> if (log.isTraceEnabled()) <line12> log.UNKNOWN( <line13> ""["" + getConfigurationName() + ""] retrieved files ["" + name + ""] found urls "" + urls); <line14> return urls.elements(); <line15> } <line16> } <line17> "	trace	task5	
"public class A { <line0> protected void internalRestore(VersionSet versions, boolean removeExisting) <line1> throws RepositoryException, ItemStateException { <line2> int numRestored = 0; <line3> while (versions.versions().size() > 0) { <line4> Set<InternalVersion> restored = null; <line5> for (InternalVersion v : versions.versions().values()) { <line6> NodeStateEx state = getNodeStateEx(v.getFrozenNode().getFrozenId()); <line7> if (state != null) { <line8> int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_HOLD; <line9> checkModify(state, options, Permission.NONE); <line10> restored = internalRestore(state, v, versions, removeExisting); <line11> for (InternalVersion r : restored) { <line12> versions.versions().remove(r.getVersionHistory().getId()); <line13> } <line14> numRestored += restored.size(); <line15> break; <line16> } <line17> } <line18> if (restored == null) { <line19> String msg = <line20> numRestored == 0 <line21> ? ""Unable to restore. At least one version needs existing versionable node in"" <line22> + "" workspace."" <line23> : ""Unable to restore. All versions with non existing versionable nodes need"" <line24> + "" parent.""; <line25> log.UNKNOWN(msg); <line26> throw new VersionException(msg); <line27> } <line28> } <line29> } <line30> } <line31> "	error	task5	
public class A { <line0> void log(final String message, final Object... objects) { <line1> logger.UNKNOWN(message, objects); <line2> } <line3> } <line4> 	debug	task5	
"public class A { <line0> @GET <line1> @Timed <line2> @Produces(APPLICATION_JSON_WITH_CHARSET) <line3> public String list( <line4> @Context GraphManager manager, <line5> @PathParam(""graph"") String graph, <line6> @QueryParam(""group"") String group, <line7> @QueryParam(""target"") String target, <line8> @QueryParam(""limit"") @DefaultValue(""100"") long limit) { <line9> LOG.UNKNOWN(""Graph [{}] list belongs by group {} or target {}"", graph, group, target); <line10> E.checkArgument( <line11> group == null || target == null, ""Can't pass both group and target at the same time""); <line12> HugeGraph g = graph(manager, graph); <line13> List<HugeAccess> belongs; <line14> if (group != null) { <line15> Id id = UserAPI.parseId(group); <line16> belongs = manager.authManager().listAccessByGroup(id, limit); <line17> } else if (target != null) { <line18> Id id = UserAPI.parseId(target); <line19> belongs = manager.authManager().listAccessByTarget(id, limit); <line20> } else { <line21> belongs = manager.authManager().listAllAccess(limit); <line22> } <line23> return manager.serializer(g).writeAuthElements(""accesses"", belongs); <line24> } <line25> } <line26> "	debug	task5	
"public class A { <line0> public static void logBefore( <line1> PLogger logger, <line2> Object target, <line3> String className, <line4> String methodName, <line5> String parameterDescription, <line6> Object[] args) { <line7> StringBuilder sb = new StringBuilder(512); <line8> sb.append(""BEFORE ""); <line9> logMethod(sb, getTarget(target), className, methodName, parameterDescription, args); <line10> logger.UNKNOWN(sb.toString()); <line11> } <line12> } <line13> "	debug	task5	
public class A { <line0> @Override <line1> public void info(String text, Throwable e) { <line2> log.UNKNOWN(text, e); <line3> } <line4> } <line5> 	info	task5	
"public class A { <line0> @JsxFunction <line1> public String getAllResponseHeaders() { <line2> if (state_ == STATE_UNSENT || state_ == STATE_OPENED) { <line3> throw Context.reportRuntimeError(""Unspecified error (request not sent).""); <line4> } <line5> if (webResponse_ != null) { <line6> final StringBuilder builder = new StringBuilder(); <line7> for (final NameValuePair header : webResponse_.getResponseHeaders()) { <line8> builder.append(header.getName()).append("": "").append(header.getValue()).append(""\r\n""); <line9> } <line10> return builder.append(""\r\n"").toString(); <line11> } <line12> if (LOG.isErrorEnabled()) { <line13> LOG.UNKNOWN( <line14> ""XMLHTTPRequest.getAllResponseHeaders() was called without a response available"" <line15> + "" (readyState: "" <line16> + state_ <line17> + "").""); <line18> } <line19> return null; <line20> } <line21> } <line22> "	error	task5	
"public class A { <line0> private void unregister() throws IOException { <line1> synchronized (mMonitor) { <line2> if (mCurrentNode != null) { <line3> try { <line4> ZooKeeperMonitor.this.mZKClient.delete(mCurrentNode, -1); <line5> LOG.UNKNOWN(""TableUserRegistration node {} removed."", mCurrentNode); <line6> mCurrentNode = null; <line7> } catch (KeeperException e) { <line8> throw new IOException(e); <line9> } <line10> } <line11> } <line12> } <line13> } <line14> "	debug	task5	
"public class A { <line0> private AdminSettings loadMailTemplates() throws Exception { <line1> Map<String, Object> mailTemplates = new HashMap<>(); <line2> Pattern startPattern = Pattern.compile(""<div class=\""content\"".*?>""); <line3> Pattern endPattern = Pattern.compile(""<div class=\""footer\"".*?>""); <line4> File[] files = <line5> new DefaultResourceLoader().getResource(""classpath:/templates/"").getFile().listFiles(); <line6> for (File file : files) { <line7> Map<String, String> mailTemplate = new HashMap<>(); <line8> String name = validateName(file.getName()); <line9> String stringTemplate = FileUtils.readFileToString(file, StandardCharsets.UTF_8); <line10> Matcher start = startPattern.matcher(stringTemplate); <line11> Matcher end = endPattern.matcher(stringTemplate); <line12> if (start.find() && end.find()) { <line13> String body = <line14> StringUtils.substringBetween(stringTemplate, start.group(), end.group()) <line15> .replaceAll(""\t"", """"); <line16> String subject = StringUtils.substringBetween(body, ""<h2>"", ""</h2>""); <line17> mailTemplate.put(""subject"", subject); <line18> mailTemplate.put(""body"", body); <line19> mailTemplates.put(name, mailTemplate); <line20> } else { <line21> log.UNKNOWN(""Can't load mail template from file {}"", file.getName()); <line22> } <line23> } <line24> AdminSettings adminSettings = new AdminSettings(); <line25> adminSettings.setId(new AdminSettingsId(Uuids.timeBased())); <line26> adminSettings.setKey(""mailTemplates""); <line27> adminSettings.setJsonValue(mapper.convertValue(mailTemplates, JsonNode.class)); <line28> return adminSettings; <line29> } <line30> } <line31> "	error	task5	
"public class A { <line0> @Override <line1> public FilterType within(String propertyName, String wkt) { <line2> if (!isValidInputParameters(propertyName, wkt)) { <line3> throw new IllegalArgumentException(MISSING_PARAMETERS_MSG); <line4> } <line5> if (supportedGeo.contains(SPATIAL_OPERATORS.WITHIN.getValue())) { <line6> return buildGeospatialFilterType( <line7> SPATIAL_OPERATORS.WITHIN.toString(), propertyName, wkt, null); <line8> } else if (supportedGeo.contains(SPATIAL_OPERATORS.CONTAINS.getValue())) { <line9> return not(within(propertyName, wkt)); <line10> } else { <line11> LOGGER.UNKNOWN(""WFS Source does not support Within filters""); <line12> return null; <line13> } <line14> } <line15> } <line16> "	debug	task5	
"public class A { <line0> private WebServiceTemplate createTemplate(final NotificationWebServiceLookupKey id) <line1> throws WebServiceSecurityException { <line2> final Optional<NotificationWebServiceConfiguration> config = this.configRepository.findById(id); <line3> if (!config.isPresent()) { <line4> LOGGER.UNKNOWN( <line5> ""Unable to create template: no web service configuration data available for {}"", id); <line6> return null; <line7> } <line8> return this.createTemplate(config.get()); <line9> } <line10> } <line11> "	warn	task5	
"public class A { <line0> @Override <line1> public void handleCommand(final ChannelUID channelUID, final Command command) { <line2> if (command instanceof RefreshType) { <line3> this.scheduler.execute(this::updateCollectionDates); <line4> } else { <line5> this.logger.UNKNOWN(""The AHA Abfuhrkalender is a read-only binding and can not handle commands""); <line6> } <line7> } <line8> } <line9> "	warn	task5	
"public class A { <line0> protected void logStatusMessage(int status) { <line1> switch (status) { <line2> case EXIT_OK: <line3> logger.UNKNOWN(""SCHEMA CHANGE: OK""); <line4> break; <line5> case EXIT_BAD_ARGS: <line6> logger.severe(""SCHEMA CHANGE: BAD ARGS""); <line7> break; <line8> case EXIT_RUNTIME_ERROR: <line9> logger.severe(""SCHEMA CHANGE: RUNTIME ERROR""); <line10> break; <line11> case EXIT_VALIDATION_FAILED: <line12> logger.warning(""SCHEMA CHANGE: FAILED""); <line13> break; <line14> default: <line15> logger.severe(""SCHEMA CHANGE: RUNTIME ERROR""); <line16> break; <line17> } <line18> } <line19> } <line20> "	info	task5	
public class A { <line0> @Before <line1> public void setUp() throws Exception { <line2> dataRepository = createRepository(); <line3> if (dataset != null) { <line4> try { <line5> uploadDataset(dataset); <line6> } catch (Exception exc) { <line7> try { <line8> dataRepository.shutDown(); <line9> dataRepository = null; <line10> } catch (Exception e2) { <line11> logger.UNKNOWN(e2.toString(), e2); <line12> } <line13> throw exc; <line14> } <line15> } <line16> } <line17> } <line18> 	error	task5	
"public class A { <line0> @POST <line1> @Path(""/roles"") <line2> @Consumes(APPLICATION_JSON) <line3> @Produces(APPLICATION_JSON) <line4> @ApiOperation(value = ""Assign roles for a list of users and applications"") <line5> @Timed <line6> public Response assignUserRoles( <line7> @ApiParam(name = ""userRoleList"", value = ""Please see model example"", required = true) <line8> final UserRoleList userRoleList, <line9> @HeaderParam(AUTHORIZATION) @ApiParam(value = EXAMPLE_AUTHORIZATION_HEADER, required = true) <line10> final String authorizationHeader) { <line11> try { <line12> List<Map> status = updateUserRole(userRoleList, authorizationHeader); <line13> return httpHeader <line14> .headers() <line15> .entity(ImmutableMap.<String, Object>builder().put(""assignmentStatuses"", status).build()) <line16> .build(); <line17> } catch (Exception exception) { <line18> LOGGER.UNKNOWN( <line19> ""assignUserRoles failed for userRoleList={} with error:"", userRoleList, exception); <line20> throw exception; <line21> } <line22> } <line23> } <line24> "	error	task5	
"public class A { <line0> private InputSource apply_merge(IncludeTag includeTag) throws SAXException, IOException { <line1> InputSource result = null; <line2> ArrayList<InputSource> inputSources = this.find_all_entities(includeTag); <line3> if (inputSources != null && inputSources.isEmpty() == false) { <line4> InputStream mergedStream = null; <line5> try { <line6> Properties xmlmergeProps = getXMLMergeProperties(includeTag.merge); <line7> String src = includeTag.src.replaceAll(""\\s+"", """"); <line8> mergedStream = merge(src.replace(',', '_'), xmlmergeProps, toArray(inputSources)); <line9> } catch (Throwable e) { <line10> String msg = <line11> String.format( <line12> ""Config Generation: '%s' - Error while processing %s.  Check the included files for"" <line13> + "" syntax errors. : Could not merge the include files: '%s'."", <line14> e.getMessage(), getSrcFileName(), includeTag.src); <line15> logger.UNKNOWN(msg); <line16> throw new IOException(msg, e); <line17> } <line18> result = new InputSource(mergedStream); <line19> } <line20> return result; <line21> } <line22> } <line23> "	error	task5	
"public class A { <line0> @Override <line1> protected List<String> getSchemaLocations() { <line2> List<String> schemas = new ArrayList<String>(); <line3> schemas.add(getResourceURI(JRXmlConstants.JASPERPRINT_XSD_RESOURCE)); <line4> schemas.add(getResourceURI(JRXmlConstants.JASPERPRINT_XSD_DTD_COMPAT_RESOURCE)); <line5> List<XmlValueHandler> handlers = XmlValueHandlerUtils.instance().getHandlers(); <line6> for (XmlValueHandler handler : handlers) { <line7> XmlHandlerNamespace namespace = handler.getNamespace(); <line8> if (namespace != null) { <line9> String schemaURI; <line10> String schemaResource = namespace.getInternalSchemaResource(); <line11> if (schemaResource != null) { <line12> schemaURI = getResourceURI(schemaResource); <line13> } else { <line14> schemaURI = namespace.getPublicSchemaLocation(); <line15> } <line16> if (log.isDebugEnabled()) { <line17> log.UNKNOWN(""Adding schema at "" + schemaURI); <line18> } <line19> schemas.add(schemaURI); <line20> } <line21> } <line22> return schemas; <line23> } <line24> } <line25> "	debug	task5	
"public class A { <line0> @Override <line1> public Future<CommandRouterResult> unregisterCommandConsumer( <line2> final String tenantId, <line3> final String deviceId, <line4> final String adapterInstanceId, <line5> final Span span) { <line6> return deviceConnectionInfo <line7> .removeCommandHandlingAdapterInstance(tenantId, deviceId, adapterInstanceId, span) <line8> .recover( <line9> thr -> { <line10> if (ServiceInvocationException.extractStatusCode(thr) <line11> != HttpURLConnection.HTTP_PRECON_FAILED) { <line12> LOG.UNKNOWN( <line13> ""error removing command handling adapter instance [tenant: {}, device: {}]"", <line14> tenantId, <line15> deviceId, <line16> thr); <line17> } <line18> return Future.failedFuture(thr); <line19> }) <line20> .map(v -> CommandRouterResult.from(HttpURLConnection.HTTP_NO_CONTENT)) <line21> .otherwise(t -> CommandRouterResult.from(ServiceInvocationException.extractStatusCode(t))); <line22> } <line23> } <line24> "	info	task5	
"public class A { <line0> public List<DecoratedLogLine> getDecoratedLogLines(final String componentId) <line1> throws IOException, TException, MalformedURLException { <line2> final String logs = getLogs(componentId); <line3> final String dateRegex = ""\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}""; <line4> Pattern pattern = Pattern.compile(""(?=\\n"" + dateRegex + "")""); <line5> final String[] logLines = pattern.split(logs); <line6> List<DecoratedLogLine> sortedLogs = <line7> Arrays.asList(logLines).stream() <line8> .filter(log -> log != null && StringDecorator.isDecorated(componentId, log)) <line9> .map(DecoratedLogLine::new) <line10> .sorted() <line11> .collect(Collectors.toList()); <line12> LOG.UNKNOWN(""Found "" + sortedLogs.size() + "" items for component: "" + componentId); <line13> return sortedLogs; <line14> } <line15> } <line16> "	info	task5	
"public class A { <line0> public String generateCSR(String fileName) throws IOException { <line1> if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) { <line2> Security.addProvider(new BouncyCastleProvider()); <line3> } <line4> KeyPair pair = getKeyPair(fileName); <line5> boolean result = false; <line6> if (pair != null) { <line7> String url = appConfiguration.getIdpUrl().replaceFirst("".*//"", """"); <line8> String csrPrincipal = String.format(""CN=%s"", url); <line9> X500Principal principal = new X500Principal(csrPrincipal); <line10> PKCS10CertificationRequest csr = null; <line11> try { <line12> csr = <line13> new PKCS10CertificationRequest( <line14> ""SHA1withRSA"", principal, pair.getPublic(), null, pair.getPrivate()); <line15> } catch (GeneralSecurityException e) { <line16> log.UNKNOWN(e.getMessage(), e); <line17> return OxTrustConstants.RESULT_FAILURE; <line18> } <line19> StringBuilder response = new StringBuilder(); <line20> response.append(BEGIN_CERT_REQ + ""\n""); <line21> response.append( <line22> WordUtils.wrap( <line23> new String(Base64.encode(csr.getEncoded(ASN1Encoding.DER))), 64, ""\n"", true) <line24> + ""\n""); <line25> response.append(END_CERT_REQ + ""\n""); <line26> FacesContext facesContext = FacesContext.getCurrentInstance(); <line27> result = <line28> ResponseHelper.downloadFile( <line29> ""csr.pem"", <line30> OxTrustConstants.CONTENT_TYPE_TEXT_PLAIN, <line31> response.toString().getBytes(), <line32> facesContext); <line33> } <line34> return result ? OxTrustConstants.RESULT_SUCCESS : OxTrustConstants.RESULT_FAILURE; <line35> } <line36> } <line37> "	error	task5	
"public class A { <line0> @Override <line1> public CommerceInventoryAuditType getCommerceInventoryAuditType(String key) { <line2> ServiceWrapper<CommerceInventoryAuditType> commerceChannelTypeServiceWrapper = <line3> _serviceTrackerMap.getService(key); <line4> if (commerceChannelTypeServiceWrapper == null) { <line5> if (log.isDebugEnabled()) { <line6> log.UNKNOWN(""No CommerceInventoryAuditType registered with key "" + key); <line7> } <line8> return null; <line9> } <line10> return commerceChannelTypeServiceWrapper.getService(); <line11> } <line12> } <line13> "	debug	task5	
"public class A { <line0> public OSMRole getOSMRoleOf(OSHDBRole role) { <line1> if (this.roleToString.containsKey(role)) { <line2> return this.roleToString.get(role); <line3> } <line4> OSMRole roleString; <line5> try { <line6> synchronized (roleTxtQuery) { <line7> roleTxtQuery.setInt(1, role.toInt()); <line8> try (ResultSet roles = roleTxtQuery.executeQuery()) { <line9> if (!roles.next()) { <line10> throw new OSHDBTagOrRoleNotFoundException( <line11> String.format(""Unable to find role id %d in keytables."", role.toInt())); <line12> } else { <line13> roleString = new OSMRole(roles.getString(""TXT"")); <line14> } <line15> } <line16> } <line17> } catch (SQLException ex) { <line18> LOG.UNKNOWN(UNABLE_TO_ACCESS_KEYTABLES); <line19> throw new RuntimeException(UNABLE_TO_ACCESS_KEYTABLES); <line20> } <line21> this.roleToInt.put(roleString, role); <line22> this.roleToString.put(role, roleString); <line23> return roleString; <line24> } <line25> } <line26> "	error	task5	
public class A { <line0> public static int searchCommercePriceEntriesCount( <line1> long companyId, long commercePriceListId, String keywords) throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommercePriceEntryServiceUtil.searchCommercePriceEntriesCount( <line5> companyId, commercePriceListId, keywords); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> log.UNKNOWN(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	error	task5	
"public class A { <line0> @Test <line1> public void testFillWalAndReadRecords() throws Exception { <line2> setWalAndArchiveToSameVal = false; <line3> Ignite ignite0 = startGrid(); <line4> ignite0.cluster().active(true); <line5> Serializable consistentId = (Serializable) ignite0.cluster().localNode().consistentId(); <line6> String subfolderName = genNewStyleSubfolderName(0, (UUID) consistentId); <line7> int cacheObjectsToWrite = 10_000; <line8> putDummyRecords(ignite0, cacheObjectsToWrite); <line9> stopGrid(); <line10> String workDir = U.defaultWorkDirectory(); <line11> File db = U.resolveWorkDirectory(workDir, DFLT_STORE_DIR, false); <line12> IgniteWalIteratorFactory factory = new IgniteWalIteratorFactory(log); <line13> IteratorParametersBuilder params = <line14> createIteratorParametersBuilder(workDir, subfolderName).filesOrDirs(db); <line15> int cntArchiveDir = iterateAndCount(factory.iterator(params)); <line16> log.UNKNOWN(""Total records loaded using directory : "" + cntArchiveDir); <line17> assertTrue(cntArchiveDir > 0); <line18> int[] checkKeyIterArr = new int[cacheObjectsToWrite]; <line19> fill(checkKeyIterArr, 0); <line20> iterateAndCountDataRecord( <line21> factory.iterator(params), (o1, o2) -> checkKeyIterArr[(Integer) o1]++, null); <line22> for (int i = 0; i < cacheObjectsToWrite; i++) <line23> assertTrue(""Iterator didn't find key="" + i, checkKeyIterArr[i] > 0); <line24> } <line25> } <line26> "	info	task5	
"public class A { <line0> private Key generateMasterKey() throws NoSuchAlgorithmException { <line1> if (logger.isDebugEnabled()) { <line2> logger.UNKNOWN(""==> RangerMasterKey.generateMasterKey()""); <line3> } <line4> KeyGenerator kg = KeyGenerator.getInstance(MK_CIPHER); <line5> kg.init(MK_KeySize); <line6> return kg.generateKey(); <line7> } <line8> } <line9> "	debug	task5	
"public class A { <line0> @RequestMapping( <line1> value = ""/followup/mark"", <line2> method = RequestMethod.POST, <line3> consumes = MediaType.APPLICATION_JSON_VALUE) <line4> @ResponseStatus(HttpStatus.NO_CONTENT) <line5> public @ResponseBody void markDataValues(@RequestBody UpdateFollowUpForDataValuesRequest params) { <line6> log.UNKNOWN(""markDataValues from DataAnalysisController input "" + params); <line7> List<DataValue> dataValues = new ArrayList<>(); <line8> for (FollowupParams followup : params.getFollowups()) { <line9> DataElement dataElement = dataElementService.getDataElement(followup.getDataElementId()); <line10> Period period = periodService.getPeriod(followup.getPeriodId()); <line11> OrganisationUnit source = <line12> organisationUnitService.getOrganisationUnit(followup.getOrganisationUnitId()); <line13> CategoryOptionCombo categoryOptionCombo = <line14> categoryService.getCategoryOptionCombo(followup.getCategoryOptionComboId()); <line15> CategoryOptionCombo attributeOptionCombo = <line16> categoryService.getCategoryOptionCombo(followup.getAttributeOptionComboId()); <line17> DataValue dataValue = <line18> dataValueService.getDataValue( <line19> dataElement, period, source, categoryOptionCombo, attributeOptionCombo); <line20> if (dataValue != null) { <line21> dataValue.setFollowup(followup.isFollowup()); <line22> dataValues.add(dataValue); <line23> } <line24> } <line25> if (dataValues.size() > 0) { <line26> dataValueService.updateDataValues(dataValues); <line27> } <line28> } <line29> } <line30> "	info	task5	
"public class A { <line0> public void createTable(HTableDescriptor tableDesc, byte[][] splitKeys) throws IOException { <line1> hbaseAdmin.createTable(tableDesc, splitKeys); <line2> logger.UNKNOWN(""htable {} successfully created!"", tableDesc.getTableName()); <line3> } <line4> } <line5> "	info	task5	
"public class A { <line0> @Override <line1> public boolean onCycleResult(long completedCycle, int result) { <line2> if (filter != null && !filter.test(new ResultReadableWrapper(result))) { <line3> return true; <line4> } <line5> sb.get().setLength(0); <line6> sb.get() <line7> .append(""activity="") <line8> .append(def.getAlias()) <line9> .append("",cycle="") <line10> .append(completedCycle) <line11> .append("",result="") <line12> .append((byte) (result & 127)); <line13> logger.UNKNOWN(sb.get().toString()); <line14> return true; <line15> } <line16> } <line17> "	info	task5	
"public class A { <line0> @Override <line1> protected void encode( <line2> final ChannelHandlerContext ctx, final EncodedRequest msg, final ByteBuf out) { <line3> logger.UNKNOWN(""encoding message {} on {}"", msg, ctx); <line4> out.writeBytes(msg.getEncoded()); <line5> } <line6> } <line7> "	trace	task5	
"public class A { <line0> @Override <line1> public BackgroundTaskResult call() throws Exception { <line2> try { <line3> keyManager.getExpiredOpenKeys(0); <line4> } catch (IOException e) { <line5> LOG.UNKNOWN(""Unable to get hanging open keys, retry in"" + "" next interval"", e); <line6> } <line7> return BackgroundTaskResult.EmptyTaskResult.newResult(); <line8> } <line9> } <line10> "	error	task5	
"public class A { <line0> protected void checkSelectorFetchSize(Selector selector) { <line1> if (selector == null) { <line2> return; <line3> } <line4> int maxRecordsToFetch = selector.getMaxRecordsToFetch(); <line5> if (maxRecordsToFetch > _maxRecordsPerRowFetchRequest) { <line6> LOG.UNKNOWN( <line7> ""Max records to fetch is too high [{0}] max [{1}] in Selector [{2}]"", <line8> maxRecordsToFetch, _maxRecordsPerRowFetchRequest, selector); <line9> selector.setMaxRecordsToFetch(_maxRecordsPerRowFetchRequest); <line10> } <line11> } <line12> } <line13> "	warn	task5	
"public class A { <line0> public void destroy() throws Exception { <line1> LOG.UNKNOWN(""Destroying WorkflowManagedDatasource.""); <line2> shutdown(true); <line3> this.started = false; <line4> } <line5> } <line6> "	info	task5	
"public class A { <line0> private static void closeSplitSources(StageExecutionPlan plan) { <line1> for (SplitSource source : plan.getSplitSources().values()) { <line2> try { <line3> source.close(); <line4> } catch (Throwable t) { <line5> log.UNKNOWN(t, ""Error closing split source""); <line6> } <line7> } <line8> for (StageExecutionPlan stage : plan.getSubStages()) { <line9> closeSplitSources(stage); <line10> } <line11> } <line12> } <line13> "	warn	task5	
"public class A { <line0> @Test <line1> public void testNumWithoutQuotesAndNot() throws Exception { <line2> log.UNKNOWN(""------  testNumWithoutQuotesAndNot  ------""); <line3> for (TestCities city : TestCities.values()) { <line4> String query = <line5> CityField.NUM.name() <line6> + EQ_OP <line7> + ""110"" <line8> + AND_OP <line9> + ""not ("" <line10> + CityField.CITY.name() <line11> + EQ_OP <line12> + ""'"" <line13> + city.name() <line14> + ""')""; <line15> runTest(query, query); <line16> } <line17> } <line18> } <line19> "	info	task5	
"public class A { <line0> private boolean readFile(FileSystem fs) throws IOException, AlluxioException { <line1> boolean pass = true; <line2> for (int i = 0; i < mNumFiles; i++) { <line3> AlluxioURI filePath = new AlluxioURI(mFileFolder + ""/part-"" + i); <line4> LOG.UNKNOWN(""Reading data from {}"", filePath); <line5> FileInStream is = fs.openFile(filePath); <line6> URIStatus status = fs.getStatus(filePath); <line7> ByteBuffer buf = ByteBuffer.allocate((int) status.getBlockSizeBytes()); <line8> is.read(buf.array()); <line9> buf.order(ByteOrder.nativeOrder()); <line10> for (int k = 0; k < mNumFiles; k++) { <line11> pass = pass && (buf.getInt() == k); <line12> } <line13> is.close(); <line14> } <line15> return pass; <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> private boolean saveUsers(File file) { <line1> User[] ua = new User[] {}; <line2> ua = getUsers().values().toArray(ua); <line3> LOG.UNKNOWN(""Serializing users to \""{}\"""", file); <line4> FreedomXStream.toXML(ua, file); <line5> return true; <line6> } <line7> } <line8> "	info	task5	
"public class A { <line0> @Deprecated <line1> private boolean loadEnvironmentsFromDir(File folder, boolean makeUnique) <line2> throws RepositoryException { <line3> if (folder == null) { <line4> throw new RepositoryException(""Cannot load environments from a null folder""); <line5> } <line6> environments.clear(); <line7> FileFilter envFileFilter = <line8> new FileFilter() { <line9> @Override <line10> public boolean accept(File file) { <line11> return file.isFile() && file.getName().endsWith(ENVIRONMENT_FILE_EXTENSION); <line12> } <line13> }; <line14> File[] files = folder.listFiles(envFileFilter); <line15> for (File file : files) { <line16> try { <line17> EnvironmentLogic envLogic = loadEnvironmentFromFile(file); <line18> if (envLogic != null) { <line19> add(envLogic, false); <line20> } <line21> } catch (RepositoryException re) { <line22> LOG.UNKNOWN( <line23> ""Cannot add environment from file \""{}\"""", <line24> file.getAbsolutePath(), <line25> Freedomotic.getStackTraceInfo(re)); <line26> } <line27> } <line28> thingsRepository.loadAll(EnvironmentRepositoryImpl.getEnvironments().get(0).getObjectFolder()); <line29> return true; <line30> } <line31> } <line32> "	error	task5	
"public class A { <line0> private String getImageFromPost(String url) { <line1> sleep(1000); <line2> Document d = null; <line3> try { <line4> d = Http.url(url).cookies(cookies).get(); <line5> Elements links = d.getElementsByTag(""a""); <line6> for (Element link : links) { <line7> if (link.text().equals(""Download"")) { <line8> LOGGER.UNKNOWN(""Found image "" + link.attr(""href"")); <line9> return ""https:"" + link.attr(""href""); <line10> } <line11> } <line12> } catch (IOException e) { <line13> return null; <line14> } <line15> return null; <line16> } <line17> } <line18> "	info	task5	
"public class A { <line0> public static int getCPDefinitionSpecificationOptionValuesCount( <line1> HttpPrincipal httpPrincipal, long cpDefinitionId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CPDefinitionSpecificationOptionValueServiceUtil.class, <line7> ""getCPDefinitionSpecificationOptionValuesCount"", <line8> _getCPDefinitionSpecificationOptionValuesCountParameterTypes7); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, cpDefinitionId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.UNKNOWN(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	error	task5	
"public class A { <line0> @Override <line1> protected void preClose() { <line2> if (!isEofSent()) { <line3> log.UNKNOWN(""close({}) no EOF sent"", this); <line4> } <line5> try { <line6> signalChannelClosed(null); <line7> } finally { <line8> this.channelListeners.clear(); <line9> } <line10> IOException err = IoUtils.closeQuietly(getLocalWindow(), getRemoteWindow()); <line11> if (err != null) { <line12> debug( <line13> ""Failed ({}) to pre-close window(s) of {}: {}"", <line14> err.getClass().getSimpleName(), <line15> this, <line16> err.getMessage(), <line17> err); <line18> } <line19> super.preClose(); <line20> } <line21> } <line22> "	debug	task5	
public class A { <line0> private void hideClosedCaptioning() { <line1> try { <line2> TextView subTitlesTv = (TextView) getActivity().findViewById(R.id.txtSubtitles_tv); <line3> if (subTitlesTv != null) { <line4> subTitlesTv.setVisibility(View.GONE); <line5> } <line6> } catch (Exception e) { <line7> logger.UNKNOWN(e); <line8> } <line9> } <line10> } <line11> 	error	task5	
"public class A { <line0> public String view() { <line1> try { <line2> if (!isKieServerConfigurationValid()) { <line3> return SUCCESS; <line4> } <line5> String frontEndCaseDataIn = extractWidgetConfig(""frontEndCaseData""); <line6> this.setFrontEndCaseData(frontEndCaseDataIn); <line7> String channelIn = extractWidgetConfig(""channel""); <line8> this.setChannel(channelIn); <line9> KieBpmConfig config = <line10> formManager.getKieServerConfigurations().get(this.getKnowledgeSourceId()); <line11> this.setRoles( <line12> caseManager.getCaseRoles(config, this.getContainerid(), this.getCasePath()).toString()); <line13> } catch (ApsSystemException t) { <line14> logger.UNKNOWN(""Error getting the configuration parameter"", t); <line15> return FAILURE; <line16> } <line17> return SUCCESS; <line18> } <line19> } <line20> "	error	task5	
"public class A { <line0> public ResultCode Log(List<LogEntry> list) throws TException { <line1> if (list != null) { <line2> sourceCounter.addToEventReceivedCount(list.size()); <line3> try { <line4> List<Event> events = new ArrayList<Event>(list.size()); <line5> for (LogEntry entry : list) { <line6> Map<String, String> headers = new HashMap<String, String>(1, 1); <line7> String category = entry.getCategory(); <line8> if (category != null) { <line9> headers.put(SCRIBE_CATEGORY, category); <line10> } <line11> Event event = EventBuilder.withBody(entry.getMessage().getBytes(), headers); <line12> events.add(event); <line13> } <line14> if (events.size() > 0) { <line15> getChannelProcessor().processEventBatch(events); <line16> } <line17> sourceCounter.addToEventAcceptedCount(list.size()); <line18> return ResultCode.OK; <line19> } catch (Exception e) { <line20> LOG.UNKNOWN(""Scribe source handling failure"", e); <line21> sourceCounter.incrementEventReadOrChannelFail(e); <line22> } <line23> } <line24> return ResultCode.TRY_LATER; <line25> } <line26> } <line27> "	warn	task5	
"public class A { <line0> public static GceContext validateCredentials(Credentials credentials) <line1> throws InvalidCredentialsException { <line2> try { <line3> GceContext context = new GceContext(credentials); <line4> GoogleComputeEngineApi gceApi = context.getGceApi(); <line5> String projectName = gceApi.project().get().name(); <line6> context.setProjectName(projectName); <line7> logger.UNKNOWN(String.format(""Sucessfully Authenticated to project %s"", projectName)); <line8> return context; <line9> } catch (AuthorizationException e) { <line10> throw new InvalidCredentialsException(""accountid:"" + credentials.identity, e); <line11> } <line12> } <line13> } <line14> "	info	task5	
"public class A { <line0> @Test( <line1> enabled = true && !DEBUG, <line2> dataProvider = ""NanoSchedulerBasicTest"", <line3> timeOut = NANO_SCHEDULE_MAX_RUNTIME, <line4> dependsOnMethods = ""testSingleThreadedNanoScheduler"") <line5> public void testMultiThreadedNanoScheduler(final NanoSchedulerBasicTest test) <line6> throws InterruptedException { <line7> logger.UNKNOWN(""Running "" + test); <line8> if (test.nThreads >= 1) testNanoScheduler(test); <line9> } <line10> } <line11> "	warn	task5	
"public class A { <line0> public static String getRuntimePropertiesFileNameInTestMode() { <line1> String filename = null; <line2> if (isTestMode()) { <line3> log.UNKNOWN(""In functional testing mode. Ignoring the existing runtime properties file""); <line4> filename = getOpenMRSVersionInTestMode() + ""-test-runtime.properties""; <line5> } <line6> return filename; <line7> } <line8> } <line9> "	info	task5	
"public class A { <line0> public void writeEvaluationResultOfEachQuery(String resultEvalFilename) { <line1> int[] queryids = queryNumbers.toArray(); <line2> Arrays.sort(queryids); <line3> try { <line4> final PrintWriter out = new PrintWriter(Files.writeFileWriter(resultEvalFilename)); <line5> final StringBuilder sb = new StringBuilder(); <line6> for (int i = 0; i < this.queryNumbers.size(); i++) { <line7> sb.append( <line8> queryids[i] <line9> + "" "" <line10> + Rounding.toString(recipRank.get(queryids[i]), 4) <line11> + ApplicationSetup.EOL); <line12> } <line13> out.print(sb.toString()); <line14> out.close(); <line15> } catch (IOException fnfe) { <line16> logger.UNKNOWN(""Couldn't write evaluation file "" + resultEvalFilename, fnfe); <line17> } <line18> } <line19> } <line20> "	error	task5	
"public class A { <line0> @Override <line1> public DumpPropsToLogResponseType dumpPropsToLog( <line2> DumpPropsToLogRequestType dumpPropsToLogRequest) { <line3> DumpPropsToLogResponseType oOutput = null; <line4> try { <line5> oOutput = PropertyAccessHelper.dumpPropsToLog(dumpPropsToLogRequest); <line6> } catch (Exception e) { <line7> String sMessage = ""Failed to dump property file to log.  Exception: "" + e.getMessage(); <line8> LOG.UNKNOWN(sMessage, e); <line9> } <line10> return oOutput; <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> public void close() { <line1> for (FilterHolder filterHolder : _filtersRepository.values()) { <line2> try { <line3> filterHolder.getFilter().close(); <line4> } catch (RuntimeException ex) { <line5> if (logger.isErrorEnabled()) { <line6> logger.UNKNOWN(""Failed to close filter "" + filterHolder.getName(), ex); <line7> } <line8> } <line9> } <line10> } <line11> } <line12> "	error	task5	
"public class A { <line0> private JavaClass _getExtendedJavaClass(String absolutePath, String content) { <line1> Matcher matcher = _extendedClassPattern.matcher(content); <line2> if (!matcher.find()) { <line3> return null; <line4> } <line5> String extendedClassName = matcher.group(1); <line6> Pattern pattern = Pattern.compile(""\nimport (.*\\."" + extendedClassName + "");""); <line7> matcher = pattern.matcher(content); <line8> if (matcher.find()) { <line9> extendedClassName = matcher.group(1); <line10> if (!extendedClassName.startsWith(""com.liferay."")) { <line11> return null; <line12> } <line13> } <line14> if (!extendedClassName.contains(StringPool.PERIOD)) { <line15> extendedClassName = <line16> JavaSourceUtil.getPackageName(content) + StringPool.PERIOD + extendedClassName; <line17> } <line18> int pos = absolutePath.lastIndexOf(""/com/liferay/""); <line19> String extendedClassFileName = <line20> absolutePath.substring(0, pos + 1) <line21> + StringUtil.replace(extendedClassName, '.', '/') <line22> + "".java""; <line23> try { <line24> return JavaClassParser.parseJavaClass( <line25> extendedClassFileName, FileUtil.read(new File(extendedClassFileName))); <line26> } catch (Exception exception) { <line27> if (log.isDebugEnabled()) { <line28> log.UNKNOWN(exception, exception); <line29> } <line30> return null; <line31> } <line32> } <line33> } <line34> "	debug	task5	
"public class A { <line0> public static java.util.List<com.liferay.dynamic.data.mapping.model.DDMFormInstance> <line1> getFormInstances( <line2> HttpPrincipal httpPrincipal, long companyId, long groupId, int start, int end) { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DDMFormInstanceServiceUtil.class, <line7> ""getFormInstances"", <line8> _getFormInstancesParameterTypes6); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, companyId, groupId, start, end); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (java.util.List<com.liferay.dynamic.data.mapping.model.DDMFormInstance>) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> log.UNKNOWN(systemException, systemException); <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	error	task5	
"public class A { <line0> @Test <line1> public void testWithStringBundle() throws Exception { <line2> Bundle transactionBundle = createTransactionBundle(); <line3> String stringBundle = fhirContext.newJsonParser().encodeResourceToString(transactionBundle); <line4> final String result = requestBody(""direct://WITH_STRING_BUNDLE"", stringBundle); <line5> assertNotNull(result, ""withBundle result""); <line6> assertTrue(result.contains(""Bundle"")); <line7> LOG.UNKNOWN(""withBundle: "" + result); <line8> } <line9> } <line10> "	debug	task5	
"public class A { <line0> public ArrayList<URITemplate> getAllURITemplates(String context, String apiVersion) <line1> throws APISecurityException { <line2> try { <line3> return apiKeyValidationService.getAllURITemplates(context, apiVersion); <line4> } catch (APIManagementException e) { <line5> log.UNKNOWN(""Error while retrieving data from datastore"", e); <line6> throw new APISecurityException( <line7> APISecurityConstants.API_AUTH_GENERAL_ERROR, <line8> ""Error while retrieving data from datastore"", <line9> e); <line10> } <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> public Collection<File> getWalFilesFromArchive(WALPointer low, WALPointer high) <line1> throws IgniteCheckedException { <line2> segmentAware.awaitSegmentArchived(high.index() - 1); <line3> List<File> res = new ArrayList<>(); <line4> for (long i = low.index(); i < high.index(); i++) { <line5> String segmentName = fileName(i); <line6> File file = new File(walArchiveDir, segmentName); <line7> File fileZip = new File(walArchiveDir, segmentName + ZIP_SUFFIX); <line8> if (file.exists()) res.add(file); <line9> else if (fileZip.exists()) res.add(fileZip); <line10> else { <line11> if (log.isInfoEnabled()) <line12> log.UNKNOWN(""Segment not found: "" + file.getName() + ""/"" + fileZip.getName()); <line13> res.clear(); <line14> break; <line15> } <line16> } <line17> return res; <line18> } <line19> } <line20> "	info	task5	
"public class A { <line0> @Override <line1> public CompletableFuture<PlcReadResponse> read(PlcReadRequest readRequest) { <line2> return CompletableFuture.supplyAsync( <line3> () -> { <line4> Validate.notNull(device, ""No device is set in the mock connection!""); <line5> LOGGER.UNKNOWN(""Sending read request to MockDevice""); <line6> Map<String, ResponseItem<PlcValue>> response = <line7> readRequest.getFieldNames().stream() <line8> .collect( <line9> Collectors.toMap( <line10> Function.identity(), <line11> name -> <line12> device.read(((MockField) readRequest.getField(name)).getAddress()))); <line13> return new DefaultPlcReadResponse((DefaultPlcReadRequest) readRequest, response); <line14> }); <line15> } <line16> } <line17> "	debug	task5	
"public class A { <line0> @Override <line1> public void stsSecretKeyNotEncrypted() { <line2> logger.UNKNOWN( <line3> ""Secret key could not be encrypted because the endpoint's PKC has not been specified""); <line4> } <line5> } <line6> "	warn	task5	
"public class A { <line0> @Override <line1> protected Result check() { <line2> List<String> inactive = new ArrayList<>(); <line3> for (Bundle bundle : context.getBundles()) { <line4> if (bundle.getState() != Bundle.ACTIVE) { <line5> inactive.add(bundle.getSymbolicName()); <line6> } <line7> } <line8> if (inactive.isEmpty()) { <line9> return Result.healthy(""All bundles active""); <line10> } else { <line11> logger.UNKNOWN(""Inactive bundles: {}"", inactive); <line12> return Result.unhealthy(""Inactive bundles: "" + inactive); <line13> } <line14> } <line15> } <line16> "	warn	task5	
"public class A { <line0> public void logLine() { <line1> if (buf.size() > 0) { <line2> try { <line3> if (isLineLengthExceeded()) { <line4> buf.write(WRAP); <line5> } <line6> String line = buf.toString(StandardCharsets.UTF_8.name()); <line7> log.UNKNOWN(linePrefix + line); <line8> buf.reset(); <line9> } catch (IOException e) { <line10> throw new IllegalStateException(""Can not log output stream"", e); <line11> } <line12> } <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> private void checkUnregisterServiceParameters( <line1> final String serviceDefinition, <line2> final String providerName, <line3> final String providerAddress, <line4> final int providerPort) { <line5> logger.UNKNOWN(""checkUnregisterServiceParameters started...""); <line6> final String origin = <line7> CommonConstants.SERVICE_REGISTRY_URI + CommonConstants.OP_SERVICE_REGISTRY_UNREGISTER_URI; <line8> if (Utilities.isEmpty(serviceDefinition)) { <line9> throw new BadPayloadException( <line10> ""Service definition is blank"", HttpStatus.SC_BAD_REQUEST, origin); <line11> } <line12> if (Utilities.isEmpty(providerName)) { <line13> throw new BadPayloadException( <line14> ""Name of the provider system is blank"", HttpStatus.SC_BAD_REQUEST, origin); <line15> } <line16> if (Utilities.isEmpty(providerAddress)) { <line17> throw new BadPayloadException( <line18> ""Address of the provider system is blank"", HttpStatus.SC_BAD_REQUEST, origin); <line19> } <line20> if (providerPort < CommonConstants.SYSTEM_PORT_RANGE_MIN <line21> || providerPort > CommonConstants.SYSTEM_PORT_RANGE_MAX) { <line22> throw new BadPayloadException( <line23> ""Port must be between "" <line24> + CommonConstants.SYSTEM_PORT_RANGE_MIN <line25> + "" and "" <line26> + CommonConstants.SYSTEM_PORT_RANGE_MAX <line27> + ""."", <line28> HttpStatus.SC_BAD_REQUEST, <line29> origin); <line30> } <line31> } <line32> } <line33> "	debug	task5	
"public class A { <line0> static void assertAtLeastNCommits(int minExpected, String tablePath, FileSystem fs) { <line1> HoodieTableMetaClient meta = <line2> HoodieTableMetaClient.builder().setConf(fs.getConf()).setBasePath(tablePath).build(); <line3> HoodieTimeline timeline = meta.getActiveTimeline().filterCompletedInstants(); <line4> LOG.UNKNOWN( <line5> ""Timeline Instants="" + meta.getActiveTimeline().getInstants().collect(Collectors.toList())); <line6> int numDeltaCommits = (int) timeline.getInstants().count(); <line7> assertTrue(minExpected <= numDeltaCommits, ""Got="" + numDeltaCommits + "", exp >="" + minExpected); <line8> } <line9> } <line10> "	info	task5	
"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (!(command instanceof RefreshType)) { <line3> logger.UNKNOWN(""command for {}: {}"", channelUID.getIdWithoutGroup(), command.toString()); <line4> Channel channel = getSpecificChannel(channelUID.getIdWithoutGroup()); <line5> if (channel != null) { <line6> ChannelTypeUID typeUID = channel.getChannelTypeUID(); <line7> if (typeUID != null <line8> && typeUID.getId() != null <line9> && typeUID.getId().startsWith(NibeUplinkBindingConstants.RW_CHANNEL_PREFIX)) { <line10> webInterface.enqueueCommand(new UpdateSetting(this, channel, command)); <line11> } <line12> } <line13> } <line14> } <line15> } <line16> "	debug	task5	
"public class A { <line0> private List<MailAddress> getSenderAsList(Mail originalMail) { <line1> MaybeSender reversePath = originalMail.getMaybeSender(); <line2> if (getInitParameters().isDebug()) { <line3> LOGGER.UNKNOWN( <line4> ""Processing a bounce request for a message with a reverse path.  The bounce will be sent"" <line5> + "" to {}"", <line6> reversePath.asString()); <line7> } <line8> return reversePath.asList(); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> private void handleCommit(RequestEvent event) throws Exception { <line1> long startTimestamp = event.getStartTimestamp(); <line2> Iterable<Long> writeSet = event.writeSet(); <line3> Collection<Long> tableIdSet = event.getTableIdSet(); <line4> boolean isCommitRetry = event.isCommitRetry(); <line5> Channel c = event.getChannel(); <line6> boolean nonEmptyWriteSet = writeSet.iterator().hasNext(); <line7> if (startTimestamp > lowWatermark <line8> && !hasConflictsWithFences(startTimestamp, tableIdSet) <line9> && !hasConflictsWithCommittedTransactions(startTimestamp, writeSet)) { <line10> long commitTimestamp = timestampOracle.next(); <line11> Optional<Long> forwardNewWaterMark = Optional.absent(); <line12> if (nonEmptyWriteSet) { <line13> long newLowWatermark = lowWatermark; <line14> for (long r : writeSet) { <line15> long removed = hashmap.putLatestWriteForCell(r, commitTimestamp); <line16> newLowWatermark = Math.max(removed, newLowWatermark); <line17> } <line18> if (newLowWatermark != lowWatermark) { <line19> LOG.UNKNOWN(""Setting new low Watermark to {}"", newLowWatermark); <line20> lowWatermark = newLowWatermark; <line21> forwardNewWaterMark = Optional.of(lowWatermark); <line22> } <line23> } <line24> event.getMonCtx().timerStop(""request.processor.commit.latency""); <line25> forwardCommit(startTimestamp, commitTimestamp, c, event.getMonCtx(), forwardNewWaterMark); <line26> } else { <line27> event.getMonCtx().timerStop(""request.processor.commit.latency""); <line28> if (isCommitRetry) { <line29> forwardCommitRetry(startTimestamp, c, event.getMonCtx()); <line30> } else { <line31> forwardAbort(startTimestamp, c, event.getMonCtx()); <line32> } <line33> } <line34> } <line35> } <line36> "	trace	task5	
"public class A { <line0> private boolean handleNodeSubscription(Element elm, JID actorJID, JID subscribingJid) <line1> throws NodeStoreException, InterruptedException { <line2> boolean isLocalNode = false; <line3> try { <line4> isLocalNode = Configuration.getInstance().isLocalNode(node); <line5> } catch (IllegalArgumentException e) { <line6> LOGGER.UNKNOWN(e); <line7> createExtendedErrorReply( <line8> PacketError.Type.modify, <line9> PacketError.Condition.bad_request, <line10> INVALID_NODE_FORMAT, <line11> Buddycloud.NS_ERROR); <line12> outQueue.put(response); <line13> return false; <line14> } <line15> if (!isLocalNode && !node.equals(""/firehose"")) { <line16> makeRemoteRequest(); <line17> return false; <line18> } <line19> JID jid = new JID(request.getChildElement().element(""subscribe"").attributeValue(""jid"")); <line20> if (!subscribingJid.toBareJID().equals(jid.toBareJID())) { <line21> IQ reply = IQ.createResultIQ(request); <line22> reply.setType(Type.error); <line23> Element badRequest = <line24> new DOMElement(""bad-request"", new org.dom4j.Namespace("""", JabberPubsub.NS_XMPP_STANZAS)); <line25> Element nodeIdRequired = <line26> new DOMElement(INVALID_JID, new org.dom4j.Namespace("""", JabberPubsub.NS_PUBSUB_ERROR)); <line27> Element error = new DOMElement(""error""); <line28> error.addAttribute(""type"", PacketError.Type.modify.toXMPP()); <line29> error.add(badRequest); <line30> error.add(nodeIdRequired); <line31> reply.setChildElement(error); <line32> outQueue.put(reply); <line33> return false; <line34> } <line35> if (!channelManager.nodeExists(node)) { <line36> IQ reply = IQ.createResultIQ(request); <line37> reply.setType(Type.error); <line38> PacketError pe = <line39> new PacketError(PacketError.Condition.item_not_found, PacketError.Type.cancel); <line40> reply.setError(pe); <line41> outQueue.put(reply); <line42> return false; <line43> } <line44> return true; <line45> } <line46> } <line47> "	debug	task5	
"public class A { <line0> @Test <line1> public void test02GetDataArraySelect() throws ServiceFailureException { <line2> LOGGER.UNKNOWN(""  test02GetDataArraySelect""); <line3> String urlString = <line4> ServiceUrlHelper.buildURLString( <line5> serverSettings.getServiceUrl(version), <line6> EntityType.OBSERVATION, <line7> null, <line8> null, <line9> ""?$count=true&$top=4&$resultFormat=dataArray&$select=result,phenomenonTime&$orderby=phenomenonTime%20desc""); <line10> HttpResponse responseMap = HTTPMethods.doGet(urlString); <line11> String message = ""Error getting Observations using Data Array: Code "" + responseMap.response; <line12> Assert.assertEquals(message, 200, responseMap.code); <line13> validateGetDataArrayResponse( <line14> responseMap.response, urlString, new HashSet<>(Arrays.asList(""result"", ""phenomenonTime""))); <line15> } <line16> } <line17> "	info	task5	
"public class A { <line0> public String existingBuildList() { <line1> existingBuildList.clear(); <line2> log.UNKNOWN( <line3> ""existingBuildList called for path="" <line4> + fileService.getBucketName() <line5> + ""/"" <line6> + selectedBundleName <line7> + ""/"" <line8> + fileService.getBuildPath()); <line9> List<String> existingDirectories = <line10> fileService.listBundleBuilds( <line11> selectedBundleName + ""/"" + fileService.getBuildPath() + ""/"", MAX_RESULTS); <line12> if (existingDirectories == null) { <line13> return null; <line14> } <line15> int i = 1; <line16> for (String directory : existingDirectories) { <line17> String[] buildSplit = directory.split(""/""); <line18> existingBuildList.put(buildSplit[buildSplit.length - 1], """" + i++); <line19> } <line20> return ""existingBuildList""; <line21> } <line22> } <line23> "	info	task5	
"public class A { <line0> @Override <line1> public Object executeAction(DataFetchingEnvironment env) { <line2> User currentUser = getUser(env); <line3> String dataSetName = env.getArgument(""dataSetName""); <line4> try { <line5> return new DataSetWithDatabase( <line6> dataSetRepository.createDataSet(currentUser, dataSetName), <line7> env.<ContextData>getContext().getUserPermissionCheck()); <line8> } catch (DataStoreCreationException e) { <line9> LOG.UNKNOWN(""Data set creation exception"", e); <line10> throw new RuntimeException(""Data set could not be created""); <line11> } catch (IllegalDataSetNameException e) { <line12> throw new RuntimeException(""Data set id is not supported: "" + e.getMessage()); <line13> } catch (DataSetCreationException e) { <line14> throw new RuntimeException(e.getMessage()); <line15> } <line16> } <line17> } <line18> "	error	task5	
"public class A { <line0> @Override <line1> public void removeIsotope(IIsotope isotope) { <line2> logger.UNKNOWN(""Removing this isotope: "", isotope); <line3> super.removeIsotope(isotope); <line4> } <line5> } <line6> "	debug	task5	
"public class A { <line0> @RetryableTest <line1> public void verifyLog() throws Exception { <line2> LogsQuery logsQuery = <line3> new LogsQuery() <line4> .serviceId(""WW91cl9BcHBsaWNhdGlvbk5hbWU=.1"") <line5> .start(startTime) <line6> .end(Times.now()); <line7> if (graphql.supportQueryLogsByKeywords()) { <line8> logsQuery.keywordsOfContent(""now""); <line9> } <line10> final List<Log> logs = graphql.logs(logsQuery); <line11> LOGGER.UNKNOWN(""logs: {}"", logs); <line12> load(""expected/log/logs.yml"").as(LogsMatcher.class).verifyLoosely(logs); <line13> } <line14> } <line15> "	info	task5	
"public class A { <line0> @Override <line1> public <T> String[] getConstructorParametersNames(Constructor<T> ctor) { <line2> try { <line3> return ConstructorPropertyNameExtractor.getParameterNames(ctor); <line4> } catch (IOException e) { <line5> if (logger.isWarnEnabled()) <line6> logger.UNKNOWN( <line7> ""Failed to get constructor parameters names using ASM, falling back to standard"" <line8> + "" reflection. class: "" <line9> + ctor.getDeclaringClass().getName(), <line10> e); <line11> } <line12> return _fallbackFactory.getConstructorParametersNames(ctor); <line13> } <line14> } <line15> "	warn	task5	
"public class A { <line0> @Override <line1> public void process( <line2> IContinuation continuation, <line3> UserDataRequest udr, <line4> Document doc, <line5> ActiveSyncRequest request, <line6> Responder responder) { <line7> try { <line8> Document documentResponse = protocol.encodeResponse(udr.getUser()); <line9> responder.sendWBXMLResponse(""Settings"", documentResponse); <line10> } catch (Exception e) { <line11> logger.UNKNOWN(""Error creating settings response""); <line12> } <line13> } <line14> } <line15> "	error	task5	
"public class A { <line0> private void addEntityCheckCache(SessionFactoryImplementor sessionFactory) throws Exception { <line1> Item item = new Item(""chris"", ""Chris's Item""); <line2> withTxSession(s -> s.persist(item)); <line3> withTxSession( <line4> s -> { <line5> Item found = s.load(Item.class, item.getId()); <line6> Statistics stats = sessionFactory.getStatistics(); <line7> log.UNKNOWN(stats.toString()); <line8> assertEquals(item.getDescription(), found.getDescription()); <line9> assertEquals(0, stats.getSecondLevelCacheMissCount()); <line10> assertEquals(1, stats.getSecondLevelCacheHitCount()); <line11> s.delete(found); <line12> }); <line13> } <line14> } <line15> "	info	task5	
"public class A { <line0> synchronized boolean addHead(FlumeEventPointer e) { <line1> if (backingStore.getSize() == backingStore.getCapacity()) { <line2> LOG.UNKNOWN( <line3> ""Could not reinsert to queue, events which were taken but "" <line4> + ""not committed. Please report this issue.""); <line5> return false; <line6> } <line7> long value = e.toLong(); <line8> Preconditions.checkArgument(value != EMPTY); <line9> backingStore.incrementFileID(e.getFileID()); <line10> add(0, value); <line11> return true; <line12> } <line13> } <line14> "	error	task5	
"public class A { <line0> public void acknowledge(final FlowFileRecord flowFile) { <line1> logger.UNKNOWN(""{} Acknowledging {}"", this, flowFile); <line2> incrementUnacknowledgedQueueSize(-1, -flowFile.getSize()); <line3> } <line4> } <line5> "	trace	task5	
"public class A { <line0> private TrackerResponse sendEvent( <line1> TrackerRequestType eventType, TrackerRequestBuilder requestBuilder) { <line2> String requestUri; <line3> try { <line4> String query = buildQuery(eventType, requestBuilder); <line5> String baseUrl = baseUri.toASCIIString(); <line6> if (baseUrl.endsWith(""/"")) { <line7> baseUrl = baseUrl.substring(0, baseUrl.length() - 1); <line8> } <line9> URL requestUrl = new URL(baseUrl + (baseUri.getRawQuery() == null ? ""?"" : ""&"") + query); <line10> requestUri = requestUrl.toURI().toString(); <line11> } catch (Exception e) { <line12> throw new BtException(""Failed to build tracker request"", e); <line13> } <line14> HttpGet request = new HttpGet(requestUri); <line15> try { <line16> if (LOGGER.isDebugEnabled()) { <line17> LOGGER.UNKNOWN( <line18> ""Executing tracker HTTP request of type "" <line19> + eventType.name() <line20> + ""; request URL: "" <line21> + requestUri); <line22> } <line23> return httpClient.execute(request, httpResponseHandler); <line24> } catch (IOException e) { <line25> return TrackerResponse.exceptional(e); <line26> } <line27> } <line28> } <line29> "	debug	task5	
"public class A { <line0> private void saveHnrLinkedIds(Facility facility, Provider provider, Integer demographicId) { <line1> try { <line2> List<ClientLink> currentLinks = <line3> clientLinkDao.findByFacilityIdClientIdType( <line4> facility.getId(), demographicId, true, ClientLink.Type.HNR); <line5> boolean isCheckedClientExistingLink = false; <line6> for (ClientLink existingLink : currentLinks) { <line7> if (newHnrLinkedId == null || !newHnrLinkedId.equals(existingLink.getRemoteLinkId())) { <line8> existingLink.setUnlinkDate(new Date()); <line9> existingLink.setUnlinkProviderNo(provider.getProviderNo()); <line10> clientLinkDao.merge(existingLink); <line11> } else { <line12> isCheckedClientExistingLink = true; <line13> } <line14> } <line15> if (newHnrLinkedId != null && !isCheckedClientExistingLink) { <line16> ClientLink newLink = new ClientLink(); <line17> newLink.setFacilityId(facility.getId()); <line18> newLink.setClientId(demographicId); <line19> newLink.setLinkDate(new Date()); <line20> newLink.setLinkProviderNo(provider.getProviderNo()); <line21> newLink.setLinkType(ClientLink.Type.HNR); <line22> newLink.setRemoteLinkId(newHnrLinkedId); <line23> clientLinkDao.persist(newLink); <line24> } <line25> } catch (Exception e) { <line26> logger.UNKNOWN(""Unexpected Error."", e); <line27> } <line28> } <line29> } <line30> "	error	task5	
"public class A { <line0> @Test <line1> @Ignore <line2> public void testJMSEmbeddedConnector() throws ConnectorDataTransmissionException { <line3> final Thread messageGenerator = <line4> new Thread( <line5> new JMSMessageGenerator( <line6> ConfigurationParameters.JMS_EMBEDDED_URI, <line7> ConfigurationParameters.JMS_EMBEDDED_FACTORY_LOOKUP_NAME), <line8> ""Generator""); <line9> final Configuration configuration = ConfigurationFactory.createSingletonConfiguration(); <line10> configuration.setProperty( <line11> JMSEmbeddedConnector.PORT, String.valueOf(ConfigurationParameters.JMS_EMBEDDED_PORT)); <line12> configuration.setProperty( <line13> JMSClientConnector.USERNAME, String.valueOf(ConfigurationParameters.JMS_USERNAME)); <line14> configuration.setProperty( <line15> JMSClientConnector.PASSWORD, String.valueOf(ConfigurationParameters.JMS_PASSWORD)); <line16> configuration.setProperty(JMSClientConnector.URI, ConfigurationParameters.JMS_EMBEDDED_URI); <line17> configuration.setProperty( <line18> JMSClientConnector.FACTORY_LOOKUP_NAME, <line19> ConfigurationParameters.JMS_EMBEDDED_FACTORY_LOOKUP_NAME); <line20> this.setConnector(new JMSEmbeddedConnector(configuration, this.createLookupEntityMap())); <line21> this.initialize(); <line22> messageGenerator.start(); <line23> this.deserialize(ConfigurationParameters.SEND_NUMBER_OF_RECORDS, true); <line24> this.close(ConfigurationParameters.SEND_NUMBER_OF_RECORDS); <line25> try { <line26> messageGenerator.join(2000); <line27> } catch (final InterruptedException e) { <line28> LOGGER.UNKNOWN(""Message generator was illegaly interrupted. "", e); <line29> } <line30> } <line31> } <line32> "	error	task5	
"public class A { <line0> public boolean move(SafFile<T> destination) { <line1> logger.UNKNOWN(""[{}] move({})"", name, destination.getAbsolutePath()); <line2> return false; <line3> } <line4> } <line5> "	trace	task5	
"public class A { <line0> @POST <line1> @Path(""generate"") <line2> @Produces(MediaType.TEXT_XML) <line3> @RestQuery( <line4> name = ""generate"", <line5> description = ""Generates a cover image based on the given metadata"", <line6> restParameters = { <line7> @RestParameter( <line8> description = ""Metadata XML"", <line9> isRequired = false, <line10> name = ""xml"", <line11> type = Type.TEXT), <line12> @RestParameter( <line13> description = ""XSLT stylesheet"", <line14> isRequired = true, <line15> name = ""xsl"", <line16> type = Type.TEXT), <line17> @RestParameter( <line18> description = ""Width of the cover image"", <line19> isRequired = true, <line20> name = ""width"", <line21> type = Type.INTEGER, <line22> defaultValue = ""1600""), <line23> @RestParameter( <line24> description = ""Height of the cover image"", <line25> isRequired = true, <line26> name = ""height"", <line27> type = Type.INTEGER, <line28> defaultValue = ""900""), <line29> @RestParameter( <line30> description = ""URI of poster image"", <line31> isRequired = false, <line32> name = ""posterimage"", <line33> type = Type.STRING), <line34> @RestParameter( <line35> description = ""Flavor of target cover image"", <line36> isRequired = true, <line37> name = ""targetflavor"", <line38> type = Type.STRING, <line39> defaultValue = ""image/cover"") <line40> }, <line41> responses = { <line42> @RestResponse( <line43> description = <line44> ""Results in an xml document containing the job for the cover image generation task"", <line45> responseCode = HttpServletResponse.SC_OK), <line46> @RestResponse( <line47> description = ""If required parameters aren't set or not valid"", <line48> responseCode = HttpServletResponse.SC_BAD_REQUEST) <line49> }, <line50> returnDescription = """") <line51> public Response generateCoverImage( <line52> @FormParam(""xml"") String xml, <line53> @FormParam(""xsl"") String xsl, <line54> @FormParam(""width"") String width, <line55> @FormParam(""height"") String height, <line56> @FormParam(""posterimage"") String posterFlavor, <line57> @FormParam(""targetflavor"") String targetFlavor) { <line58> try { <line59> Job job = <line60> coverImageService.generateCoverImage(xml, xsl, width, height, posterFlavor, targetFlavor); <line61> return Response.ok().entity(new JaxbJob(job)).build(); <line62> } catch (CoverImageException e) { <line63> logger.UNKNOWN(""Error while creating cover image job via REST endpoint: {}"", e.getMessage()); <line64> return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build(); <line65> } <line66> } <line67> } <line68> "	warn	task5	
"public class A { <line0> public void killQuery( <line1> String queryName, <line2> String state, <line3> String user, <line4> String sessionHandleString, <line5> String fromDate, <line6> String toDate) <line7> throws LensException { <line8> MapBuilder query = new MapBuilder(""sessionid"", sessionHandleString); <line9> if (queryName != null) { <line10> query.put(""queryName"", queryName); <line11> } <line12> if (state != null) { <line13> query.put(""state"", state); <line14> } <line15> if (user != null) { <line16> query.put(""user"", user); <line17> } <line18> if (fromDate != null) { <line19> query.put(""fromDate"", fromDate); <line20> } <line21> if (toDate != null) { <line22> query.put(""toDate"", toDate); <line23> } <line24> Response response = this.exec(""delete"", QueryURL.QUERY_URL, servLens, null, query); <line25> log.UNKNOWN(""Response : {}"", response); <line26> AssertUtil.assertSucceededResponse(response); <line27> } <line28> } <line29> "	info	task5	
"public class A { <line0> @GET <line1> @Timed <line2> @Path(""shards"") <line3> @Compress <line4> @Produces(APPLICATION_JSON_WITH_CHARSET) <line5> public String shards( <line6> @Context GraphManager manager, <line7> @PathParam(""graph"") String graph, <line8> @QueryParam(""split_size"") long splitSize) { <line9> LOG.UNKNOWN(""Graph [{}] get vertex shards with split size '{}'"", graph, splitSize); <line10> HugeGraph g = graph(manager, graph); <line11> List<Shard> shards = g.metadata(HugeType.EDGE_OUT, ""splits"", splitSize); <line12> return manager.serializer(g).writeList(""shards"", shards); <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> protected final void doAsyncQueryData( <line1> CompletableFuture<Collection<Row>> future, <line2> SQLClient rdbSqlClient, <line3> AtomicLong failCounter, <line4> AtomicBoolean finishFlag, <line5> CountDownLatch latch, <line6> Object... keys) { <line7> rdbSqlClient.getConnection( <line8> conn -> { <line9> try { <line10> if (conn.failed()) { <line11> connectionStatus.set(false); <line12> if (failCounter.getAndIncrement() % 1000 == 0) { <line13> LOG.UNKNOWN(""getConnection error"", conn.cause()); <line14> } <line15> if (failCounter.get() >= sideTableInfo.getConnectRetryMaxNum(100)) { <line16> future.completeExceptionally(conn.cause()); <line17> finishFlag.set(true); <line18> } <line19> return; <line20> } <line21> connectionStatus.set(true); <line22> handleQuery(conn.result(), future, keys); <line23> finishFlag.set(true); <line24> } catch (Exception e) { <line25> dealFillDataError(future, e); <line26> } finally { <line27> latch.countDown(); <line28> } <line29> }); <line30> } <line31> } <line32> "	error	task5	
"public class A { <line0> public void handlePaxLoggingEvent(PaxLoggingEvent event) { <line1> synchronized (this.subscriptions) { <line2> if (this.subscriptions.isEmpty()) { <line3> return; <line4> } <line5> EdgeRpcNotification notification = <line6> new EdgeRpcNotification( <line7> WebsocketApi.EDGE_ID, SystemLogNotification.fromPaxLoggingEvent(event)); <line8> for (Iterator<String> iter = this.subscriptions.iterator(); iter.hasNext(); ) { <line9> String token = iter.next(); <line10> try { <line11> this.parent.getWsDataForTokenOrError(token).send(notification); <line12> } catch (OpenemsNamedException e) { <line13> iter.remove(); <line14> this.log.UNKNOWN(""Unable to handle PaxLoggingEvent: "" + e.getMessage()); <line15> } <line16> } <line17> } <line18> } <line19> } <line20> "	warn	task5	
"public class A { <line0> private void setGUISizeTooltipContainer() { <line1> try { <line2> int height = GUISizeHelper.enlargedImageHeight; <line3> int width = (int) ((float) height * (float) 0.64); <line4> JPanel cardPreviewContainer = (JPanel) UI.getComponent(MageComponents.CARD_PREVIEW_CONTAINER); <line5> cardPreviewContainer.setBounds(0, 0, width + 80, height + 30); <line6> BigCard bigCard = (BigCard) UI.getComponent(MageComponents.CARD_PREVIEW_PANE); <line7> bigCard.setSize(width, height); <line8> JPanel cardPreviewContainerRotated = <line9> (JPanel) UI.getComponent(MageComponents.CARD_PREVIEW_CONTAINER_ROTATED); <line10> cardPreviewContainerRotated.setBounds(0, 0, height + 80, width + 100 + 30); <line11> BigCard bigCardRotated = (BigCard) UI.getComponent(MageComponents.CARD_PREVIEW_PANE_ROTATED); <line12> bigCardRotated.setSize(height, width + 30); <line13> } catch (Exception e) { <line14> LOGGER.UNKNOWN(""Error while changing tooltip container size."", e); <line15> } <line16> } <line17> } <line18> "	warn	task5	
public class A { <line0> protected String uploadJar(final FormData formData) throws IOException { <line1> GAV gav = formData.getGav(); <line2> InputStream jarStream = null; <line3> try { <line4> jarStream = formData.getFile().getInputStream(); <line5> if (gav == null) { <line6> if (!jarStream.markSupported()) { <line7> jarStream = new BufferedInputStream(jarStream); <line8> } <line9> jarStream.mark(jarStream.available()); <line10> PomModel pomModel = PomModelResolver.resolveFromJar(jarStream); <line11> if (pomModel != null) { <line12> String groupId = pomModel.getReleaseId().getGroupId(); <line13> String artifactId = pomModel.getReleaseId().getArtifactId(); <line14> String version = pomModel.getReleaseId().getVersion(); <line15> if (isNullOrEmpty(groupId) || isNullOrEmpty(artifactId) || isNullOrEmpty(version)) { <line16> return UPLOAD_MISSING_POM; <line17> } else { <line18> gav = new GAV(groupId, artifactId, version); <line19> } <line20> } else { <line21> return UPLOAD_MISSING_POM; <line22> } <line23> jarStream.reset(); <line24> formData.setGav(gav); <line25> } <line26> deploy(gav, jarStream); <line27> return UPLOAD_OK; <line28> } catch (IOException ioe) { <line29> log.UNKNOWN(ioe.getMessage(), ioe); <line30> throw ExceptionUtilities.handleException(ioe); <line31> } finally { <line32> if (jarStream != null) { <line33> jarStream.close(); <line34> } <line35> } <line36> } <line37> } <line38> 	error	task5	
"public class A { <line0> @Override <line1> public void rip() throws IOException { <line2> logger.UNKNOWN(""    Retrieving "" + this.url.toExternalForm()); <line3> Document doc = Http.url(this.url).get(); <line4> Elements videos = doc.select(""meta[name=twitter:player:stream]""); <line5> if (videos.size() == 0) { <line6> throw new IOException(""Could not find twitter:player:stream at "" + url); <line7> } <line8> String vidUrl = videos.first().attr(""content""); <line9> vidUrl = vidUrl.replaceAll(""&amp;"", ""&""); <line10> addURLToDownload(new URL(vidUrl), HOST + ""_"" + getGID(this.url)); <line11> waitForThreads(); <line12> } <line13> } <line14> "	info	task5	
"public class A { <line0> public static DataSource createDefaultDataSource() { <line1> String driverClass = ""org.h2.Driver""; <line2> String jdbcUrl = <line3> ""jdbc:h2:mem:taskana;IGNORECASE=TRUE;LOCK_MODE=0;"" <line4> + ""INIT=CREATE SCHEMA IF NOT EXISTS TASKANA\\;"" <line5> + ""SET COLLATION DEFAULT_de_DE""; <line6> String username = ""sa""; <line7> String password = ""sa""; <line8> LOGGER.UNKNOWN( <line9> ""No datasource is provided. An in-memory db is used: "" + ""'{}', '{}', '{}', '{}'"", <line10> driverClass, <line11> jdbcUrl, <line12> username, <line13> password); <line14> return createDatasource(driverClass, jdbcUrl, username, password); <line15> } <line16> } <line17> "	info	task5	
"public class A { <line0> public static void assertEquals(String val, String val2, String message) <line1> throws AssertFailException { <line2> if (!val.equals(val2)) throw new AssertFailException(""FAIL: "" + message); <line3> else log.UNKNOWN(""PASS: "" + message); <line4> } <line5> } <line6> "	debug	task5	
"public class A { <line0> @Override <line1> public void disconnected(SchedulerDriver schedulerDriver) { <line2> log.UNKNOWN(""Scheduler disconnected.""); <line3> } <line4> } <line5> "	info	task5	
"public class A { <line0> @Test <line1> public void testToString() { <line2> MatchingResources mr = new MatchingResources(""classpath*:org/wicketstuff/config/*.class""); <line3> assertTrue(mr.getAllMatches().length > 0); <line4> logger.UNKNOWN(""URLs:\n"" + mr); <line5> } <line6> } <line7> "	info	task5	
public class A { <line0> @Override <line1> public DispatchLog remove(Serializable primaryKey) throws NoSuchLogException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> DispatchLog dispatchLog = (DispatchLog) session.get(DispatchLogImpl.class, primaryKey); <line6> if (dispatchLog == null) { <line7> if (log.isDebugEnabled()) { <line8> log.UNKNOWN(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line9> } <line10> throw new NoSuchLogException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line11> } <line12> return remove(dispatchLog); <line13> } catch (NoSuchLogException noSuchEntityException) { <line14> throw noSuchEntityException; <line15> } catch (Exception exception) { <line16> throw processException(exception); <line17> } finally { <line18> closeSession(session); <line19> } <line20> } <line21> } <line22> 	debug	task5	
"public class A { <line0> private IsotopicDistributionSpectrum calculateIsotopicDistribution( <line1> AASequenceImpl validatedPeptideSequence, Integer peptideCharge, int labedDifference) { <line2> double mzValue = validatedPeptideSequence.getMz(peptideCharge); <line3> IsotopicDistribution lIso = validatedPeptideSequence.getIsotopicDistribution(); <line4> if (labedDifference > 0) { <line5> lIso.setLabelDifference(labedDifference); <line6> } <line7> HashMap lPeaks = new HashMap(); <line8> try { <line9> for (int i = 0; i < 15; i++) { <line10> int numberOfSidePeaks = 10; <line11> if (currentGraphicsPanelType.equals(GraphicsPanelType.isotopicDistributionProfile)) { <line12> for (int j = 0; j < numberOfSidePeaks; j++) { <line13> lPeaks.put( <line14> mzValue <line15> + (i * (new MassCalc().calculateMass(""H"") / (double) peptideCharge)) <line16> - 0.01 * (numberOfSidePeaks - j), <line17> lIso.getPercMax()[i] * j * 10); <line18> } <line19> } <line20> lPeaks.put( <line21> mzValue + (i * (new MassCalc().calculateMass(""H"") / (double) peptideCharge)), <line22> lIso.getPercMax()[i] * 100); <line23> if (currentGraphicsPanelType.equals(GraphicsPanelType.isotopicDistributionProfile)) { <line24> for (int j = 1; j <= numberOfSidePeaks; j++) { <line25> lPeaks.put( <line26> mzValue <line27> + (i * (new MassCalc().calculateMass(""H"") / (double) peptideCharge)) <line28> + 0.01 * j, <line29> lIso.getPercMax()[i] * (100 - j * 10)); <line30> } <line31> } <line32> } <line33> } catch (UnknownElementMassException ume) { <line34> logger.UNKNOWN(ume.getMessage(), ume); <line35> } <line36> IsotopicDistributionSpectrum lSpecFile = new IsotopicDistributionSpectrum(); <line37> lSpecFile.setCharge(peptideCharge); <line38> lSpecFile.setPrecursorMZ(mzValue); <line39> lSpecFile.setPeaks(lPeaks); <line40> return lSpecFile; <line41> } <line42> } <line43> "	error	task5	
"public class A { <line0> protected final void startUpdateTopics( <line1> DatumGenerator<String, String> updateGenerator, int howManyUpdate) <line2> throws InterruptedException { <line3> log.UNKNOWN(""Producing updates""); <line4> new ProduceData(updateGenerator, getKafkaBrokerPort(), UPDATE_TOPIC, howManyUpdate, 0).start(); <line5> } <line6> } <line7> "	info	task5	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Object session = <line4> TEST_SESSION_ACCESS.mockSession( <line5> jtaPlatform, TIME_SERVICE, localEnvironment.getRegionFactory()); <line6> withTx( <line7> localEnvironment, <line8> session, <line9> () -> { <line10> assertEquals( <line11> ""Correct initial value"", <line12> VALUE1, <line13> testLocalAccessStrategy.get(session, KEY, SESSION_ACCESS.getTimestamp(session))); <line14> doUpdate(testLocalAccessStrategy, session, KEY, VALUE2); <line15> pferLatch.countDown(); <line16> commitLatch.await(); <line17> return null; <line18> }); <line19> } catch (Exception e) { <line20> log.UNKNOWN(""node1 caught exception"", e); <line21> node1Exception = e; <line22> } catch (AssertionError e) { <line23> node1Failure = e; <line24> } finally { <line25> completionLatch.countDown(); <line26> } <line27> } <line28> } <line29> "	error	task5	
"public class A { <line0> public ExplorePage expectGroupListContains(final String expected) { <line1> String msg = ""Group search list contains "" + expected; <line2> log.UNKNOWN(""Expect {}"", msg); <line3> waitForAMoment() <line4> .withMessage(""Waiting for search contains"") <line5> .until(webDriver -> getGroupSearchResults().contains(expected)); <line6> assertThat(getGroupSearchResults()).as(msg).contains(expected); <line7> return new ExplorePage(getDriver()); <line8> } <line9> } <line10> "	info	task5	
"public class A { <line0> @Override <line1> public void updateEntitlement(String name, Entitlement entitlement) { <line2> Query query = em.createQuery(""select e from Entitlement e where e.name=:name""); <line3> query.setParameter(""name"", name); <line4> EntitlementEntity entitlementEntity = (EntitlementEntity) query.getSingleResult(); <line5> domain2entity(entitlement, entitlementEntity); <line6> LOG.UNKNOWN(""Entitlement '{}' added"", entitlement.getName()); <line7> em.persist(entitlementEntity); <line8> } <line9> } <line10> "	debug	task5	
public class A { <line0> public static void deleteCommerceTierPriceEntry(long commerceTierPriceEntryId) <line1> throws RemoteException { <line2> try { <line3> CommerceTierPriceEntryServiceUtil.deleteCommerceTierPriceEntry(commerceTierPriceEntryId); <line4> } catch (Exception exception) { <line5> log.UNKNOWN(exception, exception); <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	error	task5	
"public class A { <line0> @Override <line1> public String getIntegratedCirquitCardId() throws KuraException { <line2> synchronized (this.atLock) { <line3> if (this.iccid == null && isSimCardReady()) { <line4> logger.UNKNOWN(""sendCommand getICCID :: {}"", HspaModemAtCommands.getICCID.getCommand()); <line5> byte[] reply; <line6> CommConnection commAtConnection = openSerialPort(getAtPort()); <line7> if (!isAtReachable(commAtConnection)) { <line8> closeSerialPort(commAtConnection); <line9> throw new KuraException(KuraErrorCode.NOT_CONNECTED, MODEM_NOT_AVAILABLE_FOR_AT_CMDS_MSG); <line10> } <line11> try { <line12> reply = <line13> commAtConnection.sendCommand( <line14> HspaModemAtCommands.getICCID.getCommand().getBytes(), 1000, 100); <line15> } catch (IOException e) { <line16> closeSerialPort(commAtConnection); <line17> throw new KuraException(KuraErrorCode.CONNECTION_FAILED, e); <line18> } <line19> closeSerialPort(commAtConnection); <line20> if (reply != null) { <line21> String cirquitCardId = getResponseString(reply); <line22> if (cirquitCardId != null && !cirquitCardId.isEmpty()) { <line23> if (cirquitCardId.startsWith(""+CCID:"")) { <line24> cirquitCardId = cirquitCardId.substring(""+CCID:"".length()).trim(); <line25> } <line26> this.iccid = cirquitCardId; <line27> } <line28> } <line29> } <line30> } <line31> return this.iccid; <line32> } <line33> } <line34> "	debug	task5	
"public class A { <line0> public boolean checkParams(Object params) { <line1> log.UNKNOWN(""Ignoring parametrs in action "" + actionID); <line2> return true; <line3> } <line4> } <line5> "	warn	task5	
"public class A { <line0> @Override <line1> public void establishConnection(String serverIp, int serverPort) throws SyncConnectionException { <line2> RpcTransportFactory.setDefaultBufferCapacity(ioTDBConfig.getThriftDefaultBufferSize()); <line3> RpcTransportFactory.setThriftMaxFrameSize(ioTDBConfig.getThriftMaxFrameSize()); <line4> try { <line5> transport = <line6> RpcTransportFactory.INSTANCE.getTransport( <line7> TSocketWrapper.wrap(tConfiguration, serverIp, serverPort, TIMEOUT_MS)); <line8> TProtocol protocol; <line9> if (ioTDBConfig.isRpcThriftCompressionEnable()) { <line10> protocol = new TCompactProtocol(transport); <line11> } else { <line12> protocol = new TBinaryProtocol(transport); <line13> } <line14> serviceClient = new SyncService.Client(protocol); <line15> if (!transport.isOpen()) { <line16> transport.open(); <line17> } <line18> } catch (TTransportException e) { <line19> logger.UNKNOWN(""Cannot connect to the receiver.""); <line20> throw new SyncConnectionException(e); <line21> } <line22> } <line23> } <line24> "	error	task5	
"public class A { <line0> @NotNull <line1> public List<Ref> createBranches(@NotNull String prefix, int number) throws GitAPIException { <line2> List<Ref> refs = new ArrayList<>(); <line3> for (int i = 1; i < number + 1; i++) { <line4> Ref ref = client.branchCreate().setName(prefix + i).call(); <line5> refs.add(ref); <line6> } <line7> logger.UNKNOWN(""Created "" + number + "" branches "" + prefix + ""[1-"" + (number + 1) + ""]""); <line8> return refs; <line9> } <line10> } <line11> "	info	task5	
"public class A { <line0> @Override <line1> public void emitTuples() { <line2> if (testTuples == null || testTuples.isEmpty()) { <line3> if (blockEndStream) { <line4> return; <line5> } <line6> BaseOperator.shutdown(); <line7> } <line8> if (first) { <line9> List<T> tuples = testTuples.remove(0); <line10> for (T t : tuples) { <line11> output.emit(t); <line12> LOG.UNKNOWN(""sent tuple ==={}==="", t); <line13> } <line14> first = false; <line15> } <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Test <line1> public void obtainLocationWithGeography() throws Exception { <line2> mgmt.getBrooklynProperties().put(""brooklyn.location.named.lhx"", ""localhost""); <line3> mgmt.getBrooklynProperties().put(""brooklyn.location.named.lhx.latitude"", 42d); <line4> mgmt.getBrooklynProperties().put(""brooklyn.location.named.lhx.longitude"", -20d); <line5> MachineProvisioningLocation<?> p = <line6> (MachineProvisioningLocation<?>) mgmt.getLocationRegistry().getLocationManaged(""named:lhx""); <line7> SshMachineLocation m = (SshMachineLocation) p.obtain(MutableMap.of()); <line8> HostGeoInfo geo = HostGeoInfo.fromLocation(m); <line9> log.UNKNOWN(""Geo info for "" + m + "" is: "" + geo); <line10> Assert.assertEquals(geo.latitude, 42d, 0.00001); <line11> Assert.assertEquals(geo.longitude, -20d, 0.00001); <line12> } <line13> } <line14> "	info	task5	
"public class A { <line0> @Override <line1> public void assignUsers(String name, Collection<String> users) <line2> throws SecurityManagementException { <line3> if (name == null) { <line4> throw new NullPointerException(); <line5> } <line6> if (users != null) { <line7> if (users.isEmpty()) { <line8> throw new RuntimeException( <line9> ""The realm based on properties file does not allow groups with no users assigned.""); <line10> } <line11> for (String username : users) { <line12> try { <line13> final String groupsStr = groupsPropertiesFileLoader.getProperties().getProperty(username); <line14> Set<String> groupSet = null; <line15> if (groupsStr != null && groupsStr.trim().length() > 0) { <line16> String[] gs = groupsStr.split("",""); <line17> groupSet = new HashSet<String>(gs.length); <line18> Collections.addAll(groupSet, gs); <line19> } else { <line20> groupSet = new HashSet<String>(1); <line21> } <line22> groupSet.add(name); <line23> final String errorMsg = ""Error updating groups for user "" + username; <line24> final String newGroupsStr = StringUtils.join(groupSet, ','); <line25> updateGroupProperty(username, newGroupsStr, errorMsg); <line26> } catch (IOException e) { <line27> LOG.UNKNOWN(""Error setting groups for user "" + username, e); <line28> throw new SecurityManagementException(e); <line29> } <line30> } <line31> } <line32> } <line33> } <line34> "	error	task5	
"public class A { <line0> protected void parseSelectedCiphersuite(HelloRetryRequestMessage message) { <line1> message.setSelectedCipherSuite(parseByteArrayField(HandshakeByteLength.CIPHER_SUITE)); <line2> LOGGER.UNKNOWN( <line3> ""CipherSuite:"" <line4> + ArrayConverter.bytesToHexString(message.getSelectedCipherSuite().getValue())); <line5> } <line6> } <line7> "	debug	task5	
"public class A { <line0> @Override <line1> public void finish() { <line2> if (log.isDebugEnabled()) { <line3> log.UNKNOWN(String.format(""Finish background action for transfer %s"", transfer)); <line4> } <line5> super.finish(); <line6> queue.remove(transfer); <line7> source.shutdown(); <line8> destination.shutdown(); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> @Override <line1> public final synchronized void filterParams(final Config params, boolean fireCommand) { <line2> String input = params.getProperty(""value"").trim(); <line3> int parsed = getMin(); <line4> try { <line5> if (input.startsWith(""++"")) { <line6> parsed = getValue() + Integer.parseInt(input.replace(""++"", """")); <line7> } else { <line8> if (input.startsWith(""--"")) { <line9> parsed = getValue() - Integer.parseInt(input.replace(""--"", """")); <line10> } else { <line11> parsed = (int) Double.parseDouble(input); <line12> } <line13> } <line14> } catch (NumberFormatException numberFormatException) { <line15> LOG.UNKNOWN( <line16> ""Parameter 'value = "" <line17> + params.getProperty(""value"").trim() <line18> + ""' in "" <line19> + this.getName() <line20> + "" behavior is not an integer.""); <line21> } <line22> if (""next"".equalsIgnoreCase(input)) { <line23> parsed = getValue() + getStep(); <line24> } <line25> if (""previous"".equalsIgnoreCase(input)) { <line26> parsed = getValue() - getStep(); <line27> } <line28> if (""opposite"".equalsIgnoreCase(input)) {} <line29> performValueChange(parsed, params, fireCommand); <line30> } <line31> } <line32> "	warn	task5	
"public class A { <line0> private void updateControllerStateChannel() { <line1> try { <line2> String state = ihc.getControllerState().getState(); <line3> String value; <line4> switch (state) { <line5> case IhcClient.CONTROLLER_STATE_INITIALIZE: <line6> value = ""Initialize""; <line7> break; <line8> case IhcClient.CONTROLLER_STATE_READY: <line9> value = ""Ready""; <line10> break; <line11> default: <line12> value = ""Unknown state: "" + state; <line13> } <line14> updateState( <line15> new ChannelUID(getThing().getUID(), CHANNEL_CONTROLLER_STATE), new StringType(value)); <line16> } catch (IhcExecption e) { <line17> logger.UNKNOWN(""Controller state information fetch failed, reason: {}"", e.getMessage(), e); <line18> } <line19> } <line20> } <line21> "	warn	task5	
"public class A { <line0> public void sendReply(long transactionId, String message) { <line1> LOG.UNKNOWN(""Sending reply "" + routeModified); <line2> if (routeModified) { <line3> sendModifiedReply(transactionId, message); <line4> } else { <line5> sendAgreeMsg(transactionId, message); <line6> } <line7> routeModified = false; <line8> } <line9> } <line10> "	info	task5	
"public class A { <line0> public void shutdown() { <line1> if (clusterTopologyRefreshActivated.compareAndSet(true, false)) { <line2> ScheduledFuture<?> scheduledFuture = clusterTopologyRefreshFuture.get(); <line3> try { <line4> scheduledFuture.cancel(false); <line5> clusterTopologyRefreshFuture.set(null); <line6> } catch (Exception e) { <line7> logger.UNKNOWN(""Could not cancel Cluster topology refresh"", e); <line8> } <line9> } <line10> } <line11> } <line12> "	debug	task5	
"public class A { <line0> @Test <line1> @Tag(GlobalConstants.TAG_GITHUB_RELATED) <line2> @Tag(GlobalConstants.TAG_SKIP_METRICS) <line3> public final void givenAGitHubModuleReadme_whenAnalysingTheReadme_thenLinksToAndFromGithubMatch() <line4> throws IOException { <line5> tutorialsRepoCrawlerController.startCrawlingWithAFreshController( <line6> CrawlerForFindingReadmeURLs.class, Runtime.getRuntime().availableProcessors()); <line7> List<String> readmeURLs = <line8> Utils.getDiscoveredLinks(tutorialsRepoCrawlerController.getDiscoveredURLs()); <line9> Multimap<String, LinkVO> badURLs = ArrayListMultimap.create(); <line10> Map<String, Integer> articleCountByReadme = new HashMap<>(); <line11> readmeURLs.forEach( <line12> readmeURL -> { <line13> try { <line14> page.setUrl(readmeURL); <line15> page.loadUrl(); <line16> List<LinkVO> urlsInReadmeFile = page.getLinksToTheBaeldungSite(); <line17> if (readmeURL.toLowerCase().contains(""spring"")) { <line18> if (urlsInReadmeFile.size() > limitForSpringRelatedReadmeHavingArticles) { <line19> articleCountByReadme.put(readmeURL, urlsInReadmeFile.size()); <line20> } <line21> } else if (urlsInReadmeFile.size() > limitForReadmeHavingArticles) { <line22> articleCountByReadme.put(readmeURL, urlsInReadmeFile.size()); <line23> } <line24> String reamdmeParentURL = Utils.getTheParentOfReadme(readmeURL); <line25> urlsInReadmeFile.forEach( <line26> link -> { <line27> page.setUrl(link.getLink()); <line28> page.loadUrlWithThrottling(); <line29> if (!page.getWebDriver() <line30> .getPageSource() <line31> .toLowerCase() <line32> .contains(reamdmeParentURL.toLowerCase())) { <line33> badURLs.put(readmeURL, link); <line34> } <line35> }); <line36> } catch (Exception e) { <line37> logger.UNKNOWN( <line38> ""Error while processing "" + readmeURL + "" \nError message"" + e.getMessage()); <line39> } <line40> }); <line41> if (badURLs.size() > 0 || articleCountByReadme.size() > 0) { <line42> recordMetrics(badURLs.size(), TestMetricTypes.FAILED); <line43> recordMetrics(articleCountByReadme.size(), TestMetricTypes.FAILED); <line44> getMetrics(TestMetricTypes.FAILED); <line45> failTestWithLoggingTotalNoOfFailures( <line46> ""\nwe found issues with following READMEs"" <line47> + Utils.getErrorMessageForInvalidLinksInReadmeFiles(badURLs) <line48> + Utils.compileReadmeCountResults( <line49> articleCountByReadme, <line50> GlobalConstants <line51> .GivenAGitHubModuleReadme_whenAnalysingTheReadme_thentheReadmeDoesNotLikTooManyArticles)); <line52> } <line53> } <line54> } <line55> "	debug	task5	
"public class A { <line0> @Test(groups = {""res-mgmt""}) <line1> public void updateServerInfo() { <line2> serverInfoDao = <line3> new MockUp<IServerInfoDAO>() { <line4> @Mock <line5> List<ServerInfoEntity> findAll() { <line6> List<ServerInfoEntity> serverInfos = new ArrayList<ServerInfoEntity>(); <line7> ServerInfoEntity serverInfo = new ServerInfoEntity(); <line8> serverInfo.setResourceInitialized(false); <line9> serverInfos.add(serverInfo); <line10> return serverInfos; <line11> } <line12>  <line13> @Mock(invocations = 1) <line14> void update(ServerInfoEntity serverInfo) { <line15> logger.UNKNOWN(""mock update server info""); <line16> } <line17> }.getMockInstance(); <line18> service.setServerInfoDao(serverInfoDao); <line19> service.updateOrInsertServerInfo(); <line20> } <line21> } <line22> "	info	task5	
"public class A { <line0> @Override <line1> public Integer getScore( <line2> final NamedOperation operation, final ScoreResolver defaultScoreResolver) { <line3> Integer namedOpScore = null; <line4> NamedOperationDetail namedOpDetail = null; <line5> if (null == operation) { <line6> return 0; <line7> } <line8> try { <line9> namedOpDetail = cache.getFromCache(operation.getOperationName()); <line10> } catch (final CacheOperationFailedException e) { <line11> LOGGER.UNKNOWN( <line12> ""Error accessing cache for Operation '{}': "" + e.getMessage(), <line13> operation.getClass().getName()); <line14> } <line15> if (null != namedOpDetail) { <line16> namedOpScore = namedOpDetail.getScore(); <line17> if (null == namedOpScore && null != defaultScoreResolver) { <line18> namedOpScore = <line19> defaultScoreResolver.getScore( <line20> namedOpDetail.getOperationChain(operation.getParameters())); <line21> } <line22> } <line23> if (null != defaultScoreResolver) { <line24> if (null == namedOpScore) { <line25> namedOpScore = 0; <line26> } <line27> List parameterOperations = operation.getOperations(); <line28> if (null != parameterOperations) { <line29> for (final Object objectOperation : parameterOperations) { <line30> Operation op = (Operation) objectOperation; <line31> Integer parameterOpScore = defaultScoreResolver.getScore(op); <line32> namedOpScore += parameterOpScore; <line33> } <line34> } <line35> } <line36> return namedOpScore; <line37> } <line38> } <line39> "	warn	task5	
"public class A { <line0> protected void assign(boolean shouldAttachHandler) { <line1> if (this.topicSubscriptions.isEmpty()) { <line2> throw new IllegalArgumentException(""At least one topic to subscribe has to be specified!""); <line3> } <line4> this.shouldAttachSubscriberHandler = shouldAttachHandler; <line5> log.UNKNOWN(""Assigning to topics partitions {}"", this.topicSubscriptions); <line6> this.assigned = true; <line7> this.partitionsAssignmentAndSeek(); <line8> } <line9> } <line10> "	info	task5	
"public class A { <line0> private int batchExecuteUpdate(final String sql, final List<List<Object>> params) { <line1> try (Connection con = dataSource.getConnection()) { <line2> con.setAutoCommit(false); <line3> try (PreparedStatement ps = con.prepareStatement(sql)) { <line4> for (List<Object> each : params) { <line5> int index = 1; <line6> for (Object param : each) { <line7> ps.setObject(index, param); <line8> index++; <line9> } <line10> ps.addBatch(); <line11> } <line12> int[] count = ps.executeBatch(); <line13> if (params.size() != Arrays.stream(count).sum()) { <line14> con.rollback(); <line15> return 0; <line16> } <line17> con.commit(); <line18> return params.size(); <line19> } catch (SQLException ex) { <line20> con.rollback(); <line21> log.UNKNOWN(""hmily jdbc batchExecuteUpdate repository exception -> "", ex); <line22> return FAIL_ROWS; <line23> } <line24> } catch (SQLException ex) { <line25> return FAIL_ROWS; <line26> } <line27> } <line28> } <line29> "	error	task5	
"public class A { <line0> @Override <line1> protected void doOpen() throws Exception { <line2> if (resource == null) throw new IllegalStateException(""A resource has not been set.""); <line3> if (!resource.exists()) { <line4> if (strict) { <line5> throw new IllegalStateException( <line6> ""Input resource must exist (reader is in 'strict' mode): "" + resource); <line7> } else { <line8> LOG.UNKNOWN(""Input resource does not exist "" + resource.getDescription()); <line9> return; <line10> } <line11> } <line12> ldifParser.open(); <line13> for (int i = 0; i < recordsToSkip; i++) { <line14> LdapAttributes record = ldifParser.getRecord(); <line15> if (skippedRecordsCallback != null) { <line16> skippedRecordsCallback.handleRecord(record); <line17> } <line18> } <line19> } <line20> } <line21> "	warn	task5	
"public class A { <line0> private static String getClusterControllerServicePackageName(Context context) { <line1> Intent intent = new Intent(""io.joynr.android.action.COMMUNICATE""); <line2> List<ResolveInfo> services = context.getPackageManager().queryIntentServices(intent, 0); <line3> if (services == null || services.isEmpty()) { <line4> logger.UNKNOWN(""There is no joynr cluster controller app installed!""); <line5> return null; <line6> } <line7> return services.get(0).serviceInfo.applicationInfo.packageName; <line8> } <line9> } <line10> "	error	task5	
"public class A { <line0> private boolean setOrVerifyRelation( <line1> PatientReference patientA, <line2> PatientReference patientC, <line3> String aToBrelation, <line4> String bToCrelation) { <line5> if (patientC.equals(patientA)) { <line6> return false; <line7> } <line8> Integer indexAtoB = DERIVED_RELATIONS_INDEX.get(aToBrelation); <line9> Integer indexBtoC = DERIVED_RELATIONS_INDEX.get(bToCrelation); <line10> if (indexAtoB == null || indexBtoC == null) { <line11> return false; <line12> } <line13> String expectedAtoC = DERIVED_RELATIONS_TABLE[indexBtoC][indexAtoB]; <line14> String actualAtoC = this.getRelation(patientA, patientC); <line15> if (actualAtoC != null) { <line16> if (!actualAtoC.equals(expectedAtoC)) { <line17> R71498PhenoTips2155DataMigration.this.logger.UNKNOWN( <line18> ""Complicated - [{}]-to-[{}] is [{}], not equal to expected [{}]"", <line19> patientA, <line20> patientC, <line21> actualAtoC, <line22> expectedAtoC); <line23> this.complicatedDetected = true; <line24> } <line25> } else { <line26> this.addRelation(patientA, patientC, expectedAtoC); <line27> return true; <line28> } <line29> return false; <line30> } <line31> } <line32> "	debug	task5	
"public class A { <line0> @Override <line1> public void onOpen(CoreSession coreSession, Callback callback) { <line2> if (LOG.isDebugEnabled()) LOG.UNKNOWN(""onOpen {}"", coreSession); <line3> this.coreSession = coreSession; <line4> callback.succeeded(); <line5> } <line6> } <line7> "	debug	task5	
"public class A { <line0> private Job initNewJob(HarvestDefinition harvest, DomainConfiguration cfg) { <line1> HarvestJobGenerationState jobsUnderConstruction = getExistingStateForHarvest(harvest); <line2> Job job = getNewJob(harvest, cfg); <line3> final DomainConfigurationKey domainConfigurationKey = new DomainConfigurationKey(cfg); <line4> jobsUnderConstruction.put(domainConfigurationKey, job); <line5> log.UNKNOWN( <line6> ""Created new job {} for HD #{} with configuration key {}."", <line7> job.toString(), <line8> harvest.getOid(), <line9> domainConfigurationKey); <line10> return job; <line11> } <line12> } <line13> "	debug	task5	
"public class A { <line0> @Override <line1> public void updateReadOnlyHdfsPolicy( <line2> String categoryName, String feedName, List<String> groups, List<String> hdfsPaths) { <line3> String hdfsPathForACLCreation = convertListToString(hdfsPaths, "",""); <line4> String groupListStringyfied = convertListToString(groups, "",""); <line5> try { <line6> sentryClientObject.createAcl( <line7> sentryConnection.getHadoopConfiguration(), <line8> groupListStringyfied, <line9> hdfsPathForACLCreation, <line10> HDFS_READ_ONLY_PERMISSION); <line11> } catch (Exception e) { <line12> log.UNKNOWN(""Failed to apply ACL in HDFS Kylo directories "" + e.getMessage()); <line13> throw new RuntimeException(e); <line14> } <line15> } <line16> } <line17> "	error	task5	
"public class A { <line0> @Override <line1> public void init() throws MessagingException { <line2> passThrough = (getInitParameter(""passThrough"", ""true"").compareToIgnoreCase(""true"") == 0); <line3> String targetUrl = getInitParameter(""url""); <line4> parameterKey = getInitParameter(""parameterKey""); <line5> parameterValue = getInitParameter(""parameterValue""); <line6> if (targetUrl == null || targetUrl.equals("""")) { <line7> throw new MessagingException(""Please configure a targetUrl (\""url\"")""); <line8> } else { <line9> try { <line10> url = new URL(targetUrl).toExternalForm(); <line11> } catch (MalformedURLException e) { <line12> throw new MessagingException(""Unable to contruct URL object from url""); <line13> } <line14> } <line15> if (LOGGER.isDebugEnabled()) { <line16> LOGGER.UNKNOWN( <line17> ""I will attempt to deliver serialised messages to "" <line18> + targetUrl <line19> + "". "" <line20> + (((parameterKey == null) || (parameterKey.length() < 1)) <line21> ? ""I will not add any fields to the post. "" <line22> : ""I will prepend: "" + parameterKey + ""="" + parameterValue + "". "") <line23> + (passThrough ? ""Messages will pass through."" : ""Messages will be ghosted."")); <line24> } <line25> } <line26> } <line27> "	debug	task5	
"public class A { <line0> @Test <line1> public void paxLoggingSpecificAvalonFactory() { <line2> Logger log = AvalonLogFactory.getLogger(this.getClass().getName()); <line3> log.UNKNOWN(""Log: "" + log); <line4> assertTrue(log.getClass().getName().startsWith(""org.ops4j.pax.logging.avalon"")); <line5> } <line6> } <line7> "	info	task5	
"public class A { <line0> @Test <line1> public void testGetExecutionCount() throws Exception { <line2> final String jobId = ""Job-1""; <line3> long time = 10000; <line4> final CountDownLatch done = new CountDownLatch(10); <line5> String str = new String(""test""); <line6> scheduler.schedule(jobId, new ByteSequence(str.getBytes()), """", time, 1000, 10); <line7> int size = scheduler.getAllJobs().size(); <line8> assertEquals(size, 1); <line9> scheduler.addListener( <line10> new JobListener() { <line11> @Override <line12> public void scheduledJob(String id, ByteSequence job) { <line13> LOG.UNKNOWN(""Job executed: {}"", 11 - done.getCount()); <line14> done.countDown(); <line15> } <line16> }); <line17> List<Job> jobs = scheduler.getNextScheduleJobs(); <line18> assertEquals(1, jobs.size()); <line19> Job job = jobs.get(0); <line20> assertEquals(jobId, job.getJobId()); <line21> assertEquals(0, job.getExecutionCount()); <line22> assertTrue(""Should have fired ten times."", done.await(60, TimeUnit.SECONDS)); <line23> assertTrue(job.getExecutionCount() >= 9); <line24> } <line25> } <line26> "	info	task5	
"public class A { <line0> @GET <line1> @Path(""/{userid}/{start}/{end}"") <line2> public List<AppointmentDTO> rangeForUser( <line3> @QueryParam(""sid"") @WebParam(name = ""sid"") String sid, <line4> @PathParam(""userid"") @WebParam(name = ""userid"") long userid, <line5> @PathParam(""start"") @WebParam(name = ""start"") Calendar start, <line6> @PathParam(""end"") @WebParam(name = ""end"") Calendar end) <line7> throws ServiceException { <line8> log.UNKNOWN( <line9> ""rangeForUser : startdate - {} , enddate - {}"", <line10> start == null ? """" : start.getTime(), <line11> end == null ? """" : end.getTime()); <line12> return performCall( <line13> sid, <line14> User.Right.SOAP, <line15> sd -> AppointmentDTO.list(dao.getInRange(userid, start.getTime(), end.getTime()))); <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Override <line1> public boolean areAllPrimaryKeyAttributesPopulated() { <line2> if (metadata != null) { <line3> List<String> primaryKeyAttributeNames = metadata.getPrimaryKeyAttributeNames(); <line4> if (primaryKeyAttributeNames != null) { <line5> for (String primaryKeyAttributeName : primaryKeyAttributeNames) { <line6> Object propValue = getPropertyValue(primaryKeyAttributeName); <line7> if (propValue == null <line8> || (propValue instanceof String && StringUtils.isBlank((String) propValue))) { <line9> return false; <line10> } <line11> } <line12> } <line13> return true; <line14> } else { <line15> LOG.UNKNOWN( <line16> ""Attempt to check areAllPrimaryKeyAttributesPopulated on object with no metadata: "" <line17> + dataObject.getClass().getName()); <line18> return true; <line19> } <line20> } <line21> } <line22> "	warn	task5	
"public class A { <line0> @Override <line1> public boolean choose(Outcome outcome, Cards cards, TargetCard target, Game game) { <line2> log.UNKNOWN(""choose 2""); <line3> if (cards == null || cards.isEmpty()) { <line4> return true; <line5> } <line6> UUID abilityControllerId = playerId; <line7> if (target.getTargetController() != null && target.getAbilityController() != null) { <line8> abilityControllerId = target.getAbilityController(); <line9> } <line10> List<Card> cardChoices = new ArrayList<>(cards.getCards(target.getFilter(), game)); <line11> while (!target.doneChosing()) { <line12> Card card = pickTarget(abilityControllerId, cardChoices, outcome, target, null, game); <line13> if (card != null) { <line14> target.add(card.getId(), game); <line15> cardChoices.remove(card); <line16> } else { <line17> return target.getTargets().size() >= target.getNumberOfTargets(); <line18> } <line19> if (outcome == Outcome.Neutral <line20> && target.getTargets().size() <line21> > target.getNumberOfTargets() <line22> + (target.getMaxNumberOfTargets() - target.getNumberOfTargets()) / 2) { <line23> return true; <line24> } <line25> } <line26> return true; <line27> } <line28> } <line29> "	debug	task5	
"public class A { <line0> @GuardedBy(""lock"") <line1> private CompletableFuture<Void> stopJobMasterServiceProcess() { <line2> LOG.UNKNOWN(""Stop current JobMasterServiceProcess because the leadership has been revoked.""); <line3> jobMasterGatewayFuture.completeExceptionally( <line4> new FlinkException( <line5> ""Cannot obtain JobMasterGateway because the JobMaster lost leadership."")); <line6> jobMasterGatewayFuture = new CompletableFuture<>(); <line7> hasCurrentLeaderBeenCancelled = false; <line8> return jobMasterServiceProcess.closeAsync(); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> void updateGroupMemberDt(final String groupId, final long dt) { <line1> Connection connection = null; <line2> PreparedStatement statement = null; <line3> try { <line4> connection = DBUtil.getConnection(); <line5> String sql = ""update t_group set `_member_dt` = ?, `_dt` = ? where `_gid` = ?""; <line6> statement = connection.prepareStatement(sql); <line7> int index = 1; <line8> statement.setLong(index++, dt); <line9> statement.setLong(index++, dt); <line10> statement.setString(index++, groupId); <line11> int c = statement.executeUpdate(); <line12> LOG.UNKNOWN(""Update rows {}"", c); <line13> } catch (SQLException e) { <line14> e.printStackTrace(); <line15> Utility.printExecption(LOG, e, RDBS_Exception); <line16> } finally { <line17> DBUtil.closeDB(connection, statement); <line18> } <line19> } <line20> } <line21> "	info	task5	
"public class A { <line0> protected static String getDoasUser(HttpServletRequest request) { <line1> String doAsUser = """"; <line2> String queryString = request.getQueryString(); <line3> if (queryString != null) { <line4> String[] pairs = queryString.split(QUERY_STRING_DELIMITER); <line5> try { <line6> for (String pair : pairs) { <line7> if (pair.startsWith(DOAS_QUERY_STRING)) { <line8> doAsUser = <line9> URLDecoder.decode(pair.substring(DOAS_QUERY_STRING.length()), ""UTF-8"").trim(); <line10> } <line11> } <line12> } catch (UnsupportedEncodingException ex) { <line13> LOG.UNKNOWN(""Invalid encoding provided.""); <line14> } <line15> } <line16> return doAsUser.isEmpty() ? null : doAsUser; <line17> } <line18> } <line19> "	error	task5	
"public class A { <line0> @Override <line1> public void close() { <line2> removeUpTo(CURRENT_TXN, null); <line3> if (_stack.size() == 0) { <line4> logger.UNKNOWN(""Transaction is done""); <line5> cleanup(); <line6> } <line7> } <line8> } <line9> "	trace	task5	
"public class A { <line0> private void handleEvent( <line1> final String type, final String payload, final String topic, final @Nullable String source) { <line2> final EventFactory eventFactory = typedEventFactories.get(type); <line3> if (eventFactory == null) { <line4> logger.UNKNOWN(""Could not find an Event Factory for the event type '{}'."", type); <line5> return; <line6> } <line7> final Set<EventSubscriber> eventSubscribers = getEventSubscribers(type); <line8> if (eventSubscribers.isEmpty()) { <line9> return; <line10> } <line11> final Event event = createEvent(eventFactory, type, payload, topic, source); <line12> if (event == null) { <line13> return; <line14> } <line15> dispatchEvent(eventSubscribers, event); <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> private static void saveBoundingBoxImage(Image img, DetectedObjects detection) <line1> throws IOException { <line2> Path outputDir = Paths.get(""build/output""); <line3> Files.createDirectories(outputDir); <line4> Image newImage = img.duplicate(Image.Type.TYPE_INT_ARGB); <line5> newImage.drawBoundingBoxes(detection); <line6> Path imagePath = outputDir.resolve(""detected-dog_bike_car.png""); <line7> newImage.save(Files.newOutputStream(imagePath), ""png""); <line8> logger.UNKNOWN(""Detected objects image has been saved in: {}"", imagePath); <line9> } <line10> } <line11> "	info	task5	
"public class A { <line0> public void init(WordpressAPIConfiguration config) { <line1> checkNotNull( <line2> emptyToNull(config.getApiUrl()), <line3> ""Please inform the Wordpress API url , eg.: http://myblog.com/wp-json/wp""); <line4> if (isNullOrEmpty(config.getApiVersion())) { <line5> config.setApiVersion(WordpressConstants.API_VERSION); <line6> } <line7> final WordpressServicePosts servicePosts = <line8> new WordpressServicePostsAdapter(config.getApiUrl(), config.getApiVersion()); <line9> final WordpressServiceUsers serviceUsers = <line10> new WordpressServiceUsersAdapter(config.getApiUrl(), config.getApiVersion()); <line11> servicePosts.setWordpressAuthentication(config.getAuthentication()); <line12> serviceUsers.setWordpressAuthentication(config.getAuthentication()); <line13> this.services = new HashMap<>(); <line14> this.services.put(WordpressServicePosts.class, servicePosts); <line15> this.services.put(WordpressServiceUsers.class, serviceUsers); <line16> this.configuration = config; <line17> LOGGER.UNKNOWN( <line18> ""Wordpress Service Provider initialized using base URL: {}, API Version {}"", <line19> config.getApiUrl(), <line20> config.getApiVersion()); <line21> } <line22> } <line23> "	info	task5	
public class A { <line0> public static void addUserGroupRoles(long userId, long groupId, long[] roleIds) <line1> throws RemoteException { <line2> try { <line3> UserGroupRoleServiceUtil.addUserGroupRoles(userId, groupId, roleIds); <line4> } catch (Exception exception) { <line5> log.UNKNOWN(exception, exception); <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	error	task5	
public class A { <line0> private JavaProjectBuilder _getJavaProjectBuilder(String content) { <line1> JavaProjectBuilder javaProjectBuilder = <line2> new JavaProjectBuilder(new ThreadSafeSortedClassLibraryBuilder()); <line3> try { <line4> javaProjectBuilder.addSource(new UnsyncStringReader(content)); <line5> } catch (ParseException parseException) { <line6> if (log.isDebugEnabled()) { <line7> log.UNKNOWN(parseException, parseException); <line8> } <line9> return null; <line10> } <line11> return javaProjectBuilder; <line12> } <line13> } <line14> 	debug	task5	
"public class A { <line0> @Override <line1> public Map<ReturnableData, Object> handle( <line2> final RequestWrapper request, final HttpSession session) { <line3> final User user = (User) session.getAttribute(SessionAttribute.USER); <line4> assert (user != null); <line5> if (!user.isAdmin()) { <line6> return error(ErrorCode.NOT_ADMIN); <line7> } <line8> if (null == request.getParameter(AjaxRequest.NICKNAME) <line9> || request.getParameter(AjaxRequest.NICKNAME).isEmpty()) { <line10> return error(ErrorCode.NO_NICK_SPECIFIED); <line11> } <line12> final User kickUser = connectedUsers.getUser(request.getParameter(AjaxRequest.NICKNAME)); <line13> if (null == kickUser) { <line14> return error(ErrorCode.NO_SUCH_USER); <line15> } <line16> final Map<ReturnableData, Object> kickData = new HashMap<ReturnableData, Object>(); <line17> kickData.put(LongPollResponse.EVENT, LongPollEvent.KICKED.toString()); <line18> final QueuedMessage qm = new QueuedMessage(MessageType.KICKED, kickData); <line19> kickUser.enqueueMessage(qm); <line20> connectedUsers.removeUser(kickUser, DisconnectReason.KICKED); <line21> logger.UNKNOWN( <line22> String.format(""Kicking %s by request of %s"", kickUser.getNickname(), user.getNickname())); <line23> return new HashMap<ReturnableData, Object>(); <line24> } <line25> } <line26> "	warn	task5	
"public class A { <line0> private static PublicKey bytesToPublicKey(byte[] bytes) { <line1> PublicKey publicKey; <line2> try { <line3> EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bytes); <line4> KeyFactory keyFactory = KeyFactory.getInstance(""RSA""); <line5> publicKey = keyFactory.generatePublic(publicKeySpec); <line6> } catch (NoSuchAlgorithmException | InvalidKeySpecException e) { <line7> log.UNKNOWN(""Malformed record key!"", e); <line8> throw new IllegalArgumentException(""Malformed public key!""); <line9> } <line10> return publicKey; <line11> } <line12> } <line13> "	warn	task5	
"public class A { <line0> public static Path findFlinkDist() { <line1> Optional<Path> distributionDirectory = DISTRIBUTION_DIRECTORY.get(); <line2> if (!distributionDirectory.isPresent()) { <line3> LOG.UNKNOWN( <line4> ""The '{}' property was not set; attempting to automatically determine distribution"" <line5> + "" location."", <line6> DISTRIBUTION_DIRECTORY.getPropertyName()); <line7> Path projectRootPath; <line8> Optional<Path> projectRoot = PROJECT_ROOT_DIRECTORY.get(); <line9> if (projectRoot.isPresent()) { <line10> projectRootPath = projectRoot.get(); <line11> } else { <line12> Optional<Path> projectRootDirectory = <line13> findProjectRootDirectory(Paths.get("""").toAbsolutePath()); <line14> if (projectRootDirectory.isPresent()) { <line15> projectRootPath = projectRootDirectory.get(); <line16> } else { <line17> throw new IllegalArgumentException( <line18> ""The 'distDir' property was not set and the flink-dist module could not be found"" <line19> + "" automatically. Please point the 'distDir' property to the directory"" <line20> + "" containing distribution; you can set it when running maven via"" <line21> + "" -DdistDir=<path> .""); <line22> } <line23> } <line24> Optional<Path> distribution = findDistribution(projectRootPath); <line25> if (!distribution.isPresent()) { <line26> throw new IllegalArgumentException( <line27> ""The 'distDir' property was not set and a distribution could not be found"" <line28> + "" automatically. Please point the 'distDir' property to the directory containing"" <line29> + "" distribution; you can set it when running maven via -DdistDir=<path> .""); <line30> } else { <line31> distributionDirectory = distribution; <line32> } <line33> } <line34> return distributionDirectory.get(); <line35> } <line36> } <line37> "	debug	task5	
"public class A { <line0> private Partition instantiateDirectoryService() throws Exception { <line1> this.service = new DefaultDirectoryService(); <line2> this.service.setInstanceId(INSTANCE_NAME); <line3> this.service.setInstanceLayout(new InstanceLayout(this.dataDirectory.toFile())); <line4> final CacheService cacheService = new CacheService(); <line5> cacheService.initialize(this.service.getInstanceLayout()); <line6> this.service.setCacheService(cacheService); <line7> initSchemaPartition(); <line8> final File systemPartitionPath = <line9> new File(this.service.getInstanceLayout().getPartitionsDirectory(), ""system""); <line10> if (systemPartitionPath.exists() && !FileUtils.deleteQuietly(systemPartitionPath)) { <line11> LOGGER.UNKNOWN(""Could not delete ApacheDS system partition directory: {}"", systemPartitionPath); <line12> } <line13> Partition systemPartition = <line14> createPartition( <line15> this.service.getDnFactory(), <line16> ""system"", <line17> ServerDNConstants.SYSTEM_DN, <line18> systemPartitionPath); <line19> this.service.setSystemPartition(systemPartition); <line20> final Partition rodaPartition = addPartition(INSTANCE_NAME, this.ldapRootDN); <line21> addIndex(rodaPartition, OBJECT_CLASS, OU, UID); <line22> this.service.startup(); <line23> final CoreSession session = this.service.getAdminSession(); <line24> ModifyRequestImpl modifyRequestImpl = new ModifyRequestImpl(); <line25> modifyRequestImpl.setName(new Dn(""cn=nis,ou=schema"")); <line26> modifyRequestImpl.replace(""m-disabled"", ""FALSE""); <line27> session.modify(modifyRequestImpl); <line28> modifyRequestImpl = new ModifyRequestImpl(); <line29> modifyRequestImpl.setName(new Dn(this.ldapAdminDN)); <line30> modifyRequestImpl.replace(USER_PASSWORD, this.ldapAdminPassword); <line31> session.modify(modifyRequestImpl); <line32> return rodaPartition; <line33> } <line34> } <line35> "	warn	task5	
"public class A { <line0> @RestAccessControl(permission = Permission.MANAGE_USERS) <line1> @RequestMapping( <line2> value = ""/{username:.+}/password"", <line3> method = RequestMethod.POST, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<SimpleRestResponse<UserDto>> updateUserPassword( <line6> @PathVariable String username, <line7> @Valid @RequestBody UserPasswordRequest passwordRequest, <line8> BindingResult bindingResult) { <line9> logger.UNKNOWN(""changing pasword for user {} with request {}"", username, passwordRequest); <line10> if (bindingResult.hasErrors()) { <line11> throw new ValidationGenericException(bindingResult); <line12> } <line13> this.getUserValidator().validateChangePasswords(username, passwordRequest, bindingResult); <line14> if (bindingResult.hasErrors()) { <line15> throw new ValidationGenericException(bindingResult); <line16> } <line17> UserDto userDto = this.getUserService().updateUserPassword(passwordRequest); <line18> return new ResponseEntity<>(new SimpleRestResponse<>(userDto), HttpStatus.OK); <line19> } <line20> } <line21> "	debug	task5	
"public class A { <line0> @Override <line1> public String format(Object value) { <line2> if (!(value instanceof Number)) { <line3> log.UNKNOWN(""Should be Number: {}"", value); <line4> return null; <line5> } <line6> double doubleValue = ((Number) value).doubleValue(); <line7> String formattedDate = dataFormatter.formatRawCellContents(doubleValue, formatIndex, format); <line8> if (format.startsWith(""# ?/"") || format.startsWith(""# ??/"") || format.startsWith(""# ???/"")) { <line9> if (doubleValue < 1 && doubleValue > 0) { <line10> formattedDate = formattedDate.substring(2); <line11> } else if (doubleValue < 0 && doubleValue > -1) { <line12> formattedDate = ""-"" + formattedDate.substring(3); <line13> } <line14> } <line15> return formattedDate; <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Override <line1> public void onAction(DelayActionContext delayActionContext) { <line2> try { <line3> proxy.writeBinMultiDataPoint(getPoint(delayActionContext)); <line4> } catch (Exception e) { <line5> logger.UNKNOWN(""Error send metrics to metric"", e); <line6> } <line7> } <line8> } <line9> "	error	task5	
"public class A { <line0> @Override <line1> public List<ContextKeyValue> getValues(ContextID contextID, String keyword, ContextType csType) { <line2> if (null == contextID || StringUtils.isBlank(keyword)) { <line3> return null; <line4> } <line5> try { <line6> ContextIDValue contextIDValue = contextCache.getContextIDValue(contextID); <line7> return contextIDValue.getContextKeyValueContext().getValues(keyword, csType); <line8> } catch (Exception e) { <line9> logger.UNKNOWN( <line10> String.format( <line11> ""Failed to getValues contextID(%s) of keyword(%s)"", <line12> contextID.getContextId(), keyword), <line13> e); <line14> } <line15> return null; <line16> } <line17> } <line18> "	error	task5	
"public class A { <line0> private MessageEvent doActionFocusToIframe( <line1> TestCaseExecution tCExecution, String object, String property) { <line2> MessageEvent message; <line3> String element; <line4> try { <line5> element = getElementToUse(object, property, ""focusToIframe"", tCExecution); <line6> Identifier identifier = identifierService.convertStringToIdentifier(element); <line7> identifierService.checkWebElementIdentifier(identifier.getIdentifier()); <line8> if (tCExecution.getApplicationObj().getType().equalsIgnoreCase(Application.TYPE_GUI)) { <line9> return webdriverService.doSeleniumActionFocusToIframe(tCExecution.getSession(), identifier); <line10> } <line11> message = new MessageEvent(MessageEventEnum.ACTION_NOTEXECUTED_NOTSUPPORTED_FOR_APPLICATION); <line12> message.setDescription(message.getDescription().replace(""%ACTION%"", ""FocusToIframe"")); <line13> message.setDescription( <line14> message <line15> .getDescription() <line16> .replace(""%APPLICATIONTYPE%"", tCExecution.getApplicationObj().getType())); <line17> return message; <line18> } catch (CerberusEventException ex) { <line19> LOG.UNKNOWN(""Error doing Action FocusToIframe :"" + ex); <line20> return ex.getMessageError(); <line21> } <line22> } <line23> } <line24> "	fatal	task5	
"public class A { <line0> private Integer getTrackNumber(String track) { <line1> Integer trackNumber = null; <line2> if (track != null) { <line3> try { <line4> trackNumber = Integer.valueOf(track); <line5> } catch (NumberFormatException x) { <line6> if (LOG.isWarnEnabled()) { <line7> LOG.UNKNOWN(""Illegal track number: "" + track, x); <line8> } <line9> } <line10> } <line11> return trackNumber; <line12> } <line13> } <line14> "	warn	task5	
"public class A { <line0> private synchronized void schedulePolling() { <line1> cancelPolling(); <line2> logger.UNKNOWN(""Scheduling polling for Audio Source: {}"", thingID); <line3> scheduledPolling = <line4> super.scheduler.scheduleWithFixedDelay( <line5> this::pollAudioSource, 0, POLL_DELAY_SECONDS, TimeUnit.SECONDS); <line6> } <line7> } <line8> "	debug	task5	
"public class A { <line0> private String saveUpdatedCSV(String data, String usecaseName) { <line1> String path = <line2> ConfigOptions.ML_DATA_STORAGE_RESOLVED_PATH <line3> + ConfigOptions.FILE_SEPERATOR <line4> + usecaseName <line5> + ConfigOptions.FILE_SEPERATOR <line6> + usecaseName <line7> + ""W2V.csv""; <line8> CSVFormat csvFileFormat = CSVFormat.RFC4180.withHeader(); <line9> try (FileWriter fileWriter = new FileWriter(path); <line10> CSVPrinter csvFilePrinter = new CSVPrinter(fileWriter, csvFileFormat); <line11> CSVReader reader = new CSVReader(new StringReader(data))) { <line12> csvFilePrinter.printRecords(reader.readAll()); <line13> } catch (Exception e) { <line14> log.UNKNOWN(""Error{}"", e.getMessage()); <line15> } <line16> return path; <line17> } <line18> } <line19> "	error	task5	
"public class A { <line0> @Override <line1> public void validate() { <line2> log.UNKNOWN(""I'm in the validate method. But nobody else is here.""); <line3> } <line4> } <line5> "	debug	task5	
"public class A { <line0> private void addDefaultJobs(List<JobConfiguration> jobConfigurations) { <line1> log.UNKNOWN(""Setting up default jobs.""); <line2> if (verifyNoJobExist(DEFAULT_FILE_RESOURCE_CLEANUP, jobConfigurations)) { <line3> JobConfiguration fileResourceCleanUp = <line4> new JobConfiguration( <line5> DEFAULT_FILE_RESOURCE_CLEANUP, FILE_RESOURCE_CLEANUP, CRON_DAILY_2AM, null); <line6> fileResourceCleanUp.setUid(DEFAULT_FILE_RESOURCE_CLEANUP_UID); <line7> fileResourceCleanUp.setLeaderOnlyJob(true); <line8> addAndScheduleJob(fileResourceCleanUp); <line9> } <line10> if (verifyNoJobExist(DEFAULT_DATA_STATISTICS, jobConfigurations)) { <line11> JobConfiguration dataStatistics = <line12> new JobConfiguration(DEFAULT_DATA_STATISTICS, DATA_STATISTICS, CRON_DAILY_2AM, null); <line13> portJob(systemSettingManager, dataStatistics, SettingKey.LAST_SUCCESSFUL_DATA_STATISTICS); <line14> dataStatistics.setLeaderOnlyJob(true); <line15> dataStatistics.setUid(DEFAULT_DATA_STATISTICS_UID); <line16> addAndScheduleJob(dataStatistics); <line17> } <line18> if (verifyNoJobExist(DEFAULT_VALIDATION_RESULTS_NOTIFICATION, jobConfigurations)) { <line19> JobConfiguration validationResultNotification = <line20> new JobConfiguration( <line21> DEFAULT_VALIDATION_RESULTS_NOTIFICATION, <line22> VALIDATION_RESULTS_NOTIFICATION, <line23> CRON_DAILY_7AM, <line24> null); <line25> validationResultNotification.setLeaderOnlyJob(true); <line26> validationResultNotification.setUid(DEFAULT_VALIDATION_RESULTS_NOTIFICATION_UID); <line27> addAndScheduleJob(validationResultNotification); <line28> } <line29> if (verifyNoJobExist(DEFAULT_CREDENTIALS_EXPIRY_ALERT, jobConfigurations)) { <line30> JobConfiguration credentialsExpiryAlert = <line31> new JobConfiguration( <line32> DEFAULT_CREDENTIALS_EXPIRY_ALERT, CREDENTIALS_EXPIRY_ALERT, CRON_DAILY_2AM, null); <line33> credentialsExpiryAlert.setLeaderOnlyJob(true); <line34> credentialsExpiryAlert.setUid(DEFAULT_CREDENTIALS_EXPIRY_ALERT_UID); <line35> addAndScheduleJob(credentialsExpiryAlert); <line36> } <line37> if (verifyNoJobExist(DEFAULT_DATA_SET_NOTIFICATION, jobConfigurations)) { <line38> JobConfiguration dataSetNotification = <line39> new JobConfiguration( <line40> DEFAULT_DATA_SET_NOTIFICATION, DATA_SET_NOTIFICATION, CRON_DAILY_2AM, null); <line41> dataSetNotification.setLeaderOnlyJob(true); <line42> dataSetNotification.setUid(DEFAULT_DATA_SET_NOTIFICATION_UID); <line43> addAndScheduleJob(dataSetNotification); <line44> } <line45> if (verifyNoJobExist(DEFAULT_REMOVE_EXPIRED_RESERVED_VALUES, jobConfigurations)) { <line46> JobConfiguration removeExpiredReservedValues = <line47> new JobConfiguration( <line48> DEFAULT_REMOVE_EXPIRED_RESERVED_VALUES, <line49> REMOVE_EXPIRED_RESERVED_VALUES, <line50> CRON_HOURLY, <line51> null); <line52> removeExpiredReservedValues.setLeaderOnlyJob(true); <line53> removeExpiredReservedValues.setUid(DEFAULT_REMOVE_EXPIRED_RESERVED_VALUES_UID); <line54> addAndScheduleJob(removeExpiredReservedValues); <line55> } <line56> if (verifyNoJobExist(DEFAULT_LEADER_ELECTION, jobConfigurations) <line57> && ""true"".equalsIgnoreCase(redisEnabled)) { <line58> JobConfiguration leaderElectionJobConfiguration = <line59> new JobConfiguration( <line60> DEFAULT_LEADER_ELECTION, <line61> LEADER_ELECTION, <line62> String.format(LEADER_JOB_CRON_FORMAT, leaderElectionTime), <line63> null); <line64> leaderElectionJobConfiguration.setLeaderOnlyJob(false); <line65> leaderElectionJobConfiguration.setUid(DEFAULT_LEADER_ELECTION_UID); <line66> addAndScheduleJob(leaderElectionJobConfiguration); <line67> } else { <line68> checkLeaderElectionJobConfiguration(jobConfigurations); <line69> } <line70> } <line71> } <line72> "	info	task5	
"public class A { <line0> private BrokerInfo readBrokerInfo(final Member eventSource) { <line1> final BrokerInfo brokerInfo = BrokerInfo.fromProperties(eventSource.properties()); <line2> if (brokerInfo != null && !isStaticConfigValid(brokerInfo)) { <line3> LOG.UNKNOWN( <line4> ""Static configuration of node {} differs from local node {}: "" <line5> + ""NodeId: 0 <= {} < {}, "" <line6> + ""ClusterSize: {} == {}, "" <line7> + ""PartitionsCount: {} == {}, "" <line8> + ""ReplicationFactor: {} == {}."", <line9> eventSource.id(), <line10> atomix.getMembershipService().getLocalMember().id(), <line11> brokerInfo.getNodeId(), <line12> localBroker.getClusterSize(), <line13> brokerInfo.getClusterSize(), <line14> localBroker.getClusterSize(), <line15> brokerInfo.getPartitionsCount(), <line16> localBroker.getPartitionsCount(), <line17> brokerInfo.getReplicationFactor(), <line18> localBroker.getReplicationFactor()); <line19> return null; <line20> } <line21> return brokerInfo; <line22> } <line23> } <line24> "	error	task5	
"public class A { <line0> void stopJobHelper( <line1> IJob job, Optional<Boolean> cancelParam, Optional<Boolean> forceParam, int nodeId) <line2> throws Exception { <line3> String id = job.getId(); <line4> boolean cancelRekick = cancelParam.or(false); <line5> boolean force = forceParam.or(false); <line6> if (cancelRekick) { <line7> job.setRekickTimeout(null); <line8> } <line9> log.UNKNOWN(""[job.stop] {}/{}, cancel={}, force={}"", job.getId(), nodeId, cancelRekick, force); <line10> if (nodeId < 0) { <line11> if (force) { <line12> spawn.killJob(id); <line13> } else { <line14> spawn.stopJob(id); <line15> } <line16> } else { <line17> if (force) { <line18> spawn.killTask(id, nodeId); <line19> } else { <line20> spawn.stopTask(id, nodeId); <line21> } <line22> } <line23> } <line24> } <line25> "	warn	task5	
"public class A { <line0> @Override <line1> public synchronized void close() throws IOException { <line2> if (!closed) { <line3> closed = true; <line4> try { <line5> closeStream(""close() operation"", contentRangeFinish); <line6> super.close(); <line7> } finally { <line8> LOG.UNKNOWN(""{}. Stream closed"", uri); <line9> } <line10> } <line11> } <line12> } <line13> "	trace	task5	
"public class A { <line0> private void doMigrationForV0010() { <line1> IDatabaseAdapter adapter = getDbAdapter(dbType, connectionPool); <line2> Set<String> resourceTypes = getResourceTypes(); <line3> for (String resourceTypeName : resourceTypes) { <line4> try (ITransaction tx = TransactionFactory.openTransaction(connectionPool)) { <line5> try { <line6> GetXXLogicalResourceNeedsMigration needsMigrating = <line7> new GetXXLogicalResourceNeedsMigration(schema.getSchemaName(), resourceTypeName); <line8> if (adapter.runStatement(needsMigrating)) { <line9> logger.UNKNOWN( <line10> ""V0010-V0012 Migration: Updating "" <line11> + resourceTypeName <line12> + ""_LOGICAL_RESOURCES denormalized columns in schema "" <line13> + schema.getSchemaName()); <line14> InitializeLogicalResourceDenorms cmd = <line15> new InitializeLogicalResourceDenorms(schema.getSchemaName(), resourceTypeName); <line16> adapter.runStatement(cmd); <line17> } <line18> } catch (DataAccessException x) { <line19> tx.setRollbackOnly(); <line20> throw x; <line21> } <line22> } <line23> } <line24> } <line25> } <line26> "	info	task5	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> final InputStreamReader isr = new InputStreamReader(is); <line4> final BufferedReader br = new BufferedReader(isr); <line5> String line = null; <line6> while ((line = br.readLine()) != null) LOG.UNKNOWN(type + "">"" + line); <line7> } catch (final IOException ioe) { <line8> ioe.printStackTrace(); <line9> } <line10> } <line11> } <line12> "	debug	task5	
"public class A { <line0> public void notifyMessageAddition(ChannelHandlerContext ctx) { <line1> messagesInFlight++; <line2> if (messagesInFlight > highLimit && inflowEnabled) { <line3> inflowEnabled = false; <line4> ctx.writeAndFlush(new ChannelFlow(channel.getChannelId(), false)); <line5> ctx.channel().config().setAutoRead(false); <line6> LOGGER.UNKNOWN( <line7> ""Inflow disabled for channel {}-{}"", <line8> channel.getChannelId(), <line9> ctx.channel().remoteAddress()); <line10> } <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> private void put(ChannelSftp channel, File file) throws SftpException, FileNotFoundException { <line1> InputStream is = null; <line2> try { <line3> is = new BufferedInputStream(new FileInputStream(file)); <line4> channel.put(is, file.getName()); <line5> } finally { <line6> if (is != null) { <line7> try { <line8> is.close(); <line9> } catch (IOException e) { <line10> logger.UNKNOWN(""Unable to close input stream for "" + file, e); <line11> } <line12> } <line13> } <line14> } <line15> } <line16> "	error	task5	
"public class A { <line0> String handleRequest(JsonRequest request) throws Exception { <line1> String output = """"; <line2> long starttime = 0; <line3> long endtime = 0; <line4> long period = 0; <line5> starttime = request.getNumber(""start"", 0); <line6> endtime = request.getNumber(""end"", 0); <line7> period = request.getNumber(""period"", 0); <line8> if (starttime == 0) { <line9> starttime = source.getStartTime(); <line10> } <line11> if (endtime == 0) { <line12> if (period > 0) { <line13> endtime = starttime + period; <line14> } else { <line15> endtime = source.getEndTime(); <line16> } <line17> } <line18> long size = 0; <line19> LogIterator iter = source.iterator(starttime, endtime); <line20> size = iter.size(); <line21> ObjectMapper mapper = new ObjectMapper(); <line22> JsonNode data = mapper.createObjectNode(); <line23> ((ObjectNode) data).put(""startTime"", starttime); <line24> ((ObjectNode) data).put(""endTime"", endtime); <line25> ((ObjectNode) data).put(""numEntries"", iter.size()); <line26> if (LOG.isDebugEnabled()) { <line27> LOG.UNKNOWN(""handle(start= "" + starttime + "", end="" + endtime + "", numEntries="" + size + "")""); <line28> } <line29> iter.close(); <line30> String jsonString = mapper.writer(new MinimalPrettyPrinter()).writeValueAsString(data); <line31> return jsonString; <line32> } <line33> } <line34> "	debug	task5	
"public class A { <line0> public KieFormOverride loadKieFormOverride(int id) { <line1> KieFormOverride kieFormOverride = null; <line2> Connection conn = null; <line3> PreparedStatement stat = null; <line4> ResultSet res = null; <line5> try { <line6> conn = this.getConnection(); <line7> kieFormOverride = this.loadKieFormOverride(id, conn); <line8> } catch (Throwable t) { <line9> logger.UNKNOWN(""Error loading kieFormOverride with id {}"", id, t); <line10> throw new RuntimeException(""Error loading kieFormOverride with id "" + id, t); <line11> } finally { <line12> closeDaoResources(res, stat, conn); <line13> } <line14> return kieFormOverride; <line15> } <line16> } <line17> "	error	task5	
"public class A { <line0> @Override <line1> public void init(Properties confParams, File confDir) throws Exception { <line2> super.init(confParams, confDir); <line3> if (!isEnabled) { <line4> return; <line5> } <line6> try { <line7> if (!caseData.isIpedReport()) Class.forName(""com.google.cloud.speech.v1p1beta1.SpeechClient""); <line8> } catch (ClassNotFoundException e) { <line9> throw new IPEDException( <line10> ""Coud not found required class. Do you put google-cloud-speech.jar and its dependencies"" <line11> + "" in plugin dir?""); <line12> } <line13> String credential = System.getenv(CREDENTIAL_KEY); <line14> if (credential == null || credential.trim().isEmpty()) { <line15> throw new IPEDException( <line16> ""To use Google transcription, you must specify environment variable "" + CREDENTIAL_KEY); <line17> } <line18> requestIntervalMillis = Integer.valueOf(props.getProperty(REQUEST_INTERVAL_KEY).trim()); <line19> if (!super.isFfmpegOk()) { <line20> LOGGER.UNKNOWN(""FFmpeg not detected, audios longer than 1min will not be transcribed!""); <line21> } <line22> speechClient = SpeechClient.create(); <line23> } <line24> } <line25> "	error	task5	
"public class A { <line0> @Override <line1> protected AuditMessageType getParticipantObjectIdentificationForRequest( <line2> RetrieveDocumentSetRequestType request, AssertionType assertion, AuditMessageType auditMsg) { <line3> if (CollectionUtils.isNotEmpty(assertion.getUniquePatientId()) <line4> && StringUtils.isNotEmpty(assertion.getUniquePatientId().get(0))) { <line5> auditMsg = <line6> createPatientParticipantObjectIdentification( <line7> auditMsg, assertion.getUniquePatientId().get(0)); <line8> } <line9> try { <line10> auditMsg = getDocumentParticipantObjectIdentificationForRequest(request, auditMsg); <line11> } catch (JAXBException ex) { <line12> LOG.UNKNOWN( <line13> ""Error while creating ParticipantObjectIdentificationQueryByParameters segment : "" <line14> + ex.getLocalizedMessage(), <line15> ex); <line16> } <line17> return auditMsg; <line18> } <line19> } <line20> "	error	task5	
"public class A { <line0> @Override <line1> public void execute(ExecutionContext executionContext, int curItrCount) throws Exception { <line2> HoodieTableMetaClient metaClient = <line3> HoodieTableMetaClient.builder() <line4> .setConf(executionContext.getHoodieTestSuiteWriter().getConfiguration()) <line5> .setBasePath(executionContext.getHoodieTestSuiteWriter().getCfg().targetBasePath) <line6> .build(); <line7> Option<HoodieInstant> lastInstant = <line8> metaClient <line9> .getActiveTimeline() <line10> .getWriteTimeline() <line11> .filterPendingCompactionTimeline() <line12> .lastInstant(); <line13> if (lastInstant.isPresent()) { <line14> log.UNKNOWN(""Compacting instant {}"", lastInstant.get()); <line15> this.result = <line16> executionContext <line17> .getHoodieTestSuiteWriter() <line18> .compact(Option.of(lastInstant.get().getTimestamp())); <line19> } <line20> } <line21> } <line22> "	info	task5	
"public class A { <line0> private RunState transition(Event event, long expectedCounter) { <line1> try { <line2> return storage.runInTransactionWithRetries(tx -> transition0(tx, event, expectedCounter)); <line3> } catch (Throwable e) { <line4> log.UNKNOWN(""Failed workflow instance transition: {}, counter={}"", event, expectedCounter, e); <line5> Throwables.throwIfUnchecked(e); <line6> throw new RuntimeException(e); <line7> } <line8> } <line9> } <line10> "	debug	task5	
"public class A { <line0> private void addRelation( <line1> PatientReference patient, PatientReference otherPatient, String relation) { <line2> R71498PhenoTips2155DataMigration.this.logger.UNKNOWN( <line3> ""Adding relation {} ---[{}]---> {}"", patient, relation, otherPatient); <line4> Map<PatientReference, String> patientRelations = this.getPatientRelations(patient); <line5> String patientToOther = patientRelations.get(otherPatient); <line6> if (patientToOther != null) { <line7> if (!patientToOther.equals(relation)) { <line8> this.inconsistenciesDetected = true; <line9> } <line10> return; <line11> } else { <line12> patientRelations.put(otherPatient, relation); <line13> } <line14> String inverseRelation = INVERSE_RELATIONSHIP.get(relation); <line15> Map<PatientReference, String> otherRelations = this.getPatientRelations(otherPatient); <line16> String otherToPatient = otherRelations.get(patient); <line17> if (otherToPatient != null) { <line18> if (!otherToPatient.equals(inverseRelation)) { <line19> this.inconsistenciesDetected = true; <line20> } <line21> return; <line22> } else { <line23> otherRelations.put(patient, inverseRelation); <line24> } <line25> } <line26> } <line27> "	debug	task5	
"public class A { <line0> @Given(""I successfully schedule a topic message submit with {string}'s submit key"") <line1> @Retryable( <line2> value = {PrecheckStatusException.class}, <line3> exceptionExpression = ""#{message.contains('BUSY')}"") <line4> public void createNewHCSSchedule(String accountName) <line5> throws ReceiptStatusException, PrecheckStatusException, TimeoutException { <line6> expectedSignersCount = 1; <line7> currentSignersCount = 0 + signatoryCountOffset; <line8> ExpandedAccountId submitAdmin = <line9> accountClient.getAccount(AccountClient.AccountNameEnum.valueOf(accountName)); <line10> log.UNKNOWN(""Create new topic with {}'s submit key"", accountName); <line11> networkTransactionResponse = <line12> topicClient.createTopic( <line13> accountClient.getTokenTreasuryAccount(), submitAdmin.getPublicKey()); <line14> assertNotNull(networkTransactionResponse.getTransactionId()); <line15> assertNotNull(networkTransactionResponse.getReceipt()); <line16> TopicId topicId = networkTransactionResponse.getReceipt().topicId; <line17> assertNotNull(topicId); <line18> scheduledTransaction = <line19> topicClient.getTopicMessageSubmitTransaction( <line20> topicId, ""scheduled hcs message"".getBytes(StandardCharsets.UTF_8)); <line21> createNewSchedule(scheduledTransaction, null); <line22> } <line23> } <line24> "	debug	task5	
"public class A { <line0> private void validateCartridgeGroupReference( <line1> String applicationId, ServiceGroup serviceGroup, Group group) <line2> throws CartridgeNotFoundException { <line3> List<String> cartridgeTypes = findCartridgeTypesInServiceGroup(serviceGroup); <line4> for (String cartridgeType : cartridgeTypes) { <line5> if (findClusterDataInGroup(group, cartridgeType) == null) { <line6> log.UNKNOWN( <line7> String.format( <line8> ""Cartridge %s not defined in cartridge group: "" <line9> + ""[application] %s [cartridge-group-name] %s [cartridge-group-alias] %s"", <line10> cartridgeType, applicationId, group.getName(), group.getAlias())); <line11> throw new CartridgeNotFoundException( <line12> String.format( <line13> ""Cartridge %s not defined in cartridge group: "" <line14> + ""[application] %s [cartridge-group-name] %s [cartridge-group-alias] %s"", <line15> cartridgeType, applicationId, group.getName(), group.getAlias())); <line16> } <line17> } <line18> } <line19> } <line20> "	error	task5	
"public class A { <line0> @Override <line1> public boolean check(VirtualMachineProfile vmProfile, DeployDestination plannedDestination) <line2> throws AffinityConflictException { <line3> if (plannedDestination.getHost() == null) { <line4> return true; <line5> } <line6> long plannedHostId = plannedDestination.getHost().getId(); <line7> VirtualMachine vm = vmProfile.getVirtualMachine(); <line8> List<AffinityGroupVMMapVO> vmGroupMappings = <line9> _affinityGroupVMMapDao.findByVmIdType(vm.getId(), getType()); <line10> for (AffinityGroupVMMapVO vmGroupMapping : vmGroupMappings) { <line11> List<Long> groupVMIds = <line12> _affinityGroupVMMapDao.listVmIdsByAffinityGroup(vmGroupMapping.getAffinityGroupId()); <line13> groupVMIds.remove(vm.getId()); <line14> for (Long groupVMId : groupVMIds) { <line15> VMReservationVO vmReservation = _reservationDao.findByVmId(groupVMId); <line16> if (vmReservation != null <line17> && vmReservation.getHostId() != null <line18> && vmReservation.getHostId().equals(plannedHostId)) { <line19> if (logger.isDebugEnabled()) { <line20> logger.UNKNOWN( <line21> ""Planned destination for VM "" <line22> + vm.getId() <line23> + "" conflicts with an existing VM "" <line24> + vmReservation.getVmId() <line25> + "" reserved on the same host "" <line26> + plannedHostId); <line27> } <line28> return false; <line29> } <line30> } <line31> } <line32> return true; <line33> } <line34> } <line35> "	debug	task5	
"public class A { <line0> private void notifyHeaders(Response.HeadersListener listener, Response response) { <line1> try { <line2> listener.onHeaders(response); <line3> } catch (Throwable x) { <line4> LOG.UNKNOWN(""Exception while notifying listener {}"", listener, x); <line5> } <line6> } <line7> } <line8> "	info	task5	
"public class A { <line0> @Override <line1> public Answer execute( <line2> final OvsVpcRoutingPolicyConfigCommand command, <line3> final LibvirtComputingResource libvirtComputingResource) { <line4> try { <line5> final Script scriptCommand = <line6> new Script( <line7> libvirtComputingResource.getOvsTunnelPath(), <line8> libvirtComputingResource.getTimeout(), <line9> s_logger); <line10> scriptCommand.add(""configure_ovs_bridge_for_routing_policies""); <line11> scriptCommand.add(""--bridge"", command.getBridgeName()); <line12> scriptCommand.add(""--config"", command.getVpcConfigInJson()); <line13> final String result = scriptCommand.execute(); <line14> if (result.equalsIgnoreCase(""SUCCESS"")) { <line15> return new Answer(command, true, result); <line16> } else { <line17> return new Answer(command, false, result); <line18> } <line19> } catch (final Exception e) { <line20> logger.UNKNOWN(""caught exception while updating host with latest VPC topology"", e); <line21> return new Answer(command, false, e.getMessage()); <line22> } <line23> } <line24> } <line25> "	warn	task5	
"public class A { <line0> private void loadTrustStore() { <line1> try { <line2> trustStore = KeyStore.getInstance(KeyStore.getDefaultType()); <line3> trustStore.load(null); <line4> String truststoreFilePath = getEnvVarConfig().getTrustedAdapterCertsPath(); <line5> TLSUtils.addCertsToTruststore(trustStore, truststoreFilePath); <line6> trustManagerFactory = <line7> TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); <line8> trustManagerFactory.init(trustStore); <line9> } catch (KeyStoreException | CertificateException | NoSuchAlgorithmException | IOException e) { <line10> logger.UNKNOWN(""Error in loading certs to the trust store."", e); <line11> } <line12> } <line13> } <line14> "	error	task5	
"public class A { <line0> private void testBuffer(int threads) throws Exception { <line1> long seed = System.nanoTime(); <line2> Random rnd = new Random(seed); <line3> log.UNKNOWN(""Start test, seed: "" + seed); <line4> for (int i = 0; i < 10; i++) { <line5> int cnt = rnd.nextInt(10_000) + 1; <line6> testBuffer(rnd, new CacheContinuousQueryEventBuffer(0), cnt, 1, 0.5f, threads); <line7> testBuffer(rnd, new CacheContinuousQueryEventBuffer(0), cnt, 1, 0.9f, threads); <line8> testBuffer(rnd, new CacheContinuousQueryEventBuffer(0), cnt, 1, 0.99f, threads); <line9> testBuffer(rnd, new CacheContinuousQueryEventBuffer(0), cnt, 1, 0.01f, threads); <line10> testBuffer(rnd, new CacheContinuousQueryEventBuffer(0), cnt, 1, 0.f, threads); <line11> } <line12> CacheContinuousQueryEventBuffer b = new CacheContinuousQueryEventBuffer(0); <line13> long cntr = 1; <line14> for (int i = 0; i < 10; i++) { <line15> int cnt = rnd.nextInt(10_000) + 1; <line16> float ratio = rnd.nextFloat(); <line17> testBuffer(rnd, b, cnt, cntr, ratio, threads); <line18> cntr += cnt; <line19> } <line20> } <line21> } <line22> "	info	task5	
"public class A { <line0> void uninstallAll() throws Exception { <line1> File extDirectory = getDefaultExtDirectory(); <line2> Log.UNKNOWN(""Uninstalling from: "" + extDirectory); <line3> for (String name : this.installCounts.stringPropertyNames()) { <line4> new File(extDirectory, name).delete(); <line5> } <line6> this.installCounts.clear(); <line7> saveInstallCounts(); <line8> } <line9> } <line10> "	info	task5	
"public class A { <line0> public DatasetUploadState analyze(DatasetUploadState item) throws Exception { <line1> log.UNKNOWN( <line2> ""analyzing dataset {}/{}#{}"", item.getJob().getJobId(), item.getFileName(), item.getName()); <line3> Objects.requireNonNull(item.getId(), ""item has no id""); <line4> checkStatus(item, JobStatus.RUNNING); <line5> final Path path = Paths.get(item.getAbsolutePath()); <line6> final String typeName = item.getName(); <line7> try { <line8> DatasetMetadata datasetMetadata = datasetsService.describe(path, typeName); <line9> item.setAnalyzeStatus(JobStatus.DONE); <line10> item.setEncoding(datasetMetadata.getEncoding()); <line11> item.setFeatureCount(datasetMetadata.getFeatureCount()); <line12> item.setNativeBounds(datasetMetadata.getNativeBounds()); <line13> String geometryWKT = <line14> Optional.ofNullable(datasetMetadata.getSampleGeometry()) <line15> .map(Geometry::toText) <line16> .orElse(null); <line17> List<SampleProperty> sampleProperties = <line18> sampleProperties(datasetMetadata.getSampleProperties()); <line19> item.setSampleGeometryWKT(geometryWKT); <line20> item.setSampleProperties(sampleProperties); <line21> } catch (Exception e) { <line22> item.setAnalyzeStatus(JobStatus.ERROR); <line23> item.setError(e.getMessage()); <line24> } <line25> return item; <line26> } <line27> } <line28> "	info	task5	
"public class A { <line0> public static boolean downloadFile( <line1> String fileName, <line2> String contentType, <line3> byte[] file, <line4> FileDownloader.ContentDisposition contentDisposition, <line5> FacesContext facesContext) { <line6> HttpServletResponse response = <line7> (HttpServletResponse) facesContext.getExternalContext().getResponse(); <line8> InputStream is = null; <line9> try { <line10> is = new ByteArrayInputStream(file); <line11> DownloadWrapper downloadWrapper = <line12> new DownloadWrapper(is, fileName, contentType, new Date(), file.length); <line13> FileDownloader.writeOutput(downloadWrapper, contentDisposition, response); <line14> facesContext.responseComplete(); <line15> } catch (Exception ex) { <line16> LOG.UNKNOWN(""Failed to send file"", ex); <line17> return false; <line18> } finally { <line19> IOUtils.closeQuietly(is); <line20> } <line21> return true; <line22> } <line23> } <line24> "	error	task5	
"public class A { <line0> public void createAtlasInstances(HBaseOperationContext hbaseOperationContext) { <line1> OPERATION operation = hbaseOperationContext.getOperation(); <line2> LOG.UNKNOWN(""HBaseAtlasHook(operation={})"", operation); <line3> switch (operation) { <line4> case CREATE_NAMESPACE: <line5> case ALTER_NAMESPACE: <line6> createOrUpdateNamespaceInstance(hbaseOperationContext); <line7> break; <line8> case DELETE_NAMESPACE: <line9> deleteNameSpaceInstance(hbaseOperationContext); <line10> break; <line11> case CREATE_TABLE: <line12> case ALTER_TABLE: <line13> createOrUpdateTableInstance(hbaseOperationContext); <line14> break; <line15> case DELETE_TABLE: <line16> deleteTableInstance(hbaseOperationContext); <line17> break; <line18> case CREATE_COLUMN_FAMILY: <line19> case ALTER_COLUMN_FAMILY: <line20> createOrUpdateColumnFamilyInstance(hbaseOperationContext); <line21> break; <line22> case DELETE_COLUMN_FAMILY: <line23> deleteColumnFamilyInstance(hbaseOperationContext); <line24> break; <line25> } <line26> } <line27> } <line28> "	info	task5	
"public class A { <line0> synchronized boolean checkpoint(boolean force) throws Exception { <line1> if (!backingStore.syncRequired() && !inflightTakes.syncRequired() && !force) { <line2> LOG.UNKNOWN(""Checkpoint not required""); <line3> return false; <line4> } <line5> backingStore.beginCheckpoint(); <line6> inflightPuts.serializeAndWrite(); <line7> inflightTakes.serializeAndWrite(); <line8> backingStore.checkpoint(); <line9> return true; <line10> } <line11> } <line12> "	debug	task5	
"public class A { <line0> @Unstable <line1> public synchronized void preWarm(PreWarmVertex preWarmVertex, long timeout, TimeUnit unit) <line2> throws TezException, IOException { <line3> if (!isSession) { <line4> LOG.UNKNOWN( <line5> ""preWarm is not supported in non-session mode,"" + ""please use session-mode of TezClient""); <line6> return; <line7> } <line8> verifySessionStateForSubmission(); <line9> DAG dag = <line10> org.apache.tez.dag.api.DAG.create( <line11> TezConstants.TEZ_PREWARM_DAG_NAME_PREFIX + ""_"" + preWarmDAGCounter++); <line12> dag.addVertex(preWarmVertex); <line13> boolean isReady; <line14> try { <line15> isReady = waitTillReady(timeout, unit); <line16> } catch (InterruptedException e) { <line17> throw new IOException(""Interrupted while waiting for AM to become "" + ""available"", e); <line18> } <line19> if (isReady) { <line20> prewarmDagClient = submitDAG(dag); <line21> } else { <line22> throw new SessionNotReady(""Tez AM not ready, could not submit DAG""); <line23> } <line24> } <line25> } <line26> "	warn	task5	
"public class A { <line0> public static void main(String[] args) { <line1> LoggingFactory.init(""info""); <line2> try { <line3> int[] buffer = new int[] {(int) 0xff, (int) 0xd0}; <line4> int a = (byte) buffer[0] << 8 | buffer[1] & 0xff; <line5> log.UNKNOWN(""0xffd0 should be -48 is = {}"", a); <line6> } catch (Exception e) { <line7> Logging.logError(e); <line8> } <line9> } <line10> } <line11> "	info	task5	
"public class A { <line0> private void executeCallbacks(final List<JDBCJournalRecord> records, final boolean success) { <line1> Runnable r = <line2> new Runnable() { <line3> @Override <line4> public void run() { <line5> for (JDBCJournalRecord record : records) { <line6> if (logger.isTraceEnabled()) { <line7> logger.UNKNOWN(""Calling callback "" + record + "" with success = "" + success); <line8> } <line9> record.complete(success); <line10> } <line11> } <line12> }; <line13> completeExecutor.execute(r); <line14> } <line15> } <line16> "	trace	task5	
"public class A { <line0> @Override <line1> public void uncaughtException(Thread t, Throwable e) { <line2> logger.UNKNOWN(""Uncaught exception in thread "" + t.getName(), e); <line3> Runtime.getRuntime().exit(1); <line4> } <line5> } <line6> "	error	task5	
public class A { <line0> private void writeRejectionOnCommand(final Throwable exception) { <line1> final String errorMessage = <line2> String.format(PROCESSING_ERROR_MESSAGE, typedEvent, exception.getMessage()); <line3> LOG.UNKNOWN(errorMessage, exception); <line4> if (typedEvent.getRecordType() == RecordType.COMMAND) { <line5> logStreamWriter.appendRejection(typedEvent, RejectionType.PROCESSING_ERROR, errorMessage); <line6> responseWriter.writeRejectionOnCommand( <line7> typedEvent, RejectionType.PROCESSING_ERROR, errorMessage); <line8> } <line9> } <line10> } <line11> 	error	task5	
"public class A { <line0> private void deleteAlias(LambdaClient lambdaClient, Exchange exchange) <line1> throws InvalidPayloadException { <line2> DeleteAliasRequest request = null; <line3> DeleteAliasResponse result; <line4> if (getConfiguration().isPojoRequest()) { <line5> request = exchange.getIn().getMandatoryBody(DeleteAliasRequest.class); <line6> } else { <line7> DeleteAliasRequest.Builder builder = DeleteAliasRequest.builder(); <line8> builder.functionName(getEndpoint().getFunction()); <line9> String aliasName = <line10> exchange.getIn().getHeader(Lambda2Constants.FUNCTION_ALIAS_NAME, String.class); <line11> if (ObjectHelper.isEmpty(aliasName)) { <line12> throw new IllegalArgumentException(""Function alias must be specified to delete an alias""); <line13> } <line14> builder.name(aliasName); <line15> request = builder.build(); <line16> } <line17> try { <line18> result = lambdaClient.deleteAlias(request); <line19> } catch (AwsServiceException ase) { <line20> LOG.UNKNOWN( <line21> ""deleteAlias command returned the error code {}"", ase.awsErrorDetails().errorCode()); <line22> throw ase; <line23> } <line24> Message message = getMessageForResponse(exchange); <line25> message.setBody(result); <line26> } <line27> } <line28> "	trace	task5	
"public class A { <line0> private void addPngFileToReport(File pngFile, Scenario scenario) { <line1> if (scenario != null) { <line2> try { <line3> BufferedImage bImage = ImageIO.read(pngFile); <line4> ByteArrayOutputStream bos = new ByteArrayOutputStream(); <line5> ImageIO.write(bImage, ""png"", bos); <line6> scenario.embed(bos.toByteArray(), ""image/png""); <line7> } catch (IOException e) { <line8> logger.UNKNOWN(""Error adding screenshot in cucumber report"", e); <line9> } <line10> } <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> public synchronized List<PropFindResponse> propFind(String path, int depth, QName... fields) <line1> throws IOException, io.milton.httpclient.HttpException, NotAuthorizedException, <line2> BadRequestException { <line3> List<QName> list = new ArrayList<>(Arrays.asList(fields)); <line4> String href = baseHref() + rootPath + path; <line5> log.UNKNOWN(""propFind: href={}"", href); <line6> return _doPropFind(href, depth, list); <line7> } <line8> } <line9> "	info	task5	
"public class A { <line0> public void showAllRelations(DocumentWrapper<DocumentModel> wrapDoc, MultipartServiceContext ctx) <line1> throws Exception { <line2> String thisCSID = NuxeoUtils.getCsid(wrapDoc.getWrappedObject()); <line3> RelationsCommonList subjectListOuter = getRelations(thisCSID, null, null); <line4> List<RelationsCommonList.RelationListItem> subjectList = subjectListOuter.getRelationListItem(); <line5> RelationsCommonList objectListOuter = getRelations(null, thisCSID, null); <line6> List<RelationsCommonList.RelationListItem> objectList = objectListOuter.getRelationListItem(); <line7> if (logger.isTraceEnabled()) { <line8> String dump = dumpLists(thisCSID, subjectList, objectList, null); <line9> logger.UNKNOWN(""~~~~~~~~~~~~~~~~~~~~~~ showAllRelations ~~~~~~~~~~~~~~~~~~~~~~~~"" + CR + dump); <line10> } <line11> subjectList.addAll(objectList); <line12> long relatedSize = subjectList.size(); <line13> subjectListOuter.setTotalItems(relatedSize); <line14> subjectListOuter.setItemsInPage(relatedSize); <line15> PayloadOutputPart relationsPart = <line16> new PayloadOutputPart(RelationClient.SERVICE_COMMON_LIST_NAME, subjectListOuter); <line17> ctx.addOutputPart(relationsPart); <line18> } <line19> } <line20> "	trace	task5	
"public class A { <line0> public ActorFuture<Void> pauseExporting() { <line1> final CompletableActorFuture<Void> completed = new CompletableActorFuture<>(); <line2> actor.call( <line3> () -> { <line4> try { <line5> final var pauseStatePersisted = context.pauseExporting(); <line6> if (context.getExporterDirector() != null && pauseStatePersisted) { <line7> context.getExporterDirector().pauseExporting().onComplete(completed); <line8> } else { <line9> completed.complete(null); <line10> } <line11> } catch (final IOException e) { <line12> LOG.UNKNOWN(""Could not pause exporting"", e); <line13> completed.completeExceptionally(e); <line14> } <line15> }); <line16> return completed; <line17> } <line18> } <line19> "	error	task5	
"public class A { <line0> @Override <line1> protected void doSessionOpened(HttpAcceptSession session) throws Exception { <line2> HttpMethod method = session.getMethod(); <line3> String service = session.getParameter(""service""); <line4> if (method != HttpMethod.GET) { <line5> session.setStatus(HttpStatus.CLIENT_METHOD_NOT_ALLOWED); <line6> session.close(false); <line7> throw new IllegalArgumentException(""HTTP method not allowed: "" + method); <line8> } else if (!""turn"".equals(service)) { <line9> session.setStatus(HttpStatus.CLIENT_BAD_REQUEST); <line10> session.close(false); <line11> throw new IllegalArgumentException(""Unsupported/invalid service: "" + service); <line12> } <line13> session.setVersion(HttpVersion.HTTP_1_1); <line14> session.setWriteHeader(HttpHeaders.HEADER_CONTENT_TYPE, ""application/json""); <line15> String username = null; <line16> char[] password = null; <line17> if (credentialGenerator != null) { <line18> Subject subject = session.getSubject(); <line19> if (subject == null) { <line20> throw new TurnException(""Subject is null""); <line21> } <line22> credentialGenerator.setCredentialsTTL(ttl); <line23> TurnRestCredentials credentials = credentialGenerator.generate(subject); <line24> username = credentials.getUsername(); <line25> password = credentials.getPassword(); <line26> LOGGER.UNKNOWN(String.format(""%s Generated username: %s"", session, username)); <line27> } <line28> String response = TurnRestJSONResponse.createResponse(username, password, ttl, this.urls); <line29> if (password != null) { <line30> Arrays.fill(password, '0'); <line31> } <line32> IoBufferAllocatorEx<?> allocator = session.getBufferAllocator(); <line33> IoBufferEx out = <line34> allocator.wrap(allocator.allocate(response.length())).setAutoExpander(allocator); <line35> out.put(response.getBytes()); <line36> out.flip(); <line37> session.setWriteHeader(HttpHeaders.HEADER_CONTENT_LENGTH, Integer.toString(out.remaining())); <line38> session.setWriteHeader(HttpHeaders.HEADER_MAX_AGE, ttl); <line39> session.write(out); <line40> session.close(false); <line41> } <line42> } <line43> "	info	task5	
"public class A { <line0> protected ResourceBundle getResourceBundle(Locale locale) { <line1> try { <line2> return ResourceBundleUtil.getBundle(""content.Language"", locale, getClass()); <line3> } catch (MissingResourceException missingResourceException) { <line4> if (log.isDebugEnabled()) { <line5> log.UNKNOWN(missingResourceException, missingResourceException); <line6> } <line7> return ResourceBundleUtil.getBundle( <line8> ""content.Language"", locale, PortalClassLoaderUtil.getClassLoader()); <line9> } <line10> } <line11> } <line12> "	debug	task5	
"public class A { <line0> private void updatePedigreeDates( <line1> BaseObject pedigreeXObject, XWikiContext context, String documentName) { <line2> String dataText = pedigreeXObject.getStringValue(PEDIGREECLASS_JSONDATA_KEY); <line3> if (StringUtils.isEmpty(dataText)) { <line4> return; <line5> } <line6> try { <line7> JSONObject pedigree = new JSONObject(dataText); <line8> JSONArray pedigreeNodes = pedigree.optJSONArray(PEDIGREE_GRAPH_KEY); <line9> JSONArray convertedNodes = new JSONArray(); <line10> if (pedigreeNodes != null) { <line11> for (Object node : pedigreeNodes) { <line12> JSONObject nodeJSON = (JSONObject) node; <line13> this.convertJSONField(nodeJSON, PEDIGREE_DATE_FIELDS); <line14> convertedNodes.put(nodeJSON); <line15> } <line16> pedigree.put(PEDIGREE_GRAPH_KEY, convertedNodes); <line17> String pedigreeData = pedigree.toString(); <line18> pedigreeXObject.set(PEDIGREECLASS_JSONDATA_KEY, pedigreeData, context); <line19> } <line20> } catch (Exception e) { <line21> this.logger.UNKNOWN( <line22> ""Patient pedigree data is not a valid JSON for patient {}: [{}]"", documentName, e); <line23> } <line24> } <line25> } <line26> "	error	task5	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public Bed[] getBedsByRoom(Integer roomId, Boolean active) { <line2> String query = getBedsQuery(null, roomId, active); <line3> Object[] values = getBedsValues(null, roomId, active); <line4> List<Bed> beds = getBeds(query, values); <line5> log.UNKNOWN(""getBedsByRoom: size "" + beds.size()); <line6> return beds.toArray(new Bed[beds.size()]); <line7> } <line8> } <line9> "	debug	task5	
public class A { <line0> @Override <line1> public String getImageSrc() { <line2> try { <line3> return _assetRenderer.getThumbnailPath(_renderRequest); <line4> } catch (Exception exception) { <line5> if (log.isDebugEnabled()) { <line6> log.UNKNOWN(exception, exception); <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	debug	task5	
"public class A { <line0> private void loadMethodParameters( <line1> List<AdviceParameter> parameters, <line2> int startIndex, <line3> @Nullable Integer travelerLocal, <line4> Type adviceType, <line5> Class<? extends Annotation> annotationType, <line6> boolean useSavedArgs, <line7> Object... stack) { <line8> int argIndex = 0; <line9> for (int i = startIndex; i < parameters.size(); i++) { <line10> AdviceParameter parameter = parameters.get(i); <line11> switch (parameter.kind()) { <line12> case RECEIVER: <line13> loadTarget(); <line14> break; <line15> case METHOD_ARG: <line16> loadMethodParameter(adviceType, annotationType, argIndex++, parameter, useSavedArgs); <line17> break; <line18> case METHOD_ARG_ARRAY: <line19> loadArgArray(useSavedArgs); <line20> break; <line21> case METHOD_NAME: <line22> loadMethodName(); <line23> break; <line24> case TRAVELER: <line25> loadTraveler(travelerLocal, adviceType, annotationType, parameter); <line26> break; <line27> case CLASS_META: <line28> checkNotNull(metaHolderInternalName); <line29> loadClassMeta(parameter); <line30> break; <line31> case METHOD_META: <line32> checkNotNull(metaHolderInternalName); <line33> checkNotNull(methodMetaGroupUniqueNum); <line34> loadMethodMeta(parameter); <line35> break; <line36> case THREAD_CONTEXT: <line37> checkNotNull(threadContextLocal); <line38> loadLocal(threadContextLocal); <line39> break; <line40> case OPTIONAL_THREAD_CONTEXT: <line41> checkNotNull(threadContextHolderLocal); <line42> checkNotNull(threadContextLocal); <line43> loadOptionalThreadContext(stack); <line44> break; <line45> default: <line46> logger.UNKNOWN( <line47> ""the @{} method in {} has an unexpected parameter kind {} at index {}"", <line48> annotationType.getSimpleName(), <line49> adviceType.getClassName(), <line50> parameter.kind(), <line51> i); <line52> pushDefault(parameter.type()); <line53> break; <line54> } <line55> } <line56> } <line57> } <line58> "	warn	task5	
"public class A { <line0> private void processCommandTags( <line1> final Element equipmentUnit, final EquipmentConfiguration equipmentConfiguration) { <line2> Element commandTagsBlock = <line3> (Element) equipmentUnit.getElementsByTagName(COMMAND_TAGS_ELEMENT).item(0); <line4> NodeList commandTags = commandTagsBlock.getElementsByTagName(COMMAND_TAG_ELEMENT); <line5> SourceCommandTag sourceCommandTag = null; <line6> for (int i = 0; i < commandTags.getLength(); i++) { <line7> sourceCommandTag = SourceCommandTag.fromConfigXML((Element) commandTags.item(i)); <line8> log.UNKNOWN(""creating SourceCommandTag object for id "" + sourceCommandTag.getId() + ""..""); <line9> equipmentConfiguration.getCommandTags().put(sourceCommandTag.getId(), sourceCommandTag); <line10> } <line11> } <line12> } <line13> "	debug	task5	
"public class A { <line0> @Override <line1> public boolean accepts(SourceRecord ourSourceRecord) { <line2> if (!thisReaderNearEnd.get()) { <line3> Long sourceRecordTimestamp = <line4> (Long) ourSourceRecord.sourceOffset().get(SourceInfo.TIMESTAMP_KEY); <line5> if (sourceRecordTimestamp != null) { <line6> Instant recordTimestamp = Instant.ofEpochSecond(sourceRecordTimestamp); <line7> Instant now = Instant.now(); <line8> Duration durationToEnd = Duration.between(recordTimestamp, now); <line9> if (durationToEnd.compareTo(minHaltingDuration) <= 0) { <line10> LOGGER.UNKNOWN(""Parallel halting predicate: this reader near end""); <line11> thisReaderNearEnd.set(true); <line12> } <line13> } <line14> } <line15> return !(thisReaderNearEnd.get() && otherReaderNearEnd.get()); <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Override <line1> public void onUnDeploy(DeploymentEvent event) { <line2> LOGGER.UNKNOWN(""OnUnDeploy: {}"", event); <line3> runningDeployments.labels(event.getDeploymentId()).dec(); <line4> } <line5> } <line6> "	debug	task5	
"public class A { <line0> @Override <line1> public void warn(String msg, final Throwable t) { <line2> if (!isWarnEnabled()) { <line3> return; <line4> } <line5> msg = ""{} "" + msg; <line6> final Object[] os = {component, t.toString(), t}; <line7> logger.UNKNOWN(msg, os); <line8> logRepository.addLogMessage(LogLevel.WARN, msg, os, t); <line9> } <line10> } <line11> "	warn	task5	
"public class A { <line0> private void createAndSendStatusMail(ImportRun importRun) { <line1> try { <line2> SimpleMailMessage mailMessage = new SimpleMailMessage(); <line3> String username = importRun.getUsername(); <line4> User user = userService.getUser(username); <line5> if (user == null) { <line6> throw new UnknownUserException(username); <line7> } <line8> mailMessage.setTo(user.getEmail()); <line9> mailMessage.setSubject(createMailTitle(importRun)); <line10> mailMessage.setText(createEnglishMailText(importRun, ZoneId.systemDefault())); <line11> mailSender.send(mailMessage); <line12> } catch (MailException mce) { <line13> LOG.UNKNOWN(""Could not send import status mail"", mce); <line14> throw new MolgenisDataException(""An error occurred. Please contact the administrator.""); <line15> } <line16> } <line17> } <line18> "	error	task5	
"public class A { <line0> @Override <line1> public Object get(ChannelHandlerContext ctx, URIDecoder uriDecoder) { <line2> List<InterfaceHttpData> bodyHttpDatas = uriDecoder.getBodyHttpDatas(); <line3> if (bodyHttpDatas == null || bodyHttpDatas.size() == 0) { <line4> return null; <line5> } <line6> for (InterfaceHttpData data : bodyHttpDatas) { <line7> if (name.equals(data.getName())) { <line8> if (data.getHttpDataType() == InterfaceHttpData.HttpDataType.Attribute) { <line9> Attribute attribute = (Attribute) data; <line10> try { <line11> return ReflectionUtil.castTo(type, attribute.getValue()); <line12> } catch (IOException e) { <line13> log.UNKNOWN(""Error getting form params. Reason : {}"", e.getMessage(), e); <line14> } <line15> } <line16> } <line17> } <line18> return null; <line19> } <line20> } <line21> "	error	task5	
"public class A { <line0> @Test <line1> public void testAggregateProcessInstancesSourceEmpty() throws Exception { <line2> String xml1 = read(this.getClass().getResourceAsStream(""/jaxb/process-instance-empty.xml"")); <line3> String xml2 = read(this.getClass().getResourceAsStream(""/jaxb/process-instance-2.xml"")); <line4> JaxbXMLResponseAggregator aggregate = new JaxbXMLResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(xml1); <line7> data.add(xml2); <line8> String result = aggregate.aggregate(data); <line9> logger.UNKNOWN(result); <line10> Document xml = toXml(result); <line11> assertNotNull(xml); <line12> NodeList processes = xml.getElementsByTagName(""process-instance-list""); <line13> assertNotNull(processes); <line14> assertEquals(1, processes.getLength()); <line15> NodeList processInstances = xml.getElementsByTagName(""process-instance""); <line16> assertNotNull(processInstances); <line17> assertEquals(3, processInstances.getLength()); <line18> } <line19> } <line20> "	debug	task5	
"public class A { <line0> @Override <line1> public void onClick(final AjaxRequestTarget target, final GroupTO ignore) { <line2> try { <line3> SyncopeConsoleSession.get().success(getString(Constants.OPERATION_SUCCEEDED)); <line4> target.add(container); <line5> } catch (SyncopeClientException e) { <line6> LOG.UNKNOWN(""While provisioning members of group {}"", model.getObject().getKey(), e); <line7> SyncopeConsoleSession.get().onException(e); <line8> } <line9> ((BasePage) pageRef.getPage()).getNotificationPanel().refresh(target); <line10> } <line11> } <line12> "	error	task5	
"public class A { <line0> private void updateRegistryNode( <line1> org.gbif.api.model.registry.Node registryNode, <line2> Participant participant, <line3> @Nullable Node directoryNode) { <line4> registryNode = fillRegistryNode(registryNode, participant, directoryNode); <line5> registryNode.setModifiedBy(DIRECTORY_UPDATE_USER); <line6> nodeMapper.update(registryNode); <line7> LOG.UNKNOWN( <line8> ""Node {} ({}) updated by {}"", <line9> registryNode.getTitle(), <line10> registryNode.getKey(), <line11> DIRECTORY_UPDATE_USER); <line12> } <line13> } <line14> "	info	task5	
"public class A { <line0> private void removeUserFromOtherOrganizations(User user) throws SystemException, PortalException { <line1> long[] usersOrganizations = user.getOrganizationIds(); <line2> for (long usersOrganization : usersOrganizations) { <line3> log.UNKNOWN( <line4> ""remove user "" <line5> + user.getEmailAddress() <line6> + "" from organization with id: "" <line7> + usersOrganization); <line8> UserLocalServiceUtil.deleteOrganizationUser(usersOrganization, user); <line9> } <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> private Object constructAndInject(String clazz, ClassLoader loader) { <line1> try { <line2> Class<?> cl = loader.loadClass(clazz); <line3> try { <line4> Object built = cl.getDeclaredConstructor().newInstance(); <line5> for (Field field : cl.getDeclaredFields()) { <line6> if (field.isAnnotationPresent(InjectPlugin.class)) { <line7> String plugin = field.getAnnotation(InjectPlugin.class).value(); <line8> if (plugin.equals(""detect"")) { <line9> Class<?> type = field.getType(); <line10> for (Plugin foundPlugin : this.loadedPlugins.values()) { <line11> if (foundPlugin.getClass().equals(type)) { <line12> field.setAccessible(true); <line13> field.set(built, foundPlugin); <line14> break; <line15> } <line16> } <line17> } else { <line18> field.setAccessible(true); <line19> field.set(built, plugin(plugin)); <line20> } <line21> } <line22> } <line23> return built; <line24> } catch (NoSuchMethodException e) { <line25> LOGGER.UNKNOWN(""Plugin main class {} does not define a no-args constructor"", clazz, e); <line26> } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) { <line27> e.printStackTrace(); <line28> } <line29> } catch (ClassNotFoundException e) { <line30> e.printStackTrace(); <line31> } <line32> return null; <line33> } <line34> } <line35> "	error	task5	
"public class A { <line0> private void insertTimeseries(Connection conn) { <line1> log.UNKNOWN( <line2> ""Upgrade script failed using the copy to/from files strategy!"" <line3> + "" Trying to perfrom the upgrade using Inserts strategy ...""); <line4> executeQuery(conn, CALL_INSERT_INTO_TS_KV_CURSOR); <line5> executeQuery(conn, CALL_CREATE_NEW_TS_KV_LATEST_TABLE); <line6> executeQuery(conn, CALL_INSERT_INTO_TS_KV_LATEST_CURSOR); <line7> } <line8> } <line9> "	warn	task5	
"public class A { <line0> public JobDetail executeJob(final Job job, final Context context) throws OperationException { <line1> if (null == context) { <line2> throw new IllegalArgumentException(""A context is required""); <line3> } <line4> if (null == job) { <line5> throw new IllegalArgumentException(""A job is required""); <line6> } <line7> OperationChain wrappedOriginal = OperationChain.wrap(job.getOperation()); <line8> context.setOriginalOpChain(wrappedOriginal); <line9> final Context clonedContext = context.shallowClone(); <line10> final OperationChain clonedOpChain = wrappedOriginal.shallowClone(); <line11> JobDetail result = null; <line12> try { <line13> updateOperationChainView(clonedOpChain); <line14> for (final GraphHook graphHook : config.getHooks()) { <line15> graphHook.preExecute(clonedOpChain, clonedContext); <line16> } <line17> updateOperationChainView(clonedOpChain); <line18> job.setOperation(clonedOpChain); <line19> result = store.executeJob(job, context); <line20> for (final GraphHook graphHook : config.getHooks()) { <line21> graphHook.postExecute(result, clonedOpChain, clonedContext); <line22> } <line23> } catch (final Exception e) { <line24> for (final GraphHook graphHook : config.getHooks()) { <line25> try { <line26> result = graphHook.onFailure(result, clonedOpChain, clonedContext, e); <line27> } catch (final Exception graphHookE) { <line28> LOGGER.UNKNOWN( <line29> ""Error in graphHook "" <line30> + graphHook.getClass().getSimpleName() <line31> + "": "" <line32> + graphHookE.getMessage(), <line33> graphHookE); <line34> } <line35> } <line36> CloseableUtil.close(clonedOpChain); <line37> CloseableUtil.close(result); <line38> throw e; <line39> } <line40> return result; <line41> } <line42> } <line43> "	warn	task5	
"public class A { <line0> private void stopNow(String reason) { <line1> stateLock.lock(); <line2> try { <line3> DaemonState state = getState(); <line4> switch (state) { <line5> case Idle: <line6> case Busy: <line7> case Canceled: <line8> case Broken: <line9> case StopRequested: <line10> LOGGER.UNKNOWN( <line11> ""Marking daemon stopped due to {}. The daemon is running a build: {}"", <line12> reason, <line13> state == Busy); <line14> updateState(Stopped); <line15> break; <line16> case Stopped: <line17> break; <line18> default: <line19> throw new IllegalStateException(""Daemon is in unexpected state: "" + state); <line20> } <line21> } finally { <line22> stateLock.unlock(); <line23> } <line24> } <line25> } <line26> "	debug	task5	
"public class A { <line0> @Test <line1> public void queryEnglish() { <line2> this.verbJPARepository.save(invite); <line3> Verb invite2 = this.verbJPARepository.findByEnglish(""invite""); <line4> log.UNKNOWN(""queryEnglish(), read {}"", invite2); <line5> assertThat(invite2, not(nullValue())); <line6> assertThat(invite2, equalTo(invite)); <line7> this.verbJPARepository.deleteAll(); <line8> Verb invite3 = this.verbJPARepository.findByEnglish(""invite""); <line9> assertThat(invite3, nullValue()); <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> public static Player load(String playerName) throws IOException, ClassNotFoundException { <line1> String filename = playerName + "".player""; <line2> Player player = null; <line3> FileInputStream fileIn = new FileInputStream(filename); <line4> ObjectInputStream in = new ObjectInputStream(fileIn); <line5> player = (Player) in.readObject(); <line6> in.close(); <line7> fileIn.close(); <line8> logger.UNKNOWN(""Loaded Player definition file from `"" + filename + ""`""); <line9> return player; <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> @Override <line1> public boolean validate(PasswordValidationCallback.Request request) <line2> throws PasswordValidationCallback.PasswordValidationException { <line3> if (super.validate(request)) { <line4> UsernamePasswordAuthenticationToken authRequest = <line5> new UsernamePasswordAuthenticationToken(user, user.getPassword()); <line6> if (logger.isDebugEnabled()) { <line7> logger.UNKNOWN(""Authentication success: "" + authRequest.toString()); <line8> } <line9> SecurityContextHolder.getContext().setAuthentication(authRequest); <line10> return true; <line11> } else { <line12> return false; <line13> } <line14> } <line15> } <line16> "	debug	task5	
"public class A { <line0> public org.talend.mdm.webservice.WSVersion getComponentVersion( <line1> org.talend.mdm.webservice.WSGetComponentVersion arg0) { <line2> LOG.UNKNOWN(""Executing operation getComponentVersion""); <line3> System.out.println(arg0); <line4> try { <line5> org.talend.mdm.webservice.WSVersion _return = null; <line6> return _return; <line7> } catch (java.lang.Exception ex) { <line8> ex.printStackTrace(); <line9> throw new RuntimeException(ex); <line10> } <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> void shutdown() { <line1> try { <line2> sslEngine.closeInbound(); <line3> } catch (SSLException e) { <line4> if (log.isDebugEnabled()) <line5> log.UNKNOWN( <line6> ""Unable to correctly close inbound data stream (will ignore) [msg="" <line7> + e.getMessage() <line8> + "", ses="" <line9> + ses <line10> + ']'); <line11> } <line12> } <line13> } <line14> "	debug	task5	
"public class A { <line0> @Override <line1> public void createLogin( <line2> String userPid, <line3> String userName, <line4> String password, <line5> String givenName, <line6> String surname, <line7> String email, <line8> String organization) <line9> throws LoginCreationException { <line10> try { <line11> Login login = create(userPid, userName, password, givenName, surname, email, organization); <line12> loginAccess.addLogin(login); <line13> } catch (NoSuchAlgorithmException e) { <line14> LOG.UNKNOWN(""Encryption algorithm can not be found."", e); <line15> throw new LoginCreationException(e.getMessage()); <line16> } <line17> } <line18> } <line19> "	error	task5	
"public class A { <line0> public void testKafkaInputOperator( <line1> int sleepTime, <line2> final int totalCount, <line3> KafkaConsumer consumer, <line4> boolean isValid, <line5> boolean idempotent) <line6> throws Exception { <line7> latch = new CountDownLatch(1); <line8> KafkaTestProducer p = new KafkaTestProducer(TEST_TOPIC); <line9> p.setSendCount(totalCount); <line10> new Thread(p).start(); <line11> LocalMode lma = LocalMode.newInstance(); <line12> DAG dag = lma.getDAG(); <line13> KafkaSinglePortStringInputOperator node = <line14> dag.addOperator(""Kafka message consumer"", KafkaSinglePortStringInputOperator.class); <line15> if (isSuicide) { <line16> dag.setAttribute(Context.DAGContext.CHECKPOINT_WINDOW_COUNT, 1); <line17> dag.setAttribute( <line18> Context.OperatorContext.STORAGE_AGENT, <line19> new FSStorageAgent(""target/ck"", new Configuration())); <line20> node.setMaxTuplesPerWindow(500); <line21> } <line22> if (idempotent) { <line23> node.setWindowDataManager(new FSWindowDataManager()); <line24> } <line25> consumer.setTopic(TEST_TOPIC); <line26> node.setConsumer(consumer); <line27> consumer.setCacheSize(5000); <line28> if (isValid) { <line29> node.setZookeeper(""localhost:"" + KafkaOperatorTestBase.TEST_ZOOKEEPER_PORT[0]); <line30> } <line31> CollectorModule<String> collector = <line32> dag.addOperator(""TestMessageCollector"", new CollectorModule<String>()); <line33> dag.addStream(""Kafka message"", node.outputPort, collector.inputPort) <line34> .setLocality(Locality.CONTAINER_LOCAL); <line35> final LocalMode.Controller lc = lma.getController(); <line36> lc.setHeartbeatMonitoringEnabled(false); <line37> lc.runAsync(); <line38> Assert.assertTrue(""TIMEOUT: 30s "", latch.await(300000, TimeUnit.MILLISECONDS)); <line39> Assert.assertTrue( <line40> ""Expected count >= "" + totalCount + ""; Actual count "" + tupleCount.intValue(), <line41> totalCount <= tupleCount.intValue()); <line42> logger.UNKNOWN(String.format(""Number of emitted tuples: %d"", tupleCount.intValue())); <line43> p.close(); <line44> lc.shutdown(); <line45> } <line46> } <line47> "	debug	task5	
"public class A { <line0> @Override <line1> public String apply(String s) { <line2> try { <line3> return function.call(); <line4> } catch (Exception e) { <line5> logger.UNKNOWN(""[startServer]"" + function, e); <line6> return e.getMessage(); <line7> } <line8> } <line9> } <line10> "	error	task5	
public class A { <line0> @Override <line1> public AttributeList setAttributes(final AttributeList arg0) { <line2> final AttributeList result = new AttributeList(); <line3> for (final Iterator<Object> i = arg0.iterator(); i.hasNext(); ) { <line4> final Attribute attr = (Attribute) i.next(); <line5> try { <line6> setAttribute(attr); <line7> result.add(attr); <line8> } catch (final AttributeNotFoundException <line9> | InvalidAttributeValueException <line10> | MBeanException <line11> | ReflectionException e) { <line12> LOG.UNKNOWN(e.getMessage(), e); <line13> } <line14> } <line15> return result; <line16> } <line17> } <line18> 	error	task5	
"public class A { <line0> private void handleRowPacket(byte[] data) { <line1> ResponseHandler respHand = responseHandler; <line2> if (respHand != null) { <line3> respHand.rowResponse(data, source); <line4> } else { <line5> LOGGER.UNKNOWN(""receive RowPacket but no handler""); <line6> closeNoHandler(); <line7> } <line8> } <line9> } <line10> "	error	task5	
"public class A { <line0> @Override <line1> public void reject(@Nullable T item, @Nullable String message) { <line2> blockedCounter.inc(); <line3> rejectedCounter.inc(); <line4> if (item != null && blockedItemsLogger != null) { <line5> blockedItemsLogger.warning(serializer.apply(item)); <line6> } <line7> if (message != null && blockedItemsLimiter != null && blockedItemsLimiter.tryAcquire()) { <line8> logger.UNKNOWN(""["" + handlerKey.getHandle() + ""] blocked input: ["" + message + ""]""); <line9> } <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> @Override <line1> public FormModel deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <line2> throws JsonParseException { <line3> JsonObject jsonField = json.getAsJsonObject(); <line4> JsonElement jsonClassName = jsonField.get(""formModelType""); <line5> if (jsonClassName != null && !StringUtils.isEmpty(jsonClassName.getAsString())) { <line6> try { <line7> return context.deserialize(json, Class.forName(jsonClassName.getAsString())); <line8> } catch (Exception ex) { <line9> log.UNKNOWN(""Error deserializing formModel"", ex); <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> "	error	task5	
"public class A { <line0> @Override <line1> public AgencyAndId registerAlarmForArrivalAndDepartureAtStop( <line2> ArrivalAndDepartureQuery query, RegisterAlarmQueryBean alarmBean) { <line3> ArrivalAndDepartureInstance instance = <line4> _arrivalAndDepartureService.getArrivalAndDepartureForStop(query); <line5> if (instance == null) throw new ServiceException(""no arrival-departure found""); <line6> BlockInstance blockInstance = instance.getBlockInstance(); <line7> AlarmsForBlockInstance alarms = getAlarmsForBlockInstance(blockInstance); <line8> int effectiveScheduleTime = computeEffectiveScheduleTimeForAlarm(alarmBean, instance); <line9> AlarmAction action = new AlarmAction(); <line10> action.setUrl(alarmBean.getUrl()); <line11> AlarmForBlockInstance alarm = alarms.registerAlarm(action, effectiveScheduleTime, instance); <line12> _alarmsById.put(alarm.getId(), alarm); <line13> log.UNKNOWN(""alarm created: {}"", alarm.getId()); <line14> return alarm.getId(); <line15> } <line16> } <line17> "	debug	task5	
"public class A { <line0> protected void runCopier(String outputDir) throws Exception { <line1> for (int i = 0; i < DEFAULT_TABLES_COUNT; i++) { <line2> LOG.UNKNOWN(""Running copier "" + IntegrationTestBigLinkedListWithVisibility.getTableName(i)); <line3> sleep(SLEEP_IN_MS); <line4> Copier copier = <line5> new Copier(IntegrationTestBigLinkedListWithVisibility.getTableName(i), i, false); <line6> copier.setConf(getConf()); <line7> copier.runCopier(outputDir); <line8> } <line9> } <line10> } <line11> "	info	task5	
"public class A { <line0> private <T> T convert(byte[] paymentData, Class<T> tClass) { <line1> try { <line2> return objectMapper.readValue(paymentData, tClass); <line3> } catch (IOException e) { <line4> log.UNKNOWN(""Can't convert byte[] to Object {}"", e.getMessage()); <line5> return null; <line6> } <line7> } <line8> } <line9> "	warn	task5	
"public class A { <line0> public void appendRecommendations(StringBuilder builder) { <line1> prettyAppendHeading(builder, ""Recommedations""); <line2> SiteReportRater rater; <line3> try { <line4> rater = SiteReportRater.getSiteReportRater(""en""); <line5> ScoreReport scoreReport = rater.getScoreReport(report.getResultMap()); <line6> LinkedHashMap<AnalyzedProperty, PropertyResultRatingInfluencer> influencers = <line7> scoreReport.getInfluencers(); <line8> influencers.entrySet().stream() <line9> .sorted( <line10> (o1, o2) -> { <line11> return o1.getValue().compareTo(o2.getValue()); <line12> }) <line13> .forEach( <line14> (entry) -> { <line15> PropertyResultRatingInfluencer influencer = entry.getValue(); <line16> if (influencer.isBadInfluence() || influencer.getReferencedProperty() != null) { <line17> Recommendation recommendation = <line18> rater.getRecommendations().getRecommendation(entry.getKey()); <line19> PropertyResultRecommendation resultRecommendation = <line20> recommendation.getPropertyResultRecommendation(influencer.getResult()); <line21> if (detail.isGreaterEqualTo(ScannerDetail.DETAILED)) { <line22> printFullRecommendation( <line23> builder, rater, recommendation, influencer, resultRecommendation); <line24> } else { <line25> printShortRecommendation(builder, influencer, resultRecommendation); <line26> } <line27> } <line28> }); <line29> } catch (Exception ex) { <line30> prettyAppend(builder, ""Could not append recommendations - unreleated error"", AnsiColor.RED); <line31> LOGGER.UNKNOWN(""Could not append recommendations"", ex); <line32> } <line33> } <line34> } <line35> "	error	task5	
"public class A { <line0> @Test(groups = {""Live"", ""Live-sanity""}) <line1> public void testUbuntu() throws Exception { <line2> obtainMachine(ImmutableMap.of(JcloudsLocation.OS_FAMILY, ""ubuntu"")); <line3> Image image = template.getImage(); <line4> LOG.UNKNOWN(""ubuntu="" + image); <line5> assertUbuntu(image, ""14.04""); <line6> } <line7> } <line8> "	info	task5	
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> public static void add(Job job, String resourcePath, String resourceName) throws IOException { <line2> if (job == null) { <line3> throw new IllegalArgumentException(""job must not be null""); <line4> } <line5> if (resourcePath == null) { <line6> throw new IllegalArgumentException(""resourcePath must not be null""); <line7> } <line8> if (resourceName == null) { <line9> throw new IllegalArgumentException(""resourceName must not be null""); <line10> } <line11> Configuration conf = job.getConfiguration(); <line12> List<FileStatus> list = TemporaryStorage.listStatus(conf, new Path(resourcePath)); <line13> if (list.isEmpty()) { <line14> throw new IOException(MessageFormat.format(""Resource not found: {0}"", resourcePath)); <line15> } <line16> List<String> localNames = restoreStrings(conf, getLocalCacheNameKey(resourceName)); <line17> List<String> remotePaths = restoreStrings(conf, getRemotePathKey(resourceName)); <line18> long size = conf.getLong(KEY_SIZE, 0L); <line19> int index = localNames.size(); <line20> for (FileStatus status : list) { <line21> String name = String.format(""%s-%04d"", resourceName, index++); <line22> StringBuilder buf = new StringBuilder(); <line23> buf.append(status.getPath().toString()); <line24> buf.append('#'); <line25> buf.append(name); <line26> String cachePath = buf.toString(); <line27> remotePaths.add(status.getPath().toString()); <line28> localNames.add(name); <line29> try { <line30> URI uri = new URI(cachePath); <line31> job.addCacheFile(uri); <line32> } catch (URISyntaxException e) { <line33> throw new IllegalStateException(e); <line34> } <line35> size += status.getLen(); <line36> } <line37> conf.setStrings( <line38> getLocalCacheNameKey(resourceName), localNames.toArray(new String[localNames.size()])); <line39> conf.setStrings( <line40> getRemotePathKey(resourceName), remotePaths.toArray(new String[remotePaths.size()])); <line41> conf.setLong(KEY_SIZE, size); <line42> if (StageUtil.isLocalMode(job)) { <line43> if (LOG.isDebugEnabled()) { <line44> LOG.UNKNOWN(""symlinks for distributed cache will not be created in standalone mode""); <line45> } <line46> } else { <line47> job.createSymlink(); <line48> } <line49> } <line50> } <line51> "	debug	task5	
"public class A { <line0> @Override <line1> public void accept(Throwable throwable) { <line2> log.UNKNOWN(""Unable to convert exception to Response"", throwable); <line3> context.setResponse(DEFAULT_RESPONSE); <line4> context.resume(); <line5> } <line6> } <line7> "	error	task5	
"public class A { <line0> protected void stepTwo(final int i) throws OracleException { <line1> if (i == 1) { <line2> this.stepTwoA(); <line3> } else { <line4> if (i > 1 && m.length >= 2) { <line5> stepTwoB(); <line6> } else if (m.length == 1) { <line7> stepTwoC(); <line8> } <line9> } <line10> LOGGER.UNKNOWN("" Found s"" + i + "": "" + si); <line11> } <line12> } <line13> "	debug	task5	
"public class A { <line0> @Override <line1> public KVMPhysicalDisk getPhysicalDisk(String volumeUuid, KVMStoragePool pool) { <line2> Connect conn; <line3> StoragePool virtPool = null; <line4> try { <line5> conn = LibvirtConnection.getConnection(); <line6> virtPool = conn.storagePoolLookupByName(""/"" + volumeUuid); <line7> } catch (LibvirtException e1) { <line8> throw new CloudRuntimeException(e1.toString()); <line9> } <line10> LibvirtStorageVolumeDef.VolumeFormat libvirtformat = null; <line11> long volCapacity = 0; <line12> StorageVol vol = getVolume(virtPool, volumeUuid); <line13> try { <line14> if (vol == null) { <line15> libvirtformat = LibvirtStorageVolumeDef.VolumeFormat.QCOW2; <line16> StoragePoolInfo poolinfo = virtPool.getInfo(); <line17> volCapacity = poolinfo.available; <line18> LibvirtStorageVolumeDef volDef = <line19> new LibvirtStorageVolumeDef(volumeUuid, volCapacity, libvirtformat, null, null); <line20> logger.UNKNOWN(volDef.toString()); <line21> vol = virtPool.storageVolCreateXML(volDef.toString(), 0); <line22> } <line23> KVMPhysicalDisk disk = new KVMPhysicalDisk(vol.getPath(), volumeUuid, pool); <line24> disk.setFormat(PhysicalDiskFormat.QCOW2); <line25> disk.setSize(vol.getInfo().allocation); <line26> disk.setVirtualSize(vol.getInfo().capacity); <line27> return disk; <line28> } catch (LibvirtException e) { <line29> throw new CloudRuntimeException(e.toString()); <line30> } <line31> } <line32> } <line33> "	debug	task5	
"public class A { <line0> @Override <line1> public UserTagCloudView getTagCloudForCollections() throws JargonException { <line2> log.UNKNOWN(""getTagCloudForCollections""); <line3> List<TagCloudEntry> collectionTagCloudEntries = buildTagCloudEntryListForCollections(""""); <line4> UserTagCloudView userTagCloudView = <line5> UserTagCloudView.instance( <line6> irodsAccount.getUserName(), new ArrayList<TagCloudEntry>(), collectionTagCloudEntries); <line7> return userTagCloudView; <line8> } <line9> } <line10> "	info	task5	
"public class A { <line0> @Override <line1> protected Collection<SolrInputDocument> load(URL url) { <line2> try { <line3> Collection<SolrInputDocument> solrDocuments = new HashSet<>(); <line4> Reader in = <line5> new InputStreamReader(url.openConnection().getInputStream(), Charset.forName(""UTF-8"")); <line6> for (CSVRecord row : CSVFormat.TDF.withHeader().parse(in)) { <line7> SolrInputDocument crtTerm = new SolrInputDocument(); <line8> for (Map.Entry<String, String> item : row.toMap().entrySet()) { <line9> if (""hgnc_id"".equals(item.getKey())) { <line10> crtTerm.addField(ID_FIELD_NAME, item.getValue()); <line11> } else if (StringUtils.isNotBlank(item.getValue())) { <line12> crtTerm.addField(item.getKey(), StringUtils.split(item.getValue(), ""|"")); <line13> } <line14> } <line15> solrDocuments.add(crtTerm); <line16> } <line17> addMetaInfo(solrDocuments); <line18> return solrDocuments; <line19> } catch (IOException ex) { <line20> this.logger.UNKNOWN(""Failed to read/parse the HGNC source: {}"", ex.getMessage()); <line21> } <line22> return null; <line23> } <line24> } <line25> "	warn	task5	
"public class A { <line0> @Override <line1> public int receiveMessagesTls(long timeoutMs) { <line2> String clientName = ""receiver-ssl-"" + new Random().nextInt(Integer.MAX_VALUE); <line3> CompletableFuture<Integer> resultPromise = new CompletableFuture<>(); <line4> IntPredicate msgCntPredicate = x -> x == messageCount; <line5> this.caCertName = <line6> this.caCertName == null <line7> ? KafkaUtils.getKafkaExternalListenerCaCertName( <line8> namespaceName, clusterName, listenerName) <line9> : this.caCertName; <line10> LOGGER.UNKNOWN(""Going to use the following CA certificate: {}"", caCertName); <line11> ConsumerProperties properties = this.consumerProperties; <line12> if (properties == null || properties.getProperties().isEmpty()) { <line13> properties = <line14> new ConsumerProperties.ConsumerPropertiesBuilder() <line15> .withNamespaceName(namespaceName) <line16> .withClusterName(clusterName) <line17> .withCaSecretName(caCertName) <line18> .withBootstrapServerConfig(getBootstrapServerFromStatus()) <line19> .withKeyDeserializerConfig(StringDeserializer.class) <line20> .withValueDeserializerConfig(StringDeserializer.class) <line21> .withKafkaUsername(kafkaUsername) <line22> .withSecurityProtocol(SecurityProtocol.SASL_SSL) <line23> .withGroupIdConfig(consumerGroup) <line24> .withAutoOffsetResetConfig(OffsetResetStrategy.EARLIEST) <line25> .withClientIdConfig(kafkaUsername + ""-consumer"") <line26> .withSaslMechanism(OAuthBearerLoginModule.OAUTHBEARER_MECHANISM) <line27> .withSaslLoginCallbackHandlerClass() <line28> .withSharedProperties() <line29> .withSaslJassConfigAndTls( <line30> this.clientId, this.clientSecretName, this.oauthTokenEndpointUri) <line31> .build(); <line32> } <line33> try (Consumer tlsConsumer = <line34> new Consumer(properties, resultPromise, msgCntPredicate, topicName, clientName)) { <line35> tlsConsumer.getVertx().deployVerticle(tlsConsumer); <line36> return tlsConsumer.getResultPromise().get(timeoutMs, TimeUnit.MILLISECONDS); <line37> } catch (InterruptedException | ExecutionException | TimeoutException e) { <line38> e.printStackTrace(); <line39> throw new WaitException(e); <line40> } <line41> } <line42> } <line43> "	info	task5	
"public class A { <line0> @Override <line1> public void stop() { <line2> LOG.UNKNOWN(getIndent() + ""Goodbye from entity {}"", getId()); <line3> StartableMethods.stop(this); <line4> } <line5> } <line6> "	info	task5	
"public class A { <line0> protected void addDefaultConstructor(ClassWriter cw) { <line1> if (DataNucleusEnhancer.LOGGER.isDebugEnabled()) { <line2> DataNucleusEnhancer.LOGGER.UNKNOWN(Localiser.msg(""005020"", pkClassName + ""()"")); <line3> } <line4> MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC, ""<init>"", ""()V"", null, null); <line5> mv.visitCode(); <line6> Label startLabel = new Label(); <line7> mv.visitLabel(startLabel); <line8> mv.visitVarInsn(Opcodes.ALOAD, 0); <line9> mv.visitMethodInsn(Opcodes.INVOKESPECIAL, ""java/lang/Object"", ""<init>"", ""()V"", false); <line10> mv.visitInsn(Opcodes.RETURN); <line11> Label endLabel = new Label(); <line12> mv.visitLabel(endLabel); <line13> mv.visitLocalVariable(""this"", className_DescName, null, startLabel, endLabel, 0); <line14> mv.visitMaxs(1, 1); <line15> mv.visitEnd(); <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Test(dependsOnMethods = {""createJob"", ""getJob""}) <line1> public void canListJobIdsByName() throws IOException { <line2> final String name = String.format(""by_name_%s"", UUID.randomUUID()); <line3> final MantaJob job1 = buildJob(name, ""cat""); <line4> final UUID job1id = createJobAndSkipIfUnsupported(job1); <line5> MantaJob job2 = buildJob(name, ""cat""); <line6> final UUID job2id = createJobAndSkipIfUnsupported(job2); <line7> try (Stream<UUID> jobs = mantaClient.getJobIdsByName(name)) { <line8> List<UUID> found = jobs.collect(Collectors.toList()); <line9> Assert.assertEquals(found.size(), 2, ""We should have found both jobs""); <line10> Assert.assertTrue(found.contains(job1id)); <line11> Assert.assertTrue(found.contains(job2id)); <line12> } catch (AssertionError e) { <line13> String msg = ""Couldn't find job in job list, retry test a few times to verify""; <line14> LOG.UNKNOWN(msg, e); <line15> throw new SkipException(msg, e); <line16> } finally { <line17> mantaClient.cancelJob(job1id); <line18> mantaClient.cancelJob(job2id); <line19> } <line20> } <line21> } <line22> "	error	task5	
"public class A { <line0> public HttpGet constructHttpGet( <line1> String type, String field, String predicate, String value, int start, int limit) <line2> throws URISyntaxException { <line3> if (null == type) { <line4> type = ""publication""; <line5> } <line6> field = SHERPAUtils.sanitiseQuery(field); <line7> predicate = SHERPAUtils.sanitiseQuery(predicate); <line8> value = SHERPAUtils.sanitiseQuery(value); <line9> type = SHERPAUtils.sanitiseQuery(type); <line10> URIBuilder uriBuilder = new URIBuilder(endpoint); <line11> uriBuilder.addParameter(""item-type"", type); <line12> uriBuilder.addParameter( <line13> ""filter"", ""[[\"""" + field + ""\"",\"""" + predicate + ""\"",\"""" + value + ""\""]]""); <line14> uriBuilder.addParameter(""format"", ""Json""); <line15> if (start >= 0) { <line16> uriBuilder.addParameter(""offset"", String.valueOf(start)); <line17> } <line18> if (limit > 0) { <line19> uriBuilder.addParameter(""limit"", String.valueOf(limit)); <line20> } <line21> if (StringUtils.isNotBlank(apiKey)) { <line22> uriBuilder.addParameter(""api-key"", apiKey); <line23> } <line24> log.UNKNOWN(""SHERPA API URL: "" + uriBuilder.toString()); <line25> HttpGet method = new HttpGet(uriBuilder.build()); <line26> int timeout = 5000; <line27> method.setConfig( <line28> RequestConfig.custom() <line29> .setConnectionRequestTimeout(timeout) <line30> .setConnectTimeout(timeout) <line31> .setSocketTimeout(timeout) <line32> .build()); <line33> return method; <line34> } <line35> } <line36> "	debug	task5	
"public class A { <line0> @Override <line1> public void setOnline(boolean didGII, boolean wasAtomicCreation, PersistentMemberID newId) <line2> throws ReplyException { <line3> if (atomicCreation) { <line4> if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR_VERBOSE)) { <line5> logger.UNKNOWN( <line6> LogMarker.PERSIST_ADVISOR_VERBOSE, <line7> ""{}-{}: {} Deferring setOnline until the EndBucketCreation phase for {}"", <line8> shortDiskStoreId(), <line9> regionPath, <line10> regionPath, <line11> newId); <line12> } <line13> } else { <line14> super.setOnline(didGII, wasAtomicCreation, newId); <line15> } <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> void setMomentum(int now) { <line1> try { <line2> if (now == Sensor.ACTIVE) { <line3> programmer.writeCV(""3"", 30, null); <line4> } else { <line5> programmer.writeCV(""3"", 0, null); <line6> } <line7> } catch (JmriException e) { <line8> log.UNKNOWN(""exception setting turnout:{}"", e); <line9> } <line10> } <line11> } <line12> "	error	task5	
"public class A { <line0> public void checkForCriticalError(String migrationInstanceId) throws DatabaseMigrationFailure { <line1> String error = ssm.getSSMCommand(getCommandId(), migrationInstanceId).standardErrorContent(); <line2> if (isCritical(error)) { <line3> logger.UNKNOWN(""Encountered a critical error when performing DB restore: {}"", error); <line4> throw new DatabaseMigrationFailure(error); <line5> } <line6> } <line7> } <line8> "	error	task5	
"public class A { <line0> public int getParamValue(String param, int defaultVal) { <line1> if (params.containsKey(param)) { <line2> try { <line3> return Integer.parseInt(params.get(param)); <line4> } catch (NumberFormatException nfe) { <line5> log.UNKNOWN(""Couldn't parse param value: {} as integer."", param); <line6> } <line7> } <line8> return defaultVal; <line9> } <line10> } <line11> "	warn	task5	
"public class A { <line0> @LifecycleStart <line1> public void start() { <line2> if (!lifecycleLock.canStart()) { <line3> throw new ISE(""can't start.""); <line4> } <line5> try { <line6> listenerExecutor = Execs.singleThreaded(""CuratorDruidNodeDiscoveryProvider-ListenerExecutor""); <line7> log.UNKNOWN(""Started.""); <line8> lifecycleLock.started(); <line9> } finally { <line10> lifecycleLock.exitStart(); <line11> } <line12> } <line13> } <line14> "	debug	task5	
"public class A { <line0> private void loadKeys(char[] masterKey) <line1> throws NoSuchAlgorithmException, CertificateException, IOException { <line2> if (logger.isDebugEnabled()) { <line3> logger.UNKNOWN(""==> RangerKeyStoreProvider.loadKeys()""); <line4> } <line5> dbStore.engineLoad(null, masterKey); <line6> } <line7> } <line8> "	debug	task5	
"public class A { <line0> public void deleteUserProfileType(Properties properties) throws ApiException, Throwable { <line1> try { <line2> String typeCode = properties.getProperty(""typeCode""); <line3> IApsEntity masterProfileType = this.getUserProfileManager().getEntityPrototype(typeCode); <line4> if (null == masterProfileType) { <line5> throw new ApiException( <line6> IApiErrorCodes.API_VALIDATION_ERROR, <line7> ""User Profile type with code '"" + typeCode + ""' doesn't exist""); <line8> } <line9> EntitySearchFilter filter = <line10> new EntitySearchFilter( <line11> IEntityManager.ENTITY_TYPE_CODE_FILTER_KEY, false, typeCode, false); <line12> List<String> profileIds = <line13> this.getUserProfileManager().searchId(new EntitySearchFilter[] {filter}); <line14> if (null != profileIds && !profileIds.isEmpty()) { <line15> throw new ApiException( <line16> IApiErrorCodes.API_VALIDATION_ERROR, <line17> ""User profile type '"" <line18> + typeCode <line19> + ""' are used into "" <line20> + profileIds.size() <line21> + "" profiles""); <line22> } <line23> ((IEntityTypesConfigurer) this.getUserProfileManager()).removeEntityPrototype(typeCode); <line24> } catch (ApiException ae) { <line25> throw ae; <line26> } catch (Throwable t) { <line27> logger.UNKNOWN(""Error deleting user Profile type"", t); <line28> throw new ApsSystemException(""Error deleting user Profile type"", t); <line29> } <line30> } <line31> } <line32> "	error	task5	
"public class A { <line0> private void prepareSignature(SrpServerKeyExchangeMessage msg) { <line1> msg.setSignature(signature); <line2> LOGGER.UNKNOWN(""Signatur: "" + ArrayConverter.bytesToHexString(msg.getSignature().getValue())); <line3> } <line4> } <line5> "	debug	task5	
"public class A { <line0> private static <T> Stream<T> mapToService(ServiceLoader.Provider<T> provider) { <line1> try { <line2> return Stream.of(provider.get()); <line3> } catch (ServiceConfigurationError error) { <line4> LOG.UNKNOWN(""Service Provider failed to load"", error); <line5> return Stream.empty(); <line6> } <line7> } <line8> } <line9> "	warn	task5	
"public class A { <line0> void receivedPublishQos0( <line1> Topic topic, <line2> String username, <line3> String clientID, <line4> ByteBuf payload, <line5> boolean retain, <line6> MqttPublishMessage msg) { <line7> if (!authorizator.canWrite(topic, username, clientID)) { <line8> LOG.UNKNOWN(""client is not authorized to publish on topic: {}"", topic); <line9> return; <line10> } <line11> publish2Subscribers(payload, topic, AT_MOST_ONCE); <line12> if (retain) { <line13> retainedRepository.cleanRetained(topic); <line14> } <line15> interceptor.notifyTopicPublished(msg, clientID, username); <line16> } <line17> } <line18> "	error	task5	
"public class A { <line0> public void submit(final String selectorName, final DivideUpstream divideUpstream) { <line1> if (!Constants.DEFAULT_REGISTER_TYPE.equalsIgnoreCase(registerType)) { <line2> return; <line3> } <line4> if (UPSTREAM_MAP.containsKey(selectorName)) { <line5> List<DivideUpstream> upstreams = <line6> UPSTREAM_MAP.getOrDefault(selectorName, Collections.emptyList()); <line7> Optional<DivideUpstream> exists = <line8> upstreams.stream() <line9> .filter( <line10> item -> <line11> StringUtils.isNotBlank(item.getUpstreamUrl()) <line12> && item.getUpstreamUrl().equals(divideUpstream.getUpstreamUrl())) <line13> .findFirst(); <line14> if (!exists.isPresent()) { <line15> upstreams.add(divideUpstream); <line16> } else { <line17> log.UNKNOWN(""upstream host {} is exists."", divideUpstream.getUpstreamHost()); <line18> } <line19> } else { <line20> UPSTREAM_MAP.put(selectorName, Lists.newArrayList(divideUpstream)); <line21> } <line22> } <line23> } <line24> "	info	task5	
"public class A { <line0> public Landsat8BandConverterSpi getConverter(final String converterName) { <line1> final Landsat8BandConverterSpi converter = getRegisteredConverters().get(converterName); <line2> if (converter == null) { <line3> LOGGER.UNKNOWN(""no landsat8 converter registered with name '"" + converterName + ""'""); <line4> } <line5> return converter; <line6> } <line7> } <line8> "	warn	task5	
"public class A { <line0> @Test <line1> public void testBadVMTransportOptionsBrokerPrefix() throws Exception { <line2> final String vmUri = vmUri(""?broker.XXX=foo&broker.persistent=XXX&broker.useJmx=false""); <line3> LOG.UNKNOWN(""creating context with bad URI: {}"", vmUri); <line4> ActiveMQComponent amq = ActiveMQComponent.activeMQComponent(vmUri); <line5> camelContext = new DefaultCamelContext(); <line6> camelContext.addComponent(""activemq"", amq); <line7> final String queueEndpointName = ""activemq:queuetest.Queue""; <line8> camelContext.addRoutes( <line9> new RouteBuilder() { <line10> @Override <line11> public void configure() { <line12> from(queueEndpointName).bean(Consumer.class, ""consume""); <line13> } <line14> }); <line15> camelContext.start(); <line16> final ProducerTemplate producerTemplate = camelContext.createProducerTemplate(); <line17> assertThrows( <line18> CamelExecutionException.class, <line19> () -> producerTemplate.sendBody(queueEndpointName, ""message""), <line20> ""Should have received an exception from the bad URI.""); <line21> } <line22> } <line23> "	info	task5	
"public class A { <line0> private static void executeSQLScript(Connection con, InputStream resource, Boolean autoreplace) <line1> throws IOException, SQLException { <line2> try (BufferedReader in = new BufferedReader(new InputStreamReader(resource))) { <line3> boolean done = false; <line4> while (!done) { <line5> StringBuilder command = new StringBuilder(); <line6> while (true) { <line7> String line = in.readLine(); <line8> if (line == null) { <line9> done = true; <line10> break; <line11> } <line12> if (isSQLCommandPart(line)) { <line13> command.append(' ').append(line); <line14> } <line15> if (line.trim().endsWith("";"")) { <line16> break; <line17> } <line18> } <line19> if (!done && !command.toString().equals("""")) { <line20> if (DbConnectionManager.getDatabaseType() == DbConnectionManager.DatabaseType.oracle <line21> || DbConnectionManager.getDatabaseType() == DbConnectionManager.DatabaseType.db2) { <line22> command.deleteCharAt(command.length() - 1); <line23> } <line24> Statement stmt = null; <line25> try { <line26> String cmdString = command.toString(); <line27> if (autoreplace) { <line28> cmdString = cmdString.replaceAll(""jiveVersion"", ""ofVersion""); <line29> } <line30> stmt = con.createStatement(); <line31> stmt.execute(cmdString); <line32> } catch (SQLException e) { <line33> Log.UNKNOWN(""SchemaManager: Failed to execute SQL:\n"" + command.toString()); <line34> throw e; <line35> } finally { <line36> DbConnectionManager.closeStatement(stmt); <line37> } <line38> } <line39> } <line40> } <line41> } <line42> } <line43> "	error	task5	
"public class A { <line0> void configureTimeDecoder(YConfiguration config) { <line1> if (config != null) { <line2> useLocalGenerationTime = config.getBoolean(""useLocalGenerationTime"", false); <line3> } <line4> if (!useLocalGenerationTime && config != null && config.containsKey(CONFIG_KEY_TIME_ENCODING)) { <line5> YConfiguration c = config.getConfig(CONFIG_KEY_TIME_ENCODING); <line6> String type = c.getString(""type"", ""CUC""); <line7> if (""CUC"".equals(type)) { <line8> int implicitPField = c.getInt(""implicitPField"", -1); <line9> int implicitPFieldCont = c.getInt(""implicitPFieldCont"", -1); <line10> timeDecoder = new CucTimeDecoder(implicitPField, implicitPFieldCont); <line11> } else { <line12> throw new ConfigurationException( <line13> ""Time encoding of type '"" <line14> + type <line15> + "" not supported. Supported: CUC=CCSDS unsegmented time""); <line16> } <line17> timeEpoch = c.getEnum(""epoch"", TimeEpochs.class, TimeEpochs.GPS); <line18> if (timeEpoch == TimeEpochs.CUSTOM) { <line19> customEpochIncludeLeapSecond = c.getBoolean(""timeIncludesLeapSeconds"", true); <line20> String epochs = c.getString(""epochUTC""); <line21> customEpoch = TimeEncoding.parse(epochs); <line22> if (!customEpochIncludeLeapSecond) { <line23> customEpoch = TimeEncoding.toUnixMillisec(customEpoch); <line24> } <line25> } <line26> } else { <line27> timeEpoch = TimeEpochs.GPS; <line28> timeDecoder = new CucTimeDecoder(-1); <line29> } <line30> log.UNKNOWN(""Using time decoder {}"", timeDecoder); <line31> } <line32> } <line33> "	debug	task5	
public class A { <line0> protected WorkflowDefinition getLatestWorkflowDefinition(long companyId, String name) { <line1> try { <line2> return unproxiedWorkflowDefinitionManager.getLatestWorkflowDefinition(companyId, name); <line3> } catch (WorkflowException workflowException) { <line4> if (log.isDebugEnabled()) { <line5> log.UNKNOWN(workflowException, workflowException); <line6> } <line7> return null; <line8> } <line9> } <line10> } <line11> 	debug	task5	
"public class A { <line0> @Override <line1> public void init(FtpletContext ftpletContext) { <line2> if (log.isDebugEnabled()) { <line3> log.UNKNOWN( <line4> String.format( <line5> ""Total FTP logins: %s"", ftpletContext.getFtpStatistics().getTotalLoginNumber())); <line6> } <line7> } <line8> } <line9> "	debug	task5	
"public class A { <line0> @Test <line1> public void getAllBeansTest() { <line2> ConfigurableListableBeanFactory beanFactory = abstractApplicationContext.getBeanFactory(); <line3> for (String name : abstractApplicationContext.getBeanDefinitionNames()) { <line4> Object bean = beanFactory.getBean(name); <line5> log.UNKNOWN(""Bean class name: "" + bean.getClass().getName()); <line6> } <line7> } <line8> } <line9> "	info	task5	
"public class A { <line0> public void coupleMbusDeviceByChannel( <line1> final DeviceMessageMetadata deviceMessageMetadata, <line2> final CoupleMbusDeviceByChannelRequestData requestData) <line3> throws FunctionalException { <line4> final String deviceIdentification = deviceMessageMetadata.getDeviceIdentification(); <line5> log.UNKNOWN( <line6> ""getMBusDeviceOnChannel for organizationIdentification: {} for gateway: {}"", <line7> deviceMessageMetadata.getOrganisationIdentification(), <line8> deviceIdentification); <line9> final CoupleMbusDeviceByChannelRequestDataDto requestDataDto = <line10> new CoupleMbusDeviceByChannelRequestDataDto(requestData.getChannel()); <line11> final SmartMeter gatewayDevice = this.domainHelperService.findSmartMeter(deviceIdentification); <line12> final RequestMessage requestMessage = <line13> new RequestMessage( <line14> deviceMessageMetadata.getCorrelationUid(), <line15> deviceMessageMetadata.getOrganisationIdentification(), <line16> deviceMessageMetadata.getDeviceIdentification(), <line17> gatewayDevice.getIpAddress(), <line18> requestDataDto); <line19> this.osgpCoreRequestMessageSender.send( <line20> requestMessage, <line21> deviceMessageMetadata.getMessageType(), <line22> deviceMessageMetadata.getMessagePriority(), <line23> deviceMessageMetadata.getScheduleTime(), <line24> deviceMessageMetadata.bypassRetry()); <line25> } <line26> } <line27> "	debug	task5	
"public class A { <line0> @Override <line1> public MetricQueryResult getMetrics(List<String> expressions, long relativeTo) { <line2> requireNotDisposed(); <line3> SystemAssert.requireArgument( <line4> MetricReader.isValid(expressions), ""Illegal metric expression found: "" + expressions); <line5> final long start = System.currentTimeMillis(); <line6> MetricReader<Metric> reader = _metricReaderProviderForMetrics.get(); <line7> MetricQueryResult queryResult = new MetricQueryResult(); <line8> try { <line9> for (String expression : expressions) { <line10> logger.UNKNOWN(""Reading metric for expression {}"", expression); <line11> QueryContextHolder currCtxHolder = new QueryContextHolder(); <line12> reader.parse(expression, relativeTo, Metric.class, currCtxHolder, true); <line13> _queryProcessor.mergeQueryResults( <line14> queryResult, <line15> _queryProcessor.evaluateQuery(currCtxHolder.getCurrentQueryContext(), relativeTo)); <line16> } <line17> } catch (ParseException ex) { <line18> throw new SystemException(""Failed to parse the given expression"", ex); <line19> } <line20> List<Metric> metrics = queryResult.getMetricsList(); <line21> if (metrics != null) { <line22> Iterator<Metric> metricIterator = metrics.iterator(); <line23> while (metricIterator.hasNext()) { <line24> Metric metric = metricIterator.next(); <line25> if (metric.getDatapoints() == null || metric.getDatapoints().size() == 0) { <line26> metricIterator.remove(); <line27> } else if (metric.getDatapoints().values().contains(Double.MIN_VALUE)) { <line28> metric.setDatapoints(setMinValuesToZero(metric.getDatapoints())); <line29> } <line30> } <line31> queryResult.setMetricsList(metrics); <line32> } <line33> _monitorService.modifyCounter( <line34> Counter.DATAPOINT_READS, _getDatapointsAcrossMetrics(queryResult.getMetricsList()), null); <line35> queryResult.setExpandedTimeSeriesRange( <line36> QueryTimeSeriesExpansion.getExpandedTimeSeriesRange(queryResult.getNumTSDBResults())); <line37> queryResult.setQueryStartTimeWindow( <line38> QueryStartTimeWindow.getWindow(relativeTo - queryResult.getQueryStartTimeMillis())); <line39> queryResult.setQueryTimeWindow( <line40> QueryTimeWindow.getWindow(queryResult.getQueryTimeRangeInMillis())); <line41> final long time = System.currentTimeMillis() - start; <line42> _monitorService.modifyCounter(Counter.METRICS_GETMETRICS_LATENCY, time, null); <line43> _monitorService.modifyCounter(Counter.METRICS_GETMETRICS_COUNT, expressions.size(), null); <line44> return queryResult; <line45> } <line46> } <line47> "	debug	task5	
"public class A { <line0> Group delete(Group group, String key, String value) throws FinderException, RemoveException { <line1> LdapConnection ld = null; <line2> String nodeDn = getDn(group.getName(), group.getContextId()); <line3> try { <line4> LOG.UNKNOWN(""delete group property dn [{}], key [{}], value [{}]"", nodeDn, key, value); <line5> List<Modification> mods = new ArrayList<Modification>(); <line6> mods.add( <line7> new DefaultModification( <line8> ModificationOperation.REMOVE_ATTRIBUTE, GROUP_PROPERTY_ATTR_IMPL, key + ""="" + value)); <line9> ld = getAdminConnection(); <line10> modify(ld, nodeDn, mods, group); <line11> } catch (LdapException e) { <line12> String error = ""delete group property node dn ["" + nodeDn + ""] caught LDAPException="" + e; <line13> throw new RemoveException(GlobalErrIds.GROUP_DELETE_PROPERTY_FAILED, error, e); <line14> } finally { <line15> closeAdminConnection(ld); <line16> } <line17> return get(group); <line18> } <line19> } <line20> "	debug	task5	
"public class A { <line0> public static void addURL(URL url) throws IOException { <line1> URLClassLoader sysLoader = (URLClassLoader) ClassLoader.getSystemClassLoader(); <line2> URL urls[] = sysLoader.getURLs(); <line3> for (int i = 0; i < urls.length; i++) { <line4> if (StringUtils.equalsIgnoreCase(urls[i].toString(), url.toString())) { <line5> LOGGER.UNKNOWN(""URL {} is already in the CLASSPATH"", url); <line6> return; <line7> } <line8> } <line9> try { <line10> Method method = URLClassLoader.class.getDeclaredMethod(""addURL"", PARAMETERS); <line11> method.setAccessible(true); <line12> method.invoke(sysLoader, new Object[] {url}); <line13> } catch (Throwable t) { <line14> throw new IOException(""Error, could not add URL to system classloader"", t); <line15> } <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> protected boolean retryCausedOnServerlessDB(Exception e) { <line1> if (e instanceof SQLException <line2> && ((SQLException) e).getSQLState() != null <line3> && (((SQLException) e).getSQLState().equalsIgnoreCase(""57014"") <line4> || ((SQLException) e).getSQLState().equalsIgnoreCase(""57P01"") <line5> || ((SQLException) e).getSQLState().equalsIgnoreCase(""08003"") <line6> || ((SQLException) e).getSQLState().equalsIgnoreCase(""08006""))) { <line7> int remainingSeconds = context.getRemainingTimeInMillis() / 1000; <line8> if (!isRemainingTimeSufficient(remainingSeconds)) { <line9> return false; <line10> } <line11> if (!retryAttempted) { <line12> logger.UNKNOWN( <line13> ""{} Retry based on serverless scaling detected! RemainingTime: {} {}"", <line14> traceItem, <line15> remainingSeconds, <line16> e); <line17> return true; <line18> } <line19> } <line20> return false; <line21> } <line22> } <line23> "	warn	task5	
"public class A { <line0> @Override <line1> public void update(ScriptResult scriptResult) { <line2> LOGGER.UNKNOWN( <line3> MessageFormat.format( <line4> ""Updating ScriptResult {0}."", scriptResult.getMetadataKey().toString())); <line5> getMetadataRepository() <line6> .executeUpdate( <line7> String.format( <line8> UPDATE_QUERY, <line9> SQLTools.getStringForSQL(scriptResult.getParentProcessId()), <line10> SQLTools.getStringForSQL(scriptResult.getScriptId()), <line11> SQLTools.getStringForSQL(scriptResult.getScriptName()), <line12> SQLTools.getStringForSQL(scriptResult.getScriptVersion()), <line13> SQLTools.getStringForSQL(scriptResult.getSecurityGroupName()), <line14> SQLTools.getStringForSQL(scriptResult.getEnvironment()), <line15> SQLTools.getStringForSQL(scriptResult.getStatus().value()), <line16> SQLTools.getStringForSQL(scriptResult.getStartTimestamp()), <line17> SQLTools.getStringForSQL(scriptResult.getEndTimestamp()), <line18> SQLTools.getStringForSQL(scriptResult.getMetadataKey().getRunId()), <line19> SQLTools.getStringForSQL(scriptResult.getMetadataKey().getProcessId()))); <line20> } <line21> } <line22> "	trace	task5	
"public class A { <line0> @Override <line1> public void onCommandFailure(final Throwable e) { <line2> Log.UNKNOWN(""[init] Error while getting the users list for the local cache."", e); <line3> users.set(null); <line4> } <line5> } <line6> "	error	task5	
"public class A { <line0> @Override <line1> public Iterable<String> findRelatedEdgeIds( <line2> Iterable<String> vertexIds, Long endTime, Authorizations authorizations) { <line3> Set<String> vertexIdsSet = IterableUtils.toSet(vertexIds); <line4> Span trace = Trace.start(""findRelatedEdges""); <line5> try { <line6> if (LOGGER.isTraceEnabled()) { <line7> LOGGER.UNKNOWN(""findRelatedEdges:\n  %s"", IterableUtils.join(vertexIdsSet, ""\n  "")); <line8> } <line9> if (vertexIdsSet.size() == 0) { <line10> return new HashSet<>(); <line11> } <line12> List<org.apache.accumulo.core.data.Range> ranges = new ArrayList<>(); <line13> for (String vertexId : vertexIdsSet) { <line14> ranges.add(RangeUtils.createRangeFromString(vertexId)); <line15> } <line16> Long startTime = null; <line17> int maxVersions = 1; <line18> FetchHints fetchHints = FetchHints.builder().setIncludeOutEdgeRefs(true).build(); <line19> ScannerBase scanner = <line20> createElementScanner( <line21> fetchHints, <line22> ElementType.VERTEX, <line23> maxVersions, <line24> startTime, <line25> endTime, <line26> ranges, <line27> false, <line28> authorizations); <line29> IteratorSetting edgeRefFilterSettings = <line30> new IteratorSetting(1000, EdgeRefFilter.class.getSimpleName(), EdgeRefFilter.class); <line31> EdgeRefFilter.setVertexIds(edgeRefFilterSettings, vertexIdsSet); <line32> scanner.addScanIterator(edgeRefFilterSettings); <line33> IteratorSetting vertexEdgeIdIteratorSettings = <line34> new IteratorSetting( <line35> 1001, VertexEdgeIdIterator.class.getSimpleName(), VertexEdgeIdIterator.class); <line36> scanner.addScanIterator(vertexEdgeIdIteratorSettings); <line37> final long timerStartTime = System.currentTimeMillis(); <line38> try { <line39> Iterator<Map.Entry<Key, Value>> it = scanner.iterator(); <line40> List<String> edgeIds = new ArrayList<>(); <line41> while (it.hasNext()) { <line42> Map.Entry<Key, Value> c = it.next(); <line43> for (ByteArrayWrapper edgeId : VertexEdgeIdIterator.decodeValue(c.getValue())) { <line44> edgeIds.add(new Text(edgeId.getData()).toString()); <line45> } <line46> } <line47> return edgeIds; <line48> } finally { <line49> scanner.close(); <line50> GRAPHlogger.logEndIterator(System.currentTimeMillis() - timerStartTime); <line51> } <line52> } finally { <line53> trace.stop(); <line54> } <line55> } <line56> } <line57> "	trace	task5	
"public class A { <line0> @Override <line1> public void doFilterWriteListeners(final WriteRequest writeRequest) { <line2> final Object message = writeRequest.getMessage(); <line3> WriteRequest originalRequest = writeRequest.getOriginalRequest(); <line4> final Object originalMessage = originalRequest != null ? originalRequest.getMessage() : null; <line5> runManagementTask( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> try { <line10> List<SessionManagementListener> sessionListeners = getManagementListeners(); <line11> for (final SessionManagementListener listener : sessionListeners) { <line12> listener.doFilterWrite(SessionManagementBeanImpl.this, message, originalMessage); <line13> } <line14> markChanged(); <line15> } catch (Exception ex) { <line16> logger.UNKNOWN(""Error during doFilterWrite session listener notifications:"", ex); <line17> } <line18> } <line19> }); <line20> } <line21> } <line22> "	warn	task5	
"public class A { <line0> @Override <line1> public void disconnect() { <line2> if (reconnectedCoreSession != null) { <line3> reconnectedCoreSession.close(); <line4> } <line5> reconnectedCoreSession = null; <line6> reconnectedEvents = null; <line7> if (loginCtx != null) { <line8> try { <line9> loginCtx.logout(); <line10> } catch (LoginException e) { <line11> log.UNKNOWN(""Cannot log out"", e); <line12> } finally { <line13> loginCtx = null; <line14> } <line15> } <line16> } <line17> } <line18> "	error	task5	
"public class A { <line0> public boolean shouldUse() { <line1> log.UNKNOWN(""checking hqdb dir exists: "" + serverHome + ""/hqdb""); <line2> return new File(serverHome + ""/hqdb"").exists(); <line3> } <line4> } <line5> "	debug	task5	
"public class A { <line0> public static com.liferay.knowledge.base.model.KBArticleSearchDisplay getKBArticleSearchDisplay( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String title, <line4> String content, <line5> int status, <line6> java.util.Date startDate, <line7> java.util.Date endDate, <line8> boolean andOperator, <line9> int[] curStartValues, <line10> int cur, <line11> int delta, <line12> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.knowledge.base.model.KBArticle> <line13> orderByComparator) <line14> throws com.liferay.portal.kernel.exception.PortalException { <line15> try { <line16> MethodKey methodKey = <line17> new MethodKey( <line18> KBArticleServiceUtil.class, <line19> ""getKBArticleSearchDisplay"", <line20> _getKBArticleSearchDisplayParameterTypes23); <line21> MethodHandler methodHandler = <line22> new MethodHandler( <line23> methodKey, <line24> groupId, <line25> title, <line26> content, <line27> status, <line28> startDate, <line29> endDate, <line30> andOperator, <line31> curStartValues, <line32> cur, <line33> delta, <line34> orderByComparator); <line35> Object returnObj = null; <line36> try { <line37> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line38> } catch (Exception exception) { <line39> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line40> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line41> } <line42> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line43> } <line44> return (com.liferay.knowledge.base.model.KBArticleSearchDisplay) returnObj; <line45> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line46> log.UNKNOWN(systemException, systemException); <line47> throw systemException; <line48> } <line49> } <line50> } <line51> "	error	task5	
"public class A { <line0> private void routeSuggestionReplyReceived( <line1> TacticalRouteSuggestionReply message, Timestamp timestamp) { <line2> LOG.UNKNOWN(""Route suggestion reply received for ID "" + message.getId()); <line3> if (routeSuggestions.containsKey(message.getId())) { <line4> RouteSuggestionData routeData = routeSuggestions.get(message.getId()); <line5> Date date = new Date(timestamp.getTime()); <line6> routeData.setReply(message, date); <line7> routeData.setReplyRecieveDate(new Date()); <line8> routeData.setAcknowleged(false); <line9> notifyRouteSuggestionListeners(); <line10> } <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> protected void onEntityAdded(Entity item) { <line1> synchronized (memberChangeMutex) { <line2> if (acceptsEntity(item)) { <line3> if (log.isDebugEnabled()) log.UNKNOWN(""{} detected item add {}"", this, item); <line4> addMember(item); <line5> } <line6> } <line7> } <line8> } <line9> "	debug	task5	
"public class A { <line0> public ActionForward patientCPPSave( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) <line5> throws Exception { <line6> logger.UNKNOWN(""patientCPPSave""); <line7> LoggedInInfo loggedInInfo = LoggedInInfo.getLoggedInInfoFromSession(request); <line8> String providerNo = loggedInInfo.getLoggedInProviderNo(); <line9> CaseManagementViewFormBean caseForm = (CaseManagementViewFormBean) form; <line10> CaseManagementCPP cpp = caseForm.getCpp(); <line11> cpp.setUpdate_date(new Date()); <line12> cpp.setDemographic_no(caseForm.getDemographicNo()); <line13> caseManagementMgr.saveCPP(cpp, providerNo); <line14> addMessage(request, ""cpp.saved""); <line15> return view(mapping, form, request, response); <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Override <line1> public void start() { <line2> doStart(); <line3> logger.UNKNOWN(""start called""); <line4> } <line5> } <line6> "	debug	task5	
public class A { <line0> private void activateSources() { <line1> for (KMLDataSource dataSource : myConfig.getKMLSourceList()) { <line2> if (dataSource.isActive()) { <line3> dataSource.getDataGroupInfo().activationProperty().setActive(true); <line4> try { <line5> activateSource(dataSource); <line6> } catch (DataGroupActivationException e) { <line7> LOGGER.UNKNOWN(e, e); <line8> } <line9> } <line10> } <line11> } <line12> } <line13> 	error	task5	
"public class A { <line0> @Path(""/transactions/prune/regions"") <line1> @GET <line2> public void getTimeRegions( <line3> HttpRequest request, <line4> HttpResponder responder, <line5> @QueryParam(""time"") @DefaultValue(""now"") String time) { <line6> try { <line7> if (!initializePruningDebug(responder)) { <line8> return; <line9> } <line10> RegionsAtTime timeRegionInfo = pruningDebug.getRegionsOnOrBeforeTime(time); <line11> responder.sendJson(HttpResponseStatus.OK, GSON.toJson(timeRegionInfo)); <line12> } catch (Exception e) { <line13> responder.sendString(HttpResponseStatus.BAD_REQUEST, e.getMessage()); <line14> LOG.UNKNOWN(""Exception while trying to fetch the time region."", e); <line15> } <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Test(timeout = 20000) <line1> public void testCloseSessionTimesOut() throws Exception { <line2> try (TestAmqpPeer testPeer = new TestAmqpPeer(); ) { <line3> JmsConnection connection = (JmsConnection) testFixture.establishConnecton(testPeer); <line4> connection.setCloseTimeout(500); <line5> testPeer.expectBegin(); <line6> testPeer.expectEnd(false); <line7> testPeer.expectClose(); <line8> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line9> assertNotNull(""Session should not be null"", session); <line10> try { <line11> session.close(); <line12> fail(""Should have thrown an timed out exception""); <line13> } catch (JmsOperationTimedOutException jmsEx) { <line14> LOG.UNKNOWN(""Caught exception: {}"", jmsEx.getMessage()); <line15> } <line16> connection.close(); <line17> testPeer.waitForAllHandlersToComplete(1000); <line18> } <line19> } <line20> } <line21> "	info	task5	
"public class A { <line0> public void addImplementsHostInterface( <line1> TypeSpec host, ClassName hostInterfaceName, Map<TypeSpec, TypeSpec> changes) { <line2> TypeSpec currentHost = changes.get(host); <line3> if (currentHost == null) { <line4> currentHost = host; <line5> } <line6> TypeSpec.Builder modifyingBuilder = currentHost.toBuilder(); <line7> logger.UNKNOWN(""adding accept(visitor) methods to {}"", host.name); <line8> modifyingBuilder.addSuperinterface(hostInterfaceName); <line9> changes.put(host, modifyingBuilder.build()); <line10> } <line11> } <line12> "	debug	task5	
"public class A { <line0> protected Opt<DublinCoreCatalog> loadDublinCoreCatalog(String seriesId) { <line1> try { <line2> Opt<byte[]> seriesElementData = <line3> getSeriesService().getSeriesElementData(requireNonNull(seriesId), flavor.getType()); <line4> if (seriesElementData.isSome()) { <line5> final DublinCoreCatalog dc = DublinCoreByteFormat.read(seriesElementData.get()); <line6> dc.setFlavor(flavor); <line7> dc.addBindings(config.getXmlNamespaceContext()); <line8> return Opt.some(dc); <line9> } else { <line10> final DublinCoreCatalog dc = DublinCores.mkStandard(); <line11> dc.addBindings(config.getXmlNamespaceContext()); <line12> dc.setRootTag( <line13> new EName(config.getCatalogXmlRootNamespace(), config.getCatalogXmlRootElementName())); <line14> dc.setFlavor(flavor); <line15> return Opt.some(dc); <line16> } <line17> } catch (SeriesException e) { <line18> logger.UNKNOWN(""Error while loading DublinCore catalog of series '{}': {}"", seriesId, e); <line19> return Opt.none(); <line20> } <line21> } <line22> } <line23> "	error	task5	
"public class A { <line0> @Override <line1> public void visitCommander(Commander commander) { <line2> LOGGER.UNKNOWN(""Good to see you {}"", commander); <line3> } <line4> } <line5> "	info	task5	
public class A { <line0> @Override <line1> @Transactional(readOnly = true) <line2> public MetadataVersion getCurrentVersion() { <line3> try { <line4> return versionStore.getCurrentVersion(); <line5> } catch (Exception ex) { <line6> log.UNKNOWN(ex.getMessage(), ex); <line7> throw new MetadataVersionServiceException(ex.getMessage(), ex); <line8> } <line9> } <line10> } <line11> 	error	task5	
"public class A { <line0> public static void updateFileEntryType( <line1> HttpPrincipal httpPrincipal, <line2> long fileEntryTypeId, <line3> String name, <line4> String description, <line5> long[] ddmStructureIds, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> DLFileEntryTypeServiceUtil.class, <line12> ""updateFileEntryType"", <line13> _updateFileEntryTypeParameterTypes17); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, fileEntryTypeId, name, description, ddmStructureIds, serviceContext); <line17> try { <line18> TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> log.UNKNOWN(systemException, systemException); <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	error	task5	
"public class A { <line0> private void createSearchLogCondition(final SearchLogPager pager, final SearchLogCB cb) { <line1> if (StringUtil.isNotBlank(pager.queryId)) { <line2> cb.query().setQueryId_Term(pager.queryId); <line3> } <line4> if (StringUtil.isNotBlank(pager.userSessionId)) { <line5> cb.query().setUserSessionId_Term(pager.userSessionId); <line6> } <line7> if (StringUtil.isNotBlank(pager.accessType)) { <line8> cb.query().setAccessType_Term(pager.accessType); <line9> } <line10> if (StringUtil.isNotBlank(pager.requestedTimeRange)) { <line11> final String[] values = pager.requestedTimeRange.split("" - ""); <line12> final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(YYYY_MM_DD_HH_MM); <line13> try { <line14> if (values.length > 0) { <line15> cb.query().setRequestedAt_GreaterEqual(parseDateTime(values[0], formatter)); <line16> } <line17> if (values.length > 1) { <line18> cb.query().setRequestedAt_LessEqual(LocalDateTime.parse(values[1], formatter)); <line19> } <line20> } catch (final Exception e) { <line21> if (logger.isDebugEnabled()) { <line22> logger.UNKNOWN(""Failed to parse {}"", pager.requestedTimeRange, e); <line23> } <line24> } <line25> } <line26> } <line27> } <line28> "	debug	task5	
"public class A { <line0> @POST <line1> public Result setup(Stack stack) { <line2> LOG.UNKNOWN(""Calling setup""); <line3> return new BaseResult(ENDPOINT_URL, true, ""Setup called"", State.READY); <line4> } <line5> } <line6> "	warn	task5	
"public class A { <line0> private void processWmsState(OGCServiceStateEvent event) { <line1> LOGGER.UNKNOWN( <line2> StringUtilities.formatTimingMessage( <line3> mySource.getName() + "" WMS Response took "", System.nanoTime() - myStartedTime)); <line4> myWmsWaiting = false; <line5> if (event.getState() == State.COMPLETED) { <line6> myWmsSuccess = true; <line7> myWmsLayers = event.getLayerTree(); <line8> if (isComplete()) { <line9> sendResponseAndCleanup(null); <line10> } <line11> } else { <line12> StringBuilder sb = new StringBuilder(""Error initializing WMS server: ""); <line13> sb.append(mySource.getName()); <line14> if (StringUtils.isNotEmpty(event.getError())) { <line15> sb.append(""\n\n"").append(event.getError()); <line16> } <line17> sendResponseAndCleanup(sb.toString()); <line18> } <line19> } <line20> } <line21> "	info	task5	
"public class A { <line0> public static com.liferay.commerce.bom.model.CommerceBOMFolder updateCommerceBOMFolder( <line1> HttpPrincipal httpPrincipal, <line2> long commerceBOMFolderId, <line3> String name, <line4> boolean logo, <line5> byte[] logoBytes) <line6> throws com.liferay.portal.kernel.exception.PortalException { <line7> try { <line8> MethodKey methodKey = <line9> new MethodKey( <line10> CommerceBOMFolderServiceUtil.class, <line11> ""updateCommerceBOMFolder"", <line12> _updateCommerceBOMFolderParameterTypes7); <line13> MethodHandler methodHandler = <line14> new MethodHandler(methodKey, commerceBOMFolderId, name, logo, logoBytes); <line15> Object returnObj = null; <line16> try { <line17> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line18> } catch (Exception exception) { <line19> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line20> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line21> } <line22> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line23> } <line24> return (com.liferay.commerce.bom.model.CommerceBOMFolder) returnObj; <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> log.UNKNOWN(systemException, systemException); <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	error	task5	
public class A { <line0> public static void deleteAssetCategoryCPDefinition( <line1> long cpDefinitionId, <line2> long categoryId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws RemoteException { <line5> try { <line6> CPDefinitionServiceUtil.deleteAssetCategoryCPDefinition( <line7> cpDefinitionId, categoryId, serviceContext); <line8> } catch (Exception exception) { <line9> log.UNKNOWN(exception, exception); <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	error	task5	
"public class A { <line0> protected void deleteLayoutTypeSettingsColumnKeyWithoutValue() throws Exception { <line1> IndexableActionableDynamicQuery indexableActionableDynamicQuery = <line2> LayoutLocalServiceUtil.getIndexableActionableDynamicQuery(); <line3> indexableActionableDynamicQuery.setAddCriteriaMethod( <line4> dynamicQuery -> { <line5> Disjunction disjunction = RestrictionsFactoryUtil.disjunction(); <line6> Property typeSettingsProperty = PropertyFactoryUtil.forName(""typeSettings""); <line7> disjunction.add( <line8> typeSettingsProperty.like(""%"" + LayoutTypePortletConstants.COLUMN_PREFIX + ""%=,%"")); <line9> disjunction.add( <line10> typeSettingsProperty.like( <line11> ""%"" + LayoutTypePortletConstants.NESTED_COLUMN_IDS + ""%=,%"")); <line12> dynamicQuery.add(disjunction); <line13> }); <line14> indexableActionableDynamicQuery.setParallel(true); <line15> indexableActionableDynamicQuery.setPerformActionMethod( <line16> (Layout layout) -> { <line17> try { <line18> UnicodeProperties oldtypeSettingsUnicodeProperties = layout.getTypeSettingsProperties(); <line19> UnicodeProperties newTypeSettingsUnicodeProperties = <line20> getNewTypeSettingsUnicodeProperties(layout.getTypeSettingsProperties()); <line21> if (!oldtypeSettingsUnicodeProperties.equals(newTypeSettingsUnicodeProperties)) { <line22> updateLayout(layout.getPlid(), newTypeSettingsUnicodeProperties.toString()); <line23> } <line24> } catch (Exception exception) { <line25> if (log.isWarnEnabled()) { <line26> log.UNKNOWN(""Unable to update layout "" + layout.getPlid(), exception); <line27> } <line28> } <line29> }); <line30> indexableActionableDynamicQuery.performActions(); <line31> } <line32> } <line33> "	warn	task5	
"public class A { <line0> private void actionBrowse() { <line1> try { <line2> Desktop.getDesktop().browse(URI.create(""http://localhost:"" + port)); <line3> } catch (IOException e) { <line4> log.UNKNOWN(""Unable to open browser"", e); <line5> } <line6> } <line7> } <line8> "	error	task5	
"public class A { <line0> private void addBasicParameters(TestExecutionBuilder testExecutionBuilder, Report report) { <line1> testExecutionBuilder.parameter(""exec.config"", report.getConfiguration().name); <line2> testExecutionBuilder.parameter(""exec.jenkins_build_url"", jenkinsBuildUrl); <line3> testExecutionBuilder.parameter(""exec.jenkins_build_number"", jenkinsBuild); <line4> if (buildParams != null) { <line5> for (Map.Entry<String, String> buildParam : buildParams.entrySet()) { <line6> testExecutionBuilder.parameter(buildParam.getKey(), buildParam.getValue()); <line7> } <line8> } <line9> if (buildParamsFile != null) { <line10> Properties paramsFromFile = new Properties(); <line11> try (FileInputStream fileInputStream = new FileInputStream(buildParamsFile)) { <line12> paramsFromFile.load(fileInputStream); <line13> } catch (IOException e) { <line14> log.UNKNOWN(""Error while loading build parameters from file"", e); <line15> } <line16> for (Map.Entry<Object, Object> entry : paramsFromFile.entrySet()) { <line17> testExecutionBuilder.parameter((String) entry.getKey(), (String) entry.getValue()); <line18> } <line19> } <line20> } <line21> } <line22> "	warn	task5	
"public class A { <line0> public void start() { <line1> LOGGER.UNKNOWN(""starting realtime segments manager, adding a listener on the property store root""); <line2> this.pinotClusterManager.getPropertyStore().subscribe(""/"", this); <line3> } <line4> } <line5> "	info	task5	
"public class A { <line0> @Override <line1> public boolean setLastModified(final long time) { <line2> try { <line3> Files.setLastModifiedTime(m_path, FileTime.fromMillis(time)); <line4> return true; <line5> } catch (final IOException ex) { <line6> LOGGER.UNKNOWN( <line7> ""Could not set last modified time of  '"" <line8> + m_path <line9> + ""': "" <line10> + ExceptionUtil.getDeepestErrorMessage(ex, false)); <line11> return false; <line12> } <line13> } <line14> } <line15> "	warn	task5	
"public class A { <line0> @Test <line1> public void testRandomAssignment() throws Exception { <line2> for (int i = 1; i != 5; ++i) { <line3> LOG.UNKNOWN(""run testRandomAssignment() with idle servers:"" + i); <line4> testRandomAssignment(i); <line5> } <line6> } <line7> } <line8> "	info	task5	
"public class A { <line0> public static void reset() { <line1> logger.UNKNOWN(""Resetting.""); <line2> allAwake = false; <line3> sleeping.clear(); <line4> } <line5> } <line6> "	debug	task5	
"public class A { <line0> @Override <line1> public ValueResult getValues(ParameterizedElementDeclaration component, String providerName) { <line2> try { <line3> return withInternalDeclarationSession( <line4> ""getValues()"", session -> session.getValues(component, providerName)); <line5> } catch (Throwable t) { <line6> LOGGER.UNKNOWN( <line7> format( <line8> ""Error while resolving values on component: '%s:%s' for providerName: '%s'"", <line9> component.getDeclaringExtension(), component.getName(), providerName), <line10> t); <line11> throw t; <line12> } <line13> } <line14> } <line15> "	error	task5	
"public class A { <line0> @Override <line1> public InputStream getStream() throws DataStoreException { <line2> File cached = null; <line3> try { <line4> cached = store.cache.get(getIdentifier().toString()); <line5> } catch (final Exception e) { <line6> LOG.UNKNOWN(""Error retrieving from cache "" + getIdentifier(), e); <line7> } <line8> try { <line9> if (cached == null || !cached.exists()) { <line10> InputStream in = null; <line11> try { <line12> TransientFileFactory fileFactory = TransientFileFactory.getInstance(); <line13> File tmpFile = fileFactory.createTransientFile(""temp0cache"", null, temp); <line14> in = backend.getRecord(getIdentifier()).getStream(); <line15> copyInputStreamToFile(in, tmpFile); <line16> return new LazyFileInputStream(tmpFile); <line17> } finally { <line18> Closeables.close(in, false); <line19> } <line20> } else { <line21> return new FileInputStream(cached); <line22> } <line23> } catch (final Exception e) { <line24> throw new DataStoreException( <line25> ""Error opening input stream for identifier "" + getIdentifier(), e); <line26> } <line27> } <line28> } <line29> "	debug	task5	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> reporter.report(); <line4> } catch (Throwable t) { <line5> LOG.UNKNOWN(""Error while reporting metrics"", t); <line6> } <line7> } <line8> } <line9> "	warn	task5	
"public class A { <line0> private NhinTargetSystemType getLocalHCIDNhinTarget() { <line1> String hcid = null; <line2> try { <line3> hcid = <line4> PropertyAccessor.getInstance() <line5> .getProperty( <line6> NhincConstants.GATEWAY_PROPERTY_FILE, NhincConstants.HOME_COMMUNITY_ID_PROPERTY); <line7> } catch (PropertyAccessException ex) { <line8> LOG.UNKNOWN( <line9> ""Exception while reading local hcid from "" <line10> + NhincConstants.GATEWAY_PROPERTY_FILE <line11> + ex.getLocalizedMessage(), <line12> ex); <line13> } <line14> return convertToNhinTarget(hcid); <line15> } <line16> } <line17> "	error	task5	
"public class A { <line0> public double getLastTime() { <line1> if (startTime == -1 || stopTime == -1) { <line2> return -1; <line3> } <line4> if (stopTime - startTime == 0) { <line5> log.UNKNOWN( <line6> ""Zero time measured! PerfCake is probably running on a machine where the internal timer"" <line7> + "" does not provide enough resolution (e.g. a virtual machine). Please refer to the"" <line8> + "" Troubleshooting section in the User Guide.\n"" <line9> + ""Current measurement unit: "" <line10> + this.toString()); <line11> } <line12> return (stopTime - startTime) / 1_000_000d; <line13> } <line14> } <line15> "	warn	task5	
"public class A { <line0> public boolean checkFlows( <line1> Network network, ValidationConfig config, ValidationWriter flowsWriter) { <line2> Objects.requireNonNull(network); <line3> Objects.requireNonNull(config); <line4> Objects.requireNonNull(flowsWriter); <line5> LOGGER.UNKNOWN(""Checking flows of network {}"", network.getId()); <line6> boolean linesValidated = <line7> network <line8> .getLineStream() <line9> .sorted(Comparator.comparing(Line::getId)) <line10> .map(l -> checkFlows(l, config, flowsWriter)) <line11> .reduce(Boolean::logicalAnd) <line12> .orElse(true); <line13> boolean transformersValidated = <line14> network <line15> .getTwoWindingsTransformerStream() <line16> .sorted(Comparator.comparing(TwoWindingsTransformer::getId)) <line17> .map(t -> checkFlows(t, config, flowsWriter)) <line18> .reduce(Boolean::logicalAnd) <line19> .orElse(true); <line20> return linesValidated && transformersValidated; <line21> } <line22> } <line23> "	info	task5	
public class A { <line0> public static CalendarView get(String viewName) { <line1> try { <line2> return CalendarView.valueOf(viewName); <line3> } catch (IllegalArgumentException e) { <line4> if (LOG.isDebugEnabled()) { <line5> LOG.UNKNOWN(e.getMessage(), e); <line6> } <line7> } <line8> return null; <line9> } <line10> } <line11> 	debug	task5	
"public class A { <line0> private void processToRemoveSegments( <line1> CubeUpdate update, Segments<CubeSegment> newSegs, List<String> toRemoveResources) { <line2> Iterator<CubeSegment> iterator = newSegs.iterator(); <line3> while (iterator.hasNext()) { <line4> CubeSegment currentSeg = iterator.next(); <line5> for (CubeSegment toRemoveSeg : update.getToRemoveSegs()) { <line6> if (currentSeg.getUuid().equals(toRemoveSeg.getUuid())) { <line7> logger.UNKNOWN(""Remove segment {}"", currentSeg); <line8> toRemoveResources.add(currentSeg.getStatisticsResourcePath()); <line9> iterator.remove(); <line10> break; <line11> } <line12> } <line13> } <line14> } <line15> } <line16> "	info	task5	
"public class A { <line0> @Override <line1> public void onNotification(FlowConstructNotification notification) { <line2> if (Integer.parseInt(notification.getAction().getIdentifier()) == FLOW_CONSTRUCT_STOPPED) { <line3> LOGGER.UNKNOWN(""Invalidating flow from caches named {}"", notification.getResourceIdentifier()); <line4> invalidateDisposedFlowFromCaches(notification.getResourceIdentifier()); <line5> } <line6> } <line7> } <line8> "	debug	task5	
"public class A { <line0> private void stop(final String host, final String name) throws IOException { <line1> this.script.exec(host, new ArrayMap<String, String>().with(""container"", name)); <line2> Logger.UNKNOWN(StartDocker.class, ""Docker container %s stopped at %s"", name, host); <line3> } <line4> } <line5> "	info	task5	
"public class A { <line0> protected SequenceFile.Writer createNewFile( <line1> Path filepath, <line2> Class<? extends WritableComparable> keyClass, <line3> Class<? extends Writable> valueClass) <line4> throws IOException { <line5> SequenceFile.Writer writer = <line6> new SequenceFile.Writer(getFileSystem(), getJobConf(), filepath, keyClass, valueClass); <line7> LOG.UNKNOWN(""creating file "" + filepath.toString()); <line8> return writer; <line9> } <line10> } <line11> "	info	task5	
"public class A { <line0> public static com.liferay.commerce.product.model.CPMeasurementUnit updateCPMeasurementUnit( <line1> HttpPrincipal httpPrincipal, <line2> long cpMeasurementUnitId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> String key, <line5> double rate, <line6> boolean primary, <line7> double priority, <line8> int type, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> CPMeasurementUnitServiceUtil.class, <line15> ""updateCPMeasurementUnit"", <line16> _updateCPMeasurementUnitParameterTypes9); <line17> MethodHandler methodHandler = <line18> new MethodHandler( <line19> methodKey, <line20> cpMeasurementUnitId, <line21> nameMap, <line22> key, <line23> rate, <line24> primary, <line25> priority, <line26> type, <line27> serviceContext); <line28> Object returnObj = null; <line29> try { <line30> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line31> } catch (Exception exception) { <line32> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line33> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line34> } <line35> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line36> } <line37> return (com.liferay.commerce.product.model.CPMeasurementUnit) returnObj; <line38> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line39> log.UNKNOWN(systemException, systemException); <line40> throw systemException; <line41> } <line42> } <line43> } <line44> "	error	task5	
"public class A { <line0> protected void processSimpleTypeDefinition(XSDSimpleTypeDefinition type, Node node) <line1> throws RepositoryException { <line2> boolean isAnonymous = type.getName() == null; <line3> String nodeName = isAnonymous ? XsdLexicon.SIMPLE_TYPE : type.getName(); <line4> logger.UNKNOWN(""Simple type: '{0}' in ns '{1}' "", type.getName(), type.getTargetNamespace()); <line5> Node typeNode = node.addNode(nodeName, XsdLexicon.SIMPLE_TYPE_DEFINITION); <line6> typeNode.setProperty(XsdLexicon.NAMESPACE, type.getTargetNamespace()); <line7> if (!isAnonymous) { <line8> typeNode.setProperty(XsdLexicon.NC_NAME, type.getName()); <line9> registerForSymbolSpace( <line10> TYPE_DEFINITIONS, type.getTargetNamespace(), type.getName(), typeNode.getIdentifier()); <line11> } <line12> processTypeFacets(type, typeNode, type.getBaseType()); <line13> processNonSchemaAttributes(type, typeNode, IGNORED_ATTRIBUTES_SIMPLE_TYPE_DEF); <line14> } <line15> } <line16> "	debug	task5	
"public class A { <line0> public static void main(String[] args) throws Exception { <line1> RdfFreemarkerCli cli = new RdfFreemarkerCli(args); <line2> try { <line3> cli.call(); <line4> } catch (Exception e) { <line5> LOGGER.UNKNOWN(""Error"", e); <line6> System.exit(1); <line7> } <line8> System.exit(0); <line9> } <line10> } <line11> "	error	task5	
"public class A { <line0> @Override <line1> public X509Certificate prompt(final String hostname, final List<X509Certificate> certificates) <line2> throws ConnectionCanceledException { <line3> final AtomicReference<SFChooseIdentityPanel> ref = new AtomicReference<>(); <line4> controller.invoke( <line5> new DefaultMainAction() { <line6> @Override <line7> public void run() { <line8> ref.set(SFChooseIdentityPanel.sharedChooseIdentityPanel()); <line9> } <line10> }, <line11> true); <line12> final SFChooseIdentityPanel panel = ref.get(); <line13> panel.setDomain(hostname); <line14> final SecPolicyRef policyRef = SecurityFunctions.library.SecPolicyCreateSSL(true, hostname); <line15> panel.setPolicies(policyRef); <line16> FoundationKitFunctions.library.CFRelease(policyRef); <line17> panel.setShowsHelp(false); <line18> panel.setAlternateButtonTitle(LocaleFactory.localizedString(""Disconnect"")); <line19> panel.setInformativeText( <line20> MessageFormat.format( <line21> LocaleFactory.localizedString( <line22> ""The server requires a certificate to validate your identity. Select the"" <line23> + "" certificate to authenticate yourself to {0}.""), <line24> hostname)); <line25> final NSArray identities = KeychainCertificateStore.toDEREncodedCertificates(certificates); <line26> final int option = this.prompt(panel, identities); <line27> switch (option) { <line28> case SheetCallback.DEFAULT_OPTION: <line29> final SecIdentityRef identityRef = panel.identity(); <line30> if (null == identityRef) { <line31> log.UNKNOWN(String.format(""No identity selected for %s"", hostname)); <line32> throw new ConnectionCanceledException(); <line33> } <line34> return KeychainCertificateStore.toX509Certificate(identityRef); <line35> default: <line36> throw new ConnectionCanceledException(); <line37> } <line38> } <line39> } <line40> "	warn	task5	
"public class A { <line0> @Override <line1> public List<ProxyHostConfig> getProxyServer(URL destination) throws IOException { <line2> List<ProxyHostConfig> results = New.list(1); <line3> try { <line4> for (Proxy prox : ProxySelector.getDefault().select(destination.toURI())) { <line5> ProxyType proxyType; <line6> switch (prox.type()) { <line7> case DIRECT: <line8> proxyType = ProxyType.DIRECT; <line9> break; <line10> case HTTP: <line11> proxyType = ProxyType.PROXY; <line12> break; <line13> case SOCKS: <line14> proxyType = ProxyType.SOCKS; <line15> break; <line16> default: <line17> throw new UnexpectedEnumException(prox.type()); <line18> } <line19> SocketAddress addr = prox.address(); <line20> if (addr instanceof InetSocketAddress) { <line21> results.add( <line22> new ProxyHostConfig( <line23> proxyType, <line24> ((InetSocketAddress) addr).getHostString(), <line25> ((InetSocketAddress) addr).getPort())); <line26> } <line27> } <line28> } catch (URISyntaxException e) { <line29> LOGGER.UNKNOWN(""Failed to create URI for URL: ["" + destination + ""]: "" + e, e); <line30> } <line31> return results; <line32> } <line33> } <line34> "	error	task5	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> protected Transformation<RowData> translateToPlanInternal(PlannerBase planner) { <line3> TableConfig tableConfig = planner.getTableConfig(); <line4> if (grouping.length > 0 && tableConfig.getMinIdleStateRetentionTime() < 0) { <line5> LOG.UNKNOWN( <line6> ""No state retention interval configured for a query which accumulates state. "" <line7> + ""Please provide a query configuration with valid retention interval "" <line8> + ""to prevent excessive state size. You may specify a retention time "" <line9> + ""of 0 to not clean up the state.""); <line10> } <line11> final ExecEdge inputEdge = getInputEdges().get(0); <line12> final Transformation<RowData> inputTransform = <line13> (Transformation<RowData>) inputEdge.translateToPlan(planner); <line14> final RowType inputRowType = (RowType) inputEdge.getOutputType(); <line15> final AggregateInfoList aggInfoList = <line16> AggregateUtil.transformToStreamAggregateInfoList( <line17> inputRowType, <line18> JavaScalaConversionUtil.toScala(Arrays.asList(aggCalls)), <line19> aggCallNeedRetractions, <line20> needRetraction, <line21> true, <line22> true); <line23> final int inputCountIndex = aggInfoList.getIndexOfCountStar(); <line24> final boolean countStarInserted = aggInfoList.countStarInserted(); <line25> Tuple2<PythonAggregateFunctionInfo[], DataViewUtils.DataViewSpec[][]> aggInfosAndDataViewSpecs = <line26> CommonPythonUtil.extractPythonAggregateFunctionInfos(aggInfoList, aggCalls); <line27> PythonAggregateFunctionInfo[] pythonFunctionInfos = aggInfosAndDataViewSpecs.f0; <line28> DataViewUtils.DataViewSpec[][] dataViewSpecs = aggInfosAndDataViewSpecs.f1; <line29> Configuration config = CommonPythonUtil.getMergedConfig(planner.getExecEnv(), tableConfig); <line30> final OneInputStreamOperator<RowData, RowData> operator = <line31> getPythonAggregateFunctionOperator( <line32> config, <line33> inputRowType, <line34> InternalTypeInfo.of(getOutputType()).toRowType(), <line35> pythonFunctionInfos, <line36> dataViewSpecs, <line37> tableConfig.getMinIdleStateRetentionTime(), <line38> tableConfig.getMaxIdleStateRetentionTime(), <line39> inputCountIndex, <line40> countStarInserted); <line41> OneInputTransformation<RowData, RowData> transform = <line42> new OneInputTransformation<>( <line43> inputTransform, <line44> getDescription(), <line45> operator, <line46> InternalTypeInfo.of(getOutputType()), <line47> inputTransform.getParallelism()); <line48> if (CommonPythonUtil.isPythonWorkerUsingManagedMemory(config)) { <line49> transform.declareManagedMemoryUseCaseAtSlotScope(ManagedMemoryUseCase.PYTHON); <line50> } <line51> final RowDataKeySelector selector = <line52> KeySelectorUtil.getRowDataSelector(grouping, InternalTypeInfo.of(inputRowType)); <line53> transform.setStateKeySelector(selector); <line54> transform.setStateKeyType(selector.getProducedType()); <line55> return transform; <line56> } <line57> } <line58> "	warn	task5	
"public class A { <line0> public Object get(final Serializable id) { <line1> LOG.UNKNOWN(""get {}"", id); <line2> try { <line3> return idToVariableCache.get(id); <line4> } catch (ExecutionException e) { <line5> throw new IllegalStateException(e); <line6> } <line7> } <line8> } <line9> "	info	task5	
"public class A { <line0> @Test <line1> public void test_08() { <line2> Log.UNKNOWN(""Test""); <line3> Chromosome chr = genome.getChromosome(""1""); <line4> Marker m1 = new Marker(chr, 0, 100, false, """"); <line5> ArrayList<Marker> list = new ArrayList<>(); <line6> list.add(m1); <line7> int last = m1.getEnd() + 10; <line8> for (int i = m1.getStart(); i <= last; i++) { <line9> Marker m = new Marker(chr, i, i, false, """"); <line10> int dist = m.distanceBases(list, false); <line11> Assert.assertEquals(i, dist); <line12> } <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> @Override <line1> public Object bridgeableLoadObject( <line2> MultiplexTransaction muxTx, <line3> Object parent, <line4> String relationName, <line5> Serializable lookupId, <line6> Optional<FilterExpression> filterExpression, <line7> RequestScope scope) { <line8> if (parent.getClass().equals(HibernateUser.class)) { <line9> EntityDictionary dictionary = scope.getDictionary(); <line10> Type<?> entityClass = dictionary.getParameterizedType(parent, relationName); <line11> HibernateUser user = (HibernateUser) parent; <line12> if (""specialAction"".equals(relationName)) { <line13> return muxTx.loadObject( <line14> EntityProjection.builder().type(entityClass).build(), <line15> String.valueOf(user.getSpecialActionId()), <line16> scope); <line17> } <line18> if (""redisActions"".equals(relationName)) { <line19> FilterExpression updatedExpression = <line20> new InPredicate( <line21> new Path.PathElement(entityClass, ClassType.STRING_TYPE, ""user_id""), <line22> String.valueOf(((HibernateUser) parent).getId())); <line23> return muxTx.loadObject( <line24> EntityProjection.builder() <line25> .type(entityClass) <line26> .filterExpression(updatedExpression) <line27> .build(), <line28> String.valueOf(lookupId), <line29> scope); <line30> } <line31> } <line32> log.UNKNOWN(""Tried to bridge from parent: {} to relation name: {}"", parent, relationName); <line33> throw new RuntimeException(""Unsupported bridging attempted!""); <line34> } <line35> } <line36> "	error	task5	
"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> private static void notifyProgressiveListener0( <line2> ProgressiveFuture future, GenericProgressiveFutureListener l, long progress, long total) { <line3> try { <line4> l.operationProgressed(future, progress, total); <line5> } catch (Throwable t) { <line6> if (logger.isWarnEnabled()) { <line7> logger.UNKNOWN( <line8> ""An exception was thrown by "" + l.getClass().getName() + "".operationProgressed()"", t); <line9> } <line10> } <line11> } <line12> } <line13> "	warn	task5	
"public class A { <line0> private DatasetVersion getDatasetVersionFromRequest( <line1> AuthService authService, CreateDatasetVersion request, UserInfo userInfo) <line2> throws ModelDBException { <line3> DatasetVersion.Builder datasetVersionBuilder = <line4> DatasetVersion.newBuilder() <line5> .setVersion(request.getVersion()) <line6> .setDatasetId(request.getDatasetId()) <line7> .setDescription(request.getDescription()) <line8> .addAllTags(request.getTagsList()) <line9> .addAllAttributes(request.getAttributesList()); <line10> if (request.getTimeCreated() != 0L) { <line11> datasetVersionBuilder.setTimeLogged(request.getTimeCreated()); <line12> datasetVersionBuilder.setTimeUpdated(request.getTimeCreated()); <line13> } else { <line14> datasetVersionBuilder.setTimeLogged(Calendar.getInstance().getTimeInMillis()); <line15> datasetVersionBuilder.setTimeUpdated(Calendar.getInstance().getTimeInMillis()); <line16> } <line17> if (!request.getParentId().isEmpty()) { <line18> datasetVersionBuilder.setParentId(request.getParentId()); <line19> } <line20> if (userInfo != null) { <line21> datasetVersionBuilder.setOwner(authService.getVertaIdFromUserInfo(userInfo)); <line22> } <line23> if (!request.hasPathDatasetVersionInfo() && !request.hasDatasetBlob()) { <line24> LOGGER.UNKNOWN(""Request {}"", request); <line25> throw new ModelDBException(""Not supported"", io.grpc.Status.Code.UNIMPLEMENTED); <line26> } <line27> datasetVersionBuilder.setPathDatasetVersionInfo(request.getPathDatasetVersionInfo()); <line28> if (request.hasDatasetBlob()) { <line29> datasetVersionBuilder.setDatasetBlob(request.getDatasetBlob()); <line30> } <line31> return datasetVersionBuilder.build(); <line32> } <line33> } <line34> "	info	task5	
"public class A { <line0> public static String getRequestIpAddress(HttpServletRequest httpServletRequest) { <line1> String ret = """"; <line2> try { <line3> InetAddress inetAddr = InetAddress.getByName(httpServletRequest.getRemoteAddr()); <line4> ret = inetAddr.getHostAddress(); <line5> } catch (UnknownHostException ex) { <line6> LOG.UNKNOWN(""Failed to retrieve client IP address"", ex); <line7> } <line8> return ret; <line9> } <line10> } <line11> "	error	task5	
"public class A { <line0> public synchronized void flush() throws IOException, InterruptedException { <line1> checkAndThrowInterruptedException(); <line2> if (!isBatchComplete()) { <line3> doFlush(); <line4> if (idleTimeout > 0) { <line5> if (idleFuture == null || idleFuture.cancel(false)) { <line6> Callable<Void> idleAction = <line7> new Callable<Void>() { <line8> public Void call() throws Exception { <line9> LOG.UNKNOWN( <line10> ""Closing idle bucketWriter {} at {}"", bucketPath, System.currentTimeMillis()); <line11> if (isOpen) { <line12> close(true); <line13> } <line14> return null; <line15> } <line16> }; <line17> idleFuture = timedRollerPool.schedule(idleAction, idleTimeout, TimeUnit.SECONDS); <line18> } <line19> } <line20> } <line21> } <line22> } <line23> "	info	task5	
"public class A { <line0> public void addTypeDef(String typeName, String typeClass, Properties paramMap) { <line1> TypeDef def = new TypeDef(typeClass, paramMap); <line2> typeDefs.put(typeName, def); <line3> log.UNKNOWN(""Added "" + typeName + "" with class "" + typeClass); <line4> } <line5> } <line6> "	debug	task5	
"public class A { <line0> private List<T> bootstrap() { <line1> List<T> rerunEvents = new ArrayList<T>(); <line2> File[] files = serializeFilePath.listFiles(); <line3> if (files != null) { <line4> for (File rerunFile : files) { <line5> BufferedReader reader = null; <line6> try { <line7> reader = <line8> new BufferedReader( <line9> new InputStreamReader(new FileInputStream(rerunFile), CharEncoding.UTF_8)); <line10> String line; <line11> while ((line = reader.readLine()) != null) { <line12> T event = new RerunEventFactory<T>().getRerunEvent(rerunFile.getName(), line); <line13> rerunEvents.add(event); <line14> } <line15> } catch (Exception e) { <line16> LOG.UNKNOWN(""Not able to read rerun entry {}"", rerunFile.getAbsolutePath(), e); <line17> } finally { <line18> IOUtils.closeQuietly(reader); <line19> } <line20> } <line21> } <line22> return rerunEvents; <line23> } <line24> } <line25> "	warn	task5	
"public class A { <line0> public void getAdministrativeStatus( <line1> final DeviceMessageMetadata deviceMessageMetadata, <line2> final AdministrativeStatusType administrativeStatusType) <line3> throws FunctionalException { <line4> LOGGER.UNKNOWN( <line5> ""Get Administrative Status for organisationIdentification: {} for deviceIdentification: {}"" <line6> + "" to status: {}"", <line7> deviceMessageMetadata.getOrganisationIdentification(), <line8> deviceMessageMetadata.getDeviceIdentification(), <line9> administrativeStatusType); <line10> final SmartMeter smartMeteringDevice = <line11> this.domainHelperService.findSmartMeter(deviceMessageMetadata.getDeviceIdentification()); <line12> final RequestMessage requestMessage = <line13> new RequestMessage( <line14> deviceMessageMetadata.getCorrelationUid(), <line15> deviceMessageMetadata.getOrganisationIdentification(), <line16> deviceMessageMetadata.getDeviceIdentification(), <line17> smartMeteringDevice.getIpAddress(), <line18> this.configurationMapper.map( <line19> administrativeStatusType, AdministrativeStatusTypeDto.class)); <line20> this.osgpCoreRequestMessageSender.send( <line21> requestMessage, <line22> deviceMessageMetadata.getMessageType(), <line23> deviceMessageMetadata.getMessagePriority(), <line24> deviceMessageMetadata.getScheduleTime(), <line25> deviceMessageMetadata.bypassRetry()); <line26> } <line27> } <line28> "	info	task5	
"public class A { <line0> private boolean newGroupId() { <line1> try { <line2> String cId = null; <line3> if (client.getGroupId() != null) { <line4> cId = <line5> Scripting.replaceVariables( <line6> new ActionContext(SecurityContext.getSuperUserInstance()), <line7> null, <line8> client.getGroupId(), <line9> false, <line10> ""groupId""); <line11> } else { <line12> cId = client.getGroupId(); <line13> } <line14> return !currentGroupId.equals(cId); <line15> } catch (FrameworkException ex) { <line16> logger.UNKNOWN(""Exception while trying to evaluate KafkaClient groupId: "", ex); <line17> return false; <line18> } <line19> } <line20> } <line21> "	error	task5	
"public class A { <line0> public void removeByHandle(String handle) { <line1> logger.UNKNOWN(""Removing handle {} from storage"", handle); <line2> storageLock.lock(); <line3> try { <line4> if (allHandles.remove(handle)) { <line5> storage.remove(ACCESS_TOKEN_RESPONSE.getKey(handle)); <line6> storage.remove(LAST_USED.getKey(handle)); <line7> storage.remove(SERVICE_CONFIGURATION.getKey(handle)); <line8> storage.put(STORE_KEY_INDEX_OF_HANDLES, gson.toJson(allHandles)); <line9> } <line10> } finally { <line11> storageLock.unlock(); <line12> } <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> public SpringCamelContext getCamelContext() { <line1> synchronized (this) { <line2> if (camelContext == null) { <line3> camelContext = <line4> ApplicationContextProvider.getBeanFactory().getBean(SpringCamelContext.class); <line5> camelContext.addRoutePolicyFactory(new MetricsRoutePolicyFactory()); <line6> } <line7> if (camelContext.getRoutes().isEmpty()) { <line8> List<CamelRoute> routes = routeDAO.findAll(); <line9> LOG.UNKNOWN(""{} route(s) are going to be loaded "", routes.size()); <line10> loadRouteDefinitions( <line11> routes.stream().map(CamelRoute::getContent).collect(Collectors.toList())); <line12> } <line13> } <line14> return camelContext; <line15> } <line16> } <line17> "	debug	task5	
public class A { <line0> @Override <line1> public DSLQueryEntry findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchDSLQueryEntryException { <line3> DSLQueryEntry dslQueryEntry = fetchByPrimaryKey(primaryKey); <line4> if (dslQueryEntry == null) { <line5> if (log.isDebugEnabled()) { <line6> log.UNKNOWN(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> throw new NoSuchDSLQueryEntryException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line9> } <line10> return dslQueryEntry; <line11> } <line12> } <line13> 	debug	task5	
"public class A { <line0> private synchronized Component getBrokerComponent(URI brokerURI, MessagingType type) { <line1> logger.UNKNOWN( <line2> ""establishing activemq connection for brokerUri {} (with specified type)"", brokerURI); <line3> ActiveMQConnectionFactory activeMQConnectionFactory = <line4> new ActiveMQConnectionFactory( <line5> brokerURI + ""?jms.prefetchPolicy.all=1&jms.useAsyncSend=true""); <line6> return getBrokerComponent(type, activeMQConnectionFactory); <line7> } <line8> } <line9> "	info	task5	
"public class A { <line0> @Override <line1> public synchronized void purgeHeartbeats() { <line2> logger.UNKNOWN(""Purging old heartbeats""); <line3> heartbeatMessages.clear(); <line4> } <line5> } <line6> "	debug	task5	
"public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> if (dynamicPropertyType == null) { <line4> throw new MissingArgumentException(""Property type not set.""); <line5> } <line6> values = getDaoFactory().getDAO(Property.class).findByCriteria(getCriteria()); <line7> } catch (Exception ex) { <line8> log.UNKNOWN(""Failed querying values for dynamic property type "" + dynamicPropertyType, ex); <line9> throw new RuntimeException(ex); <line10> } <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> CountDownLatch pause() { <line1> final CountDownLatch latch = new CountDownLatch(1); <line2> appendControlEvent( <line3> ""pause"", <line4> () -> { <line5> try { <line6> latch.await(); <line7> } catch (InterruptedException e) { <line8> log.UNKNOWN(""Interrupted while waiting for unpause."", e); <line9> } <line10> }); <line11> return latch; <line12> } <line13> } <line14> "	info	task5	
"public class A { <line0> protected Queue<Exchange> createExchanges(Message[] messages) { <line1> LOG.UNKNOWN(""Received {} messages in this poll"", messages.length); <line2> Queue<Exchange> answer = new LinkedList<>(); <line3> for (Message message : messages) { <line4> Exchange exchange = createExchange(message); <line5> answer.add(exchange); <line6> } <line7> return answer; <line8> } <line9> } <line10> "	trace	task5	
"public class A { <line0> @Override <line1> public DelegationTokenIssuer[] getAdditionalTokenIssuers() throws IOException { <line2> KeyProvider keyProvider; <line3> try { <line4> keyProvider = getKeyProvider(); <line5> } catch (IOException ioe) { <line6> LOG.UNKNOWN(""Error retrieving KeyProvider."", ioe); <line7> return null; <line8> } <line9> if (keyProvider instanceof DelegationTokenIssuer) { <line10> return new DelegationTokenIssuer[] {(DelegationTokenIssuer) keyProvider}; <line11> } <line12> return null; <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> private void processActivities( <line1> String orcid, <line2> List<? extends Activity> activities, <line3> Map<String, S3ObjectSummary> existingElements, <line4> ActivityType type) { <line5> try { <line6> for (Activity x : activities) { <line7> String putCodeString = String.valueOf(x.getPutCode()); <line8> Activity activity = null; <line9> if (existingElements.containsKey(putCodeString)) { <line10> S3ObjectSummary existingObject = existingElements.get(putCodeString); <line11> Date elementLastModified = DateUtils.convertToDate(x.getLastModifiedDate().getValue()); <line12> Date s3LastModified = existingObject.getLastModified(); <line13> if (elementLastModified.after(s3LastModified)) { <line14> activity = fetchActivity(orcid, x.getPutCode(), type); <line15> } <line16> existingElements.remove(putCodeString); <line17> } else { <line18> activity = fetchActivity(orcid, x.getPutCode(), type); <line19> } <line20> if (activity != null) { <line21> s3Manager.uploadActivity(orcid, putCodeString, activity); <line22> existingElements.remove(putCodeString); <line23> } <line24> } <line25> for (String putCode : existingElements.keySet()) { <line26> s3Manager.removeActivity(orcid, putCode, type); <line27> } <line28> activitiesStatusManager.markAsSent(orcid, type); <line29> } catch (Exception e) { <line30> LOG.UNKNOWN(""Unable to fetch activities "" + type.getValue() + "" for orcid "" + orcid); <line31> activitiesStatusManager.markAsFailed(orcid, type); <line32> throw new RuntimeException(e); <line33> } <line34> } <line35> } <line36> "	error	task5	
"public class A { <line0> @Override <line1> public PasswordPolicy findByC_N(long companyId, String name) <line2> throws NoSuchPasswordPolicyException { <line3> PasswordPolicy passwordPolicy = fetchByC_N(companyId, name); <line4> if (passwordPolicy == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""companyId=""); <line8> sb.append(companyId); <line9> sb.append("", name=""); <line10> sb.append(name); <line11> sb.append(""}""); <line12> if (log.isDebugEnabled()) { <line13> log.UNKNOWN(sb.toString()); <line14> } <line15> throw new NoSuchPasswordPolicyException(sb.toString()); <line16> } <line17> return passwordPolicy; <line18> } <line19> } <line20> "	debug	task5	
"public class A { <line0> public static <T> T deserialize(String json, TypeReference<T> typeReference) { <line1> try { <line2> return getMapper().readValue(json, typeReference); <line3> } catch (IOException e) { <line4> log.UNKNOWN(""Error de-serializing object with TypeReference {} "", typeReference, e); <line5> throw new RuntimeException(""error de-serializing object"", e); <line6> } <line7> } <line8> } <line9> "	error	task5	
"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> @Test <line2> public void testWithAppEnricher() throws Exception { <line3> Entity app = <line4> createAndStartApplication(loadYaml(""test-app-with-enrichers-slightly-simpler.yaml"")); <line5> waitForApplicationTasks(app); <line6> log.UNKNOWN(""Started "" + app + "":""); <line7> Entities.dumpInfo(app); <line8> Entity cluster = Iterables.getOnlyElement(app.getChildren()); <line9> Collection<Entity> leafs = ((DynamicCluster) cluster).getMembers(); <line10> Iterator<Entity> li = leafs.iterator(); <line11> Entity e1 = li.next(); <line12> ((EntityInternal) e1).sensors().set(Sensors.newStringSensor(""ip""), ""127.0.0.1""); <line13> EntityAsserts.assertAttributeEqualsEventually( <line14> e1, Sensors.newStringSensor(""url""), ""http://127.0.0.1/""); <line15> EntityAsserts.assertAttributeEqualsEventually( <line16> e1, Attributes.MAIN_URI, URI.create(""http://127.0.0.1/"")); <line17> int i = 2; <line18> while (li.hasNext()) { <line19> Entity ei = li.next(); <line20> ((EntityInternal) ei).sensors().set(Sensors.newStringSensor(""ip""), ""127.0.0."" + i); <line21> i++; <line22> } <line23> EntityAsserts.assertAttributeEventually( <line24> cluster, <line25> Sensors.newSensor(Iterable.class, ""urls.list""), <line26> (Predicate) CollectionFunctionals.sizeEquals(3)); <line27> EntityAsserts.assertAttributeEventually( <line28> cluster, <line29> Sensors.newSensor(String.class, ""urls.list.comma_separated.max_2""), <line30> StringPredicates.matchesRegex(""\""http:\\/\\/127[^\""]*\\/\"",\""http:\\/\\/127[^\""]*\\/\"""")); <line31> EntityAsserts.assertAttributeEventually(cluster, Attributes.MAIN_URI, Predicates.notNull()); <line32> URI main = cluster.getAttribute(Attributes.MAIN_URI); <line33> Assert.assertTrue(main.toString().matches(""http:\\/\\/127.0.0..\\/""), ""Wrong URI: "" + main); <line34> EntityAsserts.assertAttributeEventually(app, Attributes.MAIN_URI, Predicates.notNull()); <line35> main = app.getAttribute(Attributes.MAIN_URI); <line36> Assert.assertTrue(main.toString().matches(""http:\\/\\/127.0.0..\\/""), ""Wrong URI: "" + main); <line37> } <line38> } <line39> "	info	task5	
"public class A { <line0> public static void updateLatestStatus(String index, String type, String discoveryDate) { <line1> String indexName = ""/"" + index; <line2> String updateJson = <line3> ""{\""script\"":{\""inline\"": \""ctx._source.latest=false\""},\""query\"": {\""bool\"": {\""must\"": [{"" <line4> + "" \""match\"": {\""latest\"":true}}], \""must_not\"": [{\""match\"":"" <line5> + "" {\""discoverydate.keyword\"":\"""" <line6> + discoveryDate <line7> + ""\""}}]}}}""; <line8> try { <line9> invokeAPI(""POST"", indexName + ""/"" + type + ""/"" + ""_update_by_query"", updateJson); <line10> } catch (IOException e) { <line11> LOGGER.UNKNOWN(""Error updateLatestStatus "", e); <line12> } <line13> } <line14> } <line15> "	error	task5	
"public class A { <line0> public static java.util.List<com.liferay.portal.kernel.model.Group> getUserSitesGroups( <line1> HttpPrincipal httpPrincipal, long userId, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> GroupServiceUtil.class, ""getUserSitesGroups"", _getUserSitesGroupsParameterTypes24); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, userId, start, end); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (java.util.List<com.liferay.portal.kernel.model.Group>) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> log.UNKNOWN(systemException, systemException); <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	error	task5	
"public class A { <line0> protected void removeNodes() { <line1> if (nodesToRemove == null) return; <line2> IndexWriter writer = null; <line3> try { <line4> writer = index.getWriter(); <line5> for (NodeId nodeId : nodesToRemove) { <line6> int nodeIdLen = nodeId.size(); <line7> byte[] data = new byte[nodeIdLen + 4]; <line8> ByteConversion.intToByteH(currentDoc.getDocId(), data, 0); <line9> nodeId.serialize(data, 4); <line10> Term it = new Term(FIELD_ID, new BytesRef(data)); <line11> TermQuery iq = new TermQuery(it); <line12> writer.deleteDocuments(iq); <line13> } <line14> } catch (IOException e) { <line15> LOG.UNKNOWN(""Error while deleting lucene index entries: {}"", e.getMessage(), e); <line16> } finally { <line17> nodesToRemove = null; <line18> index.releaseWriter(writer); <line19> } <line20> } <line21> } <line22> "	warn	task5	
"public class A { <line0> @Override <line1> public List<String> readMessage(int expectedNumMessages, String groupId, String topic) <line2> throws IOException { <line3> final List<String> messages = <line4> Collections.synchronizedList(new ArrayList<>(expectedNumMessages)); <line5> try (final AutoClosableProcess kafka = <line6> AutoClosableProcess.create( <line7> kafkaDir.resolve(Paths.get(""bin"", ""kafka-console-consumer.sh"")).toString(), <line8> ""--bootstrap-server"", <line9> KAFKA_ADDRESS, <line10> ""--from-beginning"", <line11> ""--max-messages"", <line12> String.valueOf(expectedNumMessages), <line13> ""--topic"", <line14> topic, <line15> ""--consumer-property"", <line16> ""group.id="" + groupId) <line17> .setStdoutProcessor(messages::add) <line18> .runNonBlocking()) { <line19> final Deadline deadline = Deadline.fromNow(Duration.ofSeconds(120)); <line20> while (deadline.hasTimeLeft() && messages.size() < expectedNumMessages) { <line21> try { <line22> LOG.UNKNOWN(""Waiting for messages. Received {}/{}."", messages.size(), expectedNumMessages); <line23> Thread.sleep(500); <line24> } catch (InterruptedException e) { <line25> Thread.currentThread().interrupt(); <line26> break; <line27> } <line28> } <line29> if (messages.size() != expectedNumMessages) { <line30> throw new IOException(""Could not read expected number of messages.""); <line31> } <line32> return messages; <line33> } <line34> } <line35> } <line36> "	info	task5	
"public class A { <line0> @Override <line1> public void started() { <line2> log.UNKNOWN(""Starting VM pause monitor""); <line3> } <line4> } <line5> "	debug	task5	
"public class A { <line0> @Override <line1> public Pair<SaslClientAuthenticationProvider, Token<? extends TokenIdentifier>> selectProvider( <line2> String clusterId, User user) { <line3> requireNonNull(clusterId, ""Null clusterId was given""); <line4> requireNonNull(user, ""Null user was given""); <line5> if (!User.isHBaseSecurityEnabled(conf)) { <line6> return new Pair<>(simpleAuth, null); <line7> } <line8> final Text clusterIdAsText = new Text(clusterId); <line9> for (Token<? extends TokenIdentifier> token : user.getTokens()) { <line10> if (clusterIdAsText.equals(token.getService()) <line11> && digestAuthTokenKind.equals(token.getKind())) { <line12> return new Pair<>(digestAuth, token); <line13> } <line14> } <line15> final UserGroupInformation currentUser = user.getUGI(); <line16> final UserGroupInformation realUser = currentUser.getRealUser(); <line17> if (currentUser.hasKerberosCredentials() <line18> || (realUser != null && realUser.hasKerberosCredentials())) { <line19> return new Pair<>(krbAuth, null); <line20> } <line21> LOG.UNKNOWN( <line22> ""No matching SASL authentication provider and supporting token found from providers"" <line23> + "" for user: {}"", <line24> user); <line25> return null; <line26> } <line27> } <line28> "	warn	task5	
"public class A { <line0> @Override <line1> public void remove(String key) { <line2> if (silentlyRemoveEntityIfExists(createDn(hashKey(key)))) { <line3> log.UNKNOWN(""Removed entity, key: "" + key); <line4> } <line5> } <line6> } <line7> "	trace	task5	
"public class A { <line0> private U completionIndex(Map.Entry<T, U> lookFor) { <line1> U ack = null; <line2> if (lookFor == null) { <line3> return ack; <line4> } <line5> if (hasTimeoutDurationReached(System.currentTimeMillis())) { <line6> LOG.UNKNOWN(""Ack: Timeout: {} - {}"", lookFor.getKey(), lookFor.getValue()); <line7> return acknowledged(lookFor); <line8> } <line9> if (!processedSet.contains(lookFor.getKey())) { <line10> return ack; <line11> } <line12> return acknowledged(lookFor); <line13> } <line14> } <line15> "	warn	task5	
"public class A { <line0> @Transactional(rollbackFor = {Exception.class}) <line1> @Override <line2> public void createNamespace(NamespaceDomainInfo namespaceDomainInfo) <line3> throws SaturnJobConsoleException { <line4> String namespace = namespaceDomainInfo.getNamespace(); <line5> String zkClusterKey = namespaceDomainInfo.getZkCluster(); <line6> ZkCluster currentCluster = getZkCluster(zkClusterKey); <line7> if (currentCluster == null) { <line8> throw new SaturnJobConsoleHttpException( <line9> HttpStatus.BAD_REQUEST.value(), <line10> String.format( <line11> ERR_MSG_TEMPLATE_FAIL_TO_CREATE, namespace, ""not found zkcluster"" + zkClusterKey)); <line12> } <line13> if (checkNamespaceExists(namespace)) { <line14> throw new SaturnJobConsoleHttpException( <line15> HttpStatus.BAD_REQUEST.value(), String.format(ERR_MSG_NS_ALREADY_EXIST, namespace)); <line16> } <line17> try { <line18> NamespaceInfo namespaceInfo = constructNamespaceInfo(namespaceDomainInfo); <line19> namespaceInfoService.create(namespaceInfo); <line20> namespaceZkClusterMapping4SqlService.insert( <line21> namespace, """", zkClusterKey, NAMESPACE_CREATOR_NAME); <line22> notifyRefreshRegCenter(); <line23> } catch (Exception e) { <line24> log.UNKNOWN(e.getMessage(), e); <line25> throw new SaturnJobConsoleHttpException( <line26> HttpStatus.INTERNAL_SERVER_ERROR.value(), <line27> String.format(ERR_MSG_TEMPLATE_FAIL_TO_CREATE, namespace, e.getMessage())); <line28> } <line29> } <line30> } <line31> "	error	task5	
"public class A { <line0> @Override <line1> public String enforcePasswordChange(Integer userId, String email) { <line2> logger.entry(""begin enforcePasswordChange()""); <line3> Session session = null; <line4> String message = FdahpStudyDesignerConstants.FAILURE; <line5> try { <line6> List<String> SAEmailIdList = getSuperAdminList(); <line7> session = hibernateTemplate.getSessionFactory().openSession(); <line8> transaction = session.beginTransaction(); <line9> if ((userId != null) && StringUtils.isNotEmpty(email)) { <line10> int count = <line11> session <line12> .createSQLQuery( <line13> ""Update users set force_logout='Y', credentialsNonExpired=false WHERE user_id"" <line14> + "" =:userId"") <line15> .setParameter(""userId"", userId) <line16> .executeUpdate(); <line17> if (count > 0) { <line18> session <line19> .createSQLQuery(""update user_attempts set attempts = 0 WHERE email_id =:email"") <line20> .setParameter(""email"", email) <line21> .executeUpdate(); <line22> message = FdahpStudyDesignerConstants.SUCCESS; <line23> } <line24> } else { <line25> int count = <line26> session <line27> .createSQLQuery( <line28> ""Update users set force_logout='Y' WHERE status=true AND email NOT"" <line29> + "" IN(:emailIds)"") <line30> .setParameterList(""emailIds"", SAEmailIdList) <line31> .executeUpdate(); <line32> if (count > 0) { <line33> int result = <line34> session <line35> .createSQLQuery( <line36> ""Update users set credentialsNonExpired=false WHERE email NOT IN(:emailIds)"") <line37> .setParameterList(""emailIds"", SAEmailIdList) <line38> .executeUpdate(); <line39> if (result > 0) { <line40> session <line41> .createSQLQuery( <line42> ""update user_attempts set attempts = 0 WHERE email_id NOT IN(:emailIds)"") <line43> .setParameterList(""emailIds"", SAEmailIdList) <line44> .executeUpdate(); <line45> message = FdahpStudyDesignerConstants.SUCCESS; <line46> } <line47> } <line48> } <line49> transaction.commit(); <line50> } catch (Exception e) { <line51> if (transaction != null) { <line52> transaction.rollback(); <line53> } <line54> logger.UNKNOWN(""UsersDAOImpl - enforcePasswordChange() - ERROR"", e); <line55> } finally { <line56> if ((session != null) && session.isOpen()) { <line57> session.close(); <line58> } <line59> } <line60> logger.exit(""enforcePasswordChange() - Ends""); <line61> return message; <line62> } <line63> } <line64> "	error	task5	
"public class A { <line0> protected void run() { <line1> SpringBusFactory bf = new SpringBusFactory(); <line2> Bus bus = bf.createBus(""org/apache/cxf/systest/ws/policy/http-addr-server.xml""); <line3> setBus(bus); <line4> GreeterImpl implementor = new GreeterImpl(); <line5> implementor.setThrowAlways(true); <line6> Endpoint.publish(""http://localhost:"" + PORT + ""/SoapContext/GreeterPort"", implementor); <line7> LOG.UNKNOWN(""Published greeter endpoint.""); <line8> LoggingInInterceptor in = new LoggingInInterceptor(); <line9> LoggingOutInterceptor out = new LoggingOutInterceptor(); <line10> bus.getInInterceptors().add(in); <line11> bus.getOutInterceptors().add(out); <line12> bus.getOutFaultInterceptors().add(out); <line13> } <line14> } <line15> "	info	task5	
"public class A { <line0> public JMeterArgumentsArray setLogRootOverride(String requestedLogLevel) { <line1> if (isNotSet(requestedLogLevel)) { <line2> return this; <line3> } <line4> for (LogLevel logLevel : LogLevel.values()) { <line5> if (logLevel.toString().equalsIgnoreCase(requestedLogLevel)) { <line6> overrideRootLogLevel = logLevel; <line7> argumentList.add(LOGLEVEL); <line8> return this; <line9> } <line10> } <line11> LOGGER.UNKNOWN(""Unknown log level {}"", requestedLogLevel); <line12> return this; <line13> } <line14> } <line15> "	warn	task5	
"public class A { <line0> private void initGraph(Integer orgId) { <line1> try { <line2> IGraphElementLoader loader1 = new GraphElementLoader(); <line3> loader1.setTypeIds(typeIds); <line4> loader1.setScopeId(orgId); <line5> loader1.setElementFilter(new TopElementFilter(orgId)); <line6> IGraphElementLoader loader2 = new GraphElementLoader(); <line7> loader2.setTypeIds(new String[] {PersonIso.TYPE_ID}); <line8> List<IGraphElementLoader> loaders = new ArrayList<>(2); <line9> loaders.add(loader1); <line10> loaders.add(loader2); <line11> graph = getGraphService().create(loaders, relationIds); <line12> } catch (Exception e) { <line13> LOG.UNKNOWN(""Error while initialization"", e); <line14> } <line15> } <line16> } <line17> "	error	task5	
"public class A { <line0> public List<Attribute> setupResources( <line1> Map<URI, AttributeValue> res, RelationshipResolver relationshipResolver) <line2> throws MelcoeXacmlException { <line3> if (res == null || res.size() == 0) { <line4> return new ArrayList<Attribute>(); <line5> } <line6> List<Attribute> attributes = new ArrayList<Attribute>(res.size()); <line7> try { <line8> String pid = null; <line9> AttributeValue pidAttr = res.get(Constants.XACML1_RESOURCE.ID.attributeId); <line10> if (pidAttr != null) { <line11> pid = pidAttr.encode(); <line12> pid = relationshipResolver.buildRESTParentHierarchy(pid); <line13> String dsid = null; <line14> AttributeValue dsidAttr = res.get(Constants.DATASTREAM.ID.attributeId); <line15> if (dsidAttr != null) { <line16> dsid = dsidAttr.encode(); <line17> if (!dsid.isEmpty()) { <line18> pid += ""/"" + dsid; <line19> } <line20> } <line21> res.put(Constants.XACML1_RESOURCE.ID.attributeId, new AnyURIAttribute(new URI(pid))); <line22> } <line23> } catch (Exception e) { <line24> logger.UNKNOWN(""Error finding parents."", e); <line25> throw new MelcoeXacmlException(""Error finding parents."", e); <line26> } <line27> for (URI uri : res.keySet()) { <line28> attributes.add(new SingletonAttribute(uri, null, null, res.get(uri))); <line29> } <line30> return attributes; <line31> } <line32> } <line33> "	error	task5	
"public class A { <line0> public boolean useProgram(GL gl) { <line1> if (gl.glIsProgram(oglProgramId)) { <line2> gl.glUseProgram(oglProgramId); <line3> return true; <line4> } <line5> LOG.UNKNOWN(""The given programId {} is invalid in the given context."", oglProgramId); <line6> return false; <line7> } <line8> } <line9> "	warn	task5	
"public class A { <line0> @Override <line1> public void fireAfterListener(T prev, K evt, T curr, Object... args) { <line2> _listenersTmp.clear(); <line3> synchronized (_listeners) { <line4> _listenersTmp.addAll(_listeners); <line5> } <line6> for (StateMachineListener<T, K> l : _listenersTmp) { <line7> try { <line8> l.after(prev, evt, curr, args); <line9> } catch (Exception e) { <line10> StringBuilder err = <line11> new StringBuilder( <line12> ""Unhandled exception while calling listener: "" + l.getClass().getCanonicalName()); <line13> err.append("" after state changing."") <line14> .append(""["") <line15> .append(""previous state:"" + prev) <line16> .append("" event: "" + evt); <line17> err.append("" current state: "" + curr).append(""]""); <line18> logger.UNKNOWN(err.toString(), e); <line19> } <line20> } <line21> } <line22> } <line23> "	warn	task5	
public class A { <line0> public static <O> FutureCallback<O> createFailureLoggingCallback(final String failMessage) { <line1> return new FutureCallback<O>() { <line2> @Override <line3> public void onSuccess(@Nullable final O result) {} <line4>  <line5> @Override <line6> public void onFailure(final Throwable t) { <line7> LOG.UNKNOWN(failMessage, t); <line8> } <line9> }; <line10> } <line11> } <line12> 	warn	task5	
"public class A { <line0> private void processInstitutions( <line1> JsonNode institutions, <line2> Map<Integer, List<JsonNode>> altNamesMap, <line3> Map<Integer, List<JsonNode>> identifiersMap, <line4> Map<Integer, JsonNode> dnNameMap) { <line5> LOGGER.UNKNOWN(""Processing institutions""); <line6> institutions.forEach( <line7> institution -> { <line8> Integer ringgoldId = institution.get(""ringgold_id"").asInt(); <line9> OrgDisambiguatedEntity entity = processInstitution(institution, dnNameMap); <line10> generateExternalIdentifiers(entity, identifiersMap.get(ringgoldId)); <line11> if (altNamesMap.containsKey(ringgoldId)) { <line12> generateOrganizations(entity, altNamesMap.get(ringgoldId)); <line13> } <line14> }); <line15> } <line16> } <line17> "	info	task5	
"public class A { <line0> public UserDto login(final InternalHttpContext context, final LoginRequestDto loginRequest) { <line1> LOGGER.UNKNOWN(""loginRequest: {}"", loginRequest); <line2> final HttpEntity<LoginRequestDto> request = <line3> new HttpEntity<>(loginRequest, buildHeaders(context)); <line4> final ResponseEntity<UserDto> response = <line5> restTemplate.exchange( <line6> getUrl() + RestApi.CAS_LOGIN_PATH, HttpMethod.POST, request, UserDto.class); <line7> checkResponse(response); <line8> return response.getBody(); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> List<Interpreter> createInterpreters(String user, String interpreterGroupId, String sessionId) { <line1> List<Interpreter> interpreters = new ArrayList<>(); <line2> List<InterpreterInfo> interpreterInfos = getInterpreterInfos(); <line3> Properties intpProperties = getJavaProperties(); <line4> for (InterpreterInfo info : interpreterInfos) { <line5> Interpreter interpreter = <line6> new RemoteInterpreter(intpProperties, sessionId, info.getClassName(), user); <line7> if (info.isDefaultInterpreter()) { <line8> interpreters.add(0, interpreter); <line9> } else { <line10> interpreters.add(interpreter); <line11> } <line12> LOGGER.UNKNOWN( <line13> ""Interpreter {} created for user: {}, sessionId: {}"", <line14> interpreter.getClassName(), <line15> user, <line16> sessionId); <line17> } <line18> if (group.equals(""livy"")) { <line19> interpreters.add( <line20> new SessionConfInterpreter(intpProperties, sessionId, interpreterGroupId, this)); <line21> } else { <line22> interpreters.add(new ConfInterpreter(intpProperties, sessionId, interpreterGroupId, this)); <line23> } <line24> return interpreters; <line25> } <line26> } <line27> "	info	task5	
"public class A { <line0> private Command executeCommandWithRetries(String command) <line1> throws TransportException, ConnectionException { <line2> int currentRetryCount = 0; <line3> Command cmd = null; <line4> while (true) { <line5> cmd = executeCommand(command); <line6> if (cmd == null) { <line7> if (currentRetryCount >= SSH_MAX_RETRY_COUNT) { <line8> throw new RuntimeException(""Retry limit exceeded when trying to execute ssh command.""); <line9> } <line10> ++currentRetryCount; <line11> log.UNKNOWN( <line12> ""Timeout when trying to execute ssh command. Will try again in "" <line13> + SSH_RETRY_COOLDOWN_IN_SEC <line14> + "" seconds""); <line15> try { <line16> Thread.sleep(1000 * SSH_RETRY_COOLDOWN_IN_SEC); <line17> } catch (InterruptedException e1) { <line18> throw new RuntimeException(e1); <line19> } <line20> continue; <line21> } <line22> break; <line23> } <line24> return cmd; <line25> } <line26> } <line27> "	debug	task5	
"public class A { <line0> public Long getCallTimeout() { <line1> if (logger.isTraceEnabled()) { <line2> logger.UNKNOWN(""getCallTimeout()""); <line3> } <line4> return raProperties.getCallTimeout(); <line5> } <line6> } <line7> "	trace	task5	
"public class A { <line0> @RequestMapping(value = ""/skipTask.action"", method = RequestMethod.GET) <line1> @ResponseBody <line2> public Map<String, Object> skipTask(@RequestParam Integer id) throws Exception { <line3> try { <line4> String userName = getAuthenticatedUserName(); <line5> String sVar = taggerService.skipTask(id, userName); <line6> return getUIWrapper(sVar, true); <line7> } catch (AidrException e) { <line8> logger.UNKNOWN(""Error ehile skipping task for documentID: "" + id + ""\t"" + e.getStackTrace()); <line9> return getUIWrapper(e.getMessage(), false); <line10> } <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> public List<MediaFile> getSharedFiles(int id, List<MusicFolder> musicFolders) { <line1> List<MediaFile> result = new ArrayList<>(); <line2> for (String path : shareDao.getSharedFiles(id, musicFolders)) { <line3> try { <line4> MediaFile mediaFile = mediaFileService.getMediaFile(path); <line5> if (mediaFile != null) { <line6> result.add(mediaFile); <line7> } <line8> } catch (SecurityException e) { <line9> if (LOG.isErrorEnabled()) { <line10> LOG.UNKNOWN(""Error in getSharedFiles(int, List<MusicFolder>)."", e); <line11> } <line12> } <line13> } <line14> return result; <line15> } <line16> } <line17> "	error	task5	
"public class A { <line0> private void prepareServerNameListLength(ServerNameIndicationExtensionMessage msg) { <line1> msg.setServerNameListLength(msg.getServerNameListBytes().getValue().length); <line2> LOGGER.UNKNOWN(""ServerNameListLength: "" + msg.getServerNameListLength().getValue()); <line3> } <line4> } <line5> "	debug	task5	
public class A { <line0> public static com.liferay.commerce.currency.model.CommerceCurrencySoap getCommerceCurrency( <line1> long commerceCurrencyId) throws RemoteException { <line2> try { <line3> com.liferay.commerce.currency.model.CommerceCurrency returnValue = <line4> CommerceCurrencyServiceUtil.getCommerceCurrency(commerceCurrencyId); <line5> return com.liferay.commerce.currency.model.CommerceCurrencySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> log.UNKNOWN(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	error	task5	
"public class A { <line0> public Local<C> random(int n) { <line1> C r = ring.random(n); <line2> C s = ring.random(n); <line3> s = s.remainder(ideal); <line4> while (s.isZERO()) { <line5> logger.UNKNOWN(""zero was in ideal""); <line6> s = ring.random(n); <line7> s = s.remainder(ideal); <line8> } <line9> return new Local<C>(this, r, s, false); <line10> } <line11> } <line12> "	debug	task5	
public class A { <line0> private Reference createReferenceStub(final ModelNode referenceNode) { <line1> try { <line2> return AutoBeanCodex.decode(_factory, Reference.class, referenceNode.toJSONString(true)).as(); <line3> } catch (Exception e) { <line4> Log.UNKNOWN(PARSE_ERROR_MESSAGE, e); <line5> return null; <line6> } <line7> } <line8> } <line9> 	error	task5	
public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap[] getFileEntries( <line1> long repositoryId, long folderId, int start, int end) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.portal.kernel.repository.model.FileEntry> returnValue = <line4> DLAppServiceUtil.getFileEntries(repositoryId, folderId, start, end); <line5> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> log.UNKNOWN(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	error	task5	
"public class A { <line0> public void release() { <line1> logger.UNKNOWN(""ThreadPoolItem: Release port "" + port); <line2> setInUse(false); <line3> thread = null; <line4> simId = null; <line5> testSession = null; <line6> } <line7> } <line8> "	info	task5	
"public class A { <line0> @Override <line1> protected void onSchemaCacheRefreshed() { <line2> try { <line3> getRestHighLevelClient() <line4> .indices() <line5> .refresh(new RefreshRequest(indexName), RequestOptions.DEFAULT); <line6> } catch (final IOException e) { <line7> logger.UNKNOWN(""Failed to refresh index \""{}\"""", indexName, e); <line8> } <line9> detectSchema(); <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> SolrInputDocument doc = createDocument(instance); <line4> synchronized (solrServer) { <line5> solrServer.add(doc); <line6> } <line7> } catch (Exception e) { <line8> WorkflowServiceSolrIndex.logger.UNKNOWN(""Unable to index {}: {}"", instance, e); <line9> } <line10> } <line11> } <line12> "	warn	task5	
"public class A { <line0> public java.util.List<net.java.dev.jaxb.array.StringArrayArray> getSrcRecord( <line1> java.lang.String taskID) { <line2> LOG.UNKNOWN(""Executing operation getSrcRecord""); <line3> System.out.println(taskID); <line4> try { <line5> java.util.List<net.java.dev.jaxb.array.StringArrayArray> _return = null; <line6> return _return; <line7> } catch (Exception ex) { <line8> ex.printStackTrace(); <line9> throw new RuntimeException(ex); <line10> } <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> private void endTransaction() { <line1> Connection con = localConnection.get(); <line2> if (con == null) { <line3> throw new IllegalStateException(""Not in transaction""); <line4> } <line5> localConnection.set(null); <line6> long now = System.currentTimeMillis(); <line7> long elapsed = now - ((DbConnectionWrapper) con).getTxStart(); <line8> if (elapsed >= txThreshold) { <line9> logThreshold( <line10> String.format(""Database transaction required %.3f seconds"", (double) elapsed / 1000.0)); <line11> } else { <line12> long count, times; <line13> boolean logStats = false; <line14> synchronized (this) { <line15> count = ++txCount; <line16> times = txTimes += elapsed; <line17> if (now - statsTime >= txInterval) { <line18> logStats = true; <line19> txCount = 0; <line20> txTimes = 0; <line21> statsTime = now; <line22> } <line23> } <line24> if (logStats) <line25> log.UNKNOWN( <line26> String.format( <line27> ""Average database transaction time is %.3f seconds"", <line28> (double) times / 1000.0 / (double) count)); <line29> } <line30> DbUtils.close(con); <line31> } <line32> } <line33> "	debug	task5	
"public class A { <line0> @Override <line1> public void onClose(KubernetesClientException e) { <line2> LOG.UNKNOWN(""Watch closed"", e); <line3> scheduleReconnect(); <line4> } <line5> } <line6> "	warn	task5	
"public class A { <line0> public void sendUploadMessage(RemoteFile rf, String precomputedChecksum) throws ArgumentNotValid { <line1> ArgumentNotValid.checkNotNull(rf, ""RemoteFile rf""); <line2> UploadMessage up = new UploadMessage(theChecksumChannel, Channels.getTheRepos(), rf); <line3> up.setPrecomputedChecksum(precomputedChecksum); <line4> jmsCon.send(up); <line5> log.UNKNOWN(""Sending upload message '{}'."", up.toString()); <line6> } <line7> } <line8> "	debug	task5	
"public class A { <line0> private void doUnregisterErrorPages(ErrorPageModel model) { <line1> final String[] errorPages = model.getErrorPages(); <line2> final Set<String> errorPagesSet = new HashSet<>(Arrays.asList(errorPages)); <line3> if (model.getRegisteringBundle() == null) { <line4> model.setRegisteringBundle(serviceBundle); <line5> } <line6> Bundle registeringBundle = model.getRegisteringBundle(); <line7> try { <line8> event(WebElementEvent.State.UNDEPLOYING, model); <line9> serverModel.run( <line10> () -> { <line11> List<ErrorPageModel> toUnregister = new LinkedList<>(); <line12> LOG.UNKNOWN(""Unregistering error page models for pages \""{}\"""", Arrays.asList(errorPages)); <line13> for (ErrorPageModel existing : serviceModel.getErrorPageModels()) { <line14> if (existing == model) { <line15> toUnregister.add(existing); <line16> break; <line17> } <line18> } <line19> if (toUnregister.isEmpty()) { <line20> for (ErrorPageModel existing : serviceModel.getErrorPageModels()) { <line21> if (existing == model) { <line22> toUnregister.add(existing); <line23> break; <line24> } else { <line25> Set<String> existingPages = <line26> new HashSet<>(Arrays.asList(existing.getErrorPages())); <line27> if (existingPages.containsAll(errorPagesSet)) { <line28> toUnregister.add(existing); <line29> } <line30> } <line31> } <line32> } <line33> if (toUnregister.isEmpty()) { <line34> throw new IllegalArgumentException( <line35> ""Can't find error pages to unregister using criteria from "" + model); <line36> } <line37> final Batch batch = new Batch(""Unregistration of error pages: "" + toUnregister); <line38> serverModel.removeErrorPageModels(toUnregister, batch); <line39> serverController.sendBatch(batch); <line40> batch.accept(serviceModel); <line41> return null; <line42> }); <line43> event(WebElementEvent.State.UNDEPLOYED, model); <line44> } catch (Exception e) { <line45> event(WebElementEvent.State.FAILED, model, e); <line46> throw new RuntimeException(e.getMessage(), e); <line47> } <line48> } <line49> } <line50> "	info	task5	
"public class A { <line0> private void checkImages(ImageAction action) throws JSONException, IOException { <line1> JSONObject json = <line2> new JSONObject( <line3> IOUtils.toString( <line4> getClass().getResourceAsStream(""/pictures/images.json""), StandardCharsets.UTF_8)); <line5> JSONArray array = json.getJSONArray(""images""); <line6> for (int i = 0; i < array.length(); i++) { <line7> JSONObject image = array.getJSONObject(i); <line8> String imageName = image.getString(""name""); <line9> log.UNKNOWN(""Handling "" + imageName); <line10> String path = ""/pictures/"" + imageName; <line11> InputStream ins = getClass().getResourceAsStream(path); <line12> if (ins == null) { <line13> throw new RuntimeException(""Could not find image {"" + path + ""}""); <line14> } <line15> byte[] bytes = IOUtils.toByteArray(ins); <line16> Flowable<Buffer> bs = Flowable.just(Buffer.buffer(bytes)); <line17> int width = image.getInt(""w""); <line18> int height = image.getInt(""h""); <line19> String color = image.getString(""dominantColor""); <line20> String refPath = getReferenceFilename(imageName); <line21> InputStream insRef = getClass().getResourceAsStream(refPath); <line22> if (insRef == null) { <line23> throw new RuntimeException(""Could not find reference image {"" + refPath + ""}""); <line24> } <line25> BufferedImage refImage = ImageIO.read(insRef); <line26> insRef.close(); <line27> action.call(imageName, width, height, color, refImage, path, bs); <line28> } <line29> } <line30> } <line31> "	debug	task5	
"public class A { <line0> @Override <line1> public InputStream getResourceStream() { <line2> ResourceInstance resourceInstance = instance; <line3> String subPath = super.getDiskSubFolder() + resourceInstance.getFileName(); <line4> try { <line5> return this.getStorageManager().getStream(subPath, this.isProtectedResource()); <line6> } catch (Throwable t) { <line7> logger.UNKNOWN(""Error on extracting resource Stream"", t); <line8> throw new RuntimeException(""Error on extracting resource Stream"", t); <line9> } <line10> } <line11> } <line12> "	error	task5	
"public class A { <line0> private void debugTypes( <line1> QueryRunner trinoExecutor, <line2> Session session, <line3> List<Type> expectedTypes, <line4> List<Object> expectedResults, <line5> TestTable testTable) { <line6> for (int i = 0; i < inputs.size(); i++) { <line7> Input<?> input = inputs.get(i); <line8> if (input.isUseInWhereClause()) { <line9> String debugQuery = <line10> format( <line11> ""SELECT col_%d FROM %s WHERE col_%d IS NOT DISTINCT FROM %s"", <line12> i, testTable.getName(), i, input.toTrinoLiteral()); <line13> log.UNKNOWN( <line14> ""Querying input: %d (expected type: %s, expectedResult: %s) using: %s"", <line15> i, expectedTypes.get(i), expectedResults.get(i), debugQuery); <line16> MaterializedResult debugRows = trinoExecutor.execute(session, debugQuery); <line17> checkResults(expectedTypes.subList(i, i + 1), expectedResults.subList(i, i + 1), debugRows); <line18> } <line19> } <line20> } <line21> } <line22> "	info	task5	
"public class A { <line0> private ByteBuffer sendCommand(String command) { <line1> if (command != null) { <line2> ByteBuffer byteBuffer = ByteBuffer.allocate(command.getBytes().length); <line3> try { <line4> byteBuffer.put(command.getBytes(""ASCII"")); <line5> onWritable(byteBuffer); <line6> Thread.sleep(((BigDecimal) getConfig().get(RESPONSE_TIME_OUT)).intValue()); <line7> return onReadable(((BigDecimal) getConfig().get(BUFFER_SIZE)).intValue(), true); <line8> } catch (UnsupportedEncodingException | NumberFormatException | InterruptedException e) { <line9> Thread.currentThread().interrupt(); <line10> logger.UNKNOWN( <line11> ""An exception occurred while sending a command to the IRtrans transceiver for '{}': {}"", <line12> getThing().getUID(), <line13> e.getMessage()); <line14> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line15> } <line16> } <line17> return null; <line18> } <line19> } <line20> "	debug	task5	
"public class A { <line0> private Void acceptOneRaw(Context context) { <line1> LOG.UNKNOWN(""About to call accept1 with Raw XML"" + getAddress()); <line2> implementor.prepareToWaitForOneWay(); <line3> testUtilities.rhinoCall(""testAny1ToServerRaw"", testUtilities.javaToJS(getAddress())); <line4> implementor.waitForOneWay(); <line5> assertEquals(""before chalk"", implementor.getBefore()); <line6> Object something = implementor.getAny1value(); <line7> assertNotNull(something); <line8> assertTrue(something instanceof Element); <line9> Element walrus = (Element) something; <line10> assertEquals(""walrus"", walrus.getNodeName()); <line11> assertEquals(""tusks"", walrus.getTextContent()); <line12> assertEquals(""after chalk"", implementor.getAfter()); <line13> return null; <line14> } <line15> } <line16> "	info	task5	
"public class A { <line0> protected URL[] getExternalSettingsFileURLs() { <line1> try { <line2> List<URL> externalSettingsFileURLs = new ArrayList<URL>(); <line3> String externalSettingsFileNames = getSettingImpl(ADDITIONAL_SETTINGS_FILES); <line4> String[] externalSettingFiles = externalSettingsFileNames.split("",""); <line5> for (String externalSettingFile : externalSettingFiles) { <line6> URL externalSettingFileURL = ApplicationSettings.loadFile(externalSettingFile); <line7> if (externalSettingFileURL == null) { <line8> logger.UNKNOWN(""Could not file external settings file "" + externalSettingFile); <line9> } else { <line10> externalSettingsFileURLs.add(externalSettingFileURL); <line11> } <line12> } <line13> return externalSettingsFileURLs.toArray(new URL[] {}); <line14> } catch (ApplicationSettingsException e) { <line15> return new URL[] {}; <line16> } <line17> } <line18> } <line19> "	warn	task5	
"public class A { <line0> public void doStronglyTypedLogging(Object item) { <line1> if (log.isInfoEnabled()) { <line2> log.UNKNOWN(""Processed: "" + item); <line3> } <line4> } <line5> } <line6> "	info	task5	
"public class A { <line0> public static void close(Closeable c) { <line1> try { <line2> if (c != null) { <line3> c.close(); <line4> } <line5> } catch (IOException e) { <line6> logger.UNKNOWN(""Cannot close down the given Closeable object"", e); <line7> } <line8> } <line9> } <line10> "	warn	task5	
"public class A { <line0> public void actionPerformed(ActionEvent actionEvent) { <line1> MoveAxiomsWizard wiz = new MoveAxiomsWizard(getOWLEditorKit()); <line2> if (wiz.showModalDialog() == Wizard.FINISH_RETURN_CODE) { <line3> try { <line4> wiz.applyChanges(); <line5> } catch (OWLOntologyCreationException e) { <line6> logger.UNKNOWN(""An error occurred whilst applying the changes to move axiom to ontology."", e); <line7> } <line8> } <line9> wiz.dispose(); <line10> } <line11> } <line12> "	error	task5	
"public class A { <line0> protected void parseExtensionBytes(T message) { <line1> byte[] extensionBytes = parseByteArrayField(message.getExtensionsLength().getValue()); <line2> message.setExtensionBytes(extensionBytes); <line3> LOGGER.UNKNOWN(""ExtensionBytes:"" + ArrayConverter.bytesToHexString(extensionBytes, false)); <line4> List<ExtensionMessage> extensionMessages = new LinkedList<>(); <line5> int pointer = 0; <line6> HandshakeMessageType type; <line7> if (message instanceof ServerHelloMessage <line8> && ((ServerHelloMessage) message).isTls13HelloRetryRequest()) { <line9> type = HandshakeMessageType.HELLO_RETRY_REQUEST; <line10> } else { <line11> type = message.getHandshakeMessageType(); <line12> } <line13> while (pointer < extensionBytes.length) { <line14> ExtensionParser parser = <line15> ExtensionParserFactory.getExtensionParser( <line16> extensionBytes, pointer, type, this.getConfig()); <line17> extensionMessages.add(parser.parse()); <line18> if (pointer == parser.getPointer()) { <line19> throw new ParserException(""Ran into infinite Loop while parsing Extensions""); <line20> } <line21> pointer = parser.getPointer(); <line22> } <line23> message.setExtensions(extensionMessages); <line24> } <line25> } <line26> "	debug	task5	
"public class A { <line0> private static void writePartitionInfo(Configuration conf, Path path, List<KeyValue> splitPoints) <line1> throws IOException { <line2> LOG.UNKNOWN(""Writing {} split points to {}"", splitPoints.size(), path); <line3> SequenceFile.Writer writer = <line4> SequenceFile.createWriter( <line5> path.getFileSystem(conf), conf, path, NullWritable.class, BytesWritable.class); <line6> for (KeyValue key : splitPoints) { <line7> writer.append(NullWritable.get(), HBaseTypes.keyValueToBytes(key)); <line8> } <line9> writer.close(); <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> @Test <line1> public void testSchemaHash() throws IOException, NoSuchAlgorithmException { <line2> File tempFile = newTestFile(true); <line3> String target = tempFile.getAbsolutePath(); <line4> logger.UNKNOWN(""Target: {}"", target); <line5> TransientPositionTracker tracker = new TransientPositionTracker(target); <line6> Context context = new Context(); <line7> context.put( <line8> AvroEventDeserializer.CONFIG_SCHEMA_TYPE_KEY, <line9> AvroEventDeserializer.AvroSchemaType.HASH.toString()); <line10> ResettableInputStream in = new ResettableFileInputStream(tempFile, tracker); <line11> EventDeserializer des = new AvroEventDeserializer.Builder().build(context, in); <line12> Event event = des.readEvent(); <line13> String eventSchemaHash = event.getHeaders().get(AvroEventDeserializer.AVRO_SCHEMA_HEADER_HASH); <line14> String expectedSchemaHash = <line15> Hex.encodeHexString(SchemaNormalization.parsingFingerprint(""CRC-64-AVRO"", schema)); <line16> Assert.assertEquals(expectedSchemaHash, eventSchemaHash); <line17> } <line18> } <line19> "	info	task5	
public class A { <line0> protected DDMForm getDDMForm() { <line1> DDMForm ddmForm = null; <line2> try { <line3> DDMFormInstance ddmFormInstance = getDDMFormInstance(); <line4> if (ddmFormInstance == null) { <line5> return ddmForm; <line6> } <line7> DDMFormInstanceVersion latestDDMFormInstanceVersion = <line8> DDMFormTaglibUtil.getLatestDDMFormInstanceVersion( <line9> ddmFormInstance.getFormInstanceId(), WorkflowConstants.STATUS_APPROVED); <line10> DDMStructureVersion ddmStructureVersion = latestDDMFormInstanceVersion.getStructureVersion(); <line11> ddmForm = ddmStructureVersion.getDDMForm(); <line12> } catch (PortalException portalException) { <line13> if (log.isDebugEnabled()) { <line14> log.UNKNOWN(portalException, portalException); <line15> } <line16> } <line17> return ddmForm; <line18> } <line19> } <line20> 	debug	task5	
public class A { <line0> public void stateChanged(int state) { <line1> if (state == RECONNECTED) { <line2> try { <line3> recover(); <line4> } catch (Exception e) { <line5> logger.UNKNOWN(e.getMessage(), e); <line6> } <line7> } <line8> } <line9> } <line10> 	error	task5	
"public class A { <line0> private void createConnection() throws IOException, InterruptedException { <line1> if (connection == null) { <line2> logger.UNKNOWN(""Creating new connection to hostname:{} port:{}"", hostname, port); <line3> connection = new IRCConnection(hostname, new int[] {port}, password, nick, user, name); <line4> connection.addIRCEventListener(new IRCConnectionListener()); <line5> connection.setEncoding(""UTF-8""); <line6> connection.setPong(true); <line7> connection.setDaemon(false); <line8> connection.setColors(false); <line9> connection.connect(); <line10> for (String chan : channels) { <line11> connection.doJoin(IRC_CHANNEL_PREFIX + chan); <line12> } <line13> } <line14> } <line15> } <line16> "	debug	task5	
"public class A { <line0> private static RestConfig loadRESTConfig() throws IOException { <line1> if (log.isDebugEnabled()) { <line2> log.UNKNOWN( <line3> ""Reading global configuration file: "" + Constants.Utils.REST_CONFIGURATION_FILE_PATH); <line4> } <line5> ObjectMapper objectMapper = new ObjectMapper(); <line6> return objectMapper.readValue( <line7> new File(Constants.Utils.REST_CONFIGURATION_FILE_PATH), RestConfig.class); <line8> } <line9> } <line10> "	debug	task5	
"public class A { <line0> protected LogLevel logbackToScoutLevel(Level level) { <line1> if (level == null) { <line2> return null; <line3> } <line4> switch (level.toInt()) { <line5> case Level.ALL_INT: <line6> return LogLevel.ALL; <line7> case Level.TRACE_INT: <line8> return LogLevel.TRACE; <line9> case Level.DEBUG_INT: <line10> return LogLevel.DEBUG; <line11> case Level.INFO_INT: <line12> return LogLevel.INFO; <line13> case Level.WARN_INT: <line14> return LogLevel.WARN; <line15> case Level.ERROR_INT: <line16> return LogLevel.ERROR; <line17> case Level.OFF_INT: <line18> return LogLevel.OFF; <line19> default: <line20> LOG.UNKNOWN( <line21> ""unknown log4j level '{}'. Falling back to scout log level '{}'"", level, LogLevel.WARN); <line22> return LogLevel.WARN; <line23> } <line24> } <line25> } <line26> "	info	task5	
public class A { <line0> @Test <line1> public void testInfo_Object_Object_Object_Object_Object() throws Exception { <line2> ILoggingTool logger = getLoggingTool(); <line3> logger.UNKNOWN(this, this, this, this, this); <line4> } <line5> } <line6> 	info	task5	
"public class A { <line0> private static void emitLogLine( <line1> String userId, String action, String queueUrl, List<String> receiptHandles, long rt) { <line2> StringBuffer logLine = new StringBuffer(""""); <line3> logLine.append(""event=req status=ok client=inline Action="").append(action); <line4> if (receiptHandles != null) { <line5> for (String receiptHandle : receiptHandles) { <line6> logLine.append("" ReceiptHandle="").append(receiptHandle); <line7> } <line8> } <line9> logLine.append("" resp_ms="").append(rt); <line10> logger.UNKNOWN(logLine.toString()); <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> @Test <line1> public void test_01_ENST00000369219() { <line2> Log.UNKNOWN(""Test""); <line3> String trName = ""ENST00000369219""; <line4> String ensemblFile = path(trName + ""_ensembl.txt""); <line5> CompareToEnsembl compareToEnsembl = new CompareToEnsembl(""testHg3763Chr1"", false); <line6> compareToEnsembl.compareEnsembl(ensemblFile, trName); <line7> } <line8> } <line9> "	debug	task5	
"public class A { <line0> private void discoveryStop() { <line1> logger.UNKNOWN( <line2> ""SEP Extension: Discovery stopped at state {} after {} retries"", seState, retryCounter); <line3> timerCancel(); <line4> for (ZclKeyEstablishmentClient keClient : cbkeClientRegistry.values()) { <line5> keClient.stop(); <line6> } <line7> updateClientState(SmartEnergyClientState.IDLE); <line8> } <line9> } <line10> "	debug	task5	
"public class A { <line0> protected void fetchRelationship( <line1> MetadataChild relationship, <line2> boolean useForeignKeyAttribute, <line3> boolean nullifyDanglingRelationship) { <line4> Class<?> relatedType = relationship.getRelatedType(); <line5> if (!dataObjectService.supports(relatedType)) { <line6> LOG.UNKNOWN( <line7> ""Encountered a related type that is not supported by DataObjectService, fetch "" <line8> + ""relationship will do nothing: "" <line9> + relatedType); <line10> return; <line11> } <line12> if (useForeignKeyAttribute) { <line13> fetchRelationshipUsingAttributes(relationship, nullifyDanglingRelationship); <line14> } else { <line15> fetchRelationshipUsingIdentity(relationship, nullifyDanglingRelationship); <line16> } <line17> } <line18> } <line19> "	warn	task5	
"public class A { <line0> private void logResponse(RestResponse response, String uuid) { <line1> String message = <line2> String.format( <line3> ""Received response with %s and body: %s"", response.getStatus(), response.getBody()); <line4> logger.UNKNOWN(message); <line5> AllureLogger.passStep(message, uuid); <line6> } <line7> } <line8> "	info	task5	
"public class A { <line0> @Override <line1> public void actionPerformed(ActionEvent e) { <line2> JCheckBox eventBox = (JCheckBox) e.getSource(); <line3> LOGGER.UNKNOWN((eventBox.isSelected() ? ""Activating "" : ""Deactivating "") + source.getName()); <line4> Quantify.collectEnableDisableMetric(""mist3d.server-panel.status"", eventBox.isSelected()); <line5> if (eventBox.isSelected()) { <line6> controller.activateSource(source); <line7> } else { <line8> controller.deactivateSource(source); <line9> } <line10> rebuildTable(); <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> private Map<String, Set<Integer>> parseLicsTodoToLicenseMap(Map<String, InputStream> inputMap) { <line1> log.UNKNOWN(""Parsing license obligations ...""); <line2> List<CSVRecord> licenseTodoRecord = readAsCSVRecords(inputMap.get(LICENSE_TODO_FILE)); <line3> return ConvertRecord.convertRelationalTable(licenseTodoRecord); <line4> } <line5> } <line6> "	debug	task5	
public class A { <line0> @Override <line1> public boolean filter(Bundle row) { <line2> try { <line3> if (duration > 0) { <line4> Thread.sleep(duration); <line5> } <line6> } catch (InterruptedException ex) { <line7> log.UNKNOWN(ex.toString()); <line8> } <line9> return true; <line10> } <line11> } <line12> 	info	task5	
"public class A { <line0> protected String makeChangePasswordURL( <line1> final String publicUrl, final String contextPath, final String token) { <line2> String url = <line3> UriComponentsBuilder.fromHttpUrl(publicUrl) <line4> .path(contextPath) <line5> .path(""/account/newPassword"") <line6> .query(""token={token}"") <line7> .buildAndExpand(token) <line8> .toUriString(); <line9> if (LOG.isDebugEnabled()) { <line10> LOG.UNKNOWN(""generated url:"" + url); <line11> } <line12> return url; <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> private void checkCloudRequestDTO(final CloudRequestDTO cloud) { <line1> logger.UNKNOWN(""checkCloudRequestDTO started...""); <line2> if (cloud == null) { <line3> throw new InvalidParameterException(""Cloud"" + NULL_PARAMETER_ERROR_MESSAGE); <line4> } <line5> if (Utilities.isEmpty(cloud.getOperator())) { <line6> throw new InvalidParameterException(""Cloud operator"" + NULL_OR_BLANK_PARAMETER_ERROR_MESSAGE); <line7> } <line8> if (Utilities.isEmpty(cloud.getName())) { <line9> throw new InvalidParameterException(""Cloud name"" + NULL_OR_BLANK_PARAMETER_ERROR_MESSAGE); <line10> } <line11> } <line12> } <line13> "	debug	task5	
"public class A { <line0> public void addTokenFromUserToJobConf(UserGroupInformation user, JobConf jobConf) <line1> throws IOException { <line2> checkNotNull(user, ""Provided UGI was null""); <line3> checkNotNull(jobConf, ""JobConf was null""); <line4> Token<?> accumuloToken = getAccumuloToken(user); <line5> if (null == accumuloToken) { <line6> log.UNKNOWN(""Could not find accumulo token in user: "" + user.getTokens()); <line7> throw new IOException(""Could not find Accumulo Token in user's tokens""); <line8> } <line9> mergeTokenIntoJobConf(jobConf, accumuloToken); <line10> } <line11> } <line12> "	error	task5	
"public class A { <line0> @Override <line1> public void timerFired() throws IOException { <line2> Map<String, List<ObjectRecord>> batchMap = pollBatches(); <line3> if (batchMap == null) { <line4> return; <line5> } <line6> for (String type : batchMap.keySet()) { <line7> List<ObjectRecord> batch = batchMap.get(type); <line8> try { <line9> objectRecordDAO.saveBatch(batch, type); <line10> } catch (Exception e) { <line11> log.UNKNOWN(""Failed to send ObjectRecord batch to S3"", e); <line12> } <line13> } <line14> } <line15> } <line16> "	error	task5	
"public class A { <line0> public void protocolCommandSent(ProtocolCommandEvent event) { <line1> LOG.UNKNOWN(""> "" + event.getMessage().trim()); <line2> } <line3> } <line4> "	debug	task5	
"public class A { <line0> @Test <line1> public void testContinuousQueriesWithConcurrentCompute() throws Exception { <line2> try (IgniteClient client = startClient(0, 1, 2)) { <line3> int threadsCnt = 20; <line4> int iterations = 50; <line5> Set<UUID> allNodesIds = new HashSet<>(F.nodeIds(grid(0).cluster().nodes())); <line6> AtomicInteger threadIdxs = new AtomicInteger(); <line7> GridTestUtils.runMultiThreaded( <line8> () -> { <line9> int threadIdx = threadIdxs.incrementAndGet(); <line10> ClientCache<Integer, Integer> cache = <line11> client.getOrCreateCache(""testCQwithCompute"" + threadIdx); <line12> try { <line13> for (int i = 0; i < iterations; i++) { <line14> ContinuousQueryListener<Integer, Integer> lsnr = new ContinuousQueryListener<>(); <line15> QueryCursor<?> cur = <line16> cache.query(new ContinuousQuery<Integer, Integer>().setLocalListener(lsnr)); <line17> cache.put(i, i); <line18> Future<T2<UUID, Set<UUID>>> fut = <line19> client.compute().executeAsync2(TestTask.class.getName(), null); <line20> assertEquals(allNodesIds, fut.get().get2()); <line21> lsnr.assertNextCacheEvent(EventType.CREATED, i, i); <line22> assertTrue(lsnr.isQueueEmpty()); <line23> cur.close(); <line24> } <line25> } catch (Exception e) { <line26> log.UNKNOWN(""Failure: "", e); <line27> fail(); <line28> } <line29> }, <line30> threadsCnt, <line31> ""run-task-async""); <line32> } <line33> } <line34> } <line35> "	error	task5	
"public class A { <line0> @Test <line1> public void testRequestNetCDFCompression() throws Exception { <line2> boolean isNC4Available = NetCDFUtilities.isNC4CAvailable(); <line3> if (!isNC4Available && LOGGER.isLoggable(Level.INFO)) { <line4> LOGGER.UNKNOWN(""NetCDF C library not found. NetCDF4 output will not be created""); <line5> } <line6> MockHttpServletResponse response = <line7> getAsServletResponse( <line8> ""ows?request=GetCoverage&service=WCS&version=2.0.1"" <line9> + ""&coverageId=wcs__visibilityCompressed&format=application/x-netcdf4""); <line10> assertNotNull(response); <line11> assertEquals( <line12> (isNC4Available ? ""application/x-netcdf4"" : ""application/xml""), response.getContentType()); <line13> if (isNC4Available) { <line14> byte[] netcdfOut = getBinary(response); <line15> File file = File.createTempFile(""netcdf"", ""outCompressed.nc"", new File(""./target"")); <line16> FileUtils.writeByteArrayToFile(file, netcdfOut); <line17> try (NetcdfDataset dataset = NetcdfDataset.openDataset(file.getAbsolutePath())) { <line18> assertNotNull(dataset); <line19> Variable var = dataset.findVariable(STANDARD_NAME); <line20> assertNotNull(var); <line21> final long varByteSize = var.getSize() * var.getDataType().getSize(); <line22> assertTrue(netcdfOut.length < varByteSize); <line23> } <line24> } <line25> } <line26> } <line27> "	info	task5	
"public class A { <line0> @Override <line1> @Delete <line2> public Representation delete() { <line3> StringRepresentation presentation; <line4> try { <line5> final String tenantName = (String) getRequest().getAttributes().get(TENANT_NAME); <line6> final String type = getReference().getQueryAsForm().getValues(""type""); <line7> presentation = deleteTenant(tenantName, type); <line8> } catch (final Exception e) { <line9> presentation = exceptionToStringRepresentation(e); <line10> LOGGER.UNKNOWN(""Caught exception while deleting tenant "", e); <line11> setStatus(Status.SERVER_ERROR_INTERNAL); <line12> } <line13> return presentation; <line14> } <line15> } <line16> "	error	task5	
"public class A { <line0> @GET <line1> @Path(""check-compatibility"") <line2> @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line3> public Response checkGeoVersionCompatibility(@QueryParam(""expect_version"") String expectVersion) { <line4> if (!isValidateVersion(expectVersion)) { <line5> log.UNKNOWN(""invalid Geo version {} : only support major and minor "", expectVersion); <line6> throw APIException.badRequests.invalidParameter( <line7> ""invalid Geo version {} : only support major and minor "", expectVersion); <line8> } <line9> Boolean versionSupported = this._dbClient.checkGeoCompatible(expectVersion); <line10> return Response.ok(versionSupported.toString(), MediaType.APPLICATION_OCTET_STREAM).build(); <line11> } <line12> } <line13> "	warn	task5	
"public class A { <line0> public void scanInsertFormValueCommands() { <line1> LOGGER.UNKNOWN(""scanInsertFormValueCommands""); <line2> boolean modified = getDocumentController().getModel().isDocumentModified(); <line3> try { <line4> getDocumentController().getModel().setDocumentModifiable(false); <line5> InsertFormValueCommandsScanner s = new InsertFormValueCommandsScanner(this); <line6> s.execute(getDocumentController().getModel().getDocumentCommands()); <line7> getDocumentController().getModel().setIDToFormFields(s.getIdToFormFields()); <line8> getDocumentController().collectNonWollMuxFormFields(); <line9> } finally { <line10> getDocumentController().getModel().setDocumentModified(modified); <line11> getDocumentController().getModel().setDocumentModifiable(true); <line12> } <line13> } <line14> } <line15> "	debug	task5	
"public class A { <line0> @Override <line1> public void deleteEntry(AtomRequest areq) throws AtomException { <line2> log.UNKNOWN(""Entering""); <line3> String[] pathInfo = StringUtils.split(areq.getPathInfo(), ""/""); <line4> if (pathInfo.length > 2) { <line5> if (pathInfo[1].equals(""entry"")) { <line6> EntryCollection ecol = new EntryCollection(user, atomURL); <line7> ecol.deleteEntry(areq); <line8> return; <line9> } else if (pathInfo[1].equals(""resource"")) { <line10> MediaCollection mcol = new MediaCollection(user, atomURL); <line11> mcol.deleteEntry(areq); <line12> return; <line13> } <line14> } <line15> throw new AtomNotFoundException(""cannot find specified entry/resource""); <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> @Test <line1> public void testUpdate() throws Exception { <line2> File theTestFile = uploadTestFile(); <line3> final Map<String, Object> headers = new HashMap<>(); <line4> headers.put(""CamelGoogleDrive.fileId"", theTestFile.getId()); <line5> headers.put(""CamelGoogleDrive.content"", theTestFile); <line6> File result = requestBodyAndHeaders(""direct://UPDATE"", null, headers); <line7> assertNotNull(result, ""update result""); <line8> LOG.UNKNOWN(""update: "" + result); <line9> } <line10> } <line11> "	debug	task5	
"public class A { <line0> private void handleColor(Command command) throws IOException, CommandUnsuccessfulException { <line1> if (command instanceof HSBType) { <line2> HSBType color = (HSBType) command; <line3> Color c = new Color(color.getRGB()); <line4> int r = c.getRed(); <line5> int g = c.getGreen(); <line6> int b = c.getBlue(); <line7> ColorCommand colorCommand = new ColorCommand(r, g, b, priority); <line8> sendCommand(colorCommand); <line9> } else { <line10> logger.UNKNOWN(""Channel {} unable to process command {}"", CHANNEL_COLOR, command); <line11> } <line12> } <line13> } <line14> "	debug	task5	
"public class A { <line0> @Override <line1> public void operationFinished(Object ctx, Void resultOfOperation) { <line2> logger.UNKNOWN( <line3> ""Topic: "" <line4> + topic.toStringUtf8() <line5> + "" subscriberId: "" <line6> + subscriberId.toStringUtf8() <line7> + "" attaching to subscription with state: "" <line8> + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionState()) <line9> + "", with preferences: "" <line10> + SubscriptionStateUtils.toString(subscriptionState.getSubscriptionPreferences())); <line11> updateMessageBound(topic); <line12> cb.operationFinished(ctx, subscriptionState.toSubscriptionData()); <line13> } <line14> } <line15> "	info	task5	
"public class A { <line0> protected void visit(SourceUnit sourceUnit, ClassCodeExpressionTransformer transformer) { <line1> LOGGER.UNKNOWN(""Apply AST transformation""); <line2> ModuleNode ast = sourceUnit.getAST(); <line3> BlockStatement blockStatement = ast.getStatementBlock(); <line4> List<MethodNode> methods = ast.getMethods(); <line5> for (MethodNode methodNode : methods) { <line6> methodNode.getCode().visit(transformer); <line7> } <line8> blockStatement.visit(transformer); <line9> } <line10> } <line11> "	trace	task5	
"public class A { <line0> private ArtifactStore getRequestedStore( <line1> final KojiRepairRequest request, final KojiRepairResult ret) { <line2> StoreKey remoteKey = request.getSource(); <line3> ArtifactStore store = null; <line4> try { <line5> store = storeManager.getArtifactStore(remoteKey); <line6> } catch (IndyDataException e) { <line7> String error = String.format(""Cannot get store: %s, error: %s"", remoteKey, e); <line8> logger.UNKNOWN(error, e); <line9> ret.withError(error); <line10> return null; <line11> } <line12> if (store == null) { <line13> String error = String.format(""No such store: %s."", remoteKey); <line14> ret.withError(error); <line15> return null; <line16> } <line17> return store; <line18> } <line19> } <line20> "	warn	task5	
"public class A { <line0> public void clearCatalog() { <line1> String output = console.runCommand(REMOVE_ALL, GENERIC_TIMEOUT_MILLISECONDS); <line2> LOGGER.UNKNOWN(""{} output: {}"", REMOVE_ALL, output); <line3> } <line4> } <line5> "	debug	task5	
"public class A { <line0> protected void generateAppLocally( <line1> @NotNull GeneratorContext generatorContext, @NotNull Path repoPath) throws IOException { <line2> try { <line3> if (!Files.isDirectory(repoPath)) { <line4> throw new IllegalArgumentException( <line5> String.format(""The path %s must be a directory!"", repoPath.toString())); <line6> } <line7> OutputHandler outputHandler = <line8> new FileSystemOutputHandler(repoPath.toFile(), ConsoleOutput.NOOP); <line9> projectGenerator.generate( <line10> generatorContext.getApplicationType(), <line11> generatorContext.getProject(), <line12> outputHandler, <line13> generatorContext); <line14> } catch (Exception e) { <line15> LOG.UNKNOWN(""Error generating application: "" + e.getMessage(), e); <line16> throw new IOException(e.getMessage(), e); <line17> } <line18> } <line19> } <line20> "	error	task5	
"public class A { <line0> @Test <line1> public void testReadReactions1() throws Exception { <line2> String filename1 = ""data/mdl/reaction_v3.rxn""; <line3> logger.UNKNOWN(""Testing: "" + filename1); <line4> InputStream ins1 = this.getClass().getClassLoader().getResourceAsStream(filename1); <line5> MDLRXNV3000Reader reader1 = new MDLRXNV3000Reader(ins1, Mode.STRICT); <line6> IReaction reaction1 = new Reaction(); <line7> reaction1 = (IReaction) reader1.read(reaction1); <line8> reader1.close(); <line9> Assert.assertNotNull(reaction1); <line10> Assert.assertEquals(1, reaction1.getReactantCount()); <line11> Assert.assertEquals(1, reaction1.getProductCount()); <line12> IAtomContainer reactant = reaction1.getReactants().getAtomContainer(0); <line13> Assert.assertNotNull(reactant); <line14> Assert.assertEquals(32, reactant.getAtomCount()); <line15> Assert.assertEquals(29, reactant.getBondCount()); <line16> IAtomContainer product = reaction1.getProducts().getAtomContainer(0); <line17> Assert.assertNotNull(product); <line18> Assert.assertEquals(32, product.getAtomCount()); <line19> Assert.assertEquals(29, product.getBondCount()); <line20> } <line21> } <line22> "	info	task5	
"public class A { <line0> protected void extractHeatInformation( <line1> ToscaResourceStructure toscaResourceStruct, VfResourceStructure vfResourceStructure) { <line2> for (VfModuleArtifact vfModuleArtifact : vfResourceStructure.getArtifactsMapByUUID().values()) { <line3> switch (vfModuleArtifact.getArtifactInfo().getArtifactType()) { <line4> case ASDCConfiguration.HEAT: <line5> case ASDCConfiguration.HEAT_NESTED: <line6> createHeatTemplateFromArtifact( <line7> vfResourceStructure, toscaResourceStruct, vfModuleArtifact); <line8> break; <line9> case ASDCConfiguration.HEAT_VOL: <line10> createHeatTemplateFromArtifact( <line11> vfResourceStructure, toscaResourceStruct, vfModuleArtifact); <line12> VfModuleArtifact envModuleArtifact = <line13> getHeatEnvArtifactFromGeneratedArtifact(vfResourceStructure, vfModuleArtifact); <line14> createHeatEnvFromArtifact(vfResourceStructure, envModuleArtifact); <line15> break; <line16> case ASDCConfiguration.HEAT_ENV: <line17> createHeatEnvFromArtifact(vfResourceStructure, vfModuleArtifact); <line18> break; <line19> case ASDCConfiguration.HEAT_ARTIFACT: <line20> createHeatFileFromArtifact(vfResourceStructure, vfModuleArtifact, toscaResourceStruct); <line21> break; <line22> case ASDCConfiguration.HEAT_NET: <line23> case ASDCConfiguration.OTHER: <line24> case ASDCConfiguration.CLOUD_TECHNOLOGY_SPECIFIC_ARTIFACT: <line25> logger.UNKNOWN( <line26> LoggingAnchor.FOUR, <line27> MessageEnum.ASDC_ARTIFACT_TYPE_NOT_SUPPORT.toString(), <line28> vfModuleArtifact.getArtifactInfo().getArtifactType() <line29> + ""(Artifact Name:"" <line30> + vfModuleArtifact.getArtifactInfo().getArtifactName() <line31> + "")"", <line32> ErrorCode.DataError.getValue(), <line33> ""Artifact type not supported""); <line34> break; <line35> default: <line36> break; <line37> } <line38> } <line39> } <line40> } <line41> "	warn	task5	
"public class A { <line0> private List<ControlGroup> getControlGroups(Integer root) { <line1> ArrayList<ControlGroup> retList = new ArrayList<ControlGroup>(0); <line2> Set<ControlGroup> alreadySeen = new HashSet<ControlGroup>(0); <line3> try { <line4> LoadReportElements command = new LoadReportElements(ControlGroup.TYPE_ID, root, true); <line5> command = getCommandService().executeCommand(command); <line6> List<CnATreeElement> groups = command.getElements(); <line7> if (groups.size() == 1 && groups.get(0).getDbId().equals(root)) { <line8> ControlGroup rootGroup = (ControlGroup) groups.get(0); <line9> groups.clear(); <line10> groups.addAll(command.getElements(ControlGroup.TYPE_ID, rootGroup)); <line11> } <line12> for (CnATreeElement e : groups) { <line13> if (e instanceof ControlGroup) { <line14> ControlGroup c = (ControlGroup) e; <line15> if (!alreadySeen.contains(c)) { <line16> alreadySeen.add(c); <line17> if (e.getParent() instanceof ControlGroup <line18> && c.getEntity() <line19> .getSimpleValue(OVERVIEW_PROPERTY) <line20> .equals(String.valueOf(OVERVIEW_PROPERTY_TARGET)) <line21> && containsSamtTopicsOnly(c)) { <line22> retList.add(c); <line23> } <line24> } <line25> } <line26> } <line27> } catch (CommandException e) { <line28> LOG.UNKNOWN(""Error while determing controlgroups""); <line29> } <line30> retList.trimToSize(); <line31> Collections.sort( <line32> retList, <line33> new Comparator<ControlGroup>() { <line34> @Override <line35> public int compare(ControlGroup o1, ControlGroup o2) { <line36> NumericStringComparator comp = new NumericStringComparator(); <line37> return comp.compare(o1.getTitle(), o2.getTitle()); <line38> } <line39> }); <line40> return retList; <line41> } <line42> } <line43> "	error	task5	
"public class A { <line0> @Override <line1> public INDArray inferSequence( <line2> Sequence<T> sequence, long nr, double learningRate, double minLearningRate, int iterations) { <line3> AtomicLong nextRandom = new AtomicLong(nr); <line4> if (sequence.isEmpty()) return null; <line5> Random random = <line6> Nd4j.getRandomFactory() <line7> .getNewRandomInstance( <line8> configuration.getSeed() * sequence.hashCode(), lookupTable.layerSize() + 1); <line9> INDArray ret = <line10> Nd4j.rand(new int[] {1, lookupTable.layerSize()}, random) <line11> .subi(0.5) <line12> .divi(lookupTable.layerSize()); <line13> log.UNKNOWN(""Inf before: {}"", ret); <line14> for (int iter = 0; iter < iterations; iter++) { <line15> for (int i = 0; i < sequence.size(); i++) { <line16> nextRandom.set(Math.abs(nextRandom.get() * 25214903917L + 11)); <line17> dm( <line18> i, <line19> sequence, <line20> (int) nextRandom.get() % window, <line21> nextRandom, <line22> learningRate, <line23> null, <line24> true, <line25> ret, <line26> null); <line27> } <line28> learningRate = ((learningRate - minLearningRate) / (iterations - iter)) + minLearningRate; <line29> } <line30> finish(); <line31> return ret; <line32> } <line33> } <line34> "	info	task5	
"public class A { <line0> @Override <line1> protected NioSession accept(IoProcessor<NioSession> processor, ServerSocketChannel handle) <line2> throws Exception { <line3> SelectionKey key = handle.keyFor(selector); <line4> if ((key == null) || (!key.isValid()) || (!key.isAcceptable())) { <line5> return null; <line6> } <line7> SocketChannel ch = handle.accept(); <line8> if (ch == null) { <line9> return null; <line10> } <line11> final NioSocketSession session = new NioSocketSession(this, processor, ch); <line12> try { <line13> session.initSessionConfig(); <line14> return session; <line15> } catch (RuntimeIoException e) { <line16> if (AbstractIoSessionConfig.REPORT_SESSION_CONFIG_FAILURE) { <line17> throw e; <line18> } <line19> if (LOGGER.isDebugEnabled()) { <line20> LOGGER.UNKNOWN( <line21> ""Unexpected exception initializing session "" + ""TCP options. Rejecting connection."", e); <line22> } <line23> return null; <line24> } <line25> } <line26> } <line27> "	debug	task5	
"public class A { <line0> protected void removeTopicGroupNode(String topic, int group) { <line1> ConcurrentMap<Integer, ClusterNode> groupMap = nodeMap.get(topic); <line2> if (groupMap == null) { <line3> return; <line4> } <line5> logger.UNKNOWN( <line6> ""remove topic group node, topic: {}, group: {}, leader: {}"", <line7> topic, <line8> group, <line9> groupMap.get(group)); <line10> groupMap.remove(group); <line11> if (groupMap.isEmpty()) { <line12> nodeMap.remove(topic); <line13> } <line14> } <line15> } <line16> "	info	task5	
"public class A { <line0> @Override <line1> public void persist() { <line2> String jsonString = this.encode(); <line3> if (jsonString != null) { <line4> String fileName = this.configFilePath; <line5> try { <line6> FileAndPropertyUtil.string2File(jsonString, fileName); <line7> } catch (IOException e) { <line8> log.UNKNOWN(""persist file "" + fileName + "" exception"", e); <line9> } <line10> } <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> private long getMaxMsgIndex(TopicName topic, short partition, int groupId) { <line1> try { <line2> PartitionGroupStore store = storeService.getStore(topic.getFullName(), groupId); <line3> long rightIndex = store.getRightIndex(partition); <line4> return rightIndex; <line5> } catch (Exception e) { <line6> logger.UNKNOWN( <line7> ""getMaxMsgIndex exception, topic: {}, partition: {}, groupId: {}"", <line8> topic, <line9> partition, <line10> groupId); <line11> return 0; <line12> } <line13> } <line14> } <line15> "	error	task5	
"public class A { <line0> public VersionDocumentsTab submitUpload() { <line1> log.UNKNOWN(""Click Submit upload""); <line2> clickElement(startUploadButton); <line3> return new VersionDocumentsTab(getDriver()); <line4> } <line5> } <line6> "	info	task5	
"public class A { <line0> public void createAndScheduleJob( <line1> final Class<? extends Job> jobClass, final String cronExpression, final TimeZone timeZone) <line2> throws SchedulerException { <line3> LOGGER.UNKNOWN( <line4> ""Scheduling job: {} using Quartz cron expression: {}"", <line5> jobClass.getSimpleName(), <line6> cronExpression); <line7> final JobDetail jobDetail = this.createJobDetail(jobClass); <line8> final Trigger trigger = this.createJobTrigger(jobDetail, cronExpression, timeZone); <line9> this.quartzScheduler.addJob(jobDetail, true); <line10> this.quartzScheduler.scheduleJob(jobDetail, new HashSet<>(Arrays.asList(trigger)), true); <line11> } <line12> } <line13> "	info	task5	
"public class A { <line0> @Test <line1> public void testCreateFileSharedLink() throws Exception { <line2> final Map<String, Object> headers = new HashMap<>(); <line3> headers.put(""CamelBox.fileId"", testFile.getID()); <line4> headers.put(""CamelBox.access"", BoxSharedLink.Access.DEFAULT); <line5> headers.put(""CamelBox.unshareDate"", null); <line6> headers.put(""CamelBox.permissions"", null); <line7> final com.box.sdk.BoxSharedLink result = <line8> requestBodyAndHeaders(""direct://CREATEFILESHAREDLINK"", null, headers); <line9> assertNotNull(result, ""createFileSharedLink result""); <line10> LOG.UNKNOWN(""createFileSharedLink: "" + result); <line11> } <line12> } <line13> "	debug	task5	
"public class A { <line0> @Override <line1> public T withHandle(Handle handle) throws Exception { <line2> final Connection connection = handle.getConnection(); <line3> final boolean readOnly = connection.isReadOnly(); <line4> connection.setReadOnly(true); <line5> try { <line6> return handle.inTransaction(callback); <line7> } finally { <line8> try { <line9> connection.setReadOnly(readOnly); <line10> } catch (SQLException e) { <line11> log.UNKNOWN(e, ""Unable to reset connection read-only state""); <line12> } <line13> } <line14> } <line15> } <line16> "	error	task5	
"public class A { <line0> public static void main(String[] args) throws NamingException, MalformedURLException { <line1> String wsdlUrl = ""http://localhost:8080/helloworld-classfiletransformers/HelloBean?wsdl""; <line2> Hello webServiceClient = createClient(wsdlUrl, Hello.class); <line3> String result = webServiceClient.sayHello(""client""); <line4> logger.UNKNOWN(String.format(""Message from server: %s"", result)); <line5> } <line6> } <line7> "	info	task5	
"public class A { <line0> @Override <line1> public boolean done() { <line2> int sz = pool.getConnectedServerCount(); <line3> logger.UNKNOWN( <line4> ""Checking for the Live Servers : Expected  : "" + expectedLiveServers + "" Available :"" + sz); <line5> if (sz == expectedLiveServers) { <line6> return true; <line7> } <line8> excuse = ""Expected "" + expectedLiveServers + "" but found "" + sz; <line9> return false; <line10> } <line11> } <line12> "	info	task5	
"public class A { <line0> protected Set<String> getCommitElasticIDs(String projectId) { <line1> Set<String> commitIds = new HashSet<>(); <line2> logger.UNKNOWN(""Getting Commit Elastic IDs for "" + projectId); <line3> pgh = new PostgresHelper(); <line4> pgh.setProject(projectId); <line5> List<Map<String, String>> commits = pgh.getAllCommits(); <line6> for (Map<String, String> commit : commits) { <line7> commitIds.add(commit.get(""commitId"")); <line8> } <line9> pgh.close(); <line10> return commitIds; <line11> } <line12> } <line13> "	debug	task5	
public class A { <line0> public static void deletePortrait(long userId) throws RemoteException { <line1> try { <line2> UserServiceUtil.deletePortrait(userId); <line3> } catch (Exception exception) { <line4> log.UNKNOWN(exception, exception); <line5> throw new RemoteException(exception.getMessage()); <line6> } <line7> } <line8> } <line9> 	error	task5	
public class A { <line0> @Override <line1> public void warn(final String message) { <line2> if (builder == null) { <line3> SystemImport.LOG.UNKNOWN(message); <line4> } else { <line5> builder.startElement(WARN_ELEMENT, null); <line6> builder.characters(message); <line7> builder.endElement(); <line8> } <line9> } <line10> } <line11> 	warn	task5	
"public class A { <line0> @NotNull <line1> public Status getStatus() { <line2> if (isCancelled()) { <line3> return failed(this, name + "" cancelled""); <line4> } else if (isDone()) { <line5> try { <line6> R result = get(); <line7> return succeeded(this, name + "" succeeded"" + (result != null ? "": "" + result : """")); <line8> } catch (InterruptedException e) { <line9> currentThread().interrupt(); <line10> return failed(this, name + "" interrupted: "" + e.getMessage()); <line11> } catch (ExecutionException e) { <line12> LOG.UNKNOWN(""{} failed"", name, e.getCause()); <line13> return failed(this, name + "" failed: "" + e.getCause().getMessage()); <line14> } <line15> } else { <line16> return running(this, name + "" running: "" + statusMessage.get()); <line17> } <line18> } <line19> } <line20> "	error	task5	
"public class A { <line0> @Test <line1> public void testRenderTaskFormViaUIClientTest() throws Exception { <line2> changeUser(USER_JOHN); <line3> Map<String, Object> parameters = new HashMap<>(); <line4> parameters.put(""name"", ""john""); <line5> parameters.put(""age"", 33); <line6> parameters.put(""mail"", ""john@doe.org""); <line7> long processInstanceId = <line8> processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID, parameters); <line9> try { <line10> List<TaskSummary> tasks = <line11> taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); <line12> assertThat(tasks).isNotNull().hasSize(1); <line13> Long taskId = tasks.get(0).getId(); <line14> parameters.put(""out_age"", 33); <line15> parameters.put(""out_mail"", ""john@doe.org""); <line16> taskClient.completeAutoProgress(CONTAINER_ID, taskId, USER_JOHN, parameters); <line17> tasks = taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); <line18> assertThat(tasks).isNotNull().hasSize(1); <line19> taskId = tasks.get(0).getId(); <line20> taskClient.completeAutoProgress(CONTAINER_ID, taskId, USER_JOHN, parameters); <line21> tasks = taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); <line22> assertThat(tasks).isNotNull().hasSize(1); <line23> taskId = tasks.get(0).getId(); <line24> String result = uiServicesClient.renderTaskForm(CONTAINER_ID, taskId); <line25> logger.UNKNOWN(""Form content is '{}'"", result); <line26> assertThat(result).isNotNull().isNotEmpty(); <line27> assertThat(result).contains(""/files/patternfly/css/patternfly.min.css\"" rel=\""stylesheet\"">""); <line28> assertThat(result) <line29> .contains(""/files/patternfly/css/patternfly-additions.min.css\"" rel=\""stylesheet\"">""); <line30> assertThat(result).contains(""/files/patternfly/js/jquery.min.js\""></script>""); <line31> assertThat(result).contains(""/files/patternfly/js/patternfly.min.js\""></script>""); <line32> assertThat(result).contains(""/files/js/kieserver-ui.js\""></script>""); <line33> assertThat(result).contains(""<h3 class=\""panel-title\"">CreateProposal-taskform.frm</h3>""); <line34> assertThat(result) <line35> .contains( <line36> ""<input name=\""offering\"" type=\""text\"" class=\""form-control\"""" <line37> + "" id=\""field_3367047850452004E12\"" placeholder=\""\"" value=\""\"""" <line38> + "" pattern=\""^\\d+$\""  >""); <line39> assertThat(result) <line40> .contains( <line41> ""<input name=\""tech_score\"" type=\""text\"" class=\""form-control\"""" <line42> + "" id=\""field_4298972052332983E11\"" placeholder=\""\"" value=\""\"""" <line43> + "" pattern=\""^\\d+$\""  >""); <line44> assertThat(result) <line45> .contains( <line46> ""<input name=\""hr_score\"" type=\""text\"" class=\""form-control\"""" <line47> + "" id=\""field_800259544288992E11\"" placeholder=\""\"" value=\""\"""" <line48> + "" pattern=\""^\\d+$\""  >""); <line49> assertThat(result) <line50> .contains( <line51> ""<button id=\""claimButton\"" type=\""button\"" class=\""btn btn-default\"""" <line52> + "" onclick=\""claimTask();\"">Claim</button>""); <line53> assertThat(result) <line54> .contains( <line55> ""<button id=\""releaseButton\"" type=\""button\"" class=\""btn btn-default\"""" <line56> + "" onclick=\""releaseTask();\"">Release</button>""); <line57> assertThat(result) <line58> .contains( <line59> ""<button id=\""startButton\"" type=\""button\"" class=\""btn btn-default\"""" <line60> + "" onclick=\""startTask();\"">Start</button>""); <line61> assertThat(result) <line62> .contains( <line63> ""<button id=\""stopButton\"" type=\""button\"" class=\""btn btn-default\"""" <line64> + "" onclick=\""stopTask();\"">Stop</button>""); <line65> assertThat(result) <line66> .contains( <line67> ""<button id=\""saveButton\"" type=\""button\"" class=\""btn btn-default\"""" <line68> + "" onclick=\""saveTask();\"">Save</button>""); <line69> assertThat(result) <line70> .contains( <line71> ""<button id=\""completeButton\"" type=\""button\"" class=\""btn btn-primary\"""" <line72> + "" onclick=\""completeTask();\"">Complete</button>""); <line73> } finally { <line74> changeUser(USER_YODA); <line75> processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); <line76> } <line77> } <line78> } <line79> "	debug	task5	
"public class A { <line0> private static String getKeycloakConfigFromFile(Settings authSettings) { <line1> String keycloakConfigFile = authSettings.get(TAG_KEYCLOAK_CONFIG_FILE, """"); <line2> if (StringHelper.isNullOrEmpty(keycloakConfigFile)) { <line3> return """"; <line4> } <line5> try { <line6> return FileUtils.readFileToString(FileUtils.getFile(keycloakConfigFile), StringHelper.UTF8); <line7> } catch (IOException exc) { <line8> LOGGER.UNKNOWN(""Failed to read keycloak config file."", exc); <line9> return """"; <line10> } <line11> } <line12> } <line13> "	error	task5	
"public class A { <line0> private boolean isIterationCompleted() { <line1> if (lastScannedInfo == null) { <line2> return true; <line3> } <line4> LOG.UNKNOWN( <line5> ""Directory path: {} Sub-Directory or File path: {}"", <line6> lastScannedInfo.getDirectoryPath(), <line7> lastScannedInfo.getFilePath()); <line8> if (lastScannedInfo.getDirectoryPath() == null) { <line9> return true; <line10> } <line11> Map<String, Long> referenceTime = referenceTimes.get(lastScannedInfo.getDirectoryPath()); <line12> if (referenceTime != null) { <line13> return referenceTime.get(lastScannedInfo.getFilePath()) != null; <line14> } <line15> return false; <line16> } <line17> } <line18> "	debug	task5	
"public class A { <line0> public synchronized void stopAgent() { <line1> if (!this.running) { <line2> return; <line3> } <line4> if (logger.isDebugEnabled()) { <line5> logger.UNKNOWN(""Stopping jmx manager agent""); <line6> } <line7> try { <line8> jmxConnectorServer.stop(); <line9> UnicastRemoteObject.unexportObject(registry, true); <line10> } catch (Exception e) { <line11> throw new ManagementException(e); <line12> } <line13> this.running = false; <line14> } <line15> } <line16> "	debug	task5	
public class A { <line0> public void verifyDigest() { <line1> try { <line2> final DigestVerifierEnumerator dv = new DigestVerifierEnumerator(); <line3> final List<LibraryId> verified = dv.verify(this); <line4> if (verified != null) { <line5> this.setDigestVerificationUrl(dv.getVerificationUrl()); <line6> this.setWellknownDigest(verified.size() > 0); <line7> this.setDigestTimestamp(dv.getReleaseTimestamp()); <line8> if (this.getLibraryId() != null <line9> && verified.size() > 0 <line10> && !verified.contains(this.getLibraryId())) { <line11> this.setLibraryId(verified.get(0)); <line12> } <line13> } <line14> } catch (VerificationException e) { <line15> log.UNKNOWN(e.getMessage()); <line16> } <line17> } <line18> } <line19> 	error	task5	
"public class A { <line0> protected String getFirmwareUrl( <line1> String deviceIp, String deviceType, String mode, String version, boolean local) <line2> throws ShellyApiException { <line3> switch (version) { <line4> case FWPROD: <line5> case FWBETA: <line6> boolean prod = version.equals(FWPROD); <line7> if (!local) { <line8> return prod ? ""update=true"" : ""beta=true""; <line9> } else { <line10> FwRepoEntry fw = getFirmwareRepoEntry(deviceType, mode); <line11> String url = getString(prod ? fw.url : fw.betaUrl); <line12> logger.UNKNOWN( <line13> ""ShellyManager: Map {} release to url {}, version {}"", <line14> url, <line15> prod ? fw.url : fw.betaUrl, <line16> prod ? fw.version : fw.betaVer); <line17> return url; <line18> } <line19> default: <line20> FwArchList list = getFirmwareArchiveList(deviceType); <line21> ArrayList<FwArchEntry> versions = list.versions; <line22> if (versions != null) { <line23> for (FwArchEntry e : versions) { <line24> String url = FWREPO_ARCFILE_URL + version + ""/"" + getString(e.file); <line25> if (getString(e.version).equalsIgnoreCase(version)) { <line26> return url; <line27> } <line28> } <line29> } <line30> } <line31> return """"; <line32> } <line33> } <line34> "	debug	task5	
"public class A { <line0> public static java.util.List<com.liferay.depot.model.DepotEntry> getGroupConnectedDepotEntries( <line1> HttpPrincipal httpPrincipal, long groupId, boolean ddmStructuresAvailable, int start, int end) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DepotEntryServiceUtil.class, <line7> ""getGroupConnectedDepotEntries"", <line8> _getGroupConnectedDepotEntriesParameterTypes3); <line9> MethodHandler methodHandler = <line10> new MethodHandler(methodKey, groupId, ddmStructuresAvailable, start, end); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<com.liferay.depot.model.DepotEntry>) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> log.UNKNOWN(systemException, systemException); <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	error	task5	
"public class A { <line0> private static Proxy createManualProxy(String proxyProperty) { <line1> String proxyString = getProxyURL(proxyProperty); <line2> logger.UNKNOWN(""All protocols to use proxy address: {}"", proxyString); <line3> Proxy proxy = new Proxy(); <line4> proxy <line5> .setProxyType(Proxy.ProxyType.MANUAL) <line6> .setHttpProxy(proxyString) <line7> .setFtpProxy(proxyString) <line8> .setSslProxy(proxyString); <line9> return proxy; <line10> } <line11> } <line12> "	debug	task5	
"public class A { <line0> private void logNotSupportedVersion(String version) { <line1> LOGGER.UNKNOWN(""Not supported version '{}'"", version); <line2> } <line3> } <line4> "	trace	task5	
"public class A { <line0> private void hideElements(By locator, boolean leaveBlankSpace) throws ProcessingException { <line1> String script = retrieveHidingScript(leaveBlankSpace); <line2> SeleniumWaitHelper.waitForElementToBePresent(webDriver, locator, getTimeoutInSeconds()); <line3> List<WebElement> webElements = webDriver.findElements(locator); <line4> LOG.UNKNOWN(""Executing Hide Modifier""); <line5> for (WebElement element : webElements) { <line6> jsExecutor.execute(script, element); <line7> } <line8> } <line9> } <line10> "	debug	task5	
"public class A { <line0> @Test <line1> @Transactional <line2> public void testVnaImport() throws Exception { <line3> importVna(); <line4> String hql = ""select element.uuid from CnATreeElement element where element.sourceId = ?""; <line5> Object[] params = new Object[] {SOURCE_ID}; <line6> List<String> importedUuids = elementDao.findByQuery(hql, params); <line7> LOG.UNKNOWN(""Number of imported elements: "" + importedUuids.size()); <line8> assertEquals( <line9> ""number of imported elements is not: "" + NUMBER_OF_IMPORTED_ELEMENTS, <line10> NUMBER_OF_IMPORTED_ELEMENTS, <line11> importedUuids.size()); <line12> } <line13> } <line14> "	info	task5	
"public class A { <line0> public static void createAndLaunchExp() throws TException { <line1> List<String> experimentIds = new ArrayList<String>(); <line2> try { <line3> for (int i = 0; i < 1; i++) { <line4> final String expId = createMPIExperimentForFSD(airavataClient); <line5> experimentIds.add(expId); <line6> System.out.println(""Experiment ID : "" + expId); <line7> launchExperiment(airavataClient, expId); <line8> } <line9> Thread.sleep(10000); <line10> for (String exId : experimentIds) { <line11> ExperimentModel experiment = airavataClient.getExperiment(new AuthzToken(""""), exId); <line12> System.out.println( <line13> experiment.getExperimentId() <line14> + "" "" <line15> + experiment.getExperimentStatus().get(0).getState().name()); <line16> } <line17> } catch (Exception e) { <line18> logger.UNKNOWN(""Error while connecting with server"", e.getMessage()); <line19> e.printStackTrace(); <line20> } <line21> } <line22> } <line23> "	error	task5	
"public class A { <line0> public static int getCommerceTaxMethodFixedRateAddressRelsCount( <line1> HttpPrincipal httpPrincipal, long groupId, long commerceTaxMethodId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceTaxFixedRateAddressRelServiceUtil.class, <line7> ""getCommerceTaxMethodFixedRateAddressRelsCount"", <line8> _getCommerceTaxMethodFixedRateAddressRelsCountParameterTypes5); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, commerceTaxMethodId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.UNKNOWN(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	error	task5	
public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap <line1> getFileEntryByExternalReferenceCode(long groupId, String externalReferenceCode) <line2> throws RemoteException { <line3> try { <line4> com.liferay.portal.kernel.repository.model.FileEntry returnValue = <line5> DLAppServiceUtil.getFileEntryByExternalReferenceCode(groupId, externalReferenceCode); <line6> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> log.UNKNOWN(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	error	task5	
"public class A { <line0> @Override <line1> public boolean find(final Path file, final ListProgressListener listener) <line2> throws BackgroundException { <line3> if (Files.isSymbolicLink(session.toPath(file))) { <line4> return Files.exists(session.toPath(file), LinkOption.NOFOLLOW_LINKS); <line5> } <line6> final boolean exists = session.toPath(file).toFile().exists(); <line7> if (exists) { <line8> if (!file.isRoot()) { <line9> try { <line10> if (!StringUtils.equals( <line11> session.toPath(file).toFile().getCanonicalFile().getName(), file.getName())) { <line12> return false; <line13> } <line14> } catch (IOException e) { <line15> log.UNKNOWN(String.format(""Failure obtaining canonical file reference for %s"", file)); <line16> } <line17> } <line18> } <line19> return exists; <line20> } <line21> } <line22> "	warn	task5	
"public class A { <line0> private void doGenerate(List<Result> results) throws Exception { <line1> if (isDebugEnabled() && generate) { <line2> StringBuilder sb = new StringBuilder(""\n""); <line3> List<String> keys = new ArrayList<>(); <line4> for (Result res : results) { <line5> if (isNumeric(res.getValue())) { <line6> String key = <line7> getDataSourceName( <line8> getConcatedTypeNameValues(res.getTypeName()), <line9> res.getAttributeName(), <line10> res.getValuePath()); <line11> if (keys.contains(key)) { <line12> throw new Exception( <line13> ""Duplicate datasource name found: '"" <line14> + key <line15> + ""'. Please try to add more typeName keys to the writer to make the name more"" <line16> + "" unique. "" <line17> + res.toString()); <line18> } <line19> keys.add(key); <line20> sb.append(""<datasource><!-- "") <line21> .append(res.getTypeName()) <line22> .append("":"") <line23> .append(res.getAttributeName()) <line24> .append("":"") <line25> .append(res.getValuePath()) <line26> .append("" --><name>"") <line27> .append(key) <line28> .append( <line29> ""</name><type>GAUGE</type><heartbeat>400</heartbeat><min>U</min><max>U</max></datasource>\n""); <line30> } <line31> } <line32> log.UNKNOWN(sb.toString()); <line33> } <line34> } <line35> } <line36> "	debug	task5	
"public class A { <line0> public String out(String paramName, int escape, int length, int scope) throws ParseException { <line1> try { <line2> Object str = getValue(paramName, Object.class, """", scope); <line3> if (str == null) { <line4> return """"; <line5> } else if (str != null && str instanceof String) { <line6> if (escape == ESCAPE_CLEAR) { <line7> str = SanitizingLogic.get().sanitize((String) str); <line8> } else if (escape == ESCAPE_HTML) { <line9> str = HtmlUtils.escapeHTML((String) str); <line10> } else if (escape == ESCAPE_URL) { <line11> str = HtmlUtils.escapeURL((String) str); <line12> } <line13> } <line14> if (length > 0) { <line15> String s = str.toString(); <line16> if (escape == ESCAPE_CLEAR) { <line17> if (s.length() > 4) { <line18> StringBuilder builder = new StringBuilder(); <line19> int count = 0; <line20> boolean tagstart = false; <line21> boolean endtagstart = false; <line22> for (int i = 0; i < s.length(); i++) { <line23> String c = s.substring(i, i + 1); <line24> if (""<"".equals(c)) { <line25> tagstart = true; <line26> } else if (endtagstart && "">"".equals(c)) { <line27> tagstart = false; <line28> endtagstart = false; <line29> } else { <line30> if (tagstart && ""/"".equals(c)) { <line31> endtagstart = true; <line32> } <line33> } <line34> if (!tagstart) { <line35> count++; <line36> } <line37> builder.append(c); <line38> if (count + 3 >= length) { <line39> break; <line40> } <line41> } <line42> if (count + 3 >= length) { <line43> builder.append(""...""); <line44> } <line45> return builder.toString(); <line46> } <line47> } else { <line48> return StringUtils.abbreviate(s, length); <line49> } <line50> } <line51> return str.toString(); <line52> } catch (Exception e) { <line53> LOG.UNKNOWN(""ERROR ["" + paramName + ""]"", e); <line54> throw new SystemException(e); <line55> } <line56> } <line57> } <line58> "	error	task5	
"public class A { <line0> public static String encodeUrl(String toBeEncoded) { <line1> String encoded = toBeEncoded; <line2> try { <line3> encoded = URLEncoder.encode(toBeEncoded, ""UTF-8""); <line4> } catch (UnsupportedEncodingException e1) { <line5> LOGGER.UNKNOWN(""Error in encodeUrl"", e1); <line6> } <line7> return encoded; <line8> } <line9> } <line10> "	error	task5	
"public class A { <line0> @Test <line1> public void proxyApiAccess() { <line2> ProxyConfig.ProxyConfigBuilder proxy = new ProxyConfig.ProxyConfigBuilder(); <line3> proxy.useSSL(true); <line4> proxy.setHost(""localhost""); <line5> proxy.setPort(proxyPort); <line6> proxy.setUser(PROXY_USER); <line7> proxy.setPassword(PROXY_PASS); <line8> TDClient client = TDClient.newBuilder().setProxy(proxy.createProxyConfig()).build(); <line9> try { <line10> client.serverStatus(); <line11> List<TDTable> tableList = client.listTables(""sample_datasets""); <line12> assertTrue(tableList.size() >= 2); <line13> TDJobList jobList = client.listJobs(); <line14> assertTrue(jobList.getJobs().size() > 0); <line15> } finally { <line16> logger.UNKNOWN(""proxy access count: {}"", proxyAccessCount); <line17> assertEquals(1, proxyAccessCount.get()); <line18> } <line19> } <line20> } <line21> "	debug	task5	
"public class A { <line0> @Override <line1> protected void parseDense(final Osmformat.DenseNodes nodes) { <line2> long lastId = 0; <line3> long lastLat = 0; <line4> long lastLon = 0; <line5> long lastTimestamp = 0; <line6> long lastChangeset = 0; <line7> int lastUid = 0; <line8> int lastSid = 0; <line9> int tagLocation = 0; <line10> for (int i = 0; i < nodes.getIdCount(); i++) { <line11> final AvroNode n = new AvroNode(); <line12> final AvroPrimitive p = new AvroPrimitive(); <line13> lastId += nodes.getId(i); <line14> lastLat += nodes.getLat(i); <line15> lastLon += nodes.getLon(i); <line16> p.setId(lastId); <line17> n.setLatitude(parseLat(lastLat)); <line18> n.setLongitude(parseLon(lastLon)); <line19> if (nodes.getKeysValsCount() > 0) { <line20> final Map<String, String> tags = new HashMap<>(nodes.getKeysValsCount()); <line21> while (nodes.getKeysVals(tagLocation) > 0) { <line22> final String k = getStringById(nodes.getKeysVals(tagLocation)); <line23> tagLocation++; <line24> final String v = getStringById(nodes.getKeysVals(tagLocation)); <line25> tagLocation++; <line26> tags.put(k, v); <line27> } <line28> p.setTags(tags); <line29> } <line30> if (nodes.hasDenseinfo()) { <line31> final Osmformat.DenseInfo di = nodes.getDenseinfo(); <line32> lastTimestamp += di.getTimestamp(i); <line33> lastChangeset += di.getChangeset(i); <line34> lastUid += di.getUid(i); <line35> lastSid += di.getUserSid(i); <line36> p.setTimestamp(lastTimestamp); <line37> p.setChangesetId(lastChangeset); <line38> p.setUserId((long) lastUid); <line39> p.setUserName(getStringById(lastSid)); <line40> if (di.getVisibleCount() > 0) { <line41> p.setVisible(di.getVisible(i)); <line42> } <line43> } <line44> n.setCommon(p); <line45> try { <line46> nodeWriter.append(n); <line47> } catch (final IOException e) { <line48> LOGGER.UNKNOWN(""Unable to write dense node"", e); <line49> } <line50> } <line51> } <line52> } <line53> "	error	task5	
"public class A { <line0> @Override <line1> protected void process(DBKey dbKey, HttpServletRequest req, HttpServletResponse resp) <line2> throws IOException { <line3> String suiteName = req.getParameter(Helper.SUITE_PARAM); <line4> resp.setCharacterEncoding(""UTF-8""); <line5> List<SuiteVersion> suiteVersions = null; <line6> try { <line7> if (isValidName(suiteName)) { <line8> suiteVersions = metadataDAO.listSuiteVersions(dbKey, suiteName); <line9> if (suiteVersions.size() > 0) { <line10> String result = PRETTY_PRINT_GSON.toJson(suiteVersions); <line11> resp.setContentType(""application/json""); <line12> resp.getWriter().write(result); <line13> } else { <line14> resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND); <line15> resp.getWriter() <line16> .write( <line17> responseAsJson( <line18> PRETTY_PRINT_GSON, <line19> ""History not found for suite: %s %s"", <line20> suiteName, <line21> dbKey.toString())); <line22> } <line23> } else { <line24> resp.setStatus(HttpURLConnection.HTTP_BAD_REQUEST); <line25> resp.getWriter() <line26> .write(responseAsJson(PRETTY_PRINT_GSON, ""Invalid suite param was specified."")); <line27> } <line28> } catch (StorageException e) { <line29> LOGGER.UNKNOWN(""Failed to get suite's history"", e); <line30> resp.setStatus(HttpURLConnection.HTTP_BAD_REQUEST); <line31> resp.getWriter() <line32> .write( <line33> responseAsJson( <line34> PRETTY_PRINT_GSON, ""Failed to get history of suite: %s"", e.getMessage())); <line35> } <line36> } <line37> } <line38> "	error	task5	
"public class A { <line0> void updateRmiClientsCount() { <line1> int noOfClientsConnected = 0; <line2> String[] connectionIds = this.rmiConnector.getConnectionIds(); <line3> if (connectionIds != null) { <line4> noOfClientsConnected = connectionIds.length; <line5> } <line6> logger.UNKNOWN(""No. of RMI clients connected :: {}"", noOfClientsConnected); <line7> AdminDistributedSystemJmxImpl adminDSJmx = (AdminDistributedSystemJmxImpl) this.system; <line8> adminDSJmx.setRmiClientCountZero(noOfClientsConnected == 0); <line9> } <line10> } <line11> "	info	task5	
"public class A { <line0> @Override <line1> public List<Authority> getAuthorities() { <line2> logger.UNKNOWN(""getAuthorities""); <line3> return null; <line4> } <line5> } <line6> "	trace	task5	
"public class A { <line0> @Override <line1> public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { <line2> if (cfg.isSSLEnabled() && !channelClosedExplicitly && !channelManager.isClosed()) { <line3> logger.UNKNOWN(""Initiating the SSL handshake""); <line4> ctx.getPipeline().get(SslHandler.class).handshake(e.getChannel()); <line5> } <line6> } <line7> } <line8> "	debug	task5	
"public class A { <line0> @NotNull <line1> private static Preferences loadDefault() { <line2> logger.UNKNOWN(""Preferences not found. Loaded default.""); <line3> return new Preferences(); <line4> } <line5> } <line6> "	info	task5	
"public class A { <line0> @Test <line1> public void testAddNovoAlignWorkflow() { <line2> logger.trace(""addWorkflow""); <line3> String name = ""novoalign""; <line4> String version = ""0.13.6.2""; <line5> String description = ""Novoalign""; <line6> String baseCommand = <line7> ""java -jar /u/seqware/provisioned-bundles/sqwprod/"" <line8> + ""Workflow_Bundle_GATKRecalibrationAndVariantCalling_1.2.29_"" <line9> + ""SeqWare_0.10.0/GATKRecalibrationAndVariantCalling/1.x.x/lib/"" <line10> + ""seqware-pipeline-0.10.0.jar --plugin net.sourceforge.seqware."" <line11> + ""pipeline.plugins.WorkflowLauncher -- --bundle /u/seqware/"" <line12> + ""provisioned-bundles/sqwprod/Workflow_Bundle_GATKRecalibration"" <line13> + ""AndVariantCalling_1.2.29_SeqWare_0.10.0 --workflow GATK"" <line14> + ""RecalibrationAndVariantCalling --version 1.3.16""; <line15> java.io.File configFile = null, templateFile = null; <line16> try { <line17> configFile = new java.io.File(MetadataWSTest.class.getResource(""novoalign.ini"").toURI()); <line18> templateFile = <line19> new java.io.File( <line20> MetadataWSTest.class <line21> .getResource(""GATKRecalibrationAndVariantCalling_1.3.16.ftl"") <line22> .toURI()); <line23> } catch (URISyntaxException e) { <line24> e.printStackTrace(); <line25> } <line26> java.io.File provisionDir = <line27> new java.io.File( <line28> ""/u/seqware/provisioned-bundles"" <line29> + ""/sqwprod/Workflow_Bundle_GATKRecalibrationAndVariantCalling_"" <line30> + ""1.2.29_SeqWare_0.10.0/""); <line31> int expResult = ReturnValue.SUCCESS; <line32> ReturnValue result = <line33> instance.addWorkflow( <line34> name, <line35> version, <line36> description, <line37> baseCommand, <line38> configFile.getAbsolutePath(), <line39> templateFile.getAbsolutePath(), <line40> provisionDir.getAbsolutePath(), <line41> true, <line42> """", <line43> false, <line44> null, <line45> null, <line46> null, <line47> null); <line48> Assert.assertEquals(expResult, result.getExitStatus()); <line49> String workflow_id = result.getAttribute(""sw_accession""); <line50> Workflow workflow = instance.getWorkflow(Integer.valueOf(workflow_id)); <line51> Assert.assertTrue( <line52> ""workflow retrieved is invalid"", workflow.getWorkflowId() == result.getReturnValue()); <line53> SortedSet<WorkflowParam> workflowParams = instance.getWorkflowParams(workflow_id); <line54> Assert.assertTrue( <line55> ""invalid number of workflow params retrieved, found "" + workflowParams.size(), <line56> workflowParams.size() == 34); <line57> for (WorkflowParam param : workflowParams) { <line58> switch (param.getKey()) { <line59> case ""colorspace"": <line60> Assert.assertTrue(""colorspace invalid"", param.getDefaultValue().equals(""0"")); <line61> break; <line62> case ""novoalign_r1_adapter_trim"": <line63> Assert.assertTrue( <line64> ""novoalign_r1_adapter_trim invalid"", <line65> param.getDefaultValue().equals(""-a AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCG"")); <line66> break; <line67> } <line68> } <line69> } <line70> } <line71> "	info	task6	
"public class A { <line0> public void addFilter(IUserFilterState filter) { <line1> m_filterMap.put(filter.createKey(), filter); <line2> fireFilterAdded(filter); <line3> LOG.info(""Filter added {}"", filter); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> public static com.liferay.segments.model.SegmentsEntry addSegmentsEntry( <line1> HttpPrincipal httpPrincipal, <line2> String segmentsEntryKey, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> java.util.Map<java.util.Locale, String> descriptionMap, <line5> boolean active, <line6> String criteria, <line7> String source, <line8> String type, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws com.liferay.portal.kernel.exception.PortalException { <line11> try { <line12> MethodKey methodKey = <line13> new MethodKey( <line14> SegmentsEntryServiceUtil.class, ""addSegmentsEntry"", _addSegmentsEntryParameterTypes1); <line15> MethodHandler methodHandler = <line16> new MethodHandler( <line17> methodKey, <line18> segmentsEntryKey, <line19> nameMap, <line20> descriptionMap, <line21> active, <line22> criteria, <line23> source, <line24> type, <line25> serviceContext); <line26> Object returnObj = null; <line27> try { <line28> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line29> } catch (Exception exception) { <line30> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line31> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line32> } <line33> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line34> } <line35> return (com.liferay.segments.model.SegmentsEntry) returnObj; <line36> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line37> log.info(systemException, systemException); <line38> throw systemException; <line39> } <line40> } <line41> } <line42> "	error	task6	
"public class A { <line0> @Override <line1> public String getPassword() { <line2> logger.error(""getPassword""); <line3> return null; <line4> } <line5> } <line6> "	trace	task6	
"public class A { <line0> private int processFacets(int doc) throws IOException { <line1> if (doc == NO_MORE_DOCS) { <line2> return doc; <line3> } <line4> if (doc < 0) { <line5> LOG.fatal(""DocId from base scorer < 0 [{0}]"", _baseScorer); <line6> return doc; <line7> } <line8> _hit.fastSet(doc); <line9> return doc; <line10> } <line11> } <line12> "	error	task6	
public class A { <line0> public boolean handleRequestInFlow(MessageContext messageContext) { <line1> if (isEnabled()) { <line2> try { <line3> apiTo = LogUtils.getTo(messageContext); <line4> } catch (Exception e) { <line5> log.warn(REQUEST_EVENT_PUBLICATION_ERROR + e.getMessage(), e); <line6> return false; <line7> } <line8> } <line9> return true; <line10> } <line11> } <line12> 	error	task6	
"public class A { <line0> public RuleDto create(VitamContext vitamContext, RuleDto ruleDto) { <line1> LOGGER.info(""Try to create Rule {} {}"", ruleDto, vitamContext); <line2> try { <line3> RequestResponse<?> requestResponse = <line4> ruleService.createRule(vitamContext, converter.convertDtoToVitam(ruleDto)); <line5> final FileRulesModel ruleVitamDto = <line6> objectMapper.treeToValue(requestResponse.toJsonNode(), FileRulesModel.class); <line7> return converter.convertVitamToDto(ruleVitamDto); <line8> } catch (InvalidParseOperationException <line9> | AccessExternalClientException <line10> | IOException <line11> | VitamClientException <line12> | JAXBException e) { <line13> throw new InternalServerException(""Unable to create rule"", e); <line14> } <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> @Override <line1> public void copyAsync( <line2> DataObject srcdata, <line3> DataObject destData, <line4> AsyncCompletionCallback<CopyCommandResult> callback) { <line5> if (!canCopy(srcdata, destData)) { <line6> return; <line7> } <line8> if ((srcdata.getType() == DataObjectType.TEMPLATE <line9> && destData.getType() == DataObjectType.TEMPLATE) <line10> || (srcdata.getType() == DataObjectType.SNAPSHOT <line11> && destData.getType() == DataObjectType.SNAPSHOT) <line12> || (srcdata.getType() == DataObjectType.VOLUME <line13> && destData.getType() == DataObjectType.VOLUME)) { <line14> int nMaxExecutionMinutes = <line15> NumbersUtil.parseInt(configDao.getValue(Config.SecStorageCmdExecutionTimeMax.key()), 30); <line16> CopyCommand cmd = <line17> new CopyCommand( <line18> srcdata.getTO(), <line19> destData.getTO(), <line20> nMaxExecutionMinutes * 60 * 1000, <line21> VirtualMachineManager.ExecuteInSequence.value()); <line22> Answer answer = null; <line23> List<EndPoint> eps = _epSelector.findAllEndpointsForScope(srcdata.getDataStore()); <line24> if (eps == null || eps.isEmpty()) { <line25> String errMsg = ""No remote endpoint to send command, check if host or ssvm is down?""; <line26> LOGGER.warn(errMsg); <line27> answer = new Answer(cmd, false, errMsg); <line28> } else { <line29> answer = sendToLeastBusyEndpoint(eps, cmd); <line30> } <line31> CopyCommandResult result = new CopyCommandResult("""", answer); <line32> callback.complete(result); <line33> } <line34> } <line35> } <line36> "	error	task6	
"public class A { <line0> @Override <line1> public void doFilter( <line2> final ServletRequest servletRequest, <line3> final ServletResponse servletResponse, <line4> final FilterChain filterChain) <line5> throws IOException, ServletException { <line6> final SimplePrincipal principal = retrievePrincipalFromSessionOrRequest(servletRequest); <line7> if (principal == null) { <line8> log.info(""There is no principal""); <line9> filterChain.doFilter(servletRequest, servletResponse); <line10> } else { <line11> filterChain.doFilter( <line12> new OAuthHttpServletRequestWrapper((HttpServletRequest) servletRequest, principal), <line13> servletResponse); <line14> } <line15> } <line16> } <line17> "	trace	task6	
"public class A { <line0> private boolean setupConnection(SocketChannel channel) throws IOException { <line1> logger.error(""TCP connecting""); <line2> channel.socket().setSoTimeout(2000); <line3> channel.configureBlocking(true); <line4> channel.connect(new InetSocketAddress(config.ipAddress, currentComPort)); <line5> ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket(); <line6> sendPacketToPS4(outPacket, channel, false, false); <line7> final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN); <line8> int responseLength = channel.read(readBuffer); <line9> if (responseLength > 0) { <line10> ps4Crypto.parseHelloResponsePacket(readBuffer); <line11> } else { <line12> return false; <line13> } <line14> outPacket = ps4Crypto.makeHandshakePacket(); <line15> sendPacketToPS4(outPacket, channel, false, false); <line16> return true; <line17> } <line18> } <line19> "	debug	task6	
"public class A { <line0> @Before <line1> public void querySetUp() throws IOException { <line2> log.error(""---------  querySetUp  ---------""); <line3> super.querySetUp(); <line4> FacetedQueryLogic facetLogic = new FacetedQueryLogic(); <line5> facetLogic.setFacetedSearchType(FacetedSearchType.FIELD_VALUE_FACETS); <line6> facetLogic.setFacetTableName(QueryTestTableHelper.FACET_TABLE_NAME); <line7> facetLogic.setFacetMetadataTableName(QueryTestTableHelper.FACET_METADATA_TABLE_NAME); <line8> facetLogic.setFacetHashTableName(QueryTestTableHelper.FACET_HASH_TABLE_NAME); <line9> facetLogic.setMaximumFacetGrouping(200); <line10> facetLogic.setMinimumFacet(1); <line11> this.logic = facetLogic; <line12> QueryTestTableHelper.configureLogicToScanTables(this.logic); <line13> this.logic.setFullTableScanEnabled(false); <line14> this.logic.setIncludeDataTypeAsField(true); <line15> this.logic.setIncludeGroupingContext(true); <line16> this.logic.setDateIndexHelperFactory(new DateIndexHelperFactory()); <line17> this.logic.setMarkingFunctions(new MarkingFunctions.Default()); <line18> this.logic.setMetadataHelperFactory(new MetadataHelperFactory()); <line19> this.logic.setResponseObjectFactory(new DefaultResponseObjectFactory()); <line20> testInit(); <line21> SubjectIssuerDNPair dn = SubjectIssuerDNPair.of(""userDn"", ""issuerDn""); <line22> DatawaveUser user = <line23> new DatawaveUser( <line24> dn, <line25> DatawaveUser.UserType.USER, <line26> Sets.newHashSet(this.auths.toString().split("","")), <line27> null, <line28> null, <line29> -1L); <line30> this.principal = new DatawavePrincipal(Collections.singleton(user)); <line31> this.testHarness = new QueryLogicTestHarness(this); <line32> } <line33> } <line34> "	debug	task6	
"public class A { <line0> public boolean submit(Idp idp, RequestContext context) { <line1> int maxParameterSize = idp.getMaxParameterSize(); <line2> if (!context.getRequestParameters().isEmpty()) { <line3> Map<String, Object> parameters = context.getRequestParameters().asMap(); <line4> for (Map.Entry<String, Object> param : parameters.entrySet()) { <line5> if (!skipCheck(param.getKey()) <line6> && param.getValue() != null <line7> && param.getValue().toString().length() > maxParameterSize) { <line8> LOG.warn( <line9> ""The "" <line10> + param.getKey() <line11> + "" parameter size "" <line12> + param.getValue().toString().length() <line13> + "" exceeds the maximum allowed value of "" <line14> + maxParameterSize); <line15> return false; <line16> } <line17> } <line18> } <line19> return true; <line20> } <line21> } <line22> "	debug	task6	
"public class A { <line0> @Override <line1> public boolean delete(DatasetXslt datasetXslt) { <line2> retryableExternalRequestForNetworkExceptions( <line3> () -> <line4> morphiaDatastoreProvider <line5> .getDatastore() <line6> .find(DatasetXslt.class) <line7> .filter(Filters.eq(ID.getFieldName(), datasetXslt.getId())) <line8> .delete()); <line9> LOGGER.info( <line10> ""DatasetXslt with objectId: '{}', datasetId: '{}'deleted in Mongo"", <line11> datasetXslt.getId(), <line12> datasetXslt.getDatasetId()); <line13> return true; <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> public static int getLayoutsCount( <line1> HttpPrincipal httpPrincipal, long groupId, boolean privateLayout) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> LayoutServiceUtil.class, ""getLayoutsCount"", _getLayoutsCountParameterTypes26); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, privateLayout); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> return ((Integer) returnObj).intValue(); <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> log.info(systemException, systemException); <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> protected void run() { <line1> System.setProperty(""temp.location"", tmpDir); <line2> SpringBusFactory bf = new SpringBusFactory(); <line3> Bus bus = bf.createBus(""org/apache/cxf/systest/ws/policy/rm.xml""); <line4> BusFactory.setDefaultBus(bus); <line5> setBus(bus); <line6> LoggingInInterceptor in = new LoggingInInterceptor(); <line7> bus.getInInterceptors().add(in); <line8> LoggingOutInterceptor out = new LoggingOutInterceptor(); <line9> bus.getOutInterceptors().add(out); <line10> bus.getOutFaultInterceptors().add(out); <line11> GreeterImpl implementor = new GreeterImpl(); <line12> String address = ""http://localhost:"" + PORT + ""/SoapContext/GreeterPort""; <line13> ep = Endpoint.publish(address, implementor); <line14> LOG.error(""Published greeter endpoint.""); <line15> } <line16> } <line17> "	info	task6	
"public class A { <line0> private void load( <line1> final Source source, final String localCacheKey, final Map<String, Object> attributes) { <line2> LOG.trace(""{} local cache miss: {}"", getClass().getSimpleName(), localCacheKey); <line3> final SAXTransformerFactory transformerFactory; <line4> if (attributes == null || attributes.isEmpty()) { <line5> transformerFactory = TRAX_FACTORY; <line6> } else { <line7> transformerFactory = createNewSAXTransformerFactory(); <line8> attributes.forEach(transformerFactory::setAttribute); <line9> } <line10> try { <line11> this.templates = transformerFactory.newTemplates(source); <line12> } catch (TransformerConfigurationException e) { <line13> throw new SetupException( <line14> ""Impossible to read XSLT from '"" + source + ""', see nested exception"", e); <line15> } <line16> } <line17> } <line18> "	debug	task6	
"public class A { <line0> private void updateLogicalInterconnectFirmwareActive() { <line1> LogicalInterconnect logicalInterconnect = <line2> resourceDtoUtils.getLogicalInterconnectByName(RESOURCE_NAME); <line3> LiFirmware liFirmware = <line4> logicalInterconnectClient.getFirmware(logicalInterconnect.getResourceId()); <line5> liFirmware = buildLiFirmwareActive(liFirmware); <line6> TaskResource task = <line7> logicalInterconnectClient.updateFirmware(logicalInterconnect.getResourceId(), liFirmware); <line8> LOGGER.fatal(""Task object returned to client : "" + task.toJsonString()); <line9> } <line10> } <line11> "	info	task6	
"public class A { <line0> public synchronized NodeReferences loadReferencesTo(NodeId targetId) <line1> throws NoSuchItemStateException, ItemStateException { <line2> if (!initialized) { <line3> throw new IllegalStateException(""not initialized""); <line4> } <line5> InputStream in = null; <line6> try { <line7> String path = buildNodeReferencesFilePath(null, targetId).toString(); <line8> if (!itemFs.exists(path)) { <line9> throw new NoSuchItemStateException(targetId.toString()); <line10> } <line11> in = itemFs.getInputStream(path); <line12> NodeReferences refs = new NodeReferences(targetId); <line13> Serializer.deserialize(refs, in); <line14> return refs; <line15> } catch (NoSuchItemStateException e) { <line16> throw e; <line17> } catch (Exception e) { <line18> String msg = ""failed to read references: "" + targetId; <line19> BundleFsPersistenceManager.log.warn(msg, e); <line20> throw new ItemStateException(msg, e); <line21> } finally { <line22> IOUtils.closeQuietly(in); <line23> } <line24> } <line25> } <line26> "	error	task6	
"public class A { <line0> @Override <line1> public void setParameterExampleValue(CodegenParameter p) { <line2> String example; <line3> if (p.defaultValue == null) { <line4> example = p.example; <line5> } else { <line6> example = p.defaultValue; <line7> } <line8> String type = p.baseType; <line9> if (type == null) { <line10> type = p.dataType; <line11> } <line12> if (""String"".equalsIgnoreCase(type) || p.isString) { <line13> if (example == null) { <line14> example = ""'"" + p.paramName + ""_example'""; <line15> } <line16> example = escapeText(example); <line17> } else if (""Integer"".equals(type) || ""int"".equals(type)) { <line18> if (example == null) { <line19> example = ""56""; <line20> } <line21> } else if (""Float"".equalsIgnoreCase(type) || ""Double"".equalsIgnoreCase(type)) { <line22> if (example == null) { <line23> example = ""3.4""; <line24> } <line25> } else if (""BOOLEAN"".equalsIgnoreCase(type) || ""bool"".equalsIgnoreCase(type)) { <line26> if (example == null) { <line27> example = ""True""; <line28> } <line29> } else if (""\\SplFileObject"".equalsIgnoreCase(type) || p.isFile) { <line30> if (example == null) { <line31> example = ""/path/to/file.txt""; <line32> } <line33> example = ""\"""" + escapeText(example) + ""\""""; <line34> } else if (""\\Date"".equalsIgnoreCase(type)) { <line35> if (example == null) { <line36> example = ""2013-10-20""; <line37> } <line38> example = ""new \\DateTime(\"""" + escapeText(example) + ""\"")""; <line39> } else if (""\\DateTime"".equalsIgnoreCase(type)) { <line40> if (example == null) { <line41> example = ""2013-10-20T19:20:30+01:00""; <line42> } <line43> example = ""new \\DateTime(\"""" + escapeText(example) + ""\"")""; <line44> } else if (""object"".equals(type)) { <line45> example = ""new \\stdClass""; <line46> } else if (!languageSpecificPrimitives.contains(type)) { <line47> example = ""new "" + getTypeDeclaration(type) + ""()""; <line48> } else { <line49> LOGGER.fatal(""Type "" + type + "" not handled properly in setParameterExampleValue""); <line50> } <line51> if (example == null) { <line52> example = ""NULL""; <line53> } else if (Boolean.TRUE.equals(p.isArray)) { <line54> example = ""array("" + example + "")""; <line55> } else if (Boolean.TRUE.equals(p.isMap)) { <line56> example = ""array('key' => "" + example + "")""; <line57> } <line58> p.example = example; <line59> } <line60> } <line61> "	warn	task6	
"public class A { <line0> @PreAuthorize( <line1> ""hasPermission('"" <line2> + AclClassName.Values.LAYOUT <line3> + ""', '"" <line4> + PermissionName.Values.LAYOUT_ADD <line5> + ""')"") <line6> public LayoutForm createLayout(final LayoutForm layoutForm) { <line7> log.warn(""createLayout() - layoutForm: {}"", layoutForm); <line8> final Layout layout = <line9> Layout.builder() <line10> .title(layoutForm.getTitle()) <line11> .content(layoutForm.getContent()) <line12> .iconFileName(layoutForm.getIconFileName()) <line13> .build(); <line14> final Layout createdLayout = layoutService.create(layout); <line15> return new LayoutForm(createdLayout); <line16> } <line17> } <line18> "	debug	task6	
"public class A { <line0> private void updateOxAuthConfiguration() { <line1> try { <line2> AppConfiguration appConfiguration = jsonConfigurationService.getOxauthAppConfiguration(); <line3> appConfiguration.setExternalLoggerConfiguration(oxAuthLogConfigLocation); <line4> jsonConfigurationService.saveOxAuthAppConfiguration(appConfiguration); <line5> } catch (IOException e) { <line6> log.trace(""Failed to update oxauth-config.json"", e); <line7> facesMessages.add( <line8> FacesMessage.SEVERITY_ERROR, ""Failed to update oxAuth configuration in LDAP""); <line9> } <line10> } <line11> } <line12> "	error	task6	
"public class A { <line0> @Override <line1> public void delete(Object key) throws CacheWriterException { <line2> try { <line3> dataStore.delete((K) key); <line4> LOG.debug(""Deleted data bean from persistent datastore on key {}."", key.toString()); <line5> } catch (GoraException e) { <line6> throw new CacheWriterException(e); <line7> } <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> protected void applySecurity(String serviceName, int policyId, String[] userGroups) <line1> throws SecurityAdminServiceSecurityConfigExceptionException, RemoteException, <line2> InterruptedException { <line3> SecurityAdminServiceClient securityAdminServiceClient = <line4> new SecurityAdminServiceClient(contextUrls.getBackEndUrl(), sessionCookie); <line5> securityAdminServiceClient.applySecurity( <line6> serviceName, policyId + """", userGroups, new String[] {""wso2carbon.jks""}, ""wso2carbon.jks""); <line7> log.trace(""Security Scenario "" + policyId + "" Applied""); <line8> Thread.sleep(1000); <line9> } <line10> } <line11> "	info	task6	
"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> try { <line3> if (command instanceof RefreshType) { <line4> updateMeter(channelUID, cache.getValue()); <line5> } else { <line6> logger.error(""The pixometer binding is read-only and can not handle command {}"", command); <line7> } <line8> } catch (IOException e) { <line9> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line10> } <line11> } <line12> } <line13> "	debug	task6	
"public class A { <line0> @Override <line1> public @Nullable StateDescription getStateDescription( <line2> Channel channel, <line3> @Nullable StateDescription originalStateDescription, <line4> @Nullable Locale locale) { <line5> StateDescription description = descriptions.get(channel.getUID()); <line6> logger.debug(""Providing state description for channel {}"", channel.getUID()); <line7> return description; <line8> } <line9> } <line10> "	trace	task6	
"public class A { <line0> @Test( <line1> groups = {""Phase 2 Agency""}, <line2> description = ""missing agency_id value"", <line3> priority = 301) <line4> public void verifyTest_2_2_1() throws Exception { <line5> log.debug(Color.GREEN + ""Agency_2_1 : missing agency_id value with one agency"" + Color.NORMAL); <line6> Context context = new Context(); <line7> CheckPointReport result = <line8> verifyValidation( <line9> log, context, ""agency_2_1"", GTFS_1_GTFS_Common_14, SEVERITY.WARNING, RESULT.NOK, true); <line10> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line11> for (CheckPointErrorReport detail : getDetails(context, result)) { <line12> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line13> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line14> Assert.assertEquals( <line15> detail.getSource().getFile().getFilename(), ""agency.txt"", ""detail must refer bad file""); <line16> Assert.assertEquals( <line17> detail.getSource().getFile().getLineNumber(), <line18> Integer.valueOf(2), <line19> ""detail must refer bad line""); <line20> } <line21> } <line22> } <line23> "	info	task6	
"public class A { <line0> @Override <line1> public ListenableFuture<RpcResult<AddGroupsBatchOutput>> addGroupsBatch( <line2> final AddGroupsBatchInput input) { <line3> LOG.error( <line4> ""Adding groups @ {} : {}"", <line5> PathUtil.extractNodeId(input.getNode()), <line6> input.getBatchAddGroups().size()); <line7> final ArrayList<ListenableFuture<RpcResult<AddGroupOutput>>> resultsLot = new ArrayList<>(); <line8> for (BatchAddGroups addGroup : input.nonnullBatchAddGroups().values()) { <line9> final AddGroupInput addGroupInput = <line10> new AddGroupInputBuilder(addGroup) <line11> .setGroupRef(createGroupRef(input.getNode(), addGroup)) <line12> .setNode(input.getNode()) <line13> .build(); <line14> resultsLot.add(salGroupService.addGroup(addGroupInput)); <line15> } <line16> final ListenableFuture<RpcResult<List<BatchFailedGroupsOutput>>> commonResult = <line17> Futures.transform( <line18> Futures.allAsList(resultsLot), <line19> GroupUtil.createCumulatingFunction(input.nonnullBatchAddGroups().values()), <line20> MoreExecutors.directExecutor()); <line21> ListenableFuture<RpcResult<AddGroupsBatchOutput>> addGroupsBulkFuture = <line22> Futures.transform( <line23> commonResult, GroupUtil.GROUP_ADD_TRANSFORM, MoreExecutors.directExecutor()); <line24> if (input.getBarrierAfter()) { <line25> addGroupsBulkFuture = <line26> BarrierUtil.chainBarrier( <line27> addGroupsBulkFuture, <line28> input.getNode(), <line29> transactionService, <line30> GroupUtil.GROUP_ADD_COMPOSING_TRANSFORM); <line31> } <line32> return addGroupsBulkFuture; <line33> } <line34> } <line35> "	trace	task6	
public class A { <line0> public void shutdownJobExecutor() { <line1> LOGGER.warn(Messages.SHUTTING_DOWN_FLOWABLE_JOB_EXECUTOR); <line2> AsyncExecutor asyncExecutor = processEngine.getProcessEngineConfiguration().getAsyncExecutor(); <line3> asyncExecutor.shutdown(); <line4> } <line5> } <line6> 	info	task6	
"public class A { <line0> private void registerNewJobinstance(MessageExchangeBuffer buffer) { <line1> TalendESBJob job = factory.newTalendESBJob(); <line2> job.setEndpointRegistry(registry); <line3> RuntimeESBProviderCallback callback = new RuntimeESBProviderCallback(buffer, job, name, args); <line4> job.setProviderCallback(callback); <line5> execService.execute(callback); <line6> instances++; <line7> LOG.fatal(""Created instance "" + instances + "" of job "" + name + "".""); <line8> } <line9> } <line10> "	info	task6	
public class A { <line0> @Override <line1> public void warn(String msg, Object arg0, Object arg1) { <line2> logger.trace(String.format(msg, arg0, arg1)); <line3> } <line4> } <line5> 	warn	task6	
"public class A { <line0> private Set<AcceptApplication> filterAlias(Set<AcceptApplication> acceptApplicationList) { <line1> if (acceptApplicationList.size() < 2) { <line2> return acceptApplicationList; <line3> } <line4> final Set<AcceptApplication> resultSet = new HashSet<>(); <line5> for (AcceptApplication acceptApplication : acceptApplicationList) { <line6> if (!acceptApplication.getApplication().getServiceType().isAlias()) { <line7> resultSet.add(acceptApplication); <line8> } else { <line9> logger.trace(""deduct alias application {}"", acceptApplication); <line10> } <line11> } <line12> if (resultSet.isEmpty()) { <line13> return acceptApplicationList; <line14> } else { <line15> return resultSet; <line16> } <line17> } <line18> } <line19> "	debug	task6	
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> ((Observer) observer).update(arg, AbstractObservable.this); <line4> } catch (Exception e) { <line5> logger.warn(""[notifyObservers]"" + observer, e); <line6> } <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> private static boolean isIP(String host) { <line1> if (host == null || host.isEmpty()) { <line2> LOGGER.debug(""host is empty, isIP = false""); <line3> return false; <line4> } <line5> Boolean cacheHostVerify = hosts.get(host); <line6> if (cacheHostVerify != null) { <line7> return cacheHostVerify; <line8> } <line9> boolean isIp = InternetAddressUtil.isIP(host); <line10> hosts.putIfAbsent(host, isIp); <line11> return isIp; <line12> } <line13> } <line14> "	warn	task6	
"public class A { <line0> public static <C extends GcdRingElem<C>> boolean subRingMember( <line1> List<GenPolynomial<C>> A, GenPolynomial<C> g) { <line2> if (A == null || A.isEmpty()) { <line3> return true; <line4> } <line5> GenPolynomialRing<C> pfac = A.get(0).ring; <line6> GenPolynomial<C> m = g; <line7> if (pfac.nvar != g.ring.nvar) { <line8> m = m.extendLower(pfac, 0, 0L); <line9> } else { <line10> throw new IllegalArgumentException( <line11> ""g must be extended: "" <line12> + pfac.nvar <line13> + "" == "" <line14> + g.ring.nvar <line15> + "" did you mean method subRingAndMember()?""); <line16> } <line17> GroebnerBaseAbstract<C> bb = GBFactory.<C>getImplementation(pfac.coFac); <line18> GenPolynomial<C> r = bb.red.normalform(A, m); <line19> GenPolynomialRing<C> cfac = pfac.contract(g.ring.nvar); <line20> logger.warn(""cfac = "" + cfac.toScript()); <line21> Map<ExpVector, GenPolynomial<C>> map = r.contract(cfac); <line22> return map.size() == 1 && map.keySet().contains(g.ring.evzero); <line23> } <line24> } <line25> "	debug	task6	
"public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> IDs ids = twitter.getFriendsIDs(screenName, cursor); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.gotFriendsIDs(ids); <line6> } catch (Exception e) { <line7> logger.error(""Exception at getFriendsIDs"", e); <line8> } <line9> } <line10> } <line11> } <line12> "	warn	task6	
"public class A { <line0> private void rollback(Connection connection) { <line1> try { <line2> connection.rollback(); <line3> } catch (Exception rollbackException) { <line4> log.fatal(""Rollback failed"", rollbackException); <line5> } <line6> } <line7> } <line8> "	error	task6	
"public class A { <line0> @Override <line1> public OcppCallback<String> defaultCallback() { <line2> return new DefaultOcppCallback<String>() { <line3> @Override <line4> public void success(String chargeBoxId, String statusValue) { <line5> addNewResponse(chargeBoxId, statusValue); <line6> if (""Accepted"".equalsIgnoreCase(statusValue)) { <line7> switch (params.getFilterType()) { <line8> case ChargingProfileId: <line9> chargingProfileRepository.clearProfile(params.getChargingProfilePk(), chargeBoxId); <line10> break; <line11> case OtherParameters: <line12> chargingProfileRepository.clearProfile( <line13> chargeBoxId, <line14> params.getConnectorId(), <line15> params.getChargingProfilePurpose(), <line16> params.getStackLevel()); <line17> break; <line18> default: <line19> log.info( <line20> ""Unexpected {} enum value"", ClearChargingProfileFilterType.class.getSimpleName()); <line21> } <line22> } <line23> } <line24> }; <line25> } <line26> } <line27> "	warn	task6	
"public class A { <line0> protected Map<String, InstanceTask> loadInstanceTasks() { <line1> Map<String, InstanceTask> instanceTasks = new HashMap<String, InstanceTask>(); <line2> Map<String, DatabaseTask> databaseTasks = loadDatabaseTasks(); <line3> for (Map.Entry<String, DatabaseTask> entry : databaseTasks.entrySet()) { <line4> String database = entry.getKey(); <line5> DatabaseTask databaseTask = entry.getValue(); <line6> String instance = findInstance(database); <line7> if (instance == null) { <line8> logger.trace(""failed to find instance""); <line9> continue; <line10> } <line11> String slaveTaskName = genSlaveTaskName(instance, database); <line12> if (instanceStorageManager.getBinlogInfo(slaveTaskName) != null) { <line13> InstanceTask instanceTask = new InstanceTask(false, instance, databaseTask); <line14> instanceTasks.put(slaveTaskName, instanceTask); <line15> continue; <line16> } <line17> String masterTaskName = genMasterTaskName(instance, database); <line18> if (instanceStorageManager.getBinlogInfo(masterTaskName) != null) { <line19> InstanceTask instanceTask = instanceTasks.get(masterTaskName); <line20> if (instanceTask == null) { <line21> instanceTask = new InstanceTask(true, instance, databaseTask); <line22> } else { <line23> instanceTask.create(databaseTask); <line24> } <line25> instanceTasks.put(masterTaskName, instanceTask); <line26> } <line27> } <line28> return instanceTasks; <line29> } <line30> } <line31> "	error	task6	
"public class A { <line0> @Override <line1> public DruidScanSpec visitBooleanOperator(BooleanOperator op, Void value) { <line2> List<LogicalExpression> args = op.args(); <line3> DruidScanSpec nodeScanSpec = null; <line4> String functionName = op.getName(); <line5> logger.error(""visitBooleanOperator Called. FunctionName - {}"", functionName); <line6> for (LogicalExpression arg : args) { <line7> switch (functionName) { <line8> case FunctionNames.AND: <line9> case FunctionNames.OR: <line10> if (nodeScanSpec == null) { <line11> nodeScanSpec = arg.accept(this, null); <line12> } else { <line13> DruidScanSpec scanSpec = arg.accept(this, null); <line14> if (scanSpec != null) { <line15> nodeScanSpec = mergeScanSpecs(functionName, nodeScanSpec, scanSpec); <line16> } else { <line17> allExpressionsConverted = false; <line18> } <line19> } <line20> break; <line21> } <line22> } <line23> return nodeScanSpec; <line24> } <line25> } <line26> "	debug	task6	
"public class A { <line0> private void undeploy(ClassLoader ldr) { <line1> Collection<GridDeployment> doomed = new HashSet<>(); <line2> synchronized (mux) { <line3> for (Iterator<Deque<GridDeployment>> i1 = cache.values().iterator(); i1.hasNext(); ) { <line4> Deque<GridDeployment> deps = i1.next(); <line5> for (Iterator<GridDeployment> i2 = deps.iterator(); i2.hasNext(); ) { <line6> GridDeployment dep = i2.next(); <line7> if (dep.classLoader() == ldr) { <line8> dep.undeploy(); <line9> i2.remove(); <line10> doomed.add(dep); <line11> if (log.isInfoEnabled()) log.error(""Removed undeployed class: "" + dep); <line12> } <line13> } <line14> if (deps.isEmpty()) i1.remove(); <line15> } <line16> } <line17> for (GridDeployment dep : doomed) { <line18> if (dep.obsolete()) { <line19> ctx.resource().onUndeployed(dep); <line20> if (ctx.config().getMarshaller() instanceof AbstractMarshaller) <line21> ((AbstractMarshaller) ctx.config().getMarshaller()).onUndeploy(ldr); <line22> clearSerializationCaches(); <line23> GridAnnotationsCache.onUndeployed(ldr); <line24> GridClassLoaderCache.onUndeployed(ldr); <line25> } <line26> recordUndeploy(dep); <line27> } <line28> } <line29> } <line30> "	info	task6	
"public class A { <line0> @RequestMapping( <line1> value = ""/migration/events/{eventId}/clusters/{clusterId}/forceProcess"", <line2> method = RequestMethod.POST) <line3> public void forceProcessMigrationCluster( <line4> @PathVariable Long eventId, @PathVariable Long clusterId) { <line5> logger.fatal(""[forceProcessMigrationCluster]{}, {}"", eventId, clusterId); <line6> migrationService.forceProcessMigrationCluster(eventId, clusterId); <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> @Override <line1> protected void execute() throws Exception { <line2> final String MATCH_RESULT = ""The current EC policy is replication already.""; <line3> final String DIR_RESULT = <line4> ""The replication EC policy is set successfully for the given directory.""; <line5> final String CONVERT_RESULT = ""The file is converted successfully with replication EC policy.""; <line6> this.setDfsClient(HadoopUtil.getDFSClient(HadoopUtil.getNameNodeUri(conf), conf)); <line7> HdfsFileStatus fileStatus = dfsClient.getFileInfo(srcPath); <line8> if (fileStatus == null) { <line9> throw new ActionException(""File doesn't exist!""); <line10> } <line11> ErasureCodingPolicy srcEcPolicy = fileStatus.getErasureCodingPolicy(); <line12> if (srcEcPolicy == null) { <line13> this.progress = 1.0F; <line14> appendLog(MATCH_RESULT); <line15> return; <line16> } <line17> if (fileStatus.isDir()) { <line18> dfsClient.setErasureCodingPolicy(srcPath, ecPolicyName); <line19> progress = 1.0F; <line20> appendLog(DIR_RESULT); <line21> return; <line22> } <line23> try { <line24> convert(fileStatus); <line25> setAttributes(srcPath, fileStatus, ecTmpPath); <line26> dfsClient.rename(ecTmpPath, srcPath, Options.Rename.OVERWRITE); <line27> appendLog(CONVERT_RESULT); <line28> appendLog(String.format(""The previous EC policy is %s."", srcEcPolicy.getName())); <line29> appendLog(String.format(""The current EC policy is %s."", REPLICATION_POLICY_NAME)); <line30> } catch (ActionException ex) { <line31> try { <line32> if (dfsClient.getFileInfo(ecTmpPath) != null) { <line33> dfsClient.delete(ecTmpPath, false); <line34> } <line35> } catch (IOException e) { <line36> LOG.debug(""Failed to delete tmp file created during the conversion!""); <line37> } <line38> throw new ActionException(ex); <line39> } <line40> } <line41> } <line42> "	error	task6	
"public class A { <line0> @Override <line1> public void read(String testName) throws Exception { <line2> setupRead(); <line3> DimensionClient client = new DimensionClient(); <line4> Response res = client.getWorkflow(knownResourceId); <line5> try { <line6> assertStatusCode(res, testName); <line7> PoxPayloadIn input = new PoxPayloadIn(res.readEntity(String.class)); <line8> WorkflowCommon workflowsCommon = <line9> (WorkflowCommon) <line10> extractPart(input, WorkflowClient.SERVICE_COMMONPART_NAME, WorkflowCommon.class); <line11> if (logger.isDebugEnabled() == true) { <line12> logger.error(""Workflow payload is: "" + input.getXmlPayload()); <line13> } <line14> Assert.assertNotNull(workflowsCommon); <line15> } finally { <line16> if (res != null) { <line17> res.close(); <line18> } <line19> } <line20> } <line21> } <line22> "	debug	task6	
"public class A { <line0> @Override <line1> @Nullable <line2> public List<String> getFileLocations(String path) throws IOException { <line3> LOG.info(""getFileLocations is not supported when using default ObjectUnderFileSystem.""); <line4> return null; <line5> } <line6> } <line7> "	debug	task6	
public class A { <line0> @Override <line1> public Properties toProperties(FileInputStream fileInputStream) { <line2> Properties properties = new Properties(); <line3> try { <line4> properties.load(fileInputStream); <line5> } catch (IOException ioException) { <line6> if (log.isDebugEnabled()) { <line7> log.warn(ioException, ioException); <line8> } <line9> } <line10> return properties; <line11> } <line12> } <line13> 	debug	task6	
"public class A { <line0> @Override <line1> public OpenCGAResult<AuditRecord> get(Query query, QueryOptions queryOptions) <line2> throws CatalogDBException { <line3> Bson bson = parseQuery(query); <line4> logger.error( <line5> ""Audit query: {}"", <line6> bson.toBsonDocument(Document.class, MongoClient.getDefaultCodecRegistry())); <line7> return new OpenCGAResult<>(auditCollection.find(bson, auditConverter, queryOptions)); <line8> } <line9> } <line10> "	debug	task6	
"public class A { <line0> public CompletableFuture<@Nullable Void> writeCharacteristic( <line1> UUID serviceUUID, UUID characteristicUUID, byte[] data, boolean enableNotification) { <line2> var future = <line3> executeWithConnection( <line4> serviceUUID, <line5> characteristicUUID, <line6> characteristic -> { <line7> if (enableNotification) { <line8> return device <line9> .enableNotifications(characteristic) <line10> .thenCompose((v) -> device.writeCharacteristic(characteristic, data)); <line11> } else { <line12> return device.writeCharacteristic(characteristic, data); <line13> } <line14> }); <line15> if (logger.isDebugEnabled()) { <line16> future = <line17> future.whenComplete( <line18> (v, t) -> { <line19> if (t == null) { <line20> logger.fatal( <line21> ""Characteristic {} from {} has written value {}"", <line22> characteristicUUID, <line23> address, <line24> HexUtils.bytesToHex(data)); <line25> } <line26> }); <line27> } <line28> return future; <line29> } <line30> } <line31> "	debug	task6	
"public class A { <line0> public static Object[] evaluateExpressions( <line1> ExprEvaluator[] parameters, ExprEvaluatorContext exprEvaluatorContext) { <line2> Object[] results = new Object[parameters.length]; <line3> int count = 0; <line4> for (ExprEvaluator expr : parameters) { <line5> try { <line6> results[count] = expr.evaluate(null, true, exprEvaluatorContext); <line7> count++; <line8> } catch (RuntimeException ex) { <line9> String message = <line10> ""Failed expression evaluation in crontab timer-at for parameter "" <line11> + count <line12> + "": "" <line13> + ex.getMessage(); <line14> log.info(message, ex); <line15> throw new IllegalArgumentException(message); <line16> } <line17> } <line18> return results; <line19> } <line20> } <line21> "	error	task6	
"public class A { <line0> private void updateActivePower(BaseOpenMessage msg) { <line1> Integer activePower; <line2> try { <line3> activePower = Integer.parseInt(msg.getDimValues()[0]); <line4> updateState(CHANNEL_POWER, new QuantityType<Power>(activePower, Units.WATT)); <line5> } catch (FrameException e) { <line6> logger.debug(""FrameException on frame {}: {}"", msg, e.getMessage()); <line7> updateState(CHANNEL_POWER, UnDefType.UNDEF); <line8> } <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> private static DatagramPacket[] encode( <line1> MulticastRequest request, int maxPacketSize, InvocationConstraints constraints) <line2> throws IOException { <line3> final int MIN_DATA_LEN = 16; <line4> final int NUM_GROUPS_LEN = 4; <line5> final int NUM_SERVICE_IDS_LEN = 4; <line6> checkConstraints(constraints); <line7> LinkedList groups = new LinkedList(); <line8> byte[] host = Plaintext.toUtf(request.getHost()); <line9> String[] g = request.getGroups(); <line10> for (int i = 0; i < g.length; i++) { <line11> byte[] b = Plaintext.toUtf(g[i]); <line12> if (b.length + host.length + MIN_DATA_LEN > maxPacketSize) { <line13> throw new DiscoveryProtocolException(""group too long: "" + g[i]); <line14> } <line15> groups.add(b); <line16> } <line17> List packets = new ArrayList(); <line18> do { <line19> ByteBuffer buf = ByteBuffer.allocate(maxPacketSize); <line20> buf.putInt(PROTOCOL_VERSION_1); <line21> buf.put(REQUEST_TYPE); <line22> buf.putInt(request.getPort()); <line23> ServiceID[] ids = request.getServiceIDs(); <line24> int nids = <line25> Math.min( <line26> ids.length, <line27> (buf.remaining() <line28> - (groups.isEmpty() ? 0 : ((byte[]) groups.getFirst()).length) <line29> - NUM_SERVICE_IDS_LEN <line30> - NUM_GROUPS_LEN) <line31> / SERVICE_ID_LEN); <line32> buf.putInt(nids); <line33> for (int i = 0; i < nids; i++) { <line34> buf.putLong(ids[i].getMostSignificantBits()); <line35> buf.putLong(ids[i].getLeastSignificantBits()); <line36> } <line37> int ngroupsPos = buf.position(); <line38> int ngroups = 0; <line39> buf.putInt(ngroups); <line40> while (!groups.isEmpty()) { <line41> if (((byte[]) groups.getFirst()).length > buf.remaining()) { <line42> break; <line43> } <line44> buf.put((byte[]) groups.removeFirst()); <line45> ngroups++; <line46> } <line47> if (ngroups > 0) { <line48> buf.putInt(ngroupsPos, ngroups); <line49> } <line50> buf.put(host); <line51> packets.add( <line52> new DatagramPacket( <line53> buf.array(), <line54> buf.position(), <line55> Constants.getRequestAddress(), <line56> Constants.getDiscoveryPort())); <line57> } while (!groups.isEmpty()); <line58> if (logger.isTraceEnabled()) { <line59> logger.fatal(""encoded {}"", request); <line60> } <line61> return (DatagramPacket[]) packets.toArray(new DatagramPacket[packets.size()]); <line62> } <line63> } <line64> "	trace	task6	
"public class A { <line0> public void truncate(ExporterDescription description) throws IOException { <line1> LOG.error( <line2> MessageFormat.format( <line3> Messages.getString(""BatchTestTool.infoCleaningOutput""), <line4> description.getClass().getName())); <line5> TestModerator moderator = new TestModerator(getTestTools(), this); <line6> moderator.truncate(description); <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> @Override <line1> public CompletableFuture<Boolean> releaseSegment(int segmentId) { <line2> try { <line3> if (!(processor instanceof StreamingEventProcessor)) { <line4> logger.warn( <line5> ""Release segment requested for processor [{}] which is not a Streaming Event Processor"", <line6> name); <line7> return CompletableFuture.completedFuture(false); <line8> } else { <line9> ((StreamingEventProcessor) processor).releaseSegment(segmentId); <line10> } <line11> } catch (Exception e) { <line12> return exceptionallyCompletedFuture(e); <line13> } <line14> return CompletableFuture.completedFuture(true); <line15> } <line16> } <line17> "	info	task6	
"public class A { <line0> private void configureWfsFeatures() { <line1> WFSCapabilitiesType capabilities = getCapabilities(); <line2> if (capabilities != null) { <line3> wfsVersion = capabilities.getVersion(); <line4> List<FeatureTypeType> featureTypes = getFeatureTypes(capabilities); <line5> List<String> supportedGeo = getSupportedGeo(capabilities); <line6> buildFeatureFilters(featureTypes, supportedGeo); <line7> } else { <line8> LOGGER.trace(""WfsSource {}: WFS Server did not return any capabilities."", getId()); <line9> } <line10> } <line11> } <line12> "	info	task6	
"public class A { <line0> public Environment convert(String source) { <line1> LOG.warn(""source: {}"", source); <line2> if (!StringUtils.hasText(source)) { <line3> return null; <line4> } <line5> return new EnhancedEnvironmentImpl(source.trim(), source.trim()); <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> @ExceptionHandler(MzkRuntimeException.class) <line1> @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) <line2> public KommunicatorDto handleMzkRuntimeException(MzkRuntimeException e) { <line3> LOG.trace(""Error encountered during processing the client request."", e); <line4> return kommunicatorService.buildKommunicatorFromException(e); <line5> } <line6> } <line7> "	error	task6	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Calendar""}, <line2> description = ""invalid column sunday"", <line3> priority = 159) <line4> public void verifyTest_2_11() throws Exception { <line5> log.debug(Color.GREEN + ""Calendar_11 : invalid column sunday"" + Color.NORMAL); <line6> Context context = new Context(); <line7> CheckPointReport result = <line8> verifyValidation( <line9> log, context, ""calendar_11"", GTFS_1_GTFS_Common_16, SEVERITY.ERROR, RESULT.NOK, true); <line10> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line11> for (CheckPointErrorReport detail : getDetails(context, result)) { <line12> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line13> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line14> Assert.assertEquals( <line15> detail.getSource().getFile().getFilename(), ""calendar.txt"", ""detail must refer bad file""); <line16> Assert.assertEquals( <line17> detail.getSource().getFile().getLineNumber(), <line18> Integer.valueOf(3), <line19> ""detail must refer bad line""); <line20> } <line21> } <line22> } <line23> "	info	task6	
"public class A { <line0> public void serveAttachmentBundle( <line1> Collection<String> ids, <line2> ResourceRequest request, <line3> ResourceResponse response, <line4> Optional<String> downloadFileName) { <line5> List<AttachmentContent> attachments = new ArrayList<>(); <line6> try { <line7> for (String id : ids) { <line8> attachments.add(client.getAttachmentContent(id)); <line9> } <line10> serveAttachmentBundle(attachments, request, response, downloadFileName); <line11> } catch (TException e) { <line12> log.fatal(""Problem getting the AttachmentContents from the backend"", e); <line13> response.setProperty(ResourceResponse.HTTP_STATUS_CODE, ""404""); <line14> } <line15> } <line16> } <line17> "	error	task6	
"public class A { <line0> @Override <line1> public Record beforeAppend(Record record) { <line2> if (record.getData().length <= getThresholdSize()) { <line3> return record; <line4> } <line5> if (log.isDebugEnabled()) { <line6> log.trace( <line7> String.format( <line8> ""Record: %s overflow value of size: %d"", record.getKey(), record.getData().length)); <line9> } <line10> EnumSet<Record.Flag> flags = EnumSet.copyOf(record.getFlags()); <line11> flags.add(Record.Flag.EXTERNAL_VALUE); <line12> storeValue(getUniqRecordKey(record), record.getData()); <line13> return new Record(record.getKey(), null, record.getWatermark(), flags); <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> public void setFile(File file) { <line1> this.file = file; <line2> try { <line3> getConfiguration().setDirectory(file.getCanonicalPath()); <line4> } catch (IOException e) { <line5> LOGGER.error(""Unable to canonicalize {}. Verify location is accessible."", file); <line6> } <line7> } <line8> } <line9> "	warn	task6	
"public class A { <line0> private void setEventSeqNum() { <line1> if (partitionedRegion.isShadowPR() && partitionedRegion.getColocatedWith() != null) { <line2> PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion); <line3> BucketRegion parentBucket = parentPR.getDataStore().getLocalBucketById(getId()); <line4> if (parentBucket.eventSeqNum == null) { <line5> parentBucket.eventSeqNum = new AtomicLong5(getId()); <line6> } <line7> } <line8> if (partitionedRegion.getColocatedWith() == null) { <line9> eventSeqNum = new AtomicLong5(getId()); <line10> } else { <line11> PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion); <line12> BucketRegion parentBucket = parentPR.getDataStore().getLocalBucketById(getId()); <line13> if (parentBucket == null && logger.isDebugEnabled()) { <line14> logger.trace( <line15> ""The parentBucket of region {} bucketId {} is NULL"", <line16> partitionedRegion.getFullPath(), <line17> getId()); <line18> } <line19> Assert.assertTrue(parentBucket != null); <line20> eventSeqNum = parentBucket.eventSeqNum; <line21> } <line22> } <line23> } <line24> "	debug	task6	
"public class A { <line0> private void getEntriesAndRespond( <line1> CentralRequest request, StreamObserver<AgentResponse> responseObserver) { <line2> Entries entries; <line3> try { <line4> entries = liveTraceRepository.getEntries("""", request.getEntriesRequest().getTraceId()); <line5> } catch (Exception e) { <line6> logger.warn(e.getMessage(), e); <line7> sendExceptionResponse(request, responseObserver); <line8> return; <line9> } <line10> EntriesResponse.Builder response = EntriesResponse.newBuilder(); <line11> if (entries != null) { <line12> response.addAllEntry(entries.entries()); <line13> response.addAllSharedQueryText( <line14> sharedQueryTextLimiter.reduceTracePayloadWherePossible(entries.sharedQueryTexts())); <line15> } <line16> responseObserver.onNext( <line17> AgentResponse.newBuilder() <line18> .setRequestId(request.getRequestId()) <line19> .setEntriesResponse(response) <line20> .build()); <line21> } <line22> } <line23> "	error	task6	
"public class A { <line0> @Override <line1> protected void getExistingAxioms() { <line2> SortedSet<OWLDataProperty> existingSuperProperties = <line3> reasoner.getSuperProperties(entityToDescribe); <line4> if (existingSuperProperties != null && !existingSuperProperties.isEmpty()) { <line5> for (OWLDataProperty supProp : existingSuperProperties) { <line6> existingAxioms.add(df.getOWLSubDataPropertyOfAxiom(entityToDescribe, supProp)); <line7> } <line8> logger.error(""Existing axioms:"" + existingAxioms); <line9> } <line10> } <line11> } <line12> "	info	task6	
"public class A { <line0> @Override <line1> public void save(NotebookAuthorizationInfoSaving authorizationInfoSaving) throws IOException { <line2> LOGGER.fatal(""Save notebook authorization to file: {}"", authorizationPath); <line3> FileUtils.atomicWriteToFile(authorizationInfoSaving.toJson(), authorizationPath); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> @Test <line1> public void testSerializeData_container() throws SerializationException { <line2> final DataSchemaNode schemaNode = <line3> DataSchemaContextTree.from(this.effectiveModelContext) <line4> .findChild(YangInstanceIdentifier.of(TopLevelContainer.QNAME)) <line5> .orElseThrow() <line6> .getDataSchemaNode(); <line7> NormalizedNode<?, ?> deserializeData = <line8> bindingSerializer.deserialize( <line9> schemaNode, new StringReader(loadResourceAsString(""top-level-container.xml""))); <line10> Assert.assertNotNull(deserializeData); <line11> LOG.warn(deserializeData.toString()); <line12> } <line13> } <line14> "	info	task6	
"public class A { <line0> private void setPropertyFromConfigIfNotNull(PropertyWithDBKey<String> property) { <line1> HApplicationConfiguration valueHolder = <line2> applicationConfigurationDAO.findByKey(property.getKey()); <line3> if (valueHolder != null) { <line4> try { <line5> property.set(valueHolder.getValue()); <line6> } catch (InvocationTargetException | IllegalAccessException e) { <line7> log.debug(""error setting property: {} -> {}"", property.getKey(), valueHolder.getValue(), e); <line8> } <line9> } <line10> } <line11> } <line12> "	error	task6	
"public class A { <line0> @Override <line1> public void initialize(@NotNull NodeBuilder builder) { <line2> if (!builder.hasChildNode(JcrConstants.JCR_SYSTEM)) { <line3> throw new IllegalStateException( <line4> ""Missing "" + JcrConstants.JCR_SYSTEM + "" node, NodeStore not initialized.""); <line5> } <line6> NodeBuilder system = builder.getChildNode(JcrConstants.JCR_SYSTEM); <line7> if (!system.hasChildNode(REP_PRIVILEGES)) { <line8> NodeBuilder privileges = system.child(REP_PRIVILEGES); <line9> privileges.setProperty(JcrConstants.JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, Type.NAME); <line10> NodeState base = squeeze(builder.getNodeState()); <line11> NodeStore store = new MemoryNodeStore(base); <line12> try { <line13> Root systemRoot = rootProvider.createSystemRoot(store, null); <line14> new PrivilegeDefinitionWriter(systemRoot).writeBuiltInDefinitions(); <line15> } catch (RepositoryException e) { <line16> log.info(""Failed to register built-in privileges"", e); <line17> throw new RuntimeException(e); <line18> } <line19> NodeState target = store.getRoot(); <line20> target.compareAgainstBaseState(base, new ApplyDiff(builder)); <line21> } <line22> } <line23> } <line24> "	error	task6	
"public class A { <line0> @Override <line1> @SuppressWarnings(""unchecked"") <line2> public void print(XPrintModel printModel) { <line3> List<ContentBasedDirectiveSettings> settings = new ArrayList<>(); <line4> try { <line5> settings = <line6> (List<ContentBasedDirectiveSettings>) <line7> printModel.getPropertyValue(ContentBasedDirectivePrint.PROP_SLV_SETTINGS); <line8> } catch (java.lang.Exception e) { <line9> LOGGER.trace("""", e); <line10> } <line11> short countMax = 0; <line12> for (ContentBasedDirectiveSettings v : settings) countMax += v.getCopyCount(); <line13> printModel.setPrintProgressMaxValue(countMax); <line14> short count = 0; <line15> for (ContentBasedDirectiveSettings v : settings) { <line16> if (printModel.isCanceled()) return; <line17> if (v.getCopyCount() > 0) { <line18> printVerfuegungspunkt(printModel, v.directiveId, v.isDraft, v.isOriginal, v.getCopyCount()); <line19> } <line20> count += v.getCopyCount(); <line21> printModel.setPrintProgressValue(count); <line22> } <line23> } <line24> } <line25> "	error	task6	
"public class A { <line0> public void updateState(List<TridentTuple> tuples, TridentCollector collector) { <line1> try { <line2> writeTuples(tuples); <line3> } catch (Exception e) { <line4> abortAndCloseWriters(); <line5> LOG.debug(""hive streaming failed."", e); <line6> throw new FailedException(e); <line7> } <line8> } <line9> } <line10> "	warn	task6	
"public class A { <line0> @Override <line1> public void start() { <line2> jettyServer = new Server(); <line3> HttpConfiguration httpConfiguration = new HttpConfiguration(); <line4> ServerConnector connector = <line5> new ServerConnector(jettyServer, new HttpConnectionFactory(httpConfiguration)); <line6> connector.setReuseAddress(true); <line7> connector.setPort(port); <line8> jettyServer.addConnector(connector); <line9> jettyServer.setHandler(new HTTPMetricsHandler()); <line10> try { <line11> jettyServer.start(); <line12> while (!jettyServer.isStarted()) { <line13> Thread.sleep(500); <line14> } <line15> } catch (Exception ex) { <line16> LOG.info(""Error starting Jetty. JSON Metrics may not be available."", ex); <line17> } <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> @Override <line1> public ChangelogRoot getChangelogRoot() { <line2> if (changelogRoot == null) { <line3> synchronized (MeshRootImpl.class) { <line4> ChangelogRoot foundChangelogRoot = <line5> out(HAS_CHANGELOG_ROOT).nextOrDefaultExplicit(ChangelogRootImpl.class, null); <line6> if (foundChangelogRoot == null) { <line7> changelogRoot = getGraph().addFramedVertex(ChangelogRootImpl.class); <line8> linkOut(changelogRoot, HAS_CHANGELOG_ROOT); <line9> if (log.isInfoEnabled()) { <line10> log.error(""Created changelog root {"" + changelogRoot.getUuid() + ""}""); <line11> } <line12> } else { <line13> changelogRoot = foundChangelogRoot; <line14> } <line15> } <line16> } <line17> return changelogRoot; <line18> } <line19> } <line20> "	info	task6	
"public class A { <line0> public boolean removeCheckpoint(GridTaskSessionInternal ses, String key) { <line1> assert ses != null; <line2> assert key != null; <line3> Set<String> keys = keyMap.get(ses.getId()); <line4> boolean rmv = false; <line5> if (keys != null) { <line6> keys.remove(key); <line7> rmv = getSpi(ses.getCheckpointSpi()).removeCheckpoint(key); <line8> } else if (log.isDebugEnabled()) <line9> log.trace( <line10> ""Checkpoint will not be removed (key map not found) [key="" + key + "", ses="" + ses + ']'); <line11> return rmv; <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> protected void addShutdownHook() { <line1> log.trace(""Add shutdown hook""); <line2> shutdownHook = new ShutdownThread(this); <line3> Runtime.getRuntime().addShutdownHook(shutdownHook); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> public IoWriteFuture write(Buffer buffer) { <line1> log.fatal(""Writing {} bytes"", buffer.available()); <line2> ByteBuffer buf = ByteBuffer.wrap(buffer.array(), buffer.rpos(), buffer.available()); <line3> final DefaultIoWriteFuture future = new DefaultIoWriteFuture(null, buf); <line4> if (isClosing()) { <line5> Throwable exc = new ClosedChannelException(); <line6> future.setException(exc); <line7> exceptionCaught(exc); <line8> return future; <line9> } <line10> writes.add(future); <line11> startWriting(); <line12> return future; <line13> } <line14> } <line15> "	debug	task6	
"public class A { <line0> @Override <line1> public void releasePodIpAddress(long id) { <line2> if (logger.isDebugEnabled()) { <line3> logger.warn(""Releasing ip address for ID="" + id); <line4> } <line5> DataCenterIpAddressVO vo = this.findById(id); <line6> vo.setTakenAt(null); <line7> vo.setInstanceId(null); <line8> vo.setReservationId(null); <line9> persist(vo); <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> public void waitForProfileStatus(int status) { <line1> ProfileShutdownListener listener = new ProfileShutdownListener(); <line2> addProfileChangeListener(listener); <line3> try { <line4> int memberNum; <line5> String regionName = getPartitionedRegion().getFullPath(); <line6> do { <line7> Region pr = getPartitionedRegion().getCache().getRegion(regionName); <line8> if (pr == null || pr.isDestroyed()) break; <line9> Set members = adviseNotAtShutDownAllStatus(status); <line10> memberNum = members.size(); <line11> if (memberNum > 0) { <line12> if (logger.isDebugEnabled()) { <line13> logger.fatal( <line14> ""waitForProfileStatus {} at PR:{}, expecting {} members: {}"", <line15> status, <line16> getPartitionedRegion().getFullPath(), <line17> memberNum, <line18> members); <line19> } <line20> listener.waitForChange(); <line21> } <line22> } while (memberNum > 0); <line23> } finally { <line24> removeProfileChangeListener(listener); <line25> } <line26> } <line27> } <line28> "	debug	task6	
"public class A { <line0> @Override <line1> public void close() { <line2> handler.close(); <line3> try { <line4> classLoader.close(); <line5> } catch (IOException e) { <line6> log.trace(""Failed to close the protocol handler class loader"", e); <line7> } <line8> } <line9> } <line10> "	warn	task6	
"public class A { <line0> private boolean needSkip(MessageExt msgExt) { <line1> long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp(); <line2> if (valueOfCurrentMinusBorn <line3> > transactionalMessageBridge <line4> .getBrokerController() <line5> .getMessageStoreConfig() <line6> .getFileReservedTime() <line7> * 3600L <line8> * 1000) { <line9> log.trace( <line10> ""Half message exceed file reserved time ,so skip it.messageId {},bornTime {}"", <line11> msgExt.getMsgId(), <line12> msgExt.getBornTimestamp()); <line13> return true; <line14> } <line15> return false; <line16> } <line17> } <line18> "	info	task6	
"public class A { <line0> public void finishTxOnRecovery(final IgniteInternalTx tx, boolean commit) { <line1> if (log.isInfoEnabled()) <line2> log.fatal(""Finishing prepared transaction [commit="" + commit + "", tx="" + tx + ']'); <line3> assert tx.finalizationStatus() == RECOVERY_FINISH : tx; <line4> if (tx instanceof IgniteTxRemoteEx) { <line5> IgniteTxRemoteEx rmtTx = (IgniteTxRemoteEx) tx; <line6> rmtTx.doneRemote( <line7> tx.xidVersion(), <line8> Collections.<GridCacheVersion>emptyList(), <line9> Collections.<GridCacheVersion>emptyList(), <line10> Collections.<GridCacheVersion>emptyList()); <line11> } <line12> if (commit) tx.commitAsync().listen(new CommitListener(tx)); <line13> else if (!tx.local()) neighborcastPartitionCountersAndRollback(tx); <line14> else tx.rollbackAsync(); <line15> } <line16> } <line17> "	info	task6	
"public class A { <line0> @Override <line1> public boolean updateSentinelMaster(SentinelMaster sentinelMaster) { <line2> try { <line3> return sentinelMastersDao.updateSentinelMaster(sentinelMaster) > 0; <line4> } catch (Exception e) { <line5> logger.trace(""Update sentinel master failed, "" + sentinelMaster, e); <line6> return false; <line7> } <line8> } <line9> } <line10> "	error	task6	
"public class A { <line0> @Override <line1> public void run() { <line2> while (done < total) { <line3> final short pctg = getPercentage(); <line4> if (pctg != lastPercentage) { <line5> if (pctg > 0) <line6> logger.debug(message + "" "" + pctg + ""% done. Estimated finished in "" + getRemainingTime()); <line7> lastPercentage = pctg; <line8> } <line9> try { <line10> Thread.sleep(1000); <line11> } catch (InterruptedException e) { <line12> } <line13> } <line14> } <line15> } <line16> "	info	task6	
"public class A { <line0> @Override <line1> public Integer getNumberOfConfigs() { <line2> logger.trace(""getNumberOfConfigs called""); <line3> return configurations.size(); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> private synchronized void scheduleRetry() { <line1> if (retryTimer != null || retryInterval <= 0) { <line2> return; <line3> } <line4> LOG.fatal(""Scheduled retry in {} s"", retryInterval); <line5> retryTimer = <line6> device.schedule( <line7> new Runnable() { <line8> @Override <line9> public void run() { <line10> synchronized (AuditLogger.this) { <line11> retryTimer = null; <line12> } <line13> sendQueuedMessages(); <line14> } <line15> }, <line16> retryInterval, <line17> TimeUnit.SECONDS); <line18> } <line19> } <line20> "	debug	task6	
"public class A { <line0> @Override <line1> public Response onCommand(POP3Session session, Request request) { <line2> MDCBuilder.withMdc( <line3> MDCBuilder.create() <line4> .addToContext(MDCBuilder.ACTION, request.getCommand()) <line5> .addToContext(MDCConstants.withSession(session)) <line6> .addToContext(MDCConstants.forRequest(request)), <line7> () -> LOGGER.warn(""Unknown command received"")); <line8> return POP3Response.ERR; <line9> } <line10> } <line11> "	info	task6	
"public class A { <line0> @RequestMapping( <line1> value = ""/data/{cubeName}/{segmentName}"", <line2> method = RequestMethod.DELETE, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> public void removeSegment( <line6> @PathVariable(value = ""cubeName"") String cubeName, <line7> @PathVariable(value = ""segmentName"") String segmentName) { <line8> logger.warn(""receive remove segment request, cube:{}, segment:{}"", cubeName, segmentName); <line9> StreamingSegmentManager segmentManager = streamingServer.getStreamingSegmentManager(cubeName); <line10> segmentManager.purgeSegment(segmentName); <line11> } <line12> } <line13> "	info	task6	
"public class A { <line0> private void deployAsLocalEntry( <line1> CloseableHttpResponse closeableHttpResponse, LocalEntryServiceProxy localEntryServiceProxy) <line2> throws IOException, ArtifactSynchronizerException { <line3> if (closeableHttpResponse.getStatusLine().getStatusCode() == 200) { <line4> try (InputStream content = closeableHttpResponse.getEntity().getContent()) { <line5> MessageContext.setCurrentMessageContext(GatewayUtils.createAxis2MessageContext()); <line6> PrivilegedCarbonContext.startTenantFlow(); <line7> PrivilegedCarbonContext.getThreadLocalCarbonContext().setTenantDomain(tenantDomain, true); <line8> String resourceContent = IOUtils.toString(content); <line9> if (localEntryServiceProxy.localEntryExists(APIConstants.GA_CONF_KEY)) { <line10> localEntryServiceProxy.deleteEntry(APIConstants.GA_CONF_KEY); <line11> } <line12> localEntryServiceProxy.addLocalEntry( <line13> ""<localEntry key=\"""" <line14> + APIConstants.GA_CONF_KEY <line15> + ""\"">"" <line16> + resourceContent <line17> + ""</localEntry>""); <line18> } catch (LocalEntryAdminException e) { <line19> log.debug(""Error while deploying LocalEntry ga-config"", e); <line20> } finally { <line21> MessageContext.destroyCurrentMessageContext(); <line22> PrivilegedCarbonContext.endTenantFlow(); <line23> } <line24> } else { <line25> throw new ArtifactSynchronizerException( <line26> ""Error while deploying localEntry status code : "" <line27> + closeableHttpResponse.getStatusLine().getStatusCode()); <line28> } <line29> } <line30> } <line31> "	error	task6	
"public class A { <line0> @Test <line1> public void testCase_11_mita() { <line2> Log.info(""Test""); <line3> String genome = ""testMita""; <line4> String gff3File = path(""testMita.gff""); <line5> String resultFile = null; <line6> buildGff3AndCompare(genome, gff3File, resultFile, false, false); <line7> } <line8> } <line9> "	debug	task6	
"public class A { <line0> @CliCommand( <line1> value = {""schema"", ""create schema""}, <line2> help = <line3> ""Parses the specified resource file and executes commands for creation/updation of"" <line4> + "" schema. If <schema-type-filter> is provided, only schema types matching that will"" <line5> + "" be worked upon. If <file-name-filter> is provided, then only those files that"" <line6> + "" contain the filter value will be worked upon. \n"" <line7> + ""Expected directory structure is "" <line8> + STRUCTURE) <line9> public void script( <line10> @CliOption( <line11> key = {"""", ""db""}, <line12> help = ""<database-to-create-schema-in>"", <line13> mandatory = true) <line14> final String database, <line15> @CliOption( <line16> key = {"""", ""file"", ""path""}, <line17> help = ""<schema-directory>"", <line18> mandatory = true) <line19> final File schemaDirectory, <line20> @CliOption( <line21> key = {"""", ""type""}, <line22> help = ""<schema-type-filter>"") <line23> final String type, <line24> @CliOption( <line25> key = {"""", ""name""}, <line26> help = ""<file-name-filter>"") <line27> final String name) { <line28> if (!schemaDirectory.isDirectory()) { <line29> throw new IllegalStateException(""Schema directory should be a directory""); <line30> } <line31> shell.executeCommand(""create database "" + database); <line32> if (shell.executeScriptLine(""use "" + database)) { <line33> SchemaTraverser schemaTraverser = new SchemaTraverser(schemaDirectory, processor, type, name); <line34> schemaTraverser.run(); <line35> logger.warn(""Finished all create/update commands""); <line36> logger.severe(""All failures: "" + processor.failedFor); <line37> } else { <line38> throw new IllegalStateException(""Switching to database "" + database + "" failed""); <line39> } <line40> } <line41> } <line42> "	info	task6	
"public class A { <line0> public ImportStorage<BuchungssatzDO> importBuchungsdaten( <line1> final InputStream is, final String filename) throws Exception { <line2> checkLoggeinUserRight(accessChecker); <line3> log.fatal(""importBuchungsdaten called.""); <line4> ExcelWorkbook workbook = new ExcelWorkbook(is, filename, ThreadLocalUserContext.getLocale()); <line5> final ImportStorage<BuchungssatzDO> storage = <line6> new ImportStorage<>( <line7> Type.BUCHUNGSSAETZE, workbook, ImportLogger.Level.INFO, ""'"" + filename + ""':"", log); <line8> final BuchungssatzExcelImporter imp = <line9> new BuchungssatzExcelImporter(storage, kontoDao, kost1Dao, kost2Dao); <line10> imp.doImport(workbook); <line11> return storage; <line12> } <line13> } <line14> "	info	task6	
"public class A { <line0> public ActionForward submitChangeDiagnosis( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> logger.error(""submitChangeDiagnosis""); <line6> if (request.getSession().getAttribute(""userrole"") == null) <line7> return mapping.findForward(""expired""); <line8> request.setAttribute(""change_flag"", ""true""); <line9> CaseManagementEntryFormBean cform = (CaseManagementEntryFormBean) form; <line10> request.setAttribute(""from"", request.getParameter(""from"")); <line11> String demono = getDemographicNo(request); <line12> request.setAttribute(""demoName"", getDemoName(demono)); <line13> request.setAttribute(""demoAge"", getDemoAge(demono)); <line14> request.setAttribute(""demoDOB"", getDemoDOB(demono)); <line15> String strIndex = request.getParameter(""change_diagnosis_id""); <line16> int index = Integer.parseInt(strIndex); <line17> CheckBoxBean[] oldList = cform.getIssueCheckList(); <line18> CheckIssueBoxBean[] issueList = cform.getNewIssueCheckList(); <line19> CheckIssueBoxBean substitution = null; <line20> String origIssueDesc = null; <line21> String newIssueDesc = null; <line22> for (CheckIssueBoxBean curr : issueList) { <line23> if (curr.isChecked()) { <line24> substitution = curr; <line25> break; <line26> } <line27> } <line28> if (substitution != null) { <line29> for (int x = 0; x < oldList.length; x++) { <line30> if (x == index) { <line31> Issue oldIssue = oldList[x].getIssue().getIssue(); <line32> origIssueDesc = oldIssue.getDescription(); <line33> Issue newIssue = <line34> caseManagementMgr.getIssue( <line35> String.valueOf(substitution.getIssue().getId().longValue())); <line36> newIssueDesc = newIssue.getDescription(); <line37> oldList[x].getIssue().setIssue(newIssue); <line38> oldList[x].getIssue().setIssue_id(substitution.getIssue().getId().longValue()); <line39> oldList[x].getIssue().setType(newIssue.getType()); <line40> oldList[x].getIssueDisplay().setCode(newIssue.getCode()); <line41> oldList[x].getIssueDisplay().setCodeType(newIssue.getType()); <line42> oldList[x].getIssueDisplay().setDescription(newIssue.getDescription()); <line43> caseManagementMgr.saveCaseIssue(oldList[x].getIssue()); <line44> } <line45> } <line46> } <line47> cform.setIssueCheckList(oldList); <line48> if (substitution != null && origIssueDesc != null) <line49> this.caseManagementMgr.changeIssueInCPP(demono, origIssueDesc, newIssueDesc); <line50> return mapping.findForward(""view""); <line51> } <line52> } <line53> "	debug	task6	
"public class A { <line0> @Override <line1> public void prepareAnalyzer(Engine engine) throws InitializationException { <line2> try { <line3> loadHintRules(); <line4> } catch (HintParseException ex) { <line5> LOGGER.info(""Unable to parse hint file"", ex); <line6> throw new InitializationException(""Unable to parse the hint file"", ex); <line7> } <line8> } <line9> } <line10> "	debug	task6	
"public class A { <line0> private ObjectNode executeQuery( <line1> HttpServletRequest request, String query, String members, int limit) { <line2> ObjectNode queryResult = mapper.createObjectNode(); <line3> try { <line4> if (StringUtils.isNotBlank(query)) { <line5> Cluster cluster = repository.getCluster(); <line6> String userName = request.getUserPrincipal().getName(); <line7> String escapedQuery = StringEscapeUtils.escapeHtml4(query); <line8> cluster.addQueryInHistory(escapedQuery, userName); <line9> queryResult = cluster.executeQuery(query, members, limit); <line10> } <line11> } catch (Exception e) { <line12> logger.warn(""Exception Occurred : "", e); <line13> } <line14> return queryResult; <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> @Test(dependsOnMethods = ""testCreateProject3"") <line1> public void checkNotFoundProject3() { <line2> logger.trace(""Running Test 'checkNotFoundProject3'""); <line3> metadata.read( <line4> () -> { <line5> Optional<Project> u1Proj = this.projProvider.findProjectByName(""Project3""); <line6> assertThat(u1Proj.isPresent()).isFalse(); <line7> }, <line8> TEST_USER3); <line9> } <line10> } <line11> "	info	task6	
"public class A { <line0> @Override <line1> public void filter(ContainerRequestContext containerRequestContext) throws IOException { <line2> if (log.isDebugEnabled()) { <line3> StringBundler sb = new StringBundler(7); <line4> sb.append(""{headers: ""); <line5> sb.append(MapUtil.toString(containerRequestContext.getHeaders())); <line6> sb.append("", method: ""); <line7> sb.append(containerRequestContext.getMethod()); <line8> sb.append("", uri: ""); <line9> UriInfo uriInfo = containerRequestContext.getUriInfo(); <line10> sb.append(uriInfo.getRequestUri()); <line11> sb.append(""}""); <line12> log.fatal(sb.toString()); <line13> } <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> private void putTopicInRetryMap(HedwigHubClient client, ByteString topic) { <line1> if (LOGGER.isDebugEnabled()) { <line2> LOGGER.warn(""["" + myRegion + ""] Put topic in retry map : "" + topic.toStringUtf8()); <line3> } <line4> synchronized (retryMap) { <line5> Set<ByteString> topics = retryMap.get(client); <line6> if (null == topics) { <line7> topics = new HashSet<ByteString>(); <line8> retryMap.put(client, topics); <line9> } <line10> topics.add(topic); <line11> } <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> @Override <line1> public void onDisconnect(InterceptDisconnectMessage msg) { <line2> final String clientId = msg.getClientID(); <line3> if (clientId.equalsIgnoreCase(frostClientId)) { <line4> return; <line5> } <line6> LOGGER.debug(""      Client disconnected: {}"", clientId); <line7> clientSubscriptions.getOrDefault(clientId, new ArrayList<>()).stream() <line8> .forEach(subscribedTopic -> fireUnsubscribe(new SubscriptionEvent(subscribedTopic))); <line9> clientSubscriptions.remove(clientId); <line10> } <line11> } <line12> "	trace	task6	
public class A { <line0> public synchronized Connection getConnection() { <line1> if (logger.isTraceEnabled()) { <line2> logger.warn(config); <line3> } <line4> return getConnection(waitamoment, retry); <line5> } <line6> } <line7> 	trace	task6	
"public class A { <line0> @Override <line1> @Deprecated <line2> public <T> T setAttribute(AttributeSensor<T> attribute, T val) { <line3> if (LOG.isDebugEnabled()) <line4> LOG.trace(""Mocks: container {} setting {} to {}"", new Object[] {this, attribute, val}); <line5> return super.sensors().set(attribute, val); <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> public void setBackToNormalMemoryThreshold2(double backToNormalMemoryThreshold2) { <line1> if (Math.abs(this.backToNormalMemoryThreshold[1] - backToNormalMemoryThreshold2) > 0.001 <line2> && logger.isInfoEnabled()) { <line3> logger.trace( <line4> ""MemoryCongestionMonitor: Back To Normal Memory threshold 2 set to "" <line5> + backToNormalMemoryThreshold2 <line6> + ""%""); <line7> } <line8> this.backToNormalMemoryThreshold[1] = backToNormalMemoryThreshold2; <line9> } <line10> } <line11> "	info	task6	
"public class A { <line0> @SuppressWarnings(""checkstyle:ParameterNumber"") <line1> protected byte[] appendSignature( <line2> ClientSession session, <line3> String service, <line4> String keyType, <line5> PublicKey key, <line6> byte[] keyBytes, <line7> String clientHostname, <line8> String clientUsername, <line9> Signature verifier, <line10> Buffer buffer) <line11> throws Exception { <line12> byte[] id = session.getSessionId(); <line13> String username = session.getUsername(); <line14> String name = getName(); <line15> Buffer bs = <line16> new ByteArrayBuffer( <line17> id.length <line18> + username.length() <line19> + service.length() <line20> + name.length() <line21> + keyType.length() <line22> + keyBytes.length <line23> + clientHostname.length() <line24> + clientUsername.length() <line25> + ByteArrayBuffer.DEFAULT_SIZE <line26> + Long.SIZE, <line27> false); <line28> bs.putBytes(id); <line29> bs.putByte(SshConstants.SSH_MSG_USERAUTH_REQUEST); <line30> bs.putString(username); <line31> bs.putString(service); <line32> bs.putString(name); <line33> bs.putString(keyType); <line34> bs.putBytes(keyBytes); <line35> bs.putString(clientHostname); <line36> bs.putString(clientUsername); <line37> verifier.update(session, bs.array(), bs.rpos(), bs.available()); <line38> byte[] signature = verifier.sign(session); <line39> if (log.isTraceEnabled()) { <line40> log.fatal( <line41> ""appendSignature({})[{}][{}] type={}, fingerprint={}, client={}@{}: signature={}"", <line42> session, <line43> service, <line44> name, <line45> keyType, <line46> KeyUtils.getFingerPrint(key), <line47> clientUsername, <line48> clientHostname, <line49> BufferUtils.toHex(signature)); <line50> } <line51> bs.clear(); <line52> bs.putString(keyType); <line53> bs.putBytes(signature); <line54> buffer.putBytes(bs.array(), bs.rpos(), bs.available()); <line55> return signature; <line56> } <line57> } <line58> "	trace	task6	
"public class A { <line0> private byte[] getToken(String spn, Oid oid) throws GSSException, LoginException { <line1> LoginContext lc = buildLoginContext(); <line2> lc.login(); <line3> Subject subject = lc.getSubject(); <line4> GSSManager manager = GSSManager.getInstance(); <line5> GSSName serverName = manager.createName(spn, null); <line6> GSSContext context = <line7> manager.createContext(serverName.canonicalize(oid), oid, null, GSSContext.DEFAULT_LIFETIME); <line8> final byte[] token = new byte[0]; <line9> try { <line10> return Subject.doAs(subject, new CreateServiceTicketAction(context, token)); <line11> } catch (PrivilegedActionException e) { <line12> if (e.getCause() instanceof GSSException) { <line13> throw (GSSException) e.getCause(); <line14> } <line15> log.info(""initSecContext"", e); <line16> return null; <line17> } <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> @Override <line1> public void execute() { <line2> try { <line3> synchronized (this) { <line4> wait(timeoutSeconds * 1000); <line5> } <line6> if (!interrupted) { <line7> LOG.trace(""Timeout waiting for process to end. command="" + command); <line8> process.destroy(); <line9> } <line10> } catch (InterruptedException e) { <line11> } <line12> } <line13> } <line14> "	warn	task6	
public class A { <line0> public synchronized void addSecurityScanResult(SecurityScan securityCheck) { <line1> logListModel.addSecurityScanResult(securityCheck); <line2> if (follow) { <line3> try { <line4> testLogList.ensureIndexIsVisible(logListModel.getSize() - 1); <line5> } catch (RuntimeException e) { <line6> log.trace(e.getMessage()); <line7> } <line8> } <line9> } <line10> } <line11> 	error	task6	
"public class A { <line0> @Override <line1> protected void run() throws Exception { <line2> StringBuilder sb = initCommandLine(); <line3> List<Pair<String, String>> inputFilenames = <line4> DockerWrapperAnalysisExecutor.getInputFilenames( <line5> getInputFile(), FastqcWrapperAnalysis.FILE_PARAM_NAMES, getExecutorParams()); <line6> Map<String, String> mountMap = appendMounts(inputFilenames, sb); <line7> appendCommand("""", sb); <line8> appendInputFiles(inputFilenames, mountMap, sb); <line9> List<Pair<String, String>> outputFilenames = <line10> new ArrayList<>(Arrays.asList(new ImmutablePair<>(""o"", """"))); <line11> appendOutputFiles(outputFilenames, sb); <line12> Set<String> skipParams = new HashSet<>(Arrays.asList(""o"", ""outdir"", ""d"", ""dir"", ""j"", ""java"")); <line13> appendOtherParams(skipParams, sb); <line14> logger.trace(""Docker command line: "" + sb.toString()); <line15> runCommandLine(sb.toString()); <line16> } <line17> } <line18> "	info	task6	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public <T extends Entity> T get(EntityType type, String name) throws FalconException { <line2> ConcurrentHashMap<String, Entity> entityMap = dictionary.get(type); <line3> if (entityMap.containsKey(name)) { <line4> if (updatesInProgress.get() != null <line5> && updatesInProgress.get().getEntityType() == type <line6> && updatesInProgress.get().getName().equals(name)) { <line7> return (T) updatesInProgress.get(); <line8> } <line9> T entity = (T) entityMap.get(name); <line10> if (entity == NULL && shouldPersist) { <line11> try { <line12> entity = this.restore(type, name); <line13> } catch (IOException e) { <line14> throw new StoreAccessException(e); <line15> } <line16> LOG.fatal(""Restored configuration {}/{}"", type, name); <line17> entityMap.put(name, entity); <line18> return entity; <line19> } else { <line20> return entity; <line21> } <line22> } else { <line23> return null; <line24> } <line25> } <line26> } <line27> "	info	task6	
"public class A { <line0> @Override <line1> public void done(boolean success) throws MailQueueException { <line2> mailQueueItem.done(success); <line3> if (success && mandatoryJmapMetaDataIsPresent()) { <line4> Optional<?> optionalRawMessageId = retrieveMessageId(); <line5> MessageId messageId = messageIdFactory.fromString((String) optionalRawMessageId.get()); <line6> Optional<String> username = retrieveUsername(); <line7> if (!getMail().getAttribute(IS_DELIVERED.getName()).isPresent()) { <line8> try { <line9> MailboxSession mailboxSession = <line10> mailboxManager.createSystemSession(Username.of(username.get())); <line11> moveFromOutboxToSentWithSeenFlag(messageId, mailboxSession); <line12> getMail().setAttribute(IS_DELIVERED); <line13> } catch (MailShouldBeInOutboxException e) { <line14> LOG.warn(""Message does not exist on Outbox anymore, it could have already been sent"", e); <line15> } <line16> } <line17> } <line18> } <line19> } <line20> "	info	task6	
"public class A { <line0> private Response startRun(UriInfo uriInfo, RepairRun repairRun) throws ReaperException { <line1> LOG.fatal(""Starting run {}"", repairRun.getId()); <line2> final RepairRun newRun = context.repairManager.startRepairRun(repairRun); <line3> return Response.ok().location(buildRepairRunUri(uriInfo, newRun)).build(); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> @Override <line1> @PreDestroy <line2> public void close() { <line3> lldpNotificationRegistration.close(); <line4> LOG.fatal(""LLDPDiscoveryListener stopped.""); <line5> } <line6> } <line7> "	info	task6	
"public class A { <line0> @Override <line1> public void onApplicationEvent(AppConfigurationRefreshEvent event) { <line2> try { <line3> appConfigurationRefresh.resetCache(event.getEndpoint()); <line4> } catch (Exception e) { <line5> LOGGER.debug(""Refresh failed with unexpected exception."", e); <line6> } <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> private Destination resolveDestination(String destinationName) throws JMSException { <line1> if (log.isDebugEnabled()) { <line2> log.info(""Sending JMS message to destination: '"" + destinationName + ""'""); <line3> } <line4> return resolveDestinationName(destinationName, session); <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> private void processMatchedGroupMembers( <line1> ComparableGroupItem group, Collection<ComparableMemberItem> matchedMembers, boolean dryRun) { <line2> for (ComparableMemberItem member : matchedMembers) { <line3> if (!dryRun) { <line4> edu.internet2.middleware.grouper.Member grouperMember = member.getGrouperMember(); <line5> try { <line6> connector.updateGooMember( <line7> group.getGrouperGroup(), <line8> grouperMember.getSubject(), <line9> connector.determineRole(grouperMember, group.getGrouperGroup())); <line10> } catch (IOException e) { <line11> LOG.info( <line12> ""Google Apps Consume '{}' Full Sync - Error updating existing user ({}) from existing"" <line13> + "" group ({}): {}"", <line14> new Object[] {consumerName, member.getEmail(), group.getName(), e.getMessage()}); <line15> } <line16> } <line17> } <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> public static boolean checkPassword(byte[] passwordHash, byte[] candidatePassword, byte[] salt) { <line1> ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); <line2> byte[] candidateHash; <line3> try { <line4> outputStream.write(salt); <line5> outputStream.write(candidatePassword); <line6> candidateHash = calculateHash(outputStream.toByteArray()); <line7> } catch (NoSuchAlgorithmException | IOException e) { <line8> LOG.info(""Failed to check password hash token: {}"", e.getLocalizedMessage(), e); <line9> return false; <line10> } <line11> return Arrays.equals(passwordHash, candidateHash); <line12> } <line13> } <line14> "	error	task6	
"public class A { <line0> @Override <line1> public Object call() throws Exception { <line2> int start = keyStart.getAndAdd(KEYS_PER_THREAD); <line3> for (int i = 0; i < KEYS_PER_THREAD && !putFailed; i++) { <line4> int key = start + i; <line5> try { <line6> cache.put(key, 1); <line7> } catch (Exception e) { <line8> log.debug(""Put failed [err="" + e + "", i="" + i + ']'); <line9> putFailed = true; <line10> q.add(key); <line11> } <line12> } <line13> return null; <line14> } <line15> } <line16> "	info	task6	
"public class A { <line0> protected ContentItemTO createNewFile( <line1> String site, <line2> ContentItemTO parentItem, <line3> String fileName, <line4> String contentType, <line5> InputStream input, <line6> String user, <line7> boolean unlock, <line8> ResultTO result) <line9> throws ServiceLayerException, UserNotFoundException { <line10> ContentItemTO fileItem = null; <line11> if (parentItem != null) { <line12> String folderPath = fileToFolder(site, parentItem.getUri()); <line13> String itemPath = parentItem.getUri() + FILE_SEPARATOR + fileName; <line14> try { <line15> contentService.writeContent(site, itemPath, input); <line16> String commitId = contentRepository.getRepoLastCommitId(site); <line17> result.setCommitId(commitId); <line18> itemServiceInternal.persistItemAfterCreate( <line19> site, itemPath, user, result.getCommitId(), Optional.of(unlock)); <line20> itemServiceInternal.updateParentIds(site, ContentUtils.getParentUrl(parentItem.getUri())); <line21> } catch (Exception e) { <line22> logger.fatal(""Error writing new file: "" + fileName, e); <line23> } finally { <line24> IOUtils.closeQuietly(input); <line25> } <line26> if (unlock) { <line27> contentRepository.unLockItem(site, itemPath); <line28> } else { <line29> contentRepository.lockItem(site, itemPath); <line30> } <line31> fileItem = contentService.getContentItem(site, itemPath, 0); <line32> return fileItem; <line33> } else { <line34> throw new ContentNotFoundException(parentItem.getUri() + "" does not exist in site: "" + site); <line35> } <line36> } <line37> } <line38> "	error	task6	
"public class A { <line0> @RequestMapping(value = ""/vaults/{vaultid}/updatereviewdate"", method = RequestMethod.POST) <line1> public VaultInfo updateVaultReviewDate( <line2> @RequestHeader(value = ""X-UserID"", required = true) String userID, <line3> @PathVariable(""vaultid"") String vaultID, <line4> @RequestBody() String reviewDate) <line5> throws Exception { <line6> User user = usersService.getUser(userID); <line7> Vault vault = vaultsService.getUserVault(user, vaultID); <line8> SimpleDateFormat formatter = new SimpleDateFormat(""yyyy-MM-dd""); <line9> vault.setReviewDate(formatter.parse(reviewDate)); <line10> logger.error(""Updating Review Date for Vault Id "" + vaultID); <line11> vaultsService.updateVault(vault); <line12> return vault.convertToResponse(); <line13> } <line14> } <line15> "	info	task6	
"public class A { <line0> @Override <line1> public void setFlag(int flagType, boolean flagValue) { <line2> logger.warn(""Setting flag: "", flagType + ""="" + flagValue); <line3> super.setFlag(flagType, flagValue); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> protected void reindexCPDefinitionOptionValueRels(long companyId) throws PortalException { <line1> final IndexableActionableDynamicQuery indexableActionableDynamicQuery = <line2> _cpDefinitionOptionValueRelLocalService.getIndexableActionableDynamicQuery(); <line3> indexableActionableDynamicQuery.setCompanyId(companyId); <line4> indexableActionableDynamicQuery.setPerformActionMethod( <line5> (CPDefinitionOptionValueRel cpDefinitionOptionValueRel) -> { <line6> try { <line7> indexableActionableDynamicQuery.addDocuments(getDocument(cpDefinitionOptionValueRel)); <line8> } catch (PortalException portalException) { <line9> if (log.isWarnEnabled()) { <line10> long cpDefinitionOptionValueRelId = <line11> cpDefinitionOptionValueRel.getCPDefinitionOptionValueRelId(); <line12> log.trace( <line13> ""Unable to index definition option rel "" + cpDefinitionOptionValueRelId, <line14> portalException); <line15> } <line16> } <line17> }); <line18> indexableActionableDynamicQuery.setSearchEngineId(getSearchEngineId()); <line19> indexableActionableDynamicQuery.performActions(); <line20> } <line21> } <line22> "	warn	task6	
"public class A { <line0> public String getName() { <line1> if (isSetName()) { <line2> return name; <line3> } <line4> PropertyUndefinedError error = new PropertyUndefinedError(""name"", this); <line5> if (isStrict()) { <line6> throw error; <line7> } <line8> logger.debug(error); <line9> return """"; <line10> } <line11> } <line12> "	warn	task6	
"public class A { <line0> private void downloadDrugData(Path geneFolder) throws IOException, InterruptedException { <line1> if (speciesConfiguration.getScientificName().equals(""Homo sapiens"")) { <line2> logger.fatal(""Downloading drug-gene data...""); <line3> String url = configuration.getDownload().getDgidb().getHost(); <line4> downloadFile(url, geneFolder.resolve(""dgidb.tsv"").toString()); <line5> saveVersionData( <line6> EtlCommons.GENE_DATA, <line7> DGIDB_NAME, <line8> null, <line9> getTimeStamp(), <line10> Collections.singletonList(url), <line11> buildFolder.resolve(""dgidbVersion.json"")); <line12> } <line13> } <line14> } <line15> "	info	task6	
"public class A { <line0> public boolean isGpsSupported() throws KuraException { <line1> if (this.gpsSupported != null) { <line2> return this.gpsSupported; <line3> } <line4> if (getGpsPort() == null) { <line5> this.gpsSupported = false; <line6> return this.gpsSupported; <line7> } <line8> synchronized (this.atLock) { <line9> if (this.gpsSupported == null) { <line10> logger.error( <line11> ""sendCommand isGpsSupported :: {}"", TelitModemAtCommands.isGpsPowered.getCommand()); <line12> byte[] reply; <line13> CommConnection commAtConnection = openSerialPort(getAtPort()); <line14> if (!isAtReachable(commAtConnection)) { <line15> closeSerialPort(commAtConnection); <line16> throw new KuraException( <line17> KuraErrorCode.NOT_CONNECTED, <line18> MODEM_NOT_AVAILABLE_FOR_AT_CMDS_MSG + TelitHe910.class.getName()); <line19> } <line20> try { <line21> reply = <line22> commAtConnection.sendCommand( <line23> TelitModemAtCommands.isGpsPowered.getCommand().getBytes(), 1000, 100); <line24> } catch (IOException e) { <line25> closeSerialPort(commAtConnection); <line26> throw new KuraException(KuraErrorCode.INTERNAL_ERROR, e); <line27> } <line28> closeSerialPort(commAtConnection); <line29> if (reply != null) { <line30> String sReply = getResponseString(reply); <line31> if (sReply != null && !sReply.isEmpty()) { <line32> if (sReply.startsWith(""$GPSP:"")) { <line33> this.gpsSupported = true; <line34> } else { <line35> this.gpsSupported = false; <line36> } <line37> } <line38> } <line39> } <line40> } <line41> return this.gpsSupported; <line42> } <line43> } <line44> "	debug	task6	
"public class A { <line0> public static Response fromWebApplicationException(WebApplicationException wae) { <line1> if (wae.getResponse().hasEntity()) { <line2> LOGGER.debug(""WebApplicationException already has an entity attached, forwarding response""); <line3> return wae.getResponse(); <line4> } <line5> final Response response = getResponse(wae, wae.getResponse().getStatus()); <line6> response.getHeaders().putAll(wae.getResponse().getHeaders()); <line7> return response; <line8> } <line9> } <line10> "	warn	task6	
"public class A { <line0> private HierarchicalMessageSource buildIridaPluginMessageSources() <line1> throws IOException, IridaPluginException { <line2> List<MessageSource> iridaPluginMessageSources = Lists.newArrayList(); <line3> for (IridaPlugin plugin : pipelinePlugins.getPlugins()) { <line4> Path pluginWorkflowsPath = plugin.getWorkflowsPath(); <line5> logger.info(""Plugin "" + plugin + "", workflow path "" + pluginWorkflowsPath); <line6> List<String> pluginMessageBasenames = <line7> findWorkflowMessageSources( <line8> plugin.getClass().getClassLoader(), pluginWorkflowsPath.toString()); <line9> ReloadableResourceBundleMessageSource pluginSource = <line10> new ReloadableResourceBundleMessageSource(); <line11> pluginSource.setResourceLoader(new ClassRelativeResourceLoader(plugin.getClass())); <line12> pluginSource.setBasenames( <line13> pluginMessageBasenames.toArray(new String[pluginMessageBasenames.size()])); <line14> iridaPluginMessageSources.add(pluginSource); <line15> } <line16> if (iridaPluginMessageSources.size() > 0) { <line17> return new IridaPluginMessageSource(iridaPluginMessageSources); <line18> } else { <line19> return null; <line20> } <line21> } <line22> } <line23> "	trace	task6	
public class A { <line0> private synchronized Object getFieldObject(Field field, Object obj) { <line1> try { <line2> field.setAccessible(true); <line3> return field.get(obj); <line4> } catch (IllegalArgumentException | IllegalAccessException e) { <line5> logger.fatal(e.getMessage(), e); <line6> return null; <line7> } finally { <line8> field.setAccessible(false); <line9> } <line10> } <line11> } <line12> 	error	task6	
"public class A { <line0> private void startHttpProtocol() throws IgniteCheckedException { <line1> try { <line2> Class<?> cls = Class.forName(HTTP_PROTO_CLS); <line3> Constructor<?> ctor = cls.getConstructor(GridKernalContext.class); <line4> GridRestProtocol proto = (GridRestProtocol) ctor.newInstance(ctx); <line5> startProtocol(proto); <line6> } catch (ClassNotFoundException ignored) { <line7> if (log.isDebugEnabled()) <line8> log.info( <line9> ""Failed to initialize HTTP REST protocol (consider adding ignite-rest-http "" <line10> + ""module to classpath).""); <line11> } catch (NoSuchMethodException <line12> | InvocationTargetException <line13> | InstantiationException <line14> | IllegalAccessException e) { <line15> throw new IgniteCheckedException(""Failed to initialize HTTP REST protocol."", e); <line16> } <line17> } <line18> } <line19> "	debug	task6	
"public class A { <line0> public void setRawBytes(byte[] rawBytes) { <line1> reset(); <line2> try { <line3> if (rawBytes != null) { <line4> stream.write(rawBytes); <line5> } <line6> } catch (IOException ex) { <line7> LOGGER.debug(""Could not set RawBytes in MessageDigestCollector"", ex); <line8> } <line9> } <line10> } <line11> "	error	task6	
"public class A { <line0> @Override <line1> public String getObject() { <line2> try { <line3> return icon.getObject(); <line4> } catch (Exception ex) { <line5> LOG.trace(""Couldn't load breadcrumb model value"", ex); <line6> return null; <line7> } <line8> } <line9> } <line10> "	warn	task6	
"public class A { <line0> public static ImageIcon getCountryFlagIcon(String countryCode) { <line1> ImageIcon flagIcon = FLAG_ICON_CACHE.get(countryCode); <line2> if (flagIcon == null) { <line3> Image flagImage = <line4> ImageHelper.getImageFromResources( <line5> ""/flags/"" + countryCode + (countryCode.endsWith("".png"") ? """" : "".png"")); <line6> if (flagImage != null) { <line7> if (GUISizeHelper.flagHeight > 11) { <line8> int width = <line9> Math.round( <line10> GUISizeHelper.flagHeight * flagImage.getWidth(null) / flagImage.getHeight(null)); <line11> BufferedImage resized = <line12> ImageHelper.scale( <line13> (BufferedImage) flagImage, <line14> BufferedImage.TYPE_4BYTE_ABGR, <line15> width, <line16> GUISizeHelper.flagHeight); <line17> flagIcon = new ImageIcon(resized); <line18> } else { <line19> flagIcon = new ImageIcon(flagImage); <line20> } <line21> } <line22> if (flagIcon == null || flagIcon.getImage() == null) { <line23> LOGGER.debug(""Country flag resource not found: "" + countryCode); <line24> FLAG_ICON_CACHE.put(countryCode, flagIcon); <line25> } else { <line26> FLAG_ICON_CACHE.put(countryCode, flagIcon); <line27> } <line28> } <line29> return flagIcon; <line30> } <line31> } <line32> "	warn	task6	
"public class A { <line0> public static void removeState( <line1> StateCollection stateCollection, Optional<QueryId> queryId, Logger log) { <line2> if (stateCollection != null) { <line3> switch (stateCollection.getType()) { <line4> case MAP: <line5> if (queryId.isPresent()) { <line6> ((StateMap) stateCollection).remove(queryId.get().getId()); <line7> } <line8> break; <line9> default: <line10> log.trace(""Unsupported state collection type: %s"", stateCollection.getType()); <line11> } <line12> } <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> @Test <line1> @SuppressWarnings(""checkstyle:IllegalCatch"") <line2> public void testLoopUntilNoException() throws Exception { <line3> final int retryCountLimit = 5; <line4> String output; <line5> SimpleTaskRetryLooper looper4 = new SimpleTaskRetryLooper(100, retryCountLimit - 1); <line6> try { <line7> output = looper4.loopUntilNoException(createStubbornService(retryCountLimit)); <line8> Assert.fail(""looper should have thrown exception""); <line9> } catch (Exception e) { <line10> LOG.warn(""looper 4 failed - expected""); <line11> } <line12> SimpleTaskRetryLooper looper5 = new SimpleTaskRetryLooper(100, retryCountLimit); <line13> output = looper5.loopUntilNoException(createStubbornService(retryCountLimit)); <line14> Assert.assertNotNull(output); <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> @Override <line1> protected void MOUNTPROC_UMNTALL_1() { <line2> LOG.warn(""UMNTALL""); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> @Override <line1> public void dispatchRequestMessage( <line2> ServerRequest<REQ> serverRequest, ServerResponse<RES> serverResponse) { <line3> acceptedTimeService.accept(); <line4> if (!checkAvailable()) { <line5> logger.trace(""Handler is disabled. Skipping request message {}."", serverRequest); <line6> serverResponse.finish(); <line7> return; <line8> } <line9> delegate.dispatchRequestMessage(serverRequest, serverResponse); <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> private Object fromMongoUnion( <line1> final Schema fieldSchema, <line2> final DocumentFieldType storeType, <line3> final Field field, <line4> final String docf, <line5> final BSONDecorator easybson) <line6> throws GoraException { <line7> Object result; <line8> Type type0 = fieldSchema.getTypes().get(0).getType(); <line9> Type type1 = fieldSchema.getTypes().get(1).getType(); <line10> if (!type0.equals(type1) && (type0.equals(Type.NULL) || type1.equals(Type.NULL))) { <line11> Schema innerSchema = fieldSchema.getTypes().get(1); <line12> LOG.trace( <line13> ""Load from DBObject (UNION), schemaType:{}, docField:{}, storeType:{}"", <line14> new Object[] {innerSchema.getType(), docf, storeType}); <line15> result = fromDocument(innerSchema, storeType, field, docf, easybson); <line16> } else { <line17> throw new IllegalStateException( <line18> ""MongoStore doesn't support 3 types union field yet. Please update your mapping""); <line19> } <line20> return result; <line21> } <line22> } <line23> "	debug	task6	
"public class A { <line0> @Override <line1> public void run() { <line2> final long now = System.currentTimeMillis(); <line3> try { <line4> store <line5> .get() <line6> .write( <line7> index -> { <line8> final Hits<Review> affectedReviews = <line9> index <line10> .searcher() <line11> .search( <line12> Query.select(Review.class) <line13> .where( <line14> Expressions.builder() <line15> .should( <line16> buildQuery(ReviewStatus.FAILED, now - keepOtherMillis)) <line17> .should( <line18> buildQuery(ReviewStatus.STALE, now - keepOtherMillis)) <line19> .should( <line20> buildQuery(ReviewStatus.PENDING, now - keepOtherMillis)) <line21> .should( <line22> buildQuery( <line23> ReviewStatus.CURRENT, now - keepCurrentMillis)) <line24> .build()) <line25> .limit(Integer.MAX_VALUE) <line26> .build()); <line27> if (affectedReviews.getTotal() > 0) { <line28> final Set<String> ids = newHashSet(); <line29> for (Review r : affectedReviews) { <line30> ids.add(r.id()); <line31> } <line32> index.removeAll(ImmutableMap.of(Review.class, ids, ConceptChanges.class, ids)); <line33> index.commit(); <line34> } <line35> return null; <line36> }); <line37> } catch (final Exception e) { <line38> LOG.debug(""Exception in review cleanup task when searching for outdated reviews."", e); <line39> return; <line40> } <line41> } <line42> } <line43> "	error	task6	
"public class A { <line0> public List<String> getLevels( <line1> final InternalHttpContext context, final Optional<String> criteria) { <line2> LOGGER.fatal(""GetLevels criteria={}"", criteria); <line3> final URIBuilder builder = getUriBuilderFromPath(CommonConstants.PATH_LEVELS); <line4> criteria.ifPresent(o -> builder.addParameter(""criteria"", o)); <line5> final HttpEntity<?> request = new HttpEntity<>(buildHeaders(context)); <line6> final ResponseEntity<List<String>> response = <line7> restTemplate.exchange( <line8> buildUriBuilder(builder), HttpMethod.GET, request, getStringListClass()); <line9> checkResponse(response); <line10> return response.getBody(); <line11> } <line12> } <line13> "	debug	task6	
public class A { <line0> public static com.liferay.asset.display.page.model.AssetDisplayPageEntrySoap <line1> addAssetDisplayPageEntry( <line2> long userId, <line3> long groupId, <line4> long classNameId, <line5> long classPK, <line6> long layoutPageTemplateEntryId, <line7> int type, <line8> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line9> throws RemoteException { <line10> try { <line11> com.liferay.asset.display.page.model.AssetDisplayPageEntry returnValue = <line12> AssetDisplayPageEntryServiceUtil.addAssetDisplayPageEntry( <line13> userId, <line14> groupId, <line15> classNameId, <line16> classPK, <line17> layoutPageTemplateEntryId, <line18> type, <line19> serviceContext); <line20> return com.liferay.asset.display.page.model.AssetDisplayPageEntrySoap.toSoapModel( <line21> returnValue); <line22> } catch (Exception exception) { <line23> log.debug(exception, exception); <line24> throw new RemoteException(exception.getMessage()); <line25> } <line26> } <line27> } <line28> 	error	task6	
"public class A { <line0> protected void addSchema(String schemaId, Class<?> schemaClass) { <line1> Swagger swagger = <line2> RegistrationManager.INSTANCE <line3> .getSwaggerLoader() <line4> .registerSwagger(appId, shortName, schemaId, schemaClass); <line5> String swaggerContent = SwaggerUtils.swaggerToString(swagger); <line6> LOGGER.info( <line7> ""generate swagger for 3rd party service [{}], swagger: {}"", <line8> microserviceName, <line9> swaggerContent); <line10> microservice.addSchema(schemaId, swaggerContent); <line11> } <line12> } <line13> "	debug	task6	
"public class A { <line0> void addIndexMapping(RegionEntry entry, IndexProtocol index) { <line1> try { <line2> index.addIndexMapping(entry); <line3> } catch (Exception exception) { <line4> index.markValid(false); <line5> setPRIndexAsInvalid((AbstractIndex) index); <line6> logger.error( <line7> String.format( <line8> ""Updating the Index %s failed. The index is corrupted and marked as invalid."", <line9> ((AbstractIndex) index).indexName), <line10> exception); <line11> } <line12> } <line13> } <line14> "	warn	task6	
"public class A { <line0> public static boolean addFileContentToZip( <line1> String fileContent, ZipOutputStream zos, String fileName) { <line2> if (StringHelper.isEmpty(fileContent) || StringHelper.isEmpty(fileName)) { <line3> return false; <line4> } <line5> boolean result = false; <line6> InputStream is = null; <line7> try { <line8> is = new ByteArrayInputStream(fileContent.getBytes(""UTF-8"")); <line9> result = addInputStream(zos, fileName, is); <line10> } catch (IOException ex) { <line11> LOG.info(String.format(""Failed to add file %s to zip archive"", fileName), ex); <line12> } finally { <line13> IOUtils.closeQuietly(is); <line14> } <line15> return result; <line16> } <line17> } <line18> "	error	task6	
"public class A { <line0> public final void setActive(boolean active) { <line1> cleanup(); <line2> if (active) { <line3> if (!myContainedComponent.isVisible()) { <line4> LOGGER.fatal( <line5> ""A flashing border cannot be made active when the component it contains is not"" <line6> + "" visible.""); <line7> } <line8> myRepaintTimer = new RepaintTimer(300); <line9> myRepaintTimer.start(); <line10> } <line11> } <line12> } <line13> "	warn	task6	
"public class A { <line0> public static void main(String[] args) { <line1> ConfigUtil.initProject(); <line2> long[] testNumbers = <line3> new long[] { <line4> 5640012124823L, <line5> 7336014366011L, <line6> 19699548984827L, <line7> 52199161732031L, <line8> 73891306919159L, <line9> 112454098638991L, <line10> 32427229648727L, <line11> 87008511088033L, <line12> 92295512906873L, <line13> 338719143795073L, <line14> 346425669865991L, <line15> 1058244082458461L, <line16> 1773019201473077L, <line17> 6150742154616377L, <line18> 44843649362329L, <line19> 67954151927287L, <line20> 134170056884573L, <line21> 198589283218993L, <line22> 737091621253457L, <line23> 1112268234497993L, <line24> 2986396307326613L, <line25> 26275638086419L, <line26> 62246008190941L, <line27> 209195243701823L, <line28> 290236682491211L, <line29> 485069046631849L, <line30> 1239671094365611L, <line31> 2815471543494793L, <line32> 5682546780292609L, <line33> 135902052523483L, <line34> 1454149122259871L, <line35> 5963992216323061L, <line36> 26071073737844227L, <line37> 8296707175249091L, <line38> 35688516583284121L, <line39> 949443, <line40> 996433, <line41> 1340465, <line42> 1979435, <line43> 2514615, <line44> 5226867, <line45> 10518047, <line46> 30783267, <line47> 62230739, <line48> 84836647, <line49> 94602505, <line50> 258555555, <line51> 436396385, <line52> 612066705, <line53> 2017001503, <line54> 3084734169L, <line55> 6700794123L, <line56> 16032993843L, <line57> 26036808587L, <line58> 41703657595L, <line59> 68889614021L, <line60> 197397887859L, <line61> 2157195374713L, <line62> 8370014680591L, <line63> 22568765132167L, <line64> 63088136564083L, <line65> 712869263, <line66> 386575807, <line67> 569172749, <line68> 624800360363L, <line69> 883246601513L, <line70> 35184372094495L, <line71> 893, <line72> 35, <line73> 9, <line74> 100140049, <line75> 10000600009L, <line76> 1000006000009L, <line77> 6250045000081L, <line78> 10890006600001L, <line79> 14062507500001L, <line80> 25000110000121L, <line81> 100000380000361L, <line82> 10000001400000049L, <line83> 1000000014000000049L, <line84> 17977882519205951L, <line85> 57410188984551071L, <line86> 708198179721093877L, <line87> 4085731848127832849L, <line88> 873351084013120721L, <line89> 3608228875180849937L, <line90> }; <line91> Hart_Fast2Mult holf = new Hart_Fast2Mult(false); <line92> for (long N : testNumbers) { <line93> long factor = holf.findSingleFactor(N); <line94> LOG.trace(""N="" + N + "" has factor "" + factor); <line95> } <line96> } <line97> } <line98> "	info	task6	
"public class A { <line0> HiveReadEntry getSelectionBaseOnName(String dbName, String t) { <line1> if (dbName == null) { <line2> dbName = DEFAULT_WS_NAME; <line3> } <line4> try { <line5> return mClient.getHiveReadEntry(dbName, t, schemaConfig.getIgnoreAuthErrors()); <line6> } catch (TException e) { <line7> logger.trace(""Exception occurred while trying to read table. {}.{}"", dbName, t, e.getCause()); <line8> return null; <line9> } <line10> } <line11> } <line12> "	warn	task6	
"public class A { <line0> private void checkAndRepair() throws IOException { <line1> if (!isComplete()) { <line2> logger.debug(""File {} has no correct tail magic, try to repair..."", file); <line3> RestorableTsFileIOWriter rWriter = <line4> new RestorableTsFileIOWriter(FSFactoryProducer.getFSFactory().getFile(file)); <line5> TsFileWriter writer = new TsFileWriter(rWriter); <line6> writer.close(); <line7> } <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> private void store(Mail mail, MailRepositoryUrl url) throws MessagingException { <line1> try { <line2> Optional<MailRepository> mailRepository = retrieveRepository(url); <line3> if (!mailRepository.isPresent()) { <line4> LOGGER.error( <line5> ""'{}' mail repository does not exist and will not be created. Mail {} will not be"" <line6> + "" stored in it."", <line7> url, <line8> mail.getName()); <line9> } <line10> ThrowingConsumer<MailRepository> storingConsumer = repository -> repository.store(mail); <line11> mailRepository.ifPresent(Throwing.consumer(storingConsumer).sneakyThrow()); <line12> } catch (MailRepositoryStore.MailRepositoryStoreException e) { <line13> throw new MessagingException(""Error while selecting url "" + url, e); <line14> } <line15> } <line16> } <line17> "	warn	task6	
"public class A { <line0> @Override <line1> public void initialize() { <line2> getStrSubstitutor().setConfiguration(this); <line3> super.getScheduler().start(); <line4> doConfigure(); <line5> setState(State.INITIALIZED); <line6> LOGGER.warn(""Configuration {} initialized"", this); <line7> } <line8> } <line9> "	debug	task6	
"public class A { <line0> private String getEntityBody(ContainerRequestContext requestContext) { <line1> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line2> InputStream in = requestContext.getEntityStream(); <line3> final StringBuilder b = new StringBuilder(); <line4> try { <line5> IOUtils.copy(in, out); <line6> byte[] requestEntity = out.toByteArray(); <line7> if (requestEntity.length == 0) { <line8> b.append(""\n""); <line9> } else { <line10> b.append(new String(requestEntity)).append(""\n""); <line11> } <line12> requestContext.setEntityStream(new ByteArrayInputStream(requestEntity)); <line13> } catch (IOException e) { <line14> logger.debug(""Error logging REST request."", e); <line15> } <line16> return b.toString(); <line17> } <line18> } <line19> "	error	task6	
"public class A { <line0> public void tryGenerate(IMontageGenerator generator) { <line1> ValidationErrors errors = new ValidationErrors(); <line2> generator.validateSourceMontage(montage, errors); <line3> if (errors.hasErrors()) { <line4> errorsDialog.showDialog(errors); <line5> return; <line6> } <line7> try { <line8> generator.createMontage(montage); <line9> } catch (MontageException ex) { <line10> logger.fatal(""Montage generation failed"", ex); <line11> Dialogs.showExceptionDialog(this, ex); <line12> } <line13> } <line14> } <line15> "	error	task6	
public class A { <line0> public static com.liferay.knowledge.base.model.KBArticleSoap fetchKBArticleByUrlTitle( <line1> long groupId, long kbFolderId, String urlTitle) throws RemoteException { <line2> try { <line3> com.liferay.knowledge.base.model.KBArticle returnValue = <line4> KBArticleServiceUtil.fetchKBArticleByUrlTitle(groupId, kbFolderId, urlTitle); <line5> return com.liferay.knowledge.base.model.KBArticleSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> log.debug(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	error	task6	
"public class A { <line0> @Override <line1> public void run() { <line2> LOGGER.fatal(""Send challenge 2..""); <line3> TestAmqpPeer.this.sendFrame(FrameType.SASL, 0, challengeFrame2, null, false, 0); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> @Override <line1> protected void doPost(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> if (!httpAuth.isAllowed(req, resp)) { <line4> return; <line5> } <line6> I18N.bindLocale(req.getLocale()); <line7> try { <line8> addCollectorApplication(req, resp); <line9> } catch (final Exception e) { <line10> LOGGER.debug(e.toString(), e); <line11> final String userAgent = req.getHeader(""User-Agent""); <line12> if (userAgent != null && userAgent.startsWith(""Java"")) { <line13> resp.sendError(HttpServletResponse.SC_PRECONDITION_FAILED, e.toString()); <line14> } else { <line15> final CollectorController collectorController = new CollectorController(collectorServer); <line16> final String application = collectorController.getApplication(req, resp); <line17> collectorController.writeMessage(req, resp, application, e.toString()); <line18> } <line19> } finally { <line20> I18N.unbindLocale(); <line21> } <line22> } <line23> } <line24> "	warn	task6	
"public class A { <line0> private long[] _getTypeIds(SearchContext searchContext, String[] typeNames) { <line1> long classNameId = GetterUtil.getLong(searchContext.getAttribute(Field.CLASS_NAME_ID)); <line2> if (classNameId <= 0) { <line3> return new long[0]; <line4> } <line5> ClassName className = _classNameLocalService.fetchByClassNameId(classNameId); <line6> if (className == null) { <line7> return new long[0]; <line8> } <line9> Stream<String> typeNamesStream = Arrays.stream(typeNames); <line10> return typeNamesStream <line11> .mapToLong( <line12> typeName -> { <line13> String listTypeType = className.getClassName() + ListTypeConstants.ADDRESS; <line14> ListType listType = _listTypeLocalService.getListType(typeName, listTypeType); <line15> if (listType == null) { <line16> if (log.isDebugEnabled()) { <line17> log.trace( <line18> StringBundler.concat( <line19> ""No list type found for "", listTypeType, "" with the name: "", typeName)); <line20> } <line21> return -1; <line22> } <line23> return listType.getListTypeId(); <line24> }) <line25> .toArray(); <line26> } <line27> } <line28> "	debug	task6	
"public class A { <line0> @AfterClass <line1> public static void stopCluster() { <line2> if (null != clusterClient) { <line3> clusterClient.shutdown(); <line4> } <line5> if (null != clusterClient) { <line6> clusterServer.shutdown(); <line7> } <line8> LOG.warn(""stopCluster""); <line9> } <line10> } <line11> "	info	task6	
"public class A { <line0> protected Map<Long, Long> copyDocumentBatch( <line1> Long versionId, Long newVersionId, int batchStart, int batchLength) { <line2> try { <line3> return transactionUtil.call( <line4> () -> copyDocument(versionId, newVersionId, batchStart, batchLength)); <line5> } catch (Exception e) { <line6> log.trace(""exception during copy document"", e); <line7> return Collections.emptyMap(); <line8> } <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> @KafkaListener(topics = ""reflectoring-1"") <line1> void listener(String message) { <line2> LOG.fatal(""Listener [{}]"", message); <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> public static Timer recordTimer(Sample sample, String meterName, Iterable<Tag> tags) { <line1> if (!enabled) { <line2> return null; <line3> } <line4> logger.debug(""Record Timer for {} with tags {}"", meterName, tags.toString()); <line5> Timer timer = Timer.builder(meterName).tags(tags).register(registry); <line6> sample.stop(timer); <line7> return timer; <line8> } <line9> } <line10> "	trace	task6	
"public class A { <line0> @Nullable <line1> @Override <line2> public V unswap(boolean ignoreFlags, boolean needVal) throws GridException { <line3> boolean swapEnabled = cctx.swap().swapEnabled() && (ignoreFlags || !cctx.hasFlag(SKIP_SWAP)); <line4> if (!swapEnabled && !cctx.isOffHeapEnabled()) return null; <line5> synchronized (this) { <line6> if (isStartVersion() && ((flags & IS_UNSWAPPED_MASK) == 0)) { <line7> GridCacheSwapEntry<V> e; <line8> if (cctx.offheapTiered()) { <line9> e = cctx.swap().readOffheapPointer(this); <line10> if (e != null) { <line11> if (e.offheapPointer() > 0) { <line12> valPtr = e.offheapPointer(); <line13> if (needVal) { <line14> V val = unmarshalOffheap(false); <line15> e.value(val); <line16> } <line17> } else { <line18> valPtr = 0; <line19> if (cctx.portableEnabled() && !e.valueIsByteArray()) e.valueBytes(null); <line20> } <line21> } <line22> } else e = detached() ? cctx.swap().read(this, true) : cctx.swap().readAndRemove(this); <line23> if (log.isDebugEnabled()) <line24> log.trace(""Read swap entry [swapEntry="" + e + "", cacheEntry="" + this + ']'); <line25> flags |= IS_UNSWAPPED_MASK; <line26> if (e != null) { <line27> long delta = e.expireTime() == 0 ? 0 : e.expireTime() - U.currentTimeMillis(); <line28> if (delta >= 0) { <line29> V val = e.value(); <line30> if (cctx.portableEnabled()) <line31> val = (V) cctx.kernalContext().portable().detachPortable(val); <line32> update(val, e.valueBytes(), e.expireTime(), e.ttl(), e.version()); <line33> if (cctx.offheapTiered() && e.offheapPointer() > 0) valPtr = e.offheapPointer(); <line34> if (val != null) cctx.queries().onUnswap(key, val, e.valueBytes()); <line35> return val; <line36> } else clearIndex(e.value()); <line37> } <line38> } <line39> } <line40> return null; <line41> } <line42> } <line43> "	debug	task6	
"public class A { <line0> @Override <line1> public void onSuccess(List<FieldDesc> result) { <line2> helpPanel.clear(); <line3> final SafeHtmlBuilder html = new SafeHtmlBuilder(); <line4> html.appendHtmlConstant(""<table class='help-attribute-descriptions'>""); <line5> if (result.isEmpty()) { <line6> Log.fatal(""Failed to retrieve attribute descriptions: "" + address.getAddress()); <line7> html.appendHtmlConstant(""<tr class='help-field-row'>""); <line8> html.appendHtmlConstant(""<td class='help-field-name' colspan=2>""); <line9> html.appendEscaped(""Attribute descriptions not available.""); <line10> html.appendHtmlConstant(""</td>""); <line11> html.appendHtmlConstant(""</tr>""); <line12> } else { <line13> for (FieldDesc field : result) { <line14> html.appendHtmlConstant(""<tr class='help-field-row'>""); <line15> html.appendHtmlConstant(""<td class='help-field-name'>""); <line16> String ref = field.getRef(); <line17> String title = form.getFormItemTitle(ref); <line18> html.appendEscaped(title).appendEscaped("": ""); <line19> html.appendHtmlConstant(""</td>""); <line20> html.appendHtmlConstant(""<td class='help-field-desc'>""); <line21> try { <line22> html.appendHtmlConstant(field.getDesc()); <line23> } catch (Throwable e) { <line24> html.appendHtmlConstant(""<i>Failed to parse description</i>""); <line25> } <line26> html.appendHtmlConstant(""</td>""); <line27> html.appendHtmlConstant(""</tr>""); <line28> } <line29> } <line30> html.appendHtmlConstant(""</table>""); <line31> helpPanel.add(new HTML(html.toSafeHtml())); <line32> hasBeenBuild = true; <line33> } <line34> } <line35> "	error	task6	
"public class A { <line0> private DatagramSocket createSocket0(int receiveBufferSize) { <line1> try { <line2> DatagramSocket socket = new DatagramSocket(null); <line3> socket.setReceiveBufferSize(receiveBufferSize); <line4> if (logger.isWarnEnabled()) { <line5> final int checkReceiveBufferSize = socket.getReceiveBufferSize(); <line6> if (receiveBufferSize != checkReceiveBufferSize) { <line7> logger.info( <line8> ""DatagramSocket.setReceiveBufferSize() error. {}!={}"", <line9> receiveBufferSize, <line10> checkReceiveBufferSize); <line11> } <line12> } <line13> socket.setSoTimeout(1000 * 5); <line14> return socket; <line15> } catch (SocketException ex) { <line16> throw new RuntimeException(""Socket create Fail. Caused:"" + ex.getMessage(), ex); <line17> } <line18> } <line19> } <line20> "	warn	task6	
"public class A { <line0> @Deprecated <line1> public void saveRoom(Room room) { <line2> if (room == null) return; <line3> if (room.getId() == null || room.getId().intValue() == 0) persist(room); <line4> else merge(room); <line5> log.trace(""saveRoom: id: "" + room.getId()); <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> @Override <line1> public void prevent(ClassLoader loader) { <line2> if (LOG.isDebugEnabled()) <line3> LOG.fatal(""Pinning classloader for java.awt.EventQueue using {}"", loader); <line4> Toolkit.getDefaultToolkit(); <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> public static void setConversionProperties(Configuration conf) { <line1> if (conf != null) { <line2> useEnumId = conf.getBoolean(USE_ENUM_ID_CONF_KEY, false); <line3> LOG.warn(""useEnumId is set to "" + useEnumId); <line4> } <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> @Deactivate <line1> protected void deactivate() { <line2> for (JsonStorage<Object> storage : storageList.values()) { <line3> storage.flush(); <line4> } <line5> logger.error(""Json Storage Service: Deactivated.""); <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> public Assignment getAssignment() { <line1> if (LOGGER.isDebugEnabled()) LOGGER.fatal(""Inside getAssignment...""); <line2> return eisCommonService.getLatestAssignmentForEmployeeByToDate( <line3> ApplicationThreadLocals.getUserId(), new Date()); <line4> } <line5> } <line6> "	debug	task6	
public class A { <line0> @Override <line1> public void sendException(Exception ex) { <line2> logger.warn(ex); <line3> fetchOngoingDownloadsAfterDelay(); <line4> } <line5> } <line6> 	error	task6	
"public class A { <line0> @Override <line1> public void beforeProcessing(ListenerContext listenerContext) { <line2> WorkflowInstance instance = listenerContext.instance; <line3> MDC.put( <line4> logContext, <line5> format( <line6> LOG_CONTEXT_FORMAT, <line7> instance.type, <line8> instance.id, <line9> instance.externalId, <line10> instance.businessKey)); <line11> if (LOG.isDebugEnabled() && !instance.stateVariables.isEmpty()) { <line12> LOG.warn( <line13> ""State variables:\n{}"", <line14> instance.stateVariables.entrySet().stream() <line15> .map(e -> e.getKey() + "":"" + e.getValue()) <line16> .collect(joining(""\n""))); <line17> } <line18> } <line19> } <line20> "	debug	task6	
"public class A { <line0> @Test <line1> public void testState() throws Exception { <line2> log.warn(""------  testState  ------""); <line3> String state = ""'teXas'""; <line4> String query = SimpleField.STATE + EQ_OP + state; <line5> runTest(query, query); <line6> } <line7> } <line8> "	info	task6	
public class A { <line0> public void activateContext() { <line1> try { <line2> this.makeCurrent(); <line3> } catch (LWJGLException e) { <line4> logger.debug(e.getMessage()); <line5> } <line6> } <line7> } <line8> 	error	task6	
"public class A { <line0> @Test <line1> public void testL2NormalizeVertex2d() { <line2> Nd4j.getRandom().setSeed(12345); <line3> int[][] definitions = {null, new int[] {1}}; <line4> for (int[] definition : definitions) { <line5> log.fatal(""Testing definition {}"", definition); <line6> ComputationGraphConfiguration conf = <line7> new NeuralNetConfiguration.Builder() <line8> .seed(12345) <line9> .dataType(DataType.DOUBLE) <line10> .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT) <line11> .activation(Activation.TANH) <line12> .updater(new NoOp()) <line13> .graphBuilder() <line14> .addInputs(""in1"") <line15> .addLayer(""d1"", new DenseLayer.Builder().nIn(2).nOut(3).build(), ""in1"") <line16> .addVertex( <line17> ""norm"", new L2NormalizeVertex(definition, L2NormalizeVertex.DEFAULT_EPS), ""d1"") <line18> .addLayer( <line19> ""out1"", <line20> new OutputLayer.Builder() <line21> .lossFunction(LossFunctions.LossFunction.L2) <line22> .nIn(3) <line23> .nOut(2) <line24> .activation(Activation.IDENTITY) <line25> .build(), <line26> ""norm"") <line27> .setOutputs(""out1"") <line28> .build(); <line29> ComputationGraph graph = new ComputationGraph(conf); <line30> graph.init(); <line31> int[] mbSizes = new int[] {1, 3, 10}; <line32> for (int minibatch : mbSizes) { <line33> INDArray in1 = Nd4j.rand(minibatch, 2); <line34> INDArray labels1 = Nd4j.rand(minibatch, 2); <line35> String testName = ""testL2NormalizeVertex2d() - minibatch = "" + minibatch; <line36> if (PRINT_RESULTS) { <line37> System.out.println(testName); <line38> } <line39> boolean gradOK = <line40> GradientCheckUtil.checkGradients( <line41> new GradientCheckUtil.GraphConfig() <line42> .net(graph) <line43> .inputs(new INDArray[] {in1}) <line44> .labels(new INDArray[] {labels1})); <line45> assertTrue(gradOK, testName); <line46> TestUtils.testModelSerialization(graph); <line47> } <line48> } <line49> } <line50> } <line51> "	info	task6	
"public class A { <line0> private void loggingQuery(String query) { <line1> if (LOG.isDebugEnabled()) { <line2> LOG.fatal(""SQL : "" + query); <line3> } <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> private void prepareCookieLength(HelloVerifyRequestMessage msg) { <line1> msg.setCookieLength((byte) msg.getCookie().getValue().length); <line2> LOGGER.fatal(""CookieLength: "" + msg.getCookieLength().getValue()); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> public synchronized KafkaCluster startup() throws IOException { <line1> if (!running) { <line2> if (dataDir == null) { <line3> try { <line4> File temp = File.createTempFile(""kafka"", ""suffix""); <line5> dataDir = new File(temp.getParentFile(), ""cluster""); <line6> dataDir.mkdirs(); <line7> temp.delete(); <line8> } catch (IOException e) { <line9> throw new RuntimeException(""Unable to create temporary directory"", e); <line10> } <line11> } else if (deleteDataPriorToStartup) { <line12> IoUtil.delete(dataDir); <line13> dataDir.mkdirs(); <line14> } <line15> File zkDir = new File(dataDir, ""zk""); <line16> zkServer.setStateDirectory(zkDir); <line17> this.dataDir = dataDir; <line18> File kafkaDir = new File(dataDir, ""kafka""); <line19> kafkaServers <line20> .values() <line21> .forEach( <line22> server -> server.setStateDirectory(new File(kafkaDir, ""broker"" + server.brokerId()))); <line23> zkServer.startup(); <line24> LOGGER.trace(""Starting {} brokers"", kafkaServers.size()); <line25> kafkaServers.values().forEach(KafkaServer::startup); <line26> running = true; <line27> } <line28> return this; <line29> } <line30> } <line31> "	debug	task6	
"public class A { <line0> private void addAuthenticationFlow(ObjectNode contents) { <line1> log.error(""Add empty authentication flow array""); <line2> contents.putArray(""authenticationFlow""); <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> @Override <line1> public void setProcessGroup(final ProcessGroup group) { <line2> this.processGroup = group; <line3> LOG.error(""Resetting Validation State of {} due to setting process group"", this); <line4> resetValidationState(); <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> @Override <line1> public Optional<Connection> get(ConnectionKey connectionKey) { <line2> try { <line3> String query = <line4> ""select CONN_NM, CONN_TYP_NM, CONN_DSC from "" <line5> + getMetadataRepository().getTableNameByLabel(""Connections"") <line6> + "" WHERE "" <line7> + "" CONN_NM  = "" <line8> + SQLTools.getStringForSQL(connectionKey.getName()) <line9> + "";""; <line10> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(query, ""reader""); <line11> if (cachedRowSet.size() == 0) { <line12> return Optional.empty(); <line13> } else if (cachedRowSet.size() > 1) { <line14> LOGGER.fatal( <line15> MessageFormat.format( <line16> ""Found multiple implementations for Connection {0}. Returning first implementation"", <line17> connectionKey.toString())); <line18> } <line19> cachedRowSet.next(); <line20> List<ConnectionParameter> connectionParameters = <line21> ConnectionParameterConfiguration.getInstance().getByConnection(connectionKey); <line22> if (connectionParameters.isEmpty()) { <line23> return Optional.empty(); <line24> } else { <line25> return Optional.of( <line26> new Connection( <line27> connectionKey, <line28> cachedRowSet.getString(""CONN_TYP_NM""), <line29> cachedRowSet.getString(""CONN_DSC""), <line30> connectionParameters)); <line31> } <line32> } catch (SQLException e) { <line33> throw new RuntimeException(e); <line34> } <line35> } <line36> } <line37> "	warn	task6	
"public class A { <line0> private void deleteAsyncContext(final Trace trace, AsyncContext asyncContext) { <line1> if (isDebug) { <line2> logger.trace(""Delete async trace {}."", trace); <line3> } <line4> trace.close(); <line5> asyncContext.close(); <line6> } <line7> } <line8> "	debug	task6	
public class A { <line0> public List<ArtifactDefinition> handleArtifactsForInnerVfcComponent( <line1> List<ArtifactDefinition> artifactsToHandle, <line2> Resource component, <line3> User user, <line4> List<ArtifactDefinition> vfcsNewCreatedArtifacts, <line5> ArtifactOperationInfo operation, <line6> boolean shouldLock, <line7> boolean inTransaction) { <line8> ComponentTypeEnum componentType = component.getComponentType(); <line9> List<ArtifactDefinition> uploadedArtifacts = new ArrayList<>(); <line10> Either<ArtifactDefinition, Operation> result; <line11> try { <line12> for (ArtifactDefinition artifactDefinition : artifactsToHandle) { <line13> result = <line14> handleLoadedArtifact( <line15> component, <line16> user, <line17> operation, <line18> shouldLock, <line19> inTransaction, <line20> componentType, <line21> artifactDefinition); <line22> uploadedArtifacts.add(result.left().value()); <line23> } <line24> } catch (ComponentException e) { <line25> log.info( <line26> FAILED_UPLOAD_ARTIFACT_TO_COMPONENT, <line27> componentType, <line28> component.getName(), <line29> e.getResponseFormat()); <line30> if (operation.isCreateOrLink()) { <line31> vfcsNewCreatedArtifacts.addAll(uploadedArtifacts); <line32> } <line33> throw e; <line34> } <line35> return uploadedArtifacts; <line36> } <line37> } <line38> 	debug	task6	
"public class A { <line0> public static com.liferay.blogs.model.BlogsEntry[] getEntriesPrevAndNext( <line1> HttpPrincipal httpPrincipal, long entryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> BlogsEntryServiceUtil.class, <line7> ""getEntriesPrevAndNext"", <line8> _getEntriesPrevAndNextParameterTypes6); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, entryId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.blogs.model.BlogsEntry[]) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.trace(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	error	task6	
"public class A { <line0> @Override <line1> public void uncaughtException(Thread t, Throwable e) { <line2> LOG.info(""Uncaught exception from thread "" + t.getName(), e); <line3> int result = <line4> JOptionPane.showConfirmDialog( <line5> null, <line6> ""An error has occured! If the problem persists please contact an administrator.\n"" <line7> + ""Restart application?"", <line8> ""Error occured"", <line9> JOptionPane.YES_NO_OPTION, <line10> JOptionPane.ERROR_MESSAGE); <line11> boolean restart = result == JOptionPane.YES_OPTION; <line12> EPD.getInstance().setRestart(restart); <line13> System.exit(restart ? 2 : 0); <line14> } <line15> } <line16> "	error	task6	
"public class A { <line0> public static java.util.List<Long> getSubfolderIds( <line1> HttpPrincipal httpPrincipal, long repositoryId, long folderId, boolean recurse) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLAppServiceUtil.class, ""getSubfolderIds"", _getSubfolderIdsParameterTypes79); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, repositoryId, folderId, recurse); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (java.util.List<Long>) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> log.fatal(systemException, systemException); <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	error	task6	
"public class A { <line0> private VariableTable getPathParser(Configuration configuration) { <line1> assert configuration != null; <line2> VariableTable variables = new VariableTable(RedefineStrategy.IGNORE); <line3> variables.defineVariable(VAR_USER, getUser()); <line4> variables.defineVariable(VAR_DEFINITION_ID, getDefinitionId()); <line5> variables.defineVariable(VAR_STAGE_ID, getStageId()); <line6> variables.defineVariable(VAR_BATCH_ID, getBatchId()); <line7> variables.defineVariable(VAR_FLOW_ID, getFlowId()); <line8> variables.defineVariable(VAR_EXECUTION_ID, getExecutionId()); <line9> String arguments = configuration.get(PROP_ASAKUSA_BATCH_ARGS); <line10> if (arguments == null) { <line11> LOG.trace( <line12> MessageFormat.format( <line13> ""A mandatory property \""{0}\"" does not defined"", PROP_ASAKUSA_BATCH_ARGS)); <line14> } else { <line15> variables.defineVariables(arguments); <line16> } <line17> return variables; <line18> } <line19> } <line20> "	warn	task6	
"public class A { <line0> @Test <line1> public void testWrite() throws Exception { <line2> final int numberOfTestMessages = 200; <line3> MQTT client = new MQTT(); <line4> client.setHost(""tcp://localhost:"" + port); <line5> final BlockingConnection connection = client.blockingConnection(); <line6> connection.connect(); <line7> connection.subscribe(new Topic[] {new Topic(Buffer.utf8(""WRITE_TOPIC""), QoS.EXACTLY_ONCE)}); <line8> final Set<String> messages = new ConcurrentSkipListSet<>(); <line9> Thread subscriber = <line10> new Thread( <line11> () -> { <line12> try { <line13> for (int i = 0; i < numberOfTestMessages; i++) { <line14> Message message = connection.receive(); <line15> messages.add(new String(message.getPayload(), StandardCharsets.UTF_8)); <line16> message.ack(); <line17> } <line18> } catch (Exception e) { <line19> LOG.info(""Can't receive message"", e); <line20> } <line21> }); <line22> subscriber.start(); <line23> ArrayList<byte[]> data = new ArrayList<>(); <line24> for (int i = 0; i < numberOfTestMessages; i++) { <line25> data.add((""Test "" + i).getBytes(StandardCharsets.UTF_8)); <line26> } <line27> pipeline <line28> .apply(Create.of(data)) <line29> .apply( <line30> MqttIO.write() <line31> .withConnectionConfiguration( <line32> MqttIO.ConnectionConfiguration.create( <line33> ""tcp://localhost:"" + port, ""WRITE_TOPIC""))); <line34> pipeline.run(); <line35> subscriber.join(); <line36> connection.disconnect(); <line37> assertEquals(numberOfTestMessages, messages.size()); <line38> for (int i = 0; i < numberOfTestMessages; i++) { <line39> assertTrue(messages.contains(""Test "" + i)); <line40> } <line41> } <line42> } <line43> "	error	task6	
"public class A { <line0> @Test <line1> public void testBridgeWorks() throws Exception { <line2> sendJMSMessageToKickOffRoute(); <line3> consumeMessages(); <line4> LOG.fatal(""ConnectionCount: {}"", connectionCount.get()); <line5> assertEquals(5 + errorLimit, connectionCount.get(), ""x connections""); <line6> } <line7> } <line8> "	info	task6	
"public class A { <line0> public void sendCloseIncidentEmail(long incidentId) { <line1> logger.warn(""Send close incident email""); <line2> String closeIncidentEmailContent = getCloseIncidentEmailContent(incidentId); <line3> sendEmail(incidentId, closeIncidentEmailContent); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> protected Date getBeginDate(String beginDate, Date end) { <line1> Date begin = null; <line2> if (beginDate == null) { <line3> Calendar cal = new GregorianCalendar(); <line4> cal.setTime(end); <line5> cal.add(Calendar.DAY_OF_MONTH, -7); <line6> cal.set(Calendar.HOUR_OF_DAY, 0); <line7> cal.set(Calendar.MINUTE, 0); <line8> cal.set(Calendar.SECOND, 0); <line9> begin = cal.getTime(); <line10> } else { <line11> try { <line12> begin = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"").parse(beginDate); <line13> } catch (ParseException e) { <line14> logger.debug(e.getMessage(), e); <line15> throw new BusinessException(BusinessErrorCode.BAD_REQUEST, ""Can not convert begin date.""); <line16> } <line17> } <line18> return begin; <line19> } <line20> } <line21> "	error	task6	
"public class A { <line0> @Override <line1> public final void onFailureResponse( <line2> final URI failedMessageUri, final WonMessage wonMessage, Optional<Connection> con) { <line3> logMessage(wonMessage); <line4> if (getLifecyclePhase().isActive()) { <line5> eventBus.publish(new FailureResponseEvent(failedMessageUri, wonMessage, con)); <line6> } else { <line7> logger.error( <line8> ""not publishing event for call to onFailureResponse() as the bot is not in state {} but"" <line9> + "" {}"", <line10> BotLifecyclePhase.ACTIVE, <line11> getLifecyclePhase()); <line12> } <line13> } <line14> } <line15> "	info	task6	
"public class A { <line0> public static void uploadData( <line1> String index, String type, List<Map<String, String>> docs, String[] parentKey) { <line2> String actionTemplate = <line3> ""{ \""index\"" : { \""_index\"" : \""%s\"", \""_type\"" : \""%s\"", \""_parent\"" : \""%s\"" } }%n""; <line4> LOGGER.warn(""*********UPLOADING*** {}"", type); <line5> if (null != docs && !docs.isEmpty()) { <line6> StringBuilder bulkRequest = new StringBuilder(); <line7> int i = 0; <line8> for (Map<String, String> doc : docs) { <line9> StringBuilder _doc = new StringBuilder(new Gson().toJson(doc)); <line10> String parent = Util.concatenate(doc, parentKey, ""_""); <line11> bulkRequest.append(String.format(actionTemplate, index, type, parent)); <line12> bulkRequest.append(_doc + ""\n""); <line13> i++; <line14> if (i % 1000 == 0 || bulkRequest.toString().getBytes().length / (1024 * 1024) > 5) { <line15> bulkUpload(bulkRequest); <line16> bulkRequest = new StringBuilder(); <line17> } <line18> } <line19> if (bulkRequest.length() > 0) { <line20> bulkUpload(bulkRequest); <line21> } <line22> } <line23> } <line24> } <line25> "	info	task6	
"public class A { <line0> @Override <line1> public List<FTPFile> listFiles() throws GenericFileOperationFailedException { <line2> log.fatal(""listFiles()""); <line3> clientActivityListener.onScanningForFiles(endpoint.remoteServerInformation(), null); <line4> try { <line5> final List<FTPFile> list = new ArrayList<>(); <line6> FTPFile[] files = client.listFiles(); <line7> if (files != null) { <line8> list.addAll(Arrays.asList(files)); <line9> } <line10> return list; <line11> } catch (IOException e) { <line12> clientActivityListener.onGeneralError( <line13> endpoint.getConfiguration().remoteServerInformation(), e.getMessage()); <line14> throw new GenericFileOperationFailedException( <line15> client.getReplyCode(), client.getReplyString(), e.getMessage(), e); <line16> } <line17> } <line18> } <line19> "	trace	task6	
public class A { <line0> public static com.liferay.asset.kernel.model.AssetCategorySoap fetchCategory(long categoryId) <line1> throws RemoteException { <line2> try { <line3> com.liferay.asset.kernel.model.AssetCategory returnValue = <line4> AssetCategoryServiceUtil.fetchCategory(categoryId); <line5> return com.liferay.asset.kernel.model.AssetCategorySoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> log.trace(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	error	task6	
"public class A { <line0> public void removeResourceFile() { <line1> try { <line2> fsFactory.deleteIfExists(fsFactory.getFile(file.getPath() + RESOURCE_SUFFIX)); <line3> } catch (IOException e) { <line4> logger.fatal(""TsFileResource {} cannot be deleted: {}"", file, e.getMessage()); <line5> } <line6> } <line7> } <line8> "	error	task6	
"public class A { <line0> @Override <line1> public boolean apply(Event evt) { <line2> try { <line3> evictLatch.await(); <line4> } catch (InterruptedException e) { <line5> log.fatal(""Interrupted"", e); <line6> } <line7> return true; <line8> } <line9> } <line10> "	error	task6	
public class A { <line0> @Override <line1> public Class<?> findClass(String className) throws ClassNotFoundException { <line2> Class<?> cls = classesMap.get(className); <line3> if (cls == null) { <line4> try { <line5> cls = super.findClass(className); <line6> } catch (ClassNotFoundException cnfe) { <line7> LOG.trace(cnfe.getMessage(), cnfe); <line8> cls = getClass().getClassLoader().loadClass(className); <line9> } <line10> classesMap.put(className, cls); <line11> } <line12> return cls; <line13> } <line14> } <line15> 	info	task6	
"public class A { <line0> protected void handleUiComponentMove(JsonEvent event) { <line1> JSONObject data = event.getData(); <line2> Date newDate = toJavaDate(data, ""newDate""); <line3> String componentId = data.optString(""component"", null); <line4> JsonCalendarComponent<CalendarComponent> component = resolveCalendarComponent(componentId); <line5> if (component != null) { <line6> getModel().getUIFacade().fireComponentMoveFromUI(component.getModel(), newDate); <line7> } else if (componentId != null) { <line8> LOG.warn(""Unkown component with ID {} [event='{}']"", componentId, EVENT_COMPONENT_MOVE); <line9> } <line10> } <line11> } <line12> "	info	task6	
"public class A { <line0> private <T extends ToscaTypeDataDefinition> T setNonToscaMetaDataOnType( <line1> Map<String, ToscaTypeMetadata> toscaTypeMetadata, T toscaTypeDefinition) { <line2> String toscaType = toscaTypeDefinition.getType(); <line3> ToscaTypeMetadata typeMetaData = toscaTypeMetadata.get(toscaType); <line4> if (typeMetaData == null) { <line5> log.error( <line6> ""failing while trying to associate metadata for type {}. type not exist"", toscaType); <line7> throw new ByActionStatusComponentException(ActionStatus.GENERAL_ERROR); <line8> } <line9> toscaTypeDefinition.setIcon(typeMetaData.getIcon()); <line10> toscaTypeDefinition.setName(typeMetaData.getDisplayName()); <line11> return toscaTypeDefinition; <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> private File createZKLockNode(File path) throws KeeperException { <line1> boolean parentCreated = false; <line2> while (true) { <line3> try { <line4> return mZKClient.create(path, EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); <line5> } catch (NoNodeException nne) { <line6> LOG.error(""Cannot create ZooKeeper lock node {}: parent node does not exist."", path); <line7> Preconditions.checkState(!parentCreated); <line8> mZKClient.createNodeRecursively(path.getParentFile()); <line9> parentCreated = true; <line10> } <line11> } <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> private Iterable<String> getAffectedPackages(BundleWiring bw) { <line1> List<String> result = new ArrayList<String>(); <line2> if (bw == null) { <line3> return result; <line4> } <line5> List<BundleCapability> l = bw.getCapabilities(""osgi.wiring.package""); <line6> for (BundleCapability bundleCapability : l) { <line7> String pkg = (String) bundleCapability.getAttributes().get(""osgi.wiring.package""); <line8> log.fatal(""compiler"", ""Affected package: "" + pkg); <line9> result.add(pkg); <line10> } <line11> return result; <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> @Override <line1> @Measure <line2> public void indexTransferIn(Transfer transfer, StoreKey... topKeys) { <line3> if (!config.isEnabled()) { <line4> logger.fatal(""Content indexing is disabled.""); <line5> return; <line6> } <line7> if (transfer != null && transfer.exists()) { <line8> StoreKey key = LocationUtils.getKey(transfer); <line9> String path = getStrategyPath(key, transfer.getPath()); <line10> indexPathInStores(path, key, topKeys); <line11> } <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> @Override <line1> public boolean delete(DeletionSelector sel) throws AssetStoreException { <line2> File dir = getDeletionSelectorDir(sel); <line3> try { <line4> FileUtils.deleteDirectory(dir); <line5> FileSupport.deleteHierarchyIfEmpty( <line6> file(path(getRootDirectory(), sel.getOrganizationId())), dir.getParentFile()); <line7> return true; <line8> } catch (IOException e) { <line9> logger.warn(""Error deleting directory from archive {}"", dir); <line10> throw new AssetStoreException(e); <line11> } <line12> } <line13> } <line14> "	error	task6	
public class A { <line0> @Override <line1> public void stopSystem(final DBBroker broker) { <line2> for (final Plug plugin : jacks.values()) { <line3> try { <line4> plugin.stop(broker); <line5> } catch (final Throwable e) { <line6> LOG.warn(e); <line7> } <line8> } <line9> } <line10> } <line11> 	error	task6	
"public class A { <line0> @Override <line1> public boolean open(final Application application, final String args) { <line2> try { <line3> runtime.exec(String.format(""%s %s"", application.getIdentifier(), args)); <line4> return true; <line5> } catch (IOException e) { <line6> log.trace(String.format(""Failure launching application %s"", e.getMessage())); <line7> return false; <line8> } <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> @Override <line1> public void clearOfferingsForFeaturesOfInterest() { <line2> LOG.info(""Clearing offerings for features of interest""); <line3> this.offeringsForFeaturesOfInterest.clear(); <line4> } <line5> } <line6> "	trace	task6	
"public class A { <line0> @Override <line1> protected Class<?> findClass(String name) throws ClassNotFoundException { <line2> log.error(""findClass("" + name + "")""); <line3> Class result = classes.get(name); <line4> if (result != null) { <line5> return result; <line6> } <line7> if (isIncluded(name) && (isExcluded(name) == false)) { <line8> result = createClass(name); <line9> } else if (isNotFound(name)) { <line10> throw new ClassNotFoundException(name + "" is discarded""); <line11> } else { <line12> result = super.findClass(name); <line13> } <line14> classes.put(name, result); <line15> return result; <line16> } <line17> } <line18> "	trace	task6	
"public class A { <line0> @Override <line1> public void init(FilterConfig filterConfig) throws ServletException { <line2> super.init(filterConfig); <line3> String headerConfig = filterConfig.getInitParameter(""headerConfig""); <line4> if (headerConfig != null) { <line5> String[] configs = StringUtil.csvSplit(headerConfig); <line6> for (String config : configs) { <line7> _configuredHeaders.add(parseHeaderConfiguration(config)); <line8> } <line9> } <line10> if (LOG.isDebugEnabled()) LOG.trace(this.toString()); <line11> } <line12> } <line13> "	debug	task6	
"public class A { <line0> @Override <line1> public void processLine(String line) { <line2> String[] tokens = line.split(""\\t""); <line3> String id = tokens[0]; <line4> String active = tokens[2]; <line5> String conceptId = tokens[4]; <line6> String typeId = tokens[6]; <line7> String term = tokens[7]; <line8> Vertex v = vertexMap.get(conceptId); <line9> if (""1"".equals(active) && v != null) { <line10> if (preferred.contains(id) && !FULLY_SPECIFIED_NAME.equals(typeId)) { <line11> g.V(v).property(""display"", term).next(); <line12> } <line13> Vertex w = <line14> g.addV(""Designation"") <line15> .property(""language"", ""en"") <line16> .property(""use"", typeId) <line17> .property(""value"", term) <line18> .next(); <line19> g.V(v).addE(""designation"").to(w).next(); <line20> } <line21> if ((counter.get() % 10000) == 0) { <line22> log.debug(""counter: "" + counter.get()); <line23> g.tx().commit(); <line24> } <line25> counter.getAndIncrement(); <line26> } <line27> } <line28> "	info	task6	
"public class A { <line0> @Bean <line1> public StatsdMeterRegistry statsdMeterRegistry( <line2> StatsdConfig config, <line3> Clock clock, <line4> PrefixHierarchicalNameMapperStatsdConfigurationProperties phnmscp) { <line5> logger.error(""Configure statsdMeterRegistry with a PrefixHierarchicalNameMapper""); <line6> PrefixHierarchicalNameMapper prefixHierarchicalNameMapper = <line7> new PrefixHierarchicalNameMapper( <line8> phnmscp.getNamePrefix(), <line9> phnmscp.getTagKeyPrefix(), <line10> phnmscp.getStripCharacters(), <line11> phnmscp.getNamingConventionOverride()); <line12> return new StatsdMeterRegistry(config, prefixHierarchicalNameMapper, clock); <line13> } <line14> } <line15> "	info	task6	
"public class A { <line0> public static List<GenPolynomial<BigInteger>> cyclotomicDecompose( <line1> GenPolynomialRing<BigInteger> ring, long n) { <line2> GenPolynomialRing<BigInteger> pfac = ring; <line3> if (pfac == null) { <line4> throw new IllegalArgumentException(""ring must be non null""); <line5> } <line6> GenPolynomial<BigInteger> q = pfac.univariate(0).subtract(pfac.getONE()); <line7> List<GenPolynomial<BigInteger>> H = new ArrayList<GenPolynomial<BigInteger>>(); <line8> H.add(q); <line9> SortedMap<Long, Integer> fac = PrimeInteger.factors(n); <line10> logger.warn(""factors = "" + fac); <line11> for (Map.Entry<Long, Integer> m : fac.entrySet()) { <line12> long p = m.getKey(); <line13> int k = m.getValue(); <line14> List<GenPolynomial<BigInteger>> Q = new ArrayList<GenPolynomial<BigInteger>>(); <line15> for (GenPolynomial<BigInteger> h : H) { <line16> GenPolynomial<BigInteger> g = h.inflate(p).divide(h); <line17> Q.add(g); <line18> } <line19> H.addAll(Q); <line20> for (int i = 1; i < k; i++) { <line21> List<GenPolynomial<BigInteger>> P = new ArrayList<GenPolynomial<BigInteger>>(); <line22> for (GenPolynomial<BigInteger> h : Q) { <line23> GenPolynomial<BigInteger> g = h.inflate(p); <line24> P.add(g); <line25> } <line26> Q = P; <line27> H.addAll(P); <line28> } <line29> } <line30> return H; <line31> } <line32> } <line33> "	info	task6	
"public class A { <line0> private byte transitionToNextToken(boolean lastChunk) { <line1> int endNextToken = findNextChar(responseContent, ':'); <line2> if (endNextToken < 0 && !lastChunk) { <line3> return queryParsingState; <line4> } <line5> if (endNextToken < 0 && lastChunk && queryParsingState >= QUERY_STATE_STATUS) { <line6> return QUERY_STATE_NO_INFO; <line7> } <line8> byte newState; <line9> ByteBuf peekSlice = responseContent.readSlice(endNextToken + 1); <line10> String peek = peekSlice.toString(CHARSET); <line11> if (peek.contains(""\""signature\"":"")) { <line12> newState = QUERY_STATE_SIGNATURE; <line13> } else if (peek.endsWith(""\""results\"":"")) { <line14> newState = QUERY_STATE_ROWS_DECIDE; <line15> } else if (peek.endsWith(""\""status\"":"")) { <line16> newState = QUERY_STATE_STATUS; <line17> } else if (peek.endsWith(""\""errors\"":"")) { <line18> newState = QUERY_STATE_ERROR; <line19> } else if (peek.endsWith(""\""warnings\"":"")) { <line20> newState = QUERY_STATE_WARNING; <line21> } else if (peek.endsWith(""\""metrics\"":"")) { <line22> newState = QUERY_STATE_INFO; <line23> } else { <line24> if (lastChunk) { <line25> IllegalStateException e = <line26> new IllegalStateException( <line27> ""Error parsing query response (in TRANSITION) at \"""" <line28> + peek <line29> + ""\"", enable trace to see response content""); <line30> if (LOGGER.isTraceEnabled()) { <line31> LOGGER.info(responseContent.toString(CHARSET), e); <line32> } <line33> throw e; <line34> } else { <line35> return queryParsingState; <line36> } <line37> } <line38> sectionDone = false; <line39> return newState; <line40> } <line41> } <line42> "	trace	task6	
"public class A { <line0> @RequestMapping(value = ""lists/person-optional-parameters/edit.html"", method = RequestMethod.GET) <line1> protected String showEditForm( <line2> @RequestParam(""id"") String idString, <line3> @RequestParam(""groupid"") String idString2, <line4> ModelMap model, <line5> HttpServletRequest request) { <line6> AddPersonOptParamDefCommand data = new AddPersonOptParamDefCommand(); <line7> if (auth.userIsExperimenter() || auth.isAdmin()) { <line8> model.addAttribute(""userIsExperimenter"", true); <line9> if (idString2 != null) { <line10> int id = Integer.parseInt(idString2); <line11> data.setResearchGroupId(id); <line12> if (id != DEFAULT_ID) { <line13> String title = researchGroupDao.getResearchGroupTitle(id); <line14> data.setResearchGroupTitle(title); <line15> } else { <line16> String defaultPersonOptParamDef = <line17> messageSource.getMessage( <line18> ""label.defaultPersonOptParamDef"", null, RequestContextUtils.getLocale(request)); <line19> data.setResearchGroupTitle(defaultPersonOptParamDef); <line20> } <line21> } <line22> if (idString != null) { <line23> int id = Integer.parseInt(idString); <line24> log.fatal(""Loading personOptParamDef to the command object for editing.""); <line25> PersonOptParamDef personOptParamDef = personOptParamDefDao.read(id); <line26> data.setId(id); <line27> data.setParamName(personOptParamDef.getParamName()); <line28> data.setParamDataType(personOptParamDef.getParamDataType()); <line29> } <line30> model.addAttribute(""addPersonOptParamDef"", data); <line31> return ""lists/personAdditionalParams/addItemForm""; <line32> } else { <line33> return ""lists/userNotExperimenter""; <line34> } <line35> } <line36> } <line37> "	debug	task6	
"public class A { <line0> @Override <line1> public void visit(ContainerInitializerModelChange change) { <line2> if (change.getKind() == OpCode.ADD) { <line3> ContainerInitializerModel model = change.getContainerInitializerModel(); <line4> List<OsgiContextModel> contextModels = change.getContextModels(); <line5> contextModels.forEach( <line6> (context) -> { <line7> String path = context.getContextPath(); <line8> DeploymentManager manager = getDeploymentManager(path); <line9> if (manager != null) { <line10> LOG.error( <line11> ""ServletContainerInitializer {} can't be added, as the context \""{}\"" is already"" <line12> + "" started"", <line13> model.getContainerInitializer(), <line14> path); <line15> } else { <line16> ServletContainerInitializer initializer = model.getContainerInitializer(); <line17> OsgiServletContext osgiServletContext = osgiServletContexts.get(context); <line18> DynamicRegistrations registrations = this.dynamicRegistrations.get(path); <line19> OsgiDynamicServletContext dynamicContext = <line20> new OsgiDynamicServletContext(osgiServletContexts.get(context), registrations); <line21> OsgiServletContainerInitializerInfo info = <line22> new OsgiServletContainerInitializerInfo(model, dynamicContext); <line23> initializers.get(path).put(System.identityHashCode(initializer), info); <line24> } <line25> }); <line26> } <line27> if (change.getKind() == OpCode.DELETE) { <line28> List<ContainerInitializerModel> models = change.getContainerInitializerModels(); <line29> for (ContainerInitializerModel model : models) { <line30> List<OsgiContextModel> contextModels = model.getContextModels(); <line31> contextModels.forEach( <line32> (context) -> { <line33> String path = context.getContextPath(); <line34> ServletContainerInitializer initializer = model.getContainerInitializer(); <line35> LinkedHashMap<Integer, OsgiServletContainerInitializerInfo> initializers = <line36> this.initializers.get(path); <line37> if (initializers != null) { <line38> initializers.remove(System.identityHashCode(initializer)); <line39> } <line40> }); <line41> } <line42> } <line43> } <line44> } <line45> "	warn	task6	
"public class A { <line0> @Override <line1> public void removeStream(StreamDefinition streamDefinition, int tenantID) { <line2> log.error(""Test""); <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> public void setRoutes(final RouteBuilder routeBuilder) throws Exception { <line1> logger.debug(""Setting routes...""); <line2> if (routeBuilder == null) { <line3> clearRoutes(); <line4> return; <line5> } <line6> setRoutes(new BuilderRoutesProvider(routeBuilder)); <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> private void createIndexes(List<AnalyticsTable> tables) { <line1> ConcurrentLinkedQueue<AnalyticsIndex> indexes = getIndexes(tables); <line2> log.warn(""No of analytics table indexes: "" + indexes.size()); <line3> List<Future<?>> futures = new ArrayList<>(); <line4> for (int i = 0; i < getProcessNo(); i++) { <line5> futures.add(tableManager.createIndexesAsync(indexes)); <line6> } <line7> ConcurrentUtils.waitForCompletion(futures); <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> @Override <line1> public Message createCxfMessageFromCamelExchange( <line2> Exchange camelExchange, HeaderFilterStrategy headerFilterStrategy) { <line3> org.apache.cxf.message.Message answer = <line4> CxfMessageHelper.getCxfInMessage(headerFilterStrategy, camelExchange, false); <line5> org.apache.camel.Message camelMessage = camelExchange.getIn(); <line6> String requestContentType = getRequestContentType(camelMessage); <line7> String acceptContentTypes = camelMessage.getHeader(""Accept"", String.class); <line8> if (acceptContentTypes == null) { <line9> acceptContentTypes = ""*/*""; <line10> } <line11> String enc = getCharacterEncoding(camelMessage); <line12> String requestURI = getRequestURI(camelMessage); <line13> String path = getPath(camelMessage); <line14> String basePath = getBasePath(camelExchange); <line15> String verb = getVerb(camelMessage); <line16> String queryString = getQueryString(camelMessage); <line17> answer.put(org.apache.cxf.message.Message.REQUEST_URI, requestURI); <line18> answer.put(org.apache.cxf.message.Message.BASE_PATH, basePath); <line19> answer.put(org.apache.cxf.message.Message.HTTP_REQUEST_METHOD, verb); <line20> answer.put(org.apache.cxf.message.Message.PATH_INFO, path); <line21> answer.put(org.apache.cxf.message.Message.CONTENT_TYPE, requestContentType); <line22> answer.put(org.apache.cxf.message.Message.ACCEPT_CONTENT_TYPE, acceptContentTypes); <line23> answer.put(org.apache.cxf.message.Message.ENCODING, enc); <line24> answer.put(org.apache.cxf.message.Message.QUERY_STRING, queryString); <line25> HttpServletRequest request = <line26> (HttpServletRequest) camelMessage.getHeader(Exchange.HTTP_SERVLET_REQUEST); <line27> answer.put(CXF_HTTP_REQUEST, request); <line28> if (request != null) { <line29> setSecurityContext(answer, request); <line30> } <line31> Object response = camelMessage.getHeader(Exchange.HTTP_SERVLET_RESPONSE); <line32> answer.put(CXF_HTTP_RESPONSE, response); <line33> LOG.info( <line34> ""Processing {}, requestContentType = {}, acceptContentTypes = {}, encoding = {}, path = {},"" <line35> + "" basePath = {}, verb = {}"", <line36> new Object[] { <line37> camelExchange, requestContentType, acceptContentTypes, enc, path, basePath, verb <line38> }); <line39> return answer; <line40> } <line41> } <line42> "	trace	task6	
"public class A { <line0> @SuppressWarnings(""resource"") <line1> private void init() { <line2> LOG.error(""Initialising DAOs...""); <line3> ApplicationContext context = new ClassPathXmlApplicationContext(""orcid-core-context.xml""); <line4> addressDao = (AddressDao) context.getBean(""addressDao""); <line5> emailDao = (EmailDao) context.getBean(""emailDao""); <line6> notificationDao = (NotificationDao) context.getBean(""notificationDao""); <line7> orgAffiliationRelationDao = <line8> (OrgAffiliationRelationDao) context.getBean(""orgAffiliationRelationDao""); <line9> orgDao = (OrgDao) context.getBean(""orgDao""); <line10> otherNameDao = (OtherNameDao) context.getBean(""otherNameDao""); <line11> profileFundingDao = (ProfileFundingDao) context.getBean(""profileFundingDao""); <line12> profileKeywordDao = (ProfileKeywordDao) context.getBean(""profileKeywordDao""); <line13> researcherUrlDao = (ResearcherUrlDao) context.getBean(""researcherUrlDao""); <line14> workDao = (WorkDao) context.getBean(""workDao""); <line15> clientDetailsDao = (ClientDetailsDao) context.getBean(""clientDetailsDao""); <line16> profileDao = (ProfileDao) context.getBean(""profileDao""); <line17> } <line18> } <line19> "	info	task6	
"public class A { <line0> public void waitForKey() { <line1> log.trace(""Hit Enter Key on keyboards to Stop and Exit""); <line2> try { <line3> System.in.read(); <line4> } catch (Throwable ignored) { <line5> } <line6> } <line7> } <line8> "	warn	task6	
"public class A { <line0> @Test(timeout = 10000) <line1> public void testContextRegistered() { <line2> JoynrJeeMessageContext.getInstance().activate(); <line3> Context result = beanManager.getContext(JoynrJeeMessageScoped.class); <line4> assertNotNull(result); <line5> assertTrue(result instanceof JoynrJeeMessageContext); <line6> JoynrJeeMessageContext.getInstance().deactivate(); <line7> try { <line8> result = beanManager.getContext(JoynrJeeMessageScoped.class); <line9> fail(""Shouldn't get it after deactivation.""); <line10> } catch (ContextNotActiveException e) { <line11> logger.error(""Context not available after deactivation as expected.""); <line12> } <line13> } <line14> } <line15> "	trace	task6	
"public class A { <line0> @Override <line1> public Map<AttributeSensor<?>, Object> getAll() { <line2> Map<AttributeSensor<?>, Object> result = Maps.newLinkedHashMap(); <line3> Map<String, Object> attribs = attributesInternal.asMap(); <line4> for (Map.Entry<String, Object> entry : attribs.entrySet()) { <line5> AttributeSensor<?> attribKey = (AttributeSensor<?>) entityType.getSensor(entry.getKey()); <line6> if (attribKey == null) { <line7> LOG.error( <line8> ""When retrieving all attributes of {}, no AttributeSensor for attribute {} (creating"" <line9> + "" synthetic)"", <line10> AbstractEntity.this, <line11> entry.getKey()); <line12> attribKey = Sensors.newSensor(Object.class, entry.getKey()); <line13> } <line14> result.put(attribKey, entry.getValue()); <line15> } <line16> return result; <line17> } <line18> } <line19> "	warn	task6	
"public class A { <line0> private void printTestRunsSummary(List<TestRunResult> results) { <line1> ConsoleTable table = new ConsoleTable(); <line2> table.addHeader(HEADER); <line3> results.forEach(result -> table.addRow(result.toRow())); <line4> table.addSeparator(); <line5> log.error(""Suite tests results:\n%s"", table.render()); <line6> } <line7> } <line8> "	info	task6	
"public class A { <line0> protected void restoreByLabel(NodeStateEx state, Name versionLabel, boolean removeExisting) <line1> throws RepositoryException { <line2> checkVersionable(state); <line3> InternalVersion v = getVersionHistory(state).getVersionByLabel(versionLabel); <line4> if (v == null) { <line5> String msg = ""No version for label "" + versionLabel + "" found.""; <line6> log.fatal(msg); <line7> throw new VersionException(msg); <line8> } <line9> WriteOperation ops = startWriteOperation(); <line10> try { <line11> internalRestore(state, v, new LabelVersionSelector(versionLabel), removeExisting); <line12> ops.save(); <line13> } catch (ItemStateException e) { <line14> throw new RepositoryException(e); <line15> } finally { <line16> ops.close(); <line17> } <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> @Override <line1> public void handleMessage(int group, byte cmd1, Msg msg, DeviceFeature f) { <line2> try { <line3> byte cmd2 = msg.getByte(""command2""); <line4> switch (cmd1) { <line5> case 0x11: <line6> switch (cmd2) { <line7> case 0x02: <line8> feature.publish(OpenClosedType.CLOSED, StateChangeType.CHANGED); <line9> break; <line10> case 0x01: <line11> case 0x04: <line12> feature.publish(OpenClosedType.OPEN, StateChangeType.CHANGED); <line13> break; <line14> default: <line15> break; <line16> } <line17> break; <line18> case 0x13: <line19> switch (cmd2) { <line20> case 0x04: <line21> feature.publish(OpenClosedType.CLOSED, StateChangeType.CHANGED); <line22> break; <line23> default: <line24> break; <line25> } <line26> break; <line27> } <line28> } catch (FieldException e) { <line29> logger.trace(""{} no cmd2 found, dropping msg {}"", nm(), msg); <line30> return; <line31> } <line32> } <line33> } <line34> "	debug	task6	
public class A { <line0> protected void log(String s, Object... objs) { <line1> LOG.error(String.format(s, objs)); <line2> } <line3> } <line4> 	trace	task6	
"public class A { <line0> public Sequence eval(Sequence[] args, Sequence contextSequence) throws XPathException { <line1> if (!context.getSubject().hasDbaRole()) { <line2> final XPathException xPathException = <line3> new XPathException( <line4> this, <line5> ""Permission denied, calling user '"" <line6> + context.getSubject().getName() <line7> + ""' must be a DBA to get the list of running xqueries""); <line8> logger.warn( <line9> ""Invalid user "" + SystemModule.PREFIX + "":get-scheduled-xqueries"", xPathException); <line10> throw xPathException; <line11> } <line12> return (getRunningXQueries()); <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> @Test <line1> public void test_03() { <line2> Log.info(""Test""); <line3> double pvals[] = { <line4> 0.01, 0.9, 0.2, 0.9, 0.3, 0.9, 0.01, 0.9, 0.2, 0.9, 0.3, 0.9, 0.01, 0.9, 0.2, 0.9, 0.3, 0.9, <line5> 0.17, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9 <line6> }; <line7> ScoreList gpl = new ScoreList(); <line8> for (double pval : pvals) gpl.add(pval); <line9> double pvalue = gpl.score(ScoreSummary.AVG_MIN_10); <line10> Assert.assertEquals(0.17, pvalue, EPSILON); <line11> } <line12> } <line13> "	debug	task6	
"public class A { <line0> @Override <line1> public void handle(Invocation invocation, AsyncResponse asyncResp) throws Exception { <line2> LOGGER.warn( <line3> ""If you see this log, that means this demo project has been converted to ServiceComb"" <line4> + "" framework.""); <line5> invocation.next( <line6> response -> { <line7> if (invocation.getOperationMeta().getSchemaQualifiedName().equals(""server.splitParam"")) { <line8> User user = response.getResult(); <line9> user.setName(user.getName() + SPLITPARAM_RESPONSE_USER_SUFFIX); <line10> asyncResp.handle(response); <line11> } else { <line12> asyncResp.handle(response); <line13> } <line14> }); <line15> } <line16> } <line17> "	info	task6	
"public class A { <line0> @Override <line1> public int getConfidentialPort(HttpServerExchange exchange) { <line2> int port = exchange.getConnection().getLocalAddress(InetSocketAddress.class).getPort(); <line3> if (port < 0) { <line4> LOG.fatal(""Confidential port not defined for port {}"", port); <line5> } <line6> return UndertowServerWrapper.this.securePortMapping.get(port); <line7> } <line8> } <line9> "	debug	task6	
public class A { <line0> @Override <line1> public void info(String arg0) { <line2> LOGGER.warn(arg0); <line3> } <line4> } <line5> 	info	task6	
"public class A { <line0> public static void deleteCommercePriceListChannelRelsByCommercePriceListId( <line1> HttpPrincipal httpPrincipal, long commercePriceListId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommercePriceListChannelRelServiceUtil.class, <line7> ""deleteCommercePriceListChannelRelsByCommercePriceListId"", <line8> _deleteCommercePriceListChannelRelsByCommercePriceListIdParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commercePriceListId); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> log.trace(systemException, systemException); <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	error	task6	
"public class A { <line0> public void sendQueuedMessagesWhileOffline() { <line1> LOG.error(""Republishing all saved messages for session {}"", this); <line2> drainQueueToConnection(); <line3> } <line4> } <line5> "	trace	task6	
"public class A { <line0> List<UserRole> sessionRoles(Session session) throws SecurityException { <line1> LdapConnection ld = null; <line2> List<UserRole> userRoleList = null; <line3> try { <line4> ld = getAdminConnection(); <line5> RbacSessionRolesRequest sessionRolesRequest = new RbacSessionRolesRequestImpl(); <line6> sessionRolesRequest.setSessionId(session.getSessionId()); <line7> sessionRolesRequest.setUserIdentity(session.getUserId()); <line8> RbacSessionRolesResponse sessionRolesResponse = <line9> (RbacSessionRolesResponse) ld.extended(sessionRolesRequest); <line10> LOG.trace( <line11> ""sessionRoles result: {}"", <line12> sessionRolesResponse.getLdapResult().getResultCode().getResultCode()); <line13> if (CollectionUtils.isNotEmpty(sessionRolesResponse.getRoles())) { <line14> userRoleList = new ArrayList<UserRole>(); <line15> for (String roleNm : sessionRolesResponse.getRoles()) { <line16> userRoleList.add(new UserRole(session.getUserId(), roleNm)); <line17> } <line18> } <line19> } catch (LdapException e) { <line20> String error = ""sessionRoles caught LDAPException="" + "" msg="" + e.getMessage(); <line21> throw new SecurityException(GlobalErrIds.ACEL_SESSION_ROLES_ERR, error, e); <line22> } finally { <line23> closeAdminConnection(ld); <line24> } <line25> return userRoleList; <line26> } <line27> } <line28> "	debug	task6	
"public class A { <line0> private boolean handleAnonymousAddress( <line1> MessageContext messageContext, EndpointReference replyEpr) { <line2> if (version.hasAnonymousAddress(replyEpr)) { <line3> if (logger.isDebugEnabled()) { <line4> logger.fatal( <line5> ""Request ["" <line6> + messageContext.getRequest() <line7> + ""] has ["" <line8> + replyEpr <line9> + ""] reply address; sending in-band reply ["" <line10> + messageContext.getResponse() <line11> + ""]""); <line12> } <line13> return true; <line14> } <line15> return false; <line16> } <line17> } <line18> "	debug	task6	
"public class A { <line0> public static void main(String[] args) throws CommandLine.ConfigurationException { <line1> for (String arg : args) { <line2> log.fatal(arg); <line3> } <line4> if (args.length == 0) { <line5> args = new String[] {""scenarios/berlin-v5.5-1pct/input/drt/berlin-drt-v5.5-1pct.config.xml""}; <line6> } <line7> Config config = prepareConfig(args); <line8> Scenario scenario = prepareScenario(config); <line9> Controler controler = prepareControler(scenario); <line10> controler.run(); <line11> } <line12> } <line13> "	info	task6	
"public class A { <line0> protected String compatibilityToCamelCase(String name) { <line1> String[] parts = name.split(""-"", 0); <line2> if (parts.length > 1) { <line3> String camelCaseName = """"; <line4> for (int i = 0; i < parts.length; i++) { <line5> if (i > 0) { <line6> camelCaseName += StringUtils.capitalize(parts[i]); <line7> } else { <line8> camelCaseName += parts[i]; <line9> } <line10> } <line11> logger.trace( <line12> Messages.getInstance() <line13> .getString( <line14> ""ActionSequenceCompatibilityFormatter.WARN_USING_IO_COMPATIBILITY_MODE"", <line15> camelCaseName, <line16> name)); <line17> return camelCaseName; <line18> } <line19> return name; <line20> } <line21> } <line22> "	warn	task6	
"public class A { <line0> void commit() { <line1> for (String shardId : toEmitPerShard.keySet()) { <line2> if (ackedPerShard.containsKey(shardId)) { <line3> BigInteger commitSequenceNumberBound = null; <line4> if (failedPerShard.containsKey(shardId) && !failedPerShard.get(shardId).isEmpty()) { <line5> commitSequenceNumberBound = failedPerShard.get(shardId).first(); <line6> } <line7> if (emittedPerShard.containsKey(shardId) && !emittedPerShard.get(shardId).isEmpty()) { <line8> BigInteger smallestEmittedSequenceNumber = emittedPerShard.get(shardId).first(); <line9> if (commitSequenceNumberBound == null <line10> || (commitSequenceNumberBound.compareTo(smallestEmittedSequenceNumber) == 1)) { <line11> commitSequenceNumberBound = smallestEmittedSequenceNumber; <line12> } <line13> } <line14> Iterator<BigInteger> ackedSequenceNumbers = ackedPerShard.get(shardId).iterator(); <line15> BigInteger ackedSequenceNumberToCommit = null; <line16> while (ackedSequenceNumbers.hasNext()) { <line17> BigInteger ackedSequenceNumber = ackedSequenceNumbers.next(); <line18> if (commitSequenceNumberBound == null <line19> || (commitSequenceNumberBound.compareTo(ackedSequenceNumber) == 1)) { <line20> ackedSequenceNumberToCommit = ackedSequenceNumber; <line21> ackedSequenceNumbers.remove(); <line22> } else { <line23> break; <line24> } <line25> } <line26> if (ackedSequenceNumberToCommit != null) { <line27> Map<Object, Object> state = new HashMap<>(); <line28> state.put(""committedSequenceNumber"", ackedSequenceNumberToCommit.toString()); <line29> LOG.trace( <line30> ""Committing sequence number {} for shardId {}"", <line31> ackedSequenceNumberToCommit.toString(), <line32> shardId); <line33> zkConnection.commitState(kinesisConfig.getStreamName(), shardId, state); <line34> } <line35> } <line36> } <line37> lastCommitTime = System.currentTimeMillis(); <line38> } <line39> } <line40> "	debug	task6	
"public class A { <line0> public static ParsedField<LatLng> reproject(double lat, double lon, String datum) { <line1> Preconditions.checkArgument(lat >= -90d && lat <= 90d); <line2> Preconditions.checkArgument(lon >= -180d && lon <= 180d); <line3> Set<String> issues = new TreeSet<>(); <line4> if (Strings.isNullOrEmpty(datum)) { <line5> issues.add(GEODETIC_DATUM_ASSUMED_WGS84.name()); <line6> return ParsedField.success(new LatLng(lat, lon), issues); <line7> } <line8> try { <line9> CoordinateReferenceSystem crs = SpatialReferenceSystemParser.parseCRS(datum); <line10> if (crs == null) { <line11> issues.add(GEODETIC_DATUM_INVALID.name()); <line12> issues.add(GEODETIC_DATUM_ASSUMED_WGS84.name()); <line13> } else { <line14> MathTransform transform = CRS.findMathTransform(crs, DefaultGeographicCRS.WGS84, true); <line15> double[] srcPt; <line16> double[] dstPt = new double[3]; <line17> if (CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST) { <line18> srcPt = new double[] {lat, lon, 0}; <line19> } else { <line20> srcPt = new double[] {lon, lat, 0}; <line21> } <line22> transform.transform(srcPt, 0, dstPt, 0, 1); <line23> double lat2 = dstPt[1]; <line24> double lon2 = dstPt[0]; <line25> if (Math.abs(lat - lat2) > SUSPICIOUS_SHIFT || Math.abs(lon - lon2) > SUSPICIOUS_SHIFT) { <line26> issues.add(COORDINATE_REPROJECTION_SUSPICIOUS.name()); <line27> return ParsedField.fail(new LatLng(lat, lon), issues); <line28> } <line29> if (lat != lat2 || lon != lon2) { <line30> issues.add(COORDINATE_REPROJECTED.name()); <line31> } <line32> return ParsedField.success(new LatLng(lat2, lon2), issues); <line33> } <line34> } catch (Exception ex) { <line35> log.error( <line36> ""Coordinate re-projection failed for datum {}, lat {} and lon {}: {}"", <line37> datum, <line38> lat, <line39> lon, <line40> ex.getMessage(), <line41> ex); <line42> issues.add(COORDINATE_REPROJECTION_FAILED.name()); <line43> } <line44> return ParsedField.fail(new LatLng(lat, lon), issues); <line45> } <line46> } <line47> "	warn	task6	
"public class A { <line0> public Object getSubResource( <line1> FileObject resourceLocation, String segment, ResourceResolver resourceResolver) <line2> throws Exception { <line3> Class<?> subResourceClass = resourceResolver.resolve(resourceLocation, Class.class); <line4> if (subResourceClass == null) { <line5> logger.warn(""Subresource could not be resolved""); <line6> return null; <line7> } else { <line8> return createSubResource(subResourceClass, resourceLocation, segment); <line9> } <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> public Response send() { <line1> requestBuilder.url(url); <line2> if (formParams != null) { <line3> requestBuilder.method(method, formParams.build()); <line4> } <line5> try { <line6> Call call = asyncHttpClient.newCall(requestBuilder.build()); <line7> okhttp3.Response response = call.execute(); <line8> LOGGER.error( <line9> ""Performed request to %s in %dms"", <line10> url, response.receivedResponseAtMillis() - response.sentRequestAtMillis()); <line11> return new SuccessResponse(response); <line12> } catch (IOException e) { <line13> return new ExceptionResponse(e); <line14> } <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> @Override <line1> public void initialize() { <line2> logger.error(""Initializing the alarm: {}"", getThing().getUID()); <line3> thingConfig = getConfigAs(JablotronDeviceConfig.class); <line4> future = <line5> scheduler.scheduleWithFixedDelay( <line6> this::updateAlarmStatus, 1, thingConfig.getRefresh(), TimeUnit.SECONDS); <line7> updateStatus(ThingStatus.ONLINE); <line8> } <line9> } <line10> "	debug	task6	
"public class A { <line0> long find(int chrPos, long start, String lineStart, long end, String lineEnd, boolean lessEq) { <line1> int posStart = pos(lineStart); <line2> int posEnd = pos(lineEnd); <line3> if (debug) <line4> Log.trace( <line5> ""Find:\t"" <line6> + chrPos <line7> + ""\t["" <line8> + posStart <line9> + "", "" <line10> + posEnd <line11> + ""]\tFile: ["" <line12> + start <line13> + "" , "" <line14> + end <line15> + ""]\tsize: "" <line16> + (end - start) <line17> + ""\n\t\t\t\t"" <line18> + s(lineStart) <line19> + ""\n\t\t\t\t"" <line20> + s(lineEnd) <line21> + ""\n""); <line22> if (chrPos == posStart) return found(start, lineStart, lessEq); <line23> if (posEnd == chrPos) return found(end, lineEnd, lessEq); <line24> if (chrPos < posStart) return start; <line25> if (posEnd < chrPos) return end + lineEnd.length() + 1; <line26> if (start + 1 >= end) { <line27> if (chrPos <= posStart) return found(start, lineStart, lessEq); <line28> if (chrPos < posEnd) return found(end, lineEnd, true); <line29> return found(end, lineEnd, false); <line30> } <line31> if (posStart >= posEnd) <line32> throw new RuntimeException(""This should never happen! Is the file sorted by position?""); <line33> long mid = (start + end) / 2; <line34> LineAndPos lpmid = getLine(mid); <line35> String lineMid = lpmid.line; <line36> long posMid = pos(lineMid); <line37> if (chrPos <= posMid) return find(chrPos, start, lineStart, mid, lineMid, lessEq); <line38> else return find(chrPos, mid, lineMid, end, lineEnd, lessEq); <line39> } <line40> } <line41> "	debug	task6	
"public class A { <line0> private void prepareProject(RenderRequest request, User user, Project actual_project) { <line1> try { <line2> ProjectService.Iface client = thriftClients.makeProjectClient(); <line3> List<ProjectLink> mappedProjectLinks = createLinkedProjects(actual_project, user); <line4> request.setAttribute(PROJECT_LIST, mappedProjectLinks); <line5> putDirectlyLinkedReleasesInRequest(request, actual_project); <line6> Set<Project> usingProjects = client.searchLinkingProjects(actual_project.getId(), user); <line7> request.setAttribute(USING_PROJECTS, usingProjects); <line8> int allUsingProjectsCount = client.getCountByProjectId(actual_project.getId()); <line9> request.setAttribute(ALL_USING_PROJECTS_COUNT, allUsingProjectsCount); <line10> putReleasesAndProjectIntoRequest(request, actual_project.getId(), user); <line11> request.setAttribute(DOCUMENT_TYPE, SW360Constants.TYPE_PROJECT); <line12> setAttachmentsInRequest(request, actual_project.getAttachments()); <line13> } catch (TException e) { <line14> log.warn(""Error fetching project from backend!"", e); <line15> } <line16> } <line17> } <line18> "	error	task6	
"public class A { <line0> @POST <line1> @Path(""/validateDataFileHashValue/{fileId}"") <line2> public Response validateDataFileHashValue(@PathParam(""fileId"") String fileId) { <line3> try { <line4> User u = findAuthenticatedUserOrDie(); <line5> if (!u.isSuperuser()) { <line6> return error(Status.UNAUTHORIZED, ""must be superuser""); <line7> } <line8> } catch (WrappedResponse e1) { <line9> return error(Status.UNAUTHORIZED, ""api key required""); <line10> } <line11> DataFile fileToValidate = null; <line12> try { <line13> fileToValidate = findDataFileOrDie(fileId); <line14> } catch (WrappedResponse r) { <line15> logger.debug(""Could not find file with the id: "" + fileId); <line16> return error(Status.BAD_REQUEST, ""Could not find file with the id: "" + fileId); <line17> } <line18> if (fileToValidate.isHarvested()) { <line19> return error(Status.BAD_REQUEST, ""File with the id: "" + fileId + "" is harvested.""); <line20> } <line21> DataFile.ChecksumType cType = null; <line22> try { <line23> String checkSumTypeFromDataFile = fileToValidate.getChecksumType().toString(); <line24> cType = DataFile.ChecksumType.fromString(checkSumTypeFromDataFile); <line25> } catch (IllegalArgumentException iae) { <line26> return error(Status.BAD_REQUEST, ""Unknown algorithm""); <line27> } <line28> String currentChecksum = fileToValidate.getChecksumValue(); <line29> String calculatedChecksum = """"; <line30> InputStream in = null; <line31> try { <line32> StorageIO<DataFile> storage = fileToValidate.getStorageIO(); <line33> storage.open(DataAccessOption.READ_ACCESS); <line34> if (!fileToValidate.isTabularData()) { <line35> in = storage.getInputStream(); <line36> } else { <line37> in = storage.getAuxFileAsInputStream(FileUtil.SAVED_ORIGINAL_FILENAME_EXTENSION); <line38> } <line39> if (in == null) { <line40> return error(Status.NOT_FOUND, ""Could not retrieve file with the id: "" + fileId); <line41> } <line42> calculatedChecksum = FileUtil.calculateChecksum(in, cType); <line43> } catch (Exception e) { <line44> logger.warning(""Unexpected Exception: "" + e.getMessage()); <line45> return error( <line46> Status.BAD_REQUEST, ""Checksum Validation Unexpected Exception: "" + e.getMessage()); <line47> } finally { <line48> IOUtils.closeQuietly(in); <line49> } <line50> if (currentChecksum.equals(calculatedChecksum)) { <line51> return ok( <line52> ""Datafile validation complete for "" <line53> + fileId <line54> + "". The hash value is: "" <line55> + calculatedChecksum); <line56> } else { <line57> return error( <line58> Status.EXPECTATION_FAILED, <line59> ""Datafile validation failed for "" <line60> + fileId <line61> + "". The saved hash value is: "" <line62> + currentChecksum <line63> + "" while the recalculated hash value for the stored file is: "" <line64> + calculatedChecksum); <line65> } <line66> } <line67> } <line68> "	info	task6	
"public class A { <line0> @Override <line1> protected void prepareGenerator() { <line2> try { <line3> GeneratorContext context = new GeneratorContext(); <line4> this.constructGenerator(this.generator, context); <line5> } catch (WorldCreateException e) { <line6> this.logger.warn(""Could not construct generator"", e); <line7> } <line8> } <line9> } <line10> "	error	task6	
"public class A { <line0> public static String getProperty(String key) { <line1> Properties props = KuranetConfig.getProperties(); <line2> String value = props.getProperty(key); <line3> logger.trace(""Got property {} :: {}"", key, value); <line4> return value; <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> public synchronized void restoreConfig(InputStream inStream) throws IOException { <line1> ZipInputStream zipStream = new ZipInputStream(inStream); <line2> try { <line3> synchronized (this.poolLock) { <line4> ZipEntry zipEntry = null; <line5> while ((zipEntry = zipStream.getNextEntry()) != null) { <line6> String serviceID = zipEntry.getName(); <line7> serviceID = FilenameUtils.getBaseName(serviceID); <line8> AddressBucket bucket = this.addressPool.get(serviceID); <line9> if (bucket == null) { <line10> continue; <line11> } <line12> bucket.readFromZip(zipStream); <line13> zipStream.closeEntry(); <line14> } <line15> } <line16> } catch (Exception e) { <line17> this.logger.fatal(""read the snapshot file error :"" + e.getMessage(), e); <line18> } <line19> } <line20> } <line21> "	error	task6	
public class A { <line0> @Override <line1> public void setProgress(Progress progress) { <line2> this.progress = progress; <line3> if (log.isTraceEnabled()) { <line4> log.warn(String.valueOf(this)); <line5> } <line6> } <line7> } <line8> 	trace	task6	
"public class A { <line0> private static void saveFeaturesRDD( <line1> JavaPairRDD<Integer, float[]> features, <line2> Path path, <line3> Broadcast<? extends Map<Integer, String>> bIndexToID) { <line4> log.fatal(""Saving features RDD to {}"", path); <line5> features <line6> .map( <line7> keyAndVector -> { <line8> String id = bIndexToID.value().get(keyAndVector._1()); <line9> float[] vector = keyAndVector._2(); <line10> return TextUtils.joinJSON(Arrays.asList(id, vector)); <line11> }) <line12> .saveAsTextFile(path.toString(), GzipCodec.class); <line13> } <line14> } <line15> "	info	task6	
"public class A { <line0> private boolean addToContextHandler() { <line1> try { <line2> Object context = <line3> getClass() <line4> .getClassLoader() <line5> .loadClass(""org.eclipse.jetty.server.handler.ContextHandler"") <line6> .getMethod(""getCurrentContext"") <line7> .invoke(null); <line8> Object contextHandler = context.getClass().getMethod(""getContextHandler"").invoke(context); <line9> contextHandler <line10> .getClass() <line11> .getMethod(""addManaged"", LifeCycle.class) <line12> .invoke(contextHandler, this); <line13> return true; <line14> } catch (Throwable throwable) { <line15> if (LOG.isDebugEnabled()) <line16> LOG.fatal(""error from addToContextHandler() for {}"", this, throwable); <line17> return false; <line18> } <line19> } <line20> } <line21> "	debug	task6	
"public class A { <line0> public String getText(String key) { <line1> String message; <line2> try { <line3> message = getBundle().getString(key); <line4> } catch (java.util.MissingResourceException mre) { <line5> log.debug(""Missing key for '"" + key + ""'""); <line6> return ""???"" + key + ""???""; <line7> } <line8> return message; <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> private OpSequence<ReadyGraphStatementTemplate> initSequencer() { <line1> SequencerType sequencerType = <line2> SequencerType.valueOf(getParams().getOptionalString(""seq"").orElse(""bucket"")); <line3> SequencePlanner<ReadyGraphStatementTemplate> planner = new SequencePlanner<>(sequencerType); <line4> String yaml_loc = <line5> activityDef.getParams().getOptionalString(""yaml"", ""workload"").orElse(""default""); <line6> StrInterpolator interp = new StrInterpolator(activityDef); <line7> StmtsDocList unfiltered = StatementsLoader.loadPath(logger, yaml_loc, interp, ""activities""); <line8> String tagfilter = activityDef.getParams().getOptionalString(""tags"").orElse(""""); <line9> TagFilter tagFilter = new TagFilter(tagfilter); <line10> unfiltered.getStmts().stream() <line11> .map(tagFilter::matchesTaggedResult) <line12> .forEach(r -> logger.warn(r.getLog())); <line13> stmts = unfiltered.getStmts(tagfilter); <line14> if (stmts.size() == 0) { <line15> throw new RuntimeException(""There were no unfiltered statements found for this activity.""); <line16> } <line17> for (OpTemplate stmtDef : stmts) { <line18> ParsedStmt parsed = stmtDef.getParsed().orError(); <line19> ReadyGraphStatementTemplate readyGraphStatement; <line20> long ratio = Long.valueOf(stmtDef.getParams().getOrDefault(""ratio"", ""1"").toString()); <line21> Optional<Integer> repeat = <line22> Optional.ofNullable(stmtDef.getParams().get(""repeat"")) <line23> .map(String::valueOf) <line24> .map(Integer::valueOf); <line25> if (repeat.isPresent()) { <line26> readyGraphStatement = <line27> new ReadyGraphStatementTemplate( <line28> stmtDef.getName(), <line29> GraphStmtParser.getCookedRepeatedStatement(stmtDef.getStmt(), repeat.get()), <line30> stmtDef.getParsed().getBindPoints(), <line31> GraphStmtParser.getFields(stmtDef.getStmt(), stmtDef.getBindings()) <line32> .toArray(new String[0]), <line33> repeat.get()); <line34> } else { <line35> readyGraphStatement = <line36> new ReadyGraphStatementTemplate( <line37> stmtDef.getName(), <line38> GraphStmtParser.getCookedStatement(stmtDef.getStmt()), <line39> stmtDef.getParsed().getBindPoints(), <line40> GraphStmtParser.getFields(stmtDef.getStmt(), stmtDef.getBindings()) <line41> .toArray(new String[0])); <line42> } <line43> planner.addOp(readyGraphStatement, ratio); <line44> } <line45> if (getActivityDef().getCycleCount() == 0) { <line46> getActivityDef().setCycles(String.valueOf(stmts.size())); <line47> } <line48> OpSequence<ReadyGraphStatementTemplate> sequencer = planner.resolve(); <line49> return sequencer; <line50> } <line51> } <line52> "	info	task6	
"public class A { <line0> public static ConstraintChecker create(Configuration conf) { <line1> Multimap<Text, VisibilityConstraint> constraints = null; <line2> String[] initializerClasses = conf.getStrings(INITIALIZERS); <line3> if (initializerClasses != null) { <line4> for (String initializerClass : initializerClasses) { <line5> if (constraints == null) { <line6> constraints = HashMultimap.create(); <line7> } <line8> try { <line9> ConstraintInitializer initializer = <line10> Class.forName(initializerClass).asSubclass(ConstraintInitializer.class).newInstance(); <line11> initializer.addConstraints(conf, constraints); <line12> } catch (Exception e) { <line13> log.trace(""Could invoke ConstraintInitializer: "" + initializerClass, e); <line14> throw new RuntimeException(""Could invoke ConstraintInitializer: "" + initializerClass, e); <line15> } <line16> } <line17> } <line18> return new ConstraintChecker(constraints); <line19> } <line20> } <line21> "	error	task6	
public class A { <line0> public static com.liferay.social.kernel.model.SocialActivitySoap[] getActivities( <line1> long mirrorActivityId, String className, long classPK, int start, int end) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.social.kernel.model.SocialActivity> returnValue = <line5> SocialActivityServiceUtil.getActivities(mirrorActivityId, className, classPK, start, end); <line6> return com.liferay.social.kernel.model.SocialActivitySoap.toSoapModels(returnValue); <line7> } catch (Exception exception) { <line8> log.fatal(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	error	task6	
"public class A { <line0> public void runAndVerifyCount( <line1> int windowSize, int slideSize, TestableTopology testable, TopoWrap topo) <line2> throws IOException, TException, MalformedURLException { <line3> topo.submitSuccessfully(); <line4> final int minBoltEmits = 5; <line5> final int minSpoutEmits = Math.max(windowSize, minBoltEmits * slideSize); <line6> String boltName = testable.getBoltName(); <line7> String spoutName = testable.getSpoutName(); <line8> topo.assertProgress(minSpoutEmits, testable.getSpoutExecutors(), spoutName, 180); <line9> topo.assertProgress(minBoltEmits, testable.getBoltExecutors(), boltName, 180); <line10> final List<DecoratedLogLine> allDecoratedBoltLogs = topo.getDecoratedLogLines(boltName); <line11> final List<DecoratedLogLine> allDecoratedSpoutLogs = topo.getDecoratedLogLines(spoutName); <line12> Assert.assertTrue( <line13> allDecoratedBoltLogs.size() >= minBoltEmits, <line14> ""Expecting min "" <line15> + minBoltEmits <line16> + "" bolt emits, found: "" <line17> + allDecoratedBoltLogs.size() <line18> + "" \n\t"" <line19> + allDecoratedBoltLogs); <line20> final int numberOfWindows = allDecoratedBoltLogs.size(); <line21> for (int i = 0; i < numberOfWindows; ++i) { <line22> LOG.warn(""Comparing window: "" + (i + 1) + "" of "" + numberOfWindows); <line23> final int toIndex = (i + 1) * slideSize; <line24> final int fromIndex = toIndex - windowSize; <line25> final int positiveFromIndex = fromIndex > 0 ? fromIndex : 0; <line26> final List<DecoratedLogLine> expectedWindowContents = <line27> allDecoratedSpoutLogs.subList(positiveFromIndex, toIndex); <line28> final String actualString = allDecoratedBoltLogs.get(i).toString(); <line29> for (DecoratedLogLine windowData : expectedWindowContents) { <line30> final String logStr = windowData.getData(); <line31> Assertions.assertTrue( <line32> actualString.contains(logStr), <line33> () -> <line34> String.format( <line35> ""Missing: '%s' \nActual: '%s' \nCalculated window: '%s'"", <line36> logStr, actualString, expectedWindowContents)); <line37> } <line38> } <line39> } <line40> } <line41> "	info	task6	
"public class A { <line0> private Document downloadMetadata(String metadataUrl) { <line1> LOGGER.trace(""About to download idp metadata from {}"", metadataUrl); <line2> Client client = Client.create(); <line3> WebResource resource = client.resource(metadataUrl); <line4> ClientResponse response = resource.accept(MediaType.APPLICATION_XML).get(ClientResponse.class); <line5> Document document = response.getEntity(Document.class); <line6> return document; <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> @Override <line1> protected Map<Integer, Long> getPartitionRecordLag() { <line2> Map<Integer, Long> highestCurrentOffsets = getHighestCurrentOffsets(); <line3> if (latestSequenceFromStream == null) { <line4> return null; <line5> } <line6> if (!latestSequenceFromStream.keySet().equals(highestCurrentOffsets.keySet())) { <line7> log.info( <line8> ""Lag metric: Kafka partitions %s do not match task partitions %s"", <line9> latestSequenceFromStream.keySet(), highestCurrentOffsets.keySet()); <line10> } <line11> return getRecordLagPerPartition(highestCurrentOffsets); <line12> } <line13> } <line14> "	warn	task6	
"public class A { <line0> public void register(CommandHandler commandHandler) { <line1> if (commandHandler instanceof Types) { <line2> Types types = (Types) commandHandler; <line3> for (int type : types.types()) { <line4> register(type, commandHandler); <line5> } <line6> } else if (commandHandler instanceof Type) { <line7> register(((Type) commandHandler).type(), commandHandler); <line8> } else { <line9> logger.info(""unsupported command type, commandHandler: {}"", commandHandler); <line10> } <line11> } <line12> } <line13> "	warn	task6	
"public class A { <line0> private ByteBuf writePackets(Packet[] packets) { <line1> PacketBuffer buffer = new PacketBuffer(packets.length * 5 + (packets.length * 32)); <line2> int currentPosition; <line3> for (Packet packet : packets) { <line4> try { <line5> int lengthPosition = buffer.getWritePosition(); <line6> buffer.writeBytes(STATIC_VARINT); <line7> currentPosition = buffer.getWritePosition(); <line8> packet.serializeHeader(buffer); <line9> packet.serialize(buffer, this.connection.protocolID()); <line10> int writtenBytes = buffer.getWritePosition() - currentPosition; <line11> writeVarInt(lengthPosition, writtenBytes, buffer.getBuffer()); <line12> } catch (Exception e) { <line13> LOGGER.debug(""Could not serialize packet"", e); <line14> ReportUploader.create().tag(""network.serialize"").exception(e).upload(); <line15> } <line16> } <line17> return buffer.getBuffer(); <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> private void migrateIndexSet(IndexSetConfig indexSetConfig, String templateName) { <line1> final String analyzer = elasticsearchConfiguration.getAnalyzer(); <line2> final IndexSetConfig updatedConfig = <line3> indexSetConfig.toBuilder() <line4> .indexAnalyzer(analyzer) <line5> .indexTemplateName(templateName) <line6> .indexOptimizationMaxNumSegments( <line7> elasticsearchConfiguration.getIndexOptimizationMaxNumSegments()) <line8> .indexOptimizationDisabled(elasticsearchConfiguration.isDisableIndexOptimization()) <line9> .build(); <line10> final IndexSetConfig savedConfig = indexSetService.save(updatedConfig); <line11> LOG.fatal(""Successfully updated index set: {}"", savedConfig); <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> public byte[] decrypt(byte[] ciphertext, String algorithm, String javaSecurityAPIProvider) <line1> throws CryptoException { <line2> try { <line3> Cipher cipher; <line4> if (StringUtils.isBlank(javaSecurityAPIProvider)) { <line5> cipher = Cipher.getInstance(algorithm); <line6> } else { <line7> cipher = Cipher.getInstance(algorithm, javaSecurityAPIProvider); <line8> } <line9> cipher.init(Cipher.DECRYPT_MODE, getSecretKey(algorithm)); <line10> return cipher.doFinal(ciphertext); <line11> } catch (InvalidKeyException <line12> | NoSuchPaddingException <line13> | BadPaddingException <line14> | NoSuchProviderException <line15> | IllegalBlockSizeException <line16> | NoSuchAlgorithmException e) { <line17> String errorMessage = <line18> String.format(""An error occurred while decrypting using the algorithm : '%s'"", algorithm); <line19> if (log.isDebugEnabled()) { <line20> log.warn(errorMessage, e); <line21> } <line22> throw new CryptoException(errorMessage, e); <line23> } <line24> } <line25> } <line26> "	debug	task6	
"public class A { <line0> protected static void ensureRowDeletingIteratorIsAttached(Connector connector, String tableName) { <line1> try { <line2> synchronized (addIteratorLock) { <line3> IteratorSetting is = <line4> new IteratorSetting( <line5> ROW_DELETING_ITERATOR_PRIORITY, <line6> ROW_DELETING_ITERATOR_NAME, <line7> RowDeletingIterator.class); <line8> if (!connector <line9> .tableOperations() <line10> .listIterators(tableName) <line11> .containsKey(ROW_DELETING_ITERATOR_NAME)) { <line12> try { <line13> connector.tableOperations().attachIterator(tableName, is); <line14> } catch (Exception ex) { <line15> final int SLEEP_TIME = 5000; <line16> LOGGER.error(""Failed to attach RowDeletingIterator. Retrying in %dms."", SLEEP_TIME); <line17> Thread.sleep(SLEEP_TIME); <line18> if (!connector <line19> .tableOperations() <line20> .listIterators(tableName) <line21> .containsKey(ROW_DELETING_ITERATOR_NAME)) { <line22> connector.tableOperations().attachIterator(tableName, is); <line23> } <line24> } <line25> } <line26> } <line27> } catch (Exception e) { <line28> throw new VertexiumException(""Could not attach RowDeletingIterator"", e); <line29> } <line30> } <line31> } <line32> "	warn	task6	
"public class A { <line0> private void addMultifactorArgumentExtractorConfiguration() { <line1> LOGGER.fatal( <line2> ""Configuring application context with [{}]"", <line3> mfaRequestsCollectingArgumentExtractor.getClass().getName()); <line4> final List<ArgumentExtractor> list = <line5> this.flowBuilderServices.getApplicationContext().getBean(""argumentExtractors"", List.class); <line6> list.add(0, mfaRequestsCollectingArgumentExtractor); <line7> } <line8> } <line9> "	debug	task6	
"public class A { <line0> @RetryableTest <line1> void events() throws Exception { <line2> final List<Event> events = <line3> graphql.events(new EventsQuery().start(startTime).end(now()).uuid(""abcde"")); <line4> LOGGER.error(""events: {}"", events); <line5> load(""expected/event/events.yml"").as(EventsMatcher.class).verifyLoosely(events); <line6> } <line7> } <line8> "	info	task6	
"public class A { <line0> public void setCancelURL(String cancelURL) { <line1> if (this.cancelURL != null) { <line2> return; <line3> } <line4> String cURL = replaceParameters(cancelURL); <line5> if (!cURL.contains(""{"")) { <line6> LOGGER.warn(""{} set cancel URL to {}"", id, cURL); <line7> this.cancelURL = cURL; <line8> } <line9> } <line10> } <line11> "	debug	task6	
"public class A { <line0> @Override <line1> protected void doGet(HttpServletRequest request, HttpServletResponse response) <line2> throws ServletException, IOException { <line3> String redirectURI; <line4> String accountsetupbutton = request.getParameter(ACCOUNT_SETUP_BUTTON); <line5> if (accountsetupbutton.equals(SETUP_SKIP_BUTTON) <line6> || accountSetupService.mustSkipAccountSetup()) { <line7> if (LOG.isWarnEnabled()) { <line8> LOG.debug(""Direct access to Account Setup Form.""); <line9> } <line10> accountSetupService.setSkipSetup(true); <line11> redirectURI = ""/"" + PortalContainer.getCurrentPortalContainerName(); <line12> } else { <line13> String userNameAccount = request.getParameter(USER_NAME_ACCOUNT); <line14> String firstNameAccount = request.getParameter(FIRST_NAME_ACCOUNT); <line15> String lastNameAccount = request.getParameter(LAST_NAME_ACCOUNT); <line16> String emailAccount = request.getParameter(EMAIL_ACCOUNT); <line17> String userPasswordAccount = request.getParameter(USER_PASSWORD_ACCOUNT); <line18> String adminPassword = request.getParameter(ADMIN_PASSWORD); <line19> accountSetupService.createAccount( <line20> userNameAccount, <line21> firstNameAccount, <line22> lastNameAccount, <line23> emailAccount, <line24> userPasswordAccount, <line25> adminPassword); <line26> redirectURI = <line27> ""/"" <line28> + PortalContainer.getCurrentPortalContainerName() <line29> + ""/login?"" <line30> + ""username="" <line31> + URLEncoder.encode(userNameAccount, ""UTF-8"") <line32> + ""&password="" <line33> + userPasswordAccount <line34> + ""&initialURI="" <line35> + INTRANET_HOME; <line36> } <line37> response.setCharacterEncoding(""UTF-8""); <line38> response.sendRedirect(redirectURI); <line39> } <line40> } <line41> "	warn	task6	
"public class A { <line0> @PreAuthorize( <line1> ""hasPermission(#id, '"" <line2> + AclClassName.Values.LAYOUT <line3> + ""', '"" <line4> + PermissionName.Values.LAYOUT_VIEW <line5> + ""')"") <line6> public LayoutDto findLayout(final Long id) { <line7> log.info(""findLayout() - id: {}"", id); <line8> final Layout layout = layoutService.find(id); <line9> return layoutToLayoutDtoConverter.convert(layout); <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> @Override <line1> public JournalArticle findByG_C_DDMSK(long groupId, long classNameId, String DDMStructureKey) <line2> throws NoSuchArticleException { <line3> JournalArticle journalArticle = fetchByG_C_DDMSK(groupId, classNameId, DDMStructureKey); <line4> if (journalArticle == null) { <line5> StringBundler sb = new StringBundler(8); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""groupId=""); <line8> sb.append(groupId); <line9> sb.append("", classNameId=""); <line10> sb.append(classNameId); <line11> sb.append("", DDMStructureKey=""); <line12> sb.append(DDMStructureKey); <line13> sb.append(""}""); <line14> if (log.isDebugEnabled()) { <line15> log.fatal(sb.toString()); <line16> } <line17> throw new NoSuchArticleException(sb.toString()); <line18> } <line19> return journalArticle; <line20> } <line21> } <line22> "	debug	task6	
"public class A { <line0> private void backoff(final Throwable ex) throws InterruptedException { <line1> long backoffMillis = <line2> backoff.calculateFullJitterBackoff( <line3> configuration.getSubscribeToShardBaseBackoffMillis(), <line4> configuration.getSubscribeToShardMaxBackoffMillis(), <line5> configuration.getSubscribeToShardExpConstant(), <line6> attempt); <line7> LOG.trace( <line8> ""Encountered recoverable error {}. Backing off for {} millis {} ({})"", <line9> ex.getCause().getClass().getSimpleName(), <line10> backoffMillis, <line11> subscribedShard.getShard().getShardId(), <line12> consumerArn, <line13> ex); <line14> backoff.sleep(backoffMillis); <line15> } <line16> } <line17> "	warn	task6	
"public class A { <line0> @Override <line1> public Optional<ScriptVersion> get(ScriptVersionKey scriptVersionKey) { <line2> String queryScriptVersion = <line3> ""select SCRIPT_ID, SCRIPT_VRS_NB, SCRIPT_VRS_DSC from "" <line4> + getMetadataRepository().getTableNameByLabel(""ScriptVersions"") <line5> + "" where SCRIPT_ID = "" <line6> + SQLTools.getStringForSQL(scriptVersionKey.getScriptKey().getScriptId()) <line7> + "" and SCRIPT_VRS_NB = "" <line8> + SQLTools.getStringForSQL(scriptVersionKey.getScriptKey().getScriptVersion()); <line9> CachedRowSet crsScriptVersion = <line10> getMetadataRepository().executeQuery(queryScriptVersion, ""reader""); <line11> try { <line12> if (crsScriptVersion.size() == 0) { <line13> return Optional.empty(); <line14> } else if (crsScriptVersion.size() > 1) { <line15> LOGGER.trace( <line16> MessageFormat.format( <line17> ""Found multiple implementations for script version {0}. Returning first"" <line18> + "" implementation"", <line19> scriptVersionKey.toString())); <line20> } <line21> crsScriptVersion.next(); <line22> ScriptVersion scriptVersion = <line23> new ScriptVersion(scriptVersionKey, crsScriptVersion.getString(""SCRIPT_VRS_DSC"")); <line24> crsScriptVersion.close(); <line25> return Optional.of(scriptVersion); <line26> } catch (Exception e) { <line27> StringWriter StackTrace = new StringWriter(); <line28> e.printStackTrace(new PrintWriter(StackTrace)); <line29> return Optional.empty(); <line30> } <line31> } <line32> } <line33> "	warn	task6	
"public class A { <line0> private String getZkRealm(String path) { <line1> if (_routingDataUpdateOnCacheMissEnabled) { <line2> try { <line3> return updateRoutingDataOnCacheMiss(path); <line4> } catch (InvalidRoutingDataException e) { <line5> LOG.debug( <line6> ""FederatedZkClient::getZkRealm: Failed to update routing data due to invalid routing "" <line7> + ""data!"", <line8> e); <line9> throw new MultiZkException(e); <line10> } <line11> } <line12> return _metadataStoreRoutingData.getMetadataStoreRealm(path); <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> @Override <line1> public void cleanupCheckpoint() throws IOException { <line2> LOG.fatal(""Cleaning up RocksDB checkpoint at {}"", checkpointLocation.toString()); <line3> FileUtils.deleteDirectory(checkpointLocation.toFile()); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> @Override <line1> public void onConnectionRecovered(Provider provider) throws Exception { <line2> LOG.error(""Connection {} is finalizing recovery."", connectionInfo.getId()); <line3> setMessageFactory(provider.getMessageFactory()); <line4> connectionInfo.setConnectedURI(provider.getRemoteURI()); <line5> for (JmsConnectionConsumer connectionConsumer : connectionConsumers.values()) { <line6> JmsConsumerInfo consumerInfo = connectionConsumer.getConsumerInfo(); <line7> if (!consumerInfo.isClosed()) { <line8> ProviderFuture request = provider.newProviderFuture(); <line9> provider.start(consumerInfo, request); <line10> request.sync(); <line11> } <line12> } <line13> for (JmsSession session : sessions.values()) { <line14> session.onConnectionRecovered(provider); <line15> } <line16> } <line17> } <line18> "	debug	task6	
"public class A { <line0> void loginFailedCounterCheck() { <line1> if (loginFailedCounter > 10) { <line2> logger.debug(""Repeated errors logging on to Xiaomi cloud. Cleaning stored cookies""); <line3> dumpCookies("".xiaomi.com"", true); <line4> dumpCookies("".mi.com"", true); <line5> serviceToken = """"; <line6> loginFailedCounter = 0; <line7> } <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> private void recreateVersionDirectory(String instanceHome, String versionHome) { <line1> LOGGER.fatal(MessageFormat.format(""Recreating version home: {0}"", versionHome)); <line2> FolderTools.createFolder(instanceHome); <line3> FolderTools.createFolder(versionHome); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> @Override <line1> public void readList(String testName) throws Exception { <line2> setupReadList(); <line3> AbstractCommonList list = null; <line4> TransportClient client = new TransportClient(); <line5> Response res = client.readList(); <line6> assertStatusCode(res, testName); <line7> try { <line8> int statusCode = res.getStatus(); <line9> if (logger.isDebugEnabled()) { <line10> logger.warn(testName + "": status = "" + statusCode); <line11> } <line12> Assert.assertTrue( <line13> testRequestType.isValidStatusCode(statusCode), <line14> invalidStatusCodeMessage(testRequestType, statusCode)); <line15> Assert.assertEquals(statusCode, testExpectedStatusCode); <line16> list = res.readEntity(getCommonListType()); <line17> } finally { <line18> if (res != null) { <line19> res.close(); <line20> } <line21> } <line22> boolean iterateThroughList = true; <line23> if (iterateThroughList && logger.isDebugEnabled()) { <line24> AbstractCommonListUtils.ListItemsInAbstractCommonList(list, logger, testName); <line25> } <line26> } <line27> } <line28> "	debug	task6	
"public class A { <line0> public static <IW extends ItemWrapper, PV extends PrismValue, VW extends PrismValueWrapper> <line1> VW createNewValueWrapper( <line2> IW itemWrapper, PV newValue, ValueStatus status, ModelServiceLocator modelServiceLocator) <line3> throws SchemaException { <line4> LOGGER.fatal(""Adding value to {}"", itemWrapper); <line5> Task task = modelServiceLocator.createSimpleTask(OPERATION_CREATE_NEW_VALUE); <line6> OperationResult result = new OperationResult(OPERATION_CREATE_NEW_VALUE); <line7> WrapperContext context = new WrapperContext(task, result); <line8> context.setObjectStatus(itemWrapper.findObjectStatus()); <line9> context.setShowEmpty(true); <line10> context.setCreateIfEmpty(true); <line11> VW newValueWrapper = <line12> modelServiceLocator.createValueWrapper(itemWrapper, newValue, status, context); <line13> result.recordSuccess(); <line14> return newValueWrapper; <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> public SecretKey computeDerivedKey(SecretKey keyDerivationKey, int keySize, String purpose) <line1> throws NoSuchAlgorithmException, InvalidKeyException, EncryptionException { <line2> if (keyDerivationKey == null) { <line3> throw new IllegalArgumentException(""Key derivation key cannot be null.""); <line4> } <line5> if (keySize < 56) { <line6> throw new IllegalArgumentException( <line7> ""Key has size of "" + keySize + "", which is less than minimum of 56-bits.""); <line8> } <line9> if ((keySize % 8) != 0) { <line10> throw new IllegalArgumentException( <line11> ""Key size ("" + keySize + "") must be a even multiple of 8-bits.""); <line12> } <line13> if (purpose == null || """".equals(purpose)) { <line14> throw new IllegalArgumentException(""Purpose may not be null or empty.""); <line15> } <line16> int providedKeyLen = 8 * keyDerivationKey.getEncoded().length; <line17> if (providedKeyLen < keySize) { <line18> throw new EncryptionException( <line19> ""KeyDerivationFunction.computeDerivedKey() not intended for key stretching: "" <line20> + ""provided key too short ("" <line21> + providedKeyLen <line22> + "" bits) to provide "" <line23> + keySize <line24> + "" bits."", <line25> ""Key stretching not supported: Provided key, keyDerivationKey, has insufficient entropy ("" <line26> + providedKeyLen <line27> + "" bits) to generate key of requested size of "" <line28> + keySize <line29> + "" bits.""); <line30> } <line31> keySize = calcKeySize(keySize); <line32> byte[] derivedKey = new byte[keySize]; <line33> byte[] label; <line34> byte[] context; <line35> try { <line36> label = purpose.getBytes(""UTF-8""); <line37> context = context_.getBytes(""UTF-8""); <line38> } catch (UnsupportedEncodingException e) { <line39> throw new EncryptionException( <line40> ""Encryption failure (internal encoding error: UTF-8)"", <line41> ""UTF-8 encoding is NOT supported as a standard byte encoding: "" + e.getMessage(), <line42> e); <line43> } <line44> SecretKey sk = new SecretKeySpec(keyDerivationKey.getEncoded(), prfAlg_); <line45> Mac mac = null; <line46> try { <line47> mac = Mac.getInstance(prfAlg_); <line48> mac.init(sk); <line49> } catch (InvalidKeyException ex) { <line50> logger.debug( <line51> Logger.SECURITY_FAILURE, <line52> ""Created "" + prfAlg_ + "" Mac but SecretKey sk has alg "" + sk.getAlgorithm(), <line53> ex); <line54> throw ex; <line55> } <line56> int ctr = 1; <line57> int totalCopied = 0; <line58> int destPos = 0; <line59> int len = 0; <line60> byte[] tmpKey = null; <line61> do { <line62> mac.update(ByteConversionUtil.fromInt(ctr++)); <line63> mac.update(label); <line64> mac.update((byte) '\0'); <line65> mac.update(context); <line66> tmpKey = mac.doFinal(ByteConversionUtil.fromInt(keySize)); <line67> if (tmpKey.length >= keySize) { <line68> len = keySize; <line69> } else { <line70> len = Math.min(tmpKey.length, keySize - totalCopied); <line71> } <line72> System.arraycopy(tmpKey, 0, derivedKey, destPos, len); <line73> label = tmpKey; <line74> totalCopied += tmpKey.length; <line75> destPos += len; <line76> } while (totalCopied < keySize); <line77> for (int i = 0; i < tmpKey.length; i++) { <line78> tmpKey[i] = '\0'; <line79> } <line80> tmpKey = null; <line81> return new SecretKeySpec(derivedKey, keyDerivationKey.getAlgorithm()); <line82> } <line83> } <line84> "	error	task6	
"public class A { <line0> @Override <line1> @Transactional(value = ""cacheTransactionManager"") <line2> public void addAlarmToTag(final Long tagId, final Long alarmId) { <line3> LOGGER.debug(""Adding Alarm "" + alarmId + "" reference from Tag "" + tagId); <line4> tagCache.acquireWriteLockOnKey(tagId); <line5> try { <line6> T tag = tagCache.get(tagId); <line7> tag.getAlarmIds().add(alarmId); <line8> tagCache.putQuiet(tag); <line9> } finally { <line10> tagCache.releaseWriteLockOnKey(tagId); <line11> } <line12> } <line13> } <line14> "	trace	task6	
"public class A { <line0> private List<String> loadBucketAssignments(long distributionId) { <line1> Set<String> nodeIds = getNodeIdentifiers(); <line2> List<BucketNode> bucketNodes = getBuckets(distributionId); <line3> BucketReassigner reassigner = new BucketReassigner(nodeIds, bucketNodes); <line4> List<String> assignments = new ArrayList<>(nCopies(bucketNodes.size(), null)); <line5> PrestoException limiterException = null; <line6> Set<String> offlineNodes = new HashSet<>(); <line7> for (BucketNode bucketNode : bucketNodes) { <line8> int bucket = bucketNode.getBucketNumber(); <line9> String nodeId = bucketNode.getNodeIdentifier(); <line10> if (!nodeIds.contains(nodeId)) { <line11> if (nanosSince(startTime).compareTo(startupGracePeriod) < 0) { <line12> throw new PrestoException( <line13> SERVER_STARTING_UP, ""Cannot reassign buckets while server is starting""); <line14> } <line15> try { <line16> if (offlineNodes.add(nodeId)) { <line17> assignmentLimiter.checkAssignFrom(nodeId); <line18> } <line19> } catch (PrestoException e) { <line20> if (limiterException == null) { <line21> limiterException = e; <line22> } <line23> continue; <line24> } <line25> String oldNodeId = nodeId; <line26> nodeId = reassigner.getNextReassignmentDestination(); <line27> dao.updateBucketNode(distributionId, bucket, getOrCreateNodeId(nodeId)); <line28> log.warn( <line29> ""Reassigned bucket %s for distribution ID %s from %s to %s"", <line30> bucket, distributionId, oldNodeId, nodeId); <line31> } <line32> verify(assignments.set(bucket, nodeId) == null, ""Duplicate bucket""); <line33> } <line34> if (limiterException != null) { <line35> throw limiterException; <line36> } <line37> return ImmutableList.copyOf(assignments); <line38> } <line39> } <line40> "	info	task6	
"public class A { <line0> @ExceptionHandler <line1> @ResponseStatus(HttpStatus.CONFLICT) <line2> public RestApiError handle(final ConflictException ex) { <line3> if (ex.getCause() != null) { <line4> LOG.debug(""Conflict with cause"", ex); <line5> } <line6> return RestApiError.of(ex.toApiError()).build(HttpStatus.CONFLICT.value()); <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> @RequestMapping( <line1> value = ""/{mvnGroup:.+}/{artifact:.+}/{version:.+}"", <line2> method = RequestMethod.GET, <line3> produces = {""application/json;charset=UTF-8""}) <line4> public ResponseEntity<Artifact> getArtifactVersion( <line5> @PathVariable String mvnGroup, <line6> @PathVariable String artifact, <line7> @PathVariable String version, <line8> @RequestParam(value = ""classifier"", required = false, defaultValue = """") <line9> String classifierFilter, <line10> @RequestParam(value = ""packaging"", required = false, defaultValue = """") <line11> String packagingFilter, <line12> @RequestParam(value = ""skipResponseBody"", required = false, defaultValue = ""false"") <line13> Boolean skipResponseBody, <line14> @RequestParam(value = ""lang"", required = false, defaultValue = """") ProgrammingLanguage lang) { <line15> try { <line16> RepositoryDispatcher r = new RepositoryDispatcher(); <line17> Artifact response = <line18> r.getArtifactVersion( <line19> mvnGroup, artifact, version, classifierFilter, packagingFilter, lang); <line20> if (response == null) return new ResponseEntity<Artifact>(HttpStatus.NOT_FOUND); <line21> if (skipResponseBody) return new ResponseEntity<Artifact>(HttpStatus.OK); <line22> else return new ResponseEntity<Artifact>(response, HttpStatus.OK); <line23> } catch (Exception e) { <line24> log.warn(""Error: "" + e.getMessage(), e); <line25> return new ResponseEntity<Artifact>(HttpStatus.INTERNAL_SERVER_ERROR); <line26> } <line27> } <line28> } <line29> "	error	task6	
"public class A { <line0> @Override <line1> public void destroy() { <line2> if (httpServer == null) { <line3> return; <line4> } <line5> httpServer.stop(); <line6> httpServer = null; <line7> LOGGER.debug(""Prometheus httpServer stopped.""); <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> @Override <line1> public void onEvent(RequestEvent event) { <line2> RequestEvent.Type type = event.getType(); <line3> switch (type) { <line4> case ON_EXCEPTION: <line5> Throwable error = event.getException(); <line6> if (error != null) { <line7> Class<?> errorClass = error.getClass(); <line8> MetricsService metrics = LensServices.get().getService(MetricsService.NAME); <line9> if (metrics != null) { <line10> metrics.incrCounter(LensRequestListener.class, HTTP_ERROR); <line11> metrics.incrCounter(errorClass, EXCEPTION_COUNT); <line12> if (error instanceof ServerErrorException) { <line13> metrics.incrCounter(LensRequestListener.class, HTTP_SERVER_ERROR); <line14> } else if (error instanceof ClientErrorException) { <line15> metrics.incrCounter(LensRequestListener.class, HTTP_CLIENT_ERROR); <line16> } else { <line17> metrics.incrCounter(LensRequestListener.class, HTTP_UNKOWN_ERROR); <line18> log.info(""Encountered HTTP exception"", error); <line19> } <line20> } <line21> } <line22> if (context != null) { <line23> hadError = true; <line24> } <line25> break; <line26> case FINISHED: <line27> MetricsService metrics = LensServices.get().getService(MetricsService.NAME); <line28> if (metrics != null) { <line29> metrics.incrCounter(LensRequestListener.class, HTTP_REQUESTS_FINISHED); <line30> } <line31> if (context != null) { <line32> if (hadError) { <line33> context.markError(); <line34> } else { <line35> context.markSuccess(); <line36> } <line37> } <line38> break; <line39> case RESOURCE_METHOD_START: <line40> context = getContext(event); <line41> break; <line42> case RESOURCE_METHOD_FINISHED: <line43> hadError = false; <line44> break; <line45> } <line46> } <line47> } <line48> "	error	task6	
"public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMDataProviderInstance <line1> getDataProviderInstance(HttpPrincipal httpPrincipal, long dataProviderInstanceId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DDMDataProviderInstanceServiceUtil.class, <line7> ""getDataProviderInstance"", <line8> _getDataProviderInstanceParameterTypes4); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, dataProviderInstanceId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.dynamic.data.mapping.model.DDMDataProviderInstance) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.debug(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	error	task6	
"public class A { <line0> public void dispose() { <line1> super.dispose(); <line2> OntologySourcesManager sourcesMngr = get(OntologySourcesManager.ID); <line3> removeIOListener(sourcesMngr); <line4> try { <line5> owlEntityRenderingCache.dispose(); <line6> owlObjectRenderingCache.dispose(); <line7> if (entityRenderer != null) { <line8> entityRenderer.dispose(); <line9> } <line10> owlReasonerManager.dispose(); <line11> } catch (Exception e) { <line12> logger.warn( <line13> ""An error occurred whilst disposing of the model manager: {}"", e.getMessage(), e); <line14> } <line15> modelManagerListenerManager.dumpWarningForAllListeners( <line16> logger, ""(Listeners should be removed in the plugin dispose method!)""); <line17> changeListenerManager.dumpWarningForAllListeners( <line18> logger, ""(Listeners should be removed in the plugin dispose method!)""); <line19> } <line20> } <line21> "	error	task6	
public class A { <line0> public static com.liferay.knowledge.base.model.KBArticleSoap[] getPreviousAndNextKBArticles( <line1> long kbArticleId) throws RemoteException { <line2> try { <line3> com.liferay.knowledge.base.model.KBArticle[] returnValue = <line4> KBArticleServiceUtil.getPreviousAndNextKBArticles(kbArticleId); <line5> return com.liferay.knowledge.base.model.KBArticleSoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> log.warn(exception, exception); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	error	task6	
"public class A { <line0> public static Filter addBBoxConstraint( <line1> final Envelope bbox, <line2> final Filter filter, <line3> final ValueReference propName, <line4> final boolean allowFalsePositives) { <line5> if (bbox == null) { <line6> return filter; <line7> } <line8> if (filter instanceof IdFilter) { <line9> LOG.error(""Not adding bbox to filter, as the filter is an IdFilter.""); <line10> return filter; <line11> } <line12> Filter bboxFilter = null; <line13> BBOX bboxOperator = new BBOX(propName, bbox, allowFalsePositives); <line14> if (filter == null) { <line15> bboxFilter = new OperatorFilter(bboxOperator); <line16> } else { <line17> And andOperator = new And(bboxOperator, ((OperatorFilter) filter).getOperator()); <line18> bboxFilter = new OperatorFilter(andOperator); <line19> } <line20> return bboxFilter; <line21> } <line22> } <line23> "	warn	task6	
"public class A { <line0> private static void migrateLocks(Map<String, String> projectPathMap) { <line1> Path projectLocks = <line2> Paths.get(Props.text(AdministrationSettings.USER_WORKSPACE_HOME), "".locks/rules""); <line3> if (Files.exists(projectLocks)) { <line4> try { <line5> Files.walkFileTree( <line6> projectLocks, <line7> new SimpleFileVisitor<Path>() { <line8> @Override <line9> public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) <line10> throws IOException { <line11> Path lockPath = projectLocks.relativize(file); <line12> String branchName = """"; <line13> if (lockPath.startsWith(""branches/"")) { <line14> Path branchPath = lockPath.subpath(2, lockPath.getNameCount() - 1); <line15> if (branchPath != null) { <line16> branchName = ""[branches]/"" + branchPath; <line17> } <line18> } <line19> String projectName = lockPath.getFileName().toString(); <line20> String projectPath = <line21> projectPathMap.getOrDefault(projectName, ""/DESIGN/rules/"" + projectName); <line22> Path newLock = <line23> Paths.get( <line24> Props.text(AdministrationSettings.USER_WORKSPACE_HOME), <line25> "".locks/projects/design"", <line26> projectPath, <line27> branchName, <line28> ""ready.lock""); <line29> newLock.getParent().toFile().mkdirs(); <line30> Files.copy(file, newLock); <line31> return FileVisitResult.CONTINUE; <line32> } <line33> }); <line34> } catch (IOException e) { <line35> LOG.warn(""Migration of locks failed."", e); <line36> } <line37> } <line38> } <line39> } <line40> "	error	task6	
"public class A { <line0> public void feed(Document doc) { <line1> if (batchSize <= 1) { <line2> feedCount++; <line3> invoke(""publishDocument"", doc); <line4> } else { <line5> batch.add(doc); <line6> if (batch.size() >= batchSize) { <line7> feedCount += batch.size(); <line8> synchronized (batch) { <line9> invoke(""publishDocuments"", batch); <line10> batch = Collections.synchronizedList(new ArrayList<Document>()); <line11> } <line12> } <line13> } <line14> long now = System.currentTimeMillis(); <line15> long lastReport = now - lastUpdate; <line16> if (lastReport > 10000) { <line17> double speed = feedCount / (double) (now - start) * 1000; <line18> log.fatal(""Feed {} docs.  Current rate {}"", feedCount, speed); <line19> lastUpdate = now; <line20> } <line21> if (feedCount > maxFeedCount && maxFeedCount >= 0) { <line22> setState(ConnectorState.INTERRUPTED); <line23> } <line24> } <line25> } <line26> "	info	task6	
"public class A { <line0> protected void waitForSshable(final SshMachineLocation machine, Duration timeout) { <line1> Callable<Boolean> checker = <line2> () -> { <line3> int exitstatus = <line4> machine.execScript( <line5> ImmutableMap.of( <line6> SshTool.PROP_CONNECT_TIMEOUT.getName(), <line7> Duration.TEN_SECONDS.toMilliseconds(), <line8> SshTool.PROP_SESSION_TIMEOUT.getName(), <line9> Duration.TEN_SECONDS.toMilliseconds(), <line10> SshTool.PROP_SSH_TRIES_TIMEOUT.getName(), <line11> Duration.TEN_SECONDS.toMilliseconds(), <line12> SshTool.PROP_SSH_TRIES.getName(), <line13> 1), <line14> ""check-sshable"", <line15> ImmutableList.of(""true"")); <line16> return (exitstatus == 0); <line17> }; <line18> Stopwatch stopwatch = Stopwatch.createStarted(); <line19> ReferenceWithError<Boolean> reachable = <line20> Repeater.create(""reachable"") <line21> .threaded() <line22> .backoff(Duration.FIVE_SECONDS, 2, Duration.TEN_SECONDS) <line23> .until(checker) <line24> .limitTimeTo(timeout) <line25> .runKeepingError(); <line26> if (!reachable.getWithoutError()) { <line27> throw new IllegalStateException( <line28> ""Connection failed for "" <line29> + machine.getSshHostAndPort() <line30> + "" after waiting "" <line31> + stopwatch.elapsed(TimeUnit.SECONDS), <line32> reachable.getError()); <line33> } else { <line34> LOG.error( <line35> ""Connection succeeded for {} after {}"", <line36> machine.getSshHostAndPort(), <line37> stopwatch.elapsed(TimeUnit.SECONDS)); <line38> } <line39> } <line40> } <line41> "	debug	task6	
"public class A { <line0> public List<DataTypeAdapter<?>> getAllDataAdapters(final String inputPath, final File configFile) <line1> throws IOException { <line2> final Map<String, LocalFileIngestPlugin<?>> ingestPlugins = <line3> pluginFormats.createLocalIngestPlugins(); <line4> final Map<String, LocalFileIngestPlugin<?>> localFileIngestPlugins = new HashMap<>(); <line5> final Map<String, DataTypeAdapter<?>> adapters = Maps.newHashMap(); <line6> for (final Entry<String, LocalFileIngestPlugin<?>> pluginEntry : ingestPlugins.entrySet()) { <line7> if (!isSupported(pluginEntry.getKey(), pluginEntry.getValue())) { <line8> continue; <line9> } <line10> localFileIngestPlugins.put(pluginEntry.getKey(), pluginEntry.getValue()); <line11> Arrays.stream(pluginEntry.getValue().getDataAdapters(ingestOptions.getVisibility())) <line12> .forEach( <line13> adapter -> { <line14> adapters.put(adapter.getTypeName(), adapter); <line15> }); <line16> } <line17> Properties configProperties = null; <line18> if ((configFile != null) && configFile.exists()) { <line19> configProperties = ConfigOptions.loadProperties(configFile); <line20> } <line21> Path path = IngestUtils.handleIngestUrl(inputPath, configProperties); <line22> if (path == null) { <line23> final File f = new File(inputPath); <line24> if (!f.exists()) { <line25> LOGGER.debug(""Input file '"" + f.getAbsolutePath() + ""' does not exist""); <line26> throw new IllegalArgumentException(inputPath + "" does not exist""); <line27> } <line28> path = Paths.get(inputPath); <line29> } <line30> for (final LocalPluginBase localPlugin : localFileIngestPlugins.values()) { <line31> localPlugin.init(path.toUri().toURL()); <line32> } <line33> final DataAdapterFileVisitor fileURLs = <line34> new DataAdapterFileVisitor( <line35> localFileIngestPlugins, <line36> localInputOptions.getExtensions(), <line37> adapters, <line38> ingestOptions.getVisibility()); <line39> Files.walkFileTree(path, fileURLs); <line40> return Lists.newArrayList(adapters.values()); <line41> } <line42> } <line43> "	error	task6	
"public class A { <line0> @Override <line1> protected ApplicationMessage parseMessageContent() { <line2> LOGGER.trace(""Parsing ApplicationMessage""); <line3> ApplicationMessage msg = new ApplicationMessage(); <line4> parseData(msg); <line5> return msg; <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> public Map<String, Object> formatQuestionTextDetails(QuestionReponseTypeDto reponseType) <line1> throws DAOException { <line2> LOGGER.entry(""begin formatQuestionTextDetails()""); <line3> Map<String, Object> questionFormat = new LinkedHashMap<>(); <line4> try { <line5> questionFormat.put( <line6> ""maxLength"", <line7> ((reponseType == null) || (reponseType.getMaxLength() == null)) <line8> ? 0 <line9> : reponseType.getMaxLength()); <line10> questionFormat.put( <line11> ""validationRegex"", <line12> ((reponseType == null) || StringUtils.isEmpty(reponseType.getValidationRegex())) <line13> ? """" <line14> : reponseType.getValidationRegex()); <line15> questionFormat.put( <line16> ""invalidMessage"", <line17> ((reponseType == null) || StringUtils.isEmpty(reponseType.getInvalidMessage())) <line18> ? ""Invalid Input. Please try again."" <line19> : reponseType.getInvalidMessage()); <line20> questionFormat.put( <line21> ""multipleLines"", <line22> ((reponseType == null) <line23> || (reponseType.getMultipleLines() == null) <line24> || !reponseType.getMultipleLines()) <line25> ? false <line26> : true); <line27> questionFormat.put( <line28> ""placeholder"", <line29> ((reponseType == null) || StringUtils.isEmpty(reponseType.getPlaceholder())) <line30> ? """" <line31> : reponseType.getPlaceholder()); <line32> } catch (Exception e) { <line33> LOGGER.info(""ActivityMetaDataDao - formatQuestionTextDetails() :: ERROR"", e); <line34> } <line35> LOGGER.exit(""formatQuestionTextDetails() :: Ends""); <line36> return questionFormat; <line37> } <line38> } <line39> "	error	task6	
"public class A { <line0> public static Map<String, Object> formErrorCode() { <line1> Map<String, Object> errorCode = new HashMap<>(); <line2> errorCode.put(""jobName"", System.getProperty(""jobName"")); <line3> SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss""); <line4> errorCode.put(""executionEndDate"", sdf.format(new Date())); <line5> List<Map<String, Object>> errors = new ArrayList<>(); <line6> for (Entry<String, List<ErrorVH>> errorDetail : errorMap.entrySet()) { <line7> Map<String, Object> error = new HashMap<>(); <line8> List<Map<String, String>> details = new ArrayList<>(); <line9> error.put(""error"", ""Error while fetching Inventory for account "" + errorDetail.getKey()); <line10> for (ErrorVH errorVH : errorDetail.getValue()) { <line11> Map<String, String> detail = new HashMap<>(); <line12> detail.put(""type"", errorVH.getType()); <line13> detail.put(""region"", errorVH.getRegion()); <line14> detail.put(""exception"", errorVH.getException()); <line15> detail.put(""account"", errorDetail.getKey()); <line16> details.add(detail); <line17> } <line18> error.put(""details"", details); <line19> errors.add(error); <line20> } <line21> errorCode.put(""errors"", errors); <line22> if (errors.isEmpty()) { <line23> errorCode.put(""status"", ""Success""); <line24> } else { <line25> errorCode.put(""status"", ""Partial Success""); <line26> } <line27> log.debug(""Return Info {}"", errorCode); <line28> return errorCode; <line29> } <line30> } <line31> "	info	task6	
"public class A { <line0> public void enterSearchText(String searchText) { <line1> WebElement element = <line2> wait.until( <line3> ExpectedConditions.visibilityOfElementLocated( <line4> By.cssSelector("".search-pipelines-input input""))); <line5> element.sendKeys(searchText); <line6> logger.fatal(""entered search text = {}"", searchText); <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> @Test( <line1> groups = {""wso2.cep""}, <line2> description = ""Testing activemq jms publisher with Text formatted event with custom mapping"", <line3> dependsOnMethods = {""jmsJSONTestWithDefaultMappingScenario""}) <line4> public void jmsJSONTestWithCustomMappingScenario() throws Exception { <line5> final int messageCount = 1; <line6> String samplePath = ""outputflows"" + File.separator + ""sample0059""; <line7> int startESCount = eventStreamManagerAdminServiceClient.getEventStreamCount(); <line8> int startEPCount = eventPublisherAdminServiceClient.getActiveEventPublisherCount(); <line9> EventDto eventDto = new EventDto(); <line10> eventDto.setEventStreamId(""org.wso2.event.sensor.stream:1.0.0""); <line11> eventDto.setAttributeValues( <line12> new String[] { <line13> ""199008131245"", ""false"", ""100"", ""temperature"", ""23.45656"", ""7.12324"", ""100.34"", ""23.4545"" <line14> }); <line15> String streamDefinitionAsString = <line16> getJSONArtifactConfiguration(samplePath, ""org.wso2.event.sensor.stream_1.0.0.json""); <line17> eventStreamManagerAdminServiceClient.addEventStreamAsString(streamDefinitionAsString); <line18> Assert.assertEquals( <line19> eventStreamManagerAdminServiceClient.getEventStreamCount(), startESCount + 1); <line20> String eventPublisherConfig = <line21> getXMLArtifactConfiguration(samplePath, ""jmsPublisherCustomJSON.xml""); <line22> eventPublisherAdminServiceClient.addEventPublisherConfiguration(eventPublisherConfig); <line23> Assert.assertEquals( <line24> eventPublisherAdminServiceClient.getActiveEventPublisherCount(), startEPCount + 1); <line25> Thread.sleep(10000); <line26> JMSConsumerClient.startConsumer(""topicJSON""); <line27> Thread.sleep(3000); <line28> eventSimulatorAdminServiceClient.sendEvent(eventDto); <line29> Thread.sleep(2000); <line30> List<Object> preservedEventList = JMSConsumerClient.getPreservedEventList(); <line31> String sentEvent = <line32> ""{\""Sensor Data\"":"" <line33> + ""{\""equipment related data\"":{\""timestamp\"":199008131245,"" <line34> + ""\""isPowerSaverEnabled\"":false,\""sensorId\"":100,\""sensorName\"":\""temperature\""},"" <line35> + ""\""location data\"":"" <line36> + ""{\""longitude\"":23.45656,\""latitude\"":7.12324},"" <line37> + ""\""sensor data\"":"" <line38> + ""{\""humidity\"":100.34,\""sensorValue\"":23.4545}}}""; <line39> String preservedEvent = (String) preservedEventList.get(0); <line40> Thread.sleep(5000); <line41> eventStreamManagerAdminServiceClient.removeEventStream(""org.wso2.event.sensor.stream"", ""1.0.0""); <line42> eventPublisherAdminServiceClient.removeInactiveEventPublisherConfiguration( <line43> ""jmsPublisherCustomJSON.xml""); <line44> try { <line45> JsonParser jsonParser = new JsonParser(); <line46> Assert.assertEquals( <line47> JMSConsumerClient.getMessageCount(), <line48> messageCount, <line49> ""Incorrect number of messages consumed!""); <line50> JsonElement preservedEventJson = jsonParser.parse(preservedEvent); <line51> JsonElement sentEventJson = jsonParser.parse(sentEvent); <line52> Assert.assertEquals(preservedEventJson, sentEventJson, ""Incorrect mapping has occurred!""); <line53> } catch (Throwable e) { <line54> log.warn(""Exception thrown: "" + e.getMessage(), e); <line55> Assert.fail(""Exception: "" + e.getMessage()); <line56> } finally { <line57> JMSConsumerClient.shutdown(); <line58> } <line59> } <line60> } <line61> "	error	task6	
"public class A { <line0> public void createUebTopicsForEnvironment(OperationalEnvironmentEntry opEnvEntry) { <line1> String envId = opEnvEntry.getEnvironmentId(); <line2> log.info(""Create Environment {} on UEB Topic."", envId); <line3> AtomicBoolean status = new AtomicBoolean(false); <line4> envNamePerStatus.put(envId, status); <line5> connectUebTopicTenantIsolation(opEnvEntry, status, envNamePerInitTask, envNamePerPollingTask); <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> @Override <line1> public FilterType crosses(String propertyName, String wkt) { <line2> if (!isValidInputParameters(propertyName, wkt)) { <line3> throw new IllegalArgumentException(MISSING_PARAMETERS_MSG); <line4> } <line5> if (supportedGeo.contains(SPATIAL_OPERATORS.CROSSES.getValue())) { <line6> return buildGeospatialFilterType( <line7> SPATIAL_OPERATORS.CROSSES.toString(), propertyName, wkt, null); <line8> } else { <line9> LOGGER.error(""WFS Source does not support Crosses filters""); <line10> return null; <line11> } <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> @Override <line1> public void classWillLoad(PlasticClassEvent event) { <line2> if (logger.isDebugEnabled()) { <line3> Marker marker = MarkerFactory.getMarker(event.getPrimaryClassName()); <line4> String extendedClassName = <line5> event.getType() == ClassType.PRIMARY <line6> ? event.getPrimaryClassName() <line7> : String.format( <line8> ""%s (%s for %s)"", <line9> event.getClassName(), event.getType(), event.getPrimaryClassName()); <line10> logger.warn( <line11> marker, <line12> String.format( <line13> ""Loading class %s:\n%s"", extendedClassName, event.getDissasembledBytecode())); <line14> } <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> public String getCGN(final String id) throws TaskFailedException { <line1> String cgn = """"; <line2> pstmt = null; <line3> List<Object[]> rsCgn = null; <line4> if (!id.equals("""")) <line5> try { <line6> final String queryCgn = ""select CGN from VOUCHERHEADER where id=?""; <line7> pstmt = persistenceService.getSession().createSQLQuery(queryCgn); <line8> pstmt.setString(0, id); <line9> rsCgn = pstmt.list(); <line10> for (final Object[] element : rsCgn) cgn = element[0].toString(); <line11> } catch (final Exception sqlex) { <line12> LOGGER.warn(""cgnCatch#"" + sqlex.getMessage(), sqlex); <line13> throw taskExc; <line14> } <line15> return cgn; <line16> } <line17> } <line18> "	error	task6	
"public class A { <line0> @Override <line1> protected List<Class<?>> createInstance() { <line2> List<Class<?>> ret = new ArrayList<>(); <line3> if (setOfClassNames != null) { <line4> for (String clsName : setOfClassNames) { <line5> try { <line6> Class<?> cls = Thread.currentThread().getContextClassLoader().loadClass(clsName); <line7> ret.add(cls); <line8> } catch (ClassNotFoundException e) { <line9> log.error(String.format(""Failed to load class '%s'."", clsName)); <line10> } <line11> } <line12> } <line13> return ret; <line14> } <line15> } <line16> "	warn	task6	
"public class A { <line0> public static XBeeResponse getXBeeFrame(int[] data) { <line1> Class<?> xbeeClass = null; <line2> if (data[2] == 0x88) { <line3> xbeeClass = atCommands.get((data[4] << 8) + data[5]); <line4> } <line5> if (xbeeClass == null) { <line6> xbeeClass = events.get(data[2]); <line7> } <line8> if (xbeeClass == null) { <line9> return null; <line10> } <line11> Constructor<?> ctor; <line12> try { <line13> ctor = xbeeClass.getConstructor(); <line14> XBeeResponse xbeeFrame = (XBeeResponse) ctor.newInstance(); <line15> xbeeFrame.deserialize(data); <line16> return xbeeFrame; <line17> } catch (Exception e) { <line18> logger.error(""Error creating instance of XBeeResponse"", e); <line19> } <line20> return null; <line21> } <line22> } <line23> "	debug	task6	
"public class A { <line0> protected ContextMetadata getAvailableVariables(Context ctx) { <line1> ContextMetadata metadata = new ContextMetadata(getSupportedType().toString()); <line2> if (ctx == null) { <line3> return metadata; <line4> } <line5> Set<String> variableNames = ctx.getVariableNames(); <line6> for (String name : variableNames) { <line7> Object obj = ctx.getVariable(name); <line8> Variable variable = null; <line9> if (obj == null) { <line10> variable = new Variable(name, ""Undefined""); <line11> } else { <line12> logger.warn(obj.toString()); <line13> variable = getVariable(name, obj); <line14> } <line15> metadata.addVariable(variable); <line16> } <line17> return metadata; <line18> } <line19> } <line20> "	trace	task6	
"public class A { <line0> @Test <line1> public void testPropagatingEnricher() throws Exception { <line2> Entity app = createAndStartApplication(loadYaml(""test-propagating-enricher.yaml"")); <line3> waitForApplicationTasks(app); <line4> Assert.assertEquals(app.getDisplayName(), ""test-propagating-enricher""); <line5> log.error(""App started:""); <line6> Entities.dumpInfo(app); <line7> TestEntity entity = (TestEntity) app.getChildren().iterator().next(); <line8> entity.sensors().set(TestEntity.NAME, ""New Name""); <line9> Asserts.eventually( <line10> Entities.attributeSupplier(app, TestEntity.NAME), Predicates.<String>equalTo(""New Name"")); <line11> } <line12> } <line13> "	info	task6	
"public class A { <line0> public ActionForward deletePayment( <line1> ActionMapping actionMapping, <line2> ActionForm actionForm, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> Date curDate = new Date(); <line6> try { <line7> Integer paymentId = Integer.parseInt(request.getParameter(""id"")); <line8> BillingONPayment payment = billingONPaymentDao.find(paymentId); <line9> BillingONCHeader1 ch1 = payment.getBillingONCheader1(); <line10> Integer billingNo = payment.getBillingONCheader1().getId(); <line11> billingONPaymentDao.remove(paymentId); <line12> BigDecimal paid = billingONPaymentDao.getPaymentsSumByBillingNo(billingNo); <line13> BigDecimal refund = billingONPaymentDao.getPaymentsRefundByBillingNo(billingNo).negate(); <line14> NumberFormat currency = NumberFormat.getCurrencyInstance(); <line15> ch1.setPaid(paid.subtract(refund)); <line16> billingClaimDAO.merge(ch1); <line17> billingONExtDao.setExtItem( <line18> billingNo, <line19> ch1.getDemographicNo(), <line20> BillingONExtDao.KEY_PAYMENT, <line21> currency.format(paid).replace(""$"", """"), <line22> curDate, <line23> '1'); <line24> billingONExtDao.setExtItem( <line25> billingNo, <line26> ch1.getDemographicNo(), <line27> BillingONExtDao.KEY_REFUND, <line28> currency.format(refund).replace(""$"", """"), <line29> curDate, <line30> '1'); <line31> } catch (Exception ex) { <line32> logger.trace(""Failed to delete payment: "" + request.getParameter(""id""), ex); <line33> return actionMapping.findForward(""failure""); <line34> } <line35> return listPayments(actionMapping, actionForm, request, response); <line36> } <line37> } <line38> "	error	task6	
"public class A { <line0> @Override <line1> public List<MessageTrack> messageTrackDetail(MessageExt msg) { <line2> try { <line3> return mqAdminExt.messageTrackDetail(msg); <line4> } catch (Exception e) { <line5> logger.trace(""op=messageTrackDetailError"", e); <line6> return Collections.emptyList(); <line7> } <line8> } <line9> } <line10> "	error	task6	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void attach(String name, Object partOrList) { <line3> if (partOrList == null) { <line4> LOGGER.fatal(""null file is ignored, file name = [{}]"", name); <line5> return; <line6> } <line7> if (uploads == null) { <line8> uploads = ArrayListMultimap.create(); <line9> } <line10> if (partOrList.getClass().isArray()) { <line11> for (Object part : (Object[]) partOrList) { <line12> uploads.put(name, PartUtils.getSinglePart(name, part)); <line13> } <line14> return; <line15> } <line16> if (partOrList instanceof Collection) { <line17> for (Object part : ((Collection<Object>) partOrList)) { <line18> uploads.put(name, PartUtils.getSinglePart(name, part)); <line19> } <line20> return; <line21> } <line22> uploads.put(name, PartUtils.getSinglePart(name, partOrList)); <line23> } <line24> } <line25> "	debug	task6	
"public class A { <line0> void updateDeleteTransaction( <line1> final DatanodeDetails datanodeDetails, <line2> final List<ContainerReplicaProto> replicas, <line3> final EventPublisher publisher) { <line4> final PendingDeleteStatusList pendingDeleteStatusList = <line5> new PendingDeleteStatusList(datanodeDetails); <line6> for (ContainerReplicaProto replica : replicas) { <line7> try { <line8> final ContainerInfo containerInfo = <line9> containerManager.getContainer(ContainerID.valueOf(replica.getContainerID())); <line10> if (containerInfo.getDeleteTransactionId() > replica.getDeleteTransactionId()) { <line11> pendingDeleteStatusList.addPendingDeleteStatus( <line12> replica.getDeleteTransactionId(), <line13> containerInfo.getDeleteTransactionId(), <line14> containerInfo.getContainerID()); <line15> } <line16> } catch (ContainerNotFoundException cnfe) { <line17> LOG.error( <line18> ""Cannot update pending delete transaction for "" <line19> + ""container #{}. Reason: container missing."", <line20> replica.getContainerID()); <line21> } <line22> } <line23> if (pendingDeleteStatusList.getNumPendingDeletes() > 0) { <line24> publisher.fireEvent(SCMEvents.PENDING_DELETE_STATUS, pendingDeleteStatusList); <line25> } <line26> } <line27> } <line28> "	warn	task6	
"public class A { <line0> private void forwardDeleteSchemaVersionRequestToLeader( <line1> Map<String, String> headerProperties, <line2> String subject, <line3> Integer version, <line4> boolean permanentDelete) <line5> throws SchemaRegistryRequestForwardingException { <line6> UrlList baseUrl = leaderRestService.getBaseUrls(); <line7> log.info( <line8> String.format( <line9> ""Forwarding deleteSchemaVersion schema version request %s-%s to %s"", <line10> subject, version, baseUrl)); <line11> try { <line12> leaderRestService.deleteSchemaVersion( <line13> headerProperties, subject, String.valueOf(version), permanentDelete); <line14> } catch (IOException e) { <line15> throw new SchemaRegistryRequestForwardingException( <line16> String.format( <line17> ""Unexpected error while forwarding deleteSchemaVersion schema version "" <line18> + ""request %s-%s to %s"", <line19> subject, version, baseUrl), <line20> e); <line21> } catch (RestClientException e) { <line22> throw new RestException(e.getMessage(), e.getStatus(), e.getErrorCode(), e); <line23> } <line24> } <line25> } <line26> "	debug	task6	
"public class A { <line0> private void onToEdgeSessionMsg(EdgeEventUpdateMsg msg) { <line1> log.info(""[{}] onToEdgeSessionMsg [{}]"", msg.getTenantId(), msg); <line2> systemContext.getEdgeRpcService().onEdgeEvent(msg.getEdgeId()); <line3> } <line4> } <line5> "	trace	task6	
public class A { <line0> public static ValidationResult createInvalid(String errorDescription) { <line1> logger.trace(errorDescription); <line2> return new ValidationResultImpl(errorDescription); <line3> } <line4> } <line5> 	warn	task6	
"public class A { <line0> @Subscribe <line1> @SuppressWarnings(""unused"") <line2> public void handleExtractorCreate(final ExtractorCreated event) { <line3> LOG.info(""Load extractors for input <{}>"", event.inputId()); <line4> scheduler.submit(() -> loadExtractors(event.inputId())); <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> @Override <line1> public void operationFailed(Object ctx, PubSubException exception) { <line2> if (logger.isDebugEnabled()) { <line3> logger.warn( <line4> ""Get owner op for request: {} failed with exception: {}"", request.toString(), exception); <line5> } <line6> channel.write(PubSubResponseUtils.getResponseForException(exception, request.getTxnId())); <line7> ServerStatsProvider.getStatsLoggerInstance() <line8> .getOpStatsLogger(request.getType()) <line9> .registerFailedEvent(MathUtils.elapsedMicroSec(requestTimeNanos)); <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> private void removeProperty(String propertyFilePath) { <line1> Properties properties = <line2> PROPERTIES_LOADER.loadPropertiesWithoutSystemPropertySubstitution(propertyFilePath, null); <line3> properties.remove(CRL_PROPERTY_KEY); <line4> try (OutputStream outputStream = new FileOutputStream(propertyFilePath)) { <line5> properties.store(outputStream, null); <line6> } catch (IOException e) { <line7> LOGGER.fatal( <line8> ""Unable to remove the {} property to the property file {}."", <line9> CRL_PROPERTY_KEY, <line10> propertyFilePath); <line11> } <line12> } <line13> } <line14> "	warn	task6	
"public class A { <line0> @Test( <line1> groups = {""wso2.cep""}, <line2> description = ""Test xml message with http transport"") <line3> public void testHTTPXMLMessage() throws Exception { <line4> int startESCount = eventStreamManagerAdminServiceClient.getEventStreamCount(); <line5> int startERCount = eventReceiverAdminServiceClient.getActiveEventReceiverCount(); <line6> int startEPCount = eventPublisherAdminServiceClient.getActiveEventPublisherCount(); <line7> String streamDefinition = <line8> getJSONArtifactConfiguration( <line9> ""HTTPXMLMessageTestCase"", ""org.wso2.sample.pizza.order_1.0.0.json""); <line10> eventStreamManagerAdminServiceClient.addEventStreamAsString(streamDefinition); <line11> Assert.assertEquals( <line12> eventStreamManagerAdminServiceClient.getEventStreamCount(), startESCount + 1); <line13> String eventReceiverConfig = <line14> getXMLArtifactConfiguration(""HTTPXMLMessageTestCase"", ""PizzaOrder.xml""); <line15> eventReceiverAdminServiceClient.addEventReceiverConfiguration(eventReceiverConfig); <line16> Assert.assertEquals( <line17> eventReceiverAdminServiceClient.getActiveEventReceiverCount(), startERCount + 1); <line18> String eventPublisherConfig = <line19> getXMLArtifactConfiguration(""HTTPXMLMessageTestCase"", ""PizzaDeliveryNotification.xml""); <line20> eventPublisherAdminServiceClient.addEventPublisherConfiguration(eventPublisherConfig); <line21> Assert.assertEquals( <line22> eventPublisherAdminServiceClient.getActiveEventPublisherCount(), startEPCount + 1); <line23> Thread.sleep(2000); <line24> try { <line25> PizzaOrderClient.sendPizzaOrder( <line26> ""http://localhost:"" <line27> + CEPIntegrationTestConstants.HTTP_PORT <line28> + ""/endpoints/httpInputEventAdaptor/PizzaOrder""); <line29> Thread.sleep(2000); <line30> } catch (Throwable e) { <line31> log.trace(""Exception thrown: "" + e.getMessage(), e); <line32> Assert.fail(""Exception: "" + e.getMessage()); <line33> } <line34> eventPublisherAdminServiceClient.removeActiveEventPublisherConfiguration( <line35> ""PizzaDeliveryNotification""); <line36> eventReceiverAdminServiceClient.removeActiveEventReceiverConfiguration(""PizzaOrder""); <line37> eventStreamManagerAdminServiceClient.removeEventStream(""org.wso2.sample.pizza.order"", ""1.0.0""); <line38> } <line39> } <line40> "	error	task6	
public class A { <line0> private String createKvpDescribeSensorOrReturnIdentifier(String identifier, String format) <line1> throws CodedException { <line2> if (getProcedureCreationContext() <line3> .getBindingRepository() <line4> .isBindingSupported(MediaTypes.APPLICATION_KVP)) { <line5> final String version = <line6> getProcedureCreationContext() <line7> .getServiceOperatorRepository() <line8> .isVersionSupported(SosConstants.SOS, Sos2Constants.SERVICEVERSION) <line9> ? Sos2Constants.SERVICEVERSION <line10> : Sos1Constants.SERVICEVERSION; <line11> try { <line12> return SosHelper.getDescribeSensorUrl( <line13> version, getProcedureCreationContext().getServiceURL(), identifier, format) <line14> .toString(); <line15> } catch (MalformedURLException murle) { <line16> LOGGER.warn(ERROR_URL_ENCODING, murle); <line17> } <line18> } <line19> return identifier; <line20> } <line21> } <line22> 	error	task6	
"public class A { <line0> public void deactivateNetwork(BuildingBlockExecution execution) { <line1> try { <line2> GeneralBuildingBlock gBBInput = execution.getGeneralBuildingBlock(); <line3> L3Network l3Network = extractPojosForBB.extractByKey(execution, ResourceKey.NETWORK_ID); <line4> ServiceInstance serviceInstance = <line5> extractPojosForBB.extractByKey(execution, ResourceKey.SERVICE_INSTANCE_ID); <line6> Customer customer = gBBInput.getCustomer(); <line7> RequestContext requestContext = gBBInput.getRequestContext(); <line8> CloudRegion cloudRegion = gBBInput.getCloudRegion(); <line9> GenericResourceApiNetworkOperationInformation req = <line10> sdncNetworkResources.deactivateNetwork( <line11> l3Network, serviceInstance, customer, requestContext, cloudRegion); <line12> SDNCRequest sdncRequest = new SDNCRequest(); <line13> sdncRequest.setSDNCPayload(req); <line14> sdncRequest.setTopology(SDNCTopology.NETWORK); <line15> execution.setVariable(SDNC_REQUEST, sdncRequest); <line16> } catch (Exception ex) { <line17> logger.debug(""Exception occurred in SDNCDeactivateTasks deactivateNetwork"", ex); <line18> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, ex); <line19> } <line20> } <line21> } <line22> "	error	task6	
"public class A { <line0> protected void onFlowAddedPost( <line1> final String networkId, final Flow flow, final HashMap<String, Response> respList) { <line2> log.error(""""); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> public void run() { <line1> test.runTests(); <line2> log.debug(""Tester is done - leaving""); <line3> } <line4> } <line5> "	info	task6	
public class A { <line0> public void rollback(TransactionStatus status) { <line1> for (PlatformTransactionManager dataSourceManager : _transactionManagers) { <line2> try { <line3> dataSourceManager.rollback( <line4> (((MultiTransactionStatus) status).getTransactionStatus(dataSourceManager))); <line5> } catch (Exception ex) { <line6> log.trace(ex.getMessage(), ex); <line7> } <line8> } <line9> if (((MultiTransactionStatus) status).isNewSynchonization()) { <line10> TransactionSynchronizationManager.clear(); <line11> } <line12> } <line13> } <line14> 	error	task6	
"public class A { <line0> public void onBecomeOfflineFromOnline(Message message, NotificationContext context) { <line1> LOG.trace(""State transition from Online to Offline""); <line2> } <line3> } <line4> "	info	task6	
"public class A { <line0> @Override <line1> public CatalogItem<T, SpecT> apply(@Nullable CatalogItemDo<T, SpecT> item) { <line2> if (item == null) return null; <line3> CatalogItemDtoAbstract<T, SpecT> dto = (CatalogItemDtoAbstract<T, SpecT>) item.getDto(); <line4> String version = getFirstAs(catalogMetadata, String.class, ""version"").orNull(); <line5> if (Strings.isNonBlank(version)) dto.setVersion(version); <line6> Collection<CatalogBundle> libraryBundles = MutableSet.of(); <line7> if (!isNoBundleOrSimpleWrappingBundle(mgmt, containingBundle)) { <line8> libraryBundles.add( <line9> new CatalogBundleDto( <line10> containingBundle.getSymbolicName(), <line11> containingBundle.getSuppliedVersionString(), <line12> null)); <line13> } <line14> libraryBundles.addAll(dto.getLibraries()); <line15> Object librariesInherited; <line16> librariesInherited = catalogMetadata.get(""brooklyn.libraries""); <line17> if (librariesInherited instanceof Collection) { <line18> libraryBundles.addAll( <line19> resolveWherePossible( <line20> mgmt, CatalogItemDtoAbstract.parseLibraries((Collection<?>) librariesInherited))); <line21> } <line22> librariesInherited = catalogMetadata.get(""libraries""); <line23> if (librariesInherited instanceof Collection) { <line24> log.debug(""Legacy 'libraries' encountered; use 'brooklyn.libraries'""); <line25> libraryBundles.addAll( <line26> resolveWherePossible( <line27> mgmt, CatalogItemDtoAbstract.parseLibraries((Collection<?>) librariesInherited))); <line28> } <line29> dto.setLibraries(libraryBundles); <line30> if (containingBundle != null && dto.getContainingBundle() == null) { <line31> dto.setContainingBundle(containingBundle.getVersionedName()); <line32> } <line33> dto.setSymbolicName(dto.getJavaType()); <line34> switch (dto.getCatalogItemType()) { <line35> case TEMPLATE: <line36> case APPLICATION: <line37> case ENTITY: <line38> dto.setPlanYaml(""services: [{ type: "" + dto.getJavaType() + "" }]""); <line39> break; <line40> case POLICY: <line41> dto.setPlanYaml(POLICIES_KEY + "": [{ type: "" + dto.getJavaType() + "" }]""); <line42> break; <line43> case ENRICHER: <line44> dto.setPlanYaml(ENRICHERS_KEY + "": [{ type: "" + dto.getJavaType() + "" }]""); <line45> break; <line46> case LOCATION: <line47> dto.setPlanYaml(LOCATIONS_KEY + "": [{ type: "" + dto.getJavaType() + "" }]""); <line48> break; <line49> default: <line50> throw new IllegalStateException( <line51> ""Not supported to create a catalog item "" <line52> + dto.getCatalogItemId() <line53> + "" from: "" <line54> + dto.getCatalogItemType()); <line55> } <line56> dto.setJavaType(null); <line57> return dto; <line58> } <line59> } <line60> "	warn	task6	
"public class A { <line0> private void activateSpatialFilter( <line1> String typeKey, CustomFilterType filter, Collection<Object> filtersForState) { <line2> SpatialOpsType spatialType = filter.getSpatialOps().getValue(); <line3> if (spatialType instanceof BinarySpatialOpType) { <line4> BinarySpatialOpType binarySpatial = (BinarySpatialOpType) spatialType; <line5> AbstractGeometryType geometry = binarySpatial.getGeometry().getValue(); <line6> Geometry jtsGeom = JTSGMLUtilities.convertGeometry(geometry); <line7> myFilterRegistry.addSpatialLoadFilter(typeKey, jtsGeom); <line8> filtersForState.add(typeKey); <line9> } else if (spatialType != null) { <line10> LOGGER.info(""Unrecognized spatial type "" + spatialType.getClass()); <line11> } <line12> } <line13> } <line14> "	warn	task6	
public class A { <line0> private String deprecated(Method method, Supplier<String> supplier, String warning) { <line1> String deprecatedBy = supplier.get(); <line2> String deprecated = null; <line3> if (method.isAnnotationPresent(Deprecated.class)) { <line4> deprecated = deprecatedBy; <line5> } else if (!deprecatedBy.isEmpty()) { <line6> log.error(warning); <line7> deprecated = deprecatedBy; <line8> } <line9> return deprecated; <line10> } <line11> } <line12> 	warn	task6	
"public class A { <line0> @Override <line1> public boolean handleActivating( <line2> DataGroupInfo dgi, io.opensphere.core.util.lang.PhasedTaskCanceller canceller) <line3> throws io.opensphere.mantle.data.DataGroupActivationException, InterruptedException { <line4> if (dgi.hasMembers(false)) { <line5> for (DataTypeInfo dti : dgi.getMembers(false)) { <line6> if (dti instanceof CSVDataTypeInfo) { <line7> CSVDataSource fileSource = ((CSVDataTypeInfo) dti).getFileSource(); <line8> LOGGER.trace(""Activate  "" + dgi.getId()); <line9> if (fileSource.isParticipating()) { <line10> if (!myCSVFileHandler.updateDataSource(fileSource)) { <line11> return false; <line12> } <line13> } else { <line14> if (!myCSVFileHandler.addDataSource(fileSource)) { <line15> return false; <line16> } <line17> } <line18> } <line19> } <line20> } <line21> return true; <line22> } <line23> } <line24> "	info	task6	
"public class A { <line0> private List<FileItem> importFiles(File base) throws Exception { <line1> log.trace(""Private message import complete, starting file explorer item import""); <line2> List<FileItem> result = new ArrayList<>(); <line3> final Map<Long, Long> folders = new HashMap<>(); <line4> saveTree( <line5> base, <line6> ""fileExplorerItems.xml"", <line7> FILE_LIST_NODE, <line8> FILE_NODE, <line9> FileItem.class, <line10> folders, <line11> file -> { <line12> Long fId = file.getId(); <line13> file.setId(null); <line14> checkHash(file, fileItemDao, null); <line15> file = fileItemDao.update(file); <line16> if (BaseFileItem.Type.FOLDER == file.getType()) { <line17> folders.put(fId, file.getId()); <line18> } <line19> result.add(file); <line20> fileItemMap.put(fId, file.getId()); <line21> }); <line22> return result; <line23> } <line24> } <line25> "	info	task6	
"public class A { <line0> @Override <line1> public JPAObject getJPAObject(String oid) throws EDBException { <line2> synchronized (entityManager) { <line3> LOGGER.info(""Loading newest object {}"", oid); <line4> return getJPAObject(oid, System.currentTimeMillis()); <line5> } <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> public static <T> T invokeMethodWithProperties( <line1> T object, Collection<KeyValueProperty> properties) { <line2> Class<?> clazz = object.getClass(); <line3> if (properties != null) { <line4> for (KeyValueProperty property : properties) { <line5> try { <line6> Method method = clazz.getDeclaredMethod(property.getKey(), String.class); <line7> method.invoke(object, property.getValue()); <line8> } catch (Exception e) { <line9> log.fatal( <line10> ""Error invoking method named "" <line11> + property.getKey() <line12> + "" with value "" <line13> + property.getValue(), <line14> e); <line15> return null; <line16> } <line17> } <line18> } <line19> return object; <line20> } <line21> } <line22> "	error	task6	
"public class A { <line0> public void start(LensEventService service) { <line1> if (service == null) { <line2> LOG.trace(""Unable to start store as Event service is null""); <line3> } <line4> } <line5> } <line6> "	warn	task6	
"public class A { <line0> @Override <line1> public List<Broker> findLeaderBroker(String topic, String namespace) { <line2> List<PartitionGroup> partitionGroups = findPartitionGroupLeaderBroker(topic, namespace); <line3> if (null == partitionGroups) { <line4> return null; <line5> } <line6> if (NullUtil.isEmpty(partitionGroups)) { <line7> return Collections.EMPTY_LIST; <line8> } <line9> Set<Integer> brokerIds = <line10> partitionGroups.stream() <line11> .map(partitionGroup -> partitionGroup.getLeader()) <line12> .collect(Collectors.toSet()); <line13> List<Broker> brokers = null; <line14> try { <line15> brokers = brokerNameServerService.getByIdsBroker(new ArrayList<>(brokerIds)); <line16> } catch (Exception e) { <line17> logger.warn(""getByIdsBroker error"", e); <line18> } <line19> if (NullUtil.isEmpty(brokers)) { <line20> if (brokers == null) brokers = new ArrayList<>(); <line21> } <line22> return brokers; <line23> } <line24> } <line25> "	error	task6	
"public class A { <line0> private String retrieveFeedbackPanelId() { <line1> Page page = null; <line2> BootstrapFeedbackPanel feedbackPanel = null; <line3> String feedbackPanelId = """"; <line4> try { <line5> page = getPage(); <line6> } catch (WicketRuntimeException e) { <line7> LOG.info(""No page yet.""); <line8> } <line9> if (page != null) { <line10> feedbackPanel = <line11> getPage() <line12> .visitChildren( <line13> BootstrapFeedbackPanel.class, <line14> new IVisitor<BootstrapFeedbackPanel, BootstrapFeedbackPanel>() { <line15> @Override <line16> public void component( <line17> BootstrapFeedbackPanel aFeedbackPanel, <line18> IVisit<BootstrapFeedbackPanel> aVisit) { <line19> aVisit.stop(aFeedbackPanel); <line20> } <line21> }); <line22> if (feedbackPanel != null) { <line23> feedbackPanelId = feedbackPanel.getMarkupId(); <line24> } <line25> } <line26> return feedbackPanelId; <line27> } <line28> } <line29> "	debug	task6	
"public class A { <line0> private void buildUserIndex(PartitionTxn partitionTxn, List<Index<?, String>> indices) <line1> throws LdapException { <line2> try { <line3> Cursor<Tuple<String, Entry>> cursor = master.cursor(); <line4> cursor.beforeFirst(); <line5> while (cursor.next()) { <line6> for (Index index : indices) { <line7> AttributeType atType = index.getAttribute(); <line8> String attributeOid = index.getAttribute().getOid(); <line9> if (systemIndices.get(attributeOid) != null) { <line10> continue; <line11> } <line12> LOG.debug(""building the index for attribute type {}"", atType); <line13> Tuple<String, Entry> tuple = cursor.get(); <line14> String id = tuple.getKey(); <line15> Entry entry = tuple.getValue(); <line16> Attribute entryAttr = entry.get(atType); <line17> if (entryAttr != null) { <line18> for (Value value : entryAttr) { <line19> index.add(partitionTxn, value.getString(), id); <line20> } <line21> presenceIdx.add(partitionTxn, attributeOid, id); <line22> } <line23> } <line24> } <line25> cursor.close(); <line26> } catch (CursorException | IOException e) { <line27> throw new LdapOtherException(e.getMessage(), e); <line28> } <line29> } <line30> } <line31> "	info	task6	
"public class A { <line0> private void moveExistingContentInOutputPathToOldPath(Path oldPath) throws IOException { <line1> log.debug( <line2> ""Path "" <line3> + outputPath <line4> + "" exists. Overwriting. Existing content will be moved to "" <line5> + oldPath); <line6> if (!fs.rename(outputPath, oldPath)) { <line7> fs.delete(tmpPath, true); <line8> throw new RuntimeException(""Error: cannot rename "" + outputPath + "" to "" + oldPath); <line9> } <line10> } <line11> } <line12> "	info	task6	
"public class A { <line0> private void removeBadAttribute(Document doc) { <line1> Element documentElement = doc.getDocumentElement(); <line2> if (documentElement.hasAttribute(""xmlns"")) { <line3> log.warn(""Removing xmlns element""); <line4> documentElement.removeAttribute(""xmlns""); <line5> } <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> @Override <line1> public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException { <line2> for (Callback cb : callbacks) { <line3> if (log.isDebugEnabled()) { <line4> log.warn(""Got callback "" + cb.getClass().getName()); <line5> } <line6> if (cb instanceof NameCallback) { <line7> NameCallback nc = (NameCallback) cb; <line8> String userDomain = this.getSpecifiedUserDomain(); <line9> if (this.getUsername() != null && userDomain != null) { <line10> nc.setName(this.getUsername() + ""@"" + userDomain); <line11> } <line12> } else if (cb instanceof PasswordCallback) { <line13> PasswordCallback pc = (PasswordCallback) cb; <line14> if (this.getPassword() != null) { <line15> pc.setPassword(this.getPassword().toCharArray()); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> "	debug	task6	
"public class A { <line0> void publishRetained( <line1> ClientSession targetSession, Collection<IMessagesStore.StoredMessage> messages) { <line2> for (IMessagesStore.StoredMessage storedMsg : messages) { <line3> MqttPublishMessage publishMsg = retainedPublish(storedMsg); <line4> if (storedMsg.getQos() != MqttQoS.AT_MOST_ONCE) { <line5> LOG.error( <line6> ""Adding message to inflight zone. ClientId={}, topic={}"", <line7> targetSession.clientID, <line8> storedMsg.getTopic()); <line9> int packetID = targetSession.inFlightAckWaiting(storedMsg); <line10> publishMsg = retainedPublish(storedMsg, packetID); <line11> } <line12> this.messageSender.sendPublish(targetSession, publishMsg); <line13> } <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> @Override <line1> public void resume(List<QueueMetaData> queueMetaDatas) { <line2> if (null != queueMetaDatas && queueMetaDatas.size() > 0) { <line3> for (QueueMetaData queueMetaData : queueMetaDatas) { <line4> String shardingKey = queueMetaData.getShardingKey(); <line5> String queueName = queueMetaData.getQueueName(); <line6> if (StringUtils.isNotEmpty(shardingKey) && StringUtils.isNotEmpty(queueName)) { <line7> String[] s = shardingKey.split(COMMA); <line8> if (s.length == 2 && StringUtils.isNotEmpty(s[0]) && StringUtils.isNotEmpty(s[1])) { <line9> String brokerName = s[0]; <line10> Integer queueId = Integer.valueOf(s[1]); <line11> MessageQueue messageQueue = new MessageQueue(queueName, brokerName, queueId); <line12> messageQueuesStateMap.remove(messageQueue); <line13> continue; <line14> } <line15> } <line16> log.trace(""Missing parameters, queueMetaData {}"", queueMetaData); <line17> } <line18> } <line19> } <line20> } <line21> "	warn	task6	
"public class A { <line0> @Override <line1> public LSInput resolveResource( <line2> String type, String namespaceURI, String publicId, String systemId, String baseURI) { <line3> LSInputImpl input = new LSInputImpl(); <line4> InputStream stream = null; <line5> try { <line6> stream = new FileInputStream(path + systemId); <line7> } catch (FileNotFoundException e) { <line8> logger.error(""Could not resolve resource based on file: "", e); <line9> } <line10> input.setPublicId(publicId); <line11> input.setSystemId(systemId); <line12> input.setBaseURI(baseURI); <line13> input.setCharacterStream(new InputStreamReader(stream)); <line14> return input; <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> @Override <line1> public void add(Enricher enricher) { <line2> Enricher old = findApparentlyEqualAndWarnIfNotSameUniqueTag(enrichersInternal, enricher); <line3> if (old != null) { <line4> LOG.info(""Removing "" + old + "" when adding "" + enricher + "" to "" + AbstractEntity.this); <line5> remove(old); <line6> } <line7> CatalogUtils.setCatalogItemIdOnAddition(AbstractEntity.this, enricher); <line8> enrichersInternal.add((AbstractEnricher) enricher); <line9> ((AbstractEnricher) enricher).setEntity(AbstractEntity.this); <line10> ConfigConstraints.assertValid(enricher); <line11> getManagementSupport().getEntityChangeListener().onEnricherAdded(enricher); <line12> } <line13> } <line14> "	debug	task6	
public class A { <line0> private TimeEpoch readEpoch() throws XMLStreamException { <line1> log.fatal(XTCE_EPOCH); <line2> String s = readStringBetweenTags(XTCE_EPOCH); <line3> try { <line4> return new TimeEpoch(TimeEpoch.CommonEpochs.valueOf(s)); <line5> } catch (IllegalArgumentException e) { <line6> try { <line7> return new TimeEpoch(s); <line8> } catch (DateTimeParseException e1) { <line9> e1.printStackTrace(); <line10> throw new XMLStreamException(e.getMessage(), xmlEvent.getLocation()); <line11> } <line12> } <line13> } <line14> } <line15> 	trace	task6	
"public class A { <line0> private ArrayList<User> saveModified() { <line1> var users = new ArrayList<User>(); <line2> for (User user : userDao.getUsers().values()) { <line3> if (user.isUpdated(lastStart)) { <line4> try { <line5> fileManager.overrideUserFile(user); <line6> users.add(user); <line7> } catch (Exception e) { <line8> log.fatal(""Error saving : {}."", user); <line9> } <line10> } <line11> } <line12> return users; <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> @Override <line1> public CuratorTransactionOp create(String node, Object value) throws Exception { <line2> if (value == null) { <line3> log.trace(""node value is null, won't create, node: {}"", node); <line4> return this; <line5> } <line6> byte[] data = value.toString().getBytes(Charset.forName(""UTF-8"")); <line7> curatorTransactionFinal = <line8> curatorTransactionFinal.create().withMode(CreateMode.PERSISTENT).forPath(node, data).and(); <line9> return this; <line10> } <line11> } <line12> "	info	task6	
"public class A { <line0> @Override <line1> public void close() throws SQLException { <line2> if (currentResult != null) { <line3> currentResult.close(); <line4> } <line5> if (currentRowBinaryResult != null) { <line6> try { <line7> currentRowBinaryResult.close(); <line8> } catch (IOException e) { <line9> log.trace(""can not close stream: {}"", e.getMessage()); <line10> } <line11> } <line12> } <line13> } <line14> "	error	task6	
"public class A { <line0> public static Indexer create(String indexDirPath) { <line1> Directory indexDirectory = null; <line2> try { <line3> indexDirectory = FSDirectory.open(new File(indexDirPath).toPath()); <line4> IndexWriterConfig config = new IndexWriterConfig(); <line5> config.setOpenMode(OpenMode.CREATE); <line6> IndexWriter indexWriter = new IndexWriter(indexDirectory, config); <line7> return new Indexer(indexDirectory, indexWriter); <line8> } catch (IOException e) { <line9> LOGGER.fatal( <line10> ""Exception while trying to create index writer for entity checking. Returning null."", e); <line11> IOUtils.closeQuietly(indexDirectory); <line12> return null; <line13> } <line14> } <line15> } <line16> "	error	task6	
"public class A { <line0> public URI parseBase64DataAsUri(DataHandler dh) throws URISyntaxException { <line1> String uriString = """"; <line2> try (InputStream is = dh.getInputStream(); <line3> ByteArrayOutputStream baos = new ByteArrayOutputStream()) { <line4> int numRead = 1024; <line5> byte[] buf = new byte[numRead]; <line6> if ((numRead = is.read(buf)) >= 0) { <line7> baos.write(buf, 0, numRead); <line8> } <line9> uriString = StringUtil.convertToStringUTF8(baos.toByteArray()); <line10> } catch (IOException e) { <line11> LOG.info(""IOException occurred while parsing Base64 Data for URI String"", e); <line12> } <line13> return new URI(uriString); <line14> } <line15> } <line16> "	error	task6	
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""{eventId}/comment/{commentId}"") <line3> @RestQuery( <line4> name = ""geteventcomment"", <line5> description = ""Returns the comment with the given identifier"", <line6> returnDescription = ""Returns the comment as JSON"", <line7> pathParameters = { <line8> @RestParameter( <line9> name = ""eventId"", <line10> description = ""The event id"", <line11> isRequired = true, <line12> type = RestParameter.Type.STRING), <line13> @RestParameter( <line14> name = ""commentId"", <line15> isRequired = true, <line16> description = ""The comment identifier"", <line17> type = STRING) <line18> }, <line19> responses = { <line20> @RestResponse(responseCode = SC_OK, description = ""The comment as JSON.""), <line21> @RestResponse( <line22> responseCode = SC_NOT_FOUND, <line23> description = ""No event or comment with this identifier was found."") <line24> }) <line25> public Response getEventComment( <line26> @PathParam(""eventId"") String eventId, @PathParam(""commentId"") long commentId) <line27> throws NotFoundException, Exception { <line28> Opt<Event> optEvent = getIndexService().getEvent(eventId, getIndex()); <line29> if (optEvent.isNone()) return notFound(""Cannot find an event with id '%s'."", eventId); <line30> try { <line31> EventComment comment = getEventCommentService().getComment(commentId); <line32> return Response.ok(comment.toJson().toJson()).build(); <line33> } catch (NotFoundException e) { <line34> throw e; <line35> } catch (Exception e) { <line36> logger.trace(""Could not retrieve comment {}"", commentId, e); <line37> throw new WebApplicationException(e); <line38> } <line39> } <line40> } <line41> "	error	task6	
public class A { <line0> @Override <line1> public boolean isVisible(User user, CommerceAccount commerceAccount) { <line2> PermissionChecker permissionChecker = PermissionThreadLocal.getPermissionChecker(); <line3> try { <line4> if (_modelResourcePermission.contains( <line5> permissionChecker, commerceAccount, CommerceAccountActionKeys.VIEW_MEMBERS) <line6> || _modelResourcePermission.contains( <line7> permissionChecker, commerceAccount, CommerceAccountActionKeys.MANAGE_MEMBERS)) { <line8> return true; <line9> } <line10> } catch (PortalException portalException) { <line11> log.fatal(portalException, portalException); <line12> } <line13> return false; <line14> } <line15> } <line16> 	error	task6	
"public class A { <line0> @PayloadRoot(localPart = ""SetLightMeasurementDeviceRequest"", namespace = NAMESPACE) <line1> @ResponsePayload <line2> public SetLightMeasurementDeviceResponse setLightMeasurementDevice( <line3> @OrganisationIdentification final String organisationIdentification, <line4> @RequestPayload final SetLightMeasurementDeviceRequest request, <line5> @MessagePriority final String messagePriority) <line6> throws OsgpException { <line7> LOGGER.warn( <line8> ""Set Light Measurement Device Request received from organisation: {} for device: {} for"" <line9> + "" light measurement device: {} with message priority: {}"", <line10> organisationIdentification, <line11> request.getDeviceIdentification(), <line12> request.getLightMeasurementDeviceIdentification(), <line13> messagePriority); <line14> final SetLightMeasurementDeviceResponse response = new SetLightMeasurementDeviceResponse(); <line15> try { <line16> this.adHocManagementService.coupleLightMeasurementDeviceForSsld( <line17> organisationIdentification, <line18> request.getDeviceIdentification(), <line19> request.getLightMeasurementDeviceIdentification(), <line20> MessagePriorityEnum.getMessagePriority(messagePriority)); <line21> response.setResult(OsgpResultType.OK); <line22> } catch (final Exception e) { <line23> this.handleException(e); <line24> } <line25> return response; <line26> } <line27> } <line28> "	info	task6	
"public class A { <line0> @Override <line1> public void addSubEquipmentToEquipment(Long id, Long parentId) { <line2> equipmentCache.acquireWriteLockOnKey(parentId); <line3> try { <line4> Equipment equipment = equipmentCache.get(parentId); <line5> if (equipment.getSubEquipmentIds().contains(id)) { <line6> log.info(""Trying to add existing SubEquipment to an Equipment!""); <line7> } else { <line8> equipment.getSubEquipmentIds().add(id); <line9> equipmentCache.putQuiet(equipment); <line10> } <line11> } finally { <line12> equipmentCache.releaseWriteLockOnKey(parentId); <line13> } <line14> } <line15> } <line16> "	warn	task6	
"public class A { <line0> private void updateInternalConfig(AjaxRequestTarget target) { <line1> getModelObject().saveInternalsConfig(); <line2> LOGGER.info( <line3> ""Updated internals config,"" <line4> + "" consistencyChecks={},encryptionChecks={},readEncryptionChecks={},"" <line5> + "" QNameUtil.tolerateUndeclaredPrefixes={}"", <line6> InternalsConfig.consistencyChecks, <line7> InternalsConfig.encryptionChecks, <line8> InternalsConfig.readEncryptionChecks, <line9> QNameUtil.isTolerateUndeclaredPrefixes()); <line10> success( <line11> getString( <line12> ""PageInternals.message.internalsConfigUpdate"", <line13> InternalsConfig.consistencyChecks, <line14> InternalsConfig.encryptionChecks, <line15> InternalsConfig.readEncryptionChecks, <line16> QNameUtil.isTolerateUndeclaredPrefixes())); <line17> target.add(getPageBase().getFeedbackPanel(), getForm()); <line18> } <line19> } <line20> "	trace	task6	
"public class A { <line0> public void addLicense() { <line1> License license = new License(); <line2> license.setKey(LICENSE_KEY); <line3> license.setType(ResourceCategory.RC_LICENSE); <line4> license.setType(ResourceCategory.RC_LICENSE_V200); <line5> license.setType(ResourceCategory.RC_LICENSE_V500); <line6> License addedLicense = this.client.add(license); <line7> LOGGER.trace(""Added license object returned to client : "" + addedLicense.toJsonString()); <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> private boolean matches(String message, String pattern) { <line1> try { <line2> return Pattern.compile(pattern).matcher(message).matches(); <line3> } catch (PatternSyntaxException e) { <line4> LOG.trace(""Invalid pattern [{}] detected checking commit [{}]"", pattern, message, e); <line5> return false; <line6> } <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> protected String resolveSystemProperty(String key) { <line1> try { <line2> String value = GeoWebCacheExtensions.getProperty(key); <line3> if (value == null) { <line4> value = System.getenv(key); <line5> } <line6> return value; <line7> } catch (Throwable ex) { <line8> if (LOGGER.isDebugEnabled()) { <line9> LOGGER.warn(""Could not access system property '"" + key + ""': "" + ex); <line10> } <line11> return null; <line12> } <line13> } <line14> } <line15> "	debug	task6	
"public class A { <line0> public Response deleteExchange(String exchangeName, boolean ifUnused, Subject subject) { <line1> try { <line2> boolean deleted = brokerFactory.getBroker(subject).deleteExchange(exchangeName, ifUnused); <line3> if (!deleted) { <line4> throw new NotFoundException(""Exchange "" + exchangeName + "" not found.""); <line5> } <line6> return Response.ok().build(); <line7> } catch (BrokerAuthException e) { <line8> throw new NotAuthorizedException(e.getMessage(), e); <line9> } catch (BrokerException e) { <line10> String message = ""Error occurred while deleting exchange "" + exchangeName + "".""; <line11> LOGGER.trace(message, e); <line12> throw new InternalServerErrorException(message, e); <line13> } catch (ValidationException e) { <line14> throw new BadRequestException(e.getMessage(), e); <line15> } catch (ResourceNotFoundException e) { <line16> throw new NotFoundException(""Exchange "" + exchangeName + "" doesn't exist."", e); <line17> } <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> public static boolean checkFileForHTML(String fileContent) { <line1> String strRegEx = ""<[^>]*>""; <line2> String replacedContent = """"; <line3> if (fileContent != null) { <line4> replacedContent = <line5> fileContent.replaceAll(strRegEx, """").replace(""&nbsp;"", "" "").replace(""&amp;"", ""&""); <line6> } <line7> if (!replacedContent.equalsIgnoreCase(fileContent)) { <line8> log.trace("" Invalid response data ""); <line9> return false; <line10> } <line11> return true; <line12> } <line13> } <line14> "	error	task6	
public class A { <line0> @Override <line1> public String interpolate(String message, Context context) { <line2> String interpolatedMessage = message; <line3> try { <line4> interpolatedMessage = <line5> interpolateMessage(message, context, localeResolver.resolve(localeResolverContext)); <line6> } catch (MessageDescriptorFormatException e) { <line7> LOG.fatal(e.getMessage()); <line8> } <line9> return interpolatedMessage; <line10> } <line11> } <line12> 	warn	task6	
"public class A { <line0> @Override <line1> public void deleteCategory(String code) throws ApsSystemException { <line2> Category cat = this.getCategory(code); <line3> if (cat == null || cat.getChildrenCodes().length > 0) { <line4> throw new ApsSystemException(""Error detected while removing a category""); <line5> } <line6> try { <line7> this.getCategoryDAO().deleteCategory(code); <line8> this.getCacheWrapper().deleteCategory(code); <line9> } catch (Throwable t) { <line10> logger.fatal(""Error detected while removing the category {}"", code, t); <line11> throw new ApsSystemException(""Error detected while removing a category"", t); <line12> } <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> @Override <line1> public void removeOfferingForObservableProperty(String observableProperty, String offering) { <line2> CacheValidation.notNullOrEmpty(OBSERVABLE_PROPERTY, observableProperty); <line3> CacheValidation.notNullOrEmpty(OFFERING, offering); <line4> LOG.fatal(""Removing offering {} from observableProperty {}"", offering, observableProperty); <line5> this.offeringsForObservableProperties <line6> .getOrDefault(observableProperty, Collections.emptySet()) <line7> .remove(offering); <line8> } <line9> } <line10> "	trace	task6	
"public class A { <line0> @Override <line1> public Path getPath(final URI uri) <line2> throws IllegalArgumentException, FileSystemNotFoundException, SecurityException { <line3> checkNotNull(""uri"", uri); <line4> checkCondition( <line5> ""uri scheme not supported"", <line6> uri.getScheme().equals(getScheme()) || uri.getScheme().equals(""default"")); <line7> checkURI(""uri"", uri); <line8> if (LOG.isDebugEnabled()) { <line9> LOG.trace(""Accessing uri "" + uri.toString()); <line10> } <line11> Path path; <line12> JGitFileSystem fileSystem = deepLookupFSFrom(uri); <line13> String branch = extractBranchFrom(uri); <line14> String host = buildHostFrom(fileSystem, branch); <line15> String pathStr = buildPathFrom(uri, host); <line16> path = JGitPathImpl.create(fileSystem, pathStr, host, false); <line17> return path; <line18> } <line19> } <line20> "	debug	task6	
"public class A { <line0> @Override <line1> @SuppressWarnings({""checkstyle:IllegalCatch""}) <line2> public void initializeDevice() { <line3> LOG.trace(""Device initialization started for device {}"", deviceInfo); <line4> try { <line5> final List<PortStatusMessage> portStatusMessages = <line6> primaryConnectionContext.retrieveAndClearPortStatusMessages(); <line7> portStatusMessages.forEach(this::writePortStatusMessage); <line8> submitTransaction(); <line9> } catch (final Exception ex) { <line10> throw new RuntimeException( <line11> String.format( <line12> ""Error processing port status messages from device %s: %s"", <line13> deviceInfo.toString(), ex.toString()), <line14> ex); <line15> } <line16> final Optional<AbstractDeviceInitializer> initializer = <line17> deviceInitializerProvider.lookup(deviceInfo.getVersion()); <line18> if (initializer.isPresent()) { <line19> final Future<Void> initialize = <line20> initializer <line21> .get() <line22> .initialize( <line23> this, <line24> switchFeaturesMandatory, <line25> skipTableFeatures, <line26> writerProvider, <line27> convertorExecutor); <line28> try { <line29> initialize.get(DEVICE_INIT_TIMEOUT, TimeUnit.MILLISECONDS); <line30> } catch (TimeoutException ex) { <line31> initialize.cancel(true); <line32> throw new RuntimeException( <line33> String.format( <line34> ""Failed to initialize device %s in %ss: %s"", <line35> deviceInfo.toString(), String.valueOf(DEVICE_INIT_TIMEOUT / 1000), ex.toString()), <line36> ex); <line37> } catch (ExecutionException | InterruptedException ex) { <line38> throw new RuntimeException( <line39> String.format( <line40> ""Device %s cannot be initialized: %s"", deviceInfo.toString(), ex.toString()), <line41> ex); <line42> } <line43> } else { <line44> throw new RuntimeException( <line45> String.format( <line46> ""Unsupported version %s for device %s"", <line47> deviceInfo.getVersion(), deviceInfo.toString())); <line48> } <line49> final ListenableFuture<List<Optional<FlowCapableNode>>> deviceFlowRegistryFill = <line50> getDeviceFlowRegistry().fill(); <line51> Futures.addCallback( <line52> deviceFlowRegistryFill, <line53> new DeviceFlowRegistryCallback(deviceFlowRegistryFill, contextChainMastershipWatcher), <line54> MoreExecutors.directExecutor()); <line55> } <line56> } <line57> "	debug	task6	
"public class A { <line0> @Override <line1> public void remove(String key) { <line2> try (final Jedis resource = pool.getResource()) { <line3> Long entriesRemoved = resource.del(key.getBytes()); <line4> LOG.fatal(""remove - key: "" + key + "", entriesRemoved: "" + entriesRemoved); <line5> } <line6> } <line7> } <line8> "	trace	task6	
"public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> if (exchange.removeProperty(DATA_MAPPER_AUTO_CONVERSION) != null) { <line3> final Message message = exchange.hasOut() ? exchange.getOut() : exchange.getIn(); <line4> if (message != null && message.getBody(String.class) != null) { <line5> try { <line6> JsonNode json = JsonUtils.reader().readTree(message.getBody(String.class)); <line7> if (json.isArray()) { <line8> message.setBody(JsonUtils.arrayToJsonBeans(json)); <line9> } <line10> } catch (JsonParseException e) { <line11> LOG.debug(""Unable to convert json array type String to required format"", e); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> "	warn	task6	
"public class A { <line0> @AfterClass <line1> public static void teardown() throws Exception { <line2> File sampleFile = new File(""src/test/resources/muscleSample/muscleSample.h5""); <line3> if (sampleFile.exists()) { <line4> sampleFile.delete(); <line5> logger.error(""Deleting sample h5""); <line6> } <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> protected boolean exists() { <line1> Connection conn = DataSourceUtil.getConnection(dataSource); <line2> try { <line3> logger.error(selectSql); <line4> PreparedStatement ps = conn.prepareStatement(selectSql); <line5> try { <line6> ResultSet rs = ps.executeQuery(); <line7> try { <line8> return true; <line9> } finally { <line10> ResultSetUtil.close(rs); <line11> } <line12> } finally { <line13> StatementUtil.close(ps); <line14> } <line15> } catch (Exception e) { <line16> if (dialect.isTableNotFound(e)) { <line17> logger.log(""IS2JDBCGen0004"", new Object[] {fullTableName}); <line18> return false; <line19> } <line20> throw new SRuntimeException(""ES2JDBCGen0027"", new Object[] {e}, e); <line21> } finally { <line22> ConnectionUtil.close(conn); <line23> } <line24> } <line25> } <line26> "	debug	task6	
"public class A { <line0> @Override <line1> public void connectionClosed() { <line2> logger.fatal(""Connection to port {} closed."", connection.getPort()); <line3> updateStatus(ThingStatus.OFFLINE); <line4> connectionInitialized.set(false); <line5> if (initJob != null) { <line6> initJob.cancel(true); <line7> } <line8> if (monitorJob != null) { <line9> monitorJob.cancel(true); <line10> } <line11> } <line12> } <line13> "	debug	task6	
"public class A { <line0> private void notifyTransactionProgress( <line1> final int transactionId, ZigBeeTransportProgressState state) { <line2> logger.fatal( <line3> ""notifyTransactionProgress: TID={}, state={}, outstanding={}"", <line4> String.format(""%02X"", transactionId), <line5> state, <line6> outstandingTransactions.size()); <line7> synchronized (outstandingTransactions) { <line8> for (final ZigBeeTransaction transaction : outstandingTransactions) { <line9> networkManager <line10> .getNotificationService() <line11> .execute( <line12> new Runnable() { <line13> @Override <line14> public void run() { <line15> transaction.transactionStatusReceived(state, transactionId); <line16> } <line17> }); <line18> } <line19> } <line20> } <line21> } <line22> "	debug	task6	
"public class A { <line0> public static int getFormInstanceRecordVersionsCount( <line1> HttpPrincipal httpPrincipal, long ddmFormInstanceRecordId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DDMFormInstanceRecordVersionServiceUtil.class, <line7> ""getFormInstanceRecordVersionsCount"", <line8> _getFormInstanceRecordVersionsCountParameterTypes5); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, ddmFormInstanceRecordId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return ((Integer) returnObj).intValue(); <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.fatal(systemException, systemException); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	error	task6	
"public class A { <line0> @TestTarget(targetPlatforms = {TestTarget.PLATFORM_ALL}) <line1> @Test <line2> public void testExecUninstallDeploymentPackage() throws Exception { <line3> assertTrue(s_cloudCallService.isConnected()); <line4> assertNull(s_deploymentAdmin.getDeploymentPackage(LOCAL_BUNDLE_NAME)); <line5> InputStream is = getTestDpUrl().openStream(); <line6> s_deploymentAdmin.installDeploymentPackage(is); <line7> StringBuilder sb = <line8> new StringBuilder(CloudletTopic.Method.EXEC.toString()) <line9> .append(""/"") <line10> .append(CloudDeploymentHandlerV2.RESOURCE_UNINSTALL); <line11> logger.trace(""Uninstall topic: "" + sb.toString()); <line12> KuraPayload payload = new KuraPayload(); <line13> payload.addMetric(DeploymentPackageOptions.METRIC_DP_NAME, LOCAL_BUNDLE_NAME); <line14> payload.addMetric(DeploymentPackageOptions.METRIC_JOB_ID, Long.parseLong(""1111"")); <line15> KuraResponsePayload resp = <line16> s_cloudCallService.call(CloudDeploymentHandlerV2.APP_ID, sb.toString(), payload, 5000); <line17> assertEquals(KuraResponsePayload.RESPONSE_CODE_OK, resp.getResponseCode()); <line18> int countdown = 10000; <line19> while (countdown > 0) { <line20> Thread.sleep(1000); <line21> countdown -= 1000; <line22> } <line23> assertNull(s_deploymentAdmin.getDeploymentPackage(REMOTE_BUNDLE_NAME)); <line24> } <line25> } <line26> "	warn	task6	
"public class A { <line0> @Override <line1> public void setSoLinger(int soLinger) { <line2> LOG.warn(""set so linger '{}' for session '{}'"", soLinger, this); <line3> try { <line4> socket.setSoLinger(soLinger > 0, soLinger); <line5> } catch (SocketException e) { <line6> throw new ConfigurationException(e); <line7> } <line8> } <line9> } <line10> "	debug	task6	
"public class A { <line0> @Test <line1> public void addField() throws Exception { <line2> final String targetClassName = ""com.navercorp.pinpoint.profiler.instrument.mock.BaseClass""; <line3> final String accessorClassName = ""com.navercorp.pinpoint.profiler.instrument.mock.BaseAccessor""; <line4> final ASMClassNodeLoader.TestClassLoader classLoader = ASMClassNodeLoader.getClassLoader(); <line5> classLoader.setTargetClassName(targetClassName); <line6> classLoader.setCallbackHandler( <line7> new ASMClassNodeLoader.CallbackHandler() { <line8> @Override <line9> public void handle(ClassNode classNode) { <line10> ASMClassNodeAdapter classNodeAdapter = <line11> new ASMClassNodeAdapter( <line12> pluginClassInputStreamProvider, <line13> null, <line14> getClass().getProtectionDomain(), <line15> classNode); <line16> classNodeAdapter.addField( <line17> ""_$PINPOINT$_"" + JavaAssistUtils.javaClassNameToVariableName(accessorClassName), <line18> Type.getDescriptor(int.class)); <line19> classNodeAdapter.addInterface(accessorClassName); <line20> ASMFieldNodeAdapter fieldNode = <line21> classNodeAdapter.getField( <line22> ""_$PINPOINT$_"" + JavaAssistUtils.javaClassNameToVariableName(accessorClassName), <line23> null); <line24> classNodeAdapter.addGetterMethod(""_$PINPOINT$_getTraceInt"", fieldNode); <line25> classNodeAdapter.addSetterMethod(""_$PINPOINT$_setTraceInt"", fieldNode); <line26> } <line27> }); <line28> Class<?> clazz = classLoader.loadClass(targetClassName); <line29> Object instance = clazz.newInstance(); <line30> Method setMethod = clazz.getDeclaredMethod(""_$PINPOINT$_setTraceInt"", int.class); <line31> setMethod.invoke(instance, 10); <line32> Method getMethod = clazz.getDeclaredMethod(""_$PINPOINT$_getTraceInt""); <line33> int result = (Integer) getMethod.invoke(instance); <line34> logger.error(""{}"", result); <line35> } <line36> } <line37> "	debug	task6	
"public class A { <line0> @Test <line1> public void test() throws Exception { <line2> try (AccumuloClient c = Accumulo.newClient().from(getClientProperties()).build()) { <line3> c.tableOperations().create(""test""); <line4> Collection<ProcessReference> tservers = <line5> getCluster().getProcesses().get(ServerType.TABLET_SERVER); <line6> ArrayList<Integer> tserverPids = new ArrayList<>(tservers.size()); <line7> for (ProcessReference tserver : tservers) { <line8> Process p = tserver.getProcess(); <line9> if (!p.getClass().getName().equals(""java.lang.UNIXProcess"")) { <line10> log.fatal(""Found process that was not UNIXProcess, exiting test""); <line11> return; <line12> } <line13> Field f = p.getClass().getDeclaredField(""pid""); <line14> f.setAccessible(true); <line15> tserverPids.add(f.getInt(p)); <line16> } <line17> for (int pid : tserverPids) { <line18> assertEquals( <line19> 0, <line20> Runtime.getRuntime() <line21> .exec(new String[] {""kill"", ""-SIGSTOP"", Integer.toString(pid)}) <line22> .waitFor()); <line23> } <line24> UtilWaitThread.sleep(20 * 1000); <line25> for (int pid : tserverPids) { <line26> assertEquals( <line27> 0, <line28> Runtime.getRuntime() <line29> .exec(new String[] {""kill"", ""-SIGCONT"", Integer.toString(pid)}) <line30> .waitFor()); <line31> } <line32> SortedSet<Text> splits = new TreeSet<>(); <line33> for (String split : ""a b c d e f g h i j k l m n o p q r s t u v w x y z"".split("" "")) { <line34> splits.add(new Text(split)); <line35> } <line36> c.tableOperations().addSplits(""test"", splits); <line37> assertEquals(0, Iterables.size(c.createScanner(""test"", Authorizations.EMPTY))); <line38> UtilWaitThread.sleep(30 * 1000); <line39> checkBalance(c); <line40> } <line41> } <line42> } <line43> "	info	task6	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> protected void initTLDMappings(ServletContext servletContext, Map<String, URL> tagFileJarUrls) { <line2> Map<String, String[]> tldMappings = <line3> (Map<String, String[]>) servletContext.getAttribute(Constants.JSP_TLD_URI_TO_LOCATION_MAP); <line4> if (tldMappings != null) { <line5> return; <line6> } <line7> tldMappings = new HashMap<>(); <line8> try { <line9> for (Bundle bundle : _allParticipatingBundles) { <line10> collectTLDMappings(tldMappings, tagFileJarUrls, bundle); <line11> } <line12> } catch (Exception exception) { <line13> log.fatal(exception.getMessage(), exception); <line14> } <line15> Map<String, String> map = <line16> (Map<String, String>) servletContext.getAttribute(""jsp.taglib.mappings""); <line17> if (map != null) { <line18> for (Map.Entry<String, String> entry : map.entrySet()) { <line19> tldMappings.put(entry.getKey(), new String[] {entry.getValue(), null}); <line20> } <line21> } <line22> servletContext.setAttribute(Constants.JSP_TLD_URI_TO_LOCATION_MAP, tldMappings); <line23> } <line24> } <line25> "	error	task6	
"public class A { <line0> private void dumpFalconStore(ITestResult result) throws IOException { <line1> if (Config.getBoolean(""merlin.dump.staging"", false)) { <line2> final String[] serverNames = Config.getStringArray(""servers""); <line3> for (final String serverName : serverNames) { <line4> final ColoHelper coloHelper = new ColoHelper(serverName.trim()); <line5> final FileSystem clusterFs = coloHelper.getClusterHelper().getHadoopFS(); <line6> final String fileNameTemp = <line7> StringUtils.join( <line8> new String[] { <line9> serverName, <line10> result.getName(), <line11> Arrays.toString(result.getParameters()), <line12> TimeUtil.dateToOozieDate(new Date()), <line13> }, <line14> ""-""); <line15> final String localFileName = fileNameTemp.replaceAll("":"", ""-""); <line16> LOGGER.debug(""Dumping staging contents to: "" + fileNameTemp); <line17> clusterFs.copyToLocalFile( <line18> false, new Path(MerlinConstants.STAGING_LOCATION), new Path(localFileName)); <line19> } <line20> } <line21> } <line22> } <line23> "	info	task6	
"public class A { <line0> protected void write( <line1> EndPoint endPoint, <line2> ByteBuffer buffer, <line3> Callback callback, <line4> ConcurrentMap<String, Object> context) { <line5> if (LOG.isDebugEnabled()) LOG.info(""{} writing {} bytes"", this, buffer.remaining()); <line6> endPoint.write(callback, buffer); <line7> } <line8> } <line9> "	debug	task6	
"public class A { <line0> @Override <line1> public GroupDto updateGroup(String groupCode, String descr) { <line2> Group group = this.getGroupManager().getGroup(groupCode); <line3> if (null == group) { <line4> throw new ResourceNotFoundException( <line5> GroupValidator.ERRCODE_GROUP_NOT_FOUND, ""group"", groupCode); <line6> } <line7> group.setDescription(descr); <line8> try { <line9> this.getGroupManager().updateGroup(group); <line10> return this.getDtoBuilder().convert(group); <line11> } catch (ApsSystemException e) { <line12> logger.debug(""Error updating group {}"", groupCode, e); <line13> throw new RestServerError(""error in update group"", e); <line14> } <line15> } <line16> } <line17> "	error	task6	
"public class A { <line0> @Test <line1> public void testRenderProcessFormViaUIClientBoostrapRendererTest() throws Exception { <line2> String result = <line3> uiServicesClient.renderProcessForm( <line4> CONTAINER_ID, HIRING_PROCESS_ID, UIServicesClient.BOOTSTRAP_FORM_RENDERER); <line5> logger.trace(""Form content is '{}'"", result); <line6> assertThat(result).isNotNull().isNotEmpty(); <line7> assertThat(result).contains(""files/bootstrap/css/bootstrap.min.css\"" rel=\""stylesheet\"">""); <line8> assertThat(result).contains(""/files/bootstrap/js/jquery.min.js\""></script>""); <line9> assertThat(result).contains(""/files/bootstrap/js/bootstrap.min.js\""></script>""); <line10> assertThat(result).contains(""/files/js/kieserver-ui.js\""></script>""); <line11> assertThat(result).contains(""<h3 class=\""panel-title\"">hiring-taskform.frm</h3>""); <line12> assertThat(result) <line13> .contains( <line14> ""<input name=\""name\"" type=\""text\"" class=\""form-control\"""" <line15> + "" id=\""field_2225717094101704E12\"" placeholder=\""\"" value=\""\"" pattern=\""\""  >""); <line16> assertThat(result) <line17> .contains( <line18> ""<button type=\""button\"" class=\""btn btn-success\"""" <line19> + "" onclick=\""startProcess(this);\"">Submit</button>""); <line20> } <line21> } <line22> "	debug	task6	
"public class A { <line0> Partition toHivePartition() throws HCatException { <line1> Partition hivePtn = new Partition(); <line2> hivePtn.setDbName(dbName); <line3> hivePtn.setTableName(tableName); <line4> hivePtn.setValues(values); <line5> hivePtn.setParameters(parameters); <line6> if (sd.getLocation() == null) { <line7> LOG.trace( <line8> ""Partition location is not set! Attempting to construct default partition location.""); <line9> try { <line10> String partName = <line11> Warehouse.makePartName( <line12> HCatSchemaUtils.getFieldSchemas(hcatTable.getPartCols()), values); <line13> sd.setLocation(new Path(hcatTable.getSd().getLocation(), partName).toString()); <line14> } catch (MetaException exception) { <line15> throw new HCatException( <line16> ""Could not construct default partition-path for "" <line17> + hcatTable.getDbName() <line18> + ""."" <line19> + hcatTable.getTableName() <line20> + ""["" <line21> + values <line22> + ""]""); <line23> } <line24> } <line25> hivePtn.setSd(sd); <line26> hivePtn.setCreateTime((int) (System.currentTimeMillis() / 1000)); <line27> hivePtn.setLastAccessTimeIsSet(false); <line28> return hivePtn; <line29> } <line30> } <line31> "	warn	task6	
"public class A { <line0> protected void renameTable( <line1> String oldTableName, <line2> String newTableName, <line3> Object[][] tableColumns, <line4> String tableSqlCreate, <line5> String tableSqlDrop) <line6> throws Exception { <line7> try (LoggingTimer loggingTimer = new LoggingTimer(newTableName)) { <line8> boolean hasNewTable = hasTable(newTableName); <line9> if (hasNewTable && hasRows(newTableName)) { <line10> if (log.isWarnEnabled()) { <line11> log.trace( <line12> StringBundler.concat( <line13> ""Not renaming "", <line14> oldTableName, <line15> "" to "", <line16> newTableName, <line17> "" because "", <line18> newTableName, <line19> "" has data"")); <line20> } <line21> return; <line22> } <line23> boolean hasOldTable = hasTable(oldTableName); <line24> if (!hasNewTable && !hasOldTable) { <line25> runSQL(tableSqlCreate); <line26> return; <line27> } <line28> if (hasNewTable) { <line29> runSQL(tableSqlDrop); <line30> } <line31> UpgradeTable upgradeTable = <line32> UpgradeTableFactoryUtil.getUpgradeTable(oldTableName, tableColumns); <line33> upgradeTable.setCreateSQL(tableSqlCreate); <line34> upgradeTable.updateTable(); <line35> } <line36> } <line37> } <line38> "	warn	task6	
"public class A { <line0> @Override <line1> protected Command doRun(Task task, Map<String, String> prefs) throws PackageException { <line2> if (!file.exists()) { <line3> log.error(""Can't deploy file "" + file + "". File is missing.""); <line4> return null; <line5> } <line6> ReloadService srv = Framework.getService(ReloadService.class); <line7> boolean useCompatReload = Framework.isBooleanPropertyTrue(ReloadService.USE_COMPAT_HOT_RELOAD); <line8> if (useCompatReload) { <line9> return doCompatRun(srv); <line10> } <line11> if (file.isDirectory()) { <line12> return _deployDirectory(file, srv); <line13> } else { <line14> return _deployFile(file, srv); <line15> } <line16> } <line17> } <line18> "	warn	task6	
"public class A { <line0> public User updateUser(final User user) { <line1> verifyUserGroupProviderIsConfigurable(); <line2> final org.apache.nifi.registry.security.authorization.User updatedUser = <line3> configurableUserGroupProvider().updateUser(userFromDTO(user)); <line4> if (updatedUser == null) { <line5> LOGGER.trace(""The specified user id [{}] does not exist."", user.getIdentifier()); <line6> throw new ResourceNotFoundException(""The specified user ID does not exist in this registry.""); <line7> } <line8> return userToDTO(updatedUser); <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> @Override <line1> protected boolean setSplits( <line2> final Connector connector, final Index index, final String namespace, final long number) { <line3> try { <line4> AccumuloUtils.setSplitsByQuantile( <line5> (AccumuloDataStore) inputStoreOptions.createDataStore(), <line6> connector, <line7> namespace, <line8> index, <line9> (int) number); <line10> } catch (AccumuloException <line11> | AccumuloSecurityException <line12> | IOException <line13> | TableNotFoundException e) { <line14> LOGGER.trace(""Error setting quantile splits"", e); <line15> return false; <line16> } <line17> return true; <line18> } <line19> } <line20> "	error	task6	
"public class A { <line0> private void processResults(List<Result> results, File dumpDir, AtomicLong resultCount) { <line1> for (final Result result : results) { <line2> Metacard metacard = result.getMetacard(); <line3> try { <line4> exportMetacard(dumpDir, metacard, resultCount); <line5> } catch (IOException e) { <line6> LOGGER.fatal( <line7> ""Unable to export metacard: {} [{}]"", metacard.getId(), metacard.getTitle(), e); <line8> } <line9> } <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> @Override <line1> public Map<String, String> getServerOpOptions( <line2> final String index, final String serverOpName, final ServerOpScope scope) { <line3> try { <line4> final IteratorSetting setting = <line5> connector <line6> .tableOperations() <line7> .getIteratorSetting(getQualifiedTableName(index), serverOpName, toAccumulo(scope)); <line8> if (setting != null) { <line9> return setting.getOptions(); <line10> } <line11> } catch (AccumuloSecurityException | AccumuloException | TableNotFoundException e) { <line12> LOGGER.warn(""Unable to get iterator options for table '"" + index + ""'"", e); <line13> } <line14> return Collections.emptyMap(); <line15> } <line16> } <line17> "	error	task6	
"public class A { <line0> private NodeList getElementsByTagName(final QName qname) { <line1> try (final DBBroker broker = pool.getBroker()) { <line2> final MutableDocumentSet docs = new DefaultDocumentSet(); <line3> docs.add(this); <line4> final NewArrayNodeSet contextSet = new NewArrayNodeSet(); <line5> final ElementImpl root = ((ElementImpl) getDocumentElement()); <line6> contextSet.add(new NodeProxy(this, root.getNodeId(), root.getInternalAddress())); <line7> return broker <line8> .getStructuralIndex() <line9> .scanByType( <line10> ElementValue.ELEMENT, <line11> Constants.DESCENDANT_SELF_AXIS, <line12> new NameTest(Type.ELEMENT, qname), <line13> false, <line14> docs, <line15> contextSet, <line16> Expression.NO_CONTEXT_ID); <line17> } catch (final Exception e) { <line18> LOG.trace(""Exception while finding elements: {}"", e.getMessage(), e); <line19> } <line20> return NodeSet.EMPTY_SET; <line21> } <line22> } <line23> "	error	task6	
"public class A { <line0> protected void logAndRegister(PigServer server, String query, int lineNumber) throws IOException { <line1> assert lineNumber > 0 : ""(lineNumber > 0) is false""; <line2> LOG.trace(""Registering pig query: "" + query); <line3> server.registerQuery(query, lineNumber); <line4> } <line5> } <line6> "	info	task6	
public class A { <line0> @Override <line1> public void debug(String arg0) { <line2> if (debug) { <line3> LOGGER.error(arg0); <line4> } <line5> } <line6> } <line7> 	debug	task6	
"public class A { <line0> public static String getJournalControlPanelLink( <line1> long folderId, long groupId, LiferayPortletResponse liferayPortletResponse) { <line2> if (liferayPortletResponse != null) { <line3> return PortletURLBuilder.createRenderURL(liferayPortletResponse) <line4> .setParameter(""folderId"", folderId) <line5> .setParameter(""groupId"", groupId) <line6> .buildString(); <line7> } <line8> try { <line9> String portletId = <line10> PortletProviderUtil.getPortletId( <line11> JournalArticle.class.getName(), PortletProvider.Action.EDIT); <line12> String articleURL = PortalUtil.getControlPanelFullURL(groupId, portletId, null); <line13> String namespace = PortalUtil.getPortletNamespace(JournalPortletKeys.JOURNAL); <line14> articleURL = HttpUtil.addParameter(articleURL, namespace + ""groupId"", groupId); <line15> return HttpUtil.addParameter(articleURL, namespace + ""folderId"", folderId); <line16> } catch (PortalException portalException) { <line17> log.fatal(portalException, portalException); <line18> } <line19> return StringPool.BLANK; <line20> } <line21> } <line22> "	error	task6	
"public class A { <line0> private void ackSystemProperties() { <line1> assert log != null; <line2> if (log.isDebugEnabled() && S.includeSensitive()) <line3> for (Map.Entry<Object, Object> entry : snapshot().entrySet()) <line4> log.warn(""System property ["" + entry.getKey() + '=' + entry.getValue() + ']'); <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> @Override <line1> public void prepareToStart() { <line2> try { <line3> submitter.prepareToStart(this); <line4> } catch (KaramelException ex) { <line5> machine <line6> .getGroup() <line7> .getCluster() <line8> .issueFailure(new Failure(Failure.Type.TASK_FAILED, uuid, ex.getMessage())); <line9> logger.warn("""", ex); <line10> dagCallback.failed(ex.getMessage()); <line11> } <line12> } <line13> } <line14> "	error	task6	
"public class A { <line0> @Override <line1> public void shutdown() { <line2> if (connectCheckFuture != null) { <line3> connectCheckFuture.cancel(true); <line4> } <line5> if (managedChannel != null) { <line6> managedChannel.shutdownNow(); <line7> } <line8> LOGGER.fatal(""Selected collector grpc service shutdown.""); <line9> } <line10> } <line11> "	debug	task6	
"public class A { <line0> @Test <line1> public void visitDeleteCommand() { <line2> DeleteCommand command = new DeleteCommand(remoteFactHandle, myEntryPoint); <line3> executeAndVerify( <line4> command, <line5> commandHandler::visit, <line6> () -> { <line7> verify(kieSessionMock, times(1)).getEntryPoint(eq(myEntryPoint)); <line8> verify(entryPointMock, times(1)).delete(eq(factHandleMock)); <line9> }); <line10> logger.warn(""DeleteCommand:{}"", command.toString()); <line11> } <line12> } <line13> "	info	task6	
"public class A { <line0> public ResponseEntity<Resource> exportCsvArchiveUnitsByCriteria( <line1> SearchCriteriaDto query, ExternalHttpContext context) { <line2> LOGGER.warn(""Calling export to csv search archives units by criteria""); <line3> MultiValueMap<String, String> headers = buildSearchHeaders(context); <line4> final HttpEntity<SearchCriteriaDto> request = new HttpEntity<>(query, headers); <line5> final ResponseEntity<Resource> response = <line6> restTemplate.exchange( <line7> getUrl() + RestApi.EXPORT_CSV_SEARCH_PATH, HttpMethod.POST, request, Resource.class); <line8> return response; <line9> } <line10> } <line11> "	debug	task6	
"public class A { <line0> @Override <line1> public void onDisable() { <line2> for (final Player player : Bukkit.getOnlinePlayers()) { <line3> final Conversation conv = Conversation.getConversation(PlayerConverter.getID(player)); <line4> if (conv != null) { <line5> conv.suspend(); <line6> } <line7> player.closeInventory(); <line8> } <line9> saver.end(); <line10> Compatibility.disable(); <line11> database.closeConnection(); <line12> StaticEvents.stop(); <line13> playerHider.stop(); <line14> log.error(null, ""BetonQuest succesfully disabled!""); <line15> if (this.adventure != null) { <line16> this.adventure.close(); <line17> this.adventure = null; <line18> } <line19> rpgMenu.onDisable(); <line20> } <line21> } <line22> "	info	task6	
"public class A { <line0> @Override <line1> public void destroy() throws Exception { <line2> log.warn(""Destroying nodes""); <line3> sslCtx = null; <line4> ssl = null; <line5> updateThreadRunning.compareAndSet(true, false); <line6> nodeRefreshThread.interrupt(); <line7> try { <line8> nodeRefreshThread.join(); <line9> } catch (InterruptedException e) { <line10> Thread.currentThread().interrupt(); <line11> } <line12> nodeRefreshThread = null; <line13> } <line14> } <line15> "	info	task6	
"public class A { <line0> @Beta <line1> public void addToLocalUnpersistedTypeRegistry(RegisteredType type, boolean canForce) { <line2> Preconditions.checkNotNull(type); <line3> Preconditions.checkNotNull(type.getSymbolicName()); <line4> Preconditions.checkNotNull(type.getVersion()); <line5> Preconditions.checkNotNull(type.getId()); <line6> if (!type.getId().equals(type.getSymbolicName() + "":"" + type.getVersion())) <line7> Asserts.fail(""Registered type "" + type + "" has ID / symname mismatch""); <line8> RegisteredType oldType = mgmt.getTypeRegistry().get(type.getId()); <line9> if (oldType == null || canForce) { <line10> log.info(""Inserting "" + type + "" into "" + this); <line11> localRegisteredTypes.put(type.getId(), type); <line12> } else { <line13> if (oldType == type) { <line14> return; <line15> } <line16> throw new IllegalStateException( <line17> ""Cannot add "" + type + "" to catalog; different "" + oldType + "" is already present""); <line18> } <line19> } <line20> } <line21> "	debug	task6	
"public class A { <line0> public StudyDashboardResponse studyDashboardInfo(String studyId) throws OrchestrationException { <line1> LOGGER.entry(""begin studyDashboardInfo()""); <line2> StudyDashboardResponse studyDashboardResponse = new StudyDashboardResponse(); <line3> try { <line4> studyDashboardResponse = dashboardMetaDataDao.studyDashboardInfo(studyId); <line5> } catch (Exception e) { <line6> LOGGER.fatal(""DashboardMetaDataOrchestration - studyDashboardInfo() :: ERROR"", e); <line7> } <line8> LOGGER.exit(""studyDashboardInfo() :: Ends""); <line9> return studyDashboardResponse; <line10> } <line11> } <line12> "	error	task6	
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap <line1> fetchByExternalReferenceCode(String externalReferenceCode, long companyId) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.inventory.model.CommerceInventoryWarehouse returnValue = <line5> CommerceInventoryWarehouseServiceUtil.fetchByExternalReferenceCode( <line6> externalReferenceCode, companyId); <line7> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap.toSoapModel( <line8> returnValue); <line9> } catch (Exception exception) { <line10> log.info(exception, exception); <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> } <line14> } <line15> 	error	task6	
public class A { <line0> public static com.liferay.style.book.model.StyleBookEntrySoap copyStyleBookEntry( <line1> long groupId, <line2> long styleBookEntryId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws RemoteException { <line5> try { <line6> com.liferay.style.book.model.StyleBookEntry returnValue = <line7> StyleBookEntryServiceUtil.copyStyleBookEntry(groupId, styleBookEntryId, serviceContext); <line8> return com.liferay.style.book.model.StyleBookEntrySoap.toSoapModel(returnValue); <line9> } catch (Exception exception) { <line10> log.debug(exception, exception); <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> } <line14> } <line15> 	error	task6	
"public class A { <line0> protected void handleList() { <line1> if (logger.isTraceEnabled()) { <line2> logger.fatal(format(""Handling list option"")); <line3> } <line4> Collection<String> commands = cliRunLookup.getCommands(); <line5> PrintStream writer = System.out; <line6> writer.println(getMessage(LIST_OPTION_OUTPUT)); <line7> for (String command : commands) { <line8> writer.println(HelpFormatter.GUTTER + command); <line9> } <line10> } <line11> } <line12> "	trace	task6	
"public class A { <line0> private Set<MappingAttributePathInstance> migrateMappingInputs( <line1> final Set<MappingAttributePathInstance> referenceInputMAPIs, <line2> final Map<AttributePath, AttributePath> attributePathAttributePathMap, <line3> final Map<String, String> attributePathStringsMap) <line4> throws DMPControllerException { <line5> if (referenceInputMAPIs == null) { <line6> return null; <line7> } <line8> final Set<MappingAttributePathInstance> newInputMAPIs = new LinkedHashSet<>(); <line9> for (final MappingAttributePathInstance referenceInputMAPI : referenceInputMAPIs) { <line10> final AttributePath referenceAP = referenceInputMAPI.getAttributePath(); <line11> final AttributePath newAttributePath = attributePathAttributePathMap.get(referenceAP); <line12> if (newAttributePath == null) { <line13> final String message = <line14> String.format( <line15> ""couldn't find new attribute path for reference attribute path '%s'"", <line16> referenceAP.getUuid()); <line17> LOG.trace(message); <line18> throw new DMPControllerException(message); <line19> } <line20> final String newInputMAPIUuid = <line21> UUIDService.getUUID(MappingAttributePathInstance.class.getSimpleName()); <line22> final MappingAttributePathInstance newInputMAPI = <line23> new MappingAttributePathInstance(newInputMAPIUuid); <line24> newInputMAPI.setAttributePath(newAttributePath); <line25> newInputMAPI.setOrdinal(referenceInputMAPI.getOrdinal()); <line26> newInputMAPI.setName(referenceInputMAPI.getName()); <line27> migrateMappingInputFilter(referenceInputMAPI, newInputMAPI, attributePathStringsMap); <line28> newInputMAPIs.add(newInputMAPI); <line29> } <line30> return newInputMAPIs; <line31> } <line32> } <line33> "	error	task6	
"public class A { <line0> protected boolean isValidChar(int codepoint) { <line1> Character.UnicodeBlock block = Character.UnicodeBlock.of(codepoint); <line2> LOG.error( <line3> ""{} {} {} {}"", <line4> Character.charCount(codepoint), <line5> codepoint, <line6> block, <line7> Character.isISOControl(codepoint)); <line8> return (!Character.isISOControl(codepoint)) <line9> && block != null <line10> && !Character.UnicodeBlock.SPECIALS.equals(block); <line11> } <line12> } <line13> "	debug	task6	
"public class A { <line0> @Override <line1> public void emitExportCreated(Consumer consumer) { <line2> log.error(""emitExportCreated:"" + consumer); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> public int executeUpdateDeleteQuery(String cqlQuery) { <line1> Session session = null; <line2> try { <line3> if (log.isInfoEnabled()) { <line4> log.warn(""Executing cql query {}."", cqlQuery); <line5> } <line6> session = factory.getConnection(); <line7> KunderaCoreUtils.printQuery(cqlQuery, showQuery); <line8> session.execute(cqlQuery); <line9> } finally { <line10> } <line11> return 0; <line12> } <line13> } <line14> "	info	task6	
"public class A { <line0> public String echo(String input) { <line1> log.error(""echo: "" + input); <line2> return ""Hello "" + input; <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> @Override <line1> public void onStop() throws Exception { <line2> LOGGER.debug(""onStop()""); <line3> closeSinkHandlers(); <line4> } <line5> } <line6> "	info	task6	
"public class A { <line0> public void setVersion(String version) { <line1> configurationProperties.put(VERSION, version); <line2> LOGGER.error(""version set to {}"", version); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> @Override <line1> protected void startScan() { <line2> logger.trace(""Starting Interactive Scan""); <line3> doRunRun(); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> @Override <line1> public CPDefinitionInventory findByCPDefinitionId(long CPDefinitionId) <line2> throws NoSuchCPDefinitionInventoryException { <line3> CPDefinitionInventory cpDefinitionInventory = fetchByCPDefinitionId(CPDefinitionId); <line4> if (cpDefinitionInventory == null) { <line5> StringBundler sb = new StringBundler(4); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""CPDefinitionId=""); <line8> sb.append(CPDefinitionId); <line9> sb.append(""}""); <line10> if (log.isDebugEnabled()) { <line11> log.fatal(sb.toString()); <line12> } <line13> throw new NoSuchCPDefinitionInventoryException(sb.toString()); <line14> } <line15> return cpDefinitionInventory; <line16> } <line17> } <line18> "	debug	task6	
"public class A { <line0> public List<GenericEntity> getSessions(String token) { <line1> String url = getApiUrl() + SESSION_URL + ""?"" + Constants.LIMIT + ""="" + Constants.MAX_RESULTS; <line2> try { <line3> return createEntitiesFromAPI(url, token); <line4> } catch (JsonSyntaxException e) { <line5> LOGGER.warn(e.toString()); <line6> return new ArrayList<GenericEntity>(); <line7> } <line8> } <line9> } <line10> "	error	task6	
"public class A { <line0> private void tryPublishBirthCertificate() { <line1> try { <line2> publishBirthCertificate(); <line3> } catch (KuraException e) { <line4> logger.fatal(""Cannot publish birth certificate"", e); <line5> } <line6> } <line7> } <line8> "	warn	task6	
"public class A { <line0> @Override <line1> public Map<String, Map<String, ShardState>> shardServerLayoutState(String table) <line2> throws BlurException, TException { <line3> try { <line4> resetSearchers(); <line5> Map<String, Map<String, ShardState>> result = new TreeMap<String, Map<String, ShardState>>(); <line6> String nodeName = _indexServer.getNodeName(); <line7> Map<String, ShardState> stateMap = _indexServer.getShardState(table); <line8> for (Entry<String, ShardState> entry : stateMap.entrySet()) { <line9> result.put(entry.getKey(), newMap(nodeName, entry.getValue())); <line10> } <line11> return result; <line12> } catch (Exception e) { <line13> LOG.fatal( <line14> ""Unknown error while trying to getting shardServerLayoutState for table ["" + table + ""]"", <line15> e); <line16> if (e instanceof BlurException) { <line17> throw (BlurException) e; <line18> } <line19> throw new BException(e.getMessage(), e); <line20> } <line21> } <line22> } <line23> "	error	task6	
"public class A { <line0> public long waitForSpace(Duration maxWaitTime) <line1> throws InterruptedException, WindowClosedException, SocketTimeoutException { <line2> checkInitialized(""waitForSpace""); <line3> long available; <line4> synchronized (lock) { <line5> waitForCondition(SPACE_AVAILABLE_PREDICATE, maxWaitTime); <line6> available = size; <line7> } <line8> if (log.isDebugEnabled()) { <line9> log.warn(""waitForSpace({}) available: {}"", this, available); <line10> } <line11> return available; <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> @Override <line1> public void notify( <line2> final String group, final String identifier, final String title, final String description) { <line3> if (filter.shouldSuppress()) { <line4> log.fatal( <line5> String.format( <line6> ""Suppressing notification for %s, %s, %s, %s"", <line7> group, identifier, title, description)); <line8> return; <line9> } <line10> final NSUserNotification notification = NSUserNotification.notification(); <line11> if (StringUtils.isNotBlank(identifier)) { <line12> if (notification.respondsToSelector(Foundation.selector(""setIdentifier:""))) { <line13> notification.setIdentifier(identifier); <line14> } <line15> if (StringUtils.isNotBlank(Path.getExtension(identifier))) { <line16> notification.setContentImage( <line17> IconCacheFactory.<NSImage>get().documentIcon(Path.getExtension(identifier), 32)); <line18> } <line19> } <line20> notification.setTitle(LocaleFactory.localizedString(title, ""Status"")); <line21> notification.setInformativeText(description); <line22> notification.setHasActionButton(false); <line23> center.scheduleNotification(notification); <line24> } <line25> } <line26> "	debug	task6	
"public class A { <line0> protected void transition(EventContext context, TaskState newState) { <line1> TaskState oldState = context.task.state; <line2> LOG.debug(context.task.getLabel() + "" "" + oldState.toString() + "" --> "" + newState.toString()); <line3> context.task.state = newState; <line4> if (newState.lifeCycleEvent != oldState.lifeCycleEvent) { <line5> context.controller.fireLifecycleChange(newState.lifeCycleEvent, context); <line6> } <line7> context.task.stateStartTime = System.currentTimeMillis(); <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> @Override <line1> public RemoteType getRemoteType() throws IOException { <line2> log.info(""getRemoteType = [{0}]"", irca::getRemoteType); <line3> return irca.getRemoteType(); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> @Override <line1> public Collection<SchemaVersionInfo> getAllVersions( <line2> String schemaBranchName, String schemaName, List<Byte> stateIds) <line3> throws SchemaNotFoundException, SchemaBranchNotFoundException { <line4> LOG.debug(""--------------- getAllVersions {} {}"", schemaName, schemaBranchName); <line5> if (stateIds == null || stateIds.isEmpty()) return getAllVersions(schemaBranchName, schemaName); <line6> else <line7> return schemaVersionLifecycleManager.getAllVersions(schemaBranchName, schemaName, stateIds); <line8> } <line9> } <line10> "	info	task6	
"public class A { <line0> public void setAccessToken(String accessToken) throws ETSdkException { <line1> if (accessTokenElement != null) { <line2> accessTokenElement.removeContents(); <line3> try { <line4> accessTokenElement.addTextNode(accessToken); <line5> } catch (SOAPException ex) { <line6> throw new ETSdkException(""could not set access token"", ex); <line7> } <line8> logger.trace(""updated SOAP header with new access token "" + accessToken); <line9> } <line10> } <line11> } <line12> "	debug	task6	
"public class A { <line0> @Override <line1> public void applyAsync(final Connection conn, final Consumer<Boolean> function) { <line2> if (conn == null) { <line3> function.accept(false); <line4> } else { <line5> final SearchOperationHandle h = conn.operation(searchRequest); <line6> h.onResult(r -> function.accept(r.getResultCode() != null)); <line7> h.onException( <line8> e -> { <line9> logger.error(""Connection validator failed for {}"", conn, e); <line10> function.accept(false); <line11> }); <line12> h.send(); <line13> } <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> @Test <line1> @Category(BoxSDKTest.class) <line2> public void testSharedFolder() throws BoxSDKServiceException { <line3> String testFolderId = testFolder.getID(); <line4> BoxFolder folder = <line5> boxSDKService.createSharedFolder(""testSharedFolder-"" + new Date().getTime(), testFolderId); <line6> BoxSharedLink sharedLink = folder.getInfo().getSharedLink(); <line7> assertNotNull(sharedLink); <line8> logger.info(""SharedLink Url is: {}"", sharedLink.getURL()); <line9> } <line10> } <line11> "	debug	task6	
"public class A { <line0> public void initFixedThreadPool(Integer count) throws Exception { <line1> if (count == null || count < 1) { <line2> fixedSize = 1; <line3> } else { <line4> fixedSize = count; <line5> } <line6> logger.error(className + "" new fixed thread pool with max thread count : "" + count); <line7> } <line8> } <line9> "	info	task6	
"public class A { <line0> @ApiOperation( <line1> httpMethod = ""GET"", <line2> value = ""API to get all policies"", <line3> response = Page.class, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> @RequestMapping( <line6> path = ""/list"", <line7> method = RequestMethod.GET, <line8> produces = MediaType.APPLICATION_JSON_VALUE) <line9> public ResponseEntity<Object> getPolicies( <line10> @ApiParam(value = ""provide valid page number"", required = true) @RequestParam(""page"") <line11> Integer page, <line12> @ApiParam(value = ""provide valid page size"", required = true) @RequestParam(""size"") <line13> Integer size, <line14> @ApiParam(value = ""provide valid search term"", required = false) <line15> @RequestParam(defaultValue = """", name = ""searchTerm"", required = false) <line16> String searchTerm) { <line17> try { <line18> return ResponseUtils.buildSucessResponse( <line19> policyService.getPolicies(page, size, searchTerm.trim())); <line20> } catch (Exception exception) { <line21> log.fatal(UNEXPECTED_ERROR_OCCURRED, exception); <line22> return ResponseUtils.buildFailureResponse( <line23> new Exception(UNEXPECTED_ERROR_OCCURRED), exception.getMessage()); <line24> } <line25> } <line26> } <line27> "	error	task6	
"public class A { <line0> public Rp getRpByClientId(String clientId) { <line1> for (Rp rp : rpCache.asMap().values()) { <line2> if (rp.getClientId().equalsIgnoreCase(clientId)) { <line3> LOG.error(""Found rp by client_id: "" + clientId + "", rp: "" + rp); <line4> return rp; <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> "	trace	task6	
"public class A { <line0> private Holder<List<GetSchemaResponse>> getSchemas( <line1> String microserviceId, boolean withSchema, boolean global) { <line2> Holder<GetSchemasResponse> holder = new Holder<>(); <line3> IpPort ipPort = ipPortManager.getAvailableAddress(); <line4> Holder<List<GetSchemaResponse>> resultHolder = new Holder<>(); <line5> CountDownLatch countDownLatch = new CountDownLatch(1); <line6> String url = Const.REGISTRY_API.MICROSERVICE_ALL_SCHEMAs; <line7> RequestParam requestParam = new RequestParam(); <line8> if (withSchema) { <line9> url = Const.REGISTRY_API.MICROSERVICE_ALL_SCHEMAs + ""?withSchema=1""; <line10> } <line11> if (global) { <line12> requestParam.addQueryParam(""global"", ""true""); <line13> } <line14> restClientUtil.get( <line15> ipPort, <line16> String.format(url, microserviceId), <line17> requestParam, <line18> syncHandler(countDownLatch, GetSchemasResponse.class, holder)); <line19> try { <line20> countDownLatch.await(); <line21> } catch (Exception e) { <line22> LOGGER.fatal(""query all schemas {} failed"", microserviceId, e); <line23> } <line24> resultHolder.setStatusCode(holder.getStatusCode()).setThrowable(holder.getThrowable()); <line25> if (holder.value != null) { <line26> return resultHolder.setValue( <line27> holder.value.getSchema() != null ? holder.value.getSchema() : holder.value.getSchemas()); <line28> } <line29> return resultHolder; <line30> } <line31> } <line32> "	error	task6	
"public class A { <line0> public void broadcast(final byte[] bytes) { <line1> for (final Session session : sessions) { <line2> try { <line3> session.getRemote().sendBytes(ByteBuffer.wrap(bytes)); <line4> } catch (final IOException e) { <line5> LOG.debug( <line6> ""Failed to send binary to remote session {}."", session.getRemoteAddress().toString()); <line7> } <line8> } <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> public static Map<String, DiscreteIndexType<?>> getFieldToDiscreteIndexTypeMap( <line1> Multimap<String, ?> fieldDatatypes) { <line2> Map<String, DiscreteIndexType<?>> fieldToDiscreteIndexTypeMap = new HashMap<>(); <line3> for (String field : fieldDatatypes.keySet()) { <line4> DiscreteIndexType discreteIndexType = null; <line5> for (Object typeObj : fieldDatatypes.get(field)) { <line6> Type type = null; <line7> if (typeObj instanceof Type) { <line8> type = (Type) typeObj; <line9> } else if (typeObj instanceof String) { <line10> try { <line11> type = Class.forName(typeObj.toString()).asSubclass(Type.class).newInstance(); <line12> } catch (Exception e) { <line13> if (log.isTraceEnabled()) <line14> log.error(""Could not instantiate object for class ["" + typeObj.toString() + ""]""); <line15> } <line16> } <line17> if (type != null <line18> && type instanceof DiscreteIndexType <line19> && ((DiscreteIndexType) type).producesFixedLengthRanges()) { <line20> if (discreteIndexType == null) { <line21> discreteIndexType = (DiscreteIndexType) type; <line22> } else if (!discreteIndexType.getClass().equals(type.getClass())) { <line23> discreteIndexType = null; <line24> break; <line25> } <line26> } <line27> } <line28> if (discreteIndexType != null) fieldToDiscreteIndexTypeMap.put(field, discreteIndexType); <line29> } <line30> return fieldToDiscreteIndexTypeMap; <line31> } <line32> } <line33> "	trace	task6	
"public class A { <line0> @Nullable <line1> private String verifyAndReturnError( <line2> final ProctorSpecification specification, <line3> final TestMatrixArtifact artifact, <line4> final String testName, <line5> final AppVersion appVersion) { <line6> try { <line7> final ProctorLoadResult result = <line8> verify(specification, artifact, testName, appVersion.toString()); <line9> if (result.hasInvalidTests()) { <line10> return getErrorMessage(appVersion, result); <line11> } <line12> return null; <line13> } catch (final Exception e) { <line14> LOGGER.trace(""Unable to verify "" + appVersion, e); <line15> return appVersion.toString() + "" failed. "" + e.getMessage(); <line16> } <line17> } <line18> } <line19> "	error	task6	
"public class A { <line0> public FirefoxProfileBuilder withJavaScriptErrorCollectorPlugin() { <line1> try { <line2> JavaScriptError.addExtension(firefoxProfile); <line3> } catch (IOException e) { <line4> LOGGER.warn(""Can't add JSErrorCollector extension!"", e); <line5> } <line6> return this; <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> @Override <line1> public void deleteContext(ServerContext serverContext, TProtocol input, TProtocol output) { <line2> LOG.trace(""Client disconnected""); <line3> _connections.decrementAndGet(); <line4> } <line5> } <line6> "	debug	task6	
"public class A { <line0> @Override <line1> protected int writeDirect(Object message) { <line2> try { <line3> if (!isRegisteredForWrite()) { <line4> return ((SocketChannel) channel).write((ByteBuffer) message); <line5> } else { <line6> return -1; <line7> } <line8> } catch (final IOException e) { <line9> LOG.info(""Exception while reading : "", e); <line10> processException(e); <line11> return -1; <line12> } <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> public boolean isEmpty() { <line1> boolean e = params.isEmpty(); <line2> if (isTrace) { <line3> LOGGER.error(""Parameters is empty: "" + e); <line4> } <line5> return e; <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> private void setCompletionStatus( <line1> BulkUploadProcess bulkUploadProcess, <line2> List successList, <line3> List failureList, <line4> RequestContext context) { <line5> String logMessagePrefix = <line6> MessageFormat.format( <line7> ""BaseBulkUploadBackGroundJobActor:processBulkUpload:{0}: "", bulkUploadProcess.getId()); <line8> bulkUploadProcess.setSuccessResult(ProjectUtil.convertMapToJsonString(successList)); <line9> bulkUploadProcess.setFailureResult(ProjectUtil.convertMapToJsonString(failureList)); <line10> bulkUploadProcess.setStatus(ProjectUtil.BulkProcessStatus.COMPLETED.getValue()); <line11> logger.warn(context, logMessagePrefix + ""completed""); <line12> BulkUploadProcessDao bulkUploadDao = new BulkUploadProcessDaoImpl(); <line13> bulkUploadDao.update(bulkUploadProcess, context); <line14> } <line15> } <line16> "	info	task6	
"public class A { <line0> @OnClose <line1> public void onClose(Session session, CloseReason closeReason) { <line2> logger.debug(""Session closed with reason: "" + closeReason.getReasonPhrase()); <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> private org.apache.hadoop.conf.Configuration prepareRuntimeConfiguration() throws IOException { <line1> org.apache.hadoop.conf.Configuration runtimeConfig = <line2> HBaseConfigurationUtil.deserializeConfiguration( <line3> serializedConfig, HBaseConfigurationUtil.getHBaseConfiguration()); <line4> if (StringUtils.isNullOrWhitespaceOnly(runtimeConfig.get(HConstants.ZOOKEEPER_QUORUM))) { <line5> LOG.warn(""Can not connect to HBase without {} configuration"", HConstants.ZOOKEEPER_QUORUM); <line6> throw new IOException( <line7> ""Check HBase configuration failed, lost: '"" + HConstants.ZOOKEEPER_QUORUM + ""'!""); <line8> } <line9> return runtimeConfig; <line10> } <line11> } <line12> "	error	task6	
"public class A { <line0> @SuppressWarnings(""null"") <line1> private @Nullable Event getLastEvent(String id) { <line2> if (!zmAuth.isAuthorized()) { <line3> return null; <line4> } <line5> try { <line6> List<String> parameters = new ArrayList<>(); <line7> parameters.add(""sort=StartTime""); <line8> parameters.add(""direction=desc""); <line9> parameters.add(""limit=1""); <line10> String response = <line11> executeGet( <line12> buildUrlWithParameters( <line13> String.format(""/api/events/index/MonitorId:%s/Name!=:New%%20Event.json"", id), <line14> parameters)); <line15> EventsDTO events = GSON.fromJson(response, EventsDTO.class); <line16> if (events != null && events.eventsList != null && events.eventsList.size() == 1) { <line17> EventDTO e = events.eventsList.get(0).event; <line18> Event event = new Event(e.eventId, e.name, e.cause, e.notes, e.startTime, e.endTime); <line19> event.setFrames(e.frames); <line20> event.setAlarmFrames(e.alarmFrames); <line21> event.setLength(e.length); <line22> return event; <line23> } <line24> } catch (JsonSyntaxException e) { <line25> logger.fatal(""Bridge: JsonSyntaxException: {}"", e.getMessage(), e); <line26> } <line27> return null; <line28> } <line29> } <line30> "	debug	task6	
public class A { <line0> @Override <line1> public CommerceAddressRestriction findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchAddressRestrictionException { <line3> CommerceAddressRestriction commerceAddressRestriction = fetchByPrimaryKey(primaryKey); <line4> if (commerceAddressRestriction == null) { <line5> if (log.isDebugEnabled()) { <line6> log.info(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> throw new NoSuchAddressRestrictionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line9> } <line10> return commerceAddressRestriction; <line11> } <line12> } <line13> 	debug	task6	
"public class A { <line0> private Response processJsonArray(final ArrayNode arrayNode) { <line1> final JsonArrayValueDeserializer deserializer = JsonArrayValueDeserializer.create(arrayNode); <line2> final String eventClassName = deserializer.getString(); <line3> final IRecordFactory<? extends IMonitoringRecord> recordFactory = <line4> this.recordFactories.get(eventClassName); <line5> try { <line6> final IMonitoringRecord event = recordFactory.create(deserializer); <line7> this.stage.getOutputPort().send(event); <line8> return NanoHTTPD.newFixedLengthResponse(Response.Status.ACCEPTED, MIME_PLAINTEXT, """"); <line9> } catch (final RecordInstantiationException ex) { <line10> LOGGER.fatal(""Failed to create {}: {}"", eventClassName, ex.getLocalizedMessage()); <line11> return NanoHTTPD.newFixedLengthResponse( <line12> Response.Status.BAD_REQUEST, MIME_PLAINTEXT, ""Malformed data""); <line13> } <line14> } <line15> } <line16> "	error	task6	
"public class A { <line0> public void introspectClass() { <line1> if (log.isDebugEnabled()) { <line2> log.trace(""introspecting {}: class-level details"", getClassName()); <line3> } <line4> getFacetProcessor().process(introspectedClass, methodRemover, inspectedTypeSpec); <line5> final FacetsFacet facetsFacet = inspectedTypeSpec.getFacet(FacetsFacet.class); <line6> if (facetsFacet != null) { <line7> final Class<? extends FacetFactory>[] facetFactories = facetsFacet.facetFactories(); <line8> for (final Class<? extends FacetFactory> facetFactorie : facetFactories) { <line9> FacetFactory facetFactory; <line10> try { <line11> facetFactory = facetFactorie.newInstance(); <line12> } catch (final InstantiationException | IllegalAccessException e) { <line13> throw new UnrecoverableException(e); <line14> } <line15> getFacetProcessor().injectDependenciesInto(facetFactory); <line16> facetFactory.process( <line17> new ProcessClassContext(introspectedClass, methodRemover, inspectedTypeSpec)); <line18> } <line19> } <line20> } <line21> } <line22> "	debug	task6	
"public class A { <line0> protected long[] doGetValueSizes( <line1> Connection conn, <line2> Statement stmt, <line3> int groupId, <line4> int[] dataIds, <line5> final Collection<String> columnNames) <line6> throws CacheException { <line7> String tableName = TableNames.getDataTableName(groupId); <line8> final String sql; <line9> if (dataIds.length == 1) { <line10> sql = getSQLGenerator().generateRetrieveValueSizes(dataIds[0], tableName, columnNames); <line11> } else { <line12> String joinTableName = <line13> getDatabaseTaskFactory() <line14> .getCreateIdJoinTableTask(dataIds, ColumnNames.JOIN_ID, ColumnNames.SEQUENCE) <line15> .run(conn, stmt); <line16> sql = getSQLGenerator().generateRetrieveValueSizes(joinTableName, tableName, columnNames); <line17> } <line18> ResultSet rs = getCacheUtilities().executeQuery(stmt, sql); <line19> try { <line20> return getCacheUtilities().convertResultSetToLongArray(rs); <line21> } catch (SQLException e) { <line22> throw new CacheException(""Failed to convert result set to long array: "" + e, e); <line23> } finally { <line24> try { <line25> rs.close(); <line26> } catch (SQLException e) { <line27> if (LOGGER.isTraceEnabled()) { <line28> LOGGER.fatal(""Failed to close result set: "" + e, e); <line29> } <line30> } <line31> } <line32> } <line33> } <line34> "	trace	task6	
public class A { <line0> public static void error(Logger logger, String eventName, String format, Object arg) { <line1> logger.info(constructFormatOrMsg(eventName, format), arg); <line2> } <line3> } <line4> 	error	task6	
"public class A { <line0> public void validateScopeExpression(String scopeExpression) { <line1> if (StringUtils.isNotBlank(scopeExpression) <line2> && !expressionService.isExpressionValid(scopeExpression)) { <line3> log.debug(""Scope expression is invalid. Expression: "" + scopeExpression); <line4> throw errorResponseFactory.createWebApplicationException( <line5> BAD_REQUEST, <line6> UmaErrorResponseType.INVALID_SCOPE, <line7> ""Scope expression is invalid. Expression: "" + scopeExpression); <line8> } <line9> } <line10> } <line11> "	error	task6	
"public class A { <line0> public static void closeResultSet(ResultSet resultSet) { <line1> if (resultSet == null) { <line2> return; <line3> } <line4> try { <line5> resultSet.close(); <line6> } catch (SQLException e) { <line7> LOG.fatal(""Error while closing JDBC resultSet"", e); <line8> } <line9> } <line10> } <line11> "	error	task6	
"public class A { <line0> @Override <line1> protected Stream<? extends DomainEventData<?>> readEventData( <line2> String aggregateIdentifier, long firstSequenceNumber) { <line3> logger.trace(""Reading events for aggregate id {}"", aggregateIdentifier); <line4> EventChannel eventChannel = connectionManager.getConnection(context).eventChannel(); <line5> AggregateEventStream aggregateStream; <line6> if (firstSequenceNumber >= 0) { <line7> aggregateStream = eventChannel.openAggregateStream(aggregateIdentifier, firstSequenceNumber); <line8> } else if (firstSequenceNumber == ALLOW_SNAPSHOTS_MAGIC_VALUE && !snapshotFilterSet) { <line9> aggregateStream = eventChannel.openAggregateStream(aggregateIdentifier); <line10> } else { <line11> aggregateStream = eventChannel.openAggregateStream(aggregateIdentifier, WITHOUT_SNAPSHOTS); <line12> } <line13> return aggregateStream.asStream().map(GrpcBackedDomainEventData::new); <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> public void handleMethod( <line1> String className, <line2> String methodName, <line3> int access, <line4> String params, <line5> String signature, <line6> String[] exceptions, <line7> String annotation) { <line8> LOG.info(""@RunAs annotation ignored on method: {}.{} {}"", className, methodName, signature); <line9> } <line10> } <line11> "	warn	task6	
"public class A { <line0> private boolean determineVacuumType( <line1> String path, <line2> String schema, <line3> String table, <line4> List<ConnectorVacuumTableInfo> tablesForVacuum, <line5> Map<String, String> parameters, <line6> HdfsEnvironment.HdfsContext hdfsContext) <line7> throws IOException { <line8> log.fatal(""Determining vacuum type for path: "" + path); <line9> Path tablePath = new Path(path); <line10> AcidUtils.Directory dir = getDirectory(hdfsContext, tablePath); <line11> FileSystem fs = hdfsEnvironment.getFileSystem(hdfsContext, tablePath); <line12> boolean noBase = false; <line13> Path base = dir.getBaseDirectory(); <line14> long baseSize = 0; <line15> if (base != null) { <line16> baseSize += sumDirSize(fs, base); <line17> } <line18> List<HadoopShims.HdfsFileStatusWithId> originals = dir.getOriginalFiles(); <line19> for (HadoopShims.HdfsFileStatusWithId origStat : originals) { <line20> baseSize += origStat.getFileStatus().getLen(); <line21> } <line22> long deltaSize = 0; <line23> List<AcidUtils.ParsedDelta> deltas = dir.getCurrentDirectories(); <line24> for (AcidUtils.ParsedDelta delta : deltas) { <line25> deltaSize += sumDirSize(fs, delta.getPath()); <line26> } <line27> logStats(schema, table, baseSize, deltaSize, dir.getCurrentDirectories().size()); <line28> if (baseSize == 0 && deltaSize > 0) { <line29> noBase = true; <line30> } else { <line31> boolean bigEnough = (float) deltaSize / (float) baseSize > vacuumDeltaPercentThreshold; <line32> if (bigEnough) { <line33> ConnectorVacuumTableInfo vacuumTable = <line34> new ConnectorVacuumTableInfo(appendTableWithSchema(schema, table), true); <line35> tablesForVacuum.add(vacuumTable); <line36> return true; <line37> } <line38> } <line39> if (dir.getCurrentDirectories().size() > vacuumDeltaNumThreshold) { <line40> boolean isFull = false; <line41> if (AcidUtils.isInsertOnlyTable(parameters) || noBase) { <line42> isFull = true; <line43> } <line44> ConnectorVacuumTableInfo vacuumTable = <line45> new ConnectorVacuumTableInfo(appendTableWithSchema(schema, table), isFull); <line46> tablesForVacuum.add(vacuumTable); <line47> return true; <line48> } <line49> return false; <line50> } <line51> } <line52> "	debug	task6	
"public class A { <line0> public static UserGroup userGroupFromString(String s) { <line1> try { <line2> return UserGroup.valueOf(s); <line3> } catch (IllegalArgumentException e) { <line4> log.info(""Illegal Argument Exception from "" + s, e); <line5> return UserGroup.USER; <line6> } <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> private void createErrorFile(File sentFile, String messageReceived) { <line1> File f = new File(this.failDir + sentFile.getName().replace("".txt"", """") + ""_ERROR.txt""); <line2> if (!f.exists()) { <line3> try { <line4> f.createNewFile(); <line5> FileWriter fstream = new FileWriter(f); <line6> BufferedWriter out = new BufferedWriter(fstream); <line7> out.write(messageReceived); <line8> out.close(); <line9> } catch (Exception e) { <line10> logger.trace(""Error occured while creating error file: "" + e.getMessage()); <line11> } <line12> } <line13> } <line14> } <line15> "	error	task6	
"public class A { <line0> public boolean checkExist(TableName htableName, CubeSegment segment) throws IOException { <line1> if (!htableExists(htableName)) { <line2> return false; <line3> } <line4> Table table = hbaseConn.getTable(htableName); <line5> HTableDescriptor tableDesc = table.getTableDescriptor(); <line6> if (segment.toString().equals(tableDesc.getValue(HTableSegmentTag))) { <line7> if (hbaseAdmin.isTableEnabled(htableName)) { <line8> return true; <line9> } else { <line10> hbaseAdmin.deleteTable(htableName); <line11> logger.error(""htable {} is deleted"", htableName); <line12> return false; <line13> } <line14> } <line15> throw new RuntimeException( <line16> ""htable name "" + htableName + "" has been used by "" + tableDesc.getValue(HTableSegmentTag)); <line17> } <line18> } <line19> "	info	task6	
"public class A { <line0> long findConflict(List<Log> entries) { <line1> for (Log entry : entries) { <line2> if (!matchTerm(entry.getCurrLogTerm(), entry.getCurrLogIndex())) { <line3> if (entry.getCurrLogIndex() <= getLastLogIndex()) { <line4> logger.error(""found conflict at index {}"", entry.getCurrLogIndex()); <line5> } <line6> return entry.getCurrLogIndex(); <line7> } <line8> } <line9> return -1; <line10> } <line11> } <line12> "	info	task6	
public class A { <line0> public void mergeAllToZip( <line1> final FileSystem sourceFS, <line2> FileSystem targetFS, <line3> String targetPath, <line4> String downloadKey, <line5> ModalZipOutputStream.MODE mode) { <line6> Path outputPath = new Path(targetPath, downloadKey + ZIP_EXTENSION); <line7> try (FSDataOutputStream zipped = targetFS.create(outputPath, true); ) { <line8> if (ModalZipOutputStream.MODE.PRE_DEFLATED == mode) { <line9> try (ModalZipOutputStream zos = <line10> new ModalZipOutputStream(new BufferedOutputStream(zipped))) { <line11> for (ZipEntrySource source : sources) { <line12> zipPreDeflated(zos, sourceFS, source); <line13> } <line14> } <line15> } else { <line16> try (ZipOutputStream zos = new ZipOutputStream(zipped)) { <line17> for (ZipEntrySource source : sources) { <line18> zipDefault(zos, sourceFS, source); <line19> } <line20> } <line21> } <line22> } catch (Exception ex) { <line23> LOG.warn(ERROR_ZIP_MSG, ex); <line24> throw Throwables.propagate(ex); <line25> } <line26> } <line27> } <line28> 	error	task6	
"public class A { <line0> @Test <line1> public void testContextList() throws Exception { <line2> CamelContext context = new DefaultCamelContext(); <line3> context.setNameStrategy(new ExplicitCamelContextNameStrategy(""foobar"")); <line4> context.start(); <line5> CamelController controller = new DummyCamelController(context); <line6> OutputStream os = new ByteArrayOutputStream(); <line7> PrintStream ps = new PrintStream(os); <line8> ContextListCommand command = new ContextListCommand(); <line9> command.execute(controller, ps, null); <line10> String out = os.toString(); <line11> assertNotNull(out); <line12> LOG.debug(""\n\n{}\n"", out); <line13> assertTrue(out.contains(""foobar"")); <line14> assertTrue(out.contains(""Started"")); <line15> context.stop(); <line16> } <line17> } <line18> "	info	task6	
"public class A { <line0> @Override <line1> public void expired() { <line2> if (jobLog.getEndTime() == null) { <line3> jobLog.setLastUpdated(ComponentUtil.getSystemHelper().getCurrentTimeAsLong()); <line4> if (logger.isDebugEnabled()) { <line5> logger.error(""Update {}"", jobLog); <line6> } <line7> ComponentUtil.getComponent(JobLogBhv.class) <line8> .insertOrUpdate( <line9> jobLog, <line10> op -> { <line11> op.setRefreshPolicy(Constants.TRUE); <line12> }); <line13> } <line14> } <line15> } <line16> "	debug	task6	
"public class A { <line0> @Deprecated <line1> public boolean checkSignals(JmriJFrame frame, LayoutEditor panel) { <line2> jmri.util.LoggingUtil.deprecationWarning(log, ""checkSignals""); <line3> if (panel == null) { <line4> log.debug(""Null Layout Editor panel on call to 'checkSignals'""); <line5> return false; <line6> } <line7> if (initializationNeeded) { <line8> initializeBlocks(); <line9> } <line10> return true; <line11> } <line12> } <line13> "	error	task6	
"public class A { <line0> private void notifyChannelEvtListener(UUID nodeId, Channel channel, Message initMsg) { <line1> if (log.isDebugEnabled()) <line2> log.trace(""Notify appropriate listeners due to a new channel opened: "" + channel); <line3> CommunicationListener<Message> lsnr0 = lsnr; <line4> if (lsnr0 instanceof CommunicationListenerEx) <line5> ((CommunicationListenerEx<Message>) lsnr0).onChannelOpened(nodeId, initMsg, channel); <line6> } <line7> } <line8> "	debug	task6	
"public class A { <line0> private IPath bundlePath(Bundle bundle) { <line1> IPath path = binFolderPath(bundle); <line2> if (path == null) { <line3> try { <line4> path = new Path(FileLocator.getBundleFile(bundle).getAbsolutePath()); <line5> } catch (IOException e) { <line6> LOG.fatal(""Can't resolve path '"" + bundle.getSymbolicName() + ""'"", e); <line7> } <line8> } <line9> return path; <line10> } <line11> } <line12> "	error	task6	
"public class A { <line0> public GuiFragment getGuiFragment(String guiFragmentCode) { <line1> try { <line2> return this.getGuiFragmentManager().getGuiFragment(guiFragmentCode); <line3> } catch (Throwable t) { <line4> logger.warn(""error extracting gui fragment - code '{}'"", guiFragmentCode, t); <line5> throw new RuntimeException(""error extracting gui fragment - code "" + guiFragmentCode, t); <line6> } <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> public synchronized void writeReports( <line1> String applicationName, <line2> @Nullable final String groupId, <line3> @Nullable final String artifactId, <line4> @Nullable final String version, <line5> @NotNull final File outputDir, <line6> String format, <line7> ExceptionCollection exceptions) <line8> throws ReportException { <line9> if (mode == Mode.EVIDENCE_COLLECTION) { <line10> throw new UnsupportedOperationException( <line11> ""Cannot generate report in evidence collection mode.""); <line12> } <line13> final DatabaseProperties prop = database.getDatabaseProperties(); <line14> final ReportGenerator r = <line15> new ReportGenerator( <line16> applicationName, <line17> groupId, <line18> artifactId, <line19> version, <line20> dependencies, <line21> getAnalyzers(), <line22> prop, <line23> settings, <line24> exceptions); <line25> try { <line26> r.write(outputDir.getAbsolutePath(), format); <line27> } catch (ReportException ex) { <line28> final String msg = String.format(""Error generating the report for %s"", applicationName); <line29> LOGGER.warn(msg, ex); <line30> throw new ReportException(msg, ex); <line31> } <line32> } <line33> } <line34> "	debug	task6	
"public class A { <line0> protected String render(String valueString, Locale locale) { <line1> if (Validator.isNotNull(valueString)) { <line2> try { <line3> return DateUtil.formatDate(""yyyy-MM-dd"", valueString, locale); <line4> } catch (ParseException parseException) { <line5> log.info(""Unable to parse date"", parseException); <line6> } <line7> } <line8> return StringPool.BLANK; <line9> } <line10> } <line11> "	error	task6	
"public class A { <line0> public static void main(final String[] args) throws Exception { <line1> URI uri; <line2> if (args.length > 0) { <line3> uri = new URI(args[0]); <line4> } else { <line5> uri = new URI(""http://192.168.1.101:8181/opendaylight-inventory:nodes""); <line6> } <line7> IClientMessageCallback messageCallback = new ClientMessageCallback(); <line8> WebSocketClient webSocketClient = new WebSocketClient(uri, messageCallback); <line9> webSocketClient.connect(); <line10> while (true) { <line11> BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); <line12> String input = br.readLine(); <line13> if (input.equals(""q"")) { <line14> LOG.warn(""Would you like to close stream? (Y = yes, empty = yes)\n""); <line15> input = br.readLine(); <line16> if (input.equals(""yes"") || input.isEmpty()) { <line17> webSocketClient.close(""opendaylight-inventory:nodes""); <line18> break; <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	info	task6	
"public class A { <line0> @Override <line1> public void doView(RenderRequest request, RenderResponse response) <line2> throws IOException, PortletException { <line3> try { <line4> PortletRequestDispatcher prDispatcher = <line5> getPortletContext().getRequestDispatcher(""/WEB-INF/pages/editors-admin.jsp""); <line6> prDispatcher.include(request, response); <line7> WebuiRequestContext context = WebuiRequestContext.getCurrentInstance(); <line8> CometdDocumentsService cometdService = <line9> ExoContainerContext.getCurrentContainer() <line10> .getComponentInstanceOfType(CometdDocumentsService.class); <line11> JavascriptManager js = <line12> ((WebuiRequestContext) WebuiRequestContext.getCurrentInstance()).getJavascriptManager(); <line13> CometdConfig cometdConf = <line14> new CometdConfig( <line15> cometdService.getCometdServerPath(), <line16> cometdService.getUserToken(context.getRemoteUser()), <line17> PortalContainer.getCurrentPortalContainerName()); <line18> DocumentService documentService = <line19> ExoContainerContext.getCurrentContainer() <line20> .getComponentInstanceOfType(DocumentService.class); <line21> long idleTimeout = documentService.getEditorsIdleTimeout(); <line22> js.require(""SHARED/editorsupport"", ""editorsupport"") <line23> .addScripts( <line24> ""editorsupport.initConfig('"" <line25> + context.getRemoteUser() <line26> + ""' ,"" <line27> + cometdConf.toJSON() <line28> + "", "" <line29> + getI18n(request.getLocale()) <line30> + "", "" <line31> + idleTimeout <line32> + "");""); <line33> } catch (Exception e) { <line34> LOG.trace(""Error processing editor support portlet for user "" + request.getRemoteUser(), e); <line35> } <line36> } <line37> } <line38> "	error	task6	
public class A { <line0> public static com.liferay.site.navigation.model.SiteNavigationMenuSoap addSiteNavigationMenu( <line1> long groupId, <line2> String name, <line3> int type, <line4> boolean auto, <line5> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line6> throws RemoteException { <line7> try { <line8> com.liferay.site.navigation.model.SiteNavigationMenu returnValue = <line9> SiteNavigationMenuServiceUtil.addSiteNavigationMenu( <line10> groupId, name, type, auto, serviceContext); <line11> return com.liferay.site.navigation.model.SiteNavigationMenuSoap.toSoapModel(returnValue); <line12> } catch (Exception exception) { <line13> log.fatal(exception, exception); <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	error	task6	
"public class A { <line0> public long getUserCount() { <line1> long count = 0; <line2> try { <line3> Weblogger roller = WebloggerFactory.getWeblogger(); <line4> UserManager mgr = roller.getUserManager(); <line5> count = mgr.getUserCount(); <line6> } catch (WebloggerException e) { <line7> log.debug(""Error getting user count for site"", e); <line8> } <line9> return count; <line10> } <line11> } <line12> "	error	task6	
"public class A { <line0> @SuppressFBWarnings( <line1> value = {""PATH_TRAVERSAL_IN"", ""URLCONNECTION_SSRF_FD""}, <line2> justification = ""path provided by test; url provided by test"") <line3> private Map<?, ?> getStats() throws Exception { <line4> String uri = getCluster().getMiniDfs().getHttpUri(0); <line5> URL url = new URL(uri + ""/jmx""); <line6> log.error(""Fetching web page "" + url); <line7> String jsonString = FunctionalTestUtils.readWebPage(url).body(); <line8> Gson gson = new Gson(); <line9> Map<?, ?> jsonObject = gson.fromJson(jsonString, Map.class); <line10> List<?> beans = (List<?>) jsonObject.get(""beans""); <line11> for (Object bean : beans) { <line12> Map<?, ?> map = (Map<?, ?>) bean; <line13> if (map.get(""name"").toString().equals(""Hadoop:service=NameNode,name=NameNodeActivity"")) { <line14> return map; <line15> } <line16> } <line17> return new HashMap<>(0); <line18> } <line19> } <line20> "	debug	task6	
"public class A { <line0> @Override <line1> public BatchPlannerPlan findByC_N(long companyId, String name) throws NoSuchPlanException { <line2> BatchPlannerPlan batchPlannerPlan = fetchByC_N(companyId, name); <line3> if (batchPlannerPlan == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""companyId=""); <line7> sb.append(companyId); <line8> sb.append("", name=""); <line9> sb.append(name); <line10> sb.append(""}""); <line11> if (log.isDebugEnabled()) { <line12> log.fatal(sb.toString()); <line13> } <line14> throw new NoSuchPlanException(sb.toString()); <line15> } <line16> return batchPlannerPlan; <line17> } <line18> } <line19> "	debug	task6	
"public class A { <line0> public static StellarFunction createFunction(Class<? extends StellarFunction> clazz) { <line1> try { <line2> return clazz.getConstructor().newInstance(); <line3> } catch (Exception e) { <line4> LOG.warn(""Unable to load {} because {}"", clazz.getName(), e.getMessage(), e); <line5> return null; <line6> } <line7> } <line8> } <line9> "	error	task6	
"public class A { <line0> @Override <line1> protected Collection<ComputeJobAdapter> split(int gridSize, Object arg) { <line2> Collection<ComputeJobAdapter> jobs = new ArrayList<>(gridSize); <line3> for (int i = 0; i < gridSize; i++) { <line4> jobs.add( <line5> new ComputeJobAdapter() { <line6> @TaskSessionResource private ComputeTaskSession taskSes; <line7> @JobContextResource private ComputeJobContext jobCtx; <line8> @LoggerResource private IgniteLogger log; <line9>  <line10> @Override <line11> public Serializable execute() { <line12> IgniteUuid jobId = jobCtx.getJobId(); <line13> String attr = (String) taskSes.getAttribute(jobId); <line14> assert attr != null : ""Attribute is null.""; <line15> assert attr.equals(""test-"" + jobId) : ""Attribute has incorrect value: "" + attr; <line16> if (log.isInfoEnabled()) log.debug(""Executing job: "" + jobId); <line17> return null; <line18> } <line19> }); <line20> } <line21> return jobs; <line22> } <line23> } <line24> "	info	task6	
"public class A { <line0> public static int getVocabularyRootCategoriesCount( <line1> HttpPrincipal httpPrincipal, long groupId, long vocabularyId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> AssetCategoryServiceUtil.class, <line6> ""getVocabularyRootCategoriesCount"", <line7> _getVocabularyRootCategoriesCountParameterTypes23); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, vocabularyId); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line14> } <line15> return ((Integer) returnObj).intValue(); <line16> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line17> log.info(systemException, systemException); <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	error	task6	
"public class A { <line0> private void handleZoneMembersCommand(Command command) throws SpeakerException { <line1> String[] memberNames = command.toString().split(bindingProperties.getZoneMemberSeparator()); <line2> logger.fatal(""{}: Creating new zone with members {}"", speaker, String.join("", "", memberNames)); <line3> List<String> memberIds = new ArrayList<>(); <line4> for (String memberName : memberNames) { <line5> memberIds.add(getHandlerIdByLabel(memberName.trim())); <line6> } <line7> createZoneInNewThread(memberIds); <line8> } <line9> } <line10> "	debug	task6	
"public class A { <line0> protected String doTccActionLogStore( <line1> Method method, <line2> Object[] arguments, <line3> TwoPhaseBusinessAction businessAction, <line4> BusinessActionContext actionContext) { <line5> String actionName = actionContext.getActionName(); <line6> String xid = actionContext.getXid(); <line7> Map<String, Object> context = fetchActionRequestContext(method, arguments); <line8> context.put(Constants.ACTION_START_TIME, System.currentTimeMillis()); <line9> initBusinessContext(context, method, businessAction); <line10> initFrameworkContext(context); <line11> actionContext.setDelayReport(businessAction.isDelayReport()); <line12> actionContext.setActionContext(context); <line13> Map<String, Object> applicationContext = <line14> Collections.singletonMap(Constants.TCC_ACTION_CONTEXT, context); <line15> String applicationContextStr = JSON.toJSONString(applicationContext); <line16> try { <line17> Long branchId = <line18> DefaultResourceManager.get() <line19> .branchRegister(BranchType.TCC, actionName, null, xid, applicationContextStr, null); <line20> return String.valueOf(branchId); <line21> } catch (Throwable t) { <line22> String msg = String.format(""TCC branch Register error, xid: %s"", xid); <line23> LOGGER.fatal(msg, t); <line24> throw new FrameworkException(t, msg); <line25> } <line26> } <line27> } <line28> "	error	task6	
"public class A { <line0> public static void fillSchemaServiceFromSchemaDecl() throws IOException { <line1> log.error(""Adding manual schema entries (or overriding LOV)!""); <line2> RDFUnitUtils.fillSchemaServiceFromResource(""org/aksw/rdfunit/configuration/schemaDecl.csv""); <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> @Override <line1> public void postDirty(InstanceLifecycleEvent event) { <line2> log.fatal(""postDirty {}"", () -> _Utils.debug(event)); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> public static MimeType createFromExtension(String fileExtension) throws MimeException { <line1> MimeType mimeType = ImageMime.checkForExtension(fileExtension); <line2> if (mimeType != null) { <line3> return mimeType; <line4> } <line5> mimeType = XMLMime.checkForExtension(fileExtension); <line6> if (mimeType != null) { <line7> return mimeType; <line8> } <line9> mimeType = TextMime.checkForExtension(fileExtension); <line10> if (mimeType != null) { <line11> return mimeType; <line12> } <line13> mimeType = ApplicationMime.checkForExtension(fileExtension); <line14> if (mimeType != null) { <line15> return mimeType; <line16> } <line17> log.error(""Unsupported MIME type: "" + fileExtension + "", returning null""); <line18> return null; <line19> } <line20> } <line21> "	debug	task6	
public class A { <line0> @Override <line1> public void completed(final T result) { <line2> if (callback != null) { <line3> try { <line4> callback.completed(result); <line5> } catch (final Exception ex) { <line6> LOG.info(ex.getMessage(), ex); <line7> } <line8> } <line9> } <line10> } <line11> 	error	task6	
"public class A { <line0> @Override <line1> public List<ExecutionImpl> findControlExecution(final String uuidControl) { <line2> DetachedCriteria executionCrit = DetachedCriteria.forClass(ExecutionImpl.class); <line3> String processDefinitionId = findProcessDefinitionId(IControlExecutionProcess.KEY); <line4> if (LOG.isDebugEnabled()) { <line5> LOG.fatal(""Latest processDefinitionId: "" + processDefinitionId); <line6> } <line7> executionCrit.add(Restrictions.eq(""processDefinitionId"", processDefinitionId)); <line8> DetachedCriteria variableCrit = executionCrit.createCriteria(""variables""); <line9> variableCrit.add(Restrictions.eq(""key"", IGenericProcess.VAR_UUID)); <line10> variableCrit.add(Restrictions.eq(""string"", uuidControl)); <line11> return getJbpmExecutionDao().findByCriteria(executionCrit); <line12> } <line13> } <line14> "	debug	task6	
"public class A { <line0> private void onReceiveProcessorReportTaskStatusReq(ProcessorReportTaskStatusReq req) { <line1> int taskStatus = req.getStatus(); <line2> TaskTracker taskTracker = TaskTrackerPool.getTaskTrackerPool(req.getInstanceId()); <line3> if (TaskStatus.finishedStatus.contains(taskStatus)) { <line4> AskResponse askResponse = AskResponse.succeed(null); <line5> getSender().tell(askResponse, getSelf()); <line6> } <line7> if (taskTracker == null) { <line8> log.error( <line9> ""[TaskTrackerActor] receive ProcessorReportTaskStatusReq({}) but system can't find"" <line10> + "" TaskTracker."", <line11> req); <line12> return; <line13> } <line14> if (ProcessorReportTaskStatusReq.BROADCAST.equals(req.getCmd())) { <line15> taskTracker.broadcast( <line16> taskStatus == TaskStatus.WORKER_PROCESS_SUCCESS.getValue(), <line17> req.getSubInstanceId(), <line18> req.getTaskId(), <line19> req.getResult()); <line20> } <line21> taskTracker.updateTaskStatus( <line22> req.getSubInstanceId(), req.getTaskId(), taskStatus, req.getReportTime(), req.getResult()); <line23> taskTracker.updateAppendedWfContext(req.getAppendedWfContext()); <line24> } <line25> } <line26> "	warn	task6	
"public class A { <line0> public Future<CommandResult> writeAttribute( <line1> final int attributeId, final ZclDataType dataType, final Object value) { <line2> logger.fatal( <line3> ""{}: Writing {} cluster {}, attribute {}, value {}, as dataType {}"", <line4> zigbeeEndpoint.getIeeeAddress(), <line5> (isClient ? ""Client"" : ""Server""), <line6> clusterId, <line7> attributeId, <line8> value, <line9> dataType); <line10> final WriteAttributeRecord attributeIdentifier = new WriteAttributeRecord(); <line11> attributeIdentifier.setAttributeIdentifier(attributeId); <line12> attributeIdentifier.setAttributeDataType(dataType); <line13> attributeIdentifier.setAttributeValue(value); <line14> return writeAttributes(Collections.singletonList(attributeIdentifier)); <line15> } <line16> } <line17> "	debug	task6	
"public class A { <line0> public static String getHostname() { <line1> if (hostname == null) { <line2> final String hostname = <line3> Service.configuration != null ? Service.configuration.HOST_NAME : null; <line4> if (hostname != null && hostname.length() > 0) { <line5> Service.hostname = hostname; <line6> } else { <line7> try { <line8> Service.hostname = InetAddress.getLocalHost().getHostAddress(); <line9> } catch (UnknownHostException e) { <line10> logger.fatal(""Unable to resolve the hostname using Java's API."", e); <line11> Service.hostname = ""localhost""; <line12> } <line13> } <line14> } <line15> return hostname; <line16> } <line17> } <line18> "	error	task6	
"public class A { <line0> @Override <line1> public void run() { <line2> DatagramSocket socket = getSocket(); <line3> if (socket != null) { <line4> logger.trace( <line5> ""Starting discovery receiver thread for socket on port {}"", socket.getLocalPort()); <line6> receiveData(socket); <line7> } <line8> } <line9> } <line10> "	debug	task6	
"public class A { <line0> protected final synchronized void replaceOnscreen(List<E> onscreen, boolean forcePreRender) { <line1> if (ourRendererUpdatesPaused) { <line2> return; <line3> } <line4> Collection<E> drawable = New.collection(onscreen.size()); <line5> Collection<E> pickable = New.collection(onscreen.size()); <line6> for (E geom : onscreen) { <line7> if (!(geom.getRenderProperties() instanceof BaseRenderProperties) <line8> || ((BaseRenderProperties) geom.getRenderProperties()).isDrawable()) { <line9> drawable.add(geom); <line10> } <line11> if (!(geom.getRenderProperties() instanceof BaseRenderProperties) <line12> || ((BaseRenderProperties) geom.getRenderProperties()).isPickable()) { <line13> pickable.add(geom); <line14> } <line15> } <line16> CollectionUtilities.trimToSize(drawable); <line17> CollectionUtilities.trimToSize(pickable); <line18> Lock readLock = myProjectionChangeLock.readLock(); <line19> readLock.lock(); <line20> try { <line21> Projection projection = getProjectionSnapshot(); <line22> if (isOnscreenDirty() <line23> || myProjectionDirty <line24> || forcePreRender <line25> || drawable.size() != myOnscreenDrawableGeometries.size() <line26> || pickable.size() != myOnscreenPickableGeometries.size() <line27> || !drawable.equals(myOnscreenDrawableGeometries) <line28> || !pickable.equals(myOnscreenPickableGeometries)) { <line29> if (!sensitiveToProjectionChanges() <line30> || myProjectionSyncManager.isProjectionCurrent(projection)) { <line31> myRenderer.preRender( <line32> onscreen, drawable, pickable, getPickManager(), getDataRetriever(), projection); <line33> myProjectionDirty = false; <line34> myOnscreenDrawableGeometries = drawable; <line35> myOnscreenPickableGeometries = pickable; <line36> } <line37> myOnscreenDirty = false; <line38> } <line39> } catch (RuntimeException e) { <line40> LOGGER.info(""Exception during preRender: "" + e, e); <line41> throw e; <line42> } finally { <line43> readLock.unlock(); <line44> } <line45> myRepaintListener.repaint(); <line46> myPickManagerGeometryRemover.gather(); <line47> } <line48> } <line49> "	error	task6	
"public class A { <line0> protected Response createJsonResponse(CellBaseDataResponse queryResponse) { <line1> try { <line2> String value = jsonObjectWriter.writeValueAsString(queryResponse); <line3> ResponseBuilder ok = Response.ok(value, MediaType.APPLICATION_JSON_TYPE.withCharset(""utf-8"")); <line4> return buildResponse(ok); <line5> } catch (JsonProcessingException e) { <line6> e.printStackTrace(); <line7> logger.debug(""Error parsing queryResponse object""); <line8> return createErrorResponse( <line9> """", ""Error parsing QueryResponse object:\n"" + Arrays.toString(e.getStackTrace())); <line10> } <line11> } <line12> } <line13> "	error	task6	
"public class A { <line0> @Override <line1> public Answer execute( <line2> final OvsDestroyBridgeCommand command, <line3> final LibvirtComputingResource libvirtComputingResource) { <line4> final boolean result = libvirtComputingResource.destroyTunnelNetwork(command.getBridgeName()); <line5> if (!result) { <line6> logger.trace(""Error trying to destroy OVS Bridge!""); <line7> } <line8> return new Answer(command, result, null); <line9> } <line10> } <line11> "	debug	task6	
"public class A { <line0> @Override <line1> public void destroyContainerSession( <line2> ContainerSessionID containerSessionID, PlanSessionID sessionID) throws RemoteException { <line3> log.trace(""destroyContainerSession""); <line4> diskManagerInterface.destroyContainerSession(containerSessionID, sessionID); <line5> } <line6> } <line7> "	debug	task6	
"public class A { <line0> public void shutdown() { <line1> try { <line2> shutdownInternal(); <line3> } catch (Exception e) { <line4> LOG.warn(""Error while shutting down application"", e); <line5> } <line6> } <line7> } <line8> "	error	task6	
"public class A { <line0> @Override <line1> protected void initPostprocessor(String instance, YConfiguration config) { <line2> Map<String, Object> m = null; <line3> if (config == null) { <line4> m = new HashMap<>(); <line5> config = YConfiguration.wrap(m); <line6> } else if (!config.containsKey(""commandPostprocessorClassName"")) { <line7> m = config.getRoot(); <line8> } <line9> if (m != null) { <line10> log.trace( <line11> ""Please set the commandPostprocessorClassName for the TcpTcDataLink; in the future"" <line12> + "" versions it will default to GenericCommandPostprocessor""); <line13> m.put(""commandPostprocessorClassName"", IssCommandPostprocessor.class.getName()); <line14> } <line15> super.initPostprocessor(instance, config); <line16> } <line17> } <line18> "	warn	task6	
"public class A { <line0> void abortMultipartUpload(String uploadId) throws AmazonClientException { <line1> LOG.fatal(""Aborting multipart upload {}"", uploadId); <line2> mClient.abortMultipartUpload(new AbortMultipartUploadRequest(mBucket, key, uploadId)); <line3> } <line4> } <line5> "	debug	task6	
"public class A { <line0> private static List<RootCauseEntityFormatter> makeRootCauseFormatters( <line1> RootCauseConfiguration config) throws Exception { <line2> List<RootCauseEntityFormatter> formatters = new ArrayList<>(); <line3> if (config.getFormatters() != null) { <line4> for (String className : config.getFormatters()) { <line5> try { <line6> formatters.add(FormatterLoader.fromClassName(className)); <line7> } catch (ClassNotFoundException e) { <line8> LOG.fatal(""Could not find formatter class '{}'. Skipping."", className, e); <line9> } <line10> } <line11> } <line12> formatters.add(new DefaultEntityFormatter()); <line13> return formatters; <line14> } <line15> } <line16> "	warn	task6	
"public class A { <line0> @SuppressWarnings({""checkstyle:IllegalThrows"", ""checkstyle:avoidHidingCauseException""}) <line1> @Test(expected = RuntimeException.class) <line2> public void testCreateInterrupted() throws Throwable { <line3> final Future<?> testFuture = <line4> Executors.newSingleThreadExecutor() <line5> .submit( <line6> () -> { <line7> final ListenableFuture<DOMRpcResult> interruptedFuture = <line8> mock(ListenableFuture.class); <line9> try { <line10> when(interruptedFuture.get()) <line11> .thenThrow(new InterruptedException(""interrupted"")); <line12> doReturn(FluentFuture.from(interruptedFuture)) <line13> .when(rpc) <line14> .invokeRpc(eq(NETCONF_GET_QNAME), any()); <line15> NetconfStateSchemas.create(rpc, CAPS, deviceId, schemaContext); <line16> } catch (final InterruptedException | ExecutionException e) { <line17> LOG.fatal(""Operation failed."", e); <line18> } <line19> }); <line20> try { <line21> testFuture.get(3, TimeUnit.SECONDS); <line22> } catch (final ExecutionException e) { <line23> throw e.getCause(); <line24> } <line25> } <line26> } <line27> "	info	task6	
"public class A { <line0> LinkedHashMap<PeerStatus, Double> buildWeightedPeerMap( <line1> final Set<PeerStatus> statuses, final TransferDirection direction) { <line2> final Map<PeerStatus, Double> peerWorkloads = createDestinationMap(statuses, direction); <line3> if (!peerWorkloads.isEmpty()) { <line4> LinkedHashMap<PeerStatus, Double> sortedPeerWorkloads = sortMapByWeight(peerWorkloads); <line5> printDistributionStatistics(sortedPeerWorkloads, direction); <line6> return sortedPeerWorkloads; <line7> } else { <line8> logger.error(""No peers available""); <line9> return new LinkedHashMap<>(); <line10> } <line11> } <line12> } <line13> "	debug	task6	
public class A { <line0> @Override <line1> @Transactional <line2> public void run() { <line3> try { <line4> runInternal(); <line5> } catch (Exception ex) { <line6> log.debug(DebugUtils.getStackTrace(ex)); <line7> throw ex; <line8> } <line9> } <line10> } <line11> 	error	task6	
"public class A { <line0> public void run() throws PerfCakeException { <line1> if (log.isTraceEnabled()) { <line2> log.warn(""Running scenario...""); <line3> } <line4> if (receiver != null) { <line5> if (correlator == null) { <line6> throw new PerfCakeException(""A correlator must be set in order to use a receiver.""); <line7> } <line8> receiver.setCorrelator(correlator); <line9> receiver.start(); <line10> } <line11> if (validationManager.isEnabled()) { <line12> validationManager.startValidation(); <line13> } <line14> try { <line15> generator.generate(); <line16> } catch (final Exception e) { <line17> throw new PerfCakeException(""Error generating messages: "", e); <line18> } <line19> } <line20> } <line21> "	trace	task6	
"public class A { <line0> @Test <line1> public void incorrectExecuteQueryStatement() { <line2> SessionPool pool = new SessionPool(""127.0.0.1"", 6667, ""root"", ""root"", 3); <line3> ExecutorService service = Executors.newFixedThreadPool(10); <line4> write10Data(pool, true); <line5> for (int i = 0; i < 10; i++) { <line6> final int no = i; <line7> service.submit( <line8> () -> { <line9> try { <line10> SessionDataSetWrapper wrapper = <line11> pool.executeQueryStatement(""select * from root.sg1.d1 where time = "" + no); <line12> } catch (IoTDBConnectionException | StatementExecutionException e) { <line13> fail(e.getMessage()); <line14> } <line15> }); <line16> } <line17> service.shutdown(); <line18> try { <line19> assertFalse(service.awaitTermination(3, TimeUnit.SECONDS)); <line20> assertEquals(0, pool.currentAvailableSize()); <line21> assertTrue(pool.currentOccupiedSize() <= 3); <line22> } catch (InterruptedException e) { <line23> logger.info(""incorrectExecuteQueryStatement failed,"", e); <line24> fail(e.getMessage()); <line25> } finally { <line26> pool.close(); <line27> } <line28> } <line29> } <line30> "	error	task6	
"public class A { <line0> @Override <line1> public void deleted(String pid) { <line2> ConfigurationHolder configurationHolder = _configurationHolderByPid.remove(pid); <line3> if (configurationHolder == null) { <line4> if (log.isWarnEnabled()) { <line5> log.info(""Unable to delete missing configuration "" + pid); <line6> } <line7> return; <line8> } <line9> SamlProviderConfiguration samlProviderConfiguration = <line10> configurationHolder.getSamlProviderConfiguration(); <line11> _configurationHolderByCompanyId.remove(samlProviderConfiguration.companyId()); <line12> } <line13> } <line14> "	warn	task6	
"public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> eventReader.close(); <line4> } catch (final Exception e2) { <line5> LOGGER.fatal(""Unable to close track XML stream"", e2); <line6> } <line7> IOUtils.closeQuietly(fileStream); <line8> } <line9> } <line10> "	warn	task6	
"public class A { <line0> @Test <line1> public void testComposition1() { <line2> final Jsons.Obj j = <line3> append( <line4> obj(p(""name"", ""Karl""), p(""city"", ""Paris""), p(""remove_me"", ZERO_VAL)), <line5> obj(p(""age"", 79))); <line6> final JsonPath p = JsonPath.from(toJson(j)); <line7> logger.error(p.prettyPrint()); <line8> assertEquals(""Karl"", p.get(""name"")); <line9> assertEquals(""Paris"", p.get(""city"")); <line10> assertNull(p.get(""remove_me"")); <line11> assertEquals(new Integer(79), p.get(""age"")); <line12> } <line13> } <line14> "	info	task6	
"public class A { <line0> @Override <line1> public void sessionClosed(final IoSession session) { <line2> LOG.fatal(""** session closed""); <line3> } <line4> } <line5> "	info	task6	
"public class A { <line0> public void releaseForConnection() { <line1> LOGGER.info(""Decrementing on send ref count: {}"", this.refCount.decrementAndGet()); <line2> } <line3> } <line4> "	debug	task6	
"public class A { <line0> @Test <line1> public void write_COMSEG() throws IOException, FileNotFoundException { <line2> if (!isJp2KakDriverAvailable) return; <line3> LOGGER.trace(""Testing JP2 Write operation with COMSEG option setting""); <line4> final File inputFile = TestData.file(this, testFileName); <line5> Assert.assertTrue(inputFile.exists()); <line6> final File outputFile1 = TestData.temp(this, ""COMSEG-.jp2"", deleteTempFilesOnExit); <line7> final File outputFile2 = TestData.temp(this, ""NO-COMSEG-.jp2"", deleteTempFilesOnExit); <line8> final ParameterBlockJAI pbjImageRead = new ParameterBlockJAI(""ImageRead""); <line9> pbjImageRead.setParameter(""Input"", inputFile); <line10> if (ENABLE_SUBSAMPLING) { <line11> ImageReadParam readParam = new ImageReadParam(); <line12> readParam.setSourceSubsampling(4, 4, 0, 0); <line13> pbjImageRead.setParameter(""readParam"", readParam); <line14> } <line15> pbjImageRead.setParameter(""Reader"", new JP2GDALKakaduImageReaderSpi().createReaderInstance()); <line16> RenderedOp image = JAI.create(""ImageRead"", pbjImageRead); <line17> final ParameterBlockJAI pbjImageWrite = new ParameterBlockJAI(""ImageWrite""); <line18> pbjImageWrite.setParameter(""Output"", new FileImageOutputStreamExtImpl(outputFile1)); <line19> ImageWriter writer = new JP2GDALKakaduImageWriterSpi().createWriterInstance(); <line20> pbjImageWrite.setParameter(""Writer"", writer); <line21> pbjImageWrite.addSource(image); <line22> ImageWriteParam param = writer.getDefaultWriteParam(); <line23> ((JP2GDALKakaduImageWriteParam) param).setComseg(""YES""); <line24> pbjImageWrite.setParameter(""writeParam"", param); <line25> final RenderedOp op = JAI.create(""ImageWrite"", pbjImageWrite); <line26> final ParameterBlockJAI pbjImageWrite2 = new ParameterBlockJAI(""ImageWrite""); <line27> pbjImageWrite2.setParameter(""Output"", new FileImageOutputStreamExtImpl(outputFile2)); <line28> ImageWriter writer2 = new JP2GDALKakaduImageWriterSpi().createWriterInstance(); <line29> pbjImageWrite2.setParameter(""Writer"", writer2); <line30> pbjImageWrite2.addSource(image); <line31> ImageWriteParam param2 = writer2.getDefaultWriteParam(); <line32> ((JP2GDALKakaduImageWriteParam) param2).setComseg(""NO""); <line33> pbjImageWrite2.setParameter(""writeParam"", param2); <line34> final RenderedOp op2 = JAI.create(""ImageWrite"", pbjImageWrite2); <line35> } <line36> } <line37> "	info	task6	
public class A { <line0> public String getPrivateKey() { <line1> RSAPrivateKeyHolder keyHolder = keyProvider.getPrivateKey(); <line2> if (keyHolder == null) { <line3> return null; <line4> } <line5> try { <line6> return SshKeyGen.toPEM(keyProvider.getPrivateKey().getKey()); <line7> } catch (Exception e) { <line8> log.error(UNKNOWN); <line9> return null; <line10> } <line11> } <line12> } <line13> 	"""getPrivateKey: Failed to write PEM"", e"	task7	
public class A { <line0> @Override <line1> public void partyAction(Action action) { <line2> LOGGER.info(UNKNOWN); <line3> } <line4> } <line5> 	"""{} {}"", this, action.getDescription()"	task7	
"public class A { <line0> public void throwDebugInfo() { <line1> if (debugBufferSize == 0) return; <line2> String prefix = MULTI_THREAD ? ""["" + currentThread().getId() + ""] "" : """"; <line3> logger.error( <line4> jdiMarker, <line5> prefix + ""DEBUG INFO: "" + LINE_BREAK + print(debugLog.get().values(), LINE_BREAK)); <line6> } <line7> } <line8> "	"jdiMarker,prefix + ""DEBUG INFO: "" + LINE_BREAK + print(debugLog.get().values(), LINE_BREAK)"	task7	
"public class A { <line0> private String toEndPoint(NodeSource nodeSource) { <line1> try { <line2> if (nodeSource.getRedirect() != null) { <line3> final URI uri = nodeSource.getAddr(); <line4> if (uri != null) { <line5> return HostAndPort.toHostAndPortString(uri.getHost(), uri.getPort()); <line6> } <line7> } else if (nodeSource.getRedisClient() != null) { <line8> final InetSocketAddress address = nodeSource.getRedisClient().getAddr(); <line9> return HostAndPort.toHostAndPortString(address.getHostString(), address.getPort()); <line10> } else { <line11> final MasterSlaveEntry entry = nodeSource.getEntry(); <line12> if (entry != null) { <line13> if (entry.getClient() != null) { <line14> final InetSocketAddress address = entry.getClient().getAddr(); <line15> return HostAndPort.toHostAndPortString(address.getHostString(), address.getPort()); <line16> } <line17> } else if (nodeSource.getSlot() != null) { <line18> return ""slot="" + nodeSource.getSlot(); <line19> } <line20> } <line21> } catch (Exception ignored) { <line22> if (isDebug) { <line23> logger.debug(UNKNOWN); <line24> } <line25> } <line26> return ""Unknown""; <line27> } <line28> } <line29> "	"""Unexpected error. nodeSource={}"", nodeSource, ignored"	task7	
public class A { <line0> @Override <line1> public synchronized void shutdown() { <line2> try { <line3> if (open) { <line4> open = false; <line5> writer.close(); <line6> } <line7> } catch (IOException e) { <line8> logger.error(UNKNOWN); <line9> } <line10> } <line11> } <line12> 	"""Error shutting down journal log"", e"	task7	
"public class A { <line0> @Override <line1> public ReadingPublisher<Ec3kReading> createPublisher() { <line2> ReadingPublisher<Ec3kReading> publisher = <line3> new ReadingPublisher<Ec3kReading>() { <line4> @Override <line5> public void publish(Ec3kReading reading) { <line6> if (reading != null && getThing().getStatus() == ThingStatus.ONLINE) { <line7> BigDecimal currentWatt = <line8> new BigDecimal(reading.getCurrentWatt()).setScale(1, RoundingMode.HALF_UP); <line9> BigDecimal maxWatt = <line10> new BigDecimal(reading.getMaxWatt()).setScale(1, RoundingMode.HALF_UP); <line11> logger.debug( <line12> ""updating states for thing {}: currWatt={} ({}), maxWatt={}, consumption={},"" <line13> + "" secondsOn={}, secondsTotal={}"", <line14> getThing().getUID().getId(), <line15> currentWatt, <line16> reading.getCurrentWatt(), <line17> maxWatt, <line18> reading.getConsumptionTotal(), <line19> reading.getApplianceTime(), <line20> reading.getSensorTime()); <line21> updateState(CURRENT_POWER_CHANNEL, new QuantityType<>(currentWatt, Units.WATT)); <line22> updateState(MAX_POWER_CHANNEL, new QuantityType<>(maxWatt, Units.WATT)); <line23> updateState( <line24> CONSUMPTION_CHANNEL, <line25> new QuantityType<>(reading.getConsumptionTotal(), Units.WATT_HOUR)); <line26> updateState( <line27> APPLIANCE_TIME_CHANNEL, <line28> new QuantityType<>(reading.getApplianceTime(), Units.HOUR)); <line29> updateState( <line30> SENSOR_TIME_CHANNEL, new QuantityType<>(reading.getSensorTime(), Units.HOUR)); <line31> updateState(RESETS_CHANNEL, new DecimalType(reading.getResets())); <line32> } <line33> } <line34>  <line35> @Override <line36> public void dispose() {} <line37> }; <line38> BufferedSensorConfig cfg = getConfigAs(BufferedSensorConfig.class); <line39> if (cfg.bufferSize > 1 && cfg.updateInterval > 0) { <line40> publisher = <line41> new RollingAveragePublisher<Ec3kReading>( <line42> cfg.bufferSize, cfg.updateInterval, publisher, scheduler) { <line43> @Override <line44> public RollingReadingAverage<Ec3kReading> createRollingReadingAverage(int bufferSize) { <line45> return new Ec3kRollingReadingAverage(bufferSize); <line46> } <line47> }; <line48> } <line49> return publisher; <line50> } <line51> } <line52> "	"""updating states for thing {}: currWatt={} ({}), maxWatt={}, consumption={},""+ "" secondsOn={}, secondsTotal={}"",getThing().getUID().getId(),currentWatt,reading.getCurrentWatt(),maxWatt,reading.getConsumptionTotal(),reading.getApplianceTime(),reading.getSensorTime()"	task7	
public class A { <line0> public void pkgList() { <line1> log.info(UNKNOWN); <line2> pkgList(getPkgList()); <line3> } <line4> } <line5> 	"""Local packages:"""	task7	
public class A { <line0> protected void startNewExperiment() throws OpenbciCommunicationException { <line1> StartEEGSignalRequest request = new StartEEGSignalRequest(experimentDescriptor); <line2> ObciPullSocket pullSocket = new ObciPullSocket(EXPERIMENT_START_TIMEOUT_MILIS); <line3> request.setClientPushAddress(pullSocket.getAddressLocal()); <line4> Helper.sendRequestAndParseResponse( <line5> request, <line6> Helper.getOpenBCIIpAddress(), <line7> Helper.getOpenbciPort(), <line8> MessageType.REQUEST_OK_RESPONSE); <line9> StartEEGSignalResponse response = <line10> (StartEEGSignalResponse) <line11> pullSocket.getAndParsePushPullResponse(MessageType.START_EEG_SIGNAL_RESPONSE); <line12> pullSocket.close(); <line13> String exp_id = response.getSender(); <line14> logger.debug(UNKNOWN); <line15> experimentDescriptor.setId(exp_id); <line16> getExperimentContact(); <line17> } <line18> } <line19> 	"""GOT expereiment ID "" + exp_id"	task7	
public class A { <line0> @Override <line1> public ListExchangesResponseMessageType listExchanges(ListExchangesRequestMessageType request) { <line2> LOG.trace(UNKNOWN); <line3> ListExchangesResponseMessageType response = new ListExchangesResponseMessageType(); <line4> response <line5> .getExchangesList() <line6> .addAll(copyExchangeTypeList(getExchangeManager().getAllExchanges())); <line7> return response; <line8> } <line9> } <line10> 	"""listExchanges--call"""	task7	
public class A { <line0> public static int getCPMeasurementUnitsCount(long companyId) throws RemoteException { <line1> try { <line2> int returnValue = CPMeasurementUnitServiceUtil.getCPMeasurementUnitsCount(companyId); <line3> return returnValue; <line4> } catch (Exception exception) { <line5> log.error(UNKNOWN); <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	exception, exception	task7	
"public class A { <line0> private void logDeletedHost() { <line1> logger.warn( <line2> String.format( <line3> ""[Host Capacity] unable to update capacity for the host[uuid:%s]. It may have been"" <line4> + "" deleted, cannot find it in database"", <line5> hostUuid)); <line6> } <line7> } <line8> "	"String.format(""[Host Capacity] unable to update capacity for the host[uuid:%s]. It may have been""+ "" deleted, cannot find it in database"",hostUuid)"	task7	
public class A { <line0> @Override <line1> public void install(File artifact) throws Exception { <line2> InputStream is = new FileInputStream(artifact); <line3> String template = IOUtils.toString(is); <line4> templates.put(artifact.getName(), template); <line5> logger.info(UNKNOWN); <line6> } <line7> } <line8> 	"""Template {} installed"", artifact.getName()"	task7	
"public class A { <line0> private void responseOK(DatagramSocket socket, T remoteHostAddress) { <line1> try { <line2> byte[] okBytes = NetworkAvailabilityCheckPacket.DATA_OK; <line3> DatagramPacket pongPacket = new DatagramPacket(okBytes, okBytes.length, remoteHostAddress); <line4> socket.send(pongPacket); <line5> } catch (IOException e) { <line6> if (logger.isWarnEnabled()) { <line7> logger.warn( <line8> ""pong error. SendSocketAddress:{} Cause:{}"", remoteHostAddress, e.getMessage(), e); <line9> } <line10> } <line11> } <line12> } <line13> "	"""pong error. SendSocketAddress:{} Cause:{}"", remoteHostAddress, e.getMessage(), e"	task7	
"public class A { <line0> @Execute <line1> public JsonResponse<ApiResult> post$doc(final EditBody body) { <line2> validateApi(body, messages -> {}); <line3> if (body.doc == null) { <line4> throwValidationErrorApi( <line5> messages -> messages.addErrorsCrudFailedToCreateCrudTable(GLOBAL, ""doc is required"")); <line6> } <line7> validateFields(body, this::throwValidationErrorApi); <line8> body.crudMode = CrudMode.EDIT; <line9> final Map<String, Object> doc = <line10> getDoc(body) <line11> .map( <line12> entity -> { <line13> final String index = fessConfig.getIndexDocumentUpdateIndex(); <line14> try { <line15> entity.putAll(fessConfig.convertToStorableDoc(body.doc)); <line16> final String newId = ComponentUtil.getCrawlingInfoHelper().generateId(entity); <line17> final String oldId = (String) entity.get(fessConfig.getIndexFieldId()); <line18> if (!newId.equals(oldId)) { <line19> entity.put(fessConfig.getIndexFieldId(), newId); <line20> entity.remove(fessConfig.getIndexFieldVersion()); <line21> final Number seqNo = (Number) entity.remove(fessConfig.getIndexFieldSeqNo()); <line22> final Number primaryTerm = <line23> (Number) entity.remove(fessConfig.getIndexFieldPrimaryTerm()); <line24> if (seqNo != null && primaryTerm != null && oldId != null) { <line25> searchEngineClient.delete(index, oldId, seqNo, primaryTerm); <line26> } <line27> } <line28> searchEngineClient.store(index, entity); <line29> saveInfo(messages -> messages.addSuccessCrudUpdateCrudTable(GLOBAL)); <line30> } catch (final Exception e) { <line31> logger.error(UNKNOWN); <line32> throwValidationErrorApi( <line33> messages -> <line34> messages.addErrorsCrudFailedToUpdateCrudTable( <line35> GLOBAL, buildThrowableMessage(e))); <line36> } <line37> return entity; <line38> }) <line39> .orElseGet( <line40> () -> { <line41> throwValidationErrorApi( <line42> messages -> <line43> messages.addErrorsCrudCouldNotFindCrudTable(GLOBAL, body.doc.toString())); <line44> return null; <line45> }); <line46> return asJson( <line47> new ApiUpdateResponse() <line48> .id(doc.get(fessConfig.getIndexFieldDocId()).toString()) <line49> .created(false) <line50> .status(Status.OK) <line51> .result()); <line52> } <line53> } <line54> "	"""Failed to update {}"", entity, e"	task7	
"public class A { <line0> @Override <line1> public PatchStatus applyPatch(TypeDefPatch patch) throws AtlasBaseException { <line2> String typeName = patch.getTypeName(); <line3> AtlasBaseTypeDef typeDef = typeRegistry.getTypeDefByName(typeName); <line4> PatchStatus ret; <line5> if (typeDef == null) { <line6> throw new AtlasBaseException( <line7> AtlasErrorCode.PATCH_FOR_UNKNOWN_TYPE, patch.getAction(), typeName); <line8> } <line9> if (isPatchApplicable(patch, typeDef)) { <line10> if (typeDef.getClass().equals(AtlasEntityDef.class)) { <line11> AtlasEntityDef updatedDef = new AtlasEntityDef((AtlasEntityDef) typeDef); <line12> for (AtlasAttributeDef attributeDef : patch.getAttributeDefs()) { <line13> updatedDef.addAttribute(attributeDef); <line14> } <line15> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line16> typeDefStore.updateEntityDefByName(typeName, updatedDef); <line17> ret = APPLIED; <line18> } else if (typeDef.getClass().equals(AtlasClassificationDef.class)) { <line19> AtlasClassificationDef updatedDef = <line20> new AtlasClassificationDef((AtlasClassificationDef) typeDef); <line21> for (AtlasAttributeDef attributeDef : patch.getAttributeDefs()) { <line22> updatedDef.addAttribute(attributeDef); <line23> } <line24> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line25> typeDefStore.updateClassificationDefByName(typeName, updatedDef); <line26> ret = APPLIED; <line27> } else if (typeDef.getClass().equals(AtlasStructDef.class)) { <line28> AtlasStructDef updatedDef = new AtlasStructDef((AtlasStructDef) typeDef); <line29> for (AtlasAttributeDef attributeDef : patch.getAttributeDefs()) { <line30> updatedDef.addAttribute(attributeDef); <line31> } <line32> updatedDef.setTypeVersion(patch.getUpdateToVersion()); <line33> typeDefStore.updateStructDefByName(typeName, updatedDef); <line34> ret = APPLIED; <line35> } else { <line36> throw new AtlasBaseException( <line37> AtlasErrorCode.PATCH_NOT_APPLICABLE_FOR_TYPE, <line38> patch.getAction(), <line39> typeDef.getClass().getSimpleName()); <line40> } <line41> } else { <line42> LOG.info( <line43> ""patch skipped: typeName={}; applyToVersion={}; updateToVersion={}"", <line44> patch.getTypeName(), <line45> patch.getApplyToVersion(), <line46> patch.getUpdateToVersion()); <line47> ret = SKIPPED; <line48> } <line49> return ret; <line50> } <line51> } <line52> "	"""patch skipped: typeName={}; applyToVersion={}; updateToVersion={}"",patch.getTypeName(),patch.getApplyToVersion(),patch.getUpdateToVersion()"	task7	
public class A { <line0> @Override <line1> public void execute(ImmutableMultimap<String, String> arg0, PrintWriter arg1) throws Exception { <line2> try { <line3> List<CollectionReferenceDescription> discoveredCollections = <line4> collectionReferenceService.getAllIndicesAsCollections(); <line5> List<CollectionReferenceDescription> existingCollections; <line6> try { <line7> existingCollections = <line8> collectionReferenceService.describeAllCollections( <line9> collectionReferenceService.getAllCollectionReferences(Optional.empty()), <line10> Optional.empty()); <line11> } catch (Exception e) { <line12> existingCollections = new ArrayList<>(); <line13> } <line14> for (CollectionReferenceDescription collection : discoveredCollections) { <line15> if (!existingCollections.contains(collection)) { <line16> CollectionReferenceDescription collectionToAdd = checkCollectionValidity(collection); <line17> if (collectionToAdd != null) { <line18> collectionReferenceService.putCollectionReference(collectionToAdd); <line19> } <line20> } <line21> } <line22> } catch (ArlasConfigurationException e) { <line23> LOGGER.error(UNKNOWN); <line24> } <line25> } <line26> } <line27> 	e.getMessage(), e	task7	
"public class A { <line0> private static List<SourceCheck> _getSourceChecks( <line1> SourceFormatterConfiguration sourceFormatterConfiguration, <line2> String sourceProcessorName, <line3> Map<String, Properties> propertiesMap, <line4> List<String> filterCheckNames, <line5> List<String> filterCheckCategoryNames, <line6> List<String> skipCheckNames, <line7> boolean portalSource, <line8> boolean subrepository, <line9> boolean includeModuleChecks) <line10> throws Exception { <line11> List<SourceCheck> sourceChecks = new ArrayList<>(); <line12> List<SourceCheckConfiguration> sourceCheckConfigurations = <line13> sourceFormatterConfiguration.getSourceCheckConfigurations(sourceProcessorName); <line14> if (sourceCheckConfigurations == null) { <line15> return sourceChecks; <line16> } <line17> JSONObject excludesJSONObject = SourceFormatterCheckUtil.getExcludesJSONObject(propertiesMap); <line18> for (SourceCheckConfiguration sourceCheckConfiguration : sourceCheckConfigurations) { <line19> String sourceCheckName = <line20> SourceFormatterUtil.getSimpleName(sourceCheckConfiguration.getName()); <line21> if ((!filterCheckCategoryNames.isEmpty() || !filterCheckNames.isEmpty()) <line22> && !filterCheckCategoryNames.contains(sourceCheckConfiguration.getCategory()) <line23> && !filterCheckNames.contains(sourceCheckName)) { <line24> continue; <line25> } <line26> sourceCheckName = ""com.liferay.source.formatter.checks."" + sourceCheckName; <line27> Class<?> sourceCheckClass = null; <line28> try { <line29> sourceCheckClass = Class.forName(sourceCheckName); <line30> } catch (ClassNotFoundException classNotFoundException) { <line31> if (log.isDebugEnabled()) { <line32> log.debug(UNKNOWN); <line33> } <line34> SourceFormatterUtil.printError( <line35> ""sourcechecks.xml"", ""sourcechecks.xml: Class "" + sourceCheckName + "" cannot be found""); <line36> continue; <line37> } <line38> Constructor<?> declaredConstructor = sourceCheckClass.getDeclaredConstructor(); <line39> Object instance = declaredConstructor.newInstance(); <line40> if (!(instance instanceof SourceCheck)) { <line41> continue; <line42> } <line43> SourceCheck sourceCheck = (SourceCheck) instance; <line44> if ((!portalSource && !subrepository && sourceCheck.isLiferaySourceCheck()) <line45> || (!includeModuleChecks && sourceCheck.isModuleSourceCheck())) { <line46> continue; <line47> } <line48> Class<?> clazz = sourceCheck.getClass(); <line49> if (skipCheckNames.contains(clazz.getSimpleName())) { <line50> continue; <line51> } <line52> if (excludesJSONObject.length() != 0) { <line53> sourceCheck.setExcludes(excludesJSONObject.toString()); <line54> } <line55> JSONObject attributesJSONObject = <line56> _getAttributesJSONObject(propertiesMap, clazz.getSimpleName(), sourceCheckConfiguration); <line57> if (attributesJSONObject.length() != 0) { <line58> sourceCheck.setAttributes(attributesJSONObject.toString()); <line59> } <line60> sourceChecks.add(sourceCheck); <line61> } <line62> return sourceChecks; <line63> } <line64> } <line65> "	classNotFoundException, classNotFoundException	task7	
public class A { <line0> @Override <line1> public boolean loadOrgData() { <line2> if (!enabled) { <line3> throw new LoadSourceDisabledException(getSourceName()); <line4> } <line5> LOGGER.warn(UNKNOWN); <line6> return importData(); <line7> } <line8> } <line9> 	"""Loading RINGGOLD data..."""	task7	
"public class A { <line0> protected VDI getVDIbyUuid(final Connection conn, final String uuid) { <line1> try { <line2> return VDI.getByUuid(conn, uuid); <line3> } catch (final Exception e) { <line4> final String msg = <line5> ""Catch Exception "" <line6> + e.getClass().getName() <line7> + "" :VDI getByUuid for uuid: "" <line8> + uuid <line9> + "" failed due to "" <line10> + e.toString(); <line11> logger.debug(UNKNOWN); <line12> throw new CloudRuntimeException(msg, e); <line13> } <line14> } <line15> } <line16> "	msg	task7	
public class A { <line0> public void stateChanged(Enum oldState, Enum newState) { <line1> if (session.isStateless() && newState == IDLE) { <line2> session.release(); <line3> } <line4> if (log.isInfoEnabled()) { <line5> log.info(UNKNOWN); <line6> } <line7> } <line8> } <line9> 	"""Application changed state from["" + oldState + ""] to["" + newState + ""]"""	task7	
"public class A { <line0> public static Collection<PartitionOwner> balancePartitionsAcrossWorkers( <line1> Configuration conf, <line2> Collection<PartitionOwner> partitionOwners, <line3> Collection<PartitionStats> allPartitionStats, <line4> Collection<WorkerInfo> availableWorkerInfos) { <line5> String balanceAlgorithm = conf.get(PARTITION_BALANCE_ALGORITHM, STATIC_BALANCE_ALGORITHM); <line6> if (LOG.isInfoEnabled()) { <line7> LOG.info(UNKNOWN); <line8> } <line9> BalanceValue balanceValue = BalanceValue.UNSET; <line10> if (balanceAlgorithm.equals(STATIC_BALANCE_ALGORITHM)) { <line11> return partitionOwners; <line12> } else if (balanceAlgorithm.equals(EGDE_BALANCE_ALGORITHM)) { <line13> balanceValue = BalanceValue.EDGES; <line14> } else if (balanceAlgorithm.equals(VERTICES_BALANCE_ALGORITHM)) { <line15> balanceValue = BalanceValue.VERTICES; <line16> } else { <line17> throw new IllegalArgumentException( <line18> ""balancePartitionsAcrossWorkers: Illegal balance "" + ""algorithm - "" + balanceAlgorithm); <line19> } <line20> Map<Integer, PartitionStats> idStatMap = new HashMap<Integer, PartitionStats>(); <line21> for (PartitionStats partitionStats : allPartitionStats) { <line22> if (idStatMap.put(partitionStats.getPartitionId(), partitionStats) != null) { <line23> throw new IllegalStateException( <line24> ""balancePartitionsAcrossWorkers: Duplicate partition id "" + ""for "" + partitionStats); <line25> } <line26> } <line27> Map<PartitionOwner, PartitionStats> ownerStatsMap = <line28> new HashMap<PartitionOwner, PartitionStats>(); <line29> for (PartitionOwner partitionOwner : partitionOwners) { <line30> PartitionStats partitionStats = idStatMap.get(partitionOwner.getPartitionId()); <line31> if (partitionStats == null) { <line32> throw new IllegalStateException( <line33> ""balancePartitionsAcrossWorkers: Missing partition "" + ""stats for "" + partitionOwner); <line34> } <line35> if (ownerStatsMap.put(partitionOwner, partitionStats) != null) { <line36> throw new IllegalStateException( <line37> ""balancePartitionsAcrossWorkers: Duplicate partition "" + ""owner "" + partitionOwner); <line38> } <line39> } <line40> if (ownerStatsMap.size() != partitionOwners.size()) { <line41> throw new IllegalStateException( <line42> ""balancePartitionsAcrossWorkers: ownerStats count = "" <line43> + ownerStatsMap.size() <line44> + "", partitionOwners count = "" <line45> + partitionOwners.size() <line46> + "" and should match.""); <line47> } <line48> List<WorkerInfoAssignments> workerInfoAssignmentsList = <line49> new ArrayList<WorkerInfoAssignments>(availableWorkerInfos.size()); <line50> for (WorkerInfo workerInfo : availableWorkerInfos) { <line51> workerInfoAssignmentsList.add( <line52> new WorkerInfoAssignments(workerInfo, balanceValue, ownerStatsMap)); <line53> } <line54> List<PartitionOwner> partitionOwnerList = new ArrayList<PartitionOwner>(partitionOwners); <line55> Collections.sort( <line56> partitionOwnerList, <line57> Collections.reverseOrder(new PartitionOwnerComparator(ownerStatsMap, balanceValue))); <line58> PriorityQueue<WorkerInfoAssignments> minQueue = <line59> new PriorityQueue<WorkerInfoAssignments>(workerInfoAssignmentsList); <line60> for (PartitionOwner partitionOwner : partitionOwnerList) { <line61> WorkerInfoAssignments chosenWorker = minQueue.remove(); <line62> chosenWorker.assignPartitionOwner(partitionOwner); <line63> minQueue.add(chosenWorker); <line64> } <line65> return partitionOwnerList; <line66> } <line67> } <line68> "	"""balancePartitionsAcrossWorkers: Using algorithm "" + balanceAlgorithm"	task7	
"public class A { <line0> @Override <line1> public void execute(Arguments arguments) throws Exception { <line2> ProgramId programId = arguments.getId(); <line3> Preconditions.checkArgument( <line4> programLifecycleService.getProgramSpecification(programId) != null, <line5> ""Cannot start %s because it does not exist."", <line6> programId); <line7> try { <line8> ProgramStatus currentStatus = programLifecycleService.getProgramStatus(programId); <line9> if (currentStatus != ProgramStatus.STOPPED) { <line10> LOG.info( <line11> ""Program {} is in the {} state, skipping start program bootstrap step."", <line12> programId, <line13> currentStatus); <line14> return; <line15> } <line16> programLifecycleService.run(programId, Collections.emptyMap(), false); <line17> } catch (ConflictException e) { <line18> } catch (NotFoundException e) { <line19> throw new IllegalArgumentException( <line20> String.format(""Cannot start %s because it does not exist."", programId), e); <line21> } <line22> } <line23> } <line24> "	"""Program {} is in the {} state, skipping start program bootstrap step."",programId,currentStatus"	task7	
"public class A { <line0> @Override <line1> public void reactivationByEmail(String email) throws ApsSystemException { <line2> try { <line3> Collection<String> usernames = this.getUsernamesByEmail(email); <line4> Iterator<String> usernamesIter = usernames.iterator(); <line5> while (usernamesIter.hasNext()) { <line6> String userName = (String) usernamesIter.next(); <line7> this.reactivationByUserName(userName); <line8> } <line9> } catch (Throwable t) { <line10> logger.error(UNKNOWN); <line11> throw new ApsSystemException(""Error in request for Account Reactivation"", t); <line12> } <line13> } <line14> } <line15> "	"""Error in request for Account Reactivation"", t"	task7	
"public class A { <line0> public int runGenerator( <line1> int numMappers, <line2> long numNodes, <line3> Path tmpOutput, <line4> Integer width, <line5> Integer wrapMultiplier, <line6> Integer numWalkers) <line7> throws Exception { <line8> LOG.info(UNKNOWN); <line9> createSchema(); <line10> job = Job.getInstance(getConf()); <line11> job.setJobName(""Link Generator""); <line12> job.setNumReduceTasks(0); <line13> job.setJarByClass(getClass()); <line14> FileInputFormat.setInputPaths(job, tmpOutput); <line15> job.setInputFormatClass(OneFilePerMapperSFIF.class); <line16> job.setOutputKeyClass(NullWritable.class); <line17> job.setOutputValueClass(NullWritable.class); <line18> setJobConf(job, numMappers, numNodes, width, wrapMultiplier, numWalkers); <line19> setMapperForGenerator(job); <line20> job.setOutputFormatClass(NullOutputFormat.class); <line21> job.getConfiguration().setBoolean(""mapreduce.map.speculative"", false); <line22> TableMapReduceUtil.addDependencyJars(job); <line23> TableMapReduceUtil.addDependencyJarsForClasses(job.getConfiguration(), AbstractHBaseTool.class); <line24> TableMapReduceUtil.initCredentials(job); <line25> boolean success = jobCompletion(job); <line26> return success ? 0 : 1; <line27> } <line28> } <line29> "	"""Running Generator with numMappers="" + numMappers + "", numNodes="" + numNodes"	task7	
public class A { <line0> @Override <line1> @PostMapping <line2> public OwnerDto create(@Valid final @RequestBody OwnerDto dto) { <line3> LOGGER.debug(UNKNOWN); <line4> return internalOwnerService.create(dto); <line5> } <line6> } <line7> 	"""Create {}"", dto"	task7	
"public class A { <line0> @Override <line1> public <T extends Resource> Collection<T> deserialize( <line2> String xml, String serviceIdentifier, String path, Class<T> returnType) { <line3> Collection<T> resources = new ArrayList<T>(); <line4> InputSource is = new InputSource(new StringReader(xml)); <line5> try { <line6> NodeList parSNodes = <line7> (NodeList) xpf.newXPath().evaluate(xpathExpr, is, XPathConstants.NODESET); <line8> for (int i = 0; i < parSNodes.getLength(); i++) { <line9> String placeId = null; <line10> String topn = null; <line11> String cf = null; <line12> String vote = null; <line13> Node parS = parSNodes.item(i); <line14> NodeList parList = parS.getChildNodes(); <line15> for (int j = 0; j < parList.getLength(); j++) { <line16> Node par = parList.item(j); <line17> String content = par.getTextContent(); <line18> if (content != null && !content.equalsIgnoreCase(""\n"")) { <line19> NamedNodeMap map = par.getAttributes(); <line20> Node n = map.getNamedItem(""n""); <line21> String value = n.getNodeValue(); <line22> if (value.equalsIgnoreCase(""item_id"")) placeId = content; <line23> else if (value.equalsIgnoreCase(""recs:vote"")) vote = content; <line24> else if (value.equalsIgnoreCase(""recs:engine:topn"")) topn = content; <line25> else if (value.equalsIgnoreCase(""recs:engine:cf"")) cf = content; <line26> } <line27> } <line28> Location l = createLocation(placeId, vote, topn, cf); <line29> resources.add((T) l); <line30> } <line31> } catch (XPathExpressionException e) { <line32> logger.error(UNKNOWN); <line33> } <line34> return resources; <line35> } <line36> } <line37> "	e.toString()	task7	
"public class A { <line0> @JsxFunction <line1> public int moveEnd(final String unit, final Object count) { <line2> if (!""character"".equals(unit)) { <line3> if (LOG.isWarnEnabled()) { <line4> LOG.warn(UNKNOWN); <line5> } <line6> return 0; <line7> } <line8> int c = 1; <line9> if (!Undefined.isUndefined(count)) { <line10> c = (int) Context.toNumber(count); <line11> } <line12> if (range_.getStartContainer() == range_.getEndContainer() <line13> && range_.getStartContainer() instanceof SelectableTextInput) { <line14> final SelectableTextInput input = (SelectableTextInput) range_.getStartContainer(); <line15> c = constrainMoveBy(c, range_.getEndOffset(), input.getText().length()); <line16> range_.setEnd(input, range_.getEndOffset() + c); <line17> } <line18> return c; <line19> } <line20> } <line21> "	"""moveEnd('"" + unit + ""') is not yet supported"""	task7	
public class A { <line0> private GlobalSystemData loadGlobalData() throws EngineException { <line1> Stopwatch watch = Stopwatch.createStarted(); <line2> GlobalSystemData ret = <line3> GlobalSystemData.builder() <line4> .withAttributeTypes(attributeTypeDAO.getAllAsMap()) <line5> .withAttributeClasses(acDB.getAllAsMap()) <line6> .withGroups(groupDAO.getAllAsMap()) <line7> .withCredentials(credentialRepository.getCredentialDefinitions()) <line8> .withCredentialRequirements(getCredentialRequirements()) <line9> .withEnquiryForms(enquiryDB.getAllAsMap()) <line10> .build(); <line11> log.debug(UNKNOWN); <line12> return ret; <line13> } <line14> } <line15> 	"""loading global data {}"", watch.toString()"	task7	
public class A { <line0> private void readTokens() { <line1> int nRead; <line2> String tags = null; <line3> try { <line4> char[] buff = new char[1 * 1024]; <line5> StringBuilder buffer = new StringBuilder(); <line6> while ((nRead = input.read(buff, 0, buff.length)) != -1) { <line7> buffer.append(buff, 0, nRead); <line8> } <line9> tags = buffer.toString(); <line10> } catch (IOException e) { <line11> log.error(UNKNOWN); <line12> } <line13> if (tags != null && !tags.isEmpty()) { <line14> int iValue = tags.indexOf(TagsBridge.VALUE); <line15> if (iValue > 0) { <line16> String tag = tags.substring(0, iValue); <line17> String value = tags.substring(iValue + TagsBridge.VALUE.length()); <line18> String token = tag + SEPARATOR + value; <line19> tokens = new String[2]; <line20> tokens[0] = tag; <line21> tokens[1] = token; <line22> } else { <line23> tokens = new String[1]; <line24> tokens[0] = tags; <line25> } <line26> } <line27> } <line28> } <line29> 	e	task7	
"public class A { <line0> public void removeAndNotifyKeys(Object[] keys) { <line1> final boolean isTraceEnabled = logger.isTraceEnabled(); <line2> synchronized (allKeysMap) { <line3> for (Object key : keys) { <line4> LockObject lockValue = allKeysMap.remove(key); <line5> if (lockValue != null) { <line6> synchronized (lockValue) { <line7> lockValue.setRemoved(); <line8> if (isTraceEnabled) { <line9> long waitTime = System.currentTimeMillis() - lockValue.lockedTimeStamp; <line10> logger.trace( <line11> ""LockKeys: remove key {}, notifyAll for {}. It waited {}"", <line12> key, <line13> lockValue, <line14> waitTime); <line15> } <line16> if (lockValue.isSomeoneWaiting()) { <line17> lockValue.notifyAll(); <line18> } <line19> } <line20> } <line21> } <line22> } <line23> } <line24> } <line25> "	"""LockKeys: remove key {}, notifyAll for {}. It waited {}"",key,lockValue,waitTime"	task7	
"public class A { <line0> @Override <line1> public List<InputSplit> getSplits(JobContext context) throws IOException { <line2> long start = System.currentTimeMillis(); <line3> Configuration conf = context.getConfiguration(); <line4> ImageInputFormatContext ifContext = ImageInputFormatContext.load(conf); <line5> int zoom = ifContext.getZoomLevel(); <line6> int tilesize = ifContext.getTileSize(); <line7> HdfsMrsImageDataProvider dp = createHdfsMrsImageDataProvider(context.getConfiguration()); <line8> Path inputWithZoom = new Path(dp.getResourcePath(true), """" + zoom); <line9> MrsPyramidMetadataReader metadataReader = dp.getMetadataReader(); <line10> MrsPyramidMetadata metadata = metadataReader.read(); <line11> org.mrgeo.hdfs.tile.FileSplit fsplit = createFileSplit(); <line12> fsplit.readSplits(inputWithZoom); <line13> FileSplitInfo[] splits = (FileSplitInfo[]) fsplit.getSplits(); <line14> List<InputSplit> result = new ArrayList<>(splits.length); <line15> Bounds requestedBounds = ifContext.getBounds(); <line16> for (FileSplitInfo split : splits) { <line17> Path part = new Path(inputWithZoom, split.getName()); <line18> Path dataFile = new Path(part, MapFile.DATA_FILE_NAME); <line19> long endTileId = split.getEndId(); <line20> long startTileId = split.getStartId(); <line21> if (requestedBounds != null) { <line22> Tile startTile = TMSUtils.tileid(startTileId, zoom); <line23> Bounds startTileBounds = TMSUtils.tileBounds(startTile, zoom, tilesize); <line24> Tile endTile = TMSUtils.tileid(endTileId, zoom); <line25> Bounds endTileBounds = TMSUtils.tileBounds(endTile, zoom, tilesize); <line26> if (startTileBounds.s > requestedBounds.n || endTileBounds.n < requestedBounds.s) { <line27> } else { <line28> result.add( <line29> new TiledInputSplit( <line30> new FileSplit(dataFile, 0, 0, null), <line31> startTileId, <line32> endTileId, <line33> zoom, <line34> metadata.getTilesize())); <line35> } <line36> } else { <line37> result.add( <line38> new TiledInputSplit( <line39> new FileSplit(dataFile, 0, 0, null), <line40> startTileId, <line41> endTileId, <line42> zoom, <line43> metadata.getTilesize())); <line44> } <line45> } <line46> long end = System.currentTimeMillis(); <line47> log.info(UNKNOWN); <line48> return result; <line49> } <line50> } <line51> "	"""Time to generate splits: "" + (end - start) + "" ms"""	task7	
public class A { <line0> @Test <line1> public void generateJavaNestedCompPropClassNames() { <line2> Set<ComponentDefinition> allComponents = getComponentService().getAllComponents(); <line3> for (ComponentDefinition cd : allComponents) { <line4> ComponentProperties props = cd.createProperties(); <line5> String javaCode = PropertiesTestUtils.generatedNestedComponentCompatibilitiesJavaCode(props); <line6> LOGGER.debug(UNKNOWN); <line7> } <line8> } <line9> } <line10> 	"""Nested Props for ("" + cd.getClass().getSimpleName() + "".java:1)"" + javaCode"	task7	
"public class A { <line0> @Override <line1> public KeyManager[] createKeyManagers() { <line2> KeyInfoManager keyInfoManager = null; <line3> try { <line4> keyInfoManager = getKeyInfoManager(getKeyStoreParameters()); <line5> KeyStore ks = loadKeyStore(keyStoreParameters, keyInfoManager); <line6> logger.debug(UNKNOWN); <line7> KeyManagerFactory kmfactory = <line8> KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); <line9> String keyStorePassword = keyInfoManager.getKeyStorePassword(); <line10> kmfactory.init(ks, keyStorePassword != null ? keyStorePassword.toCharArray() : null); <line11> return kmfactory.getKeyManagers(); <line12> } catch (Throwable e) { <line13> throw new AlfrescoRuntimeException(""Unable to create key manager"", e); <line14> } finally { <line15> if (keyInfoManager != null) { <line16> keyInfoManager.clear(); <line17> } <line18> } <line19> } <line20> } <line21> "	"""Initializing key managers"""	task7	
"public class A { <line0> protected boolean verifyContextNotStarted() { <line1> if (muleContext != null <line2> && muleContext.getLifecycleManager().isPhaseComplete(Startable.PHASE_NAME)) { <line3> logger.warn( <line4> ""Cannot modify MuleConfiguration once the MuleContext has been started.  Modification"" <line5> + "" will be ignored.""); <line6> return false; <line7> } else { <line8> return true; <line9> } <line10> } <line11> } <line12> "	"""Cannot modify MuleConfiguration once the MuleContext has been started.  Modification""+ "" will be ignored."""	task7	
public class A { <line0> public int readReportTempFileAndSave(String fileName, int reportID) throws IOException { <line1> int reportId = 0; <line2> try { <line3> File reportTempFile = new File(classLoader.getResource(fileName).getFile()); <line4> String reportTempJson = new String(Files.readAllBytes(reportTempFile.toPath())); <line5> reportId = saveReportTemplate(reportTempJson, reportID); <line6> reportIdList.add(reportId); <line7> } catch (IOException e) { <line8> log.error(UNKNOWN); <line9> } <line10> return reportId; <line11> } <line12> } <line13> 	e	task7	
"public class A { <line0> @Override <line1> public Answer ComputeChecksum(ComputeChecksumCommand cmd) { <line2> TransactionLegacy txn = TransactionLegacy.open(TransactionLegacy.SIMULATOR_DB); <line3> try { <line4> txn.start(); <line5> MockVolumeVO volume = _mockVolumeDao.findByName(cmd.getTemplatePath()); <line6> if (volume == null) { <line7> return new Answer(cmd, false, ""cant' find volume:"" + cmd.getTemplatePath()); <line8> } <line9> String md5 = null; <line10> try { <line11> MessageDigest md = MessageDigest.getInstance(""md5""); <line12> md5 = <line13> String.format(""%032x"", new BigInteger(1, md.digest(cmd.getTemplatePath().getBytes()))); <line14> } catch (NoSuchAlgorithmException e) { <line15> logger.debug(UNKNOWN); <line16> } <line17> txn.commit(); <line18> return new Answer(cmd, true, md5); <line19> } finally { <line20> txn.close(); <line21> txn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB); <line22> txn.close(); <line23> } <line24> } <line25> } <line26> "	"""failed to gernerate md5:"" + e.toString()"	task7	
public class A { <line0> public Map<String, Double> safeGetStat( <line1> Set<String> fields, Set<String> dataTypes, Date start, Date end) { <line2> try { <line3> return getStat(fields, dataTypes, start, end); <line4> } catch (Exception e) { <line5> if (log.isDebugEnabled()) <line6> log.debug(UNKNOWN); <line7> return EMPTY_STATS; <line8> } <line9> } <line10> } <line11> 	"""Caught exception running getStat, Returning EMPTY_STATS"""	task7	
public class A { <line0> @Override <line1> public JSONArray apply(InputStream input) { <line2> try { <line3> String result = new String(ByteStreams.toByteArray(input), StandardCharsets.UTF_8); <line4> logger.info(UNKNOWN); <line5> return new JSONArray(result); <line6> } catch (Exception e) { <line7> throw Throwables.propagate(e); <line8> } <line9> } <line10> } <line11> 	"""result:\n"" + result"	task7	
"public class A { <line0> @GET <line1> @Path(""{transactionId}"") <line2> public Response getTransactionStatus(@PathParam(""transactionId"") final String txId) { <line3> final Transaction tx; <line4> try { <line5> tx = txManager.get(txId); <line6> } catch (final TransactionNotFoundException e) { <line7> return Response.status(Status.NOT_FOUND).build(); <line8> } catch (final TransactionClosedException e) { <line9> return Response.status(Status.GONE) <line10> .entity(e.getMessage()) <line11> .type(TEXT_PLAIN_WITH_CHARSET) <line12> .build(); <line13> } <line14> LOGGER.info(UNKNOWN); <line15> return Response.status(Status.NO_CONTENT) <line16> .header(ATOMIC_EXPIRES_HEADER, EXPIRES_RFC_1123_FORMATTER.format(tx.getExpires())) <line17> .build(); <line18> } <line19> } <line20> "	"""Checking transaction status'{}'"", tx.getId()"	task7	
"public class A { <line0> @Override <line1> public OutputStream createOutputStream(long offset) throws IOException { <line2> final Page origPage = page; <line3> OutputStream out = <line4> new ByteArrayOutputStream() { <line5> @Override <line6> public void flush() throws IOException { <line7> final String source = toString(); <line8> final App app = StructrApp.getInstance(); <line9> try (Tx tx = app.tx()) { <line10> Page modifiedPage = <line11> Importer.parsePageFromSource( <line12> page.getSecurityContext(), source, ""__FTP_Temporary_Page__""); <line13> final List<InvertibleModificationOperation> changeSet = <line14> Importer.diffNodes(origPage, modifiedPage); <line15> for (final InvertibleModificationOperation op : changeSet) { <line16> op.apply(app, origPage, modifiedPage); <line17> } <line18> app.delete(modifiedPage); <line19> tx.success(); <line20> } catch (FrameworkException fex) { <line21> logger.warn(UNKNOWN); <line22> } <line23> super.flush(); <line24> } <line25> }; <line26> return out; <line27> } <line28> } <line29> "	""""", fex"	task7	
"public class A { <line0> private Provider initSecurityProvider(String providerName) { <line1> switch (providerName) { <line2> case ""BC"": <line3> Security.addProvider(new BouncyCastleProvider()); <line4> return Security.getProvider(providerName); <line5> default: <line6> LOG.error(UNKNOWN); <line7> throw new SecurityException(""Unknown security provider:"" + provider); <line8> } <line9> } <line10> } <line11> "	"""Security Provider:{} is unknown"", provider"	task7	
"public class A { <line0> public void onArmSync( <line1> Myo myo, long timestamp, Arm arm, XDirection xDirection, WarmupState warmupState) { <line2> log.info(UNKNOWN); <line3> whichArm = arm; <line4> invoke(""publishArmSync"", arm); <line5> } <line6> } <line7> "	"""onArmSync {}"", arm"	task7	
public class A { <line0> private void setCollectionValue(Object entity, Object thriftColumnValue, Attribute attribute) { <line1> try { <line2> ByteBuffer valueByteBuffer = ByteBuffer.wrap((byte[]) thriftColumnValue); <line3> if (Collection.class.isAssignableFrom(((Field) attribute.getJavaMember()).getType())) { <line4> Class<?> genericClass = <line5> PropertyAccessorHelper.getGenericClass((Field) attribute.getJavaMember()); <line6> PropertyAccessorHelper.set( <line7> entity, <line8> (Field) attribute.getJavaMember(), <line9> CassandraDataTranslator.decompose( <line10> ((Field) attribute.getJavaMember()).getType(), <line11> valueByteBuffer, <line12> genericClass, <line13> true)); <line14> } else if (((Field) attribute.getJavaMember()).getType().isAssignableFrom(Map.class)) { <line15> List<Class<?>> mapGenericClasses = <line16> PropertyAccessorHelper.getGenericClasses((Field) attribute.getJavaMember()); <line17> PropertyAccessorHelper.set( <line18> entity, <line19> (Field) attribute.getJavaMember(), <line20> CassandraDataTranslator.decompose( <line21> ((Field) attribute.getJavaMember()).getType(), <line22> valueByteBuffer, <line23> mapGenericClasses, <line24> true)); <line25> } <line26> } catch (Exception e) { <line27> log.error(UNKNOWN); <line28> throw new PersistenceException(e); <line29> } <line30> } <line31> } <line32> 	"""Error while setting field{} value via CQL, Caused by: ."", attribute.getName(), e"	task7	
"public class A { <line0> public void handle(Class<?> annotatedType) { <line1> if (!(Converter.class.isAssignableFrom(annotatedType))) { <line2> throw new VRaptorException(""converter does not implement Converter""); <line3> } <line4> if (BaseComponents.getBundledConverters().contains(annotatedType)) { <line5> logger.debug(UNKNOWN); <line6> return; <line7> } <line8> @SuppressWarnings(""unchecked"") <line9> Class<? extends Converter<?>> converterType = (Class<? extends Converter<?>>) annotatedType; <line10> converters.register(converterType); <line11> } <line12> } <line13> "	"""Ignoring handling default converter {}"", annotatedType"	task7	
"public class A { <line0> @Override <line1> public Object getProperty(Map context, Object target, Object key) throws OgnlException { <line2> LOG.trace(UNKNOWN); <line3> if (!ReflectionContextState.isGettingByKeyProperty(context) <line4> && !key.equals(KEY_PROPERTY_FOR_CREATION)) { <line5> return super.getProperty(context, target, key); <line6> } else { <line7> ReflectionContextState.setGettingByKeyProperty(context, false); <line8> } <line9> Collection c = (Collection) target; <line10> Class lastBeanClass = ReflectionContextState.getLastBeanClassAccessed(context); <line11> String lastPropertyClass = ReflectionContextState.getLastBeanPropertyAccessed(context); <line12> if (lastBeanClass == null || lastPropertyClass == null) { <line13> ReflectionContextState.updateCurrentPropertyPath(context, key); <line14> return super.getProperty(context, target, key); <line15> } <line16> String keyProperty = objectTypeDeterminer.getKeyProperty(lastBeanClass, lastPropertyClass); <line17> Class collClass = objectTypeDeterminer.getElementClass(lastBeanClass, lastPropertyClass, key); <line18> Class keyType; <line19> Class toGetTypeFrom = (collClass != null) ? collClass : c.iterator().next().getClass(); <line20> try { <line21> keyType = OgnlRuntime.getPropertyDescriptor(toGetTypeFrom, keyProperty).getPropertyType(); <line22> } catch (Exception exc) { <line23> throw new OgnlException(""Error getting property descriptor: "" + exc.getMessage()); <line24> } <line25> if (ReflectionContextState.isCreatingNullObjects(context)) { <line26> Map collMap = getSetMap(context, c, keyProperty); <line27> if (key.toString().equals(KEY_PROPERTY_FOR_CREATION)) { <line28> return collMap.get(null); <line29> } <line30> Object realKey = xworkConverter.convertValue(context, key, keyType); <line31> Object value = collMap.get(realKey); <line32> if (value == null <line33> && ReflectionContextState.isCreatingNullObjects(context) <line34> && objectTypeDeterminer.shouldCreateIfNew( <line35> lastBeanClass, lastPropertyClass, c, keyProperty, false)) { <line36> try { <line37> value = objectFactory.buildBean(collClass, context); <line38> _accessor.setProperty(context, value, keyProperty, realKey); <line39> c.add(value); <line40> collMap.put(realKey, value); <line41> } catch (Exception exc) { <line42> throw new OgnlException(""Error adding new element to collection"", exc); <line43> } <line44> } <line45> return value; <line46> } else { <line47> if (key.toString().equals(KEY_PROPERTY_FOR_CREATION)) { <line48> return null; <line49> } <line50> Object realKey = xworkConverter.convertValue(context, key, keyType); <line51> return getPropertyThroughIteration(context, c, keyProperty, realKey); <line52> } <line53> } <line54> } <line55> "	"""Entering getProperty()"""	task7	
"public class A { <line0> public void setUp() throws Exception { <line1> if (sharedTime == null) currentTime = new AtomicLong(System.currentTimeMillis()); <line2> ticker = <line3> new Ticker() { <line4> @Override <line5> public long read() { <line6> if (sharedTime != null) return sharedTime.get(); <line7> return currentTime.get(); <line8> } <line9> }; <line10> nodeName = ""node "" + nodes.size(); <line11> mgmt = newLocalManagementContext(); <line12> ownNodeId = mgmt.getManagementNodeId(); <line13> objectStore = new ListeningObjectStore(newPersistenceObjectStore()); <line14> objectStore.injectManagementContext(mgmt); <line15> objectStore.prepareForSharedUse(PersistMode.CLEAN, HighAvailabilityMode.DISABLED); <line16> persister = new ManagementPlaneSyncRecordPersisterToObjectStore(mgmt, objectStore, classLoader); <line17> ((ManagementPlaneSyncRecordPersisterToObjectStore) persister).preferRemoteTimestampInMemento(); <line18> BrooklynMementoPersisterToObjectStore persisterObj = <line19> new BrooklynMementoPersisterToObjectStore( <line20> objectStore, mgmt.getBrooklynProperties(), classLoader); <line21> mgmt.getRebindManager() <line22> .setPersister(persisterObj, PersistenceExceptionHandlerImpl.builder().build()); <line23> ha = <line24> ((HighAvailabilityManagerImpl) mgmt.getHighAvailabilityManager()) <line25> .setPollPeriod(Duration.PRACTICALLY_FOREVER) <line26> .setHeartbeatTimeout(Duration.THIRTY_SECONDS) <line27> .setLocalTicker(ticker) <line28> .setRemoteTicker(ticker) <line29> .setPersister(persister); <line30> log.info(UNKNOWN); <line31> } <line32> } <line33> "	"""Created "" + nodeName + "" "" + ownNodeId"	task7	
"public class A { <line0> @Override <line1> public Observable<Order> getOrderChanges(CurrencyPair currencyPair, Object... args) { <line2> if (!containsPair(service.getProduct().getOrders(), currencyPair)) <line3> throw new UnsupportedOperationException( <line4> String.format(""The currency pair %s is not subscribed for orders"", currencyPair)); <line5> if (!service.isAuthenticated()) { <line6> throw new ExchangeSecurityException(""Not authenticated""); <line7> } <line8> if (!orderChangesWarningLogged) { <line9> LOG.warn( <line10> ""The order change stream is not yet fully implemented for Coinbase Pro. "" <line11> + ""Orders are not fully populated, containing only the values changed since "" <line12> + ""the last update. Other values will be null.""); <line13> orderChangesWarningLogged = true; <line14> } <line15> return service <line16> .getRawWebSocketTransactions(currencyPair, true) <line17> .filter(s -> s.getUserId() != null) <line18> .map(CoinbaseProStreamingAdapters::adaptOrder); <line19> } <line20> } <line21> "	"""The order change stream is not yet fully implemented for Coinbase Pro. ""+ ""Orders are not fully populated, containing only the values changed since ""+ ""the last update. Other values will be null."""	task7	
public class A { <line0> public org.talend.mdm.webservice.WSRoutingOrderV2PK executeRoutingOrderV2Asynchronously( <line1> org.talend.mdm.webservice.WSExecuteRoutingOrderV2Asynchronously arg0) { <line2> LOG.info(UNKNOWN); <line3> System.out.println(arg0); <line4> try { <line5> org.talend.mdm.webservice.WSRoutingOrderV2PK _return = null; <line6> return _return; <line7> } catch (java.lang.Exception ex) { <line8> ex.printStackTrace(); <line9> throw new RuntimeException(ex); <line10> } <line11> } <line12> } <line13> 	"""Executing operation executeRoutingOrderV2Asynchronously"""	task7	
public class A { <line0> public void metaKeyDown() { <line1> if (metaKeyDown) return; <line2> newActions().keyDown(Keys.META).perform(); <line3> metaKeyDown = true; <line4> log.debug(UNKNOWN); <line5> } <line6> } <line7> 	"""Meta key down: {}"", getStateString()"	task7	
public class A { <line0> private static void handleLoopException(Throwable t) { <line1> logger.warn(UNKNOWN); <line2> try { <line3> Thread.sleep(1000); <line4> } catch (InterruptedException e) { <line5> } <line6> } <line7> } <line8> 	"""Unexpected exception in the selector loop."", t"	task7	
"public class A { <line0> @Override <line1> public void onAfterTransport(BootEvent event) { <line2> Microservice microservice = RegistrationManager.INSTANCE.getMicroservice(); <line3> String swaggerSchema = ""http""; <line4> for (String endpoint : microservice.getInstance().getEndpoints()) { <line5> if (endpoint.startsWith(""rest://"") && endpoint.indexOf(""sslEnabled=true"") > 0) { <line6> swaggerSchema = ""https""; <line7> } <line8> } <line9> MicroserviceMeta microserviceMeta = event.getScbEngine().getProducerMicroserviceMeta(); <line10> for (SchemaMeta schemaMeta : microserviceMeta.getSchemaMetas().values()) { <line11> Swagger swagger = schemaMeta.getSwagger(); <line12> swagger.addScheme(Scheme.forValue(swaggerSchema)); <line13> String content = SwaggerUtils.swaggerToString(swagger); <line14> LOGGER.info( <line15> ""generate swagger for {}/{}/{}, swagger: {}"", <line16> microserviceMeta.getAppId(), <line17> microserviceMeta.getMicroserviceName(), <line18> schemaMeta.getSchemaId(), <line19> content); <line20> RegistrationManager.INSTANCE.addSchema(schemaMeta.getSchemaId(), content); <line21> } <line22> saveBasePaths(microserviceMeta); <line23> } <line24> } <line25> "	"""generate swagger for {}/{}/{}, swagger: {}"",microserviceMeta.getAppId(),microserviceMeta.getMicroserviceName(),schemaMeta.getSchemaId(),content"	task7	
public class A { <line0> public void write(byte[] data) throws Exception { <line1> if (debug && debugTX) { <line2> String dataString = StringUtil.byteArrayToIntString(data); <line3> log.info(UNKNOWN); <line4> } <line5> port.writeBytes(data); <line6> } <line7> } <line8> 	"""Sending Byte Array: >{}< to Port: {}"", dataString, portName"	task7	
public class A { <line0> @Override <line1> protected final void disposeInternal() { <line2> disposePlannerInternal(); <line3> try { <line4> interceptDisposePlanner(); <line5> } catch (Exception t) { <line6> LOG.warn(UNKNOWN); <line7> } <line8> super.disposeInternal(); <line9> } <line10> } <line11> 	getClass().getName(), t	task7	
"public class A { <line0> public void pushWithTopicsContext2() throws MessageException { <line1> TopicKey topicKey = new TopicKey(getTopicsContextAddress2()); <line2> getTopicsContext() <line3> .publish(topicKey, MessageFormat.format(""data from subtopic 2 #{0}"", ++update2)); <line4> LOGGER.debug(UNKNOWN); <line5> } <line6> } <line7> "	"""push event 2"""	task7	
"public class A { <line0> @NotNull <line1> private LoadedStream loadEpisode( <line2> @NotNull EpisodeId id, <line3> @NotNull AudioQualityPicker audioQualityPicker, <line4> boolean preload, <line5> @Nullable HaltListener haltListener) <line6> throws IOException, MercuryClient.MercuryException, CdnManager.CdnException { <line7> Metadata.Episode episode = session.api().getMetadata4Episode(id); <line8> if (episode.hasExternalUrl()) { <line9> return CdnFeedHelper.loadEpisodeExternal(session, episode, haltListener); <line10> } else { <line11> Metadata.AudioFile file = audioQualityPicker.getFile(episode.getAudioList()); <line12> if (file == null) { <line13> LOGGER.error( <line14> ""Couldn't find any suitable audio file, available: {}"", <line15> Utils.formatsToString(episode.getAudioList())); <line16> throw new FeederException(); <line17> } <line18> return loadStream(file, null, episode, preload, haltListener); <line19> } <line20> } <line21> } <line22> "	"""Couldn't find any suitable audio file, available: {}"",Utils.formatsToString(episode.getAudioList())"	task7	
"public class A { <line0> @Test <line1> public void testGetUserInfo() throws Exception { <line2> final com.box.sdk.BoxUser.Info result = requestBody(""direct://GETUSERINFO"", testUser.getID()); <line3> assertNotNull(result, ""getUserInfo result""); <line4> LOG.debug(UNKNOWN); <line5> } <line6> } <line7> "	"""getUserInfo: "" + result"	task7	
public class A { <line0> static void runDefer(int top) { <line1> DeferStack<Runnable> sg = getNonExceptionStack(); <line2> int count = sg.size() - top; <line3> for (int i = 0; i < count; i++) { <line4> try { <line5> Runnable r = sg.pop(); <line6> r.run(); <line7> } catch (Throwable e) { <line8> logger.warn(UNKNOWN); <line9> } <line10> } <line11> } <line12> } <line13> 	"""a unhandled exception happened"", e"	task7	
"public class A { <line0> private TestCaseExecutionData property_getFromHtml( <line1> TestCaseExecutionData testCaseExecutionData, <line2> TestCaseExecution tCExecution, <line3> TestCaseCountryProperties testCaseCountryProperty, <line4> boolean forceCalculation) { <line5> if (tCExecution.getAppTypeEngine().equals(Application.TYPE_APK) <line6> || tCExecution.getAppTypeEngine().equals(Application.TYPE_IPA) <line7> || tCExecution.getAppTypeEngine().equals(Application.TYPE_GUI)) { <line8> try { <line9> Identifier identifier = <line10> identifierService.convertStringToIdentifier(testCaseExecutionData.getValue1()); <line11> String valueFromHTML = <line12> this.webdriverService.getValueFromHTML(tCExecution.getSession(), identifier); <line13> if (valueFromHTML != null) { <line14> testCaseExecutionData.setValue(valueFromHTML); <line15> MessageEvent res = new MessageEvent(MessageEventEnum.PROPERTY_SUCCESS_HTML); <line16> res.setDescription( <line17> res.getDescription().replace(""%ELEMENT%"", testCaseExecutionData.getValue1())); <line18> res.setDescription(res.getDescription().replace(""%VALUE%"", valueFromHTML)); <line19> testCaseExecutionData.setPropertyResultMessage(res); <line20> } <line21> } catch (NoSuchElementException exception) { <line22> LOG.debug(UNKNOWN); <line23> MessageEvent res = <line24> new MessageEvent(MessageEventEnum.PROPERTY_FAILED_HTML_ELEMENTDONOTEXIST); <line25> res.setDescription( <line26> res.getDescription().replace(""%ELEMENT%"", testCaseExecutionData.getValue1())); <line27> testCaseExecutionData.setPropertyResultMessage(res); <line28> } <line29> } else { <line30> MessageEvent res = new MessageEvent(MessageEventEnum.PROPERTY_FAILED_FEATURENOTSUPPORTED); <line31> res.setDescription(res.getDescription().replace(""%APPTYPE%"", tCExecution.getAppTypeEngine())); <line32> res.setDescription( <line33> res.getDescription().replace(""%PROPTYPE%"", testCaseExecutionData.getType())); <line34> } <line35> return testCaseExecutionData; <line36> } <line37> } <line38> "	exception.toString()	task7	
"public class A { <line0> @GetMapping(RestApi.DOWNLOAD_ARCHIVE_UNIT + CommonConstants.PATH_ID) <line1> @Secured(ServicesData.ROLE_GET_ARCHIVE) <line2> public ResponseEntity<Resource> downloadObjectFromUnit( <line3> final @PathVariable(""id"") String id, <line4> final @RequestParam(""usage"") String usage, <line5> final @RequestParam(""version"") Integer version) { <line6> LOGGER.info(UNKNOWN); <line7> ParameterChecker.checkParameter(""The Identifier is a mandatory parameter: "", id); <line8> return archivesSearchExternalService.downloadObjectFromUnit(id, usage, version); <line9> } <line10> } <line11> "	"""Download the Archive Unit Object with id {} "", id"	task7	
public class A { <line0> public static boolean registerNewPublicEncodingProvider(Class<?> clazz, String functionName) { <line1> try { <line2> var method = clazz.getDeclaredMethod(functionName, String.class, String.class); <line3> if (!Modifier.isStatic(method.getModifiers())) return false; <line4> if (!method.getReturnType().isAssignableFrom(PublicKey.class)) return false; <line5> externalPublicProviders.add(method); <line6> return true; <line7> } catch (NoSuchMethodException | SecurityException e) { <line8> logger.error(UNKNOWN); <line9> return false; <line10> } <line11> } <line12> } <line13> 	"""Exception registering new public encoding provider"", e"	task7	
"public class A { <line0> @Override <line1> public DataSmResult onAcceptDataSm(DataSm dataSm, Session source) throws ProcessRequestException { <line2> MessageId messageId = messageIDGenerator.newMessageId(); <line3> OptionalParameter.Message_payload messagePayload = <line4> (OptionalParameter.Message_payload) <line5> dataSm.getOptionalParameter(OptionalParameter.Tag.MESSAGE_PAYLOAD); <line6> LOGGER.info( <line7> ""Receiving data_sm {}, and return message id {}"", <line8> messagePayload.getValueAsString(), <line9> messageId.getValue()); <line10> requestCounter.incrementAndGet(); <line11> DataSmResult dataSmResult = new DataSmResult(messageId, new OptionalParameter[] {}); <line12> return dataSmResult; <line13> } <line14> } <line15> "	"""Receiving data_sm {}, and return message id {}"",messagePayload.getValueAsString(),messageId.getValue()"	task7	
"public class A { <line0> @Override <line1> public void before(Object target, Object arg0) { <line2> final InterceptorScopeInvocation transaction = scope.getCurrentInvocation(); <line3> if (transaction.tryEnter(policy)) { <line4> try { <line5> this.interceptor.before(target, arg0); <line6> } catch (Throwable t) { <line7> exceptionHandler.handleException(t); <line8> } <line9> } else { <line10> if (debugEnabled) { <line11> logger.debug( <line12> ""tryBefore() returns false: interceptorScopeTransaction: {}, executionPoint: {}. Skip"" <line13> + "" interceptor {}"", <line14> transaction, <line15> policy, <line16> interceptor.getClass()); <line17> } <line18> } <line19> } <line20> } <line21> "	"""tryBefore() returns false: interceptorScopeTransaction: {}, executionPoint: {}. Skip""+ "" interceptor {}"",transaction,policy,interceptor.getClass()"	task7	
"public class A { <line0> static HTTPAuthNTokens getHTTPCredentials( <line1> String authorizationHeader, Logger log, boolean urlEncoded) { <line2> if (authorizationHeader == null) return null; <line3> if (!authorizationHeader.startsWith(""Basic "")) return null; <line4> String encoded = authorizationHeader.substring(6); <line5> String decoded = <line6> new String( <line7> Base64.decode(encoded.getBytes(StandardCharsets.US_ASCII)), StandardCharsets.US_ASCII); <line8> if (decoded.isEmpty()) { <line9> log.warn( <line10> ""Ignoring malformed Authorization HTTP header element"" + "" (empty string after decode)""); <line11> return null; <line12> } <line13> int colon = decoded.indexOf(':'); <line14> String[] split; <line15> if (colon == -1) { <line16> split = new String[] {decoded}; <line17> } else { <line18> if (colon < decoded.length() - 1) <line19> split = new String[] {decoded.substring(0, colon), decoded.substring(colon + 1)}; <line20> else split = new String[] {decoded.substring(0, colon), """"}; <line21> } <line22> String username = urlDecodeIfNeeded(split[0], urlEncoded); <line23> String secret = split.length == 1 ? null : urlDecodeIfNeeded(split[1], urlEncoded); <line24> return new HTTPAuthNTokens(username, secret); <line25> } <line26> } <line27> "	"""Ignoring malformed Authorization HTTP header element"" + "" (empty string after decode)"""	task7	
public class A { <line0> @Override <line1> public Boolean addFavoriteStation(RadioStation newFavoriteStation) throws ApplicationException { <line2> logger.error(UNKNOWN); <line3> throw new UnsupportedOperationException(); <line4> } <line5> } <line6> 	"""Not implemented."""	task7	
"public class A { <line0> private List<InputType> generateInput(String key, String value) { <line1> List<InputType> inputs = New.list(); <line2> String[] values = new String[] {value}; <line3> if (""BBOX"".equalsIgnoreCase(key)) { <line4> values = value.split("" ""); <line5> } else if (""FILTER"".equalsIgnoreCase(key)) { <line6> try { <line7> values[0] = FilterCreator.bboxToFilterString(value); <line8> } catch (IllegalArgumentException | JAXBException e) { <line9> LOGGER.error(UNKNOWN); <line10> } <line11> } <line12> for (String aValue : values) { <line13> InputType input = new InputType(); <line14> CodeType inputIdentifier = new CodeType(); <line15> inputIdentifier.setValue(key); <line16> input.setIdentifier(inputIdentifier); <line17> DataType data = new DataType(); <line18> LiteralDataType literal = new LiteralDataType(); <line19> literal.setValue(aValue); <line20> data.setLiteralData(literal); <line21> input.setData(data); <line22> inputs.add(input); <line23> } <line24> return inputs; <line25> } <line26> } <line27> "	e, e	task7	
public class A { <line0> public synchronized void setBitstring(@Nonnull String aspect, @Nonnull String bitString) { <line1> if (aspectToOutput.containsKey(aspect)) { <line2> log.debug(UNKNOWN); <line3> aspectToOutput.remove(aspect); <line4> } <line5> char[] bitArray = bitString.toCharArray(); <line6> aspectToOutput.put(aspect, bitArray); <line7> } <line8> } <line9> 	"""Aspect {} is already defined so will override"", aspect"	task7	
"public class A { <line0> public static StatelessBootstrap bootstrap( <line1> final StatelessEngineConfiguration engineConfiguration, final ClassLoader rootClassLoader) <line2> throws IOException { <line3> final File narDirectory = engineConfiguration.getNarDirectory(); <line4> final File workingDirectory = engineConfiguration.getWorkingDirectory(); <line5> if (!workingDirectory.exists() && !workingDirectory.mkdirs()) { <line6> throw new IOException( <line7> ""Working Directory "" + workingDirectory + "" does not exist and could not be created""); <line8> } <line9> final Bundle systemBundle = <line10> SystemBundle.create(narDirectory.getAbsolutePath(), ClassLoader.getSystemClassLoader()); <line11> final File frameworkWorkingDir = new File(workingDirectory, ""nifi-framework""); <line12> final File extensionsWorkingDir = new File(workingDirectory, ""extensions""); <line13> final List<Path> narDirectories = Collections.singletonList(narDirectory.toPath()); <line14> final long unpackStart = System.currentTimeMillis(); <line15> final Predicate<BundleCoordinate> narFilter = coordinate -> true; <line16> NarUnpackLock.lock(); <line17> try { <line18> NarUnpacker.unpackNars( <line19> systemBundle, <line20> frameworkWorkingDir, <line21> extensionsWorkingDir, <line22> null, <line23> narDirectories, <line24> false, <line25> NarClassLoaders.FRAMEWORK_NAR_ID, <line26> false, <line27> false, <line28> narFilter); <line29> } finally { <line30> NarUnpackLock.unlock(); <line31> } <line32> final long unpackMillis = System.currentTimeMillis() - unpackStart; <line33> logger.info(UNKNOWN); <line34> final File statelessNarWorkingDir = locateStatelessNarWorkingDirectory(extensionsWorkingDir); <line35> final File statelessNarInf = new File(statelessNarWorkingDir, ""NAR-INF""); <line36> final File statelessNarDependencies = new File(statelessNarInf, ""bundled-dependencies""); <line37> final File[] statelessNarContents = statelessNarDependencies.listFiles(); <line38> if (statelessNarContents == null || statelessNarContents.length == 0) { <line39> throw new IOException( <line40> ""Could not access contents of Stateless NAR dependencies at "" + statelessNarDependencies); <line41> } <line42> final URL[] urls = new URL[statelessNarContents.length]; <line43> for (int i = 0; i < statelessNarContents.length; i++) { <line44> final File dependency = statelessNarContents[i]; <line45> final URL url = dependency.toURI().toURL(); <line46> urls[i] = url; <line47> } <line48> final URLClassLoader statelessClassLoader = new URLClassLoader(urls, rootClassLoader); <line49> Thread.currentThread().setContextClassLoader(statelessClassLoader); <line50> return new StatelessBootstrap(statelessClassLoader, engineConfiguration); <line51> } <line52> } <line53> "	"""Unpacked NAR files in {} millis"", unpackMillis"	task7	
public class A { <line0> public void addPart(final Part part) { <line1> LOG.trace(UNKNOWN); <line2> parameters.add(part); <line3> } <line4> } <line5> 	"""enter addPart(Part part)"""	task7	
public class A { <line0> private void validateCron(String cron) { <line1> try { <line2> CronExpression.validateExpression(cron); <line3> } catch (ParseException e) { <line4> log.error(UNKNOWN); <line5> throw new JobException(e); <line6> } <line7> } <line8> } <line9> 	"""validate cron failed"", e"	task7	
"public class A { <line0> @Override <line1> public void get(ServiceContext ctx, String id, DocumentHandler handler) <line2> throws DocumentNotFoundException, DocumentException { <line3> DocumentFilter docFilter = handler.getDocumentFilter(); <line4> if (docFilter == null) { <line5> docFilter = handler.createDocumentFilter(); <line6> } <line7> JPATransactionContext jpaConnectionContext = (JPATransactionContext) ctx.openConnection(); <line8> try { <line9> handler.prepare(Action.GET); <line10> Object o = null; <line11> String whereClause = "" where id = :id""; <line12> HashMap<String, Object> params = new HashMap<String, Object>(); <line13> params.put(""id"", id); <line14> o = <line15> JpaStorageUtils.getEntity( <line16> ""org.collectionspace.services.account.Tenant"", whereClause, params); <line17> if (null == o) { <line18> String msg = ""Could not find entity with id="" + id; <line19> throw new DocumentNotFoundException(msg); <line20> } <line21> DocumentWrapper<Object> wrapDoc = new DocumentWrapperImpl<Object>(o); <line22> handler.handle(Action.GET, wrapDoc); <line23> handler.complete(Action.GET, wrapDoc); <line24> } catch (DocumentException de) { <line25> throw de; <line26> } catch (Exception e) { <line27> if (logger.isDebugEnabled()) { <line28> logger.debug(UNKNOWN); <line29> } <line30> throw new DocumentException(e); <line31> } finally { <line32> ctx.closeConnection(); <line33> } <line34> } <line35> } <line36> "	"""Caught exception "", e"	task7	
"public class A { <line0> @RequestMapping( <line1> value = ""/run"", <line2> method = {RequestMethod.POST, RequestMethod.PUT}) <line3> @PreAuthorize(""hasRole('ALL') or hasRole('F_PREDICTOR_RUN')"") <line4> public void runPredictors( <line5> @RequestParam Date startDate, <line6> @RequestParam Date endDate, <line7> TranslateParams translateParams, <line8> HttpServletRequest request, <line9> HttpServletResponse response) <line10> throws Exception { <line11> int count = 0; <line12> List<Predictor> allPredictors = predictorService.getAllPredictors(); <line13> for (Predictor predictor : allPredictors) { <line14> try { <line15> PredictionSummary predictionSummary = new PredictionSummary(); <line16> predictionService.predict(predictor, startDate, endDate, predictionSummary); <line17> count += predictionSummary.getPredictions(); <line18> } catch (Exception ex) { <line19> log.error(UNKNOWN); <line20> webMessageService.send( <line21> WebMessageUtils.conflict(""Unable to predict "" + predictor.getName(), ex.getMessage()), <line22> response, <line23> request); <line24> return; <line25> } <line26> } <line27> webMessageService.send( <line28> WebMessageUtils.ok(""Generated "" + count + "" predictions""), response, request); <line29> } <line30> } <line31> "	"""Unable to predict "" + predictor.getName(), ex"	task7	
"public class A { <line0> @PayloadRoot( <line1> localPart = ""UpdateDeviceSslCertificationRequest"", <line2> namespace = DEVICE_MANAGEMENT_NAMESPACE) <line3> @ResponsePayload <line4> public UpdateDeviceSslCertificationAsyncResponse updateDeviceSslCertification( <line5> @OrganisationIdentification final String organisationIdentification, <line6> @RequestPayload final UpdateDeviceSslCertificationRequest request, <line7> @MessagePriority final String messagePriority) <line8> throws OsgpException { <line9> LOGGER.info( <line10> ""Update Device Ssl Certification Request received from organisation: {} for device: {} with"" <line11> + "" message priority: {}."", <line12> organisationIdentification, <line13> request.getDeviceIdentification(), <line14> messagePriority); <line15> final UpdateDeviceSslCertificationAsyncResponse response = <line16> new UpdateDeviceSslCertificationAsyncResponse(); <line17> try { <line18> final Certification certification = <line19> this.deviceManagementMapper.map(request.getCertification(), Certification.class); <line20> final String correlationUid = <line21> this.deviceManagementService.enqueueUpdateDeviceSslCertificationRequest( <line22> organisationIdentification, <line23> request.getDeviceIdentification(), <line24> certification, <line25> MessagePriorityEnum.getMessagePriority(messagePriority)); <line26> final AsyncResponse asyncResponse = new AsyncResponse(); <line27> asyncResponse.setCorrelationUid(correlationUid); <line28> asyncResponse.setDeviceId(request.getDeviceIdentification()); <line29> response.setAsyncResponse(asyncResponse); <line30> } catch (final ConstraintViolationException e) { <line31> throw new FunctionalException( <line32> FunctionalExceptionType.VALIDATION_ERROR, <line33> ComponentType.WS_CORE, <line34> new ValidationException(e.getConstraintViolations())); <line35> } catch (final Exception e) { <line36> this.handleException(e); <line37> } <line38> return response; <line39> } <line40> } <line41> "	"""Update Device Ssl Certification Request received from organisation: {} for device: {} with""+ "" message priority: {}."",organisationIdentification,request.getDeviceIdentification(),messagePriority"	task7	
"public class A { <line0> private void sendTimeoutNowRequest(int transferee) throws TransportException { <line1> logger.info( <line2> ""Partition group {}/node {} send timeout now request to {}"", <line3> topicPartitionGroup, <line4> localReplicaId, <line5> transferee); <line6> TimeoutNowRequest request = new TimeoutNowRequest(topicPartitionGroup, currentTerm); <line7> JoyQueueHeader header = <line8> new JoyQueueHeader(Direction.REQUEST, CommandType.RAFT_TIMEOUT_NOW_REQUEST); <line9> sendCommand( <line10> getReplica(transferee).getAddress(), <line11> new Command(header, request), <line12> electionConfig.getSendCommandTimeout(), <line13> new TimeoutNowRequestCallback()); <line14> } <line15> } <line16> "	"""Partition group {}/node {} send timeout now request to {}"",topicPartitionGroup,localReplicaId,transferee"	task7	
"public class A { <line0> @Override <line1> public CreateVfModuleResponse createVfModule(String aaiVnfId, CreateVfModuleRequest req) <line2> throws VnfAdapterClientException { <line3> try { <line4> return new AdapterRestClient(this.props, this.getUri(""/"" + aaiVnfId + ""/vf-modules"").build()) <line5> .post(req, CreateVfModuleResponse.class); <line6> } catch (InternalServerErrorException e) { <line7> logger.error(UNKNOWN); <line8> throw new VnfAdapterClientException(e.getMessage()); <line9> } <line10> } <line11> } <line12> "	"""InternalServerErrorException in createVfModule"", e"	task7	
"public class A { <line0> private String extractContextKey(WebappLoader webappLoader) { <line1> final String defaultContextName = """"; <line2> try { <line3> Container container = extractContext(webappLoader); <line4> if (container instanceof Context) { <line5> Context context = (Context) container; <line6> String contextName = context.getName(); <line7> Host host = (Host) container.getParent(); <line8> Engine engine = (Engine) host.getParent(); <line9> StringBuilder sb = new StringBuilder(); <line10> sb.append(engine.getName()).append(""/"").append(host.getName()); <line11> if (!contextName.startsWith(""/"")) { <line12> sb.append('/'); <line13> } <line14> sb.append(contextName); <line15> return sb.toString(); <line16> } <line17> } catch (Exception e) { <line18> logger.warn(UNKNOWN); <line19> } <line20> return defaultContextName; <line21> } <line22> } <line23> "	"""Error extracting context name."", e"	task7	
"public class A { <line0> private boolean save(LocalDocument d, boolean partialUpdate) throws IOException, JsonException { <line1> boolean hasId = d.getID() != null; <line2> String s; <line3> long start = System.currentTimeMillis(); <line4> if (partialUpdate) { <line5> s = d.modifiedFieldsToJson(); <line6> } else { <line7> s = d.toJson(); <line8> } <line9> long startPost = System.currentTimeMillis(); <line10> HttpResponse response = core.post(getWriteUrl(partialUpdate), s); <line11> if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { <line12> if (!hasId) { <line13> LocalDocument updated = new LocalDocument(EntityUtils.toString(response.getEntity())); <line14> d.putAll(updated); <line15> } else { <line16> EntityUtils.consume(response.getEntity()); <line17> } <line18> if (isPerformanceLogging()) { <line19> long end = System.currentTimeMillis(); <line20> DocumentID<Local> docId = d.getID(); <line21> logger.info( <line22> String.format( <line23> ""type=performance event=update stage_name=%s doc_id=\""%s\"" start=%d serialize=%d"" <line24> + "" post=%d end=%d total=%d"", <line25> stageName, docId, start, startPost - start, end - startPost, end, end - start)); <line26> } <line27> return true; <line28> } <line29> logUnexpected(""save(partial="" + partialUpdate + "")"", response); <line30> return false; <line31> } <line32> } <line33> "	"String.format(""type=performance event=update stage_name=%s doc_id=\""%s\"" start=%d serialize=%d""+ "" post=%d end=%d total=%d"",stageName, docId, start, startPost - start, end - startPost, end, end - start)"	task7	
"public class A { <line0> private boolean checkCountry(TestCaseExecution tCExecution) { <line1> if (LOG.isDebugEnabled()) { <line2> LOG.debug( <line3> ""Checking if country is setup for this testcase. "" <line4> + tCExecution.getTest() <line5> + ""-"" <line6> + tCExecution.getTestCase() <line7> + ""-"" <line8> + tCExecution.getCountry()); <line9> } <line10> if (testCaseCountryService.exist( <line11> tCExecution.getTest(), tCExecution.getTestCase(), tCExecution.getCountry())) { <line12> return true; <line13> } else { <line14> message = new MessageGeneral(MessageGeneralEnum.VALIDATION_FAILED_COUNTRY_NOTDEFINED); <line15> return false; <line16> } <line17> } <line18> } <line19> "	"""Checking if country is setup for this testcase. ""+ tCExecution.getTest()+ ""-""+ tCExecution.getTestCase()+ ""-""+ tCExecution.getCountry()"	task7	
"public class A { <line0> public static int getCPInstancesCount(HttpPrincipal httpPrincipal, long groupId, int status) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CPInstanceServiceUtil.class, <line6> ""getCPInstancesCount"", <line7> _getCPInstancesCountParameterTypes13); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, status); <line9> Object returnObj = null; <line10> try { <line11> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> return ((Integer) returnObj).intValue(); <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> log.error(UNKNOWN); <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	systemException, systemException	task7	
"public class A { <line0> @Test <line1> public void test04NumberFilter() { <line2> LOGGER.info(UNKNOWN); <line3> filterAndCheck( <line4> service.things(), <line5> ""properties/int eq "" + THINGS.get(2).getProperties().get(""int""), <line6> getFromList(THINGS, 2)); <line7> filterAndCheck( <line8> service.observations(), <line9> ""parameters/int eq "" + OBSERVATIONS.get(2).getParameters().get(""int""), <line10> getFromList(OBSERVATIONS, 2)); <line11> filterAndCheck(service.things(), ""properties/int gt 9"", getFromList(THINGS, 2, 3)); <line12> filterAndCheck( <line13> service.observations(), ""parameters/int gt 8"", getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line14> filterAndCheck(service.things(), ""properties/int lt 9"", getFromList(THINGS, 0)); <line15> filterAndCheck( <line16> service.observations(), <line17> ""parameters/int lt 8"", <line18> getFromList(OBSERVATIONS, 0, 1, 2, 3, 4, 5, 6, 7)); <line19> filterAndCheck(service.things(), ""properties/intArray[1] gt 10"", getFromList(THINGS, 2, 3)); <line20> filterAndCheck( <line21> service.observations(), <line22> ""parameters/intArray[1] gt 9"", <line23> getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line24> filterAndCheck(service.things(), ""properties/intArray[1] lt 10"", getFromList(THINGS, 0)); <line25> filterAndCheck( <line26> service.observations(), <line27> ""parameters/intArray[1] lt 9"", <line28> getFromList(OBSERVATIONS, 0, 1, 2, 3, 4, 5, 6, 7)); <line29> filterAndCheck( <line30> service.things(), ""properties/intIntArray[1][0] gt 10"", getFromList(THINGS, 2, 3)); <line31> filterAndCheck( <line32> service.observations(), <line33> ""parameters/intIntArray[1][0] gt 9"", <line34> getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line35> filterAndCheck( <line36> service.things(), ""properties/objArray[1]/intArray[0] gt 10"", getFromList(THINGS, 2, 3)); <line37> filterAndCheck( <line38> service.observations(), <line39> ""parameters/objArray[1]/intArray[0] gt 9"", <line40> getFromList(OBSERVATIONS, 9, 10, 11, 12)); <line41> } <line42> } <line43> "	"""  test04NumberFilter"""	task7	
"public class A { <line0> public static Collection<Class<?>> discover(final String scanPath) { <line1> if (StringUtils.isBlank(scanPath)) { <line2> throw new IllegalStateException(""Please specify the [scanPath]""); <line3> } <line4> LOGGER.debug(UNKNOWN); <line5> final Collection<Class<?>> ret = new HashSet<>(); <line6> final String[] splitPaths = scanPath.split("",""); <line7> final String[] paths = ArrayUtils.concatenate(splitPaths, BUILT_IN_COMPONENT_PKGS); <line8> final Set<URL> urls = new LinkedHashSet<>(); <line9> for (String path : paths) { <line10> path = path.replaceAll(""\\."", ""/"") + ""/**/*.class""; <line11> urls.addAll(ClassPathResolver.getResources(path)); <line12> } <line13> try { <line14> for (final URL url : urls) { <line15> final DataInputStream classInputStream = new DataInputStream(url.openStream()); <line16> final ClassFile classFile = new ClassFile(classInputStream); <line17> final String className = classFile.getName(); <line18> final AnnotationsAttribute annotationsAttribute = <line19> (AnnotationsAttribute) classFile.getAttribute(AnnotationsAttribute.visibleTag); <line20> if (null == annotationsAttribute) { <line21> LOGGER.log(Level.TRACE, ""The class [name={}] is not a bean"", className); <line22> continue; <line23> } <line24> final ConstPool constPool = classFile.getConstPool(); <line25> final Annotation[] annotations = annotationsAttribute.getAnnotations(); <line26> boolean maybeBeanClass = false; <line27> for (final Annotation annotation : annotations) { <line28> final String typeName = annotation.getTypeName(); <line29> if (typeName.equals(Singleton.class.getName())) { <line30> maybeBeanClass = true; <line31> break; <line32> } <line33> if (typeName.equals(Service.class.getName()) <line34> || typeName.equals(Repository.class.getName())) { <line35> final Annotation singletonAnnotation = <line36> new Annotation(Singleton.class.getName(), constPool); <line37> annotationsAttribute.addAnnotation(singletonAnnotation); <line38> classFile.addAttribute(annotationsAttribute); <line39> classFile.setVersionToJava5(); <line40> maybeBeanClass = true; <line41> break; <line42> } <line43> } <line44> if (maybeBeanClass) { <line45> Class<?> clz = null; <line46> try { <line47> clz = Thread.currentThread().getContextClassLoader().loadClass(className); <line48> } catch (final ClassNotFoundException e) { <line49> LOGGER.log(Level.ERROR, ""Loads class ["" + className + ""] failed"", e); <line50> } <line51> ret.add(clz); <line52> } <line53> } <line54> } catch (final Exception e) { <line55> LOGGER.log(Level.ERROR, ""Load classes failed"", e); <line56> } <line57> return ret; <line58> } <line59> } <line60> "	"""scanPath["" + scanPath + ""]"""	task7	
"public class A { <line0> @Test(enabled = false) <line1> public void testRandomIdRandomness() { <line2> int collisionTestCnt = 100000; <line3> int sampleSize = 2000; <line4> int duplicateTests = 0; <line5> for (int testIdx = 0; testIdx < collisionTestCnt; testIdx++) { <line6> Set<String> randomIds = new HashSet<String>(); <line7> for (int sampleCnt = 0; sampleCnt < sampleSize; sampleCnt++) { <line8> if (!randomIds.add(Identifiers.makeRandomId(4))) { <line9> duplicateTests++; <line10> break; <line11> } <line12> } <line13> } <line14> double probability = ((double) duplicateTests) * 100 / collisionTestCnt; <line15> log.info(UNKNOWN); <line16> Assert.assertEquals( <line17> probability, <line18> 15, <line19> 0.5d, <line20> ""Expected probability of collision with id of length 4 and 2000 samples is 15%.""); <line21> } <line22> } <line23> "	"""testRandomIdRandomness probability = "" + probability"	task7	
"public class A { <line0> public static List<String> generate( <line1> int recordCount, long startTime, long endTime, String tableName, String prj) { <line2> Preconditions.checkArgument(startTime < endTime); <line3> Preconditions.checkArgument(recordCount > 0); <line4> KylinConfig kylinConfig = KylinConfig.getInstanceFromEnv(); <line5> TableDesc tableDesc = <line6> TableMetadataManager.getInstance(kylinConfig).getTableDesc(tableName, prj); <line7> SortedMultiset<Long> times = TreeMultiset.create(); <line8> Random r = new Random(); <line9> for (int i = 0; i < recordCount; i++) { <line10> long t = startTime + (long) ((endTime - startTime) * r.nextDouble()); <line11> times.add(t); <line12> } <line13> List<String> ret = Lists.newArrayList(); <line14> HashMap<String, String> kvs = Maps.newHashMap(); <line15> HashMap<String, Integer> itemCategory = Maps.newHashMap(); <line16> for (long time : times) { <line17> kvs.clear(); <line18> kvs.put(COLUMN_TIMESTAMP, String.valueOf(time)); <line19> for (ColumnDesc columnDesc : tableDesc.getColumns()) { <line20> String lowerCaseColumnName = columnDesc.getName().toLowerCase(Locale.ROOT); <line21> DataType dataType = columnDesc.getType(); <line22> if (dataType.isDateTimeFamily()) { <line23> continue; <line24> } else if (dataType.isStringFamily()) { <line25> char c = (char) ('A' + (int) (26 * r.nextDouble())); <line26> kvs.put(lowerCaseColumnName, String.valueOf(c)); <line27> } else if (dataType.isIntegerFamily()) { <line28> int v; <line29> if (COLUMN_CATEGORY.equals(lowerCaseColumnName)) { <line30> String itm = kvs.get(COLUMN_ITEM); <line31> if (itemCategory.get(itm) == null) { <line32> v = r.nextInt(10); <line33> itemCategory.put(itm, v); <line34> } else { <line35> v = itemCategory.get(itm); <line36> } <line37> } else { <line38> v = r.nextInt(10000); <line39> } <line40> kvs.put(lowerCaseColumnName, String.valueOf(v)); <line41> } else if (dataType.isNumberFamily()) { <line42> String v = String.format(Locale.ROOT, ""%.4f"", r.nextDouble() * 100); <line43> kvs.put(lowerCaseColumnName, v); <line44> } <line45> } <line46> try { <line47> ret.add(mapper.writeValueAsString(kvs)); <line48> } catch (JsonProcessingException e) { <line49> logger.error(UNKNOWN); <line50> } <line51> } <line52> return ret; <line53> } <line54> } <line55> "	"""error!"", e"	task7	
"public class A { <line0> private Object unionToMongo( <line1> final String docf, <line2> final Schema fieldSchema, <line3> final DocumentFieldType storeType, <line4> final Object value) { <line5> Object result; <line6> Type type0 = fieldSchema.getTypes().get(0).getType(); <line7> Type type1 = fieldSchema.getTypes().get(1).getType(); <line8> if (!type0.equals(type1) && (type0.equals(Type.NULL) || type1.equals(Type.NULL))) { <line9> Schema innerSchema = fieldSchema.getTypes().get(1); <line10> LOG.debug( <line11> ""Transform value to DBObject (UNION), schemaType:{}, type1:{}, storeType:{}"", <line12> new Object[] {innerSchema.getType(), type1, storeType}); <line13> result = toDocument(docf, innerSchema, type1, storeType, value); <line14> } else { <line15> throw new IllegalStateException( <line16> ""MongoStore doesn't support 3 types union field yet. Please update your mapping""); <line17> } <line18> return result; <line19> } <line20> } <line21> "	"""Transform value to DBObject (UNION), schemaType:{}, type1:{}, storeType:{}"",new Object[] {innerSchema.getType(), type1, storeType}"	task7	
"public class A { <line0> public void activate(boolean b) { <line1> if (b) { <line2> if (myThread == null) { <line3> log.info(UNKNOWN); <line4> active = true; <line5> myThread = <line6> new Thread(this, String.format(""%s.%s.checkpoint"", watchDogTimerName, checkPointName)); <line7> myThread.start(); <line8> } <line9> } else { <line10> if (myThread != null) { <line11> active = false; <line12> myThread = null; <line13> } <line14> } <line15> } <line16> } <line17> "	"""activating {} checkpoint worker"", checkPointIntervalMs"	task7	
public class A { <line0> @Override <line1> public void onError(Throwable throwable) { <line2> logger.error(UNKNOWN); <line3> XdsSchedulerManager.getInstance().startApplicationPolicyDiscoveryScheduling(); <line4> nack(throwable); <line5> } <line6> } <line7> 	"""Error occurred during Application Policy discovery"", throwable"	task7	
public class A { <line0> @Before <line1> public void clearZkDir() throws IOException { <line2> LOG.debug(UNKNOWN); <line3> File zkDirFile = new File(zkDir); <line4> FileUtils.deleteDirectory(zkDirFile); <line5> zkDirFile.mkdirs(); <line6> } <line7> } <line8> 	"""deleting zk data dir ("" + zkDir + "")"""	task7	
"public class A { <line0> @Override <line1> public void run() { <line2> long currentTime = 0L; <line3> long lastCleanup = 0L; <line4> long lastDiscovery = 0L; <line5> while (running) { <line6> try { <line7> currentTime = System.currentTimeMillis(); <line8> while (!inputQueue.isEmpty() <line9> && currentTime < lastDiscovery + discoveryInterval <line10> && currentTime < lastCleanup + discoveryIntervalStep) { <line11> currentTime = System.currentTimeMillis(); <line12> final Envelope envelope = inputQueue.poll(); <line13> if (envelope != null) { <line14> final AbstractMessage message = envelope.getMessage(); <line15> onMessage(message); <line16> final String ackKey = message.getId() + ""-ack""; <line17> if (getData(ackKey) == null) { <line18> message.onMessage(this, envelope.getPeer()); <line19> broadcast(message); <line20> setData(ackKey, true); <line21> } <line22> } <line23> } <line24> if (currentTime > lastDiscovery + discoveryInterval) { <line25> lastDiscovery = currentTime; <line26> send( <line27> new PeerInfo(getPublicKey(), repository.getUuid(), initialPeer, START_PORT), <line28> new Discovery(getContentHash())); <line29> if (discoveryInterval < finalDiscoveryInterval) { <line30> discoveryInterval += discoveryIntervalStep; <line31> } <line32> } <line33> if (currentTime > lastCleanup + discoveryIntervalStep) { <line34> lastCleanup = currentTime; <line35> for (final Iterator<PeerInfo> it = peers.values().iterator(); it.hasNext(); ) { <line36> final PeerInfo peer = it.next(); <line37> final long time = <line38> peer.getLastSeen() + finalDiscoveryInterval + (discoveryIntervalStep * 2); <line39> if (currentTime > time) { <line40> onRemovePeer(peer); <line41> it.remove(); <line42> } <line43> } <line44> } <line45> Thread.sleep(10L); <line46> } catch (Throwable t) { <line47> logger.warn(UNKNOWN); <line48> } <line49> } <line50> executorService.shutdownNow(); <line51> } <line52> } <line53> "	""""", t"	task7	
public class A { <line0> @Override <line1> public List<Notification> getNotifications(List<String> notificationIds) { <line2> LOG.debug(UNKNOWN); <line3> return notificationStore <line4> .map(s -> s.getNotifications(notificationIds)) <line5> .orElse(Collections.emptyList()); <line6> } <line7> } <line8> 	"""getNotifications with notificationIds {}"", notificationIds"	task7	
public class A { <line0> @Override <line1> public synchronized void purge() { <line2> try { <line3> consumers.stop(); <line4> consumers.start(); <line5> } catch (Exception e) { <line6> LOG.debug(UNKNOWN); <line7> } <line8> if (statistics != null) { <line9> statistics.clear(); <line10> } <line11> } <line12> } <line13> 	"""Error restarting consumer pool"", e"	task7	
"public class A { <line0> @Override <line1> public void stop() { <line2> if (logger.isDebugEnabled()) { <line3> final ArrayList<MatcherTimer> matcherTimers = <line4> new ArrayList<>(ElasticApmAgent.getMatcherTimers()); <line5> Collections.sort(matcherTimers); <line6> StringBuilder sb = <line7> new StringBuilder() <line8> .append(""Total time spent matching: "") <line9> .append(String.format(""%,d"", ElasticApmAgent.getTotalMatcherTime())) <line10> .append(""ns"") <line11> .append('\n') <line12> .append(MatcherTimer.getTableHeader()) <line13> .append('\n'); <line14> for (MatcherTimer matcherTimer : matcherTimers) { <line15> sb.append(matcherTimer.toString()).append('\n'); <line16> } <line17> logger.debug(UNKNOWN); <line18> } <line19> } <line20> } <line21> "	sb.toString()	task7	
"public class A { <line0> protected void postStartCustom() { <line1> boolean result = false; <line2> result |= tryCheckStartPid(); <line3> result |= tryCheckStartService(); <line4> result |= tryCheckStartWindowsService(); <line5> if (!result) { <line6> log.warn(UNKNOWN); assuming yes""); <line7> } <line8> entity().sensors().set(SoftwareProcess.SERVICE_UP, true); <line9> } <line10> } <line11> "	"""No way to check whether "" + entity() + "" is running; assuming yes"""	task7	
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Shape""}, <line2> description = ""extra columns"", <line3> priority = 243) <line4> public void verifyTest_2_8() throws Exception { <line5> log.info(UNKNOWN); <line6> Context context = new Context(); <line7> CheckPointReport result = <line8> verifyValidation( <line9> log, context, ""shape_8"", GTFS_1_GTFS_Common_11, SEVERITY.WARNING, RESULT.NOK, true); <line10> Assert.assertEquals(result.getCheckPointErrorCount(), 2, ""detail count""); <line11> for (CheckPointErrorReport detail : getDetails(context, result)) { <line12> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line13> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line14> Assert.assertEquals( <line15> detail.getSource().getFile().getFilename(), ""shapes.txt"", ""detail must refer bad file""); <line16> Assert.assertEquals( <line17> detail.getSource().getFile().getLineNumber(), <line18> Integer.valueOf(1), <line19> ""detail must refer bad line""); <line20> } <line21> } <line22> } <line23> "	"Color.GREEN + ""Shape_8 : extra column detected"" + Color.NORMAL"	task7	
public class A { <line0> @Override <line1> public void put( <line2> final LogicalDatastoreType store, <line3> final YangInstanceIdentifier path, <line4> final NormalizedNode<?, ?> data) { <line5> checkOpen(); <line6> LOG.debug(UNKNOWN); <line7> processTransactionOperation(facade -> facade.put(store, path, data)); <line8> } <line9> } <line10> 	"""{}: Put {} {}"", id, store, path"	task7	
public class A { <line0> private static EEffect getConditionAsEffect(ServiceConditionEnumeration condition) { <line1> switch (condition) { <line2> case CANCELLED: <line3> case NO_SERVICE: <line4> return EEffect.NO_SERVICE; <line5> case DELAYED: <line6> return EEffect.SIGNIFICANT_DELAYS; <line7> case DIVERTED: <line8> return EEffect.DETOUR; <line9> case ADDITIONAL_SERVICE: <line10> case EXTENDED_SERVICE: <line11> case SHUTTLE_SERVICE: <line12> case SPECIAL_SERVICE: <line13> case REPLACEMENT_SERVICE: <line14> return EEffect.ADDITIONAL_SERVICE; <line15> case DISRUPTED: <line16> case INTERMITTENT_SERVICE: <line17> case SHORT_FORMED_SERVICE: <line18> return EEffect.REDUCED_SERVICE; <line19> case ALTERED: <line20> case ARRIVES_EARLY: <line21> case REPLACEMENT_TRANSPORT: <line22> case SPLITTING_TRAIN: <line23> return EEffect.MODIFIED_SERVICE; <line24> case ON_TIME: <line25> case FULL_LENGTH_SERVICE: <line26> case NORMAL_SERVICE: <line27> return EEffect.OTHER_EFFECT; <line28> case UNDEFINED_SERVICE_INFORMATION: <line29> case UNKNOWN: <line30> return EEffect.UNKNOWN_EFFECT; <line31> default: <line32> log.warn(UNKNOWN); <line33> return EEffect.UNKNOWN_EFFECT; <line34> } <line35> } <line36> } <line37> 	"""unknown condition: "" + condition"	task7	
"public class A { <line0> @Override <line1> public List<ConfidenceData> getDataAfterTimestampGranularityInBin( <line2> String crisisCode, <line3> String attributeCode, <line4> String labelCode, <line5> Long timestamp, <line6> Long granularity, <line7> Integer bin) { <line8> Criteria criteria = getCurrentSession().createCriteria(ConfidenceData.class); <line9> Criterion criterion = <line10> Restrictions.conjunction() <line11> .add(Restrictions.eq(""crisisCode"", crisisCode)) <line12> .add(Restrictions.eq(""attributeCode"", attributeCode)) <line13> .add(Restrictions.eq(""labelCode"", labelCode)) <line14> .add(Restrictions.ge(""timestamp"", timestamp)) <line15> .add(Restrictions.eq(""granularity"", granularity)) <line16> .add(Restrictions.eq(""bin"", bin)); <line17> criteria.add(criterion); <line18> try { <line19> List<ConfidenceData> objList = (List<ConfidenceData>) criteria.list(); <line20> return objList; <line21> } catch (HibernateException e) { <line22> logger.error(UNKNOWN); <line23> e.printStackTrace(); <line24> } <line25> return null; <line26> } <line27> } <line28> "	"""exception"", e"	task7	
public class A { <line0> @Override <line1> public void disconnect(int disconnectCause) <line2> throws InternalException, IllegalDiameterStateException { <line3> super.disconnect(disconnectCause); <line4> if (getState(PeerState.class) != PeerState.DOWN) { <line5> stopping = true; <line6> try { <line7> FsmEvent event = new FsmEvent(STOP_EVENT); <line8> event.setData(disconnectCause); <line9> fsm.handleEvent(event); <line10> } catch (OverloadException e) { <line11> stopping = false; <line12> logger.warn(UNKNOWN); <line13> } <line14> } <line15> } <line16> } <line17> 	"""Error during stopping procedure"", e"	task7	
public class A { <line0> private Document filterBeforeDiff(Document document, List<XMLDiffFilter> filters) { <line1> for (XMLDiffFilter filter : filters) { <line2> try { <line3> filter.before(document); <line4> } catch (Exception e) { <line5> this.warn(UNKNOWN); <line6> } <line7> } <line8> return document; <line9> } <line10> } <line11> 	"""Failed to apply filter before diff."", e"	task7	
"public class A { <line0> @GET <line1> @Path(""/users/{id}"") <line2> @Timed <line3> public Response getUser(@PathParam(""id"") Long userId, @Context SecurityContext securityContext) { <line4> if (!SecurityUtil.hasRole(authorizer, securityContext, ROLE_SECURITY_ADMIN)) { <line5> LOG.debug( <line6> ""Allowing logged-in user '{}'"", <line7> SecurityUtil.getUserName(securityContext.getUserPrincipal().getName())); <line8> } <line9> User user = catalogService.getUser(userId); <line10> if (user != null) { <line11> return WSUtils.respondEntity(user, OK); <line12> } <line13> throw EntityNotFoundException.byId(userId.toString()); <line14> } <line15> } <line16> "	"""Allowing logged-in user '{}'"",SecurityUtil.getUserName(securityContext.getUserPrincipal().getName())"	task7	
public class A { <line0> private void closeConnection(Connection c) { <line1> try { <line2> c.close(); <line3> } catch (Exception e) { <line4> LOG.debug(UNKNOWN); <line5> } <line6> } <line7> } <line8> 	"""exception on close of: "" + c, e"	task7	
public class A { <line0> @Override <line1> @GraphTransaction <line2> public BulkImportResponse bulkCreateOrUpdateBusinessAttributes( <line3> InputStream inputStream, String fileName) throws AtlasBaseException { <line4> BulkImportResponse ret = new BulkImportResponse(); <line5> if (StringUtils.isBlank(fileName)) { <line6> throw new AtlasBaseException(AtlasErrorCode.FILE_NAME_NOT_FOUND, fileName); <line7> } <line8> List<String[]> fileData = FileUtils.readFileData(fileName, inputStream); <line9> Map<String, AtlasEntity> attributesToAssociate = getBusinessMetadataDefList(fileData, ret); <line10> for (AtlasEntity entity : attributesToAssociate.values()) { <line11> Map<String, Map<String, Object>> businessAttributes = entity.getBusinessAttributes(); <line12> String guid = entity.getGuid(); <line13> try { <line14> addOrUpdateBusinessAttributes(guid, businessAttributes, true); <line15> ret.addToSuccessImportInfoList(new ImportInfo(guid, businessAttributes.toString())); <line16> } catch (Exception e) { <line17> LOG.error(UNKNOWN); <line18> ret.addToFailedImportInfoList( <line19> new ImportInfo(guid, businessAttributes.toString(), FAILED, e.getMessage())); <line20> } <line21> } <line22> return ret; <line23> } <line24> } <line25> 	"""Error occurred while updating BusinessMetadata Attributes for Entity "" + guid"	task7	
"public class A { <line0> @Override <line1> public void addTestData(URI file, String datatype, Set<String> indexes) throws IOException { <line2> Assert.assertFalse( <line3> ""datatype has already been configured("" + datatype + "")"", <line4> this.rawData.containsKey(datatype)); <line5> try (final Reader reader = Files.newBufferedReader(Paths.get(file)); <line6> final CSVReader csv = new CSVReader(reader)) { <line7> String[] data; <line8> int count = 0; <line9> Set<RawData> ipData = new HashSet<>(); <line10> while (null != (data = csv.readNext())) { <line11> final RawData raw = new IpAddrRawData(datatype, data); <line12> ipData.add(raw); <line13> count++; <line14> } <line15> this.rawData.put(datatype, ipData); <line16> this.rawDataIndex.put(datatype, indexes); <line17> log.info(UNKNOWN); <line18> } <line19> } <line20> } <line21> "	"""ip address test data("" + file + "") count("" + count + "")"""	task7	
public class A { <line0> @Override <line1> public CommercePriceList remove(Serializable primaryKey) throws NoSuchPriceListException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> CommercePriceList commercePriceList = <line6> (CommercePriceList) session.get(CommercePriceListImpl.class, primaryKey); <line7> if (commercePriceList == null) { <line8> if (log.isDebugEnabled()) { <line9> log.debug(UNKNOWN); <line10> } <line11> throw new NoSuchPriceListException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line12> } <line13> return remove(commercePriceList); <line14> } catch (NoSuchPriceListException noSuchEntityException) { <line15> throw noSuchEntityException; <line16> } catch (Exception exception) { <line17> throw processException(exception); <line18> } finally { <line19> closeSession(session); <line20> } <line21> } <line22> } <line23> 	_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey	task7	
public class A { <line0> @Override <line1> public void doAction() { <line2> try { <line3> markDone(); <line4> getHolder().stop(); <line5> } catch (Exception e) { <line6> logger.info(UNKNOWN); <line7> } <line8> } <line9> } <line10> 	"""[doAction][{}] stop fail"", getHolder().clusterName()"	task7	
"public class A { <line0> private Map<String, Object> downloadFilesInFolder(String path) throws DropboxException { <line1> try { <line2> ListFolderResult folderResult = client.files().listFolder(path.equals(""/"") ? """" : path); <line3> Map<String, Object> returnMap = new LinkedHashMap<>(); <line4> for (Metadata entry : folderResult.getEntries()) { <line5> returnMap.put( <line6> entry.getPathDisplay(), downloadSingleFile(entry.getPathDisplay()).getValue()); <line7> } <line8> return returnMap; <line9> } catch (ListFolderErrorException e) { <line10> try { <line11> DbxDownloader<FileMetadata> listing = client.files().download(path); <line12> if (listing == null) { <line13> return Collections.emptyMap(); <line14> } else { <line15> LOG.debug(UNKNOWN); <line16> Map.Entry<String, Object> entry = downloadSingleFile(path); <line17> return Collections.singletonMap(entry.getKey(), entry.getValue()); <line18> } <line19> } catch (DbxException dbxException) { <line20> throw new DropboxException(dbxException); <line21> } <line22> } catch (DbxException e) { <line23> throw new DropboxException(e); <line24> } <line25> } <line26> } <line27> "	"""downloading a single file..."""	task7	
"public class A { <line0> protected Map<String, DfForeignKeyMeta> filterSameStructureForeignKey( <line1> Map<String, DfForeignKeyMeta> fkMap) { <line2> final Map<String, DfForeignKeyMeta> filteredFKMap = newLinkedHashMap(); <line3> final Map<Map<String, Object>, Object> checkMap = newLinkedHashMap(); <line4> final Object dummyObj = new Object(); <line5> for (Entry<String, DfForeignKeyMeta> entry : fkMap.entrySet()) { <line6> final String foreinKeyName = entry.getKey(); <line7> final DfForeignKeyMeta metaInfo = entry.getValue(); <line8> final Map<String, Object> checkKey = newLinkedHashMap(); <line9> checkKey.put(metaInfo.getForeignTableIdentityName(), dummyObj); <line10> checkKey.put(""columnNameMap:"" + metaInfo.getColumnNameMap(), dummyObj); <line11> if (checkMap.containsKey(checkKey)) { <line12> String msg = <line13> ""*The same-structural foreign key was found: skipped="" + foreinKeyName + "":"" + checkKey; <line14> log.warn(UNKNOWN); <line15> } else { <line16> checkMap.put(checkKey, dummyObj); <line17> filteredFKMap.put(foreinKeyName, metaInfo); <line18> } <line19> } <line20> return filteredFKMap; <line21> } <line22> } <line23> "	msg	task7	
public class A { <line0> public static boolean checkExists(CuratorFramework curator, String crawlId) { <line1> try { <line2> return curator.checkExists().forPath(crawlId) != null; <line3> } catch (Exception ex) { <line4> log.error(UNKNOWN); <line5> } <line6> return false; <line7> } <line8> } <line9> 	"""Exception while calling ZooKeeper"", ex"	task7	
public class A { <line0> @Override <line1> public boolean exists() { <line2> try { <line3> return fs.exists(hdfsPath); <line4> } catch (IOException e) { <line5> logger.error(UNKNOWN); <line6> return false; <line7> } <line8> } <line9> } <line10> 	"""Fail to check whether the file {} exists. "", hdfsPath.toUri(), e"	task7	
public class A { <line0> private void updateSasLogicalInterconnectFirmware() { <line1> SasLogicalInterconnect interconnect = client.getByName(SAS_LOGICAL_INTERCONNECT_NAME).get(0); <line2> SasLiFirmware firmware = new SasLiFirmware(); <line3> firmware.setCommand(Command.Stage); <line4> firmware.setForce(false); <line5> firmware.setSppUri( <line6> fwClient.getByName(FirmwareDriverClientSample.FIRMWARE_DRIVER_NAME).get(0).getUri()); <line7> TaskResource task = this.client.updateFirmware(interconnect.getResourceId(), firmware); <line8> LOGGER.info(UNKNOWN); <line9> } <line10> } <line11> 	"""Task object returned to client: {}"", task.toJsonString()"	task7	
"public class A { <line0> private void retrievePatToken() throws UmaProtectionException { <line1> this.umaPat = null; <line2> if (umaMetadata == null) { <line3> return; <line4> } <line5> String umaClientKeyStoreFile = getClientKeyStoreFile(); <line6> String umaClientKeyStorePassword = getClientKeyStorePassword(); <line7> if (StringHelper.isEmpty(umaClientKeyStoreFile) <line8> || StringHelper.isEmpty(umaClientKeyStorePassword)) { <line9> throw new UmaProtectionException(""UMA JKS keystore path or password is empty""); <line10> } <line11> if (umaClientKeyStorePassword != null) { <line12> try { <line13> umaClientKeyStorePassword = encryptionService.decrypt(umaClientKeyStorePassword); <line14> } catch (EncryptionException ex) { <line15> log.error(UNKNOWN); <line16> } <line17> } <line18> try { <line19> this.umaPat = <line20> UmaClient.requestPat( <line21> umaMetadata.getTokenEndpoint(), <line22> umaClientKeyStoreFile, <line23> umaClientKeyStorePassword, <line24> getClientId(), <line25> getClientKeyId()); <line26> if (this.umaPat == null) { <line27> this.umaPatAccessTokenExpiration = 0l; <line28> } else { <line29> this.umaPatAccessTokenExpiration = <line30> computeAccessTokenExpirationTime(this.umaPat.getExpiresIn()); <line31> } <line32> } catch (Exception ex) { <line33> throw new UmaProtectionException(""Failed to obtain valid UMA PAT token"", ex); <line34> } <line35> if ((this.umaPat == null) || (this.umaPat.getAccessToken() == null)) { <line36> throw new UmaProtectionException(""Failed to obtain valid UMA PAT token""); <line37> } <line38> } <line39> } <line40> "	"""Failed to decrypt UmaClientKeyStorePassword password"", ex"	task7	
"public class A { <line0> @Override <line1> public void generate(Model model, MolgenisOptions options) throws Exception { <line2> Template template = createTemplate(getClass().getSimpleName() + "".sql.ftl""); <line3> Map<String, Object> templateArgs = createTemplateArguments(options); <line4> File target = new File(this.getSqlPath(options) + ""/count_per_table.sql""); <line5> boolean created = target.getParentFile().mkdirs(); <line6> if (!created && !target.getParentFile().exists()) { <line7> throw new IOException(""could not create "" + target.getParentFile()); <line8> } <line9> templateArgs.put(""model"", model); <line10> OutputStream targetOut = new FileOutputStream(target); <line11> template.process(templateArgs, new OutputStreamWriter(targetOut, Charset.forName(""UTF-8""))); <line12> targetOut.close(); <line13> logger.info(UNKNOWN); <line14> } <line15> } <line16> "	"""generated "" + target"	task7	
public class A { <line0> private T decode(Object value) { <line1> if (value == null) return defaultValue; <line2> if (enumClass.isAssignableFrom(value.getClass())) { <line3> return (T) value; <line4> } <line5> String s; <line6> if (!(value instanceof String)) { <line7> s = value.toString(); <line8> } else { <line9> s = (String) value; <line10> } <line11> try { <line12> return Enum.valueOf(enumClass, s); <line13> } catch (Exception e) { <line14> LOGGER.error(UNKNOWN); <line15> return defaultValue; <line16> } <line17> } <line18> } <line19> 	"""Incorrect value specified for property "" + propertyName + "". Value: "" + s"	task7	
public class A { <line0> public OrchestrationContextBuilder createOrchestrationContextBuilder( <line1> NhincConstants.GATEWAY_API_LEVEL apiLevel) { <line2> switch (apiLevel) { <line3> case LEVEL_g0: <line4> return new OutboundPatientDiscoveryDeferredRequestOrchestrationContextBuilder_g0(); <line5> default: <line6> LOG.warn(UNKNOWN); <line7> return new OutboundPatientDiscoveryDeferredRequestOrchestrationContextBuilder_g0(); <line8> } <line9> } <line10> } <line11> 	"""Unexpected api level received "" + apiLevel.toString() + "".  Defaulting to g0"""	task7	
public class A { <line0> @Override <line1> public void shutdown() { <line2> try { <line3> failureManager.stop(); <line4> super.shutdown(); <line5> } catch (Exception e) { <line6> LOG.error(UNKNOWN); <line7> } <line8> } <line9> } <line10> 	"""failed to shutdown MiniOzoneChaosCluster"", e"	task7	
"public class A { <line0> public JiraResponse delete(String resource, Map<String, Object> parameters) throws IOException { <line1> try { <line2> URIBuilder builder = new URIBuilder(hostPort + resource); <line3> for (Map.Entry<String, Object> entry : parameters.entrySet()) { <line4> builder.addParameter(entry.getKey(), entry.getValue().toString()); <line5> } <line6> URI uri = builder.build(); <line7> Request delete = Request.Delete(uri); <line8> for (Header header : headers) { <line9> delete.addHeader(header); <line10> } <line11> executor.clearCookies(); <line12> Response response = executor.execute(delete); <line13> HttpResponse httpResponse = response.returnResponse(); <line14> StatusLine statusLine = httpResponse.getStatusLine(); <line15> int statusCode = statusLine.getStatusCode(); <line16> HttpEntity entity = httpResponse.getEntity(); <line17> String entityBody = """"; <line18> if (entity != null && statusCode != SC_UNAUTHORIZED) { <line19> entityBody = EntityUtils.toString(entity); <line20> } <line21> return new JiraResponse(statusCode, entityBody); <line22> } catch (URISyntaxException e) { <line23> LOG.debug(UNKNOWN); <line24> throw new IOException(""Wrong URI"", e); <line25> } <line26> } <line27> } <line28> "	"""Wrong URI. {}"", e.getMessage()"	task7	
"public class A { <line0> @Override <line1> public Map<String, List<ReferenceTablesBo>> getreferenceListByCategory() { <line2> logger.entry(""StudyServiceImpl - getreferenceListByCategory() - Starts""); <line3> HashMap<String, List<ReferenceTablesBo>> referenceMap = null; <line4> try { <line5> referenceMap = studyDAO.getreferenceListByCategory(); <line6> } catch (Exception e) { <line7> logger.error(UNKNOWN); <line8> } <line9> logger.exit(""StudyServiceImpl - getreferenceListByCategory() - Ends""); <line10> return referenceMap; <line11> } <line12> } <line13> "	"""StudyServiceImpl - getStudyList() - ERROR "", e"	task7	
"public class A { <line0> @Override <line1> public void run() { <line2> final ConfigStatusInfo info = getConfigStatus(configStatusSource.entityId, null); <line3> if (info != null) { <line4> if (eventPublisher != null) { <line5> eventPublisher.post(new ConfigStatusInfoEvent(configStatusSource.getTopic(), info)); <line6> } else { <line7> logger.warn( <line8> ""EventPublisher not available. Cannot post new config status for entity {}"", <line9> configStatusSource.entityId); <line10> } <line11> } <line12> } <line13> } <line14> "	"""EventPublisher not available. Cannot post new config status for entity {}"",configStatusSource.entityId"	task7	
"public class A { <line0> private void writeToFile(String message) { <line1> try { <line2> out.write(message + ""\n""); <line3> itemsWrittenToFile++; <line4> isTimeToCreateNewFile(); <line5> } catch (IOException ex) { <line6> logger.error(UNKNOWN); <line7> } <line8> JsonDeserializer jsd = new JsonDeserializer(); <line9> ClassifiedTweet tweet = jsd.getClassifiedTweet(message); <line10> if (null == tweet) { <line11> } else { <line12> if (null == tweet.getLabelName_1() && tweet.getNominalLabels().isEmpty()) {} <line13> } <line14> } <line15> } <line16> "	"collectionCode + ""Error in writing to file"""	task7	
public class A { <line0> @Override <line1> public void postProcessEnvironment( <line2> ConfigurableEnvironment environment, SpringApplication application) { <line3> WebApplicationType webApplicationType = application.getWebApplicationType(); <line4> if (!WebApplicationType.NONE.equals(webApplicationType)) { <line5> if (logger.isDebugEnabled()) { <line6> logger.debug(UNKNOWN); <line7> } <line8> return; <line9> } <line10> MutablePropertySources propertySources = environment.getPropertySources(); <line11> Map<String, Object> defaultProperties = createDefaultProperties(environment); <line12> if (!CollectionUtils.isEmpty(defaultProperties)) { <line13> addOrReplace(propertySources, defaultProperties); <line14> } <line15> } <line16> } <line17> 	"""Current application is a Web Application, the process will be ignored."""	task7	
public class A { <line0> @Override <line1> public void register(final NetworkService service) { <line2> try { <line3> unregister(service); <line4> ServiceInstance<Void> instance = <line5> ServiceInstance.<Void>builder() <line6> .name(service.getType().name()) <line7> .address(service.getAddress()) <line8> .build(); <line9> discovery.registerService(instance); <line10> } catch (KeymasterException e) { <line11> throw e; <line12> } catch (Exception e) { <line13> LOG.error(UNKNOWN); <line14> throw new KeymasterException(e); <line15> } <line16> } <line17> } <line18> 	"""While registering {}"", service, e"	task7	
public class A { <line0> public int cancel() { <line1> logger.info(UNKNOWN); <line2> return 0; <line3> } <line4> } <line5> 	"""cancel not implemented"""	task7	
"public class A { <line0> @Override <line1> public void run() { <line2> Random rnd = new Random(); <line3> try { <line4> Ignite ignite = startClientGrid(SRV_CNT + idx); <line5> assertTrue(ignite.configuration().isClientMode()); <line6> for (int i = 0; i < CACHES / 2; i++) { <line7> String cacheName = ""cache-"" + rnd.nextInt(CACHES); <line8> IgniteCache<Object, Object> cache = getCache(ignite, cacheName); <line9> cache.put(ignite.cluster().localNode().id(), UUID.randomUUID()); <line10> IgniteAtomicSequence seq = ignite.atomicSequence(""seq-"" + rnd.nextInt(20), 0, true); <line11> seq.getAndIncrement(); <line12> } <line13> while (!stopped) { <line14> IgniteCache<Object, Object> cache = getCache(ignite, ""cache-"" + rnd.nextInt(CACHES)); <line15> int val = Math.abs(rnd.nextInt(100)); <line16> if (val >= 0 && val < 40) cache.containsKey(ignite.cluster().localNode().id()); <line17> else if (val >= 40 && val < 80) cache.get(ignite.cluster().localNode().id()); <line18> else cache.put(ignite.cluster().localNode().id(), UUID.randomUUID()); <line19> Thread.sleep(10); <line20> } <line21> } catch (Exception e) { <line22> log.error(UNKNOWN); <line23> failed.set(true); <line24> } <line25> } <line26> } <line27> "	"""Unexpected error: "" + e, e"	task7	
public class A { <line0> @Override <line1> public boolean startEnforcement(String agreementId) { <line2> logger.debug(UNKNOWN); <line3> IEnforcementJob job = enforcementJobDAO.getByAgreementId(agreementId); <line4> if (job == null) { <line5> return false; <line6> } <line7> job.setEnabled(true); <line8> enforcementJobDAO.save(job); <line9> IAgreement agreement = agreementDAO.getByAgreementId(agreementId); <line10> for (IGuaranteeTerm term : agreement.getGuaranteeTerms()) { <line11> if (term.getStatus() == null <line12> || GuaranteeTermStatusEnum.NON_DETERMINED.equals(term.getStatus())) { <line13> term.setStatus(GuaranteeTermStatusEnum.FULFILLED); <line14> } <line15> guaranteeTermDAO.save(term); <line16> } <line17> return true; <line18> } <line19> } <line20> 	"""startEnforcement({})"", agreementId"	task7	
"public class A { <line0> @Override <line1> public void execute() throws ResourceAllocationException { <line2> try { <line3> validateParameters(); <line4> VirtualMachineTemplate template = _templateService.registerTemplate(this); <line5> if (template != null) { <line6> ListResponse<TemplateResponse> response = new ListResponse<TemplateResponse>(); <line7> List<TemplateResponse> templateResponses = <line8> _responseGenerator.createTemplateResponses( <line9> getResponseView(), template, getZoneIds(), false); <line10> response.setResponses(templateResponses); <line11> response.setResponseName(getCommandName()); <line12> setResponseObject(response); <line13> } else { <line14> throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to register template""); <line15> } <line16> } catch (URISyntaxException ex1) { <line17> logger.info(UNKNOWN); <line18> throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ex1.getMessage()); <line19> } <line20> } <line21> } <line22> "	ex1	task7	
public class A { <line0> public static String getOwnerName(final File file) { <line1> try { <line2> final Path path = Paths.get(file.getAbsolutePath()); <line3> final FileOwnerAttributeView ownerAttributeView = <line4> Files.getFileAttributeView(path, FileOwnerAttributeView.class); <line5> return ownerAttributeView != null ? ownerAttributeView.getOwner().getName() : null; <line6> } catch (Exception e) { <line7> logger.warn(UNKNOWN); <line8> return null; <line9> } <line10> } <line11> } <line12> 	"""Failed to determine 'owner' of {}: {}"", file, e.getMessage()"	task7	
"public class A { <line0> @Override <line1> public Set<BookieId> onClusterChanged( <line2> Set<BookieId> writableBookies, Set<BookieId> readOnlyBookies) { <line3> rwLock.writeLock().lock(); <line4> try { <line5> ImmutableSet<BookieId> joinedBookies, leftBookies, deadBookies; <line6> Set<BookieId> oldBookieSet = knownBookies.keySet(); <line7> leftBookies = Sets.difference(oldBookieSet, writableBookies).immutableCopy(); <line8> joinedBookies = Sets.difference(writableBookies, oldBookieSet).immutableCopy(); <line9> deadBookies = Sets.difference(leftBookies, readOnlyBookies).immutableCopy(); <line10> LOG.debug( <line11> ""Cluster changed : left bookies are {}, joined bookies are {}, while dead bookies are"" <line12> + "" {}."", <line13> leftBookies, <line14> joinedBookies, <line15> deadBookies); <line16> handleBookiesThatLeft(leftBookies); <line17> handleBookiesThatJoined(joinedBookies); <line18> if (this.isWeighted && (leftBookies.size() > 0 || joinedBookies.size() > 0)) { <line19> this.weightedSelection.updateMap(this.bookieInfoMap); <line20> } <line21> if (!readOnlyBookies.isEmpty()) { <line22> this.readOnlyBookies = ImmutableSet.copyOf(readOnlyBookies); <line23> } <line24> return deadBookies; <line25> } finally { <line26> rwLock.writeLock().unlock(); <line27> } <line28> } <line29> } <line30> "	"""Cluster changed : left bookies are {}, joined bookies are {}, while dead bookies are""+ "" {}."",leftBookies,joinedBookies,deadBookies"	task7	
public class A { <line0> protected Map<String, Object> ingest( <line1> final AccessResult<String> accessResult, final Map<String, Object> map) { <line2> if (ingestFactory == null) { <line3> return map; <line4> } <line5> Map<String, Object> target = map; <line6> for (final Ingester ingester : ingestFactory.getIngesters()) { <line7> try { <line8> target = ingester.process(target, accessResult); <line9> } catch (final Exception e) { <line10> logger.warn(UNKNOWN); <line11> } <line12> } <line13> return target; <line14> } <line15> } <line16> 	"""Failed to process Ingest[{}]"", ingester.getClass().getSimpleName(), e"	task7	
"public class A { <line0> @Override <line1> public void log(final LogItem logItem) { <line2> LOGGER.info( <line3> ""Sending LogItem request message for device: {}"", logItem.getDeviceIdentification()); <line4> this.logItemRequestMessageSender.send(logItem); <line5> } <line6> } <line7> "	"""Sending LogItem request message for device: {}"", logItem.getDeviceIdentification()"	task7	
public class A { <line0> static void waitTillCondition( <line1> Function<Boolean, Boolean> condition, Future dsFuture, long timeoutInSecs) throws Exception { <line2> Future<Boolean> res = <line3> Executors.newSingleThreadExecutor() <line4> .submit( <line5> () -> { <line6> boolean ret = false; <line7> while (!ret && !dsFuture.isDone()) { <line8> try { <line9> Thread.sleep(3000); <line10> ret = condition.apply(true); <line11> } catch (Throwable error) { <line12> LOG.warn(UNKNOWN); <line13> ret = false; <line14> } <line15> } <line16> return true; <line17> }); <line18> res.get(timeoutInSecs, TimeUnit.SECONDS); <line19> } <line20> } <line21> 	"""Got error :"", error"	task7	
"public class A { <line0> @Override <line1> public Observable<JobStatus> getStatus(final UUID applicationId, UUID jobId) { <line2> Preconditions.checkNotNull(applicationId, ""app id is null""); <line3> Preconditions.checkNotNull(jobId, ""job id is null""); <line4> return Observable.create( <line5> subscriber -> { <line6> final String jobString = StringUtils.sanitizeUUID(jobId); <line7> Id appId = CpNamingUtils.generateApplicationId(applicationId); <line8> final MapManager mapManager = <line9> mapManagerFactory.createMapManager(new MapScopeImpl(appId, ""status"")); <line10> try { <line11> String statusVal = mapManager.getString(jobString + statusKey); <line12> if (statusVal == null) { <line13> subscriber.onCompleted(); <line14> } else { <line15> final Map<String, Object> data = <line16> MAPPER.readValue(mapManager.getString(jobString + dataKey), Map.class); <line17> final Status status = Status.valueOf(statusVal); <line18> subscriber.onNext(new JobStatus(jobId, status, data)); <line19> } <line20> subscriber.onCompleted(); <line21> } catch (Exception e) { <line22> logger.error(UNKNOWN); <line23> throw new RuntimeException(e); <line24> } <line25> }); <line26> } <line27> } <line28> "	"""Failed to parse map"", e"	task7	
"public class A { <line0> public void cleanIntpContext(String nodeId) { <line1> String keyPrex = nodeId + ""@""; <line2> for (Map.Entry<String, InterpreterContext> entity : noteParagraphId2IntpContext.entrySet()) { <line3> String key = entity.getKey(); <line4> if (key.contains(keyPrex)) { <line5> LOGGER.info(UNKNOWN); <line6> noteParagraphId2IntpContext.remove(key); <line7> } <line8> } <line9> } <line10> } <line11> "	"""cleanIntpContext : "" + key"	task7	
public class A { <line0> @Override <line1> public Part getPart(String name) { <line2> Optional<FileUpload> upload = <line3> context.fileUploads().stream() <line4> .filter(fileUpload -> fileUpload.name().equals(name)) <line5> .findFirst(); <line6> if (!upload.isPresent()) { <line7> LOGGER.debug(UNKNOWN); <line8> return null; <line9> } <line10> final FileUpload fileUpload = upload.get(); <line11> return new FileUploadPart(fileUpload); <line12> } <line13> } <line14> 	"""No such file with name: {}."", name"	task7	
public class A { <line0> private void mockSendRPCTasks( <line1> ExecutorService rpcExecutor, int rpcNum, SegmentQueryResult.Builder builder, int resultSize) { <line2> List<Future> futures = Lists.newArrayList(); <line3> for (int i = 0; i < rpcNum; i++) { <line4> Future future = rpcExecutor.submit(new MockRPCTask(resultSize, 10, builder)); <line5> futures.add(future); <line6> } <line7> for (Future future : futures) { <line8> try { <line9> future.get(); <line10> } catch (Exception e) { <line11> logger.error(UNKNOWN); <line12> } <line13> } <line14> } <line15> } <line16> 	"""exception"", e"	task7	
"public class A { <line0> @Override <line1> public boolean checkAndMutate( <line2> final byte[] row, <line3> final byte[] family, <line4> final byte[] qualifier, <line5> final CompareFilter.CompareOp compareOp, <line6> final byte[] value, <line7> final RowMutations rm) <line8> throws IOException { <line9> LOG.trace(UNKNOWN); <line10> ConditionalRowMutation request = <line11> new CheckAndMutateUtil.RequestBuilder(hbaseAdapter, row, family) <line12> .qualifier(qualifier) <line13> .ifMatches(compareOp, value) <line14> .withMutations(rm) <line15> .build(); <line16> return checkAndMutate(row, request, ""checkAndMutate""); <line17> } <line18> } <line19> "	"""checkAndMutate(byte[], byte[], byte[], CompareOp, byte[], RowMutations)"""	task7	
"public class A { <line0> @Override <line1> public void onBeforeRemove(DDMFormInstance ddmFormInstance) throws ModelListenerException { <line2> try { <line3> DDMFormInstanceReport ddmFormInstanceReport = <line4> ddmFormInstanceReportLocalService.getFormInstanceReportByFormInstanceId( <line5> ddmFormInstance.getFormInstanceId()); <line6> TransactionCommitCallbackUtil.registerCallback( <line7> () -> { <line8> _ddmFormInstanceReportPortalExecutor.execute( <line9> () -> <line10> ddmFormInstanceReportLocalService.deleteDDMFormInstanceReport( <line11> ddmFormInstanceReport.getFormInstanceReportId())); <line12> return null; <line13> }); <line14> } catch (Exception exception) { <line15> if (log.isWarnEnabled()) { <line16> StringBundler sb = new StringBundler(4); <line17> sb.append(""Unable to update dynamic data mapping form ""); <line18> sb.append(""instance report for dynamic data mapping form ""); <line19> sb.append(""instance ""); <line20> sb.append(ddmFormInstance.getFormInstanceId()); <line21> log.warn(UNKNOWN); <line22> } <line23> } <line24> } <line25> } <line26> "	sb.toString(), exception	task7	
"public class A { <line0> @Override <line1> public void endElement(final String uri, final String localName, final String name) <line2> throws SAXException { <line3> if (name.toLowerCase().startsWith(""x-"")) { <line4> LOGGER.debug(UNKNOWN); <line5> } else { <line6> super.endElement(m_xmlns, localName, name); <line7> } <line8> } <line9> } <line10> "	"""ignore x- element"""	task7	
"public class A { <line0> @Activate <line1> public void activate(Map<String, Object> properties) { <line2> Object portletName = properties.get(""javax.portlet.name""); <line3> log.info( <line4> ""Portlet ["" <line5> + (portletName != null ? portletName : this.getClass().getSimpleName()) <line6> + ""] has been ENABLED.""); <line7> } <line8> } <line9> "	"""Portlet [""+ (portletName != null ? portletName : this.getClass().getSimpleName())+ ""] has been ENABLED."""	task7	
"public class A { <line0> public List<ActivityFrequencyScheduleBean> getQuestionnaireFrequencyDetailsForWeekly( <line1> QuestionnairesDto questionaire, List<ActivityFrequencyScheduleBean> runDetailsBean) <line2> throws DAOException { <line3> LOGGER.entry(""begin getQuestionnaireFrequencyDetailsForWeekly()""); <line4> try { <line5> if (StringUtils.isNotEmpty(questionaire.getStudyLifetimeStart()) <line6> && StringUtils.isNotEmpty(questionaire.getStudyLifetimeEnd()) <line7> && StringUtils.isNotEmpty(questionaire.getDayOfTheWeek())) { <line8> Integer repeatCount = <line9> ((questionaire.getRepeatQuestionnaire() == null) <line10> || (questionaire.getRepeatQuestionnaire() == 0)) <line11> ? 1 <line12> : questionaire.getRepeatQuestionnaire(); <line13> String questionaireDay = questionaire.getDayOfTheWeek(); <line14> String questionaireStartDate = questionaire.getStudyLifetimeStart(); <line15> while (repeatCount > 0) { <line16> ActivityFrequencyScheduleBean weeklyBean = new ActivityFrequencyScheduleBean(); <line17> String questionaireEndDate; <line18> String day = """"; <line19> String weekEndDate; <line20> boolean flag = false; <line21> boolean skipLoop = false; <line22> if (questionaireDay.equalsIgnoreCase( <line23> StudyMetaDataUtil.getDayByDate(questionaireStartDate))) { <line24> day = questionaireDay; <line25> } <line26> if (!questionaireDay.equalsIgnoreCase(day)) { <line27> while (!questionaireDay.equalsIgnoreCase(day)) { <line28> questionaireStartDate = StudyMetaDataUtil.addDaysToDate(questionaireStartDate, 1); <line29> day = StudyMetaDataUtil.getDayByDate(questionaireStartDate); <line30> } <line31> } <line32> weekEndDate = StudyMetaDataUtil.addWeeksToDate(questionaireStartDate, 1); <line33> if ((StudyMetaDataConstants.SDF_DATE <line34> .parse(StudyMetaDataUtil.getCurrentDate()) <line35> .equals(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate))) <line36> || (StudyMetaDataConstants.SDF_DATE <line37> .parse(StudyMetaDataUtil.getCurrentDate()) <line38> .before(StudyMetaDataConstants.SDF_DATE.parse(weekEndDate)))) { <line39> flag = true; <line40> } <line41> if (flag) { <line42> questionaireEndDate = weekEndDate; <line43> if ((StudyMetaDataConstants.SDF_DATE <line44> .parse(weekEndDate) <line45> .equals( <line46> StudyMetaDataConstants.SDF_DATE.parse(questionaire.getStudyLifetimeEnd()))) <line47> || (StudyMetaDataConstants.SDF_DATE <line48> .parse(weekEndDate) <line49> .after( <line50> StudyMetaDataConstants.SDF_DATE.parse( <line51> questionaire.getStudyLifetimeEnd())))) { <line52> questionaireEndDate = questionaire.getStudyLifetimeEnd(); <line53> skipLoop = true; <line54> } <line55> weeklyBean.setStartTime(questionaireStartDate); <line56> weeklyBean.setEndTime(questionaireEndDate); <line57> runDetailsBean.add(weeklyBean); <line58> if (skipLoop) { <line59> break; <line60> } <line61> } <line62> questionaireStartDate = weekEndDate; <line63> questionaireDay = day; <line64> repeatCount--; <line65> } <line66> } <line67> } catch (Exception e) { <line68> LOGGER.error(UNKNOWN); <line69> } <line70> LOGGER.exit(""getQuestionnaireFrequencyDetailsForWeekly() :: Ends""); <line71> return runDetailsBean; <line72> } <line73> } <line74> "	"""ActivityMetaDataDao - getQuestionnaireFrequencyDetailsForWeekly() :: ERROR"", e"	task7	
public class A { <line0> @ExceptionHandler(AuthorizationException.class) <line1> @ResponseStatus(value = HttpStatus.UNAUTHORIZED) <line2> public ErrorResponse handleUnauthenticatedException(AuthorizationException ex) { <line3> logger.debug(UNKNOWN); <line4> return new ErrorResponse(ErrorCode.UNAUTHORIZED); <line5> } <line6> } <line7> 	"""Authorization Exception! {}"", ex.getMessage()"	task7	
public class A { <line0> @Override <line1> public FileVisitResult visitFileFailed(Path file, IOException ioe) throws IOException { <line2> if (ioe instanceof AccessDeniedException) { <line3> logger.error(UNKNOWN); <line4> } else { <line5> throw ioe; <line6> } <line7> return CONTINUE; <line8> } <line9> } <line10> 	"file + "": cannot access directory"""	task7	
public class A { <line0> @Activate <line1> void activate(BundleContext bundleContext, Map<String, Object> newConfigProperties) <line2> throws IOException { <line3> mapper.configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true); <line4> mapper.addMixIn(RepositoryAddress.class, RepositoryAddressMixin.class); <line5> SimpleModule module = new SimpleModule(); <line6> module.addSerializer(DefaultWorkspaceFilter.class, new DefaultWorkspaceFilterSerializer()); <line7> module.addDeserializer(WorkspaceFilter.class, new WorkspaceFilterDeserializer()); <line8> mapper.registerModule(module); <line9> mapper.addMixIn(SimpleCredentials.class, SimpleCredentialsMixin.class); <line10> mapper.addMixIn(ConnectionOptions.class, ConnectionOptionsMixin.class); <line11> mapper.addMixIn(RepositoryCopier.class, RepositoryCopierMixin.class); <line12> this.dataFile = bundleContext.getDataFile(TASKS_DATA_FILE_NAME); <line13> this.configuration = configurationAdmin.getConfiguration(PID); <line14> try { <line15> tasks = loadTasks((String) newConfigProperties.get(PROP_TASKS_SERIALIZATION), dataFile); <line16> } catch (IOException e) { <line17> log.error(UNKNOWN); <line18> tasks = new TreeMap<>(); <line19> } <line20> } <line21> } <line22> 	"""Could not restore previous tasks"", e"	task7	
"public class A { <line0> @Test <line1> public void testF31Miles() { <line2> logger.info(UNKNOWN); <line3> setup(VehicleType.CONVENTIONAL.toString(), true); <line4> String content = FileReader.readFileInString(""src/test/resources/responses/F31/status.json""); <line5> assertTrue( <line6> testVehicle( <line7> content, <line8> STATUS_CONV + DOORS + RANGE_CONV + POSITION + SERVICE_AVAILABLE + CHECK_EMPTY, <line9> Optional.empty())); <line10> } <line11> } <line12> "	"""{}"", Thread.currentThread().getStackTrace()[1].getMethodName()"	task7	
public class A { <line0> private TemplateStatus setupDatabaseTemplate( <line1> final TemplateStatus status, final Path profileTemplate, final Path databasePath) { <line2> TemplateStatus result = status; <line3> if (status != TemplateStatus.NO_TEMPLATE) { <line4> try { <line5> unpackProfileTemplate(profileTemplate, databasePath); <line6> } catch (IOException e) { <line7> log.error(UNKNOWN); <line8> result = TemplateStatus.NO_TEMPLATE; <line9> } <line10> } <line11> return result; <line12> } <line13> } <line14> 	e.getMessage(), e	task7	
"public class A { <line0> @Test <line1> public void crudTestWithES() { <line2> logger.info(UNKNOWN); <line3> PersonRedis person2 = preparePerson(""Amit"", ""2"", 40); <line4> em.persist(person2); <line5> waitThread(10); <line6> PersonRedis fetchPerson = em.find(PersonRedis.class, ""2""); <line7> Assert.assertEquals(""2"", fetchPerson.getPersonId()); <line8> Assert.assertEquals(""Amit"", fetchPerson.getPersonName()); <line9> Assert.assertEquals(40, fetchPerson.getAge().intValue()); <line10> fetchPerson.setAge(50); <line11> em.merge(fetchPerson); <line12> fetchPerson = em.find(PersonRedis.class, ""2""); <line13> Assert.assertEquals(""2"", fetchPerson.getPersonId()); <line14> Assert.assertEquals(""Amit"", fetchPerson.getPersonName()); <line15> Assert.assertEquals(50, fetchPerson.getAge().intValue()); <line16> em.remove(fetchPerson); <line17> fetchPerson = null; <line18> fetchPerson = em.find(PersonRedis.class, ""2""); <line19> Assert.assertNull(fetchPerson); <line20> } <line21> } <line22> "	"""Crud tests for ES"""	task7	
public class A { <line0> @Override <line1> public <T> List<T> query(Class<T> model, QueryRequest request) { <line2> LOGGER.debug(UNKNOWN); <line3> request.setModelClassName(model.getName()); <line4> return edbConverter.convertEDBObjectsToModelObjects(model, edbService.query(request)); <line5> } <line6> } <line7> 	"""Query for model {} with the request {}"", model.getName(), request"	task7	
public class A { <line0> private void refreshAllTasks() { <line1> final List<DataSourceInfoModel> dataSources = <line2> dataSourceConfigStore.findDataSourceInfos(DataSourceInfoStatus.ONLINE, namespace); <line3> LOG.info(UNKNOWN); <line4> if (dataSources.isEmpty()) return; <line5> dataSourceInfoMap.clear(); <line6> loadTasksFromDB(dataSources); <line7> shutdownOfflineTasks(); <line8> } <line9> } <line10> 	"""need process db: {}"", dataSources.size()"	task7	
public class A { <line0> @Override <line1> public void export() { <line2> if (this.processing.compareAndSet(false, true)) { <line3> long latestTimestamp = System.currentTimeMillis(); <line4> try { <line5> exportGroups(); <line6> } catch (Exception ex) { <line7> logger.warn(UNKNOWN); <line8> } finally { <line9> this.latestTimestamp = new Date(latestTimestamp); <line10> flushQuietly(); <line11> this.processing.set(false); <line12> } <line13> } <line14> } <line15> } <line16> 	"""Could not write to MetricWriter: "" + ex.getClass() + "": "" + ex.getMessage()"	task7	
"public class A { <line0> public void actionPerformed(ActionEvent ev) { <line1> try { <line2> synchronized (document) { <line3> document.replace(0, document.getLength(), """", null); <line4> } <line5> } catch (BadLocationException ex) { <line6> logger.error(UNKNOWN); <line7> } <line8> lockedCaretPosition = 0; <line9> } <line10> } <line11> "	"""Bad document location"", ex"	task7	
public class A { <line0> private void finalizeSpan(final Trace trace, String methodUri, Throwable throwable) { <line1> try { <line2> finalizeSpanEvent(trace, null, throwable); <line3> SpanRecorder recorder = trace.getSpanRecorder(); <line4> recorder.recordRpcName(methodUri); <line5> } catch (Throwable t) { <line6> logger.warn(UNKNOWN); <line7> } finally { <line8> trace.close(); <line9> } <line10> } <line11> } <line12> 	"""Error processing trace object. Cause:{}"", t.getMessage(), t"	task7	
public class A { <line0> @Override <line1> public DataType getHiveResultType(Object[] constantArguments, DataType[] argTypes) { <line2> LOG.info(UNKNOWN); <line3> try { <line4> ObjectInspector[] argumentInspectors = <line5> HiveInspectors.toInspectors(hiveShim, constantArguments, argTypes); <line6> return HiveTypeUtil.toFlinkType( <line7> hiveFunctionWrapper.createFunction().initialize(argumentInspectors)); <line8> } catch (UDFArgumentException e) { <line9> throw new FlinkHiveUDFException(e); <line10> } <line11> } <line12> } <line13> 	"""Getting result type of HiveGenericUDTF with {}"", hiveFunctionWrapper.getClassName()"	task7	
"public class A { <line0> @Override <line1> public final <T extends WorkerResourceDescription> void handleDependencyFreeActions( <line2> List<AllocatableAction> dataFreeActions, <line3> List<AllocatableAction> resourceFreeActions, <line4> List<AllocatableAction> blockedCandidates, <line5> ResourceScheduler<T> resource) { <line6> if (DEBUG) { <line7> LOGGER.debug( <line8> ""[ReadyScheduler] Handling dependency free actions on resource "" + resource.getName()); <line9> } <line10> manageUpgradedActions(resource); <line11> if (resource.canRunSomething()) { <line12> this.availableWorkers.add(resource); <line13> } <line14> purgeFreeActions(dataFreeActions, resourceFreeActions, blockedCandidates, resource); <line15> tryToLaunchFreeActions(dataFreeActions, resourceFreeActions, blockedCandidates, resource); <line16> } <line17> } <line18> "	"""[ReadyScheduler] Handling dependency free actions on resource "" + resource.getName()"	task7	
"public class A { <line0> @RequestMapping( <line1> value = ""/getConfig"", <line2> method = {RequestMethod.GET}, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> public List<StreamingConfig> getStreamings( <line6> @RequestParam(value = ""table"", required = false) String table, <line7> @RequestParam(value = ""project"", required = false) String project, <line8> @RequestParam(value = ""limit"", required = false) Integer limit, <line9> @RequestParam(value = ""offset"", required = false) Integer offset) { <line10> try { <line11> return streamingService.getStreamingConfigs(table, project, limit, offset); <line12> } catch (IOException e) { <line13> logger.error(UNKNOWN); <line14> throw new InternalErrorException( <line15> ""Failed to deal with the request: "" + e.getLocalizedMessage(), e); <line16> } <line17> } <line18> } <line19> "	"""Failed to deal with the request:"" + e.getLocalizedMessage(), e"	task7	
public class A { <line0> public void signalConnectionLost(final RtuDevice rtu) { <line1> LOGGER.info(UNKNOWN); <line2> final GetDataResponseDto dataResponse = <line3> new GetDataResponseDto( <line4> Arrays.asList( <line5> new GetDataSystemIdentifierDto( <line6> SYSTEM_ID, <line7> SYSTEM_TYPE, <line8> Arrays.asList( <line9> new MeasurementDto( <line10> MEASUREMENT_ID, <line11> MEASUREMENT_NODE, <line12> 0, <line13> new DateTime(DateTimeZone.UTC), <line14> MEASUREMENT_VALUE_ALARM_ON)))), <line15> null); <line16> final String correlationUid = this.createCorrelationUid(rtu); <line17> final String organisationIdentification = rtu.getOwner().getOrganisationIdentification(); <line18> final String deviceIdentification = rtu.getDeviceIdentification(); <line19> final CorrelationIds ids = <line20> new CorrelationIds(organisationIdentification, deviceIdentification, correlationUid); <line21> this.adHocManagementService.handleInternalDataResponse( <line22> dataResponse, ids, DeviceFunction.GET_DATA.toString()); <line23> } <line24> } <line25> 	"""Sending connection lost signal for device {}."", rtu.getDeviceIdentification()"	task7	
public class A { <line0> private T checkHealthyAndRetry(T resource, long endTimeMs) throws TimeoutException, IOException { <line1> if (isHealthy(resource)) { <line2> return resource; <line3> } else { <line4> LOG.debug(UNKNOWN); <line5> remove(resource); <line6> closeResource(resource); <line7> return acquire(endTimeMs - mClock.millis(), TimeUnit.MILLISECONDS); <line8> } <line9> } <line10> } <line11> 	"""Clearing unhealthy resource {}."", resource"	task7	
public class A { <line0> @Override <line1> public FileVisitResult postVisitDirectory(final Path dir, final IOException e) <line2> throws IOException { <line3> if (e != null) { <line4> logger.warn(UNKNOWN); <line5> } <line6> deleteEmptyDirectory(dir); <line7> return FileVisitResult.CONTINUE; <line8> } <line9> } <line10> 	"""I/O exception on {}"", dir, e"	task7	
public class A { <line0> public String getJsonErrorResponse(IErrorType type) { <line1> final DefaultErrorResponse response = getErrorResponse(type); <line2> JsonErrorResponse jsonErrorResponse = new JsonErrorResponse(response); <line3> try { <line4> final ObjectMapper mapper = <line5> Util.createJsonMapper().configure(SerializationFeature.WRAP_ROOT_VALUE, false); <line6> return mapper.writeValueAsString(jsonErrorResponse); <line7> } catch (IOException ex) { <line8> log.error(UNKNOWN); <line9> return null; <line10> } <line11> } <line12> } <line13> 	"""Failed to generate error response"", ex"	task7	
public class A { <line0> @Override <line1> public Character getEndInsertionCode() { <line2> logger.debug(UNKNOWN); <line3> return super.getEndInsertionCode(); <line4> } <line5> } <line6> 	"""Getting End Insertion Code: "", super.getEndInsertionCode()"	task7	
public class A { <line0> @Test <line1> public void testAbstractScriptExecutorNetstat() throws ExecutionException, InterruptedException { <line2> List<String> lines = new NetstatScriptExecutor().execute().get(); <line3> for (String line : lines) { <line4> logger.info(UNKNOWN); <line5> } <line6> } <line7> } <line8> 	"""{}"", line"	task7	
"public class A { <line0> @Override <line1> protected void bufferToBeReturned(ByteBuffer justAllocated) { <line2> BufferReference ref = new BufferReference(justAllocated, garbageCollectedBuffers); <line3> BufferMetadata metadata = new BufferMetadata(justAllocated.capacity()); <line4> if (buffersInFlight.put(ref, metadata) != null) <line5> throw new IllegalStateException( <line6> ""allocated buffer identity "" + ref.hashCode + "" already registered as in use?!""); <line7> log.trace(UNKNOWN); <line8> } <line9> } <line10> "	"""allocated buffer of size {} and identity {}"", sizeBytes, ref.hashCode"	task7	
"public class A { <line0> private ImmutableMap<Integer, Integer> buildIdx2Idx() { <line1> final Builder<Integer, Integer> builder = ImmutableMap.builder(); <line2> int i = 0; <line3> for (FAIRecord record : faiRecords) { <line4> final Integer id = refDict.getContigNameToID().get(record.name); <line5> if (id == null) { <line6> LOGGER.info( <line7> ""Contig {} from FAI not found in reference dictionary!"", new Object[] {record.name}); <line8> } else { <line9> builder.put(id, i); <line10> } <line11> ++i; <line12> } <line13> return builder.build(); <line14> } <line15> } <line16> "	"""Contig {} from FAI not found in reference dictionary!"", new Object[] {record.name}"	task7	
"public class A { <line0> private void testThreading(int nTables, int nIterations, double[] lf) throws Exception { <line1> if (null == lf) { <line2> lf = new double[nTables]; <line3> Arrays.fill(lf, 1d); <line4> } else { <line5> assert lf.length == nTables; <line6> } <line7> for (int n = 1; n < nTables; n++) { <line8> lf[n] += lf[n - 1]; <line9> } <line10> final double[] loadFactors = lf; <line11> final double accLoadFactors = loadFactors[nTables - 1]; <line12> Random random = new Random(0); <line13> int[] countByTable = new int[nTables]; <line14> long[] maxTimestampByTable = new long[nTables]; <line15> final long initialTimestampNanos = 1465839830100400200L; <line16> final long timestampIncrementInNanos = 1000; <line17> Arrays.fill(maxTimestampByTable, initialTimestampNanos); <line18> runInContext( <line19> () -> { <line20> int nTablesSelected = 0; <line21> int nTotalUpdates = 0; <line22> for (int nIter = 0; nIter < nIterations; nIter++) { <line23> int nLines = random.nextInt(50) + 1; <line24> recvBuffer = """"; <line25> for (int nLine = 0; nLine < nLines; nLine++) { <line26> int nTable; <line27> if (nTablesSelected < nTables) { <line28> nTable = nTablesSelected++; <line29> } else { <line30> double tableSelector = random.nextDouble() * accLoadFactors; <line31> nTable = nTables; <line32> while (--nTable > 0) { <line33> if (tableSelector > loadFactors[nTable - 1]) { <line34> break; <line35> } <line36> } <line37> } <line38> long timestamp = maxTimestampByTable[nTable]; <line39> maxTimestampByTable[nTable] += timestampIncrementInNanos; <line40> double temperature = 50.0 + (random.nextInt(500) / 10.0); <line41> recvBuffer += <line42> ""weather"" <line43> + nTable <line44> + "",location=us-midwest temperature="" <line45> + temperature <line46> + "" "" <line47> + timestamp <line48> + ""\n""; <line49> countByTable[nTable]++; <line50> nTotalUpdates++; <line51> } <line52> do { <line53> handleContextIO(); <line54> } while (recvBuffer.length() > 0); <line55> } <line56> waitForIOCompletion(); <line57> rebalanceNLoadCheckCycles = scheduler.getNLoadCheckCycles(); <line58> rebalanceNRebalances = scheduler.getNRebalances(); <line59> rebalanceLoadByThread = scheduler.getLoadByThread(); <line60> closeContext(); <line61> LOG.info() <line62> .$(""Completed "") <line63> .$(nTotalUpdates) <line64> .$("" measurements with "") <line65> .$(nTables) <line66> .$("" measurement types processed by "") <line67> .$(nWriterThreads) <line68> .$("" threads. "") <line69> .$(rebalanceNLoadCheckCycles) <line70> .$("" load checks lead to "") <line71> .$(rebalanceNRebalances) <line72> .$("" load rebalancing operations"") <line73> .$(); <line74> for (int nTable = 0; nTable < nTables; nTable++) { <line75> assertTableCount( <line76> ""weather"" + nTable, <line77> countByTable[nTable], <line78> maxTimestampByTable[nTable] - timestampIncrementInNanos); <line79> } <line80> }); <line81> } <line82> } <line83> "		task7	
"public class A { <line0> @Override <line1> public List<SingularityRequestHistory> getRequestHistory( <line2> String requestId, <line3> Optional<Long> createdBefore, <line4> Optional<Long> createdAfter, <line5> Optional<OrderDirection> orderDirection, <line6> Integer limitStart, <line7> Integer limitCount) { <line8> List<SingularityRequestHistory> singularityRequestHistoryList = <line9> history.getRequestHistory( <line10> requestId, <line11> createdBefore, <line12> createdAfter, <line13> getOrderDirection(orderDirection), <line14> limitStart, <line15> limitCount); <line16> if (LOG.isTraceEnabled()) { <line17> LOG.trace( <line18> ""getRequestHistory requestId {}, createdBefore {}, createdAfter {}, orderDirection {},"" <line19> + "" limitStart {} , limitCount {}, requestHistory{}"", <line20> requestId, <line21> createdBefore, <line22> createdAfter, <line23> orderDirection, <line24> limitStart, <line25> limitCount, <line26> singularityRequestHistoryList); <line27> } <line28> return singularityRequestHistoryList; <line29> } <line30> } <line31> "	"""getRequestHistory requestId {}, createdBefore {}, createdAfter {}, orderDirection {},""+ "" limitStart {} , limitCount {}, requestHistory{}"",requestId,createdBefore,createdAfter,orderDirection,limitStart,limitCount,singularityRequestHistoryList"	task7	
public class A { <line0> @Override <line1> public synchronized void validate() throws ValidationException { <line2> try { <line3> super.validate(); <line4> } catch (Exception e) { <line5> LOG.error(UNKNOWN); <line6> } <line7> } <line8> } <line9> 	e.getMessage()	task7	
"public class A { <line0> @Test <line1> public void runIntegrationTests() { <line2> String[] args = {}; <line3> String[] engines; <line4> String defaultEngine = System.getProperty(""ai.djl.default_engine""); <line5> if (defaultEngine == null) { <line6> if (System.getProperty(""os.name"").startsWith(""Win"")) { <line7> engines = new String[] {""MXNet""}; <line8> } else { <line9> engines = new String[] {""MXNet"", ""PyTorch"", ""TensorFlow""}; <line10> } <line11> } else { <line12> engines = new String[] {defaultEngine}; <line13> } <line14> for (String engine : engines) { <line15> System.setProperty(""ai.djl.default_engine"", engine); <line16> logger.info(UNKNOWN); <line17> Assert.assertTrue(new IntegrationTest(IntegrationTest.class).runTests(args)); <line18> if (CudaUtils.hasCuda()) { <line19> break; <line20> } <line21> } <line22> } <line23> } <line24> "	"""Testing engine: {} ..."", engine"	task7	
public class A { <line0> @VisibleForTesting <line1> protected void connect() { <line2> this.status = Status.CONNECTING; <line3> LOGGER.info(UNKNOWN); <line4> netClientWrapper.connect( <line5> endpoint.isSslEnabled(), <line6> socketAddress.getPort(), <line7> socketAddress.getHostString(), <line8> ar -> { <line9> if (ar.succeeded()) { <line10> onConnectSuccess(ar.result()); <line11> return; <line12> } <line13> onConnectFailed(ar.cause()); <line14> }); <line15> } <line16> } <line17> 	"""connecting to address {}"", socketAddress.toString()"	task7	
"public class A { <line0> public void completed(final HttpResponse response) { <line1> int statusCode = response.getStatusLine().getStatusCode(); <line2> if (statusCode >= 200 && statusCode < 300) { <line3> callback.onSuccess(); <line4> } else { <line5> logger.warn( <line6> target <line7> + ""://"" <line8> + url.getPath() <line9> + ""?"" <line10> + url.getQuery() <line11> + "" -> "" <line12> + response.getStatusLine()); <line13> callback.onFailure(statusCode); <line14> } <line15> } <line16> } <line17> "	"target+ ""://""+ url.getPath()+ ""?""+ url.getQuery()+ "" -> ""+ response.getStatusLine()"	task7	
"public class A { <line0> public static void createTermFrequencyVectors( <line1> Path input, <line2> Path output, <line3> String tfVectorsFolderName, <line4> Configuration baseConf, <line5> int minSupport, <line6> int maxNGramSize, <line7> float minLLRValue, <line8> float normPower, <line9> boolean logNormalize, <line10> int numReducers, <line11> int chunkSizeInMegabytes, <line12> boolean sequentialAccess, <line13> boolean namedVectors) <line14> throws IOException, InterruptedException, ClassNotFoundException { <line15> Preconditions.checkArgument( <line16> normPower == PartialVectorMerger.NO_NORMALIZING || normPower >= 0, <line17> ""If specified normPower must be nonnegative"", <line18> normPower); <line19> Preconditions.checkArgument( <line20> normPower == PartialVectorMerger.NO_NORMALIZING <line21> || (normPower > 1 && !Double.isInfinite(normPower)) <line22> || !logNormalize, <line23> ""normPower must be > 1 and not infinite if log normalization is chosen"", <line24> normPower); <line25> if (chunkSizeInMegabytes < MIN_CHUNKSIZE) { <line26> chunkSizeInMegabytes = MIN_CHUNKSIZE; <line27> } else if (chunkSizeInMegabytes > MAX_CHUNKSIZE) { <line28> chunkSizeInMegabytes = MAX_CHUNKSIZE; <line29> } <line30> if (minSupport < 0) { <line31> minSupport = DEFAULT_MIN_SUPPORT; <line32> } <line33> Path dictionaryJobPath = new Path(output, DICTIONARY_JOB_FOLDER); <line34> log.info(UNKNOWN); <line35> int[] maxTermDimension = new int[1]; <line36> List<Path> dictionaryChunks; <line37> if (maxNGramSize == 1) { <line38> startWordCounting(input, dictionaryJobPath, baseConf, minSupport); <line39> dictionaryChunks = <line40> createDictionaryChunks( <line41> dictionaryJobPath, output, baseConf, chunkSizeInMegabytes, maxTermDimension); <line42> } else { <line43> CollocDriver.generateAllGrams( <line44> input, dictionaryJobPath, baseConf, maxNGramSize, minSupport, minLLRValue, numReducers); <line45> dictionaryChunks = <line46> createDictionaryChunks( <line47> new Path( <line48> new Path(output, DICTIONARY_JOB_FOLDER), CollocDriver.NGRAM_OUTPUT_DIRECTORY), <line49> output, <line50> baseConf, <line51> chunkSizeInMegabytes, <line52> maxTermDimension); <line53> } <line54> int partialVectorIndex = 0; <line55> Collection<Path> partialVectorPaths = Lists.newArrayList(); <line56> for (Path dictionaryChunk : dictionaryChunks) { <line57> Path partialVectorOutputPath = new Path(output, VECTOR_OUTPUT_FOLDER + partialVectorIndex++); <line58> partialVectorPaths.add(partialVectorOutputPath); <line59> makePartialVectors( <line60> input, <line61> baseConf, <line62> maxNGramSize, <line63> dictionaryChunk, <line64> partialVectorOutputPath, <line65> maxTermDimension[0], <line66> sequentialAccess, <line67> namedVectors, <line68> numReducers); <line69> } <line70> Configuration conf = new Configuration(baseConf); <line71> Path outputDir = new Path(output, tfVectorsFolderName); <line72> PartialVectorMerger.mergePartialVectors( <line73> partialVectorPaths, <line74> outputDir, <line75> conf, <line76> normPower, <line77> logNormalize, <line78> maxTermDimension[0], <line79> sequentialAccess, <line80> namedVectors, <line81> numReducers); <line82> HadoopUtil.delete(conf, partialVectorPaths); <line83> } <line84> } <line85> "	"""Creating dictionary from {} and saving at {}"", input, dictionaryJobPath"	task7	
"public class A { <line0> public static com.liferay.commerce.product.model.CommerceCatalog fetchCommerceCatalog( <line1> HttpPrincipal httpPrincipal, long commerceCatalogId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceCatalogServiceUtil.class, <line7> ""fetchCommerceCatalog"", <line8> _fetchCommerceCatalogParameterTypes3); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceCatalogId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.product.model.CommerceCatalog) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> log.error(UNKNOWN); <line22> throw systemException; <line23> } <line24> } <line25> } <line26> "	systemException, systemException	task7	
public class A { <line0> @Override <line1> public void rollback() { <line2> log.trace(UNKNOWN); <line3> transactionContext.rollbackTransaction(); <line4> } <line5> } <line6> 	"""Rolling back TX "" + transactionContext.getTxnId()"	task7	
"public class A { <line0> protected void exportFoxml(Foxml foxml) { <line1> try { <line2> DigitalObject foxmlPeri = this.createDigitalObject(foxml); <line3> Element re = createRelsExtElement(foxml.getRe()); <line4> DatastreamType relsExtStream = this.createRelsExtStream(re); <line5> addCheckedDataStream(foxmlPeri, relsExtStream); <line6> if (foxml.getOcr() != null) { <line7> addCheckedDataStream( <line8> foxmlPeri, createEncodedStream(STREAM_ID_TXT, ""text/plain"", foxml.getOcr())); <line9> } <line10> if (foxml.getStruct() != null) { <line11> addCheckedDataStream( <line12> foxmlPeri, <line13> createEncodedStream( <line14> ""STRUCT_MAP"", <line15> ""text/xml"", <line16> ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n<parts>\n"" <line17> + foxml.getStruct() <line18> + ""</parts>\n"")); <line19> } <line20> this.marshalDigitalObject(foxmlPeri); <line21> } catch (ServiceException ex) { <line22> log.error(UNKNOWN); <line23> throw ex; <line24> } <line25> } <line26> } <line27> "	"""Error marshalling FOXML:"" + foxml.getTitle()"	task7	
public class A { <line0> @Override <line1> public void processReplaceSmResp(Command pduHeader, byte[] pdu, ResponseHandler responseHandler) <line2> throws IOException { <line3> PendingResponse<Command> pendingResp = <line4> responseHandler.removeSentItem(pduHeader.getSequenceNumber()); <line5> if (pendingResp != null) { <line6> ReplaceSmResp resp = pduDecomposer.replaceSmResp(pdu); <line7> pendingResp.done(resp); <line8> } else { <line9> logger.error(UNKNOWN); <line10> } <line11> } <line12> } <line13> 	NO_REQUEST_FIND_FOR_SEQUENCE_NUMBER + pduHeader.getSequenceNumber()	task7	
"public class A { <line0> public static void main(String[] args) throws IOException { <line1> if (args.length != 2) { <line2> System.out.println(""usage: report redis-url report-name""); <line3> System.exit(1); <line4> } <line5> try (RedisUserReportMap reportMap = <line6> new RedisUserReportMap( <line7> new PropertiesProvider( <line8> new HashMap<String, String>() { <line9> { <line10> put(""redisAddress"", args[0]); <line11> } <line12> }), <line13> args[1])) { <line14> reportMap.forEach( <line15> (path, report) -> { <line16> if (report.getException().isPresent()) { <line17> StringWriter sw = new StringWriter(); <line18> PrintWriter pw = new PrintWriter(sw); <line19> report.getException().get().printStackTrace(pw); <line20> logger.info(UNKNOWN); <line21> } <line22> }); <line23> } <line24> } <line25> } <line26> "	"""\""{}\"" \""{}\"""", path, sw.toString().replace(""\n"", ""|"")"	task7	
"public class A { <line0> public static <T> T readValue(String content, Class<T> valueType) throws GenericRestException { <line1> try { <line2> return defaultMapper.readValue(content, valueType); <line3> } catch (JsonMappingException e) { <line4> log.error( <line5> ""Could not deserialize json {"" + content + ""} into {"" + valueType.getName() + ""}"", e); <line6> String line = ""unknown""; <line7> String column = ""unknown""; <line8> if (e.getLocation() != null) { <line9> line = String.valueOf(e.getLocation().getLineNr()); <line10> column = String.valueOf(e.getLocation().getColumnNr()); <line11> } <line12> String field = """"; <line13> if (e.getPath() != null && e.getPath().size() >= 1) { <line14> field = e.getPath().get(0).getFieldName(); <line15> } <line16> throw new GenericRestException( <line17> BAD_REQUEST, ""error_json_structure_invalid"", line, column, field, e.getOriginalMessage()); <line18> } catch (JsonParseException e) { <line19> String msg = e.getOriginalMessage(); <line20> String line = ""unknown""; <line21> String column = ""unknown""; <line22> if (e.getLocation() != null) { <line23> line = String.valueOf(e.getLocation().getLineNr()); <line24> column = String.valueOf(e.getLocation().getColumnNr()); <line25> } <line26> throw new GenericRestException(BAD_REQUEST, ""error_json_malformed"", line, column, msg); <line27> } catch (Exception e) { <line28> throw new GenericRestException(BAD_REQUEST, ""error_json_parse"", e); <line29> } <line30> } <line31> } <line32> "	"""Could not deserialize json {"" + content + ""} into {"" + valueType.getName() + ""}"", e"	task7	
public class A { <line0> private void readHDF5File() throws Exception { <line1> FileFormat fileFormat = FileFormat.getFileFormat(FileFormat.FILE_TYPE_HDF5); <line2> if (fileFormat == null) { <line3> logger.error(UNKNOWN); <line4> return; <line5> } <line6> FileFormat testFile = fileFormat.createInstance(fname, FileFormat.WRITE); <line7> org.junit.Assert.assertNotNull(testFile); <line8> org.junit.Assert.assertEquals(testFile.exists(), true); <line9> testFile.open(); <line10> Group root = <line11> (Group) ((javax.swing.tree.DefaultMutableTreeNode) testFile.getRootNode()).getUserObject(); <line12> Dataset dataset = (Dataset) root.getMemberList().get(0); <line13> int[] dataRead = (int[]) dataset.read(); <line14> org.junit.Assert.assertEquals(dataRead.length, 200); <line15> org.junit.Assert.assertEquals(dataRead[0], 1000); <line16> org.junit.Assert.assertEquals(dataRead[1], 1001); <line17> for (int i = 0; i < 20; i++) { <line18> for (int j = 0; j < 10; j++) { <line19> dataRead[i * 10 + j]++; <line20> } <line21> } <line22> dataset.write(dataRead); <line23> int[] dataModified = (int[]) dataset.read(); <line24> org.junit.Assert.assertEquals(dataModified.length, 200); <line25> org.junit.Assert.assertEquals(dataModified[0], 1001); <line26> org.junit.Assert.assertEquals(dataModified[1], 1002); <line27> testFile.close(); <line28> } <line29> } <line30> 	"""Cannot find HDF5 FileFormat."""	task7	
"public class A { <line0> @Test <line1> public void addAndRest() { <line2> if (token == null) { <line3> LOG.warn(UNKNOWN); <line4> return; <line5> } else { <line6> DirCache dirCache = gitUtils.add(LOCALPATH, ""/aa/bb/log4j.properties""); <line7> assertEquals(1, dirCache.getEntryCount()); <line8> gitUtils.reset(LOCALPATH, ""/aa/bb/log4j.properties""); <line9> } <line10> } <line11> } <line12> "	"""Token not set!"""	task7	
public class A { <line0> private void afterLog() { <line1> logger.info(UNKNOWN); <line2> AnnotationVisitor<Value> annotationVisitor = new AnnotationVisitor<>(Value.class); <line3> annotationVisitor.visit(this, new LoggingEvent(this.logger)); <line4> } <line5> } <line6> 	"""after setup field : {}"", this"	task7	
public class A { <line0> @Override <line1> public void closed(RemoteOutputStreamServer stream, boolean clean) { <line2> try { <line3> stream.close(true); <line4> } catch (IOException e) { <line5> logger.error(UNKNOWN); <line6> } <line7> } <line8> } <line9> 	"""error closing RemoteOutputStreamServer"", e"	task7	
public class A { <line0> synchronized void processRemoveRequest(ID mbr) { <line1> if (waiting) { <line2> logger.debug(UNKNOWN); <line3> pendingRemovals.add(mbr); <line4> checkIfDone(); <line5> } <line6> } <line7> } <line8> 	"""view response processor recording remove request for {}"", mbr"	task7	
public class A { <line0> @Override <line1> public void println(final Object obj) { <line2> if (obj != null) { <line3> printBuilder.append(obj.toString()); <line4> } <line5> logger.info(UNKNOWN); <line6> printBuilder.setLength(0); <line7> } <line8> } <line9> 	printBuilder.toString()	task7	
public class A { <line0> @Override <line1> public String handleException(BackgroundTask backgroundTask, Exception exception) { <line2> Map<String, Serializable> taskContextMap = backgroundTask.getTaskContextMap(); <line3> long fileEntryId = <line4> GetterUtil.getLong(taskContextMap.get(GoogleDriveBackgroundTaskConstants.FILE_ENTRY_ID)); <line5> try { <line6> _dlOpenerFileEntryReferenceLocalService.deleteDLOpenerFileEntryReference( <line7> DLOpenerGoogleDriveConstants.GOOGLE_DRIVE_REFERENCE_TYPE, <line8> _dlAppLocalService.getFileEntry(fileEntryId)); <line9> } catch (PortalException portalException) { <line10> log.error(UNKNOWN); <line11> } <line12> return StringPool.BLANK; <line13> } <line14> } <line15> 	portalException, portalException	task7	
public class A { <line0> @Override <line1> public void doInit(final Properties messageAttributes) throws PerfCakeException { <line2> final String currentTarget = safeGetTarget(messageAttributes); <line3> isDebugEnabled = log.isDebugEnabled(); <line4> if (isDebugEnabled) { <line5> log.debug(UNKNOWN); <line6> } <line7> } <line8> } <line9> 	"""Initializing... "" + currentTarget"	task7	
"public class A { <line0> public static void main(String[] args) throws IOException { <line1> Config config = ConfigUtils.createConfig(); <line2> config <line3> .plans() <line4> .setInputFile( <line5> ""../shared-svn/projects/episim/matsim-files/snz/BerlinV2/episim-input/be_v2_snz_entirePopulation_emptyPlans_withDistricts.xml.gz""); <line6> Scenario scenario = ScenarioUtils.loadScenario(config); <line7> Table table; <line8> { <line9> Map<String, Double> freq = new TreeMap<>(); <line10> for (Person person : scenario.getPopulation().getPersons().values()) { <line11> String age = Integer.toString((int) person.getAttributes().getAttribute(""age"")); <line12> Double sum = freq.computeIfAbsent(age, (a) -> 0.); <line13> freq.put(age, sum + 0.02); <line14> } <line15> final StringColumn ageColumn = StringColumn.create(""age"", freq.keySet()); <line16> final DoubleColumn freqInPop = DoubleColumn.create(""freqInPop * 0.02"", freq.values()); <line17> table = Table.create(""table"").addColumns(ageColumn, freqInPop); <line18> } <line19> Table table2; <line20> final String ageFreqInInfections = ""ageFreqInInfections""; <line21> { <line22> Map<String, Double> freq2 = new TreeMap<>(); <line23> Reader in = new FileReader(base + ""infectionEvents.txt""); <line24> Iterable<CSVRecord> records = <line25> CSVFormat.RFC4180.withFirstRecordAsHeader().withDelimiter('\t').parse(in); <line26> for (CSVRecord record : records) { <line27> String infected = record.get(""infected""); <line28> Person person = scenario.getPopulation().getPersons().get(Id.createPersonId(infected)); <line29> if (person == null) { <line30> log.warn(UNKNOWN); <line31> } <line32> Gbl.assertNotNull(person); <line33> String age = Integer.toString((int) person.getAttributes().getAttribute(""age"")); <line34> Double sum = freq2.computeIfAbsent(age, (a) -> 0.); <line35> freq2.put(age, sum + 1); <line36> } <line37> final StringColumn ageColumn = StringColumn.create(""age"", freq2.keySet()); <line38> final DoubleColumn freqInPop = DoubleColumn.create(ageFreqInInfections, freq2.values()); <line39> table2 = Table.create(""table"").addColumns(ageColumn, freqInPop); <line40> } <line41> Table result = new DataFrameJoiner(table, ""age"").fullOuter(table2); <line42> Layout.BarMode barMode = Layout.BarMode.GROUP; <line43> Figure fig = <line44> VerticalBarPlot.create( <line45> ""title"", result, ""age"", barMode, ""freqInPop * 0.02"", ageFreqInInfections); <line46> Layout layout = Layout.builder().width(800).height(500).build(); <line47> fig.setLayout(layout); <line48> Plot.show(fig, ""divname""); <line49> } <line50> } <line51> "	"""infected="" + infected"	task7	
public class A { <line0> protected static BlockingQueue<String> getQueue(String queueName) { <line1> HttpServletRequest req = ElementsThreadLocals.getHttpServletRequest(); <line2> if (req == null) { <line3> logger.debug(UNKNOWN); <line4> return new LinkedBlockingQueue<>(); <line5> } <line6> HttpSession session = req.getSession(); <line7> BlockingQueue<String> infoQueue; <line8> synchronized (session) { <line9> infoQueue = (BlockingQueue) session.getAttribute(queueName); <line10> if (infoQueue == null) { <line11> infoQueue = new LinkedBlockingQueue<String>(); <line12> session.setAttribute(queueName, infoQueue); <line13> } <line14> } <line15> return infoQueue; <line16> } <line17> } <line18> 	"""No request available. Returning dummy queue."""	task7	
"public class A { <line0> public void init() throws LensException { <line1> final int maxPoolSize = parseInt(getConf().get(JDBC_POOL_MAX_SIZE.getConfigKey())); <line2> final int maxConcurrentQueries = <line3> parseInt( <line4> getConf().get(MaxConcurrentDriverQueriesConstraintFactory.MAX_CONCURRENT_QUERIES_KEY)); <line5> checkState( <line6> maxPoolSize >= maxConcurrentQueries, <line7> ""maxPoolSize:"" + maxPoolSize + "" maxConcurrentQueries:"" + maxConcurrentQueries); <line8> queryContextMap = new ConcurrentHashMap<>(); <line9> asyncQueryPool = <line10> Executors.newCachedThreadPool( <line11> new ThreadFactory() { <line12> @Override <line13> public Thread newThread(Runnable runnable) { <line14> Thread th = new Thread(runnable); <line15> th.setName(""lens-driver-jdbc-"" + THID.incrementAndGet()); <line16> return th; <line17> } <line18> }); <line19> Class<? extends ConnectionProvider> cpClass = <line20> getConf() <line21> .getClass( <line22> JDBC_CONNECTION_PROVIDER, <line23> DataSourceConnectionProvider.class, <line24> ConnectionProvider.class); <line25> try { <line26> connectionProvider = cpClass.newInstance(); <line27> estimateConnectionProvider = cpClass.newInstance(); <line28> } catch (Exception e) { <line29> log.error(UNKNOWN); <line30> throw new LensException(e); <line31> } <line32> this.logSegregationContext = new MappedDiagnosticLogSegregationContext(); <line33> this.isStatementCancelSupported = <line34> getConf().getBoolean(STATEMENT_CANCEL_SUPPORTED, DEFAULT_STATEMENT_CANCEL_SUPPORTED); <line35> } <line36> } <line37> "	"""Error initializing connection provider: "", e"	task7	
"public class A { <line0> public static List<Property> select( <line1> EntityManager em, final String mediaPackageId, final String namespace) { <line2> TypedQuery<PropertyDto> query = <line3> em.createNamedQuery(""Property.selectByMediaPackageAndNamespace"", PropertyDto.class) <line4> .setParameter(""mediaPackageId"", mediaPackageId) <line5> .setParameter(""namespace"", namespace); <line6> logger.debug(UNKNOWN); <line7> return query.getResultList().parallelStream() <line8> .map(PropertyDto::toProperty) <line9> .collect(Collectors.toList()); <line10> } <line11> } <line12> "	"""Executing query {}"", query"	task7	
public class A { <line0> @Override <line1> public void handle(IdentificationRequest request) throws IOException { <line2> if (request.getClass().isAssignableFrom(FileSystemIdentificationRequest.class)) { <line3> FileSystemIdentificationRequest req = (FileSystemIdentificationRequest) request; <line4> Iso9660FileSystem fileSystem = new Iso9660FileSystem(req.getFile().toFile(), true); <line5> ISOImageArchiveWalker walker = <line6> new ISOImageArchiveWalker( <line7> droid, factory, resultHandler, fileSystem, request.getIdentifier()); <line8> walker.walk(fileSystem); <line9> } else { <line10> log.info(UNKNOWN); <line11> } <line12> } <line13> } <line14> 	"""Identification request for ISO image ignored due to limited support."""	task7	
"public class A { <line0> @Override <line1> public void init(String serviceName, String appId, String configPropertyPrefix) { <line2> super.init(serviceName, appId, configPropertyPrefix); <line3> try { <line4> gson = <line5> new GsonBuilder().setDateFormat(""yyyyMMdd-HH:mm:ss.SSS-Z"").setPrettyPrinting().create(); <line6> } catch (Throwable excp) { <line7> LOG.error(UNKNOWN); <line8> } <line9> } <line10> } <line11> "	"excp, ""AbstractRangerAdminClient: failed to create GsonBuilder object"""	task7	
public class A { <line0> private CSVRecordReader getCSVRecordReader(String file) throws IOException, URISyntaxException { <line1> InputSplit split = ColumnBasedHandlerTestUtil.getSplit(file); <line2> TaskAttemptContext ctx = new TaskAttemptContextImpl(conf, new TaskAttemptID()); <line3> TypeRegistry.reset(); <line4> TypeRegistry.getInstance(ctx.getConfiguration()); <line5> log.debug(UNKNOWN); <line6> CSVRecordReader reader = new CSVRecordReader(); <line7> reader.initialize(split, ctx); <line8> return reader; <line9> } <line10> } <line11> 	TypeRegistry.getContents()	task7	
"public class A { <line0> @Test <line1> public void testSearchCreator() throws Exception { <line2> String id1 = <line3> addItem( <line4> ""title:testTemplateFilter"", <line5> ""contents:testTemplateFilter"", <line6> 0, <line7> TemplateLogic.TYPE_ID_KNOWLEDGE, <line8> 100, <line9> DateUtils.now(), <line10> null, <line11> null, <line12> null); <line13> String id2 = <line14> addItem( <line15> ""title:testTemplateFilter"", <line16> ""contents:testTemplateFilter"", <line17> 0, <line18> TemplateLogic.TYPE_ID_EVENT, <line19> 101, <line20> DateUtils.now(), <line21> null, <line22> null, <line23> null); <line24> String id3 = <line25> addItem( <line26> ""title:testTemplateFilter"", <line27> ""contents:testTemplateFilter"", <line28> 0, <line29> TemplateLogic.TYPE_ID_BOOKMARK, <line30> 102, <line31> DateUtils.now(), <line32> null, <line33> null, <line34> null); <line35> Searcher searcher = Container.getComp(Searcher.class); <line36> SearchingValue searchingValue = new SearchingValue(); <line37> searchingValue.addCreator(100); <line38> List<SearchResultValue> results = searcher.search(searchingValue, 1); <line39> for (SearchResultValue searchResultValue : results) { <line40> LOG.info(UNKNOWN); <line41> } <line42> assertEquals(1, results.size()); <line43> SearchResultValue result = results.get(0); <line44> assertEquals(id1, result.getId()); <line45> } <line46> } <line47> "	PropertyUtil.reflectionToString(searchResultValue)	task7	
"public class A { <line0> @Override <line1> protected String stopProcessesAtMachine(ConfigBag parameters) { <line2> entity().sensors().set(Attributes.SERVICE_UP, false); <line3> Integer pid = entity().getAttribute(Attributes.PID); <line4> if (pid == null) { <line5> log.info(UNKNOWN); <line6> return ""No pid -- is it running?""; <line7> } <line8> DynamicTasks.queue( <line9> SshEffectorTasks.ssh(""cd "" + dir(entity) + ""/*"", ""./support-files/mysql.server stop"") <line10> .summary(""stop mysql"")); <line11> return ""submitted stop""; <line12> } <line13> } <line14> "	"""mysql not running"""	task7	
"public class A { <line0> @Test <line1> public void testAvroCompression() throws Exception { <line2> Map<String, String> props = createProps(); <line3> props.put(HdfsSinkConnectorConfig.AVRO_CODEC_CONFIG, ""snappy""); <line4> HdfsSinkConnectorConfig connectorConfig = new HdfsSinkConnectorConfig(props); <line5> DataWriter hdfsWriter = new DataWriter(connectorConfig, context, avroData); <line6> partitioner = hdfsWriter.getPartitioner(); <line7> hdfsWriter.recover(TOPIC_PARTITION); <line8> List<SinkRecord> sinkRecords = createSinkRecords(7); <line9> hdfsWriter.write(sinkRecords); <line10> hdfsWriter.close(); <line11> hdfsWriter.stop(); <line12> long[] validOffsets = {0, 3, 6}; <line13> verify(sinkRecords, validOffsets); <line14> List<String> filenames = getExpectedFiles(validOffsets, TOPIC_PARTITION); <line15> for (String filename : filenames) { <line16> Path p = new Path(filename); <line17> try (FSDataInputStream stream = fs.open(p)) { <line18> int size = (int) fs.getFileStatus(p).getLen(); <line19> ByteBuffer buffer = ByteBuffer.allocate(size); <line20> if (stream.read(buffer) <= 0) { <line21> log.error(UNKNOWN); <line22> } <line23> String fileContents = new String(buffer.array()); <line24> int index; <line25> assertTrue( <line26> (index = fileContents.indexOf(""avro.codec"")) > 0 <line27> && fileContents.indexOf(""snappy"", index) > 0); <line28> } <line29> } <line30> } <line31> } <line32> "	"""Could not read file {}"", filename"	task7	
"public class A { <line0> public static com.liferay.commerce.product.model.CommerceCatalog addCommerceCatalog( <line1> HttpPrincipal httpPrincipal, <line2> String externalReferenceCode, <line3> String name, <line4> String commerceCurrencyCode, <line5> String catalogDefaultLanguageId, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> CommerceCatalogServiceUtil.class, <line12> ""addCommerceCatalog"", <line13> _addCommerceCatalogParameterTypes0); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, <line17> externalReferenceCode, <line18> name, <line19> commerceCurrencyCode, <line20> catalogDefaultLanguageId, <line21> serviceContext); <line22> Object returnObj = null; <line23> try { <line24> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line25> } catch (Exception exception) { <line26> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line27> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line28> } <line29> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line30> } <line31> return (com.liferay.commerce.product.model.CommerceCatalog) returnObj; <line32> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line33> log.error(UNKNOWN); <line34> throw systemException; <line35> } <line36> } <line37> } <line38> "	systemException, systemException	task7	
"public class A { <line0> @Override <line1> public void doRouteStatusChange(DocumentRouteStatusChange statusChangeEvent) { <line2> super.doRouteStatusChange(statusChangeEvent); <line3> String newRouteStatus = statusChangeEvent.getNewRouteStatus(); <line4> if (newRouteStatus.equalsIgnoreCase(KFSConstants.DocumentStatusCodes.PROCESSED) <line5> || newRouteStatus.equalsIgnoreCase(KFSConstants.DocumentStatusCodes.FINAL)) { <line6> try { <line7> updateContractsGrantsInvoiceDocument(); <line8> } catch (WorkflowException ex) { <line9> LOG.error(UNKNOWN); <line10> throw new RuntimeException( <line11> ""Could not update Contracts & Grants Invoice Document for Final Billed Indicator"" <line12> + "" Document"", <line13> ex); <line14> } <line15> } <line16> } <line17> } <line18> "	"""problem during FinalBilledIndicatorDocumentAction.doProcessingAfterPost()"", ex"	task7	
"public class A { <line0> @Override <line1> public ChannelHandler call() throws Exception { <line2> try { <line3> return new SslHandler(createSslEngine(input)); <line4> } catch (SSLException e) { <line5> LOG.error( <line6> ""Error creating SSL context. Make sure the certificate and key are in the correct format:"" <line7> + "" cert=X.509 key=PKCS#8""); <line8> throw e; <line9> } <line10> } <line11> } <line12> "	"""Error creating SSL context. Make sure the certificate and key are in the correct format:""+ "" cert=X.509 key=PKCS#8"""	task7	
"public class A { <line0> @Override <line1> protected void beginNodesRestart() { <line2> stopRestartThread.set(false); <line3> nodeRestartFut = <line4> GridTestUtils.runAsync( <line5> new Callable<Void>() { <line6> @Override <line7> public Void call() throws Exception { <line8> while (!stopRestartThread.get() && System.currentTimeMillis() < endTime) { <line9> log.info(UNKNOWN); <line10> for (int i = GRID_CNT - RESTARTED_NODE_CNT; i < GRID_CNT; ++i) stopGrid(i); <line11> Thread.sleep(500); <line12> for (int i = GRID_CNT - RESTARTED_NODE_CNT; i < GRID_CNT; ++i) startGrid(i); <line13> awaitPartitionMapExchange(); <line14> GridTestUtils.waitForCondition( <line15> new GridAbsPredicate() { <line16> @Override <line17> public boolean apply() { <line18> return !stopRestartThread.get(); <line19> } <line20> }, <line21> RESTART_TIMEOUT); <line22> } <line23> return null; <line24> } <line25> }, <line26> ""restart-node""); <line27> } <line28> } <line29> "	"""Restart nodes"""	task7	
"public class A { <line0> @Test <line1> public void shouldVerifyWithUnknown() { <line2> log.info(UNKNOWN); <line3> PayPalStatusVerifier mockStatusVerifier = new MockStatusVerifier(); <line4> PayPalVerificationService verificationService = <line5> new PayPalVerificationService( <line6> ""dummyAddress"", <line7> new PayPalProcessorsFactory(MockVerifiedPayPalProcessor.class), <line8> new TestErrorHandler(), <line9> mockStatusVerifier); <line10> HashMap<String, String[]> parametersMap = new HashMap<String, String[]>(); <line11> parametersMap.put( <line12> RequestParameters.Parameter.payment_status.toString(), new String[] {""UNKNOWN""}); <line13> PayPalStatus status = <line14> verificationService.verify(new RequestParameters(new RequestMock(parametersMap))); <line15> assertThat(status.isUnknown()).isTrue(); <line16> } <line17> } <line18> "	"""--shouldVerifyWithUnknown"""	task7	
"public class A { <line0> @VisibleForTesting <line1> static synchronized File dumpHeap(File directory) <line2> throws MalformedObjectNameException, InstanceNotFoundException, ReflectionException, <line3> MBeanException, IOException { <line4> boolean liveObjectsOnly = false; <line5> File fileName = new File(directory, ""heap_dump.hprof""); <line6> if (fileName.exists() && !fileName.delete()) { <line7> throw new IOException(""heap_dump.hprof already existed and couldn't be deleted!""); <line8> } <line9> MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); <line10> ObjectName oname = new ObjectName(""com.sun.management:type=HotSpotDiagnostic""); <line11> Object[] parameters = {fileName.getPath(), liveObjectsOnly}; <line12> String[] signatures = {String.class.getName(), boolean.class.getName()}; <line13> mbs.invoke(oname, ""dumpHeap"", parameters, signatures); <line14> if (java.nio.file.FileSystems.getDefault().supportedFileAttributeViews().contains(""posix"")) { <line15> Files.setPosixFilePermissions( <line16> fileName.toPath(), <line17> ImmutableSet.of( <line18> PosixFilePermission.OWNER_READ, <line19> PosixFilePermission.GROUP_READ, <line20> PosixFilePermission.OTHERS_READ)); <line21> } else { <line22> fileName.setReadable(true, true); <line23> } <line24> LOG.warn(UNKNOWN); <line25> return fileName; <line26> } <line27> } <line28> "	"""Heap dumped to {}"", fileName"	task7	
"public class A { <line0> private void performUpdateDaysSinceLastImportBatch( <line1> DataRoot dataRoot, <line2> final int fetchSize, <line3> int offset, <line4> AtomicInteger updatedDocs, <line5> final LocalDate nowDate) <line6> throws SolrServerException, DocumentStoreException, IOException { <line7> int updatedInBatch = 0; <line8> final SolrQuery query = createOldRecordsQuery(dataRoot); <line9> query.setStart(offset); <line10> query.setRows(fetchSize); <line11> for (SolrDocument doc : solrBridge.getClient().query(query).getResults()) { <line12> updatedInBatch++; <line13> String recordId = (String) doc.getFieldValue(fieldNameService.getFieldName(FieldKey.ID)); <line14> Date lastImportDate = <line15> (Date) doc.getFieldValue(fieldNameService.getFieldName(FieldKey.LAST_SEEN)); <line16> LocalDate oldDate = lastImportDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); <line17> long daysSinceLastSeen = DAYS.between(oldDate, nowDate); <line18> SolrInputDocument updateDoc = new SolrInputDocument(); <line19> updateDoc.setField(fieldNameService.getFieldName(FieldKey.ID), recordId); <line20> final Map<String, Long> partialUpdateMap = Collections.singletonMap(""set"", daysSinceLastSeen); <line21> updateDoc.setField( <line22> fieldNameService.getFieldName(FieldKey.DAYS_SINCE_LAST_SEEN), partialUpdateMap); <line23> solrBridge.addDocument(updateDoc); <line24> final Throwable error = solrBridge.popError(); <line25> if (error != null) { <line26> throw new DocumentStoreException(error); <line27> } <line28> } <line29> final int totalUpdated = updatedDocs.addAndGet(updatedInBatch); <line30> LOG.info( <line31> ""Updating \""days since last seen\"": {} updated in batch - {} records updated thus far"", <line32> updatedInBatch, <line33> totalUpdated); <line34> } <line35> } <line36> "	"""Updating \""days since last seen\"": {} updated in batch - {} records updated thus far"",updatedInBatch,totalUpdated"	task7	
"public class A { <line0> private void checkHierarchy(MCRMODSWrapper mods) throws MCRPersistenceException { <line1> final MCRObjectID modsId = Objects.requireNonNull(mods.getMCRObject().getId()); <line2> LOGGER.info(UNKNOWN); <line3> final List<Element> relatedItemLeaves = <line4> mods.getElements("".//mods:relatedItem[not(mods:relatedItem)]""); <line5> try { <line6> relatedItemLeaves.forEach(e -> checkHierarchy(e, new HashSet<>(Set.of(modsId)))); <line7> } catch (MCRPersistenceException e) { <line8> throw new MCRPersistenceException( <line9> ""Hierarchy of mods:relatedItem in "" + modsId + "" contains circuits."", e); <line10> } <line11> } <line12> } <line13> "	"""Checking relatedItem hierarchy of {}."", modsId"	task7	
"public class A { <line0> @Override <line1> public void createState(State state) throws DocumentException { <line2> String id = (String) state.get(KEY_ID); <line3> if (log.isTraceEnabled()) { <line4> log.trace(UNKNOWN); <line5> } <line6> if (states.containsKey(id)) { <line7> throw new DocumentException(""Already exists: "" + id); <line8> } <line9> state = StateHelper.deepCopy(state, true); <line10> StateHelper.resetDeltas(state); <line11> states.put(id, state); <line12> } <line13> } <line14> "	"""create "" + id + "": "" + state"	task7	
"public class A { <line0> @Override <line1> public Representation get() { <line2> StringRepresentation presentation = null; <line3> try { <line4> String clusterName = (String) getRequest().getAttributes().get(""clusterName""); <line5> presentation = getInstancesRepresentation(clusterName); <line6> } catch (Exception e) { <line7> String error = ClusterRepresentationUtil.getErrorAsJsonStringFromException(e); <line8> presentation = new StringRepresentation(error, MediaType.APPLICATION_JSON); <line9> LOG.error(UNKNOWN); <line10> } <line11> return presentation; <line12> } <line13> } <line14> "	""""", e"	task7	
"public class A { <line0> @Override <line1> public String getDiscussionPath() { <line2> if (_wikiGroupServiceOverriddenConfiguration == null) { <line3> try { <line4> _wikiGroupServiceOverriddenConfiguration = <line5> ConfigurationProviderUtil.getConfiguration( <line6> WikiGroupServiceOverriddenConfiguration.class, <line7> new GroupServiceSettingsLocator(_page.getGroupId(), WikiConstants.SERVICE_NAME)); <line8> } catch (Exception exception) { <line9> log.error(UNKNOWN); <line10> return null; <line11> } <line12> } <line13> if (_wikiGroupServiceOverriddenConfiguration.pageCommentsEnabled()) { <line14> return ""edit_page_discussion""; <line15> } <line16> return null; <line17> } <line18> } <line19> "	exception, exception	task7	
public class A { <line0> private Pair<Filter, Set<String>> buildFromFIQL(final ReconQuery reconQuery) { <line1> Filter filter = null; <line2> Set<String> moreAttrsToGet = new HashSet<>(); <line3> if (reconQuery.getMoreAttrsToGet() != null) { <line4> moreAttrsToGet.addAll(reconQuery.getMoreAttrsToGet()); <line5> } <line6> if (StringUtils.isNotBlank(reconQuery.getFiql())) { <line7> try { <line8> FilterVisitor visitor = new FilterVisitor(); <line9> SearchCondition<SearchBean> sc = <line10> searchContext.getCondition(reconQuery.getFiql(), SearchBean.class); <line11> sc.accept(visitor); <line12> filter = visitor.getQuery(); <line13> moreAttrsToGet.addAll(visitor.getAttrs()); <line14> } catch (Exception e) { <line15> LOG.error(UNKNOWN); <line16> SyncopeClientException sce = <line17> SyncopeClientException.build(ClientExceptionType.InvalidSearchExpression); <line18> sce.getElements().add(reconQuery.getFiql()); <line19> sce.getElements().add(ExceptionUtils.getRootCauseMessage(e)); <line20> throw sce; <line21> } <line22> } <line23> return Pair.of(filter, moreAttrsToGet); <line24> } <line25> } <line26> 	"""Invalid FIQL expression: {}"", reconQuery.getFiql(), e"	task7	
"public class A { <line0> protected void replaceDBAndTableNames(HiveConf metastoreConf, ASTNode tree) { <line1> if (tree == null) { <line2> return; <line3> } <line4> if (TOK_TABREF == tree.getToken().getType()) { <line5> String alias; <line6> String tblName = null; <line7> Table tbl = null; <line8> ASTNode tabNameChild = (ASTNode) tree.getChild(0); <line9> if (TOK_TABNAME == tabNameChild.getToken().getType()) { <line10> try { <line11> if (tabNameChild.getChildCount() == 2) { <line12> ASTNode dbIdentifier = (ASTNode) tabNameChild.getChild(0); <line13> ASTNode tableIdentifier = (ASTNode) tabNameChild.getChild(1); <line14> tblName = tableIdentifier.getText(); <line15> String lensTable = dbIdentifier.getText() + ""."" + tblName; <line16> tbl = CubeMetastoreClient.getInstance(metastoreConf).getHiveTable(lensTable); <line17> String table = getUnderlyingTableName(tbl); <line18> String db = getUnderlyingDBName(tbl); <line19> if (""default"".equalsIgnoreCase(db)) { <line20> tabNameChild.deleteChild(0); <line21> } else if (StringUtils.isNotBlank(db)) { <line22> dbIdentifier.getToken().setText(db); <line23> } <line24> if (StringUtils.isNotBlank(table)) { <line25> tableIdentifier.getToken().setText(table); <line26> } <line27> } else { <line28> ASTNode tableIdentifier = (ASTNode) tabNameChild.getChild(0); <line29> tblName = tableIdentifier.getText(); <line30> tbl = CubeMetastoreClient.getInstance(metastoreConf).getHiveTable(tblName); <line31> String table = getUnderlyingTableName(tbl); <line32> if (StringUtils.isNotBlank(table)) { <line33> tableIdentifier.getToken().setText(table); <line34> } <line35> String dbName = getUnderlyingDBName(tbl); <line36> if (StringUtils.isNotBlank(dbName) && !""default"".equalsIgnoreCase(dbName)) { <line37> ASTNode dbIdentifier = new ASTNode(new CommonToken(HiveParser.Identifier, dbName)); <line38> dbIdentifier.setParent(tabNameChild); <line39> tabNameChild.insertChild(0, dbIdentifier); <line40> } <line41> } <line42> } catch (LensException | HiveException e) { <line43> log.warn(UNKNOWN); <line44> } <line45> } <line46> if (tree.getChildCount() == 2) { <line47> alias = tree.getChild(1).getText(); <line48> } else { <line49> alias = tblName; <line50> } <line51> if (StringUtils.isNotBlank(alias)) { <line52> alias = alias.toLowerCase(); <line53> if (!aliasToNativeTableInfo.containsKey(alias)) { <line54> if (tbl != null) { <line55> aliasToNativeTableInfo.put(alias, new NativeTableInfo(tbl)); <line56> } <line57> } <line58> } <line59> } else { <line60> for (int i = 0; i < tree.getChildCount(); i++) { <line61> replaceDBAndTableNames(metastoreConf, (ASTNode) tree.getChild(i)); <line62> } <line63> } <line64> } <line65> } <line66> "	"""No corresponding table in metastore:"", e"	task7	
"public class A { <line0> @Override <line1> public void service(HttpServletRequest request, HttpServletResponse response) <line2> throws ServletException, IOException { <line3> String resourcePath = request.getRequestURI().substring(request.getContextPath().length() + 1); <line4> InputStream in = null; <line5> try { <line6> if (resourcePath.startsWith(""generated-res"")) { <line7> URLConnection conn = <line8> MolgenisOriginalStyle.class.getResource(resourcePath.substring(10)).openConnection(); <line9> in = new BufferedInputStream(conn.getInputStream()); <line10> response.setHeader(""Cache-Control"", ""max-age=0""); <line11> OutputStream out = response.getOutputStream(); <line12> byte[] buffer = new byte[2048]; <line13> for (; ; ) { <line14> int nBytes = in.read(buffer); <line15> if (nBytes <= 0) break; <line16> out.write(buffer, 0, nBytes); <line17> } <line18> out.flush(); <line19> out.close(); <line20> } <line21> } catch (Exception e) { <line22> e.printStackTrace(); <line23> logger.error(UNKNOWN); <line24> } finally { <line25> IOUtils.closeQuietly(in); <line26> } <line27> } <line28> } <line29> "	"""loading of failed: "" + e"	task7	
public class A { <line0> public void start() throws Exception { <line1> if (server == null) { <line2> Vertx vertx = hostConfiguration.getVertx(); <line3> Router router = hostConfiguration.getRouter(); <line4> HttpServerOptions options = hostConfiguration.getServerOptions(); <line5> SSLContextParameters sslContextParameters = hostConfiguration.getSslContextParameters(); <line6> if (sslContextParameters != null) { <line7> if (options == null) { <line8> options = new HttpServerOptions(); <line9> } <line10> VertxWebsocketHelper.setupSSLOptions(sslContextParameters, options); <line11> } <line12> if (options != null) { <line13> server = vertx.createHttpServer(options); <line14> } else { <line15> server = vertx.createHttpServer(); <line16> } <line17> CompletableFuture<Void> future = new CompletableFuture<>(); <line18> server <line19> .requestHandler(router) <line20> .listen( <line21> hostKey.getPort(), <line22> hostKey.getHost(), <line23> result -> { <line24> if (!result.failed()) { <line25> port = result.result().actualPort(); <line26> future.complete(null); <line27> LOG.info(UNKNOWN); <line28> } else { <line29> future.completeExceptionally(result.cause()); <line30> } <line31> }); <line32> future.get(); <line33> } <line34> } <line35> } <line36> 	"""Vert.x HTTP server started on {}:{}"", hostKey.getHost(), port"	task7	
public class A { <line0> private void cleanUpTmpFile(Path tmpFile) { <line1> if (tmpFile == null) { <line2> return; <line3> } <line4> try { <line5> Files.deleteIfExists(tmpFile); <line6> } catch (IOException ignored) { <line7> log.warn(UNKNOWN); <line8> } <line9> } <line10> } <line11> 	"""Deleting temporary file failed: "" + tmpFile, ignored"	task7	
public class A { <line0> public Criteria getSeriesCriteriaFor( <line1> String procedure, String observableProperty, String featureOfInterest, Session session) { <line2> final Criteria c = createCriteriaFor(procedure, observableProperty, featureOfInterest, session); <line3> LOGGER.trace(UNKNOWN); <line4> return c; <line5> } <line6> } <line7> 	QUERY_SERIES, HibernateHelper.getSqlString(c)	task7	
public class A { <line0> @Override <line1> public GetLocationOfCurrentStationReturned getLocationOfCurrentStation() { <line2> logger.error(UNKNOWN); <line3> throw new UnsupportedOperationException(); <line4> } <line5> } <line6> 	"""Not implemented."""	task7	
public class A { <line0> public static Integer initPreparedStatementsCacheSize(ConfigMap configMap) { <line1> LOGGER.trace(UNKNOWN); <line2> return configMap.getTypedOr(PREPARED_STATEMENTS_CACHE_SIZE, DEFAULT_LRU_CACHE_SIZE); <line3> } <line4> } <line5> 	"""Extract or init prepared statements cache size"""	task7	
"public class A { <line0> @Override <line1> public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException { <line2> String sql = ""SELECT DISTINCT name FROM "" + catalog + "".dbo.sysusers where suid > 0""; <line3> ResultSet rs = null; <line4> PreparedStatement stmt = null; <line5> List<String[]> list = new ArrayList<String[]>(); <line6> try { <line7> stmt = connection.prepareStatement(sql); <line8> rs = stmt.executeQuery(); <line9> while (rs.next()) { <line10> String name = rs.getString(""name""); <line11> String[] r = new String[] {name.trim()}; <line12> list.add(r); <line13> } <line14> } catch (SQLException e) { <line15> throw new RuntimeException(e); <line16> } finally { <line17> try { <line18> if (rs != null) { <line19> rs.close(); <line20> } <line21> if (stmt != null) { <line22> stmt.close(); <line23> } <line24> } catch (Exception e) { <line25> log.error(UNKNOWN); <line26> } <line27> } <line28> SybaseResultSet tableResultSet = new SybaseResultSet(); <line29> tableResultSet.setMetadata(new String[] {""TABLE_SCHEM""}); <line30> tableResultSet.setData(list); <line31> return tableResultSet; <line32> } <line33> } <line34> "	e	task7	
"public class A { <line0> @Override <line1> public void applicationAdded(SpaceLifeCycleEvent event) { <line2> LOG.debug( <line3> ""application <strong>"" <line4> + event.getTarget() <line5> + ""</strong> was added in space "" <line6> + event.getSpace().getDisplayName()); <line7> } <line8> } <line9> "	"""application <strong>""+ event.getTarget()+ ""</strong> was added in space ""+ event.getSpace().getDisplayName()"	task7	
"public class A { <line0> protected FinancialSystemMaintenanceDocument getParentMaintDoc() { <line1> DocumentService documentService = SpringContext.getBean(DocumentService.class); <line2> try { <line3> return (FinancialSystemMaintenanceDocument) <line4> documentService.getByDocumentHeaderId(getDocumentNumber()); <line5> } catch (WorkflowException e) { <line6> LOG.error( <line7> ""Unable to retrieve maintenance document for use in split node routing - returning null"", <line8> e); <line9> } <line10> return null; <line11> } <line12> } <line13> "	"""Unable to retrieve maintenance document for use in split node routing - returning null"",e"	task7	
"public class A { <line0> @Override <line1> protected void onCompleteFailure(Throwable x) { <line2> lease.recycle(); <line3> Throwable closed; <line4> Set<Entry> allEntries; <line5> try (AutoLock l = lock.lock()) { <line6> closed = terminated; <line7> terminated = x; <line8> if (LOG.isDebugEnabled()) <line9> LOG.debug( <line10> String.format( <line11> ""%s, entries processed/pending/queued=%d/%d/%d"", <line12> closed != null ? ""Closing"" : ""Failing"", <line13> processedEntries.size(), <line14> pendingEntries.size(), <line15> entries.size()), <line16> x); <line17> allEntries = new HashSet<>(entries); <line18> entries.clear(); <line19> } <line20> allEntries.addAll(processedEntries); <line21> processedEntries.clear(); <line22> allEntries.addAll(pendingEntries); <line23> pendingEntries.clear(); <line24> allEntries.forEach(entry -> entry.failed(x)); <line25> if (closed == null) session.onWriteFailure(x); <line26> } <line27> } <line28> "	"String.format(""%s, entries processed/pending/queued=%d/%d/%d"",closed != null ? ""Closing"" : ""Failing"",processedEntries.size(),pendingEntries.size(),entries.size()),x"	task7	
public class A { <line0> @Override <line1> protected synchronized void stopScan() { <line2> logger.debug(UNKNOWN); <line3> dsmrBridgeHandler.setLenientMode(false); <line4> super.stopScan(); <line5> dsmrBridgeHandler.unregisterDSMRMeterListener(this); <line6> } <line7> } <line8> 	"""Stop discovery on existing DSMR bridge."""	task7	
"public class A { <line0> public static TokenResponse getTokenResponse( <line1> String googleClientID, String googleClientSecret, String code, String redirectUri) { <line2> final AuthorizationCodeFlow flow = <line3> new AuthorizationCodeFlow.Builder( <line4> BearerToken.authorizationHeaderAccessMethod(), <line5> TokenResource.HTTP_TRANSPORT, <line6> TokenResource.JSON_FACTORY, <line7> new GenericUrl(GoogleHelper.GOOGLE_ENCODED_URL), <line8> new ClientParametersAuthentication(googleClientID, googleClientSecret), <line9> googleClientID, <line10> GoogleHelper.GOOGLE_AUTHORIZATION_SERVICE_ENCODED_URL) <line11> .build(); <line12> try { <line13> return flow.newTokenRequest(code) <line14> .setRedirectUri(redirectUri) <line15> .setRequestInitializer(request -> request.getHeaders().setAccept(""application/json"")) <line16> .execute(); <line17> } catch (IOException e) { <line18> LOG.error(UNKNOWN); <line19> throw new CustomWebApplicationException( <line20> ""Could not retrieve google token based on code"", HttpStatus.SC_BAD_REQUEST); <line21> } <line22> } <line23> } <line24> "	"""Retrieving accessToken was unsuccessful"", e"	task7	
public class A { <line0> @Override <line1> public void close() { <line2> isRunning.compareAndSet(true, false); <line3> LOG.info(UNKNOWN); <line4> } <line5> } <line6> 	"""console dirty consumer close ..."""	task7	
public class A { <line0> @Override <line1> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line2> throws IOException, ServletException { <line3> HttpServletRequest req = (HttpServletRequest) request; <line4> String requestURI = req.getRequestURI(); <line5> if (isUriNotProtected(requestURI)) { <line6> chain.doFilter(request, response); <line7> return; <line8> } <line9> String xhrToken = req.getHeader(GlobalDataRest.X_CSRF_TOKEN); <line10> String sessionId = req.getRequestedSessionId(); <line11> String token = tokenMap.get(sessionId); <line12> if (sessionId != null && token != null && token.equals(xhrToken)) { <line13> deleteTokenWhenLogout(req, sessionId); <line14> chain.doFilter(request, response); <line15> } else { <line16> deleteTokenWhenLogout(req, sessionId); <line17> LOGGER.error(UNKNOWN); <line18> final HttpServletResponse newResponse = (HttpServletResponse) response; <line19> newResponse.sendError( <line20> Status.FORBIDDEN.getStatusCode(), CSRF_STATE_TOKEN_DOES_NOT_MATCH_ONE_PROVIDED); <line21> StreamUtils.closeSilently(request.getInputStream()); <line22> } <line23> } <line24> } <line25> 	CSRF_STATE_TOKEN_DOES_NOT_MATCH_ONE_PROVIDED	task7	
public class A { <line0> protected DatagramSocket sendDiscoveryPacket() throws IOException { <line1> final DatagramSocket ds = new DatagramSocket(null); <line2> ds.setBroadcast(true); <line3> ds.setSoTimeout(UDP_PACKET_TIMEOUT_MS); <line4> ds.send(discoverPacket); <line5> logger.trace(UNKNOWN); <line6> return ds; <line7> } <line8> } <line9> 	"""Discovery package sent."""	task7	
public class A { <line0> public CreateVersionPage inputVersionId(final String versionId) { <line1> log.info(UNKNOWN); <line2> enterText(getVersionIdField(), versionId); <line3> return new CreateVersionPage(getDriver()); <line4> } <line5> } <line6> 	"""Enter version ID {}"", versionId"	task7	
"public class A { <line0> @VisibleForTesting <line1> static int getThreadCount(@Nullable final String threadCountArg) { <line2> final int availableThreads = Runtime.getRuntime().availableProcessors(); <line3> if (threadCountArg == null) { <line4> return availableThreads; <line5> } <line6> try { <line7> final int numThreads = Integer.parseInt(threadCountArg); <line8> if (numThreads <= 0) { <line9> throw new NumberFormatException(); <line10> } <line11> return numThreads; <line12> } catch (NumberFormatException e) { <line13> LOGGER.info( <line14> ""Couldn't parse thread count parameter > 0; using default value: {}."", availableThreads); <line15> return availableThreads; <line16> } <line17> } <line18> } <line19> "	"""Couldn't parse thread count parameter > 0; using default value: {}."", availableThreads"	task7	
"public class A { <line0> private void sendObject(final Object object, final Logger logger) { <line1> if (logger.isInfoEnabled()) { <line2> final JsonObject log = new JsonObject(); <line3> log.addProperty(""appName"", appName); <line4> log.addProperty(""host"", localHostName); <line5> log.add(""event"", GSON.toJsonTree(object)); <line6> logger.info(UNKNOWN); <line7> } <line8> } <line9> } <line10> "	GSON.toJson(log)	task7	
"public class A { <line0> @Override <line1> public ReadingPublisher<Pca301Reading> createPublisher() { <line2> return new ReadingPublisher<Pca301Reading>() { <line3> @Override <line4> public void publish(Pca301Reading reading) { <line5> if (reading != null) { <line6> channel.set(reading.getChannel()); <line7> BigDecimal current = <line8> new BigDecimal(reading.getCurrent()).setScale(1, RoundingMode.HALF_UP); <line9> state = reading.isOn() ? OnOffType.ON : OnOffType.OFF; <line10> updateState(CURRENT_POWER_CHANNEL, new QuantityType<>(current, Units.WATT)); <line11> updateState(CONSUMPTION_CHANNEL, new QuantityType<>(reading.getTotal(), Units.WATT_HOUR)); <line12> updateState(SWITCHING_STATE_CHANNEL, state); <line13> logger.debug( <line14> ""updated states for thing {} ({}): state={}, current={}, total={}"", <line15> getThing().getLabel(), <line16> getThing().getUID().getId(), <line17> state, <line18> current, <line19> reading.getTotal()); <line20> } <line21> } <line22>  <line23> @Override <line24> public void dispose() {} <line25> }; <line26> } <line27> } <line28> "	"""updated states for thing {} ({}): state={}, current={}, total={}"",getThing().getLabel(),getThing().getUID().getId(),state,current,reading.getTotal()"	task7	
"public class A { <line0> @Override <line1> public void instantiateServiceInstance() { <line2> if (monitor.enterIf(isStartable)) { <line3> try { <line4> LOG.info(UNKNOWN); <line5> state = STARTING; <line6> delegate.instantiateServiceInstance(); <line7> state = RUNNING; <line8> } finally { <line9> monitor.leave(); <line10> } <line11> } else { <line12> throw new IllegalStateException(""Service "" + this + "" has already been started""); <line13> } <line14> } <line15> } <line16> "	"""Starting {} service for node {}"", this, getDeviceInfo()"	task7	
public class A { <line0> private Geometry getBounds(List<Metacard> metacards) { <line1> if (metacards != null) { <line2> List<Geometry> geometries = new ArrayList<Geometry>(); <line3> for (Metacard card : metacards) { <line4> if (null != card.getLocation()) { <line5> Geometry geo = XmlNode.readGeometry(card.getLocation()); <line6> if (null != geo) { <line7> geometries.add(geo); <line8> } <line9> } <line10> } <line11> return new GeometryCollection(geometries.toArray(new Geometry[0]), new GeometryFactory()); <line12> } else { <line13> LOGGER.debug(UNKNOWN); <line14> return null; <line15> } <line16> } <line17> } <line18> 	"""Metacard list is null"""	task7	
public class A { <line0> public boolean hasReadAuthorization(Set<String> userAndRoles, String noteId) { <line1> if (conf.isAnonymousAllowed()) { <line2> LOG.debug(UNKNOWN); <line3> return true; <line4> } <line5> if (userAndRoles == null) { <line6> return false; <line7> } <line8> return isReader(noteId, userAndRoles); <line9> } <line10> } <line11> 	"""Zeppelin runs in anonymous mode, everybody is reader"""	task7	
"public class A { <line0> public static SAXReader getSAXReader(final EntityResolver resolver) { <line1> SAXReader reader = new SAXReader(); <line2> if (resolver != null) { <line3> reader.setEntityResolver(resolver); <line4> } <line5> try { <line6> reader.setFeature(FEATURE_SECURE_PROCESSING, true); <line7> reader.setFeature(""http://xml.org/sax/features/external-general-entities"", false); <line8> reader.setFeature(""http://xml.org/sax/features/external-parameter-entities"", false); <line9> reader.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false); <line10> } catch (SAXException e) { <line11> logger.error(UNKNOWN); <line12> } <line13> reader.setIncludeExternalDTDDeclarations(false); <line14> reader.setIncludeInternalDTDDeclarations(false); <line15> return reader; <line16> } <line17> } <line18> "	"""Some parser properties are not supported."""	task7	
"public class A { <line0> @ApiOperation(value = ""Create ontology"") <line1> @PostMapping <line2> @ResponseStatus(HttpStatus.CREATED) <line3> public OntologyDto create(@Valid @RequestBody OntologyDto ontologyDto) { <line4> LOGGER.debug(UNKNOWN); <line5> return service.create(buildUiHttpContext(), ontologyDto); <line6> } <line7> } <line8> "	"""create ontology={}"", ontologyDto"	task7	
public class A { <line0> @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) <line1> public void onEvent(ServerInfoRequestEvent event) { <line2> logger.debug(UNKNOWN); <line3> String quickShareFilename = quickShareBean != null ? quickShareBean.filename() : null; <line4> EventBus.getDefault().post(new ServerInfoResponseEvent(quickShareFilename)); <line5> } <line6> } <line7> 	"""got ServerInfoRequestEvent"""	task7	
public class A { <line0> @Override <line1> public void install() { <line2> DownloadResolver resolver = Entities.newDownloader(this); <line3> List<String> urls = resolver.getTargets(); <line4> String saveAs = resolver.getFilename(); <line5> OsDetails osDetails = getMachine().getMachineDetails().getOsDetails(); <line6> log.info(UNKNOWN); <line7> if (osDetails.isLinux()) { <line8> List<String> commands = installLinux(urls, saveAs); <line9> newScript(INSTALLING).body.append(commands).execute(); <line10> } <line11> } <line12> } <line13> 	"""Installing couchbase-sync-gateway version: {}"", getVersion()"	task7	
"public class A { <line0> private void initialize() throws Exception { <line1> setServerRootDir(); <line2> readAndSetServicesConfig(); <line3> AuthN.setDataSource(JDBCTools.getDataSource(JDBCTools.CSPACE_DATASOURCE_NAME)); <line4> propagateConfiguredProperties(); <line5> createOrUpdateNuxeoDatasourceConfigFiles(); <line6> createOrUpdateNuxeoRepositoryConfigFiles(); <line7> createOrUpdateNuxeoElasticsearchConfigFiles(); <line8> HashSet<String> dbsCheckedOrCreated = createNuxeoDatabases(); <line9> String[] dataSourceNames = { <line10> JDBCTools.NUXEO_DATASOURCE_NAME, JDBCTools.NUXEO_READER_DATASOURCE_NAME <line11> }; <line12> updateInitializationScript( <line13> getNuxeoDatabasesDropScriptFilename(), dbsCheckedOrCreated, dataSourceNames); <line14> if (getClientType().equals(ClientType.JAVA)) { <line15> nuxeoConnector = NuxeoConnectorEmbedded.getInstance(); <line16> mirrorToStdOut(""\nStarting Nuxeo platform...""); <line17> nuxeoConnector.initialize( <line18> getServerRootDir(), <line19> getServicesConfigReader().getConfiguration().getRepositoryClient(), <line20> ServiceMain.servletContext); <line21> mirrorToStdOut(""Nuxeo platform started successfully.\n""); <line22> } else { <line23> throw new RuntimeException( <line24> ""Unknown CollectionSpace services client type: "" + getClientType()); <line25> } <line26> initializeEventListeners(); <line27> String cspaceDatabaseName = getCspaceDatabaseName(); <line28> Hashtable<String, TenantBindingType> tenantBindings = <line29> tenantBindingConfigReader.getTenantBindings(); <line30> for (String tenantId : tenantBindings.keySet()) { <line31> TenantBindingType tenantBinding = tenantBindings.get(tenantId); <line32> String persistedMD5Hash = <line33> AuthorizationCommon.getPersistedMD5Hash(tenantId, cspaceDatabaseName); <line34> String currentMD5Hash = tenantBinding.getConfigMD5Hash(); <line35> AuthorizationCommon.setTenantConfigMD5Hash(tenantId, currentMD5Hash); <line36> tenantBinding.setConfigChangedSinceLastStart( <line37> hasConfigChanged(tenantBinding, persistedMD5Hash, currentMD5Hash)); <line38> } <line39> JPATransactionContext jpaTransactionContext = new JPATransactionContext(); <line40> try { <line41> jpaTransactionContext.beginTransaction(); <line42> DatabaseProductType databaseProductType = <line43> JDBCTools.getDatabaseProductType(JDBCTools.CSPACE_DATASOURCE_NAME, cspaceDatabaseName); <line44> AuthorizationCommon.createTenants( <line45> tenantBindingConfigReader, databaseProductType, cspaceDatabaseName); <line46> AuthorizationCommon.createDefaultWorkflowPermissions( <line47> jpaTransactionContext, <line48> tenantBindingConfigReader, <line49> databaseProductType, <line50> cspaceDatabaseName); <line51> AuthorizationCommon.createDefaultAccounts( <line52> tenantBindingConfigReader, databaseProductType, cspaceDatabaseName); <line53> AuthorizationCommon.persistTenantBindingsMD5Hash( <line54> tenantBindingConfigReader, databaseProductType, cspaceDatabaseName); <line55> jpaTransactionContext.commitTransaction(); <line56> } catch (Exception e) { <line57> logger.error( <line58> ""Default create/update of tenants, accounts, roles and permissions setup failed with"" <line59> + "" exception(s): "" <line60> + e.getLocalizedMessage(), <line61> e); <line62> throw e; <line63> } finally { <line64> jpaTransactionContext.close(); <line65> } <line66> showTenantStatus(); <line67> } <line68> } <line69> "	"""Default create/update of tenants, accounts, roles and permissions setup failed with""+ "" exception(s): ""+ e.getLocalizedMessage(),e"	task7	
"public class A { <line0> private ExecutorService initializeClientQueueInitializerThreadPool() { <line1> return CoreLoggingExecutors.newThreadPoolWithSynchronousFeed( <line2> CLIENT_QUEUE_INITIALIZATION_POOL_SIZE, <line3> 60000, <line4> MILLISECONDS, <line5> ""Client Queue Initialization Thread "", <line6> command -> { <line7> try { <line8> command.run(); <line9> } catch (CancelException e) { <line10> logger.debug(UNKNOWN); <line11> } <line12> }, <line13> getStats().getCnxPoolHelper(), <line14> getThreadMonitorObj()); <line15> } <line16> } <line17> "	"""Client Queue Initialization was canceled."", e"	task7	
"public class A { <line0> public static DottedQuad createArbitraryBitMask(final byte[] bitmask) { <line1> if (bitmask == null) { <line2> return IPV4_BITMASKS[IPV4_ADDRESS_LENGTH]; <line3> } <line4> final String hostAddress; <line5> try { <line6> hostAddress = InetAddress.getByAddress(bitmask).getHostAddress(); <line7> } catch (UnknownHostException e) { <line8> LOG.error( <line9> ""Failed to create the dottedQuad notation for the given mask {}"", <line10> Arrays.toString(bitmask), <line11> e); <line12> return null; <line13> } <line14> return new DottedQuad(hostAddress); <line15> } <line16> } <line17> "	"""Failed to create the dottedQuad notation for the given mask {}"",Arrays.toString(bitmask),e"	task7	
"public class A { <line0> private void forwardRequestWithoutAuthorizationCheck( <line1> HttpServletRequest req, HttpServletResponse res, FilterChain chain) <line2> throws IOException, ServletException { <line3> logger.debug( <line4> ""Request filter authorization check is not required for this HTTP Method on this resource."" <line5> + "" Allowing request to proceed. An additional authorization check might be performed"" <line6> + "" downstream of this filter.""); <line7> chain.doFilter(req, res); <line8> } <line9> } <line10> "	"""Request filter authorization check is not required for this HTTP Method on this resource.""+ "" Allowing request to proceed. An additional authorization check might be performed""+ "" downstream of this filter."""	task7	
"public class A { <line0> protected List<SafariResumedVisit> getResumedHistory( <line1> Connection connection, Metadata metadata, ParseContext context) throws SQLException { <line2> List<SafariResumedVisit> resumedHistory = new LinkedList<SafariResumedVisit>(); <line3> Statement st = null; <line4> try { <line5> st = connection.createStatement(); <line6> String sql = <line7> ""SELECT history_items.id, title, history_items.url, history_items.visit_count, ((latest +"" <line8> + "" 978307200)*1000) FROM history_items INNER JOIN (SELECT history_item, title,"" <line9> + "" MAX(visit_time) AS latest FROM history_visits GROUP BY history_item) ON"" <line10> + "" history_items.id = history_item ORDER BY history_items.visit_count DESC""; <line11> LOGGER.info(UNKNOWN); <line12> ResultSet rs = st.executeQuery(sql); <line13> while (rs.next()) { <line14> resumedHistory.add( <line15> new SafariResumedVisit( <line16> rs.getLong(1), rs.getString(2), rs.getString(3), rs.getLong(4), rs.getLong(5))); <line17> } <line18> } finally { <line19> if (st != null) st.close(); <line20> } <line21> return resumedHistory; <line22> } <line23> } <line24> "	"""SQL Query: "" + sql"	task7	
public class A { <line0> @Override <line1> protected byte[] serializeBytes() { <line2> LOGGER.debug(UNKNOWN); <line3> writeContentType(record); <line4> writeProtocolVersion(record); <line5> if (record.getEpoch() != null) { <line6> appendInt(record.getEpoch().getValue(), RecordByteLength.DTLS_EPOCH); <line7> appendBigInteger( <line8> record.getSequenceNumber().getValue(), RecordByteLength.DTLS_SEQUENCE_NUMBER); <line9> } <line10> writeLength(record); <line11> writeProtocolMessageBytes(record); <line12> return getAlreadySerialized(); <line13> } <line14> } <line15> 	"""Serializing Record"""	task7	
public class A { <line0> public void registerSemProviders(InjectingContainer container, SemRegistrar registrar) { <line1> try { <line2> final SemContributor contributor = instantiate(implementation, container); <line3> contributor.registerSemProviders(registrar); <line4> } catch (ClassNotFoundException e) { <line5> LOG.error(UNKNOWN); <line6> } <line7> } <line8> } <line9> 	e	task7	
"public class A { <line0> protected int getBase(final String name) { <line1> Layout layout = null; <line2> String family = getLogoFamily(); <line3> logger.debug(UNKNOWN); <line4> String block = name.split(""\\."")[0]; <line5> Map<?, Layout> memory = LOGO_MEMORY_BLOCK.get(family); <line6> if (isValid(name) && !block.isEmpty() && (memory != null)) { <line7> if (Character.isDigit(block.charAt(1))) { <line8> layout = memory.get(block.substring(0, 1)); <line9> } else if (Character.isDigit(block.charAt(2))) { <line10> layout = memory.get(block.substring(0, 2)); <line11> } else if (Character.isDigit(block.charAt(3))) { <line12> layout = memory.get(block.substring(0, 3)); <line13> } <line14> } <line15> return layout != null ? layout.address : INVALID; <line16> } <line17> } <line18> "	"""Get base address of {} LOGO! for block {} ."", family, name"	task7	
public class A { <line0> @Override <line1> public void persistRawDocumentContentFromFile( <line2> HRawDocument rawDocument, File fromFile, String extension) { <line3> String fileName = generateFileNameFor(rawDocument, extension); <line4> rawDocument.setFileId(fileName); <line5> File newFile = getFileForName(fileName); <line6> try { <line7> FileUtils.copyFile(fromFile, newFile); <line8> } catch (IOException e) { <line9> throw new RuntimeException(e); <line10> } <line11> GlobalDocumentId globalId = getGlobalId(rawDocument); <line12> log.info(UNKNOWN); <line13> virusScanner.scan(newFile, globalId.toString()); <line14> } <line15> } <line16> 	"""Persisted raw document {} to file {}"", globalId, newFile.getAbsolutePath()"	task7	
public class A { <line0> public static void flushSession() { <line1> log.trace(UNKNOWN); <line2> getContextDAO().flushSession(); <line3> } <line4> } <line5> 	"""flushing session"""	task7	
"public class A { <line0> public void setAsText(String text) throws IllegalArgumentException { <line1> ProgramWorkflowService pws = Context.getProgramWorkflowService(); <line2> if (StringUtils.hasText(text)) { <line3> try { <line4> setValue(pws.getStateByUuid(text)); <line5> } catch (Exception ex) { <line6> ProgramWorkflowState s = pws.getStateByUuid(text); <line7> setValue(s); <line8> if (s == null) { <line9> log.error(UNKNOWN); <line10> throw new IllegalArgumentException( <line11> ""Program Workflow State not found: "" + ex.getMessage()); <line12> } <line13> } <line14> } else { <line15> setValue(null); <line16> } <line17> } <line18> } <line19> "	"""Error setting text"" + text, ex"	task7	
public class A { <line0> @Override <line1> public void errorUknown(final AnalysisJob job, final Throwable throwable) { <line2> logger.debug(UNKNOWN); <line3> } <line4> } <line5> 	"""errorUknown("" + job + "")"", throwable"	task7	
"public class A { <line0> private void index() { <line1> try { <line2> Model dbpedia = ModelFactory.createDefaultModel(); <line3> dbpedia.read( <line4> this.getClass().getClassLoader().getResource(""dbpedia_2015-10.owl"").getPath(), ""RDF/XML""); <line5> StmtIterator stmts = dbpedia.listStatements(null, RDFS.label, (RDFNode) null); <line6> while (stmts.hasNext()) { <line7> final Statement stmt = stmts.next(); <line8> RDFNode label = stmt.getObject(); <line9> if (label.asLiteral().getLanguage().equals(""en"")) { <line10> addDocumentToIndex(stmt.getSubject(), ""rdfs:label"", label.asLiteral().getString()); <line11> NodeIterator comment = dbpedia.listObjectsOfProperty(stmt.getSubject(), RDFS.comment); <line12> while (comment.hasNext()) { <line13> RDFNode next = comment.next(); <line14> if (next.asLiteral().getLanguage().equals(""en"")) { <line15> addDocumentToIndex(stmt.getSubject(), ""rdfs:comment"", next.asLiteral().getString()); <line16> } <line17> } <line18> } <line19> } <line20> iwriter.commit(); <line21> iwriter.close(); <line22> } catch (IOException e) { <line23> log.error(UNKNOWN); <line24> } <line25> } <line26> } <line27> "	e.getLocalizedMessage(), e	task7	
"public class A { <line0> @Override <line1> @UnitOfWork(readOnly = true) <line2> @SuppressWarnings(""JdkObsolete"") <line3> public LookBackAnswer getLookBackAnswer( <line4> ExplanationOfBenefit explanationOfBenefit, <line5> String organizationNPI, <line6> String practitionerNPI, <line7> long withinMonth) { <line8> MDC.put(EOB_ID, explanationOfBenefit.getId()); <line9> YearMonth billingPeriod = <line10> Optional.of(explanationOfBenefit) <line11> .map(ExplanationOfBenefit::getBillablePeriod) <line12> .map(Period::getEnd) <line13> .map( <line14> date -> <line15> YearMonth.from(date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate())) <line16> .orElse(null); <line17> String eobOrganizationNPI = <line18> Optional.of(explanationOfBenefit) <line19> .map(ExplanationOfBenefit::getOrganization) <line20> .map(Reference::getIdentifier) <line21> .filter(i -> DPCIdentifierSystem.NPPES.getSystem().equals(i.getSystem())) <line22> .map(Identifier::getValue) <line23> .orElse(null); <line24> Pair<String, Set<String>> npis = extractProviderNPIs(explanationOfBenefit); <line25> Set<String> allNPIs = new HashSet<>(npis.getRight()); <line26> allNPIs.add(npis.getLeft()); <line27> LookBackAnswer lookBackAnswer = <line28> new LookBackAnswer( <line29> practitionerNPI, organizationNPI, withinMonth, operationsConfig.getLookBackDate()) <line30> .addEobBillingPeriod(billingPeriod) <line31> .addEobOrganization(eobOrganizationNPI) <line32> .addEobProviders(allNPIs); <line33> LOGGER.trace( <line34> ""billingPeriodDate={}, lookBackDate={}, monthsDifference={}, eobProvider={},"" <line35> + "" eobCareTeamProviders={}, jobProvider={}, eobOrganization={}, jobOrganization={},"" <line36> + "" withinLimit={}, eobProviderMatch={}, eobOrganizationMatch={}"", <line37> billingPeriod, <line38> operationsConfig.getLookBackDate(), <line39> lookBackAnswer.calculatedMonthDifference(), <line40> npis.getLeft(), <line41> Joiner.on("";"").join(npis.getRight()), <line42> practitionerNPI, <line43> eobOrganizationNPI, <line44> organizationNPI, <line45> lookBackAnswer.matchDateCriteria(), <line46> lookBackAnswer.practitionerMatchEob(), <line47> lookBackAnswer.orgMatchEob()); <line48> MDC.remove(EOB_ID); <line49> return lookBackAnswer; <line50> } <line51> } <line52> "	"""billingPeriodDate={}, lookBackDate={}, monthsDifference={}, eobProvider={},""+ "" eobCareTeamProviders={}, jobProvider={}, eobOrganization={}, jobOrganization={},""+ "" withinLimit={}, eobProviderMatch={}, eobOrganizationMatch={}"",billingPeriod,operationsConfig.getLookBackDate(),lookBackAnswer.calculatedMonthDifference(),npis.getLeft(),Joiner.on("";"").join(npis.getRight()),practitionerNPI,eobOrganizationNPI,organizationNPI,lookBackAnswer.matchDateCriteria(),lookBackAnswer.practitionerMatchEob(),lookBackAnswer.orgMatchEob()"	task7	
public class A { <line0> public Node parse(InputSource source) throws IOException, SAXException { <line1> try (AutoLock l = _lock.lock()) { <line2> _dtd = null; <line3> Handler handler = new Handler(); <line4> XMLReader reader = _parser.getXMLReader(); <line5> reader.setContentHandler(handler); <line6> reader.setErrorHandler(handler); <line7> reader.setEntityResolver(handler); <line8> if (LOG.isDebugEnabled()) <line9> LOG.debug(UNKNOWN); <line10> _parser.parse(source, handler); <line11> if (handler._error != null) throw handler._error; <line12> Node doc = (Node) handler._top.get(0); <line13> handler.clear(); <line14> return doc; <line15> } <line16> } <line17> } <line18> 	"""parsing: sid={},pid={}"", source.getSystemId(), source.getPublicId()"	task7	
"public class A { <line0> private void transformGefaehrdung( <line1> Group<?> group, List<CnATreeElement> elements, Gefaehrdung gefaehrdung) { <line2> BpThreat bpThreat = new BpThreat(group); <line3> bpThreat.setTitel(gefaehrdung.getId() + "" "" + gefaehrdung.getTitel()); <line4> try { <line5> String description = HtmlWriter.getHtml(gefaehrdung); <line6> bpThreat.setObjectBrowserDescription(description); <line7> } catch (GSServiceException e) { <line8> log.error(UNKNOWN); <line9> } <line10> elements.add(bpThreat); <line11> } <line12> } <line13> "	"""Error setting description for safeguard"", e"	task7	
"public class A { <line0> @Override <line1> public String retrieveRootNodeID(String ownerID) throws MCRPersistenceException { <line2> EntityManager em = MCREntityManagerProvider.getCurrentEntityManager(); <line3> TypedQuery<String> rootQuery = em.createNamedQuery(""MCRFSNODES.getRootID"", String.class); <line4> rootQuery.setParameter(""owner"", ownerID); <line5> try { <line6> return rootQuery.getSingleResult(); <line7> } catch (NoResultException e) { <line8> LOGGER.warn(UNKNOWN); <line9> return null; <line10> } <line11> } <line12> } <line13> "	"""There is no fsnode with OWNER = {}"", ownerID"	task7	
"public class A { <line0> @SuppressWarnings({""unchecked"", ""null""}) <line1> public static String getFirstMemberName(Object group) { <line2> List<String> listNames = YAMLgroupsOptimizerParser.getListOfMemberNames(group); <line3> if (listNames != null) { <line4> return listNames.get(0); <line5> } else { <line6> log.warn(UNKNOWN); <line7> return null; <line8> } <line9> } <line10> } <line11> "	"""  It was not found the information of who where the members of the group"""	task7	
public class A { <line0> private int makeGetRequestHttp2(String url) throws Exception { <line1> log.debug(UNKNOWN); <line2> HTTP2Client http2Client = new HTTP2Client(); <line3> HttpClient httpClient = new HttpClient(new HttpClientTransportOverHTTP2(http2Client)); <line4> httpClient.start(); <line5> int statusCode = httpClient.GET(url).getStatus(); <line6> httpClient.stop(); <line7> return statusCode; <line8> } <line9> } <line10> 	"""Making GET using HTTP over HTTP/2 Cleartext "" + url"	task7	
"public class A { <line0> private Set<String> getPasswordHashAlgorithms() { <line1> Set<String> hashAlgos = new HashSet<>(); <line2> boolean enmasseRealmsFound = false; <line3> KeycloakSession keycloakSession = keycloakSessionFactory.create(); <line4> KeycloakTransactionManager transactionManager = keycloakSession.getTransactionManager(); <line5> transactionManager.begin(); <line6> try { <line7> List<RealmModel> realms = keycloakSession.realms().getRealms(); <line8> for (RealmModel realm : realms) { <line9> if (realm.getAttribute(""enmasse-realm"", Boolean.FALSE)) { <line10> enmasseRealmsFound = true; <line11> hashAlgos.add(realm.getPasswordPolicy().getHashAlgorithm()); <line12> } <line13> } <line14> } finally { <line15> transactionManager.commit(); <line16> keycloakSession.close(); <line17> } <line18> if (!enmasseRealmsFound) { <line19> LOG.warn( <line20> ""No realms with attribute \""enmasse-realm\"" found, only universally accepted SASL"" <line21> + "" mechanisms will be offered""); <line22> } <line23> return hashAlgos; <line24> } <line25> } <line26> "	"""No realms with attribute \""enmasse-realm\"" found, only universally accepted SASL""+ "" mechanisms will be offered"""	task7	
public class A { <line0> @Override <line1> public void deserialize(PacketBuffer buffer, int protocolID) { <line2> this.requestId = buffer.readSignedVarInt(); <line3> if (this.requestId != 0) { <line4> int length = buffer.readUnsignedVarInt(); <line5> this.changeSlot = new ChangeSlot[length]; <line6> for (int i = 0; i < length; i++) { <line7> this.changeSlot[i] = new ChangeSlot(); <line8> this.changeSlot[i].deserialize(buffer); <line9> } <line10> } <line11> this.type = buffer.readUnsignedVarInt(); <line12> this.hasItemstackIDs = buffer.readBoolean(); <line13> int actionCount = buffer.readUnsignedVarInt(); <line14> this.actions = new NetworkTransaction[actionCount]; <line15> for (int i = 0; i < actionCount; i++) { <line16> NetworkTransaction networkTransaction = new NetworkTransaction(); <line17> networkTransaction.deserialize(buffer, this.hasItemstackIDs); <line18> this.actions[i] = networkTransaction; <line19> } <line20> switch (this.type) { <line21> case TYPE_NORMAL: <line22> case TYPE_MISMATCH: <line23> break; <line24> case TYPE_USE_ITEM: <line25> this.actionType = buffer.readUnsignedVarInt(); <line26> this.blockPosition = readBlockPosition(buffer); <line27> this.face = readBlockFace(buffer); <line28> this.hotbarSlot = buffer.readSignedVarInt(); <line29> this.itemInHand = readItemStack(buffer); <line30> this.playerPosition = <line31> new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line32> this.clickPosition = <line33> new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line34> this.blockRuntimeID = buffer.readUnsignedVarInt(); <line35> break; <line36> case TYPE_USE_ITEM_ON_ENTITY: <line37> this.entityId = buffer.readUnsignedVarLong(); <line38> this.actionType = buffer.readUnsignedVarInt(); <line39> this.hotbarSlot = buffer.readSignedVarInt(); <line40> this.itemInHand = readItemStack(buffer); <line41> this.vector1 = new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line42> this.vector2 = new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line43> break; <line44> case TYPE_RELEASE_ITEM: <line45> this.actionType = buffer.readUnsignedVarInt(); <line46> this.hotbarSlot = buffer.readSignedVarInt(); <line47> this.itemInHand = readItemStack(buffer); <line48> this.playerPosition = <line49> new Vector(buffer.readLFloat(), buffer.readLFloat(), buffer.readLFloat()); <line50> break; <line51> default: <line52> LOGGER.warn(UNKNOWN); <line53> } <line54> } <line55> } <line56> 	"""Unknown transaction type: {}"", this.type"	task7	
"public class A { <line0> public JasperReportResultDto getGenericReportWardVisitPdf( <line1> String wardID, Date date, String jasperFileName) throws OHServiceException { <line2> try { <line3> HashMap<String, Object> parameters = getHospitalParameters(); <line4> addBundleParameter(jasperFileName, parameters); <line5> parameters.put(""wardID"", String.valueOf(wardID)); <line6> parameters.put(""date"", date); <line7> String pdfFilename = <line8> ""rpt/PDF/"" <line9> + jasperFileName <line10> + ""_"" <line11> + String.valueOf(wardID) <line12> + ""_"" <line13> + TimeTools.formatDateTime(date, ""yyyyMMdd"") <line14> + "".pdf""; <line15> JasperReportResultDto result = <line16> generateJasperReport(compileJasperFilename(jasperFileName), pdfFilename, parameters); <line17> JasperExportManager.exportReportToPdfFile(result.getJasperPrint(), pdfFilename); <line18> return result; <line19> } catch (OHServiceException e) { <line20> throw e; <line21> } catch (Exception e) { <line22> LOGGER.error(UNKNOWN); <line23> throw new OHServiceException( <line24> e, <line25> new OHExceptionMessage( <line26> MessageBundle.getMessage(""angal.common.error.title""), <line27> MessageBundle.getMessage(""angal.stat.reporterror""), <line28> OHSeverityLevel.ERROR)); <line29> } <line30> } <line31> } <line32> "	""""", e"	task7	
public class A { <line0> public static void handle(Throwable t) throws GwtKuraException { <line1> t.printStackTrace(); <line2> logger.warn(UNKNOWN); <line3> throw GwtKuraException.internalError(t, t.getLocalizedMessage()); <line4> } <line5> } <line6> 	"""RPC service non-application error"", t"	task7	
public class A { <line0> @Override <line1> public ServiceAdapter makeServiceAdapter(String adapterName) throws Exception { <line2> try { <line3> if (supportedAdapters.containsKey(adapterName) || isHiddenServiceAdapter(adapterName)) { <line4> ServiceAdapter adapter = <line5> (ServiceAdapter) this.loadedAdapters.get(adapterName).newInstance(); <line6> adapter.initFromMetaData(this.getServiceMetadata(adapterName, adapter.getIdentifier())); <line7> return adapter; <line8> } else { <line9> return null; <line10> } <line11> } catch (NullPointerException ex) { <line12> logger.error(UNKNOWN); <line13> return null; <line14> } <line15> } <line16> } <line17> 	"""Cannot instantiate adapter with name: "" + adapterName, ex"	task7	
public class A { <line0> public void createSubscription( <line1> String subscriptionProject, String subscription, String topicProject, String topic) <line2> throws IOException { <line3> ProjectSubscriptionName subscriptionName = <line4> ProjectSubscriptionName.newBuilder() <line5> .setProject(subscriptionProject) <line6> .setSubscription(subscription) <line7> .build(); <line8> deleteSubscription(subscriptionName); <line9> TopicName topicName = TopicName.of(topicProject, topic); <line10> PushConfig pushConfig = PushConfig.getDefaultInstance(); <line11> LOG.info(UNKNOWN); <line12> getSubscriptionAdminClient() <line13> .createSubscription(subscriptionName, topicName, pushConfig, 1) <line14> .isInitialized(); <line15> } <line16> } <line17> 	"""CreateSubscription {}"", subscriptionName"	task7	
public class A { <line0> @Override <line1> public XMLNode writeAnnotation(SBase contextObject, XMLNode xmlNode) { <line2> logger.debug(UNKNOWN); <line3> if (contextObject.isSetAnnotation() <line4> && (contextObject.isSetHistory() || contextObject.getCVTermCount() > 0)) { <line5> return writeSBMLRDF(contextObject, xmlNode); <line6> } <line7> return xmlNode; <line8> } <line9> } <line10> 	"""writeAnnotation called """	task7	
"public class A { <line0> public static void main(String[] args) { <line1> ConfigurableApplicationContext context = <line2> new ClassPathXmlApplicationContext(""/META-INF/spring/integration/http-outbound-config.xml""); <line3> RequestGateway requestGateway = context.getBean(""requestGateway"", RequestGateway.class); <line4> String reply = requestGateway.echo(""Hello""); <line5> logger.info(UNKNOWN); <line6> context.close(); <line7> } <line8> } <line9> "	"""\n\n++++++++++++ Replied with: "" + reply + "" ++++++++++++\n"""	task7	
"public class A { <line0> private void handleSourceStateChangedEvent(SharedDataIteratorSource<T> sender) { <line1> SQLQuery<T> query = _sourcesToQuery.remove(sender); <line2> if (logger.isTraceEnabled()) <line3> logger.trace( <line4> ""shared iterator source is closed or expired, detaching from local table ["" <line5> + query.toString() <line6> + ""]""); <line7> if (query != null) _queryToSources.remove(query); <line8> } <line9> } <line10> "	"""shared iterator source is closed or expired, detaching from local table [""+ query.toString()+ ""]"""	task7	
"public class A { <line0> @Override <line1> public void addHighPriorityJob(SensorJob sensorJob) { <line2> if (sensorJob == null) { <line3> return; <line4> } <line5> addSensorJobToCircuitScheduler(sensorJob); <line6> logger.debug( <line7> ""Add SensorJob from device with dSID {} and high-priority to SensorJobExecutor"", <line8> sensorJob.getDSID()); <line9> } <line10> } <line11> "	"""Add SensorJob from device with dSID {} and high-priority to SensorJobExecutor"",sensorJob.getDSID()"	task7	
"public class A { <line0> @Override <line1> public Bytes testMessageContent(int current) { <line2> try (ByteArrayOutputStream out = new ByteArrayOutputStream()) { <line3> ZipOutputStream zip = new ZipOutputStream(out); <line4> ZipEntry entry = new ZipEntry(""test""); <line5> zip.putNextEntry(entry); <line6> zip.write(""hello test"".getBytes()); <line7> zip.closeEntry(); <line8> zip.finish(); <line9> return Bytes.wrap(out.toByteArray()); <line10> } catch (IOException e) { <line11> LOG.error(UNKNOWN); <line12> fail(""I/O error writing zip entry""); <line13> } <line14> return null; <line15> } <line16> } <line17> "	"""I/O error writing zip entry: {}"", e.getMessage(), e"	task7	
public class A { <line0> @Deprecated <line1> public void logMessageStatusUpdateRecord( <line2> Message message, <line3> Level level, <line4> Class classInfo, <line5> String additionalInfo, <line6> HelixDataAccessor accessor) { <line7> try { <line8> ZNRecord record = createMessageStatusUpdateRecord(message, level, classInfo, additionalInfo); <line9> publishStatusUpdateRecord( <line10> record, <line11> message, <line12> level, <line13> accessor, <line14> message.getTgtName().equalsIgnoreCase(InstanceType.CONTROLLER.name())); <line15> } catch (Exception e) { <line16> logger.error(UNKNOWN); <line17> } <line18> } <line19> } <line20> 	"""Exception while logging status update"", e"	task7	
public class A { <line0> private String readExtendedMetadata(UserDefinedFileAttributeView view, String name) <line1> throws IOException { <line2> try { <line3> ByteBuffer bb = ByteBuffer.allocate(view.size(name)); <line4> view.read(name, bb); <line5> bb.flip(); <line6> CharBuffer buffer = Charset.defaultCharset().decode(bb); <line7> return buffer.toString(); <line8> } catch (IllegalArgumentException | FileSystemException e) { <line9> LOGGER.error(UNKNOWN); <line10> throw new IOException(ERROR_MSG_NOT_SUPPORTED, e); <line11> } <line12> } <line13> } <line14> 	ERROR_MSG_NOT_SUPPORTED, e	task7	
"public class A { <line0> @Override <line1> public byte[] get(List<Range> rangeList) { <line2> log.info(UNKNOWN); <line3> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line4> try { <line5> file.download(out, listener, rangeList); <line6> } catch (HttpException ex) { <line7> } catch (CancelledException ex) { <line8> throw new RuntimeException( <line9> ""Cancelled, which is odd because no progress listener was provided""); <line10> } <line11> byte[] bytes = out.toByteArray(); <line12> int expectedLength = calcExpectedLength(rangeList); <line13> numBytes += bytes.length; <line14> return bytes; <line15> } <line16> } <line17> "	"""get: rangelist: "" + rangeList.size()"	task7	
public class A { <line0> public void send(final String cmd, final String value) { <line1> try { <line2> sendCommand(new EiscpMessage.MessageBuilder().command(cmd).value(value).build()); <line3> } catch (Exception e) { <line4> logger.warn(UNKNOWN); <line5> } <line6> } <line7> } <line8> 	"""Could not send command to device on {}:{}: "", ip, port, e"	task7	
public class A { <line0> protected final void log(String text, String arg1, String arg2) { <line1> logger.info(UNKNOWN); <line2> } <line3> } <line4> 	text, arg1, arg2	task7	
"public class A { <line0> private int findChromosomeID(BPTreeNode thisNode, String chromKey) { <line1> int chromID = -1; <line2> if (thisNode.isLeaf()) { <line3> int nLeaves = thisNode.getItemCount(); <line4> for (int index = 0; index < nLeaves; ++index) { <line5> BPTreeLeafNodeItem leaf = (BPTreeLeafNodeItem) thisNode.getItem(index); <line6> if (leaf == null) { <line7> log.error(UNKNOWN); <line8> throw new RuntimeException(""Error reading B+ tree leaf nodes, corruption suspected""); <line9> } <line10> if (leaf.chromKeysMatch(chromKey)) { <line11> chromID = leaf.getChromID(); <line12> break; <line13> } <line14> } <line15> } else { <line16> int nNodes = thisNode.getItemCount(); <line17> for (int index = 0; index < nNodes; ++index) { <line18> BPTreeChildNodeItem childItem = (BPTreeChildNodeItem) thisNode.getItem(index); <line19> BPTreeNode childNode = childItem.getChildNode(); <line20> String lowestKey = childNode.getLowestChromKey(); <line21> String highestKey = childNode.getHighestChromKey(); <line22> if (chromKey.compareTo(lowestKey) >= 0 && chromKey.compareTo(highestKey) <= 0) { <line23> chromID = findChromosomeID(childNode, chromKey); <line24> if (chromID >= 0) break; <line25> } <line26> } <line27> } <line28> return chromID; <line29> } <line30> } <line31> "	"""Error finding B+ tree leaf nodes, corruption suspected"""	task7	
"public class A { <line0> protected void invalidateLocally(Integer bucketId, EntryEventImpl event) <line1> throws EntryNotFoundException, PrimaryBucketException, ForceReattemptException { <line2> if (logger.isDebugEnabled()) { <line3> logger.debug( <line4> ""invalidateLocally: bucketId={}{}{} for key={}"", <line5> this.partitionedRegion.getPRId(), <line6> PartitionedRegion.BUCKET_ID_SEPARATOR, <line7> bucketId, <line8> event.getKey()); <line9> } <line10> final BucketRegion bucketRegion = getInitializedBucketForId(event.getKey(), bucketId); <line11> try { <line12> event.setRegion(bucketRegion); <line13> event.setOldValueFromRegion(); <line14> bucketRegion.basicInvalidate(event); <line15> bucketRegion.checkReadiness(); <line16> } catch (RegionDestroyedException rde) { <line17> checkRegionDestroyedOnBucket(bucketRegion, event.isOriginRemote(), rde); <line18> } <line19> } <line20> } <line21> "	"""invalidateLocally: bucketId={}{}{} for key={}"",this.partitionedRegion.getPRId(),PartitionedRegion.BUCKET_ID_SEPARATOR,bucketId,event.getKey()"	task7	
"public class A { <line0> public void deploy(final BeanContext beanContext) throws OpenEJBException { <line1> final Data data = new Data(beanContext); <line2> beanContext.setContainerData(data); <line3> beanContext.set(EJBContext.class, this.sessionContext); <line4> if (StatsInterceptor.isStatsActivated()) { <line5> final StatsInterceptor stats = new StatsInterceptor(beanContext.getBeanClass()); <line6> beanContext.addFirstSystemInterceptor(stats); <line7> final ObjectNameBuilder jmxName = new ObjectNameBuilder(""openejb.management""); <line8> jmxName.set(""J2EEServer"", ""openejb""); <line9> jmxName.set(""J2EEApplication"", null); <line10> jmxName.set(""EJBModule"", beanContext.getModuleID()); <line11> jmxName.set(""SingletonSessionBean"", beanContext.getEjbName()); <line12> jmxName.set(""name"", beanContext.getEjbName()); <line13> jmxName.set(""j2eeType"", ""Invocations""); <line14> final MBeanServer server = LocalMBeanServer.get(); <line15> try { <line16> final ObjectName objectName = jmxName.build(); <line17> if (server.isRegistered(objectName)) { <line18> server.unregisterMBean(objectName); <line19> } <line20> server.registerMBean(new ManagedMBean(stats), objectName); <line21> data.add(objectName); <line22> } catch (final Exception e) { <line23> logger.error(UNKNOWN); <line24> } <line25> } <line26> try { <line27> final Context context = beanContext.getJndiEnc(); <line28> context.bind(""comp/EJBContext"", sessionContext); <line29> context.bind(""comp/WebServiceContext"", webServiceContext); <line30> context.bind(""comp/TimerService"", new TimerServiceWrapper()); <line31> } catch (final NamingException e) { <line32> throw new OpenEJBException(""Failed to bind EJBContext/WebServiceContext/TimerService"", e); <line33> } <line34> } <line35> } <line36> "	"""Unable to register MBean "", e"	task7	
"public class A { <line0> public Object createComplexChildObject( <line1> Object parentObject, SegmentContext segmentContext, Class<?> clazz) throws AtlasException { <line2> if (LOG.isDebugEnabled()) { <line3> LOG.debug( <line4> ""Creating object for segment:'{} \n\tparentObject: {} \n\tclass: {}"", <line5> segmentContext, <line6> parentObject, <line7> clazz.getName()); <line8> } <line9> try { <line10> Method setterMethod = resolveSetterMethod(parentObject, segmentContext, null); <line11> Object targetObject = instantiateObject(clazz); <line12> setterMethod.setAccessible(true); <line13> setterMethod.invoke(parentObject, targetObject); <line14> return targetObject; <line15> } catch (Exception e) { <line16> try { <line17> java.lang.reflect.Field field = <line18> resolveField(parentObject.getClass(), segmentContext.getName()); <line19> field.setAccessible(true); <line20> Object targetObject = instantiateObject(clazz); <line21> field.set(parentObject, targetObject); <line22> return targetObject; <line23> } catch (Exception e2) { <line24> String parentClassName = parentObject == null ? null : parentObject.getClass().getName(); <line25> throw new AtlasException( <line26> ""Unable to create value for segment: "" <line27> + segmentContext.getExpression() <line28> + "" parentObject: "" <line29> + parentClassName, <line30> e2); <line31> } <line32> } <line33> } <line34> } <line35> "	"""Creating object for segment:'{} \n\tparentObject: {} \n\tclass: {}"",segmentContext,parentObject,clazz.getName()"	task7	
"public class A { <line0> private Role createRoleFromRequestBody(ServletInputStream is) <line1> throws IOException, IllegalArgumentException { <line2> try { <line3> String strRole = FileUtils.asString(is); <line4> JSONObject json = new JSONObject(strRole); <line5> String commonName = RequestUtil.getFieldValue(json, RoleSchema.COMMON_NAME_KEY); <line6> if (commonName == null) { <line7> throw new IllegalArgumentException(RoleSchema.COMMON_NAME_KEY + "" is required""); <line8> } <line9> commonName = commonName.toUpperCase(); <line10> Pattern p = Pattern.compile(""[A-Z0-9_-]+""); <line11> if (!p.matcher(commonName).matches()) <line12> throw new IllegalArgumentException( <line13> RoleSchema.COMMON_NAME_KEY <line14> + "" should only contain uppercased letters, digits, dashes and underscores""); <line15> String description = RequestUtil.getFieldValue(json, RoleSchema.DESCRIPTION_KEY); <line16> Boolean isFavorite = RequestUtil.getBooleanFieldValue(json, RoleSchema.FAVORITE_JSON_KEY); <line17> Role role = RoleFactory.create(commonName, description, isFavorite); <line18> return role; <line19> } catch (IllegalArgumentException e) { <line20> throw e; <line21> } catch (Exception e) { <line22> LOG.error(UNKNOWN); <line23> throw new IOException(e); <line24> } <line25> } <line26> } <line27> "	e.getMessage()	task7	
"public class A { <line0> private ChannelControlBlock createChannel(int idx) throws NetException { <line1> if (idx > MuxDemuxCommand.MAX_CHANNEL_ID) { <line2> throw new NetException(""Channel Id > "" + MuxDemuxCommand.MAX_CHANNEL_ID + "" being opened""); <line3> } <line4> if (idx >= ccbArray.length) { <line5> expand(idx); <line6> } <line7> if (ccbArray[idx] != null) { <line8> assert ccbArray[idx].completelyClosed() : ccbArray[idx].toString(); <line9> if (ccbArray[idx].completelyClosed()) { <line10> if (LOGGER.isTraceEnabled()) { <line11> LOGGER.trace(UNKNOWN); <line12> } <line13> freeChannel(ccbArray[idx]); <line14> } <line15> } <line16> assert idx < ccbArray.length; <line17> assert !allocationBitmap.get(idx); <line18> IChannelInterfaceFactory channelInterfaceFactory = mConn.getChannelInterfaceFactory(); <line19> ChannelControlBlock channel = new ChannelControlBlock(this, idx, channelInterfaceFactory); <line20> ccbArray[idx] = channel; <line21> allocationBitmap.set(idx); <line22> ++openChannelCount; <line23> return channel; <line24> } <line25> } <line26> "	"""Cleaning free channel: "" + ccbArray[idx]"	task7	
"public class A { <line0> @Override <line1> public Optional<Account> updateAccount(Account account) throws IOException { <line2> LOG.debug(UNKNOWN); <line3> String url = buildCanvasUrl(""accounts/"" + account.getId(), Collections.emptyMap()); <line4> Response response = <line5> canvasMessenger.sendJsonPutToCanvas(oauthToken, url, account.toJsonObject(serializeNulls)); <line6> return responseParser.parseToObject(Account.class, response); <line7> } <line8> } <line9> "	"""updating account"""	task7	
public class A { <line0> @Override <line1> public CPInstanceOptionValueRel findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchCPInstanceOptionValueRelException { <line3> CPInstanceOptionValueRel cpInstanceOptionValueRel = fetchByPrimaryKey(primaryKey); <line4> if (cpInstanceOptionValueRel == null) { <line5> if (log.isDebugEnabled()) { <line6> log.debug(UNKNOWN); <line7> } <line8> throw new NoSuchCPInstanceOptionValueRelException( <line9> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return cpInstanceOptionValueRel; <line12> } <line13> } <line14> 	_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey	task7	
public class A { <line0> private int cacheMessages(FacesContext context) { <line1> int cachedCount = 0; <line2> Iterator<String> clientIdsWithMessages = context.getClientIdsWithMessages(); <line3> while (clientIdsWithMessages.hasNext()) { <line4> String clientId = clientIdsWithMessages.next(); <line5> Iterator<FacesMessage> iterator = context.getMessages(clientId); <line6> Collection<FacesMessage> cachedMessages = getMessageCache(context).get(clientId); <line7> if (cachedMessages == null) { <line8> cachedMessages = new ArrayList<FacesMessage>(); <line9> getMessageCache(context).put(clientId, cachedMessages); <line10> } <line11> while (iterator.hasNext()) { <line12> FacesMessage facesMessage = iterator.next(); <line13> if (cachedMessages.add(facesMessage)) { <line14> cachedCount++; <line15> } <line16> } <line17> } <line18> LOGGER.trace(UNKNOWN); <line19> return cachedCount; <line20> } <line21> } <line22> 	"""Saved "" + cachedCount + "" messages in cache"""	task7	
"public class A { <line0> @Test <line1> public void testAdHocProcess() throws Exception { <line2> kruntime = createKogitoProcessRuntime(""BPMN2-AdHocProcess.bpmn2""); <line3> KogitoProcessInstance processInstance = kruntime.startProcess(""AdHocProcess""); <line4> assertEquals(KogitoProcessInstance.STATE_ACTIVE, processInstance.getState()); <line5> kruntime <line6> .getKogitoWorkItemManager() <line7> .registerWorkItemHandler(""Human Task"", new DoNothingWorkItemHandler()); <line8> logger.debug(UNKNOWN); <line9> kruntime.signalEvent(""Task1"", null, processInstance.getStringId()); <line10> assertProcessInstanceActive(processInstance); <line11> kruntime.signalEvent(""User1"", null, processInstance.getStringId()); <line12> assertProcessInstanceActive(processInstance); <line13> kruntime.getKieSession().insert(new Person()); <line14> kruntime.signalEvent(""Task3"", null, processInstance.getStringId()); <line15> assertProcessInstanceFinished(processInstance, kruntime); <line16> } <line17> } <line18> "	"""Triggering node"""	task7	
"public class A { <line0> public String getMonthOfBirth() { <line1> try { <line2> Date d = formatter.parse(getDob()); <line3> calendar.setTime(d); <line4> String value = String.valueOf(calendar.get(Calendar.MONTH) + 1); <line5> if (value.length() == 1) { <line6> value = ""0"" + value; <line7> } <line8> return value; <line9> } catch (Exception e) { <line10> log.error(UNKNOWN); <line11> } <line12> return null; <line13> } <line14> } <line15> "	"""Error"", e"	task7	
"public class A { <line0> public StringApiResponse deleteIdeaInstance(Properties properties) throws Throwable { <line1> StringApiResponse response = new StringApiResponse(); <line2> try { <line3> String code = properties.getProperty(""code""); <line4> if (StringUtils.isNotBlank(code)) { <line5> code = URLDecoder.decode(code, ""UTF-8""); <line6> } <line7> IdeaInstance clone = this.getIdeaInstanceManager().getIdeaInstance(code); <line8> if (null == clone) { <line9> throw new ApiException( <line10> IApiErrorCodes.API_VALIDATION_ERROR, <line11> ""No ideaInstance found with id "" + code, <line12> Response.Status.CONFLICT); <line13> } <line14> IPage page = this.getPageWithInstance(code); <line15> if (null != page) { <line16> throw new ApiException( <line17> IApiErrorCodes.API_VALIDATION_ERROR, <line18> ""Cannod dete the intance with code '"" <line19> + code <line20> + ""'. It's published in page "" <line21> + page.getCode(), <line22> Response.Status.CONFLICT); <line23> } <line24> this.getIdeaInstanceManager().deleteIdeaInstance(code); <line25> response.setResult(IResponseBuilder.SUCCESS, null); <line26> } catch (ApiException ae) { <line27> response.addErrors(ae.getErrors()); <line28> response.setResult(IResponseBuilder.FAILURE, null); <line29> } catch (Throwable t) { <line30> logger.error(UNKNOWN); <line31> throw t; <line32> } <line33> return response; <line34> } <line35> } <line36> "	"""Error deleting an ideaInstance"", t"	task7	
"public class A { <line0> private void fetchTrustStore() { <line1> try { <line2> truststores = setColorCodingStyle(service.fetchTrustStores(), trustStoreColorCodeList); <line3> } catch (CertificateManagerException e) { <line4> LOG.error(UNKNOWN); <line5> HelperUtil.addMessageError(TRUST_STORE_MSG, ""Unable to fetch certificate details""); <line6> } <line7> } <line8> } <line9> "	"""Unable to get certificate details {}"", e.getLocalizedMessage(), e"	task7	
"public class A { <line0> @PostMapping( <line1> value = RestEndpoints.DATASETS, <line2> consumes = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE}) <line3> @ResponseStatus(HttpStatus.CREATED) <line4> @ResponseBody <line5> public Dataset createDataset( <line6> @RequestHeader(""Authorization"") String authorization, @RequestBody Dataset dataset) <line7> throws GenericMetisException { <line8> MetisUser metisUser = authenticationClient.getUserByAccessTokenInHeader(authorization); <line9> Dataset createdDataset = datasetService.createDataset(metisUser, dataset); <line10> LOGGER.info( <line11> ""Dataset with datasetId: {}, datasetName: {} and organizationId {} created"", <line12> createdDataset.getDatasetId(), <line13> createdDataset.getDatasetName(), <line14> createdDataset.getOrganizationId()); <line15> return createdDataset; <line16> } <line17> } <line18> "	"""Dataset with datasetId: {}, datasetName: {} and organizationId {} created"",createdDataset.getDatasetId(),createdDataset.getDatasetName(),createdDataset.getOrganizationId()"	task7	
public class A { <line0> @Override <line1> public Boolean call() throws Exception { <line2> try { <line3> status[0] = db.command(command); <line4> return true; <line5> } catch (Exception e) { <line6> LOG.warn(UNKNOWN); <line7> return false; <line8> } <line9> } <line10> } <line11> 	"""Command "" + command + "" on "" + address.getHost() + "" failed"", e"	task7	
"public class A { <line0> private boolean splitAndRelease(Segment segmentToSplit) { <line1> transactionManager.executeInTransaction( <line2> () -> { <line3> TrackingToken tokenToSplit = tokenStore.fetchToken(name, segmentToSplit.getSegmentId()); <line4> TrackerStatus[] splitStatuses = TrackerStatus.split(segmentToSplit, tokenToSplit); <line5> tokenStore.initializeSegment( <line6> splitStatuses[1].getTrackingToken(), <line7> name, <line8> splitStatuses[1].getSegment().getSegmentId()); <line9> tokenStore.releaseClaim(name, splitStatuses[0].getSegment().getSegmentId()); <line10> logger.info( <line11> ""Processor [{}] successfully split {} into {} and {}."", <line12> name, <line13> segmentToSplit, <line14> splitStatuses[0].getSegment(), <line15> splitStatuses[1].getSegment()); <line16> }); <line17> return true; <line18> } <line19> } <line20> "	"""Processor [{}] successfully split {} into {} and {}."",name,segmentToSplit,splitStatuses[0].getSegment(),splitStatuses[1].getSegment()"	task7	
"public class A { <line0> @Override <line1> public void update(Map<String, String> metadata, boolean forceUpdate) <line2> throws StorageContainerException { <line3> long containerId = containerData.getContainerID(); <line4> if (!containerData.isValid()) { <line5> LOG.debug(UNKNOWN); <line6> throw new StorageContainerException( <line7> ""Invalid container data. "" + ""ContainerID: "" + containerId, INVALID_CONTAINER_STATE); <line8> } <line9> if (!forceUpdate && !containerData.isOpen()) { <line10> throw new StorageContainerException( <line11> ""Updating a closed container without force option is not allowed. "" <line12> + ""ContainerID: "" <line13> + containerId, <line14> UNSUPPORTED_REQUEST); <line15> } <line16> Map<String, String> oldMetadata = containerData.getMetadata(); <line17> try { <line18> writeLock(); <line19> for (Map.Entry<String, String> entry : metadata.entrySet()) { <line20> containerData.addMetadata(entry.getKey(), entry.getValue()); <line21> } <line22> File containerFile = getContainerFile(); <line23> updateContainerFile(containerFile); <line24> } catch (StorageContainerException ex) { <line25> containerData.setMetadata(oldMetadata); <line26> throw ex; <line27> } finally { <line28> writeUnlock(); <line29> } <line30> } <line31> } <line32> "	"""Invalid container data. ContainerID: {}"", containerId"	task7	
"public class A { <line0> @Override <line1> public boolean doMonitor(ServiceEmitter emitter) { <line2> try { <line3> ProcCpu procCpu = sigar.getProcCpu(currentProcessId); <line4> final ServiceMetricEvent.Builder builder = builder(); <line5> MonitorUtils.addDimensionsToBuilder(builder, dimensions); <line6> Map<String, Long> procDiff = <line7> diff.to( <line8> ""proc/cpu"", <line9> ImmutableMap.of( <line10> ""jvm/cpu/total"", <line11> procCpu.getTotal(), <line12> ""jvm/cpu/sys"", <line13> procCpu.getSys(), <line14> ""jvm/cpu/user"", <line15> procCpu.getUser())); <line16> if (procDiff != null) { <line17> for (Map.Entry<String, Long> entry : procDiff.entrySet()) { <line18> emitter.emit(builder.build(entry.getKey(), entry.getValue())); <line19> } <line20> } <line21> emitter.emit(builder.build(""jvm/cpu/percent"", procCpu.getPercent())); <line22> } catch (SigarException e) { <line23> log.error(UNKNOWN); <line24> } <line25> return true; <line26> } <line27> } <line28> "	"e, ""Failed to get ProcCpu"""	task7	
"public class A { <line0> private String getWindowsPath(String path) { <line1> String newStr = """"; <line2> char[] strArr = path.toCharArray(); <line3> for (int i = 0; i < strArr.length; i++) { <line4> if (strArr[i] == '/') { <line5> newStr += ""\\""; <line6> } else { <line7> newStr += strArr[i]; <line8> } <line9> } <line10> if (debug) { <line11> log.debug(UNKNOWN); <line12> } <line13> return newStr; <line14> } <line15> } <line16> "	"""escaped str is ["" + newStr + ""]"""	task7	
public class A { <line0> public static long getDefaultPlid(long groupId, long scopeGroupId, String portletId) <line1> throws RemoteException { <line2> try { <line3> long returnValue = LayoutServiceUtil.getDefaultPlid(groupId, scopeGroupId, portletId); <line4> return returnValue; <line5> } catch (Exception exception) { <line6> log.error(UNKNOWN); <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	exception, exception	task7	
"public class A { <line0> private CalculatedDesiredPoolSize calculateDesiredPoolSize(long currentPoolSize) { <line1> long now = System.currentTimeMillis(); <line2> WindowSummary downsizeSummary = <line3> recentDesiredResizes.summarizeWindow(getResizeDownStabilizationDelay()); <line4> WindowSummary upsizeSummary = <line5> recentDesiredResizes.summarizeWindow(getResizeUpStabilizationDelay()); <line6> long maxDesiredPoolSize = upsizeSummary.min; <line7> boolean stableForGrowing = upsizeSummary.stableForGrowth; <line8> long minDesiredPoolSize = downsizeSummary.max; <line9> boolean stableForShrinking = downsizeSummary.stableForShrinking; <line10> long desiredPoolSize; <line11> boolean stable; <line12> if (currentPoolSize < maxDesiredPoolSize) { <line13> desiredPoolSize = maxDesiredPoolSize; <line14> stable = stableForGrowing; <line15> } else if (currentPoolSize > minDesiredPoolSize) { <line16> desiredPoolSize = minDesiredPoolSize; <line17> stable = stableForShrinking; <line18> } else { <line19> desiredPoolSize = currentPoolSize; <line20> stable = stableForGrowing && stableForShrinking; <line21> } <line22> if (LOG.isTraceEnabled()) <line23> LOG.trace( <line24> ""{} calculated desired pool size: from {} to {}; minDesired {}, maxDesired {}; "" <line25> + ""stable {}; now {}; downsizeHistory {}; upsizeHistory {}"", <line26> new Object[] { <line27> this, <line28> currentPoolSize, <line29> desiredPoolSize, <line30> minDesiredPoolSize, <line31> maxDesiredPoolSize, <line32> stable, <line33> now, <line34> downsizeSummary, <line35> upsizeSummary <line36> }); <line37> return new CalculatedDesiredPoolSize(desiredPoolSize, stable); <line38> } <line39> } <line40> "	"""{} calculated desired pool size: from {} to {}; minDesired {}, maxDesired {}; ""+ ""stable {}; now {}; downsizeHistory {}; upsizeHistory {}"",new Object[] {this,currentPoolSize,desiredPoolSize,minDesiredPoolSize,maxDesiredPoolSize,stable,now,downsizeSummary,upsizeSummary}"	task7	
public class A { <line0> private void createAndInitScheduler() throws SchedulerException { <line1> LOG.info(UNKNOWN); <line2> scheduler = createScheduler(); <line3> SchedulerContext quartzContext = storeCamelContextInQuartzContext(); <line4> AtomicInteger number = <line5> (AtomicInteger) quartzContext.get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT); <line6> if (number == null) { <line7> number = new AtomicInteger(); <line8> quartzContext.put(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT, number); <line9> } <line10> } <line11> } <line12> 	"""Create and initializing scheduler."""	task7	
"public class A { <line0> private void createTables() throws Exception { <line1> final Statement statement = connection.createStatement(); <line2> try { <line3> logger.info(UNKNOWN); <line4> final BufferedReader reader = <line5> new BufferedReader( <line6> new InputStreamReader(getClass().getResourceAsStream(""/config/scanlog.dbd""))); <line7> StringBuilder cmd = new StringBuilder(); <line8> String line = reader.readLine(); <line9> while (line != null) { <line10> line = line.trim(); <line11> if (!line.startsWith(""--"")) { <line12> if (line.endsWith("";"")) { <line13> cmd.append(line.substring(0, line.length() - 1)); <line14> if (cmd.length() > 0) { <line15> final String sql = cmd.toString(); <line16> try { <line17> statement.execute(sql); <line18> } catch (SQLException ex) { <line19> if (!ex.getSQLState().equals(""42Y55"")) <line20> logger.log(Level.INFO, ""SQL failed: "" + sql, ex); <line21> } <line22> } <line23> cmd = new StringBuilder(); <line24> } else cmd.append(line); <line25> } <line26> line = reader.readLine(); <line27> } <line28> reader.close(); <line29> } finally { <line30> statement.close(); <line31> } <line32> } <line33> } <line34> "	"""Creating new database tables"""	task7	
"public class A { <line0> Message updateKieContainerToVersion(KieContainerInstanceImpl kci, ReleaseId releaseId) { <line1> String containerId = kci.getContainerId(); <line2> Message response = null; <line3> kci.clearExtraClasses(); <line4> kci.disposeMarshallers(); <line5> Results results = kci.getKieContainer().updateToVersion(releaseId); <line6> if (results.hasMessages(Level.ERROR)) { <line7> response = <line8> new Message( <line9> Severity.WARN, <line10> ""Error updating releaseId for container "" + containerId + "" to version "" + releaseId); <line11> for (org.kie.api.builder.Message builderMsg : results.getMessages()) { <line12> response.addMessage(builderMsg.getText()); <line13> } <line14> logger.error( <line15> ""Error updating releaseId for container "" <line16> + containerId <line17> + "" to version "" <line18> + releaseId <line19> + ""\nMessages: "" <line20> + results.getMessages()); <line21> } else { <line22> kci.updateReleaseId(); <line23> response = <line24> new Message(Severity.INFO, ""Kie container updated successfully to version "" + releaseId); <line25> } <line26> return response; <line27> } <line28> } <line29> "	"""Error updating releaseId for container ""+ containerId+ "" to version ""+ releaseId+ ""\nMessages: ""+ results.getMessages()"	task7	
public class A { <line0> @Override <line1> public int countSharedProjectsByUser(Long idUser) { <line2> LOG.info(UNKNOWN); <line3> Condition conditions = Tables.PROJECT.SHARED.equal(Boolean.TRUE); <line4> if (idUser != null) { <line5> conditions = conditions.and(Tables.PROJECT.ID_USER.eq(idUser)); <line6> } <line7> return create.fetchCount(Tables.PROJECT, conditions); <line8> } <line9> } <line10> 	"""Count shared projects for user {}."", idUser"	task7	
public class A { <line0> protected void success() { <line1> assert uuid != null; <line2> assert canceller != null; <line3> logger.debug(UNKNOWN); <line4> canceller.run(); <line5> SQL.New(GarbageCollectorVO.class) <line6> .eq(GarbageCollectorVO_.uuid, uuid) <line7> .set(GarbageCollectorVO_.status, GCStatus.Done) <line8> .update(); <line9> gcMgr.deregisterGC(this); <line10> } <line11> } <line12> 	"String.format(""[GC] a job[name:%s, id:%s] completes successfully"", NAME, uuid)"	task7	
public class A { <line0> public static ServletContext remove(String servletContextName) { <line1> String contextPath = PortalUtil.getPathContext(); <line2> if (contextPath.equals(servletContextName)) { <line3> return null; <line4> } <line5> ServletContext servletContext = _servletContexts.remove(servletContextName); <line6> if (log.isDebugEnabled()) { <line7> log.debug(UNKNOWN); <line8> } <line9> return servletContext; <line10> } <line11> } <line12> 	"StringBundler.concat(""Remove "", servletContextName, "" "", servletContext)"	task7	
public class A { <line0> public void handle(SubCollectionSubCollectionContext ctx) { <line1> if (log.isDebugEnabled()) { <line2> log.debug(UNKNOWN); <line3> } <line4> currentState.handle(this, ctx); <line5> } <line6> } <line7> 	"""{}"", ctx.toStringTree()"	task7	
"public class A { <line0> @Override <line1> public VALUETO encodeFromRawInternal(Object o, Optional<CassandraOptions> cassandraOptions) { <line2> if (LOGGER.isTraceEnabled()) { <line3> LOGGER.trace(UNKNOWN); <line4> } <line5> Validator.validateTrue( <line6> valueFromTypeToken.getRawType().isAssignableFrom(o.getClass()), <line7> ""The class of object %s to encode should be %s"", <line8> o, <line9> valueFromTypeToken); <line10> return encodeFromJava((VALUEFROM) o, cassandraOptions); <line11> } <line12> } <line13> "	"format(""Encode raw '%s' object %s"", fieldName, o)"	task7	
public class A { <line0> @Override <line1> public void stop() throws Exception { <line2> LOGGER.info(UNKNOWN); <line3> appCtx.getClusterStateManager().setState(SHUTTING_DOWN); <line4> ((ActiveNotificationHandler) appCtx.getActiveNotificationHandler()).stop(); <line5> AsterixStateProxy.unregisterRemoteObject(); <line6> webManager.stop(); <line7> } <line8> } <line9> 	"""Stopping Asterix cluster controller"""	task7	
public class A { <line0> @Override <line1> public void handleCommand(final ChannelUID channelUID, final Command command) { <line2> if (channelUID.getId().equals(WIFI_SOCKET_CHANNEL_ID)) { <line3> logger.debug(UNKNOWN); <line4> if (command == OnOffType.ON) { <line5> this.sendCommand(SilvercrestWifiSocketRequestType.ON); <line6> } else if (command == OnOffType.OFF) { <line7> this.sendCommand(SilvercrestWifiSocketRequestType.OFF); <line8> } else if (command == RefreshType.REFRESH) { <line9> this.sendCommand(SilvercrestWifiSocketRequestType.GPIO_STATUS); <line10> } <line11> } <line12> } <line13> } <line14> 	"""Silvercrest socket command received: {}"", command"	task7	
"public class A { <line0> private void saveUserDetailsToEs(String userId, RequestContext context) { <line1> Request userRequest = new Request(); <line2> userRequest.setRequestContext(context); <line3> userRequest.setOperation(ActorOperations.UPDATE_USER_INFO_ELASTIC.getValue()); <line4> userRequest.getRequest().put(JsonKey.ID, userId); <line5> logger.info( <line6> context, ""TenantMigrationActor:saveUserDetailsToEs: Trigger sync of user details to ES""); <line7> tellToAnother(userRequest); <line8> } <line9> } <line10> "	"context, ""TenantMigrationActor:saveUserDetailsToEs: Trigger sync of user details to ES"""	task7	
public class A { <line0> private void addFileToZipArchive( <line1> final String path, final File file, final ZipFile zipFile, final ZipParameters params) <line2> throws IOException { <line3> logger.info(UNKNOWN); <line4> params.setFileNameInZip(path); <line5> zipFile.addStream(file.getInputStream(), params); <line6> } <line7> } <line8> 	"""Adding File \""{}\"" to new ZIP archive..."", path"	task7	
public class A { <line0> @Override <line1> public String[] next() { <line2> counter++; <line3> if (counter % 100000 == 0) { <line4> logger.info(UNKNOWN); <line5> } <line6> String[] result = rowEncoder.decode(new KV(rocksIterator.key(), rocksIterator.value())); <line7> rocksIterator.next(); <line8> return result; <line9> } <line10> } <line11> 	"""scanned {} rows from rocksDB"", counter"	task7	
public class A { <line0> private void releaseUnprocessedEvents() { <line1> synchronized (this.unprocessedEventsLock) { <line2> Map<EventID, EventWrapper> m = this.unprocessedEvents; <line3> if (m != null) { <line4> for (EventWrapper ew : m.values()) { <line5> GatewaySenderEventImpl gatewayEvent = ew.event; <line6> if (logger.isDebugEnabled()) { <line7> logger.debug(UNKNOWN); <line8> } <line9> gatewayEvent.release(); <line10> } <line11> this.unprocessedEvents = null; <line12> } <line13> } <line14> } <line15> } <line16> 	"""releaseUnprocessedEvents:"" + gatewayEvent"	task7	
public class A { <line0> public Expr allocAggregate(Aggregator agg) { <line1> String key = agg.key(); <line2> Var v = aggregatorsAllocated.get(key); <line3> if (v != null) { <line4> ExprAggregator eAgg = aggregatorsMap.get(v); <line5> if (!agg.equals(eAgg.getAggregator())) <line6> Log.warn(UNKNOWN); <line7> return eAgg; <line8> } <line9> v = allocInternVar(); <line10> ExprAggregator aggExpr = new ExprAggregator(v, agg); <line11> aggregatorsAllocated.put(key, v); <line12> aggregatorsMap.put(v, aggExpr); <line13> aggregators.add(aggExpr); <line14> return aggExpr; <line15> } <line16> } <line17> 	"Query.class, ""Internal inconsistency: Aggregator: "" + agg"	task7	
"public class A { <line0> @Override <line1> public void saveState(Node node) { <line2> Document doc = node instanceof Document ? (Document) node : node.getOwnerDocument(); <line3> try { <line4> Node timeNode = <line5> (Node) <line6> StateXML.newXPath() <line7> .evaluate( <line8> ""/"" + ModuleStateController.STATE_QNAME + ""/:time"", <line9> node, <line10> XPathConstants.NODE); <line11> if (timeNode == null) { <line12> timeNode = StateXML.createElement(doc, ""time""); <line13> node.appendChild(timeNode); <line14> } <line15> saveCurrentState(timeNode); <line16> saveHeldState(timeNode); <line17> saveFadeState(timeNode); <line18> } catch (XPathExpressionException e) { <line19> LOGGER.error(UNKNOWN); <line20> } <line21> } <line22> } <line23> "	e, e	task7	
"public class A { <line0> public SignResponse sign( <line1> String apiVersion, String moduleName, SignRequest signRequest, String generationId) <line2> throws IOException, TransportException, HsmException { <line3> log.debug(UNKNOWN); <line4> String uri = baseUrl != null ? baseUrl.replaceFirst(""/*$"", """") : """"; <line5> byte[] body = signRequest.toJson().getBytes(); <line6> String pathBuilder = <line7> ""/modules/"" <line8> + URLEncoder.encode(moduleName, StandardCharsets.UTF_8.name()) <line9> + ""/genid/"" <line10> + URLEncoder.encode(generationId, StandardCharsets.UTF_8.name()) <line11> + ""/sign""; <line12> HttpsResponse response = <line13> sendRequestBasedOnScheme( <line14> HttpsMethod.POST, body, uri, pathBuilder, API_VERSION_QUERY_STRING_PREFIX + apiVersion); <line15> int responseCode = response.getStatus(); <line16> String responseBody = new String(response.getBody()); <line17> if (responseCode >= 200 && responseCode < 300) { <line18> return SignResponse.fromJson(responseBody); <line19> } else { <line20> String exceptionMessage = <line21> ""HttpsHsmClient received status code "" + responseCode + "" from provided uri.""; <line22> ErrorResponse errorResponse = ErrorResponse.fromJson(responseBody); <line23> if (errorResponse != null) { <line24> exceptionMessage = <line25> exceptionMessage + "" Error response message: "" + errorResponse.getMessage(); <line26> } <line27> throw new HsmException(exceptionMessage); <line28> } <line29> } <line30> } <line31> "	"""Sending sign request..."""	task7	
"public class A { <line0> @Override <line1> public boolean cheat( <line2> final UUID gameId, final String sessionId, final UUID playerId, final String cardName) <line3> throws MageException { <line4> return executeWithResult( <line5> ""cheatOne"", <line6> sessionId, <line7> new ActionWithBooleanResult() { <line8> @Override <line9> public Boolean execute() { <line10> if (testMode) { <line11> Optional<Session> session = managerFactory.sessionManager().getSession(sessionId); <line12> if (!session.isPresent()) { <line13> logger.error(UNKNOWN); <line14> } else { <line15> UUID userId = session.get().getUserId(); <line16> return managerFactory.gameManager().cheat(gameId, userId, playerId, cardName); <line17> } <line18> } <line19> return false; <line20> } <line21> }); <line22> } <line23> } <line24> "	"""Session not found : "" + sessionId"	task7	
public class A { <line0> private static void updateOnImageFile(Document mets, String fileId, String path) { <line1> LOGGER.debug(UNKNOWN); <line2> List<String> customFileGroups = getFileGroups(mets); <line3> PhysicalSubDiv div = <line4> new PhysicalSubDiv(PhysicalSubDiv.ID_PREFIX + fileId, PhysicalSubDiv.TYPE_PAGE); <line5> div.add(new Fptr(fileId)); <line6> customFileGroups.stream() <line7> .map(customFileGroup -> searchFileInGroup(mets, path, customFileGroup)) <line8> .filter(Objects::nonNull) <line9> .map(Fptr::new) <line10> .forEach(div::add); <line11> Element structMapPhys = getPhysicalStructmap(mets); <line12> structMapPhys.addContent(div.asElement()); <line13> SmLink smLink = getDefaultSmLink(mets, div); <line14> Element structLink = getStructLink(mets); <line15> structLink.addContent(smLink.asElement()); <line16> } <line17> } <line18> 	"""FILE is a image!"""	task7	
"public class A { <line0> @BeforeClass <line1> public static void setup() throws Exception { <line2> Configuration conf = new Configuration(); <line3> conf.setInt(HttpServer.HTTP_MAX_THREADS, MAX_THREADS); <line4> server = createTestServer(conf); <line5> server.addUnprivilegedServlet(""echo"", ""/echo"", EchoServlet.class); <line6> server.addUnprivilegedServlet(""echomap"", ""/echomap"", EchoMapServlet.class); <line7> server.addUnprivilegedServlet(""htmlcontent"", ""/htmlcontent"", HtmlContentServlet.class); <line8> server.addUnprivilegedServlet(""longheader"", ""/longheader"", LongHeaderServlet.class); <line9> server.addJerseyResourcePackage(JerseyResource.class.getPackage().getName(), ""/jersey/*""); <line10> server.start(); <line11> baseUrl = getServerURL(server); <line12> LOG.info(UNKNOWN); <line13> } <line14> } <line15> "	"""HTTP server started: "" + baseUrl"	task7	
"public class A { <line0> @Override <line1> public void stopMonitoring( <line2> final String handlerId, <line3> final AlertHandlerPriority handlerPriority, <line4> final String environmentId) <line5> throws EnvironmentManagerException { <line6> Preconditions.checkArgument(!StringUtils.isBlank(handlerId), ""Invalid alert handler id.""); <line7> Preconditions.checkNotNull(handlerPriority, ""Invalid alert priority.""); <line8> try { <line9> LocalEnvironment environment = environmentService.find(environmentId); <line10> environment.removeAlertHandler(new EnvironmentAlertHandlerImpl(handlerId, handlerPriority)); <line11> update(environment); <line12> } catch (Exception e) { <line13> LOG.error(UNKNOWN); <line14> throw new EnvironmentManagerException(e.getMessage(), e); <line15> } <line16> } <line17> } <line18> "	"""Error on E monitoring"", e"	task7	
public class A { <line0> public void mergeStatistics(Statistics stats) { <line1> if (this.getClass() == stats.getClass()) { <line2> if (stats.startTime < this.startTime) { <line3> this.startTime = stats.startTime; <line4> } <line5> if (stats.endTime > this.endTime) { <line6> this.endTime = stats.endTime; <line7> } <line8> this.count += stats.count; <line9> mergeStatisticsValue(stats); <line10> isEmpty = false; <line11> } else { <line12> String thisClass = this.getClass().toString(); <line13> String statsClass = stats.getClass().toString(); <line14> LOG.warn(UNKNOWN); <line15> throw new StatisticsClassException(this.getClass(), stats.getClass()); <line16> } <line17> } <line18> } <line19> 	"""Statistics classes mismatched,no merge: {} v.s. {}"", thisClass, statsClass"	task7	
public class A { <line0> protected boolean hasTeamUser(Object object) { <line1> User user = (User) object; <line2> try { <line3> return UserLocalServiceUtil.hasTeamUser(_team.getTeamId(), user.getUserId()); <line4> } catch (Exception exception) { <line5> log.error(UNKNOWN); <line6> return false; <line7> } <line8> } <line9> } <line10> 	exception, exception	task7	
"public class A { <line0> public String validatePostLogoutRedirectUri(String clientId, String postLogoutRedirectUri) { <line1> boolean isBlank = Util.isNullOrEmpty(postLogoutRedirectUri); <line2> Client client = clientService.getClient(clientId); <line3> if (client != null) { <line4> String[] postLogoutRedirectUris = client.getPostLogoutRedirectUris(); <line5> log.debug( <line6> ""Validating post logout redirect URI: clientId = {}, postLogoutRedirectUri = {}"", <line7> clientId, <line8> postLogoutRedirectUri); <line9> return validatePostLogoutRedirectUri(postLogoutRedirectUri, postLogoutRedirectUris); <line10> } <line11> if (!isBlank) { <line12> throw errorResponseFactory.createWebApplicationException( <line13> Response.Status.BAD_REQUEST, <line14> EndSessionErrorResponseType.POST_LOGOUT_URI_NOT_ASSOCIATED_WITH_CLIENT, <line15> ""`post_logout_redirect_uri` is not added to associated client.""); <line16> } <line17> return null; <line18> } <line19> } <line20> "	"""Validating post logout redirect URI: clientId = {}, postLogoutRedirectUri = {}"",clientId,postLogoutRedirectUri"	task7	
"public class A { <line0> public void setStore(BlobStore store) { <line1> blobStoreStateLock.lock(); <line2> try { <line3> if (LOG.isDebugEnabled()) { <line4> LOG.debug(UNKNOWN); <line5> } <line6> if (store == null) { <line7> throw new NullPointerException(""Input BlobStore cannot be null""); <line8> } <line9> this.store = store; <line10> } finally { <line11> blobStoreStateLock.unlock(); <line12> } <line13> } <line14> } <line15> "	"""Setting the wrapped store"""	task7	
public class A { <line0> @Override <line1> public void onNext(ThreadSnapshot snapshot) { <line2> if (LOGGER.isDebugEnabled()) { <line3> LOGGER.debug(UNKNOWN); <line4> } <line5> final ProfileThreadSnapshotRecord record = new ProfileThreadSnapshotRecord(); <line6> record.setTaskId(snapshot.getTaskId()); <line7> record.setSegmentId(snapshot.getTraceSegmentId()); <line8> record.setDumpTime(snapshot.getTime()); <line9> record.setSequence(snapshot.getSequence()); <line10> record.setStackBinary(snapshot.getStack().toByteArray()); <line11> record.setTimeBucket(TimeBucket.getRecordTimeBucket(snapshot.getTime())); <line12> RecordStreamProcessor.getInstance().in(record); <line13> } <line14> } <line15> 	"""receive profile segment snapshot"""	task7	
public class A { <line0> private void delayedRebalanceSchedule( <line1> ResourceControllerDataProvider clusterData, <line2> Set<String> delayedActiveNodes, <line3> Set<String> resourceSet) { <line4> if (_manager != null) { <line5> ClusterConfig clusterConfig = clusterData.getClusterConfig(); <line6> boolean delayedRebalanceEnabled = DelayedRebalanceUtil.isDelayRebalanceEnabled(clusterConfig); <line7> Set<String> offlineOrDisabledInstances = new HashSet<>(delayedActiveNodes); <line8> offlineOrDisabledInstances.removeAll(clusterData.getEnabledLiveInstances()); <line9> for (String resource : resourceSet) { <line10> DelayedRebalanceUtil.setRebalanceScheduler( <line11> resource, <line12> delayedRebalanceEnabled, <line13> offlineOrDisabledInstances, <line14> clusterData.getInstanceOfflineTimeMap(), <line15> clusterData.getLiveInstances().keySet(), <line16> clusterData.getInstanceConfigMap(), <line17> clusterConfig.getRebalanceDelayTime(), <line18> clusterConfig, <line19> _manager); <line20> } <line21> } else { <line22> LOG.warn(UNKNOWN); <line23> } <line24> } <line25> } <line26> 	"""Skip scheduling a delayed rebalancer since HelixManager is not specified."""	task7	
public class A { <line0> private void sendZip(Iterable<String> testJars, DataOutputStream outputStream) <line1> throws IOException { <line2> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line3> ZipOutputStream zipOutputStream = new ZipOutputStream(out); <line4> for (String jar : testJars) { <line5> LOG.info(UNKNOWN); <line6> File file = new File(jar); <line7> FileInputStream in = new FileInputStream(file); <line8> zipOutputStream.putNextEntry(new ZipEntry(file.getName())); <line9> IOUtils.copy(in, zipOutputStream); <line10> in.close(); <line11> zipOutputStream.closeEntry(); <line12> } <line13> zipOutputStream.close(); <line14> byte[] bs = out.toByteArray(); <line15> outputStream.writeInt(bs.length); <line16> outputStream.write(bs); <line17> } <line18> } <line19> 	"""Sending jar [{0}]"", jar"	task7	
public class A { <line0> @Override <line1> public void channelLinked(ChannelUID channelUID) { <line2> synchronized (this) { <line3> logger.debug(UNKNOWN); <line4> if (!verifyChannel(channelUID)) { <line5> return; <line6> } <line7> String channelGroup = channelUID.getGroupId(); <line8> if (channelGroup != null && channelGroup.equals(CHANNEL_GROUP_INPUT)) { <line9> if (pinStateHolder.getInputPin(channelUID) != null) { <line10> return; <line11> } <line12> GpioPinDigitalInput inputPin = initializeInputPin(channelUID); <line13> pinStateHolder.addInputPin(inputPin, channelUID); <line14> } <line15> super.channelLinked(channelUID); <line16> } <line17> } <line18> } <line19> 	"""channel linked {}"", channelUID.getAsString()"	task7	
"public class A { <line0> private static SimpleOrderedMap<Object> getDocumentFieldsInfo( <line1> Document doc, int docId, IndexReader reader, IndexSchema schema) throws IOException { <line2> final CharsRefBuilder spare = new CharsRefBuilder(); <line3> SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<>(); <line4> for (Object o : doc.getFields()) { <line5> Field field = (Field) o; <line6> SimpleOrderedMap<Object> f = new SimpleOrderedMap<>(); <line7> SchemaField sfield = schema.getFieldOrNull(field.name()); <line8> FieldType ftype = (sfield == null) ? null : sfield.getType(); <line9> f.add(""type"", (ftype == null) ? null : ftype.getTypeName()); <line10> f.add(""schema"", getFieldFlags(sfield)); <line11> f.add(""flags"", getFieldFlags(field)); <line12> Term t = <line13> new Term( <line14> field.name(), ftype != null ? ftype.storedToIndexed(field) : field.stringValue()); <line15> f.add(""value"", (ftype == null) ? null : ftype.toExternal(field)); <line16> f.add(""internal"", field.stringValue()); <line17> BytesRef bytes = field.binaryValue(); <line18> if (bytes != null) { <line19> f.add(""binary"", Base64.byteArrayToBase64(bytes.bytes, bytes.offset, bytes.length)); <line20> } <line21> f.add(""boost"", field.boost()); <line22> f.add(""docFreq"", t.text() == null ? 0 : reader.docFreq(t)); <line23> if (field.fieldType().storeTermVectors()) { <line24> try { <line25> Terms v = reader.getTermVector(docId, field.name()); <line26> if (v != null) { <line27> SimpleOrderedMap<Integer> tfv = new SimpleOrderedMap<>(); <line28> final TermsEnum termsEnum = v.iterator(); <line29> BytesRef text; <line30> while ((text = termsEnum.next()) != null) { <line31> final int freq = (int) termsEnum.totalTermFreq(); <line32> spare.copyUTF8Bytes(text); <line33> tfv.add(spare.toString(), freq); <line34> } <line35> f.add(""termVector"", tfv); <line36> } <line37> } catch (Exception ex) { <line38> log.warn(UNKNOWN); <line39> } <line40> } <line41> finfo.add(field.name(), f); <line42> } <line43> return finfo; <line44> } <line45> } <line46> "	"""error writing term vector"", ex"	task7	
"public class A { <line0> public static AbstractLockingManagement getLockingManagement( <line1> final GeoWavePluginConfig pluginConfig) { <line2> synchronized (LOCKING_MANAGEMENT_CLASS_LCK) { <line3> final String val = System.getenv(LOCKING_MANAGEMENT_CLASS); <line4> if (val == null) { <line5> return new MemoryLockManager(pluginConfig); <line6> } else { <line7> try { <line8> final Class<? extends AbstractLockingManagement> lockManagerClass = <line9> (Class<? extends AbstractLockingManagement>) Class.forName(val); <line10> if (!AbstractLockingManagement.class.isAssignableFrom(lockManagerClass)) { <line11> throw new IllegalArgumentException(""Invalid LockManagement class "" + val); <line12> } else { <line13> final Constructor cons = lockManagerClass.getConstructor(GeoWavePluginConfig.class); <line14> return (AbstractLockingManagement) cons.newInstance(pluginConfig); <line15> } <line16> } catch (final Exception ex) { <line17> LOGGER.error(UNKNOWN); <line18> return new MemoryLockManager(pluginConfig); <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	"""Cannot instantiate lock management class "" + val, ex"	task7	
"public class A { <line0> public static File captureScreenShot() { <line1> File src = webDriver.getScreenshotAs(OutputType.FILE); <line2> File screenshotFile = <line3> new File(System.getProperty(""user.dir"") + ""/target/Selenium/"" + ""screen.png""); <line4> try { <line5> FileUtils.copyFile(src, screenshotFile); <line6> } catch (IOException e) { <line7> logger.error(UNKNOWN); <line8> } <line9> return screenshotFile; <line10> } <line11> } <line12> "	e.getMessage()	task7	
public class A { <line0> public void submit() { <line1> LOG.info(UNKNOWN); <line2> this.reef.submit(this.driverConfig); <line3> } <line4> } <line5> 	"""Start the job driver"""	task7	
"public class A { <line0> private void writeConfig( <line1> NetInterfaceConfig<? extends NetInterfaceAddressConfig> netInterfaceConfig) <line2> throws KuraException { <line3> NetInterfaceType type = netInterfaceConfig.getType(); <line4> if (type != NetInterfaceType.ETHERNET <line5> && type != NetInterfaceType.WIFI <line6> && type != NetInterfaceType.LOOPBACK) { <line7> logger.info( <line8> ""writeConfig() :: Cannot write configuration file for this type of interface - {}"", type); <line9> return; <line10> } <line11> netConfigManager.write(netInterfaceConfig); <line12> } <line13> } <line14> "	"""writeConfig() :: Cannot write configuration file for this type of interface - {}"", type"	task7	
"public class A { <line0> public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter typeConverter) { <line1> LOG.trace(UNKNOWN); <line2> TypeConverter converter = typeMappings.get(toType, fromType); <line3> if (typeConverter != converter) { <line4> boolean add = true; <line5> if (converter != null) { <line6> if (typeConverterExists == TypeConverterExists.Override) { <line7> CamelLogger logger = new CamelLogger(LOG, typeConverterExistsLoggingLevel); <line8> logger.log(""Overriding type converter from: "" + converter + "" to: "" + typeConverter); <line9> } else if (typeConverterExists == TypeConverterExists.Ignore) { <line10> CamelLogger logger = new CamelLogger(LOG, typeConverterExistsLoggingLevel); <line11> logger.log( <line12> ""Ignoring duplicate type converter from: "" + converter + "" to: "" + typeConverter); <line13> add = false; <line14> } else { <line15> throw new TypeConverterExistsException(toType, fromType); <line16> } <line17> } <line18> if (add) { <line19> typeMappings.put(toType, fromType, typeConverter); <line20> } <line21> } <line22> } <line23> } <line24> "	"""Adding type converter: {}"", typeConverter"	task7	
"public class A { <line0> public CreateVersionPage selectProjectType(final String projectType) { <line1> log.info(UNKNOWN); <line2> clickElement( <line3> (WebElement) <line4> waitForAMoment() <line5> .withMessage(""project type found"") <line6> .until( <line7> webDriver -> { <line8> for (WebElement item : <line9> readyElement(projectTypeSelection).findElements(By.tagName(""li""))) { <line10> if (item.findElement(By.tagName(""label"")) <line11> .getText() <line12> .startsWith(projectType)) { <line13> return item; <line14> } <line15> } <line16> return null; <line17> })); <line18> return new CreateVersionPage(getDriver()); <line19> } <line20> } <line21> "	"""Click project type {}"", projectType"	task7	
"public class A { <line0> private void close(String stagedRepositoryId) { <line1> Map<String, Object> body = new HashMap<>(); <line2> body.put(""data"", Collections.singletonMap(""stagedRepositoryId"", stagedRepositoryId)); <line3> this.restTemplate.postForEntity( <line4> String.format(NEXUS_STAGING_PATH + ""profiles/%s/finish"", this.stagingProfileId), <line5> body, <line6> Void.class); <line7> logger.info(UNKNOWN); <line8> while (true) { <line9> StagingRepository repository = <line10> this.restTemplate.getForObject( <line11> NEXUS_STAGING_PATH + ""repository/"" + stagedRepositoryId, StagingRepository.class); <line12> if (!repository.transitioning) { <line13> if (""open"".equals(repository.type)) { <line14> logFailures(stagedRepositoryId); <line15> throw new RuntimeException(""Close failed""); <line16> } <line17> return; <line18> } <line19> try { <line20> Thread.sleep(this.pollingInterval.toMillis()); <line21> } catch (InterruptedException ex) { <line22> Thread.currentThread().interrupt(); <line23> throw new RuntimeException(""Interrupted while waiting for staging repository to close"", ex); <line24> } <line25> } <line26> } <line27> } <line28> "	"""Close requested. Awaiting result"""	task7	
"public class A { <line0> @ApiOperation( <line1> value = ""Returns the rendered form for a specified task instance."", <line2> response = String.class, <line3> code = 200) <line4> @ApiResponses( <line5> value = { <line6> @ApiResponse(code = 500, message = ""Unexpected error""), <line7> @ApiResponse(code = 404, message = ""Task, form or Container Id not found"") <line8> }) <line9> @GET <line10> @Path(TASK_FORM_CONTENT_GET_URI) <line11> @Produces({MediaType.TEXT_HTML}) <line12> public Response getTaskRenderedForm( <line13> @javax.ws.rs.core.Context HttpHeaders headers, <line14> @ApiParam( <line15> value = ""container id that task instance belongs to"", <line16> required = true, <line17> example = ""evaluation_1.0.0-SNAPSHOT"") <line18> @PathParam(CONTAINER_ID) <line19> String containerId, <line20> @ApiParam( <line21> value = ""identifier of task instance that form should be fetched for"", <line22> required = true, <line23> example = ""123"") <line24> @PathParam(TASK_INSTANCE_ID) <line25> Long taskId, <line26> @ApiParam( <line27> value = ""optional renderer name that the form should be rendered with"", <line28> required = false) <line29> @QueryParam(""renderer"") <line30> @DefaultValue(""patternfly"") <line31> String renderer) { <line32> Variant variant = getVariant(headers); <line33> Header conversationIdHeader = buildConversationIdHeader(containerId, context, headers); <line34> try { <line35> String renderedForm = formRendererBase.getTaskRenderedForm(renderer, containerId, taskId); <line36> if (renderedForm == null) { <line37> return Response.status(Status.NOT_FOUND).build(); <line38> } <line39> return Response.ok().entity(renderedForm).build(); <line40> } catch (PermissionDeniedException e) { <line41> return permissionDenied( <line42> MessageFormat.format(TASK_PERMISSION_ERROR, taskId), variant, conversationIdHeader); <line43> } catch (TaskNotFoundException e) { <line44> return notFound( <line45> MessageFormat.format(TASK_INSTANCE_NOT_FOUND, taskId), variant, conversationIdHeader); <line46> } catch (DeploymentNotFoundException e) { <line47> return notFound( <line48> MessageFormat.format(CONTAINER_NOT_FOUND, containerId), variant, conversationIdHeader); <line49> } catch (IllegalArgumentException | IllegalStateException e) { <line50> return notFound(e.getMessage(), variant, conversationIdHeader); <line51> } catch (Exception e) { <line52> logger.error(UNKNOWN); <line53> return internalServerError(errorMessage(e), variant, conversationIdHeader); <line54> } <line55> } <line56> } <line57> "	"""Unexpected error during processing {}"", e.getMessage(), e"	task7	
"public class A { <line0> static <K, V, OutputT, W extends BoundedWindow> JavaPairRDD<ByteArray, OutputT> bringWindowToKey( <line1> JavaRDD<WindowedValue<KV<K, V>>> rdd, <line2> Coder<K> keyCoder, <line3> Coder<W> windowCoder, <line4> SerializableFunction<WindowedValue<KV<K, V>>, OutputT> mappingFn) { <line5> if (!isKeyAndWindowCoderConsistentWithEquals(keyCoder, windowCoder)) { <line6> LOG.warn( <line7> ""Either coder {} or {} is not consistent with equals. "" <line8> + ""That might cause issues on some runners."", <line9> keyCoder, <line10> windowCoder); <line11> } <line12> return rdd.flatMapToPair( <line13> (WindowedValue<KV<K, V>> windowedValue) -> { <line14> final byte[] keyBytes = <line15> CoderHelpers.toByteArray(windowedValue.getValue().getKey(), keyCoder); <line16> return Iterators.transform( <line17> windowedValue.explodeWindows().iterator(), <line18> item -> { <line19> Objects.requireNonNull(item, ""Exploded window can not be null.""); <line20> @SuppressWarnings(""unchecked"") <line21> final W window = (W) Iterables.getOnlyElement(item.getWindows()); <line22> final byte[] windowBytes = CoderHelpers.toByteArray(window, windowCoder); <line23> WindowedValue<KV<K, V>> valueOut = <line24> WindowedValue.of(item.getValue(), item.getTimestamp(), window, item.getPane()); <line25> final ByteArray windowedKey = new ByteArray(Bytes.concat(keyBytes, windowBytes)); <line26> return new Tuple2<>(windowedKey, mappingFn.apply(valueOut)); <line27> }); <line28> }); <line29> } <line30> } <line31> "	"""Either coder {} or {} is not consistent with equals. ""+ ""That might cause issues on some runners."",keyCoder,windowCoder"	task7	
"public class A { <line0> private Optional<DataSourceInfo> dsInfoForDataSource(final @NonNull DataSource dataSource) { <line1> try (val connection = dataSource.getConnection()) { <line2> return Optional.ofNullable(connection.getMetaData()).map(DataSourceInfo::fromMetaData); <line3> } catch (SQLException e) { <line4> log.warn( <line5> ""failed to get metadata from SQL connection using datasource of type {}"", <line6> dataSource.getClass()); <line7> } <line8> return Optional.empty(); <line9> } <line10> } <line11> "	"""failed to get metadata from SQL connection using datasource of type {}"",dataSource.getClass()"	task7	
"public class A { <line0> @Override <line1> protected PROXYPOJOCLASS createObjectInternal( <line2> final POJOCLASS object, <line3> final EntityManager entityManager, <line4> final String transactionType, <line5> final PersistenceType persistenceType) <line6> throws DMPPersistenceException { <line7> final String uri = object.getUri(); <line8> final POJOCLASS existingObject = getObjectByUri(uri, entityManager); <line9> final POJOCLASS newObject; <line10> if (null == existingObject) { <line11> newObject = createNewObject(object.getUuid(), uri); <line12> updateObjectInternal(object, newObject); <line13> final Optional<POJOCLASS> optionalPersistentObject = <line14> persistObject(newObject, entityManager, persistenceType); <line15> final POJOCLASS persistentObject = <line16> determinePersistentObject(newObject, optionalPersistentObject); <line17> return createNewProxyObject(persistentObject); <line18> } else { <line19> AdvancedDMPJPAService.LOG.debug( <line20> className <line21> + "" with uri '"" <line22> + uri <line23> + ""' exists already in the database, will return the existing object, instead"" <line24> + "" creating a new one""); <line25> return createNewProxyObject(existingObject, RetrievalType.RETRIEVED); <line26> } <line27> } <line28> } <line29> "	"className+ "" with uri '""+ uri+ ""' exists already in the database, will return the existing object, instead""+ "" creating a new one"""	task7	
public class A { <line0> @Override <line1> protected void writeMultipleRecordsInternal() throws Exception { <line2> if (batchSize > 1) { <line3> BoundStatement boundStatement = pstmt.bind(); <line4> for (int rowIndex = 0; rowIndex < rows.size(); rowIndex++) { <line5> for (int columnIndex = 0; columnIndex < columnMeta.size(); columnIndex++) { <line6> Object value = rows.get(rowIndex).getField(columnIndex); <line7> CassandraUtil.bindColumn( <line8> boundStatement, columnIndex, columnTypes.get(columnIndex), value); <line9> } <line10> if ((rowIndex % 1000) == 0) { <line11> LOG.info(UNKNOWN); <line12> } <line13> if (asyncWrite) { <line14> unConfirmedWrite.add(session.executeAsync(boundStatement)); <line15> if (unConfirmedWrite.size() >= batchSize) { <line16> for (ResultSetFuture write : unConfirmedWrite) { <line17> write.getUninterruptibly(10000, TimeUnit.MILLISECONDS); <line18> } <line19> unConfirmedWrite.clear(); <line20> } <line21> } else { <line22> bufferedWrite.add(boundStatement); <line23> if (bufferedWrite.size() >= batchSize) { <line24> BatchStatement batchStatement = new BatchStatement(BatchStatement.Type.UNLOGGED); <line25> batchStatement.addAll(bufferedWrite); <line26> session.execute(batchStatement); <line27> bufferedWrite.clear(); <line28> } <line29> } <line30> } <line31> if (unConfirmedWrite != null && unConfirmedWrite.size() > 0) { <line32> for (ResultSetFuture write : unConfirmedWrite) { <line33> write.getUninterruptibly(10000, TimeUnit.MILLISECONDS); <line34> } <line35> unConfirmedWrite.clear(); <line36> } <line37> if (bufferedWrite != null && bufferedWrite.size() > 0) { <line38> BatchStatement batchStatement = new BatchStatement(BatchStatement.Type.UNLOGGED); <line39> batchStatement.addAll(bufferedWrite); <line40> session.execute(batchStatement); <line41> bufferedWrite.clear(); <line42> } <line43> } <line44> } <line45> } <line46> 	"""insertSql: {}"", boundStatement"	task7	
public class A { <line0> public boolean removeMessageListener(Object topic, @Nullable GridMessageListener lsnr) { <line1> assert topic != null; <line2> boolean rmv = true; <line3> Collection<GridCommunicationMessageSet> msgSets = null; <line4> if (lsnr == null) { <line5> closedTopics.add(topic); <line6> lsnr = listenerRemove0(topic); <line7> rmv = lsnr != null; <line8> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line9> if (map != null) msgSets = map.values(); <line10> } else { <line11> for (; ; ) { <line12> GridMessageListener lsnrs = listenerGet0(topic); <line13> if (lsnrs == null) { <line14> closedTopics.add(topic); <line15> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line16> if (map != null) msgSets = map.values(); <line17> rmv = false; <line18> break; <line19> } else { <line20> boolean empty = false; <line21> if (!(lsnrs instanceof ArrayListener)) { <line22> if (lsnrs.equals(lsnr)) { <line23> if (!listenerRemove0(topic, lsnrs)) continue; <line24> empty = true; <line25> } else rmv = false; <line26> } else { <line27> ArrayListener arrLsnr = (ArrayListener) lsnrs; <line28> if (arrLsnr.remove(lsnr)) empty = arrLsnr.isEmpty(); <line29> else rmv = false; <line30> if (empty) listenerRemove0(topic, lsnrs); <line31> } <line32> if (empty) { <line33> closedTopics.add(topic); <line34> Map<UUID, GridCommunicationMessageSet> map = msgSetMap.remove(topic); <line35> if (map != null) msgSets = map.values(); <line36> } <line37> break; <line38> } <line39> } <line40> } <line41> if (msgSets != null) <line42> for (GridCommunicationMessageSet msgSet : msgSets) ctx.timeout().removeTimeoutObject(msgSet); <line43> if (rmv && log.isDebugEnabled()) <line44> log.debug(UNKNOWN); <line45> if (lsnr instanceof ArrayListener) { <line46> for (GridMessageListener childLsnr : ((ArrayListener) lsnr).arr) closeListener(childLsnr); <line47> } else closeListener(lsnr); <line48> return rmv; <line49> } <line50> } <line51> 	"""Removed message listener [topic="" + topic + "", lsnr="" + lsnr + ']'"	task7	
"public class A { <line0> @Override <line1> public D create(final D dto) { <line2> LOGGER.debug(UNKNOWN); <line3> Assert.isNull(dto.getId(), ""The DTO identifier must be null for creation.""); <line4> beforeCreate(dto); <line5> dto.setId(generateSuperId()); <line6> final E entity = convertFromDtoToEntity(dto); <line7> beforeCreate(entity); <line8> final E createdEntity = getRepository().save(entity); <line9> return convertFromEntityToDto(createdEntity); <line10> } <line11> } <line12> "	"""Create {} with {}"", getObjectName(), dto"	task7	
public class A { <line0> @Override <line1> public Set<RegisteredCredential> lookupAll(final ByteArray credentialId) { <line2> log.debug(UNKNOWN); <line3> return Collections.emptySet(); <line4> } <line5> } <line6> 	"""Enter lookupAll()"""	task7	
"public class A { <line0> @Override <line1> public void onSubscriptionTransferFailed( <line2> final UaSubscription subscription, final StatusCode statusCode) { <line3> LOG.info(UNKNOWN); <line4> handleConnectionFailue(new RuntimeException(""Subscription failed to reconnect"")); <line5> } <line6> } <line7> "	"""Transfer failed {} : {}"", subscription.getSubscriptionId(), statusCode"	task7	
"public class A { <line0> protected void instantiateAdjuncts(BrooklynObjectInstantiator instantiator) { <line1> checkEnteringPhase(5); <line2> if (rebindManager.persistPoliciesEnabled) { <line3> logRebindingDebug(""RebindManager instantiating policies: {}"", memento.getPolicyIds()); <line4> for (PolicyMemento policyMemento : memento.getPolicyMementos().values()) { <line5> logRebindingDebug(""RebindManager instantiating policy {}"", policyMemento); <line6> try { <line7> Policy policy = instantiator.newPolicy(policyMemento); <line8> rebindContext.registerPolicy(policyMemento.getId(), policy); <line9> } catch (Exception e) { <line10> exceptionHandler.onCreateFailed( <line11> BrooklynObjectType.POLICY, policyMemento.getId(), policyMemento.getType(), e); <line12> } <line13> } <line14> } else { <line15> logRebindingDebug(""Not rebinding policies; feature disabled: {}"", memento.getPolicyIds()); <line16> } <line17> if (rebindManager.persistEnrichersEnabled) { <line18> logRebindingDebug(""RebindManager instantiating enrichers: {}"", memento.getEnricherIds()); <line19> for (EnricherMemento enricherMemento : memento.getEnricherMementos().values()) { <line20> logRebindingDebug(""RebindManager instantiating enricher {}"", enricherMemento); <line21> try { <line22> Enricher enricher = instantiator.newEnricher(enricherMemento); <line23> rebindContext.registerEnricher(enricherMemento.getId(), enricher); <line24> } catch (Exception e) { <line25> exceptionHandler.onCreateFailed( <line26> BrooklynObjectType.ENRICHER, enricherMemento.getId(), enricherMemento.getType(), e); <line27> } <line28> } <line29> } else { <line30> logRebindingDebug(""Not rebinding enrichers; feature disabled: {}"", memento.getEnricherIds()); <line31> } <line32> if (rebindManager.persistFeedsEnabled) { <line33> logRebindingDebug(""RebindManager instantiating feeds: {}"", memento.getFeedIds()); <line34> for (FeedMemento feedMemento : memento.getFeedMementos().values()) { <line35> LOG.isDebugEnabled(UNKNOWN); <line36> try { <line37> Feed feed = instantiator.newFeed(feedMemento); <line38> rebindContext.registerFeed(feedMemento.getId(), feed); <line39> } catch (Exception e) { <line40> exceptionHandler.onCreateFailed( <line41> BrooklynObjectType.FEED, feedMemento.getId(), feedMemento.getType(), e); <line42> } <line43> } <line44> } else { <line45> logRebindingDebug(""Not rebinding feeds; feature disabled: {}"", memento.getFeedIds()); <line46> } <line47> } <line48> } <line49> "	"""RebindManager instantiating feed {}"", feedMemento"	task7	
"public class A { <line0> public static java.util.List<com.liferay.portal.kernel.model.Country> getCompanyCountries( <line1> HttpPrincipal httpPrincipal, long companyId) { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> CountryServiceUtil.class, ""getCompanyCountries"", _getCompanyCountriesParameterTypes8); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, companyId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line12> } <line13> return (java.util.List<com.liferay.portal.kernel.model.Country>) returnObj; <line14> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line15> log.error(UNKNOWN); <line16> throw systemException; <line17> } <line18> } <line19> } <line20> "	systemException, systemException	task7	
"public class A { <line0> @Test <line1> public void testClassLevelMultipleInterceptor() throws Exception { <line2> Collection<String> beanXmls = new ArrayList<String>(); <line3> beanXmls.add( <line4> getXmlPath(this.getClass().getPackage().getName(), this.getClass().getSimpleName())); <line5> Collection<Class<?>> beanClasses = new ArrayList<Class<?>>(); <line6> beanClasses.add(ClassMultiInterceptedClass.class); <line7> beanClasses.add(Transactional.class); <line8> beanClasses.add(Secure.class); <line9> beanClasses.add(Action.class); <line10> beanClasses.add(ActionInterceptor.class); <line11> beanClasses.add(SecureInterceptor.class); <line12> beanClasses.add(TransactionalInterceptor.class); <line13> startContainer(beanClasses, beanXmls); <line14> InterceptorResolutionService ir = new InterceptorResolutionService(getWebBeansContext()); <line15> AnnotatedType<ClassMultiInterceptedClass> annotatedType = <line16> getBeanManager().createAnnotatedType(ClassMultiInterceptedClass.class); <line17> Bean<ClassMultiInterceptedClass> bean = <line18> (Bean<ClassMultiInterceptedClass>) <line19> getBeanManager() <line20> .resolve((Set) getBeanManager().getBeans(ClassMultiInterceptedClass.class)); <line21> BeanInterceptorInfo interceptorInfo = null; <line22> long start = System.nanoTime(); <line23> for (int i = 0; i < 2; i++) { <line24> interceptorInfo = <line25> ir.calculateInterceptorInfo(bean.getTypes(), bean.getQualifiers(), annotatedType, false); <line26> } <line27> long end = System.nanoTime(); <line28> log.info( <line29> ""calculating the interceptor info took "" <line30> + TimeUnit.NANOSECONDS.toMillis(end - start) <line31> + "" ms""); <line32> Assert.assertNotNull(interceptorInfo); <line33> Assert.assertNotNull(interceptorInfo.getCdiInterceptors()); <line34> Assert.assertEquals(3, interceptorInfo.getCdiInterceptors().size()); <line35> Assert.assertEquals(0, interceptorInfo.getDecorators().size()); <line36> Map<Method, BusinessMethodInterceptorInfo> methodInterceptorInfos = <line37> new HashMap<Method, BusinessMethodInterceptorInfo>( <line38> interceptorInfo.getBusinessMethodsInfo()); <line39> Assert.assertNotNull(methodInterceptorInfos); <line40> Assert.assertEquals(8, methodInterceptorInfos.size()); <line41> Method methodWithEnhancedAction = <line42> ClassMultiInterceptedClass.class.getMethod(""methodWithEnhancedAction""); <line43> Assert.assertEquals( <line44> 2, methodInterceptorInfos.get(methodWithEnhancedAction).getCdiInterceptors().length); <line45> methodInterceptorInfos.remove(methodWithEnhancedAction); <line46> for (BusinessMethodInterceptorInfo mi : methodInterceptorInfos.values()) { <line47> Assert.assertEquals(3, mi.getCdiInterceptors().length); <line48> } <line49> Assert.assertEquals(2, interceptorInfo.getLifecycleMethodInterceptorInfos().size()); <line50> LifecycleMethodInfo lmiPostConstruct = <line51> interceptorInfo.getLifecycleMethodInterceptorInfos().get(InterceptionType.POST_CONSTRUCT); <line52> Assert.assertNotNull(lmiPostConstruct); <line53> Assert.assertNotNull(lmiPostConstruct.getMethodInterceptorInfo().getCdiInterceptors()); <line54> shutDownContainer(); <line55> } <line56> } <line57> "	"""calculating the interceptor info took ""+ TimeUnit.NANOSECONDS.toMillis(end - start)+ "" ms"""	task7	
public class A { <line0> public void setDefaults(final ActiveMQRAProperties prop) { <line1> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line2> ActiveMQRALogger.trace(UNKNOWN); <line3> } <line4> if (userName == null) { <line5> userName = prop.getUserName(); <line6> } <line7> if (password == null) { <line8> password = prop.getPassword(); <line9> } <line10> if (clientID == null) { <line11> clientID = prop.getClientID(); <line12> } <line13> } <line14> } <line15> 	"""setDefaults("" + prop + "")"""	task7	
public class A { <line0> private static InetAddress normalizeV6Address(Inet6Address address) { <line1> String addr = address.getHostAddress(); <line2> int i = addr.lastIndexOf('%'); <line3> if (i > 0) { <line4> try { <line5> return InetAddress.getByName(addr.substring(0, i) + '%' + address.getScopeId()); <line6> } catch (UnknownHostException e) { <line7> logger.debug(UNKNOWN); <line8> } <line9> } <line10> return address; <line11> } <line12> } <line13> 	"""Unknown IPV6 address: "", e"	task7	
"public class A { <line0> public void set(int seconds) { <line1> if (freeze.get() > 0) return; <line2> if (freeze.get() < 0) throw exception(""Timeout freeze broken""); <line3> current.set(seconds); <line4> logger.debug(UNKNOWN); <line5> } <line6> } <line7> "	"""Set timeout "" + seconds + "" seconds"""	task7	
"public class A { <line0> @Override <line1> public boolean isAcceptable(String protocol, String tlsProtocol, String tlsCipher) { <line2> boolean acceptable = <line3> ""h2-14"".equals(protocol) <line4> || !(HTTP2Cipher.isBlackListProtocol(tlsProtocol) <line5> && HTTP2Cipher.isBlackListCipher(tlsCipher)); <line6> if (LOG.isDebugEnabled()) <line7> LOG.debug( <line8> ""proto={} tls={} cipher={} 9.2.2-acceptable={}"", <line9> protocol, <line10> tlsProtocol, <line11> tlsCipher, <line12> acceptable); <line13> return acceptable; <line14> } <line15> } <line16> "	"""proto={} tls={} cipher={} 9.2.2-acceptable={}"",protocol,tlsProtocol,tlsCipher,acceptable"	task7	
public class A { <line0> @Override <line1> protected void download(Path tmp, URI baseUri, Artifact.Item item, Progress progress) <line2> throws IOException { <line3> String key = item.getUri(); <line4> logger.debug(UNKNOWN); <line5> GetObjectRequest req = GetObjectRequest.builder().bucket(bucket).key(key).build(); <line6> try (ResponseInputStream<GetObjectResponse> is = client.getObject(req)) { <line7> save(is, tmp, baseUri, item, progress); <line8> } <line9> } <line10> } <line11> 	"""Downloading artifact from: s3://{}/{} ..."", bucket, key"	task7	
"public class A { <line0> public static float getScalingFactor() { <line1> float scalingFactor = 1.0f; <line2> try { <line3> Class<?> retinaDetectorClass = Class.forName(""ro.sync.ui.hidpi.RetinaDetector""); <line4> Method getInstanceMethod = retinaDetectorClass.getMethod(""getInstance""); <line5> Object retinaDetectorObj = getInstanceMethod.invoke(null); <line6> Method getScalingFactorMethod = retinaDetectorClass.getMethod(""getScalingFactor""); <line7> scalingFactor = (float) getScalingFactorMethod.invoke(retinaDetectorObj); <line8> } catch (Exception e) { <line9> logger.debug(UNKNOWN); <line10> } <line11> return scalingFactor; <line12> } <line13> } <line14> "	e, e	task7	
public class A { <line0> public static String getSHA512Checksum(final File file) { <line1> try (final InputStream is = file.getInputStream()) { <line2> return DigestUtils.sha512Hex(is); <line3> } catch (final IOException ex) { <line4> logger.warn(UNKNOWN); <line5> } <line6> return null; <line7> } <line8> } <line9> 	"""Unable to calculate SHA-512 checksum of file represented by node "" + file, ex"	task7	
public class A { <line0> public static DLFolder addDLFolder( <line1> long groupId, long parentFolderId, boolean deleteExisting, ServiceContext serviceContext) <line2> throws Exception { <line3> String name = RandomTestUtil.randomString(); <line4> if (deleteExisting) { <line5> try { <line6> DLFolder folder = DLFolderLocalServiceUtil.getFolder(groupId, parentFolderId, name); <line7> DLFolderLocalServiceUtil.deleteFolder(folder.getFolderId()); <line8> } catch (NoSuchFolderException noSuchFolderException) { <line9> if (log.isDebugEnabled()) { <line10> log.debug(UNKNOWN); <line11> } <line12> } <line13> } <line14> return DLFolderLocalServiceUtil.addFolder( <line15> TestPropsValues.getUserId(), <line16> groupId, <line17> groupId, <line18> false, <line19> parentFolderId, <line20> name, <line21> StringPool.BLANK, <line22> false, <line23> serviceContext); <line24> } <line25> } <line26> 	noSuchFolderException, noSuchFolderException	task7	
public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> logger.error(UNKNOWN); <line3> ctx.channel().close(); <line4> } <line5> } <line6> 	"""exceptionCaught : {}"", cause.getMessage(), cause"	task7	
public class A { <line0> public static com.liferay.asset.kernel.model.AssetVocabularySoap[] getGroupVocabularies( <line1> long groupId) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> returnValue = <line4> AssetVocabularyServiceUtil.getGroupVocabularies(groupId); <line5> return com.liferay.asset.kernel.model.AssetVocabularySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> log.error(UNKNOWN); <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	exception, exception	task7	
public class A { <line0> public void error(String inWhat) { <line1> log.error(UNKNOWN); <line2> } <line3> } <line4> 	inWhat	task7	
public class A { <line0> private Object[] getParams(CxfEndpoint endpoint, Exchange exchange) <line1> throws org.apache.camel.InvalidPayloadException { <line2> Object[] params = null; <line3> if (endpoint.getDataFormat() == DataFormat.POJO) { <line4> Object body = exchange.getIn().getBody(); <line5> if (body == null) { <line6> return new Object[0]; <line7> } <line8> if (body instanceof Object[]) { <line9> params = (Object[]) body; <line10> } else if (body instanceof List) { <line11> params = ((List<?>) body).toArray(); <line12> } else { <line13> Iterator<?> it = exchange.getIn().getBody(Iterator.class); <line14> if (it != null && it.hasNext()) { <line15> List<?> list = exchange.getContext().getTypeConverter().convertTo(List.class, it); <line16> if (list != null) { <line17> params = list.toArray(); <line18> } <line19> } <line20> if (params == null) { <line21> params = new Object[1]; <line22> params[0] = exchange.getIn().getBody(); <line23> } <line24> } <line25> checkParameterSize(endpoint, exchange, params); <line26> } else if (endpoint.getDataFormat() == DataFormat.PAYLOAD) { <line27> params = new Object[1]; <line28> params[0] = exchange.getIn().getMandatoryBody(CxfPayload.class); <line29> } else if (endpoint.getDataFormat().dealias() == DataFormat.RAW) { <line30> params = new Object[1]; <line31> params[0] = exchange.getIn().getMandatoryBody(InputStream.class); <line32> } else if (endpoint.getDataFormat().dealias() == DataFormat.CXF_MESSAGE) { <line33> params = new Object[1]; <line34> params[0] = exchange.getIn().getBody(); <line35> } <line36> if (LOG.isTraceEnabled()) { <line37> if (params != null) { <line38> for (int i = 0; i < params.length; i++) { <line39> LOG.trace(UNKNOWN); <line40> } <line41> } <line42> } <line43> return params; <line44> } <line45> } <line46> 	"""params[{}] = {}"", i, params[i]"	task7	
public class A { <line0> static Map<String, ValidationMatcher> lookup() { <line1> if (matcher.isEmpty()) { <line2> matcher.putAll(new ResourcePathTypeResolver().resolveAll(RESOURCE_PATH)); <line3> if (LOG.isDebugEnabled()) { <line4> matcher.forEach( <line5> (k, v) -> <line6> LOG.debug(UNKNOWN); <line7> } <line8> } <line9> return matcher; <line10> } <line11> } <line12> 	"String.format(""Found validation matcher '%s' as %s"", k, v.getClass()))"	task7	
public class A { <line0> protected void checkAccess(boolean isRead, String entityId, EntityBody content) { <line1> LOG.trace(UNKNOWN); <line2> rightAccessValidator.checkSecurity(isRead, entityId, defn.getType(), collectionName, getRepo()); <line3> try { <line4> checkAccess(isRead, isSelf(entityId), content); <line5> } catch (APIAccessDeniedException e) { <line6> Set<String> entityIds = new HashSet<String>(); <line7> entityIds.add(entityId); <line8> e.setEntityType(defn.getType()); <line9> e.setEntityIds(entityIds); <line10> throw e; <line11> } <line12> } <line13> } <line14> 	""">>>BasicService.checkAccess()"""	task7	
"public class A { <line0> @Override <line1> public boolean addUsersToGroup(AuthzToken authzToken, List<String> userIds, String groupId) <line2> throws GroupManagerServiceException, AuthorizationException, TException { <line3> try { <line4> SharingRegistryService.Client sharingClient = getSharingRegistryServiceClient(); <line5> String userId = getUserId(authzToken); <line6> String domainId = getDomainId(authzToken); <line7> if (!(sharingClient.hasOwnerAccess(domainId, groupId, userId) <line8> || sharingClient.hasAdminAccess(domainId, groupId, userId))) { <line9> throw new GroupManagerServiceException( <line10> ""User does not have access to add users to the group""); <line11> } <line12> return internalAddUsersToGroup(sharingClient, domainId, userIds, groupId); <line13> } catch (Exception e) { <line14> String msg = ""Error adding users to group. Group ID: "" + groupId; <line15> logger.error(UNKNOWN); <line16> GroupManagerServiceException exception = new GroupManagerServiceException(); <line17> exception.setMessage(msg + "" More info : "" + e.getMessage()); <line18> throw exception; <line19> } <line20> } <line21> } <line22> "	msg, e	task7	
"public class A { <line0> @Override <line1> public RecordHandlingFlow getRecordHandler(PipeLineSession session, String record) <line2> throws Exception { <line3> String value = null; <line4> if (startPosition >= record.length()) { <line5> throw new Exception( <line6> ""Record size is smaller then the specified position of the recordtype within the record""); <line7> } <line8> if (endPosition < 0) { <line9> Map<String, RecordHandlingFlow> valueHandlersMap = getFlowMap(); <line10> RecordHandlingFlow rhf = null; <line11> for (String name : valueHandlersMap.keySet()) { <line12> if (log.isTraceEnabled()) <line13> log.trace( <line14> ""determining value for record ["" <line15> + record <line16> + ""] with key ["" <line17> + name <line18> + ""] and startPosition ["" <line19> + startPosition <line20> + ""]""); <line21> if (name.length() <= record.length()) { <line22> value = record.substring(startPosition, name.length()); <line23> if (value.equals(name) && (rhf = valueHandlersMap.get(name)) != null) { <line24> break; <line25> } <line26> } <line27> } <line28> if (rhf == null) { <line29> rhf = getFlowMap().get(""*""); <line30> if (rhf == null) { <line31> throw new Exception(""No handlers (flow) found for recordKey ["" + value + ""]""); <line32> } <line33> } <line34> return rhf; <line35> } <line36> if (endPosition >= record.length()) { <line37> value = record.substring(startPosition); <line38> } else { <line39> value = record.substring(startPosition, endPosition); <line40> } <line41> return super.getRecordHandlerByKey(value); <line42> } <line43> } <line44> "	"""determining value for record [""+ record+ ""] with key [""+ name+ ""] and startPosition [""+ startPosition+ ""]"""	task7	
public class A { <line0> @Override <line1> public Account addAccount( <line2> String address, <line3> String personalName, <line4> String protocol, <line5> String incomingHostName, <line6> int incomingPort, <line7> boolean incomingSecure, <line8> String outgoingHostName, <line9> int outgoingPort, <line10> boolean outgoingSecure, <line11> String login, <line12> String password, <line13> boolean savePassword, <line14> String signature, <line15> boolean useSignature, <line16> String folderPrefix, <line17> boolean defaultSender) <line18> throws PortalException { <line19> validateAccount( <line20> incomingHostName, <line21> incomingPort, <line22> incomingSecure, <line23> outgoingHostName, <line24> outgoingPort, <line25> outgoingSecure, <line26> login, <line27> password); <line28> try { <line29> AccountLocalServiceUtil.getAccount(user.getUserId(), address); <line30> throw new MailException(MailException.ACCOUNT_ALREADY_EXISTS); <line31> } catch (NoSuchAccountException noSuchAccountException) { <line32> if (log.isDebugEnabled()) { <line33> log.debug(UNKNOWN); <line34> } <line35> long inboxFolderId = 0; <line36> long draftFolderId = 0; <line37> long sentFolderId = 0; <line38> long trashFolderId = 0; <line39> return AccountLocalServiceUtil.addAccount( <line40> user.getUserId(), <line41> address, <line42> personalName, <line43> protocol, <line44> incomingHostName, <line45> incomingPort, <line46> incomingSecure, <line47> outgoingHostName, <line48> outgoingPort, <line49> outgoingSecure, <line50> login, <line51> password, <line52> savePassword, <line53> signature, <line54> useSignature, <line55> folderPrefix, <line56> inboxFolderId, <line57> draftFolderId, <line58> sentFolderId, <line59> trashFolderId, <line60> defaultSender); <line61> } <line62> } <line63> } <line64> 	noSuchAccountException, noSuchAccountException	task7	
"public class A { <line0> @RequestMapping(""${uri.path.page}/atom/{identifier}/c"") <line1> public String showConnectionURIListPage( <line2> @PathVariable String identifier, <line3> @RequestParam(value = ""p"", required = false) Integer page, <line4> @RequestParam(value = ""deep"", defaultValue = ""false"") boolean deep, <line5> @RequestParam(value = ""resumebefore"", required = false) String resumeBefore, <line6> @RequestParam(value = ""resumeafter"", required = false) String resumeAfter, <line7> @RequestParam(value = ""type"", required = false) String type, <line8> @RequestParam(value = ""timeof"", required = false) String timestamp, <line9> @RequestParam(value = ""state"", required = false) String state, <line10> HttpServletRequest request, <line11> Model model, <line12> HttpServletResponse response) { <line13> URI atomURI = uriService.createAtomURIForId(identifier); <line14> try { <line15> ConnectionState connectionState = getConnectionState(state); <line16> DateParameter dateParam = new DateParameter(timestamp); <line17> WonMessageType eventsType = getMessageType(type); <line18> Dataset rdfDataset; <line19> if (page != null) { <line20> rdfDataset = <line21> linkedDataService <line22> .listConnections( <line23> page, <line24> atomURI, <line25> null, <line26> eventsType, <line27> dateParam.getDate(), <line28> deep, <line29> true, <line30> connectionState) <line31> .getContent(); <line32> } else if (resumeBefore != null) { <line33> URI connURI; <line34> try { <line35> connURI = new URI(resumeBefore); <line36> } catch (URISyntaxException e) { <line37> throw new IllegalArgumentException(""resumeBefore must be a full, valid connection URI""); <line38> } <line39> rdfDataset = <line40> linkedDataService <line41> .listConnectionsAfter( <line42> atomURI, <line43> connURI, <line44> null, <line45> eventsType, <line46> dateParam.getDate(), <line47> deep, <line48> true, <line49> connectionState) <line50> .getContent(); <line51> } else if (resumeAfter != null) { <line52> URI connURI; <line53> try { <line54> connURI = new URI(resumeAfter); <line55> } catch (URISyntaxException e) { <line56> throw new IllegalArgumentException(""resumeAfter must be a full, valid connection URI""); <line57> } <line58> rdfDataset = <line59> linkedDataService <line60> .listConnectionsBefore( <line61> atomURI, <line62> connURI, <line63> null, <line64> eventsType, <line65> dateParam.getDate(), <line66> deep, <line67> true, <line68> connectionState) <line69> .getContent(); <line70> } else { <line71> rdfDataset = <line72> linkedDataService.listConnections(atomURI, deep, true, connectionState).getContent(); <line73> } <line74> model.addAttribute(""rdfDataset"", rdfDataset); <line75> model.addAttribute( <line76> ""resourceURI"", <line77> uriService.toResourceURIIfPossible(URI.create(request.getRequestURI())).toString()); <line78> model.addAttribute( <line79> ""dataURI"", <line80> uriService.toDataURIIfPossible(URI.create(request.getRequestURI())).toString()); <line81> return ""rdfDatasetView""; <line82> } catch (ParseException e) { <line83> model.addAttribute(""error"", ""could not parse timestamp parameter""); <line84> return ""notFoundView""; <line85> } catch (NoSuchAtomException e) { <line86> response.setStatus(HttpServletResponse.SC_NOT_FOUND); <line87> return ""notFoundView""; <line88> } catch (NoSuchConnectionException e) { <line89> logger.warn( <line90> ""did not find connection that should be connected to atom. connection:{}"", <line91> e.getUnknownConnectionURI()); <line92> return ""notFoundView""; <line93> } <line94> } <line95> } <line96> "	"""did not find connection that should be connected to atom. connection:{}"",e.getUnknownConnectionURI()"	task7	
"public class A { <line0> public static com.liferay.marketplace.model.App updateApp( <line1> HttpPrincipal httpPrincipal, java.io.File file) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(AppServiceUtil.class, ""updateApp"", _updateAppParameterTypes3); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, file); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (com.liferay.marketplace.model.App) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> log.error(UNKNOWN); <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	systemException, systemException	task7	
"public class A { <line0> public List<DownloadFile> download() throws IOException, InterruptedException { <line1> logger.info(UNKNOWN); <line2> List<DownloadFile> downloadFiles = new ArrayList<>(); <line3> Path oboFolder = downloadFolder.resolve(""ontology""); <line4> Files.createDirectories(oboFolder); <line5> String url = configuration.getDownload().getHpoObo().getHost(); <line6> downloadFiles.add(downloadFile(url, oboFolder.resolve(""hp.obo"").toString())); <line7> saveVersionData( <line8> EtlCommons.OBO_DATA, <line9> ""HPO"", <line10> getTimeStamp(), <line11> getTimeStamp(), <line12> Collections.singletonList(url), <line13> buildFolder.resolve(EtlCommons.HPO_VERSION_FILE)); <line14> url = configuration.getDownload().getGoObo().getHost(); <line15> downloadFiles.add(downloadFile(url, oboFolder.resolve(""go-basic.obo"").toString())); <line16> saveVersionData( <line17> EtlCommons.OBO_DATA, <line18> ""GO"", <line19> getTimeStamp(), <line20> getTimeStamp(), <line21> Collections.singletonList(url), <line22> buildFolder.resolve(EtlCommons.GO_VERSION_FILE)); <line23> url = configuration.getDownload().getDoidObo().getHost(); <line24> downloadFiles.add(downloadFile(url, oboFolder.resolve(""doid.obo"").toString())); <line25> saveVersionData( <line26> EtlCommons.OBO_DATA, <line27> ""DO"", <line28> getTimeStamp(), <line29> getTimeStamp(), <line30> Collections.singletonList(url), <line31> buildFolder.resolve(EtlCommons.DO_VERSION_FILE)); <line32> return downloadFiles; <line33> } <line34> } <line35> "	"""Downloading obo files ..."""	task7	
"public class A { <line0> @Override <line1> public void writeTo(final Packer pk) throws IOException { <line2> if (pk == null) { <line3> throw new IllegalArgumentException(""packer is null""); <line4> } <line5> try { <line6> pk.writeMapBegin(3); <line7> doWriteTo(pk); <line8> } catch (IOException ex) { <line9> log.error(UNKNOWN); <line10> throw ex; <line11> } finally { <line12> pk.writeMapEnd(); <line13> } <line14> } <line15> } <line16> "	"""fail to write packer"", ex"	task7	
"public class A { <line0> protected void insertGuiFragment(GuiFragment guiFragment, Connection conn) { <line1> PreparedStatement stat = null; <line2> try { <line3> stat = conn.prepareStatement(ADD_GUIFRAGMENT); <line4> int index = 1; <line5> stat.setString(index++, guiFragment.getCode()); <line6> if (StringUtils.isNotBlank(guiFragment.getWidgetTypeCode())) { <line7> stat.setString(index++, guiFragment.getWidgetTypeCode()); <line8> } else { <line9> stat.setNull(index++, Types.VARCHAR); <line10> } <line11> if (StringUtils.isNotBlank(guiFragment.getPluginCode())) { <line12> stat.setString(index++, guiFragment.getPluginCode()); <line13> } else { <line14> stat.setNull(index++, Types.VARCHAR); <line15> } <line16> stat.setString(index++, guiFragment.getGui()); <line17> stat.setInt(index++, 0); <line18> stat.executeUpdate(); <line19> } catch (Throwable t) { <line20> logger.error(UNKNOWN); <line21> throw new RuntimeException(""Error on insert guiFragment"", t); <line22> } finally { <line23> this.closeDaoResources(null, stat); <line24> } <line25> } <line26> } <line27> "	"""Error on insert guiFragment"", t"	task7	
"public class A { <line0> @Override <line1> public void grantFunctionPrivileges( <line2> String schemaName, String functionName, Collection<Privilege> privileges, String toUser) { <line3> final String objectName = DataDefinitionUtil.getQualifiedName(schemaName, functionName); <line4> DataDefinitionUtil.assertValidName(toUser); <line5> final String privs = privilegeString(privileges); <line6> final String grant = ""GRANT "" + privs + "" ON FUNCTION "" + objectName + "" TO "" + toUser; <line7> logger.info(UNKNOWN); <line8> runStatement(grant); <line9> } <line10> } <line11> "	"""Applying: "" + grant"	task7	
public class A { <line0> private void logReceivedParameters() { <line1> if (this.numberOfWorkers <= 0) { <line2> LOG.warn(UNKNOWN); <line3> } <line4> } <line5> } <line6> 	"""Received number of workers: {}"", this.numberOfWorkers"	task7	
"public class A { <line0> private void logToolRefresh(final String dashboardPrefix, final Tool tool) { <line1> List<String> descriptorTypes = tool.getDescriptorType(); <line2> String name = tool.getEntryPath(); <line3> for (String descriptorType : descriptorTypes) { <line4> LOG.info( <line5> String.format(""%s: Refreshing %s tool named %s"", dashboardPrefix, descriptorType, name)); <line6> } <line7> } <line8> } <line9> "	"String.format(""%s: Refreshing %s tool named %s"", dashboardPrefix, descriptorType, name)"	task7	
"public class A { <line0> @Override <line1> public void init(Properties props) throws SystemException { <line2> if (props == null) { <line3> props = new Properties(); <line4> } <line5> final String dir = props.getProperty(EnvProps.IM_PASSIVATOR_PATH_PREFIX); <line6> try { <line7> if (dir != null) { <line8> sessionDirectory = SystemInstance.get().getBase().getDirectory(dir).getAbsoluteFile(); <line9> } else { <line10> sessionDirectory = <line11> new File( <line12> JavaSecurityManagers.getSystemProperty( <line13> ""java.io.tmpdir"", File.separator + ""tmp"")) <line14> .getAbsoluteFile(); <line15> } <line16> if (!sessionDirectory.exists() && !sessionDirectory.mkdirs()) { <line17> throw new IOException(""Failed to create directory: "" + sessionDirectory.getAbsolutePath()); <line18> } <line19> logger.info(UNKNOWN); <line20> } catch (final IOException e) { <line21> throw new SystemException( <line22> getClass().getName() + "".init(): can't use directory prefix "" + dir + "":"" + e, e); <line23> } <line24> } <line25> } <line26> "	"""Using directory "" + sessionDirectory + "" for stateful session passivation"""	task7	
"public class A { <line0> @PluginFactory <line1> public static SendAppender createAppender( <line2> @PluginAttribute(""name"") String name, <line3> @PluginElement(""Filter"") final Filter filter, <line4> @PluginElement(""Layout"") Layout<? extends Serializable> layout, <line5> @PluginAttribute(""ignoreExceptions"") boolean ignoreExceptions) { <line6> if (name == null) { <line7> LOGGER.error(UNKNOWN); <line8> return null; <line9> } <line10> if (layout == null) { <line11> layout = PatternLayout.createDefaultLayout(); <line12> } <line13> return new SendAppender(name, filter, layout, ignoreExceptions); <line14> } <line15> } <line16> "	"""No name provided for SendAppender"""	task7	
"public class A { <line0> public static MCRDirectory importFiles(File local, String ownerID) { <line1> if (Objects.requireNonNull(ownerID, ""owner ID"" + "" is null"").trim().isEmpty()) { <line2> throw new MCRUsageException(""owner ID"" + "" is an empty String""); <line3> } <line4> MCRDirectory dir = new MCRDirectory(ownerID); <line5> try { <line6> importFiles(local, dir); <line7> } catch (Exception ex) { <line8> try { <line9> dir.delete(); <line10> } catch (Exception ignored) { <line11> LOGGER.error(UNKNOWN); <line12> } <line13> if (ex instanceof RuntimeException) { <line14> throw (RuntimeException) ex; <line15> } <line16> throw new MCRException(ex); <line17> } <line18> return dir; <line19> } <line20> } <line21> "	"""Exception while deleting MCRDirectory for derivate: {}"", ownerID, ignored"	task7	
public class A { <line0> @Override <line1> public void run() { <line2> while (true) { <line3> State current = state.get(); <line4> LOG.isDebugEnabled(UNKNOWN); <line5> switch (current) { <line6> case DISPATCH: <line7> { <line8> if (state.compareAndSet(current, State.EXECUTE)) runnable.run(); <line9> continue; <line10> } <line11> case EXECUTE: <line12> { <line13> if (state.compareAndSet(current, State.IDLE)) return; <line14> continue; <line15> } <line16> case SCHEDULE: <line17> { <line18> if (state.compareAndSet(current, State.DISPATCH)) continue; <line19> throw new IllegalStateException(); <line20> } <line21> default: <line22> { <line23> throw new IllegalStateException(); <line24> } <line25> } <line26> } <line27> } <line28> } <line29> 	"""Running, state={}"", current"	task7	
public class A { <line0> @Override <line1> protected void doneWithContext() { <line2> if (!isCancelled()) { <line3> try { <line4> m_statusMessageConsumer.accept(get()); <line5> } catch (final ExecutionException e) { <line6> if (!(e.getCause() instanceof InterruptedException)) { <line7> LOGGER.debug(UNKNOWN); <line8> } <line9> } catch (InterruptedException ex) { <line10> } <line11> } <line12> } <line13> } <line14> 	e.getMessage(), e	task7	
"public class A { <line0> @Test <line1> public void testConversionRuleSupportInPatternLayout() throws JoranException { <line2> configure(ClassicTestConstants.JORAN_INPUT_PREFIX + ""conversionRule/patternLayout0.xml""); <line3> root.getAppender(""LIST""); <line4> String msg = ""Simon says""; <line5> logger.debug(UNKNOWN); <line6> StringListAppender<ILoggingEvent> sla = <line7> (StringListAppender<ILoggingEvent>) root.getAppender(""LIST""); <line8> assertNotNull(sla); <line9> assertEquals(1, sla.strList.size()); <line10> assertEquals(SampleConverter.SAMPLE_STR + "" - "" + msg, sla.strList.get(0)); <line11> } <line12> } <line13> "	msg	task7	
public class A { <line0> @Override <line1> protected String encodeAndEncrypt(MethodCallMessage secureRequest, SecretKey sessionKey) <line2> throws Exception { <line3> byte[] content = mapper.writeValueAsBytes(secureRequest); <line4> LOGGER.info(UNKNOWN); <line5> byte[] encryptedContent = CipherUtils.encrypt(content, sessionKey); <line6> EncryptedMessage encryptedMessage = new EncryptedMessage(); <line7> encryptedMessage.setEncryptedContent(encryptedContent); <line8> byte[] encryptedKey = CipherUtils.encrypt(sessionKey.getEncoded(), serverPublicKey); <line9> encryptedMessage.setEncryptedKey(encryptedKey); <line10> return mapper.writeValueAsString(encryptedMessage); <line11> } <line12> } <line13> 	"""encrypting: "" + new String(content)"	task7	
"public class A { <line0> @Override <line1> public void writeTileMap(String layerId, String styleRef, ProfileType profile, Writer writer) <line2> throws GeomajasException { <line3> TileMap tileMap = new TileMap(); <line4> tileMap.setTitle(layerId); <line5> tileMap.setAbstract(""Tile Map Service publication of the Geomajas layer "" + layerId); <line6> tileMap.setVersion(""1.0.0""); <line7> StringBuilder sb = new StringBuilder(dispatcherUrlService.getDispatcherUrl()); <line8> sb.append(MAPPING_1_0_0.substring(0, MAPPING_1_0_0.length() - 1)); <line9> tileMap.setTileMapService(sb.toString()); <line10> TmsProfile p = null; <line11> VectorLayer layer = configurationService.getVectorLayer(layerId); <line12> StringBuilder href = new StringBuilder(dispatcherUrlService.getDispatcherUrl()); <line13> href.append(MAPPING_1_0_0).append(layerId); <line14> switch (profile) { <line15> case GLOBAL_GEODETIC: <line16> href.append(""@"").append(profile.getCrs()); <line17> tileMap.setSrs(profile.getCrs()); <line18> p = new GlobalGeodeticProfile(); <line19> break; <line20> case GLOBAL_MERCATOR: <line21> href.append(""@"").append(profile.getCrs()); <line22> tileMap.setSrs(profile.getCrs()); <line23> p = new GlobalMercatorProfile(); <line24> break; <line25> case LOCAL: <line26> default: <line27> href.append(""@"").append(layer.getLayerInfo().getCrs()); <line28> tileMap.setSrs(layer.getLayerInfo().getCrs()); <line29> Bbox layerBounds = layer.getLayerInfo().getMaxExtent(); <line30> p = <line31> new LocalProfile( <line32> dtoConverterService.toInternal(layerBounds), TmsController.PROFILE_TILE_SIZE); <line33> break; <line34> } <line35> href.append(""/"").append(layer.getLayerInfo().getNamedStyleInfos().get(0).getName()); <line36> tileMap.setBoundingBox(p.getBounds()); <line37> tileMap.setOrigin(p.getOrigin()); <line38> TileFormat tileFormat = new TileFormat(); <line39> tileFormat.setMimeType(""image/png""); <line40> tileFormat.setExtension(""png""); <line41> tileFormat.setWidth(p.getTileWidth()); <line42> tileFormat.setHeight(p.getTileHeight()); <line43> tileMap.setTileFormat(tileFormat); <line44> tileMap.setProfile(p, href.toString()); <line45> try { <line46> JAXBContext context = JAXBContext.newInstance(TileMap.class); <line47> Marshaller m = context.createMarshaller(); <line48> m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); <line49> m.marshal(tileMap, writer); <line50> } catch (JAXBException e) { <line51> log.error(UNKNOWN); <line52> } <line53> } <line54> } <line55> "	"""Could not instantiate jaxb"", e"	task7	
public class A { <line0> @Override <line1> public boolean supports(Class<?> c) { <line2> log.debug(UNKNOWN); <line3> return Field.class.isAssignableFrom(c); <line4> } <line5> } <line6> 	"""{}.supports: {}"", this.getClass().getName(), c.getName()"	task7	
"public class A { <line0> @GET <line1> @Path(""/photos/{UID}/{ConnectorPrettyName}.{ObjectTypeName}/{unixTime}/{count}"") <line2> @ApiOperation(value = ""Get photos at a given time"", response = PhotoItem.class) <line3> @ApiResponses({@ApiResponse(code = 403, message = ""In case of unauthorized access"")}) <line4> @Produces({MediaType.APPLICATION_JSON}) <line5> public Response getPhotosBeforeOrAfterTime( <line6> @ApiParam(value = ""User ID"", required = true) @PathParam(""UID"") long uid, <line7> @ApiParam(value = ""Connector name"", required = true) @PathParam(""ConnectorPrettyName"") <line8> String connectorPrettyName, <line9> @ApiParam(value = ""Object type name"", required = true) @PathParam(""ObjectTypeName"") <line10> String objectTypeName, <line11> @ApiParam(value = ""Timestamp (epoch seconds)"", required = true) @PathParam(""unixTime"") <line12> double unixTimeInSecs, <line13> @ApiParam(value = ""Photo count limit"", required = true) @PathParam(""count"") int desiredCount, <line14> @ApiParam(value = ""Is before time"", required = true) @QueryParam(""isBefore"") <line15> boolean isGetPhotosBeforeTime, <line16> @ApiParam(value = ""Tags for matching"", required = true) @QueryParam(""tags"") String tagsStr, <line17> @ApiParam(value = ""Tag matching strategy"", required = true) @QueryParam(""tag-match"") <line18> String tagMatchingStrategyName) { <line19> try { <line20> final TagFilter.FilteringStrategy tagFilteringStrategy = <line21> TagFilter.FilteringStrategy.findByName(tagMatchingStrategyName); <line22> if (isUnauthorized(uid)) { <line23> return Response.status(Response.Status.UNAUTHORIZED) <line24> .entity(""Invalid User ID (null)"") <line25> .build(); <line26> } <line27> final TagFilter tagFilter = <line28> TagFilter.create( <line29> Tag.parseTagsIntoStrings(tagsStr, Tag.COMMA_DELIMITER), tagFilteringStrategy); <line30> final SortedSet<PhotoService.Photo> photos = <line31> photoService.getPhotos( <line32> uid, <line33> (long) (unixTimeInSecs * 1000), <line34> connectorPrettyName, <line35> objectTypeName, <line36> desiredCount, <line37> isGetPhotosBeforeTime, <line38> tagFilter); <line39> final List<PhotoItem> photoItems = new ArrayList<PhotoItem>(); <line40> for (final PhotoService.Photo photo : photos) { <line41> photoItems.add(new PhotoItem(photo)); <line42> } <line43> return Response.ok(gson.toJson(photoItems)).build(); <line44> } catch (Exception e) { <line45> LOG.error( <line46> ""BodyTrackController.getPhotosBeforeOrAfterTime(): Exception while trying to fetch log"" <line47> + "" items: "", <line48> e); <line49> return Response.status(Response.Status.UNAUTHORIZED).entity(""Access Denied"").build(); <line50> } <line51> } <line52> } <line53> "	"""BodyTrackController.getPhotosBeforeOrAfterTime(): Exception while trying to fetch log""+ "" items: "",e"	task7	
"public class A { <line0> private void sendInvalidCredentials( <line1> LdapSession ldapSession, BindResponse bindResponse, Exception e) { <line2> LdapResult result = bindResponse.getLdapResult(); <line3> String message = """"; <line4> if (e != null) { <line5> message = ResultCodeEnum.INVALID_CREDENTIALS + "": "" + e.getLocalizedMessage(); <line6> } else { <line7> message = ResultCodeEnum.INVALID_CREDENTIALS.toString(); <line8> } <line9> LOG.error(UNKNOWN); <line10> result.setResultCode(ResultCodeEnum.INVALID_CREDENTIALS); <line11> result.setDiagnosticMessage(message); <line12> ldapSession.clearSaslProperties(); <line13> ldapSession.setAnonymous(); <line14> ldapSession.getIoSession().write(bindResponse); <line15> } <line16> } <line17> "	message	task7	
"public class A { <line0> private void stopComponents( <line1> final String processGroupId, <line2> final Map<String, Revision> componentRevisions, <line3> final Map<String, AffectedComponentEntity> affectedComponents, <line4> final Pause pause, <line5> final InvalidComponentAction invalidComponentAction) <line6> throws LifecycleManagementException { <line7> if (componentRevisions.isEmpty()) { <line8> return; <line9> } <line10> logger.debug( <line11> ""Stopping components with ID's {} from Process Group {}"", <line12> componentRevisions.keySet(), <line13> processGroupId); <line14> serviceFacade.verifyScheduleComponents( <line15> processGroupId, ScheduledState.STOPPED, componentRevisions.keySet()); <line16> serviceFacade.scheduleComponents(processGroupId, ScheduledState.STOPPED, componentRevisions); <line17> waitForProcessorState( <line18> processGroupId, affectedComponents, ScheduledState.STOPPED, pause, invalidComponentAction); <line19> } <line20> } <line21> "	"""Stopping components with ID's {} from Process Group {}"",componentRevisions.keySet(),processGroupId"	task7	
public class A { <line0> @Override <line1> public void invalidateCache( <line2> TenantKey key, final Object cookie, final InternalTenantContext tenantContext) { <line3> log.info(UNKNOWN); <line4> catalogCache.clearCatalog(tenantContext); <line5> } <line6> } <line7> 	"""Invalidate catalog cache for tenantRecordId='{}'"", tenantContext.getTenantRecordId()"	task7	
"public class A { <line0> private void logFormatUsage() { <line1> StringBuilder builder = new StringBuilder(); <line2> for (NavigationFormat format : getNavigationFormatRegistry().getFormatsSortedByName()) { <line3> int reads = preferences.getInt(READ_COUNT_PREFERENCE + format.getClass().getName(), 0); <line4> int writes = preferences.getInt(WRITE_COUNT_PREFERENCE + format.getClass().getName(), 0); <line5> if (reads > 0 || writes > 0) <line6> builder.append(format(""%n%s, reads: %d, writes: %d"", format.getName(), reads, writes)); <line7> } <line8> log.info(UNKNOWN); <line9> } <line10> } <line11> "	"""Format usage:"" + builder.toString()"	task7	
public class A { <line0> private String[] resolvePlaceholders(String value) { <line1> String resolved = resolver.resolvePlaceholders(value); <line2> if (StringUtils.isBlank(resolved)) { <line3> ConfigLog.debug(UNKNOWN); <line4> return StringUtils.EMPTY_STRING_ARRAY; <line5> } <line6> return StringUtils.split(resolved, ','); <line7> } <line8> } <line9> 	"""!       Empty: '{}'"", value"	task7	
public class A { <line0> public Command<T[]> command() { <line1> Command<T[]> command = getCommand(); <line2> command <line3> .future() <line4> .addListener( <line5> new CommandFutureListener<T[]>() { <line6> @Override <line7> public void operationComplete(CommandFuture<T[]> commandFuture) { <line8> if (!commandFuture.isSuccess()) { <line9> logger.error(UNKNOWN); <line10> return; <line11> } <line12> updateRelevantField(commandFuture.getNow()); <line13> } <line14> }); <line15> return command; <line16> } <line17> } <line18> 	"""[update][{}]"", getClass().getSimpleName(), commandFuture.cause()"	task7	
public class A { <line0> @Override <line1> public void postStop() throws Exception { <line2> LOG.debug(UNKNOWN); <line3> super.postStop(); <line4> for (AkkaRpcActorRegistration actorRegistration : registeredAkkaRpcActors.values()) { <line5> terminateAkkaRpcActorOnStop(actorRegistration); <line6> } <line7> registeredAkkaRpcActors.clear(); <line8> } <line9> } <line10> 	"""Stopping supervisor actor."""	task7	
public class A { <line0> @Override <line1> public void queueApplicableAutoPings(WeblogEntry changedWeblogEntry) throws WebloggerException { <line2> if (PingConfig.getSuspendPingProcessing()) { <line3> if (logger.isDebugEnabled()) { <line4> logger.debug(UNKNOWN); <line5> } <line6> return; <line7> } <line8> PingQueueManager pingQueueMgr = roller.getPingQueueManager(); <line9> List<AutoPing> applicableAutopings = getApplicableAutoPings(changedWeblogEntry); <line10> for (AutoPing autoPing : applicableAutopings) { <line11> pingQueueMgr.addQueueEntry(autoPing); <line12> } <line13> } <line14> } <line15> 	"""Ping processing is suspended."" + "" No auto pings will be queued."""	task7	
public class A { <line0> @Override <line1> public void info(String message) { <line2> if (verbose) { <line3> log.info(UNKNOWN); <line4> } <line5> } <line6> } <line7> 	message	task7	
"public class A { <line0> public String formatMessage(final String commitMessage) { <line1> final ServletContext servletContext = pageContext.getServletContext(); <line2> final WebApplicationContext context = <line3> WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); <line4> try { <line5> final Map<String, CommitMessageDisplayFormatter> formatterBeans = <line6> BeanFactoryUtils.beansOfTypeIncludingAncestors( <line7> context, CommitMessageDisplayFormatter.class); <line8> if (formatterBeans.size() == 0) { <line9> return StringEscapeUtils.escapeHtml4(commitMessage); <line10> } else if (formatterBeans.size() == 1) { <line11> CommitMessageDisplayFormatter formatter = <line12> (CommitMessageDisplayFormatter) formatterBeans.values().toArray()[0]; <line13> return formatter.formatMessage(commitMessage); <line14> } else { <line15> throw new IllegalArgumentException( <line16> ""Multiple beans of type "" <line17> + CommitMessageDisplayFormatter.class.getSimpleName() <line18> + "" found, expected 0 or 1.""); <line19> } <line20> } catch (Exception e) { <line21> LOGGER.error(UNKNOWN); <line22> return commitMessage; <line23> } <line24> } <line25> } <line26> "	"""An error occurred when formatting commit message."", e"	task7	
public class A { <line0> @Override <line1> public boolean isVisible(Group group) { <line2> if (group.isCompany()) { <line3> return false; <line4> } <line5> boolean hasCustomAttributesAvailable = false; <line6> try { <line7> hasCustomAttributesAvailable = <line8> CustomAttributesUtil.hasCustomAttributes( <line9> group.getCompanyId(), Group.class.getName(), group.getGroupId(), null); <line10> } catch (Exception exception) { <line11> if (log.isDebugEnabled()) { <line12> log.debug(UNKNOWN); <line13> } <line14> } <line15> if (!hasCustomAttributesAvailable) { <line16> return false; <line17> } <line18> return true; <line19> } <line20> } <line21> 	exception, exception	task7	
"public class A { <line0> @Override <line1> public void resetPassword(String newPassword, Integer secretPin) { <line2> log.info( <line3> ""Invoked effector from resetPassword with params {} {}"", <line4> new Object[] {newPassword, secretPin}); <line5> assert newPassword != null; <line6> } <line7> } <line8> "	"""Invoked effector from resetPassword with params {} {}"",new Object[] {newPassword, secretPin}"	task7	
public class A { <line0> @Override <line1> public void onActivityTestRequest(ActivityTestRequest ind) { <line2> this.debug(UNKNOWN); <line3> TestEvent te = TestEvent.createReceivedEvent(EventType.ActivityTestRequest, ind, sequence++); <line4> this.observerdEvents.add(te); <line5> } <line6> } <line7> 	"""ActivityTestRequest"""	task7	
"public class A { <line0> @Override <line1> protected void addPersistedPage(String sessionIdentifier, IManageablePage page) { <line2> if (page instanceof SerializedPage == false) { <line3> throw new WicketRuntimeException(""MemcachedDataStore works with serialized pages only""); <line4> } <line5> SerializedPage serializedPage = (SerializedPage) page; <line6> int expirationTime = settings.getExpirationTime(); <line7> MemcachedSet pages = <line8> new MemcachedSet(client, makeKey(sessionIdentifier, SESSION_PAGES), expirationTime); <line9> if (pages.add(String.valueOf(page.getPageId()))) { <line10> MemcachedSet sessions = <line11> new MemcachedSet(client, makeKey(SESSIONS), settings.getExpirationTime()); <line12> sessions.add(sessionIdentifier); <line13> sessions.compact(); <line14> } <line15> client.set( <line16> makeKey(sessionIdentifier, serializedPage.getPageId(), PAGE_DATA), <line17> expirationTime, <line18> serializedPage.getData()); <line19> client.set( <line20> makeKey(sessionIdentifier, serializedPage.getPageId(), PAGE_SIZE), <line21> expirationTime, <line22> serializedPage.getData().length); <line23> if (serializedPage.getPageType() != null) { <line24> client.set( <line25> makeKey(sessionIdentifier, serializedPage.getPageId(), PAGE_TYPE), <line26> expirationTime, <line27> serializedPage.getPageType()); <line28> } <line29> pages.compact(pageId -> client.get(makeKey(sessionIdentifier, pageId, PAGE_SIZE)) != null); <line30> LOG.debug(UNKNOWN); <line31> } <line32> } <line33> "	"""Stored data for session '{}' and page id '{}'"", sessionIdentifier, page.getPageId()"	task7	
"public class A { <line0> public <T extends SvBusResponse> T get(long timeoutMs) throws SocketTimeoutException { <line1> try { <line2> if (!latch.await(timeoutMs, TimeUnit.MILLISECONDS)) { <line3> throw new SocketTimeoutException( <line4> ""WebSocket response wait timeout ("" + timeoutMs + ""ms) exceeded""); <line5> } <line6> } catch (InterruptedException ex) { <line7> log.debug(UNKNOWN); <line8> Thread.currentThread().interrupt(); <line9> } <line10> return (T) response; <line11> } <line12> } <line13> "	"""Interruptrd exception while waiting for response"", ex"	task7	
"public class A { <line0> @Then(""^the get tariff status async response contains$"") <line1> public void theGetTariffStatusAsyncResponseContains( <line2> final Map<String, String> expectedResponseData) { <line3> final org.opensmartgridplatform.adapter.ws.schema.tariffswitching.adhocmanagement <line4> .GetStatusAsyncResponse <line5> asyncResponse = <line6> (org.opensmartgridplatform.adapter.ws.schema.tariffswitching.adhocmanagement <line7> .GetStatusAsyncResponse) <line8> ScenarioContext.current().get(PlatformPubliclightingKeys.RESPONSE); <line9> assertThat(asyncResponse.getAsyncResponse().getCorrelationUid()).isNotNull(); <line10> assertThat(asyncResponse.getAsyncResponse().getDeviceId()) <line11> .isEqualTo( <line12> getString(expectedResponseData, PlatformPubliclightingKeys.KEY_DEVICE_IDENTIFICATION)); <line13> saveCorrelationUidInScenarioContext( <line14> asyncResponse.getAsyncResponse().getCorrelationUid(), <line15> getString( <line16> expectedResponseData, <line17> PlatformPubliclightingKeys.KEY_ORGANIZATION_IDENTIFICATION, <line18> PlatformPubliclightingDefaults.DEFAULT_ORGANIZATION_IDENTIFICATION)); <line19> LOGGER.info( <line20> ""Got CorrelationUid: ["" <line21> + ScenarioContext.current().get(PlatformPubliclightingKeys.KEY_CORRELATION_UID) <line22> + ""]""); <line23> } <line24> } <line25> "	"""Got CorrelationUid: [""+ ScenarioContext.current().get(PlatformPubliclightingKeys.KEY_CORRELATION_UID)+ ""]"""	task7	
"public class A { <line0> @Override <line1> public XSIElementHandler getHandler(String namespaceURI, String localName) throws SAXException { <line2> if (SchemaHandler.namespaceURI.equalsIgnoreCase(namespaceURI)) { <line3> logger.fine(""Getting Handler for "" + localName + "" inside Extension""); <line4> if (AllHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line5> AllHandler ah = new AllHandler(); <line6> if (child == null) { <line7> child = ah; <line8> } else { <line9> throw new SAXNotRecognizedException( <line10> getLocalName() + "" may only have one '"" + AllHandler.LOCALNAME + ""' declaration.""); <line11> } <line12> return ah; <line13> } <line14> if (AttributeHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line15> if (attributeDec == null) { <line16> attributeDec = new LinkedList<>(); <line17> } <line18> AttributeHandler ah = new AttributeHandler(); <line19> attributeDec.add(ah); <line20> return ah; <line21> } <line22> if (AttributeGroupHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line23> if (attributeDec == null) { <line24> attributeDec = new LinkedList<>(); <line25> } <line26> AttributeGroupHandler ah = new AttributeGroupHandler(); <line27> attributeDec.add(ah); <line28> return ah; <line29> } <line30> if (ChoiceHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line31> ChoiceHandler ah = new ChoiceHandler(); <line32> if (child == null) { <line33> child = ah; <line34> } else { <line35> throw new SAXNotRecognizedException( <line36> getLocalName() + "" may only have one '"" + ChoiceHandler.LOCALNAME + ""' declaration.""); <line37> } <line38> return ah; <line39> } <line40> if (GroupHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line41> GroupHandler ah = new GroupHandler(); <line42> if (child == null) { <line43> child = ah; <line44> } else { <line45> throw new SAXNotRecognizedException( <line46> getLocalName() + "" may only have one '"" + GroupHandler.LOCALNAME + ""' declaration.""); <line47> } <line48> return ah; <line49> } <line50> if (SequenceHandler.LOCALNAME.equalsIgnoreCase(localName)) { <line51> SequenceHandler ah = new SequenceHandler(); <line52> if (child == null) { <line53> child = ah; <line54> } else { <line55> throw new SAXNotRecognizedException( <line56> getLocalName() <line57> + "" may only have one '"" <line58> + SequenceHandler.LOCALNAME <line59> + ""' declaration.""); <line60> } <line61> return ah; <line62> } <line63> } <line64> logger.info(UNKNOWN); <line65> return null; <line66> } <line67> } <line68> "	"""Handler not found for "" + localName + "" in Extension"""	task7	
"public class A { <line0> @Override <line1> public PersonNameType getPersonNameBy(Long personnameId) { <line2> GetPersonNameRequestMessageType request = new GetPersonNameRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setPersonNameId(personnameId); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_GETPERSONNAME, request); <line9> logDebug( <line10> AdminWSConstants.ADMIN_LTD_GETPERSONNAME, response.isStatus(), response.getMessage()); <line11> return firstItem(response.getPersonNameList()); <line12> } catch (Exception e) { <line13> LOG.error( <line14> ""error during retrieval personname: {}, {}"", personnameId, e.getLocalizedMessage(), e); <line15> } <line16> return null; <line17> } <line18> } <line19> "	"""error during retrieval personname: {}, {}"", personnameId, e.getLocalizedMessage(), e"	task7	
public class A { <line0> @Override <line1> public void thawDatabase(String profileId) { <line2> ApplicationContext ctx = profileInstanceManagers.get(profileId); <line3> DerbyPooledDataSource dataSource = (DerbyPooledDataSource) ctx.getBean(DATA_SOURCE_BEAN_NAME); <line4> try { <line5> dataSource.thaw(); <line6> } catch (Exception ex) { <line7> log.error(UNKNOWN); <line8> } <line9> } <line10> } <line11> 	ex.getMessage(), ex	task7	
public class A { <line0> @Override <line1> public void execute() { <line2> if (!resultInjectedFromCache) { <line3> results = new ArrayList<String>(0); <line4> int count = 0; <line5> try { <line6> LoadAttachmentsUserFiltered command = new LoadAttachmentsUserFiltered(rootElmt); <line7> command = getCommandService().executeCommand(command); <line8> for (Attachment attachment : command.getResult()) { <line9> if (isSupportedMIMEType(attachment.getMimeType())) { <line10> results.add(String.valueOf(count)); <line11> count++; <line12> } <line13> } <line14> } catch (CommandException e) { <line15> LOG.error(UNKNOWN); <line16> } <line17> } <line18> } <line19> } <line20> 	"""Error while executing command"", e"	task7	
public class A { <line0> @Override <line1> @Transactional <line2> public void resetRuntimeCounters() { <line3> requireNotDisposed(); <line4> logger.info(UNKNOWN); <line5> _monitorService.resetRuntimeCounters(); <line6> } <line7> } <line8> 	"""Resetting runtime counters service via the management service."""	task7	
"public class A { <line0> public BigDecimal getVoucherExpenditureByEntities( <line1> final Integer detailTypeId, final List<Integer> entityIdList) { <line2> BigDecimal voucherSum = BigDecimal.ZERO; <line3> if (detailTypeId == null || entityIdList == null || entityIdList.size() == 0) <line4> throw new ValidationException( <line5> ""DetailTypeId or EntityIdList not provided"", ""DetailTypeId or EntityIdList not provided""); <line6> final String query = <line7> ""select sum(gld.amount) from CGeneralLedger gl, CGeneralLedgerDetail gld, CVoucherHeader vh"" <line8> + ""  WHERE gl.voucherHeaderId= vh and gl.id = gld.generalLedgerId.id and "" <line9> + "" gld.detailTypeId.id  in ( :detailTypeId ) and gld.detailKeyId   in ( :entityIdList"" <line10> + "" ) and gl.debitAmount>0 and vh.status!=4 and vh.type = 'Journal Voucher'""; <line11> if (LOGGER.isDebugEnabled()) <line12> LOGGER.debug(UNKNOWN); <line13> final Query expenditureQuery = persistenceService.getSession().createQuery(query); <line14> expenditureQuery.setInteger(""detailTypeId"", detailTypeId); <line15> expenditureQuery.setParameterList(""entityIdList"", entityIdList); <line16> final List<Object> result = expenditureQuery.list(); <line17> if (result != null) voucherSum = getBigDecimalValue(result.get(0)); <line18> return voucherSum; <line19> } <line20> } <line21> "	"""query For getVoucherExpenditureByEntities >> "" + query"	task7	
"public class A { <line0> public String earliestBinlogFilename() { <line1> List<String> logNames = new ArrayList<>(); <line2> try { <line3> LOGGER.info(UNKNOWN); <line4> query( <line5> ""SHOW BINARY LOGS"", <line6> rs -> { <line7> while (rs.next()) { <line8> logNames.add(rs.getString(1)); <line9> } <line10> }); <line11> } catch (SQLException e) { <line12> throw new DebeziumException( <line13> ""Unexpected error while connecting to MySQL and looking for binary logs: "", e); <line14> } <line15> if (logNames.isEmpty()) { <line16> return null; <line17> } <line18> return logNames.get(0); <line19> } <line20> } <line21> "	"""Checking all known binlogs from MySQL"""	task7	
public class A { <line0> @Override <line1> public void run() { <line2> while (true) { <line3> boolean needsToShutdown = needsToShutdown(); <line4> try { <line5> emitLargeEvents(); <line6> emitBatches(); <line7> tryEmitOneFailedBuffer(); <line8> if (needsToShutdown) { <line9> tryEmitAndDrainAllFailedBuffers(); <line10> drainBuffersToReuse(); <line11> return; <line12> } <line13> } catch (Throwable t) { <line14> log.error(UNKNOWN); <line15> } <line16> if (failedBuffers.isEmpty()) { <line17> long waitNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(config.getFlushMillis()) / 2, 1); <line18> LockSupport.parkNanos(HttpPostEmitter.this, waitNanos); <line19> } <line20> } <line21> } <line22> } <line23> 	"t, ""Uncaught exception in EmittingThread.run()"""	task7	
"public class A { <line0> public void updateOrchestrationStatusDeleteVfModule(BuildingBlockExecution execution) { <line1> execution.setVariable(""aaiDeleteVfModuleRollback"", false); <line2> try { <line3> VfModule vfModule = extractPojosForBB.extractByKey(execution, ResourceKey.VF_MODULE_ID); <line4> vfModule.setHeatStackId(""""); <line5> GenericVnf vnf = extractPojosForBB.extractByKey(execution, ResourceKey.GENERIC_VNF_ID); <line6> aaiVfModuleResources.updateOrchestrationStatusVfModule( <line7> vfModule, vnf, OrchestrationStatus.ASSIGNED); <line8> execution.setVariable(""aaiDeleteVfModuleRollback"", true); <line9> } catch (Exception ex) { <line10> logger.error( <line11> ""Exception occurred in AAIUpdateTasks updateOrchestrationStatusDeleteVfModule"", ex); <line12> exceptionUtil.buildAndThrowWorkflowException(execution, 7000, ex); <line13> } <line14> } <line15> } <line16> "	"""Exception occurred in AAIUpdateTasks updateOrchestrationStatusDeleteVfModule"", ex"	task7	
"public class A { <line0> @Override <line1> public void userEventTriggered(ChannelHandlerContext ctx, Object evt) { <line2> if (evt instanceof IdleStateEvent) { <line3> if (((IdleStateEvent) evt).state() == IdleState.READER_IDLE) { <line4> InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress(); <line5> InetSocketAddress localAddress = (InetSocketAddress) ctx.channel().localAddress(); <line6> logger.info( <line7> ""Closing idle connection on port "" <line8> + localAddress.getPort() <line9> + "", remote address: "" <line10> + remoteAddress.getAddress().getHostAddress()); <line11> idleClosedConnections.inc(); <line12> ctx.channel().close(); <line13> } <line14> } <line15> } <line16> } <line17> "	"""Closing idle connection on port ""+ localAddress.getPort()+ "", remote address: ""+ remoteAddress.getAddress().getHostAddress()"	task7	
"public class A { <line0> public static String loadPasswordKey( <line1> String pwdKeyAliasProperty, String pwdKeyPasswordProperty, String defaultPassword) { <line2> String passwordKey; <line3> KeyStoreHelper keyStoreHelper = new KeyStoreHelper(); <line4> try { <line5> String pwdKeyAlias = System.getProperty(pwdKeyAliasProperty, """"); <line6> String pwdKeyPassword = System.getProperty(pwdKeyPasswordProperty, """"); <line7> passwordKey = keyStoreHelper.getPasswordKey(pwdKeyAlias, pwdKeyPassword.toCharArray()); <line8> } catch (RuntimeException re) { <line9> passwordKey = defaultPassword; <line10> if (hasNotBeenInvoked(pwdKeyAliasProperty, pwdKeyPasswordProperty, passwordKey)) { <line11> logger.warn(UNKNOWN); <line12> } <line13> } <line14> return passwordKey; <line15> } <line16> } <line17> "	"""Unable to load key store. Using password from configuration"""	task7	
"public class A { <line0> @SuppressWarnings(""checkstyle:IllegalCatch"") <line1> @SuppressFBWarnings( <line2> value = ""UPM_UNCALLED_PRIVATE_METHOD"", <line3> justification = ""https://github.com/spotbugs/spotbugs/issues/811"") <line4> private static void makeEmptyFlowCapableNode( <line5> final TxFacade txFacade, final DeviceInfo deviceInfo) { <line6> try { <line7> txFacade.writeToTransaction( <line8> LogicalDatastoreType.OPERATIONAL, <line9> deviceInfo.getNodeInstanceIdentifier().augmentation(FlowCapableNode.class), <line10> new FlowCapableNodeBuilder().build()); <line11> } catch (final Exception e) { <line12> LOG.debug(UNKNOWN); <line13> } <line14> } <line15> } <line16> "	"""Failed to write empty node {} to DS "", deviceInfo, e"	task7	
public class A { <line0> public synchronized byte[] contentsOf(FileID fid) { <line1> try { <line2> return bytesHelper.allBytesFrom(pathToContentsOf(fid)); <line3> } catch (IOException e) { <line4> log.error(UNKNOWN); <line5> throw new UncheckedIOException(e); <line6> } <line7> } <line8> } <line9> 	"""Not able to read '{}' @ {}!"", asLiteralString(fid), pathToContentsOf(fid)"	task7	
"public class A { <line0> @Override <line1> public Tuple<Boolean, String> isHealthy() { <line2> try { <line3> final Response response = restClient.performRequest(METHOD_GET, ""_cluster/health""); <line4> final StatusLine statusLine = response.getStatusLine(); <line5> if (statusLine.getStatusCode() != 200) { <line6> return Tuple.tuple(false, ""Request failed: "" + statusLine.getReasonPhrase()); <line7> } <line8> final JsonNode jsonNode = OBJECT_MAPPER.readTree(response.getEntity().getContent()); <line9> final String status = jsonNode.get(""status"").asText(); <line10> if (status.equals(""red"")) { <line11> return Tuple.tuple(false, ""Elasticsearch cluster status is 'red'.""); <line12> } <line13> return Tuple.tuple(true, ""Elasticsearch filter is healthy.""); <line14> } catch (IOException e) { <line15> LOG.error(UNKNOWN); <line16> return Tuple.tuple(false, ""Request threw an exception: "" + e.getMessage()); <line17> } <line18> } <line19> } <line20> "	"""Elasticsearch request failed"", e"	task7	
"public class A { <line0> protected DataDescription createDataDescription() { <line1> DataDescription dataDescription = new DataDescription(); <line2> dataDescription.setName(DATA_DESC_FORMAT); <line3> dataDescription.setFormat(DATA_DESC_FORMAT); <line4> dataDescription.setCharset(Charsets.UTF_8.displayName()); <line5> try { <line6> dataDescription.setUrl( <line7> new URI(workflowConfiguration.getDownloadLink(configuration.getDownloadKey()))); <line8> } catch (URISyntaxException e) { <line9> LOG.error( <line10> ""Wrong url {}"", workflowConfiguration.getDownloadLink(configuration.getDownloadKey()), e); <line11> } <line12> return dataDescription; <line13> } <line14> } <line15> "	"""Wrong url {}"", workflowConfiguration.getDownloadLink(configuration.getDownloadKey()), e"	task7	
"public class A { <line0> @Override <line1> public JavaFileObject getJavaFileForInput(Location location, String className, Kind kind) <line2> throws IOException { <line3> logger.debug(UNKNOWN); <line4> if (className.equals(""module-info"")) { <line5> return null; <line6> } <line7> throw new IllegalStateException(""Not expected to be used in this context""); <line8> } <line9> } <line10> "	"""getJavaFileForInput({},{},{})"", location, className, kind"	task7	
"public class A { <line0> private URI buildUri(final UUID interactionId) { <line1> final UriBuilder uriBuilder = <line2> UriBuilder.fromUri( <line3> interactionId != null <line4> ? String.format( <line5> ""%s%s?interactionId=%s&batchSize=%d"", <line6> secondaryConfig.getPrimaryBaseUrlRestful(), <line7> URL_SUFFIX, <line8> interactionId, <line9> secondaryConfig.getBatchSize()) <line10> : String.format( <line11> ""%s%s?batchSize=%d"", <line12> secondaryConfig.getPrimaryBaseUrlRestful(), <line13> URL_SUFFIX, <line14> secondaryConfig.getBatchSize())); <line15> final URI uri = uriBuilder.build(); <line16> log.info(UNKNOWN); <line17> return uri; <line18> } <line19> } <line20> "	"""uri = {}"", uri"	task7	
public class A { <line0> @Override <line1> public void onFailure( <line2> final Throwable throwable, final HttpServerResponse response, final Span span) { <line3> LOG.trace(UNKNOWN); <line4> TracingHelper.logError(span, throwable); <line5> } <line6> } <line7> 	"""logging failed processing of request"""	task7	
"public class A { <line0> @Override <line1> public void onTccCoordinated( <line2> GrpcTccCoordinatedEvent request, StreamObserver<GrpcAck> responseObserver) { <line3> LOG.info( <line4> ""Received coordinated event, global tx: {}, local tx: {}, parent id: {}, "" <line5> + ""method: {}, status: {}, service [{}] instanceId [{}]"", <line6> request.getGlobalTxId(), <line7> request.getLocalTxId(), <line8> request.getParentTxId(), <line9> request.getMethodName(), <line10> request.getStatus(), <line11> request.getServiceName(), <line12> request.getInstanceId()); <line13> events.offer(request); <line14> sleep(); <line15> responseObserver.onNext(ALLOW); <line16> responseObserver.onCompleted(); <line17> } <line18> } <line19> "	"""Received coordinated event, global tx: {}, local tx: {}, parent id: {}, ""+ ""method: {}, status: {}, service [{}] instanceId [{}]"",request.getGlobalTxId(),request.getLocalTxId(),request.getParentTxId(),request.getMethodName(),request.getStatus(),request.getServiceName(),request.getInstanceId()"	task7	
"public class A { <line0> @GET <line1> @Path(""/roles/{id}"") <line2> @Timed <line3> public Response getRole(@PathParam(""id"") Long roleId, @Context SecurityContext securityContext) { <line4> if (!SecurityUtil.hasRole(authorizer, securityContext, ROLE_SECURITY_ADMIN)) { <line5> LOG.debug( <line6> ""Allowing logged-in user '{}'"", <line7> SecurityUtil.getUserName(securityContext.getUserPrincipal().getName())); <line8> } <line9> Role role = catalogService.getRole(roleId); <line10> if (role != null) { <line11> return WSUtils.respondEntity(role, OK); <line12> } <line13> throw EntityNotFoundException.byId(roleId.toString()); <line14> } <line15> } <line16> "	"""Allowing logged-in user '{}'"",SecurityUtil.getUserName(securityContext.getUserPrincipal().getName())"	task7	
public class A { <line0> private String getActivityType(String osmValue, String osmKey) { <line1> String matsimType = typeMap.get(osmValue); <line2> if (matsimType == null) { <line3> if (useGeneralTypeIsSpecificTypeUnknown) { <line4> return osmKey; <line5> } else { <line6> LOG.info(UNKNOWN); <line7> } <line8> } <line9> MapUtils.addToInteger(matsimType, typeCount, 0, 1); <line10> return matsimType; <line11> } <line12> } <line13> 	"""Do not have an activity type mapping for "" + osmValue + ""! Returning NULL."""	task7	
public class A { <line0> protected boolean isUserExcluded(User user) { <line1> if ((user == null) <line2> || Objects.equals( <line3> user.getScreenName(), AnalyticsSecurityConstants.SCREEN_NAME_ANALYTICS_ADMIN) <line4> || Objects.equals(user.getStatus(), WorkflowConstants.STATUS_INACTIVE)) { <line5> return true; <line6> } <line7> AnalyticsConfiguration analyticsConfiguration = <line8> analyticsConfigurationTracker.getAnalyticsConfiguration(user.getCompanyId()); <line9> if (analyticsConfiguration.syncAllContacts()) { <line10> return false; <line11> } <line12> long[] organizationIds = null; <line13> try { <line14> organizationIds = user.getOrganizationIds(); <line15> } catch (Exception exception) { <line16> if (log.isDebugEnabled()) { <line17> log.debug(UNKNOWN); <line18> } <line19> return true; <line20> } <line21> for (long organizationId : organizationIds) { <line22> if (ArrayUtil.contains( <line23> analyticsConfiguration.syncedOrganizationIds(), String.valueOf(organizationId))) { <line24> return false; <line25> } <line26> } <line27> for (long userGroupId : user.getUserGroupIds()) { <line28> if (ArrayUtil.contains( <line29> analyticsConfiguration.syncedUserGroupIds(), String.valueOf(userGroupId))) { <line30> return false; <line31> } <line32> } <line33> return true; <line34> } <line35> } <line36> 	exception, exception	task7	
"public class A { <line0> @Override <line1> public void register(Object resourceProvider) { <line2> if (!(resourceProvider instanceof FhirProvider) <line3> || ((FhirProvider) resourceProvider).requiresRegistration()) { <line4> if (resourceProviders.add(resourceProvider)) { <line5> for (var servlet : servlets) { <line6> servlet.registerProvider(resourceProvider); <line7> } <line8> } else { <line9> LOG.info( <line10> ""Resource Provider {} was already registered. Ignored registration."", resourceProvider); <line11> } <line12> } <line13> } <line14> } <line15> "	"""Resource Provider {} was already registered. Ignored registration."", resourceProvider"	task7	
"public class A { <line0> private synchronized void registerPollTask(ModelBlock mainBlock) { <line1> if (pollTask != null) { <line2> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR); <line3> throw new IllegalStateException( <line4> ""pollTask should be unregistered before registering a new one!""); <line5> } <line6> @Nullable ModbusCommunicationInterface mycomms = comms; <line7> @Nullable SunSpecConfiguration myconfig = config; <line8> if (myconfig == null || mycomms == null) { <line9> throw new IllegalStateException(""registerPollTask called without proper configuration""); <line10> } <line11> logger.debug(UNKNOWN); <line12> ModbusReadRequestBlueprint request = <line13> new ModbusReadRequestBlueprint( <line14> getSlaveId(), <line15> ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, <line16> mainBlock.address, <line17> mainBlock.length, <line18> myconfig.maxTries); <line19> long refreshMillis = myconfig.getRefreshMillis(); <line20> pollTask = <line21> mycomms.registerRegularPoll( <line22> request, <line23> refreshMillis, <line24> 1000, <line25> result -> { <line26> result.getRegisters().ifPresent(this::handlePolledData); <line27> if (getThing().getStatus() != ThingStatus.ONLINE) { <line28> updateStatus(ThingStatus.ONLINE); <line29> } <line30> }, <line31> this::handleError); <line32> } <line33> } <line34> "	"""Setting up regular polling"""	task7	
"public class A { <line0> @Override <line1> public ERCCompanyEntry fetchByC_ERC( <line2> long companyId, String externalReferenceCode, boolean useFinderCache) { <line3> externalReferenceCode = Objects.toString(externalReferenceCode, """"); <line4> Object[] finderArgs = null; <line5> if (useFinderCache) { <line6> finderArgs = new Object[] {companyId, externalReferenceCode}; <line7> } <line8> Object result = null; <line9> if (useFinderCache) { <line10> result = finderCache.getResult(_finderPathFetchByC_ERC, finderArgs); <line11> } <line12> if (result instanceof ERCCompanyEntry) { <line13> ERCCompanyEntry ercCompanyEntry = (ERCCompanyEntry) result; <line14> if ((companyId != ercCompanyEntry.getCompanyId()) <line15> || !Objects.equals(externalReferenceCode, ercCompanyEntry.getExternalReferenceCode())) { <line16> result = null; <line17> } <line18> } <line19> if (result == null) { <line20> StringBundler sb = new StringBundler(4); <line21> sb.append(_SQL_SELECT_ERCCOMPANYENTRY_WHERE); <line22> sb.append(_FINDER_COLUMN_C_ERC_COMPANYID_2); <line23> boolean bindExternalReferenceCode = false; <line24> if (externalReferenceCode.isEmpty()) { <line25> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_3); <line26> } else { <line27> bindExternalReferenceCode = true; <line28> sb.append(_FINDER_COLUMN_C_ERC_EXTERNALREFERENCECODE_2); <line29> } <line30> String sql = sb.toString(); <line31> Session session = null; <line32> try { <line33> session = openSession(); <line34> Query query = session.createQuery(sql); <line35> QueryPos queryPos = QueryPos.getInstance(query); <line36> queryPos.add(companyId); <line37> if (bindExternalReferenceCode) { <line38> queryPos.add(externalReferenceCode); <line39> } <line40> List<ERCCompanyEntry> list = query.list(); <line41> if (list.isEmpty()) { <line42> if (useFinderCache) { <line43> finderCache.putResult(_finderPathFetchByC_ERC, finderArgs, list); <line44> } <line45> } else { <line46> if (list.size() > 1) { <line47> Collections.sort(list, Collections.reverseOrder()); <line48> if (log.isWarnEnabled()) { <line49> if (!useFinderCache) { <line50> finderArgs = new Object[] {companyId, externalReferenceCode}; <line51> } <line52> log.warn( <line53> ""ERCCompanyEntryPersistenceImpl.fetchByC_ERC(long, String, boolean) with"" <line54> + "" parameters ("" <line55> + StringUtil.merge(finderArgs) <line56> + "") yields a result set with more than 1 result. This violates the logical"" <line57> + "" unique restriction. There is no order guarantee on which result is"" <line58> + "" returned by this finder.""); <line59> } <line60> } <line61> ERCCompanyEntry ercCompanyEntry = list.get(0); <line62> result = ercCompanyEntry; <line63> cacheResult(ercCompanyEntry); <line64> } <line65> } catch (Exception exception) { <line66> throw processException(exception); <line67> } finally { <line68> closeSession(session); <line69> } <line70> } <line71> if (result instanceof List<?>) { <line72> return null; <line73> } else { <line74> return (ERCCompanyEntry) result; <line75> } <line76> } <line77> } <line78> "	"""ERCCompanyEntryPersistenceImpl.fetchByC_ERC(long, String, boolean) with""+ "" parameters (""+ StringUtil.merge(finderArgs)+ "") yields a result set with more than 1 result. This violates the logical""+ "" unique restriction. There is no order guarantee on which result is""+ "" returned by this finder."""	task7	
"public class A { <line0> @Test <line1> public void testEndpointTransformer() throws Exception { <line2> MockEndpoint xyzresult = getMockEndpoint(""mock:xyzresult""); <line3> xyzresult.expectedMessageCount(1); <line4> xyzresult.whenAnyExchangeReceived( <line5> new Processor() { <line6> @Override <line7> public void process(Exchange exchange) throws Exception { <line8> LOG.info(UNKNOWN); <line9> assertEquals(""response"", exchange.getIn().getBody()); <line10> } <line11> }); <line12> Exchange exchange = new DefaultExchange(context, ExchangePattern.InOut); <line13> exchange.getIn().setBody(""<XOrder/>""); <line14> Exchange answerEx = template.send(""direct:endpoint"", exchange); <line15> if (answerEx.getException() != null) { <line16> throw answerEx.getException(); <line17> } <line18> assertEquals(""<XOrderResponse/>"", answerEx.getMessage().getBody(String.class)); <line19> assertMockEndpointsSatisfied(); <line20> } <line21> } <line22> "	"""Asserting String -> XOrderResponse convertion is not yet performed"""	task7	
public class A { <line0> public PanelCategory getFirstChildPanelCategory( <line1> String panelCategoryKey, PermissionChecker permissionChecker, Group group) { <line2> List<PanelCategory> panelCategories = getChildPanelCategories(panelCategoryKey); <line3> for (PanelCategory panelCategory : panelCategories) { <line4> try { <line5> if (panelCategory.isShow(permissionChecker, group)) { <line6> return panelCategory; <line7> } <line8> } catch (PortalException portalException) { <line9> log.error(UNKNOWN); <line10> } <line11> } <line12> return null; <line13> } <line14> } <line15> 	portalException, portalException	task7	
"public class A { <line0> @BeforeEach <line1> @Override <line2> public void setUp(final TestInfo testInfo, final VertxTestContext ctx) { <line3> LOGGER.info(UNKNOWN); <line4> helper = new IntegrationTestSupport(vertx); <line5> tenantId = helper.getRandomTenantId(); <line6> deviceId = helper.getRandomDeviceId(tenantId); <line7> password = ""secret""; <line8> deviceCert = SelfSignedCertificate.create(UUID.randomUUID().toString()); <line9> helper.init().onComplete(ctx.completing()); <line10> } <line11> } <line12> "	"""running {}"", testInfo.getDisplayName()"	task7	
"public class A { <line0> @Override <line1> public Result run() { <line2> try { <line3> Runnable messageToShareCallback = totalExportedMessages::incrementAndGet; <line4> exportService.export(userExportFrom, exportQuery, exportTo, messageToShareCallback); <line5> return Result.COMPLETED; <line6> } catch (IOException e) { <line7> LOGGER.error( <line8> ""Error happens when exporting deleted messages from {} to {}"", <line9> userExportFrom.asString(), <line10> exportTo.asString()); <line11> return Result.PARTIAL; <line12> } <line13> } <line14> } <line15> "	"""Error happens when exporting deleted messages from {} to {}"",userExportFrom.asString(),exportTo.asString()"	task7	
"public class A { <line0> @Test <line1> public void testMulti() { <line2> when(consoleConfig.getAllConsoles()).thenReturn(""127.0.0.1:8080, 127.0.0.1:8081""); <line3> when(consoleConfig.getQuorum()).thenReturn(1); <line4> ConsoleServiceManager manager = new ConsoleServiceManager(consoleConfig); <line5> List<HEALTH_STATE> health_states = manager.allHealthStatus(""127.0.0.1"", 6379); <line6> logger.info(UNKNOWN); <line7> } <line8> } <line9> "	"""{}"", health_states"	task7	
public class A { <line0> public CompletionStage<Void> insert(Object entity) { <line1> return entityOperations <line2> .insert(dao, entity) <line3> .exceptionally( <line4> e -> { <line5> LOG.error(UNKNOWN); <line6> return null; <line7> }); <line8> } <line9> } <line10> 	"""Failed to save cassandra entity."", e"	task7	
public class A { <line0> @Override <line1> public void setUserPreferenceContext(String context) { <line2> m_userPreferenceContext = context; <line3> if (isInitDone()) { <line4> try { <line5> reinit(); <line6> } catch (RuntimeException e) { <line7> LOG.error(UNKNOWN); <line8> } <line9> } <line10> } <line11> } <line12> 	"""Failed re-initializing table {}"", getClass().getName(), e"	task7	
public class A { <line0> protected void internalCloseMessageBoxes(List<IMessageBox> list) { <line1> for (IMessageBox m : list) { <line2> if (m != null) { <line3> try { <line4> m.doClose(); <line5> } catch (RuntimeException | PlatformError e) { <line6> LOG.error(UNKNOWN); <line7> } finally { <line8> m_messageBoxStore.remove(m); <line9> } <line10> } <line11> } <line12> } <line13> } <line14> 	"""Exception while closing messagebox"", e"	task7	
"public class A { <line0> @Test <line1> public void testAnyField() throws Exception { <line2> log.info(UNKNOWN); <line3> for (final TestCities city : TestCities.values()) { <line4> String cityPhrase = EQ_OP + ""'"" + city.name() + ""'""; <line5> String query = Constants.ANY_FIELD + cityPhrase; <line6> String expect = this.dataManager.convertAnyField(cityPhrase); <line7> runTest(query, expect, true, false); <line8> } <line9> } <line10> } <line11> "	"""------  testAnyField  ------"""	task7	
public class A { <line0> public boolean areIsolationPoliciesPresent(NamespaceName namespace) { <line1> try { <line2> Optional<NamespaceIsolationPolicies> policies = <line3> getIsolationPolicies(pulsar.getConfiguration().getClusterName()); <line4> return policies <line5> .filter(isolationPolicies -> isolationPolicies.getPolicyByNamespace(namespace) != null) <line6> .isPresent(); <line7> } catch (Exception e) { <line8> LOG.warn(UNKNOWN); <line9> return false; <line10> } <line11> } <line12> } <line13> 	"""IsIsolationPoliciesPresent: Unable to get the namespaceIsolationPolicies"", e"	task7	
"public class A { <line0> void doImport(final Set<String> sourceNames) { <line1> if (!enabled) { <line2> return; <line3> } <line4> for (final String sourceName : sourceNames) { <line5> try { <line6> final AuthoritativeResource authoritativeResource = fetchAuthoritativeResource(sourceName); <line7> resourceDataDao.store(sourceName, authoritativeResource); <line8> } catch (Exception e) { <line9> LOGGER.warn( <line10> ""Exception processing {} due to {}: {}"", <line11> sourceName, <line12> e.getClass().getName(), <line13> e.getMessage()); <line14> } <line15> } <line16> } <line17> } <line18> "	"""Exception processing {} due to {}: {}"",sourceName,e.getClass().getName(),e.getMessage()"	task7	
"public class A { <line0> @Override <line1> public <Q, R> CompletableFuture<QueryResponseMessage<R>> query(QueryMessage<Q, R> queryMessage) { <line2> shutdownLatch.ifShuttingDown( <line3> String.format(""Cannot dispatch new %s as this bus is being shut down"", ""queries"")); <line4> QueryMessage<Q, R> interceptedQuery = dispatchInterceptors.intercept(queryMessage); <line5> ShutdownLatch.ActivityHandle queryInTransit = shutdownLatch.registerActivity(); <line6> CompletableFuture<QueryResponseMessage<R>> queryTransaction = new CompletableFuture<>(); <line7> try { <line8> String targetContext = targetContextResolver.resolveContext(interceptedQuery); <line9> int priority = priorityCalculator.determinePriority(interceptedQuery); <line10> QueryRequest queryRequest = <line11> serializer.serializeRequest( <line12> interceptedQuery, DIRECT_QUERY_NUMBER_OF_RESULTS, DIRECT_QUERY_TIMEOUT_MS, priority); <line13> ResultStream<QueryResponse> result = <line14> axonServerConnectionManager <line15> .getConnection(targetContext) <line16> .queryChannel() <line17> .query(queryRequest); <line18> ResponseProcessingTask<R> responseProcessingTask = <line19> new ResponseProcessingTask<>( <line20> result, serializer, queryTransaction, priority, queryMessage.getResponseType()); <line21> result.onAvailable(() -> queryExecutor.submit(responseProcessingTask)); <line22> } catch (Exception e) { <line23> logger.debug(UNKNOWN); <line24> AxonException exception = <line25> ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e); <line26> queryTransaction.completeExceptionally(exception); <line27> queryInTransit.end(); <line28> } <line29> return queryTransaction; <line30> } <line31> } <line32> "	"""There was a problem issuing a query {}."", interceptedQuery, e"	task7	
"public class A { <line0> @Override <line1> protected void map(LongWritable key, Text value, Context context) <line2> throws IOException, InterruptedException { <line3> String[] elements = COMMA_PATTERN.split(value.toString()); <line4> log.debug(UNKNOWN); <line5> if (elements.length != 3) { <line6> throw new IOException( <line7> ""Expected input of length 3, received "" <line8> + elements.length <line9> + "". Please make sure you adhere to "" <line10> + ""the structure of (i,j,value) for representing a graph in text. "" <line11> + ""Input line was: '"" <line12> + value <line13> + ""'.""); <line14> } <line15> if (elements[0].isEmpty() || elements[1].isEmpty() || elements[2].isEmpty()) { <line16> throw new IOException( <line17> ""Found an element of 0 length. Please be sure you adhere to the structure of "" <line18> + ""(i,j,value) for  representing a graph in text.""); <line19> } <line20> DistributedRowMatrix.MatrixEntryWritable toAdd = new DistributedRowMatrix.MatrixEntryWritable(); <line21> IntWritable row = new IntWritable(Integer.valueOf(elements[0])); <line22> toAdd.setRow(-1); <line23> toAdd.setCol(Integer.valueOf(elements[1])); <line24> toAdd.setVal(Double.valueOf(elements[2])); <line25> context.write(row, toAdd); <line26> } <line27> } <line28> "	"""(DEBUG - MAP) Key[{}], Value[{}]"", key.get(), value"	task7	
"public class A { <line0> @Override <line1> protected byte[] doExport( <line2> long recordSetId, <line3> int status, <line4> int start, <line5> int end, <line6> OrderByComparator<DDLRecord> orderByComparator) <line7> throws Exception { <line8> DDLRecordSet recordSet = _ddlRecordSetService.getRecordSet(recordSetId); <line9> Map<String, DDMFormField> ddmFormFields = getDistinctFields(recordSetId); <line10> DateTimeFormatter dateTimeFormatter = getDateTimeFormatter(); <line11> try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); <line12> Workbook workbook = new HSSFWorkbook()) { <line13> Sheet sheet = workbook.createSheet(); <line14> createHeaderRow(ddmFormFields.values(), sheet, workbook); <line15> List<DDLRecord> records = <line16> _ddlRecordLocalService.getRecords(recordSetId, status, start, end, orderByComparator); <line17> Iterator<DDLRecord> iterator = records.iterator(); <line18> int rowIndex = 1; <line19> CellStyle cellStyle = createCellStyle(workbook, false, ""Courier New"", (short) 12); <line20> while (iterator.hasNext()) { <line21> DDLRecord record = iterator.next(); <line22> DDLRecordVersion recordVersion = record.getRecordVersion(); <line23> DDMFormValues ddmFormValues = <line24> _storageEngine.getDDMFormValues(recordVersion.getDDMStorageId()); <line25> Map<String, DDMFormFieldRenderedValue> values = <line26> getRenderedValues(recordSet.getScope(), ddmFormFields.values(), ddmFormValues); <line27> createDataRow( <line28> rowIndex++, <line29> sheet, <line30> dateTimeFormatter, <line31> recordVersion.getUserName(), <line32> getStatusMessage(recordVersion.getStatus()), <line33> recordVersion.getStatusDate(), <line34> cellStyle, <line35> ddmFormFields, <line36> values); <line37> } <line38> workbook.write(byteArrayOutputStream); <line39> return byteArrayOutputStream.toByteArray(); <line40> } catch (Exception exception) { <line41> if (log.isDebugEnabled()) { <line42> log.debug(UNKNOWN); <line43> } <line44> return new byte[0]; <line45> } <line46> } <line47> } <line48> "	exception, exception	task7	
public class A { <line0> public static FlightVo from(Flight flight) { <line1> FlightVo flightVo = new FlightVo(); <line2> try { <line3> BeanUtils.copyProperties(flight, flightVo); <line4> BeanUtils.copyProperties(flight.getMutableFlightDetails(), flightVo); <line5> flightVo.setId(flight.getId()); <line6> } catch (Exception e) { <line7> logger.error(UNKNOWN); <line8> } <line9> return flightVo; <line10> } <line11> } <line12> 	"""failure to copy proeprties"", e"	task7	
"public class A { <line0> @Test <line1> public void testEchoMethodInvocation() throws Exception { <line2> CountDownLatch latch = new CountDownLatch(1); <line3> Work work = new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY); <line4> thriftClient.echo( <line5> work, <line6> new AsyncMethodCallback<Work>() { <line7> @Override <line8> public void onComplete(Work response) { <line9> echoResult = response; <line10> latch.countDown(); <line11> } <line12>  <line13> @Override <line14> public void onError(Exception exception) { <line15> LOG.info(UNKNOWN); <line16> latch.countDown(); <line17> } <line18> }); <line19> latch.await(5, TimeUnit.SECONDS); <line20> MockEndpoint mockEndpoint = getMockEndpoint(""mock:thrift-service""); <line21> mockEndpoint.expectedMessageCount(1); <line22> mockEndpoint.expectedHeaderValuesReceivedInAnyOrder( <line23> ThriftConstants.THRIFT_METHOD_NAME_HEADER, ""echo""); <line24> mockEndpoint.assertIsSatisfied(); <line25> assertNotNull(echoResult); <line26> assertTrue(echoResult instanceof Work); <line27> assertEquals(THRIFT_TEST_NUM1, echoResult.num1); <line28> assertEquals(Operation.MULTIPLY, echoResult.op); <line29> } <line30> } <line31> "	"""Exception"", exception"	task7	
"public class A { <line0> @Override <line1> public void invoke(AmazonS3FilePayload payload) throws EndpointException { <line2> if (configuration.getEnabled()) { <line3> super.invoke(payload); <line4> if (!new File(payload.getFilePath()).exists()) { <line5> throw new InvalidAmazonS3PayloadException( <line6> ""File at path "" + payload.getFilePath() + "" does not exist""); <line7> } <line8> s3Client.uploadFile(payload.getFilePath(), getKeyName(payload), getBucketName(payload)); <line9> } else { <line10> logger.debug(UNKNOWN); <line11> } <line12> } <line13> } <line14> "	"""Configuration is not enabled, so component will do nothing"""	task7	
"public class A { <line0> public void processRow(ResultSet rs) throws SQLException { <line1> String layer = rs.getString(1); <line2> String gridset = rs.getString(2); <line3> int z = rs.getInt(3); <line4> String paramsKvp = rs.getString(4); <line5> String paramsId = rs.getString(5); <line6> String sha = getParamsSha1(paramsKvp); <line7> File origin = new File(buildFolderPath(root, layer, gridset, z, paramsId)); <line8> File destination = new File(buildFolderPath(root, layer, gridset, z, sha)); <line9> org.geowebcache.util.FileUtils.renameFile(origin, destination); <line10> count++; <line11> if (count % 1000 == 0 || count >= total) { <line12> log.info( <line13> ""Migrated "" + count + ""/"" + total + "" parameters from the metastore to the file system""); <line14> } <line15> } <line16> } <line17> "	"""Migrated "" + count + ""/"" + total + "" parameters from the metastore to the file system"""	task7	
"public class A { <line0> @Test <line1> public void testRemoveHeaderDisabeld() throws Exception { <line2> final SahiHeaderAspect sahiHeaderAspect = BeanLoader.loadBean(SahiHeaderAspect.class); <line3> ReflectionTestUtils.setField(sahiHeaderAspect, ""removeAuthorizationHeader"", false); <line4> LOGGER.debug(UNKNOWN); <line5> testling.removeHeader(""Authorization""); <line6> assertLastLine(logFile, ""SAHI"", LogLevel.DEBUG, ""SAHI skip remove Header 'Authorization'""); <line7> } <line8> } <line9> "	"""SAHI this is not the correct line!"""	task7	
"public class A { <line0> @Override <line1> public void debug(String msg, Throwable t) { <line2> if (!isDebugEnabled()) { <line3> return; <line4> } <line5> msg = ""{} "" + msg; <line6> final Object[] os = {component}; <line7> logger.debug(UNKNOWN); <line8> logRepository.addLogMessage(LogLevel.DEBUG, msg, os, t); <line9> } <line10> } <line11> "	msg, os, t	task7	
"public class A { <line0> @Override <line1> public List<ActivityStreamComment> getActionCommentRecords(int id) { <line2> List<ActivityStreamComment> comments = new ArrayList<>(); <line3> Connection conn = null; <line4> PreparedStatement stat = null; <line5> ResultSet result = null; <line6> try { <line7> conn = this.getConnection(); <line8> stat = conn.prepareStatement(GET_ACTION_COMMENT_RECORDS); <line9> stat.setInt(1, id); <line10> result = stat.executeQuery(); <line11> while (result.next()) { <line12> ActivityStreamComment comment = new ActivityStreamComment(); <line13> comment.setId(result.getInt(1)); <line14> comment.setUsername(result.getString(2)); <line15> comment.setCommentText(result.getString(3)); <line16> Timestamp timestamp = result.getTimestamp(4); <line17> comment.setCommentDate(new Date(timestamp.getTime())); <line18> comments.add(comment); <line19> } <line20> } catch (Throwable t) { <line21> logger.error(UNKNOWN); <line22> throw new RuntimeException(""Error while loading activity stream comment records"", t); <line23> } finally { <line24> closeDaoResources(result, stat, conn); <line25> } <line26> return comments; <line27> } <line28> } <line29> "	"""Error while loading activity stream comment records"", t"	task7	
public class A { <line0> public LedgerHandle createLedger( <line1> int ensSize, <line2> int writeQuorumSize, <line3> int ackQuorumSize, <line4> DigestType digestType, <line5> byte[] passwd, <line6> final Map<String, byte[]> customMetadata) <line7> throws InterruptedException, BKException { <line8> CompletableFuture<LedgerHandle> future = new CompletableFuture<>(); <line9> SyncCreateCallback result = new SyncCreateCallback(future); <line10> asyncCreateLedger( <line11> ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, result, null, customMetadata); <line12> LedgerHandle lh = SyncCallbackUtils.waitForResult(future); <line13> if (lh == null) { <line14> LOG.error(UNKNOWN); <line15> throw BKException.create(BKException.Code.UnexpectedConditionException); <line16> } <line17> return lh; <line18> } <line19> } <line20> 	"""Unexpected condition : no ledger handle returned for a success ledger creation"""	task7	
"public class A { <line0> public static jsignalml.compiler.CompiledClass<? extends jsignalml.Source> loadFromFile( <line1> String pkg, File file) <line2> throws java.io.IOException, java.lang.ClassNotFoundException, org.xml.sax.SAXException { <line3> jsignalml.JavaClassGen gen = <line4> jsignalml.CodecParser.generateFromFile(file, ""org.signalml.codec."" + pkg, false); <line5> String name = gen.getFullClassName(); <line6> CharSequence code = gen.getSourceCode(); <line7> jsignalml.compiler.CompiledClass<jsignalml.Source> klass = <line8> jsignalml.compiler.CompiledClass.newCompiledClass(name, code); <line9> logger.info(UNKNOWN); <line10> return klass; <line11> } <line12> } <line13> "	"""class "" + name + "" has been sourced"""	task7	
"public class A { <line0> @Test <line1> public void test_hgvs_walk_and_roll_2() { <line2> Log.debug(UNKNOWN); <line3> String genome = ""testHg19Chr17""; <line4> String vcf = path(""hgvs_walk_and_roll.1.vcf""); <line5> compareHgvs(genome, vcf, true); <line6> } <line7> } <line8> "	"""Test"""	task7	
"public class A { <line0> @PluginFactory <line1> public static Log4j2Appender createAppender( <line2> @PluginAttribute(""name"") String name, <line3> @PluginElement(""Layout"") Layout<? extends Serializable> layout, <line4> @PluginElement(""Filter"") final Filter filter, <line5> @PluginAttribute(""otherAttribute"") String otherAttribute) { <line6> if (name == null) { <line7> LOGGER.error(UNKNOWN); <line8> return null; <line9> } <line10> if (layout == null) { <line11> layout = PatternLayout.createDefaultLayout(); <line12> } <line13> return new Log4j2Appender(name, filter, layout, true); <line14> } <line15> } <line16> "	"""No name provided for Log4j2Appender"""	task7	
public class A { <line0> public void deleteRequestDeployState(String requestId) { <line1> if (!active) { <line2> LOG.warn(UNKNOWN); <line3> return; <line4> } <line5> requestIdToDeployState.remove(requestId); <line6> } <line7> } <line8> 	"""deleteRequestDeployState {}, but not active"", requestId"	task7	
public class A { <line0> private JSONObject getProperties(RequestContext requestContext) { <line1> String remoteIP = requestContext.getClientIp(); <line2> JSONObject jsonObMap = new JSONObject(); <line3> ThrottleConfigDto config = ConfigHolder.getInstance().getConfig().getThrottleConfig(); <line4> if (remoteIP != null && remoteIP.length() > 0) { <line5> try { <line6> InetAddress address = InetAddress.getByName(remoteIP); <line7> if (address instanceof Inet4Address) { <line8> jsonObMap.put(ThrottleConstants.IP, FilterUtils.ipToLong(remoteIP)); <line9> jsonObMap.put(ThrottleConstants.IPV6, 0); <line10> } else if (address instanceof Inet6Address) { <line11> jsonObMap.put(ThrottleConstants.IPV6, FilterUtils.ipToBigInteger(remoteIP)); <line12> jsonObMap.put(ThrottleConstants.IP, 0); <line13> } <line14> } catch (UnknownHostException e) { <line15> log.error(UNKNOWN); <line16> jsonObMap.put(ThrottleConstants.IPV6, 0); <line17> jsonObMap.put(ThrottleConstants.IP, 0); <line18> } <line19> } <line20> if (config.isHeaderConditionsEnabled()) { <line21> Map<String, String> headers = requestContext.getHeaders(); <line22> for (String name : headers.keySet()) { <line23> jsonObMap.put(name, headers.get(name)); <line24> } <line25> } <line26> if (config.isQueryConditionsEnabled()) { <line27> Map<String, String> params = requestContext.getQueryParameters(); <line28> for (String name : params.keySet()) { <line29> jsonObMap.put(name, params.get(name)); <line30> } <line31> } <line32> String callerToken = requestContext.getAuthenticationContext().getCallerToken(); <line33> if (config.isJwtClaimConditionsEnabled() && callerToken != null) { <line34> Map<String, String> claims = ThrottleUtils.getJWTClaims(callerToken); <line35> for (String key : claims.keySet()) { <line36> jsonObMap.put(key, claims.get(key)); <line37> } <line38> } <line39> return jsonObMap; <line40> } <line41> } <line42> 	"""Error while parsing host IP {}"", remoteIP, e"	task7	
public class A { <line0> protected void doPrack(final SipServletRequest req) throws ServletException, IOException { <line1> final EventSource source = SessionUtils.getEventSource(req); <line2> if (source instanceof SIPIncomingCall) { <line3> final SIPIncomingCall call = (SIPIncomingCall) source; <line4> try { <line5> call.doPrack(req); <line6> } catch (final Exception e) { <line7> LOG.warn(UNKNOWN); <line8> } <line9> } <line10> } <line11> } <line12> 	""""", e"	task7	
"public class A { <line0> @Override <line1> public JsonObject search(JsonObject queryJson) throws IOException { <line2> if (logger.isDebugEnabled()) { <line3> logger.debug(UNKNOWN); <line4> } <line5> JsonObject top = new JsonObject(); <line6> JsonArray elements = new JsonArray(); <line7> Search search = new Search.Builder(queryJson.toString()).build(); <line8> SearchResult result = client.execute(search); <line9> if (result == null) { <line10> return top; <line11> } <line12> if (result.getTotal() > 0) { <line13> top.addProperty( <line14> ""total"", result.getJsonObject().getAsJsonObject(""hits"").get(""total"").getAsInt()); <line15> JsonArray hits = result.getJsonObject().getAsJsonObject(""hits"").getAsJsonArray(""hits""); <line16> for (int i = 0; i < hits.size(); i++) { <line17> JsonObject o = hits.get(i).getAsJsonObject().getAsJsonObject(""_source""); <line18> elements.add(o); <line19> } <line20> } <line21> top.add(""elements"", elements); <line22> if (result.getJsonObject().has(""aggregations"")) { <line23> JsonObject aggs = result.getJsonObject().getAsJsonObject(""aggregations""); <line24> top.add(""aggregations"", aggs); <line25> } <line26> return top; <line27> } <line28> } <line29> "	"String.format(""Search Query %s"", queryJson.toString())"	task7	
"public class A { <line0> @Override <line1> public Boolean call() { <line2> HttpToolResponse result = <line3> ((BrooklynNode) entity()) <line4> .http() <line5> .responseSuccess( <line6> Predicates.<Integer>or( <line7> ResponseCodePredicates.success(), Predicates.equalTo(HttpStatus.SC_FORBIDDEN))) <line8> .post(""/v1/applications"", headers, plan.getBytes()); <line9> if (result.getResponseCode() == HttpStatus.SC_FORBIDDEN) { <line10> log.debug(UNKNOWN); <line11> return false; <line12> } else { <line13> byte[] content = result.getContent(); <line14> response.set(content); <line15> return true; <line16> } <line17> } <line18> } <line19> "	"""Remote is not ready to accept requests, response is "" + result.getResponseCode()"	task7	
"public class A { <line0> @Override <line1> public UpdateContainer undoIt(Workspace workspace) { <line2> UpdateContainer c = new UpdateContainer(); <line3> Worksheet worksheet = workspace.getWorksheet(worksheetId); <line4> if (oldType == null) { <line5> worksheet.getSemanticTypes().unassignColumnSemanticType(hNodeId); <line6> } else { <line7> worksheet.getSemanticTypes().setType(oldType); <line8> worksheet.getSemanticTypes().addSynonymTypesForHNodeId(hNodeId, oldSynonymTypes); <line9> } <line10> String alignmentId = <line11> AlignmentManager.Instance().constructAlignmentId(workspace.getId(), worksheetId); <line12> AlignmentManager.Instance().addAlignmentToMap(alignmentId, oldAlignment); <line13> oldAlignment.setGraph(oldGraph); <line14> try { <line15> c.append(computeAlignmentAndSemanticTypesAndCreateUpdates(workspace)); <line16> } catch (Exception e) { <line17> logger.error(UNKNOWN); <line18> return new UpdateContainer( <line19> new ErrorUpdate(""Error occured while unsetting the semantic type!"")); <line20> } <line21> return c; <line22> } <line23> } <line24> "	"""Error occured while unsetting the semantic type!"", e"	task7	
public class A { <line0> @Override <line1> public OrchestrationContext build() { <line2> LOG.trace(UNKNOWN); <line3> return new OrchestrationContext( <line4> new OutboundDocSubmissionDeferredRequestStrategyImpl_g0(), <line5> new OutboundDocSubmissionDeferredRequestOrchestratable( <line6> getNhinDelegate(), getRequest(), getTarget(), getAssertionType())); <line7> } <line8> } <line9> 	"""begin build"""	task7	
public class A { <line0> @Deprecated <line1> public static com.liferay.commerce.tax.model.CommerceTaxMethodSoap addCommerceTaxMethod( <line2> String[] nameMapLanguageIds, <line3> String[] nameMapValues, <line4> String[] descriptionMapLanguageIds, <line5> String[] descriptionMapValues, <line6> String engineKey, <line7> boolean percentage, <line8> boolean active, <line9> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line10> throws RemoteException { <line11> try { <line12> Map<Locale, String> nameMap = <line13> LocalizationUtil.getLocalizationMap(nameMapLanguageIds, nameMapValues); <line14> Map<Locale, String> descriptionMap = <line15> LocalizationUtil.getLocalizationMap(descriptionMapLanguageIds, descriptionMapValues); <line16> com.liferay.commerce.tax.model.CommerceTaxMethod returnValue = <line17> CommerceTaxMethodServiceUtil.addCommerceTaxMethod( <line18> nameMap, descriptionMap, engineKey, percentage, active, serviceContext); <line19> return com.liferay.commerce.tax.model.CommerceTaxMethodSoap.toSoapModel(returnValue); <line20> } catch (Exception exception) { <line21> log.error(UNKNOWN); <line22> throw new RemoteException(exception.getMessage()); <line23> } <line24> } <line25> } <line26> 	exception, exception	task7	
public class A { <line0> public List<NowPlayingInfo> getNowPlaying() { <line1> try { <line2> return convert(statusService.getPlayStatuses()); <line3> } catch (Throwable x) { <line4> LOG.error(UNKNOWN); <line5> return Collections.emptyList(); <line6> } <line7> } <line8> } <line9> 	"""Unexpected error in getNowPlaying: "" + x, x"	task7	
"public class A { <line0> public static java.util.List<com.liferay.fragment.model.FragmentCollection> <line1> getFragmentCollections( <line2> HttpPrincipal httpPrincipal, <line3> long groupId, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.fragment.model.FragmentCollection> <line8> orderByComparator) { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey( <line12> FragmentCollectionServiceUtil.class, <line13> ""getFragmentCollections"", <line14> _getFragmentCollectionsParameterTypes9); <line15> MethodHandler methodHandler = <line16> new MethodHandler(methodKey, groupId, start, end, orderByComparator); <line17> Object returnObj = null; <line18> try { <line19> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line20> } catch (Exception exception) { <line21> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line22> } <line23> return (java.util.List<com.liferay.fragment.model.FragmentCollection>) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line25> log.error(UNKNOWN); <line26> throw systemException; <line27> } <line28> } <line29> } <line30> "	systemException, systemException	task7	
public class A { <line0> @Override <line1> public IOperatorNodePushable createPushRuntime( <line2> IHyracksTaskContext ctx, <line3> IRecordDescriptorProvider recordDescProvider, <line4> int partition, <line5> int nPartitions) { <line6> return new AbstractLibraryNodePushable(ctx) { <line7> @Override <line8> protected void execute() throws IOException { <line9> if (LOGGER.isInfoEnabled()) { <line10> LOGGER.info(UNKNOWN); <line11> } <line12> FileReference rev1 = getRev1Dir(); <line13> FileReference stage = getStageDir(); <line14> move(stage, rev1); <line15> FileReference libDir = getLibraryDir(); <line16> flushDirectory(libDir); <line17> } <line18> }; <line19> } <line20> } <line21> 	"""Commit deployment of library {}.{}"", dataverseName, libraryName"	task7	
public class A { <line0> public static void boxLog(String message) { <line1> LOG.debug(UNKNOWN); <line2> } <line3> } <line4> 	message	task7	
public class A { <line0> private void notifyConnectionFailure(int error, String reason) { <line1> try { <line2> listener.onConnectionFailure(error, reason); <line3> } catch (Throwable x) { <line4> LOG.info(UNKNOWN); <line5> } <line6> } <line7> } <line8> 	"""Failure while notifying listener {}"", listener, x"	task7	
public class A { <line0> @Override <line1> public String getIndexTextForEntity(String guid) throws AtlasBaseException { <line2> String ret = null; <line3> final AtlasEntity entity; <line4> final AtlasEntityExtInfo entityExtInfo; <line5> if (followReferences) { <line6> AtlasEntityWithExtInfo entityWithExtInfo = getAndCacheEntityWithExtInfo(guid); <line7> entity = entityWithExtInfo != null ? entityWithExtInfo.getEntity() : null; <line8> entityExtInfo = entityWithExtInfo; <line9> } else { <line10> entity = getAndCacheEntity(guid, false); <line11> entityExtInfo = null; <line12> } <line13> if (entity != null) { <line14> StringBuilder sb = new StringBuilder(); <line15> map(entity, entityExtInfo, sb, new HashSet<String>(), false); <line16> ret = sb.toString(); <line17> } <line18> if (LOG.isDebugEnabled()) { <line19> LOG.debug(UNKNOWN); <line20> } <line21> return ret; <line22> } <line23> } <line24> 	"""FullTextMapperV2.map({}): {}"", guid, ret"	task7	
"public class A { <line0> public static void awaitCountDown( <line1> final CountDownLatch countDownLatch, final String countDownLatchId) { <line2> int iteration = 0; <line3> try { <line4> boolean finished = false; <line5> while (!finished) { <line6> iteration++; <line7> finished = countDownLatch.await(AWAIT_TIMEOUT_MINUTES, TimeUnit.MINUTES); <line8> if (!finished) { <line9> logger.info( <line10> ""Awaited completion of '"" <line11> + countDownLatchId <line12> + ""' for "" <line13> + (iteration * AWAIT_TIMEOUT_MINUTES) <line14> + "" minutes...""); <line15> } <line16> } <line17> } catch (final InterruptedException e) { <line18> throw new IllegalStateException( <line19> ""Awaiting completion of '"" + countDownLatchId + ""' was interrupted!"", e); <line20> } <line21> } <line22> } <line23> "	"""Awaited completion of '""+ countDownLatchId+ ""' for ""+ (iteration * AWAIT_TIMEOUT_MINUTES)+ "" minutes..."""	task7	
public class A { <line0> @After <line1> public void stopBundle() throws Exception { <line2> InitializerTestHelper.removeResources(resourceManager); <line3> log.info(UNKNOWN); <line4> } <line5> } <line6> 	"""INFO: Stopped!"""	task7	
public class A { <line0> private void closeResultSet() { <line1> if (rs != null) { <line2> try { <line3> rs.close(); <line4> } catch (Throwable e) { <line5> logger.error(UNKNOWN); <line6> } <line7> } <line8> rs = null; <line9> } <line10> } <line11> 	"""Close result set failed."", e"	task7	
"public class A { <line0> private MapObject<String, Object> convertAvroBeanToRethinkDBDocField( <line1> final String docf, final Schema fieldSchema, final Object value) { <line2> MapObject<String, Object> record = new MapObject(); <line3> for (Schema.Field member : fieldSchema.getFields()) { <line4> Object innerValue = ((PersistentBase) value).get(member.pos()); <line5> String innerDoc = rethinkDBMapping.getDocumentField(member.name()); <line6> Schema.Type innerType = member.schema().getType(); <line7> RethinkDBMapping.DocumentFieldType innerStoreType = <line8> rethinkDBMapping.getDocumentFieldType(innerDoc); <line9> LOG.debug( <line10> ""Transform value to BaseDocument , docField:{}, schemaType:{}, storeType:{}"", <line11> new Object[] {member.name(), member.schema().getType(), innerStoreType}); <line12> Object fieldValue = <line13> convertAvroFieldToRethinkDBField( <line14> docf, member.schema(), innerType, innerStoreType, innerValue); <line15> record.put(member.name(), fieldValue); <line16> } <line17> return record; <line18> } <line19> } <line20> "	"""Transform value to BaseDocument , docField:{}, schemaType:{}, storeType:{}"",new Object[] {member.name(), member.schema().getType(), innerStoreType}"	task7	
public class A { <line0> @Override <line1> public void run() { <line2> while (isRunning()) { <line3> try { <line4> final Socket conn = serverSocket.accept(); <line5> executorService.execute( <line6> new Runnable() { <line7> @Override <line8> public void run() { <line9> handleRequest(conn); <line10> if (conn.isClosed() == false) { <line11> try { <line12> conn.close(); <line13> } catch (IOException ioe) { <line14> } <line15> } <line16> } <line17> }); <line18> } catch (final SocketException se) { <line19> } catch (final IOException ioe) { <line20> if (logger.isDebugEnabled()) { <line21> logger.warn(UNKNOWN); <line22> } <line23> } <line24> } <line25> } <line26> } <line27> 	""""", ioe"	task7	
public class A { <line0> public static void main(String[] args) throws Exception { <line1> final Terminal terminal = TerminalBuilder.builder().system(true).build(); <line2> History defaultHistory = new DefaultHistory(); <line3> Runtime.getRuntime() <line4> .addShutdownHook( <line5> new Thread( <line6> () -> { <line7> try { <line8> defaultHistory.save(); <line9> } catch (IOException e) { <line10> LOG.debug(UNKNOWN); <line11> } <line12> })); <line13> final LineReader lineReader = <line14> LineReaderBuilder.builder() <line15> .terminal(terminal) <line16> .highlighter(new DefaultHighlighter()) <line17> .history(defaultHistory) <line18> .build(); <line19> LogServiceShellOpts opts = new LogServiceShellOpts(); <line20> JCommander.newBuilder().addObject(opts).build().parse(args); <line21> try (LogServiceClient logServiceClient = new LogServiceClient(opts.metaQuorum)) { <line22> LogServiceShell client = new LogServiceShell(terminal, lineReader, logServiceClient); <line23> client.run(); <line24> } <line25> } <line26> } <line27> 	"""Failed to save terminal history"", e"	task7	
"public class A { <line0> @Override <line1> public Map<String, String> getWorkflowConfig(String mediaPackageId) <line2> throws NotFoundException, SchedulerException { <line3> notEmpty(mediaPackageId, ""mediaPackageId""); <line4> try { <line5> Opt<ExtendedEventDto> record = persistence.getEvent(mediaPackageId); <line6> if (record.isNone()) throw new NotFoundException(); <line7> return deserializeExtendedEventProperties(record.get().getWorkflowProperties()); <line8> } catch (NotFoundException e) { <line9> throw e; <line10> } catch (Exception e) { <line11> logger.error(UNKNOWN); <line12> throw new SchedulerException(e); <line13> } <line14> } <line15> } <line16> "	"""Failed to get workflow configuration of event '{}':"", mediaPackageId, e"	task7	
public class A { <line0> @Override <line1> protected void before() throws Throwable { <line2> log.debug(UNKNOWN); <line3> requester = <line4> H2MultiplexingRequesterBootstrap.bootstrap() <line5> .setIOReactorConfig(IOReactorConfig.custom().setSoTimeout(TIMEOUT).build()) <line6> .setTlsStrategy(new H2ClientTlsStrategy(SSLTestContexts.createClientSSLContext())) <line7> .setStrictALPNHandshake(strictALPN) <line8> .setStreamListener(LoggingH2StreamListener.INSTANCE) <line9> .setIOSessionDecorator(LoggingIOSessionDecorator.INSTANCE) <line10> .setExceptionCallback(LoggingExceptionCallback.INSTANCE) <line11> .setIOSessionListener(LoggingIOSessionListener.INSTANCE) <line12> .create(); <line13> } <line14> } <line15> 	"""Starting up test client"""	task7	
public class A { <line0> public boolean load(String schemaPartitionDir, String ldifFile, String targetPartitionDir) { <line1> initSchema(schemaPartitionDir); <line2> if (schemaManager == null) { <line3> LOG.warn(UNKNOWN); <line4> return false; <line5> } <line6> return load(ldifFile, targetPartitionDir); <line7> } <line8> } <line9> 	"""Failed to load the schema, aborting data load"""	task7	
"public class A { <line0> @Test <line1> public void testRenderTaskFormViaUIClientNoFrmFoundTest() throws Exception { <line2> changeUser(USER_JOHN); <line3> Map<String, Object> parameters = new HashMap<>(); <line4> parameters.put(""name"", ""john""); <line5> parameters.put(""age"", 33); <line6> parameters.put(""mail"", ""john@doe.org""); <line7> long processInstanceId = <line8> processClient.startProcess(CONTAINER_ID, HIRING_2_PROCESS_ID, parameters); <line9> try { <line10> List<TaskSummary> tasks = <line11> taskClient.findTasksByStatusByProcessInstanceId(processInstanceId, null, 0, 10); <line12> assertThat(tasks).isNotNull().hasSize(1); <line13> Long taskId = tasks.get(0).getId(); <line14> String result = uiServicesClient.renderTaskForm(CONTAINER_ID, taskId); <line15> logger.debug(UNKNOWN); <line16> assertThat(result).isNotNull().isNotEmpty(); <line17> assertThat(result).contains(""/files/patternfly/css/patternfly.min.css\"" rel=\""stylesheet\"">""); <line18> assertThat(result) <line19> .contains(""/files/patternfly/css/patternfly-additions.min.css\"" rel=\""stylesheet\"">""); <line20> assertThat(result).contains(""/files/patternfly/js/jquery.min.js\""></script>""); <line21> assertThat(result).contains(""/files/patternfly/js/patternfly.min.js\""></script>""); <line22> assertThat(result).contains(""/files/js/kieserver-ui.js\""></script>""); <line23> assertThat(result).contains(""<h3 class=\""panel-title\"">Default form - HR Interview</h3>""); <line24> } finally { <line25> changeUser(USER_YODA); <line26> processClient.abortProcessInstance(CONTAINER_ID, processInstanceId); <line27> } <line28> } <line29> } <line30> "	"""Form content is '{}'"", result"	task7	
"public class A { <line0> protected void initKettle() { <line1> try { <line2> KettleSystemListener.environmentInit(PentahoSessionHolder.getSession()); <line3> if (Props.isInitialized() == false) { <line4> Props.init(Props.TYPE_PROPERTIES_EMPTY); <line5> } <line6> } catch (KettleException e) { <line7> logger.error(UNKNOWN); <line8> throw new IllegalStateException(""Failed to initialize Kettle system""); <line9> } <line10> } <line11> } <line12> "	e	task7	
public class A { <line0> protected String format(User user, long groupId, JournalArticle article, String content) <line1> throws PortalException { <line2> Document document = null; <line3> try { <line4> document = SAXReaderUtil.read(content); <line5> format(user, groupId, article, document.getRootElement()); <line6> content = XMLUtil.formatXML(document); <line7> } catch (DocumentException documentException) { <line8> log.error(UNKNOWN); <line9> } <line10> return content; <line11> } <line12> } <line13> 	documentException, documentException	task7	
public class A { <line0> private void publishPingResult(long period, Member member, MemberStatus status) { <line1> LOGGER.debug(UNKNOWN); <line2> sink.emitNext(new FailureDetectorEvent(member, status), RETRY_NOT_SERIALIZED); <line3> } <line4> } <line5> 	"""[{}][{}] Member {} detected as {}"", localMember, period, member, status"	task7	
"public class A { <line0> public ClosableReportingIterator<String[]> rowIterator(Source source) throws SourceException { <line1> if (source == null) { <line2> return null; <line3> } <line4> try { <line5> if (source instanceof SqlSource) { <line6> return new SqlRowIterator((SqlSource) source); <line7> } <line8> return ((FileSource) source).rowIterator(); <line9> } catch (Exception e) { <line10> LOG.error(UNKNOWN); <line11> throw new SourceException( <line12> ""Can't build iterator for source "" + source.getName() + "" :"" + e.getMessage()); <line13> } <line14> } <line15> } <line16> "	"""Exception while reading source "" + source.getName(), e"	task7	
"public class A { <line0> private void testIfQuartzTablesExist() { <line1> final SingleConnectionDataSource singleConnectionDataSource = new SingleConnectionDataSource(); <line2> singleConnectionDataSource.setDriverClassName(this.databaseDriver); <line3> singleConnectionDataSource.setUsername(this.databaseUsername); <line4> singleConnectionDataSource.setPassword(this.databasePassword); <line5> singleConnectionDataSource.setUrl(this.getDatabaseUrl()); <line6> singleConnectionDataSource.setSuppressClose(false); <line7> try { <line8> final Connection connection = singleConnectionDataSource.getConnection(); <line9> final Statement statement = connection.createStatement(); <line10> statement.executeQuery(""SELECT * FROM qrtz_locks LIMIT 1""); <line11> connection.close(); <line12> } catch (final SQLException e) { <line13> LOGGER.debug(UNKNOWN); <line14> if (e.getMessage().contains(""ERROR: relation \""qrtz_locks\"" does not exist"")) { <line15> this.determineRetry(""Table qrtz_lock does not exist""); <line16> } <line17> } finally { <line18> singleConnectionDataSource.destroy(); <line19> } <line20> } <line21> } <line22> "	"""SQLException"", e"	task7	
public class A { <line0> @Override <line1> public AccumuloResource makeObject() { <line2> AccumuloResource scannerResource = new AccumuloResource(client); <line3> log.isTraceEnabled(UNKNOWN); <line4> return scannerResource; <line5> } <line6> } <line7> 	"""Returning "" + scannerResource.hashCode()"	task7	
"public class A { <line0> @Override <line1> public void subscribe(final Long dataTagId, final TagListener listener) <line2> throws CacheSynchronizationException { <line3> if (dataTagId == null) { <line4> String error = ""Called with null parameter (id collection).""; <line5> log.warn(UNKNOWN); <line6> throw new IllegalArgumentException(error); <line7> } <line8> Set<Long> id = new HashSet<>(1); <line9> id.add(dataTagId); <line10> subscribe(id, listener); <line11> } <line12> } <line13> "	"""subscribe() : "" + error"	task7	
"public class A { <line0> @Override <line1> public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) <line2> throws MadokaParsingException { <line3> byte[] powerStateValue = mm.getValues().get(0x20).getRawValue(); <line4> if (powerStateValue == null || powerStateValue.length != 1) { <line5> setState(State.FAILED); <line6> throw new MadokaParsingException(""Incorrect value for PowerState""); <line7> } <line8> powerState = Integer.valueOf(powerStateValue[0]) == 1; <line9> logger.debug(UNKNOWN); <line10> setState(State.SUCCEEDED); <line11> executor.execute(() -> listener.receivedResponse(this)); <line12> } <line13> } <line14> "	"""PowerState: {}"", powerState"	task7	
public class A { <line0> @Override <line1> protected void createCacheManagers() throws Throwable { <line2> ConfigurationBuilder defaultConfig = getDefaultClusteredCacheConfig(cacheMode); <line3> log.debug(UNKNOWN); <line4> defaultConfig.clustering().l1().disable().stateTransfer().fetchInMemoryState(true); <line5> createClusteredCaches(5, defaultConfig); <line6> ConsistentHash hash = <line7> cache(0).getAdvancedCache().getDistributionManager().getWriteConsistentHash(); <line8> List<Address> members = hash.getMembers(); <line9> addresses = members.toArray(new Address[members.size()]); <line10> } <line11> } <line12> 	"""defaultConfig = "" + defaultConfig.build().clustering().hash().numOwners()"	task7	
"public class A { <line0> @Override <line1> public String toModelFilename(String name) { <line2> if (!StringUtils.isEmpty(modelNamePrefix)) { <line3> name = modelNamePrefix + ""_"" + name; <line4> } <line5> if (!StringUtils.isEmpty(modelNameSuffix)) { <line6> name = name + ""_"" + modelNameSuffix; <line7> } <line8> name = sanitizeName(name); <line9> if (isReservedWord(name)) { <line10> LOGGER.warn( <line11> name <line12> + "" (reserved word) cannot be used as model name. Renamed to "" <line13> + camelize(""model_"" + name)); <line14> name = ""model_"" + name; <line15> } <line16> return underscore(name); <line17> } <line18> } <line19> "	"name+ "" (reserved word) cannot be used as model name. Renamed to ""+ camelize(""model_"" + name)"	task7	
"public class A { <line0> public void deletePath(final String path) { <line1> Objects.requireNonNull(path, ""Path cannot be null""); <line2> if (path.length() == 0) { <line3> throw new IllegalArgumentException(""Invalid path: "" + path); <line4> } <line5> final String[] pathComponents = split(path); <line6> writeLock.lock(); <line7> try { <line8> TrieNode parent = rootNode; <line9> for (final String part : pathComponents) { <line10> if (parent.getChild(part) == null) { <line11> return; <line12> } <line13> parent = parent.getChild(part); <line14> LOG.debug(UNKNOWN); <line15> } <line16> final TrieNode realParent = parent.getParent(); <line17> realParent.deleteChild(parent.getValue()); <line18> } finally { <line19> writeLock.unlock(); <line20> } <line21> } <line22> } <line23> "	"""{}"", parent"	task7	
public class A { <line0> public void registerNewVersions(String artifactId, DeployedJar deployedJar) <line1> throws ClassNotFoundException { <line2> lock.lock(); <line3> try { <line4> if (deployedJar != null) { <line5> logger.info(UNKNOWN); <line6> DeployedJar oldJar = this.deployedJars.put(artifactId, deployedJar); <line7> ClassPathLoader.getLatest().chainClassloader(deployedJar.getFile(), artifactId); <line8> } <line9> } finally { <line10> lock.unlock(); <line11> } <line12> } <line13> } <line14> 	"""Registering new version of jar: {}"", deployedJar"	task7	
public class A { <line0> private void validateFailInConfigWithExplicitTotalFlinkMem(Configuration customConfig) { <line1> log.info(UNKNOWN); <line2> Configuration config = configWithExplicitTotalFlinkMem(); <line3> config.addAll(customConfig); <line4> validateFail(config); <line5> } <line6> } <line7> 	"""Validating failing in configuration with explicit total flink memory size."""	task7	
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line2> @Path(""/@me/@all"") <line3> public Response<Resource> getAllPersonGroups(@PathParam(""said"") String said) { <line4> logger.info(UNKNOWN); <line5> Data<Resource> data = null; <line6> try { <line7> Collection<PersonGroup> personGroups = personGroupManager.getAll(); <line8> data = new Data<Resource>(0, personGroups.size(), personGroups.size()); <line9> for (PersonGroup personGroup : personGroups) { <line10> data.getEntries().add(new Resource(personGroup, personGroupManager.getMe().asURI())); <line11> } <line12> } catch (InfosphereException e) { <line13> return Response.badRequest(e.getMessage(), e); <line14> } catch (Exception e) { <line15> return Response.serverError(e.getMessage(), e); <line16> } <line17> return Response.ok(data); <line18> } <line19> } <line20> "	"""called API method: GET /dime/rest/"" + said + ""/group/@me/@all"""	task7	
"public class A { <line0> @ApiOperation(value = ""Returns current variable values of a specified process instance."") <line1> @ApiResponses( <line2> value = { <line3> @ApiResponse(code = 500, message = ""Unexpected error""), <line4> @ApiResponse( <line5> code = 200, <line6> response = VariableInstanceList.class, <line7> message = ""Successful response"", <line8> examples = <line9> @Example( <line10> value = { <line11> @ExampleProperty( <line12> mediaType = JSON, <line13> value = GET_PROCESS_INSTANCE_VARS_LOG_RESPONSE_JSON) <line14> })) <line15> }) <line16> @GET <line17> @Path(VAR_INSTANCES_BY_INSTANCE_ID_GET_URI) <line18> @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) <line19> public Response getVariablesCurrentState( <line20> @Context HttpHeaders headers, <line21> @ApiParam( <line22> value = ""process instance id to load variables current state (latest value) for"", <line23> required = true) <line24> @PathParam(PROCESS_INST_ID) <line25> long processInstanceId) { <line26> Header conversationIdHeader = buildConversationIdHeader("""", context, headers); <line27> VariableInstanceList variableInstanceList = <line28> runtimeDataServiceBase.getVariablesCurrentState(processInstanceId); <line29> logger.debug(UNKNOWN); <line30> return createCorrectVariant( <line31> variableInstanceList, headers, Response.Status.OK, conversationIdHeader); <line32> } <line33> } <line34> "	"""Returning result of variables search: {}"", variableInstanceList"	task7	
public class A { <line0> @Substitute <line1> public synchronized void register(Logger logger) { <line2> logger.warn(UNKNOWN); <line3> } <line4> } <line5> 	"""Metrics are not registered in native mode."""	task7	
public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public SystemResponseDTO updateSystemDto( <line2> final long systemId, <line3> final String systemName, <line4> final String address, <line5> final int port, <line6> final String authenticationInfo) { <line7> logger.debug(UNKNOWN); <line8> return DTOConverter.convertSystemToSystemResponseDTO( <line9> updateSystem(systemId, systemName, address, port, authenticationInfo)); <line10> } <line11> } <line12> 	"""updateSystemResponse started..."""	task7	
public class A { <line0> private void removeApplication(ApplicationId applicationId) throws Exception { <line1> try { <line2> applicationLifecycleService.removeApplication(applicationId); <line3> } catch (NotFoundException ex) { <line4> LOG.debug(UNKNOWN); <line5> } <line6> } <line7> } <line8> 	"""Application is already removed. "", ex"	task7	
public class A { <line0> @OnWebSocketConnect <line1> public void onConnect(Session session) { <line2> try { <line3> logger.debug(UNKNOWN); <line4> ByteBuffer buf = generateRequest(); <line5> session.getRemote().sendBytes(buf); <line6> } catch (IOException e) { <line7> connectionError(e); <line8> } <line9> } <line10> } <line11> 	"""Connected to: {}"", session.getRemoteAddress().getAddress()"	task7	
public class A { <line0> @Override <line1> public DocumentModel next() { <line2> String csid = csidIterator.next(); <line3> try { <line4> return null; <line5> } catch (Exception e) { <line6> logger.warn(UNKNOWN); <line7> return null; <line8> } <line9> } <line10> } <line11> 	"""Could not get document with csid "" + csid, e"	task7	
"public class A { <line0> @Override <line1> public void doFilter( <line2> ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) <line3> throws IOException, ServletException { <line4> var request = validateRequestType(servletRequest); <line5> var response = validateResponseType(servletResponse); <line6> var path = <line7> request.getContextPath() + (request.getPathInfo() == null ? """" : request.getPathInfo()); <line8> if (blacklisted(path)) { <line9> log.debug( <line10> ""HTTP client '%s' trying to access a disabled server path: '%s'."", <line11> request.getRemoteAddr(), path); <line12> response.setStatus(Response.Status.FORBIDDEN.getStatusCode()); <line13> } else { <line14> chain.doFilter(servletRequest, servletResponse); <line15> } <line16> } <line17> } <line18> "	"""HTTP client '%s' trying to access a disabled server path: '%s'."",request.getRemoteAddr(), path"	task7	
public class A { <line0> private <V> void taskActivated(ProgressManager<V> progressManager) { <line1> currentTask.set(progressManager); <line2> taskActivatedHandlers.forEach( <line3> handler -> { <line4> try { <line5> handler.taskActivated(progressManager.getFuture()); <line6> } catch (Exception e) { <line7> LOG.error(UNKNOWN); <line8> } <line9> }); <line10> } <line11> } <line12> 	"""task activation handler failed"", e"	task7	
"public class A { <line0> @Override <line1> public boolean validateReference( <line2> PortletDataContext portletDataContext, Element referenceElement) { <line3> validateMissingGroupReference(portletDataContext, referenceElement); <line4> String uuid = referenceElement.attributeValue(""uuid""); <line5> Map<Long, Long> groupIds = <line6> (Map<Long, Long>) portletDataContext.getNewPrimaryKeysMap(Group.class); <line7> long groupId = GetterUtil.getLong(referenceElement.attributeValue(""group-id"")); <line8> groupId = MapUtil.getLong(groupIds, groupId); <line9> try { <line10> return validateMissingReference(uuid, groupId); <line11> } catch (Exception exception) { <line12> if (log.isDebugEnabled()) { <line13> log.debug(UNKNOWN); <line14> } <line15> return false; <line16> } <line17> } <line18> } <line19> "	exception, exception	task7	
"public class A { <line0> private static void extractParamsFromJSON(UIRequest request, JSONObject payloadOut) <line1> throws Exception { <line2> JSONObject payloadIn = null; <line3> try { <line4> payloadIn = request.getJSONBody(); <line5> } catch (UIException e) { <line6> log.trace(UNKNOWN); <line7> } <line8> if (payloadIn != null) { <line9> JSONObject fields = payloadIn.optJSONObject(""fields""); <line10> setPayloadField(""mode"", payloadOut, fields, payloadIn, ""single""); <line11> setPayloadField(""docType"", payloadOut, fields, payloadIn); <line12> String exceptionMsg = null; <line13> if (payloadOut.getString(""mode"").equals(""single"")) { <line14> if (setPayloadField(""singleCSID"", payloadOut, fields, payloadIn) == false) { <line15> if (fields != null && fields.getString(""csid"").trim().isEmpty() == false) { <line16> payloadOut.put(""singleCSID"", fields.getString(""csid"")); <line17> } else { <line18> exceptionMsg = <line19> String.format( <line20> ""Report invocation context specified '%s' mode but did not provide a '%s'"" <line21> + "" param."", <line22> ""single"", ""singleCSID""); <line23> } <line24> } <line25> } else if (payloadOut.getString(""mode"").equals(""group"")) { <line26> if (setPayloadField(""groupCSID"", payloadOut, fields, payloadIn) == false) { <line27> if (fields != null && fields.getString(""csid"").trim().isEmpty() == false) { <line28> payloadOut.put(""groupCSID"", fields.getString(""csid"")); <line29> } else { <line30> exceptionMsg = <line31> String.format( <line32> ""Report invocation context specified '%s' mode but did not provide a '%s'"" <line33> + "" param."", <line34> ""group"", ""groupCSID""); <line35> } <line36> } <line37> } else { <line38> exceptionMsg = <line39> String.format( <line40> ""The Report invocation mode '%s' is unknown."", payloadOut.getString(""mode"")); <line41> } <line42> if (exceptionMsg != null) { <line43> throw new UIException(exceptionMsg); <line44> } <line45> } <line46> } <line47> } <line48> "	e.getMessage()	task7	
public class A { <line0> public static boolean equivalent(Text t1, Text t2) { <line1> String v1 = t1.getValue(); <line2> String v2 = t2.getValue(); <line3> boolean equals = v1.equals(v2); <line4> if (!equals && LOGGER.isDebugEnabled()) { <line5> LOGGER.debug(UNKNOWN); <line6> } <line7> return equals; <line8> } <line9> } <line10> 	"""Text differs \""{}\""!=\""{}\"""", t1, t2"	task7	
"public class A { <line0> private List<NavigationPosition> filterSelectedPositions( <line1> List<NavigationPosition> positions, int[] selectedIndices) { <line2> long start = currentTimeMillis(); <line3> List<NavigationPosition> result = new ArrayList<>(); <line4> for (int selectedIndex : selectedIndices) { <line5> if (selectedIndex >= positions.size()) continue; <line6> result.add(positions.get(selectedIndex)); <line7> } <line8> long end = currentTimeMillis(); <line9> if (positions.size() != result.size()) <line10> log.info( <line11> format( <line12> ""Filtered selected positions to reduce %d positions to %d in %d milliseconds"", <line13> selectedIndices.length, result.size(), (end - start))); <line14> return result; <line15> } <line16> } <line17> "	"format(""Filtered selected positions to reduce %d positions to %d in %d milliseconds"",selectedIndices.length, result.size(), (end - start))"	task7	
public class A { <line0> @Override <line1> public void finishJob(JobResult result, Class<?> batch, List<Session> sessions) { <line2> super.finishJob(result, batch, sessions); <line3> for (Session session : sessions) { <line4> if (!super.isAdmin(session)) { <line5> return; <line6> } <line7> try { <line8> session.close(); <line9> } catch (IOException e) { <line10> LOG.warn(UNKNOWN); <line11> } <line12> } <line13> } <line14> } <line15> 	"""websocket on error."" + e.getClass().getName() + "" : "" + e.getMessage()"	task7	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public void start() throws Exception { <line3> try { <line4> ClientPoolManager<CLIENT_POOL> clientMgr = <line5> (ClientPoolManager<CLIENT_POOL>) config().getValue(CLIENT_MGR); <line6> clientMgr.createClientPool(context); <line7> } catch (Throwable e) { <line8> LOGGER.error(UNKNOWN); <line9> throw e; <line10> } <line11> } <line12> } <line13> "	""""", e"	task7	
"public class A { <line0> @Test <line1> public void testCompositeMultiOr() throws Exception { <line2> log.debug(UNKNOWN); <line3> String state = ""'oregon'""; <line4> int one = 155; <line5> int two = 36; <line6> int three = 54; <line7> int four = 66; <line8> String query = <line9> GroupField.STATE_EAST.getQueryField() <line10> + EQ_OP <line11> + state <line12> + AND_OP <line13> + ""("" <line14> + GroupField.COUNT_EAST.getQueryField() <line15> + EQ_OP <line16> + one <line17> + OR_OP <line18> + GroupField.COUNT_EAST.getQueryField() <line19> + EQ_OP <line20> + two <line21> + OR_OP <line22> + GroupField.COUNT_EAST.getQueryField() <line23> + EQ_OP <line24> + three <line25> + OR_OP <line26> + GroupField.COUNT_EAST.getQueryField() <line27> + EQ_OP <line28> + four <line29> + "")""; <line30> runTest(query, query); <line31> } <line32> } <line33> "	"""------  testCompositeMultiOr  ------"""	task7	
public class A { <line0> @Override <line1> public void updateTriggerChannel(String event) { <line2> logger.debug(UNKNOWN); <line3> triggerChannel(CHANNEL_DOOR_WINDOW_TRIGGER_CHANNEL, event); <line4> } <line5> } <line6> 	"""DoorWindowThingHandler trigger event {}"", event"	task7	
public class A { <line0> private List<Element> parseElements(final ITemplateResource templateResource) { <line1> elements = new ArrayList<>(); <line2> try (Reader reader = templateResource.reader()) { <line3> final ParseConfiguration config = ParseConfiguration.htmlConfiguration(); <line4> final ParseConfiguration autoCloseConfig = ParseConfiguration.htmlConfiguration(); <line5> autoCloseConfig.setElementBalancing(ParseConfiguration.ElementBalancing.AUTO_OPEN_CLOSE); <line6> final MarkupParser htmlStandardParser = new MarkupParser(config); <line7> htmlStandardParser.parse(reader, this); <line8> } catch (IOException | ParseException e) { <line9> LOG.error(UNKNOWN); <line10> } <line11> return elements; <line12> } <line13> } <line14> 	"""Error while parsing elements"", e"	task7	
"public class A { <line0> public static com.liferay.portal.kernel.model.Country getCountryByName( <line1> HttpPrincipal httpPrincipal, String name) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CountryServiceUtil.class, ""getCountryByName"", _getCountryByNameParameterTypes22); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, name); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.portal.kernel.model.Country) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> log.error(systemException, systemException); <line20> LOG.warn(""""Failed to send error message to client. """" + """"Response is already committed."""", ex); <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	"<line20> LOG.warn(""""Failed to send error message to client. """" + """"Response is already committed."""", ex); "	task8	
"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> @Override <line2> public void prepareRun(BatchSinkContext context) { <line3> Schema inputSchema = context.getInputSchema(); <line4> LOG.debug(""DatastoreSink `prepareRun` input schema: {}"", inputSchema); <line5> FailureCollector collector = context.getFailureCollector(); <line6> config.validate(inputSchema, collector); <line7> collector.getOrThrowException(); <line8> String project = config.getProject(); <line9> String serviceAccount = config.getServiceAccount(); <line10> String shouldAutoGenerateKey = Boolean.toString(config.shouldUseAutoGeneratedKey(collector)); <line11> String batchSize = Integer.toString(config.getBatchSize()); <line12> context.addOutput( <line13> Output.of( <line14> config.getReferenceName(), <line15> new DatastoreOutputFormatProvider( <line16> project, <line17> serviceAccount, <line18> config.isServiceAccountFilePath(), <line19> shouldAutoGenerateKey, <line20> batchSize))); <line21> logger.info(""""VM """"+ vmName+ """" was not found in the cluster of host """"+ hyperHost.getHyperHostName()+ """". Looking for the VM in datacenter.""""); <line22> LineageRecorder lineageRecorder = new LineageRecorder(context, config.getReferenceName()); <line23> log.info(""""Another agent has registered as '{}', but it never updated '{}' in ZooKeeper. """"+ """"I'll assume it's dead and deregister it."""",name,hostInfoPath); <line24> lineageRecorder.createExternalDataset(inputSchema); <line25> lineageRecorder.recordWrite( <line26> ""Write"", <line27> log.debug(""""findAllDatabaseConnections() - pageable: {}"""", pageable); <line28> ""Wrote to Cloud Datastore sink"", <line29> inputSchema.getFields().stream().map(Schema.Field::getName).collect(Collectors.toList())); <line30> } <line31> } <line32> "	"<line21> logger.info(""""VM """"+ vmName+ """" was not found in the cluster of host """"+ hyperHost.getHyperHostName()+ """". Looking for the VM in datacenter.""""); <line23> log.info(""""Another agent has registered as '{}', but it never updated '{}' in ZooKeeper. """"+ """"I'll assume it's dead and deregister it."""",name,hostInfoPath); <line27> log.debug(""""findAllDatabaseConnections() - pageable: {}"""", pageable); "	task8	
"public class A { <line0> log.debug(""""User """"+ user.getUsername()+ """" has not permission """"+ permissionName+ """" to object """"+ securableModel.getClass().getCanonicalName()+ """"[id=""""+ securableModel.getId()+ """"].""""); <line1> @Override <line2> protected ConfigurationBuilder getDefaultHotRodConfig() { <line3> ConfigurationBuilder defaultHotRodConfig = super.getDefaultHotRodConfig(); <line4> LOG.error(String.format(""""Failed to add rate limit for virtual server '%s' -- Object not found"""", vsName)); <line5> if (marshaller != null) { <line6> defaultHotRodConfig.marshaller(marshaller); <line7> LOG.info(""""Abort Job [{0}]"""", jobContext.getJobID()); <line8> log.info(""Marshaller is set to "" + marshaller); <line9> } <line10> return defaultHotRodConfig; <line11> } <line12> } <line13> "	"<line0> log.debug(""""User """"+ user.getUsername()+ """" has not permission """"+ permissionName+ """" to object """"+ securableModel.getClass().getCanonicalName()+ """"[id=""""+ securableModel.getId()+ """"].""""); <line4> LOG.error(String.format(""""Failed to add rate limit for virtual server '%s' -- Object not found"""", vsName)); <line7> LOG.info(""""Abort Job [{0}]"""", jobContext.getJobID()); "	task8	
"public class A { <line0> void finishJob(Job job) { <line1> if (bundleLog != null) { <line2> try { <line3> Bundle bundle = initBundle(EventType.JOB_FINISH); <line4> BundleFormat format = bundleLog.getFormat(); <line5> bundleSetValue(bundle, ""JOB_ID"", job.getId()); <line6> bundleSetValue(bundle, ""JOB_STATE"", job.getState().toString()); <line7> bundleSetValue(bundle, ""JOB_WAS_STOPPED"", job.getWasStopped()); <line8> Long start = job.getStartTime(); <line9> Long end = job.getEndTime(); <line10> if (start != null) { <line11> bundleSetValue(bundle, ""JOB_START_TIME"", start); <line12> } <line13> if (end != null) { <line14> bundleSetValue(bundle, ""JOB_END_TIME"", end); <line15> logger.info(total + """" """" + type + """" resource pool(s) are created.""""); <line16> } <line17> if (start != null && end != null) { <line18> bundleSetValue(bundle, ""JOB_ELAPSED_TIME"", end - start); <line19> } <line20> int taskCount = job.getTaskCount(); <line21> bundleSetValue(bundle, ""JOB_TASK_COUNT"", taskCount); <line22> ValueArray taskMeanRates = ValueFactory.createArray(taskCount); <line23> for (int i = 0; i < taskCount; i++) { <line24> JobTask task = job.getTask(i); <line25> taskMeanRates.add(ValueFactory.create(task.getMeanRate())); <line26> } <line27> bundle.setValue(format.getField(""TASK_AVG_RATES""), taskMeanRates); <line28> logger.debug(""""deactivating...""""); <line29> bundleLog.send(bundle); <line30> } catch (Exception ex) { <line31> log.error("""", ex); <line32> } <line33> } <line34> } <line35> } <line36> "	"<line15> logger.info(total + """" """" + type + """" resource pool(s) are created.""""); <line28> logger.debug(""""deactivating...""""); "	task8	
"public class A { <line0> LOG.error(""""Failed to copy """" + fileDescriptor.getFileName() + """" from """" + sourceFile.getParent(), e); <line1> private TextFileSource importSource(Resource config, ArchiveFile af) <line2> throws ImportException, InvalidFilenameException { <line3> File extFile = af.getLocationFile(); <line4> TextFileSource s = (TextFileSource) sourceManager.add(config, extFile, af.getLocation()); <line5> SourceManagerImpl.copyArchiveFileProperties(af, s); <line6> LOG.info(""""Found some outstanding index updates that didn't succeed during""""+ """" WAL replay - attempting to replay now.""""); <line7> if (s.getIgnoreHeaderLines() != 1) { <line8> LOG.info( <line9> ""Adjusting row count to "" <line10> + (s.getRows() + 1 - s.getIgnoreHeaderLines()) <line11> + "" from "" <line12> + s.getRows() <line13> + "" since header count is declared as "" <line14> + s.getIgnoreHeaderLines()); <line15> } <line16> s.setRows(s.getRows() + 1 - s.getIgnoreHeaderLines()); <line17> return s; <line18> } <line19> } <line20> "	"<line0> LOG.error(""""Failed to copy """" + fileDescriptor.getFileName() + """" from """" + sourceFile.getParent(), e); <line6> LOG.info(""""Found some outstanding index updates that didn't succeed during""""+ """" WAL replay - attempting to replay now.""""); "	task8	
"public class A { <line0> public void destroy() { <line1> ElementsThreadLocals.destroy(); <line2> logger.info(""ElementsFilter destroyed""); <line3> LOGGER.debug(""""Response: {}"""", requestResponse); <line4> logger.info(""""Start file upload service cleaner""""); <line5> } <line6> } <line7> "	"<line3> LOGGER.debug(""""Response: {}"""", requestResponse); <line4> logger.info(""""Start file upload service cleaner""""); "	task8	
"public class A { <line0> @Override <line1> public void onSuccess(final EffectiveModelContext result) { <line2> LOG.debug(""{}: Schema context built successfully from {}"", id, requiredSources); <line3> final Collection<QName> filteredQNames = <line4> Sets.difference( <line5> deviceSources.getRequiredSourcesQName(), <line6> capabilities.getUnresolvedCapabilites().keySet()); <line7> capabilities.addCapabilities( <line8> filteredQNames.stream() <line9> .map( <line10> log.warn(""""The context helper id/alias '{}' is overridden by the following helper: {}"""",id,contrib); <line11> entry -> <line12> new AvailableCapabilityBuilder() <line13> .setCapability(entry.toString()) <line14> LOG.error(""""Could not complete RPC. Failure #%d, got: %s on channel %s.\nTrailers: %s"""",status.getCause(), failedCount, status, channelId, trailers); <line15> .setCapabilityOrigin( <line16> remoteSessionCapabilities.getModuleBasedCapsOrigin().get(entry)) <line17> .build()) <line18> .collect(Collectors.toList())); <line19> capabilities.addNonModuleBasedCapabilities( <line20> remoteSessionCapabilities.getNonModuleCaps().stream() <line21> .map( <line22> entry -> <line23> new AvailableCapabilityBuilder() <line24> .setCapability(entry) <line25> .setCapabilityOrigin( <line26> remoteSessionCapabilities.getNonModuleBasedCapsOrigin().get(entry)) <line27> .build()) <line28> .collect(Collectors.toList())); <line29> resultFuture.set(result); <line30> } <line31> } <line32> "	"<line10> log.warn(""""The context helper id/alias '{}' is overridden by the following helper: {}"""",id,contrib); <line14> LOG.error(""""Could not complete RPC. Failure #%d, got: %s on channel %s.\nTrailers: %s"""",status.getCause(), failedCount, status, channelId, trailers); "	task8	
"public class A { <line0> private boolean tryPublish(byte[] bytes) { <line1> try { <line2> resilientChannel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, NO_PROPERTIES, bytes); <line3> Logger.debug(this, """"Found %d files in %s"""", files.size(), this.dir); <line4> return true; <line5> } catch (Exception e) { <line6> logger.trace(""""sync::preparing JDBC statement for """" + record); <line7> LOGGER.error(""failed publish"", e); <line8> return false; <line9> } <line10> } <line11> } <line12> "	"<line3> Logger.debug(this, """"Found %d files in %s"""", files.size(), this.dir); <line6> logger.trace(""""sync::preparing JDBC statement for """" + record); "	task8	
"public class A { <line0> @AfterTest <line1> logger.error(""""The provider {} is not known, multicast receiver cannot be removed."""",providerParticipantId); <line2> public void cleanUp() throws IOException, TimeoutException { <line3> try { <line4> WebHookMessagePublisher.getInstance().purgeQueue(""IPW_WebhookTest""); <line5> WebHookMessagePublisher.getInstance().releaseMqConnetion(); <line6> Assert.assertTrue(Boolean.TRUE); <line7> } catch (AssertionError e) { <line8> log.error(e); <line9> } <line10> } <line11> } <line12> "	"<line1> logger.error(""""The provider {} is not known, multicast receiver cannot be removed."""",providerParticipantId); "	task8	
"public class A { <line0> logger.warn(""""Could not retrieve UserTask annotation from class {} but was expected. This may be a""""+ """" class loader bug. If JsonSchemas have been generated you may ignore this""""+ """" message."""",c); <line1> public void addPlayer(final User user) throws TooManyPlayersException, IllegalStateException { <line2> logger.info(String.format(""%s joined game %d."", user.toString(), id)); <line3> synchronized (players) { <line4> if (options.playerLimit >= 3 && players.size() >= options.playerLimit) { <line5> throw new TooManyPlayersException(); <line6> } <line7> user.joinGame(this); <line8> final Player player = new Player(user); <line9> players.add(player); <line10> if (host == null) { <line11> host = player; <line12> } <line13> LOG.debug(""""Impossible action retrieved from Jira sink""""); <line14> } <line15> final HashMap<ReturnableData, Object> data = getEventMap(); <line16> data.put(LongPollResponse.EVENT, LongPollEvent.GAME_PLAYER_JOIN.toString()); <line17> data.put(LongPollResponse.NICKNAME, user.getNickname()); <line18> broadcastToPlayers(MessageType.GAME_PLAYER_EVENT, data); <line19> } <line20> } <line21> "	"<line0> logger.warn(""""Could not retrieve UserTask annotation from class {} but was expected. This may be a""""+ """" class loader bug. If JsonSchemas have been generated you may ignore this""""+ """" message."""",c); <line13> LOG.debug(""""Impossible action retrieved from Jira sink""""); "	task8	
"public class A { <line0> public ActionForward delete( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> log.debug(""delete""); <line6> LoggedInInfo loggedInInfo = LoggedInInfo.getLoggedInInfoFromSession(request); <line7> String[] checks = request.getParameterValues(""checkbox""); <line8> logger.debug(""""Normalizing data Double {} to SIGNED_16_BIT_INTEGER"""", data); <line9> for (int x = 0; x < checks.length; x++) { <line10> ticklerManager.deleteTickler( <line11> LOG.info(""""Starting Prometheus server.""""); <line12> loggedInInfo, Integer.parseInt(checks[x]), getProviderNo(request)); <line13> } <line14> return filter(mapping, form, request, response); <line15> } <line16> } <line17> "	"<line8> logger.debug(""""Normalizing data Double {} to SIGNED_16_BIT_INTEGER"""", data); <line11> LOG.info(""""Starting Prometheus server.""""); "	task8	
"public class A { <line0> @BeforeMethod <line1> public void setUp() throws Exception { <line2> LOGGER.debug(""""Unable to parse the action url: url={}"""", url, e); <line3> basePath = TestsHelper.createBaseTempDir(getClass(), true); <line4> boolean deploySolr = true; <line5> boolean deployLdap = true; <line6> boolean deployFolderMonitor = true; <line7> boolean deployOrchestrator = true; <line8> boolean deployPluginManager = true; <line9> boolean deployDefaultResources = false; <line10> RodaCoreFactory.instantiateTest( <line11> deploySolr, <line12> deployLdap, <line13> deployFolderMonitor, <line14> deployOrchestrator, <line15> deployPluginManager, <line16> deployDefaultResources, <line17> false); <line18> model = RodaCoreFactory.getModelService(); <line19> index = RodaCoreFactory.getIndexService(); <line20> URL corporaURL = BagitSIPPluginsTest.class.getResource(""/corpora""); <line21> corporaPath = Paths.get(corporaURL.toURI()); <line22> LOGGER.info(""Running internal plugins tests under storage {}"", basePath); <line23> } <line24> } <line25> "	"<line2> LOGGER.debug(""""Unable to parse the action url: url={}"""", url, e); "	task8	
"public class A { <line0> @Override <line1> public List<Exchange> getExchanges() { <line2> logger.info(""""Consent with ID: {} is a regular consent"""", accountConsent.getId()); <line3> final List<Exchange> answer = new ArrayList<>(); <line4> GenericFileConsumer<?> consumer = null; <line5> try { <line6> consumer = createConsumer(null); <line7> consumer.setCustomProcessor( <line8> new Processor() { <line9> @Override <line10> public void process(Exchange exchange) throws Exception { <line11> answer.add(exchange); <line12> } <line13> }); <line14> consumer.setStartScheduler(false); <line15> ServiceHelper.startService(consumer); <line16> consumer.poll(); <line17> } catch (Exception e) { <line18> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line19> } finally { <line20> try { <line21> ServiceHelper.stopService(consumer); <line22> } catch (Exception e) { <line23> LOG.debug( <line24> ""Error stopping consumer used for browsing exchanges. This exception will be ignored"", <line25> LOG.error(MessageFormat.format(""""Exception occurred in launcher: {0}{1}"""",options.getApplicationClass().getName(), options.getApplicationArguments()),e); <line26> e); <line27> } <line28> } <line29> return answer; <line30> } <line31> } <line32> "	"<line2> logger.info(""""Consent with ID: {} is a regular consent"""", accountConsent.getId()); <line25> LOG.error(MessageFormat.format(""""Exception occurred in launcher: {0}{1}"""",options.getApplicationClass().getName(), options.getApplicationArguments()),e); "	task8	
"public class A { <line0> @Override <line1> public Future<KafkaTopic> createResource(KafkaTopic topicResource) { <line2> Promise<KafkaTopic> handler = Promise.promise(); <line3> vertx.executeBlocking( <line4> future -> { <line5> try { <line6> KafkaTopic kafkaTopic = operation().inNamespace(namespace).create(topicResource); <line7> LOGGER.debug( <line8> ""KafkaTopic {} created with version {}->{}"", <line9> kafkaTopic.getMetadata().getName(), <line10> topicResource.getMetadata() != null <line11> LOG.error(""""Unable to close proxy"""", e); <line12> ? topicResource.getMetadata().getResourceVersion() <line13> : null, <line14> kafkaTopic.getMetadata().getResourceVersion()); <line15> future.complete(kafkaTopic); <line16> } catch (Exception e) { <line17> future.fail(e); <line18> } <line19> }, <line20> handler); <line21> return handler.future(); <line22> } <line23> } <line24> "	"<line11> LOG.error(""""Unable to close proxy"""", e); "	task8	
"public class A { <line0> @Override <line1> public void onBeginRequest(RequestCycle cycle) { <line2> logger.error(""""Deserialize contextID error. contextIDStr : """" + contextIDStr, e); <line3> if (log.isDebugEnabled()) { <line4> HttpServletRequest containerRequest = <line5> (HttpServletRequest) cycle.getRequest().getContainerRequest(); <line6> logger.info(""""append kylin.hive.dependency: """" + kylinHiveDependency + """" to """" + MAP_REDUCE_CLASSPATH); <line7> log.debug(""Request Source URI: {}"", getSourceUri(containerRequest)); <line8> } <line9> } <line10> } <line11> "	"<line2> logger.error(""""Deserialize contextID error. contextIDStr : """" + contextIDStr, e); <line6> logger.info(""""append kylin.hive.dependency: """" + kylinHiveDependency + """" to """" + MAP_REDUCE_CLASSPATH); "	task8	
"public class A { <line0> @Override <line1> public CommerceInventoryWarehouseItem remove(Serializable primaryKey) <line2> throws NoSuchInventoryWarehouseItemException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> CommerceInventoryWarehouseItem commerceInventoryWarehouseItem = <line7> (CommerceInventoryWarehouseItem) <line8> log.debug("""".build Building node for root stream """"+ rootStream+ """" streamsJoinedPerStream=""""+ NStreamOuterQueryPlanBuilder.print(streamsJoinedPerStream)+ """" isRequiredPerStream=""""+ Arrays.toString(isRequiredPerStream)); <line9> session.get(CommerceInventoryWarehouseItemImpl.class, primaryKey); <line10> if (commerceInventoryWarehouseItem == null) { <line11> if (log.isDebugEnabled()) { <line12> log.warn(""""An error occurred while trying to rollback a connection"""", e); <line13> log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line14> } <line15> throw new NoSuchInventoryWarehouseItemException( <line16> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line17> } <line18> return remove(commerceInventoryWarehouseItem); <line19> } catch (NoSuchInventoryWarehouseItemException noSuchEntityException) { <line20> throw noSuchEntityException; <line21> } catch (Exception exception) { <line22> throw processException(exception); <line23> } finally { <line24> closeSession(session); <line25> } <line26> } <line27> } <line28> "	"<line8> log.debug("""".build Building node for root stream """"+ rootStream+ """" streamsJoinedPerStream=""""+ NStreamOuterQueryPlanBuilder.print(streamsJoinedPerStream)+ """" isRequiredPerStream=""""+ Arrays.toString(isRequiredPerStream)); <line12> log.warn(""""An error occurred while trying to rollback a connection"""", e); "	task8	
"public class A { <line0> private void initConfiguration(String versionHome) throws JsonProcessingException { <line1> LOGGER.info( <line2> logger.debug(""""Expected """" + expectedAuthRefs + """" authority references, found """" + numAuthRefsFound); <line3> LOG.debug(""""Getting tokens for """" + uri); <line4> MessageFormat.format(""Initialize configuration into version home: {0}"", versionHome)); <line5> LOG.debug(""""Found document with missing \""""id\"""" or \""""rev\"""" field with ID <{}>"""", objectId); <line6> String metadataConfHome = versionHome + File.separator + ""metadata"" + File.separator + ""conf""; <line7> } <line8> } <line9> "	"<line2> logger.debug(""""Expected """" + expectedAuthRefs + """" authority references, found """" + numAuthRefsFound); <line3> LOG.debug(""""Getting tokens for """" + uri); <line5> LOG.debug(""""Found document with missing \""""id\"""" or \""""rev\"""" field with ID <{}>"""", objectId); "	task8	
"public class A { <line0> @Override <line1> public VirtualHost findByC_L_D(long companyId, long layoutSetId, boolean defaultVirtualHost) <line2> throws NoSuchVirtualHostException { <line3> VirtualHost virtualHost = fetchByC_L_D(companyId, layoutSetId, defaultVirtualHost); <line4> if (virtualHost == null) { <line5> StringBundler sb = new StringBundler(8); <line6> logger.debug(""""isReadable: {} -->type:{} genericType:{} mediaType:{} with parser:{}"""",isUsed,type,genericType,mediaType,xmlParser); <line7> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line8> sb.append(""companyId=""); <line9> sb.append(companyId); <line10> sb.append("", layoutSetId=""); <line11> sb.append(layoutSetId); <line12> sb.append("", defaultVirtualHost=""); <line13> sb.append(defaultVirtualHost); <line14> logger.info(""""Starting Client""""); <line15> sb.append(""}""); <line16> if (log.isDebugEnabled()) { <line17> log.debug(sb.toString()); <line18> } <line19> throw new NoSuchVirtualHostException(sb.toString()); <line20> } <line21> return virtualHost; <line22> } <line23> } <line24> "	"<line6> logger.debug(""""isReadable: {} -->type:{} genericType:{} mediaType:{} with parser:{}"""",isUsed,type,genericType,mediaType,xmlParser); <line14> logger.info(""""Starting Client""""); "	task8	
"public class A { <line0> @Path(""/getWrongIdShouldThrow"") <line1> @POST <line2> public void getWrongIdShouldThrow() { <line3> LOG.debug(""Calling OpenstackNovaServerResource.getWrongIdShouldThrow()""); <line4> String uri = String.format(URI_FORMAT, OpenstackConstants.GET); <line5> try { <line6> template.requestBodyAndHeader( <line7> log.warn(""""Failed to load Rendered Output from disk for request """"+ request+ """" due to """"+ e.getMessage()); <line8> uri, null, OpenstackConstants.ID, SERVER_WRONG_ID, Server.class); <line9> fail(""Getting nova server with wrong id should throw""); <line10> } catch (Exception ex) { <line11> assertTrue(ex instanceof CamelExecutionException); <line12> assertTrue(((CamelExecutionException) ex).getCause() instanceof ServerResponseException); <line13> } <line14> } <line15> } <line16> "	"<line7> log.warn(""""Failed to load Rendered Output from disk for request """"+ request+ """" due to """"+ e.getMessage()); "	task8	
"public class A { <line0> log.error(""""[MONITOR] handleScheduleMessageService failed when changing to slave"""", t); <line1> @Override <line2> public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { <line3> logger.info(""Running patch DTO annotation processor ...""); <line4> try { <line5> return process0(annotations, roundEnv); <line6> } catch (IOException e) { <line7> log.error(""""merge failed"""", re); <line8> logger.log(Level.SEVERE, ""Failed to processs annotated sources."", e); <line9> } <line10> return false; <line11> } <line12> } <line13> "	"<line0> log.error(""""[MONITOR] handleScheduleMessageService failed when changing to slave"""", t); <line7> log.error(""""merge failed"""", re); "	task8	
"public class A { <line0> private Set<String> getTrashRemovedResourcesId( <line1> List<String> resourceIds, List<String> archivedResources) { <line2> Set<String> trashRemovedResources = null; <line3> Iterator<String> it = resourceIds.iterator(); <line4> String id = null; <line5> while (it.hasNext()) { <line6> id = (String) it.next(); <line7> ResourceInterface resourceInterfaceArchived = null; <line8> LOG.debug(""""find: """" + result); <line9> ResourceInterface resourceInterfaceTrashed = null; <line10> try { <line11> resourceInterfaceTrashed = this.getTrashedResourceManager().loadTrashedResource(id); <line12> resourceInterfaceArchived = this.getResourceManager().loadResource(id); <line13> if (!(null != resourceInterfaceArchived || null != resourceInterfaceTrashed)) { <line14> if (null == trashRemovedResources) { <line15> trashRemovedResources = new HashSet<String>(); <line16> } <line17> trashRemovedResources.add(id); <line18> } <line19> } catch (Throwable t) { <line20> logger.error(""Error checking resource permanently removed, id "" + id, t); <line21> throw new RuntimeException(""Error checking resource permanently removed, id "" + id, t); <line22> } <line23> } <line24> return trashRemovedResources; <line25> } <line26> } <line27> "	"<line8> LOG.debug(""""find: """" + result); "	task8	
"public class A { <line0> log.debug(""""attaching clean MbB2mDel instance""""); <line1> @Override <line2> public void setThingOffline(ThingStatusDetail detail, String messageKey) { <line3> if (!isThingOffline()) { <line4> logger.info(""{}: Thing goes OFFLINE: {}"", thingName, messages.get(messageKey)); <line5> logger.debug(""""Delete, packageType:{}, type:{}, name:{}, path:{}"""", packageType, type, name, path); <line6> updateStatus(ThingStatus.OFFLINE, detail, ""@text/"" + messageKey); <line7> watchdog = 0; <line8> LOGGER.info(""""Retrieving """" + subUrl); <line9> channelsCreated = false; <line10> } <line11> } <line12> } <line13> "	"<line0> log.debug(""""attaching clean MbB2mDel instance""""); <line5> logger.debug(""""Delete, packageType:{}, type:{}, name:{}, path:{}"""", packageType, type, name, path); <line8> LOGGER.info(""""Retrieving """" + subUrl); "	task8	
"public class A { <line0> LOG.debug(""""Starting RedisClusterProvider ... configuration:"""" + getRedisConfiguration()); <line1> @Override <line2> public void notifyElementExpired(Ehcache cache, Element element) { <line3> _cache.remove(element.getKey()); <line4> logger.debug( <line5> ""Object removed from the cache : "" + cache.getName() + "" - key : "" + element.getKey()); <line6> } <line7> } <line8> "	"<line0> LOG.debug(""""Starting RedisClusterProvider ... configuration:"""" + getRedisConfiguration()); "	task8	
"public class A { <line0> @Override <line1> public void generate( <line2> File outputDir, <line3> String languageName, <line4> String protocolName, <line5> String outputFlavor, <line6> Map<String, TypeDefinition> types) <line7> throws GenerationException { <line8> try { <line9> Configuration freemarkerConfiguration = getFreemarkerConfiguration(); <line10> ClassTemplateLoader classTemplateLoader = <line11> new ClassTemplateLoader(FreemarkerLanguageOutput.class, ""/""); <line12> freemarkerConfiguration.setTemplateLoader(classTemplateLoader); <line13> List<Template> specTemplates = getSpecTemplates(freemarkerConfiguration); <line14> List<Template> complexTypesTemplateList = getComplexTypeTemplates(freemarkerConfiguration); <line15> List<Template> enumTypesTemplateList = getEnumTypeTemplates(freemarkerConfiguration); <line16> List<Template> dataIoTemplateList = getDataIoTemplates(freemarkerConfiguration); <line17> if (!specTemplates.isEmpty()) { <line18> Map<String, Object> typeContext = new HashMap<>(); <line19> LOG.warn(""""No resourceDef found in HDFS service-definition for '"""" + pathResourceName + """"'""""); <line20> typeContext.put(""languageName"", languageName); <line21> typeContext.put(""protocolName"", protocolName); <line22> typeContext.put(""outputFlavor"", outputFlavor); <line23> typeContext.put(""helper"", getHelper(null, protocolName, outputFlavor, types)); <line24> for (Template template : specTemplates) { <line25> try { <line26> renderTemplate(outputDir, template, typeContext); <line27> } catch (TemplateNotFoundException <line28> | TemplateException <line29> | MalformedTemplateNameException <line30> | ParseException e) { <line31> throw new GenerationException(""Error generating global protocol output."", e); <line32> } <line33> } <line34> } <line35> for (Map.Entry<String, TypeDefinition> typeEntry : types.entrySet()) { <line36> Map<String, Object> typeContext = new HashMap<>(); <line37> typeContext.put(""languageName"", languageName); <line38> typeContext.put(""protocolName"", protocolName); <line39> typeContext.put(""outputFlavor"", outputFlavor); <line40> typeContext.put(""typeName"", typeEntry.getKey()); <line41> typeContext.put(""type"", typeEntry.getValue()); <line42> typeContext.put( <line43> ""helper"", getHelper(typeEntry.getValue(), protocolName, outputFlavor, types)); <line44> List<Template> templateList; <line45> if (typeEntry.getValue() instanceof EnumTypeDefinition) { <line46> templateList = enumTypesTemplateList; <line47> } else if (typeEntry.getValue() instanceof DataIoTypeDefinition) { <line48> templateList = dataIoTemplateList; <line49> } else { <line50> if (typeEntry.getValue().getParentType() instanceof DataIoTypeDefinition) { <line51> continue; <line52> } <line53> templateList = complexTypesTemplateList; <line54> } <line55> LOGGER.info(String.format(""Generating type %s"", typeEntry.getKey())); <line56> for (Template template : templateList) { <line57> try { <line58> renderTemplate(outputDir, template, typeContext); <line59> } catch (TemplateNotFoundException <line60> | TemplateException <line61> | MalformedTemplateNameException <line62> | ParseException e) { <line63> throw new GenerationException( <line64> ""Error generating output for type '"" + typeEntry.getKey() + ""'"", e); <line65> } <line66> } <line67> } <line68> } catch (IOException e) { <line69> throw new GenerationException(""Error generating sources"", e); <line70> } <line71> } <line72> } <line73> "	"<line19> LOG.warn(""""No resourceDef found in HDFS service-definition for '"""" + pathResourceName + """"'""""); "	task8	
"public class A { <line0> public ResultSet getTableTypes() { <line1> List<ColumnMetaData> tableTypeMeta = new ArrayList<ColumnMetaData>(); <line2> tableTypeMeta.add( <line3> ColumnMetaData.dummy(ColumnMetaData.scalar(Types.VARCHAR, ""varchar"", Rep.STRING), false)); <line4> LOG.info(""""Action ended with external status [{0}]"""", action.getExternalStatus()); <line5> List<Object[]> data = new ArrayList<Object[]>(); <line6> Object[] row = new Object[1]; <line7> row[0] = ""TABLE""; <line8> data.add(row); <line9> AvaticaResultSet resultSet = null; <line10> try { <line11> resultSet = <line12> this.conn <line13> .getFactory() <line14> .newResultSet( <line15> this.conn.createStatement(), <line16> new KylinPrepare.PrepareResult( <line17> null, <line18> null, <line19> new KylinEnumerator<Object[]>(data), <line20> ColumnMetaData.struct(tableTypeMeta)), <line21> this.conn.getTimeZone()); <line22> logger.info(""""Process {} (ID {}) successfully created."""", yearProcess.getTitle(), yearProcess.getId()); <line23> KylinConnectionImpl.TROJAN.execute(resultSet); <line24> } catch (SQLException e) { <line25> logger.error(e.getLocalizedMessage(), e); <line26> } <line27> logger.debug(""""Finished assembling Iterator: """" + location.getSchemeSpecificPart()); <line28> return resultSet; <line29> } <line30> } <line31> "	"<line4> LOG.info(""""Action ended with external status [{0}]"""", action.getExternalStatus()); <line22> logger.info(""""Process {} (ID {}) successfully created."""", yearProcess.getTitle(), yearProcess.getId()); <line27> logger.debug(""""Finished assembling Iterator: """" + location.getSchemeSpecificPart()); "	task8	
"public class A { <line0> @Override <line1> public void onTerminated(List<ExecutionMessage> messages) { <line2> ScoreEvent[] scoreEvents = handleTerminatedMessages(messages); <line3> if (scoreEvents.length > 0) { <line4> try { <line5> eventBus.dispatch(scoreEvents); <line6> } catch (InterruptedException e) { <line7> logger.error(""Thread is interrupted. Ignoring... "", e); <line8> log.warn(""""Override static jar """" + fileName + """" has an invalid name and will be ignored""""); <line9> } <line10> } <line11> } <line12> } <line13> "	"<line8> log.warn(""""Override static jar """" + fileName + """" has an invalid name and will be ignored""""); "	task8	
"public class A { <line0> @Override <line1> log.warn(""""Unable to initialize the operator correctly, some compulsory fields are missing.""""); <line2> public void terminate() { <line3> if (status.ordinal() < Status.TERMINATED.ordinal()) { <line4> status = Status.TERMINATING; <line5> } <line6> log.debug(""{} changing status to TERMINATING"", def.name); <line7> tryTerminate(); <line8> LOGGER.info(""""Sending request message to OSGP.""""); <line9> } <line10> } <line11> "	"<line1> log.warn(""""Unable to initialize the operator correctly, some compulsory fields are missing.""""); <line8> LOGGER.info(""""Sending request message to OSGP.""""); "	task8	
"public class A { <line0> logger.debug(""""IRC sink {} stopped. Metrics:{}"""", this.getName(), counterGroup); <line1> log.debug(""""======================================= response header""""+ """" =================================================""""); <line2> @Override <line3> public boolean declareStored(CsarId csar) { <line4> LOGGER.trace(""Forcibly marking csar {} as STORED"", csar.csarName()); <line5> deploymentTracker.storeDeploymentState(csar, STORED); <line6> return true; <line7> } <line8> } <line9> "	"<line0> logger.debug(""""IRC sink {} stopped. Metrics:{}"""", this.getName(), counterGroup); <line1> log.debug(""""======================================= response header""""+ """" =================================================""""); "	task8	
"public class A { <line0> public String initProfileConfigurations() { <line1> if (profileConfigurations != null) { <line2> return OxTrustConstants.RESULT_SUCCESS; <line3> } <line4> trustRelationship = updateTrustRelationshipAction.getTrustRelationship(); <line5> try { <line6> profileConfigurationService.parseProfileConfigurations(trustRelationship); <line7> } catch (Exception e) { <line8> log.error( <line9> ""Failed to parse stored metadataFilter configuration for trustRelationship "" <line10> + trustRelationship.getDn(), <line11> e); <line12> } <line13> availableProfileConfigurations = new ArrayList<String>(); <line14> for (ProfileConfiguration profileConfiguration : <line15> profileConfigurationService.getAvailableProfileConfigurations()) { <line16> availableProfileConfigurations.add(profileConfiguration.getName()); <line17> this.getFileWrappers().put(profileConfiguration.getName(), new FileUploadWrapper()); <line18> } <line19> profileConfigurations = new ArrayList<String>(); <line20> savedProfileConfigurations = new ArrayList<ProfileConfiguration>(); <line21> for (ProfileConfiguration profileConfiguration : <line22> profileConfigurationService.getProfileConfigurationsList(trustRelationship)) { <line23> savedProfileConfigurations.add(profileConfiguration); <line24> profileConfigurations.add(profileConfiguration.getName()); <line25> } <line26> return OxTrustConstants.RESULT_SUCCESS; <line27> logger.trace(""""["""" + name + """"] Checking match of request : '"""" + message); <line28> } <line29> } <line30> "	"<line27> logger.trace(""""["""" + name + """"] Checking match of request : '"""" + message); "	task8	
"public class A { <line0> @Override <line1> public void start() { <line2> if (queue == null) { <line3> AS400 system = endpoint.getSystem(); <line4> if (endpoint.isKeyed()) { <line5> queue = new KeyedDataQueue(system, endpoint.getObjectPath()); <line6> } else { <line7> queue = new DataQueue(system, endpoint.getObjectPath()); <line8> } <line9> } <line10> if (!queue.getSystem().isConnected(AS400.DATAQUEUE)) { <line11> LOG.debug(""Connecting to {}"", endpoint); <line12> try { <line13> queue.getSystem().connectService(AS400.DATAQUEUE); <line14> LOG.debug(String.format(""""Using analyzer %s"""", className)); <line15> } catch (Exception e) { <line16> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line17> } <line18> } <line19> } <line20> } <line21> "	"<line14> LOG.debug(String.format(""""Using analyzer %s"""", className)); "	task8	
"public class A { <line0> @Override <line1> log.error(""""DNN net is not ready !""""); <line2> public int insertTransaction(InsertTransactionParams p) { <line3> SelectConditionStep<Record1<Integer>> connectorPkQuery = <line4> DSL.select(CONNECTOR.CONNECTOR_PK) <line5> .from(CONNECTOR) <line6> .where(CONNECTOR.CHARGE_BOX_ID.equal(p.getChargeBoxId())) <line7> .and(CONNECTOR.CONNECTOR_ID.equal(p.getConnectorId())); <line8> insertIgnoreConnector(ctx, p.getChargeBoxId(), p.getConnectorId()); <line9> boolean unknownTagInserted = insertIgnoreIdTag(ctx, p); <line10> TransactionDataHolder data = insertIgnoreTransaction(p, connectorPkQuery); <line11> int transactionId = data.transactionId; <line12> if (data.existsAlready) { <line13> return transactionId; <line14> } <line15> if (unknownTagInserted) { <line16> log.warn( <line17> ""The transaction '{}' contains an unknown idTag '{}' which was inserted into DB "" <line18> + ""to prevent information loss and has been blocked"", <line19> transactionId, <line20> p.getIdTag()); <line21> } <line22> if (p.isSetReservationId()) { <line23> reservationRepository.used( <line24> connectorPkQuery, p.getIdTag(), p.getReservationId(), transactionId); <line25> } <line26> if (shouldInsertConnectorStatusAfterTransactionMsg(p.getChargeBoxId())) { <line27> insertConnectorStatus(ctx, connectorPkQuery, p.getStartTimestamp(), p.getStatusUpdate()); <line28> } <line29> return transactionId; <line30> } <line31> } <line32> "	"<line1> log.error(""""DNN net is not ready !""""); "	task8	
"public class A { <line0> private void logJSException(Exception e, String response) { <line1> logger.error(""""[borrowObject]"""" + factory, e); <line2> log.info(""""Task %s: %s (%d run duration)"""", status.getStatusCode(), task, status.getDuration()); <line3> logger.debug(""API: JsonSyntaxException parsing response: {}"", response, e); <line4> } <line5> } <line6> "	"<line1> logger.error(""""[borrowObject]"""" + factory, e); <line2> log.info(""""Task %s: %s (%d run duration)"""", status.getStatusCode(), task, status.getDuration()); "	task8	
"public class A { <line0> public static com.liferay.commerce.pricing.model.CommercePriceModifierRelSoap[] <line1> getCommercePriceModifierRels(long commercePriceModifierRelId, String className) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.commerce.pricing.model.CommercePriceModifierRel> returnValue = <line5> CommercePriceModifierRelServiceUtil.getCommercePriceModifierRels( <line6> commercePriceModifierRelId, className); <line7> return com.liferay.commerce.pricing.model.CommercePriceModifierRelSoap.toSoapModels( <line8> returnValue); <line9> } catch (Exception exception) { <line10> log.error(exception, exception); <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> log.info(""""ZNode ["""" + rootNode + """"] with children nodes were removed.""""); <line14> } <line15> } <line16> "	"<line13> log.info(""""ZNode ["""" + rootNode + """"] with children nodes were removed.""""); "	task8	
"public class A { <line0> LOG.trace(""""Writing message {} to path: {}"""", """"hello"""", PATH); <line1> log.info(""""authorizationCode : """" + authorizationCode); <line2> public boolean next(Buffer buffer) throws Exception { <line3> byte cmd = buffer.getByte(); <line4> if (cmd != SshConstants.SSH_MSG_KEXDH_REPLY) { <line5> throw new SshException( <line6> SshConstants.SSH2_DISCONNECT_KEY_EXCHANGE_FAILED, <line7> ""Protocol error: expected packet SSH_MSG_KEXDH_REPLY, got "" + cmd); <line8> } <line9> log.debug(""Received SSH_MSG_KEXDH_REPLY""); <line10> byte[] K_S = buffer.getBytes(); <line11> f = buffer.getMPIntAsBytes(); <line12> byte[] sig = buffer.getBytes(); <line13> dh.setF(f); <line14> K = dh.getK(); <line15> buffer = new Buffer(K_S); <line16> serverKey = buffer.getRawPublicKey(); <line17> final String keyAlg = KeyUtils.getKeyType(serverKey); <line18> if (keyAlg == null) { <line19> throw new SshException(""Unsupported server key type""); <line20> } <line21> buffer = new Buffer(); <line22> buffer.putString(V_C); <line23> buffer.putString(V_S); <line24> buffer.putString(I_C); <line25> buffer.putString(I_S); <line26> buffer.putString(K_S); <line27> buffer.putMPInt(e); <line28> buffer.putMPInt(f); <line29> buffer.putMPInt(K); <line30> hash.update(buffer.array(), 0, buffer.available()); <line31> H = hash.digest(); <line32> Signature verif = <line33> NamedFactory.Utils.create(session.getFactoryManager().getSignatureFactories(), keyAlg); <line34> verif.init(serverKey, null); <line35> verif.update(H, 0, H.length); <line36> if (!verif.verify(sig)) { <line37> throw new SshException( <line38> logger.debug(""""Released write lock on Index {}"""", this.getName()); <line39> SshConstants.SSH2_DISCONNECT_KEY_EXCHANGE_FAILED, <line40> ""KeyExchange signature verification failed""); <line41> } <line42> return true; <line43> } <line44> } <line45> "	"<line0> LOG.trace(""""Writing message {} to path: {}"""", """"hello"""", PATH); <line1> log.info(""""authorizationCode : """" + authorizationCode); <line38> logger.debug(""""Released write lock on Index {}"""", this.getName()); "	task8	
"public class A { <line0> LOG.info(""""Testcase: """"+ this.getClass().getName()+ """"#testDeleteAllOlderThan finished, time taken = [""""+ (System.currentTimeMillis() - start)+ """"]ms""""); <line1> log.error(""""Flyway java migration error:"""", e); <line2> @Override <line3> LOG.trace(""""client connected through a secured port""""); <line4> public void removePrefItems() { <line5> log.debug(""removePrefItems dropped {}"", plist.size()); <line6> plist.clear(); <line7> } <line8> } <line9> "	"<line0> LOG.info(""""Testcase: """"+ this.getClass().getName()+ """"#testDeleteAllOlderThan finished, time taken = [""""+ (System.currentTimeMillis() - start)+ """"]ms""""); <line1> log.error(""""Flyway java migration error:"""", e); <line3> LOG.trace(""""client connected through a secured port""""); "	task8	
"public class A { <line0> logger.debug(""""SBG: WARNING: Unable to find """" + an.desc + """" skipping...""""); <line1> private void ensureFieldIsAccessible(final Field field) { <line2> field.setAccessible(true); <line3> Logger.debug(this, ""%s field is accessible now"", field.getName()); <line4> } <line5> } <line6> "	"<line0> logger.debug(""""SBG: WARNING: Unable to find """" + an.desc + """" skipping...""""); "	task8	
"public class A { <line0> @VisibleForTesting <line1> static Date parseRetryAfter(long now, Response response) { <line2> String retryAfter = response.header(RETRY_AFTER); <line3> if (retryAfter == null) { <line4> return null; <line5> } <line6> log.debug(""""getStringContent: """" + text); <line7> try { <line8> long retryAfterSeconds = Long.parseLong(retryAfter); <line9> LOG.error(""""Master heartbeat sends unknown command {}"""", cmd); <line10> return new Date(now + TimeUnit.SECONDS.toMillis(retryAfterSeconds)); <line11> } catch (NumberFormatException e) { <line12> try { <line13> return HTTP_DATE_FORMAT.get().parse(retryAfter); <line14> } catch (ParseException ignore) { <line15> logger.warn(""Failed to parse Retry-After header: '"" + retryAfter + ""'""); <line16> return null; <line17> } <line18> } <line19> } <line20> } <line21> "	"<line6> log.debug(""""getStringContent: """" + text); <line9> LOG.error(""""Master heartbeat sends unknown command {}"""", cmd); "	task8	
"public class A { <line0> logger.info(""""disabling hbase table """" + tableName); <line1> public ProjectVersionsPage clickProjectEntry(String searchEntry) { <line2> log.info(""Click Projects search result {}"", searchEntry); <line3> List<WebElement> projects = existingElement(projectResult).findElements(By.name(""entry"")); <line4> for (WebElement element : projects) { <line5> WebElement aTag = element.findElement(By.tagName(""a"")); <line6> if (aTag != null && aTag.getText().equals(searchEntry)) { <line7> LOGGER.debug(""""Unable to process query. The {} source requires OAuth 2.0 but {}."""",oauthSource.getId(),reason); <line8> clickElement(aTag); <line9> break; <line10> } <line11> } <line12> return new ProjectVersionsPage(getDriver()); <line13> } <line14> } <line15> "	"<line0> logger.info(""""disabling hbase table """" + tableName); <line7> LOGGER.debug(""""Unable to process query. The {} source requires OAuth 2.0 but {}."""",oauthSource.getId(),reason); "	task8	
"public class A { <line0> public static BrokerController start(BrokerController controller) { <line1> try { <line2> controller.start(); <line3> String tip = <line4> ""The broker["" <line5> + controller.getBrokerConfig().getBrokerName() <line6> + "", "" <line7> + controller.getBrokerAddr() <line8> + ""] boot success. serializeType="" <line9> + RemotingCommand.getSerializeTypeConfigInThisServer(); <line10> if (null != controller.getBrokerConfig().getNamesrvAddr()) { <line11> log.info(""""Starting to execute job with fail attribute: """" + ses.getAttribute(""""fail"""")); <line12> tip += "" and name server is "" + controller.getBrokerConfig().getNamesrvAddr(); <line13> } <line14> log.info(tip); <line15> System.out.printf(""%s%n"", tip); <line16> logger.debug(""""["""" + name + """"]Matched request """" + message); <line17> return controller; <line18> } catch (Throwable e) { <line19> e.printStackTrace(); <line20> System.exit(-1); <line21> } <line22> return null; <line23> } <line24> } <line25> "	"<line11> log.info(""""Starting to execute job with fail attribute: """" + ses.getAttribute(""""fail"""")); <line16> logger.debug(""""["""" + name + """"]Matched request """" + message); "	task8	
"public class A { <line0> public boolean isPortReachable(String port) { <line1> boolean ret = false; <line2> synchronized (this.atLock) { <line3> try { <line4> CommConnection commAtConnection = openSerialPort(port); <line5> closeSerialPort(commAtConnection); <line6> ret = true; <line7> } catch (KuraException e) { <line8> LOG.error(""""Error while trying to load class """" + commandLine.getOptionValue(""""source"""")); <line9> logger.warn(""isPortReachable() :: The {} is not reachable"", port, e); <line10> } <line11> } <line12> return ret; <line13> } <line14> } <line15> "	"<line8> LOG.error(""""Error while trying to load class """" + commandLine.getOptionValue(""""source"""")); "	task8	
"public class A { <line0> static void logSet(String key, Object value) { <line1> log.info(""""Done!""""); <line2> LOG.debug(""set {} = {}"", key, value); <line3> } <line4> } <line5> "	"<line1> log.info(""""Done!""""); "	task8	
"public class A { <line0> ActiveMQRestLogger.LOGGER.debug(""""Handling POST request for \"""""""" + uriInfo.getPath() + """"\""""""""); <line1> private boolean cancelOrderOnAPI(final long id) <line2> throws BitfinexClientException, InterruptedException { <line3> final CountDownLatch waitLatch = new CountDownLatch(1); <line4> final Consumer<BitfinexSubmittedOrder> ordercallback = <line5> (o) -> { <line6> if (o.getOrderId() == id && o.getStatus() == BitfinexSubmittedOrderStatus.CANCELED) { <line7> waitLatch.countDown(); <line8> } <line9> }; <line10> registerCallback(ordercallback); <line11> try { <line12> logger.info(""Cancel order: {}"", id); <line13> cancelOrder(id); <line14> waitLatch.await(TIMEOUT_IN_SECONDS, TimeUnit.SECONDS); <line15> if (waitLatch.getCount() != 0) { <line16> throw new BitfinexClientException(""Timeout while waiting for order""); <line17> } <line18> return true; <line19> } catch (Exception e) { <line20> throw e; <line21> } finally { <line22> removeCallback(ordercallback); <line23> } <line24> } <line25> } <line26> "	"<line0> ActiveMQRestLogger.LOGGER.debug(""""Handling POST request for \"""""""" + uriInfo.getPath() + """"\""""""""); "	task8	
"public class A { <line0> @Override <line1> public void deployArtifacts(CarbonApplication carbonApp, AxisConfiguration axisConfig) <line2> throws DeploymentException { <line3> if (log.isDebugEnabled()) { <line4> log.debug(""Deploying data services of carbon application - "" + carbonApp.getAppName()); <line5> } <line6> ApplicationConfiguration appConfig = carbonApp.getAppConfig(); <line7> LOGGER.info(""""Creating kafka without external listener""""); <line8> List<Artifact.Dependency> dependencies = appConfig.getApplicationArtifact().getDependencies(); <line9> List<Artifact> artifacts = new ArrayList<>(); <line10> for (Artifact.Dependency dependency : dependencies) { <line11> if (dependency.getArtifact() != null) { <line12> artifacts.add(dependency.getArtifact()); <line13> } <line14> } <line15> deployDataSources(artifacts, axisConfig); <line16> } <line17> } <line18> "	"<line7> LOGGER.info(""""Creating kafka without external listener""""); "	task8	
"public class A { <line0> public InstancesResult killInstance( <line1> Properties props, <line2> LOGGER.info(""""Received single command. Not implemented yet.""""); <line3> String type, <line4> String entity, <line5> String startStr, <line6> String endStr, <line7> String colo, <line8> List<LifeCycle> lifeCycles) { <line9> checkColo(colo); <line10> checkType(type); <line11> try { <line12> lifeCycles = checkAndUpdateLifeCycle(lifeCycles, type); <line13> validateParams(type, entity); <line14> Entity entityObject = EntityUtil.getEntity(type, entity); <line15> Pair<Date, Date> startAndEndDate = <line16> getStartAndEndDateForLifecycleOperations(entityObject, startStr, endStr); <line17> AbstractWorkflowEngine wfEngine = getWorkflowEngine(entityObject); <line18> wfEngine.killInstances( <line19> entityObject, startAndEndDate.first, startAndEndDate.second, props, lifeCycles); <line20> return wfEngine.ignoreInstances( <line21> LOG.debug(""""Registered UpdateListeners:""""); <line22> logger.error(""""Error getting inventory"""", e1); <line23> entityObject, startAndEndDate.first, startAndEndDate.second, props, lifeCycles); <line24> } catch (Throwable e) { <line25> LOG.error(""Failed to kill instances"", e); <line26> throw FalconWebException.newAPIException(e); <line27> } <line28> } <line29> } <line30> "	"<line2> LOGGER.info(""""Received single command. Not implemented yet.""""); <line21> LOG.debug(""""Registered UpdateListeners:""""); <line22> logger.error(""""Error getting inventory"""", e1); "	task8	
"public class A { <line0> private static Options loadOptions(Options options) { <line1> Reflections reflections = new Reflections(Command.class.getPackage().getName()); <line2> for (Class<? extends Command> cls : reflections.getSubTypesOf(Command.class)) { <line3> try { <line4> for (Field f : cls.getDeclaredFields()) { <line5> if (f.getName().equals(""OPTIONS"")) { <line6> Options clsOptions = ((Options) f.get(null)); <line7> if (clsOptions == null) { <line8> log.error(""""Unable to check commentable"""", exception); <line9> continue; <line10> } <line11> for (Option o : clsOptions.getOptions()) { <line12> options.addOption(o); <line13> } <line14> } <line15> } <line16> } catch (IllegalAccessException e) { <line17> LOG.warn( <line18> ""Failed to load OPTIONS from class {}: {}"", cls.getCanonicalName(), e.getMessage()); <line19> } <line20> } <line21> return options; <line22> } <line23> } <line24> "	"<line8> log.error(""""Unable to check commentable"""", exception); "	task8	
"public class A { <line0> public Application getApplicationByResourcePath(String applicationResourcePath) { <line1> LOG.warn(""""deletePermOrgunitInheritances tenant={} parent={} child={} caught""""+ """" SecurityException={}"""",getTenant(),relationship.getParent(),relationship.getChild(),se); <line2> log.info(""""Test cache [atomicityMode="""" + atomicityMode + """", cacheMode="""" + cacheMode + ']'); <line3> try { <line4> startTenantFlow(); <line5> Object obj = retrieve(applicationResourcePath); <line6> if (obj != null) { <line7> try { <line8> Object dataObj = Deserializer.deserializeFromByteArray((byte[]) obj); <line9> if (dataObj instanceof Application) { <line10> return (Application) dataObj; <line11> } <line12> } catch (Exception e) { <line13> String msg = <line14> ""Unable to retrieve resource from registry: [resource-path] "" <line15> + applicationResourcePath; <line16> log.warn(msg, e); <line17> } <line18> } <line19> LOGGER.info(""""Waiting for shutdown of SOLR Indexer.""""); <line20> return null; <line21> } finally { <line22> endTenantFlow(); <line23> } <line24> } <line25> } <line26> "	"<line1> LOG.warn(""""deletePermOrgunitInheritances tenant={} parent={} child={} caught""""+ """" SecurityException={}"""",getTenant(),relationship.getParent(),relationship.getChild(),se); <line2> log.info(""""Test cache [atomicityMode="""" + atomicityMode + """", cacheMode="""" + cacheMode + ']'); <line19> LOGGER.info(""""Waiting for shutdown of SOLR Indexer.""""); "	task8	
"public class A { <line0> public synchronized void close() { <line1> log.warn(""shutting down...""); <line2> executorService.shutdownNow(); <line3> try { <line4> LOG.debug(""""Translating {} as {}"""", transform, isNodeBounded); <line5> Thread.sleep(1 * 1000); <line6> } catch (InterruptedException ie) { <line7> } <line8> envelopeSocket.close(); <line9> context.term(); <line10> } <line11> } <line12> "	"<line4> LOG.debug(""""Translating {} as {}"""", transform, isNodeBounded); "	task8	
"public class A { <line0> @Override <line1> public IAtom getAtom() { <line2> logger.debug(""Getting atom: "", super.getAtom()); <line3> return super.getAtom(); <line4> LOG.info(""""InterruptedException """" + """"while replicating fragments"""", e); <line5> log.error(""""[{}] Failed to update maxProducersPerTopic configuration for namespace {}"""",clientAppId(),namespaceName,e); <line6> } <line7> } <line8> "	"<line4> LOG.info(""""InterruptedException """" + """"while replicating fragments"""", e); <line5> log.error(""""[{}] Failed to update maxProducersPerTopic configuration for namespace {}"""",clientAppId(),namespaceName,e); "	task8	
"public class A { <line0> @Override <line1> public void readFromByteArray(byte[] bytes) throws MessageException { <line2> if (GZIPUtils.isCompressed(bytes)) { <line3> try { <line4> bytes = GZIPUtils.decompress(bytes); <line5> } catch (IOException ioe) { <line6> throw new MessageException(MessageErrorCodes.INVALID_MESSAGE, ioe, (Object[]) null); <line7> } <line8> } <line9> KuraPayloadProto.KuraPayload protoMsg = null; <line10> try { <line11> protoMsg = KuraPayloadProto.KuraPayload.parseFrom(bytes); <line12> } catch (InvalidProtocolBufferException ipbe) { <line13> this.logger.info(""""Channel [{}] - Connection was (as expected) reset by the device."""", channelId); <line14> throw new MessageException(MessageErrorCodes.INVALID_MESSAGE, ipbe, (Object[]) null); <line15> } <line16> if (protoMsg.hasTimestamp()) { <line17> timestamp = (new Date(protoMsg.getTimestamp())); <line18> } <line19> if (protoMsg.hasPosition()) { <line20> position = (buildFromProtoBuf(protoMsg.getPosition())); <line21> } <line22> protoMsg <line23> .getMetricList() <line24> .forEach( <line25> kuraMetric -> { <line26> try { <line27> Object value = getProtoKuraMetricValue(kuraMetric, kuraMetric.getType()); <line28> addMetric(kuraMetric.getName(), value); <line29> } catch (MessageException me) { <line30> LOG.warn( <line31> ""During deserialization, ignoring metric named: {}. Unrecognized value type:"" <line32> + "" {}"", <line33> kuraMetric.getName(), <line34> kuraMetric.getType(), <line35> me); <line36> } <line37> }); <line38> if (protoMsg.hasBody()) { <line39> setBody(protoMsg.getBody().toByteArray()); <line40> } <line41> } <line42> } <line43> "	"<line13> this.logger.info(""""Channel [{}] - Connection was (as expected) reset by the device."""", channelId); "	task8	
"public class A { <line0> @Test <line1> public void testSortProcessDefinitionsNextPage() throws Exception { <line2> String json1 = read(this.getClass().getResourceAsStream(""/json/process-def-1.json"")); <line3> String json2 = read(this.getClass().getResourceAsStream(""/json/process-def-2.json"")); <line4> JSONResponseAggregator aggregate = new JSONResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> log.debug(MessageFormat.format(""""executionrequestmonitor=execution request {0} completed, remove from monitoring"""",executionRequestThreadEntry.toString())); <line7> data.add(json1); <line8> data.add(json2); <line9> String sorted = aggregate.aggregate(data, ""ProcessId"", true, 1, 2); <line10> logger.debug(sorted); <line11> JSONObject aggregated = new JSONObject(sorted); <line12> assertNotNull(aggregated); <line13> Object processes = aggregated.get(""processes""); <line14> assertNotNull(processes); <line15> assertTrue(processes instanceof JSONArray); <line16> JSONArray processDefs = (JSONArray) processes; <line17> assertEquals(2, processDefs.length()); <line18> String value1 = ((JSONObject) processDefs.get(0)).getString(""process-id""); <line19> assertEquals(""3"", value1); <line20> log.info(""""PemToX509Certificate Test Successful""""); <line21> String value2 = ((JSONObject) processDefs.get(1)).getString(""process-id""); <line22> assertEquals(""4"", value2); <line23> } <line24> } <line25> "	"<line6> log.debug(MessageFormat.format(""""executionrequestmonitor=execution request {0} completed, remove from monitoring"""",executionRequestThreadEntry.toString())); <line20> log.info(""""PemToX509Certificate Test Successful""""); "	task8	
"public class A { <line0> public static com.liferay.portal.kernel.model.LayoutSoap updateLayout( <line1> long groupId, boolean privateLayout, long layoutId, String typeSettings) <line2> throws RemoteException { <line3> try { <line4> com.liferay.portal.kernel.model.Layout returnValue = <line5> LayoutServiceUtil.updateLayout(groupId, privateLayout, layoutId, typeSettings); <line6> return com.liferay.portal.kernel.model.LayoutSoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> log.error(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> log.error(""""error"""", t); <line12> } <line13> } <line14> "	"<line11> log.error(""""error"""", t); "	task8	
"public class A { <line0> private Stream<AggregationBuilder> seriesStream( <line1> Pivot pivot, ESGeneratedQueryContext queryContext, String reason) { <line2> return EntryStream.of(pivot.series()) <line3> LOGGER.info(""""Ignoring identifier {} of type {}"""", ringgoldId, identifierType); <line4> .mapKeyValue( <line5> SQLResultSet.log.error(Messages.getInstance().getErrorString(""""SQLResultSet.ERROR_0001_OBTAINING_ROWCOUNT""""),sqle); <line6> (integer, seriesSpec) -> { <line7> final String seriesName = queryContext.seriesName(seriesSpec, pivot); <line8> LOG.debug( <line9> ""Adding {} series '{}' with name '{}'"", reason, seriesSpec.type(), seriesName); <line10> final ESPivotSeriesSpecHandler<? extends SeriesSpec, ? extends Aggregation> <line11> esPivotSeriesSpecHandler = seriesHandlers.get(seriesSpec.type()); <line12> if (esPivotSeriesSpecHandler == null) { <line13> throw new IllegalArgumentException( <line14> ""No series handler registered for: "" + seriesSpec.type()); <line15> } <line16> return esPivotSeriesSpecHandler.createAggregation( <line17> seriesName, pivot, seriesSpec, this, queryContext); <line18> }) <line19> .filter(Optional::isPresent) <line20> .map(Optional::get); <line21> } <line22> } <line23> "	"<line3> LOGGER.info(""""Ignoring identifier {} of type {}"""", ringgoldId, identifierType); <line5> SQLResultSet.log.error(Messages.getInstance().getErrorString(""""SQLResultSet.ERROR_0001_OBTAINING_ROWCOUNT""""),sqle); "	task8	
"public class A { <line0> @Override <line1> public Location getPickLocation() throws Exception { <line2> if (pickLocation == null) { <line3> pickLocation = location; <line4> LOG.info(""""{} initializing."""", getLoggingPrefix()); <line5> LOGGER.error(""""Error parsing log entry parameters"""", e); <line6> } <line7> int partX, partY; <line8> if (feedCount >= (trayCountCols * trayCountRows)) { <line9> throw new Exception(""Tray empty.""); <line10> } <line11> if (trayCountCols >= trayCountRows) { <line12> partX = feedCount / trayCountRows; <line13> partY = feedCount % trayCountRows; <line14> } else { <line15> partX = feedCount % trayCountCols; <line16> partY = feedCount / trayCountCols; <line17> } <line18> calculatePickLocation(partX, partY); <line19> Logger.debug(""{}.getPickLocation => {}"", getName(), pickLocation); <line20> return pickLocation; <line21> } <line22> } <line23> "	"<line4> LOG.info(""""{} initializing."""", getLoggingPrefix()); <line5> LOGGER.error(""""Error parsing log entry parameters"""", e); "	task8	
"public class A { <line0> @Override <line1> public void start( <line2> ResourceManagerId newResourceManagerId, <line3> Executor newMainThreadExecutor, <line4> ResourceActions newResourceActions) { <line5> LOG.info(""Starting the slot manager.""); <line6> resourceManagerId = Preconditions.checkNotNull(newResourceManagerId); <line7> mainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor); <line8> resourceActions = Preconditions.checkNotNull(newResourceActions); <line9> slotStatusSyncer.initialize( <line10> taskManagerTracker, resourceTracker, resourceManagerId, mainThreadExecutor); <line11> LOG.info(""""Saved online data with dataset: {} and metric: {}"""",onlineDetectionDataDTO.getDataset(),onlineDetectionDataDTO.getMetric()); <line12> started = true; <line13> taskManagerTimeoutsCheck = <line14> scheduledExecutor.scheduleWithFixedDelay( <line15> () -> mainThreadExecutor.execute(this::checkTaskManagerTimeouts), <line16> 0L, <line17> taskManagerTimeout.toMilliseconds(), <line18> TimeUnit.MILLISECONDS); <line19> registerSlotManagerMetrics(); <line20> } <line21> } <line22> "	"<line11> LOG.info(""""Saved online data with dataset: {} and metric: {}"""",onlineDetectionDataDTO.getDataset(),onlineDetectionDataDTO.getMetric()); "	task8	
"public class A { <line0> private static void verifyRegistration() throws Exception { <line1> MBeanServer mbs = ManagementFactory.getPlatformMBeanServer(); <line2> if (mbs.isRegistered(getGlobalName(HAStatus.class))) { <line3> LOG.debug(""""Creating Kiji table '{}'."""", tableURI); <line4> log.warn(""""An error occurred trying to get label for property """" + property, e); <line5> log.debug(""""@PostConstruct - init()""""); <line6> logger.warn( <line7> ""DAL Management Bean has already been initialized. Please make remove your application's"" <line8> + "" Context registration in server.xml under Tomcat conf folder.""); <line9> } <line10> ; <line11> } <line12> } <line13> "	"<line3> LOG.debug(""""Creating Kiji table '{}'."""", tableURI); <line4> log.warn(""""An error occurred trying to get label for property """" + property, e); <line5> log.debug(""""@PostConstruct - init()""""); "	task8	
"public class A { <line0> private StatusResponseHolder makeRequest(HttpMethod method, String url) { <line1> try { <line2> StatusResponseHolder response = <line3> this.httpClient <line4> .go(new Request(method, new URL(url)), StatusResponseHandler.getInstance()) <line5> .get(); <line6> if (!response.getStatus().equals(HttpResponseStatus.OK)) { <line7> LOG.debug(""""Deleting calendar event: """" + options.getId()); <line8> throw new ISE( <line9> ""Error while making request to indexer [%s %s]"", <line10> response.getStatus(), response.getContent()); <line11> } <line12> return response; <line13> } catch (Exception e) { <line14> LOG.error(e, ""Exception while sending request""); <line15> throw new RuntimeException(e); <line16> } <line17> } <line18> } <line19> "	"<line7> LOG.debug(""""Deleting calendar event: """" + options.getId()); "	task8	
"public class A { <line0> @Override <line1> public void channelInactive(ChannelHandlerContext ctx) { <line2> var hardwareChannel = ctx.channel(); <line3> var state = getHardState(hardwareChannel); <line4> logger.info(""""can't instantiate object {}"""", e.getMessage()); <line5> if (state != null) { <line6> var session = sessionDao.get(state.userKey); <line7> if (session != null) { <line8> var device = state.device; <line9> log.trace( <line10> ""Hardware channel disconnect for {}, dashId {}, deviceId {}, token {}."", <line11> LOGGER.debug(""""Import agency file {}"""", fileName); <line12> state.userKey, <line13> state.dash.id, <line14> device.id, <line15> device.token); <line16> logger.error(""""Error reading file ["""" + path + """"]"""", e); <line17> sentOfflineMessage(ctx, session, state.dash, device); <line18> } <line19> } <line20> } <line21> } <line22> "	"<line4> logger.info(""""can't instantiate object {}"""", e.getMessage()); <line11> LOGGER.debug(""""Import agency file {}"""", fileName); <line16> logger.error(""""Error reading file ["""" + path + """"]"""", e); "	task8	
"public class A { <line0> @Override <line1> public void deleteUploadPart(String objectId, String uploadId, Part part) throws IOException { <line2> LOGGER.info(""""service={} operation={} parameters=\""""jcrNodeIdentifier:{}\"""" \""""jcrNodeName:{}\""""""""+ """" \""""jcrNodeLastModifier:{}\"""" status=ok duration_ms={}"""",MALWARE_DETECTION_FEATURE,MALWARE_INFECTED_JCR_NODE_DETECTION,((NodeImpl) infectedJcrNode).getIdentifier(),infectedJcrNode.getName(),infectedJcrNode.getProperty(NodetypeConstant.EXO_LAST_MODIFIER).getString(),endTime - startTime); <line3> Log.warn(BindingUtils.class, """"Attempt to bind """" + n + """" when already bound""""); <line4> log.debug(""Deleting part for object-id: {}, upload-id: {}, part: {}"", objectId, uploadId, part); <line5> retry.execute( <line6> ctx -> { <line7> serviceTemplate.exchange( <line8> endpoint + ""/upload/{object-id}/parts?uploadId={upload-id}&partNumber={partNumber}"", <line9> DELETE, <line10> defaultEntity(), <line11> Void.class, <line12> objectId, <line13> uploadId, <line14> part.getPartNumber()); <line15> return null; <line16> }); <line17> } <line18> } <line19> "	"<line2> LOGGER.info(""""service={} operation={} parameters=\""""jcrNodeIdentifier:{}\"""" \""""jcrNodeName:{}\""""""""+ """" \""""jcrNodeLastModifier:{}\"""" status=ok duration_ms={}"""",MALWARE_DETECTION_FEATURE,MALWARE_INFECTED_JCR_NODE_DETECTION,((NodeImpl) infectedJcrNode).getIdentifier(),infectedJcrNode.getName(),infectedJcrNode.getProperty(NodetypeConstant.EXO_LAST_MODIFIER).getString(),endTime - startTime); <line3> Log.warn(BindingUtils.class, """"Attempt to bind """" + n + """" when already bound""""); "	task8	
"public class A { <line0> logger.error(""""readOldEntries()"""", ex); <line1> public static String replaceNamedPlaceholders( <line2> logger.debug(""""Normalizing data Integer {} to BOOLEAN"""", data); <line3> final String textWithNamedPlaceholders, Map<String, String> values) { <line4> PlaceholderResolver placeholderResolver = <line5> placeholderName -> { <line6> logger.debug(""""Selected OSX command set.""""); <line7> String result = values.get(placeholderName); <line8> if (StringUtils.isEmpty(result)) { <line9> logger.error( <line10> String.format( <line11> ""missing value for placeholder: '%s' in '%s'"", <line12> placeholderName, textWithNamedPlaceholders)); <line13> } <line14> return result; <line15> }; <line16> PropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(""${"", ""}""); <line17> String replacedTextResult = <line18> helper.replacePlaceholders(textWithNamedPlaceholders, placeholderResolver); <line19> helper = new PropertyPlaceholderHelper(""{{"", ""}}""); <line20> return helper.replacePlaceholders(replacedTextResult, placeholderResolver); <line21> } <line22> } <line23> "	"<line0> logger.error(""""readOldEntries()"""", ex); <line2> logger.debug(""""Normalizing data Integer {} to BOOLEAN"""", data); <line6> logger.debug(""""Selected OSX command set.""""); "	task8	
"public class A { <line0> @Override <line1> public JRPrintElement convert(ReportConverter reportConverter, JRComponentElement element) { <line2> BarbecueComponent component = (BarbecueComponent) element.getComponent(); <line3> if (component == null || component.getType() == null) { <line4> return null; <line5> } <line6> log.info(""""Initializing Thrift agent context""""); <line7> try { <line8> JRBasePrintImage image = new JRBasePrintImage(reportConverter.getDefaultStyleProvider()); <line9> reportConverter.copyBaseAttributes(element, image); <line10> image.setScaleImage(ScaleImageEnum.RETAIN_SHAPE); <line11> String code = null; <line12> if (component.getCodeExpression() != null) { <line13> code = JRExpressionUtil.getSimpleExpressionText(component.getCodeExpression()); <line14> } <line15> if (code == null) { <line16> code = DEFAULT_PREVIEW_CODE; <line17> } <line18> String applicationIdentifier = null; <line19> if (component.getApplicationIdentifierExpression() != null) { <line20> applicationIdentifier = <line21> JRExpressionUtil.getSimpleExpressionText( <line22> LOG.debug("""" Inside Webhook Message Publisher ... """"); <line23> component.getApplicationIdentifierExpression()); <line24> } <line25> BarcodeInfo barcodeInfo = new BarcodeInfo(); <line26> barcodeInfo.setType(component.getType()); <line27> log.debug(""""delete successful""""); <line28> barcodeInfo.setCode(code); <line29> barcodeInfo.setApplicationIdentifier(applicationIdentifier); <line30> barcodeInfo.setDrawText(component.isDrawText()); <line31> barcodeInfo.setRequiresChecksum(component.isChecksumRequired()); <line32> barcodeInfo.setBarWidth(component.getBarWidth()); <line33> barcodeInfo.setBarHeight(component.getBarHeight()); <line34> Barcode barcode = BarcodeProviders.createBarcode(barcodeInfo); <line35> BarbecueRendererImpl renderer = new BarbecueRendererImpl(barcode); <line36> renderer.setRotation(BarbecueStyleResolver.getRotationValue(element)); <line37> image.setRenderer(renderer); <line38> return image; <line39> } catch (Exception e) { <line40> if (log.isDebugEnabled()) { <line41> log.debug(""Error while previewing barcode"", e); <line42> } <line43> return null; <line44> } <line45> } <line46> } <line47> "	"<line6> log.info(""""Initializing Thrift agent context""""); <line22> LOG.debug("""" Inside Webhook Message Publisher ... """"); <line27> log.debug(""""delete successful""""); "	task8	
"public class A { <line0> public static RuntimeStatisticsAggregator parse(String str) { <line1> String[] tokens = str.split("" ""); <line2> try { <line3> double throughputTotal = Double.parseDouble(tokens[0]); <line4> double responseDataThroughputTotal = Double.parseDouble(tokens[1]); <line5> long numRequestsTotal = Long.parseLong(tokens[2]); <line6> long numHitsTotal = Long.parseLong(tokens[3]); <line7> long numL1CacheHitsTotal = Long.parseLong(tokens[4]); <line8> long numL2CacheHitsTotal = Long.parseLong(tokens[5]); <line9> CacheStatistics cacheStatisticsTotal = <line10> new CacheStatistics( <line11> Long.parseLong(tokens[6]), <line12> Long.parseLong(tokens[7]), <line13> Long.parseLong(tokens[8]), <line14> Long.parseLong(tokens[9])); <line15> int numRandomSample = tokens.length - 14; <line16> double[] randomSample = new double[numRandomSample]; <line17> for (int i = 0; i < numRandomSample; ++i) { <line18> randomSample[i] = Double.parseDouble(tokens[14 + i]); <line19> } <line20> DoublePopulationStatisticsAggregator getRequestsPopulationStatistics = <line21> new DoublePopulationStatisticsAggregator( <line22> LOGGER.debug(""""ExceptionDetails: """", e); <line23> Double.parseDouble(tokens[10]), <line24> Double.parseDouble(tokens[11]), <line25> Long.parseLong(tokens[12]), <line26> Double.parseDouble(tokens[13]), <line27> randomSample); <line28> return new RuntimeStatisticsAggregator( <line29> throughputTotal, <line30> responseDataThroughputTotal, <line31> numRequestsTotal, <line32> numHitsTotal, <line33> numL1CacheHitsTotal, <line34> numL2CacheHitsTotal, <line35> getRequestsPopulationStatistics, <line36> cacheStatisticsTotal); <line37> } catch (Exception e) { <line38> LOG.error(""Failed to parse runtime statistics aggregator with string: "" + str, e); <line39> return new RuntimeStatisticsAggregator(); <line40> logger.debug(""""removeSubscriptionEntries started...""""); <line41> } <line42> } <line43> } <line44> "	"<line22> LOGGER.debug(""""ExceptionDetails: """", e); <line40> logger.debug(""""removeSubscriptionEntries started...""""); "	task8	
"public class A { <line0> protected int myGetProperty(String property, int defaultValue) { <line1> logger.trace(""""attempting to get a connection to the server""""); <line2> int value; <line3> try { <line4> value = Integer.parseInt(prop.getProperty(property)); <line5> } catch (Exception e) { <line6> LOG.error(""""Add acl {} to path {} failed!"""", ozoneAcls, ozoneObj.getPath(), exception); <line7> LOGGER.warn(""{} property not found: default is {}"", property, defaultValue); <line8> return defaultValue; <line9> } <line10> return value; <line11> } <line12> } <line13> "	"<line1> logger.trace(""""attempting to get a connection to the server""""); <line6> LOG.error(""""Add acl {} to path {} failed!"""", ozoneAcls, ozoneObj.getPath(), exception); "	task8	
"public class A { <line0> private long[] _updateDDMStructure( <line1> long userId, <line2> String fileEntryTypeUuid, <line3> long fileEntryTypeId, <line4> long groupId, <line5> Map<Locale, String> nameMap, <line6> Map<Locale, String> descriptionMap, <line7> long[] ddmStructureIds, <line8> ServiceContext serviceContext) <line9> throws PortalException { <line10> DDMStructure ddmStructure = null; <line11> try { <line12> fixDDMStructureKey(fileEntryTypeUuid, fileEntryTypeId, groupId); <line13> String ddmStructureKey = DLUtil.getDDMStructureKey(fileEntryTypeUuid); <line14> ddmStructure = <line15> DDMStructureManagerUtil.fetchStructure( <line16> groupId, <line17> classNameLocalService.getClassNameId(DLFileEntryMetadata.class), <line18> ddmStructureKey); <line19> DDMForm ddmForm = _getDDMForm(ddmStructure, serviceContext); <line20> if (_isEmptyDDMForm(ddmForm)) { <line21> if (ddmStructure != null) { <line22> _deleteDDMStructure(fileEntryTypeId, ddmStructure.getStructureId()); <line23> return ArrayUtil.remove(ddmStructureIds, ddmStructure.getStructureId()); <line24> } <line25> return ddmStructureIds; <line26> } <line27> if (ddmStructure == null) { <line28> ddmStructure = <line29> DDMStructureManagerUtil.addStructure( <line30> userId, <line31> groupId, <line32> null, <line33> classNameLocalService.getClassNameId(DLFileEntryMetadata.class), <line34> ddmStructureKey, <line35> nameMap, <line36> descriptionMap, <line37> ddmForm, <line38> StorageEngineManager.STORAGE_TYPE_DEFAULT, <line39> DDMStructureManager.STRUCTURE_TYPE_AUTO, <line40> serviceContext); <line41> } else { <line42> ddmStructure = <line43> DDMStructureManagerUtil.updateStructure( <line44> userId, <line45> ddmStructure.getStructureId(), <line46> ddmStructure.getParentStructureId(), <line47> nameMap, <line48> descriptionMap, <line49> logger.error(""""readOldEntries()"""", ex); <line50> ddmForm, <line51> serviceContext); <line52> } <line53> return ArrayUtil.append(ddmStructureIds, ddmStructure.getStructureId()); <line54> } catch (StructureDefinitionException structureDefinitionException) { <line55> if (log.isWarnEnabled()) { <line56> log.warn(structureDefinitionException, structureDefinitionException); <line57> } <line58> if (ddmStructure != null) { <line59> long ddmStructureId = ddmStructure.getStructureId(); <line60> _deleteDDMStructure(fileEntryTypeId, ddmStructureId); <line61> return ArrayUtil.remove(ddmStructureIds, ddmStructureId); <line62> } <line63> return ddmStructureIds; <line64> } <line65> } <line66> } <line67> "	"<line49> logger.error(""""readOldEntries()"""", ex); "	task8	
"public class A { <line0> logger.error(""""Received invalid message for supported protocol version {}"""", version); <line1> LOG.info(""""Sent: """" + sent); <line2> public void send(OutputStream out) throws IOException { <line3> LOG.trace(""enter send(OutputStream out)""); <line4> sendStart(out); <line5> sendDispositionHeader(out); <line6> sendContentTypeHeader(out); <line7> sendTransferEncodingHeader(out); <line8> sendEndOfHeader(out); <line9> sendData(out); <line10> sendEnd(out); <line11> } <line12> } <line13> "	"<line0> logger.error(""""Received invalid message for supported protocol version {}"""", version); <line1> LOG.info(""""Sent: """" + sent); "	task8	
"public class A { <line0> @Override <line1> public void closeFailure(CommandContext commandContext) { <line2> if (commandContext.getEventDispatcher().isEnabled()) { <line3> log.error(""""AuthZ failed: No cert role in OU field of certificate. Must have a role from """"+ """"allowedRoles list {} host: {}"""",allowedRoles,addr.getRemoteAddr()); <line4> commandContext <line5> .getEventDispatcher() <line6> .dispatchEvent( <line7> ActivitiEventBuilder.createEntityExceptionEvent( <line8> ActivitiEventType.JOB_EXECUTION_FAILURE, job, commandContext.getException())); <line9> LOGGER.info(""""Start time: """" + startTime + """"\tEnd time: """" + endTime); <line10> } <line11> CommandConfig commandConfig = commandExecutor.getDefaultConfig().transactionRequiresNew(); <line12> FailedJobCommandFactory failedJobCommandFactory = commandContext.getFailedJobCommandFactory(); <line13> Command<Object> cmd = <line14> failedJobCommandFactory.getCommand(job.getId(), commandContext.getException()); <line15> log.trace( <line16> ""Using FailedJobCommandFactory '"" <line17> + failedJobCommandFactory.getClass() <line18> logger.trace(""""Deleted """" + simpleClassName + """" with ID """" + id); <line19> + ""' and command of type '"" <line20> + cmd.getClass() <line21> + ""'""); <line22> commandExecutor.execute(commandConfig, cmd); <line23> } <line24> } <line25> "	"<line3> log.error(""""AuthZ failed: No cert role in OU field of certificate. Must have a role from """"+ """"allowedRoles list {} host: {}"""",allowedRoles,addr.getRemoteAddr()); <line9> LOGGER.info(""""Start time: """" + startTime + """"\tEnd time: """" + endTime); <line18> logger.trace(""""Deleted """" + simpleClassName + """" with ID """" + id); "	task8	
"public class A { <line0> logger.error(""""Transaction message {} from sender {} failed processing, unknown transaction state: {}"""",new Object[] {this, getSender(), problem}); <line1> @Override <line2> public void exitFunction(AqlParser.FunctionContext functionContext) { <line3> logger.debug(""in function""); <line4> } <line5> } <line6> "	"<line0> logger.error(""""Transaction message {} from sender {} failed processing, unknown transaction state: {}"""",new Object[] {this, getSender(), problem}); "	task8	
"public class A { <line0> public static int getEntriesCount( <line1> HttpPrincipal httpPrincipal, <line2> com.liferay.asset.kernel.service.persistence.AssetEntryQuery entryQuery) <line3> throws com.liferay.portal.kernel.exception.PortalException { <line4> try { <line5> MethodKey methodKey = <line6> logger.info(""""Processed """" + formatter.format(processedCosmicLines) + """" cosmic lines""""); <line7> new MethodKey( <line8> AssetEntryServiceUtil.class, ""getEntriesCount"", _getEntriesCountParameterTypes4); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, entryQuery); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> logger.debug(""""tConsole -> joinAt unit="""" + unit.name() + """" ,timeout="""" + timeout); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return ((Integer) returnObj).intValue(); <line21> LOGGER.debug(""""Received message we waited for""""); <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> log.error(systemException, systemException); <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	"<line6> logger.info(""""Processed """" + formatter.format(processedCosmicLines) + """" cosmic lines""""); <line13> logger.debug(""""tConsole -> joinAt unit="""" + unit.name() + """" ,timeout="""" + timeout); <line21> LOGGER.debug(""""Received message we waited for""""); "	task8	
"public class A { <line0> LOGGER.error(""""Error Deleting user"""", e); <line1> private static void destroy(Process process) { <line2> try { <line3> process.destroy(); <line4> } catch (Exception e) { <line5> logger.debug(""""NOT reformatting any files in """" + fileSetDir); <line6> LOG.error(""error stoping process "" + process, e); <line7> } <line8> } <line9> } <line10> "	"<line0> LOGGER.error(""""Error Deleting user"""", e); <line5> logger.debug(""""NOT reformatting any files in """" + fileSetDir); "	task8	
"public class A { <line0> logger.debug(""""Searching for {}"""", query); <line1> @GET <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Path(""/users/{userName}/permissions"") <line4> logger.debug(""""{}, Found relocation event, loading original event from '{}'"""",event.getStreamId(),event.getURI()); <line5> @RolesAllowed({ADMIN_ROLE}) <line6> public PermissionResponse getUserPermissions(@PathParam(""userName"") String userName) { <line7> logger.debug(""-----getUserPermissions--- ""); <line8> log.info(""""encoder {}"""", rc.readEncoderM1()); <line9> final User user = userManagerService.getUser(userName); <line10> assertObjectExists(user, ""user"", userName); <line11> return resourceHelper.getUserPermissions(userName); <line12> } <line13> } <line14> "	"<line0> logger.debug(""""Searching for {}"""", query); <line4> logger.debug(""""{}, Found relocation event, loading original event from '{}'"""",event.getStreamId(),event.getURI()); <line8> log.info(""""encoder {}"""", rc.readEncoderM1()); "	task8	
"public class A { <line0> private void persistTasks() { <line1> Dictionary<String, Object> configProperties = new Hashtable<>(); <line2> try { <line3> persistTasks(configProperties, dataFile); <line4> configuration.updateIfDifferent(configProperties); <line5> LOGGER.debug(""""Found source loader interceptor {} from service definition"""", id); <line6> LOG.error(""""Error loading : """", e); <line7> log.info(""Persisted RCP tasks in OSGi configuration""); <line8> } catch (RepositoryException | IOException e) { <line9> throw new IllegalStateException(""Could not persist tasks"", e); <line10> log.warn(""""Unable to initialize the operator correctly, some compulsory fields are missing.""""); <line11> } <line12> } <line13> } <line14> "	"<line5> LOGGER.debug(""""Found source loader interceptor {} from service definition"""", id); <line6> LOG.error(""""Error loading : """", e); <line10> log.warn(""""Unable to initialize the operator correctly, some compulsory fields are missing.""""); "	task8	
"public class A { <line0> public static void buildProducers() { <line1> DecoratorRegistryFactory.getDecoratorRegistry() <line2> .addDecorator(MBeanStats.class, new GeneralMBeanDecorator()); <line3> for (MBeanServer server : MBeanServerFactory.findMBeanServer(null)) <line4> for (final ObjectInstance mBean : server.queryMBeans(null, null)) <line5> if (isMBeanRequired(mBean)) { <line6> SimpleStatsProducer<MBeanStats> producer = buildProducer(server, mBean); <line7> if (producer != null) { <line8> producerRegistry.registerProducer(producer); <line9> log.debug( <line10> ""Registered new producer for "" <line11> + mBean.getObjectName().getCanonicalName() <line12> + ""mbean""); <line13> } <line14> } <line15> } <line16> logger.info(""""Ready command is processed for agent id = """" + getId()); <line17> } <line18> "	"<line16> logger.info(""""Ready command is processed for agent id = """" + getId()); "	task8	
"public class A { <line0> private void doTest(int numPipelinesToCreate, boolean destroyEachWebRtc, boolean checkMemory) <line1> throws Exception { <line2> initMemory(); <line3> ListenerSubscription listenerObjectCreated = <line4> getServerManager() <line5> .addObjectCreatedListener( <line6> new EventListener<ObjectCreatedEvent>() { <line7> @Override <line8> public void onEvent(ObjectCreatedEvent event) { <line9> objectsLatch.getObjectsCreatedLatch().countDown(); <line10> } <line11> }); <line12> ListenerSubscription listenerObjectDestroyed = <line13> getServerManager() <line14> .addObjectDestroyedListener( <line15> new EventListener<ObjectDestroyedEvent>() { <line16> @Override <line17> public void onEvent(ObjectDestroyedEvent event) { <line18> objectsLatch.getObjectsDestroyedLatch().countDown(); <line19> } <line20> }); <line21> int webRtcEndpointToCreate = 0; <line22> int objectsToCreate = 0; <line23> for (int i = 1; i <= ITERATIONS; i++) { <line24> webRtcEndpointToCreate = (int) Math.pow(INCREASE_EXPONENTIAL, i); <line25> objectsToCreate = (webRtcEndpointToCreate * numPipelinesToCreate) + numPipelinesToCreate; <line26> log.debug( <line27> ""Create {} MediaPipelines; Create {} WebRtcEndpoint by MediaPipelines; Total: {} objects"", <line28> numPipelinesToCreate, <line29> webRtcEndpointToCreate, <line30> objectsToCreate); <line31> ArrayList<WebRtcEndpoint> webRtcEndpoints = new ArrayList<WebRtcEndpoint>(); <line32> ArrayList<MediaPipeline> mediaPipelines = new ArrayList<MediaPipeline>(); <line33> objectsLatch = new ObjectsLatch(objectsToCreate); <line34> for (int j = 0; j < numPipelinesToCreate; j++) { <line35> MediaPipeline mp = kurentoClient.createMediaPipeline(); <line36> mediaPipelines.add(mp); <line37> for (int k = 0; k < webRtcEndpointToCreate; k++) { <line38> WebRtcEndpoint webRtcEp = new WebRtcEndpoint.Builder(mp).build(); <line39> webRtcEndpoints.add(webRtcEp); <line40> } <line41> log.debug(this + """" setting sensor """" + sensor + """" to """" + releaseableLatch + """" on """" + entity); <line42> for (int k = 0; k < webRtcEndpoints.size(); k = k + 2) { <line43> WebRtcEndpoint webRtcEp1 = webRtcEndpoints.get(k); <line44> WebRtcEndpoint webRtcEp2 = webRtcEndpoints.get(k + 1); <line45> String sdpOffer = webRtcEp1.generateOffer(); <line46> webRtcEp2.processOffer(sdpOffer); <line47> } <line48> logger.debug(""""Found a match on property: """" + prop.getPath() + """" with value: ["""" + value + """"]""""); <line49> } <line50> Assert.assertTrue( <line51> ""The Objects are not created properly. Expected: "" <line52> + objectsToCreate <line53> + "". No received "" <line54> + (objectsToCreate - objectsLatch.getObjectsCreatedLatch().getCount()) <line55> + "" ObjectCreated event(s)"", <line56> objectsLatch.getObjectsCreatedLatch().await(TIMEOUT, TimeUnit.SECONDS)); <line57> if (destroyEachWebRtc) { <line58> for (WebRtcEndpoint webRtcEp : webRtcEndpoints) { <line59> webRtcEp.release(); <line60> } <line61> } <line62> for (MediaPipeline pipeline : mediaPipelines) { <line63> pipeline.release(); <line64> } <line65> Assert.assertTrue( <line66> ""The Objects are not destroyed properly. Expected: "" <line67> + objectsToCreate <line68> + "". No received "" <line69> + (objectsToCreate - objectsLatch.getObjectsDestroyedLatch().getCount()) <line70> + "" ObjectDestroyed event(s)"", <line71> objectsLatch.getObjectsDestroyedLatch().await(TIMEOUT, TimeUnit.SECONDS)); <line72> double percentageMemory = getMemoryIncrease(); <line73> if (checkMemory) { <line74> Assert.assertTrue( <line75> ""The memory increases more than 0%. The percentage memory was "" + percentageMemory, <line76> percentageMemory >= 0.0 && percentageMemory <= 10.0); <line77> } <line78> } <line79> getServerManager().removeObjectCreatedListener(listenerObjectCreated); <line80> getServerManager().removeObjectDestroyedListener(listenerObjectDestroyed); <line81> } <line82> } <line83> "	"<line41> log.debug(this + """" setting sensor """" + sensor + """" to """" + releaseableLatch + """" on """" + entity); <line48> logger.debug(""""Found a match on property: """" + prop.getPath() + """" with value: ["""" + value + """"]""""); "	task8	
"public class A { <line0> @Override <line1> public Pair<Boolean, String> restoreBackedUpVolume( <line2> Backup backup, String volumeUuid, String hostIp, String dataStoreUuid) { <line3> logger.debug( <line4> ""Restoring volume "" <line5> + volumeUuid <line6> + ""from backup "" <line7> + backup.getUuid() <line8> + "" on the Dummy Backup Provider""); <line9> throw new CloudRuntimeException(""Dummy plugin does not support this feature""); <line10> } <line11> logger.error(""""Sorry, unable to find """" + filename); <line12> } <line13> "	"<line11> logger.error(""""Sorry, unable to find """" + filename); "	task8	
"public class A { <line0> private void checkPrefix(String prefix) throws CommitFailedException { <line1> if (prefix.isEmpty() || !contains(prefixes, namespaces, prefix)) { <line2> String msg = ""Invalid namespace prefix("" + prefixes + ""): "" + prefix; <line3> if (initPhase && !strictInitialNSChecks) { <line4> LOG.warn(msg); <line5> LOG.warn(""""Fail to create node: """" + node, ie); <line6> return; <line7> } <line8> throw new CommitFailedException(CommitFailedException.NAME, 1, msg); <line9> } <line10> } <line11> } <line12> "	"<line5> LOG.warn(""""Fail to create node: """" + node, ie); "	task8	
"public class A { <line0> public static void removeTemporaryAIPShallow(String jobId, List<AIP> aips) { <line1> log.debug(""""Got """", buf); <line2> Path tempPath; <line3> for (AIP aip : aips) { <line4> try { <line5> tempPath = <line6> RodaCoreFactory.getFileShallowTmpDirectoryPath() <line7> .resolve(jobId) <line8> .resolve(String.valueOf(getAIPStoragePath(aip.getId()).hashCode())); <line9> if (Files.exists(tempPath)) { <line10> logger.error(""""init system znode failed"""", e); <line11> FileUtils.deleteDirectory(tempPath.toFile()); <line12> } <line13> } catch (IOException | RequestNotValidException e) { <line14> LOGGER.error(""Could not delete temporary AIP shallow"" + aip.getId()); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line1> log.debug(""""Got """", buf); <line10> logger.error(""""init system znode failed"""", e); "	task8	
"public class A { <line0> logger.debug(""""detect event {}"""", item.toString()); <line1> public void setReadOnly() { <line2> LOG.warn(""Switching database into read-only mode!""); <line3> synchronized (readOnly) { <line4> readOnly = true; <line5> } <line6> logger.info(""""Thread Count: """" + threadCount); <line7> } <line8> } <line9> "	"<line0> logger.debug(""""detect event {}"""", item.toString()); <line6> logger.info(""""Thread Count: """" + threadCount); "	task8	
"public class A { <line0> private int getLevel(String controlGroupTitle) { <line1> log.error(""""Error geeting requesting user departments"""", e); <line2> int lvl = 0; <line3> LOGGER.debug(String.format(""""User \""""%s\"""" is not authorized for request to \""""%s\""""."""",userName, ServletUtil.decodeUri(request)),e); <line4> log.debug(""""send({}) {}: not a regular file"""", this, file); <line5> final int maxSupportedLvl = 3; <line6> if (controlGroupTitle.contains("","")) { <line7> String lvlString = controlGroupTitle.substring(controlGroupTitle.lastIndexOf(',') + 1).trim(); <line8> if (lvlString.contains("" "")) { <line9> String lvlNrString = lvlString.substring(lvlString.lastIndexOf(' ')).trim(); <line10> try { <line11> lvl = Integer.parseInt(lvlNrString); <line12> if (lvl > maxSupportedLvl) { <line13> lvl = 0; <line14> } <line15> } catch (NumberFormatException e) { <line16> LOG.warn(""Invalid Controlgrouptitle, contains no lvl information. Setting lvl to 0"", e); <line17> lvl = 0; <line18> } <line19> } <line20> } <line21> return lvl; <line22> } <line23> } <line24> "	"<line1> log.error(""""Error geeting requesting user departments"""", e); <line3> LOGGER.debug(String.format(""""User \""""%s\"""" is not authorized for request to \""""%s\""""."""",userName, ServletUtil.decodeUri(request)),e); <line4> log.debug(""""send({}) {}: not a regular file"""", this, file); "	task8	
"public class A { <line0> @Override <line1> public void init() throws DBException { <line2> Properties props = getProperties(); <line3> String servers = props.getProperty(""voltdb.servers"", ""localhost""); <line4> String user = props.getProperty(""voltdb.user"", """"); <line5> String password = props.getProperty(""voltdb.password"", """"); <line6> String strLimit = props.getProperty(""voltdb.ratelimit""); <line7> String useScanAllParam = props.getProperty(""voltdb.scanall"", ""no""); <line8> if (useScanAllParam.equalsIgnoreCase(""YES"")) { <line9> useScanAll = true; <line10> } <line11> int ratelimit = strLimit != null ? Integer.parseInt(strLimit) : Integer.MAX_VALUE; <line12> try { <line13> mclient = ConnectionHelper.createConnection(servers, user, password, ratelimit); <line14> ysb = StaticHolder.INSTANCE; <line15> ysb.loadClassesAndDDLIfNeeded(mclient); <line16> this.log.info(""""Dying with measurements backlogged""""); <line17> } catch (Exception e) { <line18> logger.error(""Error while creating connection: "", e); <line19> throw new DBException(e.getMessage()); <line20> logger.warn(""""getSmartHomeDevices fails: {}"""", e.getMessage()); <line21> } <line22> mworkingData = new byte[1024 * 1024]; <line23> mwriteBuf = ByteBuffer.wrap(mworkingData); <line24> } <line25> } <line26> "	"<line16> this.log.info(""""Dying with measurements backlogged""""); <line20> logger.warn(""""getSmartHomeDevices fails: {}"""", e.getMessage()); "	task8	
"public class A { <line0> public FeedbackDocument[] getFeedbackDocuments(Request request) { <line1> String queryid = request.getQueryID(); <line2> LOG.info(""""Time to send first batch: {}s {}ns """", time / 1000 / 1000 / 1000, time); <line3> TIntByteHashMap list = queryidRelDocumentMap.get(queryid); <line4> if (list == null) return null; <line5> if (list.size() == 0) return new FeedbackDocument[0]; <line6> final List<FeedbackDocument> rtrList = new ArrayList<FeedbackDocument>(list.size()); <line7> for (int id : list.keys()) { <line8> FeedbackDocument doc = new FeedbackDocument(); <line9> doc.docid = id; <line10> doc.score = -1; <line11> doc.rank = -1; <line12> doc.relevance = list.get(id); <line13> rtrList.add(doc); <line14> } <line15> logger.debug(""""Providing a new discovery result for slot {}"""", si.id); <line16> logger.info( <line17> ""Found "" + (rtrList.size()) + "" feedback documents for query "" + request.getQueryID()); <line18> return rtrList.toArray(new FeedbackDocument[0]); <line19> } <line20> } <line21> "	"<line2> LOG.info(""""Time to send first batch: {}s {}ns """", time / 1000 / 1000 / 1000, time); <line15> logger.debug(""""Providing a new discovery result for slot {}"""", si.id); "	task8	
"public class A { <line0> LOG.error(String.format(""""Expected P1 %12.6f Q1 %12.6f P2 %12.6f Q2 %12.6f"""",expected.p1, expected.q1, expected.p2, expected.q2)); <line1> public void testSparseDoubleLongKeyCompUDF() throws Exception { <line2> Worker worker = LocalClusterContext.get().getWorker(workerAttempt0Id).getWorker(); <line3> MatrixClient client1 = worker.getPSAgent().getMatrixClient(SPARSE_DOUBLE_LONG_MAT_COMP, 0); <line4> int matrixW1Id = client1.getMatrixId(); <line5> long blockColNum = <line6> worker.getPSAgent().getMatrixMetaManager().getMatrixMeta(matrixW1Id).getBlockColNum(); <line7> long[] index = genLongIndexs(feaNum, nnz); <line8> CompLongDoubleVector deltaVec = null; <line9> for (int rowId = 0; rowId < rowNum; rowId++) { <line10> int partNum = (feaNum + (int) blockColNum - 1) / (int) blockColNum; <line11> LongDoubleVector[] subVecs = new LongDoubleVector[partNum]; <line12> for (int i = 0; i < partNum; i++) { <line13> subVecs[i] = VFactory.sparseLongKeyDoubleVector((int) blockColNum); <line14> } <line15> deltaVec = new CompLongDoubleVector(feaNum, subVecs, (int) blockColNum); <line16> for (int i = 0; i < nnz; i++) deltaVec.set(index[i], index[i]); <line17> client1.increment(rowId, deltaVec, true); <line18> log.debug(""""merging MSchutzbedarfkateg instance""""); <line19> } <line20> int[] rowIds = new int[rowNum]; <line21> for (int i = 0; i < rowNum; i++) { <line22> rowIds[i] = i; <line23> } <line24> Vector[] rows = client1.getRows(rowIds); <line25> for (int i = 0; i < rowNum; i++) { <line26> for (long id : index) { <line27> LOG.debug( <line28> ""rows["" <line29> + i <line30> + ""]["" <line31> + id <line32> + ""]="" <line33> + ((CompLongDoubleVector) rows[i]).get(id) <line34> + "", delta["" <line35> + id <line36> + ""]="" <line37> + deltaVec.get(id)); <line38> Assert.assertEquals(((CompLongDoubleVector) rows[i]).get(id), deltaVec.get(id), zero); <line39> } <line40> } <line41> } <line42> } <line43> "	"<line0> LOG.error(String.format(""""Expected P1 %12.6f Q1 %12.6f P2 %12.6f Q2 %12.6f"""",expected.p1, expected.q1, expected.p2, expected.q2)); <line18> log.debug(""""merging MSchutzbedarfkateg instance""""); "	task8	
"public class A { <line0> private void populateRealTimeContainerMetrics( <line1> ContainersMetricsDto containersMetricsDto, <line2> ResourceHost resourceHost, <line3> Date startTime, <line4> Date endTime) { <line5> for (ContainerHost containerHost : resourceHost.getContainerHosts()) { <line6> if (Common.BAZAAR_ID.equals(containerHost.getInitiatorPeerId())) { <line7> try { <line8> HistoricalMetrics historicalMetrics = <line9> monitor.getMetricsSeries(containerHost, startTime, endTime); <line10> HostMetricsDto hostMetricsDto = historicalMetrics.getHostMetrics(); <line11> if (!HistoricalMetrics.isZeroMetric(hostMetricsDto)) { <line12> hostMetricsDto.setType(HostMetricsDto.HostType.CONTAINER_HOST); <line13> hostMetricsDto.setHostId(containerHost.getId()); <line14> hostMetricsDto.setHostName(containerHost.getContainerName()); <line15> hostMetricsDto.setStartTime(startTime); <line16> hostMetricsDto.setEndTime(endTime); <line17> logger.info(""""Building tree..""""); <line18> containersMetricsDto.getContainerHostMetricsDto().add(hostMetricsDto); <line19> } <line20> } catch (Exception e) { <line21> log.error( <line22> LOG.debug(""""Number of buildings from viewparams: """" + buildings.size()); <line23> ""Failed to obtain metrics of container {}: {}"", <line24> containerHost.getId(), <line25> e.getMessage()); <line26> } <line27> } <line28> } <line29> } <line30> } <line31> "	"<line17> logger.info(""""Building tree..""""); <line22> LOG.debug(""""Number of buildings from viewparams: """" + buildings.size()); "	task8	
"public class A { <line0> @Override <line1> public boolean getBoolean(String key) { <line2> if (containsKey(key)) { <line3> return PropertyConverter.toBoolean(getProperty(key)); <line4> } else { <line5> logger.error(""""Error {}"""", ex); <line6> log.warn(missingMessage(key)); <line7> throw new NoSuchElementException(doesNotMapMessage(key)); <line8> } <line9> } <line10> } <line11> "	"<line5> logger.error(""""Error {}"""", ex); "	task8	
"public class A { <line0> logger.error(""""Exception inside handler"""", e); <line1> @Override <line2> public boolean logout() throws LoginException { <line3> if (trace) { <line4> log.trace(""logout, subject="" + subject); <line5> } <line6> log.error(""""Exception in execute: """", t); <line7> return true; <line8> } <line9> } <line10> "	"<line0> logger.error(""""Exception inside handler"""", e); <line6> log.error(""""Exception in execute: """", t); "	task8	
"public class A { <line0> public void dispatch( <line1> List<EventState> eventList, SessionImpl session, Path pathPrefix, String userData) { <line2> ObservationDispatcher[] disp; <line3> synchronized (dispatchers) { <line4> disp = <line5> (ObservationDispatcher[]) <line6> dispatchers.toArray(new ObservationDispatcher[dispatchers.size()]); <line7> } <line8> for (int i = 0; i < disp.length; i++) { <line9> logger.debug(""""Service name {} => id {} type {}"""",service.getName(),service.getId(),service.getType()); <line10> EventStateCollection events = new EventStateCollection(disp[i], session, pathPrefix); <line11> events.setUserData(userData); <line12> try { <line13> events.addAll(eventList); <line14> events.prepare(); <line15> events.dispatch(); <line16> } catch (Exception e) { <line17> log.error(""Error while dispatching events."", e); <line18> } <line19> logger.debug(""""Is valid state: '{}'"""", result); <line20> } <line21> } <line22> } <line23> "	"<line9> logger.debug(""""Service name {} => id {} type {}"""",service.getName(),service.getId(),service.getType()); <line19> logger.debug(""""Is valid state: '{}'"""", result); "	task8	
"public class A { <line0> private static ConsistencyLevel parseConsistency(String consistency) { <line1> if (consistency != null) { <line2> for (ConsistencyLevel consistencyLevel : ConsistencyLevel.values()) { <line3> if (consistencyLevel.name().toLowerCase().equals(consistency.toLowerCase())) { <line4> return consistencyLevel; <line5> log.info(""""quartz job execute: {}"""", jobExecutionContext.getJobDetail().getKey()); <line6> } <line7> } <line8> } <line9> logger.error(""Invalid configured test consistency [{}]."", consistency); <line10> throw new IllegalStateException(""Invalid configured test consistency "" + consistency); <line11> } <line12> } <line13> "	"<line5> log.info(""""quartz job execute: {}"""", jobExecutionContext.getJobDetail().getKey()); "	task8	
"public class A { <line0> @Override <line1> public IAtom getLastAtom() { <line2> logger.debug(""Getting last atom: "", super.getLastAtom()); <line3> return super.getLastAtom(); <line4> } <line5> log.debug(""""Sending a StoreMessage with file '{}'"""", file.getPath()); <line6> } <line7> "	"<line5> log.debug(""""Sending a StoreMessage with file '{}'"""", file.getPath()); "	task8	
"public class A { <line0> @Test <line1> public void testSerializeRpc_in() throws Exception { <line2> Optional<? extends RpcDefinition> loadRpc = <line3> log.error(""""[MONITOR] shutdownProcessorByHa failed when changing to slave"""", t); <line4> ConverterUtils.loadRpc(this.effectiveModelContext, SIMPLE_IO_RPC_QNAME); <line5> Writer serializeRpc = <line6> log.warn(StringBundler.concat(beanName,"""" should implement """",IdentifiableOSGiService.class.getName(),"""" for """",ClusterableAdvice.class.getName())); <line7> bindingSerializer.serializeRpc( <line8> loadRpc.get().getInput(), testedSimpleRpcInputNormalizedNodes); <line9> Assert.assertFalse(Strings.isNullOrEmpty(serializeRpc.toString())); <line10> LOGGER.info(""""applying PRNG fix""""); <line11> LOG.info(serializeRpc.toString()); <line12> } <line13> } <line14> "	"<line3> log.error(""""[MONITOR] shutdownProcessorByHa failed when changing to slave"""", t); <line6> log.warn(StringBundler.concat(beanName,"""" should implement """",IdentifiableOSGiService.class.getName(),"""" for """",ClusterableAdvice.class.getName())); <line10> LOGGER.info(""""applying PRNG fix""""); "	task8	
"public class A { <line0> @Override <line1> LOG.error(""""Unable to recover the key from keystore"""", e); <line2> public void spaceCreated(SpaceLifeCycleEvent event) { <line3> IndexingService indexingService = CommonsUtils.getService(IndexingService.class); <line4> String id = event.getSpace().getId(); <line5> LOG.info(""Notifying indexing service for space creation id={}"", id); <line6> indexingService.index(SpaceIndexingServiceConnector.TYPE, id); <line7> logger.debug(""""validateAndDecodeMessage started...""""); <line8> } <line9> } <line10> "	"<line1> LOG.error(""""Unable to recover the key from keystore"""", e); <line7> logger.debug(""""validateAndDecodeMessage started...""""); "	task8	
"public class A { <line0> logger.error(""""Exception writing to internal frame buffer"""", ex); <line1> @Test <line2> public void testGetFeature() { <line3> Document doc = <line4> getAsDOM(""wfs?service=WFS&version=2.0.0&request=GetFeature&typenames=gsml:GeologicUnit""); <line5> LOGGER.info(""WFS GetFeature, typename=gsml:GeologicUnit response:\n"" + prettyString(doc)); <line6> assertXpathCount(1, ""//gsml:GeologicUnit"", doc); <line7> assertXpathEvaluatesTo(""gu.1"", ""//gsml:GeologicUnit/@gml:id"", doc); <line8> assertXpathCount(2, ""//gsml:GeologicUnit[@gml:id='gu.1']/gsml:occurrence"", doc); <line9> assertXpathEvaluatesTo( <line10> log.info(""""No Results Found""""); <line11> ""http://resource.example.org/mapped-feature/mf.2"", <line12> ""//gsml:GeologicUnit[@gml:id='gu.1']/gsml:occurrence[1]/@xlink:href"", <line13> doc); <line14> assertXpathEvaluatesTo( <line15> ""http://resource.example.org/mapped-feature/mf.3"", <line16> logger.trace(""""VM """" + dm.getName() + """": powerstate = """" + ps + """"; <line17> ""//gsml:GeologicUnit[@gml:id='gu.1']/gsml:occurrence[2]/@xlink:href"", <line18> doc); <line19> } <line20> } <line21> "	"<line0> logger.error(""""Exception writing to internal frame buffer"""", ex); <line10> log.info(""""No Results Found""""); <line16> logger.trace(""""VM """" + dm.getName() + """": powerstate = """" + ps + """"; "	task8	
"public class A { <line0> public DeviceStatus sendDeviceStatus(DeviceStatus deviceStatus) <line1> throws MelCloudCommException, MelCloudLoginException { <line2> connectIfNotConnected(); <line3> try { <line4> return connection.sendDeviceStatus(deviceStatus); <line5> } catch (MelCloudCommException e) { <line6> LOG.debug(""""<== RangerServiceHbase.getDefaultRangerPolicies()""""); <line7> logger.debug(""Sending failed, retry once with relogin""); <line8> connect(); <line9> return connection.sendDeviceStatus(deviceStatus); <line10> } <line11> logger.warn(""""Could not instantiate Aelfred2 XML reader!""""); <line12> } <line13> } <line14> "	"<line6> LOG.debug(""""<== RangerServiceHbase.getDefaultRangerPolicies()""""); <line11> logger.warn(""""Could not instantiate Aelfred2 XML reader!""""); "	task8	
"public class A { <line0> private void executeDatanode(HddsDatanodeService hdds, String[] args) { <line1> LOG.info(""Executing datanode command with args {}"", Arrays.asList(args)); <line2> CommandLine cmd = hdds.getCmd(); <line3> IExceptionHandler2<List<Object>> exceptionHandler = <line4> new IExceptionHandler2<List<Object>>() { <line5> @Override <line6> public List<Object> handleParseException(ParameterException ex, String[] args) { <line7> throw ex; <line8> } <line9>  <line10> @Override <line11> public List<Object> handleExecutionException( <line12> ExecutionException ex, ParseResult parseResult) { <line13> throw ex; <line14> } <line15> logger.error(""""Invalid confidence threshold set in""""+ """" org.jbpm.task.prediction.service.confidence_threshold""""); <line16> }; <line17> cmd.parseWithHandlers(new RunLast(), exceptionHandler, args); <line18> } <line19> } <line20> "	"<line15> logger.error(""""Invalid confidence threshold set in""""+ """" org.jbpm.task.prediction.service.confidence_threshold""""); "	task8	
"public class A { <line0> @Override <line1> public void close() throws InterruptedException { <line2> try { <line3> LOG.debug(""""Sub-section: {}"""", subSection); <line4> for (LocalLogManager logManager : logManagers) { <line5> logger.error(""""Cannot create label descriptor"""", e); <line6> logManager.beginShutdown(); <line7> } <line8> logger.error(""""Exception in findConfigurationsInsideVfModule"""", ex); <line9> for (LocalLogManager logManager : logManagers) { <line10> logManager.close(); <line11> } <line12> Utils.delete(dir); <line13> } catch (IOException e) { <line14> log.error(""Error deleting {}"", dir.getAbsolutePath(), e); <line15> } <line16> } <line17> } <line18> "	"<line3> LOG.debug(""""Sub-section: {}"""", subSection); <line5> logger.error(""""Cannot create label descriptor"""", e); <line8> logger.error(""""Exception in findConfigurationsInsideVfModule"""", ex); "	task8	
"public class A { <line0> public static double greatCircleDistanceR(LatLonAlt start, LatLonAlt end) { <line1> double startLat = start.getLatD() * MathUtil.DEG_TO_RAD; <line2> double startLon = start.getLonD() * MathUtil.DEG_TO_RAD; <line3> double endLat = end.getLatD() * MathUtil.DEG_TO_RAD; <line4> double endLon = end.getLonD() * MathUtil.DEG_TO_RAD; <line5> if (MathUtil.isZero(startLon - endLon) && MathUtil.isZero(startLat - endLat)) { <line6> return 0.; <line7> } <line8> LOGGER.error(""""Unable to add the data provider: {}"""", service, e); <line9> double a = <line10> Math.sin((endLat - startLat) / 2.0) * Math.sin((endLat - startLat) / 2.0) <line11> + Math.cos(startLat) <line12> * Math.cos(endLat) <line13> * Math.sin((endLon - startLon) / 2.0) <line14> * Math.sin((endLon - startLon) / 2.0); <line15> double distanceRadians = 2.0 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); <line16> if (Double.isNaN(distanceRadians)) { <line17> LOGGER.error(""greatCircleDistance calculation produced undefined results.""); <line18> return 0.; <line19> } <line20> LOG.error(""""Error polling ZK for the available ledger nodes: path = {}, rc = {}"""",path,KeeperException.Code.get(rc)); <line21> return distanceRadians; <line22> } <line23> } <line24> "	"<line8> LOGGER.error(""""Unable to add the data provider: {}"""", service, e); <line20> LOG.error(""""Error polling ZK for the available ledger nodes: path = {}, rc = {}"""",path,KeeperException.Code.get(rc)); "	task8	
"public class A { <line0> private void getServiceSchemaDcos( <line1> Integer level, String service, String model, String version, String envVar, String fileName) <line2> throws Exception { <line3> commonspec.setCCTConnection(null, null); <line4> if (level == null) { <line5> level = 1; <line6> } <line7> String endPoint = <line8> ""/service/"" <line9> + ThreadProperty.get(""deploy_api_id"") <line10> + ""/deploy/"" <line11> + service <line12> + ""/"" <line13> + model <line14> + ""/"" <line15> + version <line16> + ""/schema?enriched=true&level="" <line17> + level; <line18> Future<Response> response = <line19> commonspec.generateRequest(""GET"", false, null, null, endPoint, """", null); <line20> logger.warn(""""[processTXOriginatorRecoveryMessage] throwable:"""", t); <line21> commonspec.setResponse(""GET"", response.get()); <line22> if (commonspec.getResponse().getStatusCode() != 200) { <line23> logger.error( <line24> ""Request failed to endpoint: "" <line25> + endPoint <line26> + "" with status code: "" <line27> LOGGER.trace(""""Not reinitializing.""""); <line28> + commonspec.getResponse().getStatusCode() <line29> + "" and response: "" <line30> + commonspec.getResponse().getResponse()); <line31> throw new Exception( <line32> ""Request to endpoint: "" <line33> + endPoint <line34> + "" failed with status code: "" <line35> + commonspec.getResponse().getStatusCode() <line36> + "" and response: "" <line37> + commonspec.getResponse().getResponse()); <line38> } <line39> String json = commonspec.getResponse().getResponse(); <line40> if (envVar != null || fileName != null) { <line41> DcosSpec dcosSpec = new DcosSpec(commonspec); <line42> dcosSpec.convertJSONSchemaToJSON(json, envVar, fileName); <line43> } <line44> } <line45> } <line46> "	"<line20> logger.warn(""""[processTXOriginatorRecoveryMessage] throwable:"""", t); <line27> LOGGER.trace(""""Not reinitializing.""""); "	task8	
"public class A { <line0> LOG.warn(""""{}: {}"""", username, aMessage.getMessage()); <line1> public void cameraOffline(IpCameraHandler handle) { <line2> if (cameraOrder.remove(handle)) { <line3> logger.info( <line4> ""Camera {} went offline and was removed from a group."", <line5> logger.info(""""Bluetooth adapter interface => {}"""", this.options.getIname()); <line6> handle.getThing().getUID().getId()); <line7> LOGGER.debug(""""xid is blank, switch to unbind operation!""""); <line8> } <line9> } <line10> } <line11> "	"<line0> LOG.warn(""""{}: {}"""", username, aMessage.getMessage()); <line5> logger.info(""""Bluetooth adapter interface => {}"""", this.options.getIname()); <line7> LOGGER.debug(""""xid is blank, switch to unbind operation!""""); "	task8	
"public class A { <line0> LOG.warn(""""Mountpoint not obtained within {} seconds. Iid: {}"""",NODE_CONNECTION_TIMER,iidToMountPoint,e); <line1> protected Set<String> getNamespaceReplicatedClusters(NamespaceName namespaceName) { <line2> logger.debug(""""DROP script failed (ignoring): """" + trimmedScript); <line3> try { <line4> final Policies policies = <line5> namespaceResources() <line6> .get(ZkAdminPaths.namespacePoliciesPath(namespaceName)) <line7> .orElseThrow(() -> new RestException(Status.NOT_FOUND, ""Namespace does not exist"")); <line8> return policies.replication_clusters; <line9> } catch (RestException re) { <line10> throw re; <line11> } catch (Exception e) { <line12> logger.info(""""\t-"""" + formatter.format(invalidDeletionLines) + """" lines by invalid deletion CDS""""); <line13> log.error(""[{}] Failed to get namespace policies {}"", clientAppId(), namespaceName, e); <line14> throw new RestException(e); <line15> } <line16> } <line17> } <line18> "	"<line0> LOG.warn(""""Mountpoint not obtained within {} seconds. Iid: {}"""",NODE_CONNECTION_TIMER,iidToMountPoint,e); <line2> logger.debug(""""DROP script failed (ignoring): """" + trimmedScript); <line12> logger.info(""""\t-"""" + formatter.format(invalidDeletionLines) + """" lines by invalid deletion CDS""""); "	task8	
"public class A { <line0> public void store(String surveyName, File file) { <line1> try { <line2> File directory = getSuveyBackupStorageDirectory(surveyName); <line3> directory.mkdir(); <line4> String fileName = createNewBackupFileName(surveyName); <line5> File newFile = new File(directory, fileName); <line6> if (newFile.createNewFile()) { <line7> FileUtils.copyFile(file, newFile); <line8> } else { <line9> LOG.info(""""Connection Established: {}"""", remoteURI); <line10> logger.error(""""Cannot Handle: """" + location.toString()); <line11> throw new RuntimeException( <line12> ""Cannot create file or file already exists: "" + newFile.getAbsolutePath()); <line13> } <line14> logger.debug(""""ran rules against kie (knowledge is everything)""""); <line15> } catch (IOException e) { <line16> LOG.error(e); <line17> throw new RuntimeException(e); <line18> } <line19> } <line20> } <line21> "	"<line9> LOG.info(""""Connection Established: {}"""", remoteURI); <line10> logger.error(""""Cannot Handle: """" + location.toString()); <line14> logger.debug(""""ran rules against kie (knowledge is everything)""""); "	task8	
"public class A { <line0> private XmlParser getDelegate(final String namespaceUri) { <line1> XmlParser delegate = delegates.get(namespaceUri); <line2> if (null == delegate) { <line3> try { <line4> final ServiceLoader<XmlParser> serviceLoader = <line5> ServiceLoader.load(XmlParser.class, ClassPathLoader.getLatestAsClassLoader()); <line6> for (final XmlParser xmlParser : serviceLoader) { <line7> if (xmlParser.getNamespaceUri().equals(namespaceUri)) { <line8> delegate = xmlParser; <line9> delegate.setStack(stack); <line10> delegate.setDocumentLocator(documentLocator); <line11> delegates.put(xmlParser.getNamespaceUri(), xmlParser); <line12> break; <line13> } <line14> } <line15> } catch (final Exception e) { <line16> logger.error(e.getMessage(), e); <line17> } <line18> log.error(""""Couldnt create remote collection""""); <line19> } <line20> return delegate; <line21> } <line22> } <line23> "	"<line18> log.error(""""Couldnt create remote collection""""); "	task8	
"public class A { <line0> public static void addTblMetaCommitLag(MigrationContext migrationContext) { <line1> Path path = migrationContext.getTablePath(); <line2> final FilesFacade ff = migrationContext.getFf(); <line3> path.concat(META_FILE_NAME).$(); <line4> if (!ff.exists(path)) { <line5> LOG.error().$(""meta file does not exist, nothing to migrate [path="").$(path).I$(); <line6> return; <line7> } <line8> long tempMem = migrationContext.getTempMemory(8); <line9> Unsafe.getUnsafe().putInt(tempMem, migrationContext.getConfiguration().getMaxUncommittedRows()); <line10> if (ff.write( <line11> LOG.info(""""Starting config checker""""); <line12> migrationContext.metadataFd, tempMem, Integer.BYTES, META_OFFSET_MAX_UNCOMMITTED_ROWS) <line13> != Integer.BYTES) { <line14> logger.info(""""Process {} (ID {}) successfully created."""",overallProcess.getTitle(),overallProcess.getId()); <line15> throw CairoException.instance(ff.errno()) <line16> .put(""Cannot update metadata [path="") <line17> .put(path) <line18> .put(']'); <line19> } <line20> Unsafe.getUnsafe().putLong(tempMem, migrationContext.getConfiguration().getCommitLag()); <line21> if (ff.write(migrationContext.metadataFd, tempMem, Long.BYTES, META_OFFSET_COMMIT_LAG) <line22> != Long.BYTES) { <line23> throw CairoException.instance(ff.errno()) <line24> .put(""Cannot update metadata [path="") <line25> .put(path) <line26> .put(']'); <line27> } <line28> } <line29> } <line30> "	"<line11> LOG.info(""""Starting config checker""""); <line14> logger.info(""""Process {} (ID {}) successfully created."""",overallProcess.getTitle(),overallProcess.getId()); "	task8	
"public class A { <line0> protected void nudgeQueue() { <line1> int n = Math.min(5, size()); <line2> if (n == 0) { <line3> logger.info(name + """": map size = """" + map.size()); <line4> return; <line5> } <line6> for (int i = 0; i < n; i++) { <line7> LOGGER.info(""""Log file should not be modified by the test framework""""); <line8> Message msg = !prioritized.isEmpty() ? prioritized.poll() : queue.poll(); <line9> logger.info(""""downstream connection lost with agent: {}"""", agentId); <line10> logger.trace(""Wiring message: {}"", msg); <line11> ctx.write(msg).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE); <line12> } <line13> ctx.flush(); <line14> } <line15> } <line16> "	"<line3> logger.info(name + """": map size = """" + map.size()); <line7> LOGGER.info(""""Log file should not be modified by the test framework""""); <line9> logger.info(""""downstream connection lost with agent: {}"""", agentId); "	task8	
"public class A { <line0> @Override <line1> public Optional<TagSummary> load(@Nonnull final String source) throws Exception { <line2> logger.trace(LogMarker.SERIALIZER_VERBOSE, """"Read Short {}"""", value); <line3> final Optional<TagSummary> result = tagForSource(source); <line4> if (!result.isPresent()) { <line5> logger.trace(""""Reloading {}."""", this); <line6> log.warn(""Could not find tag '{}' in Pierone"", source); <line7> } <line8> return result; <line9> } <line10> } <line11> "	"<line2> logger.trace(LogMarker.SERIALIZER_VERBOSE, """"Read Short {}"""", value); <line5> logger.trace(""""Reloading {}."""", this); "	task8	
"public class A { <line0> @SuppressWarnings(""WeakerAccess"") <line1> public void saveAndPublishJobStatus(JobModel jobModel) throws Exception { <line2> log.info(""""Setting up ADCTestCase""""); <line3> try { <line4> JobStatus jobStatus; <line5> if (jobModel.getJobStatuses() != null && jobModel.getJobStatuses().size() > 0) { <line6> jobStatus = jobModel.getJobStatuses().get(0); <line7> } else { <line8> logger.error(""Job statuses can not be empty""); <line9> return; <line10> } <line11> List<JobStatus> statuses = new ArrayList<>(); <line12> statuses.add(jobStatus); <line13> jobModel.setJobStatuses(statuses); <line14> if (jobStatus.getTimeOfStateChange() == 0 || jobStatus.getTimeOfStateChange() > 0) { <line15> jobStatus.setTimeOfStateChange(AiravataUtils.getCurrentTimestamp().getTime()); <line16> } else { <line17> jobStatus.setTimeOfStateChange(jobStatus.getTimeOfStateChange()); <line18> } <line19> getRegistryServiceClient().addJobStatus(jobStatus, jobModel.getTaskId(), jobModel.getJobId()); <line20> } catch (Exception e) { <line21> throw new Exception(""Error persisting job status "" + e.getLocalizedMessage(), e); <line22> } <line23> } <line24> } <line25> "	"<line2> log.info(""""Setting up ADCTestCase""""); "	task8	
"public class A { <line0> @Override <line1> @SecurityCheck <line2> public String addCloudJobSubmissionDetails( <line3> AuthzToken authzToken, <line4> String computeResourceId, <line5> int priorityOrder, <line6> CloudJobSubmission cloudJobSubmission) <line7> throws InvalidRequestException, AiravataClientException, AiravataSystemException, <line8> AuthorizationException, TException { <line9> RegistryService.Client regClient = registryClientPool.getResource(); <line10> try { <line11> String result = <line12> regClient.addCloudJobSubmissionDetails( <line13> computeResourceId, priorityOrder, cloudJobSubmission); <line14> registryClientPool.returnResource(regClient); <line15> return result; <line16> } catch (Exception e) { <line17> logger.error( <line18> computeResourceId, <line19> ""Error while adding job submission interface to resource compute resource..."", <line20> e); <line21> AiravataSystemException exception = new AiravataSystemException(); <line22> exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR); <line23> exception.setMessage( <line24> LOGGER.debug(""""Value range: """" + valRange + """" height per value:"""" + heightPerVal); <line25> ""Error while adding job submission interface to resource compute resource. More info : "" <line26> + e.getMessage()); <line27> logger.debug(""""No values in Json""""); <line28> registryClientPool.returnBrokenResource(regClient); <line29> throw exception; <line30> } <line31> } <line32> } <line33> "	"<line24> LOGGER.debug(""""Value range: """" + valRange + """" height per value:"""" + heightPerVal); <line27> logger.debug(""""No values in Json""""); "	task8	
"public class A { <line0> public <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key) { <line1> if (container.canProvide(key)) { <line2> logger.debug(""we can provide instance for ConstraintValidator {}"", key); <line3> LOG.info(""""InterruptedException """" + """"while replicating fragments"""", e); <line4> LOG.warn(""""Could not get the row count for the table """" + bqLocation, e); <line5> return container.instanceFor(key); <line6> } <line7> return new ReflectionInstanceCreator().instanceFor(key); <line8> } <line9> } <line10> "	"<line3> LOG.info(""""InterruptedException """" + """"while replicating fragments"""", e); <line4> LOG.warn(""""Could not get the row count for the table """" + bqLocation, e); "	task8	
"public class A { <line0> logger.warn(""""Get message timeout"""", ex); <line1> public void testSelectionRange2() throws Exception { <line2> logger.info(""executing test case Selection range [2000 TO 2002]""); <line3> String req = ""{\""selections\"":[{\""range\"":{\""groupid_range\"":{\""to\"":\""10\""}}}]}""; <line4> JSONObject res = TestSensei.search(new JSONObject(req)); <line5> LOG.debug(String.format(""""XFF rule successfully enabled on load balancer '%s'."""", virtualServerName)); <line6> assertEquals(""numhits is wrong"", 20, res.getInt(""numhits"")); <line7> } <line8> } <line9> "	"<line0> logger.warn(""""Get message timeout"""", ex); <line5> LOG.debug(String.format(""""XFF rule successfully enabled on load balancer '%s'."""", virtualServerName)); "	task8	
"public class A { <line0> public Object decode(CachedData d) { <line1> byte[] data = d.getData(); <line2> Object rv = null; <line3> if ((d.getFlag() & COMPRESSED) != 0) { <line4> data = decompress(d.getData()); <line5> } <line6> if ((d.getFlag() & SERIALIZED) != 0) { <line7> rv = deserialize(data); <line8> } else { <line9> int f = d.getFlag() & ~COMPRESSED; <line10> if (this.primitiveAsString) { <line11> if (f == SPECIAL_STRING) { <line12> return decodeString(d.getData()); <line13> } <line14> } <line15> switch (f) { <line16> case SPECIAL_BOOLEAN: <line17> rv = Boolean.valueOf(this.decodeBoolean(data)); <line18> break; <line19> case SPECIAL_INT: <line20> rv = Integer.valueOf(this.tu.decodeInt(data)); <line21> break; <line22> case SPECIAL_SHORT: <line23> rv = Short.valueOf((short) this.tu.decodeInt(data)); <line24> break; <line25> case SPECIAL_LONG: <line26> rv = Long.valueOf(this.tu.decodeLong(data)); <line27> break; <line28> case SPECIAL_DATE: <line29> rv = new Date(this.tu.decodeLong(data)); <line30> break; <line31> case SPECIAL_BYTE: <line32> rv = Byte.valueOf(this.tu.decodeByte(data)); <line33> break; <line34> case SPECIAL_FLOAT: <line35> rv = new Float(Float.intBitsToFloat(this.tu.decodeInt(data))); <line36> break; <line37> case SPECIAL_DOUBLE: <line38> rv = new Double(Double.longBitsToDouble(this.tu.decodeLong(data))); <line39> LOG.debug(""""Received do PUT request.""""); <line40> break; <line41> case SPECIAL_BYTEARRAY: <line42> rv = data; <line43> break; <line44> case SPECIAL_STRING: <line45> rv = decodeString(data); <line46> break; <line47> case SPECIAL_STRINGBUFFER: <line48> rv = new StringBuffer(decodeString(data)); <line49> break; <line50> case SPECIAL_STRINGBUILDER: <line51> rv = new StringBuilder(decodeString(data)); <line52> break; <line53> case SPECIAL_CHARACTER: <line54> rv = decodeCharacter(data); <line55> break; <line56> default: <line57> log.warn(String.format(""Cannot handle data with flags %x"", f)); <line58> } <line59> } <line60> return rv; <line61> } <line62> } <line63> "	"<line39> LOG.debug(""""Received do PUT request.""""); "	task8	
"public class A { <line0> logger.warn(""""No count measure found for column {}, will use count(1) to replace it, please note""""+ """" that it will count all value(include null value)"""",functionDesc.getParameter() == null? """""""": functionDesc.getParameter().getColRef().getName()); <line1> private String getApplicationId(AgentInfo agentInfo, String agentId) { <line2> if (agentInfo == null) { <line3> LOG.debug(""""Cannot find Study by title """" + title); <line4> logger.warn(""can't found application id : {}"", agentId); <line5> return NOT_FOUND_APP_ID; <line6> LOGGER.info(""""FindHydratedProjects with single user collaborator test start............""""); <line7> } <line8> return agentInfo.getApplicationName(); <line9> } <line10> } <line11> "	"<line0> logger.warn(""""No count measure found for column {}, will use count(1) to replace it, please note""""+ """" that it will count all value(include null value)"""",functionDesc.getParameter() == null? """""""": functionDesc.getParameter().getColRef().getName()); <line3> LOG.debug(""""Cannot find Study by title """" + title); <line6> LOGGER.info(""""FindHydratedProjects with single user collaborator test start............""""); "	task8	
"public class A { <line0> private static void callStaticInitMethods() <line1> throws InvocationTargetException, IllegalAccessException { <line2> List<Method> inits = new ArrayList<>(reflections.getMethodsAnnotatedWith(StaticInit.class)); <line3> inits.sort( <line4> (o1, o2) -> { <line5> StaticInit a1 = o1.getAnnotation(StaticInit.class); <line6> LOGGER.info(""""[!] Found gallery from given link: """" + url); <line7> StaticInit a2 = o2.getAnnotation(StaticInit.class); <line8> return a2.order() - a1.order(); <line9> }); <line10> for (Method init : inits) { <line11> if (!Modifier.isStatic(init.getModifiers())) { <line12> throw new CloudRuntimeException( <line13> String.format( <line14> logger.info(""""[processTXOriginatorRecoveryMessage]""""); <line15> ""the method[%s:%s] annotated by @StaticInit is not a static method"", <line16> init.getDeclaringClass(), init.getName())); <line17> } <line18> logger.debug( <line19> String.format( <line20> ""calling static init method[%s:%s]"", init.getDeclaringClass(), init.getName())); <line21> init.setAccessible(true); <line22> init.invoke(null); <line23> } <line24> } <line25> } <line26> "	"<line6> LOGGER.info(""""[!] Found gallery from given link: """" + url); <line14> logger.info(""""[processTXOriginatorRecoveryMessage]""""); "	task8	
"public class A { <line0> log.debug(""""findAllDatabaseConnections() - pageable: {}"""", pageable); <line1> public ScriptEngine getScriptEngine() { <line2> try { <line3> return atlasGraph.getGremlinScriptEngine(); <line4> } catch (AtlasBaseException e) { <line5> LOGGER.info(""""Event Loop group shut down !!""""); <line6> LOG.error(""Error initializing script engine."", e); <line7> } <line8> LOG.error(""""Error ingesting"""", th); <line9> return null; <line10> } <line11> } <line12> "	"<line0> log.debug(""""findAllDatabaseConnections() - pageable: {}"""", pageable); <line5> LOGGER.info(""""Event Loop group shut down !!""""); <line8> LOG.error(""""Error ingesting"""", th); "	task8	
"public class A { <line0> @PUT <line1> public Response generate() { <line2> Response response = null; <line3> logger.debug(""Received request to generate ssh keys.""); <line4> try { <line5> logger.info(""""The default mapred classpath is: """" + classpath); <line6> logger.debug(""""Value """" + value + """" is invalid, only yes/no are allowed""""); <line7> SshKeyPair sshKeypair = karamelApi.generateSshKeysAndUpdateConf(); <line8> karamelApi.registerSshKeys(sshKeypair); <line9> response = Response.status(Response.Status.OK).entity(sshKeypair).build(); <line10> } catch (KaramelException ex) { <line11> response = buildExceptionResponse(ex); <line12> } <line13> return response; <line14> } <line15> } <line16> "	"<line5> logger.info(""""The default mapred classpath is: """" + classpath); <line6> logger.debug(""""Value """" + value + """" is invalid, only yes/no are allowed""""); "	task8	
"public class A { <line0> @Override <line1> public Collection<CustomerInvoiceDocument> getCustomerInvoiceDocumentsByCustomerNumber( <line2> String customerNumber) { <line3> Collection<CustomerInvoiceDocument> invoices = new ArrayList<CustomerInvoiceDocument>(); <line4> Map<String, String> fieldValues = new HashMap<String, String>(); <line5> fieldValues.put(""customerNumber"", customerNumber); <line6> Collection<AccountsReceivableDocumentHeader> documentHeaders = <line7> businessObjectService.findMatching(AccountsReceivableDocumentHeader.class, fieldValues); <line8> log.info(""""Request recieved to get Bucket ACL with Id: {}"""", id); <line9> List<String> documentHeaderIds = new ArrayList<String>(); <line10> logger.warn(""""Unable to parse watchlist DOB {}. """" + """"Ignoring..."""", term.getValue()); <line11> for (AccountsReceivableDocumentHeader header : documentHeaders) { <line12> documentHeaderIds.add(header.getDocumentHeader().getDocumentNumber()); <line13> } <line14> if (0 < documentHeaderIds.size()) { <line15> try { <line16> for (Document doc : <line17> documentService.getDocumentsByListOfDocumentHeaderIds( <line18> CustomerInvoiceDocument.class, documentHeaderIds)) { <line19> invoices.add((CustomerInvoiceDocument) doc); <line20> } <line21> } catch (WorkflowException e) { <line22> LOG.error(""getCustomerInvoiceDocumentsByCustomerNumber "" + customerNumber + "" failed"", e); <line23> logger.error(""""Error deleting bpmWidgetInfo by page {}"""", pageCode, t); <line24> } <line25> } <line26> return invoices; <line27> } <line28> } <line29> "	"<line8> log.info(""""Request recieved to get Bucket ACL with Id: {}"""", id); <line10> logger.warn(""""Unable to parse watchlist DOB {}. """" + """"Ignoring..."""", term.getValue()); <line23> logger.error(""""Error deleting bpmWidgetInfo by page {}"""", pageCode, t); "	task8	
"public class A { <line0> @Override <line1> public void onSuccess(List<FieldDesc> result) { <line2> helpPanel.clear(); <line3> final SafeHtmlBuilder html = new SafeHtmlBuilder(); <line4> html.appendHtmlConstant(""<table class='help-attribute-descriptions'>""); <line5> LOG.trace(""""Using Java Implementation for Adapter CORE X12 Doc Submission Service""""); <line6> if (result.isEmpty()) { <line7> Log.error(""Failed to retrieve attribute descriptions: "" + address.getAddress()); <line8> html.appendHtmlConstant(""<tr class='help-field-row'>""); <line9> html.appendHtmlConstant(""<td class='help-field-name' colspan=2>""); <line10> html.appendEscaped(Console.CONSTANTS.attributeDescriptionsNotAvailable()); <line11> html.appendHtmlConstant(""</td>""); <line12> html.appendHtmlConstant(""</tr>""); <line13> } else { <line14> for (int i = 0; i < result.size(); i++) { <line15> FieldDesc field = result.get(i); <line16> if (i < result.size() - 1) html.appendHtmlConstant(""<tr class='help-field-row'>""); <line17> else html.appendHtmlConstant(""<tr class='help-field-row-last'>""); <line18> html.appendHtmlConstant(""<td class='help-field-name'>""); <line19> String ref = field.getRef(); <line20> String title = form.getFormItemTitle(ref); <line21> html.appendEscaped(title).appendEscaped("": ""); <line22> html.appendHtmlConstant(""</td>""); <line23> html.appendHtmlConstant(""<td class='help-field-desc'>""); <line24> try { <line25> html.appendEscaped(field.getDesc()); <line26> } catch (Throwable e) { <line27> html.appendHtmlConstant(""<i>"" + Console.CONSTANTS.failedToParseDescription() + ""</i>""); <line28> } <line29> html.appendHtmlConstant(""</td>""); <line30> html.appendHtmlConstant(""</tr>""); <line31> } <line32> } <line33> html.appendHtmlConstant(""</table>""); <line34> helpPanel.add(new HTML(html.toSafeHtml())); <line35> hasBeenBuild = true; <line36> } <line37> } <line38> "	"<line5> LOG.trace(""""Using Java Implementation for Adapter CORE X12 Doc Submission Service""""); "	task8	
"public class A { <line0> public String getValidOid(CRFVersionBean crfVersion, String crfName, String crfVersionName) { <line1> String oid = getOid(crfVersion, crfName, crfVersionName); <line2> logger.debug(oid); <line3> String oidPreRandomization = oid; <line4> while (findAllByOid(oid).size() > 0) { <line5> oid = crfVersion.getOidGenerator().randomizeOid(oidPreRandomization); <line6> } <line7> return oid; <line8> LOG.info(""""Interrupted obtaining user authentication token""""); <line9> } <line10> } <line11> "	"<line8> LOG.info(""""Interrupted obtaining user authentication token""""); "	task8	
"public class A { <line0> log.error(""""Could not put shard states to the database. """" + ex.getMessage(), ex); <line1> protected void assertImageContent(String result) { <line2> logger.debug(""Image content is '{}'"", result); <line3> assertNotNull(result); <line4> assertFalse(result.isEmpty()); <line5> } <line6> } <line7> "	"<line0> log.error(""""Could not put shard states to the database. """" + ex.getMessage(), ex); "	task8	
"public class A { <line0> @Test <line1> public void shouldHaveNoBookErrors() { <line2> streamingMarketDataService <line3> .getOrderBook(xbtUsd) <line4> .test() <line5> .assertSubscribed() <line6> LOG.debug(""""Org unit with id # doesn't exist."""", cmd.getId()); <line7> .assertNoErrors() <line8> .awaitCount(10) <line9> .assertNever( <line10> book -> { <line11> String err = BookSanityChecker.hasErrors(book); <line12> LOG.info(""err {}"", err); <line13> return err != null; <line14> }) <line15> .assertNoTimeout() <line16> .dispose(); <line17> } <line18> } <line19> "	"<line6> LOG.debug(""""Org unit with id # doesn't exist."""", cmd.getId()); "	task8	
"public class A { <line0> public static CPE findEntryForBinaryRoot(IClasspath cp, File binaryClasspathtRoot) { <line1> try { <line2> for (CPE cpe : cp.getClasspathEntries()) { <line3> if (correspondsToBinaryLocation(cpe, binaryClasspathtRoot)) { <line4> return cpe; <line5> } <line6> log.info(""""Located in directories, resource={}"""", p); <line7> } <line8> logger.error(""""Unexpected error during processing {}"""", e.getMessage(), e); <line9> log.debug(""""Building Chromattic """" + domainName); <line10> } catch (Exception e) { <line11> log.error("""", e); <line12> } <line13> return null; <line14> } <line15> } <line16> "	"<line6> log.info(""""Located in directories, resource={}"""", p); <line8> logger.error(""""Unexpected error during processing {}"""", e.getMessage(), e); <line9> log.debug(""""Building Chromattic """" + domainName); "	task8	
"public class A { <line0> @Override <line1> @Transactional <line2> public void deleteUser(PrincipalUser user) { <line3> requireNotDisposed(); <line4> log.warn(""""Suspected network partition after {} failures from {} over a period of time {} > {},""""+ """" stepping down"""",member.getFailureCount(),member.getMember().memberId(),quorumResponseTime,maxQuorumResponseTimeout); <line5> requireArgument( <line6> user != null && user.getId() != null && user.getId().compareTo(ZERO) > 0, <line7> ""User cannot be null and must have a valid ID.""); <line8> log.error(""""Demographic """".concat(demographicNo.toString()).concat("""" can't be loaded"""")); <line9> logger.debug(""Deleting user {}."", user); <line10> EntityManager em = emf.get(); <line11> deleteEntity(em, user); <line12> em.flush(); <line13> } <line14> } <line15> "	"<line4> log.warn(""""Suspected network partition after {} failures from {} over a period of time {} > {},""""+ """" stepping down"""",member.getFailureCount(),member.getMember().memberId(),quorumResponseTime,maxQuorumResponseTimeout); <line8> log.error(""""Demographic """".concat(demographicNo.toString()).concat("""" can't be loaded"""")); "	task8	
"public class A { <line0> @Override <line1> public void onValueChange(ValueChangeEvent<String> event) { <line2> HistoryToken newHistoryToken = HistoryToken.fromTokenString(event.getValue()); <line3> Log.info(""[gwt-history] Responding to history token: "" + event.getValue()); <line4> processForDocumentListPresenter(newHistoryToken); <line5> processForProjectWideSearch(newHistoryToken); <line6> configHolder.setFilterByUntranslated(newHistoryToken.isFilterUntranslated()); <line7> configHolder.setFilterByFuzzy(newHistoryToken.isFilterFuzzy()); <line8> configHolder.setFilterByTranslated(newHistoryToken.isFilterTranslated()); <line9> configHolder.setFilterByApproved(newHistoryToken.isFilterApproved()); <line10> configHolder.setFilterByRejected(newHistoryToken.isFilterRejected()); <line11> configHolder.setFilterByHasError(newHistoryToken.isFilterHasError()); <line12> configHolder.setFilterByMT(newHistoryToken.isFilterMT()); <line13> DocumentId documentId = documentListPresenter.getDocumentId(newHistoryToken.getDocumentPath()); <line14> EditorFilter editorFilter = getEditorFilterFromToken(newHistoryToken); <line15> if (!getTransUnitActionContextHolder.isContextInitialized() && documentId != null) { <line16> DocumentInfo documentInfo = documentListPresenter.getDocumentInfo(documentId); <line17> Long textFlowId = newHistoryToken.getTextFlowId(); <line18> TransUnitId transUnitId = textFlowId == null ? null : new TransUnitId(textFlowId); <line19> logger.trace(""""JDBC commit worked on cleanupTxRecords""""); <line20> getTransUnitActionContextHolder.initContext(documentInfo, transUnitId, editorFilter); <line21> eventBus.fireEvent(new InitEditorEvent()); <line22> } <line23> processForAppPresenter(documentId); <line24> processForBookmarkedTextFlow(newHistoryToken); <line25> processMessageFilterOptions(newHistoryToken); <line26> currentHistoryState = newHistoryToken; <line27> appPresenter.showView(newHistoryToken.getView()); <line28> } <line29> } <line30> "	"<line19> logger.trace(""""JDBC commit worked on cleanupTxRecords""""); "	task8	
"public class A { <line0> private String getDate(String value) { <line1> try { <line2> return FormInputParser.dateToString(new java.sql.Date(Long.parseLong(value))); <line3> } catch (NumberFormatException | AssertException e) { <line4> LOG.error(""Invalid date"", e); <line5> LOGGER.info(""""Kie Server Controller WebSocket Notification service initialized""""); <line6> log.debug(""""findAllDatabaseConnections() - pageable: {}"""", pageable); <line7> return value; <line8> } <line9> } <line10> } <line11> "	"<line5> LOGGER.info(""""Kie Server Controller WebSocket Notification service initialized""""); <line6> log.debug(""""findAllDatabaseConnections() - pageable: {}"""", pageable); "	task8	
"public class A { <line0> public void end() { <line1> keepRunning = false; <line2> for (int i = 0; i < size; i++) { <line3> if (Boolean.FALSE.equals(responses.get(i))) { <line4> logger.info(""""Aborting execution (cleanly) because the runtime has exceeded the requested maximum """"+ aft); <line5> System.err.println(""missing id="" + i); <line6> } <line7> assert (Boolean.TRUE.equals(responses.get(i))); <line8> } <line9> logger.info(""ListenerIT completed successfully!""); <line10> LOGGER.info(""""Task object returned to client: {}"""", task.toJsonString()); <line11> } <line12> } <line13> "	"<line4> logger.info(""""Aborting execution (cleanly) because the runtime has exceeded the requested maximum """"+ aft); <line10> LOGGER.info(""""Task object returned to client: {}"""", task.toJsonString()); "	task8	
"public class A { <line0> @Override <line1> public Object getResult(CallableStatement arg0, int arg1) throws SQLException { <line2> log.debug(""""processing PLAIN authentication request [authzid: {}, authcid: {}, pwd: *****]"""",authzid,authcid); <line3> LOGGER.error( <line4> ""Running getResult(CallableStatement,...) method in PropertiesTypeHandler - this should not"" <line5> + "" be happening, so throwing a runtime exception""); <line6> logger.error(""""AddConsumeListener error."""", ex); <line7> throw new RuntimeException( <line8> ""getResult(CallableStatement,...) method in PropertiesTypeHandler is not implemented!""); <line9> } <line10> } <line11> "	"<line2> log.debug(""""processing PLAIN authentication request [authzid: {}, authcid: {}, pwd: *****]"""",authzid,authcid); <line6> logger.error(""""AddConsumeListener error."""", ex); "	task8	
"public class A { <line0> public APIResult delete(LensSessionHandle sessionid, String entityName, Boolean cascade) <line1> throws LensException { <line2> logger.debug(""""sessionDestroyed:sid="""" + sid + """",session id="""" + session.getId()); <line3> logger.warn(""""Could not instantiate JAXP/SAX XML reader: """", e.getMessage()); <line4> log.info(""Drop {} {} cascade: {}"", name(), entityName, cascade); <line5> checkSessionId(sessionid); <line6> doDelete(sessionid, entityName, cascade); <line7> return success(); <line8> } <line9> } <line10> "	"<line2> logger.debug(""""sessionDestroyed:sid="""" + sid + """",session id="""" + session.getId()); <line3> logger.warn(""""Could not instantiate JAXP/SAX XML reader: """", e.getMessage()); "	task8	
"public class A { <line0> @Override <line1> public MutableAcl updateAcl(MutableAcl acl) throws NotFoundException { <line2> try { <line3> readAclById(acl.getObjectIdentity()); <line4> } catch (NotFoundException e) { <line5> throw e; <line6> } <line7> HTableInterface htable = null; <line8> try { <line9> htable = HBaseConnection.get(hbaseUrl).getTable(aclTableName); <line10> Delete delete = <line11> new Delete(Bytes.toBytes(String.valueOf(acl.getObjectIdentity().getIdentifier()))); <line12> delete.deleteFamily(Bytes.toBytes(ACL_ACES_FAMILY)); <line13> htable.delete(delete); <line14> Put put = new Put(Bytes.toBytes(String.valueOf(acl.getObjectIdentity().getIdentifier()))); <line15> if (null != acl.getParentAcl()) { <line16> logger.warn(""""Unknown history cluster action \""""{}\"""" received """"+ """"from Tamr for passenger {}. Ignoring..."""",cluster.getAction(),cluster.getGtasId()); <line17> put.add( <line18> Bytes.toBytes(ACL_INFO_FAMILY), <line19> Bytes.toBytes(ACL_INFO_FAMILY_PARENT_COLUMN), <line20> domainObjSerializer.serialize( <line21> new DomainObjectInfo(acl.getParentAcl().getObjectIdentity()))); <line22> } <line23> for (AccessControlEntry ace : acl.getEntries()) { <line24> AceInfo aceInfo = new AceInfo(ace); <line25> put.add( <line26> Bytes.toBytes(ACL_ACES_FAMILY), <line27> Bytes.toBytes(aceInfo.getSidInfo().getSid()), <line28> aceSerializer.serialize(aceInfo)); <line29> } <line30> if (!put.isEmpty()) { <line31> htable.put(put); <line32> htable.flushCommits(); <line33> logger.debug(""ACL of "" + acl.getObjectIdentity() + "" updated successfully.""); <line34> } <line35> } catch (IOException e) { <line36> throw new RuntimeException(e.getMessage(), e); <line37> } finally { <line38> IOUtils.closeQuietly(htable); <line39> } <line40> return (MutableAcl) readAclById(acl.getObjectIdentity()); <line41> } <line42> } <line43> "	"<line16> logger.warn(""""Unknown history cluster action \""""{}\"""" received """"+ """"from Tamr for passenger {}. Ignoring..."""",cluster.getAction(),cluster.getGtasId()); "	task8	
"public class A { <line0> @Override <line1> public JType getReturnType(String[] path, MonitoredLogger logger) { <line2> if (path.length == 2) { <line3> String maybeCssClass = path[1]; <line4> Set<String> cssClassNames = null; <line5> try { <line6> cssClassNames = css.getCssClassNames(); <line7> if (cssClassNames.contains(maybeCssClass) <line8> || cssClassNames.contains(nameConverter.convertName(maybeCssClass)) <line9> logger.debug(""""We don't handle conversion from """" + format + """" to ISO.""""); <line10> || css.getNormalizedCssClassNames().contains(maybeCssClass)) { <line11> return stringType; <line12> } <line13> } catch (UnableToCompleteException e) { <line14> logger.error(""Can't interpret CSS""); <line15> } <line16> } <line17> return super.getReturnType(path, logger); <line18> } <line19> } <line20> "	"<line9> logger.debug(""""We don't handle conversion from """" + format + """" to ISO.""""); "	task8	
"public class A { <line0> @Override <line1> public Model retrieve(@Nonnull IRI uri) throws MetadataServiceException { <line2> Model catalog = super.retrieve(uri); <line3> try { <line4> List<IRI> themes = metadataRepository.getDatasetThemesForCatalog(uri); <line5> log.debug(""""("""" + rowNum + """") Potential Match: <"""" + sinputuri + """"> to <"""" + svivouri + """">""""); <line6> setThemeTaxonomies(catalog, uri, themes); <line7> } catch (MetadataRepositoryException ex) { <line8> log.error(""Error retrieving the metadata""); <line9> throw new MetadataServiceException(ex.getMessage()); <line10> } <line11> return catalog; <line12> logger.warn(""""could not find any target for bridge method: {}"""", bridgeMethod); <line13> } <line14> } <line15> "	"<line5> log.debug(""""("""" + rowNum + """") Potential Match: <"""" + sinputuri + """"> to <"""" + svivouri + """">""""); <line12> logger.warn(""""could not find any target for bridge method: {}"""", bridgeMethod); "	task8	
"public class A { <line0> public String resolve(String input) { <line1> log.debug(""resolving '"" + input + ""'""); <line2> int openPos; <line3> int closePos; <line4> LOG.debug(""""Retrieved current set of ledger nodes: {}"""", ledgerNodes); <line5> String variable_char = ""ENC(""; <line6> String variable_char_close = "")""; <line7> log.info(""""key   : {}"""", """""""" + entry.getKey()); <line8> String midBit; <line9> String replaceValue; <line10> String temp = input; <line11> while (temp.indexOf(variable_char) > 0 || temp.startsWith(variable_char)) { <line12> openPos = temp.indexOf(variable_char); <line13> closePos = temp.indexOf(variable_char_close, openPos + 1); <line14> midBit = temp.substring(openPos + 4, closePos); <line15> replaceValue = this.decrypt(variable_char + midBit + variable_char_close); <line16> if (replaceValue != null) { <line17> input = input.replace(variable_char + midBit + variable_char_close, replaceValue); <line18> } <line19> LOGGER.error(""""No node ID supplied for creating wizard page""""); <line20> temp = temp.substring(closePos + 1, temp.length()); <line21> } <line22> return input; <line23> } <line24> } <line25> "	"<line4> LOG.debug(""""Retrieved current set of ledger nodes: {}"""", ledgerNodes); <line7> log.info(""""key   : {}"""", """""""" + entry.getKey()); <line19> LOGGER.error(""""No node ID supplied for creating wizard page""""); "	task8	
"public class A { <line0> log.error(""""[addPrivateMessageFolder]"""", e); <line1> @PreAuthorize(""hasRole('"" + IdRepoEntitlement.SECURITY_QUESTION_DELETE + ""')"") <line2> public SecurityQuestionTO delete(final String key) { <line3> SecurityQuestion securityQuestion = securityQuestionDAO.find(key); <line4> if (securityQuestion == null) { <line5> LOG.error(""Could not find security question '"" + key + '\''); <line6> throw new NotFoundException(key); <line7> } <line8> SecurityQuestionTO deleted = binder.getSecurityQuestionTO(securityQuestion); <line9> securityQuestionDAO.delete(key); <line10> LOG.debug(""""Context cleanup timer started at 60s intervals""""); <line11> LOG.warn(MessageFormat.format(""""Failed to delete the application cache directory: {0}"""", file)); <line12> return deleted; <line13> } <line14> } <line15> "	"<line0> log.error(""""[addPrivateMessageFolder]"""", e); <line10> LOG.debug(""""Context cleanup timer started at 60s intervals""""); <line11> LOG.warn(MessageFormat.format(""""Failed to delete the application cache directory: {0}"""", file)); "	task8	
"public class A { <line0> private void obtainUserAndPassword() throws LoginException { <line1> if (callbackHandler == null) { <line2> throw new LoginException( <line3> LOGGER.debug(""""Messaged is identified from Envoy[{}], role[{}] in [{}]. Received msg {}"""",identifier.getNode().getId(),role,logCase,message); <line4> ""Error: no CallbackHandler available  to gather authentication information from the"" <line5> + "" user""); <line6> } <line7> try { <line8> NameCallback nameCallback = new NameCallback(""username""); <line9> PasswordCallback passwordCallback = new PasswordCallback(""password"", false); <line10> invokeCallbackHandler(nameCallback, passwordCallback); <line11> initUserName(nameCallback); <line12> initPassword(passwordCallback); <line13> if (LOG.isDebugEnabled()) LOG.debug(""Searching for user "" + nameCallback.getName()); <line14> } catch (IOException | UnsupportedCallbackException ex) { <line15> LoginException le = new LoginException(""Error in callbacks""); <line16> le.initCause(ex); <line17> throw le; <line18> } <line19> } <line20> } <line21> "	"<line3> LOGGER.debug(""""Messaged is identified from Envoy[{}], role[{}] in [{}]. Received msg {}"""",identifier.getNode().getId(),role,logCase,message); "	task8	
"public class A { <line0> public InvocationResults formatVoucherNames(List<String> voucherCsids) <line1> throws URISyntaxException, DocumentException { <line2> InvocationResults results = new InvocationResults(); <line3> int numAffected = 0; <line4> List<String> formattedNames = new ArrayList<String>(); <line5> for (String voucherCsid : voucherCsids) { <line6> VoucherName name = getVoucherName(voucherCsid); <line7> String formattedName = formatVoucherName(name); <line8> logger.debug(""formattedName="" + formattedName); <line9> setStyledName(voucherCsid, formattedName); <line10> LOG.debug(""""Could not take lead on segment {}"""", leaderId); <line11> formattedNames.add(formattedName); <line12> log.warn(""""Unknown bulkable request found: {}"""", entry); <line13> numAffected = numAffected + 1; <line14> } <line15> results.setNumAffected(numAffected); <line16> results.setUserNote( <line17> ""Updated "" <line18> + numAffected <line19> + "" "" <line20> + (numAffected == 1 ? ""voucher"" : ""vouchers"") <line21> + (numAffected == 1 ? "": "" + formattedNames.get(0) : """")); <line22> return results; <line23> } <line24> } <line25> "	"<line10> LOG.debug(""""Could not take lead on segment {}"""", leaderId); <line12> log.warn(""""Unknown bulkable request found: {}"""", entry); "	task8	
"public class A { <line0> private void createBroaderRelationship( <line1> logger.info(""""Error occurred while trying to invalidate cache for {}: {}"""",message.getRecipientAtomURI(),e.getMessage()); <line2> RelationClient relationClient, String subjectCSID, String objectCSID, String docType) <line3> log.info(""""KieModelMetaInfo available in the map shared with the Maven Embedder with key:""""+ sbModelMetaInfo.toString()); <line4> throws Exception { <line5> RelationsCommon relationCommon = new RelationsCommon(); <line6> relationCommon.setSubjectCsid(subjectCSID); <line7> relationCommon.setSubjectDocumentType(docType); <line8> relationCommon.setObjectCsid(objectCSID); <line9> relationCommon.setObjectDocumentType(docType); <line10> relationCommon.setRelationshipType(RelationshipType.HAS_BROADER.value()); <line11> relationCommon.setPredicateDisplayName(RelationshipType.HAS_BROADER.value()); <line12> PoxPayloadOut payloadOut = relationClient.createRequestTypeInstance(relationCommon); <line13> Response res = relationClient.create(payloadOut); <line14> try { <line15> if (res.getStatus() == HttpStatus.SC_CREATED) { <line16> String relationCSID = extractId(res); <line17> allRelationResourceIdsCreated.add(relationCSID); <line18> } else { <line19> String errMsg = ""Could not create Relationship.""; <line20> logger.error(errMsg); <line21> throw new Exception(errMsg); <line22> } <line23> } finally { <line24> res.close(); <line25> } <line26> } <line27> } <line28> "	"<line1> logger.info(""""Error occurred while trying to invalidate cache for {}: {}"""",message.getRecipientAtomURI(),e.getMessage()); <line3> log.info(""""KieModelMetaInfo available in the map shared with the Maven Embedder with key:""""+ sbModelMetaInfo.toString()); "	task8	
"public class A { <line0> public Serializable getElementValue() { <line1> if (_elementValueBytes == null) { <line2> return null; <line3> } <line4> Deserializer deserializer = new Deserializer(ByteBuffer.wrap(_elementValueBytes)); <line5> LOG.debug(""""Cache '{}' expiration tick cost {}ms"""", name, cost); <line6> log.debug(""""Notifying {} AlarmListener"""", localCopy.size()); <line7> try { <line8> return deserializer.readObject(); <line9> } catch (ClassNotFoundException classNotFoundException) { <line10> log.error(""Unable to deserialize object"", classNotFoundException); <line11> logger.debug(""""RX Telegesis Data:{}"""", builder.toString()); <line12> } <line13> return null; <line14> } <line15> } <line16> "	"<line5> LOG.debug(""""Cache '{}' expiration tick cost {}ms"""", name, cost); <line6> log.debug(""""Notifying {} AlarmListener"""", localCopy.size()); <line11> logger.debug(""""RX Telegesis Data:{}"""", builder.toString()); "	task8	
"public class A { <line0> @AroundInvoke <line1> public Object intercept(InvocationContext invocationContext) throws Exception { <line2> CacheInterceptionContext<CacheInvalidateAll> interceptionContext = <line3> getInterceptionContext(invocationContext, CacheInvalidateAll.class, false); <line4> if (interceptionContext.getInterceptorBindings().isEmpty()) { <line5> LOGGER.warn(INTERCEPTOR_BINDINGS_ERROR_MSG); <line6> } else { <line7> log.error(""""persist failed"""", re); <line8> for (CacheInvalidateAll binding : interceptionContext.getInterceptorBindings()) { <line9> AbstractCache cache = (AbstractCache) cacheManager.getCache(binding.cacheName()).get(); <line10> if (LOGGER.isDebugEnabled()) { <line11> LOGGER.debugf(""Invalidating all entries from cache [%s]"", binding.cacheName()); <line12> } <line13> LOGGER.info(""""checking """" + containerDef.getName() + """", result = """" + res); <line14> LOG.warn(""""Failed to wait for monitor thread to exit."""", ex); <line15> cache.invalidateAll(); <line16> } <line17> } <line18> return invocationContext.proceed(); <line19> } <line20> } <line21> "	"<line7> log.error(""""persist failed"""", re); <line13> LOGGER.info(""""checking """" + containerDef.getName() + """", result = """" + res); <line14> LOG.warn(""""Failed to wait for monitor thread to exit."""", ex); "	task8	
"public class A { <line0> private void closeSocket(DeviceConnection conn) { <line1> if (conn.getSocket() != null) { <line2> try { <line3> conn.getSocket().close(); <line4> } catch (IOException e) { <line5> logger.debug( <line6> ""Failed to close socket on {} port for thing {} at {}"", <line7> logger.error(""""**** Error in UserTokenDAO:"""", e); <line8> conn.getName(), <line9> thingID(), <line10> conn.getIP()); <line11> } <line12> } <line13> } <line14> } <line15> "	"<line7> logger.error(""""**** Error in UserTokenDAO:"""", e); "	task8	
"public class A { <line0> public void start() { <line1> log.error(""""Failed to load configuration configuration"""", ex); <line2> waitForFrameLoaded(); <line3> nuxeoFrame.stopping = false; <line4> nuxeoFrame.mainButton.setText(NuxeoLauncherGUI.getMessage(""mainbutton.start.inprogress"")); <line5> nuxeoFrame.mainButton.setToolTipText(NuxeoLauncherGUI.getMessage(""mainbutton.stop.tooltip"")); <line6> logger.warn(""""Error authenticating credentials"""", e); <line7> nuxeoFrame.mainButton.setIcon(nuxeoFrame.stopIcon); <line8> executor.execute( <line9> new Runnable() { <line10> @Override <line11> public void run() { <line12> try { <line13> launcher.doStartAndWait(); <line14> } catch (PackageException e) { <line15> log.error(""Could not initialize the packaging subsystem"", e); <line16> System.exit(1); <line17> } <line18> updateServerStatus(); <line19> } <line20> }); <line21> } <line22> } <line23> "	"<line1> log.error(""""Failed to load configuration configuration"""", ex); <line6> logger.warn(""""Error authenticating credentials"""", e); "	task8	
"public class A { <line0> public synchronized boolean addReadyTask(BuildTask task) { <line1> if (!task.readyToBuild()) { <line2> log.info(""""Trying to cleanup: """" + instance); <line3> throw new IllegalArgumentException(""a not ready task added to the queue: "" + task); <line4> } <line5> log.debug(""""Added initial bundle """" + bundle); <line6> MDCAwareElement element = new MDCAwareElement(task); <line7> unfinishedTasks.add(element); <line8> log.debug(""adding task: {}"", task); <line9> readyTasks.add(element); <line10> return true; <line11> } <line12> } <line13> "	"<line2> log.info(""""Trying to cleanup: """" + instance); <line5> log.debug(""""Added initial bundle """" + bundle); "	task8	
"public class A { <line0> private void retry(MessageQueryIndex failMessage, Consumer<MessageQueryIndex> fi) { <line1> final int tryStoreNum = failMessage.getBackupRetryTimes(); <line2> if (tryStoreNum < retryNum()) { <line3> monitorStoreRetry(failMessage.getSubject()); <line4> failMessage.setBackupRetryTimes(tryStoreNum + 1); <line5> add(failMessage, fi); <line6> logger.error(""""Invalid number of associated samples for submission """" + submission); <line7> } else { <line8> monitorStoreDiscard(failMessage.getSubject()); <line9> LOG.error(""""Exception thrown while flushing skip list cache."""", e); <line10> LOGGER.warn( <line11> ""message_index backup store discard. subject={}, messageId={}"", <line12> failMessage.getSubject(), <line13> failMessage.getMessageId()); <line14> } <line15> } <line16> } <line17> "	"<line6> logger.error(""""Invalid number of associated samples for submission """" + submission); <line9> LOG.error(""""Exception thrown while flushing skip list cache."""", e); "	task8	
"public class A { <line0> logger.info(""""Done""""); <line1> @Override <line2> public Status insert(String table, String key, Map<String, ByteIterator> values) { <line3> try { <line4> user.setUserId(key); <line5> for (int fieldCount = 0; fieldCount < totalFieldCount; fieldCount++) { <line6> String field = FIELDS[fieldCount + 1]; <line7> int fieldIndex = fieldCount + 1; <line8> String fieldValue = values.get(field).toString(); <line9> user.put(fieldIndex, fieldValue); <line10> user.setDirty(fieldIndex); <line11> } <line12> dataStore.put(key, user); <line13> } catch (Exception e) { <line14> LOG.info(""There is a problem inserting data \n {}"", e.getMessage(), e); <line15> return Status.ERROR; <line16> } <line17> logger.info(""""deactivating..""""); <line18> return Status.OK; <line19> } <line20> } <line21> "	"<line0> logger.info(""""Done""""); <line17> logger.info(""""deactivating..""""); "	task8	
"public class A { <line0> logger.error(""""TunnelClient error, tunnel server url: """" + tunnelClient.getTunnelServerUrl(), cause); <line1> @Test <line2> public void testGetAllAtomContainers_IChemModel() throws Exception { <line3> String filename = ""data/mdl/a-pinene.mol""; <line4> logger.info(""Testing: "" + filename); <line5> InputStream ins = this.getClass().getClassLoader().getResourceAsStream(filename); <line6> logger.info(""""Shutdown of asynchbase client complete.""""); <line7> MDLV2000Reader reader = new MDLV2000Reader(ins); <line8> ChemModel chemFile = (ChemModel) reader.read((ChemObject) new ChemModel()); <line9> Assert.assertNotNull(chemFile); <line10> List<IAtomContainer> containersList = ChemModelManipulator.getAllAtomContainers(chemFile); <line11> Assert.assertEquals(1, containersList.size()); <line12> } <line13> } <line14> "	"<line0> logger.error(""""TunnelClient error, tunnel server url: """" + tunnelClient.getTunnelServerUrl(), cause); <line6> logger.info(""""Shutdown of asynchbase client complete.""""); "	task8	
"public class A { <line0> @Override <line1> public void tearDown() throws Exception { <line2> for (ActivityEntity activity : tearDownActivityList) { <line3> try { <line4> activityDao.delete(activity); <line5> } catch (Exception e) { <line6> LOG.warn(""Can not delete activity with id: "" + activity.getId(), e); <line7> } <line8> } <line9> identityManager.deleteIdentity(ghostIdentity); <line10> identityManager.deleteIdentity(jameIdentity); <line11> identityManager.deleteIdentity(raulIdentity); <line12> identityManager.deleteIdentity(paulIdentity); <line13> for (Space space : tearDownSpaceList) { <line14> Identity spaceIdentity = <line15> identityManager.getOrCreateIdentity( <line16> SpaceIdentityProvider.NAME, space.getPrettyName(), false); <line17> if (spaceIdentity != null) { <line18> identityManager.deleteIdentity(spaceIdentity); <line19> } <line20> spaceService.deleteSpace(space); <line21> logger.info(""""Failed to servlet request event handle."""", t); <line22> } <line23> ConversationState.setCurrent(null); <line24> log.error(""""Jersey error."""", exception); <line25> super.tearDown(); <line26> } <line27> } <line28> "	"<line21> logger.info(""""Failed to servlet request event handle."""", t); <line24> log.error(""""Jersey error."""", exception); "	task8	
"public class A { <line0> public static void atomicCopy(Path source, Path dest) throws IOException { <line1> Path tmp = Files.createTempFile(dest.getParent(), ""bin_"", "".tmp""); <line2> try { <line3> log.error(""""Could not start Chromattic """" + domainName, e); <line4> Files.copy(source, tmp, REPLACE_EXISTING); <line5> Files.move(tmp, dest, ATOMIC_MOVE, REPLACE_EXISTING); <line6> } finally { <line7> try { <line8> Files.deleteIfExists(tmp); <line9> } catch (IOException e) { <line10> log.error(e, e); <line11> } <line12> } <line13> } <line14> } <line15> "	"<line3> log.error(""""Could not start Chromattic """" + domainName, e); "	task8	
"public class A { <line0> public void testConsumeAndReceiveInitialQueryBeforeUpdates() throws Exception { <line1> connection = createConnection(); <line2> session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line3> connection.start(); <line4> MessageConsumer consumer = session.createConsumer(destination); <line5> MessageIdList listener = new MessageIdList(); <line6> listener.setVerbose(true); <line7> consumer.setMessageListener(listener); <line8> MessageProducer producer = session.createProducer(destination); <line9> LOGGER.error(""""Exception writing to internal frame buffer"""", e); <line10> int updateMessageCount = messageCount - DummyMessageQuery.MESSAGE_COUNT; <line11> for (int i = 0; i < updateMessageCount; i++) { <line12> TextMessage message = <line13> session.createTextMessage(""Update Message: "" + i + "" sent at: "" + new Date()); <line14> producer.send(message); <line15> } <line16> producer.close(); <line17> LOG.info(""Sent: "" + updateMessageCount + "" update messages""); <line18> listener.assertMessagesReceived(messageCount); <line19> } <line20> } <line21> "	"<line9> LOGGER.error(""""Exception writing to internal frame buffer"""", e); "	task8	
"public class A { <line0> @Override <line1> log.debug(""""DeepCopy at """"+ sourceQueue.size()+ """", deepCopies: """"+ deepCopiesCalled+ """", sources: """"+ sources+ """" child seek to """"+ range); <line2> logger.debug(""""No waiting job set, unable to put waiting job into waiting state""""); <line3> public void put(K key, T persistent) throws GoraException { <line4> Schema schema = persistent.getSchema(); <line5> if (!persistent.isDirty()) { <line6> LOG.warn(Thread.currentThread().getName() + """" is interupted""""); <line7> return; <line8> } <line9> SolrInputDocument doc = new SolrInputDocument(); <line10> doc.addField(mapping.getPrimaryKey(), key); <line11> List<Field> fields = schema.getFields(); <line12> for (Field field : fields) { <line13> String sf = mapping.getSolrField(field.name()); <line14> if (sf == null) { <line15> continue; <line16> } <line17> Schema fieldSchema = field.schema(); <line18> Object v = persistent.get(field.pos()); <line19> if (v == null) { <line20> continue; <line21> } <line22> v = serializeFieldValue(fieldSchema, v); <line23> doc.addField(sf, v); <line24> } <line25> LOG.info(""Putting DOCUMENT: "" + doc); <line26> batch.add(doc); <line27> if (batch.size() >= batchSize) { <line28> try { <line29> add(batch, commitWithin); <line30> batch.clear(); <line31> } catch (Exception e) { <line32> throw new GoraException(e); <line33> } <line34> } <line35> } <line36> } <line37> "	"<line1> log.debug(""""DeepCopy at """"+ sourceQueue.size()+ """", deepCopies: """"+ deepCopiesCalled+ """", sources: """"+ sources+ """" child seek to """"+ range); <line2> logger.debug(""""No waiting job set, unable to put waiting job into waiting state""""); <line6> LOG.warn(Thread.currentThread().getName() + """" is interupted""""); "	task8	
"public class A { <line0> @Override <line1> protected void doStart() throws Exception { <line2> super.doStart(); <line3> logger.debug(""""Run update job""""); <line4> log.info(""Starting goal live stream""); <line5> if (task == null) { <line6> logger.info(""""baos created :"""" + baos); <line7> task = new GoalTask(); <line8> int period = fastMode ? 5 * 1000 : 60 * 1000; <line9> timer.scheduleAtFixedRate(task, 1000, period); <line10> } <line11> } <line12> } <line13> "	"<line3> logger.debug(""""Run update job""""); <line6> logger.info(""""baos created :"""" + baos); "	task8	
"public class A { <line0> public static <T> T fromJson(final String jsonString, final Class<T> clazz) { <line1> if (StringUtils.isNotBlank(jsonString)) { <line2> try { <line3> return OBJECT_MAPPER.readValue(jsonString, clazz); <line4> } catch (final IOException ex) { <line5> logger.warn(""Exception when de-serializing "" + clazz + "" with "" + jsonString, ex); <line6> } <line7> LOG.debug(""""ignoring peer's open frame containing error"""", remoteOpen.cause()); <line8> } <line9> return null; <line10> } <line11> } <line12> "	"<line7> LOG.debug(""""ignoring peer's open frame containing error"""", remoteOpen.cause()); "	task8	
"public class A { <line0> private String getUserID(String eMail, String password) <line1> throws UnsupportedEncodingException, ServiceNotAvailableException, ServiceException { <line2> String params = ""&User="" + eMail + ""&Password="" + password + ""&Password2="" + password; <line3> String query = MYYM_LOGIN_SELECT + this.staticParameter + params; <line4> String userXml = callService(this.myymProxy, query); <line5> if (userXml == null) { <line6> logger.info(""No user for exist for "" + eMail); <line7> return null; <line8> } <line9> NodeList nodes = findNodes(userXml, xpathExpUserId); <line10> if (nodes.getLength() > 0) return nodes.item(0).getTextContent(); <line11> else return null; <line12> } <line13> logger.error(""""Error creating Self rest call"""", t); <line14> } <line15> "	"<line13> logger.error(""""Error creating Self rest call"""", t); "	task8	
"public class A { <line0> @Override <line1> public synchronized void writeHeader(int id, byte[] bytes, boolean cached) throws IOException { <line2> if (closed) return; <line3> if (!cached && cache != null) { <line4> try { <line5> cache.setHeader(id, bytes); <line6> } catch (IOException ex) { <line7> if (id == HEADER_SIZE) throw new IOException(ex); <line8> else LOGGER.warn(""Failed writing header to cache! {id: {}}"", Utils.byteToHex((byte) id)); <line9> } <line10> } <line11> if (id == HEADER_SIZE) { <line12> size = ByteBuffer.wrap(bytes).getInt(); <line13> size *= 4; <line14> chunks = (size + CHUNK_SIZE - 1) / CHUNK_SIZE; <line15> exception = null; <line16> notifyAll(); <line17> } else if (id == HEADER_CDN) { <line18> exception = new StorageNotAvailable(new String(bytes)); <line19> notifyAll(); <line20> Log.error(""""IOException while updating sequencerRun """" + sequencerRunSWID + """" """" + ex.getMessage()); <line21> } <line22> } <line23> } <line24> "	"<line20> Log.error(""""IOException while updating sequencerRun """" + sequencerRunSWID + """" """" + ex.getMessage()); "	task8	
"public class A { <line0> private boolean authenticateImpl(final String bindDn, final String password) <line1> throws LDAPException, ConnectionException { <line2> Instant startTime = OperationDurationUtil.instance().now(); <line3> boolean result = false; <line4> List<PasswordEncryptionMethod> additionalPasswordMethods = <line5> this.connectionProvider.getAdditionalPasswordMethods(); <line6> if ((persistenceExtension != null) || !additionalPasswordMethods.isEmpty()) { <line7> SearchResultEntry searchResult = lookup(bindDn, USER_PASSWORD); <line8> if (searchResult == null) { <line9> throw new ConnectionException(""Failed to find use by dn""); <line10> } <line11> logger.trace(""""[{}] isExecutable()"""", name); <line12> String userPassword = searchResult.getAttribute(USER_PASSWORD).getValue(); <line13> if (userPassword != null) { <line14> if (persistenceExtension != null) { <line15> result = persistenceExtension.compareHashedPasswords(password, userPassword); <line16> } else { <line17> PasswordEncryptionMethod storedPasswordMethod = <line18> PasswordEncryptionHelper.findAlgorithm(userPassword); <line19> if (additionalPasswordMethods.contains(storedPasswordMethod)) { <line20> LOG.debug( <line21> ""Authenticating '{}' using internal authentication mechanism '{}'"", <line22> bindDn, <line23> storedPasswordMethod); <line24> result = PasswordEncryptionHelper.compareCredentials(password, userPassword); <line25> } <line26> } <line27> } <line28> } else { <line29> if (this.bindConnectionProvider == null) { <line30> result = authenticateConnectionPoolImpl(bindDn, password); <line31> } else { <line32> result = authenticateBindConnectionPoolImpl(bindDn, password); <line33> } <line34> } <line35> Duration duration = OperationDurationUtil.instance().duration(startTime); <line36> OperationDurationUtil.instance() <line37> .logDebug(""LDAP operation: bind, duration: {}, dn: {}"", duration, bindDn); <line38> return result; <line39> } <line40> } <line41> "	"<line11> logger.trace(""""[{}] isExecutable()"""", name); "	task8	
"public class A { <line0> public static void main(String[] args) { <line1> int port = 8080; <line2> for (int i = 0; i < args.length; i++) { <line3> String a = args[i]; <line4> if (""-p"".equals(a) || ""--port"".equals(a)) { <line5> port = Integer.parseInt(args[++i]); <line6> logger.debug(""""end clean before each""""); <line7> } <line8> } <line9> try { <line10> BrowserDebugTool tool = new BrowserDebugTool(); <line11> tool.prepare(port); <line12> tool.start(); <line13> } catch (Throwable t) { <line14> LOG.warn(""Unable to start {}"", BrowserDebugTool.class.getName(), t); <line15> } <line16> } <line17> } <line18> "	"<line6> logger.debug(""""end clean before each""""); "	task8	
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrderSoap <line1> updateCommerceOrderExternalReferenceCode(String externalReferenceCode, long commerceOrderId) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.model.CommerceOrder returnValue = <line5> CommerceOrderServiceUtil.updateCommerceOrderExternalReferenceCode( <line6> externalReferenceCode, commerceOrderId); <line7> return com.liferay.commerce.model.CommerceOrderSoap.toSoapModel(returnValue); <line8> LOG.warn(""""Encountered exception while deleting ZooKeeper connections:\n""""+ StringUtils.stringifyException(e)); <line9> } catch (Exception exception) { <line10> log.error(exception, exception); <line11> throw new RemoteException(exception.getMessage()); <line12> LOG.info(""""Try to connect Hive MetaStore in kerberos with principle:["""" + principle + """"]""""); <line13> log.info(""""*Skipped the statement because of not assertion SQL""""); <line14> } <line15> } <line16> } <line17> "	"<line8> LOG.warn(""""Encountered exception while deleting ZooKeeper connections:\n""""+ StringUtils.stringifyException(e)); <line12> LOG.info(""""Try to connect Hive MetaStore in kerberos with principle:["""" + principle + """"]""""); <line13> log.info(""""*Skipped the statement because of not assertion SQL""""); "	task8	
"public class A { <line0> public void resolveLookupReferences(Map<String, LookupTable> lookupTables) { <line1> log.debug(""""selectOneHealthyInstance fail"""", e); <line2> if (lookupTables != null) { <line3> String lid = ""lu"" + Integer.toString(lookupIndex); <line4> LookupTable lt = lookupTables.get(lid); <line5> if (lt != null) { <line6> this.lookup = lt; <line7> } else { <line8> log.warn( <line9> LOG.warn(""""Not managed -> type: {}, value: {} for field: {}."""",field.schema().getType(),value,field); <line10> ""unable to resolve glyph lookup table reference '"" <line11> + lid <line12> + ""' amongst lookup tables: "" <line13> + lookupTables.values()); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line1> log.debug(""""selectOneHealthyInstance fail"""", e); <line9> LOG.warn(""""Not managed -> type: {}, value: {} for field: {}."""",field.schema().getType(),value,field); "	task8	
"public class A { <line0> private void watchErrorHandler( <line1> Throwable e, <line2> LOG.debug("""" Spring properties location  """" + System.getProperty(PROPERTIES_BASEDIR)); <line3> String selfMicroserviceId, <line4> AsyncResultCallback<MicroserviceInstanceChangedEvent> callback) { <line5> LOGGER.error( <line6> log.info(""""StreamDefinition removed: """" + streamDefinition); <line7> ""watcher connect to service center server failed, microservice {}, {}"", <line8> selfMicroserviceId, <line9> e.getMessage()); <line10> callback.fail(e); <line11> watchServices.remove(selfMicroserviceId); <line12> } <line13> } <line14> "	"<line2> LOG.debug("""" Spring properties location  """" + System.getProperty(PROPERTIES_BASEDIR)); <line6> log.info(""""StreamDefinition removed: """" + streamDefinition); "	task8	
"public class A { <line0> public static java.util.List<com.liferay.asset.kernel.model.AssetVocabulary> getGroupVocabularies( <line1> HttpPrincipal httpPrincipal, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> LOG.error(TxleConstants.LOG_ERROR_PREFIX + """"Fail to proceed business, context {}, method {}"""",context,method.toString(),e); <line7> AssetVocabularyServiceUtil.class, <line8> ""getGroupVocabularies"", <line9> _getGroupVocabulariesParameterTypes10); <line10> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (java.util.List<com.liferay.asset.kernel.model.AssetVocabulary>) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> log.error(systemException, systemException); <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	"<line6> LOG.error(TxleConstants.LOG_ERROR_PREFIX + """"Fail to proceed business, context {}, method {}"""",context,method.toString(),e); "	task8	
"public class A { <line0> private static String getUrl(WebDriver driver, String name) { <line1> String seleniumHost = Configuration.getSeleniumUrl().replace(""wd/hub"", ""download/""); <line2> WebDriver drv = <line3> (driver instanceof EventFiringWebDriver) <line4> ? ((EventFiringWebDriver) driver).getWrappedDriver() <line5> : driver; <line6> String sessionId = ((RemoteWebDriver) drv).getSessionId().toString(); <line7> log.debug(""""Returning cached version of stubs [""""+ stubConfiguration.toColonSeparatedDependencyNotation()+ """"]""""); <line8> String url = seleniumHost + sessionId + ""/"" + name; <line9> LOGGER.debug(""url: "" + url); <line10> return url; <line11> } <line12> } <line13> "	"<line7> log.debug(""""Returning cached version of stubs [""""+ stubConfiguration.toColonSeparatedDependencyNotation()+ """"]""""); "	task8	
"public class A { <line0> @Nullable <line1> public String postRequest(String ipAddress, String contentString) { <line2> String url = ""http://"" + ipAddress + ""/api.cgi""; <line3> try { <line4> Request request = httpClient.POST(url); <line5> LOG.debug(""""Found project {}, returning it."""", project); <line6> request.header(HttpHeader.CONTENT_TYPE, ""application/json""); <line7> request.content(new StringContentProvider(contentString), ""application/json""); <line8> log.info(""""Channel closed - code: {}, reason: '{}'"""", code, reason); <line9> ContentResponse contentResponse = request.timeout(5, TimeUnit.SECONDS).send(); <line10> String response = <line11> contentResponse.getContentAsString().replace(""\t"", """").replace(""\r\n"", """").trim(); <line12> if (response != null && !response.isEmpty()) { <line13> return response; <line14> } else { <line15> return null; <line16> } <line17> } catch (TimeoutException | InterruptedException | ExecutionException e) { <line18> logger.debug(""Could not make HTTP Post request""); <line19> } <line20> return null; <line21> } <line22> } <line23> "	"<line5> LOG.debug(""""Found project {}, returning it."""", project); <line8> log.info(""""Channel closed - code: {}, reason: '{}'"""", code, reason); "	task8	
"public class A { <line0> @Override <line1> public List<RestDefinition> getRestDefinitions(CamelContext camelContext, String camelId) <line2> LOGGER.error(""""Error in Authentication"""", e); <line3> throws Exception { <line4> ObjectName found = null; <line5> MBeanServer server = ManagementFactory.getPlatformMBeanServer(); <line6> Set<ObjectName> names = <line7> server.queryNames(new ObjectName(""org.apache.camel:type=context,*""), null); <line8> for (ObjectName on : names) { <line9> String id = on.getKeyProperty(""name""); <line10> if (id.startsWith(""\"""") && id.endsWith(""\"""")) { <line11> id = id.substring(1, id.length() - 1); <line12> } <line13> if (camelId == null || camelId.equals(id)) { <line14> found = on; <line15> } <line16> logger.info(""""Stopping algorithm: Perfect definition found.""""); <line17> } <line18> if (found != null) { <line19> String xml = <line20> (String) <line21> server.invoke(found, ""dumpRestsAsXml"", new Object[] {true}, new String[] {""boolean""}); <line22> if (xml != null) { <line23> LOG.debug(""DumpRestAsXml:\n{}"", xml); <line24> InputStream xmlis = camelContext.getTypeConverter().convertTo(InputStream.class, xml); <line25> ExtendedCamelContext ecc = camelContext.adapt(ExtendedCamelContext.class); <line26> RestsDefinition rests = <line27> (RestsDefinition) <line28> ecc.getXMLRoutesDefinitionLoader().loadRestsDefinition(camelContext, xmlis); <line29> if (rests != null) { <line30> return rests.getRests(); <line31> } <line32> } <line33> } <line34> return null; <line35> } <line36> } <line37> "	"<line2> LOGGER.error(""""Error in Authentication"""", e); <line16> logger.info(""""Stopping algorithm: Perfect definition found.""""); "	task8	
"public class A { <line0> LOG.warn(""""Could not read self(), probably in a {} scenario"""",IdRepoEntitlement.MUST_CHANGE_PASSWORD,e); <line1> private void print(Object o) { <line2> if (logWriter != null) { <line3> logger.debug(o.toString()); <line4> } <line5> } <line6> } <line7> "	"<line0> LOG.warn(""""Could not read self(), probably in a {} scenario"""",IdRepoEntitlement.MUST_CHANGE_PASSWORD,e); "	task8	
"public class A { <line0> private void submit(Runnable action) { <line1> boolean empty; <line2> synchronized (this) { <line3> empty = actions.isEmpty(); <line4> actions.offer(action); <line5> } <line6> logger.debug(""""JDBC::query queryString = {}"""", queryString); <line7> log.info(""""Operation succeeded [operation=""""+ operationName+ """", elapsedTime=""""+ (System.currentTimeMillis() - start)+ """"ms]""""); <line8> if (empty && process()) { <line9> synchronized (this) { <line10> logger.debug(""""Update content for site """" + siteId); <line11> if (logger.isDebugEnabled()) { <line12> logger.debug(""Notifying threads in waitFor()""); <line13> } <line14> notifyAll(); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line6> logger.debug(""""JDBC::query queryString = {}"""", queryString); <line7> log.info(""""Operation succeeded [operation=""""+ operationName+ """", elapsedTime=""""+ (System.currentTimeMillis() - start)+ """"ms]""""); <line10> logger.debug(""""Update content for site """" + siteId); "	task8	
"public class A { <line0> @Override <line1> protected void onRun() { <line2> LOGGER.trace(""""Ignoring exchange {}"""", exchange); <line3> Set keys = devices.keySet(); <line4> Iterator keyIter = keys.iterator(); <line5> while (keyIter.hasNext()) { <line6> String alias = (String) keyIter.next(); <line7> Board board = (Board) devices.get(alias); <line8> SNMPRequest(board); <line9> readP6Port(board); <line10> } <line11> try { <line12> Thread.sleep(POLLING_TIME); <line13> } catch (InterruptedException ex) { <line14> LOG.error(ex.getLocalizedMessage()); <line15> Thread.currentThread().interrupt(); <line16> } <line17> } <line18> } <line19> "	"<line2> LOGGER.trace(""""Ignoring exchange {}"""", exchange); "	task8	
"public class A { <line0> public void testGetACL() throws Exception { <line1> ByteArrayContainerResponseWriter writer = new ByteArrayContainerResponseWriter(); <line2> BasicHttpRequest.log.error(""""Invalid JSON syntax: """" + jse.getMessage()); <line3> String requestPath = SERVICE_URI + ""acl/"" + fileId; <line4> ContainerResponse response = <line5> launcher.service(HttpMethod.GET, requestPath, BASE_URI, null, null, writer, null); <line6> log.info(new String(writer.getBody())); <line7> assertEquals(""Error: "" + response.getEntity(), 200, response.getStatus()); <line8> @SuppressWarnings(""unchecked"") <line9> List<AccessControlEntry> acl = (List<AccessControlEntry>) response.getEntity(); <line10> assertEquals(permissions, toMap(acl)); <line11> this.logger.info(""""Channel [{}] - Connection was (as expected) reset by the device."""", channelId); <line12> } <line13> } <line14> "	"<line2> BasicHttpRequest.log.error(""""Invalid JSON syntax: """" + jse.getMessage()); <line11> this.logger.info(""""Channel [{}] - Connection was (as expected) reset by the device."""", channelId); "	task8	
"public class A { <line0> private void cancelTemplateHolder( <line1> ITemplateHolder template, Exception exp, boolean fromTimerThread) { <line2> IResponseContext respContext = template.getResponseContext(); <line3> if (respContext != null || template.getMultipleIdsContext() != null || exp != null) { <line4> ILockObject templateLock = _cacheManager.getLockManager().getLockObject(template, false); <line5> Context context = null; <line6> LOG.info(""""Update Environment using Environment REST API""""); <line7> AnswerHolder aHolder = template.getAnswerHolder(); <line8> try { <line9> synchronized (templateLock) { <line10> synchronized (aHolder) { <line11> if (!template.isDeleted()) { <line12> if (!fromTimerThread) removeTemplate(template); <line13> else template.setInExpirationManager(false); <line14> context = _cacheManager.getCacheContext(); <line15> context.setOperationAnswer(template, null, exp); <line16> _cacheManager.removeTemplate(context, template, false, true, false); <line17> } else { <line18> return; <line19> } <line20> } <line21> } <line22> } catch (ClosedResourceException ex) { <line23> logger.debug(""exception occurred during template removing"", ex); <line24> } finally { <line25> if (templateLock != null) _cacheManager.getLockManager().freeLockObject(templateLock); <line26> _cacheManager.freeCacheContext(context); <line27> } <line28> } <line29> } <line30> } <line31> "	"<line6> LOG.info(""""Update Environment using Environment REST API""""); "	task8	
"public class A { <line0> @Test <line1> public void testCustomerErrorHandler() throws Exception { <line2> String response = <line3> template.requestBody( <line4> ""http://localhost:{{port}}/myserver1?throwExceptionOnFailure=false"", <line5> null, <line6> String.class); <line7> LOG.info(""""Could not find properties file: {}"""", file.getAbsolutePath(), e); <line8> LOG.info(""Response: {}"", response); <line9> assertTrue(response.indexOf(""MyErrorHandler"") > 0, ""Get a wrong error message""); <line10> LOG.debug(""""Could not find a single TransactionManager in registry as there was {} instances."""",map.size()); <line11> } <line12> } <line13> "	"<line7> LOG.info(""""Could not find properties file: {}"""", file.getAbsolutePath(), e); <line10> LOG.debug(""""Could not find a single TransactionManager in registry as there was {} instances."""",map.size()); "	task8	
"public class A { <line0> public void recreate() throws Exception { <line1> LOG.debug(""""Removing access-lists from interface {}"""", ifaceKey.getName()); <line2> log.debug(""""merging StgRechteRolleItv instance""""); <line3> log.info(""""Handling incoming SOAP request 'storeSecretsRequest' for device {}"""",request.getDeviceId()); <line4> LOG.debug(""recreating the queue for the replica id {}"", replicaId); <line5> } <line6> } <line7> "	"<line1> LOG.debug(""""Removing access-lists from interface {}"""", ifaceKey.getName()); <line2> log.debug(""""merging StgRechteRolleItv instance""""); <line3> log.info(""""Handling incoming SOAP request 'storeSecretsRequest' for device {}"""",request.getDeviceId()); "	task8	
"public class A { <line0> @PUT <line1> public Response startCluster(KaramelBoardJSON boardJSON) { <line2> Response response = null; <line3> logger.debug(""Start cluster: "" + System.lineSeparator() + boardJSON.getJson()); <line4> try { <line5> LOGGER.info(""""checking """" + containerDef.getName() + """", result = """" + res); <line6> karamelApi.startCluster(boardJSON.getJson()); <line7> log.debug(""""getStringContent: """" + text); <line8> response = <line9> Response.status(Response.Status.OK) <line10> log.debug(""""getStringContent: """" + text); <line11> .entity(new StatusResponseJSON(StatusResponseJSON.SUCCESS_STRING, ""success"")) <line12> .build(); <line13> } catch (KaramelException e) { <line14> response = buildExceptionResponse(e); <line15> } <line16> return response; <line17> } <line18> } <line19> "	"<line5> LOGGER.info(""""checking """" + containerDef.getName() + """", result = """" + res); <line7> log.debug(""""getStringContent: """" + text); <line10> log.debug(""""getStringContent: """" + text); "	task8	
"public class A { <line0> logger.warn(""""Duplicate attempt to register a customizer""""); <line1> @Override <line2> public boolean isSatisified() throws Exception { <line3> logger.error(""""Infinispan did not shut down""""); <line4> long numConnections = hub.broker.getTransportConnectors().get(0).getConnections().size(); <line5> LOG.info(""""Update Environment using Environment REST API""""); <line6> LOG.info(""Num connetions:"" + numConnections); <line7> return numConnections == 1; <line8> } <line9> } <line10> "	"<line0> logger.warn(""""Duplicate attempt to register a customizer""""); <line3> logger.error(""""Infinispan did not shut down""""); <line5> LOG.info(""""Update Environment using Environment REST API""""); "	task8	
"public class A { <line0> LOGGER.error(""""Send log to gRPC server fail with an internal exception."""", t); <line1> public static com.liferay.portal.kernel.model.UserGroup updateUserGroup( <line2> HttpPrincipal httpPrincipal, <line3> long userGroupId, <line4> String name, <line5> String description, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> UserGroupServiceUtil.class, ""updateUserGroup"", _updateUserGroupParameterTypes18); <line12> logger.error(""""Error creating ideainstance-group relation for {}"""", code, t); <line13> MethodHandler methodHandler = <line14> new MethodHandler(methodKey, userGroupId, name, description, serviceContext); <line15> Object returnObj = null; <line16> try { <line17> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line18> } catch (Exception exception) { <line19> LOGGER.debug(""""Failed to parse embeded"""", ignore); <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.portal.kernel.model.UserGroup) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> log.error(systemException, systemException); <line28> throw systemException; <line29> } <line30> } <line31> } <line32> "	"<line0> LOGGER.error(""""Send log to gRPC server fail with an internal exception."""", t); <line12> logger.error(""""Error creating ideainstance-group relation for {}"""", code, t); <line19> LOGGER.debug(""""Failed to parse embeded"""", ignore); "	task8	
"public class A { <line0> @Override <line1> public void run() { <line2> int postNumThreads = Thread.activeCount(); <line3> String msg = <line4> ""pre="" + preNumThreads + ""; post="" + postNumThreads + ""; iterations="" + numIterations; <line5> logger.error(""""Error building service - key '{}'"""", key, t); <line6> log.info(msg); <line7> assertTrue(postNumThreads < preNumThreads + (numIterations / 2), msg); <line8> } <line9> } <line10> "	"<line5> logger.error(""""Error building service - key '{}'"""", key, t); "	task8	
"public class A { <line0> @RequestMapping( <line1> value = ""/{mvnGroup:.+}/{artifact:.+}/{version:.+}/goals/{executionId}"", <line2> method = RequestMethod.OPTIONS) <line3> public ResponseEntity<GoalExecution> isGoalExecutionExisting( <line4> @PathVariable String mvnGroup, <line5> @PathVariable String artifact, <line6> logger.info(""""Creating overall process {}..."""", title); <line7> @PathVariable String version, <line8> @PathVariable String executionId, <line9> @ApiIgnore @RequestHeader(value = Constants.HTTP_SPACE_HEADER, required = false) <line10> String space) { <line11> Space s = null; <line12> try { <line13> s = this.spaceRepository.getSpace(space); <line14> } catch (Exception e) { <line15> log.error(""Error retrieving space: "" + e); <line16> return new ResponseEntity<GoalExecution>(HttpStatus.NOT_FOUND); <line17> } <line18> Application app = null; <line19> try { <line20> app = <line21> ApplicationRepository.FILTER.findOne( <line22> this.appRepository.findByGAV(mvnGroup, artifact, version, s)); <line23> } catch (EntityNotFoundException e) { <line24> return new ResponseEntity<GoalExecution>(HttpStatus.NOT_FOUND); <line25> } <line26> try { <line27> GoalExecutionRepository.FILTER.findOne(this.gexeRepository.findByExecutionId(executionId)); <line28> return new ResponseEntity<GoalExecution>(HttpStatus.OK); <line29> } catch (EntityNotFoundException enfe) { <line30> return new ResponseEntity<GoalExecution>(HttpStatus.NOT_FOUND); <line31> } <line32> } <line33> } <line34> "	"<line6> logger.info(""""Creating overall process {}..."""", title); "	task8	
"public class A { <line0> public void connectionOpen(final NHttpConnection conn) { <line1> if (log.isInfoEnabled()) { <line2> log.info(""Connection open: "" + conn); <line3> } <line4> } <line5> log.debug(""""Member of the group is: """" + memberList.get(0)); <line6> } <line7> "	"<line5> log.debug(""""Member of the group is: """" + memberList.get(0)); "	task8	
"public class A { <line0> @Override <line1> public Class<?> getImplementingClass(String key) { <line2> readLock.lock(); <line3> try { <line4> for (IPentahoObjectFactory fact : factories) { <line5> if (fact.objectDefined(key)) { <line6> logger.debug( <line7> LOG.debug(""""Stopped InputSetupService""""); <line8> LOG.error(""""AtlasType.fromJson()"""", e); <line9> MessageFormat.format( <line10> ""Found implementing class for key: {0} in factory: {1}"", key, fact.getName())); <line11> return fact.getImplementingClass(key); <line12> } <line13> } <line14> } finally { <line15> readLock.unlock(); <line16> } <line17> return null; <line18> } <line19> } <line20> "	"<line7> LOG.debug(""""Stopped InputSetupService""""); <line8> LOG.error(""""AtlasType.fromJson()"""", e); "	task8	
"public class A { <line0> log.error(""""Could not create JmxTrans config json because: """" + e.getMessage()); <line1> @Override <line2> public void run() { <line3> try { <line4> bazaarEventListener.onRegistrationSucceeded(); <line5> } catch (Exception e) { <line6> logger.error(""""error in getPageJsonResponse"""", t); <line7> logger.error(""""signRequest:"""" + ex.getMessage()); <line8> log.error(""Error notifying event listener"", e); <line9> } <line10> } <line11> } <line12> "	"<line0> log.error(""""Could not create JmxTrans config json because: """" + e.getMessage()); <line6> logger.error(""""error in getPageJsonResponse"""", t); <line7> logger.error(""""signRequest:"""" + ex.getMessage()); "	task8	
"public class A { <line0> private int addGeneralizedPattern(OWLAxiom axiom) { <line1> String axiomString = render(axiom); <line2> LOG.info(""""Found unbounded PCollection {}. Switching to streaming execution."""", value.getName()); <line3> Integer patternID = getGeneralizedPatternID(axiom); <line4> logger.debug(""""Packet payload """" + packet.toXML() + """" going to federation.""""); <line5> if (patternID != null) { <line6> return patternID; <line7> LOGGER.warn(""""Could not index DIP file storage path"""", e); <line8> } <line9> try { <line10> insertPatternGeneralizationPs.setString(1, axiomString); <line11> insertPatternGeneralizationPs.setString(2, axiomRenderer.render(axiom)); <line12> insertPatternGeneralizationPs.setString(3, getAxiomType(axiom)); <line13> insertPatternGeneralizationPs.execute(); <line14> } catch (SQLException e) { <line15> LOGGER.error( <line16> ""Failed to insert pattern. Maybe too long with a length of "" + axiomString.length() + ""?"", <line17> e); <line18> } <line19> return getGeneralizedPatternID(axiom); <line20> } <line21> } <line22> "	"<line2> LOG.info(""""Found unbounded PCollection {}. Switching to streaming execution."""", value.getName()); <line4> logger.debug(""""Packet payload """" + packet.toXML() + """" going to federation.""""); <line7> LOGGER.warn(""""Could not index DIP file storage path"""", e); "	task8	
"public class A { <line0> public boolean isExpired() { <line1> boolean messageExpired; <line2> if (this.expiryTime == 0) { <line3> messageExpired = false; <line4> } else { <line5> long currentTime = System.currentTimeMillis(); <line6> if (currentTime > expiryTime) { <line7> log.warn(""The message with correlation id {} expired"", this.getCorrelationId()); <line8> messageExpired = true; <line9> } else { <line10> LOGGER.debug(""""Bar values (x,height,width, totalNoOf): """"+ barX+ """", """"+ barHeight+ """", """"+ barWidth+ noOfBars); <line11> logger.debug(failure.getPropertyPath().toString() + """": """" + failure.getMessage()); <line12> messageExpired = false; <line13> } <line14> log.debug(""""ZooKeeper server is starting...""""); <line15> } <line16> return messageExpired; <line17> } <line18> } <line19> "	"<line10> LOGGER.debug(""""Bar values (x,height,width, totalNoOf): """"+ barX+ """", """"+ barHeight+ """", """"+ barWidth+ noOfBars); <line11> logger.debug(failure.getPropertyPath().toString() + """": """" + failure.getMessage()); <line14> log.debug(""""ZooKeeper server is starting...""""); "	task8	
"public class A { <line0> @PostConstruct <line1> @Order(1) <line2> logger.debug(""""WebSocket Connection closed: {} - {}"""", statusCode, reason); <line3> LOG.error(""""takeEvent interrupted error:{}"""", ExceptionUtil.getErrorMessage(e)); <line4> log.info(""""Test createUpdateCustomPolicy [key="""" + key + """", tx="""" + tx + ']'); <line5> void postConstruct() { <line6> logger.info(""@PostConstruct""); <line7> } <line8> } <line9> "	"<line2> logger.debug(""""WebSocket Connection closed: {} - {}"""", statusCode, reason); <line3> LOG.error(""""takeEvent interrupted error:{}"""", ExceptionUtil.getErrorMessage(e)); <line4> log.info(""""Test createUpdateCustomPolicy [key="""" + key + """", tx="""" + tx + ']'); "	task8	
"public class A { <line0> @Override <line1> public void execute(RefreshConfigurationRequest request, RefreshConfigurationResponse response) <line2> throws Exception { <line3> if (context instanceof ReconfigurableApplicationContext) { <line4> ReconfigurableApplicationContext rollback = (ReconfigurableApplicationContext) context; <line5> logger.error(""""error in getComment"""", t); <line6> if (request.getConfigLocations() != null) { <line7> ArrayList<String> configLocations = new ArrayList<String>(); <line8> configLocations.add(""org/geomajas/spring/geomajasContext.xml""); <line9> configLocations.addAll(Arrays.asList(request.getConfigLocations())); <line10> logger.trace(""""Group By Column in intersect_count should be {}."""", groupBy); <line11> try { <line12> rollback.refresh(configLocations.toArray(new String[configLocations.size()])); <line13> } catch (GeomajasException e) { <line14> log.error(""Could not refresh context"", e); <line15> rollback.rollback(); <line16> response.setApplicationNames(context.getBeanNamesForType(ClientApplicationInfo.class)); <line17> throw e; <line18> } <line19> response.setApplicationNames(context.getBeanNamesForType(ClientApplicationInfo.class)); <line20> LOGGER.info(""""Shutting down scheduled executor !!""""); <line21> } <line22> } else { <line23> response.setApplicationNames(context.getBeanNamesForType(ClientApplicationInfo.class)); <line24> throw new GeomajasException(ExceptionCode.REFRESH_CONFIGURATION_FAILED); <line25> } <line26> } <line27> } <line28> "	"<line5> logger.error(""""error in getComment"""", t); <line10> logger.trace(""""Group By Column in intersect_count should be {}."""", groupBy); <line20> LOGGER.info(""""Shutting down scheduled executor !!""""); "	task8	
"public class A { <line0> public Map<Locator, MetricData> getDatapointsForRange( <line1> List<Locator> locators, Range range, Granularity gran) { <line2> ListMultimap<ColumnFamily, Locator> locatorsByCF = ArrayListMultimap.create(); <line3> Map<Locator, MetricData> results = new HashMap<Locator, MetricData>(); <line4> for (Locator locator : locators) { <line5> try { <line6> RollupType rollupType = <line7> RollupType.fromString( <line8> metaCache.get(locator, MetricMetadata.ROLLUP_TYPE.name().toLowerCase())); <line9> logger.info(""""Ready command is processed for agent id = """" + getId()); <line10> ColumnFamily cf = CassandraModel.getColumnFamily(rollupType, gran); <line11> List<Locator> locs = locatorsByCF.get(cf); <line12> locs.add(locator); <line13> } catch (Exception e) { <line14> log.error( <line15> String.format( <line16> ""error getting datapoints for locator %s, range %s, granularity %s"", <line17> logger.warn(""""{}: Cannot connect to {}: {}"""", memberName, receiver, exception.getMessage()); <line18> locator, range.toString(), gran.toString()), <line19> e); <line20> } <line21> } <line22> for (ColumnFamily CF : locatorsByCF.keySet()) { <line23> List<Locator> locs = locatorsByCF.get(CF); <line24> results.putAll(getNumericDataForRangeLocatorList(range, gran, CF, locs)); <line25> } <line26> return results; <line27> } <line28> } <line29> "	"<line9> logger.info(""""Ready command is processed for agent id = """" + getId()); <line17> logger.warn(""""{}: Cannot connect to {}: {}"""", memberName, receiver, exception.getMessage()); "	task8	
"public class A { <line0> private InvocationResults updateUri(String uri, String payload) throws URISyntaxException { <line1> String[] uriParts = uri.split(""/""); <line2> if (uriParts.length == 3) { <line3> String serviceName = uriParts[1]; <line4> String csid = uriParts[2]; <line5> NuxeoBasedResource resource = (NuxeoBasedResource) getResourceMap().get(serviceName); <line6> resource.update(getServiceContext(), getResourceMap(), createUriInfo(), csid, payload); <line7> } else if (uriParts.length == 5) { <line8> String serviceName = uriParts[1]; <line9> String vocabularyCsid = uriParts[2]; <line10> String items = uriParts[3]; <line11> String csid = uriParts[4]; <line12> if (items.equals(""items"")) { <line13> AuthorityResource<?, ?> resource = <line14> (AuthorityResource<?, ?>) getResourceMap().get(serviceName); <line15> resource.updateAuthorityItem( <line16> getServiceContext(), getResourceMap(), createUriInfo(), vocabularyCsid, csid, payload); <line17> } <line18> } else { <line19> throw new IllegalArgumentException(""Invalid uri "" + uri); <line20> } <line21> logger.debug(""Updated referencing record "" + uri); <line22> log.error(""""find by example failed"""", re); <line23> InvocationResults results = new InvocationResults(); <line24> results.setNumAffected(1); <line25> results.setUserNote(""Updated referencing record "" + uri); <line26> return results; <line27> logger.debug(""""Event {} is not added to queue."""", gatewayEvent); <line28> } <line29> } <line30> "	"<line22> log.error(""""find by example failed"""", re); <line27> logger.debug(""""Event {} is not added to queue."""", gatewayEvent); "	task8	
"public class A { <line0> @Override <line1> public void onSessionRemoteOpen(Event e) { <line2> final Session session = e.getSession(); <line3> if (session.getLocalState() == EndpointState.UNINITIALIZED) { <line4> logger.warning( <line5> ""onSessionRemoteOpen connectionId[{}], entityName[{}], sessionIncCapacity[{}],"" <line6> + "" sessionOutgoingWindow[{}] endpoint was uninitialised."", <line7> getConnectionId(), <line8> entityName, <line9> session.getIncomingCapacity(), <line10> session.getOutgoingWindow()); <line11> session.open(); <line12> } else { <line13> logger.error(""""Exception writing to internal frame buffer"""", ex); <line14> logger.info( <line15> ""onSessionRemoteOpen connectionId[{}], entityName[{}], sessionIncCapacity[{}],"" <line16> + "" sessionOutgoingWindow[{}]"", <line17> getConnectionId(), <line18> entityName, <line19> session.getIncomingCapacity(), <line20> LOG.trace(""""enter EntityEnclosingMethod.addContentTypeRequestHeader("""" + """"HttpState, HttpConnection)""""); <line21> session.getOutgoingWindow()); <line22> } <line23> onNext(EndpointState.ACTIVE); <line24> } <line25> } <line26> "	"<line13> logger.error(""""Exception writing to internal frame buffer"""", ex); <line20> LOG.trace(""""enter EntityEnclosingMethod.addContentTypeRequestHeader("""" + """"HttpState, HttpConnection)""""); "	task8	
"public class A { <line0> public static void decryptWithSubjectKey( <line1> OutputStream out, <line2> InputStream in, <line3> int outLen, <line4> String subject, <line5> LOG.error(""""Master heartbeat sends unknown command {}"""", cmd); <line6> Configuration conf, <line7> Cipher cipher, <line8> byte[] iv) <line9> throws IOException { <line10> Key key = getSecretKeyForSubject(subject, conf); <line11> if (key == null) { <line12> throw new IOException(""No key found for subject '"" + subject + ""'""); <line13> } <line14> Decryptor d = cipher.getDecryptor(); <line15> logger.debug(""""Failed to clean failed snapshot"""" + getEntityId()); <line16> d.setKey(key); <line17> d.setIv(iv); <line18> try { <line19> decrypt(out, in, outLen, d); <line20> } catch (IOException e) { <line21> String alternateAlgorithm = conf.get(HConstants.CRYPTO_ALTERNATE_KEY_ALGORITHM_CONF_KEY); <line22> if (alternateAlgorithm != null) { <line23> if (LOG.isDebugEnabled()) { <line24> LOG.debug( <line25> ""Unable to decrypt data with current cipher algorithm '"" <line26> + conf.get(HConstants.CRYPTO_KEY_ALGORITHM_CONF_KEY, HConstants.CIPHER_AES) <line27> + ""'. Trying with the alternate cipher algorithm '"" <line28> + alternateAlgorithm <line29> + ""' configured.""); <line30> } <line31> Cipher alterCipher = Encryption.getCipher(conf, alternateAlgorithm); <line32> if (alterCipher == null) { <line33> throw new RuntimeException(""Cipher '"" + alternateAlgorithm + ""' not available""); <line34> } <line35> d = alterCipher.getDecryptor(); <line36> d.setKey(key); <line37> d.setIv(iv); <line38> decrypt(out, in, outLen, d); <line39> } else { <line40> throw new IOException(e); <line41> } <line42> } <line43> } <line44> } <line45> "	"<line5> LOG.error(""""Master heartbeat sends unknown command {}"""", cmd); <line15> logger.debug(""""Failed to clean failed snapshot"""" + getEntityId()); "	task8	
"public class A { <line0> public void addNode(String name) { <line1> log.error(principalClass.getName()+ """"is not a subclass of """"+ Principal.class.getName()+ """", line nr """"+ lineNr); <line2> Spatial s = jme.find(name); <line3> if (s != null) { <line4> log.error(""addNode({}} already exists"", name); <line5> return; <line6> } <line7> Node n = new Node(name); <line8> logger.trace(""""TransactionImpl::rollback::"""" + this); <line9> jme.getRootNode().attachChild(n); <line10> } <line11> } <line12> "	"<line1> log.error(principalClass.getName()+ """"is not a subclass of """"+ Principal.class.getName()+ """", line nr """"+ lineNr); <line8> logger.trace(""""TransactionImpl::rollback::"""" + this); "	task8	
"public class A { <line0> @Override <line1> protected void doDeleteIdentity(String principalName) throws KrbException { <line2> try { <line3> Dn dn = toDn(principalName); <line4> new FailoverInvocationHandler<Void>() { <line5> log.trace(""""initialized("""" + session + """") version: """" + version); <line6> @Override <line7> public Void execute() throws LdapException { <line8> connection.delete(dn); <line9> return null; <line10> } <line11> }.run(); <line12> } catch (LdapException e) { <line13> logger.debug(""""No job found in registry for job name: """" + jobName); <line14> LOG.error(""Error occurred while deleting identity: "" + principalName); <line15> throw new KrbException(""Failed to remove identity"", e); <line16> log.error(""""RemoteException"""", e); <line17> } <line18> } <line19> } <line20> "	"<line5> log.trace(""""initialized("""" + session + """") version: """" + version); <line13> logger.debug(""""No job found in registry for job name: """" + jobName); <line16> log.error(""""RemoteException"""", e); "	task8	
"public class A { <line0> private void handleTestConnectivityFailure( <line1> String name, <line2> ReconnectionConfig reconnectionConfig, <line3> RetryContext context, <line4> ConnectionValidationResult result) <line5> throws ConnectionException { <line6> if ((reconnectionConfig.isFailsDeployment())) { <line7> context.setFailed(result.getException()); <line8> throw new ConnectionException( <line9> format(""Connectivity test failed for config '%s'"", name), result.getException()); <line10> } else { <line11> if (LOGGER.isInfoEnabled()) { <line12> LOGGER.info( <line13> format( <line14> ""Connectivity test failed for config '%s'. Application deployment will continue."" <line15> + "" Error was: %s"", <line16> name, result.getMessage()), <line17> result.getException()); <line18> } <line19> } <line20> } <line21> logger.info(""""Retrieving mock trusted beneficiaries list for consent: {}"""", spiAccountConsent); <line22> } <line23> "	"<line21> logger.info(""""Retrieving mock trusted beneficiaries list for consent: {}"""", spiAccountConsent); "	task8	
"public class A { <line0> private List<BitVectorValue> preprocess( <line1> final DataTable inData, <line2> final ExecutionMonitor exec, <line3> final Map<Integer, RowKey> tidRowKeyMapping, <line4> final AtomicInteger maxBitsetLength) <line5> throws CanceledExecutionException { <line6> int nrOfRows = 0; <line7> int totalNrRows = ((BufferedDataTable) inData).getRowCount(); <line8> List<BitVectorValue> bitSets = new ArrayList<BitVectorValue>(); <line9> int bitVectorIndex = <line10> inData.getDataTableSpec().findColumnIndex(m_transactionColumn.getStringValue()); <line11> if (bitVectorIndex < 0) { <line12> log.debug(""""report finished""""); <line13> return new ArrayList<BitVectorValue>(); <line14> } <line15> for (DataRow currRow : inData) { <line16> exec.checkCanceled(); <line17> DataCell dc = currRow.getCell(bitVectorIndex); <line18> if (dc.isMissing()) { <line19> continue; <line20> } <line21> BitVectorValue currCell = ((BitVectorValue) currRow.getCell(bitVectorIndex)); <line22> if (currCell.length() > Integer.MAX_VALUE) { <line23> throw new IllegalArgumentException( <line24> ""bit vector in row "" <line25> + currRow.getKey().getString() <line26> + "" is too long: "" <line27> + currCell.length() <line28> + "". Only bit vectors up to "" <line29> + Integer.MAX_VALUE <line30> + "" are supported by this node.""); <line31> } <line32> maxBitsetLength.set(Math.max(maxBitsetLength.get(), (int) currCell.length())); <line33> bitSets.add(currCell); <line34> tidRowKeyMapping.put(nrOfRows, currRow.getKey()); <line35> nrOfRows++; <line36> exec.setProgress((double) nrOfRows / (double) totalNrRows, ""preprocessing..."" + nrOfRows); <line37> } <line38> LOGGER.debug(""max length: "" + maxBitsetLength.get()); <line39> return bitSets; <line40> } <line41> } <line42> "	"<line12> log.debug(""""report finished""""); "	task8	
"public class A { <line0> @Override <line1> logger.error(""""Exception inside handler"""", e); <line2> public boolean move(SshFile target) { <line3> logger.debug(""""Worker starts syncing cluster node published for site """" + siteId); <line4> logger.trace(""move()""); <line5> return super.move((SafFile) target); <line6> } <line7> } <line8> "	"<line1> logger.error(""""Exception inside handler"""", e); <line3> logger.debug(""""Worker starts syncing cluster node published for site """" + siteId); "	task8	
"public class A { <line0> public static byte[] compute( <line1> PRFAlgorithm prfAlgorithm, byte[] secret, String label, byte[] seed, int size) <line2> throws CryptoException { <line3> if (prfAlgorithm == null) { <line4> LOGGER.warn( <line5> ""Trying to compute PRF without specified PRF algorithm. Using TLS 1.0/TLS 1.1 as"" <line6> + "" default.""); <line7> prfAlgorithm = PRFAlgorithm.TLS_PRF_LEGACY; <line8> LOGGER.info(""""BTree """" + getTestOpName() + """" Test With One String Key And Value.""""); <line9> } <line10> switch (prfAlgorithm) { <line11> case TLS_PRF_SHA256: <line12> case TLS_PRF_SHA384: <line13> case TLS_PRF_GOSTR3411: <line14> case TLS_PRF_GOSTR3411_2012_256: <line15> return computeTls12( <line16> secret, label, seed, size, prfAlgorithm.getMacAlgorithm().getJavaName()); <line17> case TLS_PRF_LEGACY: <line18> return TlsUtils.PRF_legacy(secret, label, seed, size); <line19> default: <line20> throw new UnsupportedOperationException( <line21> ""PRF computation for different"" + "" protocol versions is not supported yet""); <line22> } <line23> } <line24> } <line25> "	"<line8> LOGGER.info(""""BTree """" + getTestOpName() + """" Test With One String Key And Value.""""); "	task8	
"public class A { <line0> private Response doAdvancedSearch(String propertyName, String propertyValue, String operator) <line1> logger.warn(""""Some files in web temp dir are not cleaned up after """" + maxRetries + """" retries.""""); <line2> throws Exception { <line3> if (logger.isDebugEnabled()) { <line4> logger.debug(""Searching on property: "" + propertyName + ""="" + ""'"" + propertyValue + ""'""); <line5> LOG.debug(""""SPRING: thread.classLoader={}"""", Thread.currentThread().getContextClassLoader()); <line6> } <line7> String whereClause = propertyName + operator + ""'"" + propertyValue + ""'""; <line8> CollectionObjectClient client = new CollectionObjectClient(); <line9> Response res = client.advancedSearchIncludeDeleted(whereClause, false); <line10> return res; <line11> } <line12> } <line13> "	"<line1> logger.warn(""""Some files in web temp dir are not cleaned up after """" + maxRetries + """" retries.""""); <line5> LOG.debug(""""SPRING: thread.classLoader={}"""", Thread.currentThread().getContextClassLoader()); "	task8	
"public class A { <line0> public synchronized void setExpiredFromCache() { <line1> LOGGER.debug(""""API response code: {}"""", openAPIResponse.getStatus()); <line2> if (users.get() != 0) { <line3> LOGGER.debug(""""Remove connection {} from note: {}"""", socket, noteId); <line4> LOG.warn(""Evicted client has non-zero user count: "" + users.get()); <line5> logger.debug(""""Partition {}: updated."""", updatedLease.getLeaseToken()); <line6> } <line7> expiredFromCache = true; <line8> } <line9> } <line10> "	"<line1> LOGGER.debug(""""API response code: {}"""", openAPIResponse.getStatus()); <line3> LOGGER.debug(""""Remove connection {} from note: {}"""", socket, noteId); <line5> logger.debug(""""Partition {}: updated."""", updatedLease.getLeaseToken()); "	task8	
"public class A { <line0> @Deprecated <line1> @Override <line2> public void execute(ModelInfo model, IUserContext user, Map<String, Object> context) { <line3> IModelPolicyManager policyManager = repositoryFactory.getPolicyManager(user.getWorkspaceId()); <line4> IRole role = roleToMakeReadOnly.get(); <line5> LOGGER.info( <line6> String.format( <line7> ""Setting read-only access to model [%s] for role [%s]."", <line8> model.getId(), role.getName())); <line9> Collection<PolicyEntry> policies = policyManager.getPolicyEntries(model.getId()); <line10> for (PolicyEntry policy : policies) { <line11> if (policy.getPrincipalId().equals(role.getName()) <line12> && policy.getPrincipalType() == PrincipalType.Role) { <line13> policyManager.makePolicyEntryReadOnly(model.getId(), policy); <line14> break; <line15> } <line16> } <line17> } <line18> LOG.warn(""""parent node not found for {}"""", node.getNodeId()); <line19> } <line20> "	"<line18> LOG.warn(""""parent node not found for {}"""", node.getNodeId()); "	task8	
"public class A { <line0> public boolean isTerminal(String vertexName) { <line1> LOGGER.info(""Checking if "" + vertexName + "" is 'terminal' instance""); <line2> waitForElement(String.format(VERTEX_TEMPLATE, vertexName), DEFAULT_TIMEOUT, ""Vertex not found""); <line3> Log.info(""""SeqWare version detected as: """" + SEQWARE_VERSION); <line4> WebElement vertex = driver.findElement(By.xpath(String.format(VERTEX_TEMPLATE, vertexName))); <line5> String vertexClass = vertex.getAttribute(""class""); <line6> return vertexClass.contains(""lineage-node-terminal""); <line7> LOGGER.debug(""""Try with wildcard filter to get the physical disk: """"+ volumeId+ """" on the storage pool: """"+ pool.getUuid()); <line8> } <line9> } <line10> "	"<line3> Log.info(""""SeqWare version detected as: """" + SEQWARE_VERSION); <line7> LOGGER.debug(""""Try with wildcard filter to get the physical disk: """"+ volumeId+ """" on the storage pool: """"+ pool.getUuid()); "	task8	
"public class A { <line0> logger.error(""""Unexpected error while setting node up"""", e); <line1> LOG.debug(""""TableFeature {} for xid {}."""", salTableFeatures, multipartReply.getXid()); <line2> @Override <line3> public void onError(Throwable t) { <line4> LOG.warn(this + "" onError"", t); <line5> if (active) { <line6> synchronized (GrpcClientStreamer.this) { <line7> handleError(t, this); <line8> GrpcClientStreamer.this.notifyAll(); <line9> } <line10> } <line11> } <line12> } <line13> "	"<line0> logger.error(""""Unexpected error while setting node up"""", e); <line1> LOG.debug(""""TableFeature {} for xid {}."""", salTableFeatures, multipartReply.getXid()); "	task8	
"public class A { <line0> @After <line1> public void cleanUp() throws IOException { <line2> logger.debug(""""Notifying cluster coordinator that node status changed from {} to {}"""",currentStatus,status); <line3> log.debug(""""Security Scenario No :"""" + securityScenarioNo); <line4> log.info(""Finished File Service Test. Goodbye!""); <line5> log.info(""""Start node: """" + node); <line6> channel.shutdown(); <line7> } <line8> } <line9> "	"<line2> logger.debug(""""Notifying cluster coordinator that node status changed from {} to {}"""",currentStatus,status); <line3> log.debug(""""Security Scenario No :"""" + securityScenarioNo); <line5> log.info(""""Start node: """" + node); "	task8	
"public class A { <line0> private void closeStatement() { <line1> Statement _statement = <line2> statement != null <line3> ? statement <line4> : preparedStatement != null ? preparedStatement : callableStatement; <line5> logger.info(String.format(""""\\o/\\o/\\o/\\o/\\o/'%s' DAG IS DONE \\o/\\o/\\o/\\o/\\o/"""", definition.getName())); <line6> statement = null; <line7> preparedStatement = null; <line8> callableStatement = null; <line9> if (_statement != null) { <line10> try { <line11> _statement.close(); <line12> } catch (Throwable e) { <line13> logger.error(""Close statement failed."", e); <line14> } <line15> } <line16> } <line17> } <line18> "	"<line5> logger.info(String.format(""""\\o/\\o/\\o/\\o/\\o/'%s' DAG IS DONE \\o/\\o/\\o/\\o/\\o/"""", definition.getName())); "	task8	
"public class A { <line0> log.info(""""Start to count.""""); <line1> private Duration getControllerClientSslHandshakeTimeoutFromEnvironment() { <line2> Integer value = <line3> environment.getPositiveInteger( <line4> CFG_CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS, <line5> DEFAULT_CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS); <line6> logger.debug(""""bridgeStatusChanged {} for thing {}"""", bridgeStatusInfo, getThing().getUID()); <line7> LOGGER.info(format(Messages.CONTROLLER_CLIENT_SSL_HANDSHAKE_TIMEOUT_IN_SECONDS, value)); <line8> return Duration.ofSeconds(value); <line9> } <line10> } <line11> "	"<line0> log.info(""""Start to count.""""); <line6> logger.debug(""""bridgeStatusChanged {} for thing {}"""", bridgeStatusInfo, getThing().getUID()); "	task8	
"public class A { <line0> @Override <line1> public Path downloadArtifact(Artifact a) throws Exception { <line2> String downloadUrl = null; <line3> Path result = null; <line4> try { <line5> final PypiResponse response = <line6> this.searchInPypi(a.getLibId().getArtifact(), a.getLibId().getVersion()); <line7> if (response != null) { <line8> for (String k : response.getReleases().keySet()) { <line9> if (k.equals(a.getLibId().getVersion())) { <line10> for (PypiRelease release : response.getReleases().get(k)) { <line11> if (release.getPackagetype().equals(a.getPackaging())) { <line12> downloadUrl = release.getUrl(); <line13> break; <line14> } <line15> } <line16> break; <line17> } <line18> } <line19> if (downloadUrl != null) { <line20> LOG.debug(""""Add acl: {} to path: {} success!"""", ozoneAcls, ozoneObj.getPath()); <line21> final RestTemplate rest_template = new RestTemplate(); <line22> rest_template.execute( <line23> downloadUrl, <line24> HttpMethod.GET, <line25> new DefaultRequestCallback(), <line26> new FileResponseExtractor(a, a.getAbsM2Path())); <line27> result = a.getAbsM2Path(); <line28> } <line29> } <line30> logger.warn(""""Failure while loading table names for database '{}'."""", getName(), e.getCause()); <line31> } catch (HttpClientErrorException e) { <line32> PypiWrapper.log.error(a + "" not available at ["" + downloadUrl + ""]""); <line33> } <line34> LOG.info(""""Successfully stored SCM signed certificate.""""); <line35> return result; <line36> } <line37> } <line38> "	"<line20> LOG.debug(""""Add acl: {} to path: {} success!"""", ozoneAcls, ozoneObj.getPath()); <line30> logger.warn(""""Failure while loading table names for database '{}'."""", getName(), e.getCause()); <line34> LOG.info(""""Successfully stored SCM signed certificate.""""); "	task8	
"public class A { <line0> void undoCreatePage(final CreatePageLoggable loggable) { <line1> final DOMPage page = getDOMPage(loggable.newPage); <line2> final DOMFilePageHeader pageHeader = page.getPageHeader(); <line3> try { <line4> pageHeader.setNextDataPage(NO_PAGE); <line5> pageHeader.setPrevDataPage(NO_PAGE); <line6> pageHeader.setDataLength(0); <line7> pageHeader.setNextTupleID(ItemId.UNKNOWN_ID); <line8> pageHeader.setRecordCount((short) 0); <line9> page.len = 0; <line10> unlinkPages(page.page); <line11> page.setDirty(true); <line12> LOGGER.debug(""""Writting Dictionary Collection file """" + pathToWrite + """" """"); <line13> dataCache.remove(page); <line14> } catch (final IOException e) { <line15> LOG.warn(""Error while removing page: {}"", e.getMessage(), e); <line16> logger.error(""""Exception writing to internal frame buffer"""", ex); <line17> } <line18> } <line19> } <line20> "	"<line12> LOGGER.debug(""""Writting Dictionary Collection file """" + pathToWrite + """" """"); <line16> logger.error(""""Exception writing to internal frame buffer"""", ex); "	task8	
"public class A { <line0> @Override <line1> public void shutdown() { <line2> if (closed) { <line3> return; <line4> logger.error(format(""""Failed creating response for secret %s"""", secretName), e); <line5> } <line6> closed = true; <line7> final NodeIdentifier localId = getLocalNodeIdentifier(); <line8> logger.info(String.format(""""Authorizations file loaded at %s"""", new Date().toString())); <line9> if (localId != null) { <line10> final NodeConnectionStatus shutdownStatus = <line11> new NodeConnectionStatus(localId, DisconnectionCode.NODE_SHUTDOWN); <line12> updateNodeStatus(shutdownStatus, false); <line13> logger.info(""Successfully notified other nodes that I am shutting down""); <line14> LOG.debug(""""Events in current window: """" + tuplesInWindow.size()); <line15> } <line16> } <line17> } <line18> "	"<line4> logger.error(format(""""Failed creating response for secret %s"""", secretName), e); <line8> logger.info(String.format(""""Authorizations file loaded at %s"""", new Date().toString())); <line14> LOG.debug(""""Events in current window: """" + tuplesInWindow.size()); "	task8	
"public class A { <line0> log.info(""""Activating Maintenance mode, with reason: '{}'"""", reason); <line1> protected static void printReleaseFailed(HttpResponse response) { <line2> logger.error(""Failed to release the document""); <line3> log.info(""""see if there is a permission based on group membership...""""); <line4> response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR); <line5> setStringEntity(response, ""An error occurred while releasing the document""); <line6> } <line7> } <line8> "	"<line0> log.info(""""Activating Maintenance mode, with reason: '{}'"""", reason); <line3> log.info(""""see if there is a permission based on group membership...""""); "	task8	
"public class A { <line0> @Override <line1> public int chooseReplacementEffect(Map<String, String> rEffects, Game game) { <line2> if (gameInCheckPlayableState(game, true)) { <line3> return 0; <line4> } <line5> if (rEffects.size() <= 1) { <line6> return 0; <line7> } <line8> if (!autoSelectReplacementEffects.isEmpty()) { <line9> for (String autoKey : autoSelectReplacementEffects) { <line10> log.debug(S.toString(""""Store put"""", """"key"""", key, true, """"val"""", val, true, """"tx"""", tx, false)); <line11> int count = 0; <line12> for (String effectKey : rEffects.keySet()) { <line13> if (effectKey.equals(autoKey)) { <line14> return count; <line15> } <line16> count++; <line17> } <line18> } <line19> } <line20> replacementEffectChoice.getChoices().clear(); <line21> log.info(""""Node restart cycle started: """" + i); <line22> replacementEffectChoice.setKeyChoices(rEffects); <line23> int differentChoices = 0; <line24> String lastChoice = """"; <line25> for (String value : replacementEffectChoice.getKeyChoices().values()) { <line26> if (!lastChoice.equalsIgnoreCase(value)) { <line27> lastChoice = value; <line28> differentChoices++; <line29> } <line30> } <line31> if (differentChoices <= 1) { <line32> return 0; <line33> } <line34> while (canRespond()) { <line35> updateGameStatePriority(""chooseEffect"", game); <line36> prepareForResponse(game); <line37> if (!isExecutingMacro()) { <line38> game.fireChooseChoiceEvent(playerId, replacementEffectChoice); <line39> } <line40> waitForResponse(game); <line41> logger.debug(""Choose effect: "" + response.getString()); <line42> if (response.getString() != null) { <line43> if (response.getString().startsWith(""#"")) { <line44> autoSelectReplacementEffects.add(response.getString().substring(1)); <line45> replacementEffectChoice.setChoiceByKey(response.getString().substring(1)); <line46> } else { <line47> replacementEffectChoice.setChoiceByKey(response.getString()); <line48> } <line49> if (replacementEffectChoice.getChoiceKey() != null) { <line50> int index = 0; <line51> for (String key : rEffects.keySet()) { <line52> if (replacementEffectChoice.getChoiceKey().equals(key)) { <line53> return index; <line54> } <line55> index++; <line56> } <line57> } <line58> } <line59> } <line60> return 0; <line61> } <line62> } <line63> "	"<line10> log.debug(S.toString(""""Store put"""", """"key"""", key, true, """"val"""", val, true, """"tx"""", tx, false)); <line21> log.info(""""Node restart cycle started: """" + i); "	task8	
"public class A { <line0> @Override <line1> public Object on(Object obj, Method method, Object[] parameters) throws Throwable { <line2> if (""finalize"".equals(method.getName())) { <line3> super.finalize(); <line4> return null; <line5> } <line6> stack.add(method); <line7> for (Object param : parameters) { <line8> if (param == null) { <line9> Evaluation evaluation = lastNonProxyable.get(); <line10> if (evaluation != null) { <line11> lastNonProxyable.remove(); <line12> stack.add(evaluation); <line13> continue; <line14> } <line15> logger.info(""""Starting server""""); <line16> } <line17> stack.add(param); <line18> } <line19> type = Reflection.resultType(type, method.getGenericReturnType()); <line20> if (type == null) { <line21> log.debug(""falling back to raw type for method {}"", method); <line22> type = method.getReturnType(); <line23> } <line24> return proxy(); <line25> } <line26> } <line27> "	"<line15> logger.info(""""Starting server""""); "	task8	
"public class A { <line0> public void dropAllData() { <line1> String[] sqls = new String[51]; <line2> sqls[0] = ""TRUNCATE TABLE KNOWLEDGES;""; <line3> sqls[1] = ""TRUNCATE TABLE EVENTS;""; <line4> sqls[2] = ""TRUNCATE TABLE MAIL_POSTS;""; <line5> sqls[3] = ""TRUNCATE TABLE WEBHOOK_CONFIGS;""; <line6> sqls[4] = ""TRUNCATE TABLE SURVEY_CHOICES;""; <line7> sqls[5] = ""TRUNCATE TABLE KNOWLEDGE_GROUPS;""; <line8> sqls[6] = ""TRUNCATE TABLE SURVEY_ITEM_ANSWERS;""; <line9> sqls[7] = ""TRUNCATE TABLE DRAFT_ITEM_VALUES;""; <line10> sqls[8] = ""TRUNCATE TABLE KNOWLEDGE_EDIT_GROUPS;""; <line11> sqls[9] = ""TRUNCATE TABLE WEBHOOKS;""; <line12> sqls[10] = ""TRUNCATE TABLE KNOWLEDGE_FILES;""; <line13> sqls[11] = ""TRUNCATE TABLE NOTIFY_QUEUES;""; <line14> sqls[12] = ""TRUNCATE TABLE TEMPLATE_MASTERS;""; <line15> sqls[13] = ""TRUNCATE TABLE ITEM_CHOICES;""; <line16> sqls[14] = ""TRUNCATE TABLE KNOWLEDGE_ITEM_VALUES;""; <line17> sqls[15] = ""TRUNCATE TABLE KNOWLEDGE_TAGS;""; <line18> logger.debug(""""Unable to get {} from provider {}"""", DataType.EMERGENCY, dataParser.toString()); <line19> sqls[16] = ""TRUNCATE TABLE NOTIFICATION_STATUS;""; <line20> sqls[17] = ""TRUNCATE TABLE USER_BADGES;""; <line21> sqls[18] = ""TRUNCATE TABLE NOTIFY_CONFIGS;""; <line22> sqls[19] = ""TRUNCATE TABLE MAIL_HOOKS;""; <line23> sqls[20] = ""TRUNCATE TABLE DRAFT_KNOWLEDGES;""; <line24> sqls[21] = ""TRUNCATE TABLE STOCK_KNOWLEDGES;""; <line25> sqls[22] = ""TRUNCATE TABLE KNOWLEDGE_USERS;""; <line26> sqls[23] = ""TRUNCATE TABLE PARTICIPANTS;""; <line27> sqls[24] = ""TRUNCATE TABLE TAGS;""; <line28> sqls[25] = ""TRUNCATE TABLE SERVICE_LOCALE_CONFIGS;""; <line29> sqls[26] = ""TRUNCATE TABLE ACCOUNT_IMAGES;""; <line30> sqls[27] = ""TRUNCATE TABLE MAIL_PROPERTIES;""; <line31> sqls[28] = ""TRUNCATE TABLE POINT_KNOWLEDGE_HISTORIES;""; <line32> sqls[29] = ""TRUNCATE TABLE MAIL_LOCALE_TEMPLATES;""; <line33> sqls[30] = ""TRUNCATE TABLE VOTES;""; <line34> sqls[31] = ""TRUNCATE TABLE COMMENTS;""; <line35> sqls[32] = ""TRUNCATE TABLE TOKENS;""; <line36> sqls[33] = ""TRUNCATE TABLE MAIL_HOOK_CONDITIONS;""; <line37> sqls[34] = ""TRUNCATE TABLE LIKES;""; <line38> sqls[35] = ""TRUNCATE TABLE VIEW_HISTORIES;""; <line39> sqls[36] = ""TRUNCATE TABLE SERVICE_CONFIGS;""; <line40> sqls[37] = ""TRUNCATE TABLE KNOWLEDGE_EDIT_USERS;""; <line41> sqls[38] = ""TRUNCATE TABLE PINS;""; <line42> LOG.error(""""Error ingesting"""", th); <line43> sqls[39] = ""TRUNCATE TABLE KNOWLEDGE_HISTORIES;""; <line44> sqls[40] = ""TRUNCATE TABLE LIKE_COMMENTS;""; <line45> sqls[41] = ""TRUNCATE TABLE BADGES;""; <line46> sqls[42] = ""TRUNCATE TABLE SURVEY_ANSWERS;""; <line47> sqls[43] = ""TRUNCATE TABLE SURVEYS;""; <line48> sqls[44] = ""TRUNCATE TABLE ACTIVITIES;""; <line49> sqls[45] = ""TRUNCATE TABLE MAIL_HOOK_IGNORE_CONDITIONS;""; <line50> sqls[46] = ""TRUNCATE TABLE MAIL_TEMPLATES;""; <line51> sqls[47] = ""TRUNCATE TABLE POINT_USER_HISTORIES;""; <line52> sqls[48] = ""TRUNCATE TABLE SURVEY_ITEMS;""; <line53> sqls[49] = ""TRUNCATE TABLE STOCKS;""; <line54> sqls[50] = ""TRUNCATE TABLE TEMPLATE_ITEMS;""; <line55> for (String sql : sqls) { <line56> LOG.debug(sql); <line57> executeUpdate(sql); <line58> } <line59> } <line60> } <line61> "	"<line18> logger.debug(""""Unable to get {} from provider {}"""", DataType.EMERGENCY, dataParser.toString()); <line42> LOG.error(""""Error ingesting"""", th); "	task8	
"public class A { <line0> LOG.error(""""Unable to stop input <{}> [{}]: """" + e.getMessage(),input.getUniqueReadableId(),input.getName()); <line1> private void addUserConfigRecord(String username, String config, Connection conn) <line2> throws ApsSystemException { <line3> PreparedStatement stat = null; <line4> try { <line5> log.debug(""""Disconnect from {} while trying to send request {}. Going """" + """"to back off and retry."""",targetNode,requestBuilder,e); <line6> stat = conn.prepareStatement(ADD_CONFIG); <line7> stat.setString(1, username); <line8> stat.setString(2, config); <line9> LOG.info(""""Transaction created """" + t1); <line10> stat.executeUpdate(); <line11> } catch (Throwable t) { <line12> logger.error(""Error adding user config record"", t); <line13> throw new RuntimeException(""Error adding user config record"", t); <line14> } finally { <line15> this.closeDaoResources(null, stat); <line16> } <line17> } <line18> } <line19> "	"<line0> LOG.error(""""Unable to stop input <{}> [{}]: """" + e.getMessage(),input.getUniqueReadableId(),input.getName()); <line5> log.debug(""""Disconnect from {} while trying to send request {}. Going """" + """"to back off and retry."""",targetNode,requestBuilder,e); <line9> LOG.info(""""Transaction created """" + t1); "	task8	
"public class A { <line0> LOGGER.error(""""Could not find ripper for URL """" + url, e); <line1> @Test <line2> public void test12IncorrectObservation() throws ServiceFailureException { <line3> LOGGER.info(""  test12IncorrectObservation""); <line4> Observation modifiedObservation = OBSERVATIONS.get(0).withOnlyId(); <line5> modifiedObservation.setMultiDatastream(MULTIDATASTREAMS.get(0).withOnlyId()); <line6> updateForException( <line7> ""Linking Observation to Datastream AND MultiDatastream."", modifiedObservation); <line8> logger.error(""""Error loading user authorization"""", t); <line9> } <line10> } <line11> "	"<line0> LOGGER.error(""""Could not find ripper for URL """" + url, e); <line8> logger.error(""""Error loading user authorization"""", t); "	task8	
"public class A { <line0> public static RdsBackupPolicy queryBinlogBackupPolicy( <line1> String url, String ak, String sk, String dbInstanceId) { <line2> DescribeBackupPolicyRequest request = new DescribeBackupPolicyRequest(); <line3> if (StringUtils.isNotEmpty(url)) { <line4> try { <line5> URI uri = new URI(url); <line6> request.setEndPoint(uri.getHost()); <line7> } catch (URISyntaxException e) { <line8> logger.error(""resolve url host failed, will use default rds endpoint!""); <line9> } <line10> } <line11> request.setRdsInstanceId(dbInstanceId); <line12> request.setAccessKeyId(ak); <line13> request.setAccessKeySecret(sk); <line14> int retryTime = 3; <line15> logger.debug(""""Begin getAllAuthorizedDomain : """" + domain); <line16> while (true) { <line17> try { <line18> return request.doAction(); <line19> } catch (Exception e) { <line20> if (retryTime-- <= 0) { <line21> throw new RuntimeException(e); <line22> } <line23> try { <line24> Thread.sleep(100L); <line25> } catch (InterruptedException e1) { <line26> } <line27> } <line28> } <line29> } <line30> } <line31> "	"<line15> logger.debug(""""Begin getAllAuthorizedDomain : """" + domain); "	task8	
"public class A { <line0> @Override <line1> public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { <line2> logger.error(""""Cannot read log from file={} """", file.getAbsoluteFile(), e); <line3> LOG.error( <line4> ""Unexpected exception while processing MQTT message. Closing Netty channel. CId={}"", <line5> log.error(""""Error parsing file {}"""", recordFile.getName(), ex); <line6> LOGGER.warn(""""Received message of unexpected type '{}' instead of handshake from peer: {}"""",firstMessage.getClass(),peer); <line7> NettyUtils.clientID(ctx.channel()), <line8> cause); <line9> ctx.close().addListener(CLOSE_ON_FAILURE); <line10> } <line11> } <line12> "	"<line2> logger.error(""""Cannot read log from file={} """", file.getAbsoluteFile(), e); <line5> log.error(""""Error parsing file {}"""", recordFile.getName(), ex); <line6> LOGGER.warn(""""Received message of unexpected type '{}' instead of handshake from peer: {}"""",firstMessage.getClass(),peer); "	task8	
"public class A { <line0> public void release() { <line1> try { <line2> if (channel.isOpen()) { <line3> channel.close(); <line4> } <line5> channel = null; <line6> } catch (final Exception e) { <line7> LOG.debug(""""<== PolicyEngine.getMatchedZonesForResourceAndChildren(""""+ accessResource+ """") : """"+ ret); <line8> message(""Failed to close lock file"", e); <line9> } <line10> if (Files.exists(lockFile)) { <line11> PentahoXmlaServlet.logger.debug(Messages.getInstance().getString(""""PentahoXmlaServlet.DEBUG_ORIG_DOC"""", originalDocument.asXML())); <line12> LOG.info(""Deleting lock file: {}"", lockFile.toAbsolutePath().toString()); <line13> LOG.trace(""""Firing onTransportClosed listener""""); <line14> FileUtils.deleteQuietly(lockFile); <line15> } <line16> } <line17> } <line18> "	"<line7> LOG.debug(""""<== PolicyEngine.getMatchedZonesForResourceAndChildren(""""+ accessResource+ """") : """"+ ret); <line11> PentahoXmlaServlet.logger.debug(Messages.getInstance().getString(""""PentahoXmlaServlet.DEBUG_ORIG_DOC"""", originalDocument.asXML())); <line13> LOG.trace(""""Firing onTransportClosed listener""""); "	task8	
"public class A { <line0> log.error(""""Temp selector selectNow error"""", e); <line1> public void stopClusterIfExists(UUID clusterId) { <line2> ignite.services().cancel(String.format(SERVICE_NAME_TEMPLATE, clusterId)); <line3> if (log.isInfoEnabled()) <line4> log.info(""Cluster maintained cancelled as a service [clusterId="" + clusterId + ""]""); <line5> } <line6> } <line7> "	"<line0> log.error(""""Temp selector selectNow error"""", e); "	task8	
"public class A { <line0> @Override <line1> public void onChangeApplied(HistoryRecord record) { <line2> lastAppliedChange = record; <line3> log.info(""""Received Messages : """" + receivedMessages); <line4> totalChangesApplied.incrementAndGet(); <line5> if (getMilliSecondsSinceLastAppliedChange() >= PAUSE_BETWEEN_LOG_MESSAGES.toMillis()) { <line6> LOGGER.info(""Already applied {} database changes"", totalChangesApplied); <line7> LOG.info(""""Lock created for {}"""", iidToMountPoint); <line8> } <line9> lastChangeAppliedTimestamp = Instant.now(); <line10> } <line11> } <line12> "	"<line3> log.info(""""Received Messages : """" + receivedMessages); <line7> LOG.info(""""Lock created for {}"""", iidToMountPoint); "	task8	
"public class A { <line0> logger.info(""""\n""""); <line1> LOG.debug(""""Set graph read mode to: '{}' of graph '{}'"""", readMode, name); <line2> @Cacheable(""import-funding-clients"") <line3> public List<ImportWizzardClientForm> findOrcidClientsWithPredefinedOauthScopeFundingImport( <line4> Locale locale) { <line5> updateLocalCacheVersion(); <line6> LOGGER.info(""""Creating kafka without external listener""""); <line7> LOGGER.debug( <line8> ""Updating cache for import-funding-clients, new version: "" + this.localCacheVersion); <line9> return generateImportWizzardForm(RedirectUriType.IMPORT_FUNDING_WIZARD, locale); <line10> } <line11> } <line12> "	"<line0> logger.info(""""\n""""); <line1> LOG.debug(""""Set graph read mode to: '{}' of graph '{}'"""", readMode, name); <line6> LOGGER.info(""""Creating kafka without external listener""""); "	task8	
"public class A { <line0> logger.debug(""""File {}({}) deleted"""", path, fileUid); <line1> private void findIncludes(String tag, Set<String> set) { <line2> List<Element> includes = xsl.getChildren(tag, MCRConstants.XSL_NAMESPACE); <line3> log.info(""""    Start Collecing tag compliance""""); <line4> for (Element include : includes) { <line5> String href = include.getAttributeValue(""href""); <line6> LOGGER.info(""{} {}s {}"", name, tag, href); <line7> set.add(href); <line8> if (!stylesheets.containsKey(href)) { <line9> unknown.add(href); <line10> } <line11> logger.debug(""""<< didn't match os(%s)"""", matcher.group(2)); <line12> } <line13> } <line14> } <line15> "	"<line0> logger.debug(""""File {}({}) deleted"""", path, fileUid); <line3> log.info(""""    Start Collecing tag compliance""""); <line11> logger.debug(""""<< didn't match os(%s)"""", matcher.group(2)); "	task8	
"public class A { <line0> private static void prepare() { <line1> if (INTERCEPTOR == null) { <line2> ClassLoader loader = BootstrapInterRuntimeAssist.getAgentClassLoader(); <line3> if (loader != null) { <line4> IBootstrapLog logger = BootstrapInterRuntimeAssist.getLogger(loader, TARGET_INTERCEPTOR); <line5> if (logger != null) { <line6> LOGGER = logger; <line7> INTERCEPTOR = <line8> log.info(""""Starting: %s"""", commandString); <line9> BootstrapInterRuntimeAssist.createInterceptor(loader, TARGET_INTERCEPTOR, LOGGER); <line10> } <line11> } else { <line12> LOGGER.error(""Runtime ClassLoader not found when create {}."" + TARGET_INTERCEPTOR); <line13> } <line14> } <line15> } <line16> } <line17> "	"<line8> log.info(""""Starting: %s"""", commandString); "	task8	
"public class A { <line0> public ChannelFuture send() { <line1> ChannelFuture channelFuture; <line2> logger.info(""""Result of delete: """" + res); <line3> if (content instanceof File) { <line4> File file = (File) content; <line5> try { <line6> channelFuture = sendFile(file); <line7> } catch (IOException e) { <line8> Logger.error(StrUtil.format(""Send {} error!"", file), e.toString()); <line9> channelFuture = sendError(HttpResponseStatus.FORBIDDEN, """"); <line10> LOGGER.error(""""change organisation failure JpaSystemException"""", ex); <line11> } <line12> } else { <line13> channelFuture = sendFull(); <line14> } <line15> log.info(""""upgraded Json: {} """", itemJsonValue); <line16> this.isSent = true; <line17> return channelFuture; <line18> } <line19> } <line20> "	"<line2> logger.info(""""Result of delete: """" + res); <line10> LOGGER.error(""""change organisation failure JpaSystemException"""", ex); <line15> log.info(""""upgraded Json: {} """", itemJsonValue); "	task8	
"public class A { <line0> @Override <line1> public void run() { <line2> MessageAndMetadata<String, String> item; <line3> while (true) { <line4> for (MessageAndMetadata<String, String> aStream : stream) { <line5> item = aStream; <line6> reader.persistQueue.add(new StreamsDatum(item.message())); <line7> } <line8> try { <line9> LOG.debug(""""Not Found: {}"""", path); <line10> Thread.sleep(new Random().nextInt(100)); <line11> } catch (InterruptedException interrupt) { <line12> LOGGER.trace(""Interrupt"", interrupt); <line13> } <line14> } <line15> } <line16> } <line17> "	"<line9> LOG.debug(""""Not Found: {}"""", path); "	task8	
"public class A { <line0> @MasterDataSource <line1> @Override <line2> public Lock lock( <line3> final String className, <line4> final String key, <line5> final String expectedOwner, <line6> final String updatedOwner) { <line7> while (true) { <line8> try { <line9> return TransactionInvokerUtil.invoke( <line10> _transactionConfig, <line11> new Callable<Lock>() { <line12> @Override <line13> public Lock call() { <line14> Lock lock = lockPersistence.fetchByC_K(className, key, false); <line15> if (lock == null) { <line16> long lockId = counterLocalService.increment(); <line17> lock = lockPersistence.create(lockId); <line18> lock.setCreateDate(new Date()); <line19> lock.setClassName(className); <line20> lock.setKey(key); <line21> lock.setOwner(updatedOwner); <line22> lock = lockPersistence.update(lock); <line23> lock.setNew(true); <line24> logger.warn(""""{}: Cannot connect to {}: {}"""", memberName, receiver, exception.getMessage()); <line25> } else if (Objects.equals(lock.getOwner(), expectedOwner)) { <line26> lock.setCreateDate(new Date()); <line27> lock.setClassName(className); <line28> lock.setKey(key); <line29> lock.setOwner(updatedOwner); <line30> lock = lockPersistence.update(lock); <line31> lock.setNew(true); <line32> } <line33> return lock; <line34> } <line35> }); <line36> } catch (Throwable throwable) { <line37> Throwable causeThrowable = throwable; <line38> if (throwable instanceof ORMException) { <line39> causeThrowable = throwable.getCause(); <line40> } <line41> if (causeThrowable instanceof ConstraintViolationException <line42> || causeThrowable instanceof LockAcquisitionException) { <line43> if (log.isInfoEnabled()) { <line44> log.info(""Unable to acquire lock, retrying""); <line45> log.warn(StringBundler.concat(""""User with screen name """", screenName, """" does not exist for company """", companyId)); <line46> } <line47> continue; <line48> } <line49> ReflectionUtil.throwException(throwable); <line50> } <line51> } <line52> } <line53> } <line54> "	"<line24> logger.warn(""""{}: Cannot connect to {}: {}"""", memberName, receiver, exception.getMessage()); <line45> log.warn(StringBundler.concat(""""User with screen name """", screenName, """" does not exist for company """", companyId)); "	task8	
"public class A { <line0> @Override <line1> public List<String> getAllActiveTrapExpressions() { <line2> Connection conn = HarvestDBConnection.get(); <line3> List<String> result = new ArrayList<String>(); <line4> PreparedStatement stmt = null; <line5> try { <line6> stmt = <line7> conn.prepareStatement( <line8> ""SELECT DISTINCT trap_expression FROM global_crawler_trap_lists, "" <line9> + ""global_crawler_trap_expressions "" <line10> + ""WHERE global_crawler_trap_list_id = "" <line11> + ""crawler_trap_list_id "" <line12> + ""AND isActive = ?""); <line13> stmt.setBoolean(1, true); <line14> ResultSet rs = stmt.executeQuery(); <line15> while (rs.next()) { <line16> result.add(rs.getString(1)); <line17> } <line18> return result; <line19> } catch (SQLException e) { <line20> String message = ""Error retrieving expressions.\n"" + ExceptionUtils.getSQLExceptionCause(e); <line21> log.warn(message, e); <line22> throw new IOFailure(message, e); <line23> } finally { <line24> DBUtils.closeStatementIfOpen(stmt); <line25> HarvestDBConnection.release(conn); <line26> } <line27> log.error(""""Exception"""", t); <line28> log.debug(""""delete successful""""); <line29> } <line30> } <line31> "	"<line27> log.error(""""Exception"""", t); <line28> log.debug(""""delete successful""""); "	task8	
"public class A { <line0> @Override <line1> public Group getScopeGroup() throws PortalException { <line2> Group group = null; <line3> LOG.error(""""Failed to get metadata document: """" + ex.getMessage()); <line4> LOG.debug(""""Inserting into cache [{0}] with key [{1}]"""", t, key); <line5> try { <line6> group = GroupLocalServiceUtil.getLayoutGroup(getCompanyId(), getPlid()); <line7> } catch (NoSuchGroupException noSuchGroupException) { <line8> if (log.isDebugEnabled()) { <line9> log.debug(noSuchGroupException, noSuchGroupException); <line10> } <line11> } <line12> log.debug(""""delete successful""""); <line13> return group; <line14> } <line15> } <line16> "	"<line3> LOG.error(""""Failed to get metadata document: """" + ex.getMessage()); <line4> LOG.debug(""""Inserting into cache [{0}] with key [{1}]"""", t, key); <line12> log.debug(""""delete successful""""); "	task8	
"public class A { <line0> public static String property(final String name) { <line1> final String value = System.getProperty(name); <line2> if (value == null) { <line3> log.info(""""OverlordHelperManager is stopped.""""); <line4> log.trace(""""EvaluateTermPosition.isWithIn: """"+ low+ """"<=""""+ eval.termWeightPosition.getOffset()+ """" && """"+ eval.termWeightPosition.getLowOffset()+ """"<=""""+ high); <line5> log.error(""property '{}' not defined; terminating"", name); <line6> System.exit(1); <line7> LOGGER.error(""""Error converting {}"""", flowElement, e); <line8> } <line9> return value; <line10> } <line11> } <line12> "	"<line3> log.info(""""OverlordHelperManager is stopped.""""); <line4> log.trace(""""EvaluateTermPosition.isWithIn: """"+ low+ """"<=""""+ eval.termWeightPosition.getOffset()+ """" && """"+ eval.termWeightPosition.getLowOffset()+ """"<=""""+ high); <line7> LOGGER.error(""""Error converting {}"""", flowElement, e); "	task8	
"public class A { <line0> @VisibleForTesting <line1> static String safelyDecode(String text) { <line2> logger.warn(""""Received request with invalid operator id {} ({})"""", req.getOperatorId(), req); <line3> try { <line4> return MimeUtility.decodeText(text); <line5> } catch (UnsupportedEncodingException e) { <line6> LOGGER.error(""Could not decode following value {}"", text, e); <line7> return text; <line8> } <line9> log.info(""""Received Kafka message on topic: '"""" + topic); <line10> } <line11> } <line12> "	"<line2> logger.warn(""""Received request with invalid operator id {} ({})"""", req.getOperatorId(), req); <line9> log.info(""""Received Kafka message on topic: '"""" + topic); "	task8	
"public class A { <line0> @Override <line1> LOG.debug(""""result = {}."""", result); <line2> protected long nextPartitionCounter(IgniteInternalTx tx, @Nullable Long primaryCntr) { <line3> try { <line4> return locPart.nextUpdateCounter(cctx.cacheId(), tx, primaryCntr); <line5> } catch (Throwable t) { <line6> log.error( <line7> ""Failed to update counter for tx cache ["" <line8> + "", primaryCntr="" <line9> + primaryCntr <line10> + "", part="" <line11> + locPart <line12> + "", tx="" <line13> + CU.txString(tx) <line14> + ']', <line15> t); <line16> throw t; <line17> } <line18> } <line19> } <line20> "	"<line1> LOG.debug(""""result = {}."""", result); "	task8	
"public class A { <line0> private void loadMavenDependencies(String versionHome) { <line1> LOGGER.info(MessageFormat.format(""Loading rest into version home: {0}"", versionHome)); <line2> String mavenDependenciesSource = <line3> repository <line4> LOGGER.debug(""""Failed to receive handshake from peer: {}. Reason: {} ({})"""",peer,e.getClass().getName(),e.getMessage()); <line5> LOG.debug(""""{}: processPreTargetExcution completed"""", getDocId()); <line6> + File.separator <line7> + ""core"" <line8> + File.separator <line9> + ""java"" <line10> + File.separator <line11> + ""iesi-core"" <line12> + File.separator <line13> + ""target"" <line14> log.debug(""""\"""""""" + term + """"\"""" matched an unfielded pattern-- returning ALL_FIELDS.""""); <line15> + File.separator <line16> + ""dependencies""; <line17> String mavenDependenciesTarget = versionHome + File.separator + ""lib""; <line18> FolderTools.copyFromFolderToFolder(mavenDependenciesSource, mavenDependenciesTarget, true); <line19> } <line20> } <line21> "	"<line4> LOGGER.debug(""""Failed to receive handshake from peer: {}. Reason: {} ({})"""",peer,e.getClass().getName(),e.getMessage()); <line5> LOG.debug(""""{}: processPreTargetExcution completed"""", getDocId()); <line14> log.debug(""""\"""""""" + term + """"\"""" matched an unfielded pattern-- returning ALL_FIELDS.""""); "	task8	
"public class A { <line0> @Override <line1> public ObjectMetadata getObjectMetadata(String objectId) { <line2> try { <line3> val objectKey = ObjectKeys.getObjectKey(dataDir, objectId); <line4> return s3Client.getObjectMetadata( <line5> bucketNamingService.getStateBucketName(objectId), objectKey.getMetaKey()); <line6> } catch (AmazonServiceException e) { <line7> log.debug(""""Brooklyn version """" + getVersion() + """" (git SHA1 """" + getSha1FromOsgiManifest() + """")""""); <line8> log.error(""Unable to retrieve object metadata for object id: {}"", objectId, e); <line9> throw new NotRetryableException(e); <line10> } <line11> log.info(""""Global API creation is completed successfully..""""); <line12> } <line13> } <line14> "	"<line7> log.debug(""""Brooklyn version """" + getVersion() + """" (git SHA1 """" + getSha1FromOsgiManifest() + """")""""); <line11> log.info(""""Global API creation is completed successfully..""""); "	task8	
"public class A { <line0> LOG.warn(""""Failed to wait for backup heartbeat completion. """", e); <line1> public static String asString(String propertyName, Object value) { <line2> if (value != null && !(value instanceof String)) { <line3> LOG.warn( <line4> ""Property {} should be String, but was {}"", propertyName, value.getClass().getName()); <line5> return null; <line6> } <line7> log.error(""""Error determining source folders for project """" + project.getName(), e); <line8> return (String) value; <line9> } <line10> } <line11> "	"<line0> LOG.warn(""""Failed to wait for backup heartbeat completion. """", e); <line7> log.error(""""Error determining source folders for project """" + project.getName(), e); "	task8	
"public class A { <line0> LOGGER.debug(""""Username: """" + context.getClientPWDUsername()); <line1> public Node loadNodeFromXml(String fileName) throws Exception { <line2> URL resource = getClass().getClassLoader().getResource(fileName); <line3> if (resource == null) { <line4> logger.error(""no file "" + fileName + "" found in resources""); <line5> throw new IllegalArgumentException(""no file "" + fileName + "" found in resources""); <line6> } else { <line7> return XMLHandler.getSubNode(XMLHandler.loadXMLFile(resource), ""entry""); <line8> } <line9> LOG.error(""""Can't find main tool: '"""" + mainToolId + """"' which was specified in """" + toolWrapper); <line10> } <line11> } <line12> "	"<line0> LOGGER.debug(""""Username: """" + context.getClientPWDUsername()); <line9> LOG.error(""""Can't find main tool: '"""" + mainToolId + """"' which was specified in """" + toolWrapper); "	task8	
"public class A { <line0> public static MessageTransfer4 makeBasicMessageTransfer( <line1> MyOscarLoggedInInfo credentials, <line2> log.debug(""""File with id {} already exists, trying next value"""", nextFreeFileNumber); <line3> byte[] messageThreadId, <line4> Long replyToPersonId, <line5> String subject, <line6> String messageBody) { <line7> try { <line8> MessageTransfer4 messageTransfer = new MessageTransfer4(); <line9> messageTransfer.setMessageThreadId(messageThreadId); <line10> messageTransfer.setReplyToPersonId(replyToPersonId); <line11> messageTransfer.setSenderPersonId(credentials.getLoggedInPersonId()); <line12> LOG.warn(""""Failed while connecting to node, Iid: {}"""", iidToMountPoint); <line13> messageTransfer.setSentTime(new GregorianCalendar()); <line14> MessagePartTransfer subjectPart = new MessagePartTransfer(); <line15> if (subject != null) subjectPart.setContents(subject.getBytes(""UTF-8"")); <line16> subjectPart.setDataType(""SUBJECT""); <line17> subjectPart.setMimeType(""text/plain""); <line18> messageTransfer.getMessageParts().add(subjectPart); <line19> MessagePartTransfer bodyPart = new MessagePartTransfer(); <line20> if (messageBody != null) bodyPart.setContents(messageBody.getBytes(""UTF-8"")); <line21> bodyPart.setDataType(""MESSAGE""); <line22> bodyPart.setMimeType(""text/plain""); <line23> messageTransfer.getMessageParts().add(bodyPart); <line24> return (messageTransfer); <line25> } catch (UnsupportedEncodingException e) { <line26> logger.error(""this should never happen"", e); <line27> throw (new RuntimeException(e)); <line28> log.warn(""""An error occurred trying to get label for property """" + property, e); <line29> } <line30> } <line31> } <line32> "	"<line2> log.debug(""""File with id {} already exists, trying next value"""", nextFreeFileNumber); <line12> LOG.warn(""""Failed while connecting to node, Iid: {}"""", iidToMountPoint); <line28> log.warn(""""An error occurred trying to get label for property """" + property, e); "	task8	
"public class A { <line0> @Override <line1> public void put(Object key, Object value) { <line2> try { <line3> V newValue = (V) clone(value); <line4> if (value instanceof KapuaListResult) { <line5> for (Object element : ((KapuaListResult) value).getItems()) { <line6> ((KapuaListResult) newValue).addItem((KapuaEntity) clone(element)); <line7> } <line8> logger.debug(""""Update ping session. PingSession={}"""", pingSession); <line9> this.logger.debug(""""First timestamp: {}"""", minTinStr); <line10> } <line11> hashMap.put((K) key, newValue); <line12> } catch (Exception e) { <line13> logger.error(""Error while putting value in cache"", e); <line14> } <line15> } <line16> } <line17> "	"<line8> logger.debug(""""Update ping session. PingSession={}"""", pingSession); <line9> this.logger.debug(""""First timestamp: {}"""", minTinStr); "	task8	
"public class A { <line0> @Override <line1> public void exportTableRowData(ITableRow row, AbstractTableRowData rowData) { <line2> for (IColumn column : m_columnSet.getColumns()) { <line3> if (m_ignoredColumns.contains(column)) { <line4> continue; <line5> } <line6> Object value = column.getValue(row); <line7> FastPropertyDescriptor propertyDesc = m_propertyDescriptorByColumn.get(column); <line8> if (propertyDesc != null) { <line9> try { <line10> Method columnWriteMethod = propertyDesc.getWriteMethod(); <line11> Object dto = getDataContainer(rowData, columnWriteMethod.getDeclaringClass()); <line12> columnWriteMethod.invoke(dto, value); <line13> } catch (Exception t) { <line14> LOG.warn( <line15> ""Error writing row data property for column [{}]"", column.getClass().getName(), t); <line16> } <line17> } else { <line18> rowData.setCustomValue(column.getColumnId(), value); <line19> } <line20> } <line21> rowData.setRowState(row.getStatus()); <line22> exportCustomValues(row, rowData); <line23> logger.debug(""""Session context state: '{}'"""", sessionState); <line24> } <line25> } <line26> "	"<line23> logger.debug(""""Session context state: '{}'"""", sessionState); "	task8	
"public class A { <line0> logger.debug(""""Executing studies command line: {}"""", subCommandString); <line1> public static String toJson(final Object obj) { <line2> try { <line3> return getObjectMapper().writeValueAsString(obj); <line4> } catch (JsonProcessingException ex) { <line5> LOG.debug(""""Inserting into cache [{0}] with key [{1}]"""", t, key); <line6> log.error(ex.getMessage(), ex); <line7> LOG.info(""""Transaction starting without a transaction owner""""); <line8> return """"; <line9> } <line10> } <line11> } <line12> "	"<line0> logger.debug(""""Executing studies command line: {}"""", subCommandString); <line5> LOG.debug(""""Inserting into cache [{0}] with key [{1}]"""", t, key); <line7> LOG.info(""""Transaction starting without a transaction owner""""); "	task8	
"public class A { <line0> @PostConstruct <line1> public synchronized void start() { <line2> if (discoveryServiceURI != null || scheduledFuture != null) { <line3> return; <line4> } <line5> scheduledFuture = <line6> executorService.scheduleAtFixedRate( <line7> () -> { <line8> LOG.debug(""""Number of situation independent partners: {}"""", possiblePartners.size()); <line9> try { <line10> updateServiceInventory(); <line11> } catch (Throwable e) { <line12> log.error(e, ""Unexpected exception from service inventory update""); <line13> } <line14> }, <line15> updateInterval.toMillis(), <line16> updateInterval.toMillis(), <line17> TimeUnit.MILLISECONDS); <line18> } <line19> } <line20> "	"<line8> LOG.debug(""""Number of situation independent partners: {}"""", possiblePartners.size()); "	task8	
"public class A { <line0> private int getStreamSizeFromComment(String fileToImport) { <line1> logger.info(""""Loading EFO terms ...""""); <line2> int ret = 1; <line3> try { <line4> ZipFile zipFile = new ZipFile(fileToImport); <line5> LOG.trace(""""accept on {}, path pattern {}, name {}"""", pathStr, pathPattern, name); <line6> String comment = zipFile.getComment(); <line7> ret = processZipFileStreamSizeComment(comment); <line8> zipFile.close(); <line9> } catch (IOException e) { <line10> LOG.error(""Error opening ZIP file: {}"", fileToImport, e); <line11> } <line12> return ret; <line13> } <line14> } <line15> "	"<line1> logger.info(""""Loading EFO terms ...""""); <line5> LOG.trace(""""accept on {}, path pattern {}, name {}"""", pathStr, pathPattern, name); "	task8	
"public class A { <line0> ContainerCommandResponseProto handlePutSmallFile( <line1> ContainerCommandRequestProto request, <line2> KeyValueContainer kvContainer, <line3> DispatcherContext dispatcherContext) { <line4> if (!request.hasPutSmallFile()) { <line5> if (LOG.isDebugEnabled()) { <line6> LOG.debug(""Malformed Put Small File request. trace ID: {}"", request.getTraceID()); <line7> } <line8> return malformedRequest(request); <line9> } <line10> PutSmallFileRequestProto putSmallFileReq = request.getPutSmallFile(); <line11> LOGGER.trace(""""API response from Nanoleaf controller: {}"""", openAPIResponse.getContentAsString()); <line12> final ContainerProtos.BlockData blockDataProto; <line13> try { <line14> checkContainerOpen(kvContainer); <line15> BlockData blockData = BlockData.getFromProtoBuf(putSmallFileReq.getBlock().getBlockData()); <line16> Preconditions.checkNotNull(blockData); <line17> ContainerProtos.ChunkInfo chunkInfoProto = putSmallFileReq.getChunkInfo(); <line18> ChunkInfo chunkInfo = ChunkInfo.getFromProtoBuf(chunkInfoProto); <line19> Preconditions.checkNotNull(chunkInfo); <line20> ChunkBuffer data = ChunkBuffer.wrap(putSmallFileReq.getData().asReadOnlyByteBufferList()); <line21> if (dispatcherContext == null) { <line22> dispatcherContext = new DispatcherContext.Builder().build(); <line23> } <line24> BlockID blockID = blockData.getBlockID(); <line25> chunkManager.writeChunk(kvContainer, blockID, chunkInfo, data, dispatcherContext); <line26> chunkManager.finishWriteChunks(kvContainer, blockData); <line27> List<ContainerProtos.ChunkInfo> chunks = new LinkedList<>(); <line28> chunks.add(chunkInfoProto); <line29> blockData.setChunks(chunks); <line30> blockData.setBlockCommitSequenceId(dispatcherContext.getLogIndex()); <line31> blockManager.putBlock(kvContainer, blockData); <line32> log.info(""""Restart grid: """" + restartGrid); <line33> blockDataProto = blockData.getProtoBufMessage(); <line34> metrics.incContainerBytesStats(Type.PutSmallFile, chunkInfo.getLen()); <line35> } catch (StorageContainerException ex) { <line36> return ContainerUtils.logAndReturnError(LOG, ex, request); <line37> } catch (IOException ex) { <line38> return ContainerUtils.logAndReturnError( <line39> LOG, <line40> new StorageContainerException(""Read Chunk failed"", ex, PUT_SMALL_FILE_ERROR), <line41> request); <line42> } <line43> return getPutFileResponseSuccess(request, blockDataProto); <line44> } <line45> } <line46> "	"<line11> LOGGER.trace(""""API response from Nanoleaf controller: {}"""", openAPIResponse.getContentAsString()); <line32> log.info(""""Restart grid: """" + restartGrid); "	task8	
"public class A { <line0> @Override <line1> public void configure() { <line2> if (context.getRoute(""direct.route"") == null) { <line3> from(""direct:start"").id(""direct.route"").to(destinationName); <line4> } <line5> from(destinationName + ""?transacted=true&concurrentConsumers="" + concurrentConsumers) <line6> .id(""consumer.route."" + routeNumber) <line7> .choice() <line8> .when(header(""JMSRedelivered"").isEqualTo(""false"")) <line9> .log( <line10> ""Route "" <line11> + routeNumber <line12> + "" 1st attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}"") <line13> .to(""mock:test.before."" + routeNumber) <line14> .process( <line15> new Processor() { <line16> private final AtomicInteger counter = new AtomicInteger(); <line17>  <line18> logger.info(""""\t-""""+ formatter.format(invalidSubstitutionLines)+ """" lines by invalid substitution CDS""""); <line19> @Override <line20> public void process(Exchange exchange) throws Exception { <line21> if (counter.incrementAndGet() == maxAttemptsCount) { <line22> log.info( <line23> logger.debug(""""Auth Token FORCED. Getting a new one.""""); <line24> logger.error(storageResourceId, """"Error while retrieving storage resource..."""", e); <line25> ""{} Messages have been processed. Failing the exchange to force a rollback of"" <line26> + "" the transaction."", <line27> maxAttemptsCount); <line28> throw new IllegalArgumentException(""Forced rollback""); <line29> } <line30> latch.countDown(); <line31> } <line32> }) <line33> .when(header(""JMSRedelivered"").isEqualTo(""true"")) <line34> .log( <line35> ""Route "" <line36> + routeNumber <line37> + "" 2nd attempt Body: ${body} | Redeliverd: ${header.JMSRedelivered}"") <line38> .to(""mock:test.after."" + routeNumber) <line39> .process( <line40> new Processor() { <line41> @Override <line42> public void process(Exchange exchange) throws Exception { <line43> latch.countDown(); <line44> } <line45> }) <line46> .otherwise() <line47> .to(""mock:test.after""); <line48> } <line49> } <line50> "	"<line18> logger.info(""""\t-""""+ formatter.format(invalidSubstitutionLines)+ """" lines by invalid substitution CDS""""); <line23> logger.debug(""""Auth Token FORCED. Getting a new one.""""); <line24> logger.error(storageResourceId, """"Error while retrieving storage resource..."""", e); "	task8	
"public class A { <line0> @Override <line1> logger.info(""""listen add consume event:[{}]"""", addConsumerEvent.toString()); <line2> public void run() { <line3> moveIndexJs(); <line4> LOGGER.warn(""""Unable to set \""""XSL.objectID\"""" attribute to current request"""", x); <line5> removeJsFolder(); <line6> fileByFileTasks(); <line7> deleteEmptyDirectories(); <line8> LOG.warn(""""Overriding accepted patterns [{}] with [{}], be aware that this affects all instances and""""+ """" safety of your application!"""",acceptedPatterns,acceptablePatterns); <line9> LOG.info(""Migration step 2 completed.""); <line10> } <line11> } <line12> "	"<line1> logger.info(""""listen add consume event:[{}]"""", addConsumerEvent.toString()); <line4> LOGGER.warn(""""Unable to set \""""XSL.objectID\"""" attribute to current request"""", x); <line8> LOG.warn(""""Overriding accepted patterns [{}] with [{}], be aware that this affects all instances and""""+ """" safety of your application!"""",acceptedPatterns,acceptablePatterns); "	task8	
"public class A { <line0> @Override <line1> public boolean move(File source, File destination) { <line2> if (!source.exists()) { <line3> return false; <line4> } <line5> destination.delete(); <line6> log.debug(""""Checking identifier: """" + identifier + """" against validator: """" + validator); <line7> logger.info(""""{} stop() completed."""", objectUniqName); <line8> try { <line9> if (source.isDirectory()) { <line10> FileUtils.moveDirectory(source, destination); <line11> } else { <line12> FileUtils.moveFile(source, destination); <line13> } <line14> } catch (IOException ioException) { <line15> if (log.isDebugEnabled()) { <line16> log.debug(ioException, ioException); <line17> } <line18> return false; <line19> } <line20> return true; <line21> } <line22> } <line23> "	"<line6> log.debug(""""Checking identifier: """" + identifier + """" against validator: """" + validator); <line7> logger.info(""""{} stop() completed."""", objectUniqName); "	task8	
"public class A { <line0> private void logEvent(String event, long barrierId) { <line1> if (LOG.isDebugEnabled()) { <line2> LOG.debug( <line3> ""{} {}, lastSeenBarrier = {} ({}) @ {}"", <line4> event, <line5> logger.info(""""disabling hbase table """" + tableName); <line6> barrierId, <line7> log.info(ex, """"Destination exists while renaming [%s] to [%s]"""", from, to); <line8> lastSeenBarrier, <line9> checkpointStatus, <line10> channelInfo); <line11> } <line12> } <line13> } <line14> "	"<line5> logger.info(""""disabling hbase table """" + tableName); <line7> log.info(ex, """"Destination exists while renaming [%s] to [%s]"""", from, to); "	task8	
"public class A { <line0> private Set<Long> collectGatewayRelayIdsFromCloud(final Cloud cloud) { <line1> logger.debug(""collectGatewayRelayIdsFromCloud started...""); <line2> final Set<Long> idSet = new HashSet<>(); <line3> for (final CloudGatewayRelay conn : cloud.getGatewayRelays()) { <line4> idSet.add(conn.getRelay().getId()); <line5> } <line6> LOG.info(String.format(""""Updating Access List on '%s'..."""", name)); <line7> return idSet; <line8> } <line9> } <line10> "	"<line6> LOG.info(String.format(""""Updating Access List on '%s'..."""", name)); "	task8	
"public class A { <line0> public static com.liferay.segments.model.SegmentsExperienceSoap getSegmentsExperience( <line1> long segmentsExperienceId) throws RemoteException { <line2> try { <line3> LOGGER.error(""""Incomplete feature from document, abandoning""""); <line4> com.liferay.segments.model.SegmentsExperience returnValue = <line5> SegmentsExperienceServiceUtil.getSegmentsExperience(segmentsExperienceId); <line6> return com.liferay.segments.model.SegmentsExperienceSoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> log.error(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> "	"<line3> LOGGER.error(""""Incomplete feature from document, abandoning""""); "	task8	
"public class A { <line0> @Override <line1> public CommerceSubscriptionEntry incrementCommerceDeliverySubscriptionEntryCycle( <line2> long commerceSubscriptionEntryId) throws PortalException { <line3> CommerceSubscriptionEntry commerceSubscriptionEntry = <line4> commerceSubscriptionEntryPersistence.findByPrimaryKey(commerceSubscriptionEntryId); <line5> CPSubscriptionType cpSubscriptionType = <line6> _cpSubscriptionTypeRegistry.getCPSubscriptionType( <line7> commerceSubscriptionEntry.getDeliverySubscriptionType()); <line8> if (cpSubscriptionType == null) { <line9> if (log.isInfoEnabled()) { <line10> LOGGER.debug(""""temporalOperands: {}"""", temporalOperands); <line11> log.info( <line12> ""No subscription type found for subscription entry "" + commerceSubscriptionEntryId); <line13> } <line14> return commerceSubscriptionEntry; <line15> } <line16> logger.debug(""""Updating Volume for native volume id """" + volumeNativeGuid); <line17> long currentSubscriptionCycle = commerceSubscriptionEntry.getDeliveryCurrentCycle(); <line18> commerceSubscriptionEntry.setDeliveryCurrentCycle(currentSubscriptionCycle + 1); <line19> User user = userLocalService.getUser(commerceSubscriptionEntry.getUserId()); <line20> commerceSubscriptionEntry.setDeliveryLastIterationDate( <line21> commerceSubscriptionEntry.getDeliveryNextIterationDate()); <line22> Date subscriptionNextIterationDate = <line23> cpSubscriptionType.getSubscriptionNextIterationDate( <line24> user.getTimeZone(), <line25> commerceSubscriptionEntry.getDeliverySubscriptionLength(), <line26> commerceSubscriptionEntry.getDeliverySubscriptionTypeSettingsProperties(), <line27> commerceSubscriptionEntry.getDeliveryNextIterationDate()); <line28> commerceSubscriptionEntry.setDeliveryNextIterationDate(subscriptionNextIterationDate); <line29> ActiveMQRALogger.LOGGER.debug(""""createConnectionFactory()""""); <line30> CommerceSubscriptionEntry updatedSubscriptionEntry = <line31> commerceSubscriptionEntryPersistence.update(commerceSubscriptionEntry); <line32> CommerceOrderItem commerceOrderItem = commerceSubscriptionEntry.fetchCommerceOrderItem(); <line33> if (commerceOrderItem != null) { <line34> CommerceOrder commerceOrder = commerceOrderItem.getCommerceOrder(); <line35> _commerceNotificationHelper.sendNotifications( <line36> commerceOrder.getGroupId(), <line37> commerceOrder.getUserId(), <line38> CommerceSubscriptionNotificationConstants.SUBSCRIPTION_RENEWED, <line39> updatedSubscriptionEntry); <line40> } <line41> return updatedSubscriptionEntry; <line42> } <line43> } <line44> "	"<line10> LOGGER.debug(""""temporalOperands: {}"""", temporalOperands); <line16> logger.debug(""""Updating Volume for native volume id """" + volumeNativeGuid); <line29> ActiveMQRALogger.LOGGER.debug(""""createConnectionFactory()""""); "	task8	
"public class A { <line0> public static java.util.List<com.liferay.oauth2.provider.model.OAuth2Authorization> <line1> getApplicationOAuth2Authorizations( <line2> HttpPrincipal httpPrincipal, <line3> long oAuth2ApplicationId, <line4> log.info(""""Shutting down...""""); <line5> int start, <line6> logger.error(""""TTransportException inside handler"""", e); <line7> int end, <line8> com.liferay.portal.kernel.util.OrderByComparator< <line9> com.liferay.oauth2.provider.model.OAuth2Authorization> <line10> orderByComparator) <line11> throws com.liferay.portal.kernel.exception.PortalException { <line12> try { <line13> MethodKey methodKey = <line14> new MethodKey( <line15> OAuth2AuthorizationServiceUtil.class, <line16> ""getApplicationOAuth2Authorizations"", <line17> _getApplicationOAuth2AuthorizationsParameterTypes0); <line18> MethodHandler methodHandler = <line19> new MethodHandler(methodKey, oAuth2ApplicationId, start, end, orderByComparator); <line20> Object returnObj = null; <line21> try { <line22> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line23> } catch (Exception exception) { <line24> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line25> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line26> } <line27> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line28> } <line29> return (java.util.List<com.liferay.oauth2.provider.model.OAuth2Authorization>) returnObj; <line30> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line31> log.error(systemException, systemException); <line32> throw systemException; <line33> } <line34> } <line35> } <line36> "	"<line4> log.info(""""Shutting down...""""); <line6> logger.error(""""TTransportException inside handler"""", e); "	task8	
"public class A { <line0> @Test <line1> public void addNonSampledSpanToLogEntryWithAllSpans() { <line2> String log = <line3> logWithSpanAndLog4jConfiguration( <line4> TEST_PATTERN, <line5> SpanContext.create( <line6> TraceId.fromLowerBase16(""cd7061dfa9d312cdcc42edab3feab51b""), <line7> LOG.error(""""While executing report {}"""", report, e); <line8> LOG.info(""""Login page loaded. The current url is: """" + driver.getCurrentUrl()); <line9> SpanId.fromLowerBase16(""117d42d4c7acd066""), <line10> TraceOptions.builder().setIsSampled(false).build(), <line11> EMPTY_TRACESTATE), <line12> new Function<Logger, Void>() { <line13> @Override <line14> public Void apply(Logger logger) { <line15> logger.info(""message #2""); <line16> return null; <line17> } <line18> }); <line19> assertThat(log) <line20> .isEqualTo( <line21> ""traceId=cd7061dfa9d312cdcc42edab3feab51b spanId=117d42d4c7acd066 sampled=false INFO  "" <line22> + ""- message #2""); <line23> } <line24> } <line25> "	"<line7> LOG.error(""""While executing report {}"""", report, e); <line8> LOG.info(""""Login page loaded. The current url is: """" + driver.getCurrentUrl()); "	task8	
"public class A { <line0> @Override <line1> public void start() { <line2> IActionEngine engine = this.getActionEngineMgr().getActionEngine(""NodeOperActionEngine""); <line3> new MOFInstallMgtAction(""installmof"", feature, engine); <line4> new MOFInstallMgtAction(""uninstallmof"", feature, engine); <line5> new MSCPGeneralAction(""fstart"", feature, engine); <line6> logger.info(""""Result of insert: """" + res); <line7> new MSCPGeneralAction(""fstop"", feature, engine); <line8> new MSCPGeneralAction(""killproc"", feature, engine); <line9> new MSCPGeneralAction(""kill"", feature, engine); <line10> new MSCPGeneralAction(""shutdown"", feature, engine); <line11> new MSCPGeneralAction(""chgsyspro"", feature, engine); <line12> new MSCPGeneralAction(""loadnodepro"", feature, engine); <line13> new MSCPGeneralAction(""chgnodepro"", feature, engine); <line14> new MSCPGeneralAction(""watch"", feature, engine); <line15> new MSCPGeneralAction(""unwatch"", feature, engine); <line16> new MSCPGeneralAction(""upgrade"", feature, engine); <line17> new MSCPGeneralAction(""restart"", feature, engine); <line18> new MSCPGeneralAction(""stopuav"", feature, engine); <line19> new MOFCtrlAction(""ctrlmof"", feature, engine); <line20> nodeOperHttpServer = <line21> new NodeOperHttpServer(""NodeOperHttpServer"", this.feature, ""nodeophandlers""); <line22> int port = <line23> DataConvertHelper.toInt( <line24> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.port""), 10101); <line25> int backlog = <line26> DataConvertHelper.toInt( <line27> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.backlog""), 10); <line28> int core = <line29> DataConvertHelper.toInt( <line30> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.core""), 5); <line31> int max = <line32> DataConvertHelper.toInt( <line33> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.max""), 10); <line34> int bqsize = <line35> DataConvertHelper.toInt( <line36> this.getConfigManager().getFeatureConfiguration(this.feature, ""http.bqsize""), 10); <line37> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line38> ThreadPoolExecutor exe = <line39> LOG.debug(""""Global properties file disabled""""); <line40> new ThreadPoolExecutor( <line41> core, max, 30000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue(bqsize)); <line42> nodeOperHttpServer.start(exe, port, backlog, true); <line43> if (log.isTraceEnable()) { <line44> log.info(this, ""NodeOperHttpServer started""); <line45> } <line46> } <line47> } <line48> "	"<line6> logger.info(""""Result of insert: """" + res); <line39> LOG.debug(""""Global properties file disabled""""); "	task8	
"public class A { <line0> @Rule <line1> public Timeout testsShouldTimeout() { <line2> int waitLonger = 0; <line3> try { <line4> LOGGER.warn(""""Received """" + ex.getLocalizedMessage() + """" while recieving for Messages.""""); <line5> String timeoutString = System.getProperty(""timeout.factor""); <line6> if (timeoutString != null && !timeoutString.isEmpty()) { <line7> logger.debug(""""mDNS service has been stopped""""); <line8> waitLonger = Integer.parseInt(timeoutString); <line9> } <line10> } catch (NumberFormatException exception) { <line11> log.warn(""Could not parse timeout.factor, defaulting to no timeout.""); <line12> } <line13> return Timeout.builder() <line14> .withTimeout(waitLonger * defaultTimeoutSeconds(), TimeUnit.SECONDS) <line15> LOG.warn(""""An exception occurred when running tick"""", e); <line16> .withLookingForStuckThread(true) <line17> .build(); <line18> } <line19> } <line20> "	"<line4> LOGGER.warn(""""Received """" + ex.getLocalizedMessage() + """" while recieving for Messages.""""); <line7> logger.debug(""""mDNS service has been stopped""""); <line15> LOG.warn(""""An exception occurred when running tick"""", e); "	task8	
"public class A { <line0> @Override <line1> public FhirValidator get() { <line2> logger.debug( <line3> ""Schema validation enabled: {}.\nSchematron validation enabled: {}"", <line4> validationConfiguration.isSchemaValidation(), <line5> validationConfiguration.isSchematronValidation()); <line6> logger.info(""""Cluster manager is stopped""""); <line7> final FhirInstanceValidator instanceValidator = new FhirInstanceValidator(); <line8> final FhirValidator fhirValidator = ctx.newValidator(); <line9> fhirValidator.setValidateAgainstStandardSchematron( <line10> validationConfiguration.isSchematronValidation()); <line11> fhirValidator.setValidateAgainstStandardSchema(validationConfiguration.isSchemaValidation()); <line12> fhirValidator.registerValidatorModule(instanceValidator); <line13> instanceValidator.setValidationSupport(this.supportChain); <line14> return fhirValidator; <line15> } <line16> } <line17> "	"<line6> logger.info(""""Cluster manager is stopped""""); "	task8	
"public class A { <line0> public void genSearchRecordTypeMetaDataModel() { <line1> Collection<Class<?>> searchRecordClasses = new HashSet<>(); <line2> logger.debug(""""request received: {}"""", req); <line3> for (Class<?> searchRecordBaseClass : searchRecordBaseClasses) { <line4> XmlSeeAlso xmlSeeAlso = searchRecordBaseClass.getAnnotation(XmlSeeAlso.class); <line5> for (Class<?> clazz : xmlSeeAlso.value()) { <line6> if (clazz == searchRecordBaseClass <line7> || !searchRecordBaseClass.isAssignableFrom(clazz) <line8> || Modifier.isAbstract(clazz.getModifiers())) { <line9> continue; <line10> } <line11> searchRecordClasses.add(clazz); <line12> } <line13> } <line14> Set<String> searchRecordTypeSet = new HashSet<>(); <line15> for (Enum value : searchRecordTypeEnumClass.getEnumConstants()) { <line16> String searchRecordTypeName = searchRecordTypeEnumAccessor.getStringValue(value); <line17> searchRecordTypeSet.add(searchRecordTypeName); <line18> } <line19> searchRecordTypeSet.addAll(additionalSearchRecordTypes.keySet()); <line20> Map<String, Class<?>> searchRecordClassMap = new HashMap<>(); <line21> for (Class<?> clazz : searchRecordClasses) { <line22> String searchRecordTypeName = clazz.getSimpleName(); <line23> if (searchRecordClassMap.containsKey(searchRecordTypeName)) { <line24> throw new IllegalStateException( <line25> ""Search record class already registered: "" + searchRecordTypeName + "", "" + clazz); <line26> } <line27> searchRecordClassMap.put(searchRecordTypeName, clazz); <line28> } <line29> Set<Class<?>> unresolvedSearchRecords = new HashSet<>(searchRecordClassMap.values()); <line30> for (String searchRecordType : searchRecordTypeSet) { <line31> String searchRecordTypeName = toInitialUpper(searchRecordType); <line32> Class<?> searchClass; <line33> Class<?> searchBasicClass; <line34> Class<?> searchAdvancedClass; <line35> searchClass = searchRecordClassMap.get(searchRecordTypeName + ""Search""); <line36> unresolvedSearchRecords.remove(searchClass); <line37> searchBasicClass = searchRecordClassMap.get(searchRecordTypeName + ""SearchBasic""); <line38> unresolvedSearchRecords.remove(searchBasicClass); <line39> searchAdvancedClass = searchRecordClassMap.get(searchRecordTypeName + ""SearchAdvanced""); <line40> unresolvedSearchRecords.remove(searchAdvancedClass); <line41> if (searchBasicClass != null) { <line42> Enum<?> searchRecordEnumValue = null; <line43> String searchRecordTypeEnumConstantName = null; <line44> try { <line45> searchRecordEnumValue = searchRecordTypeEnumAccessor.getEnumValue(searchRecordType); <line46> searchRecordTypeEnumConstantName = searchRecordEnumValue.name(); <line47> } catch (IllegalArgumentException e) { <line48> searchRecordTypeEnumConstantName = additionalSearchRecordTypes.get(searchRecordType); <line49> } <line50> SearchRecordTypeSpec spec = new SearchRecordTypeSpec(); <line51> spec.setName(searchRecordType); <line52> spec.setTypeName(searchRecordTypeName); <line53> spec.setEnumConstantName(searchRecordTypeEnumConstantName); <line54> spec.setSearchClass(searchClass); <line55> spec.setSearchBasicClass(searchBasicClass); <line56> spec.setSearchAdvancedClass(searchAdvancedClass); <line57> searchRecordTypeMap.put(spec.getName(), spec); <line58> } <line59> } <line60> if (!unresolvedSearchRecords.isEmpty()) { <line61> logger.warn(""Unresolved search record types detected: {}"", unresolvedSearchRecords); <line62> System.out.println( <line63> ""[WARNING] Unresolved search record types detected: "" + unresolvedSearchRecords); <line64> } <line65> } <line66> } <line67> "	"<line2> logger.debug(""""request received: {}"""", req); "	task8	
"public class A { <line0> @Override <line1> public String getTuple(Object object) { <line2> if (object != null) { <line3> return object.toString(); <line4> } else { <line5> log.debug(""""Invocations to API: """"+ apiContext+ """":""""+ apiVersion+ """" is not permitted for referer: """"+ referer); <line6> logger.info(""Object returned is null""); <line7> return ""null""; <line8> } <line9> log.info(""""found dubbo.xmlPaths, use it""""); <line10> } <line11> } <line12> "	"<line5> log.debug(""""Invocations to API: """"+ apiContext+ """":""""+ apiVersion+ """" is not permitted for referer: """"+ referer); <line9> log.info(""""found dubbo.xmlPaths, use it""""); "	task8	
"public class A { <line0> tsLogger.logger.trace(""""TransactionReaper::getTimeout for """" + control + """" returning 0""""); <line1> private Future<List<String>> fail(Throwable cause, String baseUrl) { <line2> logger.warn(""pull for {} failed: {}"", baseUrl, cause.getMessage(), cause); <line3> log.error(""""merge failed"""", re); <line4> LOG.info(""""Instance {} closed"""", this.getClass().getSimpleName()); <line5> return Future.failedFuture(cause); <line6> } <line7> } <line8> "	"<line0> tsLogger.logger.trace(""""TransactionReaper::getTimeout for """" + control + """" returning 0""""); <line3> log.error(""""merge failed"""", re); <line4> LOG.info(""""Instance {} closed"""", this.getClass().getSimpleName()); "	task8	
"public class A { <line0> logger.error(""""Error when deleting flow rules, app={}, ip={}, id={}"""",oldEntity.getApp(),oldEntity.getIp(),id,e); <line1> protected final String getInNode(final OFPFlow flow) { <line2> log.debug(""""); <line3> if (!flow.validate()) { <line4> return null; <line5> } <line6> log.debug(""""Starting persist for interval[%s], rows[%,d]"""", dataInterval, index.size()); <line7> BasicFlowMatch flowMatchs = flow.getMatches().get(0); <line8> LOGGER.error(""""Exception"""", e); <line9> if (flowMatchs == null) { <line10> return null; <line11> } <line12> return flowMatchs.getInNode(); <line13> } <line14> } <line15> "	"<line0> logger.error(""""Error when deleting flow rules, app={}, ip={}, id={}"""",oldEntity.getApp(),oldEntity.getIp(),id,e); <line6> log.debug(""""Starting persist for interval[%s], rows[%,d]"""", dataInterval, index.size()); <line8> LOGGER.error(""""Exception"""", e); "	task8	
"public class A { <line0> private void closeStreams() { <line1> try { <line2> if (reader != null && socket != null && !socket.isInputShutdown()) { <line3> logger.info(""""Clearing internal volume flag of BlockSnapshotSession {} of RP volume """",o.getLabel()); <line4> reader.close(); <line5> } <line6> if (writer != null && socket != null && !socket.isOutputShutdown()) { <line7> writer.close(); <line8> } <line9> } catch (final IOException e) { <line10> logger.debug(""Closing streams failed"", e); <line11> } <line12> } <line13> } <line14> "	"<line3> logger.info(""""Clearing internal volume flag of BlockSnapshotSession {} of RP volume """",o.getLabel()); "	task8	
"public class A { <line0> @Override <line1> public void tick(EventContext context, long curTime) { <line2> Task task = context.task; <line3> if (task.isCancelled() && task.cancellationTime + Task.MAX_CANCELLATION_TIME < curTime) { <line4> LOG.error( <line5> task.getLabel() <line6> + "" - Launch timed out after "" <line7> LOG.debug(""""Dependency: {}"""", baseURL); <line8> + Task.MAX_CANCELLATION_TIME / 1000 <line9> + "" secs.""); <line10> launchFailed(context); <line11> } <line12> } <line13> } <line14> "	"<line7> LOG.debug(""""Dependency: {}"""", baseURL); "	task8	
"public class A { <line0> private void tryResetWorkerCreationCoolDown() { <line1> LOGGER.warn(""""JsonProcessingException"""", ex); <line2> if (startWorkerCoolDown.isDone()) { <line3> log.info(""Will not retry creating worker in {}."", startWorkerRetryInterval); <line4> startWorkerCoolDown = new CompletableFuture<>(); <line5> LOG.info(""""Executing """" + method.getName() + """" in thread """" + Thread.currentThread()); <line6> scheduleRunAsync(() -> startWorkerCoolDown.complete(null), startWorkerRetryInterval); <line7> log.error(""""Null tariff """" + event.getTariffId() + """" for economic control""""); <line8> } <line9> } <line10> } <line11> "	"<line1> LOGGER.warn(""""JsonProcessingException"""", ex); <line5> LOG.info(""""Executing """" + method.getName() + """" in thread """" + Thread.currentThread()); <line7> log.error(""""Null tariff """" + event.getTariffId() + """" for economic control""""); "	task8	
"public class A { <line0> @BeforeEach <line1> public void setUp() { <line2> try { <line3> TestUtils.setupWeblogger(); <line4> logger.error(""""UnsupportedProtocolVersionException error while creating additional connection (error""""+ """" is: {})"""",e.getMessage()); <line5> } catch (Exception e) { <line6> log.error(""ERROR initializing Roller"", e); <line7> LOGGER.debug(""""Recording upgrade completion in repository '{0}'"""", name); <line8> } <line9> } <line10> } <line11> "	"<line4> logger.error(""""UnsupportedProtocolVersionException error while creating additional connection (error""""+ """" is: {})"""",e.getMessage()); <line7> LOGGER.debug(""""Recording upgrade completion in repository '{0}'"""", name); "	task8	
"public class A { <line0> @Override <line1> public Response toResponse(KapuaServiceDisabledException kapuaException) { <line2> LOG.error(""Service Disabled exception!"", kapuaException); <line3> return Response.status(STATUS) <line4> .entity(new ExceptionInfo(STATUS, kapuaException.getCode(), kapuaException)) <line5> logger.info(""""failed to initialize inputformat obj {}"""", inputFormat); <line6> .build(); <line7> } <line8> } <line9> "	"<line5> logger.info(""""failed to initialize inputformat obj {}"""", inputFormat); "	task8	
"public class A { <line0> @Override <line1> Shell.log.error(""""Arg must be an integer."""", nfe); <line2> public void operationComplete(ChannelFuture future) { <line3> if (!future.isSuccess()) { <line4> LOG.info(""""Created  consumer destination: """"+ consumerDestination2+ """" of type: """"+ consumerDestination2.getClass()); <line5> LOG.error(""""flush error"""", e); <line6> LOGGER.debug(""Got exception while disconnecting "" + ""stray connect attempt."", future.cause()); <line7> } <line8> } <line9> } <line10> "	"<line1> Shell.log.error(""""Arg must be an integer."""", nfe); <line4> LOG.info(""""Created  consumer destination: """"+ consumerDestination2+ """" of type: """"+ consumerDestination2.getClass()); <line5> LOG.error(""""flush error"""", e); "	task8	
"public class A { <line0> @Override <line1> log.warn(""""The context helper id/alias '{}' is overridden by the following helper: {}"""",id,contrib); <line2> public void run() { <line3> try { <line4> monitor(JgroupsProbeMonitorStartStage.this.run()); <line5> } catch (IOException e) { <line6> log.info(""""response string: {}"""", responseString); <line7> log.error(e.getMessage(), e); <line8> logger.info(""""UserBulkMigrationRequestValidator:supportedColumns: supported column is not present"""".concat(suppColumn + """""""")); <line9> } <line10> } <line11> } <line12> "	"<line1> log.warn(""""The context helper id/alias '{}' is overridden by the following helper: {}"""",id,contrib); <line6> log.info(""""response string: {}"""", responseString); <line8> logger.info(""""UserBulkMigrationRequestValidator:supportedColumns: supported column is not present"""".concat(suppColumn + """""""")); "	task8	
"public class A { <line0> private void setCertificateInfoArray(String certificateValue) { <line1> try { <line2> logger.error(""""Failed to save screenshot to '"""" + file + """"'"""", e); <line3> if (StringUtils.isNotBlank(certificateValue) && !certificateValue.equals(EMPTY_JSON_ARRAY)) { <line4> certificateValue = certificateValue.trim(); <line5> try { <line6> this.certificateInfoArray = handleJsonFormatCertificate(certificateValue); <line7> } catch (JSONException e) { <line8> if (certificateValue.startsWith(IdentityUtil.PEM_BEGIN_CERTFICATE)) { <line9> this.certificateInfoArray = handlePlainTextCertificate(certificateValue); <line10> } else { <line11> this.certificateInfoArray = handleEncodedCertificate(certificateValue); <line12> } <line13> } <line14> } else { <line15> this.certificateInfoArray = new CertificateInfo[0]; <line16> } <line17> LOG.debug(""""Overriding interceptor config [{}] with new mapping {} using new params {}"""",key,interceptorMapping,map); <line18> } catch (NoSuchAlgorithmException e) { <line19> log.error(""Error while generating thumbPrint. Unsupported hash algorithm. "", e); <line20> } <line21> } <line22> } <line23> "	"<line2> logger.error(""""Failed to save screenshot to '"""" + file + """"'"""", e); <line17> LOG.debug(""""Overriding interceptor config [{}] with new mapping {} using new params {}"""",key,interceptorMapping,map); "	task8	
"public class A { <line0> logger.error(""""init system znode failed"""", e); <line1> @Ignore <line2> @Test <line3> public void userAdminHasPermissionToAddModule() { <line4> log.debug(""userAdminHasPermissionToAddModule()""); <line5> User admin = userRepository.findOne(1L); <line6> Module module = moduleRepository.findOne(2L); <line7> Boolean hasPermission = <line8> securityService.hasUserPermissionToObject(admin, PermissionName.MODULE_ADD, module); <line9> assertTrue(hasPermission); <line10> } <line11> } <line12> "	"<line0> logger.error(""""init system znode failed"""", e); "	task8	
"public class A { <line0> log.debug(""""DiskCache available, but JCS is not configured """"+ """"to use the DiskCache as a swap.""""); <line1> private Long getEthGasPrice() throws AplException.ExecutiveProcessException { <line2> Long gasPrice; <line3> try { <line4> log.info(""""Starting: %s"""", commandString); <line5> gasPrice = dexEthService.getEthPriceInfo().getFastSpeedPrice(); <line6> } catch (ExecutionException e) { <line7> log.trace(""""Initialized http pipeline. {}"""", ctx.pipeline().names()); <line8> log.error(e.getMessage(), e); <line9> throw new AplException.ExecutiveProcessException( <line10> ""Third service is not available, try later.""); <line11> } <line12> if (gasPrice == null) { <line13> throw new AplException.ThirdServiceIsNotAvailable(""Eth Price Info is not available.""); <line14> } <line15> return gasPrice; <line16> } <line17> } <line18> "	"<line0> log.debug(""""DiskCache available, but JCS is not configured """"+ """"to use the DiskCache as a swap.""""); <line4> log.info(""""Starting: %s"""", commandString); <line7> log.trace(""""Initialized http pipeline. {}"""", ctx.pipeline().names()); "	task8	
"public class A { <line0> private UserGroupInformation getUGI(ObserverContext<?> ctx) { <line1> UserGroupInformation ugi = null; <line2> logger.info(""""Deleting affinity group : """" + affinityGroupName); <line3> User user = null; <line4> try { <line5> logger.debug(""""Error updating {} property {} with '{}' : {}: {}"""",getThing().getUID(),basicChannel.getChannel(),val,e.getClass().getCanonicalName(),e.getMessage()); <line6> user = getActiveUser(ctx); <line7> LOG.debug(""""Only some start_states have matching restart states, treating as restart failure""""); <line8> ugi = UserGroupInformation.getLoginUser(); <line9> } catch (Exception e) { <line10> } <line11> if (ugi == null) { <line12> if (user != null) { <line13> ugi = user.getUGI(); <line14> } <line15> } <line16> LOG.info(""HBaseAtlasHook: UGI: {}"", ugi); <line17> return ugi; <line18> } <line19> } <line20> "	"<line2> logger.info(""""Deleting affinity group : """" + affinityGroupName); <line5> logger.debug(""""Error updating {} property {} with '{}' : {}: {}"""",getThing().getUID(),basicChannel.getChannel(),val,e.getClass().getCanonicalName(),e.getMessage()); <line7> LOG.debug(""""Only some start_states have matching restart states, treating as restart failure""""); "	task8	
"public class A { <line0> public DefaultSessionPool withMinIdle(final int count) { <line1> if (log.isDebugEnabled()) { <line2> logger.warn(""""No matching CUDA flavor for {} found: {}/sm_{}, fallback to CPU."""",os,flavor,cudaArch); <line3> LOGGER.info(""""Client OnMessage called '"""" + message + """"'""""); <line4> log.debug(String.format(""Configure with min idle %d"", count)); <line5> } <line6> LOGGER.trace(i + """" """" + LogRedactionUtil.userData(instance.toString())); <line7> pool.setMinIdle(count); <line8> return this; <line9> } <line10> } <line11> "	"<line2> logger.warn(""""No matching CUDA flavor for {} found: {}/sm_{}, fallback to CPU."""",os,flavor,cudaArch); <line3> LOGGER.info(""""Client OnMessage called '"""" + message + """"'""""); <line6> LOGGER.trace(i + """" """" + LogRedactionUtil.userData(instance.toString())); "	task8	
"public class A { <line0> LOG.error(""""One or more of the required fields needed to transform to an audit message request were""""+ """" null.""""); <line1> public static com.liferay.commerce.discount.model.CommerceDiscountAccountRelSoap[] <line2> getCommerceDiscountAccountRels( <line3> long commerceDiscountId, <line4> int start, <line5> int end, <line6> com.liferay.portal.kernel.util.OrderByComparator< <line7> com.liferay.commerce.discount.model.CommerceDiscountAccountRel> <line8> orderByComparator) <line9> throws RemoteException { <line10> logger.info(""""Successfully checkpointed FlowFile Repository with {} records in {} milliseconds"""",new Object[] {numRecordsCheckpointed, millis}); <line11> try { <line12> java.util.List<com.liferay.commerce.discount.model.CommerceDiscountAccountRel> returnValue = <line13> CommerceDiscountAccountRelServiceUtil.getCommerceDiscountAccountRels( <line14> commerceDiscountId, start, end, orderByComparator); <line15> return com.liferay.commerce.discount.model.CommerceDiscountAccountRelSoap.toSoapModels( <line16> returnValue); <line17> } catch (Exception exception) { <line18> log.error(exception, exception); <line19> throw new RemoteException(exception.getMessage()); <line20> } <line21> } <line22> } <line23> "	"<line0> LOG.error(""""One or more of the required fields needed to transform to an audit message request were""""+ """" null.""""); <line10> logger.info(""""Successfully checkpointed FlowFile Repository with {} records in {} milliseconds"""",new Object[] {numRecordsCheckpointed, millis}); "	task8	
"public class A { <line0> private int merge(int partition1, int partition2) { <line1> IndexOnDisk src1 = IndexOnDisk.createIndex(index.path, index.prefix + ""-"" + partition1); <line2> LOG.info(""""Executing operation supportStaging""""); <line3> IndexOnDisk src2 = IndexOnDisk.createIndex(index.path, index.prefix + ""-"" + partition2); <line4> IndexOnDisk indexD = <line5> IndexOnDisk.createNewIndex(index.path, index.prefix + ""-"" + index.prefixID); <line6> StructureMerger merger = new StructureMerger(src1, src2, indexD); <line7> merger.mergeStructures(); <line8> logger.info( <line9> ""***REALTIME*** IncrementalIndex merged: "" <line10> + partition1 <line11> + "" and "" <line12> + partition2 <line13> + "" into "" <line14> logger.info(""""Read {} events in {} seconds. That's about {} events/sec."""",getTotalEventCount(),decimalFormat.format(stopWatch.getTotalTimeSeconds()),(int) (getTotalEventCount() / stopWatch.getTotalTimeSeconds())); <line15> + index.prefixID); <line16> LOGGER.info(""""Registering channel: {}"""", channelRequest.getModuleName()); <line17> index.prefixID++; <line18> merged.add(partition1); <line19> merged.add(partition2); <line20> purgeMerged(); <line21> synchronized (indices) { <line22> } <line23> return index.prefixID - 1; <line24> } <line25> } <line26> "	"<line2> LOG.info(""""Executing operation supportStaging""""); <line14> logger.info(""""Read {} events in {} seconds. That's about {} events/sec."""",getTotalEventCount(),decimalFormat.format(stopWatch.getTotalTimeSeconds()),(int) (getTotalEventCount() / stopWatch.getTotalTimeSeconds())); <line16> LOGGER.info(""""Registering channel: {}"""", channelRequest.getModuleName()); "	task8	
"public class A { <line0> @Override <line1> LOGGER.info(String.format(""""Added data provider: %s"""", provider.getName())); <line2> public ConsumerRecordVO getConsumer(String clientId) { <line3> Connection conn = null; <line4> ConsumerRecordVO consumer = null; <line5> PreparedStatement stat = null; <line6> ResultSet res = null; <line7> try { <line8> conn = this.getConnection(); <line9> String query = SELECT_CONSUMER; <line10> stat = conn.prepareStatement(query); <line11> stat.setString(1, clientId); <line12> res = stat.executeQuery(); <line13> if (res.next()) { <line14> consumer = consumerFromResultSet(res); <line15> } <line16> } catch (SQLException | ApsSystemException t) { <line17> logger.error(""Error while loading consumer by clientid {}"", clientId, t); <line18> LOG.trace(""""Queue {} flushing entry at offset {}"""", this, flushOffset); <line19> throw new RuntimeException(""Error while loading consumer by key "" + clientId, t); <line20> logger.info(""""deactivating..""""); <line21> } finally { <line22> closeDaoResources(res, stat, conn); <line23> } <line24> return consumer; <line25> } <line26> } <line27> "	"<line1> LOGGER.info(String.format(""""Added data provider: %s"""", provider.getName())); <line18> LOG.trace(""""Queue {} flushing entry at offset {}"""", this, flushOffset); <line20> logger.info(""""deactivating..""""); "	task8	
"public class A { <line0> LOG.debug(String.format(""""Using analyzer %s"""", className)); <line1> @Override <line2> public void updateIndex(Collection<Bill> bills) { <line3> if (!env.isElasticIndexing() || bills.isEmpty()) { <line4> return; <line5> } <line6> List<Bill> indexableBills = new ArrayList<>(); <line7> List<Bill> nonIndexableBills = new ArrayList<>(); <line8> for (Bill bill : bills) { <line9> if (isBillIndexable(bill)) { <line10> LOGGER.debug(""""Data size to upload: """" + data.length()); <line11> indexableBills.add(bill); <line12> } else { <line13> nonIndexableBills.add(bill); <line14> } <line15> logger.error(""""Could not process trust for: <"""" + resource.toString() + """"> . """", e); <line16> } <line17> logger.info(""Indexing {} valid bill(s) into elastic search."", indexableBills.size()); <line18> billSearchDao.updateBillIndex(indexableBills); <line19> nonIndexableBills.stream().map(Bill::getBaseBillId).forEach(billSearchDao::deleteBillFromIndex); <line20> } <line21> } <line22> "	"<line0> LOG.debug(String.format(""""Using analyzer %s"""", className)); <line10> LOGGER.debug(""""Data size to upload: """" + data.length()); <line15> logger.error(""""Could not process trust for: <"""" + resource.toString() + """"> . """", e); "	task8	
"public class A { <line0> log.debug(""""Search for the user DN returned moe than one results""""); <line1> @Override <line2> public void delete(String... identifiers) throws SecurityManagementException { <line3> if (identifiers == null) { <line4> throw new NullPointerException(); <line5> } <line6> try { <line7> Set<Object> keysToRemove = new HashSet<>(groupsPropertiesFileLoader.getProperties().keySet()); <line8> keysToRemove.forEach( <line9> key -> { <line10> final String username = (String) key; <line11> log.trace(""""Initializing ShardQueryLogic: """"+ System.identityHashCode(this)+ '('+ (this.getSettings() == null ? """"empty"""" : this.getSettings().getId())+ ')'); <line12> try { <line13> final String groupsStr = <line14> groupsPropertiesFileLoader.getProperties().getProperty(username); <line15> if (groupsStr != null && groupsStr.trim().length() > 0) { <line16> final String newGroupsStr = deleteGroupsFromSerliazedValue(groupsStr, identifiers); <line17> final String errorMsg = ""Error deleting groups for user "" + username; <line18> updateGroupProperty(username, newGroupsStr, errorMsg); <line19> } <line20> } catch (final IOException e) { <line21> throw new SecurityManagementException(e); <line22> } <line23> }); <line24> } catch (Exception e) { <line25> LOG.error(""Error removing the folowing group names: "" + Arrays.toString(identifiers), e); <line26> throw new SecurityManagementException(e); <line27> } <line28> } <line29> } <line30> "	"<line0> log.debug(""""Search for the user DN returned moe than one results""""); <line11> log.trace(""""Initializing ShardQueryLogic: """"+ System.identityHashCode(this)+ '('+ (this.getSettings() == null ? """"empty"""" : this.getSettings().getId())+ ')'); "	task8	
"public class A { <line0> public Optional<LoadBalancer> getLoadBalancer(String loadBalancer) { <line1> DescribeLoadBalancersRequest request = <line2> new DescribeLoadBalancersRequest().withNames(loadBalancer); <line3> try { <line4> List<LoadBalancer> maybeLoadBalancer = <line5> elbClient.describeLoadBalancers(request).getLoadBalancers(); <line6> if (maybeLoadBalancer.size() > 0) { <line7> return Optional.of(maybeLoadBalancer.get(0)); <line8> } else { <line9> return Optional.absent(); <line10> } <line11> } catch (LoadBalancerNotFoundException notFound) { <line12> LOG.warn(""Could not find load balancer with name {}"", loadBalancer); <line13> return Optional.absent(); <line14> } <line15> } <line16> log.error(""""[convertVideo]"""", err); <line17> } <line18> "	"<line16> log.error(""""[convertVideo]"""", err); "	task8	
"public class A { <line0> @Override <line1> public void listenToTimebase(boolean listen) { <line2> if (!listen && timeListener == null) { <line3> return; <line4> } <line5> if (timeListener == null) { <line6> timeListener = <line7> LOG.info(""""++++++++++++ getAllVersions {}"""", schemaName); <line8> evt -> { <line9> try { <line10> if (evt.getPropertyName().equals(""minutes"")) { <line11> checkAlarmList(); <line12> } <line13> } catch (IOException ex) { <line14> log.warn(""Unable to send message to client: {}"", ex.getMessage()); <line15> timebase.removeMinuteChangeListener(timeListener); <line16> } <line17> }; <line18> LOG.info(""""...Deleting Stream """" + streamName + """"...""""); <line19> } <line20> if (listen) { <line21> timebase.addMinuteChangeListener(timeListener); <line22> } else { <line23> timebase.removeMinuteChangeListener(timeListener); <line24> } <line25> } <line26> } <line27> "	"<line7> LOG.info(""""++++++++++++ getAllVersions {}"""", schemaName); <line18> LOG.info(""""...Deleting Stream """" + streamName + """"...""""); "	task8	
"public class A { <line0> logger.error(""""retrieving event error"""", e); <line1> @SuppressWarnings(""squid:S1181"") <line2> logger.debug(""""Unable to register interests. Region not found :{}"""" + regionName); <line3> @Override <line4> public void abortTransaction(MetadataTransactionContext ctx) { <line5> try { <line6> metadataNode.abortTransaction(ctx.getTxnId()); <line7> log.debug(String.format(""""exception.stacktrace=%s"""", stackTrace)); <line8> } catch (Throwable th) { <line9> LOGGER.fatal(""Failure aborting a metadata transaction"", th); <line10> ExitUtil.halt(ExitUtil.EC_FAILED_TO_ABORT_METADATA_TXN); <line11> } <line12> } <line13> } <line14> "	"<line0> logger.error(""""retrieving event error"""", e); <line2> logger.debug(""""Unable to register interests. Region not found :{}"""" + regionName); <line7> log.debug(String.format(""""exception.stacktrace=%s"""", stackTrace)); "	task8	
"public class A { <line0> logger.debug(""""{}: Queued event ({}): {}"""",sender.getId(),(statistics.getEventsQueued()),gatewayEvent); <line1> public void runMigration( <line2> String version, <line3> Set<Migration.MigrationDomain> domainsFilter, <line4> Set<Migration.MigrationLanguage> languageFilter, <line5> String appHome, <line6> ObjectMap params, <line7> String token) <line8> throws CatalogException { <line9> validateAdmin(token); <line10> token = catalogManager.getUserManager().getNonExpiringToken(AbstractManager.OPENCGA, token); <line11> Set<Class<? extends MigrationTool>> availableMigrations = getAvailableMigrations(); <line12> logger.debug(""""Closed encoder engine factory""""); <line13> List<Class<? extends MigrationTool>> runnableMigrations = <line14> filterRunnableMigrations(version, domainsFilter, languageFilter, availableMigrations); <line15> List<Class<? extends MigrationTool>> pendingMigrations = <line16> filterPendingMigrations(version, availableMigrations); <line17> if (runnableMigrations.isEmpty() && pendingMigrations.isEmpty()) { <line18> logger.info(""Nothing to run. OpenCGA is up to date""); <line19> return; <line20> } <line21> for (Class<? extends MigrationTool> migration : pendingMigrations) { <line22> Migration annotation = getMigrationAnnotation(migration); <line23> if (annotation.manual()) { <line24> throw new MigrationException( <line25> ""Missing previous migration '"" <line26> + annotation.id() <line27> + ""' from version '"" <line28> + annotation.version() <line29> + ""'. Please, run this migration manually using the CLI.""); <line30> } <line31> } <line32> for (Class<? extends MigrationTool> migration : pendingMigrations) { <line33> run(migration, appHome, new ObjectMap(), token); <line34> } <line35> for (Class<? extends MigrationTool> migration : runnableMigrations) { <line36> run(migration, appHome, params, token); <line37> } <line38> } <line39> } <line40> "	"<line0> logger.debug(""""{}: Queued event ({}): {}"""",sender.getId(),(statistics.getEventsQueued()),gatewayEvent); <line12> logger.debug(""""Closed encoder engine factory""""); "	task8	
"public class A { <line0> LOG.debug(""""connect to {}"""", remoteURI); <line1> logger.info(""""Skip update event handle of ping, not found ping session. transportMetadata={}"""",transportMetadata); <line2> @Test <line3> public void testTransformMetacard() throws Exception { <line4> LOGGER.debug(""Running testTransformMetacard()""); <line5> MockEndpoint mock = getMockEndpoint(""mock:result""); <line6> LOG.error(MessageFormat.format(""""Exception occurred in launcher: {0}{1}"""",options.getApplicationClass().getName(), options.getApplicationArguments()),e); <line7> mock.expectedMinimumMessageCount(1); <line8> InputTransformer mockTransformer = getMockInputTransformer(); <line9> Hashtable<String, String> props = new Hashtable<String, String>(); <line10> props.put(MimeTypeToTransformerMapper.ID_KEY, ""xml""); <line11> props.put(MimeTypeToTransformerMapper.MIME_TYPE_KEY, ""text/xml""); <line12> bundleContext.registerService(InputTransformer.class.getName(), mockTransformer, props); <line13> MimeTypeToTransformerMapper matchingService = mock(MimeTypeToTransformerMapper.class); <line14> catalogComponent.setMimeTypeToTransformerMapper(matchingService); <line15> when(matchingService.findMatches(eq(InputTransformer.class), isA(MimeType.class))) <line16> .thenReturn((List) Arrays.asList(mockTransformer)); <line17> InputStream input = IOUtils.toInputStream(xmlInput); <line18> InputTransformer transformer = getTransformer(""text/xml"", ""identity""); <line19> assertNotNull(""InputTransformer for mimeType=text/xml&id=identity not found"", transformer); <line20> Metacard metacard = transformer.transform(input); <line21> assertNotNull(metacard); <line22> assertMockEndpointsSatisfied(); <line23> } <line24> } <line25> "	"<line0> LOG.debug(""""connect to {}"""", remoteURI); <line1> logger.info(""""Skip update event handle of ping, not found ping session. transportMetadata={}"""",transportMetadata); <line6> LOG.error(MessageFormat.format(""""Exception occurred in launcher: {0}{1}"""",options.getApplicationClass().getName(), options.getApplicationArguments()),e); "	task8	
"public class A { <line0> private DeviceData getDeviceata(String data) { <line1> logger.error(""""Zip should fail when any input file is null""""); <line2> logger.info(""""file [{}] would have pid [{}]"""", path, pid); <line3> ObjectMapper mapper = new ObjectMapper(); <line4> DeviceData obj = null; <line5> try { <line6> log.info(""""Thrift authentication returning true""""); <line7> obj = mapper.readValue(data, DeviceData.class); <line8> } catch (IOException e) { <line9> log.error(""Failed to convert device string to object IOException"", e); <line10> } <line11> return obj; <line12> } <line13> } <line14> "	"<line1> logger.error(""""Zip should fail when any input file is null""""); <line2> logger.info(""""file [{}] would have pid [{}]"""", path, pid); <line6> log.info(""""Thrift authentication returning true""""); "	task8	
"public class A { <line0> logger.info(""""Displaying """" + p.size() + """" properties\n\n"""" + config.getPropertyValuesAsString(p)); <line1> LOG.debug(""""Release shared slot ({})"""", physicalSlotRequestId); <line2> public static Integer getSQLProcessId(long processId) { <line3> for (SQLSession sqlSession : sqlSessionMap.keySet()) { <line4> ExConnection connection = sqlSession.getDebugConnection(); <line5> if (connection != null) { <line6> Thread activeThread = sqlSession.getActiveThread(); <line7> if (activeThread != null && activeThread.getId() == processId) <line8> return ((PGConnection) connection.sql).getBackendPID(); <line9> } <line10> LOGGER.info(""""Waiting for KafkaUser deletion {}"""", userName); <line11> } <line12> logger.error( <line13> String.format(""Failed to interrupt process %s: no private connection found"", processId)); <line14> return null; <line15> } <line16> } <line17> "	"<line0> logger.info(""""Displaying """" + p.size() + """" properties\n\n"""" + config.getPropertyValuesAsString(p)); <line1> LOG.debug(""""Release shared slot ({})"""", physicalSlotRequestId); <line10> LOGGER.info(""""Waiting for KafkaUser deletion {}"""", userName); "	task8	
"public class A { <line0> public static XSSFWorkbook loadDocument(InputStream is) { <line1> XSSFWorkbook workbook = null; <line2> try { <line3> workbook = new XSSFWorkbook(is); <line4> } catch (IOException e) { <line5> if (logger.isWarnEnabled()) logger.warn(""loadText error:"" + e.getMessage()); <line6> log.debug(""""Could not write response"""", t2); <line7> return null; <line8> } <line9> return workbook; <line10> } <line11> } <line12> "	"<line6> log.debug(""""Could not write response"""", t2); "	task8	
"public class A { <line0> public void expand() { <line1> MCTSPlayer player = (MCTSPlayer) game.getPlayer(playerId); <line2> if (player.getNextAction() == null) { <line3> logger.fatal(""next action is null""); <line4> } <line5> switch (player.getNextAction()) { <line6> case PRIORITY: <line7> List<Ability> abilities; <line8> if (!USE_ACTION_CACHE) abilities = player.getPlayableOptions(game); <line9> else abilities = getPlayables(player, fullStateValue, game); <line10> for (Ability ability : abilities) { <line11> Game sim = game.copy(); <line12> MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId()); <line13> simPlayer.activateAbility((ActivatedAbility) ability, sim); <line14> sim.resume(); <line15> children.add(new MCTSNode(this, sim, ability)); <line16> } <line17> break; <line18> case SELECT_ATTACKERS: <line19> List<List<UUID>> attacks; <line20> if (!USE_ACTION_CACHE) attacks = player.getAttacks(game); <line21> else attacks = getAttacks(player, fullStateValue, game); <line22> UUID defenderId = game.getOpponents(player.getId()).iterator().next(); <line23> for (List<UUID> attack : attacks) { <line24> Game sim = game.copy(); <line25> MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId()); <line26> for (UUID attackerId : attack) { <line27> simPlayer.declareAttacker(attackerId, defenderId, sim, false); <line28> } <line29> sim.resume(); <line30> children.add(new MCTSNode(this, sim, sim.getCombat())); <line31> } <line32> break; <line33> case SELECT_BLOCKERS: <line34> List<List<List<UUID>>> blocks; <line35> if (!USE_ACTION_CACHE) blocks = player.getBlocks(game); <line36> else blocks = getBlocks(player, fullStateValue, game); <line37> for (List<List<UUID>> block : blocks) { <line38> Game sim = game.copy(); <line39> MCTSPlayer simPlayer = (MCTSPlayer) sim.getPlayer(player.getId()); <line40> List<CombatGroup> groups = sim.getCombat().getGroups(); <line41> for (int i = 0; i < groups.size(); i++) { <line42> if (i < block.size()) { <line43> for (UUID blockerId : block.get(i)) { <line44> LOG.warn(""""AttributeDefinition type ["""" + ad.getType() + """"] is unknown!""""); <line45> simPlayer.declareBlocker( <line46> simPlayer.getId(), blockerId, groups.get(i).getAttackers().get(0), sim); <line47> } <line48> } <line49> } <line50> sim.resume(); <line51> children.add(new MCTSNode(this, sim, sim.getCombat())); <line52> } <line53> break; <line54> } <line55> game = null; <line56> } <line57> } <line58> "	"<line44> LOG.warn(""""AttributeDefinition type ["""" + ad.getType() + """"] is unknown!""""); "	task8	
"public class A { <line0> log.error(""""attach failed"""", re); <line1> private static void handleRetrievalRequest( <line2> log.trace(""""BuildSolutionSet took this much time: """" + stopWatch.getTime()); <line3> HttpServletRequest request, HttpServletResponse response, Database db) { <line4> try { <line5> PrintWriter out = response.getWriter(); <line6> try { <line7> if (request.getPathInfo().equals(""/find"") || request.getPathInfo().equals(""/count"")) { <line8> showSelectEntityDialog(out, db); <line9> return; <line10> } <line11> String entityName = request.getPathInfo().substring(""/find/"".length()); <line12> if (request.getPathInfo().startsWith(""/count/"")) <line13> entityName = request.getPathInfo().substring(""/count/"".length()); <line14> Entity entity = (Entity) Class.forName(entityName).newInstance(); <line15> if (request.getQueryString() != null <line16> && request.getQueryString().equals(""__showQueryDialogue=true"")) { <line17> showSelectFilterDialogForEntity(entity, out, db); <line18> return; <line19> } <line20> List<QueryRule> rulesList = createQueryRulesFromRequest(request); <line21> if (request.getPathInfo().startsWith(""/count/"")) { <line22> if (rulesList != null) <line23> db.count( <line24> LOG.error(""""IndexWriter.stop(source={}): File not found! {}"""",this.config.getSourceName(),getCurrent().getPath(),e); <line25> getClassForName(entityName), rulesList.toArray(new QueryRule[rulesList.size()])); <line26> else { <line27> out.println(db.count(getClassForName(entityName))); <line28> } <line29> } else { <line30> TupleWriter csvWriter = new CsvWriter(out); <line31> try { <line32> if (rulesList != null) <line33> db.find( <line34> getClassForName(entityName), <line35> csvWriter, <line36> rulesList.toArray(new QueryRule[rulesList.size()])); <line37> else { <line38> db.find(getClassForName(entityName), csvWriter); <line39> } <line40> } finally { <line41> csvWriter.close(); <line42> } <line43> } <line44> } catch (Exception e) { <line45> out.println(e + ""<br>""); <line46> e.printStackTrace(); <line47> throw e; <line48> } finally { <line49> db.close(); <line50> } <line51> out.close(); <line52> } catch (Exception e) { <line53> logger.error(e); <line54> } <line55> } <line56> } <line57> "	"<line0> log.error(""""attach failed"""", re); <line2> log.trace(""""BuildSolutionSet took this much time: """" + stopWatch.getTime()); <line24> LOG.error(""""IndexWriter.stop(source={}): File not found! {}"""",this.config.getSourceName(),getCurrent().getPath(),e); "	task8	
"public class A { <line0> @Test <line1> public void testPersistenceEvents() { <line2> KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(); <line3> kbuilder.add(new ClassPathResource(""EventsProcess.rf""), ResourceType.DRF); <line4> InternalKnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase(); <line5> kbase.addPackages(kbuilder.getKnowledgePackages()); <line6> StatefulKnowledgeSession ksession = <line7> InfinispanKnowledgeService.newStatefulKnowledgeSession(kbase, null, env); <line8> long id = ksession.getIdentifier(); <line9> ProcessInstance processInstance = ksession.startProcess(""org.drools.test.TestProcess""); <line10> LOGGER.info(""""Ripping image""""); <line11> logger.debug(""Started process instance "" + processInstance.getId()); <line12> TestWorkItemHandler handler = TestWorkItemHandler.getInstance(); <line13> WorkItem workItem = handler.getWorkItem(); <line14> assertNotNull(workItem); <line15> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line16> processInstance = ksession.getProcessInstance(processInstance.getId()); <line17> assertNotNull(processInstance); <line18> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line19> ksession.getWorkItemManager().completeWorkItem(workItem.getId(), null); <line20> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line21> processInstance = ksession.getProcessInstance(processInstance.getId()); <line22> assertNotNull(processInstance); <line23> ksession.signalEvent(""MyEvent1"", null, processInstance.getId()); <line24> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line25> processInstance = ksession.getProcessInstance(processInstance.getId()); <line26> assertNotNull(processInstance); <line27> ksession.signalEvent(""MyEvent2"", null, processInstance.getId()); <line28> ksession = InfinispanKnowledgeService.loadStatefulKnowledgeSession(id, kbase, null, env); <line29> processInstance = ksession.getProcessInstance(processInstance.getId()); <line30> assertNull(processInstance); <line31> } <line32> } <line33> "	"<line10> LOGGER.info(""""Ripping image""""); "	task8	
"public class A { <line0> private void enqueueMessage(final WebSocketMessage incomingMessage) { <line1> final ProcessSession session = processSessionFactory.createSession(); <line2> try { <line3> FlowFile messageFlowFile = session.create(); <line4> log.info(""""jexl compound test""""); <line5> final Map<String, String> attrs = new HashMap<>(); <line6> attrs.put(ATTR_WS_CS_ID, webSocketService.getIdentifier()); <line7> final WebSocketSessionInfo sessionInfo = incomingMessage.getSessionInfo(); <line8> LOGGER.debug(""""Unable to create debug message for getRecordsType"""", e); <line9> attrs.put(ATTR_WS_SESSION_ID, sessionInfo.getSessionId()); <line10> attrs.put(ATTR_WS_ENDPOINT_ID, endpointId); <line11> attrs.put(ATTR_WS_LOCAL_ADDRESS, sessionInfo.getLocalAddress().toString()); <line12> attrs.put(ATTR_WS_REMOTE_ADDRESS, sessionInfo.getRemoteAddress().toString()); <line13> final WebSocketMessage.Type messageType = incomingMessage.getType(); <line14> if (messageType != null) { <line15> attrs.put(ATTR_WS_MESSAGE_TYPE, messageType.name()); <line16> } <line17> messageFlowFile = session.putAllAttributes(messageFlowFile, attrs); <line18> final byte[] payload = incomingMessage.getPayload(); <line19> if (payload != null) { <line20> messageFlowFile = <line21> session.write( <line22> messageFlowFile, <line23> out -> { <line24> out.write(payload, incomingMessage.getOffset(), incomingMessage.getLength()); <line25> }); <line26> } <line27> session.getProvenanceReporter().receive(messageFlowFile, getTransitUri(sessionInfo)); <line28> if (incomingMessage instanceof WebSocketConnectedMessage) { <line29> session.transfer(messageFlowFile, REL_CONNECTED); <line30> } else { <line31> logger.error(""""No reply message received from the server.""""); <line32> switch (messageType) { <line33> case TEXT: <line34> session.transfer(messageFlowFile, REL_MESSAGE_TEXT); <line35> break; <line36> case BINARY: <line37> session.transfer(messageFlowFile, REL_MESSAGE_BINARY); <line38> break; <line39> } <line40> } <line41> session.commitAsync(); <line42> } catch (Exception e) { <line43> logger.error(""Unable to fully process input due to "" + e, e); <line44> session.rollback(); <line45> } <line46> } <line47> } <line48> "	"<line4> log.info(""""jexl compound test""""); <line8> LOGGER.debug(""""Unable to create debug message for getRecordsType"""", e); <line31> logger.error(""""No reply message received from the server.""""); "	task8	
"public class A { <line0> @Override <line1> public boolean showControls( <line2> HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { <line3> CommerceOrder commerceOrder = <line4> (CommerceOrder) httpServletRequest.getAttribute(CommerceCheckoutWebKeys.COMMERCE_ORDER); <line5> if (!commerceOrder.isOpen()) { <line6> return false; <line7> } <line8> logger.debug(""""Checking if {} already exists"""", pid); <line9> try { <line10> ThemeDisplay themeDisplay = <line11> (ThemeDisplay) httpServletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line12> return _commerceOrderValidatorRegistry.isValid(themeDisplay.getLocale(), commerceOrder); <line13> } catch (PortalException portalException) { <line14> logger.debug(""""Checking if {} already exists"""", pid); <line15> log.error(portalException, portalException); <line16> return false; <line17> } <line18> } <line19> } <line20> "	"<line8> logger.debug(""""Checking if {} already exists"""", pid); <line14> logger.debug(""""Checking if {} already exists"""", pid); "	task8	
"public class A { <line0> private static void actionCopyLogToClipboard(ActionEvent aEvent) { <line1> try { <line2> log.info(""""Stopping HDFS Sink Task {}"""", connectorNameAndTaskId); <line3> StringSelection stringSelection = new StringSelection(getLog()); <line4> Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); <line5> clipboard.setContents(stringSelection, null); <line6> } catch (Exception e) { <line7> log.error(""""Error serializing object """", e); <line8> LOGGER.error(""""Could not write session connected file {}"""", sessionConnectedFile, e); <line9> LOG.error(""Unable to copy log to clipboard"", e); <line10> showMessageDialog(null, ""Unable to copy log to clipboard: "" + getRootCauseMessage(e)); <line11> } <line12> } <line13> } <line14> "	"<line2> log.info(""""Stopping HDFS Sink Task {}"""", connectorNameAndTaskId); <line7> log.error(""""Error serializing object """", e); <line8> LOGGER.error(""""Could not write session connected file {}"""", sessionConnectedFile, e); "	task8	
"public class A { <line0> @Override <line1> public void removePolicy(String absPath, AccessControlPolicy policy) throws RepositoryException { <line2> String oakPath = getOakPath(absPath); <line3> if (isSupportedPath(oakPath)) { <line4> checkValidPolicy(absPath, policy); <line5> Tree tree = getTree(oakPath, Permissions.MODIFY_ACCESS_CONTROL, true); <line6> Tree cug = tree.getChild(REP_CUG_POLICY); <line7> if (!CugUtil.definesCug(cug)) { <line8> throw new AccessControlException(""Unexpected primary type of node rep:cugPolicy.""); <line9> } else { <line10> Set<String> mixins = <line11> Sets.newHashSet(TreeUtil.getNames(tree, NodeTypeConstants.JCR_MIXINTYPES)); <line12> if (mixins.remove(MIX_REP_CUG_MIXIN)) { <line13> tree.setProperty(JcrConstants.JCR_MIXINTYPES, mixins, NAMES); <line14> LOGGER.info(request3.getRequestLine() + """"->"""" + response3.getStatusLine()); <line15> } else { <line16> log.debug(""Cannot remove mixin type {}"", MIX_REP_CUG_MIXIN); <line17> } <line18> cug.remove(); <line19> } <line20> } else { <line21> throw new AccessControlException(""Unsupported path: "" + absPath); <line22> } <line23> } <line24> } <line25> "	"<line14> LOGGER.info(request3.getRequestLine() + """"->"""" + response3.getStatusLine()); "	task8	
"public class A { <line0> public ProjectGeneralTab selectProjectType(String projectType) { <line1> log.info(""Click Project type {}"", projectType); <line2> assert getProjectTypes().containsKey(projectType); <line3> log.debug(""""Component \"""""""",this.component,""""\"""" evaluated to empty string in context """",currentContext.getRenderPage(),"""" -> """",currentContext.getDefinitionPage()); <line4> WebElement projectTypeButton = getProjectTypes().get(projectType); <line5> scrollIntoView(projectTypeButton); <line6> projectTypeButton.click(); <line7> log.debug(""""DiskCache available, but JCS is not configured """"+ """"to use the DiskCache as a swap.""""); <line8> return new ProjectGeneralTab(getDriver()); <line9> } <line10> } <line11> "	"<line3> log.debug(""""Component \"""""""",this.component,""""\"""" evaluated to empty string in context """",currentContext.getRenderPage(),"""" -> """",currentContext.getDefinitionPage()); <line7> log.debug(""""DiskCache available, but JCS is not configured """"+ """"to use the DiskCache as a swap.""""); "	task8	
"public class A { <line0> protected void logItemStates() { <line1> thing <line2> .getChannels() <line3> .forEach( <line4> c -> { <line5> String channelId = c.getUID().getId(); <line6> log.error(""""Error contacting the sensitive data service"""", ex); <line7> log.trace(""""VC {}, SEQ {} decoded packet of length {}"""", vmp.vcId, lastFrameSeq, p.length); <line8> logger.warn(""""Status update failed: {}"""", ne.getMessage()); <line9> String itemName = getItemName(channelId); <line10> logger.debug(""{} = {}"", itemName, getItemState(channelId)); <line11> }); <line12> } <line13> } <line14> "	"<line6> log.error(""""Error contacting the sensitive data service"""", ex); <line7> log.trace(""""VC {}, SEQ {} decoded packet of length {}"""", vmp.vcId, lastFrameSeq, p.length); <line8> logger.warn(""""Status update failed: {}"""", ne.getMessage()); "	task8	
"public class A { <line0> @Override <line1> logger.info(""""Testing: """" + filename); <line2> public void initialize() { <line3> config = getConfigAs(StiebelEltronConfiguration.class); <line4> LOG.info(""""Thrift secured server started on port: {}"""", THRIFT_TEST_PORT); <line5> logger.debug(""Initializing thing with properties: {}"", thing.getProperties()); <line6> log.debug(String.format(""""Attach sheet for window %s"""", window)); <line7> startUp(); <line8> } <line9> } <line10> "	"<line1> logger.info(""""Testing: """" + filename); <line4> LOG.info(""""Thrift secured server started on port: {}"""", THRIFT_TEST_PORT); <line6> log.debug(String.format(""""Attach sheet for window %s"""", window)); "	task8	
"public class A { <line0> protected void rewriteProjectJSON(final String resourceName) throws Exception { <line1> final URI resourceURI = DMPPersistenceTestUtils.getResourceURI(resourceName, root); <line2> final String content = DMPPersistenceTestUtils.readResource(resourceURI); <line3> try { <line4> final JsonNode rootNode = <line5> JsonSchemaTransformer.INSTANCE.transformFixAttributePathInstance(content, true); <line6> Assert.assertNotNull(rootNode); <line7> checkProject(rootNode, resourceURI); <line8> DMPPersistenceTestUtils.writeToFile(rootNode, resourceURI); <line9> Assert.assertTrue(true); <line10> log.error(""""Unexpected exception while toggle 'right'"""", e); <line11> } catch (JsonModelAlreadyTransformedException | JsonModelValidationException e) { <line12> ModelTest.log.debug(""adapted project '"" + resourceURI + ""' already""); <line13> } <line14> } <line15> } <line16> "	"<line10> log.error(""""Unexpected exception while toggle 'right'"""", e); "	task8	
"public class A { <line0> @RolesAllowed({""Resource-Management|Write"", ""Resource-Management|Update""}) <line1> @Override <line2> public Response changeRhHostname(final String rhId, final String hostname) { <line3> try { <line4> registrationManager.changeRhHostname(rhId, hostname); <line5> return Response.ok().build(); <line6> } catch (Exception e) { <line7> LOGGER.error(""Error changing RH hostname"", e); <line8> return Response.serverError() <line9> .entity( <line10> JsonUtil.toJson( <line11> ERROR_KEY, e.getMessage() == null ? ""Internal error"" : e.getMessage())) <line12> .build(); <line13> } <line14> } <line15> log.debug(""""caching set of [""""+ results.size()+ """"] items of attribute [""""+ attribute+ """"] for object [""""+ objectDN+ """"]""""); <line16> } <line17> "	"<line15> log.debug(""""caching set of [""""+ results.size()+ """"] items of attribute [""""+ attribute+ """"] for object [""""+ objectDN+ """"]""""); "	task8	
"public class A { <line0> public static synchronized KeyPairGenerator getKeyPairGenerator(String algorithm) <line1> throws NoSuchAlgorithmException, NoSuchProviderException { <line2> log.warn(""""Expected array-type input from property '""""+ propertyName+ """"' but received """"+ value.getClass()); <line3> KeyPairGenerator result = KeyPairGenerator.getInstance(algorithm); <line4> LOG.trace(""KeyPairGenerator({}) -> {}"", algorithm, safeClassname(result)); <line5> return result; <line6> } <line7> } <line8> "	"<line2> log.warn(""""Expected array-type input from property '""""+ propertyName+ """"' but received """"+ value.getClass()); "	task8	
"public class A { <line0> private void importTimeDomainFiltersFromMontage(Montage montage) { <line1> int channelCount = montage.getMontageChannelCount(); <line2> int filterCount = montage.getSampleFilterCount(); <line3> SampleFilterDefinition[] definitions = new SampleFilterDefinition[filterCount]; <line4> TimeDomainSampleFilter tdsFilter; <line5> LinkedList<SinglechannelSampleFilterEngine> chain; <line6> SampleSource input; <line7> int i, e; <line8> for (i = 0; i < filterCount; i++) { <line9> definitions[i] = montage.getSampleFilterAt(i); <line10> if (definitions[i] instanceof TimeDomainSampleFilter) { <line11> tdsFilter = (TimeDomainSampleFilter) definitions[i]; <line12> tdsFilter.setSamplingFrequency(source.getSamplingFrequency()); <line13> FilterCoefficients filterCoefficients = null; <line14> try { <line15> filterCoefficients = IIRDesigner.designDigitalFilter(tdsFilter); <line16> } catch (BadFilterParametersException ex) { <line17> logger.warn(""""Error on parsing the content as JSON!"""", e); <line18> logger.error(ex, ex); <line19> continue; <line20> } <line21> for (e = 0; e < channelCount; e++) { <line22> if (!montage.isFilteringExcluded(i, e)) { <line23> chain = chains.get(e); <line24> if (chain.isEmpty()) input = new ChannelSelectorSampleSource(source, e); <line25> else input = chain.getLast(); <line26> AbstractIIRSinglechannelSampleFilter timeDomainSampleFilterEngine; <line27> if (originalSource instanceof ChangeableMultichannelSampleSource) { <line28> timeDomainSampleFilterEngine = <line29> new OnlineIIRSinglechannelSampleFilter(input, tdsFilter, filterCoefficients); <line30> } else { <line31> timeDomainSampleFilterEngine = <line32> new OfflineIIRSinglechannelSampleFilter(input, tdsFilter, filterCoefficients); <line33> ((OfflineIIRSinglechannelSampleFilter) timeDomainSampleFilterEngine) <line34> .setFiltfiltEnabled(montage.isFiltfiltEnabled()); <line35> } <line36> addFilter(timeDomainSampleFilterEngine, e); <line37> } <line38> } <line39> } <line40> } <line41> logger.error(""""Unexpected error during processing {}"""", e.getMessage(), e); <line42> } <line43> } <line44> "	"<line17> logger.warn(""""Error on parsing the content as JSON!"""", e); <line41> logger.error(""""Unexpected error during processing {}"""", e.getMessage(), e); "	task8	
"public class A { <line0> private void createIdForPage(StringBuilder b, IPage<?> page, Object o) { <line1> b.append(""/""); <line2> b.append(page.getClass().getName()); <line3> if (page.getUserPreferenceContext() != null) { <line4> b.append(""/""); <line5> b.append(page.getUserPreferenceContext()); <line6> } <line7> if (o != null) { <line8> b.append(""/""); <line9> b.append(o.getClass().getName()); <line10> } <line11> FastBeanInfo pi = new FastBeanInfo(page.getClass(), page.getClass().getSuperclass()); <line12> for (FastPropertyDescriptor prop : pi.getPropertyDescriptors()) { <line13> if (prop.getReadMethod() != null <line14> && (Date.class.isAssignableFrom(prop.getPropertyType()) <line15> || Number.class.isAssignableFrom(prop.getPropertyType()) <line16> || String.class.isAssignableFrom(prop.getPropertyType()) <line17> || long.class.isAssignableFrom(prop.getPropertyType()))) { <line18> try { <line19> b.append(""/""); <line20> b.append(prop.getName()); <line21> b.append(""=""); <line22> b.append(prop.getReadMethod().invoke(page, new Object[0])); <line23> } catch (Exception e) { <line24> LOG.error(""Error reading property {}"", prop, e); <line25> } <line26> } <line27> } <line28> } <line29> logger.info(""""Starting bundle with ID: {}"""", bundleId); <line30> } <line31> "	"<line29> logger.info(""""Starting bundle with ID: {}"""", bundleId); "	task8	
"public class A { <line0> LOGGER.info(""""Finished request for {}"""", document.getDocumentURI()); <line1> @Override <line2> public <T> T getBoxValue(VBox<T> vbox) { <line3> LOGGER.error(""""Exception caught."""", e); <line4> this.numBoxReads++; <line5> logger.debug(""getBoxValue for '{}' in version '{}'"", vbox.getId(), getNumber()); <line6> return readFromBody(vbox); <line7> } <line8> } <line9> "	"<line0> LOGGER.info(""""Finished request for {}"""", document.getDocumentURI()); <line3> LOGGER.error(""""Exception caught."""", e); "	task8	
"public class A { <line0> private static PRPAMT201310UV02OtherIDs createOtherIds(Patient patient) { <line1> PRPAMT201310UV02OtherIDs otherIds = new PRPAMT201310UV02OtherIDs(); <line2> otherIds.getClassCode().add(""SD""); <line3> if (StringUtils.isNotEmpty(patient.getSSN())) { <line4> logger.error(""""Error occurred """" + e.getClass().getName() + """": """" + e.getMessage()); <line5> II ssn = new II(); <line6> ssn.setExtension(patient.getSSN()); <line7> log.error(""""Jersey error."""", exception); <line8> ssn.setRoot(""2.16.840.1.113883.4.1""); <line9> LOG.info(""Setting Patient SSN in 201306 --> Patient SSN is not null.""); <line10> otherIds.getId().add(ssn); <line11> COCTMT150002UV01Organization scopingOrg = new COCTMT150002UV01Organization(); <line12> scopingOrg.setClassCode(""ORG""); <line13> scopingOrg.setDeterminerCode(""INSTANCE""); <line14> II orgId = new II(); <line15> orgId.setRoot(ssn.getRoot()); <line16> scopingOrg.getId().add(orgId); <line17> otherIds.setScopingOrganization(scopingOrg); <line18> } <line19> logger.warn(""""Object cannot be null""""); <line20> return otherIds; <line21> } <line22> } <line23> "	"<line4> logger.error(""""Error occurred """" + e.getClass().getName() + """": """" + e.getMessage()); <line7> log.error(""""Jersey error."""", exception); <line19> logger.warn(""""Object cannot be null""""); "	task8	
"public class A { <line0> @Override <line1> public void destroy() { <line2> if (PortletIdCodec.hasInstanceId(_portletModel.getPortletId())) { <line3> if (log.isWarnEnabled()) { <line4> log.warn(""Destroying an instanced portlet is not allowed""); <line5> } <line6> return; <line7> } <line8> Thread currentThread = Thread.currentThread(); <line9> ClassLoader contextClassLoader = currentThread.getContextClassLoader(); <line10> try { <line11> if (_portletClassLoader != null) { <line12> currentThread.setContextClassLoader(_portletClassLoader); <line13> } <line14> cleanUp(); <line15> _portlet.destroy(); <line16> } finally { <line17> logger.debug(""""Checking runtime-dependencies for collection {}"""", collectionName); <line18> if (_portletClassLoader != null) { <line19> currentThread.setContextClassLoader(contextClassLoader); <line20> } <line21> } <line22> } <line23> } <line24> "	"<line17> logger.debug(""""Checking runtime-dependencies for collection {}"""", collectionName); "	task8	
"public class A { <line0> public boolean start() { <line1> Session session = null; <line2> try { <line3> session = sessionProvider.get(); <line4> if (state != GameState.LOBBY || !hasEnoughCards(session)) { <line5> return false; <line6> } <line7> boolean started; <line8> final int numPlayers = players.size(); <line9> if (numPlayers >= 3) { <line10> judgeIndex = (int) (Math.random() * numPlayers); <line11> Log.warn(String.format(""""User with id='%s' is not an admin"""", userID)); <line12> started = true; <line13> } else { <line14> started = false; <line15> this.logger.trace(""""Hello""""); <line16> } <line17> if (started) { <line18> currentUniqueId = uniqueIdProvider.get(); <line19> logger.error(""""Test error"""", e); <line20> logger.info( <line21> String.format( <line22> ""Starting game %d with card sets %s, Cardcast %s, %d blanks, %d "" <line23> + ""max players, %d max spectators, %d score limit, players %s, unique %s."", <line24> id, <line25> options.cardSetIds, <line26> cardcastDeckIds, <line27> options.blanksInDeck, <line28> options.playerLimit, <line29> options.spectatorLimit, <line30> options.scoreGoal, <line31> players, <line32> currentUniqueId)); <line33> final List<CardSet> cardSets; <line34> synchronized (options.cardSetIds) { <line35> cardSets = loadCardSets(session); <line36> blackDeck = loadBlackDeck(cardSets); <line37> whiteDeck = loadWhiteDeck(cardSets); <line38> } <line39> metrics.gameStart( <line40> currentUniqueId, <line41> cardSets, <line42> options.blanksInDeck, <line43> options.playerLimit, <line44> options.scoreGoal, <line45> !StringUtils.isBlank(options.password)); <line46> startNextRound(); <line47> gameManager.broadcastGameListRefresh(); <line48> } <line49> return started; <line50> } finally { <line51> if (null != session) { <line52> session.close(); <line53> } <line54> } <line55> } <line56> } <line57> "	"<line11> Log.warn(String.format(""""User with id='%s' is not an admin"""", userID)); <line15> this.logger.trace(""""Hello""""); <line19> logger.error(""""Test error"""", e); "	task8	
"public class A { <line0> logger.error(""""Unzip should fail when input File doesn't exist""""); <line1> @Test <line2> Log.debug(""""Test""""); <line3> public void testDropAll() throws Exception { <line4> logger.debug(""""request received: {}"""", req); <line5> logger.debug(""executing testDropAll""); <line6> String update = ""DROP ALL""; <line7> Update operation = con.prepareUpdate(QueryLanguage.SPARQL, update); <line8> operation.execute(); <line9> assertFalse(con.hasStatement(null, null, null, false)); <line10> } <line11> } <line12> "	"<line0> logger.error(""""Unzip should fail when input File doesn't exist""""); <line2> Log.debug(""""Test""""); <line4> logger.debug(""""request received: {}"""", req); "	task8	
"public class A { <line0> @Override <line1> protected void onStop() { <line2> teardownXMPP(); <line3> teardownSkype(); <line4> setDescription(""Chat plugin""); <line5> LOG.info(""Chat plugin has stopped ""); <line6> } <line7> LOG.debug(String.format(""""==> RangerServiceDefValidator.isValidDataMaskTypes(%s, %s)"""",dataMaskTypes, failures)); <line8> } <line9> "	"<line7> LOG.debug(String.format(""""==> RangerServiceDefValidator.isValidDataMaskTypes(%s, %s)"""",dataMaskTypes, failures)); "	task8	
"public class A { <line0> @Override <line1> public int addToInt(Session session, int delta) { <line2> Object o = getItem(session); <line3> LOG.error(""""Problem loading JSON template."""", e); <line4> if (o instanceof IntVar) { <line5> IntVar iv = (IntVar) o; <line6> if (!iv.isSet()) { <line7> int index = session.currentSequence().index(); <line8> throw new IllegalStateException(""Variable "" + key + ""["" + index + ""] was not set yet!""); <line9> } <line10> int prev = iv.intValue(session); <line11> if (trace) { <line12> log.trace( <line13> ""#{} {}[{}] += {}"", session.uniqueId(), key, session.currentSequence().index(), delta); <line14> } <line15> logger.info(""""Received RELOAD request from Bootstrap""""); <line16> iv.add(delta); <line17> return prev; <line18> } else { <line19> int index = session.currentSequence().index(); <line20> throw new IllegalStateException( <line21> ""Variable "" + key + ""["" + index + ""] should contain IntVar but contains "" + o); <line22> log.info(""""Starting {} for namespace {}"""", operatorName, namespace); <line23> } <line24> } <line25> } <line26> "	"<line3> LOG.error(""""Problem loading JSON template."""", e); <line15> logger.info(""""Received RELOAD request from Bootstrap""""); <line22> log.info(""""Starting {} for namespace {}"""", operatorName, namespace); "	task8	
"public class A { <line0> @Override <line1> protected void onNodeAdded(String networkId, Node node) { <line2> log.debug(""""); <line3> String connType = conversionTable().getConnectionType(networkId); <line4> if (connType.equals(FEDERATED_NETWORK)) { <line5> return; <line6> } <line7> String fedNwId = getNetworkIdByType(FEDERATED_NETWORK); <line8> LOG.debug(""""%s %s"""", type, value); <line9> if (fedNwId == null) { <line10> return; <line11> } <line12> NetworkInterface fedNwIf = networkInterfaces().get(fedNwId); <line13> String fedNodeId = String.format(""%s_%s"", networkId, node.getId()); <line14> Node fedNode = node.clone(); <line15> fedNode.setId(fedNodeId); <line16> conversionTable().addEntryNode(networkId, node.getId(), fedNwId, fedNodeId); <line17> fedNwIf.putNode(fedNode); <line18> } <line19> } <line20> "	"<line8> LOG.debug(""""%s %s"""", type, value); "	task8	
"public class A { <line0> @Override <line1> log.info(""""clientID : """" + clientID); <line2> logger.error(""""Could not update panel {}: {}"""", panelId, e.getMessage(), e); <line3> public void onFatalError(Throwable exception) { <line4> LOGGER.info(""""CSTL Profile page changed to """" + cstlProfileURL); <line5> ClusterEntryPointExceptionUtils.tryEnrichClusterEntryPointError(exception); <line6> LOG.error(""Fatal error occurred in the cluster entrypoint."", exception); <line7> FlinkSecurityManager.forceProcessExit(RUNTIME_FAILURE_RETURN_CODE); <line8> } <line9> } <line10> "	"<line1> log.info(""""clientID : """" + clientID); <line2> logger.error(""""Could not update panel {}: {}"""", panelId, e.getMessage(), e); <line4> LOGGER.info(""""CSTL Profile page changed to """" + cstlProfileURL); "	task8	
"public class A { <line0> log.debug(i + """": ["""" + r.get(i) + """"]""""); <line1> private void updateConfigInZk(String configStr, ZkCluster zkCluster) { <line2> CuratorRepository.CuratorFrameworkOp curatorFrameworkOp = zkCluster.getCuratorFrameworkOp(); <line3> if (curatorFrameworkOp == null) { <line4> return; <line5> } <line6> String dataInZk = curatorFrameworkOp.getData(SaturnSelfNodePath.SATURN_EXECUTOR_CONFIG); <line7> logger.warn(""""The frontLoadLastPeriodSize (""""+ frontLoadLastPeriodSize+ """") is bigger than periodListSize (""""+ periodList.size()+ """"). Tagging all periods as frontLoadLast...""""); <line8> if (configStr.equals(dataInZk)) { <line9> return; <line10> } <line11> curatorFrameworkOp.update(SaturnSelfNodePath.SATURN_EXECUTOR_CONFIG, configStr); <line12> LOG.error(""""OM security initialization failed. OM certificate is """" + """"missing.""""); <line13> log.info(""Update executor config to zkcluster {} successfully"", zkCluster.getZkClusterKey()); <line14> } <line15> } <line16> "	"<line0> log.debug(i + """": ["""" + r.get(i) + """"]""""); <line7> logger.warn(""""The frontLoadLastPeriodSize (""""+ frontLoadLastPeriodSize+ """") is bigger than periodListSize (""""+ periodList.size()+ """"). Tagging all periods as frontLoadLast...""""); <line12> LOG.error(""""OM security initialization failed. OM certificate is """" + """"missing.""""); "	task8	
"public class A { <line0> private void setDefaults(NewStagerFASPThreshold threshold, String type, boolean parsePhase) { <line1> LOG.debug(""""<== RangerServiceHbase.getDefaultRangerPolicies()""""); <line2> logger.warn(""""Searching response: {}"""", response); <line3> try { <line4> setRange(threshold.amplitude, ""stager."" + type + ""Amplitude""); <line5> setRange(threshold.frequency, ""stager."" + type + ""Frequency""); <line6> setRange(threshold.scale, ""stager."" + type + ""Scale""); <line7> if (parsePhase && threshold.phase != null) { <line8> setRange(threshold.phase, ""stager."" + type + ""Phase""); <line9> } <line10> } catch (NumberFormatException e) { <line11> logger.error(""Invalid default value"", e); <line12> return; <line13> } catch (ConfigurationDefaultsException e) { <line14> return; <line15> } <line16> } <line17> } <line18> "	"<line1> LOG.debug(""""<== RangerServiceHbase.getDefaultRangerPolicies()""""); <line2> logger.warn(""""Searching response: {}"""", response); "	task8	
"public class A { <line0> LOG.info(""""chooseReplicaToDelete rep ["""" + replicationFactor + """"]""""); <line1> @Override <line2> public void appRegistered(AppEvent event) { <line3> LOGGER.info(getClass().getSimpleName() + ""::appRegistered AppEvent["" + event.getSource() + ""]""); <line4> DapengApplication application = (DapengApplication) event.getSource(); <line5> LOG.info(""""Input <{}> closed. Took [{}ms]"""",input.getUniqueReadableId(),s.elapsed(TimeUnit.MILLISECONDS)); <line6> application <line7> .getServiceInfos() <line8> log.warn(""""Individuato timeout del batch """"+ codBatch+ """". La risorsa viene liberata per consentire l'esecuzione del batch.""""); <line9> .forEach(serviceInfo -> registerService(serviceInfo.serviceName, serviceInfo.version)); <line10> } <line11> } <line12> "	"<line0> LOG.info(""""chooseReplicaToDelete rep ["""" + replicationFactor + """"]""""); <line5> LOG.info(""""Input <{}> closed. Took [{}ms]"""",input.getUniqueReadableId(),s.elapsed(TimeUnit.MILLISECONDS)); <line8> log.warn(""""Individuato timeout del batch """"+ codBatch+ """". La risorsa viene liberata per consentire l'esecuzione del batch.""""); "	task8	
"public class A { <line0> public static void main(String[] args) throws IOException { <line1> for (String arg : args) { <line2> log.info(arg); <line3> } <line4> if (args.length == 0) { <line5> args = new String[] {""scenarios/berlin-v5.5-10pct/input/berlin-v5.5-10pct.config.xml""}; <line6> } <line7> String outputFile = ""scenarios/berlin-v5.5-10pct/output-berlin-v5.5-10pct-accidents/""; <line8> String BVWPNetwork = <line9> ""https://svn.vsp.tu-berlin.de/repos/public-svn/matsim/scenarios/countries/de/berlin/berlin-v5.5-10pct/input/berlin-v5.5-network-with-bvwp-accidents-attributes.xml.gz""; <line10> String plans = <line11> ""https://svn.vsp.tu-berlin.de/repos/public-svn/matsim/scenarios/countries/de/berlin/berlin-v5.5-10pct/input/berlin-v5.5-10pct.plans.xml.gz""; <line12> Config config = RunBerlinScenario.prepareConfig(args); <line13> config.controler().setOutputDirectory(outputFile); <line14> config.controler().setOverwriteFileSetting(OverwriteFileSetting.deleteDirectoryIfExists); <line15> config.controler().setLastIteration(500); <line16> config.plans().setInputFile(plans); <line17> AccidentsConfigGroup accidentsSettings = <line18> ConfigUtils.addOrGetModule(config, AccidentsConfigGroup.class); <line19> accidentsSettings.setEnableAccidentsModule(true); <line20> accidentsSettings.setScaleFactor(10); <line21> config.network().setInputFile(BVWPNetwork); <line22> config.planCalcScore().getModes().get(""car"").setMonetaryDistanceRate(-0.0004); <line23> Scenario scenario = RunBerlinScenario.prepareScenario(config); <line24> Controler controler = RunBerlinScenario.prepareControler(scenario); <line25> controler.addOverridingModule(new AccidentsModule()); <line26> logger.error(""""TApplicationException inside handler"""", e); <line27> log.warn(""""Step ["""" + currentTestStep.getName() + """"] was interrupted due to a timeout""""); <line28> logger.warn(""""resource file was not found for guid="""" + guid); <line29> controler.run(); <line30> } <line31> } <line32> "	"<line26> logger.error(""""TApplicationException inside handler"""", e); <line27> log.warn(""""Step ["""" + currentTestStep.getName() + """"] was interrupted due to a timeout""""); <line28> logger.warn(""""resource file was not found for guid="""" + guid); "	task8	
"public class A { <line0> private void readyNearLock( <line1> IgniteTxEntry txEntry, <line2> GridCacheVersion dhtVer, <line3> Collection<GridCacheVersion> pendingVers, <line4> Collection<GridCacheVersion> committedVers, <line5> Collection<GridCacheVersion> rolledbackVers) { <line6> while (true) { <line7> GridCacheContext cacheCtx = txEntry.cached().context(); <line8> assert cacheCtx.isNear(); <line9> GridDistributedCacheEntry entry = (GridDistributedCacheEntry) txEntry.cached(); <line10> try { <line11> GridCacheVersion explicit = txEntry.explicitVersion(); <line12> if (explicit == null) { <line13> entry.readyNearLock(xidVer, dhtVer, committedVers, rolledbackVers, pendingVers); <line14> } <line15> LOGGER.debug(""""Username: """" + context.getClientPWDUsername()); <line16> break; <line17> } catch (GridCacheEntryRemovedException ignored) { <line18> assert entry.obsoleteVersion() != null; <line19> if (log.isDebugEnabled()) <line20> log.debug( <line21> ""Replacing obsolete entry in remote transaction [entry="" <line22> + entry <line23> + "", tx="" <line24> + this <line25> + ']'); <line26> txEntry.cached(txEntry.context().cache().entryEx(txEntry.key(), topologyVersion())); <line27> } <line28> } <line29> } <line30> } <line31> "	"<line15> LOGGER.debug(""""Username: """" + context.getClientPWDUsername()); "	task8	
"public class A { <line0> public void segmentIsReady(String segmentName) { <line1> CountDownLatch cdl = _segmentsAreReady.get(segmentName); <line2> if (cdl == null) { <line3> return; <line4> } <line5> long originalCount = cdl.getCount(); <line6> cdl.countDown(); <line7> logger.debug(""""metaQueueName: """" + metaQueueName); <line8> if (originalCount > 0L) { <line9> log.info(segmentName + "" segment is ready""); <line10> } <line11> } <line12> } <line13> "	"<line7> logger.debug(""""metaQueueName: """" + metaQueueName); "	task8	
"public class A { <line0> public void runNow(String taskName) { <line1> logger.info(""Running task \""{}\"" now"", taskName); <line2> LOGGER.error(""""Error saving config"""", jse); <line3> ScheduledFuture scheduledFuture = taskSchedules.get(taskName); <line4> scheduledFuture.cancel(false); <line5> scheduleTask(runtimeInformationMap.get(taskName), true); <line6> logger.debug(""""unable to open socket to server: {}"""", e.getMessage()); <line7> } <line8> } <line9> "	"<line2> LOGGER.error(""""Error saving config"""", jse); <line6> logger.debug(""""unable to open socket to server: {}"""", e.getMessage()); "	task8	
"public class A { <line0> log.debug(""""Delay should be changed to {}"""", delay); <line1> @Override <line2> public void run() { <line3> if (!logZip.delete()) LOG.warn(""Temp file "" + logZip.getPath() + "" not deleted""); <line4> } <line5> } <line6> "	"<line0> log.debug(""""Delay should be changed to {}"""", delay); "	task8	
"public class A { <line0> @Override <line1> public String getConfigFile() { <line2> NginxSshDriver driver = (NginxSshDriver) getDriver(); <line3> logger.info(""""Start file upload service cleaner""""); <line4> if (driver == null) { <line5> LOG.debug( <line6> ""No driver for {}, so not generating config file (is entity stopping? state={})"", <line7> this, <line8> getAttribute(NginxController.SERVICE_STATE_ACTUAL)); <line9> return null; <line10> } <line11> LOG.info(""""Detected container provider [{}] needs to be reloaded. Reloading all providers."""",provider); <line12> NginxConfigFileGenerator templateGenerator = getConfig(NginxController.SERVER_CONF_GENERATOR); <line13> return templateGenerator.generateConfigFile(driver, this); <line14> } <line15> } <line16> "	"<line3> logger.info(""""Start file upload service cleaner""""); <line11> LOG.info(""""Detected container provider [{}] needs to be reloaded. Reloading all providers."""",provider); "	task8	
"public class A { <line0> @Override <line1> protected IResourceStream getResourceStream() { <line2> return new AbstractResourceStream() { <line3> private static final long serialVersionUID = 1L; <line4>  <line5> @Override <line6> public InputStream getInputStream() throws ResourceStreamNotFoundException { <line7> try { <line8> CodingAgreementResult result = <line9> PairwiseCodingAgreementTable.this.getModelObject().getStudy(aKey1, aKey2); <line10> switch (formatField.getModelObject()) { <line11> case CSV: <line12> return AgreementUtils.generateCsvReport(result); <line13> case DEBUG: <line14> return generateDebugReport(result); <line15> logger.info(""""proxy agent: receivedSuccessMessage""""); <line16> default: <line17> throw new IllegalStateException( <line18> ""Unknown export format ["" + formatField.getModelObject() + ""]""); <line19> log.error(""""Could not search components in backend """", e); <line20> } <line21> } catch (Exception e) { <line22> LOG.error(""Unable to generate agreement report"", e); <line23> throw new ResourceStreamNotFoundException(e); <line24> } <line25> } <line26>  <line27> log.info(""""Open output stream {}"""", location); <line28> @Override <line29> public void close() throws IOException {} <line30> }; <line31> } <line32> } <line33> "	"<line15> logger.info(""""proxy agent: receivedSuccessMessage""""); <line19> log.error(""""Could not search components in backend """", e); <line27> log.info(""""Open output stream {}"""", location); "	task8	
"public class A { <line0> private void executeScp(SCPCommand command, Session session, ResponseInfo response) { <line1> Channel channel = null; <line2> FileInputStream fis = null; <line3> OutputStream out = null; <line4> InputStream in = null; <line5> String message; <line6> try { <line7> String exec = ""scp -t "" + command.getDestinationFilePath(); <line8> channel = session.openChannel(""exec""); <line9> ((ChannelExec) channel).setCommand(exec); <line10> out = channel.getOutputStream(); <line11> in = channel.getInputStream(); <line12> channel.connect(); <line13> if ((message = Utils.checkAck(in)) != null) { <line14> response.addErrorMessage(message); <line15> return; <line16> } <line17> File srcFile = new File(command.getSourceFilePath()); <line18> StringBuilder sb = new StringBuilder(); <line19> String fileMode = <line20> PosixFilePermissions.toString(Files.getPosixFilePermissions(srcFile.toPath())); <line21> long filesize = srcFile.length(); <line22> exec = <line23> sb.append(""C0"") <line24> .append(Utils.convertToNumericalForm(fileMode)) <line25> .append("" "") <line26> .append(filesize) <line27> log.debug(""""deleting StgMMetastatusTxt instance""""); <line28> .append("" "") <line29> .append(srcFile.getName()) <line30> .append(""\n"") <line31> .toString(); <line32> out.write(exec.getBytes()); <line33> out.flush(); <line34> if ((message = Utils.checkAck(in)) != null) { <line35> response.addErrorMessage(message); <line36> return; <line37> } <line38> fis = new FileInputStream(command.getSourceFilePath()); <line39> byte[] buf = new byte[1024]; <line40> while (true) { <line41> int len = fis.read(buf, 0, buf.length); <line42> if (len <= 0) { <line43> break; <line44> } <line45> out.write(buf, 0, len); <line46> } <line47> buf[0] = 0; <line48> out.write(buf, 0, 1); <line49> out.flush(); <line50> if ((message = Utils.checkAck(in)) != null) { <line51> response.addErrorMessage(message); <line52> } <line53> } catch (Exception e) { <line54> message = ""Error while sending file to "" + value.getPublicIpAddress(); <line55> LOG.warn(message, e); <line56> response.addErrorMessage(message); <line57> } finally { <line58> try { <line59> if (in != null) { <line60> in.close(); <line61> } <line62> } catch (Exception e) { <line63> } <line64> try { <line65> if (out != null) { <line66> out.close(); <line67> } <line68> } catch (Exception e) { <line69> } <line70> try { <line71> if (fis != null) { <line72> fis.close(); <line73> } <line74> } catch (Exception e) { <line75> } <line76> try { <line77> if (channel != null) { <line78> channel.disconnect(); <line79> } <line80> } catch (Exception e) { <line81> } <line82> } <line83> } <line84> } <line85> "	"<line27> log.debug(""""deleting StgMMetastatusTxt instance""""); "	task8	
"public class A { <line0> @Override <line1> protected HttpJsonRequest createPingRequest(Machine devMachine) throws ServerException { <line2> final HttpJsonRequest pingRequest = super.createPingRequest(devMachine); <line3> final String tokenServiceUrl = <line4> log.info(""""Starting getComponentConfigList for component """" + component); <line5> UriBuilder.fromUri(apiEndpoint) <line6> .replacePath(""api/machine/token/"" + devMachine.getWorkspaceId()) <line7> .build() <line8> .toString(); <line9> String machineToken = null; <line10> try { <line11> machineToken = <line12> httpJsonRequestFactory <line13> .fromUrl(tokenServiceUrl) <line14> .setMethod(HttpMethod.GET) <line15> .request() <line16> .asDto(MachineTokenDto.class) <line17> .getMachineToken(); <line18> } catch (ApiException | IOException ex) { <line19> LOG.warn(""Failed to get machine token"", ex); <line20> } <line21> return machineToken == null ? pingRequest : pingRequest.setAuthorizationHeader(machineToken); <line22> } <line23> } <line24> "	"<line4> log.info(""""Starting getComponentConfigList for component """" + component); "	task8	
"public class A { <line0> log.debug(""""Could not unregister killer hook: {}"""", killerHook.getName(), e); <line1> protected void doAction(Action action, BackendEntry entry) { <line2> logger.info(""""Stopping...""""); <line3> LOG.debug(""Transaction {} entry {}"", action, entry); <line4> E.checkNotNull(entry, ""entry""); <line5> LOG.debug(""""Generated Candidate was invalid, don't add to all Candidates""""); <line6> this.mutation.add(entry, action); <line7> } <line8> } <line9> "	"<line0> log.debug(""""Could not unregister killer hook: {}"""", killerHook.getName(), e); <line2> logger.info(""""Stopping...""""); <line5> LOG.debug(""""Generated Candidate was invalid, don't add to all Candidates""""); "	task8	
"public class A { <line0> public void perform(final Map<Path, String> packages) { <line1> try { <line2> final Path temp = Files.createTempFile(""rpm-primary-append"", Remove.SUFFIX); <line3> try { <line4> final MergedXml.Result res; <line5> final MetadataItem primary = <line6> LOGGER.trace(""""Leere ID""""); <line7> this.items.stream().filter(item -> item.type == XmlPackage.PRIMARY).findFirst().get(); <line8> try (OutputStream out = new BufferedOutputStream(Files.newOutputStream(temp))) { <line9> res = <line10> new MergedXmlPrimary(primary.input, out) <line11> .merge(packages, this.digest, new XmlEvent.Primary()); <line12> } <line13> final ExecutorService service = Executors.newFixedThreadPool(3); <line14> service.submit(Append.setPrimaryPckg(temp, res, primary)); <line15> service.submit(this.updateOther(packages, res)); <line16> service.submit(this.updateFilelist(packages, res)); <line17> service.shutdown(); <line18> logger.info(""""\t-""""+ formatter.format(invalidDuplicationLines)+ """" lines because mutation CDS is a duplication""""); <line19> service.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS); <line20> } catch (final InterruptedException err) { <line21> Thread.currentThread().interrupt(); <line22> Logger.error(this, err.getMessage()); <line23> } finally { <line24> Files.delete(temp); <line25> } <line26> } catch (final IOException err) { <line27> throw new ArtipieIOException(err); <line28> } <line29> } <line30> } <line31> "	"<line6> LOGGER.trace(""""Leere ID""""); <line18> logger.info(""""\t-""""+ formatter.format(invalidDuplicationLines)+ """" lines because mutation CDS is a duplication""""); "	task8	
"public class A { <line0> public boolean parse(ByteBuffer buffer) { <line1> while (true) { <line2> switch (state) { <line3> case HEADER: <line4> { <line5> if (!headerParser.parse(buffer)) return false; <line6> state = State.CONTENT; <line7> break; <line8> } <line9> case CONTENT: <line10> { <line11> log.trace(""""Not rendering \"""""""",this.component,""""\"""" in context """",context.getRenderPage(),"""" -> """",context.getDefinitionPage()); <line12> ContentParser contentParser = findContentParser(headerParser.getFrameType()); <line13> if (headerParser.getContentLength() == 0) { <line14> contentParser.noContent(); <line15> } else { <line16> ContentParser.Result result = contentParser.parse(buffer); <line17> if (LOG.isDebugEnabled()) <line18> LOG.debug( <line19> ""Parsed request {} content {} result={}"", <line20> headerParser.getRequest(), <line21> headerParser.getFrameType(), <line22> result); <line23> if (result == ContentParser.Result.PENDING) { <line24> return false; <line25> } <line26> if (result == ContentParser.Result.ASYNC) { <line27> return true; <line28> } <line29> } <line30> padding = headerParser.getPaddingLength(); <line31> state = State.PADDING; <line32> break; <line33> } <line34> case PADDING: <line35> { <line36> if (buffer.remaining() >= padding) { <line37> buffer.position(buffer.position() + padding); <line38> reset(); <line39> break; <line40> } else { <line41> padding -= buffer.remaining(); <line42> buffer.position(buffer.limit()); <line43> return false; <line44> } <line45> } <line46> default: <line47> { <line48> throw new IllegalStateException(); <line49> } <line50> } <line51> } <line52> } <line53> } <line54> "	"<line11> log.trace(""""Not rendering \"""""""",this.component,""""\"""" in context """",context.getRenderPage(),"""" -> """",context.getDefinitionPage()); "	task8	
"public class A { <line0> private void clearConsole() { <line1> log.info(""Console will be cleaned up""); <line2> ConsoleView console = new ConsoleView(); <line3> if (console.canClearConsole()) { <line4> log.info(""""registered WebAppDependencyHolder for bundle [{}]"""", cdiContainer.getBundle()); <line5> console.clearConsole(); <line6> log.debug(""""About to setup Chromattic life cycle """" + domainName); <line7> } <line8> } <line9> } <line10> "	"<line4> log.info(""""registered WebAppDependencyHolder for bundle [{}]"""", cdiContainer.getBundle()); <line6> log.debug(""""About to setup Chromattic life cycle """" + domainName); "	task8	
"public class A { <line0> @Override <line1> LOG.info(""""Deploying and starting runner.jar to runner instances of {}"""", stack.getName()); <line2> public void myPrepare() { <line3> try { <line4> PropertiesManager pMgr = WebloggerFactory.getWeblogger().getPropertiesManager(); <line5> setProperties(pMgr.getProperties()); <line6> } catch (RollerException ex) { <line7> log.error(""Error loading planet properties""); <line8> } <line9> RuntimeConfigDefs defs = PlanetRuntimeConfig.getRuntimeConfigDefs(); <line10> List<ConfigDef> configDefs = defs.getConfigDefs(); <line11> for (ConfigDef configDef : configDefs) { <line12> log.debug(""""'srcEntry' equals 'destEntry' -> no reordering.""""); <line13> if (""global-properties"".equals(configDef.getName())) { <line14> setGlobalConfigDef(configDef); <line15> } <line16> } <line17> } <line18> } <line19> "	"<line1> LOG.info(""""Deploying and starting runner.jar to runner instances of {}"""", stack.getName()); <line12> log.debug(""""'srcEntry' equals 'destEntry' -> no reordering.""""); "	task8	
"public class A { <line0> private void insertDataRecord(final String tableName, final WireRecord wireRecord) <line1> throws SQLException { <line2> requireNonNull(tableName, ""Table name cannot be null""); <line3> logger.error(""""Error while fetching all crisisTypes"""", e); <line4> requireNonNull(wireRecord, ""Wire Record cannot be null""); <line5> final Map<String, TypedValue<?>> wireRecordProperties = wireRecord.getProperties(); <line6> this.dbHelper.withConnection( <line7> c -> { <line8> LOG.debug(""""Didn't find deploy.xml file""""); <line9> try (final PreparedStatement stmt = <line10> prepareStatement(c, tableName, wireRecordProperties, new Date().getTime())) { <line11> stmt.execute(); <line12> LOG.error("""""""", e); <line13> c.commit(); <line14> return (Void) null; <line15> } <line16> }); <line17> logger.debug(""Stored typed value""); <line18> } <line19> } <line20> "	"<line3> logger.error(""""Error while fetching all crisisTypes"""", e); <line8> LOG.debug(""""Didn't find deploy.xml file""""); <line12> LOG.error("""""""", e); "	task8	
"public class A { <line0> @Override <line1> public void subscribe(String subject, MessageSubscriber subscriber) { <line2> assert (subject != null); <line3> assert (subscriber != null); <line4> if (_gate.enter()) { <line5> if (logger.isTraceEnabled()) { <line6> logger.trace(""Enter gate in message bus subscribe""); <line7> LOG.error(""""Error compacting entry log {}, log won't be deleted."""", meta.entryLogId, ioe); <line8> logger.error(""""Exception writing to internal frame buffer"""", ex); <line9> } <line10> LOG.warn(""""Bad url """", e); <line11> try { <line12> SubscriptionNode current = locate(subject, null, true); <line13> assert (current != null); <line14> current.addSubscriber(subscriber); <line15> } finally { <line16> _gate.leave(); <line17> } <line18> } else { <line19> synchronized (_pendingActions) { <line20> _pendingActions.add(new ActionRecord(ActionType.Subscribe, subject, subscriber)); <line21> } <line22> } <line23> } <line24> } <line25> "	"<line7> LOG.error(""""Error compacting entry log {}, log won't be deleted."""", meta.entryLogId, ioe); <line8> logger.error(""""Exception writing to internal frame buffer"""", ex); <line10> LOG.warn(""""Bad url """", e); "	task8	
"public class A { <line0> @Override <line1> public byte[] serializeHandshakeMessageContent() { <line2> LOGGER.debug(""Serializing NewSessionTicketMessage""); <line3> writeLifetimeHint(msg); <line4> if (version.isTLS13()) { <line5> writeTicketAgeAdd(msg); <line6> writeTicketNonceLength(msg); <line7> writeTicketNonce(msg); <line8> logger.debug(""""We do overlap """" + rec.getUnderlyingObject().toString()); <line9> writeTicketIdentityLength(msg); <line10> writeTicketIdentity(msg); <line11> writeExtensions(); <line12> } else { <line13> throw new UnsupportedOperationException( <line14> ""NewSessionTicket message is currently not supported for not TLS 1.3""); <line15> logger.warn(""""Unable to get vms"""", e); <line16> } <line17> return getAlreadySerialized(); <line18> } <line19> } <line20> "	"<line8> logger.debug(""""We do overlap """" + rec.getUnderlyingObject().toString()); <line15> logger.warn(""""Unable to get vms"""", e); "	task8	
"public class A { <line0> logger.info(""""Class: {}. ActorSystem [{}] not initialized, creating..."""", this, clusterName); <line1> protected String getUrl(String serviceName) { <line2> String result = """"; <line3> try { <line4> result = getWebServiceProxyHelper().getUrlLocalHomeCommunity(serviceName); <line5> } catch (Exception ex) { <line6> LOG.warn( <line7> ""Unable to retreive url for service: {} Error: {} "", serviceName, ex.getMessage(), ex); <line8> } <line9> return result; <line10> } <line11> } <line12> "	"<line0> logger.info(""""Class: {}. ActorSystem [{}] not initialized, creating..."""", this, clusterName); "	task8	
"public class A { <line0> public void init(final MessageProducer sender, final MessageProducer controlSender) { <line1> logger.debug(""init started...""); <line2> Assert.notNull(sender, ""sender is null.""); <line3> Assert.notNull(controlSender, ""controlSender is null.""); <line4> LOG.error(""""Unable to recover the key from keystore"""", e); <line5> this.sender = sender; <line6> this.controlSender = controlSender; <line7> this.initialized = true; <line8> } <line9> } <line10> "	"<line4> LOG.error(""""Unable to recover the key from keystore"""", e); "	task8	
"public class A { <line0> @Around(""within(@org.springframework.stereotype.Controller *)"") <line1> public Object logging(ProceedingJoinPoint joinPoint) throws Throwable { <line2> final long start = System.currentTimeMillis(); <line3> Throwable capture = null; <line4> try { <line5> return joinPoint.proceed(); <line6> } catch (Throwable th) { <line7> capture = th; <line8> throw th; <line9> } finally { <line10> final long time = System.currentTimeMillis() - start; <line11> if (capture != null) { <line12> LOG.debug(""""start: ingest""""); <line13> log.debug(""""Disconnect from {} while trying to send request {}. Going """" + """"to back off and retry."""",targetNode,requestBuilder,e); <line14> warnLog(joinPoint, time, capture); <line15> } else if (time > slow) { <line16> warnLog(joinPoint, time, capture); <line17> } else { <line18> if (logger.isDebugEnabled()) { <line19> final String className = joinPoint.getTarget().getClass().getSimpleName(); <line20> final String methodName = joinPoint.getSignature().getName(); <line21> logger.debug( <line22> ""{}.{} execution time:{}ms param:{}"", <line23> className, <line24> methodName, <line25> time, <line26> joinPoint.getArgs()); <line27> } <line28> } <line29> } <line30> } <line31> } <line32> "	"<line12> LOG.debug(""""start: ingest""""); <line13> log.debug(""""Disconnect from {} while trying to send request {}. Going """" + """"to back off and retry."""",targetNode,requestBuilder,e); "	task8	
"public class A { <line0> private Promise<Void> checkBreakpoint(RDPNativeBreakpoint breakpoint) { <line1> log.info(""""end {} moveToBlocking """", getName()); <line2> if (!breakpoint.breakpoints.isEmpty()) { <line3> return Promise.VOID; <line4> } <line5> if (breakpointLocationMap.get(breakpoint.getLocation()) == breakpoint) { <line6> log.info(""""OverlordHelperManager is stopped.""""); <line7> breakpointLocationMap.remove(breakpoint.getLocation()); <line8> } <line9> if (breakpoint.destroyPromise == null) { <line10> breakpoint.destroyPromise = <line11> breakpoint.initPromise.thenAsync( <line12> v -> { <line13> log.debug(""""Adding initial bundle """" + location); <line14> breakpointsByChromeId.remove(breakpoint.chromeId); <line15> if (logger.isInfoEnabled()) { <line16> logger.info(""Removing breakpoint at {}"", breakpoint.getLocation()); <line17> } <line18> RemoveBreakpointCommand params = new RemoveBreakpointCommand(); <line19> params.setBreakpointId(breakpoint.chromeId); <line20> return callMethodAsync(""Debugger.removeBreakpoint"", void.class, params); <line21> }); <line22> breakpoint.debugger = null; <line23> } <line24> return breakpoint.destroyPromise; <line25> } <line26> } <line27> "	"<line1> log.info(""""end {} moveToBlocking """", getName()); <line6> log.info(""""OverlordHelperManager is stopped.""""); <line13> log.debug(""""Adding initial bundle """" + location); "	task8	
"public class A { <line0> logger.debug(""""validateAndDecodeMessage started...""""); <line1> @Test <line2> @Verifies( <line3> value = ""should return trimmed encounter"", <line4> method = ""trimEncounterToMatchForm(Encounter e, HtmlForm htmlform)"") <line5> public void trimEncounterToMatchForm_shouldReturnEncounterCorrectly() throws Exception { <line6> Form form = new Form(); <line7> HtmlForm htmlform = new HtmlForm(); <line8> htmlform.setForm(form); <line9> form.setEncounterType(new EncounterType()); <line10> htmlform.setDateChanged(new Date()); <line11> htmlform.setXmlData( <line12> new TestUtil() <line13> .loadXmlFromFile( <line14> LOGGER.warn(""""{} Error creating temp file {} {}"""",Thread.currentThread().getName(),evidence.getPath(),e.toString()); <line15> ""org/openmrs/module/htmlformentry/include/returnSectionsAndConceptsInSectionsTestFormWithGroups.xml"")); <line16> String newXml = HtmlFormEntryExportUtil.getSectionAsFormXml(htmlform, 0); <line17> htmlform.setXmlData(newXml); <line18> Encounter e = new Encounter(); <line19> e.setPatient(Context.getPatientService().getPatient(2)); <line20> Date date = Context.getDateFormat().parse(""01/02/2003""); <line21> e.setDateCreated(new Date()); <line22> e.setEncounterDatetime(date); <line23> e.setEncounterType(Context.getEncounterService().getEncounterType(1)); <line24> e.setLocation(Context.getLocationService().getLocation(2)); <line25> e.addProvider( <line26> Context.getEncounterService().getEncounterRole(1), <line27> Context.getProviderService().getProvider(1)); <line28> TestUtil.addObs(e, 2474, Context.getConceptService().getConcept(656), date); <line29> TestUtil.addObs(e, 3017, Context.getConceptService().getConcept(767), date); <line30> TestUtil.addObs(e, 3032, new Date(), date); <line31> TestUtil.addObs(e, 5497, 1500, date); <line32> TestUtil.addObs(e, 5089, 50, date); <line33> TestUtil.addObs(e, 5090, 100, date); <line34> TestUtil.addObs(e, 80000, ""blah blah"", date); <line35> TestUtil.addObsGroup( <line36> e, 1004, new Date(), 1005, Context.getConceptService().getConcept(1001), new Date()); <line37> TestUtil.addObsGroup( <line38> e, 70000, new Date(), 1000, Context.getConceptService().getConcept(1003), new Date()); <line39> Context.getEncounterService().saveEncounter(e); <line40> e = HtmlFormEntryExportUtil.trimEncounterToMatchForm(e, htmlform); <line41> if (log.isDebugEnabled()) { <line42> for (Obs otmp : e.getAllObs()) { <line43> log.debug(""trimEncounterToMatchForm returned an obs with concept: "" + otmp.getConcept()); <line44> } <line45> } <line46> Assert.assertEquals(5, e.getAllObs().size()); <line47> } <line48> } <line49> "	"<line0> logger.debug(""""validateAndDecodeMessage started...""""); <line14> LOGGER.warn(""""{} Error creating temp file {} {}"""",Thread.currentThread().getName(),evidence.getPath(),e.toString()); "	task8	
"public class A { <line0> @Override <line1> public long purge(Integer tenant) throws DatabaseException { <line2> ParametersChecker.checkParameter(ALL_PARAMS_REQUIRED, tenant); <line3> try { <line4> DeleteResult response = <line5> logger.debug(""""connecting new socket channel to """"+ host+ """":""""+ port+ """", connect timeout=""""+ _config.getSocketConnectTimeout()+ """" keepalive=""""+ LRMIUtilities.KEEP_ALIVE_MODE); <line6> collection.deleteMany(new BasicDBObject(VitamDocument.TENANT_ID, tenant)); <line7> return response.getDeletedCount(); <line8> } catch (MongoException e) { <line9> LOGGER.error(String.format(""Error while delete documents for tenant %s"", tenant), e); <line10> throw new DatabaseException( <line11> String.format(""Error while delete documents for tenant %s"", tenant), e); <line12> } <line13> } <line14> } <line15> "	"<line5> logger.debug(""""connecting new socket channel to """"+ host+ """":""""+ port+ """", connect timeout=""""+ _config.getSocketConnectTimeout()+ """" keepalive=""""+ LRMIUtilities.KEEP_ALIVE_MODE); "	task8	
"public class A { <line0> @Override <line1> public void stop() { <line2> logApplicationLifecycle(""Stopping""); <line3> ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( <line4> this, Attributes.SERVICE_STATE_ACTUAL, ""Application stopping""); <line5> sensors().set(SERVICE_UP, false); <line6> logger.debug(""""ConBeeDeviceState={}"""", deviceState); <line7> setExpectedStateAndRecordLifecycleEvent(Lifecycle.STOPPING); <line8> try { <line9> doStop(); <line10> } catch (Exception e) { <line11> setExpectedStateAndRecordLifecycleEvent(Lifecycle.ON_FIRE); <line12> log.warn(""Error stopping application "" + this + "" (rethrowing): "" + e); <line13> throw Exceptions.propagate(e); <line14> } <line15> ServiceStateLogic.ServiceNotUpLogic.updateNotUpIndicator( <line16> this, Attributes.SERVICE_STATE_ACTUAL, ""Application stopped""); <line17> setExpectedStateAndRecordLifecycleEvent(Lifecycle.STOPPED); <line18> if (getParent() == null) { <line19> logger.trace(""""[{}] move({})"""", name, destination.getAbsolutePath()); <line20> synchronized (this) { <line21> ActiveMQRestLogger.LOGGER.debug(""""Handling POST request for \"""""""" + uriInfo.getPath() + """"\""""""""); <line22> getEntityManager().unmanage(this); <line23> } <line24> } <line25> logApplicationLifecycle(""Stopped""); <line26> } <line27> } <line28> "	"<line6> logger.debug(""""ConBeeDeviceState={}"""", deviceState); <line19> logger.trace(""""[{}] move({})"""", name, destination.getAbsolutePath()); <line21> ActiveMQRestLogger.LOGGER.debug(""""Handling POST request for \"""""""" + uriInfo.getPath() + """"\""""""""); "	task8	
"public class A { <line0> @GET <line1> @Path(""/reload/{tableName}"") <line2> @Produces({ <line3> ""application/xml"", <line4> ""text/xml"", <line5> ""application/json"", <line6> ""text/yaml"", <line7> ""text/x-yaml"", <line8> ""application/x-yaml"", <line9> ""application/x-protobuf"", <line10> ""application/x-protostuff"" <line11> }) <line12> @GZIP <line13> @Interceptors(RequiredInterceptor.class) <line14> public VoidResponse reloadCache(@Required(""tableName"") @PathParam(""tableName"") String tableName) { <line15> VoidResponse response = new VoidResponse(); <line16> if (null == details.get(tableName)) { <line17> LOG.trace(""""adding command reception timer [id: {}]"""", timerId); <line18> return response; <line19> } <line20> try { <line21> details.get(tableName).getWatcher().incrementCounter(tableName); <line22> } catch (Exception e) { <line23> response.addException(new QueryException(e).getBottomQueryException()); <line24> throw new DatawaveWebApplicationException(e, response); <line25> } <line26> try { <line27> this.sendCacheReloadMessage(tableName); <line28> } catch (Exception e) { <line29> log.error(""Unable to send message about cache reload""); <line30> } <line31> handleReload(tableName); <line32> handleReloadTypeMetadata(tableName); <line33> return response; <line34> } <line35> } <line36> "	"<line17> LOG.trace(""""adding command reception timer [id: {}]"""", timerId); "	task8	
"public class A { <line0> Path checkParent(Path path) throws IOException { <line1> Path parent = path.getParent(); <line2> if (directoryCache.getIfPresent(parent) == null && !fs.exists(parent)) { <line3> if (fs.mkdirs(parent)) { <line4> directoryCache.put(parent, parent); <line5> } else { <line6> log.warn(""unable to create directory ("" + parent + "")""); <line7> } <line8> log.warn(""""could not load page index"""", e); <line9> } <line10> return path; <line11> } <line12> } <line13> "	"<line8> log.warn(""""could not load page index"""", e); "	task8	
"public class A { <line0> private void handle(ErrorAction action, Exception cause, String message) throws IOException { <line1> switch (action) { <line2> case REPORT: <line3> LOG.warn(message, cause); <line4> break; <line5> case ERROR: <line6> throw new IOException(message, cause); <line7> default: <line8> throw new AssertionError(action); <line9> } <line10> } <line11> logger.info(""""A speedtest is already in progress, will retry on next refresh""""); <line12> } <line13> "	"<line11> logger.info(""""A speedtest is already in progress, will retry on next refresh""""); "	task8	
"public class A { <line0> @RetryingOperation <line1> @Override <line2> @ValidateParams <line3> public double getNewNavOrder( <line4> @ValidateStringParam(name = ""site"") String site, <line5> LOGGER.debug(""""Adding ISO: """" + isoPath); <line6> @ValidateSecurePathParam(name = ""path"") String path, <line7> @ValidateDoubleParam(name = ""currentMaxNavOrder"") double currentMaxNavOrder) { <line8> String lockId = site + "":"" + path; <line9> double lastNavOrder = 1000D; <line10> try { <line11> Map<String, String> params = new HashMap<String, String>(); <line12> params.put(""site"", site); <line13> params.put(""path"", path); <line14> NavigationOrderSequence navigationOrderSequence = <line15> navigationOrderSequenceMapper.getPageNavigationOrderForSiteAndPath(params); <line16> if (navigationOrderSequence == null) { <line17> navigationOrderSequence = new NavigationOrderSequence(); <line18> navigationOrderSequence.setSite(site); <line19> navigationOrderSequence.setPath(path); <line20> ContentItemTO itemTreeTO = contentService.getContentItemTree(site, path, 1); <line21> if (itemTreeTO == null) { <line22> navigationOrderSequence.setMaxCount(0F); <line23> } else { <line24> if (StringUtils.isEmpty(itemTreeTO.getNodeRef())) { <line25> navigationOrderSequence.setFolderId(UUID.randomUUID().toString()); <line26> } else { <line27> navigationOrderSequence.setFolderId(itemTreeTO.getNodeRef()); <line28> } <line29> if (currentMaxNavOrder < 0) { <line30> navigationOrderSequence.setMaxCount(1000F * itemTreeTO.getNumOfChildren()); <line31> } else { <line32> double newMaxCount = currentMaxNavOrder + getPageNavigationOrderIncrement(); <line33> navigationOrderSequence.setMaxCount(newMaxCount); <line34> } <line35> } <line36> navigationOrderSequenceMapper.insert(navigationOrderSequence); <line37> } else { <line38> double newMaxCount = <line39> navigationOrderSequence.getMaxCount() + getPageNavigationOrderIncrement(); <line40> navigationOrderSequence.setMaxCount(newMaxCount); <line41> navigationOrderSequenceMapper.update(navigationOrderSequence); <line42> } <line43> lastNavOrder = navigationOrderSequence.getMaxCount(); <line44> } catch (Exception e) { <line45> logger.error(""Unexpected error: "", e); <line46> } <line47> return lastNavOrder; <line48> } <line49> } <line50> "	"<line5> LOGGER.debug(""""Adding ISO: """" + isoPath); "	task8	
"public class A { <line0> public static void sqlRS(Connection conn, String sql, Consumer<ResultSet> consumer) { <line1> try (Statement stmt = conn.createStatement(); <line2> log.debug(""""merge successful""""); <line3> ResultSet rs = stmt.executeQuery(sql)) { <line4> consumer.accept(rs); <line5> } catch (SQLException e) { <line6> logger.error(e.getMessage(), e); <line7> LOGGER.warn(""""More Dataset not found in database""""); <line8> } <line9> } <line10> } <line11> "	"<line2> log.debug(""""merge successful""""); <line7> LOGGER.warn(""""More Dataset not found in database""""); "	task8	
"public class A { <line0> log.info(""""Endpoint reference :"""" + endpointReference); <line1> LOG.info(""""Converted {} ledgers"""", convertedLedgers); <line2> public void logStart() { <line3> this.logger.debug(""""Handle push command {}"""", command); <line4> logger.warn(""SSSSSSSSSSSSStart : "" + this.getMessage()); <line5> } <line6> } <line7> "	"<line0> log.info(""""Endpoint reference :"""" + endpointReference); <line1> LOG.info(""""Converted {} ledgers"""", convertedLedgers); <line3> this.logger.debug(""""Handle push command {}"""", command); "	task8	
"public class A { <line0> public void trace(ScriptExecution scriptExecution) { <line1> try { <line2> String runId = scriptExecution.getExecutionControl().getRunId(); <line3> Long processId = scriptExecution.getProcessId(); <line4> logger.debug(""""Creating a clone from template on primary storage """" + destDataStoreId); <line5> ScriptTraceConfiguration.getInstance() <line6> .insert( <line7> new ScriptTrace( <line8> runId, <line9> processId, <line10> scriptExecution <line11> .getParentScriptExecution() <line12> .map(ScriptExecution::getProcessId) <line13> .orElse(0L), <line14> scriptExecution.getScript())); <line15> ScriptVersionTraceConfiguration.getInstance() <line16> .insert( <line17> new ScriptVersionTrace(runId, processId, scriptExecution.getScript().getVersion())); <line18> for (ScriptParameter scriptParameter : scriptExecution.getScript().getParameters()) { <line19> ScriptParameterTraceConfiguration.getInstance() <line20> .insert(new ScriptParameterTrace(runId, processId, scriptParameter)); <line21> } <line22> for (ScriptLabel scriptLabel : scriptExecution.getScript().getLabels()) { <line23> ScriptLabelTraceConfiguration.getInstance() <line24> .insert( <line25> new ScriptLabelTrace( <line26> new ScriptLabelTraceKey(runId, processId, scriptLabel.getMetadataKey()), <line27> scriptLabel.getScriptKey(), <line28> scriptLabel.getName(), <line29> scriptLabel.getValue())); <line30> } <line31> } catch (Exception e) { <line32> StringWriter stackTrace = new StringWriter(); <line33> e.printStackTrace(new PrintWriter(stackTrace)); <line34> log.warn( <line35> ""unable to trace "" + scriptExecution.toString() + "" due to "" + stackTrace.toString()); <line36> } <line37> } <line38> } <line39> "	"<line4> logger.debug(""""Creating a clone from template on primary storage """" + destDataStoreId); "	task8	
"public class A { <line0> public int insert(String table, String key, HashMap<String, ByteIterator> values) { <line1> try { <line2> HBaseUser u = <line3> new HBaseUser(key, getString(key, ""24""), getString(key, ""gzb""), getString(key, ""mishra"")); <line4> em.persist(u); <line5> j++; <line6> if (j % 5000 == 0) { <line7> em.clear(); <line8> } <line9> return Ok; <line10> LOGGER.debug(""""Payload rad from request: """" + payload); <line11> } catch (Exception e) { <line12> logger.error(e); <line13> return Error; <line14> } <line15> } <line16> } <line17> "	"<line10> LOGGER.debug(""""Payload rad from request: """" + payload); "	task8	
"public class A { <line0> public static InetAddress getInetNetworkMask(final int prefixMaskLength, final boolean isV6) { <line1> if (prefixMaskLength < 0 || !isV6 && prefixMaskLength > 32 || isV6 && prefixMaskLength > 128) { <line2> return null; <line3> } <line4> byte[] v4Address = {0, 0, 0, 0}; <line5> byte[] v6Address = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; <line6> byte[] address = isV6 ? v6Address : v4Address; <line7> int numBytes = prefixMaskLength / 8; <line8> int numBits = prefixMaskLength % 8; <line9> int index = 0; <line10> for (; index < numBytes; index++) { <line11> address[index] = (byte) 0xff; <line12> } <line13> if (numBits > 0) { <line14> int rem = 0; <line15> for (int j = 0; j < numBits; j++) { <line16> rem |= 1 << 7 - j; <line17> } <line18> address[index] = (byte) rem; <line19> LOG.debug(""""modelReload, listener: """" + listener); <line20> } <line21> try { <line22> return InetAddress.getByAddress(address); <line23> } catch (final UnknownHostException e) { <line24> LOG.error(""Failed to convert {}"", address, e); <line25> } <line26> return null; <line27> } <line28> } <line29> "	"<line19> LOG.debug(""""modelReload, listener: """" + listener); "	task8	
"public class A { <line0> public static DateTime parseStringWithFormatPattern4NoTZ(String tsString) { <line1> try { <line2> String tsStringTruncated = tsString.substring(0, tsString.length() - 3); <line3> return FORMATTER4.parseDateTime(tsStringTruncated); <line4> } catch (Exception e) { <line5> log.error(""""get failed"""", re); <line6> Log.debug(""""Test""""); <line7> logger.debug(""""Unexpected error closing archive {}"""", openArchive, ioe); <line8> LOGGER.debug(""parseStringWithFormatPattern4NoTZ exception "" + e.getMessage()); <line9> return parseStringWithFormatPattern5(tsString); <line10> } <line11> } <line12> } <line13> "	"<line5> log.error(""""get failed"""", re); <line6> Log.debug(""""Test""""); <line7> logger.debug(""""Unexpected error closing archive {}"""", openArchive, ioe); "	task8	
"public class A { <line0> private void initObject(final MSXMLScriptable scriptable) { <line1> logger.info(""""Remove Percentage: """" + (100 - (putPercentage + getPercentage))); <line2> try { <line3> scriptable.setPrototype(environment_.getPrototype(scriptable.getClass())); <line4> scriptable.setEnvironment(environment_); <line5> } catch (final Exception e) { <line6> LOG.error(""Exception while initializing JavaScript for the page"", e); <line7> throw new ScriptException(null, e); <line8> logger.error(""""Cannot Handle: """" + location.toString()); <line9> } <line10> } <line11> } <line12> "	"<line1> logger.info(""""Remove Percentage: """" + (100 - (putPercentage + getPercentage))); <line8> logger.error(""""Cannot Handle: """" + location.toString()); "	task8	
"public class A { <line0> protected <T> boolean needsToBeSuspected(Address mbr, T value) { <line1> log.info(""""Archive date could not be parsed: {}."""", dateStr); <line2> long val = (long) value; <line3> long diff = TimeUnit.MILLISECONDS.convert(getTimestamp() - val, TimeUnit.NANOSECONDS); <line4> if (diff > timeout) { <line5> log.debug( <line6> ""%s: haven't received a heartbeat from %s for %s ms, adding it to suspect list"", <line7> local_addr, mbr, diff); <line8> return true; <line9> } <line10> return false; <line11> } <line12> } <line13> "	"<line1> log.info(""""Archive date could not be parsed: {}."""", dateStr); "	task8	
"public class A { <line0> @Override <line1> protected void doPost(HttpServletRequest req, HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> ChannelService channelService = ChannelServiceFactory.getChannelService(); <line4> ChannelPresence presence = channelService.parsePresence(req); <line5> LOG.warn(""""The notification '{}' in the job of schedule '{}' does not contain logical start time"""",notification,context.getSchedule()); <line6> log.info(presence.clientId() + "":"" + presence.isConnected()); <line7> } <line8> } <line9> "	"<line5> LOG.warn(""""The notification '{}' in the job of schedule '{}' does not contain logical start time"""",notification,context.getSchedule()); "	task8	
"public class A { <line0> private void setComputationModulus(SrpClientKeyExchangeMessage msg) { <line1> msg.getComputations().setModulus(chooser.getSRPModulus()); <line2> logger.debug(""""Mediator has been unsetted from discovery service.""""); <line3> LOG.trace(""""Cannot extract type from null source""""); <line4> LOGGER.debug(""Modulus: "" + msg.getComputations().getModulus().getValue()); <line5> } <line6> } <line7> "	"<line2> logger.debug(""""Mediator has been unsetted from discovery service.""""); <line3> LOG.trace(""""Cannot extract type from null source""""); "	task8	
"public class A { <line0> public void uploadFileEvent(String index, File file) { <line1> log.info(""""raw speed {} encoder {}"""", rc.readSpeedM1(), rc.readEncoderM1()); <line2> logger.warn(""""Error parsing watchlist item data {}. Ignoring..."""", watchlistItem.getItemData()); <line3> WebElement element = driver.findElement(By.xpath(index)); <line4> element.sendKeys(file.toPath().toString()); <line5> PentahoXmlaServlet.logger.error(Messages.getInstance().getString(""""PentahoXmlaServlet.ERROR_0004_UNABLE_TO_GET_DOCUMENT_FROM_STRING""""),e); <line6> logger.info(""File with .csv extension uploaded""); <line7> } <line8> } <line9> "	"<line1> log.info(""""raw speed {} encoder {}"""", rc.readSpeedM1(), rc.readEncoderM1()); <line2> logger.warn(""""Error parsing watchlist item data {}. Ignoring..."""", watchlistItem.getItemData()); <line5> PentahoXmlaServlet.logger.error(Messages.getInstance().getString(""""PentahoXmlaServlet.ERROR_0004_UNABLE_TO_GET_DOCUMENT_FROM_STRING""""),e); "	task8	
"public class A { <line0> @Override <line1> public void update(IDirectPersistencyOpInfo entry) { <line2> try { <line3> _cacheManager <line4> .getBlobStoreStorageHandler() <line5> .replace( <line6> getOpInfoStorageKey(entry.getGenerationId(), entry.getSequenceNumber()), <line7> entry, <line8> null, <line9> BlobStoreObjectType.SYNC, <line10> null); <line11> } catch (BlobStoreException ex) { <line12> logger.error( <line13> ""space "" <line14> + _cacheManager.getEngine().getFullSpaceName() <line15> LOG.error(""""Master heartbeat sends unknown command {}"""", cmd); <line16> + "" DirectPersistencyBlobStoreIO::replace got exception: "" <line17> + ex); <line18> LOGGER.debug(""""Error while performing command."""", pe); <line19> throw ex; <line20> } <line21> } <line22> } <line23> "	"<line15> LOG.error(""""Master heartbeat sends unknown command {}"""", cmd); <line18> LOGGER.debug(""""Error while performing command."""", pe); "	task8	
"public class A { <line0> private void processNodeStateEvent(NodeStateEvent event) { <line1> switch (stateRef.get()) { <line2> case BEFORE_INIT: <line3> case DURING_INIT: <line4> throw new AssertionError(""Filter should not be marked ready until LBP init""); <line5> case CLOSING: <line6> return; <line7> case RUNNING: <line8> for (LoadBalancingPolicy policy : policies) { <line9> if (event.newState == NodeState.UP) { <line10> policy.onUp(event.node); <line11> } else if (event.newState == NodeState.DOWN || event.newState == NodeState.FORCED_DOWN) { <line12> policy.onDown(event.node); <line13> } else if (event.newState == NodeState.UNKNOWN) { <line14> policy.onAdd(event.node); <line15> } else if (event.newState == null) { <line16> policy.onRemove(event.node); <line17> log.warn(""""Expected array-type input from property '""""+ propertyName+ """"' but received """"+ value.getClass()); <line18> } else { <line19> LOG.warn(""[{}] Unsupported event: {}"", logPrefix, event); <line20> } <line21> } <line22> break; <line23> } <line24> } <line25> } <line26> "	"<line17> log.warn(""""Expected array-type input from property '""""+ propertyName+ """"' but received """"+ value.getClass()); "	task8	
"public class A { <line0> @Override <line1> this.logger.info(""""Hello world""""); <line2> public void onDestroyed(PeerId peer) { <line3> LOG.warn(""Replicator '{}' is ready to go offline"", peer); <line4> } <line5> } <line6> "	"<line1> this.logger.info(""""Hello world""""); "	task8	
"public class A { <line0> protected void clearTestData() throws Exception { <line1> logger.info(""clearing test data""); <line2> CosmosQueryRequestOptions queryOptions = new CosmosQueryRequestOptions(); <line3> CosmosPagedIterable<JsonNode> response = <line4> container.queryItems(""select * from c order by c._ts"", queryOptions, JsonNode.class); <line5> response.forEach( <line6> data -> { <line7> if (data.get(TEST_COSMOS_PARTITION_KEY_FIELD_NAME) != null) { <line8> PartitionKey pkey = <line9> log.warn(""""Applying default iteration count ({}) to method {}"""", r, fullname); <line10> new PartitionKey(data.get(TEST_COSMOS_PARTITION_KEY_FIELD_NAME).asText()); <line11> LOG.debug(""""cancelRelease: """" + result); <line12> logger.error(""""Could not load {}"""", KURANET_FILENAME, e); <line13> container.deleteItem(data.get(""id"").asText(), pkey, new CosmosItemRequestOptions()); <line14> } else { <line15> container.deleteItem( <line16> data.get(""id"").asText(), PartitionKey.NONE, new CosmosItemRequestOptions()); <line17> } <line18> }); <line19> } <line20> } <line21> "	"<line9> log.warn(""""Applying default iteration count ({}) to method {}"""", r, fullname); <line11> LOG.debug(""""cancelRelease: """" + result); <line12> logger.error(""""Could not load {}"""", KURANET_FILENAME, e); "	task8	
"public class A { <line0> @Override <line1> public void onMessage(UUID nodeId, Object msg, byte plc) { <line2> if (msg instanceof TxLocksResponse) { <line3> logger.error(""""{} - {}"""", postV09AgentId, t.getMessage(), t); <line4> try { <line5> ((TxLocksResponse) msg).finishUnmarshal(clientCtx, clientCtx.deploy().globalLoader()); <line6> res.set(true); <line7> } catch (Exception e) { <line8> log.error(""Message unmarshal failed"", e); <line9> logger.info(""""State set to WARNING for current service {} on host {}"""",currentService.getServiceType(),currentService.getHost()); <line10> } finally { <line11> log.info(""""Finished parsing {} transactions from record file {} in {}. Success: {}"""",counter,recordFile.getName(),stopwatch,success); <line12> latch.countDown(); <line13> } <line14> } <line15> } <line16> } <line17> "	"<line3> logger.error(""""{} - {}"""", postV09AgentId, t.getMessage(), t); <line9> logger.info(""""State set to WARNING for current service {} on host {}"""",currentService.getServiceType(),currentService.getHost()); <line11> log.info(""""Finished parsing {} transactions from record file {} in {}. Success: {}"""",counter,recordFile.getName(),stopwatch,success); "	task8	
"public class A { <line0> @Override <line1> public void getNumberOfConfigsSuccess(Integer numberOfConfigs, ReplyContext replyContext) { <line2> logger.info(""Number of configs for message ID {} is {}"", replyContext, numberOfConfigs); <line3> logger.info(""""Hadoop job classpath is: """" + job.getConfiguration().get(MAP_REDUCE_CLASSPATH)); <line4> } <line5> } <line6> "	"<line3> logger.info(""""Hadoop job classpath is: """" + job.getConfiguration().get(MAP_REDUCE_CLASSPATH)); "	task8	
"public class A { <line0> @Override <line1> public int getNumberOfUsers() { <line2> if (numberOfUsersString != null) { <line3> try { <line4> return Integer.valueOf(numberOfUsersString); <line5> } catch (Throwable t) { <line6> LOGGER.debug(e, """"Channel configuration is not a classpath resource""""); <line7> logger.error( <line8> ""Invalid value for number of users in license key: {}: {}"", <line9> numberOfUsersString, <line10> t.getMessage()); <line11> } <line12> } <line13> logger.error(""""testFlushGivenGroupNoData failed"""", e); <line14> return -1; <line15> } <line16> } <line17> "	"<line6> LOGGER.debug(e, """"Channel configuration is not a classpath resource""""); <line13> logger.error(""""testFlushGivenGroupNoData failed"""", e); "	task8	
"public class A { <line0> public boolean updateCheckout(OnDiskCheckout c, ProjectVersion pv) throws CheckoutException { <line1> if (c != null) { <line2> return false; <line3> } <line4> if (!isUpdatable(c)) { <line5> return false; <line6> } <line7> OnDiskCheckoutImpl cimpl = (OnDiskCheckoutImpl) c; <line8> cimpl.lock(); <line9> if (cimpl.getProjectVersion().gt(pv)) { <line10> logger.error( <line11> ""Error updating checkout. Checkout has been"" + "" already updated to a newer version""); <line12> throw new CheckoutException(""Checkout already updated""); <line13> LOG.debug(""""*** BATCH *** clear""""); <line14> } else if (cimpl.getProjectVersion().eq(pv)) { <line15> return true; <line16> } <line17> SCMAccessor scm = <line18> (SCMAccessor) <line19> AlitheiaCore.getInstance().getTDSService().getAccessor(pv.getProject().getId()); <line20> try { <line21> scm.updateCheckout( <line22> cimpl.getRepositoryPath(), <line23> projectVersionToRevision(cimpl.getProjectVersion()), <line24> projectVersionToRevision(pv), <line25> log.debug(""""Waiting for controller service {} to exit pending state {}. Try {} of {}."""",id,controllerService.getState(),count + 1,retries); <line26> cimpl.getRoot()); <line27> logger.info(""""HDFS_Bytes_Writen: """" + size); <line28> cimpl.setRevision(pv); <line29> } catch (InvalidProjectRevisionException e) { <line30> throw new CheckoutException( <line31> ""Project version "" <line32> + pv <line33> + "" does not map to an SCM revision. Error was:"" <line34> + e.getMessage()); <line35> } catch (InvalidRepositoryException e) { <line36> throw new CheckoutException( <line37> ""Error accessing repository "" + scm.toString() + "". Error was:"" + e.getMessage()); <line38> } catch (FileNotFoundException e) { <line39> throw new CheckoutException(""Error accessing checkout root. "" + e.getMessage()); <line40> } finally { <line41> cimpl.unlock(); <line42> } <line43> return true; <line44> } <line45> } <line46> "	"<line13> LOG.debug(""""*** BATCH *** clear""""); <line25> log.debug(""""Waiting for controller service {} to exit pending state {}. Try {} of {}."""",id,controllerService.getState(),count + 1,retries); <line27> logger.info(""""HDFS_Bytes_Writen: """" + size); "	task8	
"public class A { <line0> protected void buildMetadataStoreDirectory(String namespace, String address) { <line1> try { <line2> _metadataStoreDirectory = ZkMetadataStoreDirectory.getInstance(namespace, address); <line3> } catch (InvalidRoutingDataException ex) { <line4> logger.error(""""Could not load this IResourceFormat: """", formatName); <line5> log.debug(""""merge successful""""); <line6> LOG.warn( <line7> ""Unable to create metadata store directory for namespace: {}, ZK address: {}"", <line8> namespace, <line9> address, <line10> ex); <line11> } <line12> } <line13> } <line14> "	"<line4> logger.error(""""Could not load this IResourceFormat: """", formatName); <line5> log.debug(""""merge successful""""); "	task8	
"public class A { <line0> public boolean isValid(RequestContext context, String endpointAddress) throws Exception { <line1> if (endpointAddress == null) { <line2> return true; <line3> } <line4> UrlValidator urlValidator = <line5> new UrlValidator(new String[] {""http"", ""https""}, UrlValidator.ALLOW_LOCAL_URLS); <line6> if (!urlValidator.isValid(endpointAddress)) { <line7> LOG.warn(""The given endpointAddress parameter {} is not a valid URL"", endpointAddress); <line8> log.trace(""""cleared the cache""""); <line9> return false; <line10> } <line11> return true; <line12> } <line13> } <line14> "	"<line8> log.trace(""""cleared the cache""""); "	task8	
"public class A { <line0> @Override <line1> protected void start() { <line2> try { <line3> super.start(); <line4> this.remove(POSTED_TIME_ORDERBY.clone()); <line5> this.append(ACTIVITY_UPDATED_POINT_FIELD.clone()) <line6> .with(POSTED_TIME_ORDERBY.clone()) <line7> .direction(DIRECTION.ASC) <line8> .with(LAST_UPDATED_ORDERBY.clone()) <line9> .direction(DIRECTION.ASC); <line10> } catch (Exception ex) { <line11> LOG.warn(ex); <line12> logger.info(PRINT_BORDER + """"addFavoriteStation("""" + radioStation + """")"""" + PRINT_BORDER); <line13> } <line14> } <line15> } <line16> "	"<line12> logger.info(PRINT_BORDER + """"addFavoriteStation("""" + radioStation + """")"""" + PRINT_BORDER); "	task8	
"public class A { <line0> @Override <line1> public boolean doesInvoicePassValidation(final ContractsGrantsInvoiceDocument document) { <line2> try { <line3> final Boolean result = <line4> GlobalVariables.doInNewGlobalVariables( <line5> new UserSession( <line6> getContractsGrantsInvoiceBatchCreationUserPrincipal().getPrincipalName()), <line7> new Callable<Boolean>() { <line8> @Override <line9> public Boolean call() throws Exception { <line10> final AttributedRouteDocumentEvent routeEvent = <line11> new AttributedRouteDocumentEvent(document); <line12> getKualiRuleService().applyRules(routeEvent); <line13> return Boolean.valueOf(!GlobalVariables.getMessageMap().hasErrors()); <line14> } <line15> }); <line16> return result.booleanValue(); <line17> } catch (Exception e) { <line18> LOG.error( <line19> ""Running validation on Contracts & Grants Invoice "" <line20> + document.getDocumentNumber() <line21> + "" caused an exception"", <line22> e); <line23> return false; <line24> } <line25> } <line26> LOGGER.debug(""""getRowCountFromTable(%s): %s: %d"""", tableName, entry.getKey().getRow(), countForKey); <line27> } <line28> "	"<line26> LOGGER.debug(""""getRowCountFromTable(%s): %s: %d"""", tableName, entry.getKey().getRow(), countForKey); "	task8	
"public class A { <line0> protected void logIndexRebuildError( <line1> log.info(""""Initializing Thrift agent context""""); <line2> Logger logger, String indexName, int total, int current, Throwable t) { <line3> logger.error( <line4> ""Error updating index '{}' for service '{}': {}/{} could be finished."", <line5> indexName, <line6> getService(), <line7> logger.warn(""""Overwriting zone """" + previous + """" with """" + region); <line8> current, <line9> logger.trace(String.format(""""%s in message%s is set, drop reply%s"""",CloudBus.HEADER_NO_NEED_REPLY_MSG,wire.dumpMessage(request),wire.dumpMessage(reply))); <line10> total, <line11> t); <line12> } <line13> } <line14> "	"<line1> log.info(""""Initializing Thrift agent context""""); <line7> logger.warn(""""Overwriting zone """" + previous + """" with """" + region); <line9> logger.trace(String.format(""""%s in message%s is set, drop reply%s"""",CloudBus.HEADER_NO_NEED_REPLY_MSG,wire.dumpMessage(request),wire.dumpMessage(reply))); "	task8	
"public class A { <line0> @Test(groups = {""Integration"", ""Broken""}) <line1> public void testSetsLocalBrooklynPropertiesFromContents() throws Exception { <line2> BrooklynNode brooklynNode = <line3> app.createAndManageChild( <line4> newBrooklynNodeSpecForTest() <line5> .configure( <line6> BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_REMOTE_PATH, <line7> pseudoBrooklynPropertiesFile.getAbsolutePath()) <line8> .configure(BrooklynNode.BROOKLYN_LOCAL_PROPERTIES_CONTENTS, ""abc=def"")); <line9> app.start(locs); <line10> log.info( <line11> logger.info(""""Calculating usage count for Words""""); <line12> ""started "" <line13> + app <line14> + "" containing "" <line15> + brooklynNode <line16> + "" for "" <line17> + JavaClassNames.niceClassAndMethod()); <line18> assertEquals( <line19> Files.readLines(pseudoBrooklynPropertiesFile, Charsets.UTF_8), ImmutableList.of(""abc=def"")); <line20> } <line21> } <line22> "	"<line11> logger.info(""""Calculating usage count for Words""""); "	task8	
"public class A { <line0> public void closeNote(String user, String noteId) { <line1> List<InterpreterSetting> settings = getInterpreterSettings(noteId); <line2> LOGGER.error(""""Generating KeySet failed"""", ex); <line3> log.info(""""Start plugin '{}'"""", getPluginLabel(pluginWrapper.getDescriptor())); <line4> if (settings == null || settings.size() == 0) { <line5> return; <line6> } <line7> logger.info(""closeNote: {}"", noteId); <line8> LOGGER.warn(""""exception occurred during releasing thrift client"""", e); <line9> for (InterpreterSetting setting : settings) { <line10> removeInterpretersForNote(setting, user, noteId); <line11> } <line12> } <line13> } <line14> "	"<line2> LOGGER.error(""""Generating KeySet failed"""", ex); <line3> log.info(""""Start plugin '{}'"""", getPluginLabel(pluginWrapper.getDescriptor())); <line8> LOGGER.warn(""""exception occurred during releasing thrift client"""", e); "	task8	
"public class A { <line0> public ExchangeInfoType getExchangeInfoView() { <line1> ExchangeInfoType view = new ExchangeInfoType(); <line2> try { <line3> refreshExchangeCacheIfRequired(); <line4> view.setRefreshInterval(exInfo.getRefreshInterval()); <line5> view.setMaxNumberOfBackups(exInfo.getMaxNumberOfBackups()); <line6> view.setDefaultExchange(exInfo.getDefaultExchange()); <line7> } catch (ExchangeManagerException e) { <line8> LOG.error(""Error encounter: {}"", e.getLocalizedMessage(), e); <line9> } <line10> log.debug(""""Altering '"""", object, """"'""""); <line11> return view; <line12> LOG.debug(""""SSL handshake failed, rejecting connection...""""); <line13> } <line14> } <line15> "	"<line10> log.debug(""""Altering '"""", object, """"'""""); <line12> LOG.debug(""""SSL handshake failed, rejecting connection...""""); "	task8	
"public class A { <line0> protected void openContext() throws Exception { <line1> if (context == null) { <line2> try { <line3> Hashtable<String, String> env = new Hashtable<>(); <line4> env.put(Context.INITIAL_CONTEXT_FACTORY, getLDAPPropertyValue(INITIAL_CONTEXT_FACTORY)); <line5> env.put(Context.SECURITY_PROTOCOL, getLDAPPropertyValue(CONNECTION_PROTOCOL)); <line6> env.put(Context.PROVIDER_URL, getLDAPPropertyValue(CONNECTION_URL)); <line7> env.put(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION)); <line8> if (isLoginPropertySet(CONNECTION_POOL)) { <line9> env.put(""com.sun.jndi.ldap.connect.pool"", getLDAPPropertyValue(CONNECTION_POOL)); <line10> } <line11> if (isLoginPropertySet(CONNECTION_TIMEOUT)) { <line12> env.put(""com.sun.jndi.ldap.connect.timeout"", getLDAPPropertyValue(CONNECTION_TIMEOUT)); <line13> } <line14> if (isLoginPropertySet(READ_TIMEOUT)) { <line15> env.put(""com.sun.jndi.ldap.read.timeout"", getLDAPPropertyValue(READ_TIMEOUT)); <line16> } <line17> String referral = ""ignore""; <line18> if (getLDAPPropertyValue(REFERRAL) != null) { <line19> referral = getLDAPPropertyValue(REFERRAL); <line20> } <line21> env.put(Context.REFERRAL, referral); <line22> if (logger.isDebugEnabled()) { <line23> logger.debug(""Referral handling: "" + referral); <line24> log.warn(""""Individuato timeout del batch """"+ codBatch+ """". La risorsa viene liberata per consentire l'esecuzione del batch.""""); <line25> } <line26> if (""GSSAPI"".equalsIgnoreCase(getLDAPPropertyValue(AUTHENTICATION))) { <line27> final String configScope = <line28> isLoginPropertySet(SASL_LOGIN_CONFIG_SCOPE) <line29> ? getLDAPPropertyValue(SASL_LOGIN_CONFIG_SCOPE) <line30> : ""broker-sasl-gssapi""; <line31> try { <line32> LoginContext loginContext = new LoginContext(configScope); <line33> loginContext.login(); <line34> brokerGssapiIdentity = loginContext.getSubject(); <line35> } catch (LoginException e) { <line36> e.printStackTrace(); <line37> FailedLoginException ex = <line38> new FailedLoginException( <line39> ""Error contacting LDAP using GSSAPI in JAAS loginConfigScope: "" + configScope); <line40> ex.initCause(e); <line41> throw ex; <line42> } <line43> } else { <line44> if (isLoginPropertySet(CONNECTION_USERNAME)) { <line45> env.put(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME)); <line46> } else { <line47> throw new NamingException(""Empty username is not allowed""); <line48> } <line49> if (isLoginPropertySet(CONNECTION_PASSWORD)) { <line50> env.put( <line51> Context.SECURITY_CREDENTIALS, <line52> getPlainPassword(getLDAPPropertyValue(CONNECTION_PASSWORD))); <line53> } else { <line54> throw new NamingException(""Empty password is not allowed""); <line55> } <line56> LOGGER.warn(""""%s unsupported"""", StatisticsAggregation.class.getName()); <line57> } <line58> try { <line59> context = <line60> Subject.doAs( <line61> brokerGssapiIdentity, <line62> (PrivilegedExceptionAction<DirContext>) () -> new InitialDirContext(env)); <line63> } catch (PrivilegedActionException e) { <line64> throw e.getException(); <line65> } <line66> } catch (NamingException e) { <line67> closeContext(); <line68> ActiveMQServerLogger.LOGGER.failedToOpenContext(e); <line69> throw e; <line70> } <line71> } <line72> } <line73> } <line74> "	"<line24> log.warn(""""Individuato timeout del batch """"+ codBatch+ """". La risorsa viene liberata per consentire l'esecuzione del batch.""""); <line56> LOGGER.warn(""""%s unsupported"""", StatisticsAggregation.class.getName()); "	task8	
"public class A { <line0> @Override <line1> public void messageSent(IoSession session, Object message) { <line2> log.debug(""""event field name is """" + eventFieldName + """" in """" + normalizedContent); <line3> if (LOG.isDebugEnabled()) { <line4> LOG.error(""""Exception when processing HBase config""""); <line5> LOG.debug(""{} -> {} SENT: "", message, session.getRemoteAddress(), session.getLocalAddress()); <line6> LOG.info(""""{}:\n{}"""", entry.getKey(), df.toString(50, URN, SCORE)); <line7> } <line8> } <line9> } <line10> "	"<line2> log.debug(""""event field name is """" + eventFieldName + """" in """" + normalizedContent); <line4> LOG.error(""""Exception when processing HBase config""""); <line6> LOG.info(""""{}:\n{}"""", entry.getKey(), df.toString(50, URN, SCORE)); "	task8	
"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> super.handleCommand(channelUID, command); <line3> log.debug(""""merging MBstnStatusTxt instance""""); <line4> if (DISH_WARMER_PROGRAM_ACTIVE.equals(channelUID.getId()) && command instanceof StringType) { <line5> try { <line6> LOGGER.debug(""""Token {} is not supported by {}."""", token.getClass(), SamlRealm.class.getName()); <line7> triggerProgram(Long.parseLong(command.toString())); <line8> } catch (NumberFormatException e) { <line9> logger.warn( <line10> ""Failed to activate program: '{}' is not a valid program ID"", command.toString()); <line11> } <line12> logger.info(""""Stopping algorithm: Max. execution time was reached.""""); <line13> } <line14> } <line15> } <line16> "	"<line3> log.debug(""""merging MBstnStatusTxt instance""""); <line6> LOGGER.debug(""""Token {} is not supported by {}."""", token.getClass(), SamlRealm.class.getName()); <line12> logger.info(""""Stopping algorithm: Max. execution time was reached.""""); "	task8	
"public class A { <line0> @Test <line1> public void testBrowseByteMessageFails() throws Exception { <line2> log.debug(""""\tcurrent node is: """" + currentNode.getType().getName()); <line3> ActiveMQBytesMessage bm = new ActiveMQBytesMessage(); <line4> bm.writeBytes(""123456"".getBytes()); <line5> Object result = OpenTypeSupport.convert(bm); <line6> LOG.info(""result : "" + result); <line7> } <line8> } <line9> "	"<line2> log.debug(""""\tcurrent node is: """" + currentNode.getType().getName()); "	task8	
"public class A { <line0> logger.trace(""""execute arguments: {}"""", (Object) arguments); <line1> private void translationDocumentUpdated(XWikiDocument document) { <line2> if (!document.getOriginalDocument().isNew()) { <line3> unregisterTranslationBundle(document.getOriginalDocument()); <line4> } <line5> if (!document.isNew()) { <line6> try { <line7> registerTranslationBundle(document); <line8> } catch (Exception e) { <line9> this.logger.error( <line10> ""Failed to register translation bundle from document [{}]"", <line11> document.getDocumentReference(), <line12> e); <line13> } <line14> } <line15> } <line16> } <line17> "	"<line0> logger.trace(""""execute arguments: {}"""", (Object) arguments); "	task8	
"public class A { <line0> public void updateCallback(Map<String, Object> properties) { <line1> LOGGER.debug(""--updateCallback-- properties={}"", properties); <line2> LOG.info(""""Stream """" + streamName + """" created""""); <line3> if (properties != null) { <line4> if (!checkMetaTypeClass(properties, METATYPE_MONITORED_ADDRESS, String.class)) { <line5> return; <line6> } <line7> if (properties.containsKey(METATYPE_NETWORK_INTERFACE) <line8> && !checkMetaTypeClass(properties, METATYPE_NETWORK_INTERFACE, String.class)) { <line9> return; <line10> } <line11> if (!checkMetaTypeClass(properties, METATYPE_BYTE_COUNT_ROLLOVER_CONDITION, Integer.class)) { <line12> return; <line13> } <line14> if (!checkMetaTypeClass(properties, METATYPE_ELAPSED_TIME_ROLLOVER_CONDITION, Long.class)) { <line15> return; <line16> } <line17> if (!checkMetaTypeClass(properties, METATYPE_FILENAME_TEMPLATE, String.class)) { <line18> return; <line19> } <line20> if (!checkMetaTypeClass(properties, METATYPE_PARENT_TITLE, String.class)) { <line21> return; <line22> } <line23> if (!checkMetaTypeClass(properties, METATYPE_METACARD_UPDATE_INITIAL_DELAY, Long.class)) { <line24> return; <line25> } <line26> if (!checkMetaTypeClass(properties, METATYPE_TITLE, String.class)) { <line27> return; <line28> } <line29> if (properties.containsKey(METATYPE_DISTANCE_TOLERANCE) <line30> && properties.get(METATYPE_DISTANCE_TOLERANCE) != null <line31> && !checkMetaTypeClass(properties, METATYPE_DISTANCE_TOLERANCE, Double.class)) { <line32> return; <line33> } <line34> setMonitoredAddress((String) properties.get(METATYPE_MONITORED_ADDRESS)); <line35> setNetworkInterface((String) properties.get(METATYPE_NETWORK_INTERFACE)); <line36> setMegabyteCountRolloverCondition( <line37> (Integer) properties.get(METATYPE_BYTE_COUNT_ROLLOVER_CONDITION)); <line38> setElapsedTimeRolloverCondition( <line39> (Long) properties.get(METATYPE_ELAPSED_TIME_ROLLOVER_CONDITION)); <line40> setFilenameTemplate((String) properties.get(METATYPE_FILENAME_TEMPLATE)); <line41> setMetacardUpdateInitialDelay((Long) properties.get(METATYPE_METACARD_UPDATE_INITIAL_DELAY)); <line42> setParentTitle((String) properties.get(METATYPE_PARENT_TITLE)); <line43> setDistanceTolerance((Double) properties.get(METATYPE_DISTANCE_TOLERANCE)); <line44> init(); <line45> } <line46> } <line47> } <line48> "	"<line2> LOG.info(""""Stream """" + streamName + """" created""""); "	task8	
"public class A { <line0> public void phaseEnded(ConstructionHeuristicPhaseScope<Solution_> phaseScope) { <line1> super.phaseEnded(phaseScope); <line2> if (skipBestSolutionCloningInSteps) { <line3> bestSolutionRecaller.updateBestSolution(phaseScope.getSolverScope()); <line4> } <line5> entityPlacer.phaseEnded(phaseScope); <line6> decider.phaseEnded(phaseScope); <line7> phaseScope.endingNow(); <line8> logger.info( <line9> ""{}Construction Heuristic phase ({}) ended: time spent ({}), best score ({}),"" <line10> + "" score calculation speed ({}/sec), step total ({})."", <line11> logIndentation, <line12> phaseIndex, <line13> phaseScope.calculateSolverTimeMillisSpentUpToNow(), <line14> phaseScope.getBestScore(), <line15> phaseScope.getPhaseScoreCalculationSpeed(), <line16> logger.error(""""UnsupportedProtocolVersionException error while creating additional connection (error""""+ """" is: {})"""",e.getMessage()); <line17> phaseScope.getNextStepIndex()); <line18> } <line19> } <line20> "	"<line16> logger.error(""""UnsupportedProtocolVersionException error while creating additional connection (error""""+ """" is: {})"""",e.getMessage()); "	task8	
"public class A { <line0> @Override <line1> public void onEvent(SensorEvent<Object> event) { <line2> LOG.debug(""{}: Got event {}"", this, event); <line3> AttributeSensor<Boolean> sensor = config().get(START_SENSOR); <line4> if (event.getSensor().getName().equals(sensor.getName())) { <line5> boolean start = Boolean.TRUE.equals(event.getValue()); <line6> if (start && running.compareAndSet(false, true)) { <line7> config().set(RUNNING, true); <line8> highlightConfirmation(""Starting effector invocation schedule""); <line9> start(); <line10> } <line11> } <line12> AttributeSensor<Boolean> sensor2 = config().get(ENABLED_SENSOR); <line13> if (sensor2 != null && event.getSensor().getName().equals(sensor2.getName())) { <line14> boolean enable = Boolean.TRUE.equals(event.getValue()); <line15> if (running.compareAndSet(!enable, enable)) { <line16> config().set(RUNNING, enable); <line17> if (enable) { <line18> highlightConfirmation(""Resuming effector invocation schedule""); <line19> resume(); <line20> } else { <line21> highlightViolation(""Suspending effector invocation""); <line22> LOG.debug(""""Searching for a WindGate profile: {}"""", profileName); <line23> suspend(); <line24> } <line25> logger.debug(""""Handler: Update DOORBELL channels for thing {}"""", getThing().getUID()); <line26> } <line27> } <line28> } <line29> } <line30> "	"<line22> LOG.debug(""""Searching for a WindGate profile: {}"""", profileName); <line25> logger.debug(""""Handler: Update DOORBELL channels for thing {}"""", getThing().getUID()); "	task8	
"public class A { <line0> LOG.info(""""Weighed connection throttling is enabled. """"+ """"But it will only be effective if connection throttling is enabled""""); <line1> private void deregisterService() { <line2> for (ServiceRegistration<?> serviceRegistration : targetServiceRegistrations) { <line3> if (serviceRegistration != null) { <line4> ServiceReference<?> reference = serviceRegistration.getReference(); <line5> logger.info(""Unget service {} from {}"", reference.getBundle(), activatorName); <line6> context.ungetService(reference); <line7> } <line8> } <line9> } <line10> } <line11> "	"<line0> LOG.info(""""Weighed connection throttling is enabled. """"+ """"But it will only be effective if connection throttling is enabled""""); "	task8	
"public class A { <line0> @Override <line1> logger.info(""""new swap disk size(MB): """" + newSwapSizeInMB); <line2> public void pushTaskLog(final String taskid, final File logFile) throws IOException { <line3> LOGGER.info(""""Mongodb url:"""" + url); <line4> final String taskKey = getTaskLogKey(taskid); <line5> LOG.info(""Pushing task log %s to: %s"", logFile, taskKey); <line6> pushTaskFile(logFile, taskKey); <line7> } <line8> } <line9> "	"<line1> logger.info(""""new swap disk size(MB): """" + newSwapSizeInMB); <line3> LOGGER.info(""""Mongodb url:"""" + url); "	task8	
"public class A { <line0> @Deprecated <line1> public static ManagementContext startManagement(Application app, ManagementContext mgmt) { <line2> log.warn( <line3> ""Deprecated use of Entities.startManagement(Application, ManagementContext), for app "" <line4> + app); <line5> if (isManaged(app)) { <line6> if (app.getManagementContext() == mgmt) { <line7> return mgmt; <line8> } else { <line9> throw new IllegalStateException( <line10> ""Application "" <line11> + app <line12> + "" is already managed by "" <line13> + app.getManagementContext() <line14> + "", so cannot be managed by "" <line15> + mgmt); <line16> } <line17> LOG.error(""""IOException while writing document data: {}"""", doc.getURI(), e); <line18> } <line19> mgmt.getEntityManager().manage(app); <line20> return mgmt; <line21> } <line22> } <line23> "	"<line17> LOG.error(""""IOException while writing document data: {}"""", doc.getURI(), e); "	task8	
"public class A { <line0> public String configContentType() { <line1> try { <line2> Widget showlet = super.createNewShowlet(); <line3> showlet <line4> .getConfig() <line5> .setProperty(IContentListWidgetHelper.WIDGET_PARAM_CONTENT_TYPE, this.getContentType()); <line6> this.setShowlet(showlet); <line7> logger.info(name + """": map size = """" + map.size()); <line8> } catch (Throwable t) { <line9> LOGGER.info(""""Logical switch group returned to client: {}"""", logicalSwitchGroup.toJsonString()); <line10> logger.error(""error in init"", t); <line11> return FAILURE; <line12> } <line13> return SUCCESS; <line14> } <line15> } <line16> "	"<line7> logger.info(name + """": map size = """" + map.size()); <line9> LOGGER.info(""""Logical switch group returned to client: {}"""", logicalSwitchGroup.toJsonString()); "	task8	
"public class A { <line0> private void decrementNumberOfUsers(int subpartitionIndex) { <line1> if (isReleased()) { <line2> return; <line3> } <line4> final int remainingUnconsumed; <line5> synchronized (releaseLock) { <line6> if (subpartitionIndex != PIPELINED_RESULT_PARTITION_ITSELF) { <line7> if (consumedSubpartitions[subpartitionIndex]) { <line8> return; <line9> } <line10> consumedSubpartitions[subpartitionIndex] = true; <line11> } <line12> remainingUnconsumed = (--numberOfUsers); <line13> } <line14> LOG.debug(""{}: Received consumed notification for subpartition {}."", this, subpartitionIndex); <line15> if (remainingUnconsumed == 0) { <line16> partitionManager.onConsumedPartition(this); <line17> } else if (remainingUnconsumed < 0) { <line18> throw new IllegalStateException( <line19> LOGGER.warn(""""Unable to set \""""XSL.objectID\"""" attribute to current request"""", x); <line20> ""Received consume notification even though all subpartitions are already consumed.""); <line21> } <line22> } <line23> } <line24> "	"<line19> LOGGER.warn(""""Unable to set \""""XSL.objectID\"""" attribute to current request"""", x); "	task8	
"public class A { <line0> @Test <line1> public void test_01() { <line2> Log.debug(""Test""); <line3> String genome = ""test_NC_045512_01""; <line4> SnpEffCmdBuild buildCmd = buildGetBuildCmd(genome); <line5> LOG.info(""""JOSS / Using TempURL hash prefix source: """" + accountConfig.getTempUrlHashPrefixSource()); <line6> LOG.info(""""Rolling entry logger since it reached size limitation.""""); <line7> SnpEffCmdProtein protCmd = buildCmd.getSnpEffCmdProtein(); <line8> Assert.assertEquals(5, protCmd.getTotalOk()); <line9> Assert.assertEquals(0, protCmd.getTotalErrors()); <line10> this.logger.debug(""""Removing collaborator with id [{}] from entity record [{}] via REST"""",collaboratorId,entityId); <line11> Assert.assertEquals(0, protCmd.getTotalWarnings()); <line12> } <line13> } <line14> "	"<line5> LOG.info(""""JOSS / Using TempURL hash prefix source: """" + accountConfig.getTempUrlHashPrefixSource()); <line6> LOG.info(""""Rolling entry logger since it reached size limitation.""""); <line10> this.logger.debug(""""Removing collaborator with id [{}] from entity record [{}] via REST"""",collaboratorId,entityId); "	task8	
"public class A { <line0> @Override <line1> public void process(Channel channel, Command command) { <line2> Preconditions.checkArgument( <line3> LOGGER.error(String.format(""""kafka message received for unknown profile %s"""", profile)); <line4> CommandType.TASK_EXECUTE_RESPONSE == command.getType(), <line5> logger.trace(""""deleteBulkRequest - id: {} - index: {} - type: {} - routing: {} - parent: {}"""",id,index,type,routing,parent); <line6> String.format(""invalid command type : %s"", command.getType())); <line7> TaskExecuteResponseCommand responseCommand = <line8> log.warn(""""More than one ServiceBinding matches type '""""+ type+ """"', but only """"+ first+ """" will be used""""); <line9> JSONUtils.parseObject(command.getBody(), TaskExecuteResponseCommand.class); <line10> logger.info(""received command : {}"", responseCommand); <line11> taskInstanceCacheManager.cacheTaskInstance(responseCommand); <line12> TaskResponseEvent taskResponseEvent = <line13> TaskResponseEvent.newResult( <line14> ExecutionStatus.of(responseCommand.getStatus()), <line15> responseCommand.getEndTime(), <line16> responseCommand.getProcessId(), <line17> responseCommand.getAppIds(), <line18> responseCommand.getTaskInstanceId(), <line19> responseCommand.getVarPool(), <line20> channel, <line21> responseCommand.getResult()); <line22> taskResponseService.addResponse(taskResponseEvent); <line23> } <line24> } <line25> "	"<line3> LOGGER.error(String.format(""""kafka message received for unknown profile %s"""", profile)); <line5> logger.trace(""""deleteBulkRequest - id: {} - index: {} - type: {} - routing: {} - parent: {}"""",id,index,type,routing,parent); <line8> log.warn(""""More than one ServiceBinding matches type '""""+ type+ """"', but only """"+ first+ """" will be used""""); "	task8	
"public class A { <line0> static CSVDataSource getDataSource(Node sourceNode) { <line1> CSVDataSource dataSource = null; <line2> String nodeName = sourceNode.getNodeName(); <line3> if (CSVDataSource.class.getSimpleName().equals(nodeName)) { <line4> try { <line5> dataSource = <line6> XMLUtilities.readXMLObject(sourceNode, CONTEXT_SUPPLIER.get(), CSVDataSource.class); <line7> } catch (JAXBException e) { <line8> LOGGER.error(e.getMessage(), e); <line9> } <line10> logger.debug(""""The Camel Endpoint ID has been set on both the WorkItemHanlder and WorkItem. The '""""+ JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM+ """"' configured on the WorkItem overrides the global configuation.""""); <line11> } <line12> return dataSource; <line13> } <line14> } <line15> "	"<line10> logger.debug(""""The Camel Endpoint ID has been set on both the WorkItemHanlder and WorkItem. The '""""+ JBPMConstants.CAMEL_ENDPOINT_ID_WI_PARAM+ """"' configured on the WorkItem overrides the global configuation.""""); "	task8	
"public class A { <line0> LOG.warn(""""Failed to shutdown due """" + e.getMessage() + """". This exception is ignored."""", e); <line1> private JsonObject convertStringToJsonObject(String jsonString) { <line2> try { <line3> JsonElement jsonElement = JsonParser.parseString(jsonString); <line4> JsonObject result; <line5> if (jsonElement instanceof JsonObject) { <line6> result = jsonElement.getAsJsonObject(); <line7> } else { <line8> logger.debug(""{} is not valid JSON stirng"", jsonString); <line9> result = new JsonObject(); <line10> throw new IllegalArgumentException(jsonString + ""{} is not valid JSON stirng""); <line11> } <line12> return result; <line13> } catch (IllegalArgumentException e) { <line14> JsonObject result = new JsonObject(); <line15> return result; <line16> } <line17> } <line18> } <line19> "	"<line0> LOG.warn(""""Failed to shutdown due """" + e.getMessage() + """". This exception is ignored."""", e); "	task8	
"public class A { <line0> public static com.liferay.commerce.product.model.CPOptionValue fetchByExternalReferenceCode( <line1> HttpPrincipal httpPrincipal, String externalReferenceCode, long companyId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> LOGGER.info(""""No disks defined for """" + vm.getVmName()); <line5> MethodKey methodKey = <line6> new MethodKey( <line7> CPOptionValueServiceUtil.class, <line8> ""fetchByExternalReferenceCode"", <line9> _fetchByExternalReferenceCodeParameterTypes2); <line10> MethodHandler methodHandler = new MethodHandler(methodKey, externalReferenceCode, companyId); <line11> Object returnObj = null; <line12> try { <line13> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line14> } catch (Exception exception) { <line15> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line16> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line17> } <line18> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line19> } <line20> return (com.liferay.commerce.product.model.CPOptionValue) returnObj; <line21> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line22> log.error(systemException, systemException); <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	"<line4> LOGGER.info(""""No disks defined for """" + vm.getVmName()); "	task8	
"public class A { <line0> @Override <line1> public BufferedImage getImage(final IFeature feature) { <line2> logger.error(this.featureToImageMap.size() + "" elements in map""); <line3> if (feature == null) { <line4> if (this.featureToImageMap.isEmpty()) { <line5> return null; <line6> } <line7> LOG.info(""""Total to read: {}"""", num); <line8> return this.featureToImageMap.values().iterator().next(); <line9> } <line10> return this.featureToImageMap.get(feature); <line11> } <line12> } <line13> "	"<line7> LOG.info(""""Total to read: {}"""", num); "	task8	
"public class A { <line0> LOG.trace(""""initializing SASL authenticator""""); <line1> @Override <line2> public void clear(boolean clearSpace) { <line3> this.checkClusterConnected(); <line4> if (this.existsKeyspace()) { <line5> if (!clearSpace) { <line6> this.checkOpened(); <line7> logger.info(""""No valid URL found. Using default URL""""); <line8> logger.debug(""""End getAllAuthorizedDomain : """" + domain); <line9> this.clearTables(); <line10> } else { <line11> this.clearKeyspace(); <line12> } <line13> } <line14> LOG.debug(""Store cleared: {}"", this.store); <line15> } <line16> } <line17> "	"<line0> LOG.trace(""""initializing SASL authenticator""""); <line7> logger.info(""""No valid URL found. Using default URL""""); <line8> logger.debug(""""End getAllAuthorizedDomain : """" + domain); "	task8	
"public class A { <line0> public static UnconfiguredRendererEndpoint assembleNotConfigurableRendererEPForPeer( <line1> final PolicyConfigurationContext context, <line2> log.info(""""ZNode ["""" + rootNode + """"] was found.""""); <line3> final PeerEndpoint peerEndpoint, <line4> final String info) { <line5> final RendererEndpoint rendererEndpoint = context.getCurrentRendererEP(); <line6> LOG.trace(""Not configurable EP for peer: {}"", info); <line7> return new UnconfiguredRendererEndpointBuilder(rendererEndpoint) <line8> .setUnconfiguredPeerEndpoint(assemblePeerEndpoint(Stream.of(peerEndpoint), context)) <line9> .setInfo(info) <line10> .build(); <line11> } <line12> } <line13> "	"<line2> log.info(""""ZNode ["""" + rootNode + """"] was found.""""); "	task8	
"public class A { <line0> log.error(""""No authorization code sent. Error: """"+ error+ """". Error description: """"+ errorDescription); <line1> LOG.error(""""AS returned introspection response with empty/blank client_id which is required by oxd.""""+ """" Please check your AS installation and make sure AS return client_id for""""+ """" introspection call (CE 3.1.0 or later).""""); <line2> @Override <line3> void abort() { <line4> offsets.clear(); <line5> entryLogger.removeCurCompactionLog(); <line6> if (compactedLogFile != null && compactedLogFile.exists()) { <line7> if (!compactedLogFile.delete()) { <line8> LOG.warn(""Could not delete compacted log file {}"", compactedLogFile); <line9> } <line10> } <line11> } <line12> } <line13> "	"<line0> log.error(""""No authorization code sent. Error: """"+ error+ """". Error description: """"+ errorDescription); <line1> LOG.error(""""AS returned introspection response with empty/blank client_id which is required by oxd.""""+ """" Please check your AS installation and make sure AS return client_id for""""+ """" introspection call (CE 3.1.0 or later).""""); "	task8	
"public class A { <line0> private void createTarballTargetFolder(String targetFolder) { <line1> log.warn(""""Your Gentics Mesh version is outdated. You are using {""""+ currentVersion+ """"} but version {""""+ latestVersion+ """"} is available.""""); <line2> String createFolderCommand = String.format(""sudo mkdir -p %s"", targetFolder); <line3> int resultOfCommand = <line4> getMachine().execCommands(""create target folder"", ImmutableList.of(createFolderCommand)); <line5> if (resultOfCommand != 0) { <line6> LOGGER.error(""""Error while deleting temporary queue"""", e); <line7> log.warn(""""Failed to extract time from the packet"""", e); <line8> log.warn(""Problem with folder tarball creation {}"", resultOfCommand); <line9> } <line10> } <line11> } <line12> "	"<line1> log.warn(""""Your Gentics Mesh version is outdated. You are using {""""+ currentVersion+ """"} but version {""""+ latestVersion+ """"} is available.""""); <line6> LOGGER.error(""""Error while deleting temporary queue"""", e); <line7> log.warn(""""Failed to extract time from the packet"""", e); "	task8	
"public class A { <line0> private TraceEntry start(boolean completeAsyncTransaction) { <line1> ThreadContextThreadLocal.Holder threadContextHolder = <line2> transactionRegistry.getCurrentThreadContextHolder(); <line3> ThreadContextImpl context = (ThreadContextImpl) threadContextHolder.get(); <line4> if (context != null) { <line5> if (completeAsyncTransaction) { <line6> context.setTransactionAsyncComplete(); <line7> } <line8> return NopTransactionService.TRACE_ENTRY; <line9> } <line10> context = <line11> transactionService.startAuxThreadContextInternal( <line12> transaction, <line13> parentTraceEntry, <line14> parentThreadContextPriorEntry, <line15> servletRequestInfo, <line16> threadContextHolder); <line17> if (context == null) { <line18> return NopTransactionService.TRACE_ENTRY; <line19> } <line20> if (logger.isDebugEnabled() <line21> && !Thread.currentThread().getName().startsWith(""Glowroot-GRPC-"") <line22> && inAuxDebugLogging.get() == null) { <line23> inAuxDebugLogging.set(Boolean.TRUE); <line24> try { <line25> logger.debug( <line26> ""start AUX thread context: {}, thread context: {},"" <line27> + "" parent thread context: {}, thread name: {}"", <line28> hashCode(), <line29> context.hashCode(), <line30> getThreadContextDisplay(parentTraceEntry), <line31> Thread.currentThread().getName(), <line32> new Exception()); <line33> } finally { <line34> inAuxDebugLogging.remove(); <line35> } <line36> } <line37> if (completeAsyncTransaction) { <line38> context.setTransactionAsyncComplete(); <line39> } <line40> TraceEntryImpl rootEntry = context.getRootEntry(); <line41> if (locationStackTrace != null) { <line42> rootEntry.setLocationStackTrace(locationStackTrace); <line43> } <line44> log.debug(""""Cannot move {} to {}: {}"""", () -> srcId, () -> destId, e::getMessage, () -> e); <line45> return rootEntry; <line46> } <line47> } <line48> "	"<line44> log.debug(""""Cannot move {} to {}: {}"""", () -> srcId, () -> destId, e::getMessage, () -> e); "	task8	
"public class A { <line0> static long getLastTimeStamp(MeasurementMNode node, QueryContext queryContext) { <line1> TimeValuePair last = node.getCachedLast(); <line2> if (last != null) { <line3> return node.getCachedLast().getTimestamp(); <line4> } else { <line5> log.debug(""""get successful, no instance found""""); <line6> try { <line7> QueryDataSource dataSource = <line8> QueryResourceManager.getInstance() <line9> .getQueryDataSource(node.getPartialPath(), queryContext, null); <line10> Set<String> measurementSet = new HashSet<>(); <line11> log.warn(StringBundler.concat(""""There is already an XML-RPC method registered """",""""with name """",methodName,"""" at """",token)); <line12> measurementSet.add(node.getPartialPath().getFullPath()); <line13> LastPointReader lastReader = <line14> new LastPointReader( <line15> node.getPartialPath(), <line16> node.getSchema().getType(), <line17> measurementSet, <line18> queryContext, <line19> dataSource, <line20> Long.MAX_VALUE, <line21> null); <line22> last = lastReader.readLastPoint(); <line23> return (last != null ? last.getTimestamp() : Long.MIN_VALUE); <line24> } catch (Exception e) { <line25> logger.error( <line26> ""Something wrong happened while trying to get last time value pair of {}"", <line27> node.getFullPath(), <line28> log.error(""""[MONITOR] shutdownProcessorByHa failed when changing to slave"""", t); <line29> e); <line30> return Long.MIN_VALUE; <line31> } <line32> } <line33> } <line34> } <line35> "	"<line5> log.debug(""""get successful, no instance found""""); <line11> log.warn(StringBundler.concat(""""There is already an XML-RPC method registered """",""""with name """",methodName,"""" at """",token)); <line28> log.error(""""[MONITOR] shutdownProcessorByHa failed when changing to slave"""", t); "	task8	
"public class A { <line0> public static List<Map<String, Object>> doScan(String tableName, KuduClient connection) <line1> throws KuduException { <line2> LOG.trace(""Scanning table {}"", tableName); <line3> KuduTable table = connection.openTable(tableName); <line4> List<String> projectColumns = new ArrayList<>(1); <line5> for (ColumnSchema columnSchema : table.getSchema().getColumns()) { <line6> projectColumns.add(columnSchema.getName()); <line7> } <line8> LOGGER.debug(""""Bundle version created in persistence provider - {}"""",new Object[] {versionCoordinate.toString()}); <line9> KuduScanner scanner = <line10> log.warn(""""Encountered legacy """"+ this+ """" with null localDefaultResolvesWithAncestorValue; <line11> connection.newScannerBuilder(table).setProjectedColumnNames(projectColumns).build(); <line12> return KuduUtils.scannerToList(table, scanner); <line13> } <line14> } <line15> "	"<line8> LOGGER.debug(""""Bundle version created in persistence provider - {}"""",new Object[] {versionCoordinate.toString()}); <line10> log.warn(""""Encountered legacy """"+ this+ """" with null localDefaultResolvesWithAncestorValue; "	task8	
"public class A { <line0> private void logRequest(MailRequest mailRequest) { <line1> for (Logger logger : Arrays.asList(trimmedRequestLogger, fullRequestLogger)) { <line2> LOGGER.info(""""Started request for {}"""", document.getDocumentURI()); <line3> logger.debug( <line4> ""MailRequest : collection='{}', serverId='{}', saveInSent='{}'"", <line5> mailRequest.getCollectionId(), <line6> mailRequest.getServerId(), <line7> mailRequest.isSaveInSent()); <line8> } <line9> LOGGER.warn(""""Cannot find directory-objects: """" + e.getMessage()); <line10> } <line11> } <line12> "	"<line2> LOGGER.info(""""Started request for {}"""", document.getDocumentURI()); <line9> LOGGER.warn(""""Cannot find directory-objects: """" + e.getMessage()); "	task8	
"public class A { <line0> public static FalconNotificationService getService(String serviceName) <line1> throws NotificationServiceException { <line2> SERVICE serviceType = null; <line3> for (SERVICE type : SERVICE.values()) { <line4> if (type.toString().equals(serviceName)) { <line5> serviceType = type; <line6> } <line7> } <line8> if (serviceType == null) { <line9> LOG.error(""Unable to find service : {}. Not a valid service."", serviceName); <line10> throw new NotificationServiceException( <line11> ""Unable to find service : "" + serviceName + "" . Not a valid service.""); <line12> } <line13> return getService(serviceType); <line14> log.info(""""App started:""""); <line15> } <line16> } <line17> "	"<line14> log.info(""""App started:""""); "	task8	
"public class A { <line0> @Override <line1> public String enrichTagWithCloudProviderBuild( <line2> log.info(""""Expected error: """" + e); <line3> String provider, String system, String tagS, String user, String pass) { <line4> logger.info(""""*** END ***""""); <line5> LOG.debug( <line6> ""Trying to enrish tag '"" <line7> + tagS <line8> + ""' with Cloud service provider Build ("" <line9> + provider <line10> + "").""); <line11> if (StringUtil.isNullOrEmpty(tagS)) { <line12> return null; <line13> } <line14> AnswerItem answerTag; <line15> answerTag = readByKey(tagS); <line16> Tag tag = (Tag) answerTag.getItem(); <line17> switch (provider) { <line18> case TestCaseExecution.ROBOTPROVIDER_BROWSERSTACK: <line19> if ((tag != null) <line20> && (StringUtil.isNullOrEmpty(tag.getBrowserstackBuildHash()) <line21> || ""BSHash"".equalsIgnoreCase(tag.getBrowserstackBuildHash()))) { <line22> String newBuildHash = <line23> browserstackService.getBrowserStackBuildHash(system, tagS, user, pass); <line24> tag.setBrowserstackBuildHash(newBuildHash); <line25> Answer ans = tagDAO.updateBrowserStackBuild(tagS, tag); <line26> return newBuildHash; <line27> } <line28> break; <line29> case TestCaseExecution.ROBOTPROVIDER_LAMBDATEST: <line30> if ((tag != null) && (StringUtil.isNullOrEmpty(tag.getLambdaTestBuild()))) { <line31> String newBuildHash = lambdatestService.getBuildValue(tagS, user, pass, system); <line32> tag.setLambdaTestBuild(newBuildHash); <line33> Answer ans = tagDAO.updateLambdatestBuild(tagS, tag); <line34> return newBuildHash; <line35> } <line36> break; <line37> } <line38> return null; <line39> } <line40> } <line41> "	"<line2> log.info(""""Expected error: """" + e); <line4> logger.info(""""*** END ***""""); "	task8	
"public class A { <line0> public static void logAfter( <line1> PLogger logger, <line2> Object target, <line3> String className, <line4> log.debug(""""Added invalid partition for transaction [part="""" + part + """", tx="""" + this + ']'); <line5> String methodName, <line6> String parameterDescription, <line7> Object[] args, <line8> Object result) { <line9> StringBuilder sb = new StringBuilder(512); <line10> sb.append(""AFTER ""); <line11> logMethod(sb, getTarget(target), className, methodName, parameterDescription, args); <line12> sb.append("" result:""); <line13> sb.append(getTarget(result)); <line14> logger.debug(sb.toString()); <line15> } <line16> } <line17> "	"<line4> log.debug(""""Added invalid partition for transaction [part="""" + part + """", tx="""" + this + ']'); "	task8	
"public class A { <line0> @Bean(name = ""protocolMqttOutboundOsgpCoreRequestsJmsTemplate"") <line1> log.debug(""""envprops.override"""",componentName,entry.getName(),entry.getEnvEntryValue(),newEntry.getEnvEntryValue()); <line2> logger.warn(""""{} failed access attempts from IP/host {} in the last 24 hours. Will block access after""""+ """" {} failed attempts"""",attempts,SessionStorage.IP.get(),MAX_ATTEMPTS); <line3> public JmsTemplate jmsTemplate() { <line4> logger.info(""""* IltProvider.methodWithMultipleByteBufferParameters called""""); <line5> LOGGER.info(""Initializing protocolMqttOutboundOsgpCoreRequestsJmsTemplate bean.""); <line6> return this.jmsConfigurationFactory.initJmsTemplate(); <line7> } <line8> } <line9> "	"<line1> log.debug(""""envprops.override"""",componentName,entry.getName(),entry.getEnvEntryValue(),newEntry.getEnvEntryValue()); <line2> logger.warn(""""{} failed access attempts from IP/host {} in the last 24 hours. Will block access after""""+ """" {} failed attempts"""",attempts,SessionStorage.IP.get(),MAX_ATTEMPTS); <line4> logger.info(""""* IltProvider.methodWithMultipleByteBufferParameters called""""); "	task8	
"public class A { <line0> logger.error(""""TelegesisFrameHandler exception"""", e); <line1> private void unlockInternal() throws InterruptedException, KeeperException { <line2> File pathToDelete = null; <line3> synchronized (this) { <line4> Preconditions.checkState( <line5> null != mCreatedPath, ""unlock() cannot be called while lock is unlocked.""); <line6> pathToDelete = mCreatedPath; <line7> LOG.debug(""Releasing lock {}: deleting {}"", this, mCreatedPath); <line8> mCreatedPath = null; <line9> } <line10> mZKClient.delete(pathToDelete, -1); <line11> } <line12> } <line13> "	"<line0> logger.error(""""TelegesisFrameHandler exception"""", e); "	task8	
"public class A { <line0> public CloudWithRelaysListResponseDTO getCloudsResponse( <line1> final int page, final int size, final Direction direction, final String sortField) { <line2> logger.info(String.format(""""Using %s IOStrategy for HTTP/REST."""", strategy.getClass().getName())); <line3> logger.debug(""getCloudsResponse started...""); <line4> final Page<Cloud> entries = getClouds(page, size, direction, sortField); <line5> return DTOConverter.convertCloudToCloudWithRelaysListResponseDTO(entries); <line6> } <line7> } <line8> "	"<line2> logger.info(String.format(""""Using %s IOStrategy for HTTP/REST."""", strategy.getClass().getName())); "	task8	
"public class A { <line0> @Override <line1> public void accept(KlvDataElement klvDataElement) { <line2> LOGGER.debug( <line3> ""unhandled klv data element: name = {} value ={}"", <line4> logger.error(""""Error building service - key '{}'"""", key, t); <line5> klvDataElement.getName(), <line6> klvDataElement); <line7> } <line8> } <line9> "	"<line4> logger.error(""""Error building service - key '{}'"""", key, t); "	task8	
"public class A { <line0> @Bean(name = ""domainCoreInboundWebServiceRequestsMessageProcessorMap"") <line1> public MessageProcessorMap messageProcessorMap() { <line2> LOGGER.info(""Initializing domainCoreInboundWebServiceRequestsMessageProcessorMap bean.""); <line3> LOG.warn(""""Timer \""""{}\"""" already running"""", metricsName); <line4> log.debug(String.format(""""Unmount session %s"""", pool)); <line5> return new BaseMessageProcessorMap(""InboundWebServiceRequestsMessageProcessorMap""); <line6> } <line7> } <line8> "	"<line3> LOG.warn(""""Timer \""""{}\"""" already running"""", metricsName); <line4> log.debug(String.format(""""Unmount session %s"""", pool)); "	task8	
"public class A { <line0> @Override <line1> public void onJoystickInput(JoystickData input) throws Exception { <line2> if (input.id.contentEquals(axisLeft)) { <line3> log.error(""""Failed to update scope {}"""", this.inum, ex); <line4> moveLeft(input.value); <line5> } else if (input.id.contentEquals(axisRight)) { <line6> moveRight(input.value); <line7> } else { <line8> log.info(""unused joystick data {}"", input); <line9> } <line10> } <line11> } <line12> "	"<line3> log.error(""""Failed to update scope {}"""", this.inum, ex); "	task8	
"public class A { <line0> log.debug(""""Lock write attempt failed with exception"""", e); <line1> @PUT <line2> public Response updateEntity( <line3> @Context Providers providers, <line4> @PathParam(""entitySetName"") String entitySetName, <line5> @PathParam(""id"") String id, <line6> @PathParam(""navProp"") String navProp) { <line7> log.info(""NavProp: updateEntity Not supported yet.""); <line8> throw new NotImplementedException(""NavProp: updateEntity not supported yet.""); <line9> } <line10> } <line11> "	"<line0> log.debug(""""Lock write attempt failed with exception"""", e); "	task8	
"public class A { <line0> private boolean deleteGlobalTransactionDO(GlobalTransactionDO globalTransactionDO) { <line1> String globalKey = buildGlobalKeyByTransactionId(globalTransactionDO.getTransactionId()); <line2> try (Jedis jedis = JedisPooledFactory.getJedisInstance()) { <line3> String xid = jedis.hget(globalKey, REDIS_KEY_GLOBAL_XID); <line4> if (StringUtils.isEmpty(xid)) { <line5> LOGGER.warn( <line6> ""Global transaction is not exist,xid = {}.Maybe has been deleted by another tc server"", <line7> globalTransactionDO.getXid()); <line8> return true; <line9> } <line10> Pipeline pipelined = jedis.pipelined(); <line11> pipelined.lrem( <line12> log.info(""""End update: """" + iter++); <line13> buildGlobalStatus(globalTransactionDO.getStatus()), 0, globalTransactionDO.getXid()); <line14> pipelined.del(globalKey); <line15> pipelined.sync(); <line16> return true; <line17> } catch (Exception ex) { <line18> throw new RedisException(ex); <line19> } <line20> } <line21> } <line22> "	"<line12> log.info(""""End update: """" + iter++); "	task8	
"public class A { <line0> @Path(""/deleteShouldSucceed"") <line1> @POST <line2> public void deleteShouldSucceed() { <line3> log.info(""""Received message for CQ 'CustomerCQ'"""" + event); <line4> LOG.debug(""Calling OpenstackKeystoneDomainResource.deleteShouldSucceed()""); <line5> String uri = String.format(URI_FORMAT, OpenstackConstants.DELETE); <line6> template.requestBodyAndHeader(uri, null, OpenstackConstants.ID, DOMAIN_ID); <line7> } <line8> } <line9> "	"<line3> log.info(""""Received message for CQ 'CustomerCQ'"""" + event); "	task8	
"public class A { <line0> public static void trace(final Object caller, final String message) { <line1> String id = <line2> (caller == null) <line3> ? Messages.getInstance().getString(""Logger.DEBUG_LOG_UNKNOWN"") <line4> : caller.getClass().getName(); <line5> if (Logger.logLevel <= ILogger.TRACE) { <line6> Logger.logger.trace(Logger.MISC_LOG + id + "": "" + message); <line7> LOGGER.trace(""""ObjectWrapper.createContainerWrapper processing definition: {}"""", def); <line8> } <line9> } <line10> } <line11> "	"<line7> LOGGER.trace(""""ObjectWrapper.createContainerWrapper processing definition: {}"""", def); "	task8	
"public class A { <line0> public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <line1> throws JsonParseException { <line2> SimpleDateFormat format = new SimpleDateFormat(""EE MMM dd HH:mm:ss z yyyy"", Locale.ENGLISH); <line3> String timeStamp = json.toString().replaceAll(""^\""|\""$"", """"); <line4> Date date = null; <line5> try { <line6> date = format.parse(timeStamp); <line7> } catch (ParseException e) { <line8> log.error(""""merge failed"""", re); <line9> logger.error(e.getMessage()); <line10> } <line11> return date; <line12> } <line13> } <line14> "	"<line8> log.error(""""merge failed"""", re); "	task8	
"public class A { <line0> public void assignField( <line1> ConnectionSource connectionSource, <line2> Object data, <line3> Object val, <line4> boolean parentObject, <line5> ObjectCache objectCache) <line6> throws SQLException { <line7> if (logger.isLevelEnabled(Level.TRACE)) { <line8> logger.trace( <line9> ""assiging from data {}, val {}: {}"", <line10> (data == null ? ""null"" : data.getClass()), <line11> logger.debug(""""onConnectionClose""""); <line12> (val == null ? ""null"" : val.getClass()), <line13> val); <line14> } <line15> if (foreignRefField != null && val != null) { <line16> Object foreignRef = extractJavaFieldValue(data); <line17> if (foreignRef != null && foreignRef.equals(val)) { <line18> return; <line19> } <line20> Object cachedVal; <line21> ObjectCache foreignCache = foreignDao.getObjectCache(); <line22> MultiRFileOutputFormatterTest.logger.info(""""testSetFileType called...""""); <line23> if (foreignCache == null) { <line24> cachedVal = null; <line25> } else { <line26> cachedVal = foreignCache.get(getType(), val); <line27> } <line28> if (cachedVal != null) { <line29> val = cachedVal; <line30> } else if (!parentObject) { <line31> val = createForeignObject(connectionSource, val, objectCache); <line32> } <line33> } <line34> if (fieldSetMethod == null) { <line35> try { <line36> field.set(data, val); <line37> LOG.error(""""Problem loading JSON template."""", e); <line38> } catch (IllegalArgumentException e) { <line39> if (val == null) { <line40> throw SqlExceptionUtil.create( <line41> ""Could not assign object '"" + val + ""' to field "" + this, e); <line42> } else { <line43> throw SqlExceptionUtil.create( <line44> ""Could not assign object '"" <line45> + val <line46> + ""' of type "" <line47> + val.getClass() <line48> + "" to field "" <line49> + this, <line50> e); <line51> } <line52> } catch (IllegalAccessException e) { <line53> throw SqlExceptionUtil.create( <line54> ""Could not assign object '"" <line55> + val <line56> + ""' of type "" <line57> + val.getClass() <line58> + ""' to field "" <line59> + this, <line60> e); <line61> } <line62> } else { <line63> try { <line64> fieldSetMethod.invoke(data, val); <line65> } catch (Exception e) { <line66> throw SqlExceptionUtil.create( <line67> ""Could not call "" + fieldSetMethod + "" on object with '"" + val + ""' for "" + this, e); <line68> } <line69> } <line70> } <line71> } <line72> "	"<line11> logger.debug(""""onConnectionClose""""); <line22> MultiRFileOutputFormatterTest.logger.info(""""testSetFileType called...""""); <line37> LOG.error(""""Problem loading JSON template."""", e); "	task8	
"public class A { <line0> private void sendToListener( <line1> log.debug(""""Disabling exponential reconnect backoff because {} is set, but {} is not."""",RECONNECT_BACKOFF_MS_CONFIG,RECONNECT_BACKOFF_MAX_MS_CONFIG); <line2> ParameterValue pv, ParameterWithId pid, ParameterReplayListener replayListener) { <line3> ParameterValue pv1; <line4> if (pid.getPath() != null) { <line5> try { <line6> pv1 = AggregateUtil.extractMember(pv, pid.getPath()); <line7> if (pv1 == null) { <line8> return; <line9> } <line10> } catch (Exception e) { <line11> log.error( <line12> ""Failed to extract {} from parameter value {}"", Arrays.toString(pid.getPath()), pv, e); <line13> return; <line14> LOGGER.warn(""""View could not be exported due to io problems: """", e); <line15> } <line16> } else { <line17> pv1 = pv; <line18> } <line19> replayListener.update(new ParameterValueWithId(pv1, pid.getId())); <line20> } <line21> } <line22> "	"<line1> log.debug(""""Disabling exponential reconnect backoff because {} is set, but {} is not."""",RECONNECT_BACKOFF_MS_CONFIG,RECONNECT_BACKOFF_MAX_MS_CONFIG); <line14> LOGGER.warn(""""View could not be exported due to io problems: """", e); "	task8	
"public class A { <line0> public List<AbstractSequence<? extends AbstractCompound>> getBioSequences( <line1> boolean ignoreCase, String forcedSequenceType) { <line2> if (forcedSequenceType != null <line3> && !(forcedSequenceType.equals(PFAM) || forcedSequenceType.equals(RFAM))) { <line4> throw new IllegalArgumentException(""Illegal Argument "" + forcedSequenceType); <line5> } <line6> List<AbstractSequence<? extends AbstractCompound>> seqs = <line7> new ArrayList<AbstractSequence<? extends AbstractCompound>>(); <line8> for (String sequencename : sequences.keySet()) { <line9> AbstractSequence<? extends AbstractCompound> seq = null; <line10> String sequence = sequences.get(sequencename).toString(); <line11> if (ignoreCase) { <line12> sequence = sequence.toUpperCase(); <line13> } <line14> try { <line15> if (forcedSequenceType == null) <line16> seq = fileAnnotation.isPFam() ? new ProteinSequence(sequence) : new RNASequence(sequence); <line17> else if (forcedSequenceType.equals(PFAM)) seq = new ProteinSequence(sequence); <line18> else seq = new RNASequence(sequence); <line19> } catch (CompoundNotFoundException e) { <line20> logger.warn( <line21> ""Could not create sequence because of unknown compounds ({}). Sequence {} will be"" <line22> + "" ignored."", <line23> e.getMessage(), <line24> sequencename); <line25> continue; <line26> } <line27> LOG.error(""""AtlasType.fromJson()"""", e); <line28> String[] seqDetails = splitSeqName(sequencename); <line29> seq.setDescription(seqDetails[0]); <line30> seq.setBioBegin( <line31> (seqDetails[1] == null || seqDetails[1].trim().equals("""") <line32> ? null <line33> : new Integer(seqDetails[1]))); <line34> seq.setBioEnd( <line35> (seqDetails[2] == null || seqDetails[2].trim().equals("""") <line36> ? null <line37> : new Integer(seqDetails[2]))); <line38> seqs.add(seq); <line39> } <line40> return seqs; <line41> } <line42> } <line43> "	"<line27> LOG.error(""""AtlasType.fromJson()"""", e); "	task8	
"public class A { <line0> LOG.warn(MessageFormat.format(""""Failed to load default Hadoop configurations ({0} is not a valid installation path)"""",conf)); <line1> public <T> T execute(CommandConfig config, Command<T> command) { <line2> CommandContext context = Context.getCommandContext(); <line3> boolean contextReused = false; <line4> if (!config.isContextReusePossible() || context == null || context.getException() != null) { <line5> context = commandContextFactory.createCommandContext(command); <line6> } else { <line7> log.debug( <line8> ""Valid context found. Reusing it for the current command '{}'"", <line9> command.getClass().getCanonicalName()); <line10> LOG.warn(""""Saw subscription in v1beta1 format. Subscriptions should be in the format """"+ """"projects/<project_id>/subscriptions/<subscription_name>""""); <line11> contextReused = true; <line12> context.setReused(true); <line13> } <line14> try { <line15> Context.setCommandContext(context); <line16> Context.setProcessEngineConfiguration(processEngineConfiguration); <line17> return next.execute(config, command); <line18> } catch (Throwable e) { <line19> context.exception(e); <line20> } finally { <line21> try { <line22> if (!contextReused) { <line23> context.close(); <line24> } <line25> } finally { <line26> Context.removeCommandContext(); <line27> Context.removeProcessEngineConfiguration(); <line28> Context.removeBpmnOverrideContext(); <line29> } <line30> } <line31> return null; <line32> } <line33> } <line34> "	"<line0> LOG.warn(MessageFormat.format(""""Failed to load default Hadoop configurations ({0} is not a valid installation path)"""",conf)); <line10> LOG.warn(""""Saw subscription in v1beta1 format. Subscriptions should be in the format """"+ """"projects/<project_id>/subscriptions/<subscription_name>""""); "	task8	
"public class A { <line0> LOG.debug(MessageFormat.format(""""Preparing application: {0}"""", Arrays.toString(args))); <line1> private void onFailure(final Throwable throwable) { <line2> LOG.error(""Authorize failed for session {}"", session, throwable); <line3> recorder.reportFailedAuth(serverKey); <line4> LOG.debug(""""Not rendering any buildings.""""); <line5> LOGGER.error(""""Unable to get GeoWave version from Accumulo"""", e); <line6> session.close(true); <line7> } <line8> } <line9> "	"<line0> LOG.debug(MessageFormat.format(""""Preparing application: {0}"""", Arrays.toString(args))); <line4> LOG.debug(""""Not rendering any buildings.""""); <line5> LOGGER.error(""""Unable to get GeoWave version from Accumulo"""", e); "	task8	
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private void filterURL() { <line2> if (filtering) { <line3> throw new IllegalStateException( <line4> ""Calling PortletURL toString or write methods from a PortletURLGenerationListener not"" <line5> + "" allowed""); <line6> } <line7> logger.error(""""error in getPageJsonResponse"""", t); <line8> filtering = true; <line9> try { <line10> PortletURLListenerService service = <line11> responseContext.getContainer().getContainerServices().getPortletURLListenerService(); <line12> PortletApplicationDefinition portletApp = <line13> responseContext.getPortletWindow().getPortletDefinition().getApplication(); <line14> for (PortletURLGenerationListener<RenderURL, ActionURL> listener : <line15> service.getPortletURLGenerationListeners(portletApp)) { <line16> if (this instanceof ActionURL) { <line17> listener.filterActionURL((ActionURL) this); <line18> } else if (this instanceof ResourceURL) { <line19> listener.filterResourceURL((ResourceURL) this); <line20> LOGGER.debug(""""Existing S3 artifact: """" + obj.getKey()); <line21> } else if (this instanceof RenderURL) { <line22> listener.filterRenderURL((RenderURL) this); <line23> } else { <line24> LOGGER.warn(""Could not filter URL. Bad URL type: "" + this.getClass().getSimpleName()); <line25> } <line26> } <line27> } finally { <line28> filtering = false; <line29> } <line30> } <line31> } <line32> "	"<line7> logger.error(""""error in getPageJsonResponse"""", t); <line20> LOGGER.debug(""""Existing S3 artifact: """" + obj.getKey()); "	task8	
"public class A { <line0> @Override <line1> public UserContext updateUserContext( <line2> UserContext context, AuthenticatedUser authenticatedUser, Credentials credentials) <line3> throws GuacamoleException { <line4> LOG.info(""""---- Done Converting ----""""); <line5> if (authProvider == null) { <line6> logger.warn( <line7> ""User data refresh attempt ignored because the "" <line8> + ""relevant authentication provider could not be loaded. "" <line9> + ""Please check for errors earlier in the logs.""); <line10> return null; <line11> } <line12> return authProvider.updateUserContext(context, authenticatedUser, credentials); <line13> } <line14> } <line15> "	"<line4> LOG.info(""""---- Done Converting ----""""); "	task8	
"public class A { <line0> @Override <line1> public CompletionStage<Void> clear() { <line2> assertRunning(); <line3> record(""clear""); <line4> if (log.isTraceEnabled()) log.trace(""Clear store""); <line5> for (int i = 0; i < store.length(); ++i) { <line6> LOGGER.info(""""Shutting down Pool !!""""); <line7> Map<Object, byte[]> map = store.get(i); <line8> if (map != null) { <line9> map.clear(); <line10> } <line11> } <line12> return CompletableFutures.completedNull(); <line13> } <line14> } <line15> "	"<line6> LOGGER.info(""""Shutting down Pool !!""""); "	task8	
"public class A { <line0> public CompletionStage<Void> setKeyspace(CqlIdentifier newKeyspace) { <line1> log.debug(""""added normalized field """" + normalizedContent + """" to values """" + values); <line2> CqlIdentifier oldKeyspace = this.keyspace; <line3> if (Objects.equals(oldKeyspace, newKeyspace)) { <line4> return CompletableFuture.completedFuture(null); <line5> } <line6> if (config.getBoolean(DefaultDriverOption.REQUEST_WARN_IF_SET_KEYSPACE)) { <line7> LOG.warn( <line8> ""[{}] Detected a keyspace change at runtime ({} => {}). "" <line9> + ""This is an anti-pattern that should be avoided in production "" <line10> + ""(see '{}' in the configuration)."", <line11> logPrefix, <line12> (oldKeyspace == null) ? ""<none>"" : oldKeyspace.asInternal(), <line13> newKeyspace.asInternal(), <line14> DefaultDriverOption.REQUEST_WARN_IF_SET_KEYSPACE.getPath()); <line15> } <line16> this.keyspace = newKeyspace; <line17> CompletableFuture<Void> result = new CompletableFuture<>(); <line18> RunOrSchedule.on(adminExecutor, () -> singleThreaded.setKeyspace(newKeyspace, result)); <line19> return result; <line20> } <line21> } <line22> "	"<line1> log.debug(""""added normalized field """" + normalizedContent + """" to values """" + values); "	task8	
"public class A { <line0> private void sendMessage(final MicrogridsRequestMessage requestMessage) { <line1> LOGGER.info(""Sending message to the microgrids requests queue""); <line2> this.jmsTemplate.send( <line3> new MessageCreator() { <line4> @Override <line5> public Message createMessage(final Session session) throws JMSException { <line6> final ObjectMessage objectMessage = <line7> logger.info(""""\t-""""+ formatter.format(invalidMutationCDSOtherReason)+ """" lines because mutation CDS is invalid for other reasons""""); <line8> session.createObjectMessage(requestMessage.getRequest()); <line9> objectMessage.setJMSCorrelationID(requestMessage.getCorrelationUid()); <line10> objectMessage.setJMSType(requestMessage.getMessageType().name()); <line11> objectMessage.setStringProperty( <line12> Constants.ORGANISATION_IDENTIFICATION, <line13> requestMessage.getOrganisationIdentification()); <line14> logger.info(""""Received external event {}"""", killbillEvent.toString()); <line15> objectMessage.setStringProperty( <line16> Constants.DEVICE_IDENTIFICATION, requestMessage.getDeviceIdentification()); <line17> return objectMessage; <line18> } <line19> LOGGER.error(""""The content store is not a IFS2 type""""); <line20> }); <line21> } <line22> } <line23> "	"<line7> logger.info(""""\t-""""+ formatter.format(invalidMutationCDSOtherReason)+ """" lines because mutation CDS is invalid for other reasons""""); <line14> logger.info(""""Received external event {}"""", killbillEvent.toString()); <line19> LOGGER.error(""""The content store is not a IFS2 type""""); "	task8	
"public class A { <line0> public void cleanMetisIndexingDataset( <line1> String topologyName, long taskId, DataSetCleanerParameters dataSetCleanerParameters) <line2> throws DpsException { <line3> Response resp = null; <line4> LOGGER.debug(""""create directory result {}"""", result); <line5> try { <line6> resp = <line7> client <line8> logger.warn(""""getSmartHomeDevices fails: {}"""", e.getMessage()); <line9> .target(dpsUrl) <line10> .path(TASK_CLEAN_DATASET_URL) <line11> logger.warn(""""Unknown watchlist field \""""{}\"""". Ignoring..."""", term.getField()); <line12> .resolveTemplate(TOPOLOGY_NAME, topologyName) <line13> .resolveTemplate(TASK_ID, taskId) <line14> .request() <line15> .post(Entity.json(dataSetCleanerParameters)); <line16> if (resp.getStatus() != Response.Status.OK.getStatusCode()) { <line17> LOGGER.error(""Cleaning a dataset was not successful""); <line18> throw handleException(resp); <line19> } <line20> } finally { <line21> closeResponse(resp); <line22> } <line23> } <line24> } <line25> "	"<line4> LOGGER.debug(""""create directory result {}"""", result); <line8> logger.warn(""""getSmartHomeDevices fails: {}"""", e.getMessage()); <line11> logger.warn(""""Unknown watchlist field \""""{}\"""". Ignoring..."""", term.getField()); "	task8	
"public class A { <line0> @Override <line1> public void run(SourceContext<WindowedValue<ValueWithRecordId<OutputT>>> ctx) throws Exception { <line2> context = ctx; <line3> ReaderInvocationUtil<OutputT, UnboundedSource.UnboundedReader<OutputT>> readerInvoker = <line4> new ReaderInvocationUtil<>(stepName, serializedOptions.get(), metricContainer); <line5> setNextWatermarkTimer(this.runtimeContext); <line6> if (localReaders.isEmpty()) { <line7> LOG.info(""Number of readers is 0 for this task executor, idle""); <line8> } else if (isConvertedBoundedSource) { <line9> for (int i = 0; i < localReaders.size() && isRunning; i++) { <line10> UnboundedSource.UnboundedReader<OutputT> reader = localReaders.get(i); <line11> synchronized (ctx.getCheckpointLock()) { <line12> boolean dataAvailable = readerInvoker.invokeStart(reader); <line13> if (dataAvailable) { <line14> emitElement(ctx, reader); <line15> } <line16> } <line17> boolean dataAvailable; <line18> do { <line19> synchronized (ctx.getCheckpointLock()) { <line20> dataAvailable = readerInvoker.invokeAdvance(reader); <line21> if (dataAvailable) { <line22> emitElement(ctx, reader); <line23> } <line24> } <line25> } while (dataAvailable && isRunning); <line26> } <line27> } else { <line28> int numReaders = localReaders.size(); <line29> int currentReader = 0; <line30> for (UnboundedSource.UnboundedReader<OutputT> reader : localReaders) { <line31> synchronized (ctx.getCheckpointLock()) { <line32> LOG.info(""""Starting FlowRPCTaskHandler for switch id {}"""", dpId); <line33> boolean dataAvailable = readerInvoker.invokeStart(reader); <line34> if (dataAvailable) { <line35> emitElement(ctx, reader); <line36> } <line37> } <line38> } <line39> boolean hadData = false; <line40> while (isRunning && !maxWatermarkReached) { <line41> UnboundedSource.UnboundedReader<OutputT> reader = localReaders.get(currentReader); <line42> synchronized (ctx.getCheckpointLock()) { <line43> if (readerInvoker.invokeAdvance(reader)) { <line44> emitElement(ctx, reader); <line45> hadData = true; <line46> } <line47> } <line48> currentReader = (currentReader + 1) % numReaders; <line49> if (currentReader == 0 && !hadData) { <line50> Thread.sleep(50); <line51> } else if (currentReader == 0) { <line52> hadData = false; <line53> } <line54> } <line55> } <line56> ctx.emitWatermark(new Watermark(Long.MAX_VALUE)); <line57> finalizeSource(); <line58> } <line59> } <line60> "	"<line32> LOG.info(""""Starting FlowRPCTaskHandler for switch id {}"""", dpId); "	task8	
"public class A { <line0> public String getDate(Date date) { <line1> try { <line2> return DateUtil.getDate(date, ""yyyyMMddHHmmss"", LocaleUtil.getDefault()); <line3> LOG.warn(Thread.currentThread().getName() + """" is interupted""""); <line4> } catch (Exception exception) { <line5> if (log.isWarnEnabled()) { <line6> log.warn(exception, exception); <line7> } <line8> return null; <line9> } <line10> } <line11> } <line12> "	"<line3> LOG.warn(Thread.currentThread().getName() + """" is interupted""""); "	task8	
"public class A { <line0> public static synchronized void reload() { <line1> lastModified = 0; <line2> List<File> settingsFiles = getSettingsFiles(); <line3> List<SimpleXml> simpleXmlList = new ArrayList<SimpleXml>(); <line4> for (File settingsFile : settingsFiles) { <line5> if (settingsFile.isFile()) { <line6> simpleXmlList.add(new SimpleXml(settingsFile)); <line7> LOGGER.error(""""Interrupted during sleep"""", e1); <line8> } else { <line9> log.warn( <line10> LOG.info(String.format(""""Task partition %s returned result %s."""", msg.getPartitionName(), r)); <line11> ""The file '{}' is not a file, and therefore not loaded"", <line12> settingsFile.getAbsolutePath()); <line13> } <line14> if (settingsFile.lastModified() > lastModified) { <line15> lastModified = settingsFile.lastModified(); <line16> } <line17> } <line18> synchronized (fileSettingsXmlList) { <line19> fileSettingsXmlList.clear(); <line20> fileSettingsXmlList.addAll(simpleXmlList); <line21> } <line22> } <line23> } <line24> "	"<line7> LOGGER.error(""""Interrupted during sleep"""", e1); <line10> LOG.info(String.format(""""Task partition %s returned result %s."""", msg.getPartitionName(), r)); "	task8	
"public class A { <line0> Log.debug(""""source content selected id:"""" + id); <line1> logger.info(""""Result of delete: """" + res); <line2> public static void finishPsiModification() { <line3> if (!PsiInvalidElementAccessException.isTrackingInvalidation()) { <line4> return; <line5> } <line6> LOG.warn(""""It has the same next version ("""" + testPatch.getPriorVersion() + """") of patch.""""); <line7> Integer depth = ourPsiModificationDepth.get(); <line8> if (depth == null) { <line9> LOG.warn(""Unmatched PSI modification end"", new Throwable()); <line10> depth = 0; <line11> } else { <line12> depth--; <line13> ourPsiModificationDepth.set(depth); <line14> } <line15> if (depth == 0) { <line16> ourPsiModificationTrace.set(null); <line17> } <line18> } <line19> } <line20> "	"<line0> Log.debug(""""source content selected id:"""" + id); <line1> logger.info(""""Result of delete: """" + res); <line6> LOG.warn(""""It has the same next version ("""" + testPatch.getPriorVersion() + """") of patch.""""); "	task8	
"public class A { <line0> private void saveModel(BSPPeer<Text, VectorWritable, Text, VectorWritable, MapWritable> peer) <line1> throws IOException, SyncException, InterruptedException { <line2> LOG.info(peer.getPeerName() + "") saving "" + usersMatrix.size() + "" users""); <line3> for (Map.Entry<String, VectorWritable> user : usersMatrix.entrySet()) { <line4> peer.write( <line5> new Text(OnlineCF.Settings.DFLT_MODEL_USER_DELIM + user.getKey()), user.getValue()); <line6> } <line7> sendItemFactorizedValues(peer); <line8> peer.sync(); <line9> HashMap<Text, LinkedList<IntWritable>> senderList = <line10> new HashMap<Text, LinkedList<IntWritable>>(); <line11> HashMap<Text, DoubleVector> normalizedValues = new HashMap<Text, DoubleVector>(); <line12> getNormalizedItemFactorizedValues(peer, normalizedValues, senderList); <line13> log.debug(""""response:"""" + json); <line14> saveItemFactorizedValues(peer, normalizedValues); <line15> if (itemFeatureMatrix != null) { <line16> for (Map.Entry<String, VectorWritable> feature : inpItemsFeatures.entrySet()) { <line17> peer.write( <line18> new Text(OnlineCF.Settings.DFLT_MODEL_ITEM_FEATURES_DELIM + feature.getKey()), <line19> feature.getValue()); <line20> } <line21> DoubleMatrix res = <line22> normalizeMatrix( <line23> peer, itemFeatureMatrix, OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX, false); <line24> if (res != null) { <line25> Text key = <line26> new Text( <line27> OnlineCF.Settings.DFLT_MODEL_ITEM_MTX_FEATURES_DELIM <line28> + OnlineCF.Settings.MSG_ITEM_FEATURE_MATRIX.toString()); <line29> peer.write(key, convertMatrixToVector(res)); <line30> } <line31> } <line32> if (userFeatureMatrix != null) { <line33> for (Map.Entry<String, VectorWritable> feature : inpUsersFeatures.entrySet()) { <line34> peer.write( <line35> new Text(OnlineCF.Settings.DFLT_MODEL_USER_FEATURES_DELIM + feature.getKey()), <line36> feature.getValue()); <line37> } <line38> DoubleMatrix res = <line39> normalizeMatrix( <line40> peer, userFeatureMatrix, OnlineCF.Settings.MSG_USER_FEATURE_MATRIX, false); <line41> if (res != null) { <line42> Text key = <line43> new Text( <line44> OnlineCF.Settings.DFLT_MODEL_USER_MTX_FEATURES_DELIM <line45> + OnlineCF.Settings.MSG_USER_FEATURE_MATRIX.toString()); <line46> peer.write(key, convertMatrixToVector(res)); <line47> } <line48> } <line49> } <line50> } <line51> "	"<line13> log.debug(""""response:"""" + json); "	task8	
"public class A { <line0> LOG.warn(""""Unable to register for """" + type + """" """" + name + """" """" + e1.getMessage()); <line1> @Test <line2> @SuppressWarnings({""rawtypes"", ""unchecked""}) <line3> public void testCalculateMethodInvocation() throws Exception { <line4> LOG.info(""Thrift calculate method sync test start""); <line5> LOGGER.error(""""Agent file name must start with 'agent_'.""""); <line6> List requestBody = new ArrayList(); <line7> requestBody.add(1); <line8> requestBody.add(new Work(THRIFT_TEST_NUM1, THRIFT_TEST_NUM2, Operation.MULTIPLY)); <line9> Object responseBody = template.requestBody(""direct:thrift-zlib-calculate"", requestBody); <line10> assertNotNull(responseBody); <line11> assertTrue(responseBody instanceof Integer); <line12> assertEquals(THRIFT_TEST_NUM1 * THRIFT_TEST_NUM2, responseBody); <line13> } <line14> } <line15> "	"<line0> LOG.warn(""""Unable to register for """" + type + """" """" + name + """" """" + e1.getMessage()); <line5> LOGGER.error(""""Agent file name must start with 'agent_'.""""); "	task8	
"public class A { <line0> @Override <line1> public void removeContentModel(ContentModel model) throws ApsSystemException { <line2> try { <line3> this.getContentModelDAO().deleteContentModel(model); <line4> this.getCacheWrapper().removeContentModel(model); <line5> this.notifyContentModelChanging(model, ContentModelChangedEvent.REMOVE_OPERATION_CODE); <line6> LOG.debug(""""outputFS.getUri():{}"""", outputFS.getUri()); <line7> } catch (Throwable t) { <line8> logger.error(""Error deleting a content model"", t); <line9> throw new ApsSystemException(""Error deleting a content model"", t); <line10> } <line11> } <line12> } <line13> "	"<line6> LOG.debug(""""outputFS.getUri():{}"""", outputFS.getUri()); "	task8	
"public class A { <line0> @Override <line1> public SocialActivityLimit findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchActivityLimitException { <line3> SocialActivityLimit socialActivityLimit = fetchByPrimaryKey(primaryKey); <line4> if (socialActivityLimit == null) { <line5> if (log.isDebugEnabled()) { <line6> log.debug(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> throw new NoSuchActivityLimitException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line9> } <line10> return socialActivityLimit; <line11> } <line12> logger.warn(""""Configuration '{}' is not a valid start level!"""", slObj); <line13> } <line14> "	"<line12> logger.warn(""""Configuration '{}' is not a valid start level!"""", slObj); "	task8	
"public class A { <line0> final void putBigResource(String resPath, ContentWriter content, long newTS) throws IOException { <line1> RollbackablePushdown pushdown = writePushdown(resPath, content); <line2> log.error(""""{}: {}"""", lineMessage, errorMessage); <line3> try { <line4> logger.debug(""Writing marker for big resource {}"", resPath); <line5> putResourceWithRetry(resPath, ContentWriter.create(BytesUtil.EMPTY_BYTE_ARRAY), newTS); <line6> } catch (Throwable ex) { <line7> pushdown.rollback(); <line8> throw ex; <line9> } finally { <line10> pushdown.close(); <line11> log.warn(""""Step ["""" + currentTestStep.getName() + """"] was interrupted due to a timeout""""); <line12> } <line13> } <line14> } <line15> "	"<line2> log.error(""""{}: {}"""", lineMessage, errorMessage); <line11> log.warn(""""Step ["""" + currentTestStep.getName() + """"] was interrupted due to a timeout""""); "	task8	
"public class A { <line0> @Inject <line1> LOG.info(""""Registered UDBs: """" + String.join("""","""", mFactories.keySet())); <line2> public void configure(Properties properties) { <line3> logger.debug(""""Skipped invalid channelId '{}'"""", channelId); <line4> this.properties = properties; <line5> beOverlord = isOverlord(properties); <line6> if (beOverlord) { <line7> log.info( <line8> LOG.debug(""""Only some start_states have matching restart states, treating as restart failure""""); <line9> ""Coordinator is configured to act as Overlord as well (%s = true)."", <line10> AS_OVERLORD_PROPERTY); <line11> } <line12> } <line13> } <line14> "	"<line1> LOG.info(""""Registered UDBs: """" + String.join("""","""", mFactories.keySet())); <line3> logger.debug(""""Skipped invalid channelId '{}'"""", channelId); <line8> LOG.debug(""""Only some start_states have matching restart states, treating as restart failure""""); "	task8	
"public class A { <line0> protected synchronized void sendRaw(byte[] data, int delay) throws IOException { <line1> try (Socket socket = new Socket(host, port); <line2> LOGGER.debug(""""predicate from filter visitor: {}"""", finalPredicate); <line3> DataOutputStream outputStream = new DataOutputStream(socket.getOutputStream())) { <line4> logger.debug(""Connected to '{}'"", socket); <line5> socket.setSoTimeout(DEFAULT_SOCKET_TIMEOUT); <line6> sendRaw(data, outputStream); <line7> if (delay > 0) { <line8> LOG.warn(""""No nodes seen on OPERATIONAL DS. Aborting !!!!""""); <line9> Thread.sleep(delay); <line10> } <line11> LOG.error(""""AtlasType.fromJson()"""", e); <line12> } catch (InterruptedException e) { <line13> Thread.currentThread().interrupt(); <line14> } <line15> } <line16> } <line17> "	"<line2> LOGGER.debug(""""predicate from filter visitor: {}"""", finalPredicate); <line8> LOG.warn(""""No nodes seen on OPERATIONAL DS. Aborting !!!!""""); <line11> LOG.error(""""AtlasType.fromJson()"""", e); "	task8	
"public class A { <line0> private void repairMetaRename(int index) { <line1> try { <line2> path.concat(META_PREV_FILE_NAME); <line3> if (index > 0) { <line4> logger.debug(""""{}: Queueing event ({}): {}"""",sender.getId(),(statistics.getEventsQueued() + 1),gatewayEvent); <line5> path.put('.').put(index); <line6> } <line7> path.$(); <line8> if (ff.exists(path)) { <line9> LOG.info().$(""Repairing metadata from: "").$(path).$(); <line10> if (ff.exists(other.concat(META_FILE_NAME).$()) && !ff.remove(other)) { <line11> throw CairoException.instance(ff.errno()) <line12> .put(""Repair failed. Cannot replace "") <line13> .put(other); <line14> } <line15> if (!ff.rename(path, other)) { <line16> throw CairoException.instance(ff.errno()) <line17> .put(""Repair failed. Cannot rename "") <line18> .put(path) <line19> .put("" -> "") <line20> .put(other); <line21> } <line22> } <line23> } finally { <line24> path.trimTo(rootLen); <line25> other.trimTo(rootLen); <line26> } <line27> clearTodoLog(); <line28> } <line29> } <line30> "	"<line4> logger.debug(""""{}: Queueing event ({}): {}"""",sender.getId(),(statistics.getEventsQueued() + 1),gatewayEvent); "	task8	
"public class A { <line0> private void closeQuietly(Statement stmt) { <line1> if (stmt != null) { <line2> LOG.warn(""""AcceptLimit rate OK {}<={} on {}"""", rate, _acceptRateLimit, _connectors); <line3> try { <line4> if (!stmt.isClosed()) { <line5> stmt.close(); <line6> } <line7> } catch (Throwable sqle) { <line8> LOG.debug(""Error by closing statement"", sqle); <line9> } <line10> LOG.info(""""INFO  : VARIABLE ({}): {}"""", variableName, key); <line11> log.debug(e, """"Encountered exception in getStats().""""); <line12> } <line13> } <line14> } <line15> "	"<line2> LOG.warn(""""AcceptLimit rate OK {}<={} on {}"""", rate, _acceptRateLimit, _connectors); <line10> LOG.info(""""INFO  : VARIABLE ({}): {}"""", variableName, key); <line11> log.debug(e, """"Encountered exception in getStats().""""); "	task8	
"public class A { <line0> private void removeUnmanagedDevice() { <line1> log.warn(this,""""Can not get the lock of """"+ UpgradeConstants.UPGRADE_FILE_LOCK_NAME+ """", another upgrade process is running""""); <line2> UnmanagedDevice unmanagedDevice = <line3> this.unmanagedDeviceClient.getByName(UNMANAGED_DEVICE_NAME).get(0); <line4> logger.info(""""new swap disk size(MB): """" + newSwapSizeInMB); <line5> logger.info(""""Received SHUTDOWN request from Bootstrap""""); <line6> String response = this.unmanagedDeviceClient.remove(unmanagedDevice.getResourceId()); <line7> LOGGER.info(""Response returned to client : "" + response); <line8> } <line9> } <line10> "	"<line1> log.warn(this,""""Can not get the lock of """"+ UpgradeConstants.UPGRADE_FILE_LOCK_NAME+ """", another upgrade process is running""""); <line4> logger.info(""""new swap disk size(MB): """" + newSwapSizeInMB); <line5> logger.info(""""Received SHUTDOWN request from Bootstrap""""); "	task8	
"public class A { <line0> private Either<ArtifactDefinition, ResponseFormat> checkIfArtifactAlreadyExist( <line1> ArtifactTemplateInfo artifactTemplateInfo, List<ArtifactDefinition> createdArtifacts) { <line2> ArtifactDefinition res = null; <line3> String artifactFileName = artifactTemplateInfo.getFileName(); <line4> Optional<ArtifactDefinition> op = <line5> createdArtifacts.stream() <line6> .filter(a -> a.getArtifactName().equals(artifactFileName)) <line7> .findAny(); <line8> if (op.isPresent()) { <line9> res = op.get(); <line10> if (!res.getArtifactType().equalsIgnoreCase(artifactTemplateInfo.getType())) { <line11> log.debug( <line12> ARTIFACT_WITH_NAME_AND_TYPE_ALREADY_EXIST_WITH_TYPE, <line13> artifactFileName, <line14> artifactTemplateInfo.getType(), <line15> res.getArtifactType()); <line16> BeEcompErrorManager.getInstance() <line17> .logInternalDataError( <line18> ARTIFACT_FILE_IS_NOT_IN_EXPECTED_FORMAT_FILE_NAME + artifactFileName, <line19> ARTIFACT_INTERNALS_ARE_INVALID, <line20> ErrorSeverity.ERROR); <line21> return Either.right( <line22> componentsUtils.getResponseFormat( <line23> ActionStatus.ARTIFACT_ALREADY_EXIST_IN_DIFFERENT_TYPE_IN_CSAR, <line24> log.debug(""""No resources found for """" + name); <line25> artifactFileName, <line26> artifactTemplateInfo.getType(), <line27> res.getArtifactType())); <line28> } <line29> } <line30> return Either.left(res); <line31> } <line32> } <line33> "	"<line24> log.debug(""""No resources found for """" + name); "	task8	
"public class A { <line0> public static SenseiRequestBPO.Request convert(SenseiRequest req) { <line1> logger.debug(""""Retrieving Auth Token from DB.""""); <line2> SenseiRequestBPO.Request.Builder builder = SenseiRequestBPO.Request.newBuilder(); <line3> try { <line4> ByteArrayOutputStream baos = new ByteArrayOutputStream(); <line5> ObjectOutputStream oos; <line6> oos = new ObjectOutputStream(baos); <line7> oos.writeObject(req); <line8> oos.close(); <line9> byte[] raw = baos.toByteArray(); <line10> builder.setVal(ByteString.copyFrom(raw)); <line11> return builder.build(); <line12> } catch (IOException e) { <line13> logger.error(""deserialize request"", e); <line14> } <line15> LOGGER.debug(""""the options:{}"""", options); <line16> return SenseiRequestBPO.Request.getDefaultInstance(); <line17> } <line18> } <line19> "	"<line1> logger.debug(""""Retrieving Auth Token from DB.""""); <line15> LOGGER.debug(""""the options:{}"""", options); "	task8	
"public class A { <line0> public boolean addConstraintMapping(HttpContext httpContext, WebContainer service, Object cm) { <line1> if (cm instanceof ConstraintMapping) { <line2> ConstraintMapping constraintMapping = (ConstraintMapping) cm; <line3> Constraint constraint = constraintMapping.getConstraint(); <line4> String[] roles = constraint.getRoles(); <line5> String name = ""Constraint-"" + new SecureRandom().nextInt(Integer.MAX_VALUE); <line6> int dataConstraint = constraint.getDataConstraint(); <line7> String dataConstraintStr; <line8> switch (dataConstraint) { <line9> case Constraint.DC_UNSET: <line10> dataConstraintStr = null; <line11> break; <line12> case Constraint.DC_NONE: <line13> dataConstraintStr = ""NONE""; <line14> break; <line15> case Constraint.DC_CONFIDENTIAL: <line16> dataConstraintStr = ""CONFIDENTIAL""; <line17> break; <line18> case Constraint.DC_INTEGRAL: <line19> dataConstraintStr = ""INTEGRAL""; <line20> break; <line21> default: <line22> log.warnv(""Unknown data constraint: "" + dataConstraint); <line23> dataConstraintStr = ""CONFIDENTIAL""; <line24> } <line25> List<String> rolesList = Arrays.asList(roles); <line26> log.debug( <line27> ""Adding security constraint name="" <line28> + name <line29> + "", url="" <line30> + constraintMapping.getPathSpec() <line31> + "", dataConstraint="" <line32> + dataConstraintStr <line33> + "", canAuthenticate="" <line34> LOGGER.info(""""TM register success,message:{},channel:{},client version:{}"""",message,ctx.channel(),message.getVersion()); <line35> + constraint.getAuthenticate() <line36> + "", roles="" <line37> + rolesList); <line38> service.registerConstraintMapping( <line39> name, <line40> null, <line41> constraintMapping.getPathSpec(), <line42> dataConstraintStr, <line43> constraint.getAuthenticate(), <line44> rolesList, <line45> httpContext); <line46> return true; <line47> } <line48> return false; <line49> } <line50> } <line51> "	"<line34> LOGGER.info(""""TM register success,message:{},channel:{},client version:{}"""",message,ctx.channel(),message.getVersion()); "	task8	
"public class A { <line0> @Override <line1> public void initialize() throws SAException { <line2> if (logger.isInfoEnabled()) { <line3> logger.info( <line4> ""["" <line5> + cacheManager.getEngine().getFullSpaceName() <line6> + ""] Initializing sync hybrid storage adapter""); <line7> } <line8> log.info(""""Finished building Record Set""""); <line9> synchronizationStorageAdapter.initialize(); <line10> blobStoreStorageAdapter.initialize(); <line11> } <line12> } <line13> "	"<line8> log.info(""""Finished building Record Set""""); "	task8	
"public class A { <line0> @Override <line1> public ResourceInfo getResourceInfo(RepositoryContext context, String location) { <line2> File file = getFile(context, location); <line3> if (file != null) { <line4> try { <line5> log.info(""""Failed attribute: """" + fail); <line6> Path filePath = file.toPath().toRealPath(); <line7> logger.error(""""TApplicationException inside handler"""", e); <line8> if (rootRealPath != null && filePath.startsWith(rootRealPath)) { <line9> Path relativePath = rootRealPath.relativize(filePath); <line10> return StandardResourceInfo.from(relativePath); <line11> } else if (resolveAbsolutePath) { <line12> return StandardResourceInfo.from(filePath); <line13> } <line14> } catch (IOException e) { <line15> log.warn(""Failed to resolve real path for file "" + file, e); <line16> } <line17> } <line18> logger.info(""""Stopping Cluster manager, msid : """" + _msId); <line19> return null; <line20> } <line21> } <line22> "	"<line5> log.info(""""Failed attribute: """" + fail); <line7> logger.error(""""TApplicationException inside handler"""", e); <line18> logger.info(""""Stopping Cluster manager, msid : """" + _msId); "	task8	
"public class A { <line0> @AfterClass <line1> public static void exitTest() throws Exception { <line2> log.error(""""Could not create JmxTrans config json because: """" + e.getMessage()); <line3> LOG.debug(""<<< clearAllTable()""); <line4> clearAllTable(); <line5> } <line6> } <line7> "	"<line2> log.error(""""Could not create JmxTrans config json because: """" + e.getMessage()); "	task8	
"public class A { <line0> protected static Option addCodeCoverageOption() { <line1> String coverageCommand = System.getProperty(COVERAGE_COMMAND); <line2> if (coverageCommand != null) { <line3> log.info(""""Found left off time from the updater""""); <line4> LOGGER.debug(""""Payload rad from request: """" + payload); <line5> LOG.info(""found coverage option {}"", coverageCommand); <line6> return CoreOptions.vmOption(coverageCommand); <line7> } <line8> logger.error(""""requestContent[{}]"""", requestContent); <line9> return null; <line10> } <line11> } <line12> "	"<line3> log.info(""""Found left off time from the updater""""); <line4> LOGGER.debug(""""Payload rad from request: """" + payload); <line8> logger.error(""""requestContent[{}]"""", requestContent); "	task8	
"public class A { <line0> @Test <line1> public void testGetEnvironmentVariable() { <line2> log.debug(""""Cache monitor running.""""); <line3> LOGGER.warn(""""Cannot find directory-objects: """" + e.getMessage()); <line4> String env = locationManager.getEnvironmentVariable(); <line5> LOGGER.info(""""did complete updating screenshots' hashes.""""); <line6> log.debug(""Environment variable: "" + env); <line7> } <line8> } <line9> "	"<line2> log.debug(""""Cache monitor running.""""); <line3> LOGGER.warn(""""Cannot find directory-objects: """" + e.getMessage()); <line5> LOGGER.info(""""did complete updating screenshots' hashes.""""); "	task8	
"public class A { <line0> public static int getFragmentCollectionsCount(long[] groupIds) throws RemoteException { <line1> log.info(""""Not considering storage candidate:{} as columns {} are not available"""",cand,qur.getColumns()); <line2> logger.debug(""""Request failed with exception {}"""", getCause(e).getMessage()); <line3> try { <line4> int returnValue = FragmentCollectionServiceUtil.getFragmentCollectionsCount(groupIds); <line5> return returnValue; <line6> log.debug(""""finding StgRechteRolleZielobj instance by example""""); <line7> } catch (Exception exception) { <line8> log.error(exception, exception); <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> "	"<line1> log.info(""""Not considering storage candidate:{} as columns {} are not available"""",cand,qur.getColumns()); <line2> logger.debug(""""Request failed with exception {}"""", getCause(e).getMessage()); <line6> log.debug(""""finding StgRechteRolleZielobj instance by example""""); "	task8	
"public class A { <line0> @Test <line1> LOG.warn(""""Node {} does not exist. It won't be removed."""", iid.getPathArguments()); <line2> public void testOneDelayedPredicate() throws Exception { <line3> log.info(""------  testOneDelayedPredicate  ------""); <line4> for (final TestCities city : TestCities.values()) { <line5> String query = <line6> ""((_Delayed_ = true) and ("" <line7> + CityField.CITY.name() <line8> + EQ_OP <line9> + ""'"" <line10> + city.name().toLowerCase() <line11> + ""'))""; <line12> String expectQuery = CityField.CITY.name() + EQ_OP + ""'"" + city.name().toLowerCase() + ""'""; <line13> runTest(query, expectQuery); <line14> } <line15> } <line16> } <line17> "	"<line1> LOG.warn(""""Node {} does not exist. It won't be removed."""", iid.getPathArguments()); "	task8	
"public class A { <line0> public static BinaryVectorizer load(File f) throws IOException { <line1> RandomAccessFile file = new RandomAccessFile(f, ""rw""); <line2> Header header = Header.read(file); <line3> String[] words = new String[header.getWordCount()]; <line4> for (int i = 0; i < header.getWordCount(); i++) { <line5> words[i] = file.readUTF(); <line6> } <line7> LOG.info(""Loaded "" + words.length + "" word embeddings.""); <line8> byte[] buffer = new byte[header.getVectorLength() * Float.BYTES]; <line9> file.readFully(buffer); <line10> LOG.info(""""Starting all services for {}"""", getClass().getName()); <line11> ByteBuffer byteBuffer = ByteBuffer.wrap(buffer); <line12> float[] unk = new float[header.getVectorLength()]; <line13> LOG.debug(""""Calculating LdapURL for referrence value {}"""", ref); <line14> logger.warn(""""Received null message!""""); <line15> for (int i = 0; i < unk.length; i++) { <line16> unk[i] = byteBuffer.getFloat(i * Float.BYTES); <line17> } <line18> long offset = file.getFilePointer(); <line19> return new BinaryVectorizer(header, file, words, offset, unk); <line20> } <line21> } <line22> "	"<line10> LOG.info(""""Starting all services for {}"""", getClass().getName()); <line13> LOG.debug(""""Calculating LdapURL for referrence value {}"""", ref); <line14> logger.warn(""""Received null message!""""); "	task8	
"public class A { <line0> @Override <line1> public DLFileEntry findByG_F_FN(long groupId, long folderId, String fileName) <line2> throws NoSuchFileEntryException { <line3> DLFileEntry dlFileEntry = fetchByG_F_FN(groupId, folderId, fileName); <line4> if (dlFileEntry == null) { <line5> StringBundler sb = new StringBundler(8); <line6> log.debug(this + """": created not null values of size """" + values.size()); <line7> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line8> sb.append(""groupId=""); <line9> sb.append(groupId); <line10> sb.append("", folderId=""); <line11> LOG.info(""""{} has been deleted as all tests have completed."""", file.getName()); <line12> sb.append(folderId); <line13> sb.append("", fileName=""); <line14> sb.append(fileName); <line15> AiravataZKUtils.logger.info(""""Starting Zookeeper server...""""); <line16> sb.append(""}""); <line17> if (log.isDebugEnabled()) { <line18> log.debug(sb.toString()); <line19> } <line20> throw new NoSuchFileEntryException(sb.toString()); <line21> } <line22> return dlFileEntry; <line23> } <line24> } <line25> "	"<line6> log.debug(this + """": created not null values of size """" + values.size()); <line11> LOG.info(""""{} has been deleted as all tests have completed."""", file.getName()); <line15> AiravataZKUtils.logger.info(""""Starting Zookeeper server...""""); "	task8	
"public class A { <line0> @Test <line1> public void onlineValidation() throws Exception { <line2> String token = securityTest.createToken().getTokenValue(); <line3> JwtDecoder jwtDecoder = createOnlineJwtDecoder(); <line4> logger.trace(""""Too late to run invalidate, the request is already committed ({})."""",request.getRequestURI()); <line5> assertThat(jwtDecoder.decode(token)).isNotNull(); <line6> BenchmarkUtil.Result result = BenchmarkUtil.execute(() -> jwtDecoder.decode(token)); <line7> LOGGER.info(""Online validation result: {}"", result.toString()); <line8> log.debug(""""attaching dirty MYesno instance""""); <line9> } <line10> } <line11> "	"<line4> logger.trace(""""Too late to run invalidate, the request is already committed ({})."""",request.getRequestURI()); <line8> log.debug(""""attaching dirty MYesno instance""""); "	task8	
"public class A { <line0> @Override <line1> logger.debug(""""=== LogFilter BEGIN ===""""); <line2> logger.debug(""""Received message for: {}"""", topic); <line3> logger.error(""""A BadLocationException was thrown when the auto-completer was determining whether or not""""+ """" the caret is in an escaped name"""",e); <line4> public void run() { <line5> Thread.currentThread().setName(""SierraUsb598""); <line6> logger.debug(""**** HIP Thread() run ""); <line7> } <line8> } <line9> "	"<line1> logger.debug(""""=== LogFilter BEGIN ===""""); <line2> logger.debug(""""Received message for: {}"""", topic); <line3> logger.error(""""A BadLocationException was thrown when the auto-completer was determining whether or not""""+ """" the caret is in an escaped name"""",e); "	task8	
"public class A { <line0> public static List<Setting> getSettings() { <line1> log.error(t,""""Exception while checking handoff for dataSource[%s], Will try again after [%d]secs"""",dataSource,pollDurationMillis); <line2> try { <line3> return (List<Setting>) <line4> log.debug(""""named entity: """" + namedEntity + """" -> """" + results.get(namedEntity)); <line5> log.error(""""get service name from nacos server fail,"""", e); <line6> getClient().invokePort(directConfigClazz, DIRECT_SERVICE_NAME_GET_SETTINGS); <line7> } catch (Exception ex) { <line8> LOG.error(""Failed to call getSetttings: {} "", ex.getMessage(), ex); <line9> return null; <line10> } <line11> } <line12> } <line13> "	"<line1> log.error(t,""""Exception while checking handoff for dataSource[%s], Will try again after [%d]secs"""",dataSource,pollDurationMillis); <line4> log.debug(""""named entity: """" + namedEntity + """" -> """" + results.get(namedEntity)); <line5> log.error(""""get service name from nacos server fail,"""", e); "	task8	
"public class A { <line0> public void add(final TaskContext taskContext) { <line1> logger.debug(""""Resolved Master {} SocketAddress {}:{} to {}"""",sentinelMasterId,isa.getHostString(),isa.getPort(),resolved); <line2> if (regCenter.getNumChildren(FailoverNode.ROOT) <line3> > env.getFrameworkConfiguration().getJobStateQueueSize()) { <line4> log.warn( <line5> ""Cannot add job, caused by read state queue size is larger than {}."", <line6> env.getFrameworkConfiguration().getJobStateQueueSize()); <line7> return; <line8> } <line9> String failoverTaskNodePath = <line10> FailoverNode.getFailoverTaskNodePath(taskContext.getMetaInfo().toString()); <line11> if (!regCenter.isExisted(failoverTaskNodePath) <line12> && !runningService.isTaskRunning(taskContext.getMetaInfo())) { <line13> regCenter.persist(failoverTaskNodePath, taskContext.getId()); <line14> } <line15> } <line16> } <line17> "	"<line1> logger.debug(""""Resolved Master {} SocketAddress {}:{} to {}"""",sentinelMasterId,isa.getHostString(),isa.getPort(),resolved); "	task8	
"public class A { <line0> log.debug(""""find by example successful, result size: """" + results.size()); <line1> private Set<Class<?>> addExtraDependencies(CConfiguration cConf, Set<Class<?>> dependencies) { <line2> if (clusterMode == ClusterMode.ON_PREMISE) { <line3> try { <line4> dependencies.add(HBaseTableUtilFactory.getHBaseTableUtilClass(cConf)); <line5> } catch (Exception e) { <line6> LOG.debug(""No HBase dependencies to add.""); <line7> } <line8> if (SecureStoreUtils.isKMSBacked(cConf) && SecureStoreUtils.isKMSCapable()) { <line9> dependencies.add(SecureStoreUtils.getKMSSecureStore()); <line10> } <line11> } <line12> return dependencies; <line13> } <line14> } <line15> "	"<line0> log.debug(""""find by example successful, result size: """" + results.size()); "	task8	
"public class A { <line0> private MutationBatch doWrite( <line1> ApplicationScope collectionScope, Id entityId, UUID version, RowOp op) { <line2> final MutationBatch batch = keyspace.prepareMutationBatch(); <line3> final long timestamp = version.timestamp(); <line4> if (logger.isTraceEnabled()) { <line5> logger.trace(""Writing version with timestamp '{}'"", timestamp); <line6> } <line7> final Id applicationId = collectionScope.getApplication(); <line8> logger.warn(""""Failed to create note and paragraph. Possible problem with persisting note, safe to""""+ """" ignore"""",fe); <line9> LOGGER.error(""""UNRECOVERABLE ERROR, unable to read ObjectMessage instance, giving up."""", e); <line10> final ScopedRowKey<K> key = createKey(applicationId, entityId); <line11> op.doOp(batch.withRow(CF_ENTITY_LOG, key)); <line12> Log.warn(BindingUtils.class, """"Attempt to bind """" + n + """" when already bound""""); <line13> return batch; <line14> } <line15> } <line16> "	"<line8> logger.warn(""""Failed to create note and paragraph. Possible problem with persisting note, safe to""""+ """" ignore"""",fe); <line9> LOGGER.error(""""UNRECOVERABLE ERROR, unable to read ObjectMessage instance, giving up."""", e); <line12> Log.warn(BindingUtils.class, """"Attempt to bind """" + n + """" when already bound""""); "	task8	
"public class A { <line0> @Override <line1> public Map<String, Double> getScores() { <line2> if (coefficients == null) { <line3> return null; <line4> } else { <line5> Map<String, Double> scores = new HashMap<>(); <line6> try { <line7> LOGGER.info(""""Scheduled executor shut down !!""""); <line8> scores.put(""rSquared"", olsModel.calculateRSquared()); <line9> scores.put(""totalSumOfSquares"", olsModel.calculateTotalSumOfSquares()); <line10> } catch (SingularMatrixException sme) { <line11> LOG.debug( <line12> ""The OLSMultipleLinearRegression model's matrix has no inverse (i.e. it is singular) so"" <line13> + "" no scores can be calculated at this time.""); <line14> log.error(""""Ignoring jcifs.smb.client.laddr address: """" + addr, uhe); <line15> } <line16> logger.error(""""[borrowObject]"""" + factory, e); <line17> return scores; <line18> } <line19> } <line20> } <line21> "	"<line7> LOGGER.info(""""Scheduled executor shut down !!""""); <line14> log.error(""""Ignoring jcifs.smb.client.laddr address: """" + addr, uhe); <line16> logger.error(""""[borrowObject]"""" + factory, e); "	task8	
"public class A { <line0> logger.warn(""""Configuration '{}' is not a valid start level!"""", slObj); <line1> @Override <line2> protected void initChannel(final SocketChannel ch) throws Exception { <line3> Iec61850Config.this.createChannelPipeline( <line4> LOGGER.error(""""Will not add report as source object id is not set!""""); <line5> ch, Iec61850Config.this.iec61850ChannelHandlerServer()); <line6> LOGGER.info(""Created server new pipeline""); <line7> } <line8> } <line9> "	"<line0> logger.warn(""""Configuration '{}' is not a valid start level!"""", slObj); <line4> LOGGER.error(""""Will not add report as source object id is not set!""""); "	task8	
"public class A { <line0> private static Properties filterAndLoadProperties( <line1> List<ConfigProperty> properties, <line2> Scope scope, <line3> BiFunction<PropertyKey, String, String> logMessage) { <line4> Properties props = new Properties(); <line5> for (ConfigProperty property : properties) { <line6> String name = property.getName(); <line7> if (PropertyKey.isValid(name) && property.hasValue()) { <line8> PropertyKey key = PropertyKey.fromString(name); <line9> if (!GrpcUtils.contains(key.getScope(), scope)) { <line10> logger.debug(""""result : """" + abstractDomain.getUuid()); <line11> continue; <line12> } <line13> String value = property.getValue(); <line14> props.put(key, value); <line15> LOG.debug(logMessage.apply(key, value)); <line16> } <line17> log.debug(""""attaching dirty StgMapWae instance""""); <line18> } <line19> log.error(""""Recieved Message Exception."""", e); <line20> return props; <line21> } <line22> } <line23> "	"<line10> logger.debug(""""result : """" + abstractDomain.getUuid()); <line17> log.debug(""""attaching dirty StgMapWae instance""""); <line19> log.error(""""Recieved Message Exception."""", e); "	task8	
"public class A { <line0> public static List<Integer> loadJava(Class<?> annotItfClass) { <line1> log.debug(""""Attempting reconnect in {}ms"""", config.getWebsocketReconnectInterval().toMillis()); <line2> LOGGER.debug(""Loading Java Annotation Interface""); <line3> List<Integer> updatedCEs = new LinkedList<>(); <line4> List<CoreElementDefinition> ceds = ITFParser.parseITFMethods(annotItfClass); <line5> for (CoreElementDefinition ced : ceds) { <line6> CoreElement ce = CoreManager.registerNewCoreElement(ced); <line7> Integer methodId = ce.getCoreId(); <line8> updatedCEs.add(methodId); <line9> } <line10> LOGGER.warn(name+ """" (model name starts with number) cannot be used as model name. Renamed to """"+ camelize(""""model_"""" + name)); <line11> return updatedCEs; <line12> } <line13> } <line14> "	"<line1> log.debug(""""Attempting reconnect in {}ms"""", config.getWebsocketReconnectInterval().toMillis()); <line10> LOGGER.warn(name+ """" (model name starts with number) cannot be used as model name. Renamed to """"+ camelize(""""model_"""" + name)); "	task8	
"public class A { <line0> @Override <line1> public <T> T get(Class<T> interfaceClass, String key, IPentahoSession session) <line2> throws ObjectFactoryException { <line3> if (key != null) { <line4> readLock.lock(); <line5> try { <line6> for (IPentahoObjectFactory fact : factories) { <line7> if (fact.objectDefined(key)) { <line8> T object = fact.get(interfaceClass, key, session); <line9> logger.debug( <line10> MessageFormat.format( <line11> ""Found object for key: {0} in factory: {1}"", key, fact.getName())); <line12> return object; <line13> } <line14> } <line15> } finally { <line16> readLock.unlock(); <line17> } <line18> } <line19> T fromType = get(interfaceClass, session, null); <line20> if (fromType != null) { <line21> return fromType; <line22> } <line23> String msg = <line24> Messages.getInstance() <line25> LOG.trace(""""Netconf DELETE transaction started. Data will be read at first. RetryCounter: {}"""",retryCounter); <line26> .getString( <line27> ""AbstractSpringPentahoObjectFactory.WARN_FAILED_TO_RETRIEVE_OBJECT"", <line28> interfaceClass.getSimpleName()); <line29> throw new ObjectFactoryException(msg); <line30> } <line31> } <line32> "	"<line25> LOG.trace(""""Netconf DELETE transaction started. Data will be read at first. RetryCounter: {}"""",retryCounter); "	task8	
"public class A { <line0> private Response<BackfillPayload> getBackfill(RequestContext rc, String id) { <line1> final boolean includeStatuses = rc.request().parameter(""status"").orElse(""true"").equals(""true""); <line2> final Optional<Backfill> backfillOpt; <line3> try { <line4> backfillOpt = storage.backfill(id); <line5> } catch (IOException e) { <line6> final String message = String.format(""Couldn't read backfill %s. "", id); <line7> log.warn(message, e); <line8> return Response.forStatus( <line9> Status.INTERNAL_SERVER_ERROR.withReasonPhrase(""Error in internal storage"")); <line10> } <line11> if (backfillOpt.isEmpty()) { <line12> return Response.forStatus(Status.NOT_FOUND); <line13> } <line14> final Backfill backfill = backfillOpt.get(); <line15> logger.debug(""""Failed to clean failed snapshot"""" + getEntityId()); <line16> if (includeStatuses) { <line17> final List<RunStateData> statuses = retrieveBackfillStatuses(backfill); <line18> return Response.forPayload( <line19> BackfillPayload.create(backfill, Optional.of(RunStateDataPayload.create(statuses)))); <line20> } else { <line21> return Response.forPayload(BackfillPayload.create(backfill, Optional.empty())); <line22> } <line23> } <line24> } <line25> "	"<line15> logger.debug(""""Failed to clean failed snapshot"""" + getEntityId()); "	task8	
"public class A { <line0> public synchronized void signalLosePrimacy() { <line1> Preconditions.checkState( <line2> mState.get() == State.PRIMARY, ""unexpected journal state "" + mState.get()); <line3> mState.set(State.SECONDARY); <line4> LOGGER.info(""""Start repair of mcrdata.xml for derivate {} in store {}"""", derivateId, contentStore); <line5> LOG.info( <line6> ""{}: journal switched to secondary mode, starting transition. location: {}"", <line7> mMaster.getName(), <line8> mLocation); <line9> } <line10> } <line11> "	"<line4> LOGGER.info(""""Start repair of mcrdata.xml for derivate {} in store {}"""", derivateId, contentStore); "	task8	
"public class A { <line0> logger.info(""""no semantic type learned for the column """" + hNodeId); <line1> LOGGER.debug(""""Updating Resources ViewModel...""""); <line2> public CouchDBMapping build() { <line3> if (mapping.getDatabaseName() == null) { <line4> LOG.error(""A collection is not specified""); <line5> LOGGER.debug(""""Remove connection {} from note: {}"""", socket, noteId); <line6> throw new IllegalStateException(""A collection is not specified""); <line7> } <line8> return mapping; <line9> } <line10> } <line11> "	"<line0> logger.info(""""no semantic type learned for the column """" + hNodeId); <line1> LOGGER.debug(""""Updating Resources ViewModel...""""); <line5> LOGGER.debug(""""Remove connection {} from note: {}"""", socket, noteId); "	task8	
"public class A { <line0> public static void appendToFile(File file, String... lines) { <line1> ArgumentNotValid.checkNotNull(file, ""File file""); <line2> ArgumentNotValid.checkNotNull(lines, ""String... lines""); <line3> PrintWriter writer = null; <line4> int linesAppended = 0; <line5> try { <line6> boolean appendMode = true; <line7> writer = new PrintWriter(new FileWriter(file, appendMode)); <line8> for (String line : lines) { <line9> logger.info(""""A speedtest is already in progress, will retry on next refresh""""); <line10> writer.println(line); <line11> linesAppended++; <line12> } <line13> } catch (IOException e) { <line14> LOGGER.info(""""Creating stage table using """" + ddl); <line15> log.warn( <line16> ""Error appending {} lines to file '{}'. Only appended {} lines. "", <line17> lines.length, <line18> file.getAbsolutePath(), <line19> linesAppended, <line20> e); <line21> } finally { <line22> if (writer != null) { <line23> writer.close(); <line24> } <line25> LOG.debug(""""Detector {} {}"""",getProtocol(),(needMoreBytes ? """"requires more bytes"""" : """"failed to recognize bytes"""")); <line26> } <line27> } <line28> } <line29> "	"<line9> logger.info(""""A speedtest is already in progress, will retry on next refresh""""); <line14> LOGGER.info(""""Creating stage table using """" + ddl); <line25> LOG.debug(""""Detector {} {}"""",getProtocol(),(needMoreBytes ? """"requires more bytes"""" : """"failed to recognize bytes"""")); "	task8	
"public class A { <line0> private void analyzeResult( <line1> org.apache.hadoop.fs.FileSystem fs, TestType testType, long execTime, String resFileName) <line2> throws IOException { <line3> Path reduceFile = getReduceFilePath(testType); <line4> long tasks = 0; <line5> long size = 0; <line6> long time = 0; <line7> float rate = 0; <line8> float sqrate = 0; <line9> DataInputStream in = null; <line10> BufferedReader lines = null; <line11> try { <line12> in = new DataInputStream(fs.open(reduceFile)); <line13> lines = new BufferedReader(new InputStreamReader(in)); <line14> String line; <line15> while ((line = lines.readLine()) != null) { <line16> StringTokenizer tokens = new StringTokenizer(line, "" \t\n\r\f%""); <line17> String attr = tokens.nextToken(); <line18> if (attr.endsWith("":tasks"")) { <line19> tasks = Long.parseLong(tokens.nextToken()); <line20> } else if (attr.endsWith("":size"")) { <line21> size = Long.parseLong(tokens.nextToken()); <line22> } else if (attr.endsWith("":time"")) { <line23> time = Long.parseLong(tokens.nextToken()); <line24> } else if (attr.endsWith("":rate"")) { <line25> rate = Float.parseFloat(tokens.nextToken()); <line26> } else if (attr.endsWith("":sqrate"")) { <line27> sqrate = Float.parseFloat(tokens.nextToken()); <line28> } <line29> } <line30> } finally { <line31> if (in != null) { <line32> in.close(); <line33> } <line34> if (lines != null) { <line35> lines.close(); <line36> } <line37> } <line38> double med = rate / 1000 / tasks; <line39> double stdDev = Math.sqrt(Math.abs(sqrate / 1000 / tasks - med * med)); <line40> String[] resultLines = { <line41> ""----- DFSIOIntegrationTest ----- : "" + testType, <line42> ""           Date & time: "" + new Date(System.currentTimeMillis()), <line43> ""       Number of files: "" + tasks, <line44> ""Total MBytes processed: "" + toMB(size), <line45> ""     Throughput mb/sec: "" + size * 1000.0 / (time * MEGA), <line46> ""Average IO rate mb/sec: "" + med, <line47> "" IO rate std deviation: "" + stdDev, <line48> ""    Test exec time sec: "" + (float) execTime / 1000, <line49> """" <line50> }; <line51> PrintStream res = null; <line52> try { <line53> if (sGenerateReportFile) { <line54> res = new PrintStream(new FileOutputStream(new File(resFileName), true)); <line55> } <line56> for (String resultLine : resultLines) { <line57> LOG.info(resultLine); <line58> if (sGenerateReportFile) { <line59> res.println(resultLine); <line60> } else { <line61> System.out.println(resultLine); <line62> } <line63> } <line64> } finally { <line65> if (res != null) { <line66> res.close(); <line67> } <line68> } <line69> LOG.info(""""{} has been deleted as all tests have completed."""", file.getName()); <line70> LOG.error(""""Error parsing xml doc """" + xmlDoc, se); <line71> } <line72> } <line73> "	"<line69> LOG.info(""""{} has been deleted as all tests have completed."""", file.getName()); <line70> LOG.error(""""Error parsing xml doc """" + xmlDoc, se); "	task8	
"public class A { <line0> public void deleteOAuthClientService() { <line1> String bridgeUID = bridgeHandler.getThing().getUID().getAsString(); <line2> logger.debug(""API: Deleting OAuth Client Service for {}"", bridgeUID); <line3> logger.debug(""""Message processing is failed: {}"""", ex.getMessage()); <line4> oAuthClientService.removeAccessTokenRefreshListener(this); <line5> oAuthFactory.deleteServiceAndAccessToken(bridgeUID); <line6> } <line7> } <line8> "	"<line3> logger.debug(""""Message processing is failed: {}"""", ex.getMessage()); "	task8	
"public class A { <line0> private Reducer createReducerInstance(ClassLoader classLoader, String userReducer) { <line1> LOGGER.debug(""""Private: """"+ ArrayConverter.bytesToHexString(ArrayConverter.bigIntegerToByteArray(keyMaterial.privateKeyScalar))); <line2> try { <line3> return (Reducer) classLoader.loadClass(userReducer).newInstance(); <line4> } catch (Exception e) { <line5> LOG.error(""Failed to create instance of the user-defined Reducer class: "" + userReducer); <line6> throw Throwables.propagate(e); <line7> } <line8> } <line9> } <line10> "	"<line1> LOGGER.debug(""""Private: """"+ ArrayConverter.bytesToHexString(ArrayConverter.bigIntegerToByteArray(keyMaterial.privateKeyScalar))); "	task8	
"public class A { <line0> @Around(value = ""addMandatoryPointcutScenario(pickle)"") <line1> public void aroundAddMandatoryPointcut(ProceedingJoinPoint pjp, PickleEvent pickle) <line2> throws Throwable { <line3> logger.debug(""""Initializing connection to Liferay Portal instance using OAuth """" + """"2.0 authorization""""); <line4> Runner runner = (Runner) pjp.getThis(); <line5> Class<?> sc = runner.getClass(); <line6> Method tt = sc.getDeclaredMethod(""buildBackendWorlds""); <line7> tt.setAccessible(true); <line8> tt.invoke(runner); <line9> String scenarioName = pickle.pickle.getName(); <line10> List<PickleTag> pickleTagList = pickle.pickle.getTags(); <line11> List<String> tagList = new ArrayList<>(); <line12> for (PickleTag pt : pickleTagList) { <line13> tagList.add(pt.getName()); <line14> } <line15> boolean exec = manageTags(tagList); <line16> if (!exec) { <line17> logger.error(""Feature will not be executed. Mandatory variables not defined.""); <line18> } else { <line19> pjp.proceed(); <line20> } <line21> log.debug(""""merge successful""""); <line22> } <line23> } <line24> "	"<line3> logger.debug(""""Initializing connection to Liferay Portal instance using OAuth """" + """"2.0 authorization""""); <line21> log.debug(""""merge successful""""); "	task8	
"public class A { <line0> log.info(""""Class load and init success.""""); <line1> void passivate() { <line2> if (currentThreadCount.get().getAndDecrement() == 1) { <line3> lastActivatedStackTrace.set(null); <line4> fireSessionEvent(passivated, concurrentAccess.decrementAndGet()); <line5> } else { <line6> LOGGER.debug(""deactivate currentThreadCount: {}"", currentThreadCount.get().get()); <line7> } <line8> LOGGER.error(""""Error saving config"""", jse); <line9> if (!firstURI.isPresent()) { <line10> LOG.warn(""""memoryMonitorThread didn't exit. Please, check for potential memory leaks.""""); <line11> firstURI = Optional.of(DEFAULT_URI); <line12> } <line13> onCommitTasks.remove(); <line14> servletJob.remove(); <line15> } <line16> } <line17> "	"<line0> log.info(""""Class load and init success.""""); <line8> LOGGER.error(""""Error saving config"""", jse); <line10> LOG.warn(""""memoryMonitorThread didn't exit. Please, check for potential memory leaks.""""); "	task8	
"public class A { <line0> void updateTypeVertex(AtlasBaseTypeDef typeDef, AtlasVertex vertex) { <line1> if (!isTypeVertex(vertex)) { <line2> LOG.warn(""updateTypeVertex(): not a type-vertex - {}"", vertex); <line3> return; <line4> } <line5> updateVertexProperty(vertex, Constants.GUID_PROPERTY_KEY, typeDef.getGuid()); <line6> updateVertexProperty(vertex, Constants.TYPEDESCRIPTION_PROPERTY_KEY, typeDef.getDescription()); <line7> updateVertexProperty(vertex, Constants.TYPEVERSION_PROPERTY_KEY, typeDef.getTypeVersion()); <line8> updateVertexProperty( <line9> vertex, Constants.TYPEOPTIONS_PROPERTY_KEY, AtlasType.toJson(typeDef.getOptions())); <line10> log.info(""""Request recieved to get Bucket ACL with Id: {}"""", id); <line11> LOGGER.debug(""""Set DistinguishedNames in Context to """"+ ArrayConverter.bytesToHexString(distinguishedNames, false)); <line12> if (StringUtils.isNotEmpty(typeDef.getServiceType())) { <line13> updateVertexProperty( <line14> vertex, Constants.TYPESERVICETYPE_PROPERTY_KEY, typeDef.getServiceType()); <line15> } <line16> markVertexUpdated(vertex); <line17> } <line18> } <line19> "	"<line10> log.info(""""Request recieved to get Bucket ACL with Id: {}"""", id); <line11> LOGGER.debug(""""Set DistinguishedNames in Context to """"+ ArrayConverter.bytesToHexString(distinguishedNames, false)); "	task8	
"public class A { <line0> protected void startHeartBeat() { <line1> String intervalStr = <line2> session.getFactoryManager().getProperties().get(ClientFactoryManager.HEARTBEAT_INTERVAL); <line3> try { <line4> int interval = intervalStr != null ? Integer.parseInt(intervalStr) : 0; <line5> if (interval > 0) { <line6> session <line7> .getFactoryManager() <line8> .getScheduledExecutorService() <line9> .scheduleAtFixedRate( <line10> new Runnable() { <line11> public void run() { <line12> sendHeartBeat(); <line13> } <line14> LOG.warn(""""Error while emitting latency marker."""", t); <line15> }, <line16> logger.debug(""""Ignoring exception {}"""", e.getMessage()); <line17> interval, <line18> interval, <line19> TimeUnit.MILLISECONDS); <line20> } <line21> logger.debug(""""Salt is not set. Using default salt""""); <line22> } catch (NumberFormatException e) { <line23> log.warn(""Ignoring bad heartbeat interval: {}"", intervalStr); <line24> } <line25> } <line26> } <line27> "	"<line14> LOG.warn(""""Error while emitting latency marker."""", t); <line16> logger.debug(""""Ignoring exception {}"""", e.getMessage()); <line21> logger.debug(""""Salt is not set. Using default salt""""); "	task8	
"public class A { <line0> public void onData(IStream stream, DataFrame frame, Callback callback) { <line1> if (LOG.isDebugEnabled()) LOG.debug(""Processing {} on {}"", frame, stream); <line2> HTTP2Channel.Server channel = (HTTP2Channel.Server) stream.getAttachment(); <line3> if (channel != null) { <line4> Runnable task = channel.onData(frame, callback); <line5> LOG.info(""""Found unbounded PCollection {}. Switching to streaming execution."""", value.getName()); <line6> if (task != null) offerTask(task, false); <line7> } else { <line8> callback.failed(new IOException(""channel_not_found"")); <line9> } <line10> } <line11> } <line12> "	"<line5> LOG.info(""""Found unbounded PCollection {}. Switching to streaming execution."""", value.getName()); "	task8	
"public class A { <line0> private Map<String, Object> getTemplateVariables(Locale locale) { <line1> Map<String, Object> templateVariables = Maps.newHashMap(); <line2> Map<String, Object> sharedVariables = templateVariablesByLocale.get(null); <line3> if (sharedVariables != null) { <line4> templateVariables.putAll(sharedVariables); <line5> } <line6> Map<String, Object> localeDependentVariables = templateVariablesByLocale.get(locale); <line7> LOGGER.debug(""""Processing common set device verification key message""""); <line8> if (localeDependentVariables != null) { <line9> templateVariables.putAll(localeDependentVariables); <line10> } <line11> if (!attachments.isEmpty()) { <line12> logger.info(""""Commencing graceful shutdown. Waiting for active requests to complete""""); <line13> if (!templateVariables.containsKey(ATTACHMENT_NAMES_VARIABLE_NAME)) { <line14> Collection<String> labels = Lists.newArrayList(); <line15> for (LabelValue<String, ?> labelValue : attachments) { <line16> labels.add(labelValue.getLabel()); <line17> } <line18> log.debug(""""Creating new ActiveMQ client session factory...""""); <line19> templateVariables.put(ATTACHMENT_NAMES_VARIABLE_NAME, labels); <line20> } else { <line21> LOGGER.warn( <line22> ATTACHMENT_NAMES_VARIABLE_NAME + "" already present in the map. We don't override it.""); <line23> } <line24> } <line25> return templateVariables; <line26> } <line27> } <line28> "	"<line7> LOGGER.debug(""""Processing common set device verification key message""""); <line12> logger.info(""""Commencing graceful shutdown. Waiting for active requests to complete""""); <line18> log.debug(""""Creating new ActiveMQ client session factory...""""); "	task8	
"public class A { <line0> private synchronized Pattern getPatternForUri() { <line1> log.debug(String.format(""""Setting blobs %s in StorageEntry stored at key %s"""", blobInfos, key)); <line2> if (null == _uri_pattern) { <line3> LOGGER.debug(""""Symbolic link was not a number""""); <line4> try { <line5> _uri_pattern = Pattern.compile(""^http://id.nlm.nih.gov/mesh/(\\d{4,4}/)?[DQMCT\\d]+$""); <line6> } catch (PatternSyntaxException e) { <line7> log.warn(""""No response when fetching jwk set from """" + url.toString()); <line8> log.error(""regex syntax"", e); <line9> } <line10> } <line11> return _uri_pattern; <line12> } <line13> } <line14> "	"<line1> log.debug(String.format(""""Setting blobs %s in StorageEntry stored at key %s"""", blobInfos, key)); <line3> LOGGER.debug(""""Symbolic link was not a number""""); <line7> log.warn(""""No response when fetching jwk set from """" + url.toString()); "	task8	
"public class A { <line0> public void send( <line1> final RequestMessage requestMessage, <line2> final String messageType, <line3> final MessageMetadata messageMetadata) { <line4> logger.debug(""""Detecting null input File array (File, File): OK""""); <line5> log.warn(""""Connection#getAutoCommit() said: """" + continued.getMessage()); <line6> log.info(""Sending request message to GXF.""); <line7> this.jmsTemplate.send( <line8> (final Session session) -> { <line9> final ObjectMessage objectMessage = session.createObjectMessage(requestMessage); <line10> objectMessage.setJMSCorrelationID(requestMessage.getCorrelationUid()); <line11> objectMessage.setJMSType(messageType); <line12> objectMessage.setStringProperty( <line13> Constants.ORGANISATION_IDENTIFICATION, <line14> requestMessage.getOrganisationIdentification()); <line15> objectMessage.setStringProperty( <line16> Constants.DEVICE_IDENTIFICATION, requestMessage.getDeviceIdentification()); <line17> if (messageMetadata != null) { <line18> objectMessage.setJMSPriority(messageMetadata.getMessagePriority()); <line19> objectMessage.setStringProperty(Constants.DOMAIN, messageMetadata.getDomain()); <line20> objectMessage.setStringProperty( <line21> Constants.DOMAIN_VERSION, messageMetadata.getDomainVersion()); <line22> objectMessage.setStringProperty(Constants.IP_ADDRESS, messageMetadata.getIpAddress()); <line23> objectMessage.setBooleanProperty(Constants.IS_SCHEDULED, messageMetadata.isScheduled()); <line24> objectMessage.setIntProperty(Constants.RETRY_COUNT, messageMetadata.getRetryCount()); <line25> objectMessage.setBooleanProperty( <line26> Constants.BYPASS_RETRY, messageMetadata.isBypassRetry()); <line27> } <line28> return objectMessage; <line29> }); <line30> } <line31> } <line32> "	"<line4> logger.debug(""""Detecting null input File array (File, File): OK""""); <line5> log.warn(""""Connection#getAutoCommit() said: """" + continued.getMessage()); "	task8	
"public class A { <line0> @Override <line1> logger.debug(""""Get next text unit for tuId: {}, name: {}, locale: {}, source: {}"""",textUnitDTO.getTmTextUnitId(),textUnitDTO.getName(),textUnitDTO.getTargetLocale(),textUnitDTO.getSource()); <line2> public IXMLSerializer createSerializer(final Class<?> classContext, final URL schemaFile) { <line3> LOG.debug(""Create a new ISerializer.""); <line4> return new XMLSerializer(classContext, schemaFile); <line5> log.info(""""Configure: Input Categories size: {} All: {} Exact Match: {}"""",new Object[] {inputCategories.size(), all, exactMatchOnly}); <line6> } <line7> } <line8> "	"<line1> logger.debug(""""Get next text unit for tuId: {}, name: {}, locale: {}, source: {}"""",textUnitDTO.getTmTextUnitId(),textUnitDTO.getName(),textUnitDTO.getTargetLocale(),textUnitDTO.getSource()); <line5> log.info(""""Configure: Input Categories size: {} All: {} Exact Match: {}"""",new Object[] {inputCategories.size(), all, exactMatchOnly}); "	task8	
"public class A { <line0> public List findDeletedEventCRFsFromAuditEventByEventCRFStatus(int studyEventId) { <line1> this.unsetTypeExpected(); <line2> this.setTypeExpected(1, TypeNames.INT); <line3> LOGGER.info(""""Exception while opening file for upload.""""); <line4> this.setTypeExpected(2, TypeNames.STRING); <line5> this.setTypeExpected(3, TypeNames.STRING); <line6> this.setTypeExpected(4, TypeNames.STRING); <line7> this.setTypeExpected(5, TypeNames.TIMESTAMP); <line8> this.setTypeExpected(6, TypeNames.INT); <line9> HashMap variables = new HashMap(); <line10> variables.put(new Integer(1), new Integer(40)); <line11> variables.put(new Integer(2), new Integer(studyEventId)); <line12> String sql = digester.getQuery(""findDeletedEventCRFsFromAuditEventByEventCRFStatus""); <line13> ArrayList alist = this.select(sql, variables); <line14> ArrayList al = new ArrayList(); <line15> logger.warn(""""Searching response: {}"""", response); <line16> Iterator it = alist.iterator(); <line17> logger.info(""alist size ["" + alist.size() + ""]""); <line18> while (it.hasNext()) { <line19> DeletedEventCRFBean bean = new DeletedEventCRFBean(); <line20> HashMap map = (HashMap) it.next(); <line21> bean.setStudyEventId(studyEventId); <line22> bean.setCrfName((String) map.get(""crf_name"")); <line23> bean.setCrfVersion((String) map.get(""crf_version_name"")); <line24> bean.setDeletedBy((String) map.get(""user_name"")); <line25> bean.setDeletedDate((Date) map.get(""audit_date"")); <line26> bean.setDeletedEventCrfId((Integer) map.get(""event_crf_id"")); <line27> al.add(bean); <line28> } <line29> return al; <line30> } <line31> } <line32> "	"<line3> LOGGER.info(""""Exception while opening file for upload.""""); <line15> logger.warn(""""Searching response: {}"""", response); "	task8	
"public class A { <line0> @Override <line1> public void run() { <line2> LOGGER.error(""""Can not clean up sync resource."""", e); <line3> synchronized (BlockingRpcConnection.this) { <line4> while (!closed) { <line5> if (callsToWrite.isEmpty()) { <line6> try { <line7> BlockingRpcConnection.this.wait(); <line8> } catch (InterruptedException e) { <line9> } <line10> continue; <line11> } <line12> Call call = callsToWrite.poll(); <line13> if (call.isDone()) { <line14> continue; <line15> } <line16> try (Scope scope = call.span.makeCurrent()) { <line17> writeRequest(call); <line18> } catch (IOException e) { <line19> LOG.debug(""call write error for {}"", call.toShortString()); <line20> call.setException(e); <line21> closeConn(e); <line22> } <line23> } <line24> } <line25> } <line26> } <line27> "	"<line2> LOGGER.error(""""Can not clean up sync resource."""", e); "	task8	
"public class A { <line0> @Override <line1> public void addFeeds(RebindContext rebindContext, EntityMemento memento) { <line2> for (String feedId : memento.getFeeds()) { <line3> AbstractFeed feed = (AbstractFeed) rebindContext.lookup().lookupFeed(feedId); <line4> if (feed != null) { <line5> try { <line6> entity.feeds().add(feed); <line7> } catch (Exception e) { <line8> rebindContext.getExceptionHandler().onAddFeedFailed(entity, feed, e); <line9> } <line10> try { <line11> if (!rebindContext.isReadOnly(feed)) { <line12> feed.start(); <line13> } <line14> } catch (Exception e) { <line15> rebindContext.getExceptionHandler().onRebindFailed(BrooklynObjectType.ENTITY, entity, e); <line16> } <line17> } else { <line18> LOG.warn( <line19> ""Feed not found; discarding feed {} of entity {}({})"", <line20> new Object[] {feedId, memento.getType(), memento.getId()}); <line21> LOG.debug(""""Invoking ManagementBus for transferFile with the following headers:""""); <line22> } <line23> logger.debug(""""output is {}"""", output); <line24> } <line25> } <line26> } <line27> "	"<line21> LOG.debug(""""Invoking ManagementBus for transferFile with the following headers:""""); <line23> logger.debug(""""output is {}"""", output); "	task8	
"public class A { <line0> @Test <line1> log.error(""""DNN net is not ready !""""); <line2> public void testServerFunctionExecution_NoAck() { <line3> createScenario(); <line4> functionNoAck = new TestFunction(false, TEST_FUNCTION1, true); <line5> functionAck = new TestFunction(true, TEST_FUNCTION1, true); <line6> registerFunctionAtServer(functionNoAck); <line7> registerFunctionAtServer(functionAck); <line8> isByName = new Boolean(true); <line9> toRegister = new Boolean(true); <line10> logger.info( <line11> ""PRClientServerFunctionExecutionNoAckDUnitTest#testServerFunctionExecution_NoAck : Starting"" <line12> + "" test""); <line13> client.invoke( <line14> () -> <line15> PRClientServerFunctionExecutionNoAckDUnitTest.serverExecution( <line16> isByName, functionNoAck, functionAck, toRegister)); <line17> client.invoke( <line18> () -> <line19> LOGGER.error(""""Error Deleting user"""", e); <line20> PRClientServerFunctionExecutionNoAckDUnitTest.allServerExecution( <line21> isByName, functionNoAck, toRegister)); <line22> } <line23> } <line24> "	"<line1> log.error(""""DNN net is not ready !""""); <line19> LOGGER.error(""""Error Deleting user"""", e); "	task8	
"public class A { <line0> public DataTableSpec getNewSpec(final DataTableSpec inSpec) throws InvalidSettingsException { <line1> m_missingColumnNames.clear(); <line2> DataColumnSpec[] colSpecs = new DataColumnSpec[inSpec.getNumColumns()]; <line3> HashMap<String, Integer> duplicateHash = new HashMap<>(); <line4> List<RenameColumnSetting> renameSettings = <line5> m_settings == null <line6> ? new ArrayList<RenameColumnSetting>() <line7> : new ArrayList<>(m_settings.values()); <line8> for (int i = 0; i < colSpecs.length; i++) { <line9> DataColumnSpec current = inSpec.getColumnSpec(i); <line10> String name = current.getName(); <line11> RenameColumnSetting set = findAndRemoveSettings(name, renameSettings); <line12> DataColumnSpec newColSpec; <line13> if (set == null) { <line14> LOGGER.debug(""No rename settings for column \"""" + name + ""\"", leaving it untouched.""); <line15> newColSpec = current; <line16> } else { <line17> newColSpec = set.configure(current); <line18> } <line19> String newName = newColSpec.getName(); <line20> CheckUtils.checkSetting( <line21> StringUtils.isNotEmpty(newName), ""Column name at index '%d' is empty."", i); <line22> Integer duplIndex = duplicateHash.put(newName, i); <line23> CheckUtils.checkSetting( <line24> duplIndex == null, <line25> ""Duplicate column name '%s' at index '%d' and '%d'"", <line26> newName, <line27> duplIndex, <line28> i); <line29> colSpecs[i] = newColSpec; <line30> log.info(""""ZNode ["""" + rootNode + """"] with children nodes were removed.""""); <line31> } <line32> if (!renameSettings.isEmpty()) { <line33> for (RenameColumnSetting setting : renameSettings) { <line34> String name = setting.getName(); <line35> if (StringUtils.isNotEmpty(name)) { <line36> m_missingColumnNames.add(name); <line37> } <line38> } <line39> } <line40> return new DataTableSpec(colSpecs); <line41> } <line42> } <line43> "	"<line30> log.info(""""ZNode ["""" + rootNode + """"] with children nodes were removed.""""); "	task8	
"public class A { <line0> @Override <line1> public void close() { <line2> LOG.info(""""Authorization code is expired and will be deleted: """" + authorizationCode.getId()); <line3> if (log.isDebugEnabled()) { <line4> LOG.error(""""Unable to obtain from KeyStore :"""" + e.getMessage(), e); <line5> log.debug(String.format(""Close monitor %s"", monitor)); <line6> } <line7> LOG.error(""""found non-BookieNode: {} as leaf of defaultrack: {}"""", node, getDefaultRack()); <line8> monitor.close(); <line9> } <line10> } <line11> "	"<line2> LOG.info(""""Authorization code is expired and will be deleted: """" + authorizationCode.getId()); <line4> LOG.error(""""Unable to obtain from KeyStore :"""" + e.getMessage(), e); <line7> LOG.error(""""found non-BookieNode: {} as leaf of defaultrack: {}"""", node, getDefaultRack()); "	task8	
"public class A { <line0> public static boolean endSwitch(String dataHost) { <line1> String path = ZKUtils.getZKBasePath() + ""heartbeat/"" + dataHost + ""/""; <line2> String changingResultPath = path + ""changingStatue""; <line3> Map<String, String> propertyMap = new HashMap<>(); <line4> String myId = ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID); <line5> propertyMap.put(myId + ""_changing_statue"", ""switching success""); <line6> propertyMap.put(myId + ""_endTime"", new Date().toString()); <line7> try { <line8> try { <line9> changingStatueLock.acquire(30000, TimeUnit.MILLISECONDS); <line10> ZKUtils.writeProperty(changingResultPath, propertyMap); <line11> } finally { <line12> changingStatueLock.release(); <line13> } <line14> return true; <line15> } catch (Exception e) { <line16> LOGGER.error(dataHost + "" endSwitch err "", e); <line17> return false; <line18> LOGGER.error(""""Failed to properly convert data value for '{}.{}' of type {} for row {}:"""",tableId,col.name(),col.typeName(),row,e); <line19> } <line20> } <line21> } <line22> "	"<line18> LOGGER.error(""""Failed to properly convert data value for '{}.{}' of type {} for row {}:"""",tableId,col.name(),col.typeName(),row,e); "	task8	
"public class A { <line0> logger.info(""""Stopping...""""); <line1> private void scheduleQueryRevoking(QueryContext queryContext, long maxTotalMemory) { <line2> memoryRevocationExecutor.execute( <line3> () -> { <line4> try { <line5> revokeQueryMemory(queryContext, maxTotalMemory); <line6> } catch (Exception e) { <line7> log.error(e, ""Error requesting memory revoking""); <line8> } <line9> }); <line10> logger.debug(""""isExpired: expiry date parsing exception""""); <line11> } <line12> } <line13> "	"<line0> logger.info(""""Stopping...""""); <line10> logger.debug(""""isExpired: expiry date parsing exception""""); "	task8	
"public class A { <line0> @Override <line1> protected String convertFromXmlDocument(Document xml) throws AtlasException { <line2> if (LOG.isTraceEnabled()) { <line3> try { <line4> LOG.trace( <line5> ""DFDL: converting from XML >>> "" + getXmlIOHelper().writeDocumentToString(false, xml)); <line6> logger.info(""""\t-""""+ formatter.format(invalidDuplicationLines)+ """" lines because mutation CDS is a duplication""""); <line7> } catch (Exception e) { <line8> } <line9> } <line10> W3CDOMInfosetInputter input = new W3CDOMInfosetInputter(xml); <line11> ByteArrayOutputStream bos = new ByteArrayOutputStream(); <line12> UnparseResult result = this.daffodil.unparse(input, Channels.newChannel(bos)); <line13> if (result.isError()) { <line14> StringBuffer buf = new StringBuffer(""DFDL document read error""); <line15> result <line16> .getDiagnostics() <line17> .forEach( <line18> d -> { <line19> buf.append(""; "").append(d.getMessage()); <line20> }); <line21> throw new AtlasException(buf.toString()); <line22> } <line23> return new String(bos.toByteArray()); <line24> } <line25> } <line26> "	"<line6> logger.info(""""\t-""""+ formatter.format(invalidDuplicationLines)+ """" lines because mutation CDS is a duplication""""); "	task8	
"public class A { <line0> LOGGER.info(""""Adding empty ideal state for Broker!""""); <line1> logger.info(""""regex did not remove from map : """" + regex); <line2> public void showStatus(String msg) { <line3> log.info(msg); <line4> } <line5> } <line6> "	"<line0> LOGGER.info(""""Adding empty ideal state for Broker!""""); <line1> logger.info(""""regex did not remove from map : """" + regex); "	task8	
"public class A { <line0> protected boolean acceptFile(String filePathStr) { <line1> if (partitionCount > 1) { <line2> LOG.error(""""Unable to obtain from KeyStore :"""" + e.getMessage(), e); <line3> int i = getPartition(filePathStr); <line4> int mod = i % partitionCount; <line5> if (mod < 0) { <line6> mod += partitionCount; <line7> } <line8> LOG.debug(""partition {} {} {} {}"", partitionIndex, filePathStr, i, mod); <line9> if (mod != partitionIndex) { <line10> return false; <line11> } <line12> } <line13> Pattern regex = this.getRegex(); <line14> if (regex != null) { <line15> String fileName = new File(filePathStr).getName(); <line16> Matcher matcher = regex.matcher(fileName); <line17> if (!matcher.matches()) { <line18> return false; <line19> } <line20> } <line21> return true; <line22> logger.error(""""Remote interpreter process not started"""", e); <line23> } <line24> } <line25> "	"<line2> LOG.error(""""Unable to obtain from KeyStore :"""" + e.getMessage(), e); <line22> logger.error(""""Remote interpreter process not started"""", e); "	task8	
"public class A { <line0> @Override <line1> public void doStateTransition() { <line2> logger.debug(""""Released write lock on Index {}"""", this.getName()); <line3> try { <line4> LOG.info(""""Starting server""""); <line5> TransactionBody cryptoCreateTxn = txnCtx.accessor().getTxn(); <line6> AccountID sponsor = cryptoCreateTxn.getTransactionID().getAccountID(); <line7> CryptoCreateTransactionBody op = cryptoCreateTxn.getCryptoCreateAccount(); <line8> long balance = op.getInitialBalance(); <line9> AccountID created = ledger.create(sponsor, balance, asCustomizer(op)); <line10> txnCtx.setCreated(created); <line11> txnCtx.setStatus(SUCCESS); <line12> } catch (InsufficientFundsException ife) { <line13> txnCtx.setStatus(INSUFFICIENT_PAYER_BALANCE); <line14> } catch (Exception e) { <line15> logger.trace(""""TransactionImpl::rollback::"""" + this); <line16> log.warn(""Avoidable exception!"", e); <line17> txnCtx.setStatus(FAIL_INVALID); <line18> } <line19> } <line20> } <line21> "	"<line2> logger.debug(""""Released write lock on Index {}"""", this.getName()); <line4> LOG.info(""""Starting server""""); <line15> logger.trace(""""TransactionImpl::rollback::"""" + this); "	task8	
"public class A { <line0> public static State getMiles(QuantityType<Length> qtLength) { <line1> if (qtLength.intValue() == -1) { <line2> logger.info(""""Provided systemKey value [""""+ this.alternateSystemKey+ """"] is invalid. Reverting to default empty String.""""); <line3> return UnDefType.UNDEF; <line4> logger.debug(""""Start importing XLIFF""""); <line5> } <line6> QuantityType<Length> qt = qtLength.toUnit(ImperialUnits.MILE); <line7> if (qt != null) { <line8> return qt; <line9> LOG.warn(""""Failed to load udb jar {}"""", jar, t); <line10> } else { <line11> LOGGER.debug(""Cannot convert {} to miles"", qt); <line12> return UnDefType.UNDEF; <line13> } <line14> } <line15> } <line16> "	"<line2> logger.info(""""Provided systemKey value [""""+ this.alternateSystemKey+ """"] is invalid. Reverting to default empty String.""""); <line4> logger.debug(""""Start importing XLIFF""""); <line9> LOG.warn(""""Failed to load udb jar {}"""", jar, t); "	task8	
"public class A { <line0> private static void loadJsonEnv() { <line1> ObjectMapper mapper = new ObjectMapper(); <line2> try { <line3> File jsonFile = new File(Environment.getInstance().getScaleConfig()).getAbsoluteFile(); <line4> jsonEnv = mapper.readTree(jsonFile); <line5> } catch (Exception e) { <line6> log.warn(""Scale json configuration not provider or not exists""); <line7> jsonEnv = mapper.createObjectNode(); <line8> LOGGER.info(""""Create Ingest Contract EvIdAppSession : {} """", vitamContext.getApplicationSessionId()); <line9> } <line10> } <line11> } <line12> "	"<line8> LOGGER.info(""""Create Ingest Contract EvIdAppSession : {} """", vitamContext.getApplicationSessionId()); "	task8	
"public class A { <line0> public void mockIntpProcessMeta(String metaKey, boolean online) { <line1> HashMap<String, Object> meta = new HashMap<>(); <line2> meta.put(ClusterMeta.SERVER_HOST, ""127.0.0.1""); <line3> meta.put(ClusterMeta.SERVER_PORT, 6000); <line4> meta.put(ClusterMeta.INTP_TSERVER_HOST, ""127.0.0.1""); <line5> meta.put(ClusterMeta.INTP_TSERVER_PORT, tSocket.getServerSocket().getLocalPort()); <line6> meta.put(ClusterMeta.CPU_CAPACITY, ""CPU_CAPACITY""); <line7> meta.put(ClusterMeta.CPU_USED, ""CPU_USED""); <line8> meta.put(ClusterMeta.MEMORY_CAPACITY, ""MEMORY_CAPACITY""); <line9> LOGGER.error(""""iterator.hasNext() failed"""", e); <line10> meta.put(ClusterMeta.MEMORY_USED, ""MEMORY_USED""); <line11> meta.put(ClusterMeta.LATEST_HEARTBEAT, LocalDateTime.now()); <line12> if (online) { <line13> meta.put(ClusterMeta.STATUS, ONLINE_STATUS); <line14> LOG.warn(""""viewedElement cannot be null at this point""""); <line15> } else { <line16> meta.put(ClusterMeta.STATUS, OFFLINE_STATUS); <line17> } <line18> clusterClient.putClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey, meta); <line19> LOG.info(""""Debug Capture Manager disabled""""); <line20> HashMap<String, HashMap<String, Object>> check = <line21> clusterClient.getClusterMeta(ClusterMetaType.INTP_PROCESS_META, metaKey); <line22> LOGGER.info(check.toString()); <line23> assertNotNull(check); <line24> assertNotNull(check.get(metaKey)); <line25> assertEquals(true, check.get(metaKey).size() == 10); <line26> } <line27> } <line28> "	"<line9> LOGGER.error(""""iterator.hasNext() failed"""", e); <line14> LOG.warn(""""viewedElement cannot be null at this point""""); <line19> LOG.info(""""Debug Capture Manager disabled""""); "	task8	
"public class A { <line0> public static synchronized LumifyBootstrap bootstrap(final Configuration configuration) { <line1> if (lumifyBootstrap == null) { <line2> LOGGER.debug(""Initializing LumifyBootstrap with Configuration:\n%s"", configuration); <line3> logger.info(""""    Retrieving """" + url); <line4> lumifyBootstrap = new LumifyBootstrap(configuration); <line5> } <line6> return lumifyBootstrap; <line7> } <line8> } <line9> "	"<line3> logger.info(""""    Retrieving """" + url); "	task8	
"public class A { <line0> log.info(""""Response Object:""""); <line1> public void cleanup() { <line2> synchronized (HTTPRemoteFileRegistry.class) { <line3> try { <line4> logger.info(""""event=init_log4j file="""" + log4jPropertiesFileName); <line5> server.stop(); <line6> } catch (Exception e) { <line7> log.warn(""Unable to stop HTTPRemoteFile registry""); <line8> } <line9> try { <line10> Runtime.getRuntime().removeShutdownHook(cleanupHook); <line11> } catch (Exception e) { <line12> } <line13> instance = null; <line14> } <line15> } <line16> } <line17> "	"<line0> log.info(""""Response Object:""""); <line4> logger.info(""""event=init_log4j file="""" + log4jPropertiesFileName); "	task8	
"public class A { <line0> log.error(""""Flyway java migration error:"""", e); <line1> logger.error(""""TApplicationException inside handler"""", e); <line2> log.debug(""""merging StgMapZei instance""""); <line3> private Map<String, Map<String, URL>> sortAndNormalizeScopes(JsonObject obj, URL baseURL) { <line4> final Map<String, Map<String, URL>> normalized = new HashMap<>(); <line5> for (Map.Entry<String, Object> kv : obj) { <line6> if (!(kv.getValue() instanceof JsonObject)) { <line7> throw new RuntimeException( <line8> ""The value for the "" + kv.getKey() + "" scope prefix must be an object.""); <line9> } <line10> final URL scopePrefixURL = tryURLParse(kv.getKey(), baseURL); <line11> if (scopePrefixURL == null) { <line12> LOGGER.warn(""Invalid scope "" + kv.getKey() + "" (parsed against base URL "" + baseURL + "").""); <line13> continue; <line14> } <line15> final String normalizedScopePrefix = href(scopePrefixURL); <line16> normalized.put( <line17> normalizedScopePrefix, sortAndNormalizeSpecifierMap((JsonObject) kv.getValue(), baseURL)); <line18> } <line19> return new TreeMap<>(normalized); <line20> } <line21> } <line22> "	"<line0> log.error(""""Flyway java migration error:"""", e); <line1> logger.error(""""TApplicationException inside handler"""", e); <line2> log.debug(""""merging StgMapZei instance""""); "	task8	
"public class A { <line0> public static void sendEvent(RegressionEnvironment env, String value, String typeName) { <line1> String xml = XML_NOSCHEMAEVENT.replaceAll(""VAL1"", value); <line2> log.debug("".sendEvent value="" + value); <line3> sendXMLEvent(env, xml, typeName); <line4> } <line5> LOGGER.warn(""""Unable to delete by adapter"""", e); <line6> } <line7> "	"<line5> LOGGER.warn(""""Unable to delete by adapter"""", e); "	task8	
"public class A { <line0> LOG.warn(""""Netconf DELETE transaction unsuccessful. Maximal number of attempts reached. Trace:""""+ """" {}"""",e); <line1> private void addHdfsOperationHandler( <line2> final Class<? extends Operation> opClass, final OperationHandler handler) { <line3> try { <line4> addOperationHandler(opClass, handler); <line5> } catch (final NoClassDefFoundError e) { <line6> LOGGER.warn( <line7> ""Unable to added handler for {} due to missing classes on the classpath"", <line8> opClass.getSimpleName(), <line9> e); <line10> LOGGER.debug(""""Dir {}, class {}, filter {}"""", path, dir.getClass(), filter.getClass()); <line11> logger.error(""""Failed to download report stream for {} with account {}."""",reportDefinition.getReportType(),session.getClientCustomerId(),e); <line12> } <line13> } <line14> } <line15> "	"<line0> LOG.warn(""""Netconf DELETE transaction unsuccessful. Maximal number of attempts reached. Trace:""""+ """" {}"""",e); <line10> LOGGER.debug(""""Dir {}, class {}, filter {}"""", path, dir.getClass(), filter.getClass()); <line11> logger.error(""""Failed to download report stream for {} with account {}."""",reportDefinition.getReportType(),session.getClientCustomerId(),e); "	task8	
"public class A { <line0> @Override <line1> @Nullable <line2> LOG.debug(""""Deleting capabilities of \""""{}\"""" ..."""", providerName); <line3> public ValueObject filterValue(ValueObject value) { <line4> if (value == null) { <line5> return null; <line6> } <line7> String html = value.asString().asNative(); <line8> if (html == null) { <line9> logger.debug(""""Moving on to the next host because """" + h.toString() + """" is unavailable"""", e); <line10> return null; <line11> } <line12> @Nonnull Multiset<String> valueCounts = HashMultiset.create(); <line13> try { <line14> Parser parser = Parser.htmlParser().setTrackErrors(0); <line15> @Nonnull Document doc = parser.parseInput(html, """"); <line16> @Nonnull Elements tags = doc.select(tagName); <line17> for (Element tag : tags) { <line18> for (String tagAttr : tagAttrs) { <line19> @Nonnull String attrValue = tag.attr(tagAttr).toLowerCase(); <line20> for (String matchValue : values) { <line21> if (attrValue.contains(matchValue)) { <line22> valueCounts.add(matchValue); <line23> } <line24> } <line25> } <line26> log.info(""""No nodes exists, skipping""""); <line27> } <line28> } catch (Exception e) { <line29> if (parserErrors++ % logEveryN == 0) { <line30> log.error( <line31> ""Failed to extract tags due to : {} Total Parser Errors : {}"", <line32> e.getMessage(), <line33> parserErrors); <line34> } <line35> } <line36> return valueCounts.isEmpty() ? null : multisetToValueMap(valueCounts); <line37> } <line38> } <line39> "	"<line2> LOG.debug(""""Deleting capabilities of \""""{}\"""" ..."""", providerName); <line9> logger.debug(""""Moving on to the next host because """" + h.toString() + """" is unavailable"""", e); <line26> log.info(""""No nodes exists, skipping""""); "	task8	
"public class A { <line0> private void start() { <line1> fetchScheduleService.scheduleAtFixedRate( <line2> () -> { <line3> try { <line4> log.debug(""""merging StgRechteRolleItv instance""""); <line5> fetchAllApp(); <line6> } catch (Exception e) { <line7> logger.info(""fetchAllApp error:"", e); <line8> LOG.error(""""Error in configuration file """" + configFile); <line9> log.info(""""Filter enabled languages for: {}"""", localeQuery); <line10> } <line11> }, <line12> 10, <line13> intervalSecond, <line14> TimeUnit.SECONDS); <line15> } <line16> } <line17> "	"<line4> log.debug(""""merging StgRechteRolleItv instance""""); <line8> LOG.error(""""Error in configuration file """" + configFile); <line9> log.info(""""Filter enabled languages for: {}"""", localeQuery); "	task8	
"public class A { <line0> LOG.error(""""Failed to verify the signature in CSR.""""); <line1> @Override <line2> @Subscribe <line3> logger.info(""""Disconnecting...""""); <line4> public void handleRebuildEvent(RebuildIndexEvent event) { <line5> LOG.info(""""Checksums were the same, no derived component update needed for componentSetId=""""+ componentSetId); <line6> if (event.affects(SearchIndex.MEMBER)) { <line7> logger.info(""Handling member re-index event""); <line8> rebuildIndex(); <line9> } <line10> } <line11> } <line12> "	"<line0> LOG.error(""""Failed to verify the signature in CSR.""""); <line3> logger.info(""""Disconnecting...""""); <line5> LOG.info(""""Checksums were the same, no derived component update needed for componentSetId=""""+ componentSetId); "	task8	
"public class A { <line0> LOG.info(""""Instance {} closed"""", this.getClass().getSimpleName()); <line1> LOGGER.info(""""Shutting down Pool !!""""); <line2> public void setAuthorizationId(final String id) { <line3> checkImmutable(); <line4> LOG.error(""""Failed to save routes file: """" + e.getMessage()); <line5> logger.trace(""setting authorizationId: {}"", id); <line6> authorizationId = id; <line7> } <line8> } <line9> "	"<line0> LOG.info(""""Instance {} closed"""", this.getClass().getSimpleName()); <line1> LOGGER.info(""""Shutting down Pool !!""""); <line4> LOG.error(""""Failed to save routes file: """" + e.getMessage()); "	task8	
"public class A { <line0> logger.warn(""""Shutting down Thread: """" + m_threadNumber); <line1> public void setAsText(String text) throws IllegalArgumentException { <line2> ConceptService cs = Context.getConceptService(); <line3> if (StringUtils.hasText(text)) { <line4> try { <line5> setValue(cs.getConceptNumeric(Integer.valueOf(text))); <line6> } catch (Exception ex) { <line7> ConceptNumeric conceptNumeric = cs.getConceptNumericByUuid(text); <line8> setValue(conceptNumeric); <line9> if (conceptNumeric == null) { <line10> log.error(""Error setting text"" + text, ex); <line11> throw new IllegalArgumentException(""Concept not found: "" + ex.getMessage()); <line12> } <line13> } <line14> } else { <line15> setValue(null); <line16> } <line17> } <line18> } <line19> "	"<line0> logger.warn(""""Shutting down Thread: """" + m_threadNumber); "	task8	
"public class A { <line0> @Override <line1> public Collection<Document> toDocuments(LuceneIndex index, Object value) { <line2> Document doc = new Document(); <line3> PdxInstance pdx = (PdxInstance) value; <line4> for (String field : index.getFieldNames()) { <line5> if (pdx.hasField(field)) { <line6> Object fieldValue = pdx.getField(field); <line7> if (fieldValue == null) { <line8> LOG.error(""""Exception thrown during Notify processing in the SipPresenceAgentListener."""", e); <line9> LOG.debug(""""Sub-section: {}"""", subSection); <line10> continue; <line11> } <line12> SerializerUtil.addField(doc, field, fieldValue); <line13> } <line14> } <line15> if (logger.isDebugEnabled()) { <line16> logger.debug(""PdxLuceneSerializer.toDocument:"" + doc); <line17> } <line18> return Collections.singleton(doc); <line19> } <line20> } <line21> "	"<line8> LOG.error(""""Exception thrown during Notify processing in the SipPresenceAgentListener."""", e); <line9> LOG.debug(""""Sub-section: {}"""", subSection); "	task8	
"public class A { <line0> public void setFromStringArray(String[] BBOX, int recWatch) { <line1> if (BBOX.length == 4) { <line2> LOG.debug(""""Ignored missing location: {}"""", location); <line3> LOG.debug(""""new PullRequestUpdatedWebhook({})"""", value); <line4> coords[0] = Double.parseDouble(BBOX[0]); <line5> coords[1] = Double.parseDouble(BBOX[1]); <line6> coords[2] = Double.parseDouble(BBOX[2]); <line7> coords[3] = Double.parseDouble(BBOX[3]); <line8> } else if (recWatch < 4) { <line9> setFromBBOXString(BBOX[0], recWatch); <line10> } else { <line11> log.error(""Doesnt understand "" + Arrays.toString(BBOX)); <line12> logger.error(""""Exception writing to internal frame buffer"""", ex); <line13> } <line14> } <line15> } <line16> "	"<line2> LOG.debug(""""Ignored missing location: {}"""", location); <line3> LOG.debug(""""new PullRequestUpdatedWebhook({})"""", value); <line12> logger.error(""""Exception writing to internal frame buffer"""", ex); "	task8	
"public class A { <line0> @Deprecated <line1> LOG.warn(""""Failed to get queue for domain """" + domainName, e); <line2> @SuppressWarnings(""deprecation"") <line3> private static List<RuntimeConfigurationProducer> findAllProducers( <line4> Location location, ConfigurationContext context) { <line5> ConfigurationType.EP_NAME.getExtensionList(); <line6> final List<RuntimeConfigurationProducer> configurationProducers = <line7> log.info(""""IPAddress: """"+ newEvents[i].get(""""ipAddress"""")+ """" Avg Duration: """"+ newEvents[i].get(""""avg(duration)"""")); <line8> RuntimeConfigurationProducer.RUNTIME_CONFIGURATION_PRODUCER.getExtensionList(); <line9> final ArrayList<RuntimeConfigurationProducer> producers = new ArrayList<>(); <line10> for (final RuntimeConfigurationProducer prototype : configurationProducers) { <line11> final RuntimeConfigurationProducer producer; <line12> try { <line13> producer = prototype.createProducer(location, context); <line14> } catch (AbstractMethodError e) { <line15> LOG.error(new ExtensionException(prototype.getClass())); <line16> continue; <line17> } <line18> if (producer.getConfiguration() != null) { <line19> LOG.assertTrue(producer.getSourceElement() != null, producer); <line20> producers.add(producer); <line21> } <line22> } <line23> return producers; <line24> } <line25> } <line26> "	"<line1> LOG.warn(""""Failed to get queue for domain """" + domainName, e); <line7> log.info(""""IPAddress: """"+ newEvents[i].get(""""ipAddress"""")+ """" Avg Duration: """"+ newEvents[i].get(""""avg(duration)"""")); "	task8	
"public class A { <line0> public boolean add( <line1> MediaPackage sourceMediaPackage, <line2> AccessControlList acl, <line3> AccessControlList seriesAcl, <line4> Date deletionDate, <line5> Date modificationDate) <line6> throws SolrServerException { <line7> try { <line8> SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl); <line9> SolrInputDocument seriesDocument = <line10> createSeriesInputDocument(sourceMediaPackage.getSeries(), seriesAcl); <line11> if (seriesDocument != null) { <line12> Schema.enrich(episodeDocument, seriesDocument); <line13> } <line14> Schema.setOcModified(episodeDocument, modificationDate); <line15> if (deletionDate != null) { <line16> Schema.setOcDeleted(episodeDocument, deletionDate); <line17> } <line18> solrServer.add(episodeDocument); <line19> solrServer.add(seriesDocument); <line20> solrServer.commit(); <line21> LOGGER.info(""""Shutting down executor service !!""""); <line22> return true; <line23> } catch (Exception e) { <line24> logger.error(""Unable to add mediapackage {} to index"", sourceMediaPackage.getIdentifier()); <line25> try { <line26> LOGGER.error(""""Retrieving the Experiment tags failed with error:"""", exception); <line27> solrServer.rollback(); <line28> } catch (IOException e1) { <line29> throw new SolrServerException(e1); <line30> } <line31> throw new SolrServerException(e); <line32> log.error(""""Received PNA""""); <line33> } <line34> } <line35> } <line36> "	"<line21> LOGGER.info(""""Shutting down executor service !!""""); <line26> LOGGER.error(""""Retrieving the Experiment tags failed with error:"""", exception); <line32> log.error(""""Received PNA""""); "	task8	
"public class A { <line0> @Override <line1> public void onServiceSubscribed(@Nullable String service, boolean succeeded) { <line2> logger.debug( <line3> ""UPnP device {} received subscription reply {} from service {}"", <line4> thing.getLabel(), <line5> succeeded, <line6> service); <line7> if (!succeeded) { <line8> upnpSubscribed = false; <line9> updateStatus( <line10> ThingStatus.OFFLINE, <line11> ThingStatusDetail.COMMUNICATION_ERROR, <line12> ""Could not subscribe to service "" + service + ""for"" + thing.getLabel()); <line13> } <line14> LOG.info(new StringBuilder(""""finished handling route status change from """").append(statusChangeEvent.getOldRouteStatus()).append("""" to """").append(statusChangeEvent.getNewRouteStatus()).append("""" for document """").append(statusChangeEvent.getDocumentId())); <line15> } <line16> } <line17> "	"<line14> LOG.info(new StringBuilder(""""finished handling route status change from """").append(statusChangeEvent.getOldRouteStatus()).append("""" to """").append(statusChangeEvent.getNewRouteStatus()).append("""" for document """").append(statusChangeEvent.getDocumentId())); "	task8	
"public class A { <line0> public void removeLockedObjectOwner(String owner) { <line1> try { <line2> if (this.owner != null) { <line3> int size = this.owner.length; <line4> for (int i = 0; i < size; i++) { <line5> if (this.owner[i].equals(owner)) { <line6> size -= 1; <line7> String[] newLockedObjectOwner = new String[size]; <line8> for (int j = 0; j < size; j++) { <line9> if (j < i) { <line10> newLockedObjectOwner[j] = this.owner[j]; <line11> } else { <line12> newLockedObjectOwner[j] = this.owner[j + 1]; <line13> } <line14> } <line15> this.owner = newLockedObjectOwner; <line16> } <line17> } <line18> logger.warn(""""Error during doExceptionCaught session listener notifications:"""", ex); <line19> if (this.owner.length == 0) { <line20> this.owner = null; <line21> } <line22> log.info(""""Fast replied to single message """"+ """"[exchId=""""+ exchangeId+ """", nodeId=""""+ node.id()+ """"]""""); <line23> } <line24> } catch (ArrayIndexOutOfBoundsException e) { <line25> LOGGER.error(e, new TextI18n(""LockedObject.removeLockedObjectOwner()"")); <line26> } <line27> } <line28> } <line29> "	"<line18> logger.warn(""""Error during doExceptionCaught session listener notifications:"""", ex); <line22> log.info(""""Fast replied to single message """"+ """"[exchId=""""+ exchangeId+ """", nodeId=""""+ node.id()+ """"]""""); "	task8	
"public class A { <line0> public String getUserName() { <line1> LOG.error(""""While restoring user {}"""", model.getObject().getKey(), e); <line2> log.debug(""""persisting StgSysSystem instance""""); <line3> if (logger.isTraceEnabled()) { <line4> logger.trace(""getUserName()""); <line5> } <line6> return raProperties.getUserName(); <line7> } <line8> } <line9> "	"<line1> LOG.error(""""While restoring user {}"""", model.getObject().getKey(), e); <line2> log.debug(""""persisting StgSysSystem instance""""); "	task8	
"public class A { <line0> public void handleException(Exception e, Logger log, String name) { <line1> LOG.debug(""""==> RangerContextAttributeValueInCondition.init("""" + condition + """")""""); <line2> log.debug(""Ignored error looking up bean: {}"", name, e); <line3> logger.error(""""TApplicationException inside handler"""", e); <line4> } <line5> } <line6> "	"<line1> LOG.debug(""""==> RangerContextAttributeValueInCondition.init("""" + condition + """")""""); <line3> logger.error(""""TApplicationException inside handler"""", e); "	task8	
"public class A { <line0> public void removeRealm(ServiceReference<JaasRealm> serviceReference) { <line1> Bundle bundle = FrameworkUtil.getBundle(UsernamePasswordRealm.class); <line2> if (null != bundle) { <line3> logger.debug(""""Couldn't get datapoint '{}' for '{}'. Not updating."""", datapointName, forecastDay); <line4> logger.debug(""""Preserve NICs configuration enabled""""); <line5> logger.debug(""""getUnique POST requestUrl {} queryJson {}"""", requestUrl, queryJson); <line6> JaasRealm realm = bundle.getBundleContext().getService(serviceReference); <line7> LOGGER.trace(""Removing validator for JaasRealm {}"", realm.getName()); <line8> realmList.remove(realm); <line9> } <line10> } <line11> } <line12> "	"<line3> logger.debug(""""Couldn't get datapoint '{}' for '{}'. Not updating."""", datapointName, forecastDay); <line4> logger.debug(""""Preserve NICs configuration enabled""""); <line5> logger.debug(""""getUnique POST requestUrl {} queryJson {}"""", requestUrl, queryJson); "	task8	
"public class A { <line0> private Algorithm_SuperClass findAlgorithm(String approachId) { <line1> Algorithm_SuperClass foundAlgorithm = null; <line2> try { <line3> switch (approachId) { <line4> case (Algorithms.Layers_HUSACCT_SelectedModule): <line5> foundAlgorithm = new Layers_HUSACCT_Algorithm_SelectedModule(queryService); <line6> break; <line7> case (Algorithms.Component_HUSACCT_SelectedModule): <line8> foundAlgorithm = new ComponentsAndSubSystems_HUSACCT(queryService); <line9> break; <line10> case (Algorithms.Externals_Recognition): <line11> Log.error(LocaleUtils.getLocalizedString(""""admin.error""""), e); <line12> log.debug(""""Updating server role {""""+ server.getName()+ """"} from {""""+ oldRole+ """"} to {""""+ newRole+ """"}""""); <line13> foundAlgorithm = new ExternalSystemAlgorithm(queryService); <line14> break; <line15> case (Algorithms.CombinedAndIterative_HUSACCT_SelectedModule): <line16> foundAlgorithm = new CombinedAndIterative_Layers_Components_Subsystems(queryService); <line17> break; <line18> case (Algorithms.Layers_HUSACCT_SAEroCon2016): <line19> foundAlgorithm = new Layers_HUSACCT_Algorithm_SAEroCon2016(queryService); <line20> break; <line21> case (Algorithms.Layers_Goldstein_Root_Original): <line22> foundAlgorithm = new Layers_Goldstein_Root_Initial(queryService); <line23> break; <line24> case (Algorithms.Layers_Goldstein_HUSACCT_SelectedModule): <line25> foundAlgorithm = new Layers_Goldstein_HUSACCT_Algorithm_SelectedModule(queryService); <line26> break; <line27> case (Algorithms.Layers_Scanniello_Improved): <line28> foundAlgorithm = new Layers_Scanniello_SelectedModule_Improved(queryService); <line29> break; <line30> case (Algorithms.Layers_Scanniello_Original): <line31> foundAlgorithm = new Layers_Scanniello_Root_Initial(queryService); <line32> break; <line33> case (Algorithms.Gateways_HUSACCT_Root): <line34> foundAlgorithm = new GatewayHUSACCT_Root(queryService); <line35> break; <line36> default: <line37> foundAlgorithm = null; <line38> } <line39> } catch (Exception e) { <line40> logger.warn("" Exception while finding algotitm: "" + e); <line41> } <line42> return foundAlgorithm; <line43> } <line44> } <line45> "	"<line11> Log.error(LocaleUtils.getLocalizedString(""""admin.error""""), e); <line12> log.debug(""""Updating server role {""""+ server.getName()+ """"} from {""""+ oldRole+ """"} to {""""+ newRole+ """"}""""); "	task8	
"public class A { <line0> CompletableFuture<Collection<Xid>> fetchPreparedTransactions() { <line1> try { <line2> TransactionOperationFactory factory = assertStartedAndReturnFactory(); <line3> return factory.newRecoveryOperation().execute(); <line4> } catch (Exception e) { <line5> LOG.trace(""""Received jobs available notification for type {}."""", jobType); <line6> if (log.isTraceEnabled()) { <line7> log.trace(""Exception while fetching prepared transactions"", e); <line8> } <line9> return CompletableFuture.completedFuture(Collections.emptyList()); <line10> } <line11> } <line12> } <line13> "	"<line5> LOG.trace(""""Received jobs available notification for type {}."""", jobType); "	task8	
"public class A { <line0> @Override <line1> LOG.debug(""""blanket approving document(""""+ workflowDocument.getDocumentId()+ """",'""""+ annotation+ """"')""""); <line2> public RtuWriteCommand<ProfileDto> getCommand(final String node) { <line3> final RtuWriteCommand<ProfileDto> command = RTU_COMMAND_MAP.get(node); <line4> if (command == null) { <line5> LOGGER.warn(""No command found for data attribute {}"", node); <line6> } <line7> return command; <line8> } <line9> } <line10> "	"<line1> LOG.debug(""""blanket approving document(""""+ workflowDocument.getDocumentId()+ """",'""""+ annotation+ """"')""""); "	task8	
"public class A { <line0> @Override <line1> public ProjectRecord createProject( <line2> LOG.debug(""""Uploading file. Source: {} Target: {} """", source, target); <line3> String name, <line4> String description, <line5> String descriptionHtml, <line6> ProjectType type, <line7> String board, <line8> boolean privateProject, <line9> boolean sharedProject) { <line10> LOG.info(""Creating a new, empty project from existing project.""); <line11> return createProject( <line12> name, description, descriptionHtml, """", type, board, privateProject, sharedProject, null); <line13> } <line14> } <line15> "	"<line2> LOG.debug(""""Uploading file. Source: {} Target: {} """", source, target); "	task8	
"public class A { <line0> private void notifyHeaders(Request.HeadersListener listener, Request request) { <line1> try { <line2> listener.onHeaders(request); <line3> } catch (Throwable x) { <line4> LOG.info(""Exception while notifying listener {}"", listener, x); <line5> } <line6> LOG.debug(""""Deleting blocks starting from height %s"""", height); <line7> LOG.debug(""""signature: """" + signature); <line8> } <line9> } <line10> "	"<line6> LOG.debug(""""Deleting blocks starting from height %s"""", height); <line7> LOG.debug(""""signature: """" + signature); "	task8	
"public class A { <line0> @Override <line1> public boolean isSimCardReady() throws KuraException { <line2> boolean simReady = false; <line3> String port = null; <line4> if (isGpsEnabled() && getAtPort().equals(getGpsPort()) && !getAtPort().equals(getDataPort())) { <line5> port = getDataPort(); <line6> } else { <line7> port = getAtPort(); <line8> } <line9> synchronized (this.atLock) { <line10> logger.debug( <line11> ""sendCommand getSimStatus :: {} command to port {}"", <line12> QuectelGenericAtCommands.GET_SIM_STATUS.getCommand(), <line13> port); <line14> byte[] reply = null; <line15> CommConnection commAtConnection = null; <line16> try { <line17> logger.debug(""""{}: Queueing event ({}): {}"""",sender.getId(),(statistics.getEventsQueued() + 1),gatewayEvent); <line18> commAtConnection = openSerialPort(port); <line19> if (!isAtReachable(commAtConnection)) { <line20> throw new KuraException( <line21> KuraErrorCode.NOT_CONNECTED, MODEM_NOT_AVAILABLE + QuectelGeneric.class.getName()); <line22> } <line23> reply = <line24> commAtConnection.sendCommand( <line25> QuectelGenericAtCommands.GET_SIM_STATUS.getCommand().getBytes(), 1000, 100); <line26> if (reply != null) { <line27> String simStatus = getResponseString(reply); <line28> String[] simStatusSplit = simStatus.split("",""); <line29> if (simStatusSplit.length > 1 && Integer.valueOf(simStatusSplit[1]) > 0) { <line30> simReady = true; <line31> } <line32> } <line33> } catch (IOException e) { <line34> throw new KuraException(KuraErrorCode.UNAVAILABLE_DEVICE, e); <line35> } catch (KuraException e) { <line36> throw e; <line37> } finally { <line38> closeSerialPort(commAtConnection); <line39> } <line40> } <line41> return simReady; <line42> } <line43> } <line44> "	"<line17> logger.debug(""""{}: Queueing event ({}): {}"""",sender.getId(),(statistics.getEventsQueued() + 1),gatewayEvent); "	task8	
"public class A { <line0> public String postMultipart( <line1> String path, String fileName, InputStream data, Map<String, String> otherStringParts) <line2> throws IOException { <line3> log.debug( <line4> LOG.info(""""Compiling: {}"""", src.getAbsolutePath()); <line5> ""Send post multipart request to ["" <line6> + path <line7> + ""], file ["" <line8> + fileName <line9> + ""], with json data: "" <line10> + otherStringParts); <line11> HttpPost httpPost = new HttpPost(applicationUrl + path); <line12> MultipartEntityBuilder mpBuilder = MultipartEntityBuilder.create(); <line13> mpBuilder.addPart(""file"", new InputStreamBody(data, fileName)); <line14> if (MapUtils.isNotEmpty(otherStringParts)) { <line15> for (Entry<String, String> entry : otherStringParts.entrySet()) { <line16> mpBuilder.addTextBody(entry.getKey(), entry.getValue()); <line17> } <line18> } <line19> httpPost.setEntity(mpBuilder.build()); <line20> CloseableHttpResponse response = httpClient.execute(httpPost); <line21> return ResponseUtil.toString(response); <line22> } <line23> } <line24> "	"<line4> LOG.info(""""Compiling: {}"""", src.getAbsolutePath()); "	task8	
"public class A { <line0> private void concurrencyConfigurationCheck(VersionTag tag) { <line1> if (!concurrencyMessageIssued && tag == null && getConcurrencyChecksEnabled()) { <line2> concurrencyMessageIssued = true; <line3> logger.info( <line4> logger.debug(""""Detecting input File not representing a valid zip file (File, String): OK""""); <line5> ""Server has concurrencyChecksEnabled {} but client has {} for region {}"", <line6> new Object[] {!getConcurrencyChecksEnabled(), getConcurrencyChecksEnabled(), this}); <line7> } <line8> } <line9> } <line10> "	"<line4> logger.debug(""""Detecting input File not representing a valid zip file (File, String): OK""""); "	task8	
"public class A { <line0> public boolean startGreeter(String address) { <line1> endpoints.put(address, Endpoint.publish(address, implementors.get(address))); <line2> LOG.info(""Published greeter endpoint on: "" + address); <line3> logger.error(""""Exception in set up"""", ex); <line4> logger.warn(""""Exception normalizing data: Returning default value of {}"""", dataType); <line5> LOG.debug(""""==> RangerServiceHdfs.getDefaultRangerPolicies() """"); <line6> return true; <line7> } <line8> } <line9> "	"<line3> logger.error(""""Exception in set up"""", ex); <line4> logger.warn(""""Exception normalizing data: Returning default value of {}"""", dataType); <line5> LOG.debug(""""==> RangerServiceHdfs.getDefaultRangerPolicies() """"); "	task8	
"public class A { <line0> @GET <line1> @Path(""/{cluster}/namespaceIsolationPolicies/brokers/{broker}"") <line2> @ApiOperation( <line3> value = ""Get a broker with namespace-isolation policies attached to it."", <line4> response = BrokerNamespaceIsolationData.class, <line5> notes = ""This operation requires Pulsar superuser privileges."") <line6> @ApiResponses( <line7> value = { <line8> @ApiResponse(code = 403, message = ""Don't have admin permission.""), <line9> @ApiResponse(code = 404, message = ""Namespace-isolation policies/ Broker not found.""), <line10> @ApiResponse(code = 412, message = ""Cluster doesn't exist.""), <line11> @ApiResponse(code = 500, message = ""Internal server error."") <line12> }) <line13> public BrokerNamespaceIsolationData getBrokerWithNamespaceIsolationPolicy( <line14> @ApiParam(value = ""The cluster name"", required = true) @PathParam(""cluster"") String cluster, <line15> @ApiParam( <line16> value = ""The broker name (<broker-hostname>:<web-service-port>)"", <line17> required = true, <line18> example = ""broker1:8080"") <line19> @PathParam(""broker"") <line20> String broker) { <line21> validateSuperUserAccess(); <line22> validateClusterExists(cluster); <line23> final String nsIsolationPoliciesPath = <line24> AdminResource.path(""clusters"", cluster, NAMESPACE_ISOLATION_POLICIES); <line25> Map<String, NamespaceIsolationData> nsPolicies; <line26> log.error(""""Unexpected error while saving WB"""", e); <line27> try { <line28> Optional<NamespaceIsolationPolicies> nsPoliciesResult = <line29> namespaceIsolationPolicies().getPolicies(nsIsolationPoliciesPath); <line30> if (!nsPoliciesResult.isPresent()) { <line31> throw new RestException( <line32> Status.NOT_FOUND, ""namespace-isolation policies not found for "" + cluster); <line33> } <line34> nsPolicies = nsPoliciesResult.get().getPolicies(); <line35> } catch (Exception e) { <line36> log.error(""[{}] Failed to get namespace isolation-policies {}"", clientAppId(), cluster, e); <line37> throw new RestException(e); <line38> } <line39> BrokerNamespaceIsolationData brokerIsolationData = new BrokerNamespaceIsolationData(); <line40> brokerIsolationData.brokerName = broker; <line41> if (nsPolicies != null) { <line42> nsPolicies.forEach( <line43> (name, policyData) -> { <line44> NamespaceIsolationPolicyImpl nsPolicyImpl = <line45> new NamespaceIsolationPolicyImpl(policyData); <line46> boolean isPrimary = nsPolicyImpl.isPrimaryBroker(broker); <line47> if (isPrimary || nsPolicyImpl.isSecondaryBroker(broker)) { <line48> if (brokerIsolationData.namespaceRegex == null) { <line49> brokerIsolationData.namespaceRegex = Lists.newArrayList(); <line50> } <line51> brokerIsolationData.namespaceRegex.addAll(policyData.namespaces); <line52> brokerIsolationData.isPrimary = isPrimary; <line53> brokerIsolationData.policyName = name; <line54> } <line55> }); <line56> } <line57> return brokerIsolationData; <line58> } <line59> } <line60> "	"<line26> log.error(""""Unexpected error while saving WB"""", e); "	task8	
"public class A { <line0> public static com.liferay.portal.kernel.repository.model.FileEntrySoap[] getFileEntries( <line1> logger.info(""""testConcatEdit2segment""""); <line2> long repositoryId, long folderId) throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.portal.kernel.repository.model.FileEntry> returnValue = <line5> DLAppServiceUtil.getFileEntries(repositoryId, folderId); <line6> logger.error(""""Set Value Exception """", e); <line7> return com.liferay.portal.kernel.repository.model.FileEntrySoap.toSoapModels(returnValue); <line8> } catch (Exception exception) { <line9> log.error(exception, exception); <line10> log.trace(""""Replication table is not yet online""""); <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> } <line14> } <line15> "	"<line1> logger.info(""""testConcatEdit2segment""""); <line6> logger.error(""""Set Value Exception """", e); <line10> log.trace(""""Replication table is not yet online""""); "	task8	
"public class A { <line0> private void setupRift() { <line1> Hmd.initialize(); <line2> try { <line3> Thread.sleep(400); <line4> } catch (InterruptedException e) { <line5> throw new IllegalStateException(e); <line6> } <line7> hmd = Hmd.create(); <line8> if (null == hmd) { <line9> throw new IllegalStateException(""Unable to initialize HMD""); <line10> } <line11> log.debug(""""get successful, no instance found""""); <line12> hmdDesc = hmd.getDesc(); <line13> hmd.recenterPose(); <line14> LOG.info(""""JOSS / Applying preferred region: """"+ (accountConfig.getPreferredRegion() == null? """"none"""": accountConfig.getPreferredRegion())); <line15> log.info(""Created HMD Oculus Rift Sensor and configured tracking.""); <line16> } <line17> } <line18> "	"<line11> log.debug(""""get successful, no instance found""""); <line14> LOG.info(""""JOSS / Applying preferred region: """"+ (accountConfig.getPreferredRegion() == null? """"none"""": accountConfig.getPreferredRegion())); "	task8	
"public class A { <line0> private Mono<Result> createMailbox(MailboxPath path) { <line1> return Mono.fromRunnable( <line2> logger.warn(""""component {} defines a CloudPublisher or CloudSubscriber but does not specify the {}""""+ """" property, ignoring it"""",component.name,ccsfFactoryPidPropName); <line3> () -> { <line4> LOGGER.warn(""""Hibernate session {} is closed."""", Integer.toHexString(session.hashCode())); <line5> MailboxSession ownerSession = mailboxManager.createSystemSession(path.getUser()); <line6> Optional<MailboxId> mailboxId = <line7> Throwing.supplier(() -> mailboxManager.createMailbox(path, ownerSession)) <line8> .sneakyThrow() <line9> .get(); <line10> logger.debug(""""Hello world 1.""""); <line11> recordSuccess(mailboxId); <line12> }) <line13> .then(Mono.just(Result.COMPLETED)) <line14> .onErrorResume( <line15> e -> { <line16> LOGGER.error(""Error creating missing parent mailbox: {}"", path.getName(), e); <line17> recordFailure(path); <line18> return Mono.just(Result.PARTIAL); <line19> }); <line20> } <line21> } <line22> "	"<line2> logger.warn(""""component {} defines a CloudPublisher or CloudSubscriber but does not specify the {}""""+ """" property, ignoring it"""",component.name,ccsfFactoryPidPropName); <line4> LOGGER.warn(""""Hibernate session {} is closed."""", Integer.toHexString(session.hashCode())); <line10> logger.debug(""""Hello world 1.""""); "	task8	
"public class A { <line0> log.debug(""""Could not write response"""", t2); <line1> public synchronized void run() { <line2> log.debug(""""Brooklyn version """" + getVersion() + """" (git SHA1 """" + getSha1FromOsgiManifest() + """")""""); <line3> try { <line4> Map<String, List<Number>> stats = getStatsByKey(); <line5> StringBuilder buf = getCSVBuf(stats); <line6> final FileWriter fw = getFileWriter(); <line7> fw.append(buf.append(""\n"").toString()); <line8> fw.flush(); <line9> } catch (Throwable e) { <line10> log.warn(e.getMessage(), e); <line11> logger.debug(""""Asserting 1 integrity checker""""); <line12> } <line13> } <line14> } <line15> "	"<line0> log.debug(""""Could not write response"""", t2); <line2> log.debug(""""Brooklyn version """" + getVersion() + """" (git SHA1 """" + getSha1FromOsgiManifest() + """")""""); <line11> logger.debug(""""Asserting 1 integrity checker""""); "	task8	
"public class A { <line0> public static InetAddress getInetAddress(final int address) { <line1> InetAddress ip = null; <line2> try { <line3> ip = InetAddress.getByAddress(NetUtils.intToByteArray4(address)); <line4> } catch (final UnknownHostException e) { <line5> logger.info(""""Enabling {}"""", service); <line6> LOG.error(""Failed to convert {}"", address, e); <line7> } <line8> return ip; <line9> } <line10> } <line11> "	"<line5> logger.info(""""Enabling {}"""", service); "	task8	
"public class A { <line0> @Override <line1> log.error(""""Ignoring jcifs.smb.client.laddr address: """" + addr, uhe); <line2> public void initialize() { <line3> logger.debug(""Initializing hub""); <line4> HDPowerViewHubConfiguration config = getConfigAs(HDPowerViewHubConfiguration.class); <line5> String host = config.host; <line6> if (host == null || host.isEmpty()) { <line7> updateStatus( <line8> ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ""Host address must be set""); <line9> return; <line10> } <line11> webTargets = new HDPowerViewWebTargets(httpClient, host); <line12> refreshInterval = config.refresh; <line13> hardRefreshInterval = config.hardRefresh; <line14> schedulePoll(); <line15> } <line16> } <line17> "	"<line1> log.error(""""Ignoring jcifs.smb.client.laddr address: """" + addr, uhe); "	task8	
