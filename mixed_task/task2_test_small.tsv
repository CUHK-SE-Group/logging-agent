without_logging_code_index	line_index	label
"public class A { <line0> @Test <line1> public void testGetFileForWriting() { <line2> try { <line3> file = locationManager.getFileForWriting(""test.properties""); <line4> assertTrue(file.getAbsolutePath().length() > 0); <line5> } catch (LocationManagerException ex) { <line6> log.debug(""External directory not set""); <line7> } <line8> try { <line9> file = locationManager.getFileForWriting(""doesnotexist.properties""); <line10> assertTrue(file.getAbsolutePath().length() > 0); <line11> } catch (LocationManagerException ex) { <line12> } <line13> } <line14> } <line15> "	 <line8>	No
"public class A { <line0> public void write(String bucketName, String objectName, String payload) { <line1> byte[] raw = payload.getBytes(StandardCharsets.UTF_8); <line2> ObjectMetadata omd = new ObjectMetadata(); <line3> omd.setContentLength(raw.length); <line4> omd.setContentEncoding(""application/json""); <line5> if (DEBUG) { <line6> try (FileOutputStream fos = new FileOutputStream(objectName)) { <line7> fos.write(raw); <line8> fos.flush(); <line9> } catch (IOException x) { <line10> logger.log(Level.SEVERE, ""Writing "" + objectName, x); <line11> } <line12> } else { <line13> InputStream inputStream = new ByteArrayInputStream(raw); <line14> PutObjectResult result = <line15> client.putObject(new PutObjectRequest(bucketName, objectName, inputStream, omd)); <line16> if (result != null) { <line17> if (logger.isLoggable(Level.FINE)) { <line18> logger.fine(""Wrote ["" + bucketName + ""]/"" + objectName + "", ETag: "" + result.getETag()); <line19> } <line20> } else { <line21> logger.warning( <line22> ""Writing failed for ["" + bucketName + ""]/"" + objectName + "", bytes: "" + raw.length); <line23> throw new RuntimeException(""Write to COS failed""); <line24> } <line25> } <line26> } <line27> } <line28> "	 <line21>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> cache.clearAllExpired(); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> private Object handleDataWriteCommand( <line1> InvocationContext rCtx, <line2> DataWriteCommand writeCommand, <line3> Object rv, <line4> boolean assumeOriginKeptEntryInL1) { <line5> Object key; <line6> Object key1 = (key = writeCommand.getKey()); <line7> if (shouldUpdateOnWriteCommand(writeCommand) <line8> && writeCommand.isSuccessful() <line9> && cdl.getCacheTopology().isWriteOwner(key1)) { <line10> if (log.isTraceEnabled()) { <line11> } <line12> CompletableFuture<?> f = <line13> l1Manager.flushCache( <line14> Collections.singleton(key), rCtx.getOrigin(), assumeOriginKeptEntryInL1); <line15> return asyncReturnValue(f, rv); <line16> } <line17> return rv; <line18> } <line19> } <line20> 	 <line19>	No
"public class A { <line0> @Override <line1> public Object doInTransaction(TransactionStatus status) { <line2> executorService.submit( <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> try { <line7> jdbcTemplate.update(""DELETE FROM auth WHERE auth LIKE 'SSO %' AND object_type=9""); <line8> jobsAdded.incrementAndGet(); <line9> } catch (RuntimeException e) { <line10> } <line11> } <line12> }); <line13> return null; <line14> } <line15> } <line16> "	 <line13>	No
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON + "";charset=UTF-8"") <line2> @Path(""{personID}/{resourceID}"") <line3> public Response<Resource> getResourceFromPersonById( <line4> @PathParam(""said"") String said, <line5> @PathParam(""personID"") String personID, <line6> @PathParam(""resourceID"") String resourceID) { <line7> Data<Resource> data; <line8> try { <line9> data = getResource(said, resourceID); <line10> } catch (InfosphereException e) { <line11> return Response.badRequest(e.getMessage(), e); <line12> } catch (Exception e) { <line13> return Response.serverError(e.getMessage(), e); <line14> } <line15> return Response.ok(data); <line16> } <line17> } <line18> "	 <line9>	No
"public class A { <line0> public String getApiKey() { <line1> return readyElement(apiKeyLabel).getAttribute(""value""); <line2> } <line3> } <line4> "	 <line2>	No
public class A { <line0> @Override <line1> public void refresh(Collection<Refreshable> alreadyRefreshed) { <line2> reload(); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> public CreateProjectPage enterProjectId(String projectId) { <line1> enterText(readyElement(idField), projectId); <line2> return new CreateProjectPage(getDriver()); <line3> } <line4> } <line5> 	 <line1>	Yes
"public class A { <line0> public static com.liferay.site.navigation.model.SiteNavigationMenu addSiteNavigationMenu( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String name, <line4> int type, <line5> boolean auto, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> SiteNavigationMenuServiceUtil.class, <line12> ""addSiteNavigationMenu"", <line13> _addSiteNavigationMenuParameterTypes0); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, groupId, name, type, auto, serviceContext); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.site.navigation.model.SiteNavigationMenu) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	 <line27>	Yes
public class A { <line0> static Analyzer getAnalyzerInstance(String className) { <line1> Class<?> analyzerClass; <line2> try { <line3> analyzerClass = Class.forName(className); <line4> } catch (ClassNotFoundException e) { <line5> return DEFAULT_ANALYZER; <line6> } <line7> if (!Analyzer.class.isAssignableFrom(analyzerClass)) { <line8> return DEFAULT_ANALYZER; <line9> } else if (JackrabbitAnalyzer.class.isAssignableFrom(analyzerClass)) { <line10> return DEFAULT_ANALYZER; <line11> } <line12> Exception cause = null; <line13> Constructor<?>[] constructors = analyzerClass.getConstructors(); <line14> for (Constructor<?> constructor : constructors) { <line15> Class<?>[] types = constructor.getParameterTypes(); <line16> if (types.length == 1 && types[0] == Version.class) { <line17> try { <line18> return (Analyzer) constructor.newInstance(Version.LUCENE_36); <line19> } catch (Exception e) { <line20> cause = e; <line21> } <line22> } <line23> } <line24> for (Constructor<?> constructor : constructors) { <line25> if (constructor.getParameterTypes().length == 0) { <line26> try { <line27> return (Analyzer) constructor.newInstance(); <line28> } catch (Exception e) { <line29> cause = e; <line30> } <line31> } <line32> } <line33> return DEFAULT_ANALYZER; <line34> } <line35> } <line36> 	 <line5>	Yes
public class A { <line0> @PostConstruct <line1> public void log() { <line2> if (logger.isDebugEnabled()) { <line3> AnnotationVisitor<Value> visitor = new AnnotationVisitor<>(Value.class); <line4> visitor.visit(this, new LoggingEvent(logger)); <line5> } <line6> } <line7> } <line8> 	 <line3>	No
public class A { <line0> public void attachClean(StgG20SclMapping instance) { <line1> try { <line2> sessionFactory.getCurrentSession().lock(instance, LockMode.NONE); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> public void stopThread() { <line1> CallMonitorThread thread = this.monitorThread; <line2> if (thread != null) { <line3> thread.interrupt(); <line4> monitorThread = null; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (stop()) { <line4> future.cancel(true); <line5> return; <line6> } <line7> alert(); <line8> } catch (Exception e) { <line9> } <line10> } <line11> } <line12> 	 <line4>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public ComprehensionTestQuestionBo getComprehensionTestQuestionById(Integer questionId) { <line3> logger.entry(""begin getComprehensionTestQuestionById()""); <line4> ComprehensionTestQuestionBo comprehensionTestQuestionBo = null; <line5> Session session = null; <line6> List<ComprehensionTestResponseBo> comprehensionTestResponsList = null; <line7> try { <line8> session = hibernateTemplate.getSessionFactory().openSession(); <line9> comprehensionTestQuestionBo = <line10> (ComprehensionTestQuestionBo) session.get(ComprehensionTestQuestionBo.class, questionId); <line11> if (null != comprehensionTestQuestionBo) { <line12> String searchQuery = <line13> ""From ComprehensionTestResponseBo CRBO where CRBO.comprehensionTestQuestionId=:id""; <line14> query = session.createQuery(searchQuery); <line15> query.setInteger(""id"", comprehensionTestQuestionBo.getId()); <line16> comprehensionTestResponsList = query.list(); <line17> comprehensionTestQuestionBo.setResponseList(comprehensionTestResponsList); <line18> } <line19> } catch (Exception e) { <line20> } finally { <line21> if ((null != session) && session.isOpen()) { <line22> session.close(); <line23> } <line24> } <line25> logger.exit(""getComprehensionTestQuestionById() - Ends""); <line26> return comprehensionTestQuestionBo; <line27> } <line28> } <line29> "	 <line20>	Yes
public class A { <line0> private static void ensureInjectorCreated(ModuleMaker moduleMaker, Configuration configuration) { <line1> if (injector == null) { <line2> for (LibLoader libLoader : ServiceLoaderUtil.load(LibLoader.class, configuration)) { <line3> libLoader.loadLibs(moduleMaker.getConfiguration()); <line4> } <line5> injector = Guice.createInjector(moduleMaker.createModule(), new ObjectMapperModule()); <line6> } <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> private void _installConfigs(ClassLoader classLoader) throws Exception { <line1> BundleContext bundleContext = _framework.getBundleContext(); <line2> Class<?> configurationFileInstallerClass = <line3> classLoader.loadClass( <line4> ""com.liferay.portal.file.install.internal.configuration."" <line5> + ""ConfigurationFileInstaller""); <line6> Constructor<?> constructor = <line7> configurationFileInstallerClass.getDeclaredConstructor( <line8> classLoader.loadClass(""org.osgi.service.cm.ConfigurationAdmin""), String.class); <line9> constructor.setAccessible(true); <line10> Method canTransformURLMethod = <line11> configurationFileInstallerClass.getDeclaredMethod(""canTransformURL"", File.class); <line12> Method transformURLMethod = <line13> configurationFileInstallerClass.getDeclaredMethod(""transformURL"", File.class); <line14> String encoding = bundleContext.getProperty(""file.install.configEncoding""); <line15> if (encoding == null) { <line16> encoding = StringPool.UTF8; <line17> } <line18> Object configurationFileInstaller = <line19> constructor.newInstance( <line20> bundleContext.getService( <line21> bundleContext.getServiceReference(""org.osgi.service.cm.ConfigurationAdmin"")), <line22> encoding); <line23> File dir = new File(PropsValues.MODULE_FRAMEWORK_CONFIGS_DIR); <line24> dir = dir.getCanonicalFile(); <line25> for (File file : _listConfigs(dir)) { <line26> if ((boolean) canTransformURLMethod.invoke(configurationFileInstaller, file)) { <line27> try { <line28> transformURLMethod.invoke(configurationFileInstaller, file); <line29> } catch (InvocationTargetException invocationTargetException) { <line30> } <line31> } <line32> } <line33> } <line34> } <line35> "	 <line30>	Yes
"public class A { <line0> @Override <line1> public boolean isUploadDataRecoverable(String objectId, long fileSize) throws IOException { <line2> return retry.execute( <line3> ctx -> { <line4> try { <line5> serviceTemplate.exchange( <line6> endpoint + ""/upload/{object-id}/recovery?fileSize={file-size}"", <line7> HttpMethod.POST, <line8> defaultEntity(), <line9> Boolean.class, <line10> objectId, <line11> fileSize); <line12> } catch (NotRetryableException e) { <line13> return false; <line14> } <line15> return true; <line16> }); <line17> } <line18> } <line19> "	 <line2>	Yes
"public class A { <line0> public void set(HelixConfigScope scope, Map<String, String> keyValueMap) { <line1> if (scope == null || scope.getType() == null || !scope.isFullKey()) { <line2> return; <line3> } <line4> String clusterName = scope.getClusterName(); <line5> if (!ZKUtil.isClusterSetup(clusterName, _zkClient)) { <line6> throw new HelixException(""fail to set config. cluster: "" + clusterName + "" is NOT setup.""); <line7> } <line8> if (scope.getType() == ConfigScopeProperty.PARTICIPANT) { <line9> if (!ZKUtil.isInstanceSetup( <line10> _zkClient, <line11> scope.getClusterName(), <line12> scope.getParticipantName(), <line13> InstanceType.PARTICIPANT)) { <line14> throw new HelixException( <line15> ""fail to set config. instance: "" <line16> + scope.getParticipantName() <line17> + "" is NOT setup in cluster: "" <line18> + clusterName); <line19> } <line20> } <line21> String mapKey = scope.getMapKey(); <line22> String zkPath = scope.getZkPath(); <line23> String id = zkPath.substring(zkPath.lastIndexOf('/') + 1); <line24> ZNRecord update = new ZNRecord(id); <line25> if (mapKey == null) { <line26> update.getSimpleFields().putAll(keyValueMap); <line27> } else { <line28> update.setMapField(mapKey, keyValueMap); <line29> } <line30> ZKUtil.createOrMerge(_zkClient, zkPath, update, true, true); <line31> } <line32> } <line33> "	 <line2>	Yes
public class A { <line0> public void close() { <line1> try { <line2> client.close(); <line3> } catch (IOException ex) { <line4> } <line5> } <line6> } <line7> 	 <line0>	No
"public class A { <line0> private void downloadEnsemblData(Path geneFolder) throws IOException, InterruptedException { <line1> List<String> downloadedUrls = new ArrayList<>(4); <line2> String ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease; <line3> if (!configuration.getSpecies().getVertebrates().contains(speciesConfiguration)) { <line4> ensemblHost = ensemblHostUrl + ""/"" + ensemblRelease + ""/"" + getPhylo(speciesConfiguration); <line5> } <line6> String bacteriaCollectionPath = """"; <line7> if (configuration.getSpecies().getBacteria().contains(speciesConfiguration)) { <line8> bacteriaCollectionPath = <line9> speciesConfiguration.getAssemblies().get(0).getEnsemblCollection() + ""/""; <line10> } <line11> String version = ensemblRelease.split(""-"")[1]; <line12> String url = <line13> ensemblHost <line14> + ""/gtf/"" <line15> + bacteriaCollectionPath <line16> + speciesShortName <line17> + ""/*"" <line18> + version <line19> + "".gtf.gz""; <line20> String fileName = geneFolder.resolve(speciesShortName + "".gtf.gz"").toString(); <line21> downloadFile(url, fileName); <line22> downloadedUrls.add(url); <line23> url = <line24> ensemblHost <line25> + ""/fasta/"" <line26> + bacteriaCollectionPath <line27> + speciesShortName <line28> + ""/pep/*.pep.all.fa.gz""; <line29> fileName = geneFolder.resolve(speciesShortName + "".pep.all.fa.gz"").toString(); <line30> downloadFile(url, fileName); <line31> downloadedUrls.add(url); <line32> url = <line33> ensemblHost <line34> + ""/fasta/"" <line35> + bacteriaCollectionPath <line36> + speciesShortName <line37> + ""/cdna/*.cdna.all.fa.gz""; <line38> fileName = geneFolder.resolve(speciesShortName + "".cdna.all.fa.gz"").toString(); <line39> downloadFile(url, fileName); <line40> downloadedUrls.add(url); <line41> saveVersionData( <line42> EtlCommons.GENE_DATA, <line43> ENSEMBL_NAME, <line44> ensemblVersion, <line45> getTimeStamp(), <line46> downloadedUrls, <line47> buildFolder.resolve(""ensemblCoreVersion.json"")); <line48> } <line49> } <line50> "	 <line9>	No
"public class A { <line0> @Override <line1> public void run() { <line2> while (!interrupted) { <line3> try { <line4> ConsumerRecords<Integer, KafkaPacket> records = <line5> consumer.poll(Duration.ofMillis(Long.MAX_VALUE)); <line6> if (records.isEmpty()) continue; <line7> boolean process = false; <line8> boolean align = false; <line9> for (LogDataListener listener : listeners) { <line10> if (process && align) break; <line11> process |= listener.needsProcessing(); <line12> align |= listener.needsAlignment(); <line13> } <line14> if (logger.isDebugEnabled()) <line15> batch.load(records, process, align); <line16> if (logger.isDebugEnabled()) <line17> try { <line18> deliverBatch(batch); <line19> } catch (Throwable e) { <line20> } <line21> if (binaryLogListener != null) <line22> binaryLogListener.onLogDataBatchProcessed(batch.getChannelPositions()); <line23> batch.clear(); <line24> } catch (WakeupException | InterruptedException e) { <line25> break; <line26> } catch (RuntimeException e) { <line27> exception = new BinaryLogException(""Unexpected exception while data-stream polling"", e); <line28> logger.error(exception.getMessage(), e); <line29> break; <line30> } catch (AlignerException | ProcessingException e) { <line31> exception = new BinaryLogException(""Failed to parse update batch"", e); <line32> break; <line33> } <line34> } <line35> IOUtils.closeQuietly(consumer); <line36> executor.shutdownNow(); <line37> } <line38> } <line39> "	 <line15>	Yes
"public class A { <line0> @RequestMapping(""/adminStudies/reOrderComprehensionTestQuestion.do"") <line1> public void reOrderComprehensionTestQuestion( <line2> HttpServletRequest request, HttpServletResponse response) { <line3> logger.entry(""begin reOrderComprehensionTestQuestion()""); <line4> String message = FdahpStudyDesignerConstants.FAILURE; <line5> JSONObject jsonobject = new JSONObject(); <line6> PrintWriter out = null; <line7> try { <line8> SessionObject sesObj = <line9> (SessionObject) <line10> request.getSession().getAttribute(FdahpStudyDesignerConstants.SESSION_OBJECT); <line11> int oldOrderNumber; <line12> int newOrderNumber; <line13> if (sesObj != null) { <line14> String studyId = <line15> (String) request.getSession().getAttribute(FdahpStudyDesignerConstants.STUDY_ID); <line16> if (StringUtils.isEmpty(studyId)) { <line17> studyId = <line18> FdahpStudyDesignerUtil.isEmpty( <line19> request.getParameter(FdahpStudyDesignerConstants.STUDY_ID)) <line20> ? """" <line21> : request.getParameter(FdahpStudyDesignerConstants.STUDY_ID); <line22> } <line23> String oldOrderNo = <line24> FdahpStudyDesignerUtil.isEmpty( <line25> request.getParameter(FdahpStudyDesignerConstants.OLD_ORDER_NUMBER)) <line26> ? """" <line27> : request.getParameter(FdahpStudyDesignerConstants.OLD_ORDER_NUMBER); <line28> String newOrderNo = <line29> FdahpStudyDesignerUtil.isEmpty( <line30> request.getParameter(FdahpStudyDesignerConstants.NEW_ORDER_NUMBER)) <line31> ? """" <line32> : request.getParameter(FdahpStudyDesignerConstants.NEW_ORDER_NUMBER); <line33> if (((studyId != null) && !studyId.isEmpty()) <line34> && !oldOrderNo.isEmpty() <line35> && !newOrderNo.isEmpty()) { <line36> oldOrderNumber = Integer.valueOf(oldOrderNo); <line37> newOrderNumber = Integer.valueOf(newOrderNo); <line38> message = <line39> studyService.reOrderComprehensionTestQuestion( <line40> Integer.valueOf(studyId), oldOrderNumber, newOrderNumber); <line41> } <line42> } <line43> jsonobject.put(FdahpStudyDesignerConstants.MESSAGE, message); <line44> response.setContentType(FdahpStudyDesignerConstants.APPLICATION_JSON); <line45> out = response.getWriter(); <line46> out.print(jsonobject); <line47> } catch (Exception e) { <line48> } <line49> logger.exit(""reOrderComprehensionTestQuestion() - Ends""); <line50> } <line51> } <line52> "	 <line48>	Yes
public class A { <line0> private boolean removeOldEntry(Conflatable object, Long tailKey) throws CacheException { <line1> final boolean isDebugEnabled = logger.isDebugEnabled(); <line2> boolean keepOldEntry = true; <line3> if (this.enableConflation && object.shouldBeConflated()) { <line4> if (isDebugEnabled) { <line5> } <line6> String rName = object.getRegionToConflate(); <line7> Object key = object.getKeyToConflate(); <line8> Long previousIndex; <line9> synchronized (this) { <line10> Map<Object, Long> latestIndexesForRegion = this.indexes.get(rName); <line11> if (latestIndexesForRegion == null) { <line12> latestIndexesForRegion = new HashMap<>(); <line13> this.indexes.put(rName, latestIndexesForRegion); <line14> } <line15> previousIndex = latestIndexesForRegion.put(key, tailKey); <line16> } <line17> if (isDebugEnabled) { <line18> } <line19> if (previousIndex != null) { <line20> if (isDebugEnabled) { <line21> } <line22> keepOldEntry = false; <line23> } else { <line24> if (isDebugEnabled) { <line25> } <line26> this.stats.incConflationIndexesMapSize(); <line27> keepOldEntry = true; <line28> } <line29> if (!keepOldEntry) { <line30> Conflatable previous = (Conflatable) this.region.remove(previousIndex); <line31> this.stats.decQueueSize(1); <line32> if (isDebugEnabled) { <line33> if (previous != null) { <line34> } <line35> } <line36> } <line37> } else { <line38> if (isDebugEnabled) { <line39> } <line40> } <line41> return keepOldEntry; <line42> } <line43> } <line44> 	 <line7>	No
public class A { <line0> @Override <line1> public void getUserLists(final long listOwnerUserId) { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(USER_LISTS, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> ResponseList<UserList> lists = twitter.getUserLists(listOwnerUserId); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotUserLists(lists); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	 <line9>	No
public class A { <line0> public void onComplete(java.lang.Boolean o) { <line1> updateCloudJobSubmissionDetails_result result = new updateCloudJobSubmissionDetails_result(); <line2> result.success = o; <line3> result.setSuccessIsSet(true); <line4> try { <line5> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line6> } catch (org.apache.thrift.transport.TTransportException e) { <line7> fb.close(); <line8> } catch (java.lang.Exception e) { <line9> onError(e); <line10> } <line11> } <line12> } <line13> 	 <line12>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Test( <line2> dataProvider = ""testName"", <line3> dataProviderClass = AccountTest.class, <line4> dependsOnMethods = {""update""}) <line5> public void delete(String testName) throws Exception { <line6> em.getTransaction().begin(); <line7> AccountsCommon account = findAccount(""john""); <line8> em.remove(account); <line9> if (logger.isDebugEnabled()) { <line10> } <line11> em.getTransaction().commit(); <line12> if (logger.isDebugEnabled()) { <line13> } <line14> } <line15> } <line16> "	 <line13>	Yes
"public class A { <line0> @Test <line1> public void testSubmitForSettlementWithId() throws Exception { <line2> assertNotNull(this.gateway, ""BraintreeGateway can't be null""); <line3> final Result<Transaction> createResult = <line4> requestBody( <line5> ""direct://SALE"", <line6> new TransactionRequest() <line7> .amount(new BigDecimal(""100.03"")) <line8> .paymentMethodNonce(""fake-valid-nonce"") <line9> .options() <line10> .submitForSettlement(false) <line11> .done(), <line12> Result.class); <line13> assertNotNull(createResult, ""sale result""); <line14> assertTrue(createResult.isSuccess()); <line15> this.transactionIds.add(createResult.getTarget().getId()); <line16> final Result<Transaction> result = <line17> requestBody( <line18> ""direct://SUBMITFORSETTLEMENT_WITH_ID"", createResult.getTarget().getId(), Result.class); <line19> assertNotNull(result, ""Submit For Settlement result""); <line20> } <line21> } <line22> "	 <line20>	Yes
public class A { <line0> @Override <line1> public Date getDateValue( <line2> TimeUnitValueFunctionality func, Date currentDate, BusinessErrorCode errorCode) { <line3> if (!func.getActivationPolicy().getStatus()) { <line4> return null; <line5> } <line6> Calendar calendar = getCalendarWithoutTime(timeService.dateNow()); <line7> calendar.add(func.toCalendarValue(), func.getValue()); <line8> Date defaultDate = calendar.getTime(); <line9> if (func.getDelegationPolicy() == null <line10> || !func.getDelegationPolicy().getStatus() <line11> || currentDate == null) { <line12> debuggerTime(func, currentDate, defaultDate); <line13> return defaultDate; <line14> } <line15> Date now = getCalendarWithoutTime(timeService.dateNow()).getTime(); <line16> if (func.getMaxValue() == -1 && (currentDate.after(now) || currentDate.equals(now))) { <line17> return currentDate; <line18> } <line19> Calendar c = new GregorianCalendar(); <line20> c.setTime(now); <line21> c.add(func.toCalendarMaxValue(), func.getMaxValue()); <line22> Date maxDate = getCalendarWithoutTime(c.getTime()).getTime(); <line23> if (currentDate.before(now) || currentDate.after(maxDate)) { <line24> String errorMessage = <line25> buildErrorMessage( <line26> func, <line27> dateFormat.format(currentDate), <line28> dateFormat.format(now), <line29> dateFormat.format(maxDate)); <line30> throw new BusinessException(errorCode, errorMessage); <line31> } <line32> return currentDate; <line33> } <line34> } <line35> 	 <line30>	Yes
"public class A { <line0> @Override <line1> public List<SessionMatchSpec> get() { <line2> checkState(!destroyed.get(), ""provider already destroyed""); <line3> try { <line4> sessionMatchSpecs.set(dao.getSessionMatchSpecs()); <line5> } catch (RuntimeException e) { <line6> } <line7> return ImmutableList.copyOf(this.sessionMatchSpecs.get()); <line8> } <line9> } <line10> "	 <line5>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> doClean(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line3>	No
public class A { <line0> @Override <line1> public void onAbort(AsyncUploadResult result) { <line2> DataIdentifier identifier = result.getIdentifier(); <line3> File file = result.getFile(); <line4> String fileName = getFileName(identifier); <line5> try { <line6> uploadRetryMap.remove(identifier); <line7> asyncWriteCache.remove(fileName); <line8> } catch (IOException ie) { <line9> } <line10> } <line11> } <line12> 	 <line9>	Yes
"public class A { <line0> @Override <line1> protected boolean checkSpecificAcceptConditions(Job job, DomainConfiguration cfg) { <line2> if (job.isSnapshot() <line3> && CONFIG_COUNT_SNAPSHOT != null <line4> && CONFIG_COUNT_SNAPSHOT > 0 <line5> && job.getDomainConfigurationMap().size() >= CONFIG_COUNT_SNAPSHOT) { <line6> return false; <line7> } <line8> boolean splitByObjectLimit = Settings.getBoolean(HarvesterSettings.SPLIT_BY_OBJECTLIMIT); <line9> long forceMaxObjectsPerDomain = job.getForceMaxObjectsPerDomain(); <line10> long forceMaxBytesPerDomain = job.getForceMaxBytesPerDomain(); <line11> if (splitByObjectLimit) { <line12> if (NumberUtils.compareInf(cfg.getMaxObjects(), forceMaxObjectsPerDomain) < 0 <line13> || (job.isConfigurationSetsObjectLimit() <line14> && NumberUtils.compareInf(cfg.getMaxObjects(), forceMaxObjectsPerDomain) != 0)) { <line15> return false; <line16> } <line17> } else { <line18> if (NumberUtils.compareInf(cfg.getMaxBytes(), forceMaxBytesPerDomain) < 0 <line19> || (job.isConfigurationSetsByteLimit() <line20> && NumberUtils.compareInf(cfg.getMaxBytes(), forceMaxBytesPerDomain) != 0)) { <line21> return false; <line22> } <line23> } <line24> long maxCountObjects = job.getMaxCountObjects(); <line25> long minCountObjects = job.getMinCountObjects(); <line26> assert (maxCountObjects >= minCountObjects) : ""basic invariant""; <line27> long expectation = <line28> cfg.getExpectedNumberOfObjects(forceMaxObjectsPerDomain, forceMaxBytesPerDomain); <line29> long totalCountObjects = job.getTotalCountObjects(); <line30> if ((totalCountObjects > 0) && ((expectation + totalCountObjects) > LIM_MAX_TOTAL_SIZE)) { <line31> return false; <line32> } <line33> if ((expectation <= maxCountObjects) && (expectation >= minCountObjects)) { <line34> return true; <line35> } <line36> long absDiff; <line37> long xmaxCountObjects = maxCountObjects; <line38> long yminCountObjects = minCountObjects; <line39> if (expectation > maxCountObjects) { <line40> xmaxCountObjects = expectation; <line41> } else { <line42> assert (expectation < minCountObjects) : ""New minimum expected""; <line43> yminCountObjects = expectation; <line44> } <line45> absDiff = (xmaxCountObjects - yminCountObjects); <line46> if ((absDiff == 0) || (absDiff <= LIM_MIN_ABS_SIZE)) { <line47> return true; <line48> } <line49> if (yminCountObjects == 0) { <line50> yminCountObjects = 1; <line51> } <line52> float relDiff = (float) xmaxCountObjects / (float) yminCountObjects; <line53> if (relDiff > LIM_MAX_REL_SIZE) { <line54> return false; <line55> } <line56> return true; <line57> } <line58> } <line59> "	 <line4>	No
public class A { <line0> @Override <line1> public boolean validate(JSONObject message) { <line2> Object timestampObject = message.get(Constants.Fields.TIMESTAMP.getName()); <line3> if (timestampObject instanceof Long) { <line4> Long timestamp = (Long) timestampObject; <line5> if (timestamp > 0) { <line6> return true; <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> 	 <line8>	No
public class A { <line0> public void writeDecimalType(String path, DecimalType value) throws OwException { <line1> OwserverPacket requestPacket = new OwserverPacket(OwserverMessageType.WRITE, path); <line2> requestPacket.appendPayload(String.valueOf(value)); <line3> OwserverPacket returnPacket = request(requestPacket); <line4> } <line5> } <line6> 	 <line4>	Yes
public class A { <line0> public String getSuperQueryAlias(boolean includeQuotes) { <line1> if (_alias != null) { <line2> return _alias; <line3> } else if (_column != null) { <line4> final StringBuilder sb = new StringBuilder(); <line5> if (includeQuotes) { <line6> sb.append(_column.getQuotedName()); <line7> } else { <line8> sb.append(_column.getName()); <line9> } <line10> appendFunctionSql(sb); <line11> return sb.toString(); <line12> } else { <line13> return toStringNoAlias().toString(); <line14> } <line15> } <line16> } <line17> 	 <line14>	No
"public class A { <line0> @RestAccessControl(permission = Permission.MANAGE_PAGES) <line1> @RequestMapping( <line2> value = ""/pages/search"", <line3> method = RequestMethod.GET, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<PagedRestResponse<PageDto>> getPages( <line6> @ModelAttribute(""user"") UserDetails user, PageSearchRequest searchRequest) { <line7> this.getPageValidator().validateRestListRequest(searchRequest, PageDto.class); <line8> List<String> groups = this.getAuthorizationService().getAllowedGroupCodes(user); <line9> PagedMetadata<PageDto> result = this.getPageService().searchPages(searchRequest, groups); <line10> return new ResponseEntity<>(new PagedRestResponse<>(result), HttpStatus.OK); <line11> } <line12> } <line13> "	 <line7>	Yes
"public class A { <line0> @Override <line1> public void loadModule(final RsfApiBinder apiBinder) throws Throwable { <line2> Environment env = apiBinder.getEnvironment(); <line3> WorkMode workMode = <line4> env.getSettings().getEnum(""hasor.land.workAt"", WorkMode.class, WorkMode.None); <line5> if (WorkMode.None == workMode) { <line6> return; <line7> } <line8> apiBinder.bindType(LandContext.class).asEagerSingleton(); <line9> apiBinder.bindType(Server.class).to(ServerNode.class).asEagerSingleton(); <line10> apiBinder.bindType(ElectionService.class).to(ElectionServiceManager.class).asEagerSingleton(); <line11> apiBinder <line12> .rsfService(apiBinder.getBindInfo(ElectionService.class)) <line13> .asAloneThreadPool() <line14> .asShadow() <line15> .register(); <line16> Hasor.addStartListener( <line17> apiBinder.getEnvironment(), <line18> (EventListener<AppContext>) <line19> (event, eventData) -> { <line20> eventData.getInstance(ElectionService.class); <line21> }); <line22> } <line23> } <line24> "	 <line19>	No
public class A { <line0> public UpdateResponse version(UpdateResponse updateResponse) { <line1> if (doSkip(updateResponse)) { <line2> return updateResponse; <line3> } <line4> setSkipFlag(updateResponse); <line5> if (LOGGER.isTraceEnabled()) { <line6> } <line7> List<Metacard> inputMetacards = <line8> updateResponse.getUpdatedMetacards().stream() <line9> .map(Update::getOldMetacard) <line10> .filter(isNotVersionNorDeleted) <line11> .collect(Collectors.toList()); <line12> if (inputMetacards.isEmpty()) { <line13> return updateResponse; <line14> } <line15> final Map<String, Metacard> versionedMetacards = <line16> getVersionMetacards( <line17> inputMetacards, <line18> id -> Action.VERSIONED, <line19> (Subject) <line20> updateResponse <line21> .getRequest() <line22> .getProperties() <line23> .get(SecurityConstants.SECURITY_SUBJECT)); <line24> CreateResponse response = storeVersionMetacards(versionedMetacards); <line25> if (LOGGER.isTraceEnabled()) { <line26> } <line27> return updateResponse; <line28> } <line29> } <line30> 	 <line26>	Yes
public class A { <line0> @Override <line1> protected void finalize() throws Throwable { <line2> if (disk == this) { <line3> try { <line4> store.close(); <line5> } catch (SailException e) { <line6> } finally { <line7> FileUtil.deltree(dataDir); <line8> dataDir = null; <line9> store = null; <line10> disk = null; <line11> } <line12> } <line13> super.finalize(); <line14> } <line15> } <line16> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public boolean configure(String name, Map<String, Object> params) throws ConfigurationException { <line2> super.configure(name, params); <line3> String timeZoneStr = _configDao.getValue(Config.UsageAggregationTimezone.toString()); <line4> String aggregationRange = _configDao.getValue(Config.UsageStatsJobAggregationRange.toString()); <line5> if (timeZoneStr == null) { <line6> timeZoneStr = ""GMT""; <line7> } <line8> _usageTimezone = TimeZone.getTimeZone(timeZoneStr); <line9> _aggregationDuration = Integer.parseInt(aggregationRange); <line10> if (_aggregationDuration < UsageUtils.USAGE_AGGREGATION_RANGE_MIN) { <line11> _aggregationDuration = UsageUtils.USAGE_AGGREGATION_RANGE_MIN; <line12> } <line13> if (s_logger.isDebugEnabled()) { <line14> } <line15> return true; <line16> } <line17> } <line18> "	 <line0>	No
public class A { <line0> private void fixVfGroup( <line1> Resource resource, Map<String, ArtifactDefinition> artifactsMap, GroupDefinition group) { <line2> Set<String> groupArtifactsSet = new HashSet<>(group.getArtifacts()); <line3> List<String> groupArtifacts = new ArrayList<>(groupArtifactsSet); <line4> group.getArtifacts().clear(); <line5> group.getArtifactsUuid().clear(); <line6> for (String artifactId : groupArtifacts) { <line7> fixArtifactUnderGroup(artifactsMap, group, groupArtifacts, artifactId); <line8> } <line9> } <line10> } <line11> 	 <line2>	Yes
public class A { <line0> public static void recursiveDelete(File f, File root) throws IOException { <line1> if (f.exists()) { <line2> FileUtils.forceDelete(f); <line3> } <line4> while (true) { <line5> f = f.getParentFile(); <line6> if ((f == null) || f.equals(root) || (f.list() == null) || (f.list().length > 0)) { <line7> break; <line8> } <line9> } <line10> } <line11> } <line12> 	 <line4>	No
public class A { <line0> @Override <line1> protected void execute() throws Exception { <line2> loadInternal(uri); <line3> if (!exceptionMessages.isEmpty()) { <line4> for (String message : exceptionMessages) { <line5> } <line6> } else { <line7> } <line8> } <line9> } <line10> 	 <line3>	No
"public class A { <line0> public static void main(String args[]) { <line1> try { <line2> LateralUDPReceiver lur = new LateralUDPReceiver(""228.5.6.7"", 6789); <line3> Thread t = new Thread(lur); <line4> t.start(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> "	 <line6>	Yes
public class A { <line0> @Override <line1> public String convert(Object tuple) { <line2> if (tuple == null) { <line3> return null; <line4> } <line5> try { <line6> return objMapper.writeValueAsString(tuple); <line7> } catch (JsonProcessingException e) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	 <line0>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> task.run(); <line4> } catch (Throwable t) { <line5> Throwables.throwIfUnchecked(t); <line6> throw new AssertionError(t); <line7> } <line8> } <line9> } <line10> 	 <line5>	Yes
"public class A { <line0> @Test <line1> public void testNonGeolocationEntities() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> List<Map<String, Object>> locations = new ArrayList<Map<String, Object>>(); <line5> locations.add( <line6> new LinkedHashMap<String, Object>() { <line7> { <line8> put(""name"", ""norwest""); <line9> put(""location"", ""texas""); <line10> } <line11> }); <line12> locations.add( <line13> new LinkedHashMap<String, Object>() { <line14> { <line15> put(""type"", ""store""); <line16> put(""name"", ""ashfield""); <line17> put(""location"", ""new jersey""); <line18> } <line19> }); <line20> for (Map<String, Object> location : locations) { <line21> Entity entity = em.create(""store"", location); <line22> assertNotNull(entity); <line23> } <line24> app.waitForQueueDrainAndRefreshIndex(); <line25> Query query = new Query(); <line26> Results listResults = em.searchCollection(em.getApplicationRef(), ""stores"", query); <line27> assertEquals(""total number of 'stores'"", locations.size(), listResults.size()); <line28> for (Entity entity : listResults.entities) { <line29> Object location = entity.getProperty(""location""); <line30> assertNotNull(location); <line31> assertTrue(location instanceof String); <line32> } <line33> query = Query.fromQL(""select * where location='texas'""); <line34> listResults = em.searchCollection(em.getApplicationRef(), ""stores"", query); <line35> assertEquals(""total number of 'stores'"", 1, listResults.size()); <line36> for (Entity entity : listResults.entities) { <line37> Object location = entity.getProperty(""location""); <line38> assertNotNull(location); <line39> assertTrue(location instanceof String); <line40> } <line41> } <line42> } <line43> "	 <line35>	No
"public class A { <line0> @Override <line1> public AtlasVertex preCreate(AtlasStructDef structDef) throws AtlasBaseException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> validateType(structDef); <line5> AtlasType type = typeRegistry.getType(structDef.getName()); <line6> if (type.getTypeCategory() != org.apache.atlas.model.TypeCategory.STRUCT) { <line7> throw new AtlasBaseException( <line8> AtlasErrorCode.TYPE_MATCH_FAILED, structDef.getName(), TypeCategory.STRUCT.name()); <line9> } <line10> AtlasAuthorizationUtils.verifyAccess( <line11> new AtlasTypeAccessRequest(AtlasPrivilege.TYPE_CREATE, structDef), <line12> ""create struct-def "", <line13> structDef.getName()); <line14> AtlasVertex ret = typeDefStore.findTypeVertexByName(structDef.getName()); <line15> if (ret != null) { <line16> throw new AtlasBaseException(AtlasErrorCode.TYPE_ALREADY_EXISTS, structDef.getName()); <line17> } <line18> ret = typeDefStore.createTypeVertex(structDef); <line19> AtlasStructDefStoreV2.updateVertexPreCreate( <line20> structDef, (AtlasStructType) type, ret, typeDefStore); <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> return ret; <line24> } <line25> } <line26> "	 <line11>	No
"public class A { <line0> public boolean saveExchange(ExchangeType exchangeUpdate, String originalExchangeName) <line1> throws ExchangeManagerException { <line2> boolean bSave = false; <line3> getRefreshExceptionFor(""save""); <line4> if (null == exchangeUpdate) { <line5> return bSave; <line6> } <line7> try { <line8> if (null == exInfo) { <line9> loadExchangeInfo(); <line10> } <line11> List<ExchangeType> exchanges = ExchangeManagerHelper.getAllExchanges(exInfo, true); <line12> String nameLookup = <line13> originalExchangeName != null ? originalExchangeName : exchangeUpdate.getName(); <line14> ExchangeType exchangeFound = ExchangeManagerHelper.findExchangeTypeBy(exchanges, nameLookup); <line15> if (null != exchangeFound) { <line16> exchangeFound.setName(exchangeUpdate.getName()); <line17> exchangeFound.setDisabled(exchangeUpdate.isDisabled()); <line18> exchangeFound.setKey(exchangeUpdate.getKey()); <line19> exchangeFound.setTLSVersions(exchangeUpdate.getTLSVersions()); <line20> exchangeFound.setType(exchangeUpdate.getType()); <line21> exchangeFound.setUrl(exchangeUpdate.getUrl()); <line22> exchangeFound.setSniName(exchangeUpdate.getSniName()); <line23> exchangeFound.setCertificateAlias(exchangeUpdate.getCertificateAlias()); <line24> } else { <line25> exchanges.add(exchangeUpdate); <line26> } <line27> saveExchangeInfo(); <line28> bSave = true; <line29> } catch (ExchangeManagerException e) { <line30> } <line31> return bSave; <line32> } <line33> } <line34> "	 <line5>	No
public class A { <line0> @Override <line1> public synchronized void dispose() { <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> this.terminationRequest = true; <line5> this.notify(); <line6> } <line7> } <line8> 	 <line3>	Yes
"public class A { <line0> @RequestMapping(value = ""/{app}/**"", method = RequestMethod.GET) <line1> public void renderApp( <line2> @PathVariable(""app"") String app, HttpServletRequest request, HttpServletResponse response) <line3> throws IOException, WebMessageException { <line4> App application = appManager.getApp(app); <line5> String pageName = getUrl(request.getPathInfo(), app); <line6> if (application == null) { <line7> throw new WebMessageException(WebMessageUtils.notFound(""App '"" + app + ""' not found."")); <line8> } <line9> if (application.isBundled()) { <line10> String redirectPath = application.getBaseUrl() + ""/"" + pageName; <line11> response.sendRedirect(redirectPath); <line12> return; <line13> } <line14> if (!appManager.isAccessible(application)) { <line15> throw new ReadAccessDeniedException(""You don't have access to application "" + app + "".""); <line16> } <line17> if (application.getAppState() == AppStatus.DELETION_IN_PROGRESS) { <line18> throw new WebMessageException( <line19> WebMessageUtils.conflict(""App '"" + app + ""' deletion is still in progress."")); <line20> } <line21> if (""manifest.webapp"".equals(pageName)) { <line22> if (application.getActivities() != null <line23> && application.getActivities().getDhis() != null <line24> && ""*"".equals(application.getActivities().getDhis().getHref())) { <line25> String contextPath = ContextUtils.getContextPath(request); <line26> application.getActivities().getDhis().setHref(contextPath); <line27> } <line28> jsonMapper.writeValue(response.getOutputStream(), application); <line29> } else { <line30> Resource resource = appManager.getAppResource(application, pageName); <line31> if (resource == null) { <line32> response.sendError(HttpServletResponse.SC_NOT_FOUND); <line33> return; <line34> } <line35> String filename = resource.getFilename(); <line36> if (new ServletWebRequest(request, response).checkNotModified(resource.lastModified())) { <line37> response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); <line38> return; <line39> } <line40> String mimeType = request.getSession().getServletContext().getMimeType(filename); <line41> if (mimeType != null) { <line42> response.setContentType(mimeType); <line43> } <line44> response.setContentLength((int) resource.contentLength()); <line45> response.setHeader( <line46> ""Last-Modified"", DateUtils.getHttpDateString(new Date(resource.lastModified()))); <line47> StreamUtils.copyThenCloseInputStream(resource.getInputStream(), response.getOutputStream()); <line48> } <line49> } <line50> } <line51> "	 <line21>	Yes
"public class A { <line0> @Override <line1> public void insert( <line2> String host, <line3> String bindApplicationName, <line4> short bindServiceType, <line5> String parentApplicationName, <line6> short parentServiceType) { <line7> Objects.requireNonNull(host, ""host""); <line8> Objects.requireNonNull(bindApplicationName, ""bindApplicationName""); <line9> if (logger.isDebugEnabled()) { <line10> } <line11> final long statisticsRowSlot = getSlotTime(); <line12> final CacheKey cacheKey = <line13> new CacheKey( <line14> host, bindApplicationName, bindServiceType, parentApplicationName, parentServiceType); <line15> final boolean needUpdate = updater.update(cacheKey, statisticsRowSlot); <line16> if (needUpdate) { <line17> insertHostVer2( <line18> host, <line19> bindApplicationName, <line20> bindServiceType, <line21> statisticsRowSlot, <line22> parentApplicationName, <line23> parentServiceType); <line24> } <line25> } <line26> } <line27> "	 <line20>	No
public class A { <line0> @Override <line1> public Command modify(String uuid, Command data) { <line2> try { <line3> delete(uuid); <line4> data.setUUID(uuid); <line5> add(data); <line6> return data; <line7> } catch (Exception e) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
"public class A { <line0> public static void updateRefNamesInRelations( <line1> ServiceContext<PoxPayloadIn, PoxPayloadOut> ctx, <line2> RepositoryClient<PoxPayloadIn, PoxPayloadOut> repoClient, <line3> CoreSessionInterface repoSession, <line4> String targetField, <line5> String oldRefName, <line6> String newRefName) <line7> throws Exception { <line8> int docsUpdated = 0; <line9> int currentPage = 0; <line10> int docsInCurrentPage = 0; <line11> final String ORDER_BY_VALUE = <line12> CollectionSpaceClient.CORE_CREATED_AT + "", "" + IQueryManager.NUXEO_UUID; <line13> try { <line14> boolean morePages = true; <line15> while (morePages) { <line16> DocumentModelList docModelList = <line17> findRelationsWithRefName( <line18> ctx, <line19> repoClient, <line20> repoSession, <line21> oldRefName, <line22> targetField, <line23> ORDER_BY_VALUE, <line24> currentPage, <line25> DEFAULT_PAGE_SIZE, <line26> true); <line27> if (docModelList == null) { <line28> break; <line29> } <line30> docsInCurrentPage = docModelList.size(); <line31> if (docsInCurrentPage == 0) { <line32> break; <line33> } <line34> if (docsInCurrentPage < DEFAULT_PAGE_SIZE) { <line35> morePages = false; <line36> } <line37> for (DocumentModel docModel : docModelList) { <line38> try { <line39> docModel.setProperty( <line40> IRelationsManager.SERVICE_COMMONPART_NAME, targetField, newRefName); <line41> repoSession.saveDocument(docModel); <line42> } catch (ClientException e) { <line43> } <line44> } <line45> docsUpdated += docsInCurrentPage; <line46> if (morePages) { <line47> currentPage++; <line48> } <line49> } <line50> } catch (Exception e) { <line51> throw e; <line52> } <line53> try { <line54> repoSession.save(); <line55> } catch (ClientException e) { <line56> } <line57> } <line58> } <line59> "	 <line54>	No
public class A { <line0> private boolean acquire() { <line1> if (log.isDebugEnabled()) { <line2> } <line3> Duration retryPeriod = config.getRetryPeriod(); <line4> long retryPeriodMillis = retryPeriod.toMillis(); <line5> AtomicBoolean acquired = new AtomicBoolean(false); <line6> ScheduledFuture scheduledFuture = <line7> scheduledWorkers.scheduleWithFixedDelay( <line8> () -> { <line9> Future<Boolean> future = leaseWorkers.submit(this::tryAcquireOrRenew); <line10> try { <line11> Boolean success = future.get(retryPeriodMillis, TimeUnit.MILLISECONDS); <line12> if (log.isDebugEnabled()) { <line13> } <line14> acquired.set(success); <line15> } catch (CancellationException e) { <line16> } catch (Throwable t) { <line17> this.exceptionHandler.accept(t); <line18> future.cancel(true); <line19> } finally { <line20> maybeReportTransition(); <line21> } <line22> }, <line23> 0, <line24> Double.valueOf(retryPeriodMillis * (JITTER_FACTOR * Math.random() + 1)).longValue(), <line25> TimeUnit.MILLISECONDS); <line26> try { <line27> while (!acquired.get()) { <line28> Thread.sleep(retryPeriodMillis); <line29> } <line30> } catch (InterruptedException e) { <line31> return false; <line32> } finally { <line33> scheduledFuture.cancel(true); <line34> } <line35> return true; <line36> } <line37> } <line38> 	 <line2>	Yes
"public class A { <line0> @Dependent <line1> @Named(""windowId"") <line2> @Produces <line3> @WindowId <line4> public String getWindowID() { <line5> PortletRequest portletRequest = getPortletRequest(); <line6> if (portletRequest == null) { <line7> return null; <line8> } <line9> return portletRequest.getWindowID(); <line10> } <line11> } <line12> "	 <line5>	No
"public class A { <line0> @Override <line1> public void run() { <line2> Exception cause = <line3> new JmsOperationTimedOutException(""Remote did not respond to a drain request in time""); <line4> locallyClosed(session.getConnection(), cause); <line5> stopRequest.onFailure(cause); <line6> session.pumpToProtonTransport(stopRequest); <line7> } <line8> } <line9> "	 <line2>	Yes
public class A { <line0> @Override <line1> public KaleoTaskFormInstance fetchByKaleoTaskFormId( <line2> long kaleoTaskFormId, boolean useFinderCache) { <line3> Object[] finderArgs = null; <line4> if (useFinderCache) { <line5> finderArgs = new Object[] {kaleoTaskFormId}; <line6> } <line7> Object result = null; <line8> if (useFinderCache) { <line9> result = finderCache.getResult(_finderPathFetchByKaleoTaskFormId, finderArgs); <line10> } <line11> if (result instanceof KaleoTaskFormInstance) { <line12> KaleoTaskFormInstance kaleoTaskFormInstance = (KaleoTaskFormInstance) result; <line13> if (kaleoTaskFormId != kaleoTaskFormInstance.getKaleoTaskFormId()) { <line14> result = null; <line15> } <line16> } <line17> if (result == null) { <line18> StringBundler sb = new StringBundler(3); <line19> sb.append(_SQL_SELECT_KALEOTASKFORMINSTANCE_WHERE); <line20> sb.append(_FINDER_COLUMN_KALEOTASKFORMID_KALEOTASKFORMID_2); <line21> String sql = sb.toString(); <line22> Session session = null; <line23> try { <line24> session = openSession(); <line25> Query query = session.createQuery(sql); <line26> QueryPos queryPos = QueryPos.getInstance(query); <line27> queryPos.add(kaleoTaskFormId); <line28> List<KaleoTaskFormInstance> list = query.list(); <line29> if (list.isEmpty()) { <line30> if (useFinderCache) { <line31> finderCache.putResult(_finderPathFetchByKaleoTaskFormId, finderArgs, list); <line32> } <line33> } else { <line34> if (list.size() > 1) { <line35> Collections.sort(list, Collections.reverseOrder()); <line36> if (_log.isWarnEnabled()) { <line37> if (!useFinderCache) { <line38> finderArgs = new Object[] {kaleoTaskFormId}; <line39> } <line40> } <line41> } <line42> KaleoTaskFormInstance kaleoTaskFormInstance = list.get(0); <line43> result = kaleoTaskFormInstance; <line44> cacheResult(kaleoTaskFormInstance); <line45> } <line46> } catch (Exception exception) { <line47> throw processException(exception); <line48> } finally { <line49> closeSession(session); <line50> } <line51> } <line52> if (result instanceof List<?>) { <line53> return null; <line54> } else { <line55> return (KaleoTaskFormInstance) result; <line56> } <line57> } <line58> } <line59> 	 <line36>	No
public class A { <line0> @Override <line1> public MultiplicativeSetCoPrime<C> add(GenPolynomial<C> cc) { <line2> if (cc == null || cc.isZERO() || cc.isConstant()) { <line3> return this; <line4> } <line5> if (ring.coFac.isField()) { <line6> cc = cc.monic(); <line7> } <line8> List<GenPolynomial<C>> list; <line9> if (mset.size() == 0) { <line10> list = engine.coPrime(cc, mset); <line11> if (ring.coFac.isField()) { <line12> list = PolyUtil.<C>monic(list); <line13> } <line14> return new MultiplicativeSetCoPrime<C>(ring, list, engine); <line15> } <line16> GenPolynomial<C> c = removeFactors(cc); <line17> if (c.isConstant()) { <line18> return this; <line19> } <line20> list = engine.coPrime(c, mset); <line21> if (ring.coFac.isField()) { <line22> list = PolyUtil.<C>monic(list); <line23> } <line24> return new MultiplicativeSetCoPrime<C>(ring, list, engine); <line25> } <line26> } <line27> 	 <line23>	No
public class A { <line0> @Override <line1> public boolean nukeExistingCluster() throws Exception { <line2> String zkServers = ZKMetadataDriverBase.resolveZkServers(conf); <line3> boolean ledgerRootExists = null != zk.exists(ledgersRootPath, false); <line4> if (!ledgerRootExists) { <line5> return true; <line6> } <line7> boolean availableNodeExists = null != zk.exists(bookieRegistrationPath, false); <line8> try (RegistrationClient regClient = <line9> new ZKRegistrationClient(zk, ledgersRootPath, null, false)) { <line10> if (availableNodeExists) { <line11> Collection<BookieId> rwBookies = <line12> FutureUtils.result(regClient.getWritableBookies(), EXCEPTION_FUNC).getValue(); <line13> if (rwBookies != null && !rwBookies.isEmpty()) { <line14> return false; <line15> } <line16> boolean readonlyNodeExists = null != zk.exists(bookieReadonlyRegistrationPath, false); <line17> if (readonlyNodeExists) { <line18> Collection<BookieId> roBookies = <line19> FutureUtils.result(regClient.getReadOnlyBookies(), EXCEPTION_FUNC).getValue(); <line20> if (roBookies != null && !roBookies.isEmpty()) { <line21> return false; <line22> } <line23> } <line24> } <line25> } <line26> LedgerManagerFactory ledgerManagerFactory = <line27> AbstractZkLedgerManagerFactory.newLedgerManagerFactory(conf, layoutManager); <line28> return ledgerManagerFactory.validateAndNukeExistingCluster(conf, layoutManager); <line29> } <line30> } <line31> 	 <line27>	No
public class A { <line0> private boolean matchesPath(RequestUrlParts url) { <line1> if (pattern.equals(MATCH_ALL)) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> return true; <line5> } <line6> return matcher.matches(url.getPath()); <line7> } <line8> } <line9> 	 <line3>	Yes
"public class A { <line0> @Override <line1> protected String saveContent(boolean approve) { <line2> try { <line3> Content currentContent = this.getContent(); <line4> if (null != currentContent) { <line5> if (!this.getContentActionHelper().isUserAllowed(currentContent, this.getCurrentUser())) { <line6> return USER_NOT_ALLOWED; <line7> } <line8> currentContent.setLastEditor(this.getCurrentUser().getUsername()); <line9> if (approve) { <line10> if (!Content.STATUS_READY.equals(currentContent.getStatus()) <line11> && !Content.STATUS_PUBLIC.equals(currentContent.getStatus())) { <line12> String[] args = {currentContent.getId(), currentContent.getDescription()}; <line13> this.addFieldError( <line14> ""status"", this.getText(""error.content.publish.notReadyStatus"", args)); <line15> return INPUT; <line16> } <line17> this.getContentManager().insertOnLineContent(currentContent); <line18> } else { <line19> this.getContentManager().saveContent(currentContent); <line20> } <line21> String sessionParamName = <line22> ContentActionConstants.SESSION_PARAM_NAME_CURRENT_CONTENT_PREXIX <line23> + this.getContentOnSessionMarker(); <line24> this.getRequest().getSession().removeAttribute(sessionParamName); <line25> } else { <line26> } <line27> } catch (Exception e) { <line28> return FAILURE; <line29> } <line30> return SUCCESS; <line31> } <line32> } <line33> "	 <line28>	Yes
"public class A { <line0> public static void restoreMessageAttachmentFromTrash( <line1> HttpPrincipal httpPrincipal, long messageId, String fileName) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> MBMessageServiceUtil.class, <line7> ""restoreMessageAttachmentFromTrash"", <line8> _restoreMessageAttachmentFromTrashParameterTypes32); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, messageId, fileName); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	 <line19>	Yes
public class A { <line0> @Override <line1> public void channelUnlinked(ChannelUID channelUID) { <line2> switch (channelUID.getId()) { <line3> case CHANNEL_CONTROLLER_STATE: <line4> case CHANNEL_CONTROLLER_UPTIME: <line5> case CHANNEL_CONTROLLER_TIME: <line6> break; <line7> default: <line8> Channel channel = thing.getChannel(channelUID.getId()); <line9> if (channel != null) { <line10> try { <line11> ChannelParams params = new ChannelParams(channel); <line12> if (params.getResourceId() != null) { <line13> linkedResourceIds.removeIf(c -> c.equals(params.getResourceId())); <line14> updateNotificationsRequestReminder(); <line15> } <line16> } catch (ConversionException e) { <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	 <line17>	Yes
"public class A { <line0> private void updateEntityInConfigStore(Entity oldEntity, Entity newEntity) { <line1> List<Entity> tokenList = new ArrayList<>(); <line2> try { <line3> configStore.initiateUpdate(newEntity); <line4> obtainEntityLocks(oldEntity, ""update"", tokenList); <line5> configStore.update(newEntity.getEntityType(), newEntity); <line6> } catch (Throwable e) { <line7> throw FalconWebException.newAPIException(e); <line8> } finally { <line9> ConfigurationStore.get().cleanupUpdateInit(); <line10> releaseEntityLocks(oldEntity.getName(), tokenList); <line11> } <line12> } <line13> } <line14> "	 <line7>	Yes
public class A { <line0> @Override <line1> public boolean hasNext() { <line2> if (!complete && results == null) { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> advance(); <line6> } <line7> return results != null; <line8> } <line9> } <line10> 	 <line7>	No
"public class A { <line0> @Override <line1> protected Object executeJob(int gridSize, String type) throws GridException { <line2> if (type == null) throw new IllegalArgumentException(""Node type to start should be specified.""); <line3> GridConfiguration cfg = getConfig(type); <line4> String gridName = cfg.getGridName() + "" ("" + UUID.randomUUID() + "")""; <line5> cfg.setGridName(gridName); <line6> Grid g = G.start(cfg); <line7> return true; <line8> } <line9> } <line10> "	 <line9>	No
public class A { <line0> private boolean processFolder() throws IOException { <line1> if (folderId == null && !subFolders.isEmpty()) { <line2> folderId = subFolders.get(0); <line3> subFolders.remove(0); <line4> request.setQ(format(query, folderId)); <line5> } <line6> searchResults.clear(); <line7> FileList files = request.execute(); <line8> for (File file : files.getFiles()) { <line9> if (canAddSubFolder(file.getMimeType())) { <line10> subFolders.add(file.getId()); <line11> } <line12> if (canAddFile(file.getMimeType())) { <line13> searchResults.add(file); <line14> result.totalCount++; <line15> } <line16> } <line17> request.setPageToken(files.getNextPageToken()); <line18> searchCount = searchResults.size(); <line19> if (StringUtils.isEmpty(request.getPageToken()) || searchCount == 0) { <line20> folderId = null; <line21> } <line22> return searchCount > 0; <line23> } <line24> } <line25> 	 <line5>	Yes
public class A { <line0> public void delete(StgMsUnjTxt persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
"public class A { <line0> private Bundle _addBundle(String location, InputStream inputStream, boolean checkPermission) <line1> throws PortalException { <line2> if (_framework == null) { <line3> throw new IllegalStateException(""OSGi framework is not initialized""); <line4> } <line5> if (checkPermission) { <line6> _checkPermission(); <line7> } <line8> BundleContext bundleContext = _framework.getBundleContext(); <line9> if (inputStream != null) { <line10> UnsyncBufferedInputStream unsyncBufferedInputStream = <line11> new UnsyncBufferedInputStream(inputStream); <line12> unsyncBufferedInputStream.mark(1024 * 1000); <line13> Bundle bundle = null; <line14> if (location.contains(""static=true"")) { <line15> bundle = _getStaticBundle(bundleContext, unsyncBufferedInputStream, location); <line16> } else { <line17> bundle = getBundle(bundleContext, unsyncBufferedInputStream); <line18> } <line19> try { <line20> unsyncBufferedInputStream.reset(); <line21> } catch (IOException ioException) { <line22> throw new PortalException(ioException); <line23> } <line24> if (bundle != null) { <line25> return bundle; <line26> } <line27> inputStream = unsyncBufferedInputStream; <line28> } <line29> try { <line30> return bundleContext.installBundle(location, inputStream); <line31> } catch (BundleException bundleException) { <line32> throw new PortalException(bundleException); <line33> } <line34> } <line35> } <line36> "	 <line32>	Yes
public class A { <line0> public Object[] getChildren(Object parentElement) { <line1> try { <line2> IGefaehrdungsBaumElement elmt = (IGefaehrdungsBaumElement) parentElement; <line3> return elmt.getGefaehrdungsBaumChildren().toArray(); <line4> } catch (Exception e) { <line5> return null; <line6> } <line7> } <line8> } <line9> 	 <line6>	No
"public class A { <line0> @Test <line1> public void testGetOrder() throws Exception { <line2> orderService.setupDummyOrders(); <line3> String response = <line4> template.requestBodyAndHeader( <line5> ""restlet:http://localhost:8080/orders/{id}?restletMethod=GET"", <line6> null, <line7> ""id"", <line8> ""1"", <line9> String.class); <line10> } <line11> } <line12> "	 <line10>	Yes
public class A { <line0> @Override <line1> public void init(Properties props, String topicName) { <line2> super.init(props, topicName); <line3> try { <line4> SchemaRegistry<Schema> registry = <line5> (SchemaRegistry<Schema>) <line6> Class.forName( <line7> props.getProperty( <line8> KafkaAvroMessageEncoder.KAFKA_MESSAGE_CODER_SCHEMA_REGISTRY_CLASS)) <line9> .newInstance(); <line10> registry.init(props); <line11> this.registry = new CachedSchemaRegistry<Schema>(registry, props); <line12> this.latestSchema = registry.getLatestSchemaByTopic(topicName).getSchema(); <line13> } catch (Exception e) { <line14> throw new MessageDecoderException(e); <line15> } <line16> decoderFactory = DecoderFactory.get(); <line17> } <line18> } <line19> 	 <line13>	No
"public class A { <line0> @Override <line1> public <T> Page<T> queryForPage(ViewQuery query, PageRequest pr, Class<T> type) { <line2> Assert.notNull(query, ""query may not be null""); <line3> Assert.notNull(pr, ""PageRequest may not be null""); <line4> Assert.notNull(type, ""type may not be null""); <line5> query.dbPath(dbURI.toString()); <line6> PageResponseHandler<T> ph = <line7> new PageResponseHandler<T>(pr, type, objectMapper, query.isIgnoreNotFound()); <line8> query = PageRequest.applyPagingParameters(query, pr); <line9> return executeQuery(query, ph); <line10> } <line11> } <line12> "	 <line4>	No
public class A { <line0> @Deactivate <line1> @PreDestroy <line2> @Override <line3> public synchronized void close() throws InterruptedException, ExecutionException { <line4> if (reg == null) { <line5> return; <line6> } <line7> reg.close(); <line8> reg = null; <line9> final WriteTransaction tx = dataBroker.newWriteOnlyTransaction(); <line10> tx.delete(LogicalDatastoreType.OPERATIONAL, YANG_LIBRARY_INSTANCE_IDENTIFIER); <line11> tx.delete(LogicalDatastoreType.OPERATIONAL, MODULES_STATE_INSTANCE_IDENTIFIER); <line12> final FluentFuture<? extends CommitInfo> future = tx.commit(); <line13> future.addCallback( <line14> new FutureCallback<CommitInfo>() { <line15> @Override <line16> public void onSuccess(final CommitInfo info) { <line17> } <line18>  <line19> @Override <line20> public void onFailure(final Throwable throwable) { <line21> } <line22> }, <line23> MoreExecutors.directExecutor()); <line24> future.get(); <line25> } <line26> } <line27> 	 <line21>	Yes
"public class A { <line0> private void loadLinkedReleasesRows(ResourceRequest request, ResourceResponse response) <line1> throws PortletException, IOException { <line2> final User user = UserCacheHolder.getUserFromRequest(request); <line3> String branchId = request.getParameter(PARENT_BRANCH_ID); <line4> request.setAttribute(PARENT_BRANCH_ID, branchId); <line5> ComponentService.Iface client = thriftClients.makeComponentClient(); <line6> if (branchId != null) { <line7> String id = branchId.split(""_"")[0]; <line8> try { <line9> Release release = client.getReleaseById(id, user); <line10> putDirectlyLinkedReleaseRelationsInRequest(request, release); <line11> } catch (TException e) { <line12> throw new PortletException(""cannot get projects"", e); <line13> } <line14> } else { <line15> putDirectlyLinkedReleaseRelationsInRequest(request, new Release()); <line16> } <line17> List<ReleaseLink> releaseLinkList = (List<ReleaseLink>) request.getAttribute(RELEASE_LIST); <line18> Set<String> releaseIds = <line19> releaseLinkList.stream().map(ReleaseLink::getId).collect(Collectors.toSet()); <line20> request.setAttribute(""relMainLineState"", fillMainLineState(releaseIds, client, user)); <line21> request.setAttribute( <line22> PortalConstants.PARENT_SCOPE_GROUP_ID, <line23> request.getParameter(PortalConstants.PARENT_SCOPE_GROUP_ID)); <line24> } <line25> } <line26> "	 <line12>	Yes
public class A { <line0> @Override <line1> public AsyncProducer acquireProducer(Endpoint endpoint) { <line2> try { <line3> AsyncProducer producer = producers.acquire(endpoint); <line4> if (statistics != null) { <line5> statistics.onHit(endpoint.getEndpointUri()); <line6> } <line7> if (producer instanceof StatefulService) { <line8> StatefulService ss = (StatefulService) producer; <line9> if (ss.isStarting()) { <line10> StopWatch watch = new StopWatch(); <line11> boolean done = false; <line12> while (!done) { <line13> done = !ss.isStarting() || watch.taken() > ACQUIRE_WAIT_TIME; <line14> if (!done) { <line15> Thread.sleep(5); <line16> if (LOG.isTraceEnabled()) { <line17> } <line18> } <line19> } <line20> if (LOG.isDebugEnabled()) { <line21> } <line22> } <line23> } <line24> return producer; <line25> } catch (Throwable e) { <line26> throw new FailedToCreateProducerException(endpoint, e); <line27> } <line28> } <line29> } <line30> 	 <line21>	Yes
public class A { <line0> @Test <line1> public void testGetRecord() { <line2> try { <line3> long start = System.currentTimeMillis(); <line4> doGetRecordTest(); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> private List<AssetEntry> _search(long companyId, AssetEntryQuery assetEntryQuery) { <line1> SearchContext searchContext = new SearchContext(); <line2> String ddmStructureFieldName = <line3> GetterUtil.getString(assetEntryQuery.getAttribute(""ddmStructureFieldName"")); <line4> Serializable ddmStructureFieldValue = assetEntryQuery.getAttribute(""ddmStructureFieldValue""); <line5> if (Validator.isNotNull(ddmStructureFieldName) && Validator.isNotNull(ddmStructureFieldValue)) { <line6> searchContext.setAttribute(""ddmStructureFieldName"", ddmStructureFieldName); <line7> searchContext.setAttribute(""ddmStructureFieldValue"", ddmStructureFieldValue); <line8> } <line9> searchContext.setClassTypeIds(assetEntryQuery.getClassTypeIds()); <line10> searchContext.setCompanyId(companyId); <line11> searchContext.setEnd(assetEntryQuery.getEnd()); <line12> searchContext.setKeywords(assetEntryQuery.getKeywords()); <line13> searchContext.setStart(assetEntryQuery.getStart()); <line14> try { <line15> Hits hits = <line16> _assetHelper.search( <line17> searchContext, assetEntryQuery, assetEntryQuery.getStart(), assetEntryQuery.getEnd()); <line18> return _assetHelper.getAssetEntries(hits); <line19> } catch (Exception exception) { <line20> } <line21> return Collections.emptyList(); <line22> } <line23> } <line24> "	 <line19>	No
"public class A { <line0> private void mergeCmdOptions( <line1> AbstractWorkflowDataModel model, <line2> int workflowAccession, <line3> int workflowRunAccession, <line4> String workflowEngine) { <line5> model.setWorkflow_run_accession(String.valueOf(workflowRunAccession)); <line6> model.setWorkflow_accession(String.valueOf(workflowAccession)); <line7> if (model.hasPropertyAndNotNull(ReservedIniKeys.METADATA.getKey())) { <line8> try { <line9> boolean metadataWriteBack = <line10> model.getProperty(ReservedIniKeys.METADATA.getKey()).equals(""metadata""); <line11> model.setMetadataWriteBack(metadataWriteBack); <line12> } catch (Exception ex) { <line13> Logger.getLogger(WorkflowDataModelFactory.class.getName()).log(Level.SEVERE, null, ex); <line14> } <line15> } <line16> if (model.hasPropertyAndNotNull(ReservedIniKeys.OUTPUT_PREFIX.getKey())) { <line17> try { <line18> model.setMetadata_output_file_prefix( <line19> model.getProperty(ReservedIniKeys.OUTPUT_PREFIX.getKey())); <line20> } catch (Exception ex) { <line21> Logger.getLogger(WorkflowDataModelFactory.class.getName()).log(Level.SEVERE, null, ex); <line22> } <line23> } else { <line24> } <line25> if (model.hasPropertyAndNotNull(ReservedIniKeys.OUTPUT_DIR.getKey())) { <line26> try { <line27> model.setMetadata_output_dir(model.getProperty(ReservedIniKeys.OUTPUT_DIR.getKey())); <line28> } catch (Exception ex) { <line29> Logger.getLogger(WorkflowDataModelFactory.class.getName()).log(Level.SEVERE, null, ex); <line30> } <line31> } else { <line32> } <line33> if (workflowEngine != null) { <line34> model.setWorkflow_engine(workflowEngine); <line35> } <line36> } <line37> } <line38> "	 <line19>	No
public class A { <line0> public void delete(Secuserrole persistentInstance) { <line1> Session session = getSession(); <line2> try { <line3> session.delete(persistentInstance); <line4> } catch (RuntimeException re) { <line5> throw re; <line6> } finally { <line7> this.releaseSession(session); <line8> } <line9> } <line10> } <line11> 	 <line4>	Yes
public class A { <line0> private static boolean initLOG4JXml(String homeDir) { <line1> String Log4jURL = homeDir + LOG4J_URL_XML; <line2> try { <line3> URL log4jurl = getURL(Log4jURL); <line4> DOMConfigurator.configure(log4jurl); <line5> } catch (Exception e) { <line6> return false; <line7> } <line8> return true; <line9> } <line10> } <line11> 	 <line9>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> @Override <line2> public T getValue() { <line3> try { <line4> return (T) server.getAttribute(objectName, attributeName); <line5> } catch (MBeanException <line6> | AttributeNotFoundException <line7> | InstanceNotFoundException <line8> | ReflectionException e) { <line9> return errorValue; <line10> } <line11> } <line12> } <line13> "	 <line9>	Yes
"public class A { <line0> private void copyTemplateFromSecondaryToPrimary( <line1> VmwareHypervisorHost hyperHost, <line2> DatastoreMO datastoreMo, <line3> String secondaryStorageUrl, <line4> String templatePathAtSecondaryStorage, <line5> String templateName, <line6> String templateUuid, <line7> String nfsVersion) <line8> throws Exception { <line9> String secondaryMountPoint = _mountService.getMountPoint(secondaryStorageUrl, nfsVersion); <line10> String srcOVAFileName = <line11> secondaryMountPoint <line12> + ""/"" <line13> + templatePathAtSecondaryStorage <line14> + templateName <line15> + ""."" <line16> + ImageFormat.OVA.getFileExtension(); <line17> String srcFileName = getOVFFilePath(srcOVAFileName); <line18> if (srcFileName == null) { <line19> Script command = new Script(""tar"", 0, s_logger); <line20> command.add(""--no-same-owner""); <line21> command.add(""-xf"", srcOVAFileName); <line22> command.setWorkDir(secondaryMountPoint + ""/"" + templatePathAtSecondaryStorage); <line23> String result = command.execute(); <line24> if (result != null) { <line25> String msg = ""Unable to unpack snapshot OVA file at: "" + srcOVAFileName; <line26> throw new Exception(msg); <line27> } <line28> } <line29> srcFileName = getOVFFilePath(srcOVAFileName); <line30> if (srcFileName == null) { <line31> String msg = ""Unable to locate OVF file in template package directory: "" + srcOVAFileName; <line32> s_logger.error(msg); <line33> throw new Exception(msg); <line34> } <line35> String vmName = templateUuid; <line36> hyperHost.importVmFromOVF(srcFileName, vmName, datastoreMo, ""thin"", null); <line37> VirtualMachineMO vmMo = hyperHost.findVmOnHyperHost(vmName); <line38> if (vmMo == null) { <line39> String msg = <line40> ""Failed to import OVA template. secondaryStorage: "" <line41> + secondaryStorageUrl <line42> + "", templatePathAtSecondaryStorage: "" <line43> + templatePathAtSecondaryStorage <line44> + "", templateName: "" <line45> + templateName <line46> + "", templateUuid: "" <line47> + templateUuid; <line48> s_logger.error(msg); <line49> throw new Exception(msg); <line50> } <line51> if (vmMo.createSnapshot(""cloud.template.base"", ""Base snapshot"", false, false)) { <line52> vmMo.setCustomFieldValue(CustomFieldConstants.CLOUD_UUID, templateUuid); <line53> vmMo.markAsTemplate(); <line54> } else { <line55> vmMo.destroy(); <line56> String msg = <line57> ""Unable to create base snapshot for template, templateName: "" <line58> + templateName <line59> + "", templateUuid: "" <line60> + templateUuid; <line61> throw new Exception(msg); <line62> } <line63> } <line64> } <line65> "	 <line26>	Yes
public class A { <line0> @Override <line1> public void onClose() { <line2> subscriber.onCompleted(); <line3> } <line4> } <line5> 	 <line3>	No
"public class A { <line0> @Override <line1> public boolean addTicketHostRestriction(final String ticketId, final String host) <line2> throws JargonException { <line3> Tag ticketOperationResponse = null; <line4> boolean response = true; <line5> if ((ticketId == null) || (ticketId.isEmpty())) { <line6> throw new IllegalArgumentException(""cannot modify ticket with null or empty ticketId""); <line7> } <line8> if ((host == null) || (host.isEmpty())) { <line9> throw new IllegalArgumentException(""cannot modify ticket with null or empty host""); <line10> } <line11> TicketAdminInp ticketPI = <line12> TicketAdminInp.instanceForModifyAddAccess( <line13> ticketId, TicketModifyAddOrRemoveTypeEnum.TICKET_MODIFY_HOST, host); <line14> ProtocolExtensionPoint pep = irodsAccessObjectFactory.getProtocolExtensionPoint(irodsAccount); <line15> try { <line16> ticketOperationResponse = pep.irodsFunction(ticketPI); <line17> } catch (JargonException e) { <line18> if (e.getUnderlyingIRODSExceptionCode() == ErrorEnum.CAT_TICKET_INVALID.getInt()) { <line19> response = false; <line20> } else { <line21> throw e; <line22> } <line23> } <line24> return response; <line25> } <line26> } <line27> "	 <line6>	No
public class A { <line0> @Override <line1> public int run(final Path outputDir, final int numReducers) throws Exception { <line2> PrivilegedExceptionAction<Integer> scanAction = <line3> new PrivilegedExceptionAction<Integer>() { <line4> @Override <line5> public Integer run() throws Exception { <line6> return doVerify(outputDir, numReducers); <line7> } <line8> }; <line9> return USER.runAs(scanAction); <line10> } <line11> } <line12> 	 <line5>	No
public class A { <line0> @Override <line1> public void buttonClick(final ClickEvent event) { <line2> final LoginResponse response = (LoginResponse) getApplicationManager().service(loginRequest); <line3> if (ServiceResult.SUCCESS == response.getResult()) { <line4> UI.getCurrent().getNavigator().navigateTo(UserViews.USERHOME_VIEW_NAME); <line5> } else { <line6> showNotification(LOGIN_FAILED, response.getErrorMessage(), Notification.Type.WARNING_MESSAGE); <line7> } <line8> } <line9> } <line10> 	 <line4>	Yes
"public class A { <line0> private synchronized void selectReader() throws IOException { <line1> if (lastMarker == null) { <line2> String query = String.format(""?limit=%d"", pagingSize); <line3> final HttpGet request = httpHelper.getRequestFactory().get(formatPath(path) + query); <line4> try { <line5> if (currentResponse != null) { <line6> currentResponse.close(); <line7> } <line8> } catch (IOException e) { <line9> MantaIOException mio = new MantaIOException(e); <line10> HttpHelper.annotateContextedException(mio, request, currentResponse); <line11> throw mio; <line12> } <line13> currentResponse = httpHelper.executeRequest(request, null); <line14> HttpEntity entity = currentResponse.getEntity(); <line15> String contentType; <line16> if (entity.getContentType() != null) { <line17> contentType = entity.getContentType().getValue(); <line18> } else { <line19> contentType = null; <line20> } <line21> if (!DIRECTORY_RESPONSE_CONTENT_TYPE.equals(contentType)) { <line22> String msg = <line23> ""A file was specified as the directory list path. "" <line24> + ""Only the contents of directories can be listed.""; <line25> MantaUnexpectedObjectTypeException e = <line26> new MantaUnexpectedObjectTypeException(msg, ObjectType.DIRECTORY, ObjectType.FILE); <line27> e.setContextValue(""path"", path); <line28> try { <line29> MantaHttpHeaders headers = new MantaHttpHeaders(currentResponse.getAllHeaders()); <line30> e.setResponseHeaders(headers); <line31> } catch (RuntimeException re) { <line32> } <line33> throw e; <line34> } <line35> InputStream contentStream = entity.getContent(); <line36> Objects.requireNonNull( <line37> contentStream, ""A directory listing without "" + ""content is not valid. Content is null.""); <line38> Reader streamReader = <line39> new InputStreamReader(entity.getContent(), StandardCharsets.UTF_8.name()); <line40> br = new BufferedReader(streamReader); <line41> } else { <line42> String query = <line43> String.format(""?limit=%d&marker=%s"", pagingSize, URLEncoder.encode(lastMarker, ""UTF-8"")); <line44> final HttpGet request = httpHelper.getRequestFactory().get(formatPath(path) + query); <line45> closeResources(); <line46> currentResponse = httpHelper.executeRequest(request, null); <line47> HttpEntity entity = currentResponse.getEntity(); <line48> Reader streamReader = <line49> new InputStreamReader(entity.getContent(), StandardCharsets.UTF_8.name()); <line50> br = new BufferedReader(streamReader); <line51> br.readLine(); <line52> } <line53> Header resultsHeader = currentResponse.getFirstHeader(MantaHttpHeaders.RESULT_SET_SIZE); <line54> if (resultsHeader != null) { <line55> String results = resultsHeader.getValue(); <line56> if (results.equals(""0"")) { <line57> finished.set(true); <line58> return; <line59> } <line60> } <line61> nextLine.set(br.readLine()); <line62> lines.incrementAndGet(); <line63> finished.set(nextLine.get() == null); <line64> } <line65> } <line66> "	 <line52>	No
public class A { <line0> public void sleepUntilNextRetry() throws InterruptedException { <line1> int attempts = getAttemptTimes(); <line2> long sleepTime = getBackoffTime(); <line3> retryConfig.getTimeUnit().sleep(sleepTime); <line4> useRetry(); <line5> } <line6> } <line7> 	 <line6>	No
public class A { <line0> protected void setConnectStrategy( <line1> Strategy connectStrategy, int preparedConnectionCount, int maxConnectionCount) { <line2> this.connectStrategy = <line3> ProxyConnectStrategy.newInstance( <line4> connectStrategy, preparedConnectionCount, maxConnectionCount); <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	 <line7>	No
public class A { <line0> private void getAllStorageSystems() { <line1> ResourceCollection<StorageSystem> storageSystems = this.storageSystemClient.getAll(); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> protected Optional<Task<?>> findTaskOrSubTask( <line1> Iterable<? extends Task<?>> tasks, Predicate<? super Task<?>> matcher) { <line2> List<String> taskNames = Lists.newArrayList(); <line3> Optional<Task<?>> result = findTaskOrSubTaskImpl(tasks, matcher, taskNames); <line4> if (!result.isPresent() && log.isDebugEnabled()) { <line5> } <line6> return result; <line7> } <line8> } <line9> 	 <line4>	No
public class A { <line0> static boolean sanityCheckArenaBlockSize( <line1> long writeBufferSize, long arenaBlockSizeConfigured, long writeBufferManagerCapacity) <line2> throws IllegalStateException { <line3> long defaultArenaBlockSize = <line4> RocksDBMemoryControllerUtils.calculateRocksDBDefaultArenaBlockSize(writeBufferSize); <line5> long arenaBlockSize = <line6> arenaBlockSizeConfigured <= 0 ? defaultArenaBlockSize : arenaBlockSizeConfigured; <line7> long mutableLimit = <line8> RocksDBMemoryControllerUtils.calculateRocksDBMutableLimit(writeBufferManagerCapacity); <line9> if (RocksDBMemoryControllerUtils.validateArenaBlockSize(arenaBlockSize, mutableLimit)) { <line10> return true; <line11> } else { <line12> return false; <line13> } <line14> } <line15> } <line16> 	 <line12>	Yes
"public class A { <line0> public void testTopic(String prod_broker_url, String cons_broker_url) throws Exception { <line1> int num_msg; <line2> Connection conn; <line3> Session sess; <line4> String topic_name; <line5> Destination cons_dest; <line6> num_msg = 5; <line7> conn = createConnection(cons_broker_url); <line8> conn.start(); <line9> sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE); <line10> topic_name = ""topotest2.perm.topic""; <line11> removeTopic(conn, topic_name); <line12> cons_dest = sess.createTopic(topic_name); <line13> testOneDest(conn, sess, cons_dest, num_msg); <line14> removeTopic(conn, topic_name); <line15> sess.close(); <line16> conn.close(); <line17> } <line18> } <line19> "	 <line12>	Yes
public class A { <line0> @Override <line1> public List<LwM2mObject> findLwM2mObject( <line2> TenantId tenantId, String sortOrder, String sortProperty, String[] objectIds) { <line3> validateId(tenantId, INCORRECT_TENANT_ID + tenantId); <line4> List<TbResource> resources = <line5> resourceService.findTenantResourcesByResourceTypeAndObjectIds( <line6> tenantId, ResourceType.LWM2M_MODEL, objectIds); <line7> return resources.stream() <line8> .flatMap(s -> Stream.ofNullable(toLwM2mObject(s, false))) <line9> .sorted(getComparator(sortProperty, sortOrder)) <line10> .collect(Collectors.toList()); <line11> } <line12> } <line13> 	 <line3>	Yes
"public class A { <line0> public void triggerCheckpointBarrier( <line1> final long checkpointID, <line2> final long checkpointTimestamp, <line3> final CheckpointOptions checkpointOptions) { <line4> final AbstractInvokable invokable = this.invokable; <line5> final CheckpointMetaData checkpointMetaData = <line6> new CheckpointMetaData(checkpointID, checkpointTimestamp, System.currentTimeMillis()); <line7> if (executionState == ExecutionState.RUNNING && invokable != null) { <line8> try { <line9> invokable.triggerCheckpointAsync(checkpointMetaData, checkpointOptions); <line10> } catch (RejectedExecutionException ex) { <line11> } catch (Throwable t) { <line12> if (getExecutionState() == ExecutionState.RUNNING) { <line13> failExternally( <line14> new Exception( <line15> ""Error while triggering checkpoint "" <line16> + checkpointID <line17> + "" for "" <line18> + taskNameWithSubtask, <line19> t)); <line20> } else { <line21> } <line22> } <line23> } else { <line24> checkpointResponder.declineCheckpoint( <line25> jobId, <line26> executionId, <line27> checkpointID, <line28> new CheckpointException( <line29> ""Task name with subtask : "" + taskNameWithSubtask, <line30> CheckpointFailureReason.CHECKPOINT_DECLINED_TASK_NOT_READY)); <line31> } <line32> } <line33> } <line34> "	 <line12>	No
"public class A { <line0> @Test <line1> public void stringImageInputStream() { <line2> final String inURLToFile = TestData.getResource(this, ""a.txt"").toString(); <line3> ImageInputStream instream; <line4> try { <line5> instream = ImageIO.createImageInputStream(inURLToFile); <line6> } catch (IOException e) { <line7> LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e); <line8> instream = null; <line9> } <line10> Assert.assertNotNull( <line11> ""Unable to get an StringImageInputStreamSpi from a URL pointing to a File"", instream); <line12> try { <line13> final String httpURL = new URL(""http://www.corriere.it/"").toString(); <line14> instream = ImageIO.createImageInputStream(httpURL); <line15> } catch (MalformedURLException e) { <line16> LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e); <line17> instream = null; <line18> } catch (IOException e) { <line19> LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e); <line20> instream = null; <line21> } <line22> Assert.assertNotNull( <line23> ""Unable to get an URLImageInputStreamSpi from a URL pointing to an http page"", instream); <line24> try { <line25> final String url = TestData.url(this, ""sample.jpeg"").toString(); <line26> final ImageInputStream stream = ImageIO.createImageInputStream(url); <line27> final RenderedOp image = JAI.create(""ImageRead"", stream); <line28> if (TestData.isInteractiveTest()) visualize(image, ""testURLImageInputStreamSpi""); <line29> else image.getAsBufferedImage(); <line30> } catch (IOException e) { <line31> LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e); <line32> } <line33> } <line34> } <line35> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public boolean isValid(final PropagationTask task, final ConstraintValidatorContext context) { <line2> boolean isValid; <line3> if (task == null) { <line4> isValid = true; <line5> } else { <line6> isValid = <line7> task.getOperation() != null <line8> && !task.getAttributes().isEmpty() <line9> && task.getResource() != null; <line10> if (isValid) { <line11> List<? extends TaskExec> executions = task.getExecs(); <line12> for (TaskExec execution : executions) { <line13> try { <line14> ExecStatus.valueOf(execution.getStatus()); <line15> } catch (IllegalArgumentException e) { <line16> isValid = false; <line17> } <line18> } <line19> } <line20> if (!isValid) { <line21> context.disableDefaultConstraintViolation(); <line22> context <line23> .buildConstraintViolationWithTemplate( <line24> getTemplate(EntityViolationType.InvalidPropagationTask, ""Invalid task"")) <line25> .addPropertyNode(task.getClass().getSimpleName()) <line26> .addConstraintViolation(); <line27> } <line28> } <line29> return isValid; <line30> } <line31> } <line32> "	 <line7>	No
"public class A { <line0> @Transactional(rollbackFor = ArrowheadException.class) <line1> public void logIntraMeasurementDetailsToDB( <line2> final QoSIntraPingMeasurementLog measurementLogSaved, <line3> final List<IcmpPingResponse> responseList, <line4> final ZonedDateTime aroundNow) { <line5> if (responseList == null || responseList.isEmpty()) { <line6> throw new InvalidParameterException(""List<IcmpPingResponse>"" + EMPTY_OR_NULL_ERROR_MESSAGE); <line7> } else if (measurementLogSaved == null) { <line8> throw new InvalidParameterException(""QoSIntraPingMeasurementLog"" + NULL_ERROR_MESSAGE); <line9> } else if (aroundNow == null) { <line10> throw new InvalidParameterException(""ZonedDateTime"" + NULL_ERROR_MESSAGE); <line11> } <line12> final List<QoSIntraPingMeasurementLogDetails> measurementLogDetailsList = <line13> new ArrayList<>(responseList.size()); <line14> int measurementSequenece = 0; <line15> for (final IcmpPingResponse icmpPingResponse : responseList) { <line16> final QoSIntraPingMeasurementLogDetails measurementLogDetails = <line17> new QoSIntraPingMeasurementLogDetails(); <line18> measurementLogDetails.setMeasurementLog(measurementLogSaved); <line19> measurementLogDetails.setMeasurementSequeneceNumber(measurementSequenece++); <line20> measurementLogDetails.setSuccessFlag(icmpPingResponse.getSuccessFlag()); <line21> measurementLogDetails.setTimeoutFlag(icmpPingResponse.getTimeoutFlag()); <line22> measurementLogDetails.setErrorMessage(icmpPingResponse.getErrorMessage()); <line23> measurementLogDetails.setThrowable( <line24> icmpPingResponse.getThrowable() == null <line25> ? null <line26> : icmpPingResponse.getThrowable().toString()); <line27> measurementLogDetails.setSize(icmpPingResponse.getSize()); <line28> measurementLogDetails.setTtl(icmpPingResponse.getTtl()); <line29> measurementLogDetails.setRtt(icmpPingResponse.getRtt()); <line30> measurementLogDetails.setDuration((int) icmpPingResponse.getDuration()); <line31> measurementLogDetails.setMeasuredAt(aroundNow); <line32> measurementLogDetailsList.add(measurementLogDetails); <line33> } <line34> try { <line35> qoSIntraPingMeasurementLogDetailsRepository.saveAll(measurementLogDetailsList); <line36> qoSIntraPingMeasurementLogDetailsRepository.flush(); <line37> } catch (final Exception ex) { <line38> throw new ArrowheadException(CoreCommonConstants.DATABASE_OPERATION_EXCEPTION_MSG); <line39> } <line40> } <line41> } <line42> "	 <line0>	No
"public class A { <line0> private void closeAndDeleteAfterEx(IOException ex, OplogFile olf) { <line1> if (olf == null) { <line2> return; <line3> } <line4> if (olf.raf != null) { <line5> try { <line6> olf.raf.close(); <line7> } catch (IOException e) { <line8> } <line9> } <line10> olf.RAFClosed = true; <line11> if (!olf.f.delete() && olf.f.exists()) { <line12> throw new DiskAccessException( <line13> String.format(""Could not delete %s."", olf.f.getAbsolutePath()), ex, getParent()); <line14> } <line15> } <line16> } <line17> "	 <line8>	Yes
"public class A { <line0> @Test <line1> public void testHBaseSaslRpcClientCreation() throws Exception { <line2> assertFalse(assertSuccessCreationKerberosPrincipal(null)); <line3> assertFalse(assertSuccessCreationKerberosPrincipal(""DOMAIN.COM"")); <line4> assertFalse(assertSuccessCreationKerberosPrincipal(""principal/DOMAIN.COM"")); <line5> if (!assertSuccessCreationKerberosPrincipal(""principal/localhost@DOMAIN.COM"")) { <line6> } <line7> assertFalse(assertSuccessCreationDigestPrincipal(null, null)); <line8> assertFalse(assertSuccessCreationDigestPrincipal("""", """")); <line9> assertFalse(assertSuccessCreationDigestPrincipal("""", null)); <line10> assertFalse(assertSuccessCreationDigestPrincipal(null, """")); <line11> assertTrue(assertSuccessCreationDigestPrincipal(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line12> assertFalse(assertSuccessCreationSimplePrincipal("""", """")); <line13> assertFalse(assertSuccessCreationSimplePrincipal(null, null)); <line14> assertFalse(assertSuccessCreationSimplePrincipal(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line15> assertTrue(assertIOExceptionThenSaslClientIsNull(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line16> assertTrue( <line17> assertIOExceptionWhenGetStreamsBeforeConnectCall(DEFAULT_USER_NAME, DEFAULT_USER_PASSWORD)); <line18> } <line19> } <line20> "	 <line0>	No
public class A { <line0> @Override <line1> public void registerInterpreterProcess(RegisterInfo registerInfo) <line2> throws InterpreterRPCException, TException { <line3> InterpreterGroup interpreterGroup = <line4> interpreterSettingManager.getInterpreterGroupById(registerInfo.getInterpreterGroupId()); <line5> if (interpreterGroup == null) { <line6> return; <line7> } <line8> RemoteInterpreterProcess interpreterProcess = <line9> ((ManagedInterpreterGroup) interpreterGroup).getInterpreterProcess(); <line10> if (interpreterProcess == null) { <line11> return; <line12> } <line13> interpreterProcess.processStarted(registerInfo.port, registerInfo.host); <line14> } <line15> } <line16> 	 <line3>	No
"public class A { <line0> private static void startJsonDump(CommandLineArgs args) { <line1> try { <line2> final String filename = args.getJsonDump(); <line3> final JsonDumper jsonDumper = <line4> new JsonDumper(filename, args.getLanguages(), args.getExtraTags()); <line5> NominatimConnector nominatimConnector = <line6> new NominatimConnector( <line7> args.getHost(), <line8> args.getPort(), <line9> args.getDatabase(), <line10> args.getUser(), <line11> args.getPassword()); <line12> nominatimConnector.setImporter(jsonDumper); <line13> nominatimConnector.readEntireDatabase(args.getCountryCodes().split("","")); <line14> } catch (FileNotFoundException e) { <line15> } <line16> } <line17> } <line18> "	 <line10>	No
public class A { <line0> @Override <line1> public void update(EDBObject obj) throws EDBException { <line2> if (!updates.contains(obj)) { <line3> updates.add(EDBUtils.convertEDBObjectToJPAObject(obj)); <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public void init() { <line2> super.init(); <line3> ServletContext context = (ServletContext) getOption(ServletContext.class.getName()); <line4> if (context == null) { <line5> throw new IllegalArgumentException(""Missing ServletContext""); <line6> } <line7> String cometdURLMapping = (String) getOption(COMETD_URL_MAPPING_OPTION); <line8> if (cometdURLMapping == null) { <line9> throw new IllegalArgumentException(""Missing '"" + COMETD_URL_MAPPING_OPTION + ""' parameter""); <line10> } <line11> NativeWebSocketConfiguration wsConfig = <line12> (NativeWebSocketConfiguration) <line13> context.getAttribute(NativeWebSocketConfiguration.class.getName()); <line14> if (wsConfig == null) { <line15> throw new IllegalArgumentException(""Missing WebSocketConfiguration""); <line16> } <line17> WebSocketPolicy policy = wsConfig.getFactory().getPolicy(); <line18> int bufferSize = getOption(BUFFER_SIZE_OPTION, policy.getInputBufferSize()); <line19> policy.setInputBufferSize(bufferSize); <line20> int maxMessageSize = getMaxMessageSize(); <line21> if (maxMessageSize < 0) { <line22> maxMessageSize = policy.getMaxTextMessageSize(); <line23> } <line24> policy.setMaxTextMessageSize(maxMessageSize); <line25> long idleTimeout = getOption(IDLE_TIMEOUT_OPTION, policy.getIdleTimeout()); <line26> policy.setIdleTimeout((int) idleTimeout); <line27> for (String mapping : normalizeURLMapping(cometdURLMapping)) { <line28> wsConfig.addMapping( <line29> mapping, <line30> (request, response) -> { <line31> String origin = request.getHeader(""Origin""); <line32> if (origin == null) { <line33> origin = request.getHeader(""Sec-WebSocket-Origin""); <line34> } <line35> if (checkOrigin(request, origin)) { <line36> List<ExtensionConfig> negotiated = new ArrayList<>(); <line37> for (ExtensionConfig extensionConfig : request.getExtensions()) { <line38> String name = extensionConfig.getName(); <line39> boolean option = getOption(ENABLE_EXTENSION_PREFIX_OPTION + name, true); <line40> if (option) { <line41> negotiated.add(extensionConfig); <line42> } <line43> } <line44> response.setExtensions(negotiated); <line45> modifyUpgrade(request, response); <line46> List<String> allowedTransports = getBayeux().getAllowedTransports(); <line47> if (allowedTransports.contains(getName())) { <line48> WebSocketContext handshake = new WebSocketContext(context, request); <line49> return newWebSocketEndPoint(handshake); <line50> } else { <line51> if (LOGGER.isDebugEnabled()) { <line52> } <line53> } <line54> } else { <line55> if (LOGGER.isDebugEnabled()) { <line56> } <line57> } <line58> return null; <line59> }); <line60> } <line61> } <line62> } <line63> "	 <line56>	Yes
public class A { <line0> Mono<StoreResponse> barrierForGlobalStrong( <line1> RxDocumentServiceRequest request, StoreResponse response) { <line2> try { <line3> if (ReplicatedResourceClient.isGlobalStrongEnabled() <line4> && this.isGlobalStrongRequest(request, response)) { <line5> Utils.ValueHolder<Long> lsn = Utils.ValueHolder.initialize(-1L); <line6> Utils.ValueHolder<Long> globalCommittedLsn = Utils.ValueHolder.initialize(-1L); <line7> getLsnAndGlobalCommittedLsn(response, lsn, globalCommittedLsn); <line8> if (lsn.v == -1 || globalCommittedLsn.v == -1) { <line9> throw new GoneException(RMResources.Gone); <line10> } <line11> request.requestContext.globalStrongWriteResponse = response; <line12> request.requestContext.globalCommittedSelectedLSN = lsn.v; <line13> request.requestContext.forceRefreshAddressCache = false; <line14> if (globalCommittedLsn.v < lsn.v) { <line15> Mono<RxDocumentServiceRequest> barrierRequestObs = <line16> BarrierRequestHelper.createAsync( <line17> this.diagnosticsClientContext, <line18> request, <line19> this.authorizationTokenProvider, <line20> null, <line21> request.requestContext.globalCommittedSelectedLSN); <line22> return barrierRequestObs.flatMap( <line23> barrierRequest -> { <line24> Mono<Boolean> barrierWait = <line25> this.waitForWriteBarrierAsync( <line26> barrierRequest, request.requestContext.globalCommittedSelectedLSN); <line27> return barrierWait.flatMap( <line28> res -> { <line29> if (!res) { <line30> } <line31> return Mono.just(request.requestContext.globalStrongWriteResponse); <line32> }); <line33> }); <line34> } else { <line35> return Mono.just(request.requestContext.globalStrongWriteResponse); <line36> } <line37> } else { <line38> return Mono.just(response); <line39> } <line40> } catch (CosmosException e) { <line41> } <line42> } <line43> } <line44> 	 <line1>	No
"public class A { <line0> @Override <line1> public void cleanup( <line2> BSPPeer<NullWritable, NullWritable, NullWritable, NullWritable, NullWritable> peer) <line3> throws IOException { <line4> if (peer.getConfiguration().getInt(TEST_POINT, 0) == 3) { <line5> throw new RuntimeException(""Error injected in cleanup""); <line6> } <line7> try { <line8> Thread.sleep(500); <line9> } catch (Exception e) { <line10> } <line11> super.cleanup(peer); <line12> } <line13> } <line14> "	 <line2>	No
"public class A { <line0> @Override <line1> protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception { <line2> try { <line3> try { <line4> ByteBuf binary = frame.content(); <line5> if (binary != null) { <line6> if (log.isTraceEnabled()) { <line7> } <line8> WebSocketDecodeContext msg = decoder.decodeMessage(binary); <line9> WebSocketResource resource = resourcesByName.get(msg.getResource()); <line10> if (resource != null) { <line11> WebSocketReply reply = resource.processRequest(msg, decoder); <line12> if (reply != null) { <line13> sendReply(reply); <line14> } <line15> } else { <line16> throw new WebSocketException( <line17> msg.getRequestId(), <line18> ""Invalid message (unsupported resource: '"" + msg.getResource() + ""')""); <line19> } <line20> } <line21> } catch (WebSocketException e) { <line22> sendException(e); <line23> } <line24> } catch (Exception e) { <line25> try { <line26> sendException(new WebSocketException(WSConstants.NO_REQUEST_ID, ""Internal Server Error"")); <line27> } catch (Exception e2) { <line28> } <line29> } <line30> } <line31> } <line32> "	 <line6>	No
public class A { <line0> @Override <line1> @Transactional <line2> public void disableScheduling() { <line3> requireNotDisposed(); <line4> _schedulingService.disableScheduling(); <line5> } <line6> } <line7> 	 <line5>	No
"public class A { <line0> ErrorCodedDataAccessException translateUniqueKeyViolation( <line1> Throwable sourceThrowable, PSQLException pSqlException) { <line2> ServerErrorMessage serverErrorMessage = pSqlException.getServerErrorMessage(); <line3> String tableName = serverErrorMessage.getTable(); <line4> String detailMessage = serverErrorMessage.getDetail(); <line5> Matcher matcher = <line6> Pattern.compile(""Key \\(\""?(.*?)\""?\\)=\\((.*?)\\) already exists."").matcher(detailMessage); <line7> boolean matches = matcher.matches(); <line8> if (matches) { <line9> String[] columnNames = matcher.group(1).split("", ""); <line10> if (columnNames.length == 1) { <line11> String columnName = columnNames[0]; <line12> String value = matcher.group(2); <line13> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line14> String attributeName = tryGetAttributeName(tableName, columnName).orElse(null); <line15> return new ValueAlreadyExistsException(entityTypeId, attributeName, value, sourceThrowable); <line16> } else { <line17> String columnName = columnNames[columnNames.length - 1]; <line18> String[] values = matcher.group(2).split("", ""); <line19> String entityId = values[0]; <line20> String value = values[1]; <line21> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line22> String attributeName = tryGetAttributeName(tableName, columnName).orElse(null); <line23> return new ListValueAlreadyExistsException( <line24> entityTypeId, attributeName, entityId, value, sourceThrowable); <line25> } <line26> } else { <line27> matcher = <line28> Pattern.compile(""Key \\(\""?(.*?)\""?\\)=\\((.*?)\\) is duplicated."") <line29> .matcher(detailMessage); <line30> matches = matcher.matches(); <line31> if (matches) { <line32> String columnName = matcher.group(1); <line33> String value = matcher.group(2); <line34> String entityTypeId = tryGetEntityTypeName(tableName).orElse(null); <line35> String attributeName = tryGetAttributeName(tableName, columnName).orElse(null); <line36> return new DuplicateValueException(entityTypeId, attributeName, value, sourceThrowable); <line37> } else { <line38> throw new RuntimeException(ERROR_TRANSLATING_EXCEPTION_MSG, pSqlException); <line39> } <line40> } <line41> } <line42> } <line43> "	 <line38>	Yes
public class A { <line0> public String toString() { <line1> try { <line2> JSONObject json = this.toJSON(); <line3> if (json != null) { <line4> return json.toString(); <line5> } <line6> return null; <line7> } catch (Exception e) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
public class A { <line0> void maybeFinishInit() throws IOException { <line1> if (bundleizer == null) { <line2> input = CompressedStream.decompressInputStream(input, stream.name()); <line3> opening.dec(); <line4> bundleizer = format.createBundleizer(input, AbstractStreamFileDataSource.this); <line5> long read = mark.getIndex(); <line6> if (read == 0) { <line7> return; <line8> } <line9> int bundlesSkipped = 0; <line10> skipping.inc(); <line11> while (read > 0) { <line12> if (++bundlesSkipped % 100 == 0) { <line13> int totalSkip = localBundleSkip.get() + bundlesSkipped; <line14> if ((totalSkip / 100) % 250 == 0) { <line15> localBundleSkip.set(totalSkip); <line16> globalBundleSkip.inc(bundlesSkipped); <line17> bundlesSkipped = 0; <line18> } <line19> } <line20> read--; <line21> if (shuttingDown.get() || (bundleizer.next() == null)) { <line22> close(false); <line23> break; <line24> } <line25> } <line26> skipping.dec(); <line27> localBundleSkip.set(localBundleSkip.get() + bundlesSkipped); <line28> globalBundleSkip.inc(bundlesSkipped); <line29> } <line30> } <line31> } <line32> 	 <line29>	Yes
"public class A { <line0> @RequestMapping(value = ""/masstruncate"", method = RequestMethod.GET) <line1> public ResponseEntity<?> doGet(HttpServletRequest req) { <line2> XStream xs = configXStream(new GeoWebCacheXStream()); <line3> StringBuilder sb = new StringBuilder(); <line4> Set<String> result = new HashSet<>(); <line5> sb.append(""<massTruncateRequests href=\"""").append(req.getRequestURL()).append(""\"">""); <line6> for (Class<?> requestType : getRequestTypes()) { <line7> String alias = xs.getMapper().serializedClass(requestType); <line8> sb.append("" <requestType>""); <line9> sb.append(alias); <line10> sb.append(""</requestType>""); <line11> if (!result.add(alias) && log.isWarnEnabled()) { <line12> } <line13> } <line14> sb.append(""</massTruncateRequests>""); <line15> return new ResponseEntity<Object>(sb.toString(), HttpStatus.OK); <line16> } <line17> } <line18> "	 <line12>	Yes
public class A { <line0> @Override <line1> public boolean isAuthToEdit(UserDetails user, DataObject dataObject) throws ApsSystemException { <line2> if (null == dataObject) { <line3> return false; <line4> } else if (DataObject.STATUS_NEW.equals(dataObject.getStatus()) <line5> && null == dataObject.getMainGroup()) { <line6> return true; <line7> } <line8> String mainGroupName = dataObject.getMainGroup(); <line9> return this.isAuthToEdit(user, mainGroupName); <line10> } <line11> } <line12> 	 <line5>	No
public class A { <line0> private void validateFailInConfigWithExplicitTotalFlinkAndManagedMem( <line1> final Configuration customConfig) { <line2> final Configuration config = configWithExplicitTotalFlinkAndManagedMem(); <line3> config.addAll(customConfig); <line4> validateFail(config); <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private static ExtractedDocumentMetadata.Builder convertTitles( <line2> String id, Element titleGroup, ExtractedDocumentMetadata.Builder docMetaBuilder) { <line3> List<Element> titles = titleGroup.getChildren(""article-title""); <line4> if (!titles.isEmpty()) { <line5> if (titles.size() > 1) { <line6> } <line7> for (Element titleElem : titles) { <line8> String title = titleElem.getTextNormalize(); <line9> if (title != null && !title.isEmpty()) { <line10> docMetaBuilder.setTitle(title); <line11> break; <line12> } <line13> } <line14> } <line15> return docMetaBuilder; <line16> } <line17> } <line18> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> assertFalse(running); <line4> running = true; <line5> try { <line6> doTestTransactional(this); <line7> } finally { <line8> running = false; <line9> } <line10> } catch (Throwable e) { <line11> addException(e); <line12> } <line13> } <line14> } <line15> 	 <line12>	No
"public class A { <line0> private static InputStream getStream(ServletContext context) throws NamingException { <line1> String configurationLocation = XWiki.getConfigPath(); <line2> File f = new File(configurationLocation); <line3> try { <line4> if (f.exists()) { <line5> return new FileInputStream(f); <line6> } <line7> } catch (Exception e) { <line8> } <line9> if (context != null) { <line10> InputStream xwikicfgis = context.getResourceAsStream(configurationLocation); <line11> if (xwikicfgis != null) { <line12> return xwikicfgis; <line13> } <line14> } else { <line15> } <line16> return XWiki.class.getClassLoader().getResourceAsStream(""xwiki.cfg""); <line17> } <line18> } <line19> "	 <line13>	No
public class A { <line0> public void attachClean(StgMbCss instance) { <line1> try { <line2> sessionFactory.getCurrentSession().lock(instance, LockMode.NONE); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line3>	Yes
public class A { <line0> protected void cleanup() { <line1> if (messagesSender != null) { <line2> messagesSender.close(); <line3> } <line4> if (suiteProcessor != null) { <line5> suiteProcessor.cleanup(); <line6> } <line7> } <line8> } <line9> 	 <line2>	No
"public class A { <line0> @RequestMapping( <line1> value = ""/{jobId}"", <line2> method = {RequestMethod.GET}, <line3> produces = {""application/json""}) <line4> @ResponseBody <line5> public JobInstance get(@PathVariable String jobId) { <line6> JobInstance jobInstance = null; <line7> try { <line8> jobInstance = jobService.getJobInstance(jobId); <line9> } catch (Exception e) { <line10> throw new InternalErrorException(e); <line11> } <line12> return jobInstance; <line13> } <line14> } <line15> "	 <line10>	Yes
public class A { <line0> public void setFinalLocalDefs( <line1> List<PDefinition> localDefs, List<AVarDeclIR> localDecls, IRInfo question) <line2> throws AnalysisException { <line3> for (PDefinition def : localDefs) { <line4> AVarDeclIR varDecl = null; <line5> if (def instanceof AValueDefinition) { <line6> varDecl = consLocalVarDecl((AValueDefinition) def, question); <line7> } else if (def instanceof AEqualsDefinition) { <line8> varDecl = consLocalVarDecl((AEqualsDefinition) def, question); <line9> } <line10> if (varDecl != null) { <line11> varDecl.setFinal(true); <line12> localDecls.add(varDecl); <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> 	 <line14>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> while (isLive.get()) { <line3> try { <line4> Thread.sleep(pulsePeriod); <line5> } catch (InterruptedException e) { <line6> break; <line7> } <line8> try { <line9> callback.onTick(System.currentTimeMillis()); <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> } <line15> 	 <line8>	No
public class A { <line0> @Override <line1> public boolean doesExist(String string) throws FtpException { <line2> try (Tx tx = StructrApp.getInstance(securityContext).tx()) { <line3> boolean exists = (getStructrUser(string) != null); <line4> tx.success(); <line5> return exists; <line6> } catch (FrameworkException fex) { <line7> } <line8> return false; <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> private void configureXacmlPdp() { <line1> if (xacmlPdp == null) { <line2> try { <line3> xacmlPdp = new XacmlPdp(dirPath, parser, environmentAttributes, securityLogger); <line4> } catch (PdpException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line8>	No
public class A { <line0> private QoSInterDirectPingMeasurementResponseDTO getInterDirectPingMeasurementFromQoSMonitor( <line1> final CloudSystemFormDTO request) { <line2> final QoSInterDirectPingMeasurementResponseDTO measurement = <line3> orchestratorDriver.getInterDirectPingMeasurement(request); <line4> if (measurement.hasRecord() && measurement.isAvailable()) { <line5> interDirectPingMeasurementCache.put(getCloudSystemCacheKey(request), measurement); <line6> } <line7> return measurement; <line8> } <line9> } <line10> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void onSessionInitiated(final BindingAwareBroker.ProviderContext providerContext) { <line2> final EPPolicyTemplateProviderFacade templateProviderFacade = <line3> new EPPolicyTemplateProviderIseImpl(); <line4> epPolicyTemplateProviderRegistration = <line5> sxpEpProvider <line6> .getEPPolicyTemplateProviderRegistry() <line7> .registerTemplateProvider(templateProviderFacade); <line8> final SgtInfoProcessor epgGenerator = new SgtToEpgGeneratorImpl(dataBroker); <line9> final SgtInfoProcessor templateGenerator = new SgtToEPTemplateGeneratorImpl(dataBroker); <line10> final GbpIseSgtHarvester gbpIseSgtHarvester = <line11> new GbpIseSgtHarvesterImpl(epgGenerator, templateGenerator); <line12> final GbpIseConfigListenerImpl gbpIseConfigListener = <line13> new GbpIseConfigListenerImpl(dataBroker, gbpIseSgtHarvester, templateProviderFacade); <line14> templateProviderFacade.setIseSgtHarvester(gbpIseSgtHarvester); <line15> final DataTreeIdentifier<IseSourceConfig> dataTreePath = <line16> new DataTreeIdentifier<>( <line17> LogicalDatastoreType.CONFIGURATION, <line18> InstanceIdentifier.create(GbpSxpIseAdapter.class).child(IseSourceConfig.class)); <line19> registration = dataBroker.registerDataTreeChangeListener(dataTreePath, gbpIseConfigListener); <line20> } <line21> } <line22> 	 <line2>	Yes
"public class A { <line0> protected final InputStream transformToICal(InputStream in) throws CalendarException { <line1> StreamSource xmlSource = new StreamSource(in); <line2> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line3> try { <line4> InputStream xsl = this.getClass().getClassLoader().getResourceAsStream(xslFile); <line5> Transformer tx = TransformerFactory.newInstance().newTransformer(new StreamSource(xsl)); <line6> tx.transform(xmlSource, new StreamResult(out)); <line7> InputStream result = new ByteArrayInputStream(out.toByteArray()); <line8> return result; <line9> } catch (TransformerConfigurationException tce) { <line10> throw new CalendarException(""Failed to configure transformer"", tce); <line11> } catch (TransformerException txe) { <line12> throw new CalendarException(""Failed transformation"", txe); <line13> } <line14> } <line15> } <line16> "	 <line10>	Yes
"public class A { <line0> @Override <line1> public void warmUpCache(SiteContext siteContext, boolean switchCache) { <line2> String siteName = siteContext.getSiteName(); <line3> StopWatch stopWatch = new StopWatch(); <line4> if (switchCache) { <line5> Context currentContext = siteContext.getContext(); <line6> long oldCacheVersion = currentContext.getCacheVersion(); <line7> long newCacheVersion = System.nanoTime(); <line8> Context tmpContext = currentContext.clone(); <line9> tmpContext.setCacheVersion(newCacheVersion); <line10> cacheService.addScope(tmpContext); <line11> try { <line12> stopWatch.start(); <line13> doCacheWarmUp(tmpContext); <line14> if (siteContext.isValid()) { <line15> currentContext.setCacheVersion(newCacheVersion); <line16> tmpContext.setCacheVersion(oldCacheVersion); <line17> cacheService.removeScope(tmpContext); <line18> } else { <line19> throw new CrafterException(""The site context has become invalid (possibly destroyed)""); <line20> } <line21> stopWatch.stop(); <line22> } catch (Exception e) { <line23> cacheService.removeScope(tmpContext); <line24> } <line25> } else { <line26> stopWatch.start(); <line27> doCacheWarmUp(siteContext.getContext()); <line28> stopWatch.stop(); <line29> } <line30> } <line31> } <line32> "	 <line22>	Yes
"public class A { <line0> private void addWithGroovyClassLoader(int x, int y) <line1> throws IllegalAccessException, InstantiationException, IOException { <line2> Class calcClass = <line3> loader.parseClass(new File(""src/main/groovy/com/baeldung/"", ""CalcMath.groovy"")); <line4> GroovyObject calc = (GroovyObject) calcClass.newInstance(); <line5> Object result = calc.invokeMethod(""calcSum"", new Object[] {x + 14, y + 14}); <line6> } <line7> } <line8> "	 <line6>	Yes
public class A { <line0> @Override <line1> public CPDefinitionSpecificationOptionValue findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchCPDefinitionSpecificationOptionValueException { <line3> CPDefinitionSpecificationOptionValue cpDefinitionSpecificationOptionValue = <line4> fetchByPrimaryKey(primaryKey); <line5> if (cpDefinitionSpecificationOptionValue == null) { <line6> if (_log.isDebugEnabled()) { <line7> } <line8> throw new NoSuchCPDefinitionSpecificationOptionValueException( <line9> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return cpDefinitionSpecificationOptionValue; <line12> } <line13> } <line14> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public void applyInTx() { <line2> iterateWithCommit( <line3> getGraph().getVertices(""@class"", ""NodeImpl""), <line4> vertex -> { <line5> Set<String> parents = new HashSet<>(); <line6> Set<String> branchParents = new HashSet<>(); <line7> for (Edge edge : vertex.getEdges(Direction.OUT, ""HAS_PARENT_NODE"")) { <line8> String parentUuid = edge.getVertex(Direction.IN).getProperty(""uuid""); <line9> String branchUuid = edge.getProperty(""branchUuid""); <line10> if (branchUuid == null) { <line11> continue; <line12> } <line13> parents.add(parentUuid); <line14> branchParents.add(branchParentEntry(branchUuid, parentUuid).encode()); <line15> edge.remove(); <line16> } <line17> vertex.setProperty(PARENTS_KEY_PROPERTY, parents); <line18> vertex.setProperty(BRANCH_PARENTS_KEY_PROPERTY, branchParents); <line19> }); <line20> } <line21> } <line22> "	 <line9>	No
public class A { <line0> private void sendTypeToPool(PdxType type, int id, Pool pool) { <line1> try { <line2> AddPDXTypeOp.execute((ExecutablePool) pool, id, type); <line3> } catch (ServerConnectivityException serverConnectivityException) { <line4> throw serverConnectivityException; <line5> } <line6> } <line7> } <line8> 	 <line7>	No
"public class A { <line0> @Test <line1> public void testTargetMappingUpdatesAfterRebind() throws Exception { <line2> Iterable<StubAppServer> members = Iterables.filter(cluster.getChildren(), StubAppServer.class); <line3> assertExpectedTargetsEventually(members); <line4> Assert.assertTrue( <line5> mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations()))); <line6> rebind(); <line7> Assert.assertTrue( <line8> mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations())), <line9> ""location not managed after rebind""); <line10> Iterable<StubAppServer> members2 = Iterables.filter(cluster.getChildren(), StubAppServer.class); <line11> StubAppServer target1 = Iterables.get(members2, 0); <line12> StubAppServer target2 = Iterables.get(members2, 1); <line13> assertExpectedTargetsEventually(ImmutableSet.of(target1, target2)); <line14> Integer result = cluster.resize(3); <line15> Assert.assertTrue( <line16> mgmt().getLocationManager().isManaged(Iterables.getOnlyElement(cluster.getLocations()))); <line17> HashSet<StubAppServer> newEntities = <line18> Sets.newHashSet(Iterables.filter(cluster.getChildren(), StubAppServer.class)); <line19> newEntities.remove(target1); <line20> newEntities.remove(target2); <line21> StubAppServer target3 = Iterables.getOnlyElement(newEntities); <line22> assertExpectedTargetsEventually(ImmutableSet.of(target1, target2, target3)); <line23> target1.sensors().set(StubAppServer.SERVICE_UP, false); <line24> assertExpectedTargetsEventually(ImmutableSet.of(target2, target3)); <line25> Entities.unmanage(target2); <line26> assertExpectedTargetsEventually(ImmutableSet.of(target3)); <line27> } <line28> } <line29> "	 <line9>	No
"public class A { <line0> public ReturnValue packageBundleToS3(File bundlePath, String bundleOutputPrefix) { <line1> ReturnValue ret = new ReturnValue(); <line2> ret.setExitStatus(ReturnValue.SUCCESS); <line3> if (bundlePath == null || !bundlePath.isDirectory()) { <line4> ret.setExitStatus(ReturnValue.INVALIDFILE); <line5> ret.setStderr( <line6> ""ERROR: the bundle path you're trying to zip up is either null or not a directory!""); <line7> return ret; <line8> } <line9> File tempDir = null; <line10> try { <line11> tempDir = <line12> FileTools.createDirectoryWithUniqueName(new File(this.bundleDir), ""wokflow_zip_temp""); <line13> } catch (Exception e) { <line14> ret.setExitStatus(ReturnValue.FAILURE); <line15> return ret; <line16> } <line17> boolean compression = true; <line18> Map<String, String> settings = ConfigTools.getSettings(); <line19> if (settings.containsKey(SqwKeys.BUNDLE_COMPRESSION.getSettingKey()) <line20> && settings.get(SqwKeys.BUNDLE_COMPRESSION.getSettingKey()).equals(""OFF"")) { <line21> compression = false; <line22> } <line23> if (!FileTools.zipDirectoryRecursive( <line24> bundlePath, <line25> new File(tempDir.getAbsolutePath() + File.separator + bundlePath.getName() + "".zip""), <line26> compression)) { <line27> ret.setExitStatus(ReturnValue.FAILURE); <line28> } <line29> String zipFile = tempDir.getAbsolutePath() + File.separator + bundlePath.getName() + "".zip""; <line30> ProvisionFilesUtil fileUtil = new ProvisionFilesUtil(); <line31> int bufLen = 5000 * 1024; <line32> Log.stdout( <line33> ""Copying local file "" <line34> + zipFile <line35> + "" to output "" <line36> + bundleOutputPrefix <line37> + "" this may take a long time!""); <line38> BufferedInputStream reader = fileUtil.getSourceReader(zipFile, bufLen, 0L); <line39> boolean result = fileUtil.putToS3(reader, bundleOutputPrefix, false); <line40> if (!result) { <line41> ret.setExitStatus(ReturnValue.FAILURE); <line42> return ret; <line43> } <line44> this.outputZip = bundleOutputPrefix + File.separator + bundlePath.getName() + "".zip""; <line45> if (bundleOutputPrefix.endsWith(File.separator)) { <line46> this.outputZip = bundleOutputPrefix + bundlePath.getName() + "".zip""; <line47> } <line48> Log.stdout(""Finished copying file to S3!""); <line49> Log.stdout(""You should delete (or archive locally) the local zip file: "" + zipFile); <line50> return ret; <line51> } <line52> } <line53> "	 <line45>	No
public class A { <line0> private void executeOrMerge() { <line1> int size = queueSize.incrementAndGet(); <line2> if (size > maxThreads) { <line3> return; <line4> } <line5> do { <line6> try { <line7> queue.poll().run(); <line8> } catch (Throwable e) { <line9> } <line10> } while (queueSize.getAndDecrement() > maxThreads); <line11> } <line12> } <line13> 	 <line9>	Yes
public class A { <line0> private TransactionalDataSource createShardDatasource(Long shardId, DbVersion dbVersion) { <line1> long start = System.currentTimeMillis(); <line2> waitAvailability(); <line3> ShardDataSourceCreateHelper shardDataSourceCreateHelper = <line4> new ShardDataSourceCreateHelper(this, shardId).createUninitializedDataSource(); <line5> TransactionalDataSource shardDb = shardDataSourceCreateHelper.getShardDb(); <line6> shardDb.init(dbVersion); <line7> connectedShardDataSourceMap.put(shardId, shardDb); <line8> return shardDb; <line9> } <line10> } <line11> 	 <line8>	Yes
public class A { <line0> public String identify(byte[] payload) { <line1> String tikaType = MediaType.OCTET_STREAM.toString(); <line2> Metadata md = new Metadata(); <line3> TikaInputStream tis = null; <line4> try { <line5> tis = TikaInputStream.get(payload, md); <line6> tikaType = pika.getDetector().detect(tis, md).toString(); <line7> } catch (Throwable e) { <line8> return MediaType.OCTET_STREAM.toString(); <line9> } finally { <line10> if (tis != null) { <line11> try { <line12> tis.close(); <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> try { <line18> md.set(Metadata.CONTENT_TYPE, tikaType.toString()); <line19> pika.setRecursive(ctx, false); <line20> ch = new WriteOutContentHandler(MAX_BUF); <line21> InputStream tikainput = TikaInputStream.get(payload, md); <line22> ParseRunner runner = new ParseRunner(pika, tikainput, ch, md, ctx); <line23> Thread parseThread = new Thread(runner, Long.toString(System.currentTimeMillis())); <line24> parseThread.setDaemon(true); <line25> try { <line26> parseThread.start(); <line27> parseThread.join(this.parseTimeout); <line28> parseThread.interrupt(); <line29> } catch (OutOfMemoryError o) { <line30> } catch (RuntimeException r) { <line31> } finally { <line32> if (tikainput != null) { <line33> try { <line34> tikainput.close(); <line35> } catch (IOException e) { <line36> } <line37> } <line38> } <line39> String extMimeType = md.get(PreservationParser.EXT_MIME_TYPE); <line40> if (runner.complete && extMimeType != null) tikaType = extMimeType; <line41> } catch (Throwable e) { <line42> } <line43> return tikaType; <line44> } <line45> } <line46> 	 <line14>	Yes
"public class A { <line0> @Test <line1> public void testBlackListMultiValueIncluded() throws Exception { <line2> String cont = ""'europe'""; <line3> String state = ""'mississippi'""; <line4> for (final TestCities city : TestCities.values()) { <line5> String query = <line6> CityField.CITY.name() <line7> + EQ_OP <line8> + ""'"" <line9> + city.name() <line10> + ""'"" <line11> + AND_OP <line12> + ""("" <line13> + CityField.CONTINENT.name() <line14> + EQ_OP <line15> + cont <line16> + OR_OP <line17> + CityField.STATE.name() <line18> + EQ_OP <line19> + state <line20> + "")""; <line21> final Set<String> fields = CityField.getRandomReturnFields(false); <line22> fields.remove(CityField.CITY.name()); <line23> runTest(query, false, false, fields); <line24> } <line25> } <line26> } <line27> "	 <line0>	No
public class A { <line0> @Override <line1> public void initialize() { <line2> try { <line3> CRS_BY_SRS_ID.put(WGS84_SRS_ID, WGS84); <line4> CoordinateReferenceSystem webMercatorCrs = <line5> CRS.decode(SpatialReferenceSystem.WEB_MERCATOR_SRS_ID); <line6> CRS_BY_SRS_ID.put(SpatialReferenceSystem.WEB_MERCATOR_SRS_ID, webMercatorCrs); <line7> getOrCreateTransform( <line8> SpatialReferenceSystem.WGS84_SRS_ID, SpatialReferenceSystem.WEB_MERCATOR_SRS_ID); <line9> getOrCreateTransform( <line10> SpatialReferenceSystem.WEB_MERCATOR_SRS_ID, SpatialReferenceSystem.WGS84_SRS_ID); <line11> } catch (Exception e) { <line12> throw new RuntimeException(e); <line13> } <line14> } <line15> } <line16> 	 <line1>	No
"public class A { <line0> public E create() { <line1> try { <line2> E entity = getController().getEntityClass().newInstance(); <line3> for (ParentFilter pf : this.getParentFilters()) { <line4> FormModel<?> parent = <line5> (FormModel<?>) this.getController().get(pf.getParentForm()).getModel(); <line6> List<?> records = parent.getRecords(); <line7> if (records.size() > 0) { <line8> Object value = ((Entity) records.get(0)).get(pf.getParentId()); <line9> if (!(value instanceof List<?>) && value != null) { <line10> entity.set(pf.getXrefToParent(), value); <line11> } <line12> for (String labelName : pf.getParentLabels()) { <line13> Object label = ((Entity) records.get(0)).get(labelName); <line14> entity.set(pf.getXrefToParent() + ""_"" + labelName, label); <line15> } <line16> } <line17> } <line18> return entity; <line19> } catch (Exception e) { <line20> e.printStackTrace(); <line21> } <line22> return null; <line23> } <line24> } <line25> "	 <line20>	Yes
public class A { <line0> private static void warningsForRemovedEndVars(Map<String, String> map) { <line1> if (map.containsKey(STRIMZI_DEFAULT_TLS_SIDECAR_KAFKA_IMAGE)) { <line2> } <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> private void sleepBetweenHostSkips(FailoverPolicy failoverPolicy) { <line1> if (failoverPolicy.sleepBetweenHostsMilli > 0) { <line2> if (log.isDebugEnabled()) { <line3> } <line4> try { <line5> Thread.sleep(failoverPolicy.sleepBetweenHostsMilli); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void addForward( <line2> long companyId, <line3> long userId, <line4> List<Filter> filters, <line5> List<String> emailAddresses, <line6> boolean leaveCopy) { <line7> if (_log.isDebugEnabled()) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public void onResponse(@NonNull Frame response) { <line2> stopNodeMessageTimer(); <line3> cancelTimeout(pageTimeout); <line4> lock.lock(); <line5> try { <line6> if (state < 0) { <line7> return; <line8> } <line9> try { <line10> Message responseMessage = response.message; <line11> if (responseMessage instanceof Result) { <line12> processResultResponse((Result) responseMessage, response); <line13> } else if (responseMessage instanceof Error) { <line14> processErrorResponse((Error) responseMessage); <line15> } else { <line16> IllegalStateException error = <line17> new IllegalStateException(""Unexpected response "" + responseMessage); <line18> trackNodeError(node, error); <line19> abort(error, false); <line20> } <line21> } catch (Throwable t) { <line22> trackNodeError(node, t); <line23> abort(t, false); <line24> } <line25> } finally { <line26> lock.unlock(); <line27> } <line28> } <line29> } <line30> "	 <line12>	Yes
"public class A { <line0> public String createFileName(Exchange exchange) { <line1> String answer; <line2> Object value; <line3> Object overrule = exchange.getIn().getHeader(Exchange.OVERRULE_FILE_NAME); <line4> if (overrule != null) { <line5> if (overrule instanceof Expression) { <line6> value = overrule; <line7> } else { <line8> value = <line9> exchange.getContext().getTypeConverter().convertTo(String.class, exchange, overrule); <line10> } <line11> } else { <line12> value = exchange.getIn().getHeader(Exchange.FILE_NAME); <line13> } <line14> if (overrule != null) { <line15> exchange.getIn().setHeader(Exchange.FILE_NAME, value); <line16> } <line17> if (value instanceof String && StringHelper.hasStartToken((String) value, ""simple"")) { <line18> } <line19> Expression expression = endpoint.getFileName(); <line20> if (value instanceof Expression) { <line21> expression = (Expression) value; <line22> } <line23> String name; <line24> if (expression != null) { <line25> name = expression.evaluate(exchange, String.class); <line26> } else { <line27> name = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value); <line28> } <line29> if (name != null && endpoint.isFlatten()) { <line30> int pos = Math.max(name.lastIndexOf('/'), name.lastIndexOf(""\\"")); <line31> if (pos != -1) { <line32> name = name.substring(pos + 1); <line33> } <line34> } <line35> String endpointPath = endpoint.getConfiguration().getDirectory(); <line36> String baseDir = """"; <line37> if (endpointPath.length() > 0) { <line38> baseDir = endpointPath; <line39> boolean trailingSlash = endpointPath.endsWith(""/"") || endpointPath.endsWith(""\\""); <line40> if (!trailingSlash) { <line41> baseDir += getFileSeparator(); <line42> } <line43> } <line44> if (name != null) { <line45> answer = baseDir + name; <line46> } else { <line47> answer = baseDir + endpoint.getGeneratedFileName(exchange.getIn()); <line48> } <line49> if (endpoint.isJailStartingDirectory()) { <line50> String compatchAnswer = FileUtil.compactPath(answer); <line51> String compatchBaseDir = FileUtil.compactPath(baseDir); <line52> if (!compatchAnswer.startsWith(compatchBaseDir)) { <line53> throw new IllegalArgumentException( <line54> ""Cannot write file with name: "" <line55> + compatchAnswer <line56> + "" as the filename is jailed to the starting directory: "" <line57> + compatchBaseDir); <line58> } <line59> } <line60> if (endpoint.getConfiguration().needToNormalize()) { <line61> answer = normalizePath(answer); <line62> } <line63> return answer; <line64> } <line65> } <line66> "	 <line25>	Yes
public class A { <line0> @PermitAll <line1> @Override <line2> public void runAs(Session userSession, final Callable action) { <line3> if (userSession != null) { <line4> Subject.doAs( <line5> userSession.getSubject(), <line6> new PrivilegedAction<Void>() { <line7> @Override <line8> public Void run() { <line9> try { <line10> action.call(); <line11> } catch (Exception ex) { <line12> } <line13> return null; <line14> } <line15> }); <line16> } <line17> } <line18> } <line19> 	 <line12>	Yes
public class A { <line0> private static void deleteAllTopics(EmbeddedKafkaCluster cluster) throws Exception { <line1> try (final Admin adminClient = cluster.createAdminClient()) { <line2> Set<String> topicsToBeDeleted = adminClient.listTopics().names().get(); <line3> } <line4> } <line5> } <line6> 	 <line3>	Yes
public class A { <line0> public void close() { <line1> setClosing(); <line2> timeoutScheduler.shutdownNow(); <line3> executor.shutdownNow(); <line4> try { <line5> parserThread.interrupt(); <line6> parserThread.join(); <line7> } catch (InterruptedException e) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
public class A { <line0> @Override <line1> public void setHeader(HttpRequest httpRequest, String name, String value) { <line2> final HttpHeaders headers = httpRequest.headers(); <line3> if (headers != null) { <line4> headers.set(name, value); <line5> if (isDebug) { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line5>	No
"public class A { <line0> protected XyzResponse processHealthCheckEventImpl(HealthCheckEvent event) throws SQLException { <line1> String connectorId = traceItem.getConnectorId(); <line2> if (connectorId == null) { <line3> return new ErrorResponse() <line4> .withError(XyzError.ILLEGAL_ARGUMENT) <line5> .withErrorMessage(""ConnectorId is missing as param in the Connector-Config! ""); <line6> } <line7> if (event.getWarmupCount() == 0) { <line8> SQLQuery query = new SQLQuery(""SELECT 1""); <line9> if (event.getMinResponseTime() != 0) { <line10> dbMaintainer.run(traceItem); <line11> return new HealthStatus().withStatus(""OK""); <line12> } <line13> executeQuery(query, (rs) -> null, dataSource); <line14> if (dataSource != readDataSource) { <line15> executeQuery(query, (rs) -> null, readDataSource); <line16> } <line17> } <line18> return ((HealthStatus) super.processHealthCheckEvent(event)).withStatus(""OK""); <line19> } <line20> } <line21> "	 <line9>	No
"public class A { <line0> @SuppressWarnings(""unused"") <line1> private void testScanRaw(String msg) throws IOException { <line2> long t = System.currentTimeMillis(); <line3> IGTScanner scan = <line4> simpleStore.scan( <line5> new GTScanRequestBuilder() <line6> .setInfo(info) <line7> .setRanges(null) <line8> .setDimensions(null) <line9> .setFilterPushDown(null) <line10> .createGTScanRequest()); <line11> ResultScanner innerScanner = ((SimpleHBaseStore.Reader) scan).getHBaseScanner(); <line12> int count = 0; <line13> for (Result r : innerScanner) { <line14> count++; <line15> } <line16> scan.close(); <line17> t = System.currentTimeMillis() - t; <line18> } <line19> } <line20> "	 <line18>	Yes
"public class A { <line0> private void exportData(OutputStream outputStream, int entityDefId) <line1> throws InvalidExpressionException, IOException, RecordPersistenceException { <line2> CSVDataExportColumnProviderGenerator csvDataExportColumnProviderGenerator = <line3> new CSVDataExportColumnProviderGenerator(recordFilter.getSurvey(), configuration); <line4> DataTransformation transform = <line5> csvDataExportColumnProviderGenerator.generateDataTransformation(entityDefId); <line6> @SuppressWarnings(""resource"") <line7> ModelCsvWriter modelWriter = new ModelCsvWriter(outputStream, transform); <line8> modelWriter.printColumnHeadings(); <line9> CollectSurvey survey = recordFilter.getSurvey(); <line10> Step step = recordFilter.getStepGreaterOrEqual(); <line11> List<CollectRecordSummary> summaries = recordManager.loadSummaries(recordFilter); <line12> for (CollectRecordSummary s : summaries) { <line13> if (status.isRunning()) { <line14> try { <line15> CollectRecord record = recordManager.load(survey, s.getId(), step, false); <line16> modelWriter.printData(record); <line17> } catch (Exception e) { <line18> } <line19> status.incrementProcessed(); <line20> } else { <line21> break; <line22> } <line23> } <line24> modelWriter.flush(); <line25> } <line26> } <line27> "	 <line21>	No
"public class A { <line0> public void updateBeaconAdvertisingInterval(Integer min, Integer max, String interfaceName) <line1> throws KuraBluetoothCommandException { <line2> checkInterval(min, max); <line3> String[] minHex = String.format(""%04X"", min).split(TWO_CHAR_REGEX); <line4> String[] maxHex = String.format(""%04X"", max).split(TWO_CHAR_REGEX); <line5> String[] cmd = { <line6> CMD, <line7> OGF_CONTROLLER_CMD, <line8> OCF_ADVERTISING_PARAM_CMD, <line9> minHex[1], <line10> minHex[0], <line11> maxHex[1], <line12> maxHex[0], <line13> ""03"", <line14> ""00"", <line15> ""00"", <line16> ""00"", <line17> ""00"", <line18> ""00"", <line19> ""00"", <line20> ""00"", <line21> ""00"", <line22> ""07"", <line23> ""00"" <line24> }; <line25> try { <line26> execHcitool(interfaceName, cmd); <line27> } catch (IOException e) { <line28> throw new KuraBluetoothCommandException( <line29> e, ""Update bluetooth beacon advertising interval failed""); <line30> } <line31> } <line32> } <line33> "	 <line25>	Yes
public class A { <line0> public void onSendAuthenticationInfoResponse(SendAuthenticationInfoResponse ind) { <line1> TestEvent te; <line2> if (ind.getMapProtocolVersion() >= 3) { <line3> te = TestEvent.createReceivedEvent(EventType.SendAuthenticationInfoResp_V3, ind, sequence++); <line4> } else { <line5> te = TestEvent.createReceivedEvent(EventType.SendAuthenticationInfoResp_V2, ind, sequence++); <line6> } <line7> this.observerdEvents.add(te); <line8> } <line9> } <line10> 	 <line4>	No
"public class A { <line0> public void process(Exchange exchange) throws Exception { <line1> if (""ExchangeTimedOutException"".equals(exchange.getIn().getBody(String.class))) { <line2> throw new ExchangeTimedOutException(exchange, 1); <line3> } else if (""Exception"".equals(exchange.getIn().getBody(String.class))) { <line4> throw new Exception(); <line5> } <line6> } <line7> } <line8> "	 <line1>	Yes
public class A { <line0> @Override <line1> public void onEdgeEventUpdate(TenantId tenantId, EdgeId edgeId) { <line2> EdgeEventUpdateMsg msg = new EdgeEventUpdateMsg(tenantId, edgeId); <line3> byte[] msgBytes = encodingService.encode(msg); <line4> TbQueueProducer<TbProtoQueueMsg<ToCoreNotificationMsg>> toCoreNfProducer = <line5> producerProvider.getTbCoreNotificationsMsgProducer(); <line6> Set<String> tbCoreServices = partitionService.getAllServiceIds(ServiceType.TB_CORE); <line7> for (String serviceId : tbCoreServices) { <line8> TopicPartitionInfo tpi = <line9> partitionService.getNotificationsTopic(ServiceType.TB_CORE, serviceId); <line10> ToCoreNotificationMsg toCoreMsg = <line11> ToCoreNotificationMsg.newBuilder() <line12> .setEdgeEventUpdateMsg(ByteString.copyFrom(msgBytes)) <line13> .build(); <line14> toCoreNfProducer.send(tpi, new TbProtoQueueMsg<>(msg.getEdgeId().getId(), toCoreMsg), null); <line15> toCoreNfs.incrementAndGet(); <line16> } <line17> } <line18> } <line19> 	 <line15>	No
"public class A { <line0> public Response describeRepository(Context context, boolean xml) throws ServerException { <line1> RepositoryInfo repositoryInfo = null; <line2> try { <line3> repositoryInfo = m_access.describeRepository(context); <line4> if (repositoryInfo != null) { <line5> ReposInfoSerializer result = new ReposInfoSerializer(context, repositoryInfo); <line6> if (xml) { <line7> return Response.ok(result, CONTENT_TYPE_XML).build(); <line8> } else { <line9> return Response.ok(new HtmlTransformation(context, result), CONTENT_TYPE_HTML).build(); <line10> } <line11> } else { <line12> return Response.noContent().build(); <line13> } <line14> } catch (AuthzException ae) { <line15> throw ae; <line16> } catch (Throwable th) { <line17> String msg = ""Error describing repository""; <line18> throw new GeneralException(msg, th); <line19> } <line20> } <line21> } <line22> "	 <line12>	Yes
public class A { <line0> protected void stopExecutingAsyncJobs() { <line1> if (executorService != null) { <line2> executorService.shutdown(); <line3> try { <line4> if (!executorService.awaitTermination(secondsToWaitOnShutdown, TimeUnit.SECONDS)) { <line5> } <line6> } catch (InterruptedException e) { <line7> } <line8> executorService = null; <line9> } <line10> } <line11> } <line12> 	 <line5>	Yes
public class A { <line0> private void maybeRefreshSchemaAndSignal( <line1> final Connection connection, <line2> final DefaultResultSetFuture future, <line3> final ResultSet rs, <line4> final SchemaElement targetType, <line5> final String targetKeyspace, <line6> final String targetName) { <line7> final boolean refreshSchema = (targetKeyspace != null); <line8> executor.submit( <line9> new Runnable() { <line10> @Override <line11> public void run() { <line12> boolean schemaInAgreement = false; <line13> try { <line14> schemaInAgreement = <line15> ControlConnection.waitForSchemaAgreement(connection, Manager.this); <line16> if (!schemaInAgreement) <line17> if (refreshSchema) <line18> ControlConnection.refreshSchema( <line19> connection, targetType, targetKeyspace, targetName, Manager.this, false); <line20> } catch (Exception e) { <line21> if (refreshSchema) { <line22> submitSchemaRefresh(targetType, targetKeyspace, targetName); <line23> } else { <line24> } <line25> } finally { <line26> rs.getExecutionInfo().setSchemaInAgreement(schemaInAgreement); <line27> future.setResult(rs); <line28> } <line29> } <line30> }); <line31> } <line32> } <line33> 	 <line0>	No
"public class A { <line0> @Override <line1> public void save(Note note, AuthenticationInfo subject) throws IOException { <line2> if (note == null || !isSubjectValid(subject)) { <line3> throw new IOException(""Zeppelinhub failed to save note""); <line4> } <line5> String jsonNote = GSON.toJson(note); <line6> String token = getUserToken(subject.getUser()); <line7> restApiClient.put(token, jsonNote); <line8> } <line9> } <line10> "	 <line4>	No
"public class A { <line0> private FunctionInvocationWrapper functionFromExpression(String routingExpression, Object input) { <line1> Expression expression = spelParser.parseExpression(routingExpression); <line2> String functionName = expression.getValue(this.evalContext, input, String.class); <line3> Assert.hasText( <line4> functionName, <line5> ""Failed to resolve function name based on routing expression '"" <line6> + functionProperties.getRoutingExpression() <line7> + ""'""); <line8> FunctionInvocationWrapper function = functionCatalog.lookup(functionName); <line9> Assert.notNull( <line10> function, <line11> ""Failed to lookup function to route to based on the expression '"" <line12> + functionProperties.getRoutingExpression() <line13> + ""' whcih resolved to '"" <line14> + functionName <line15> + ""' function name.""); <line16> if (logger.isInfoEnabled()) { <line17> } <line18> return function; <line19> } <line20> } <line21> "	 <line17>	Yes
public class A { <line0> @Override <line1> protected void learnAxioms() { <line2> int modalDepth = MaximumModalDepthDetector.getMaxModalDepth(pattern); <line3> modalDepth++; <line4> Model fragment = fragmentExtractor.extractFragment(cls, modalDepth); <line5> Set<OWLAxiom> instantiations = <line6> applyPattern(pattern, dataFactory.getOWLClass(IRI.create(cls.toStringID())), fragment); <line7> for (OWLAxiom instantiation : instantiations) { <line8> System.out.println(instantiation); <line9> } <line10> } <line11> } <line12> 	 <line6>	No
public class A { <line0> private void writeSrcDoc(PullStrategy strat, Resource doc) throws IOException { <line1> if (!getOpts().isDryRun()) { <line2> strat.writeSrcFile(doc); <line3> } else { <line4> } <line5> } <line6> } <line7> 	 <line0>	No
"public class A { <line0> @POST <line1> @Timed <line2> @Consumes(MediaType.APPLICATION_JSON) <line3> @Produces(MediaType.APPLICATION_JSON) <line4> @ApiOperation(value = ""Add a static field to an input"") <line5> @ApiResponses( <line6> value = { <line7> @ApiResponse(code = 404, message = ""No such input on this node.""), <line8> @ApiResponse(code = 400, message = ""Field/Key is reserved.""), <line9> @ApiResponse(code = 400, message = ""Missing or invalid configuration."") <line10> }) <line11> @AuditEvent(type = AuditEventTypes.STATIC_FIELD_CREATE) <line12> public Response create( <line13> @ApiParam(name = ""inputId"", required = true) @PathParam(""inputId"") String inputId, <line14> @ApiParam(name = ""JSON body"", required = true) @Valid @NotNull CreateStaticFieldRequest csfr) <line15> throws NotFoundException, ValidationException { <line16> checkPermission(RestPermissions.INPUTS_EDIT, inputId); <line17> final MessageInput input = persistedInputs.get(inputId); <line18> if (input == null) { <line19> final String msg = ""Input <"" + inputId + ""> not found.""; <line20> LOG.error(msg); <line21> throw new javax.ws.rs.NotFoundException(msg); <line22> } <line23> if (!Message.validKey(csfr.key())) { <line24> final String msg = ""Invalid key: ["" + csfr.key() + ""]""; <line25> throw new BadRequestException(msg); <line26> } <line27> if (Message.RESERVED_FIELDS.contains(csfr.key()) <line28> && !Message.RESERVED_SETTABLE_FIELDS.contains(csfr.key())) { <line29> final String message = ""Cannot add static field. Field ["" + csfr.key() + ""] is reserved.""; <line30> throw new BadRequestException(message); <line31> } <line32> input.addStaticField(csfr.key(), csfr.value()); <line33> final Input mongoInput = inputService.find(input.getPersistId()); <line34> inputService.addStaticField(mongoInput, csfr.key(), csfr.value()); <line35> final String msg = ""Added static field ["" + csfr.key() + ""] to input <"" + inputId + "">.""; <line36> activityWriter.write(new Activity(msg, StaticFieldsResource.class)); <line37> final URI inputUri = <line38> getUriBuilderToSelf() <line39> .path(InputsResource.class) <line40> .path(""{inputId}"") <line41> .build(mongoInput.getId()); <line42> return Response.created(inputUri).build(); <line43> } <line44> } <line45> "	 <line22>	No
public class A { <line0> @Override <line1> protected void doGet(final HttpServletRequest request, final HttpServletResponse response) <line2> throws ServletException, IOException { <line3> try { <line4> response.sendRedirect(StringExtensions.combinePath(request.getContextPath(), redirectTo)); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
public class A { <line0> public KeyLookupResult getLookupResult() { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> HoodieBaseFile dataFile = getLatestDataFile(); <line4> List<String> matchingKeys = <line5> checkCandidatesAgainstFile( <line6> hoodieTable.getHadoopConf(), candidateRecordKeys, new Path(dataFile.getPath())); <line7> return new KeyLookupResult( <line8> partitionPathFilePair.getRight(), <line9> partitionPathFilePair.getLeft(), <line10> dataFile.getCommitTime(), <line11> matchingKeys); <line12> } <line13> } <line14> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void doFilter( <line2> ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) <line3> throws IOException, ServletException { <line4> HttpServletRequest request = (HttpServletRequest) servletRequest; <line5> HttpServletResponse response = (HttpServletResponse) servletResponse; <line6> boolean redirectForLogin = fetchTokenIfCodeIsPresent(request); <line7> Object accessToken = request.getSession(true).getAttribute(""access_token""); <line8> if (accessToken == null) { <line9> if (redirectForLogin) { <line10> redirectToLogin(request, response); <line11> } else { <line12> response.setContentType(""text/html;charset=utf-8""); <line13> PrintWriter pw = response.getWriter(); <line14> pw.println(""<h3>Login failed.</h3>""); <line15> } <line16> } else { <line17> filterChain.doFilter(servletRequest, servletResponse); <line18> } <line19> } <line20> } <line21> "	 <line16>	No
public class A { <line0> @Override <line1> public void initializeState(FunctionInitializationContext context) throws Exception { <line2> TypeInformation<Tuple2<StreamShardMetadata, SequenceNumber>> shardsStateTypeInfo = <line3> new TupleTypeInfo<>( <line4> TypeInformation.of(StreamShardMetadata.class), <line5> TypeInformation.of(SequenceNumber.class)); <line6> sequenceNumsStateForCheckpoint = <line7> context <line8> .getOperatorStateStore() <line9> .getUnionListState( <line10> new ListStateDescriptor<>(sequenceNumsStateStoreName, shardsStateTypeInfo)); <line11> if (context.isRestored()) { <line12> if (sequenceNumsToRestore == null) { <line13> sequenceNumsToRestore = new HashMap<>(); <line14> for (Tuple2<StreamShardMetadata, SequenceNumber> kinesisSequenceNumber : <line15> sequenceNumsStateForCheckpoint.get()) { <line16> sequenceNumsToRestore.put( <line17> new StreamShardMetadata.EquivalenceWrapper(kinesisSequenceNumber.f0), <line18> kinesisSequenceNumber.f1); <line19> } <line20> } <line21> } else { <line22> } <line23> } <line24> } <line25> 	 <line20>	Yes
public class A { <line0> private void logError(String message, Throwable t) { <line1> if (t instanceof GemFireSecurityException) { <line2> } else { <line3> } <line4> } <line5> } <line6> 	 <line1>	No
public class A { <line0> @Override <line1> public void onSuccess(Command request, Command responseCommand) { <line2> if (!(request.getPayload() instanceof VoteRequest)) { <line3> return; <line4> } <line5> VoteRequest voteRequest = (VoteRequest) request.getPayload(); <line6> if (currentTerm != term) { <line7> return; <line8> } <line9> try { <line10> if (voteRequest.isPreVote()) { <line11> handlePreVoteResponse(responseCommand); <line12> } else { <line13> handleVoteResponse(responseCommand); <line14> } <line15> } catch (Throwable t) { <line16> } <line17> } <line18> } <line19> 	 <line16>	Yes
public class A { <line0> protected Iterable<? extends Node> execute(Iterable<String> toGet) { <line1> Iterable<? extends Node> nodes = <line2> transform( <line3> toGet, <line4> new Function<String, Node>() { <line5> @Override <line6> public Node apply(final String input) { <line7> return api.getNode(input); <line8> } <line9> }); <line10> return nodes; <line11> } <line12> } <line13> 	 <line1>	No
"public class A { <line0> @Beta <line1> @Override <line2> public <T> T modify(AttributeSensor<T> attribute, Function<? super T, Maybe<T>> modifier) { <line3> if (LOG.isTraceEnabled()) <line4> if (Boolean.TRUE.equals(getManagementSupport().isReadOnlyRaw())) { <line5> String message = <line6> AbstractEntity.this <line7> + "" modifying "" <line8> + attribute <line9> + "" = "" <line10> + modifier <line11> + "" in read only mode; will have very little effect""; <line12> if (!getManagementSupport().isDeployed()) { <line13> if (getManagementSupport().wasDeployed()) message += "" (no longer deployed)""; <line14> else message += "" (not yet deployed)""; <line15> } <line16> if (WARNED_READ_ONLY_ATTRIBUTES.add(attribute.getName())) { <line17> } else if (LOG.isTraceEnabled()) { <line18> } <line19> } <line20> return Locks.withLock( <line21> getLockInternal(), <line22> () -> { <line23> T result = attributesInternal.modify(attribute, modifier); <line24> if (result == null) { <line25> entityType.addSensorIfAbsent(attribute); <line26> } <line27> getManagementSupport().getEntityChangeListener().onAttributeChanged(attribute); <line28> return result; <line29> }); <line30> } <line31> } <line32> "	 <line14>	No
public class A { <line0> @Test(enabled = true) <line1> public void testExecutePassingUniqueOptionToHillClimb() { <line2> optimizer = new Optimizer(TestConstants.NUM_PLANS_TO_GENERATE, SearchMethodName.HILLCLIMB); <line3> executeAndSave(appModel, suitableCloudOffer, SearchMethodName.HILLCLIMB); <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> private GetRouterMonitorResultsAnswer parseLinesForHealthChecks( <line1> GetRouterMonitorResultsCommand cmd, String executionResult) { <line2> List<String> failingChecks = new ArrayList<>(); <line3> StringBuilder monitorResults = new StringBuilder(); <line4> String[] lines = executionResult.trim().split(""\n""); <line5> boolean readingFailedChecks = false, readingMonitorResults = false; <line6> for (String line : lines) { <line7> line = line.trim(); <line8> if (line.contains(""FAILING CHECKS"")) { <line9> readingFailedChecks = true; <line10> readingMonitorResults = false; <line11> } else if (line.contains(""MONITOR RESULTS"")) { <line12> readingFailedChecks = false; <line13> readingMonitorResults = true; <line14> } else if (readingFailedChecks && !readingMonitorResults) { <line15> failingChecks.addAll(getFailingChecks(line)); <line16> } else if (!readingFailedChecks && readingMonitorResults) { <line17> monitorResults.append(line); <line18> } else { <line19> } <line20> } <line21> return new GetRouterMonitorResultsAnswer(cmd, true, failingChecks, monitorResults.toString()); <line22> } <line23> } <line24> "	 <line19>	Yes
public class A { <line0> public static <T> T newExtension(Class<T> clazz) { <line1> ServiceLoader<T> serviceLoader = ServiceLoader.load(clazz); <line2> for (T service : serviceLoader) { <line3> return service; <line4> } <line5> return null; <line6> } <line7> } <line8> 	 <line2>	No
public class A { <line0> private Bundle getOwnerBundle(ServletContext context) { <line1> if (context instanceof OsgiServletContext) { <line2> return ((OsgiServletContext) context).getOsgiContextModel().getOwnerBundle(); <line3> } <line4> Object attribute = context.getAttribute(PaxWebConstants.CONTEXT_PARAM_BUNDLE_CONTEXT); <line5> if (attribute instanceof BundleContext) { <line6> return ((BundleContext) attribute).getBundle(); <line7> } <line8> if (attribute != null) { <line9> } <line10> return null; <line11> } <line12> } <line13> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void onAuthenticationSuccess( <line2> HttpServletRequest request, HttpServletResponse response, Authentication authentication) <line3> throws IOException, ServletException { <line4> String userId = authentication.getName(); <line5> Cookie newCookie = basicLoginService.createNewCookie(userId); <line6> response.addCookie(newCookie); <line7> response.setStatus(HttpStatus.OK.value()); <line8> response.setContentType(MediaType.APPLICATION_JSON_VALUE); <line9> response.sendRedirect(BasicLoginConstants.URI_MAIN); <line10> return; <line11> } <line12> } <line13> 	 <line0>	No
"public class A { <line0> @Override <line1> public DexOrder findCounterOffer(DexOrder createdOrder) { <line2> OrderType counterOrderType = createdOrder.getType().isBuy() ? OrderType.SELL : OrderType.BUY; <line3> String orderBy = createdOrder.getType().isSell() ? ""DESC"" : ""ASC""; <line4> Integer currentTime = timeService.getEpochTime(); <line5> BigDecimal offerAmount = new BigDecimal(createdOrder.getOrderAmount()); <line6> Integer pairCurrency = DexCurrency.getValue(createdOrder.getPairCurrency()); <line7> BigDecimal pairRate = new BigDecimal(EthUtil.ethToGwei(createdOrder.getPairRate())); <line8> DexOrderDBMatchingRequest dexOrderDBMatchingRequest = <line9> new DexOrderDBMatchingRequest( <line10> counterOrderType, <line11> currentTime, <line12> 0, <line13> offerAmount, <line14> pairCurrency.intValue(), <line15> pairRate, <line16> orderBy); <line17> List<DexOrder> orders = <line18> dexMatchingService.getOffersForMatching(dexOrderDBMatchingRequest, orderBy); <line19> List<DexOrder> filteredOrders = <line20> orders.stream() <line21> .filter(order -> !order.getAccountId().equals(createdOrder.getAccountId())) <line22> .collect(Collectors.toList()); <line23> for (DexOrder counterOffer : filteredOrders) { <line24> try { <line25> if (validateOffer(createdOrder, counterOffer) == OFFER_VALIDATE_OK) { <line26> return counterOffer; <line27> } <line28> } catch (Exception ex) { <line29> } <line30> } <line31> return null; <line32> } <line33> } <line34> "	 <line4>	No
"public class A { <line0> private void testNoteCreate(String noteName) throws IOException { <line1> String jsonRequest = ""{\""name\"":\"""" + noteName + ""\""}""; <line2> CloseableHttpResponse post = httpPost(""/notebook/"", jsonRequest); <line3> String postResponse = EntityUtils.toString(post.getEntity(), StandardCharsets.UTF_8); <line4> assertThat(""test note create method:"", post, isAllowed()); <line5> Map<String, Object> resp = <line6> gson.fromJson(postResponse, new TypeToken<Map<String, Object>>() {}.getType()); <line7> String newNoteId = (String) resp.get(""body""); <line8> Note newNote = TestUtils.getInstance(Notebook.class).getNote(newNoteId); <line9> assertNotNull(""Can not find new note by id"", newNote); <line10> String newNoteName = newNote.getName(); <line11> if (StringUtils.isBlank(noteName)) { <line12> noteName = ""Untitled Note""; <line13> } <line14> assertEquals(""compare note name"", noteName, newNoteName); <line15> TestUtils.getInstance(Notebook.class).removeNote(newNote, anonymous); <line16> post.close(); <line17> } <line18> } <line19> "	 <line11>	Yes
public class A { <line0> @Override <line1> public void process( <line2> AccessProcessor ap, TaskAnalyser ta, DataInfoProvider dip, TaskDispatcher td) { <line3> FileInfo fileInfo = (FileInfo) dip.deleteData(this.app, this.loc, this.noReuse); <line4> if (fileInfo == null) { <line5> String filePath = this.loc.getURIs().get(0).getPath(); <line6> File f = new File(filePath); <line7> if (f.exists()) { <line8> if (f.delete()) { <line9> } else { <line10> } <line11> } <line12> } else { <line13> ta.deleteData(fileInfo); <line14> } <line15> this.sem.release(); <line16> } <line17> } <line18> 	 <line12>	No
public class A { <line0> private void reloadAllDataModel() throws IOException { <line1> ResourceStore store = getStore(); <line2> dataModelDescMap.clear(); <line3> List<String> paths = <line4> store.collectResourceRecursively( <line5> ResourceStore.DATA_MODEL_DESC_RESOURCE_ROOT, MetadataConstants.FILE_SURFIX); <line6> for (String path : paths) { <line7> try { <line8> reloadDataModelDescAt(path); <line9> } catch (IllegalStateException e) { <line10> continue; <line11> } <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
public class A { <line0> private KuraGPIOPin getPin( <line1> String resourceName, <line2> KuraGPIODirection resourceDirection, <line3> KuraGPIOMode resourceMode, <line4> KuraGPIOTrigger resourceTrigger) { <line5> KuraGPIOPin pin = null; <line6> for (GPIOService service : this.gpioServices) { <line7> pin = service.getPinByName(resourceName, resourceDirection, resourceMode, resourceTrigger); <line8> if (pin != null) { <line9> if (!pin.isOpen()) { <line10> try { <line11> pin.open(); <line12> } catch (KuraGPIODeviceException | KuraUnavailableDeviceException | IOException e) { <line13> } <line14> } <line15> break; <line16> } <line17> } <line18> return pin; <line19> } <line20> } <line21> 	 <line15>	No
public class A { <line0> private void sendEof() { <line1> eofAckCount++; <line2> if (eofAckCount >= EOF_ACK_LIMIT) { <line3> eofSenderFuture.cancel(false); <line4> } else { <line5> EofPacket eof = <line6> new EofPacket(ConditionCode.NO_ERROR, checksum, fileSize, null, directiveHeader); <line7> simulator.transmitCfdp(eof); <line8> } <line9> } <line10> } <line11> 	 <line4>	No
public class A { <line0> @Override <line1> protected void submitWith(HapiApiSpec spec, Transaction payment) throws Throwable { <line2> Query query = getContractRecordsQuery(spec, payment, false); <line3> response = <line4> spec.clients().getScSvcStub(targetNodeFor(spec), useTls).getTxRecordByContractID(query); <line5> List<TransactionRecord> records = response.getContractGetRecordsResponse().getRecordsList(); <line6> if (verboseLoggingOn) { <line7> if (customLog.isPresent()) { <line8> customLog.get().accept(log, records); <line9> } else { <line10> } <line11> } <line12> if (snapshotDirPath.isPresent()) { <line13> saveSnapshots(spec, records); <line14> } <line15> if (saveRecordNum.isPresent()) { <line16> spec.registry().saveIntValue(saveRecordNum.get(), records.size()); <line17> } <line18> if (expectationsDirPath.isPresent()) { <line19> checkExpectations(spec, records); <line20> } <line21> } <line22> } <line23> 	 <line13>	No
"public class A { <line0> private void onThingWithSerialNumber( <line1> final ThingTypeUID deviceType, <line2> final String deviceTypeName, <line3> final DeviceDTO device, <line4> final String name) { <line5> final String serialNumber = device.getSerialNumber(); <line6> ThingUID localBridgeUID = this.bridgeUID; <line7> if (localBridgeUID != null) { <line8> final Map<String, Object> properties = new HashMap<>(); <line9> DraytonWiserPropertyHelper.setPropertiesWithSerialNumber(device, properties); <line10> final DiscoveryResult discoveryResult = <line11> DiscoveryResultBuilder.create(new ThingUID(deviceType, localBridgeUID, serialNumber)) <line12> .withBridge(localBridgeUID) <line13> .withProperties(properties) <line14> .withRepresentationProperty(PROP_SERIAL_NUMBER) <line15> .withLabel((name.isEmpty() ? """" : (name + "" - "")) + deviceTypeName) <line16> .build(); <line17> thingDiscovered(discoveryResult); <line18> } <line19> } <line20> } <line21> "	 <line19>	No
"public class A { <line0> private void testAttributes() throws Exception { <line1> Device device = findDeviceByName(""Edge Device 1""); <line2> testAttributesUpdatedMsg(device); <line3> testPostAttributesMsg(device); <line4> testAttributesDeleteMsg(device); <line5> } <line6> } <line7> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void doLoadShedding() { <line2> long overloadThreshold = this.getLoadBalancerBrokerOverloadedThresholdPercentage(); <line3> long comfortLoadLevel = this.getLoadBalancerBrokerComfortLoadThresholdPercentage(); <line4> Map<ResourceUnit, String> namespaceBundlesToBeUnloaded = new HashMap<>(); <line5> synchronized (currentLoadReports) { <line6> for (Map.Entry<ResourceUnit, LoadReport> entry : currentLoadReports.entrySet()) { <line7> ResourceUnit overloadedRU = entry.getKey(); <line8> LoadReport lr = entry.getValue(); <line9> if (isAboveLoadLevel(lr.getSystemResourceUsage(), overloadThreshold)) { <line10> ResourceType bottleneckResourceType = lr.getBottleneckResourceType(); <line11> Map<String, NamespaceBundleStats> bundleStats = <line12> lr.getSortedBundleStats(bottleneckResourceType); <line13> if (bundleStats == null) { <line14> continue; <line15> } <line16> if (bundleStats.size() == 1) { <line17> String bundleName = lr.getBundleStats().keySet().iterator().next(); <line18> continue; <line19> } <line20> for (Map.Entry<String, NamespaceBundleStats> bundleStat : bundleStats.entrySet()) { <line21> String bundleName = bundleStat.getKey(); <line22> NamespaceBundleStats stats = bundleStat.getValue(); <line23> if (isBrokerAvailableForRebalancing(bundleStat.getKey(), comfortLoadLevel)) { <line24> namespaceBundlesToBeUnloaded.put(overloadedRU, bundleName); <line25> } else { <line26> } <line27> break; <line28> } <line29> } <line30> } <line31> } <line32> unloadNamespacesFromOverLoadedBrokers(namespaceBundlesToBeUnloaded); <line33> } <line34> } <line35> 	 <line26>	Yes
public class A { <line0> public List<Template> findAllTemplates() { <line1> return templateRepository.findAll(); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> private void recordBulkOpEvent(InternalCacheEvent event, ThreadIdentifier threadID) { <line1> EventID eventID = event.getEventId(); <line2> VersionTag tag = event.getVersionTag(); <line3> if (tag == null) { <line4> return; <line5> } <line6> if (logger.isDebugEnabled()) { <line7> } <line8> RegionVersionVector versionVector = ((LocalRegion) event.getRegion()).getVersionVector(); <line9> canonicalizeIDs(tag, versionVector); <line10> boolean retry = false; <line11> do { <line12> BulkOperationHolder bulkOpTracker = recordedBulkOpVersionTags.get(threadID); <line13> if (bulkOpTracker == null) { <line14> bulkOpTracker = new BulkOperationHolder(); <line15> BulkOperationHolder old = recordedBulkOpVersionTags.putIfAbsent(threadID, bulkOpTracker); <line16> if (old != null) { <line17> retry = true; <line18> continue; <line19> } <line20> } <line21> synchronized (bulkOpTracker) { <line22> if (bulkOpTracker.isRemoved()) { <line23> retry = true; <line24> continue; <line25> } <line26> bulkOpTracker.putVersionTag(eventID, event.getVersionTag()); <line27> retry = false; <line28> } <line29> } while (retry); <line30> } <line31> } <line32> 	 <line7>	Yes
"public class A { <line0> private static List<URI> resolve( <line1> final String srvName, <line2> final String protocol, <line3> final String domain, <line4> final DnsSrvResolver resolver) { <line5> final String name; <line6> switch (protocol) { <line7> case ""https"": <line8> name = httpsSrv(srvName, domain); <line9> break; <line10> case ""http"": <line11> name = httpSrv(srvName, domain); <line12> break; <line13> default: <line14> throw new IllegalArgumentException( <line15> String.format( <line16> ""Invalid protocol: %s. Helios SRV record can only be https or http."", protocol)); <line17> } <line18> final List<LookupResult> lookupResults = resolver.resolve(name); <line19> final ImmutableList.Builder<URI> endpoints = ImmutableList.builder(); <line20> for (final LookupResult result : lookupResults) { <line21> endpoints.add(protocol(protocol, result.host(), result.port())); <line22> } <line23> final ImmutableList<URI> uris = endpoints.build(); <line24> return uris; <line25> } <line26> } <line27> "	 <line5>	No
"public class A { <line0> private void extractProject(ProjectGenerationResponse entity, String output, boolean overwrite) <line1> throws IOException { <line2> File outputFolder = <line3> (output != null ? new File(output) : new File(System.getProperty(""user.dir""))); <line4> if (!outputFolder.exists()) { <line5> outputFolder.mkdirs(); <line6> } <line7> ZipInputStream zipStream = new ZipInputStream(new ByteArrayInputStream(entity.getContent())); <line8> try { <line9> extractFromStream(zipStream, overwrite, outputFolder); <line10> fixExecutableFlag(outputFolder, ""mvnw""); <line11> fixExecutableFlag(outputFolder, ""gradlew""); <line12> } finally { <line13> zipStream.close(); <line14> } <line15> } <line16> } <line17> "	 <line2>	No
public class A { <line0> private void closeOnError() { <line1> connectionErrorCounter++; <line2> close(false); <line3> if (connectionErrorCounter > CONNECTION_MAX_RETRY) { <line4> owserverConnectionState = OwserverConnectionState.FAILED; <line5> tryingConnectionRecovery = false; <line6> thingHandlerCallback.reportConnectionState(owserverConnectionState); <line7> } else if (!tryingConnectionRecovery) { <line8> thingHandlerCallback.reportConnectionState(owserverConnectionState); <line9> } <line10> } <line11> } <line12> 	 <line4>	Yes
public class A { <line0> private StateMachine.State tryToConnectToTSOServer() { <line1> final InetSocketAddress tsoAddress = getAddress(); <line2> ChannelFuture channelFuture = bootstrap.connect(tsoAddress); <line3> channelFuture.addListener( <line4> new ChannelFutureListener() { <line5> @Override <line6> public void operationComplete(ChannelFuture channelFuture) throws Exception { <line7> if (channelFuture.isSuccess()) { <line8> } else { <line9> fsm.sendEvent(new ErrorEvent(new ConnectionException())); <line10> } <line11> } <line12> }); <line13> return new ConnectingState(fsm); <line14> } <line15> } <line16> 	 <line15>	No
"public class A { <line0> public BoxTaskAssignment.Info getTaskAssignmentInfo(String taskAssignmentId) { <line1> try { <line2> if (taskAssignmentId == null) { <line3> throw new IllegalArgumentException(""Parameter 'taskAssignmentId' can not be null""); <line4> } <line5> BoxTaskAssignment taskAssignment = new BoxTaskAssignment(boxConnection, taskAssignmentId); <line6> return taskAssignment.getInfo(); <line7> } catch (BoxAPIException e) { <line8> throw new RuntimeException( <line9> String.format( <line10> ""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), <line11> e); <line12> } <line13> } <line14> } <line15> "	 <line12>	No
public class A { <line0> @Override <line1> public void addDocumentListener(@Nonnull DocumentListener listener) { <line2> if (ArrayUtil.contains(listener, getListeners())) { <line3> } <line4> myDocumentListeners.add(listener); <line5> } <line6> } <line7> 	 <line1>	No
"public class A { <line0> public void execute(String strDxExCode, JSONObject jObj) throws Exception { <line1> byte[] sendBuff = null; <line2> String strErrCode = """"; <line3> String strErrMsg = """"; <line4> String strSuccessCode = ""0""; <line5> String startLen = ""2500""; <line6> String seek = ""0""; <line7> String strRESTORE_SN = (String) jObj.get(ProtocolID.RESTORE_SN); <line8> String strLogFileName = ""restore_dump_"" + strRESTORE_SN + "".log""; <line9> String logDir = ""../logs/pg_resLog/""; <line10> JSONObject outputObj = new JSONObject(); <line11> try { <line12> File inFile = new File(logDir, strLogFileName); <line13> HashMap hp = <line14> FileUtil.getRandomAccessFileView( <line15> inFile, Integer.parseInt(startLen), Integer.parseInt(seek), 0); <line16> outputObj.put(ProtocolID.DX_EX_CODE, strDxExCode); <line17> outputObj.put(ProtocolID.RESULT_CODE, strSuccessCode); <line18> outputObj.put(ProtocolID.ERR_CODE, strErrCode); <line19> outputObj.put(ProtocolID.ERR_MSG, strErrMsg); <line20> outputObj.put(ProtocolID.RESULT_DATA, hp.get(""file_desc"")); <line21> inFile = null; <line22> send(TotalLengthBit, outputObj.toString().getBytes()); <line23> } catch (Exception e) { <line24> outputObj.put(ProtocolID.DX_EX_CODE, TranCodeType.DxT031); <line25> outputObj.put(ProtocolID.RESULT_CODE, ""1""); <line26> outputObj.put(ProtocolID.ERR_CODE, TranCodeType.DxT031); <line27> outputObj.put(ProtocolID.ERR_MSG, ""DxT031 Error ["" + e.toString() + ""]""); <line28> sendBuff = outputObj.toString().getBytes(); <line29> send(4, sendBuff); <line30> } finally { <line31> outputObj = null; <line32> sendBuff = null; <line33> } <line34> } <line35> } <line36> "	 <line24>	Yes
"public class A { <line0> @Override <line1> public UserDetails loadUserDetails(PreAuthenticatedAuthenticationToken token) <line2> throws UsernameNotFoundException { <line3> ApplicationUser user = (ApplicationUser) token.getPrincipal(); <line4> Set<GrantedAuthority> authorities = new HashSet<>(); <line5> authorities.addAll(securityHelper.mapRolesToFunctions(user.getRoles())); <line6> authorities.addAll(securityHelper.getUnrestrictedFunctions()); <line7> SecurityUserWrapper result = <line8> new SecurityUserWrapper(user.getUserId(), ""N/A"", true, true, true, true, authorities, user); <line9> return result; <line10> } <line11> } <line12> "	 <line9>	Yes
public class A { <line0> @Override <line1> public final synchronized void dispose() { <line2> if (lifecycleManager.getState().isStarted()) { <line3> try { <line4> getLifecycleManager().fireLifecycle(Stoppable.PHASE_NAME); <line5> } catch (LifecycleException e) { <line6> } <line7> } <line8> try { <line9> getLifecycleManager().fireLifecycle(Disposable.PHASE_NAME); <line10> } catch (LifecycleException e) { <line11> } <line12> try { <line13> doDispose(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> 	 <line14>	No
public class A { <line0> void unscheduleMeasurements(AppdefEntityID ent) throws UnscheduledItemException { <line1> String key = ent.getAppdefKey(); <line2> ScheduledItem[] items; <line3> ResourceSchedule rs; <line4> synchronized (schedules) { <line5> rs = schedules.remove(key); <line6> } <line7> if (rs == null) { <line8> if (log.isDebugEnabled()) { <line9> } <line10> return; <line11> } <line12> setDiagScheduled(rs, false); <line13> items = rs.schedule.getScheduledItems(); <line14> synchronized (statsLock) { <line15> statNumMetricsScheduled -= items.length; <line16> } <line17> synchronized (scheduled) { <line18> for (ScheduledItem item : items) { <line19> ScheduledMeasurement meas = (ScheduledMeasurement) item.getObj(); <line20> scheduled.remove(meas.getDerivedID()); <line21> ParsedTemplate tmpl = getParsedTemplate(meas); <line22> if ((tmpl == null) || (tmpl.metric == null)) { <line23> continue; <line24> } <line25> tmpl.metric.setInterval(-1); <line26> } <line27> } <line28> } <line29> } <line30> 	 <line14>	Yes
public class A { <line0> public static void setupMqttOutputAdapter() throws IOException { <line1> OutputEventAdapterConfiguration outputEventAdapterConfiguration = <line2> createMqttOutputEventAdapterConfiguration( <line3> DeviceTypeConstants.MQTT_ADAPTER_NAME, <line4> DeviceTypeConstants.MQTT_ADAPTER_TYPE, <line5> MessageType.TEXT); <line6> try { <line7> PrivilegedCarbonContext.startTenantFlow(); <line8> PrivilegedCarbonContext.getThreadLocalCarbonContext() <line9> .setTenantDomain(DeviceTypeConstants.DEVICE_TYPE_PROVIDER_DOMAIN, true); <line10> DeviceTypeManagementDataHolder.getInstance() <line11> .getOutputEventAdapterService() <line12> .create(outputEventAdapterConfiguration); <line13> } catch (OutputEventAdapterException e) { <line14> } finally { <line15> PrivilegedCarbonContext.endTenantFlow(); <line16> } <line17> } <line18> } <line19> 	 <line14>	Yes
"public class A { <line0> private String _getExpectedSchemaVersion(List<String> fileNames) <line1> throws IOException, ParseException { <line2> Version expectedSchemaVersion = null; <line3> for (String fileName : fileNames) { <line4> fileName = StringUtil.replace(fileName, CharPool.BACK_SLASH, CharPool.SLASH); <line5> File file = new File(fileName); <line6> String content = FileUtil.read(file); <line7> JavaClass javaClass = JavaClassParser.parseJavaClass(fileName, content); <line8> List<String> implementedClassNames = javaClass.getImplementedClassNames(); <line9> if (!implementedClassNames.contains(""UpgradeStepRegistrator"")) { <line10> continue; <line11> } <line12> int x = -1; <line13> while (true) { <line14> x = content.indexOf("".register("", x + 1); <line15> if (x == -1) { <line16> break; <line17> } <line18> List<String> parameterList = JavaSourceUtil.getParameterList(content.substring(x - 1)); <line19> if (parameterList.size() < 3) { <line20> break; <line21> } <line22> for (int i = parameterList.size() - 2; i > 0; i--) { <line23> Version schemaVersion = null; <line24> try { <line25> schemaVersion = <line26> new Version(StringUtil.removeChar(parameterList.get(i), CharPool.QUOTE)); <line27> } catch (IllegalArgumentException illegalArgumentException) { <line28> if (_log.isDebugEnabled()) { <line29> } <line30> continue; <line31> } <line32> if ((expectedSchemaVersion == null) <line33> || (expectedSchemaVersion.compareTo(schemaVersion) < 0)) { <line34> expectedSchemaVersion = schemaVersion; <line35> } <line36> break; <line37> } <line38> } <line39> } <line40> if (expectedSchemaVersion != null) { <line41> return expectedSchemaVersion.toString(); <line42> } <line43> return null; <line44> } <line45> } <line46> "	 <line36>	No
public class A { <line0> @Before <line1> public void set() { <line2> ALAPipelinesConfig alaConfig = new ALAPipelinesConfig(); <line3> alaConfig.setLocationInfoConfig(new LocationInfoConfig(null, null, null)); <line4> try { <line5> countryCentrePoints = CountryCentrePoints.getInstance(alaConfig.getLocationInfoConfig()); <line6> stateProvinceCentrePoints = <line7> StateProvinceCentrePoints.getInstance(alaConfig.getLocationInfoConfig()); <line8> stateProvinceParser = <line9> StateProvinceParser.getInstance( <line10> alaConfig.getLocationInfoConfig().getStateProvinceNamesFile()); <line11> } catch (Exception e) { <line12> throw new RuntimeException(e.getMessage()); <line13> } <line14> } <line15> } <line16> 	 <line4>	No
"public class A { <line0> @Override <line1> @Transactional <line2> public List<IpBlockEntity> merge( <line3> List<IpBlockEntity> ipBlocks, <line4> boolean ignoreOwner, <line5> boolean ignoreType, <line6> boolean silentWhenOverlap) { <line7> if (ipBlocks.size() <= 1) { <line8> return ipBlocks; <line9> } <line10> AuAssert.check(ignoreOwner || !ignoreType, ""must ignore owner if type is ignored""); <line11> boolean inHibernateSession = <line12> getSessionFactory().getCurrentSession().getTransaction().isActive(); <line13> Collections.sort(ipBlocks); <line14> List<IpBlockEntity> newBlocks = new ArrayList<IpBlockEntity>(ipBlocks.size()); <line15> Iterator<IpBlockEntity> iter = ipBlocks.iterator(); <line16> IpBlockEntity prev = iter.next(); <line17> while (iter.hasNext()) { <line18> IpBlockEntity curr = iter.next(); <line19> if (prev.canConcatWith(curr)) { <line20> if (prev.isOverlapedWith(curr)) { <line21> if (!silentWhenOverlap) { <line22> throw NetworkException.OVERLAPPED_IP_BLOCKS(prev, curr); <line23> } <line24> } <line25> if ((ignoreOwner || prev.getOwnerId().equals(curr.getOwnerId())) <line26> && (ignoreType || prev.getType() == curr.getType())) { <line27> prev.setEndIp(Math.max(curr.getEndIp(), prev.getEndIp())); <line28> if (curr.getId() != null) { <line29> if (inHibernateSession) { <line30> delete(curr); <line31> } else { <line32> AuAssert.unreachable(); <line33> } <line34> } <line35> continue; <line36> } <line37> } <line38> newBlocks.add(prev); <line39> prev = curr; <line40> } <line41> newBlocks.add(prev); <line42> return newBlocks; <line43> } <line44> } <line45> "	 <line21>	Yes
public class A { <line0> @Override <line1> public void onBeforeRemove(CommerceApplicationModel commerceApplicationModel) { <line2> try { <line3> _commerceApplicationModelLocalService.deleteCommerceApplicationModels( <line4> commerceApplicationModel.getCommerceApplicationModelId()); <line5> } catch (PortalException portalException) { <line6> if (_log.isWarnEnabled()) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> public static com.liferay.commerce.pricing.model.CommercePricingClassCPDefinitionRelSoap <line1> fetchCommercePricingClassCPDefinitionRel(long commercePricingClassId, long cpDefinitionId) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.pricing.model.CommercePricingClassCPDefinitionRel returnValue = <line5> CommercePricingClassCPDefinitionRelServiceUtil.fetchCommercePricingClassCPDefinitionRel( <line6> commercePricingClassId, cpDefinitionId); <line7> return com.liferay.commerce.pricing.model.CommercePricingClassCPDefinitionRelSoap.toSoapModel( <line8> returnValue); <line9> } catch (Exception exception) { <line10> throw new RemoteException(exception.getMessage()); <line11> } <line12> } <line13> } <line14> 	 <line10>	Yes
"public class A { <line0> public void process(final String uri, final String hostAddress, RequestHandler requestHandler) <line1> throws IOException { <line2> HTTPAnnounceRequestMessage announceRequest; <line3> try { <line4> announceRequest = this.parseQuery(uri, hostAddress); <line5> } catch (MessageValidationException mve) { <line6> LoggerUtils.warnAndDebugDetails( <line7> logger, ""Unable to parse request message. Request url is {}"", uri, mve); <line8> serveError(Status.BAD_REQUEST, mve.getMessage(), requestHandler); <line9> return; <line10> } <line11> AnnounceRequestMessage.RequestEvent event = announceRequest.getEvent(); <line12> if (event == null) { <line13> event = AnnounceRequestMessage.RequestEvent.NONE; <line14> } <line15> TrackedTorrent torrent = myTorrentsRepository.getTorrent(announceRequest.getHexInfoHash()); <line16> if (!myAcceptForeignTorrents && torrent == null) { <line17> serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.UNKNOWN_TORRENT, requestHandler); <line18> return; <line19> } <line20> final boolean isSeeder = <line21> (event == AnnounceRequestMessage.RequestEvent.COMPLETED) <line22> || (announceRequest.getLeft() == 0); <line23> if (myAddressChecker.isBadAddress(announceRequest.getIp())) { <line24> if (torrent == null) { <line25> writeEmptyResponse(announceRequest, requestHandler); <line26> } else { <line27> writeAnnounceResponse(torrent, null, isSeeder, requestHandler); <line28> } <line29> return; <line30> } <line31> final Peer peer = new Peer(announceRequest.getIp(), announceRequest.getPort()); <line32> try { <line33> torrent = <line34> myTorrentsRepository.putIfAbsentAndUpdate( <line35> announceRequest.getHexInfoHash(), <line36> new TrackedTorrent(announceRequest.getInfoHash()), <line37> event, <line38> ByteBuffer.wrap(announceRequest.getPeerId()), <line39> announceRequest.getHexPeerId(), <line40> announceRequest.getIp(), <line41> announceRequest.getPort(), <line42> announceRequest.getUploaded(), <line43> announceRequest.getDownloaded(), <line44> announceRequest.getLeft()); <line45> } catch (IllegalArgumentException iae) { <line46> LoggerUtils.warnAndDebugDetails( <line47> logger, ""Unable to update peer torrent. Request url is {}"", uri, iae); <line48> serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.INVALID_EVENT, requestHandler); <line49> return; <line50> } <line51> writeAnnounceResponse(torrent, peer, isSeeder, requestHandler); <line52> } <line53> } <line54> "	 <line17>	Yes
"public class A { <line0> private String createExistingServersDescription( <line1> final String managementMachinePrefix, final MachineDetails[] existingManagementServers) { <line2> final StringBuilder sb = new StringBuilder(); <line3> boolean first = true; <line4> for (final MachineDetails machineDetails : existingManagementServers) { <line5> final String existingManagementServerDescription = <line6> createManagementServerDescription(machineDetails); <line7> if (first) { <line8> first = false; <line9> } else { <line10> sb.append("", ""); <line11> } <line12> sb.append(""["").append(existingManagementServerDescription).append(""]""); <line13> } <line14> final String serverDescriptions = sb.toString(); <line15> return serverDescriptions; <line16> } <line17> } <line18> "	 <line6>	No
"public class A { <line0> public static int getFoldersAndFileEntriesAndFileShortcutsCount( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> long folderId, <line4> String[] mimeTypes, <line5> boolean includeMountFolders, <line6> com.liferay.portal.kernel.dao.orm.QueryDefinition<?> queryDefinition) <line7> throws com.liferay.portal.kernel.exception.PortalException { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> DLFolderServiceUtil.class, <line12> ""getFoldersAndFileEntriesAndFileShortcutsCount"", <line13> _getFoldersAndFileEntriesAndFileShortcutsCountParameterTypes23); <line14> MethodHandler methodHandler = <line15> new MethodHandler( <line16> methodKey, groupId, folderId, mimeTypes, includeMountFolders, queryDefinition); <line17> Object returnObj = null; <line18> try { <line19> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line20> } catch (Exception exception) { <line21> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line22> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line23> } <line24> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line25> } <line26> return ((Integer) returnObj).intValue(); <line27> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line28> throw systemException; <line29> } <line30> } <line31> } <line32> "	 <line28>	Yes
public class A { <line0> @Override <line1> public void onNoteNameChanged(Note note, String oldName) { <line2> if (note.isNameEmpty()) { <line3> return; <line4> } <line5> if (!index.containsKey(note)) { <line6> putNote(note); <line7> } else { <line8> Folder folder = index.get(note); <line9> if (folder.getId().equals(note.getFolderId())) { <line10> return; <line11> } <line12> removeNote(note); <line13> putNote(note); <line14> } <line15> } <line16> } <line17> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public void processMessage(Chat chat, Message message) { <line2> try { <line3> String uname[] = chat.getParticipant().split(""/""); <line4> if (conn.getRoster().getEntry(uname[0]) != null) { <line5> chat.sendMessage(msg.manageMessage(message.getBody())); <line6> } else { <line7> chat.sendMessage(manageSubscription(chat, message)); <line8> } <line9> } catch (Exception ex) { <line10> LOG.log(Level.SEVERE, null, ex); <line11> } <line12> } <line13> } <line14> "	 <line8>	No
"public class A { <line0> public HostnameVerifier verifierFor(String hostname) { <line1> if (!hostnameVerificationEnabled) { <line2> return new HostnameVerifier() { <line3> @Override <line4> public boolean verify(final String str, final SSLSession sslSession) { <line5> return true; <line6> } <line7> }; <line8> } <line9> final String tHostname = <line10> hostname.endsWith(""."") ? hostname.substring(0, hostname.length() - 1) : hostname; <line11> return new HostnameVerifier() { <line12> @Override <line13> public boolean verify(final String str, final SSLSession sslSession) { <line14> return delegate.verify(tHostname, sslSession); <line15> } <line16> }; <line17> } <line18> } <line19> "	 <line8>	No
public class A { <line0> @BuildStep <line1> void unlessBuildProfile( <line2> CombinedIndexBuildItem index, <line3> BuildProducer<BuildTimeConditionBuildItem> producer, <line4> BuildProducer<PreAdditionalBeanBuildTimeConditionBuildItem> producerPreAdditionalBean) { <line5> Collection<AnnotationInstance> annotationInstances = <line6> index.getIndex().getAnnotations(UNLESS_BUILD_PROFILE); <line7> for (AnnotationInstance instance : annotationInstances) { <line8> String profileOnInstance = instance.value().asString(); <line9> boolean enabled = !profileOnInstance.equals(ProfileManager.getActiveProfile()); <line10> if (enabled) { <line11> } else { <line12> } <line13> producer.produce(new BuildTimeConditionBuildItem(instance.target(), enabled)); <line14> producerPreAdditionalBean.produce( <line15> new PreAdditionalBeanBuildTimeConditionBuildItem(instance.target(), enabled)); <line16> } <line17> } <line18> } <line19> 	 <line11>	Yes
public class A { <line0> @Test <line1> public void testOrganizationAdminRemovingOrganizationOwnerRoleByUsers() throws Exception { <line2> _organization = OrganizationTestUtil.addOrganization(); <line3> Role role = <line4> _roleLocalService.getRole(TestPropsValues.getCompanyId(), RoleConstants.ORGANIZATION_OWNER); <line5> _subjectUser = UserTestUtil.addOrganizationAdminUser(_organization); <line6> _objectUser = UserTestUtil.addOrganizationOwnerUser(_organization); <line7> try { <line8> _deleteUserGroupRolesByUser( <line9> _organization.getGroupId(), role.getRoleId(), _subjectUser, _objectUser); <line10> Assert.fail(); <line11> } catch (PrincipalException principalException) { <line12> if (_log.isDebugEnabled()) { <line13> } <line14> Assert.assertTrue( <line15> _userGroupRoleLocalService.hasUserGroupRole( <line16> _objectUser.getUserId(), _organization.getGroupId(), role.getRoleId())); <line17> } <line18> } <line19> } <line20> 	 <line13>	Yes
"public class A { <line0> public static boolean sendCommonFixNotification( <line1> List<AutoFixTransaction> silentautoFixTrans, <line2> Map<String, String> ruleParam, <line3> ResourceOwner resourceOwner, <line4> String targetType) { <line5> try { <line6> List<String> toRecipients = Lists.newArrayList(); <line7> String emailCCList = CommonUtils.getPropValue(PacmanSdkConstants.SEND_EMAIL_CC_KEY); <line8> toRecipients.addAll(Arrays.asList(emailCCList.split(""\\s*,\\s*""))); <line9> String emailSubject = <line10> CommonUtils.getPropValue( <line11> PacmanSdkConstants.SEND_EMAIL_FIX_SUBJECT_PREFIX <line12> + ruleParam.get(PacmanSdkConstants.RULE_ID)); <line13> Gson gson = new GsonBuilder().disableHtmlEscaping().create(); <line14> if (toRecipients != null && toRecipients.size() > 0) { <line15> toRecipients.stream().forEach(logger::debug); <line16> Map<String, Object> mailDetails = Maps.newHashMap(); <line17> mailDetails.put(""attachmentUrl"", """"); <line18> mailDetails.put(""from"", CommonUtils.getPropValue(PacmanSdkConstants.SEND_EMAIL_FROM)); <line19> mailDetails.put( <line20> ""mailBodyAsString"", formateCommonFixBody(silentautoFixTrans, ruleParam, resourceOwner)); <line21> mailDetails.put(""placeholderValues"", Maps.newHashMap()); <line22> mailDetails.put(""subject"", emailSubject); <line23> mailDetails.put(""to"", toRecipients); <line24> CommonUtils.doHttpPost( <line25> CommonUtils.getPropValue(PacmanSdkConstants.EMAIL_SERVICE_URL), <line26> gson.toJson(mailDetails), <line27> new HashMap<>()); <line28> } <line29> } catch (Exception e) { <line30> } <line31> return true; <line32> } <line33> } <line34> "	 <line30>	Yes
public class A { <line0> private void testOneFail() { <line1> try { <line2> prepare(2); <line3> FakeAllocatableAction instance0 = new FakeAllocatableAction(fao, 0); <line4> FakeAllocatableAction instance1 = new FakeAllocatableAction(fao, 1); <line5> instance0.assignResource(rs); <line6> instance1.assignResource(rs); <line7> instance0.tryToLaunch(); <line8> error(instance0); <line9> checkExecutions(new int[] {1, 0}); <line10> checkErrors(new int[] {1, 0}); <line11> checkFailed(new int[] {0, 0}); <line12> checkCancelled(new int[] {0, 0}); <line13> instance0.assignResource(rs); <line14> instance0.tryToLaunch(); <line15> error(instance0); <line16> checkExecutions(new int[] {2, 0}); <line17> checkErrors(new int[] {2, 0}); <line18> checkFailed(new int[] {1, 0}); <line19> checkCancelled(new int[] {0, 0}); <line20> } catch (Throwable e) { <line21> fail(e.getMessage()); <line22> } <line23> } <line24> } <line25> 	 <line1>	Yes
"public class A { <line0> @Override <line1> protected boolean initiateClient() { <line2> for (String host : hosts) { <line3> if (host == null) { <line4> throw new IllegalArgumentException(""Host Name should not be null.""); <line5> } <line6> } <line7> cluster = CouchbaseCluster.create(hosts); <line8> if (userName != null && password != null) { <line9> clusterManager = cluster.clusterManager(userName, password); <line10> } else { <line11> clusterManager = cluster.clusterManager(); <line12> } <line13> return true; <line14> } <line15> } <line16> "	 <line11>	No
"public class A { <line0> @Override <line1> protected void doProcessAction(ActionRequest actionRequest, ActionResponse actionResponse) <line2> throws Exception { <line3> try { <line4> _ddmFormInstanceService.sendEmail( <line5> ParamUtil.getLong(actionRequest, ""formInstanceId""), <line6> ParamUtil.getString(actionRequest, ""message""), <line7> ParamUtil.getString(actionRequest, ""subject""), <line8> ParamUtil.getStringValues(actionRequest, ""addresses"")); <line9> JSONObject jsonObject = <line10> JSONUtil.put( <line11> ""successMessage"", <line12> LanguageUtil.get( <line13> _portal.getHttpServletRequest(actionRequest), ""form-was-shared-via-email"")); <line14> JSONPortletResponseUtil.writeJSON(actionRequest, actionResponse, jsonObject); <line15> } catch (Exception exception) { <line16> if (_log.isDebugEnabled()) { <line17> } <line18> HttpServletResponse httpServletResponse = _portal.getHttpServletResponse(actionResponse); <line19> httpServletResponse.setStatus(HttpServletResponse.SC_BAD_REQUEST); <line20> JSONObject jsonObject = <line21> JSONUtil.put( <line22> ""errorMessage"", <line23> LanguageUtil.get( <line24> _portal.getHttpServletRequest(actionRequest), ""your-request-failed-to-complete"")); <line25> JSONPortletResponseUtil.writeJSON(actionRequest, actionResponse, jsonObject); <line26> } <line27> } <line28> } <line29> "	 <line28>	No
"public class A { <line0> @Override <line1> public HttpURLConnection connect( <line2> final URI uri, <line3> final String method, <line4> final byte[] entity, <line5> final Map<String, List<String>> headers) <line6> throws HeliosException { <line7> final Endpoint endpoint = endpointIterator.next(); <line8> final String endpointHost = endpoint.getUri().getHost(); <line9> try { <line10> final HttpURLConnection connection = connect0(uri, method, entity, headers, endpointHost); <line11> if (connection.getResponseCode() == HTTP_BAD_GATEWAY) { <line12> throw new HeliosException( <line13> String.format( <line14> ""Request to %s returned %s, master is down"", uri, connection.getResponseCode())); <line15> } <line16> return connection; <line17> } catch (ConnectException | SocketTimeoutException | UnknownHostException e) { <line18> throw new HeliosException(""Unable to connect to master: "" + uri, e); <line19> } catch (IOException e) { <line20> throw new HeliosException(""Unexpected error connecting to "" + uri, e); <line21> } <line22> } <line23> } <line24> "	 <line18>	Yes
"public class A { <line0> public void addNetwork(QuantumModel quantumModel, Network network) throws QuantumException { <line1> List<Network> networks = quantumModel.getNetworks(); <line2> if (networks.contains(network)) <line3> throw new QuantumException( <line4> ""Network  "" + network.getName() + "" already exists in Quantum Model.""); <line5> quantumModel.getNetworks().add(network); <line6> } <line7> } <line8> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void processResult(CuratorFramework client, CuratorEvent event) throws Exception { <line2> try { <line3> if (event.getData() == null || event.getData().length == 0) { <line4> return; <line5> } <line6> bytes.getAndAdd(event.getData().length); <line7> final Q object = transcoder.fromBytes(event.getData()); <line8> if (allPathsMap.get(event.getPath()) != null) { <line9> resultsMap.putIfAbsent(allPathsMap.get(event.getPath()), new ArrayList<Q>()); <line10> resultsMap.get(allPathsMap.get(event.getPath())).add(object); <line11> } <line12> } finally { <line13> latch.countDown(); <line14> } <line15> } <line16> } <line17> 	 <line1>	No
"public class A { <line0> public OpenAPI read(Set<Class<?>> classes) { <line1> Set<Class<?>> sortedClasses = <line2> new TreeSet<>( <line3> (class1, class2) -> { <line4> if (class1.equals(class2)) { <line5> return 0; <line6> } else if (class1.isAssignableFrom(class2)) { <line7> return -1; <line8> } else if (class2.isAssignableFrom(class1)) { <line9> return 1; <line10> } <line11> return class1.getName().compareTo(class2.getName()); <line12> }); <line13> sortedClasses.addAll(classes); <line14> Map<Class<?>, ReaderListener> listeners = new HashMap<>(); <line15> String appPath = """"; <line16> for (Class<?> cls : sortedClasses) { <line17> if (ReaderListener.class.isAssignableFrom(cls) && !listeners.containsKey(cls)) { <line18> try { <line19> listeners.put(cls, (ReaderListener) cls.newInstance()); <line20> } catch (Exception e) { <line21> } <line22> } <line23> if (config != null && Boolean.TRUE.equals(config.isAlwaysResolveAppPath())) { <line24> if (Application.class.isAssignableFrom(cls)) { <line25> ApplicationPath appPathAnnotation = <line26> ReflectionUtils.getAnnotation(cls, ApplicationPath.class); <line27> if (appPathAnnotation != null) { <line28> appPath = appPathAnnotation.value(); <line29> } <line30> } <line31> } <line32> } <line33> for (ReaderListener listener : listeners.values()) { <line34> try { <line35> listener.beforeScan(this, openAPI); <line36> } catch (Exception e) { <line37> } <line38> } <line39> String appPathRuntime = resolveApplicationPath(); <line40> if (StringUtils.isNotBlank(appPathRuntime)) { <line41> appPath = appPathRuntime; <line42> } <line43> for (Class<?> cls : sortedClasses) { <line44> read( <line45> cls, <line46> appPath, <line47> null, <line48> false, <line49> null, <line50> null, <line51> new LinkedHashSet<String>(), <line52> new ArrayList<Parameter>(), <line53> new HashSet<Class<?>>()); <line54> } <line55> for (ReaderListener listener : listeners.values()) { <line56> try { <line57> listener.afterScan(this, openAPI); <line58> } catch (Exception e) { <line59> } <line60> } <line61> return openAPI; <line62> } <line63> } <line64> "	 <line62>	No
public class A { <line0> @OnScheduled <line1> public final void abstractOnScheduled(ProcessContext context) throws IOException { <line2> try { <line3> HdfsResources resources = hdfsResources.get(); <line4> if (resources.getConfiguration() == null) { <line5> final ResourceReferences configResources = <line6> context <line7> .getProperty(HADOOP_CONFIGURATION_RESOURCES) <line8> .evaluateAttributeExpressions() <line9> .asResources(); <line10> resources = resetHDFSResources(configResources, context); <line11> hdfsResources.set(resources); <line12> } <line13> } catch (Exception ex) { <line14> hdfsResources.set(EMPTY_HDFS_RESOURCES); <line15> throw ex; <line16> } <line17> } <line18> } <line19> 	 <line14>	Yes
"public class A { <line0> public List findByExample(StgMUmsetzStatTxt instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.StgMUmsetzStatTxt"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line1>	Yes
public class A { <line0> @Override <line1> public void handleStateChanged(final Watcher.Event.KeeperState keeperState) { <line2> if (Watcher.Event.KeeperState.SyncConnected.equals(keeperState)) { <line3> nodeDataMap.forEach( <line4> (k, v) -> { <line5> if (!zkClient.exists(k)) { <line6> zkClient.createEphemeral(k, v); <line7> } <line8> }); <line9> } <line10> } <line11> } <line12> 	 <line8>	No
public class A { <line0> public boolean isIdPDefinitionComplete(String key) { <line1> String entityId; <line2> if (!isSet(key + IDP_ID)) { <line3> return false; <line4> } else entityId = getValue(key + IDP_ID); <line5> if (!isSet(key + IDP_ADDRESS)) { <line6> return false; <line7> } <line8> if (getCertificateNames(key).size() == 0) { <line9> return false; <line10> } <line11> String translatioProfile = getValue(key + CommonWebAuthnProperties.TRANSLATION_PROFILE); <line12> String embeddedTranslatioProfile = <line13> getValue(key + CommonWebAuthnProperties.EMBEDDED_TRANSLATION_PROFILE); <line14> if ((translatioProfile == null || translatioProfile.isEmpty()) <line15> && (embeddedTranslatioProfile == null || embeddedTranslatioProfile.isEmpty())) { <line16> return false; <line17> } <line18> return true; <line19> } <line20> } <line21> 	 <line15>	No
public class A { <line0> private void setXATerminator(final XATerminator terminator) { <line1> this.xaTerminator = terminator; <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> @Override <line1> public void onError(JoynrRuntimeException error) { <line2> subscribeAttributeEnumerationCallbackResult = false; <line3> subscribeAttributeEnumerationCallbackDone = true; <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> private RestResponse<ObjectMap> getAcl() throws CatalogException, ClientException { <line1> StudyCommandOptions.AclsCommandOptions c = studiesCommandOptions.aclsCommandOptions; <line2> ObjectMap params = new ObjectMap(); <line3> params.putIfNotEmpty(""member"", c.memberId); <line4> return openCGAClient.getStudyClient().acl(getSingleValidStudy(c.study), params); <line5> } <line6> } <line7> "	 <line1>	Yes
public class A { <line0> @Override <line1> public String encryptAsymmetric(final String secret) { <line2> if (isEncrypted(secret)) { <line3> return secret; <line4> } <line5> if (secret.length() > 230) { <line6> return secret; <line7> } <line8> if (kmsKeyArn == null) { <line9> return secret; <line10> } <line11> String tmp = secret; <line12> if (isToBeEncrypted(secret)) { <line13> tmp = secret.substring(2, secret.length() - 2); <line14> } <line15> try { <line16> EncryptRequest req = <line17> new EncryptRequest() <line18> .withKeyId(kmsKeyArn) <line19> .withEncryptionAlgorithm(ASYMMETRIC_ALGORITHM) <line20> .withPlaintext(ByteBuffer.wrap(tmp.getBytes())); <line21> ByteBuffer plainText = kmsClient.encrypt(req).getCiphertextBlob(); <line22> return TO_DECRYPT_PREFIX <line23> + Base64.getEncoder().encodeToString(plainText.array()) <line24> + TO_DECRYPT_POSTFIX; <line25> } catch (RuntimeException e) { <line26> } <line27> return secret; <line28> } <line29> } <line30> 	 <line8>	No
public class A { <line0> public static int countReplicas(long containerID, MiniOzoneCluster cluster) { <line1> ContainerManagerV2 containerManager = <line2> cluster.getStorageContainerManager().getContainerManager(); <line3> try { <line4> Set<ContainerReplica> replicas = <line5> containerManager.getContainerReplicas(ContainerID.valueOf(containerID)); <line6> return replicas.size(); <line7> } catch (ContainerNotFoundException e) { <line8> return 0; <line9> } <line10> } <line11> } <line12> 	 <line4>	No
public class A { <line0> private void waitForFinish(Paragraph p) { <line1> while (p.getStatus() != Status.FINISHED <line2> && p.getStatus() != Status.ERROR <line3> && p.getStatus() != Status.ABORT) { <line4> try { <line5> Thread.sleep(100); <line6> } catch (InterruptedException e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> protected void waitAfterLaunch(ManagementContext ctx, AppShutdownHandler shutdownHandler) <line1> throws IOException { <line2> if (stopOnKeyPress) { <line3> Task<Void> readTask = <line4> ctx.getExecutionManager() <line5> .submit( <line6> new Callable<Void>() { <line7> @Override <line8> public Void call() throws Exception { <line9> stdin.read(); <line10> return null; <line11> } <line12> }); <line13> while (!shutdownHandler.isRequested()) { <line14> try { <line15> readTask.get(Duration.ONE_SECOND); <line16> break; <line17> } catch (TimeoutException e) { <line18> } catch (InterruptedException e) { <line19> Thread.currentThread().interrupt(); <line20> throw Exceptions.propagate(e); <line21> } catch (ExecutionException e) { <line22> throw Exceptions.propagate(e); <line23> } <line24> } <line25> stopAllApps(ctx.getApplications()); <line26> } else { <line27> shutdownHandler.waitOnShutdownRequest(); <line28> } <line29> } <line30> } <line31> 	 <line5>	No
public class A { <line0> @Override <line1> public void registered( <line2> ExecutorDriver executorDriver, <line3> Protos.ExecutorInfo executorInfo, <line4> Protos.FrameworkInfo frameworkInfo, <line5> Protos.SlaveInfo agentInfo) { <line6> } <line7> } <line8> 	 <line2>	No
"public class A { <line0> @Override <line1> public void connectionClosed(ConnectionEvent event) { <line2> if (isActive) { <line3> try { <line4> PooledConnection conn = (PooledConnection) event.getSource(); <line5> provider.returnConnection(conn); <line6> } catch (Exception ex) { <line7> String exception = ""GemFireConnPooledDataSource::connectionclosed:Exception ="" + ex; <line8> if (logger.isDebugEnabled()) { <line9> } <line10> } <line11> } <line12> } <line13> } <line14> "	 <line4>	No
public class A { <line0> private static List<IdentityMapping> getMappings( <line1> final NiFiProperties properties, <line2> final String patternPrefix, <line3> final String valuePrefix, <line4> final String transformPrefix, <line5> final Supplier<String> getSubject) { <line6> final List<IdentityMapping> mappings = new ArrayList<>(); <line7> for (String propertyName : properties.getPropertyKeys()) { <line8> if (StringUtils.startsWith(propertyName, patternPrefix)) { <line9> final String key = StringUtils.substringAfter(propertyName, patternPrefix); <line10> final String identityPattern = properties.getProperty(propertyName); <line11> if (StringUtils.isBlank(identityPattern)) { <line12> continue; <line13> } <line14> final String identityValueProperty = valuePrefix + key; <line15> final String identityValue = properties.getProperty(identityValueProperty); <line16> if (StringUtils.isBlank(identityValue)) { <line17> continue; <line18> } <line19> final String identityTransformProperty = transformPrefix + key; <line20> String rawIdentityTransform = properties.getProperty(identityTransformProperty); <line21> if (StringUtils.isBlank(rawIdentityTransform)) { <line22> rawIdentityTransform = Transform.NONE.name(); <line23> } <line24> final Transform identityTransform; <line25> try { <line26> identityTransform = Transform.valueOf(rawIdentityTransform); <line27> } catch (final IllegalArgumentException iae) { <line28> continue; <line29> } <line30> final IdentityMapping identityMapping = <line31> new IdentityMapping( <line32> key, Pattern.compile(identityPattern), identityValue, identityTransform); <line33> mappings.add(identityMapping); <line34> } <line35> } <line36> Collections.sort( <line37> mappings, <line38> new Comparator<IdentityMapping>() { <line39> @Override <line40> public int compare(IdentityMapping m1, IdentityMapping m2) { <line41> return m1.getKey().compareTo(m2.getKey()); <line42> } <line43> }); <line44> return mappings; <line45> } <line46> } <line47> 	 <line23>	No
"public class A { <line0> public void addNewTenantPartitions( <line1> Collection<Table> tables, <line2> Map<String, PartitionInfo> partitionInfoMap, <line3> int newTenantId, <line4> String tablespaceName) { <line5> int poolSize = connectionProvider.getPoolSize(); <line6> if (poolSize == -1) { <line7> poolSize = 40; <line8> } <line9> final ExecutorService pool = Executors.newFixedThreadPool(poolSize); <line10> final AtomicInteger taskCount = new AtomicInteger(); <line11> for (Table t : tables) { <line12> String qualifiedName = t.getQualifiedName(); <line13> PartitionInfo pi = partitionInfoMap.get(t.getObjectName()); <line14> if (pi == null) { <line15> throw new DataAccessException(""No partition information found for table: "" + qualifiedName); <line16> } else { <line17> taskCount.incrementAndGet(); <line18> pool.submit( <line19> new Runnable() { <line20> @Override <line21> public void run() { <line22> try { <line23> createTenantPartitionsThr(t, pi, newTenantId, tablespaceName); <line24> } catch (Throwable x) { <line25> logger.log(Level.SEVERE, ""tenant creation failed: "" + t.getName(), x); <line26> } finally { <line27> taskCount.decrementAndGet(); <line28> } <line29> } <line30> }); <line31> } <line32> } <line33> pool.shutdown(); <line34> try { <line35> while (!pool.isTerminated()) { <line36> pool.awaitTermination(5000, TimeUnit.MILLISECONDS); <line37> } <line38> } catch (InterruptedException x) { <line39> throw new DataAccessException(""Tenant partition creation did not complete""); <line40> } <line41> } <line42> } <line43> "	 <line15>	No
"public class A { <line0> @Override <line1> public User addUser(final User user) throws JargonException, DuplicateDataException { <line2> if (log.isDebugEnabled()) { <line3> } <line4> if (user == null) { <line5> throw new IllegalArgumentException(""cannot add null user""); <line6> } <line7> updatePreChecks(user); <line8> GeneralAdminInp adminPI = GeneralAdminInp.instanceForAddUser(user); <line9> try { <line10> getIRODSProtocol().irodsFunction(adminPI); <line11> } catch (DuplicateDataException dde) { <line12> throw dde; <line13> } catch (NoMoreRulesException nmr) { <line14> throw new DuplicateDataException( <line15> ""no more rules interpereted as duplicate data exception for backwards compatibility""); <line16> } <line17> if (!user.getComment().isEmpty()) { <line18> updateUserComment(user); <line19> } <line20> if (!user.getInfo().isEmpty()) { <line21> updateUserInfo(user); <line22> } <line23> if (!user.getUserDN().isEmpty()) { <line24> updateUserDN(user.getName(), user.getUserDN()); <line25> } <line26> return findByName(user.getName()); <line27> } <line28> } <line29> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public ContentStream getContentStream( <line2> final String repositoryId, <line3> final String objectId, <line4> final String streamId, <line5> final BigInteger offset, <line6> final BigInteger length, <line7> final ExtensionsData extension) { <line8> final App app = StructrApp.getInstance(); <line9> ContentStreamImpl result = null; <line10> try (final Tx tx = app.tx()) { <line11> final File file = app.get(File.class, objectId); <line12> if (file != null) { <line13> return new CMISContentStream(file, offset, length); <line14> } <line15> tx.success(); <line16> } catch (Throwable t) { <line17> } <line18> if (result != null) { <line19> return result; <line20> } <line21> throw new CmisObjectNotFoundException(""Object with ID "" + objectId + "" does not exist""); <line22> } <line23> } <line24> "	 <line10>	No
public class A { <line0> protected Serializable getValueForMetacardAttribute( <line1> AttributeFormat attributeFormat, HierarchicalStreamReader reader) { <line2> Serializable ser = null; <line3> switch (attributeFormat) { <line4> case BOOLEAN: <line5> ser = Boolean.valueOf(reader.getValue()); <line6> break; <line7> case DOUBLE: <line8> ser = Double.valueOf(reader.getValue()); <line9> break; <line10> case FLOAT: <line11> ser = Float.valueOf(reader.getValue()); <line12> break; <line13> case INTEGER: <line14> ser = Integer.valueOf(reader.getValue()); <line15> break; <line16> case LONG: <line17> ser = Long.valueOf(reader.getValue()); <line18> break; <line19> case SHORT: <line20> ser = Short.valueOf(reader.getValue()); <line21> break; <line22> case XML: <line23> case STRING: <line24> ser = reader.getValue(); <line25> break; <line26> case GEOMETRY: <line27> XmlNode node = new XmlNode(reader); <line28> String xml = node.toString(); <line29> GMLReader gmlReader = new GMLReader(); <line30> Geometry geo = null; <line31> try { <line32> geo = gmlReader.read(xml, null); <line33> if (StringUtils.isNotBlank(srs) && !srs.equals(GeospatialUtil.EPSG_4326)) { <line34> geo = GeospatialUtil.transformToEPSG4326LonLatFormat(geo, srs); <line35> } <line36> } catch (SAXException | IOException | ParserConfigurationException | GeoFormatException e) { <line37> geo = null; <line38> } <line39> if (geo != null) { <line40> WKTWriter wktWriter = new WKTWriter(); <line41> ser = wktWriter.write(geo); <line42> } <line43> break; <line44> case BINARY: <line45> try { <line46> ser = reader.getValue().getBytes(UTF8_ENCODING); <line47> } catch (UnsupportedEncodingException e) { <line48> } <line49> break; <line50> case DATE: <line51> ser = parseDateFromXml(reader); <line52> break; <line53> default: <line54> break; <line55> } <line56> return ser; <line57> } <line58> } <line59> 	 <line26>	No
"public class A { <line0> public static WeightingModel newInstance(String name, Index index) { <line1> final Logger logger = LoggerFactory.getLogger(WeightingModelFactory.class); <line2> WeightingModel model = null; <line3> if (name == null || name.length() == 0) <line4> throw new IllegalArgumentException(""Weighting model must be defined and non-empty""); <line5> name = name.replaceFirst(""^([^\\.]+(\\(|$))"", NAMESPACE + ""$1""); <line6> if (!cache.containsKey(index)) { <line7> cache.put(index, new HashMap<String, WeightingModel>()); <line8> } <line9> model = cache.get(index).get(name); <line10> if (model == null) { <line11> try { <line12> if (name.indexOf(""("") > 0) { <line13> String params = name.substring(name.indexOf(""("") + 1, name.indexOf("")"")); <line14> String[] parameters = params.split(""\\s*,\\s*""); <line15> model = <line16> ApplicationSetup.getClass(name.substring(0, name.indexOf(""(""))) <line17> .asSubclass(WeightingModel.class) <line18> .getConstructor(new Class[] {String[].class}) <line19> .newInstance(new Object[] {parameters}); <line20> } else { <line21> model = ApplicationSetup.getClass(name).asSubclass(WeightingModel.class).newInstance(); <line22> } <line23> } catch (InvocationTargetException e) { <line24> } catch (Exception e) { <line25> } <line26> cache.get(index).put(name, model); <line27> } <line28> return model; <line29> } <line30> } <line31> "	 <line26>	No
"public class A { <line0> @Override <line1> public void searchLdap( <line2> final LdapTemplate inLdapTemplate, <line3> final String inEncodedFilter, <line4> final SearchControls inSearchControls, <line5> final CollectingNameClassPairCallbackHandler inHandler) { <line6> PagedResultsDirContextProcessor pager = new PagedResultsDirContextProcessor(resultsPerPage); <line7> if (logger.isTraceEnabled()) { <line8> } <line9> do { <line10> inLdapTemplate.search("""", inEncodedFilter, inSearchControls, inHandler, pager); <line11> pager = new PagedResultsDirContextProcessor(resultsPerPage, pager.getCookie()); <line12> } while (pager.getCookie() != null <line13> && pager.getCookie().getCookie() != null <line14> && inHandler.getList().size() < inSearchControls.getCountLimit()); <line15> if (logger.isTraceEnabled()) { <line16> } <line17> } <line18> } <line19> "	 <line4>	No
public class A { <line0> public void redo() { <line1> if (canRedo()) { <line2> try { <line3> typeOfChangeInProgress = ChangeType.REDOING; <line4> List<OWLOntologyChange> redoChanges = redoStack.pop(); <line5> manager.applyChanges(redoChanges); <line6> } catch (Exception e) { <line7> } finally { <line8> typeOfChangeInProgress = ChangeType.NORMAL; <line9> } <line10> } <line11> } <line12> } <line13> 	 <line11>	No
public class A { <line0> private String getOxTrustImportPersonConfiguration( <line1> ImportPersonConfig oxTrustImportPersonConfiguration) { <line2> try { <line3> if (oxTrustImportPersonConfiguration != null) { <line4> return jsonService.objectToJson(oxTrustImportPersonConfiguration); <line5> } <line6> return null; <line7> } catch (Exception ex) { <line8> } <line9> return null; <line10> } <line11> } <line12> 	 <line8>	Yes
public class A { <line0> private boolean _isShowPublishAction() { <line1> PermissionChecker permissionChecker = _themeDisplay.getPermissionChecker(); <line2> long scopeGroupId = _themeDisplay.getScopeGroupId(); <line3> StagingGroupHelper stagingGroupHelper = StagingGroupHelperUtil.getStagingGroupHelper(); <line4> try { <line5> if (GroupPermissionUtil.contains( <line6> permissionChecker, scopeGroupId, ActionKeys.EXPORT_IMPORT_PORTLET_INFO) <line7> && stagingGroupHelper.isStagingGroup(scopeGroupId) <line8> && stagingGroupHelper.isStagedPortlet(scopeGroupId, JournalPortletKeys.JOURNAL)) { <line9> return true; <line10> } <line11> return false; <line12> } catch (PortalException portalException) { <line13> if (_log.isDebugEnabled()) { <line14> } <line15> return false; <line16> } <line17> } <line18> } <line19> 	 <line14>	Yes
"public class A { <line0> protected CsrfToken getCsrfTokenFromLoginHtml(String loginHtml) throws AuthenticationException { <line1> Pattern pattern = Pattern.compile(""CSRF_TOKEN = '(.*?)';""); <line2> Matcher matcher = pattern.matcher(loginHtml); <line3> if (matcher.find()) { <line4> String csrfTokenString = matcher.group(1); <line5> return new DefaultCsrfToken(CSRF_HEADER_NAME, CSRF_PARAM_NAME, csrfTokenString); <line6> } else { <line7> throw new SessionAuthenticationException(""Could not find CSRF_TOKEN variable on login page""); <line8> } <line9> } <line10> } <line11> "	 <line8>	No
public class A { <line0> private void flushAndClear() { <line1> if (em != null) { <line2> em.flush(); <line3> em.clear(); <line4> } <line5> if (em != null && useTransaction) { <line6> em.getTransaction().commit(); <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> @Override <line1> public Iterator<ENTITY> iterator() { <line2> final RuntimeEngine rte = getRte(); <line3> final AbstractEntityProperty<ENTITY> meta = getMetaInternal(); <line4> final CassandraOptions cassandraOptions = getOptions(); <line5> final StatementWrapper statementWrapper = getInternalBoundStatementWrapper(); <line6> if (LOGGER.isTraceEnabled()) { <line7> } <line8> CompletableFuture<ResultSet> futureRS = rte.execute(statementWrapper); <line9> return new EntityIteratorWrapper<>(futureRS, meta, statementWrapper, cassandraOptions); <line10> } <line11> } <line12> 	 <line8>	No
public class A { <line0> public static com.liferay.commerce.model.CommerceOrderSoap executeWorkflowTransition( <line1> long commerceOrderId, long workflowTaskId, String transitionName, String comment) <line2> throws RemoteException { <line3> try { <line4> com.liferay.commerce.model.CommerceOrder returnValue = <line5> CommerceOrderServiceUtil.executeWorkflowTransition( <line6> commerceOrderId, workflowTaskId, transitionName, comment); <line7> return com.liferay.commerce.model.CommerceOrderSoap.toSoapModel(returnValue); <line8> } catch (Exception exception) { <line9> throw new RemoteException(exception.getMessage()); <line10> } <line11> } <line12> } <line13> 	 <line9>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> group = new NioEventLoopGroup(); <line3> SimpleClientInitializer clientInitializer = <line4> new SimpleClientInitializer(isOnlineFuture, securedClient); <line5> clientInitializer.setScenario(scenarioHandler); <line6> try { <line7> Bootstrap b = new Bootstrap(); <line8> b.group(group).channel(NioSocketChannel.class).handler(clientInitializer); <line9> b.connect(host, port).sync(); <line10> synchronized (scenarioHandler) { <line11> while (!scenarioHandler.isScenarioFinished()) { <line12> scenarioHandler.wait(); <line13> } <line14> } <line15> } catch (Exception ex) { <line16> } finally { <line17> try { <line18> group.shutdownGracefully().get(); <line19> } catch (InterruptedException | ExecutionException e) { <line20> } <line21> } <line22> scenarioDone.set(true); <line23> } <line24> } <line25> 	 <line13>	No
public class A { <line0> private void checkWhetherTrackerCanBeRemoved(JobID jobId, JobScopedResourceTracker tracker) { <line1> if (tracker.isEmpty()) { <line2> trackers.remove(jobId); <line3> } <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> protected CommConnection openSerialPort(String port) throws KuraException { <line1> CommConnection connection = null; <line2> if (this.connectionFactory != null) { <line3> String uri = <line4> new CommURI.Builder(port) <line5> .withBaudRate(115200) <line6> .withDataBits(8) <line7> .withStopBits(1) <line8> .withParity(0) <line9> .withTimeout(2000) <line10> .build() <line11> .toString(); <line12> try { <line13> connection = (CommConnection) this.connectionFactory.createConnection(uri, 1, false); <line14> } catch (Exception e) { <line15> throw new KuraException(KuraErrorCode.INTERNAL_ERROR, e, ""Connection Failed""); <line16> } <line17> } <line18> return connection; <line19> } <line20> } <line21> "	 <line5>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public ArtifactDefinition createHeatEnvPlaceHolder( <line2> List<ArtifactDefinition> createdArtifacts, <line3> ArtifactDefinition heatArtifact, <line4> String envType, <line5> String parentId, <line6> NodeTypeEnum parentType, <line7> String parentName, <line8> User user, <line9> Component component, <line10> Map<String, String> existingEnvVersions) { <line11> Map<String, Object> deploymentResourceArtifacts = <line12> ConfigurationManager.getConfigurationManager() <line13> .getConfiguration() <line14> .getDeploymentResourceInstanceArtifacts(); <line15> if (deploymentResourceArtifacts == null) { <line16> throw new ByActionStatusComponentException(ActionStatus.GENERAL_ERROR); <line17> } <line18> Map<String, Object> placeHolderData = <line19> (Map<String, Object>) deploymentResourceArtifacts.get(envType); <line20> if (placeHolderData == null) { <line21> throw new ByActionStatusComponentException(ActionStatus.GENERAL_ERROR); <line22> } <line23> String envLabel = (heatArtifact.getArtifactLabel() + HEAT_ENV_SUFFIX).toLowerCase(); <line24> ArtifactDefinition createArtifactPlaceHolder = <line25> createArtifactPlaceHolderInfo( <line26> parentId, <line27> envLabel, <line28> placeHolderData, <line29> user.getUserId(), <line30> ArtifactGroupTypeEnum.DEPLOYMENT, <line31> true); <line32> ArtifactDefinition artifactHeatEnv = createArtifactPlaceHolder; <line33> artifactHeatEnv.setGeneratedFromId(heatArtifact.getUniqueId()); <line34> artifactHeatEnv.setHeatParamsUpdateDate(System.currentTimeMillis()); <line35> artifactHeatEnv.setTimeout(0); <line36> artifactHeatEnv.setIsFromCsar(heatArtifact.getIsFromCsar()); <line37> buildHeatEnvFileName(heatArtifact, artifactHeatEnv, placeHolderData); <line38> handleEnvArtifactVersion(artifactHeatEnv, existingEnvVersions); <line39> ArtifactDefinition heatEnvPlaceholder; <line40> if (parentType != NodeTypeEnum.ResourceInstance) { <line41> String checkSum = <line42> artifactToscaOperation.sortAndCalculateChecksumForHeatParameters( <line43> heatArtifact.getHeatParameters()); <line44> artifactHeatEnv.setArtifactChecksum(checkSum); <line45> Either<ArtifactDefinition, StorageOperationStatus> addHeatEnvArtifact = <line46> addHeatEnvArtifact(artifactHeatEnv, heatArtifact, component, parentType, parentId); <line47> if (addHeatEnvArtifact.isRight()) { <line48> throw new ByResponseFormatComponentException( <line49> componentsUtils.getResponseFormatForResourceInstance( <line50> componentsUtils.convertFromStorageResponseForResourceInstance( <line51> addHeatEnvArtifact.right().value(), false), <line52> """", <line53> null)); <line54> } <line55> heatEnvPlaceholder = createArtifactPlaceHolder; <line56> } else { <line57> heatEnvPlaceholder = artifactHeatEnv; <line58> artifactToscaOperation.generateUUID( <line59> heatEnvPlaceholder, heatEnvPlaceholder.getArtifactVersion()); <line60> setHeatCurrentValuesOnHeatEnvDefaultValues(heatArtifact, heatEnvPlaceholder); <line61> } <line62> ComponentTypeEnum componentType = component.getComponentType(); <line63> if (parentType == NodeTypeEnum.ResourceInstance) { <line64> componentType = ComponentTypeEnum.RESOURCE_INSTANCE; <line65> } <line66> createdArtifacts.add(heatEnvPlaceholder); <line67> componentsUtils.auditComponent( <line68> componentsUtils.getResponseFormat(ActionStatus.OK), <line69> user, <line70> component, <line71> AuditingActionEnum.ARTIFACT_UPLOAD, <line72> new ResourceCommonInfo(parentName, componentType.getValue()), <line73> ResourceVersionInfo.newBuilder().build(), <line74> ResourceVersionInfo.newBuilder().artifactUuid(heatEnvPlaceholder.getUniqueId()).build(), <line75> null, <line76> heatEnvPlaceholder, <line77> null); <line78> return heatEnvPlaceholder; <line79> } <line80> } <line81> "	 <line48>	Yes
"public class A { <line0> @Override <line1> public boolean processEvent(StateEvent event) { <line2> switch (type(event)) { <line3> case DISCONNECT_EVENT: <line4> setTimer(0); <line5> doEndConnection(); <line6> break; <line7> case TIMEOUT_EVENT: <line8> doDisconnect(); <line9> doEndConnection(); <line10> break; <line11> case STOP_EVENT: <line12> setTimer(0); <line13> doDisconnect(); <line14> switchToNextState(DOWN); <line15> break; <line16> case CEA_EVENT: <line17> setTimer(0); <line18> if (context.processCeaMessage(key(event), message(event))) { <line19> switchToNextState(OKAY); <line20> } else { <line21> doDisconnect(); <line22> doEndConnection(); <line23> } <line24> break; <line25> case CER_EVENT: <line26> int resultCode = context.processCerMessage(key(event), message(event)); <line27> if (resultCode == ResultCode.SUCCESS) { <line28> try { <line29> context.sendCeaMessage(resultCode, message(event), null); <line30> switchToNextState(OKAY); <line31> } catch (Exception e) { <line32> doDisconnect(); <line33> doEndConnection(); <line34> } <line35> } else if (resultCode == -1 || resultCode == ResultCode.NO_COMMON_APPLICATION) { <line36> doDisconnect(); <line37> doEndConnection(); <line38> } <line39> break; <line40> case SEND_MSG_EVENT: <line41> throw new IllegalStateException(""Connection is down""); <line42> default: <line43> return false; <line44> } <line45> return true; <line46> } <line47> } <line48> "	 <line4>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public ModuleList nextSubModuleSet() throws IOException { <line2> RingFactory coeff = nextCoefficientRing(); <line3> vars = nextVariableList(); <line4> if (vars != null) { <line5> nvars = vars.length; <line6> } <line7> tord = nextTermOrder(); <line8> initFactory(coeff, parsedCoeff); <line9> List<List<GenPolynomial>> m = null; <line10> m = nextSubModuleList(); <line11> return new ModuleList(pfac, m); <line12> } <line13> } <line14> "	 <line11>	Yes
"public class A { <line0> public List findByExample(MbMassPhase instance) { <line1> try { <line2> List results = <line3> sessionFactory <line4> .getCurrentSession() <line5> .createCriteria(""sernet.gs.reveng.MbMassPhase"") <line6> .add(Example.create(instance)) <line7> .list(); <line8> return results; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line8>	Yes
"public class A { <line0> @AfterClass <line1> public static void reportTestFinish() { <line2> stopwatch.stop(); <line3> LOGGER.warn(""-----------------------------------------""); <line4> LOGGER.warn(""*                                       *""); <line5> } <line6> } <line7> "	 <line5>	Yes
public class A { <line0> @Override <line1> public Future<Set<String>> listTopics() { <line2> try { <line3> ListTopicsOptions listOptions = new ListTopicsOptions().listInternal(true); <line4> return mapFuture(adminClient.listTopics(listOptions).names()); <line5> } catch (Exception e) { <line6> return Future.failedFuture(e); <line7> } <line8> } <line9> } <line10> 	 <line3>	Yes
public class A { <line0> public void addAllSpouts(List<SpoutDef> spouts, boolean override) { <line1> for (SpoutDef spout : spouts) { <line2> String id = spout.getId(); <line3> if (this.spoutMap.get(id) == null || override) { <line4> this.spoutMap.put(spout.getId(), spout); <line5> } else { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line7>	No
"public class A { <line0> @Test <line1> public void testDenseSearch() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> assertNotNull(em); <line4> int numEntities = 25; <line5> float minLatitude = 48.32455f; <line6> float maxLatitude = 48.46481f; <line7> float minLongitude = 9.89561f; <line8> float maxLongitude = 10.0471f; <line9> float latitudeDelta = (maxLatitude - minLatitude) / numEntities; <line10> float longitudeDelta = (maxLongitude - minLongitude) / numEntities; <line11> for (int i = 0; i < numEntities; i++) { <line12> float latitude = minLatitude + latitudeDelta * i; <line13> float longitude = minLongitude + longitudeDelta * i; <line14> Map<String, Float> location = <line15> MapUtils.hashMap(""latitude"", latitude).map(""longitude"", longitude); <line16> Map<String, Object> data = new HashMap<String, Object>(2); <line17> data.put(""name"", String.valueOf(i)); <line18> data.put(""location"", location); <line19> em.create(""store"", data); <line20> } <line21> app.waitForQueueDrainAndRefreshIndex(); <line22> int limit = 8; <line23> long startTime = System.currentTimeMillis(); <line24> Query query = Query.fromQL(""location within 1000 of 48.38626, 9.94175""); <line25> query.setLimit(limit); <line26> Results results = em.searchCollection(em.getApplicationRef(), ""stores"", query); <line27> assertEquals(0, results.size()); <line28> long endTime = System.currentTimeMillis(); <line29> } <line30> } <line31> "	 <line27>	No
public class A { <line0> @GetMapping <line1> @Override <line2> public Collection<TenantDto> getAll(@RequestParam final Optional<String> criteria) { <line3> RestUtils.checkCriteria(criteria); <line4> return internalTenantService.getAll(criteria); <line5> } <line6> } <line7> 	 <line3>	Yes
public class A { <line0> public boolean accept(String[] query) { <line1> String feedURI = getURI(); <line2> if (searchService == null) { <line3> return false; <line4> } else if (feedURI == null) { <line5> return false; <line6> } else if (query.length == 0) { <line7> return false; <line8> } <line9> String id = extractId(feedURI); <line10> if (!query[0].equalsIgnoreCase(id)) { <line11> return false; <line12> } <line13> if (selector != null && (query.length < 2 || !query[1].equalsIgnoreCase(selector))) { <line14> return false; <line15> } <line16> return true; <line17> } <line18> } <line19> 	 <line18>	No
public class A { <line0> private void showIfBetterSolutionsFound() { <line1> if (!singleSuggestionMode <line2> && bestEvaluatedDescriptions.getBestAccuracy() > currentHighestAccuracy) { <line3> currentHighestAccuracy = bestEvaluatedDescriptions.getBestAccuracy(); <line4> expressionTestCountLastImprovement = expressionTests; <line5> timeLastImprovement = System.nanoTime(); <line6> long durationInMillis = getCurrentRuntimeInMilliSeconds(); <line7> String durationStr = getDurationAsString(durationInMillis); <line8> } <line9> } <line10> } <line11> 	 <line5>	No
public class A { <line0> @Override <line1> public int deleteBackups(String[] backupIds) throws IOException { <line2> int totalDeleted = 0; <line3> Map<String, HashSet<TableName>> allTablesMap = new HashMap<>(); <line4> boolean deleteSessionStarted; <line5> boolean snapshotDone; <line6> try (final BackupSystemTable sysTable = new BackupSystemTable(conn)) { <line7> try { <line8> sysTable.startBackupExclusiveOperation(); <line9> deleteSessionStarted = true; <line10> } catch (IOException e) { <line11> return -1; <line12> } <line13> List<BackupInfo> list = sysTable.getBackupInfos(BackupState.RUNNING); <line14> if (list.size() != 0) { <line15> return -1; <line16> } <line17> sysTable.startDeleteOperation(backupIds); <line18> if (!BackupSystemTable.snapshotExists(conn)) { <line19> BackupSystemTable.snapshot(conn); <line20> } else { <line21> } <line22> snapshotDone = true; <line23> try { <line24> for (int i = 0; i < backupIds.length; i++) { <line25> BackupInfo info = sysTable.readBackupInfo(backupIds[i]); <line26> if (info != null) { <line27> String rootDir = info.getBackupRootDir(); <line28> HashSet<TableName> allTables = allTablesMap.get(rootDir); <line29> if (allTables == null) { <line30> allTables = new HashSet<>(); <line31> allTablesMap.put(rootDir, allTables); <line32> } <line33> allTables.addAll(info.getTableNames()); <line34> totalDeleted += deleteBackup(backupIds[i], sysTable); <line35> } <line36> } <line37> finalizeDelete(allTablesMap, sysTable); <line38> sysTable.finishDeleteOperation(); <line39> BackupSystemTable.deleteSnapshot(conn); <line40> } catch (IOException e) { <line41> if (snapshotDone) { <line42> if (BackupSystemTable.snapshotExists(conn)) { <line43> BackupSystemTable.restoreFromSnapshot(conn); <line44> BackupSystemTable.deleteSnapshot(conn); <line45> throw e; <line46> } else { <line47> } <line48> } <line49> } finally { <line50> if (deleteSessionStarted) { <line51> sysTable.finishBackupExclusiveOperation(); <line52> } <line53> } <line54> } <line55> return totalDeleted; <line56> } <line57> } <line58> 	 <line15>	Yes
public class A { <line0> @Override <line1> public void start(long offset) throws AdaptorException { <line2> try { <line3> bytesReceived = offset; <line4> connectionFactory = initializeConnectionFactory(brokerURL); <line5> connection = connectionFactory.createConnection(); <line6> if (topic != null) { <line7> initializeTopic(connection, topic, selector, new JMSListener()); <line8> } else if (queue != null) { <line9> initializeQueue(connection, queue, selector, new JMSListener()); <line10> } <line11> connection.start(); <line12> } catch (Exception e) { <line13> throw new AdaptorException(e); <line14> } <line15> } <line16> } <line17> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void schedule(final ReportingTaskNode taskNode) { <line2> final Runnable scheduleTask = <line3> new Runnable() { <line4> @Override <line5> public void run() { <line6> try { <line7> attemptSchedule(taskNode); <line8> schedulingAgent.schedule(taskNode, new LifecycleState()); <line9> } catch (final Exception e) { <line10> componentLifeCycleThreadPool.schedule(this, 30, TimeUnit.SECONDS); <line11> } <line12> } <line13> }; <line14> componentLifeCycleThreadPool.submit(scheduleTask); <line15> } <line16> } <line17> 	 <line16>	No
public class A { <line0> @Override <line1> public void delete(String bucket) { <line2> s3Client.deleteBucket(bucket); <line3> s3Client.waiters().bucketNotExists().run(new WaiterParameters(new HeadBucketRequest(bucket))); <line4> } <line5> } <line6> 	 <line3>	Yes
public class A { <line0> public String fetchNameServerAddr() { <line1> try { <line2> String addrs = this.topAddressing.fetchNSAddr(); <line3> if (addrs != null) { <line4> if (!addrs.equals(this.nameSrvAddr)) { <line5> this.updateNameServerAddressList(addrs); <line6> this.nameSrvAddr = addrs; <line7> return nameSrvAddr; <line8> } <line9> } <line10> } catch (Exception e) { <line11> } <line12> return nameSrvAddr; <line13> } <line14> } <line15> 	 <line5>	Yes
"public class A { <line0> private void _initializeJspServletDependantsMap() { <line1> try { <line2> Class<?> clazz = Class.forName(""org.apache.jasper.servlet.JspServletWrapper""); <line3> Method method = ReflectionUtil.getDeclaredMethod(clazz, ""getDependants""); <line4> _jspServletDependantsMap = Map.class.isAssignableFrom(method.getReturnType()); <line5> } catch (Exception exception) { <line6> } <line7> } <line8> } <line9> "	 <line0>	No
"public class A { <line0> public Integer getMrlPinType(PinDefinition pin) { <line1> if (board == null) { <line2> error(""must have pin board type to determin pin definition""); <line3> return null; <line4> } <line5> if (pin == null) { <line6> return null; <line7> } <line8> if (pin.isAnalog()) { <line9> return 1; <line10> } <line11> return 0; <line12> } <line13> } <line14> "	 <line6>	Yes
public class A { <line0> @Override <line1> protected attrstat NFSPROC_GETATTR_2(nfs_fh params) { <line2> final attrstat ret = new attrstat(); <line3> NFSFile path; <line4> try { <line5> path = pathManager.getNFSFileByHandle(params); <line6> ret.attributes = path.getAttributes(); <line7> } catch (final StaleHandleException e) { <line8> ret.status = nfsstat.NFSERR_STALE; <line9> } catch (final FileNotFoundException e) { <line10> ret.status = nfsstat.NFSERR_NOENT; <line11> } <line12> return ret; <line13> } <line14> } <line15> 	 <line6>	Yes
"public class A { <line0> @Override <line1> protected Map<String, Object> executeImplImpl(WebScriptRequest req, Status status, Cache cache) { <line2> String user = AuthenticationUtil.getFullyAuthenticatedUser(); <line3> printHeader(user, logger, req); <line4> Timer timer = new Timer(); <line5> Map<String, Object> model = new HashMap<>(); <line6> String[] accepts = req.getHeaderValues(""Accept""); <line7> String accept = (accepts != null && accepts.length != 0) ? accepts[0] : """"; <line8> if (logger.isDebugEnabled()) { <line9> } <line10> if (logger.isDebugEnabled()) { <line11> } <line12> JsonObject top = new JsonObject(); <line13> JsonArray elementsJson = handleRequest(req); <line14> try { <line15> if (elementsJson.size() > 0) { <line16> top.add(Sjm.COMMITS, elementsJson); <line17> } else { <line18> responseStatus.setCode(HttpServletResponse.SC_NOT_FOUND); <line19> } <line20> if (!Utils.isNullOrEmpty(response.toString())) <line21> top.addProperty(""message"", response.toString()); <line22> } catch (Exception e) { <line23> log(Level.ERROR, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, ""Internal error"", e); <line24> } <line25> status.setCode(responseStatus.getCode()); <line26> if (prettyPrint || accept.contains(""webp"")) { <line27> Gson gson = new GsonBuilder().setPrettyPrinting().create(); <line28> model.put(Sjm.RES, gson.toJson(top)); <line29> } else { <line30> model.put(Sjm.RES, top); <line31> } <line32> printFooter(user, logger, timer); <line33> return model; <line34> } <line35> } <line36> "	 <line26>	No
public class A { <line0> public int saveAssessmentReport(JsonObject assessmentReportJson) throws InsightsCustomException { <line1> int assessmentReportId; <line2> try { <line3> InsightsAssessmentConfiguration assessmentConfig = <line4> populateAssessmentReportConfiguration(assessmentReportJson); <line5> assessmentReportId = reportConfigDAL.saveInsightsAssessmentConfig(assessmentConfig); <line6> return assessmentReportId; <line7> } catch (InsightsCustomException e) { <line8> throw new InsightsCustomException(e.getMessage()); <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
"public class A { <line0> @SuppressWarnings({""unchecked""}) <line1> private Map<String, Object> getMap(String path, String accessToken) { <line2> try { <line3> OAuth2RestOperations restTemplate = this.restTemplate; <line4> if (restTemplate == null) { <line5> BaseOAuth2ProtectedResourceDetails resource = new BaseOAuth2ProtectedResourceDetails(); <line6> resource.setClientId(this.clientId); <line7> restTemplate = new OAuth2RestTemplate(resource); <line8> } <line9> OAuth2AccessToken existingToken = restTemplate.getOAuth2ClientContext().getAccessToken(); <line10> if (existingToken == null || !accessToken.equals(existingToken.getValue())) { <line11> DefaultOAuth2AccessToken token = new DefaultOAuth2AccessToken(accessToken); <line12> token.setTokenType(this.tokenType); <line13> restTemplate.getOAuth2ClientContext().setAccessToken(token); <line14> } <line15> return restTemplate.getForEntity(path, Map.class).getBody(); <line16> } catch (Exception ex) { <line17> return Collections.<String, Object>singletonMap(""error"", ""Could not fetch user details""); <line18> } <line19> } <line20> } <line21> "	 <line2>	Yes
"public class A { <line0> @ProcessElement <line1> public void writeMessages(ProcessContext context) { <line2> HL7v2Message msg = context.element(); <line3> Message model = new Message(); <line4> model.setData(msg.getData()); <line5> model.setLabels(msg.getLabels()); <line6> switch (writeMethod) { <line7> case BATCH_IMPORT: <line8> throw new UnsupportedOperationException(""The Batch import API is not available yet""); <line9> case INGEST: <line10> default: <line11> try { <line12> long requestTimestamp = Instant.now().getMillis(); <line13> client.ingestHL7v2Message(hl7v2Store.get(), model); <line14> messageIngestLatencyMs.update(Instant.now().getMillis() - requestTimestamp); <line15> } catch (Exception e) { <line16> failedMessageWrites.inc(); <line17> HealthcareIOError<HL7v2Message> err = HealthcareIOError.of(msg, e); <line18> context.output(err); <line19> } <line20> } <line21> } <line22> } <line23> "	 <line10>	No
"public class A { <line0> @Path(""/getAllShouldSucceed"") <line1> @POST <line2> public void getAllShouldSucceed() { <line3> String uri = String.format(URI_FORMAT, OpenstackConstants.GET_ALL); <line4> SwiftContainer[] containers = template.requestBody(uri, null, SwiftContainer[].class); <line5> assertNotNull(containers); <line6> assertEquals(2, containers.length); <line7> assertEquals(100, containers[0].getTotalSize()); <line8> assertEquals(""Test"", containers[0].getName()); <line9> assertEquals(""marktwain"", containers[1].getName()); <line10> } <line11> } <line12> "	 <line7>	No
"public class A { <line0> @Test <line1> public void parseBsonArrayWithValues() throws IOException { <line2> BsonValue a = new BsonString(""stest""); <line3> BsonValue b = new BsonDouble(111); <line4> BsonValue c = new BsonBoolean(true); <line5> BsonDocument document = <line6> new BsonDocument() <line7> .append(""int32"", new BsonInt32(12)) <line8> .append(""int64"", new BsonInt64(77L)) <line9> .append(""bo\""olean"", new BsonBoolean(true)) <line10> .append(""date"", new BsonDateTime(new Date().getTime())) <line11> .append(""double"", new BsonDouble(12.3)) <line12> .append(""string"", new BsonString(""pinpoint"")) <line13> .append(""objectId"", new BsonObjectId(new ObjectId())) <line14> .append(""code"", new BsonJavaScript(""int i = 10;"")) <line15> .append( <line16> ""codeWithScope"", <line17> new BsonJavaScriptWithScope(""int x = y"", new BsonDocument(""y"", new BsonInt32(1)))) <line18> .append(""regex"", new BsonRegularExpression(""^test.*regex.*xyz$"", ""big"")) <line19> .append(""symbol"", new BsonSymbol(""wow"")) <line20> .append(""timestamp"", new BsonTimestamp(0x12345678, 5)) <line21> .append(""undefined"", new BsonUndefined()) <line22> .append(""binary1"", new BsonBinary(new byte[] {(byte) 0xe0, 0x4f, (byte) 0xd0, 0x20})) <line23> .append( <line24> ""oldBinary"", <line25> new BsonBinary(BsonBinarySubType.OLD_BINARY, new byte[] {1, 1, 1, 1, 1})) <line26> .append(""arrayInt"", new BsonArray(Arrays.asList(a, b, c, new BsonInt32(7)))) <line27> .append(""document"", new BsonDocument(""a"", new BsonInt32(77))) <line28> .append(""dbPointer"", new BsonDbPointer(""db.coll"", new ObjectId())) <line29> .append(""null"", new BsonNull()) <line30> .append(""decimal128"", new BsonDecimal128(new Decimal128(55))); <line31> BasicDBObject query = new BasicDBObject(); <line32> query.put(""ComplexBson"", document); <line33> NormalizedBson stringStringValue = MongoUtil.parseBson(new Object[] {query}, true); <line34> List list = <line35> objectMapper.readValue(""["" + stringStringValue.getNormalizedBson() + ""]"", List.class); <line36> Assert.assertEquals(list.size(), 1); <line37> Map<String, ?> query1Map = (Map<String, ?>) list.get(0); <line38> checkValue(query1Map); <line39> } <line40> } <line41> "	 <line12>	No
public class A { <line0> private void requestVoteAsync(Node node, ElectionHandler handler, ElectionRequest request) { <line1> AsyncClient client = localMember.getAsyncHeartbeatClient(node); <line2> if (client != null) { <line3> try { <line4> client.startElection(request, handler); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line5>	No
public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_XML) <line2> public Response getProviders() { <line3> ProviderHelper providerRestService = getProviderHelper(); <line4> String serializedProviders = null; <line5> try { <line6> serializedProviders = providerRestService.getProviders(); <line7> } catch (HelperException e) { <line8> return buildResponse(e); <line9> } <line10> return buildResponse(200, serializedProviders); <line11> } <line12> } <line13> 	 <line4>	No
"public class A { <line0> @Test( <line1> groups = {""Integration""}, <line2> enabled = false) <line3> public void testModifyEtcHosts() throws Exception { <line4> LocalManagementContextForTests mgmt = new LocalManagementContextForTests(); <line5> SshMachineLocation loc = <line6> mgmt.getLocationManager() <line7> .createLocation(LocalhostMachineProvisioningLocation.spec()) <line8> .obtain(); <line9> execRequiringZeroAndReturningStdout( <line10> loc, sudo(""cp /etc/hosts /etc/hosts-orig-testModifyEtcHosts"")) <line11> .get(); <line12> int numLinesOrig = <line13> Integer.parseInt( <line14> execRequiringZeroAndReturningStdout(loc, ""wc -l /etc/hosts"") <line15> .get() <line16> .trim() <line17> .split(""\\s"")[0]); <line18> try { <line19> String cmd = <line20> BashCommands.prependToEtcHosts( <line21> ""1.2.3.4"", ""myhostnamefor1234.at.start"", ""myhostnamefor1234b""); <line22> execRequiringZeroAndReturningStdout(loc, cmd).get(); <line23> String cmd2 = <line24> BashCommands.appendToEtcHosts(""5.6.7.8"", ""myhostnamefor5678.at.end"", ""myhostnamefor5678""); <line25> execRequiringZeroAndReturningStdout(loc, cmd2).get(); <line26> String grepFirst = <line27> execRequiringZeroAndReturningStdout(loc, ""grep -n myhostnamefor1234 /etc/hosts"").get(); <line28> String grepLast = <line29> execRequiringZeroAndReturningStdout(loc, ""grep -n myhostnamefor5678 /etc/hosts"").get(); <line30> int numLinesAfter = <line31> Integer.parseInt( <line32> execRequiringZeroAndReturningStdout(loc, ""wc -l /etc/hosts"") <line33> .get() <line34> .trim() <line35> .split(""\\s"")[0]); <line36> assertTrue( <line37> grepFirst.startsWith(""1:"") <line38> && grepFirst.contains(""1.2.3.4 myhostnamefor1234.at.start myhostnamefor1234""), <line39> ""first="" + grepFirst); <line40> assertTrue( <line41> grepLast.startsWith((numLinesOrig + 2) + "":"") <line42> && grepLast.contains(""5.6.7.8 myhostnamefor5678.at.end myhostnamefor5678""), <line43> ""last="" + grepLast); <line44> assertEquals( <line45> numLinesOrig + 2, <line46> numLinesAfter, <line47> ""lines orig="" + numLinesOrig + "", after="" + numLinesAfter); <line48> } finally { <line49> execRequiringZeroAndReturningStdout( <line50> loc, sudo(""cp /etc/hosts-orig-testModifyEtcHosts /etc/hosts"")) <line51> .get(); <line52> } <line53> } <line54> } <line55> "	 <line36>	Yes
public class A { <line0> List<EventID> getDispatchedEvents(InternalCache cache) { <line1> LocalRegion region = (LocalRegion) cache.getRegion(regionName); <line2> if (region == null) { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> return null; <line6> } <line7> HARegionQueue haRegionQueue = ((HARegion) region).getOwner(); <line8> return haRegionQueue.getDispatchedEvents(eventIds); <line9> } <line10> } <line11> 	 <line1>	No
public class A { <line0> private void findDefaultAutoIncrementingColumn(Connection db) throws SQLException { <line1> if (incrementingColumnName != null && incrementingColumnName.isEmpty()) { <line2> for (ColumnDefinition defn : <line3> dialect <line4> .describeColumns( <line5> db, tableId.catalogName(), tableId.schemaName(), tableId.tableName(), null) <line6> .values()) { <line7> if (defn.isAutoIncrement()) { <line8> incrementingColumnName = defn.id().name(); <line9> break; <line10> } <line11> } <line12> } <line13> if (incrementingColumnName != null && incrementingColumnName.isEmpty()) { <line14> for (ColumnDefinition defn : dialect.describeColumnsByQuerying(db, tableId).values()) { <line15> if (defn.isAutoIncrement()) { <line16> incrementingColumnName = defn.id().name(); <line17> break; <line18> } <line19> } <line20> } <line21> } <line22> } <line23> 	 <line14>	Yes
public class A { <line0> @Override <line1> public boolean isFileSystemItem( <line2> DocumentModel doc, boolean includeDeleted, boolean relaxSyncRootConstraint) { <line3> boolean isUserWorkspace = UserWorkspaceHelper.isUserWorkspace(doc); <line4> if (!isUserWorkspace) { <line5> return false; <line6> } <line7> return true; <line8> } <line9> } <line10> 	 <line5>	Yes
public class A { <line0> private void doDispose() { <line1> if (artifactContext == null) { <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> return; <line5> } <line6> try { <line7> stop(); <line8> } catch (DeploymentStopException e) { <line9> } <line10> artifactContext.getMuleContext().dispose(); <line11> artifactContext = null; <line12> } <line13> } <line14> 	 <line10>	No
"public class A { <line0> public static java.util.List<com.liferay.wiki.model.WikiNode> getNodes( <line1> HttpPrincipal httpPrincipal, long groupId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey(WikiNodeServiceUtil.class, ""getNodes"", _getNodesParameterTypes5); <line6> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line7> Object returnObj = null; <line8> try { <line9> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line10> } catch (Exception exception) { <line11> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line12> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line13> } <line14> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line15> } <line16> return (java.util.List<com.liferay.wiki.model.WikiNode>) returnObj; <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	 <line18>	Yes
"public class A { <line0> private GeoEvent parseInfoParameter(Element element, String identifier, String infoID) { <line1> GeoEvent msg; <line2> try { <line3> msg = <line4> geoEventCreator.create( <line5> ((AdapterDefinition) definition).getGeoEventDefinition(""CAPInfoParameter"").getGuid()); <line6> try { <line7> msg.setField(0, identifier); <line8> } catch (Exception ex) { <line9> } <line10> try { <line11> msg.setField(1, infoID); <line12> } catch (Exception ex) { <line13> } <line14> NodeList nodeList; <line15> Element line; <line16> String strValue = """"; <line17> String tagName = """"; <line18> try { <line19> tagName = ""valueName""; <line20> nodeList = element.getElementsByTagName(tagName); <line21> line = (Element) nodeList.item(0); <line22> strValue = getCharacterDataFromElement(line); <line23> msg.setField(2, strValue); <line24> } catch (Exception ex) { <line25> LOG.debug(""Failed to set 'Parameter "" + tagName + ""': "" + strValue); <line26> } <line27> try { <line28> tagName = ""value""; <line29> nodeList = element.getElementsByTagName(tagName); <line30> line = (Element) nodeList.item(0); <line31> strValue = getCharacterDataFromElement(line); <line32> msg.setField(3, strValue); <line33> } catch (Exception ex) { <line34> } <line35> } catch (MessagingException e) { <line36> return null; <line37> } <line38> return msg; <line39> } <line40> } <line41> "	 <line13>	Yes
"public class A { <line0> private List<Testcase> parseTestCases(DriverTestsuite driverTestsuite) { <line1> List<Testcase> testcases = <line2> testsuiteXml.elements(new QName(""testcase"")).stream() <line3> .map( <line4> testcaseXml -> { <line5> Testcase testcase = <line6> new Testcase( <line7> driverTestsuite, <line8> extractText(testcaseXml, ""name""), <line9> parseDescription(testcaseXml), <line10> parseSteps(testcaseXml, driverTestsuite.driverTestsuiteConfiguration), <line11> synchronizer); <line12> if (testcaseXml instanceof LocationAwareElement) { <line13> testcase.setLocation(((LocationAwareElement) testcaseXml).getLocation()); <line14> } <line15> return testcase; <line16> }) <line17> .collect(Collectors.toList()); <line18> return testcases; <line19> } <line20> } <line21> "	 <line16>	No
public class A { <line0> private static void stopSCM(StorageContainerManager scm) { <line1> if (scm != null) { <line2> scm.stop(); <line3> scm.join(); <line4> } <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> public List<InsightsWorkflowExecutionHistory> getWorkflowExecutionHistoryRecordsByWorkflowId( <line1> String workflowId) { <line2> try { <line3> Map<String, Object> parameters = new HashMap<>(); <line4> Map<String, Object> extraParameters = new HashMap<>(); <line5> parameters.put(AssessmentReportAndWorkflowConstants.WORKFLOW_ID, workflowId); <line6> extraParameters.put(""MaxResults"", 5); <line7> List<Long> executionIds = <line8> executeQueryWithExtraParameter( <line9> ""select distinct executionId FROM InsightsWorkflowExecutionHistory EH WHERE"" <line10> + "" EH.workflowConfig.workflowId = :workflowId ORDER BY executionId DESC"", <line11> Long.class, <line12> parameters, <line13> extraParameters); <line14> parameters.clear(); <line15> extraParameters.clear(); <line16> extraParameters.put(""executionIDs"", executionIds); <line17> return executeQueryWithExtraParameter( <line18> ""FROM InsightsWorkflowExecutionHistory EH WHERE EH.executionId IN (:executionIDs) ORDER"" <line19> + "" BY executionId DESC"", <line20> InsightsWorkflowExecutionHistory.class, <line21> parameters, <line22> extraParameters); <line23> } catch (Exception e) { <line24> throw e; <line25> } <line26> } <line27> } <line28> "	 <line24>	Yes
public class A { <line0> protected void doDeployment(String site, String environment, boolean waitTillDone) { <line1> String requestUrl = getDeployTargetUrl(site, environment); <line2> HttpPost postRequest = new HttpPost(requestUrl); <line3> if (waitTillDone) { <line4> String requestBody = getDeployTargetRequestBody(true); <line5> HttpEntity requestEntity = new StringEntity(requestBody, ContentType.APPLICATION_JSON); <line6> postRequest.setEntity(requestEntity); <line7> } <line8> try { <line9> CloseableHttpResponse response = httpClient.execute(postRequest); <line10> HttpStatus httpStatus = HttpStatus.valueOf(response.getStatusLine().getStatusCode()); <line11> if (!httpStatus.is2xxSuccessful()) { <line12> } <line13> } catch (IOException e) { <line14> } finally { <line15> postRequest.releaseConnection(); <line16> } <line17> } <line18> } <line19> 	 <line18>	No
public class A { <line0> @Override <line1> public void perform() throws Exception { <line2> ServerName master = cluster.getClusterMetrics().getMasterName(); <line3> restartMaster(master, sleepTime); <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void destroyNode(String id) { <line2> VirtualGuest guest = getNode(id); <line3> if (guest == null) return; <line4> if (guest.getBillingItemId() == -1) <line5> throw new IllegalStateException( <line6> String.format(""no billing item for guest(%s) so we cannot cancel the order"", id)); <line7> client.getVirtualGuestClient().cancelService(guest.getBillingItemId()); <line8> } <line9> } <line10> "	 <line7>	Yes
"public class A { <line0> @Test <line1> public void testGetRepositoryPath() { <line2> cmisObject <line3> .getProperties() <line4> .getProperties() <line5> .add(new PropertyId(PropertiesBase.OBJECTID, ""repository"")); <line6> cmisObject <line7> .getProperties() <line8> .getProperties() <line9> .add(new PropertyString(PropertiesBase.OBJECTTYPEID, CmisObject.OBJECT_TYPE_FOLDER)); <line10> String path = navService.getRepositoryPath(cmisObject); <line11> assertTrue(""repository"".equals(path)); <line12> cmisObject.setProperties(new CmisProperties()); <line13> cmisObject <line14> .getProperties() <line15> .getProperties() <line16> .add(new PropertyId(PropertiesBase.OBJECTID, ""/admin/pat"")); <line17> cmisObject <line18> .getProperties() <line19> .getProperties() <line20> .add(new PropertyString(PropertiesBase.OBJECTTYPEID, null)); <line21> path = navService.getRepositoryPath(cmisObject); <line22> assertTrue(""Repository path as expected"", ""/admin"".equals(path)); <line23> cmisObject.setProperties(new CmisProperties()); <line24> cmisObject <line25> .getProperties() <line26> .getProperties() <line27> .add(new PropertyId(PropertiesBase.OBJECTID, ""repository"")); <line28> cmisObject <line29> .getProperties() <line30> .getProperties() <line31> .add(new PropertyString(PropertiesBase.OBJECTTYPEID, null)); <line32> path = navService.getRepositoryPath(cmisObject); <line33> assertTrue(""Repository path as expected"", """".equals(path)); <line34> } <line35> } <line36> "	 <line10>	No
public class A { <line0> @PreDestroy <line1> public void restoreProperties() { <line2> try { <line3> for (Map.Entry<String, Map<String, Object>> entry : modifiedSahiConfigProps.entrySet()) { <line4> String propFile = entry.getKey(); <line5> PropertiesConfiguration propConfig = new PropertiesConfiguration(propFile); <line6> propConfig.setAutoSave(true); <line7> for (Map.Entry<String, Object> propEntry : entry.getValue().entrySet()) { <line8> String propKey = propEntry.getKey(); <line9> if (propConfig.containsKey(propKey)) { <line10> propConfig.clearProperty(propKey); <line11> } <line12> propConfig.addProperty(propKey, propEntry.getValue()); <line13> } <line14> } <line15> } catch (ConfigurationException e) { <line16> } <line17> } <line18> } <line19> 	 <line9>	No
"public class A { <line0> private GitHubPRCause checkComment( <line1> GitHubPRDecisionContext prDecisionContext, <line2> GHIssueComment issueComment, <line3> GitHubPRUserRestriction userRestriction, <line4> TaskListener listener) { <line5> GitHubPRCause cause = null; <line6> try { <line7> String body = issueComment.getBody(); <line8> if (isNull(userRestriction) || userRestriction.isWhitelisted(issueComment.getUser())) { <line9> final Matcher matcher = Pattern.compile(comment).matcher(body); <line10> if (matcher.matches()) { <line11> listener.getLogger().println(DISPLAY_NAME + "": matching comment "" + body); <line12> cause = prDecisionContext.newCause(""Comment matches to criteria."", false); <line13> cause.withCommentBody(body); <line14> if (matcher.groupCount() > 0) { <line15> cause.withCommentBodyMatch(matcher.group(1)); <line16> } <line17> } <line18> } <line19> } catch (IOException ex) { <line20> } <line21> return cause; <line22> } <line23> } <line24> "	 <line2>	No
public class A { <line0> public void exportAccountBalances(Supplier<String> dir) { <line1> AllAccountBalances.Builder allAccountBalancesBuilder = <line2> AllAccountBalances.newBuilder().addAllAllAccounts(accountBalances); <line3> try (FileOutputStream fout = new FileOutputStream(dir.get())) { <line4> allAccountBalancesBuilder.build().writeTo(fout); <line5> } catch (IOException e) { <line6> return; <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
"public class A { <line0> public NetworkPolicy generateNetworkPolicy( <line1> boolean connectorOperatorEnabled, String operatorNamespace, Labels operatorNamespaceLabels) { <line2> if (connectorOperatorEnabled) { <line3> List<NetworkPolicyIngressRule> rules = new ArrayList<>(2); <line4> NetworkPolicyIngressRule restApiRule = <line5> new NetworkPolicyIngressRuleBuilder() <line6> .addNewPort() <line7> .withNewPort(REST_API_PORT) <line8> .withNewProtocol(""TCP"") <line9> .endPort() <line10> .build(); <line11> List<NetworkPolicyPeer> peers = new ArrayList<>(2); <line12> NetworkPolicyPeer connectPeer = <line13> new NetworkPolicyPeerBuilder() <line14> .withNewPodSelector() <line15> .addToMatchLabels(getSelectorLabels().toMap()) <line16> .endPodSelector() <line17> .build(); <line18> peers.add(connectPeer); <line19> NetworkPolicyPeer clusterOperatorPeer = <line20> new NetworkPolicyPeerBuilder() <line21> .withNewPodSelector() <line22> .addToMatchLabels(Labels.STRIMZI_KIND_LABEL, ""cluster-operator"") <line23> .endPodSelector() <line24> .build(); <line25> ModelUtils.setClusterOperatorNetworkPolicyNamespaceSelector( <line26> clusterOperatorPeer, namespace, operatorNamespace, operatorNamespaceLabels); <line27> peers.add(clusterOperatorPeer); <line28> restApiRule.setFrom(peers); <line29> rules.add(restApiRule); <line30> if (isMetricsEnabled) { <line31> NetworkPolicyIngressRule metricsRule = <line32> new NetworkPolicyIngressRuleBuilder() <line33> .addNewPort() <line34> .withNewPort(METRICS_PORT) <line35> .withNewProtocol(""TCP"") <line36> .endPort() <line37> .withFrom() <line38> .build(); <line39> rules.add(metricsRule); <line40> } <line41> NetworkPolicy networkPolicy = <line42> new NetworkPolicyBuilder() <line43> .withNewMetadata() <line44> .withName(name) <line45> .withNamespace(namespace) <line46> .withLabels(labels.toMap()) <line47> .withOwnerReferences(createOwnerReference()) <line48> .endMetadata() <line49> .withNewSpec() <line50> .withNewPodSelector() <line51> .addToMatchLabels(getSelectorLabels().toMap()) <line52> .endPodSelector() <line53> .withIngress(rules) <line54> .endSpec() <line55> .build(); <line56> return networkPolicy; <line57> } else { <line58> return null; <line59> } <line60> } <line61> } <line62> "	 <line56>	Yes
public class A { <line0> @Override <line1> public ZNRecord computePartitionAssignment( <line2> final List<String> allNodes, <line3> final List<String> liveNodes, <line4> final Map<String, Map<String, String>> currentMapping, <line5> ResourceControllerDataProvider clusterData) { <line6> int numReplicas = countStateReplicas(); <line7> ZNRecord znRecord = new ZNRecord(_resourceName); <line8> if (liveNodes.size() == 0) { <line9> return znRecord; <line10> } <line11> List<String> sortedAllNodes = new ArrayList<String>(allNodes); <line12> Collections.sort(sortedAllNodes); <line13> Comparator<String> currentStateNodeComparator = new CurrentStateNodeComparator(currentMapping); <line14> List<String> sortedLiveNodes = new ArrayList<String>(liveNodes); <line15> Collections.sort(sortedLiveNodes, currentStateNodeComparator); <line16> int distRemainder = (numReplicas * _partitions.size()) % sortedLiveNodes.size(); <line17> int distFloor = (numReplicas * _partitions.size()) / sortedLiveNodes.size(); <line18> _nodeMap = new HashMap<String, Node>(); <line19> _liveNodesList = new ArrayList<Node>(); <line20> for (String id : sortedAllNodes) { <line21> Node node = new Node(id); <line22> node.capacity = 0; <line23> node.hasCeilingCapacity = false; <line24> _nodeMap.put(id, node); <line25> } <line26> for (int i = 0; i < sortedLiveNodes.size(); i++) { <line27> boolean usingCeiling = false; <line28> int targetSize = (_maximumPerNode > 0) ? Math.min(distFloor, _maximumPerNode) : distFloor; <line29> if (distRemainder > 0 && targetSize < _maximumPerNode) { <line30> targetSize += 1; <line31> distRemainder = distRemainder - 1; <line32> usingCeiling = true; <line33> } <line34> Node node = _nodeMap.get(sortedLiveNodes.get(i)); <line35> node.isAlive = true; <line36> node.capacity = targetSize; <line37> node.hasCeilingCapacity = usingCeiling; <line38> _liveNodesList.add(node); <line39> } <line40> _stateMap = generateStateMap(); <line41> _preferredAssignment = computePreferredPlacement(sortedAllNodes); <line42> _existingPreferredAssignment = computeExistingPreferredPlacement(currentMapping); <line43> _existingNonPreferredAssignment = computeExistingNonPreferredPlacement(currentMapping); <line44> _orphaned = computeOrphaned(); <line45> if (_orphaned.size() > 0 && logger.isInfoEnabled()) { <line46> } <line47> assignOrphans(); <line48> moveNonPreferredReplicasToPreferred(); <line49> moveExcessReplicas(); <line50> if (_orphaned.size() > 0) { <line51> forceToAssignOrphans(); <line52> } <line53> prepareResult(znRecord); <line54> return znRecord; <line55> } <line56> } <line57> 	 <line38>	No
public class A { <line0> @Override <line1> public void shutdown() { <line2> if (log.isDebugEnabled()) { <line3> } <line4> scheduler.shutdown(); <line5> } <line6> } <line7> 	 <line3>	Yes
"public class A { <line0> public Message createMessage(Session session) throws JMSException { <line1> Message answer = endpoint.getBinding().makeJmsMessage(exchange, in, session, null); <line2> Object jmsReplyTo = JmsMessageHelper.getJMSReplyTo(answer); <line3> if (endpoint.isDisableReplyTo()) { <line4> JmsMessageHelper.setJMSReplyTo(answer, null); <line5> } else { <line6> if (jmsReplyTo == null) { <line7> jmsReplyTo = exchange.getIn().getHeader(""JMSReplyTo"", String.class); <line8> if (jmsReplyTo == null) { <line9> jmsReplyTo = endpoint.getReplyTo(); <line10> } <line11> } <line12> } <line13> if (jmsReplyTo != null <line14> && !(endpoint.isPreserveMessageQos() || endpoint.isExplicitQosEnabled())) { <line15> if (LOG.isDebugEnabled()) { <line16> } <line17> jmsReplyTo = null; <line18> } <line19> if (jmsReplyTo instanceof String) { <line20> String replyTo = (String) jmsReplyTo; <line21> jmsReplyTo = resolveOrCreateDestination(replyTo, session); <line22> } <line23> Destination replyTo = null; <line24> String replyToOverride = endpoint.getConfiguration().getReplyToOverride(); <line25> if (replyToOverride != null) { <line26> replyTo = resolveOrCreateDestination(replyToOverride, session); <line27> } else if (jmsReplyTo instanceof Destination) { <line28> replyTo = (Destination) jmsReplyTo; <line29> } <line30> if (replyTo != null) { <line31> JmsMessageHelper.setJMSReplyTo(answer, replyTo); <line32> } else { <line33> JmsMessageHelper.setJMSReplyTo(answer, null); <line34> } <line35> return answer; <line36> } <line37> } <line38> "	 <line31>	Yes
public class A { <line0> public static com.liferay.portal.kernel.model.LayoutSoap fetchLayout( <line1> long groupId, boolean privateLayout, long layoutId) throws RemoteException { <line2> try { <line3> com.liferay.portal.kernel.model.Layout returnValue = <line4> LayoutServiceUtil.fetchLayout(groupId, privateLayout, layoutId); <line5> return com.liferay.portal.kernel.model.LayoutSoap.toSoapModel(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line0>	No
"public class A { <line0> public String encrypt(final String str) { <line1> try { <line2> byte[] utf8 = str.getBytes(""UTF8""); <line3> byte[] enc = ecipher.doFinal(utf8); <line4> return Base64.encodeBase64String(enc); <line5> } catch (UnsupportedEncodingException e) { <line6> throw new ApplicationException(""DesEncrypter failed - UnsupportedEncodingException "", e); <line7> } catch (GeneralSecurityException e) { <line8> throw new ApplicationException( <line9> ""DesEncrypter encryption failed - GeneralSecurityException"", e); <line10> } <line11> } <line12> } <line13> "	 <line12>	No
public class A { <line0> public TransactionReceipt transfer(Transaction transaction) throws Throwable { <line1> TransactionBody txBody = <line2> com.hedera.services.legacy.proto.utils.CommonUtils.extractTransactionBody(transaction); <line3> Instant consensusTime = new Date().toInstant(); <line4> TransactionRecord record = cryptoHandler.cryptoTransfer(txBody, consensusTime); <line5> Assert.assertNotNull(record); <line6> TransactionReceipt receipt = record.getReceipt(); <line7> return receipt; <line8> } <line9> } <line10> 	 <line6>	No
"public class A { <line0> Flowable<SearchRequest> syncIndices(Throwable error) { <line1> if (error instanceof ElasticsearchResponseErrorStreamable) { <line2> boolean indexNotFound = <line3> ((ElasticsearchResponseErrorStreamable) error) <line4> .stream().anyMatch(err -> ""index_not_found_exception"".equals(err.getType())); <line5> if (indexNotFound && !stopped.get()) { <line6> return syncEventHandler <line7> .generateSyncRequests() <line8> .doOnNext( <line9> request -> { <line10> idleChecker.addAndGetRequests(request.requestCount()); <line11> }) <line12> .concatMap(this::sendRequest, 1); <line13> } <line14> } <line15> } <line16> } <line17> "	 <line12>	Yes
"public class A { <line0> @Override <line1> public int compare(JSONObject a, JSONObject b) { <line2> if (a != null && b != null) { <line3> try { <line4> String aS = (String) a.get(""name""); <line5> String bS = (String) b.get(""name""); <line6> return aS.compareToIgnoreCase(bS); <line7> } catch (JSONException ex) { <line8> return 1; <line9> } <line10> } else { <line11> return 1; <line12> } <line13> } <line14> } <line15> "	 <line8>	Yes
public class A { <line0> private void createNetModeTransaction() { <line1> final List<ByteString> argList = new ArrayList<>(); <line2> Lifecycle.InstallChaincodeArgs installChaincodeArgs = <line3> Lifecycle.InstallChaincodeArgs.newBuilder() <line4> .setChaincodeInstallPackage(ByteString.copyFrom(chaincodeBytes)) <line5> .build(); <line6> argList.add(ByteString.copyFromUtf8(action)); <line7> argList.add(ByteString.copyFrom(installChaincodeArgs.toByteArray())); <line8> args(argList); <line9> } <line10> } <line11> 	 <line3>	No
"public class A { <line0> @Override <line1> public void joinTournament(final UUID tournamentId, final String sessionId) throws MageException { <line2> execute( <line3> ""joinTournament"", <line4> sessionId, <line5> () -> { <line6> Optional<Session> session = managerFactory.sessionManager().getSession(sessionId); <line7> if (!session.isPresent()) { <line8> } else { <line9> UUID userId = session.get().getUserId(); <line10> managerFactory.tournamentManager().joinTournament(tournamentId, userId); <line11> } <line12> }); <line13> } <line14> } <line15> "	 <line8>	Yes
"public class A { <line0> byte[] readWithChecksum(int length) throws Exception { <line1> byte[] b = new byte[length]; <line2> for (int i = 0; i < length; i++) { <line3> b[i] = (byte) (read(false) & 0xff); <line4> } <line5> int checksum = read(false); <line6> StringBuffer sb = new StringBuffer(); <line7> for (int i = 0; i < b.length; i++) { <line8> sb.append(String.format(""%02x"", b[i] & 0xff)); <line9> } <line10> sb.append(String.format(""%02x"", checksum & 0xff)); <line11> return b; <line12> } <line13> } <line14> "	 <line11>	Yes
public class A { <line0> @Override <line1> public synchronized long lastModified() { <line2> long lastMod = 0L; <line3> try { <line4> ObjStat objStat = irodsFileSystemAO.getObjStat(getAbsolutePath()); <line5> lastMod = objStat.getModifiedAt().getTime(); <line6> } catch (FileNotFoundException e) { <line7> } catch (JargonException e) { <line8> throw new JargonRuntimeException(e); <line9> } <line10> return lastMod; <line11> } <line12> } <line13> 	 <line0>	No
"public class A { <line0> private void showNoRepoLoadedNotification(NotificationController nc) { <line1> Platform.runLater( <line2> () -> { <line3> nc.addNotification( <line4> ""You need to load a repository before you can perform operations on it. Click on the"" <line5> + "" plus sign in the upper left corner!""); <line6> }); <line7> } <line8> } <line9> "	 <line3>	Yes
public class A { <line0> public void invalid(Supplier<String> what, Supplier<String> reason) { <line1> if (LOG.isWarnEnabled()) { <line2> } <line3> } <line4> } <line5> 	 <line3>	No
public class A { <line0> public List<IndexedRecord> convertLeadRecords( <line1> List<LeadRecord> recordList, Schema schema, Map<String, String> mappings) { <line2> List<IndexedRecord> results = new ArrayList<>(); <line3> for (LeadRecord input : recordList) { <line4> IndexedRecord record = new Record(schema); <line5> for (Field f : schema.getFields()) { <line6> String col = mappings.get(f.name()); <line7> if (col == null) { <line8> continue; <line9> } <line10> switch (col) { <line11> case FIELD_ID: <line12> record.put(f.pos(), input.getId() != null ? input.getId().getValue() : null); <line13> break; <line14> case FIELD_EMAIL: <line15> record.put(f.pos(), input.getEmail() != null ? input.getEmail().getValue() : null); <line16> break; <line17> case FIELD_FOREIGN_SYS_PERSON_ID: <line18> record.put( <line19> f.pos(), <line20> input.getForeignSysPersonId() != null <line21> ? input.getForeignSysPersonId().getValue() <line22> : null); <line23> break; <line24> case FIELD_FOREIGN_SYS_TYPE: <line25> record.put( <line26> f.pos(), <line27> input.getForeignSysType() != null && input.getForeignSysType().getValue() != null <line28> ? input.getForeignSysType().getValue().value() <line29> : null); <line30> break; <line31> default: <line32> if (!input.getLeadAttributeList().isNil()) { <line33> for (Attribute attr : input.getLeadAttributeList().getValue().getAttributes()) { <line34> if (attr.getAttrName().equals(col)) { <line35> record.put(f.pos(), attr.getAttrValue()); <line36> } <line37> } <line38> } <line39> } <line40> } <line41> results.add(record); <line42> } <line43> return results; <line44> } <line45> } <line46> 	 <line29>	No
public class A { <line0> private AddressBook parseHistoricAddressBooks() { <line1> var fileDataEntries = 0; <line2> long currentConsensusTimestamp = 0; <line3> AddressBook lastAddressBook = null; <line4> var pageSize = 1000; <line5> List<FileData> fileDataList = <line6> fileDataRepository.findAddressBooksAfter(currentConsensusTimestamp, pageSize); <line7> while (!CollectionUtils.isEmpty(fileDataList)) { <line8> for (FileData fileData : fileDataList) { <line9> if (fileData.getFileData() != null && fileData.getFileData().length > 0) { <line10> lastAddressBook = parse(fileData); <line11> fileDataEntries++; <line12> } <line13> currentConsensusTimestamp = fileData.getConsensusTimestamp(); <line14> } <line15> fileDataList = fileDataRepository.findAddressBooksAfter(currentConsensusTimestamp, pageSize); <line16> } <line17> return lastAddressBook; <line18> } <line19> } <line20> 	 <line17>	Yes
public class A { <line0> public void onComplete(Void o) { <line1> grantNamespacePermission_result result = new grantNamespacePermission_result(); <line2> try { <line3> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line4> } catch (org.apache.thrift.transport.TTransportException e) { <line5> fb.close(); <line6> } catch (java.lang.Exception e) { <line7> onError(e); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> public static QLog initial(String[] args, int type) { <line1> loggerType = type; <line2> QConfig.cfg(type).prepareCLI(args); <line3> final QLog log = LogerHolder.INSTANCE; <line4> About.load(); <line5> if (QConfig.cfg().isServer()) { <line6> } <line7> QLog.l() <line8> .logger <line9> if (QConfig.cfg().isUbtnStart()) { <line10> } <line11> return log; <line12> } <line13> } <line14> 	 <line13>	No
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap[] <line1> getCommerceInventoryWarehouseItems(long companyId, String sku, int start, int end) <line2> throws RemoteException { <line3> try { <line4> java.util.List<com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItem> <line5> returnValue = <line6> CommerceInventoryWarehouseItemServiceUtil.getCommerceInventoryWarehouseItems( <line7> companyId, sku, start, end); <line8> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseItemSoap.toSoapModels( <line9> returnValue); <line10> } catch (Exception exception) { <line11> throw new RemoteException(exception.getMessage()); <line12> } <line13> } <line14> } <line15> 	 <line4>	No
"public class A { <line0> @Override <line1> public void perform() throws Exception { <line2> ClusterMetrics status = this.cluster.getClusterMetrics(); <line3> List<ServerName> victimServers = new LinkedList<>(status.getLiveServerMetrics().keySet()); <line4> Set<ServerName> killedServers = new HashSet<>(); <line5> int liveCount = (int) Math.ceil(FRC_SERVERS_THAT_HOARD_AND_LIVE * victimServers.size()); <line6> int deadCount = (int) Math.ceil(FRC_SERVERS_THAT_HOARD_AND_DIE * victimServers.size()); <line7> Assert.assertTrue( <line8> ""There are not enough victim servers: "" + victimServers.size(), <line9> liveCount + deadCount < victimServers.size()); <line10> List<ServerName> targetServers = new ArrayList<>(liveCount); <line11> for (int i = 0; i < liveCount + deadCount; ++i) { <line12> int victimIx = RandomUtils.nextInt(0, victimServers.size()); <line13> targetServers.add(victimServers.remove(victimIx)); <line14> } <line15> unbalanceRegions(status, victimServers, targetServers, HOARD_FRC_OF_REGIONS); <line16> Thread.sleep(waitForUnbalanceMilliSec); <line17> ServerName metaServer = cluster.getServerHoldingMeta(); <line18> for (ServerName targetServer : targetServers) { <line19> if (context.isStopping()) { <line20> break; <line21> } <line22> if (killedServers.size() >= liveCount) { <line23> break; <line24> } <line25> if (!killMetaRs && targetServer.equals(metaServer)) { <line26> } else { <line27> killRs(targetServer); <line28> killedServers.add(targetServer); <line29> } <line30> } <line31> Thread.sleep(waitForKillsMilliSec); <line32> forceBalancer(); <line33> Thread.sleep(waitAfterBalanceMilliSec); <line34> for (ServerName server : killedServers) { <line35> startRs(server); <line36> } <line37> } <line38> } <line39> "	 <line26>	Yes
"public class A { <line0> public void handleTimerEvent(ActionEvent e) { <line1> if (myPayload.getTimeBudget().isExpired()) { <line2> StringBuilder error = new StringBuilder(150); <line3> error.append(""Timed out waiting for ""); <line4> int numServicesWaiting = 0; <line5> if (myWmsWaiting) { <line6> numServicesWaiting++; <line7> error.append(""WMS ""); <line8> } <line9> if (myWfsWaiting) { <line10> numServicesWaiting++; <line11> error.append(""WFS ""); <line12> } <line13> if (myWpsWaiting) { <line14> numServicesWaiting++; <line15> error.append(""WPS ""); <line16> } <line17> error <line18> .append(numServicesWaiting > 1 ? ""responses"" : ""response"") <line19> .append("" from Server: "") <line20> .append(mySource.getName()); <line21> error.append("".  Consider increasing timeout settings in Edit->Settings->Servers.""); <line22> sendResponseAndCleanup(error.toString()); <line23> } else { <line24> myResponseTimer.setInitialDelay(myPayload.getTimeBudget().getRemainingMilliseconds()); <line25> myResponseTimer.start(); <line26> } <line27> } <line28> } <line29> "	 <line14>	No
public class A { <line0> @Override <line1> public void manageTransitions(Coordinator coordinator, RingGroup ringGroup) throws IOException { <line2> DomainGroup domainGroup = ringGroup.getDomainGroup(); <line3> if (domainGroup == null) { <line4> return; <line5> } <line6> Map<Domain, Map<Integer, Set<Host>>> domainToPartitionToHostsFullyServing = <line7> PartitionUtils.domainToPartitionToHostsServing(ringGroup, status); <line8> ThreeNestedMap<Domain, Integer, String, Long> domainPartitionBucketHostCounts = <line9> PartitionUtils.domainToPartitionToHostsServingInBucket( <line10> domainToPartitionToHostsFullyServing, status); <line11> SortedSet<Ring> rings = ringGroup.getRingsSorted(); <line12> int ringCount = rings.size(); <line13> for (Ring ring : rings) { <line14> partitionAssigner.prepare( <line15> ring, domainGroup.getDomainVersions(), ringGroup.getRingGroupConductorMode()); <line16> for (Host host : ring.getHostsSorted()) { <line17> manageTransitions( <line18> ringCount, <line19> host, <line20> domainGroup, <line21> domainToPartitionToHostsFullyServing, <line22> domainPartitionBucketHostCounts); <line23> } <line24> } <line25> } <line26> } <line27> 	 <line12>	No
public class A { <line0> @Override <line1> public Double visit(LessEqualFilter lessEqualFilter) { <line2> int minBound = <line3> 9 <line4> - IntStream.rangeClosed(0, 9) <line5> .filter(i -> percentiles[9 - i] <= lessEqualFilter.getValue().doubleValue()) <line6> .findFirst() <line7> .orElse(0); <line8> final double result = ((double) minBound + 1.0) / 10.0; <line9> return result; <line10> } <line11> } <line12> 	 <line9>	Yes
public class A { <line0> @Override <line1> protected void afterDump(ErosaConnection connection) { <line2> if (metaConnection != null) { <line3> try { <line4> metaConnection.disconnect(); <line5> } catch (IOException e) { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
"public class A { <line0> private Promise<NetconfClientSession> doActivate( <line1> final Channel ch, final NetconfClientSessionListener listener) { <line2> final Promise<NetconfClientSession> activationPromise = newSessionPromise(); <line3> if (activated.compareAndExchange(false, true)) { <line4> return activationPromise.setFailure( <line5> new IllegalStateException(""Session (channel) already activated."")); <line6> } <line7> final NetconfClientSessionNegotiatorFactory negotiatorFactory = <line8> new NetconfClientSessionNegotiatorFactory( <line9> new HashedWheelTimer(), Optional.empty(), TimeUnit.SECONDS.toMillis(5)); <line10> final TlsClientChannelInitializer tlsClientChannelInitializer = <line11> new TlsClientChannelInitializer(sslHandlerFactory, negotiatorFactory, listener); <line12> tlsClientChannelInitializer.initialize(ch, activationPromise); <line13> return activationPromise; <line14> } <line15> } <line16> "	 <line8>	No
public class A { <line0> @Override <line1> public void setAttribute(AlluxioURI path, SetAttributePOptions options) <line2> throws FileDoesNotExistException, IOException, AlluxioException { <line3> checkUri(path); <line4> SetAttributePOptions mergedOptions = <line5> FileSystemOptions.setAttributeClientDefaults(mFsContext.getPathConf(path)).toBuilder() <line6> .mergeFrom(options) <line7> .build(); <line8> rpc( <line9> client -> { <line10> client.setAttribute(path, mergedOptions); <line11> return null; <line12> }); <line13> } <line14> } <line15> 	 <line9>	No
public class A { <line0> public void setEndTime(long end) { <line1> endTime = end; <line2> if (!START_TIMESTAMP) { <line3> timeStamp = endTime; <line4> } <line5> if (startTime == 0) { <line6> } else { <line7> elapsedTime = endTime - startTime - idleTime; <line8> } <line9> } <line10> } <line11> 	 <line7>	No
public class A { <line0> public org.apache.thrift.async.AsyncMethodCallback<java.lang.Boolean> getResultHandler( <line1> final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, <line2> final int seqid) { <line3> final org.apache.thrift.AsyncProcessFunction fcall = this; <line4> return new org.apache.thrift.async.AsyncMethodCallback<java.lang.Boolean>() { <line5> public void onComplete(java.lang.Boolean o) { <line6> drainReplicationTable_result result = new drainReplicationTable_result(); <line7> result.success = o; <line8> result.setSuccessIsSet(true); <line9> try { <line10> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line11> } catch (org.apache.thrift.transport.TTransportException e) { <line12> fb.close(); <line13> } catch (java.lang.Exception e) { <line14> onError(e); <line15> } <line16> } <line17>  <line18> public void onError(java.lang.Exception e) { <line19> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line20> org.apache.thrift.TSerializable msg; <line21> drainReplicationTable_result result = new drainReplicationTable_result(); <line22> if (e <line23> instanceof org.apache.accumulo.core.clientImpl.thrift.ThriftNotActiveServiceException) { <line24> result.tnase = <line25> (org.apache.accumulo.core.clientImpl.thrift.ThriftNotActiveServiceException) e; <line26> result.setTnaseIsSet(true); <line27> msg = result; <line28> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line29> fb.close(); <line30> return; <line31> } else if (e instanceof org.apache.thrift.TApplicationException) { <line32> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line33> msg = (org.apache.thrift.TApplicationException) e; <line34> } else { <line35> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line36> msg = <line37> new org.apache.thrift.TApplicationException( <line38> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line39> } <line40> try { <line41> fcall.sendResponse(fb, msg, msgType, seqid); <line42> } catch (java.lang.Exception ex) { <line43> fb.close(); <line44> } <line45> } <line46> }; <line47> } <line48> } <line49> 	 <line3>	No
"public class A { <line0> private static void tryAssertion(RegressionEnvironment env, RegressionPath path, String epl) { <line1> env.compileDeploy(epl, path).addListener(""s0""); <line2> long startTime = System.currentTimeMillis(); <line3> for (int i = 0; i < 1000; i++) { <line4> env.sendEventBean(new SupportBeanRange(""R"", ""G"", 100, 101)); <line5> env.assertListener( <line6> ""s0"", listener -> assertEquals(4, listener.getAndResetLastNewData().length)); <line7> } <line8> long endTime = System.currentTimeMillis(); <line9> assertTrue((endTime - startTime) < 500); <line10> env.undeployModuleContaining(""s0""); <line11> } <line12> } <line13> "	 <line2>	Yes
public class A { <line0> boolean retractLiveEvent(MediaPackage mp) throws LiveScheduleException { <line1> retract(mp); <line2> try { <line3> String mpId = mp.getIdentifier().toString(); <line4> Snapshot snapshot = getSnapshot(mpId); <line5> MediaPackage archivedMp = snapshot.getMediaPackage(); <line6> removeLivePublicationChannel(archivedMp); <line7> snapshotVersionCache.put(mpId, assetManager.takeSnapshot(archivedMp).getVersion()); <line8> } catch (LiveScheduleException e) { <line9> } <line10> return true; <line11> } <line12> } <line13> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void query( <line2> String deviceId, <line3> String startTs, <line4> String endTs, <line5> String notification, <line6> String sortField, <line7> String sortOrderSt, <line8> Integer take, <line9> Integer skip, <line10> @Suspended final AsyncResponse asyncResponse) { <line11> final Date timestampSt = TimestampQueryParamParser.parse(startTs); <line12> final Date timestampEnd = TimestampQueryParamParser.parse(endTs); <line13> DeviceVO byIdWithPermissionsCheck = deviceService.findById(deviceId); <line14> if (byIdWithPermissionsCheck == null) { <line15> ErrorResponse errorCode = <line16> new ErrorResponse( <line17> NOT_FOUND.getStatusCode(), String.format(Messages.DEVICE_NOT_FOUND, deviceId)); <line18> Response response = ResponseFactory.response(NOT_FOUND, errorCode); <line19> asyncResponse.resume(response); <line20> } else { <line21> Set<String> notificationNames = <line22> StringUtils.isNoneEmpty(notification) <line23> ? Collections.singleton(notification) <line24> : Collections.emptySet(); <line25> notificationService <line26> .find( <line27> Collections.singleton(deviceId), <line28> notificationNames, <line29> timestampSt, <line30> timestampEnd, <line31> sortField, <line32> sortOrderSt, <line33> take, <line34> skip) <line35> .thenApply( <line36> notifications -> <line37> ResponseFactory.response( <line38> OK, notifications, JsonPolicyDef.Policy.NOTIFICATION_TO_CLIENT)) <line39> .thenAccept(asyncResponse::resume); <line40> } <line41> } <line42> } <line43> 	 <line11>	Yes
public class A { <line0> private void createSchema(Connection conn) throws IOException { <line1> String createSchemaScriptPath = getCreateSchemaScriptPath(); <line2> ScriptRunner sr = new ScriptRunner(conn); <line3> sr.setDelimiter(delimiter); <line4> sr.setStopOnError(true); <line5> sr.setLogWriter(null); <line6> InputStream is = getClass().getClassLoader().getResourceAsStream(createSchemaScriptPath); <line7> String scriptContent = IOUtils.toString(is); <line8> Reader reader = <line9> new StringReader( <line10> scriptContent.replaceAll( <line11> CRAFTER_SCHEMA_NAME, studioConfiguration.getProperty(DB_SCHEMA))); <line12> try { <line13> sr.runScript(reader); <line14> } catch (RuntimeSqlException e) { <line15> } <line16> } <line17> } <line18> 	 <line6>	No
"public class A { <line0> @Override <line1> public List<String> findUserGroupNames(String userGroupName, boolean caseInsensitive) <line2> throws JargonException { <line3> if (userGroupName == null) { <line4> throw new IllegalArgumentException(""null userGroupName""); <line5> } <line6> List<String> userGroups = new ArrayList<String>(); <line7> IRODSGenQueryBuilder builder = new IRODSGenQueryBuilder(true, caseInsensitive, null); <line8> try { <line9> builder.addSelectAsGenQueryValue(RodsGenQueryEnum.COL_USER_GROUP_NAME); <line10> } catch (GenQueryBuilderException e) { <line11> throw new JargonException(""query builder error"", e); <line12> } <line13> IRODSGenQueryExecutor irodsGenQueryExecutor = getGenQueryExecutor(); <line14> StringBuilder sb = new StringBuilder(); <line15> sb.append(userGroupName.trim()); <line16> sb.append('%'); <line17> builder <line18> .addConditionAsGenQueryField( <line19> RodsGenQueryEnum.COL_USER_GROUP_NAME, QueryConditionOperators.LIKE, sb.toString()) <line20> .addConditionAsGenQueryField( <line21> RodsGenQueryEnum.COL_USER_TYPE, QueryConditionOperators.EQUAL, RODS_GROUP); <line22> IRODSQueryResultSet resultSet = null; <line23> try { <line24> IRODSGenQueryFromBuilder irodsQuery = <line25> builder.exportIRODSQueryFromBuilder(getJargonProperties().getMaxFilesAndDirsQueryMax()); <line26> resultSet = irodsGenQueryExecutor.executeIRODSQueryAndCloseResult(irodsQuery, 0); <line27> } catch (JargonQueryException e) { <line28> log.error(""query exception for query"", e); <line29> throw new JargonException(""error in query for data object"", e); <line30> } catch (GenQueryBuilderException e) { <line31> throw new JargonException(""error in query for data object"", e); <line32> } <line33> for (IRODSQueryResultRow row : resultSet.getResults()) { <line34> userGroups.add(row.getColumn(0)); <line35> } <line36> return userGroups; <line37> } <line38> } <line39> "	 <line25>	No
public class A { <line0> private void destroySubsystems() throws Exception { <line1> this.cpmContextListener.shutdown(); <line2> this.jobManager.shutdown(); <line3> injector.getInstance(PersistService.class).stop(); <line4> Enumeration<Driver> drivers = DriverManager.getDrivers(); <line5> while (drivers.hasMoreElements()) { <line6> Driver driver = drivers.nextElement(); <line7> try { <line8> DriverManager.deregisterDriver(driver); <line9> } catch (SQLException e) { <line10> } <line11> } <line12> if (config.getBoolean(ACTIVEMQ_ENABLED)) { <line13> activeMQContextListener.contextDestroyed(injector); <line14> } <line15> this.cpmContextListener.destroy(); <line16> this.loggerListener.contextDestroyed(); <line17> } <line18> } <line19> 	 <line13>	No
"public class A { <line0> private boolean checkIfAllowRetry(Throwable ex) { <line1> if (config.isResourceStoreReconnectEnabled() && store.isUnreachableException(ex)) { <line2> if (isTimeOut(config.getResourceStoreReconnectTimeoutMs())) { <line3> return false; <line4> } <line5> long waitMs = getSleepTimeMs(); <line6> long seconds = waitMs / 1000; <line7> try { <line8> Thread.sleep(waitMs); <line9> } catch (InterruptedException e) { <line10> throw new RuntimeException( <line11> ""Current thread for resource store's CRUD is interrupted, abandoning...""); <line12> } <line13> increaseRetryCount(); <line14> return true; <line15> } <line16> return false; <line17> } <line18> } <line19> "	 <line18>	No
"public class A { <line0> public Map<String, String> statusOfSystem() throws PacManException { <line1> Map<String, String> status = new HashMap<>(); <line2> try { <line3> List<Rule> rules = ruleRepository.findAll(); <line4> List<JobExecutionManager> jobs = jobRepository.findAll(); <line5> boolean rulesEnabled = false; <line6> boolean jobsEnabled = false; <line7> for (Rule rule : rules) { <line8> if (rule.getStatus().equals(RuleState.ENABLED.name())) { <line9> rulesEnabled = true; <line10> break; <line11> } <line12> } <line13> for (JobExecutionManager job : jobs) { <line14> if (job.getStatus().equals(RuleState.ENABLED.name())) { <line15> jobsEnabled = true; <line16> break; <line17> } <line18> } <line19> if (rulesEnabled) { <line20> status.put(""rule"", RuleState.ENABLED.name()); <line21> } else { <line22> status.put(""rule"", RuleState.DISABLED.name()); <line23> } <line24> if (jobsEnabled) { <line25> status.put(""job"", RuleState.ENABLED.name()); <line26> } else { <line27> status.put(""job"", RuleState.DISABLED.name()); <line28> } <line29> return status; <line30> } catch (Exception e) { <line31> throw new PacManException(""Error in fetching the status of system""); <line32> } <line33> } <line34> } <line35> "	 <line31>	Yes
"public class A { <line0> @Override <line1> public Future<Vector[]> asyncInitAndGet(int[] rowIds, long[] indices, InitFunc func) <line2> throws AngelException { <line3> checkNotNull(rowIds, ""rowIds""); <line4> checkNotNull(indices, ""indices""); <line5> if (rowIds.length == 0) { <line6> FutureResult<Vector[]> result = new FutureResult<>(); <line7> result.set(new Vector[0]); <line8> return result; <line9> } <line10> if (indices.length == 0) { <line11> FutureResult<Vector[]> result = new FutureResult<>(); <line12> result.set(generateEmptyVecs(rowIds)); <line13> return result; <line14> } <line15> try { <line16> return PSAgentContext.get().getUserRequestAdapter().get(matrixId, rowIds, indices, func); <line17> } catch (Throwable x) { <line18> throw new AngelException(x); <line19> } <line20> } <line21> } <line22> "	 <line7>	No
"public class A { <line0> @Override <line1> public void msg(Msg msg) { <line2> lastMessageTimestamp = System.currentTimeMillis(); <line3> messageCount++; <line4> if (msg.isPureNack()) { <line5> return; <line6> } <line7> try { <line8> if (msg.getByte(""Cmd"") == 0x69 || msg.getByte(""Cmd"") == 0x6a) { <line9> if (msg.getByte(""ACK/NACK"") == 0x15) { <line10> done(); <line11> } <line12> } else if (msg.getByte(""Cmd"") == 0x57) { <line13> updateModemDB(msg.getAddress(""LinkAddr""), port, msg, false); <line14> port.writeMessage(Msg.makeMessage(""GetNextALLLinkRecord"")); <line15> } <line16> } catch (FieldException e) { <line17> } catch (IOException e) { <line18> } catch (IllegalStateException e) { <line19> } catch (InvalidMessageTypeException e) { <line20> } <line21> } <line22> } <line23> "	 <line17>	Yes
public class A { <line0> protected void processFlow(AsyncWorkFlow flow, WorkFlowContext ctx, WorkFlowVO vo, int position) { <line1> if (vo == null) { <line2> vo = new WorkFlowVO(); <line3> } <line4> vo.setChainUuid(chainvo.getUuid()); <line5> vo.setName(flow.getName()); <line6> vo.setState(WorkFlowState.Processing); <line7> vo.setContext(ctx.toBytes()); <line8> vo.setPosition(position); <line9> vo = dbf.updateAndRefresh(vo); <line10> try { <line11> flow.process(ctx, this); <line12> } catch (WorkFlowException e) { <line13> try { <line14> fail(vo, e.getErrorCode()); <line15> } catch (Throwable t) { <line16> } <line17> } catch (Throwable t) { <line18> ErrorCode err = inerr(t.getMessage()); <line19> try { <line20> fail(vo, err); <line21> } catch (Throwable t1) { <line22> } <line23> } <line24> } <line25> } <line26> 	 <line8>	No
public class A { <line0> public JdbcConnectionOptions buildConnectionOptions() { <line1> if (this.username == null) { <line2> } <line3> if (this.password == null) { <line4> } <line5> return new JdbcConnectionOptions.JdbcConnectionOptionsBuilder() <line6> .withUrl(dbURL) <line7> .withDriverName(drivername) <line8> .withUsername(username) <line9> .withPassword(password) <line10> .build(); <line11> } <line12> } <line13> 	 <line4>	Yes
public class A { <line0> private void removePauseQueueMessage(MessageQueue messageQueue, List<MessageExt> messages) { <line1> if (null != messageQueuesStateMap.get(messageQueue)) { <line2> final Iterator<MessageExt> iterator = messages.iterator(); <line3> while (iterator.hasNext()) { <line4> final MessageExt message = iterator.next(); <line5> String msgId = message.getMsgId(); <line6> iterator.remove(); <line7> } <line8> } <line9> } <line10> } <line11> 	 <line5>	No
"public class A { <line0> private static void filterObjectNames( <line1> final Set<String> objectNames, <line2> final String[] includes, <line3> final String includePattern, <line4> final String[] excludes, <line5> final String excludePattern, <line6> final Log log) <line7> throws MojoExecutionException { <line8> final Set<String> includedNames = new HashSet<>(); <line9> if (includes != null && includes.length > 0) { <line10> for (String name : includes) { <line11> name = name.trim(); <line12> if (name.isEmpty()) { <line13> throw new MojoExecutionException(""Invalid empty name in includes""); <line14> } <line15> includedNames.add(name); <line16> } <line17> } <line18> final Set<String> excludedNames = new HashSet<>(); <line19> if (excludes != null && excludes.length > 0) { <line20> for (String name : excludes) { <line21> name = name.trim(); <line22> if (name.isEmpty()) { <line23> throw new MojoExecutionException(""Invalid empty name in excludes""); <line24> } <line25> excludedNames.add(name); <line26> } <line27> } <line28> Pattern incPattern; <line29> if (includePattern != null && !includePattern.trim().isEmpty()) { <line30> incPattern = Pattern.compile(includePattern.trim()); <line31> } else if (includedNames.isEmpty()) { <line32> incPattern = Defaults.MATCH_EVERYTHING_PATTERN; <line33> } else { <line34> incPattern = Defaults.MATCH_NOTHING_PATTERN; <line35> } <line36> Pattern excPattern; <line37> if (excludePattern != null && !excludePattern.trim().isEmpty()) { <line38> excPattern = Pattern.compile(excludePattern.trim()); <line39> } else { <line40> excPattern = Defaults.MATCH_NOTHING_PATTERN; <line41> } <line42> final Set<String> acceptedNames = new HashSet<>(); <line43> for (final String name : objectNames) { <line44> if ((includedNames.contains(name) || incPattern.matcher(name).matches()) <line45> && !excludedNames.contains(name) <line46> && !excPattern.matcher(name).matches()) { <line47> acceptedNames.add(name); <line48> } <line49> } <line50> objectNames.clear(); <line51> objectNames.addAll(acceptedNames); <line52> } <line53> } <line54> "	 <line52>	Yes
public class A { <line0> @Override <line1> public void saveGraphToCSV(File file) throws IOException { <line2> FileWriter writer = null; <line3> try { <line4> writer = new FileWriter(file); <line5> CSVSaveService.saveCSVStats( <line6> getAllDataAsTable(model, FORMATS, getLabels(COLUMNS)), writer, saveHeaders.isSelected()); <line7> } catch (IOException e) { <line8> } finally { <line9> try { <line10> if (writer != null) { <line11> writer.close(); <line12> } <line13> } catch (IOException ex) { <line14> } <line15> } <line16> } <line17> } <line18> 	 <line8>	Yes
"public class A { <line0> @POST <line1> @Path(value = ""/report-anomaly/{detectionConfigId}"") <line2> @ApiOperation(""Report a missing anomaly for a detection config"") <line3> public Response createUserAnomaly( <line4> @PathParam(""detectionConfigId"") @ApiParam(value = ""detection config id"") <line5> long detectionConfigId, <line6> @QueryParam(""startTime"") @ApiParam(""start time utc (in millis)"") Long startTime, <line7> @QueryParam(""endTime"") @ApiParam(""end time utc (in millis)"") Long endTime, <line8> @QueryParam(""metricUrn"") @ApiParam(""the metric urn of the anomaly"") String metricUrn, <line9> @QueryParam(""feedbackType"") @ApiParam(""the metric urn of the anomaly"") <line10> AnomalyFeedbackType feedbackType, <line11> @QueryParam(""comment"") @ApiParam(""comments"") String comment, <line12> @QueryParam(""baselineValue"") <line13> @ApiParam(""the baseline value for the anomaly"") <line14> @DefaultValue(""NaN"") <line15> double baselineValue) { <line16> DetectionConfigDTO detectionConfigDTO = this.configDAO.findById(detectionConfigId); <line17> if (detectionConfigDTO == null) { <line18> throw new IllegalArgumentException( <line19> String.format(""Could not resolve detection config id %d"", detectionConfigId)); <line20> } <line21> MergedAnomalyResultDTO anomaly = new MergedAnomalyResultDTO(); <line22> anomaly.setStartTime(startTime); <line23> anomaly.setEndTime(endTime); <line24> anomaly.setDetectionConfigId(detectionConfigId); <line25> anomaly.setAnomalyResultSource(AnomalyResultSource.USER_LABELED_ANOMALY); <line26> anomaly.setProperties(Collections.<String, String>emptyMap()); <line27> MetricEntity me = MetricEntity.fromURN(metricUrn); <line28> MetricConfigDTO metric = this.metricDAO.findById(me.getId()); <line29> DatasetConfigDTO dataset = this.datasetDAO.findByDataset(metric.getDataset()); <line30> anomaly.setMetricUrn(metricUrn); <line31> anomaly.setMetric(metric.getName()); <line32> anomaly.setCollection(dataset.getDataset()); <line33> try { <line34> MetricSlice currentSlice = MetricSlice.from(me.getId(), startTime, endTime, me.getFilters()); <line35> DataFrame df = <line36> this.aggregationLoader.loadAggregate(currentSlice, Collections.<String>emptyList(), -1); <line37> anomaly.setAvgCurrentVal(df.getDouble(DataFrame.COL_VALUE, 0)); <line38> } catch (Exception e) { <line39> anomaly.setAvgCurrentVal(Double.NaN); <line40> } <line41> anomaly.setAvgBaselineVal(baselineValue); <line42> if (this.anomalyDAO.save(anomaly) == null) { <line43> throw new IllegalArgumentException( <line44> String.format(""Could not store user reported anomaly: '%s'"", anomaly)); <line45> } <line46> AnomalyFeedbackDTO feedback = new AnomalyFeedbackDTO(); <line47> feedback.setFeedbackType(feedbackType); <line48> feedback.setComment(comment); <line49> anomaly.setFeedback(feedback); <line50> this.anomalyDAO.updateAnomalyFeedback(anomaly); <line51> return Response.ok(anomaly.getId()).build(); <line52> } <line53> } <line54> "	 <line28>	No
public class A { <line0> public static com.liferay.blogs.model.BlogsEntrySoap[] getGroupEntries( <line1> long groupId, int status, int max) throws RemoteException { <line2> try { <line3> java.util.List<com.liferay.blogs.model.BlogsEntry> returnValue = <line4> BlogsEntryServiceUtil.getGroupEntries(groupId, status, max); <line5> return com.liferay.blogs.model.BlogsEntrySoap.toSoapModels(returnValue); <line6> } catch (Exception exception) { <line7> throw new RemoteException(exception.getMessage()); <line8> } <line9> } <line10> } <line11> 	 <line4>	No
public class A { <line0> public void testOpenL() throws SyntaxNodeException { <line1> boolean b; <line2> long t = System.currentTimeMillis(); <line3> b = executeBooleanOpenLExprression(data, OPENL_EXPR); <line4> assertTrue(b); <line5> b = executeBooleanOpenLExprression(data, NEG_OPENL_EXPR); <line6> assertTrue(b); <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> protected void initialize() { <line1> atomManager = createAtomManager(db); <line2> reasoner = createReasoner(); <line3> termStore = createTermStore(); <line4> groundRuleStore = createGroundRuleStore(); <line5> termGenerator = createTermGenerator(); <line6> termStore.ensureVariableCapacity(atomManager.getCachedRVACount()); <line7> completeInitialize(); <line8> } <line9> } <line10> 	 <line0>	No
"public class A { <line0> @RestAccessControl(permission = Permission.SUPERUSER) <line1> @RequestMapping( <line2> value = ""/kiebpm/serverConfigs/{configCode}/caseDefinitions/{deploymentUnit:.+}"", <line3> method = RequestMethod.GET, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<SimpleRestResponse<Map<String, Object>>> getCaseDefinitions( <line6> @PathVariable String configCode, @PathVariable String deploymentUnit) { <line7> JSONObject cases = null; <line8> try { <line9> KieServerConfigDto serverConfigDto = kieConfigService.getConfig(configCode); <line10> KieBpmConfig bpmConfig = kieConfigService.buildConfig(serverConfigDto); <line11> cases = caseManager.getCasesDefinitions(bpmConfig, deploymentUnit); <line12> } catch (Exception e) { <line13> } <line14> if (cases == null) { <line15> cases = new JSONObject(); <line16> } <line17> return new ResponseEntity<>(new SimpleRestResponse<>(cases.toMap()), HttpStatus.OK); <line18> } <line19> } <line20> "	 <line13>	Yes
"public class A { <line0> @Test <line1> public void testObjectMethodNotifications() throws Exception { <line2> String pid = <line3> apim.ingest( <line4> TypeUtility.convertBytesToDataHandler(demo998FOXMLObjectXML), <line5> FOXML1_1.uri, <line6> ""ingesting new foxml object""); <line7> assertNotNull(pid); <line8> checkNotification(pid, ""ingest""); <line9> String modifyResult = <line10> apim.modifyObject( <line11> pid, ""I"", ""Updated Object Label"", null, ""Changed state to inactive and updated label""); <line12> assertNotNull(modifyResult); <line13> checkNotification(pid, ""modifyObject""); <line14> LOGGER.info(""Running TestManagementNotifications.testAddRelationship...""); <line15> boolean addRelResult = apim.addRelationship(pid, ""rel:isRelatedTo"", ""demo:5"", false, null); <line16> assertTrue(addRelResult); <line17> checkNotification(pid, ""addRelationship""); <line18> LOGGER.info(""Running TestManagementNotifications.testAddRelationship...""); <line19> addRelResult = apim.addRelationship(PID.toURI(pid), ""rel:isRelatedTo"", ""demo:6"", false, null); <line20> assertTrue(addRelResult); <line21> checkNotification(pid, ""addRelationship""); <line22> addRelResult = <line23> apim.addRelationship(PID.toURI(pid) + ""/DS1"", ""rel:isRelatedTo"", ""demo:7"", false, null); <line24> assertTrue(addRelResult); <line25> checkNotification(pid, ""addRelationship""); <line26> LOGGER.info(""Running TestManagementNotifications.testPurgeRelationship...""); <line27> boolean purgeRelResult = apim.purgeRelationship(pid, ""rel:isRelatedTo"", ""demo:5"", false, null); <line28> assertTrue(purgeRelResult); <line29> checkNotification(pid, ""purgeRelationship""); <line30> LOGGER.info(""Running TestManagementNotifications.testPurgeRelationship...""); <line31> purgeRelResult = <line32> apim.purgeRelationship(PID.toURI(pid), ""rel:isRelatedTo"", ""demo:6"", false, null); <line33> assertTrue(purgeRelResult); <line34> checkNotification(pid, ""purgeRelationship""); <line35> purgeRelResult = <line36> apim.purgeRelationship(PID.toURI(pid) + ""/DS1"", ""rel:isRelatedTo"", ""demo:7"", false, null); <line37> assertTrue(purgeRelResult); <line38> checkNotification(pid, ""purgeRelationship""); <line39> String purgeResult = apim.purgeObject(pid, ""Purging object "" + pid, false); <line40> assertNotNull(purgeResult); <line41> checkNotification(pid, ""purgeObject""); <line42> } <line43> } <line44> "	 <line30>	No
"public class A { <line0> public CMLAtom cdkAtomToCMLAtom(IAtomContainer container, IAtom cdkAtom) { <line1> CMLAtom cmlAtom = new CMLAtom(); <line2> this.checkPrefix(cmlAtom); <line3> addAtomID(cdkAtom, cmlAtom); <line4> addDictRef(cdkAtom, cmlAtom); <line5> cmlAtom.setElementType(cdkAtom.getSymbol()); <line6> if (cdkAtom instanceof IPseudoAtom) { <line7> String label = ((IPseudoAtom) cdkAtom).getLabel(); <line8> if (label != null) cmlAtom.setTitle(label); <line9> cmlAtom.setElementType(""Du""); <line10> } <line11> map2DCoordsToCML(cmlAtom, cdkAtom); <line12> map3DCoordsToCML(cmlAtom, cdkAtom); <line13> mapFractionalCoordsToCML(cmlAtom, cdkAtom); <line14> Integer formalCharge = cdkAtom.getFormalCharge(); <line15> if (formalCharge != null) cmlAtom.setFormalCharge(formalCharge); <line16> Integer totalHydrogen = cdkAtom.getImplicitHydrogenCount(); <line17> if (totalHydrogen != null) { <line18> if (container != null) { <line19> Iterator<IBond> bonds = container.getConnectedBondsList(cdkAtom).iterator(); <line20> while (bonds.hasNext()) { <line21> Iterator<IAtom> atoms = (bonds.next()).atoms().iterator(); <line22> while (atoms.hasNext()) { <line23> IAtom atom = atoms.next(); <line24> if (""H"".equals(atom.getSymbol()) && !Objects.equals(atom, cdkAtom)) totalHydrogen++; <line25> } <line26> } <line27> } <line28> cmlAtom.setHydrogenCount(totalHydrogen); <line29> } <line30> Integer massNumber = cdkAtom.getMassNumber(); <line31> if (!(cdkAtom instanceof IPseudoAtom)) { <line32> if (massNumber != null) { <line33> cmlAtom.setIsotopeNumber(massNumber); <line34> } <line35> } <line36> if (cdkAtom.getCharge() != CDKConstants.UNSET) { <line37> CMLScalar scalar = new CMLScalar(); <line38> this.checkPrefix(scalar); <line39> scalar.setDictRef(""cdk:partialCharge""); <line40> scalar.setValue(cdkAtom.getCharge()); <line41> cmlAtom.addScalar(scalar); <line42> } <line43> writeProperties(cdkAtom, cmlAtom); <line44> if (cdkAtom.getFlag(CDKConstants.ISAROMATIC)) { <line45> CMLScalar aromAtom = new CMLScalar(); <line46> aromAtom.setDictRef(""cdk:aromaticAtom""); <line47> cmlAtom.appendChild(aromAtom); <line48> } <line49> Iterator<String> elements = customizers.keySet().iterator(); <line50> while (elements.hasNext()) { <line51> ICMLCustomizer customizer = (ICMLCustomizer) customizers.get(elements.next()); <line52> try { <line53> customizer.customize(cdkAtom, cmlAtom); <line54> } catch (Exception exception) { <line55> } <line56> } <line57> return cmlAtom; <line58> } <line59> } <line60> "	 <line27>	No
public class A { <line0> @Override <line1> @Transactional(readOnly = false) <line2> public void setTimeZone(long guestId, String date, String timeZone) { <line3> } <line4> } <line5> 	 <line3>	Yes
"public class A { <line0> private void initDatabaseDriver(final String dbDrivers) { <line1> if (dbDrivers != null && !dbDrivers.trim().isEmpty()) { <line2> for (String d : dbDrivers.split("";"")) { <line3> try { <line4> DatabaseDriverLoader.loadDriver(new File(d)); <line5> } catch (IOException ioe) { <line6> } <line7> } <line8> } <line9> } <line10> } <line11> "	 <line5>	No
public class A { <line0> @Override <line1> public long getSize() { <line2> long size = 0L; <line3> try (Tx tx = StructrApp.getInstance().tx()) { <line4> size = page.getContent(RenderContext.EditMode.RAW).length(); <line5> tx.success(); <line6> } catch (FrameworkException fex) { <line7> } <line8> return size; <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> public static ActivityStreamInfo unmarshalInfo(String xml) throws ApsSystemException { <line1> ActivityStreamInfo bodyObject = null; <line2> try { <line3> JAXBContext context = JAXBContext.newInstance(ActivityStreamInfo.class); <line4> Unmarshaller unmarshaller = context.createUnmarshaller(); <line5> ByteArrayInputStream is = new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)); <line6> bodyObject = (ActivityStreamInfo) unmarshaller.unmarshal(is); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error unmarshalling activity stream info config"", t); <line9> } <line10> return bodyObject; <line11> } <line12> } <line13> "	 <line8>	Yes
public class A { <line0> public boolean isDirectory() { <line1> return isDirectory; <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> public void ensureFirstModelSync() { <line1> try { <line2> trackModels(true); <line3> } catch (Throwable t) { <line4> } <line5> } <line6> } <line7> 	 <line3>	No
"public class A { <line0> public void connect(String username, String password, String resource, int timeout) <line1> throws XmppException { <line2> Lock lock = connectionLock.writeLock(); <line3> lock.lock(); <line4> if (connection.isConnected()) { <line5> try { <line6> disconnect(); <line7> } catch (Exception e) { <line8> e.printStackTrace(); <line9> } <line10> } <line11> try { <line12> if (!connection.isConnected()) { <line13> connection.connect(timeout); <line14> connection.login(username, password, resource, timeout); <line15> connection.addStanzaListener( <line16> new RayoMessageListener(""offer"") { <line17> @Override <line18> @SuppressWarnings(""rawtypes"") <line19> public void messageReceived(Object object) { <line20> Stanza stanza = (Stanza) object; <line21> int at = stanza.getFrom().indexOf('@'); <line22> String callId = stanza.getFrom().substring(0, at); <line23> String domain = stanza.getFrom().substring(at + 1); <line24> if (domain.contains("":"")) { <line25> domain = domain.substring(0, domain.indexOf(':')); <line26> } <line27> Call call = new Call(callId, domain); <line28> callRegistry.registerCall(callId, call); <line29> } <line30> }); <line31> connection.addStanzaListener( <line32> new RayoMessageListener(""end"") { <line33> @Override <line34> @SuppressWarnings(""rawtypes"") <line35> public void messageReceived(Object object) { <line36> Stanza stanza = (Stanza) object; <line37> int at = stanza.getFrom().indexOf('@'); <line38> String callId = stanza.getFrom().substring(0, at); <line39> callRegistry.unregisterCal(callId); <line40> } <line41> }); <line42> broadcastAvailability(); <line43> TimerTask pingTask = <line44> new TimerTask() { <line45> @Override <line46> public void run() { <line47> ping(); <line48> } <line49> }; <line50> pingTimer = new Timer(); <line51> pingTimer.schedule(pingTask, 5000, 30000); <line52> connection.addStanzaListener( <line53> new RayoMessageListener(""ping"") { <line54> @Override <line55> public void messageReceived(Object object) { <line56> IQ iq = (IQ) object; <line57> if (!iq.isError()) { <line58> try { <line59> sendIQ(iq.result()); <line60> } catch (XmppException e) { <line61> e.printStackTrace(); <line62> } <line63> } <line64> } <line65> }); <line66> } else { <line67> } <line68> } catch (XmppException xe) { <line69> logger.error(""Error while trying to opean an XMPP connection""); <line70> xe.printStackTrace(); <line71> throw xe; <line72> } catch (Exception e) { <line73> e.printStackTrace(); <line74> throw new XmppException(e.getMessage()); <line75> } finally { <line76> lock.unlock(); <line77> } <line78> } <line79> } <line80> "	 <line56>	No
public class A { <line0> public void handleFailureRequest(RequestContext requestContext) { <line1> if (publisher == null) { <line2> return; <line3> } <line4> ChoreoFaultAnalyticsProvider provider = new ChoreoFaultAnalyticsProvider(requestContext); <line5> if (provider.getProxyResponseCode() == 200 || provider.getProxyResponseCode() == 204) { <line6> return; <line7> } <line8> GenericRequestDataCollector dataCollector = new GenericRequestDataCollector(provider); <line9> try { <line10> dataCollector.collectData(); <line11> } catch (AnalyticsException e) { <line12> } <line13> } <line14> } <line15> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void onExchangeDone(Route route, Exchange exchange) { <line2> try { <line3> if (isExcluded(exchange, route.getEndpoint())) { <line4> return; <line5> } <line6> SpanAdapter span = ActiveSpanManager.getSpan(exchange); <line7> if (span != null) { <line8> if (LOG.isTraceEnabled()) { <line9> } <line10> SpanDecorator sd = getSpanDecorator(route.getEndpoint()); <line11> sd.post(span, exchange, route.getEndpoint()); <line12> finishSpan(span); <line13> ActiveSpanManager.deactivate(exchange); <line14> } else { <line15> } <line16> } catch (Exception t) { <line17> } <line18> } <line19> } <line20> 	 <line9>	Yes
public class A { <line0> private boolean _isVersioningEnabled() { <line1> try { <line2> CProductVersionConfiguration cProductVersionConfiguration = <line3> ConfigurationProviderUtil.getConfiguration( <line4> CProductVersionConfiguration.class, <line5> new SystemSettingsLocator(CProductVersionConfiguration.class.getName())); <line6> if (cProductVersionConfiguration.enabled()) { <line7> return true; <line8> } <line9> } catch (PortalException portalException) { <line10> } <line11> return false; <line12> } <line13> } <line14> 	 <line2>	No
public class A { <line0> public int getGIFHeight() { <line1> if (myCustomHeightField.isEnabled()) { <line2> try { <line3> Integer value = (Integer) myFormatter.stringToValue(myCustomHeightField.getText()); <line4> return value.intValue(); <line5> } catch (ParseException e) { <line6> } <line7> } <line8> return myHeight; <line9> } <line10> } <line11> 	 <line2>	No
"public class A { <line0> @Override <line1> public List<String> findCountryByProperty(TestCaseCountryProperties testCaseCountryProperties) { <line2> List<String> countries = null; <line3> final StringBuilder query = new StringBuilder(); <line4> query.append(""SELECT country FROM testcasecountryproperties WHERE test = ? AND testcase = ?""); <line5> query.append( <line6> "" AND HEX(`property`) = hex(?) AND `type` =? AND `database` =? AND hex(`value1`) like hex("" <line7> + "" ? ) AND hex(`value2`) like hex( ? ) AND `length` = ? ""); <line8> query.append("" AND `rowlimit` = ? AND `nature` = ?""); <line9> loggingQuery(query.toString()); <line10> try (Connection connection = this.databaseSpring.connect(); <line11> PreparedStatement preStat = connection.prepareStatement(query.toString()); ) { <line12> int i = 1; <line13> preStat.setString(i++, testCaseCountryProperties.getTest()); <line14> preStat.setString(i++, testCaseCountryProperties.getTestcase()); <line15> preStat.setBytes(i++, testCaseCountryProperties.getProperty().getBytes(""UTF-8"")); <line16> preStat.setString(i++, testCaseCountryProperties.getType()); <line17> preStat.setString(i++, testCaseCountryProperties.getDatabase()); <line18> preStat.setBytes(i++, testCaseCountryProperties.getValue1().getBytes(""UTF-8"")); <line19> preStat.setBytes(i++, testCaseCountryProperties.getValue2().getBytes(""UTF-8"")); <line20> preStat.setString(i++, String.valueOf(testCaseCountryProperties.getLength())); <line21> preStat.setString(i++, String.valueOf(testCaseCountryProperties.getRowLimit())); <line22> preStat.setString(i++, testCaseCountryProperties.getNature()); <line23> try (ResultSet resultSet = preStat.executeQuery(); ) { <line24> countries = new ArrayList<String>(); <line25> String countryToAdd; <line26> while (resultSet.next()) { <line27> countryToAdd = <line28> resultSet.getString(""Country"") == null ? """" : resultSet.getString(""Country""); <line29> countries.add(countryToAdd); <line30> } <line31> } catch (SQLException exception) { <line32> } <line33> } catch (SQLException exception) { <line34> } catch (UnsupportedEncodingException ex) { <line35> } <line36> return countries; <line37> } <line38> } <line39> "	 <line32>	Yes
public class A { <line0> public static Trigger getTrigger(String name) { <line1> if ((name == null) || (name.trim().isEmpty())) { <line2> return null; <line3> } <line4> for (Trigger trigger : TRIGGERS_LIST) { <line5> if (trigger.getName().equalsIgnoreCase(name.trim())) { <line6> return trigger; <line7> } <line8> } <line9> return null; <line10> } <line11> } <line12> 	 <line9>	Yes
public class A { <line0> @Override <line1> public boolean restoreVMFromBackup(VirtualMachine vm, Backup backup) { <line2> return true; <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> public static ConfigurationManager getConfigurationManager( <line1> Component component, List<String> propertiesFiles) { <line2> String enableDistributed = System.getProperty(ENABLE_DISTRIBUTED_CONFIGURATION); <line3> boolean isDistributed; <line4> if (enableDistributed == null) { <line5> String env = System.getenv(Env.ENABLE_DISTRIBUTED_CONFIGURATION); <line6> isDistributed = Boolean.parseBoolean(env); <line7> } else { <line8> isDistributed = Boolean.parseBoolean(enableDistributed); <line9> } <line10> if (isDistributed) { <line11> String connectString = System.getProperty(ZK_CONNECT_STRING); <line12> if (connectString == null) { <line13> connectString = System.getenv(CONNECT_STRING); <line14> } <line15> if (connectString == null) { <line16> throw new IllegalArgumentException( <line17> String.format( <line18> ""%s environment variable need to be set for distributed configuration management"", <line19> CONNECT_STRING)); <line20> } <line21> System.setProperty(ZK_CONNECT_STRING, connectString); <line22> return new DistributedConfigurationManager(component); <line23> } <line24> return new StandaloneConfigurationManager(component, propertiesFiles); <line25> } <line26> } <line27> "	 <line24>	Yes
public class A { <line0> private void initialise() { <line1> Integer currentState = <line2> (Integer) <line3> iasZoneCluster.getAttribute(ZclIasZoneCluster.ATTR_ZONESTATE).readValue(Long.MAX_VALUE); <line4> if (currentState != null) { <line5> ZoneStateEnum currentStateEnum = ZoneStateEnum.getByValue(currentState); <line6> if (currentStateEnum == ZoneStateEnum.ENROLLED) { <line7> return; <line8> } <line9> } else { <line10> } <line11> ZclAttribute cieAddressAttribute = <line12> iasZoneCluster.getAttribute(ZclIasZoneCluster.ATTR_IASCIEADDRESS); <line13> IeeeAddress currentIeeeAddress = (IeeeAddress) cieAddressAttribute.readValue(0); <line14> if (!ieeeAddress.equals(currentIeeeAddress)) { <line15> cieAddressAttribute.writeValue(ieeeAddress); <line16> currentIeeeAddress = (IeeeAddress) cieAddressAttribute.readValue(0); <line17> if (ieeeAddress.equals(currentIeeeAddress)) { <line18> } else { <line19> } <line20> } <line21> Integer currentZone = <line22> (Integer) iasZoneCluster.getAttribute(ZclIasZoneCluster.ATTR_ZONEID).readValue(0); <line23> if (currentZone == null) { <line24> } else { <line25> } <line26> zoneType = <line27> (Integer) <line28> iasZoneCluster.getAttribute(ZclIasZoneCluster.ATTR_ZONETYPE).readValue(Long.MAX_VALUE); <line29> if (zoneType == null) { <line30> } else { <line31> } <line32> final Runnable runnableTask = new AutoEnrollmentTask(); <line33> autoEnrollmentTask = networkManager.scheduleTask(runnableTask, autoEnrollDelay); <line34> } <line35> } <line36> 	 <line18>	Yes
public class A { <line0> protected void handleRedirectToRegistrationForm( <line1> HttpServletRequest httpRequest, HttpServletResponse httpResponse, OAuthPrincipal principal) <line2> throws IOException { <line3> if (log.isTraceEnabled()) { <line4> } <line5> OAuthPrincipalProcessor principalProcessor = <line6> principal.getOauthProviderType().getOauthPrincipalProcessor(); <line7> User gateInUser = principalProcessor.convertToGateInUser(principal); <line8> authenticationRegistry.setAttributeOfClient( <line9> httpRequest, OAuthConstants.ATTRIBUTE_AUTHENTICATED_PORTAL_USER, gateInUser); <line10> String registrationRedirectUrl = getRegistrationRedirectURL(httpRequest); <line11> registrationRedirectUrl = httpResponse.encodeRedirectURL(registrationRedirectUrl); <line12> httpResponse.sendRedirect(registrationRedirectUrl); <line13> } <line14> } <line15> 	 <line9>	No
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""getJobs"") <line2> public void testJobLifecycle(JobInfo jobInfo, String operationName) throws Exception { <line3> jobInfo = createJob(jobInfo); <line4> jobInfo = template().requestBody(""direct:getJob"", jobInfo, JobInfo.class); <line5> assertSame(JobStateEnum.OPEN, jobInfo.getState(), ""Job should be OPEN""); <line6> jobInfo = template().requestBody(""direct:closeJob"", jobInfo, JobInfo.class); <line7> assertSame(JobStateEnum.CLOSED, jobInfo.getState(), ""Job should be CLOSED""); <line8> jobInfo = template().requestBody(""direct:abortJob"", jobInfo, JobInfo.class); <line9> assertSame(JobStateEnum.ABORTED, jobInfo.getState(), ""Job should be ABORTED""); <line10> } <line11> } <line12> "	 <line3>	Yes
"public class A { <line0> @Override <line1> public void gesvd(INDArray A, INDArray S, INDArray U, INDArray VT) { <line2> if (A.rows() > Integer.MAX_VALUE || A.columns() > Integer.MAX_VALUE) <line3> throw new ND4JArraySizeException(); <line4> int m = (int) A.rows(); <line5> int n = (int) A.columns(); <line6> byte jobu = (byte) (U == null ? 'N' : 'A'); <line7> byte jobvt = (byte) (VT == null ? 'N' : 'A'); <line8> INDArray INFO = <line9> Nd4j.createArrayFromShapeBuffer( <line10> Nd4j.getDataBufferFactory().createInt(1), <line11> Nd4j.getShapeInfoProvider() <line12> .createShapeInformation(new long[] {1, 1}, DataType.INT) <line13> .getFirst()); <line14> if (A.data().dataType() == DataType.DOUBLE) dgesvd(jobu, jobvt, m, n, A, S, U, VT, INFO); <line15> else if (A.data().dataType() == DataType.FLOAT) sgesvd(jobu, jobvt, m, n, A, S, U, VT, INFO); <line16> else throw new UnsupportedOperationException(); <line17> if (INFO.getInt(0) < 0) { <line18> throw new Error(""Parameter #"" + INFO.getInt(0) + "" to gesvd() was not valid""); <line19> } else if (INFO.getInt(0) > 0) { <line20> } <line21> } <line22> } <line23> "	 <line21>	No
public class A { <line0> public static void process(WordprocessingMLPackage wmlPackage) { <line1> TraversalUtil.visit(wmlPackage, false, COMBINE_VISITOR); <line2> if (log.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	 <line1>	Yes
"public class A { <line0> void writeHtmlToLastShutdownFile() { <line1> try { <line2> final File dir = Parameters.getStorageDirectory(getApplication()); <line3> if (!dir.mkdirs() && !dir.exists()) { <line4> throw new IOException(""JavaMelody directory can't be created: "" + dir.getPath()); <line5> } <line6> final File lastShutdownFile = new File(dir, ""last_shutdown.html""); <line7> try (BufferedWriter writer = new BufferedWriter(new FileWriter(lastShutdownFile))) { <line8> final JavaInformations javaInformations = <line9> new JavaInformations(Parameters.getServletContext(), true); <line10> final HtmlReport myHtmlReport = <line11> new HtmlReport( <line12> collector, <line13> collectorServer, <line14> Collections.singletonList(javaInformations), <line15> Period.JOUR, <line16> writer); <line17> myHtmlReport.writeLastShutdown(); <line18> } <line19> } catch (final IOException e) { <line20> } <line21> } <line22> } <line23> "	 <line20>	Yes
"public class A { <line0> @Override <line1> public CheckResult check() { <line2> try { <line3> Version esVersion = <line4> if (esVersion.isCompatible(RECOMMENDED_ES_VERSION)) { <line5> return CheckResult.builder().checkName(checkName()).resultType(ResultType.GOOD).build(); <line6> } <line7> String esVersionCompatibilityWarn = <line8> String.format( <line9> ""ES version(%s) is not compatible with the recommendation(%s)"", <line10> esVersion.toString(), RECOMMENDED_ES_VERSION.toString()); <line11> return CheckResult.builder() <line12> .checkName(checkName()) <line13> .resultType(ResultType.BAD) <line14> .description(esVersionCompatibilityWarn) <line15> .build(); <line16> } catch (IOException e) { <line17> return CheckResult.builder() <line18> .checkName(checkName()) <line19> .resultType(ResultType.BAD) <line20> .description(VERSION_CHECKING_ERROR_MESSAGE + "": "" + e.getMessage()) <line21> .build(); <line22> } <line23> } <line24> } <line25> "	 <line17>	Yes
public class A { <line0> @Override <line1> public void close() { <line2> final WriteTransaction tx = dataBroker.newWriteOnlyTransaction(); <line3> tx.delete(LogicalDatastoreType.OPERATIONAL, InstanceIdentifier.create(Netconf.class)); <line4> tx.commit() <line5> .addCallback( <line6> new FutureCallback<CommitInfo>() { <line7> @Override <line8> public void onSuccess(final CommitInfo info) { <line9> } <line10>  <line11> @Override <line12> public void onFailure(final Throwable throwable) { <line13> } <line14> }, <line15> MoreExecutors.directExecutor()); <line16> notificationRegistration.close(); <line17> } <line18> } <line19> 	 <line0>	No
"public class A { <line0> public synchronized SOAPMessage doSOAPRequestUncached(SOAPRequest soapRequest) <line1> throws Tr064CommunicationException { <line2> try { <line3> Request request = prepareSOAPRequest(soapRequest).timeout(SOAP_TIMEOUT, TimeUnit.SECONDS); <line4> if (logger.isTraceEnabled()) { <line5> request <line6> .getContent() <line7> } <line8> ContentResponse response = request.send(); <line9> if (response.getStatus() == HttpStatus.UNAUTHORIZED_401) { <line10> httpClient.getAuthenticationStore().clearAuthenticationResults(); <line11> request = prepareSOAPRequest(soapRequest).timeout(SOAP_TIMEOUT, TimeUnit.SECONDS); <line12> response = request.send(); <line13> } <line14> try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) { <line15> SOAPMessage soapMessage = MessageFactory.newInstance().createMessage(null, is); <line16> if (soapMessage.getSOAPBody().hasFault()) { <line17> String soapError = getSOAPElement(soapMessage, ""errorCode"").orElse(""unknown""); <line18> String soapReason = getSOAPElement(soapMessage, ""errorDescription"").orElse(""unknown""); <line19> String error = <line20> String.format( <line21> ""HTTP-Response-Code %d (%s), SOAP-Fault: %s (%s)"", <line22> response.getStatus(), response.getReason(), soapError, soapReason); <line23> throw new Tr064CommunicationException(error, response.getStatus(), soapError); <line24> } <line25> return soapMessage; <line26> } <line27> } catch (IOException <line28> | SOAPException <line29> | InterruptedException <line30> | TimeoutException <line31> | ExecutionException e) { <line32> throw new Tr064CommunicationException(e); <line33> } <line34> } <line35> } <line36> "	 <line15>	Yes
public class A { <line0> protected void processFuture(Future<String> future) { <line1> try { <line2> future.get(DEFAULT_EXTRACTOR_JOB_TIME, TimeUnit.SECONDS); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	 <line6>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public void execute(Tuple input) { <line2> List<PacketInfo> packetInfoList = null; <line3> try { <line4> packetInfoList = PcapParser.parse(input.getBinary(0)); <line5> if (packetInfoList != null) { <line6> for (PacketInfo packetInfo : packetInfoList) { <line7> String string_pcap = packetInfo.getJsonIndexDoc(); <line8> Object obj = JSONValue.parse(string_pcap); <line9> JSONObject header = (JSONObject) obj; <line10> JSONObject message = new JSONObject(); <line11> message.put(""message"", header); <line12> collector.emit(""message"", new Values(packetInfo.getKey(), message)); <line13> collector.emit( <line14> ""pcap_header_stream"", new Values(packetInfo.getJsonDoc(), packetInfo.getKey())); <line15> collector.emit( <line16> ""pcap_data_stream"", <line17> new Values( <line18> packetInfo.getKey(), <line19> packetInfo.getPacketTimeInNanos() / timePrecisionDivisor, <line20> input.getBinary(0))); <line21> } <line22> } <line23> } catch (Exception e) { <line24> collector.fail(input); <line25> e.printStackTrace(); <line26> JSONObject error = <line27> ErrorGenerator.generateErrorMessage(""Alerts problem: "" + input.getBinary(0), e); <line28> collector.emit(""error"", new Values(error)); <line29> return; <line30> } <line31> collector.ack(input); <line32> } <line33> } <line34> "	 <line6>	No
public class A { <line0> @Override <line1> public void stop() { <line2> DestinationDispatcherThread<T> dispatcherThread = mDispatcherThread; <line3> mDispatcherThread = null; <line4> if (dispatcherThread != null && dispatcherThread.isAlive()) { <line5> dispatcherThread.stopThread(); <line6> try { <line7> dispatcherThread.join(); <line8> } catch (InterruptedException e) { <line9> } <line10> } <line11> closeFile(); <line12> } <line13> } <line14> 	 <line1>	No
"public class A { <line0> private static int toICUCollatorReorderCode(final String reorderCode) { <line1> switch (reorderCode.toLowerCase()) { <line2> case ""default"": <line3> return Collator.ReorderCodes.DEFAULT; <line4> case ""none"": <line5> return Collator.ReorderCodes.NONE; <line6> case ""others"": <line7> return Collator.ReorderCodes.OTHERS; <line8> case ""space"": <line9> return Collator.ReorderCodes.SPACE; <line10> case ""first"": <line11> return Collator.ReorderCodes.FIRST; <line12> case ""punctuation"": <line13> return Collator.ReorderCodes.PUNCTUATION; <line14> case ""symbol"": <line15> return Collator.ReorderCodes.SYMBOL; <line16> case ""currency"": <line17> return Collator.ReorderCodes.CURRENCY; <line18> case ""digit"": <line19> return Collator.ReorderCodes.DIGIT; <line20> default: <line21> return -1; <line22> } <line23> } <line24> } <line25> "	 <line2>	No
public class A { <line0> protected synchronized void quit() { <line1> closeServerSocket(); <line2> synchronized (handlers) { <line3> for (ProtocolHandler handler : handlers) { <line4> handler.close(); <line5> } <line6> handlers.clear(); <line7> } <line8> } <line9> } <line10> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public final boolean commit() throws LoginException { <line2> if (!preCommit()) { <line3> return false; <line4> } <line5> boolean result = false; <line6> try { <line7> if (this.assertion != null) { <line8> if (this.ticket != null) { <line9> this.subject.getPrivateCredentials().add(this.ticket); <line10> } else { <line11> throw new LoginException(""Ticket credential not found.""); <line12> } <line13> final AssertionPrincipal casPrincipal = <line14> new AssertionPrincipal(this.assertion.getPrincipal().getName(), this.assertion); <line15> this.subject.getPrincipals().add(casPrincipal); <line16> final Group principalGroup = new SimpleGroup(this.principalGroupName); <line17> principalGroup.addMember(casPrincipal); <line18> this.subject.getPrincipals().add(principalGroup); <line19> final Group roleGroup = new SimpleGroup(this.roleGroupName); <line20> for (final String defaultRole : defaultRoles) { <line21> roleGroup.addMember(new SimplePrincipal(defaultRole)); <line22> } <line23> final Map<String, Object> attributes = this.assertion.getPrincipal().getAttributes(); <line24> for (final String key : attributes.keySet()) { <line25> if (this.roleAttributeNames.contains(key)) { <line26> final Object value = attributes.get(key); <line27> if (value instanceof Collection<?>) { <line28> for (final Object o : (Collection<?>) value) { <line29> roleGroup.addMember(new SimplePrincipal(o.toString())); <line30> } <line31> } else { <line32> roleGroup.addMember(new SimplePrincipal(value.toString())); <line33> } <line34> } <line35> } <line36> this.subject.getPrincipals().add(roleGroup); <line37> this.sharedState.put(LOGIN_NAME, assertion.getPrincipal().getName()); <line38> if (this.cacheAssertions) { <line39> ASSERTION_CACHE.put(this.ticket, this.assertion); <line40> } <line41> } else { <line42> if (this.ticket != null) { <line43> this.ticket = null; <line44> } <line45> } <line46> result = true; <line47> } finally { <line48> postCommit(result); <line49> } <line50> return result; <line51> } <line52> } <line53> "	 <line39>	Yes
"public class A { <line0> @VisibleForTesting <line1> void auditAction( <line2> ArchiveOperation.Action action, <line3> List<String> affectedCompIds, <line4> User user, <line5> String containerComponentType) { <line6> String comment = <line7> String.format( <line8> ""All versions of this component were %s"", <line9> action == ArchiveOperation.Action.ARCHIVE ? ""archived"" : ""restored""); <line10> HashSet<String> auditDoneUUIDs = new HashSet<>(); <line11> for (String componentId : affectedCompIds) { <line12> Either<Component, StorageOperationStatus> result = <line13> toscaOperationFacade.getToscaElement(componentId, new ComponentParametersView()); <line14> if (result.isRight()) { <line15> continue; <line16> } <line17> if (auditDoneUUIDs.add(result.left().value().getUUID())) { <line18> AuditingActionEnum auditAction = <line19> action == ArchiveOperation.Action.ARCHIVE <line20> ? AuditingActionEnum.ARCHIVE_COMPONENT <line21> : AuditingActionEnum.RESTORE_COMPONENT; <line22> result <line23> .left() <line24> .foreachDoEffect( <line25> c -> { <line26> c.setVersion(null); <line27> componentUtils.auditComponentAdmin( <line28> componentUtils.getResponseFormat(ActionStatus.OK), <line29> user, <line30> c, <line31> auditAction, <line32> ComponentTypeEnum.findByParamName(containerComponentType), <line33> comment); <line34> }); <line35> } <line36> } <line37> } <line38> } <line39> "	 <line34>	No
public class A { <line0> public void sendEmail(String subject, String receiver, String text) { <line1> try { <line2> MimeMessage mimeMessage = mailSender.createMimeMessage(); <line3> MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); <line4> helper.setSubject(subject); <line5> helper.setText(text, true); <line6> helper.setTo(receiver); <line7> helper.setFrom(SENDER); <line8> mailSender.send(mimeMessage); <line9> } catch (Exception e) { <line10> } <line11> } <line12> } <line13> 	 <line7>	No
public class A { <line0> synchronized void garbageCollect() { <line1> try { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> if (localJobFile != null) { <line5> localFs.delete(localJobFile, true); <line6> localJobFile = null; <line7> } <line8> if (localJarFile != null) { <line9> localFs.delete(localJarFile, true); <line10> localJarFile = null; <line11> } <line12> FileSystem fs = FileSystem.get(conf); <line13> fs.delete(new Path(profile.getJobFile()).getParent(), true); <line14> } catch (IOException e) { <line15> } <line16> } <line17> } <line18> 	 <line8>	No
"public class A { <line0> private void initializeLogging() throws ServletException { <line1> Context initialContext; <line2> String customLogLocation; <line3> final String defaultLogLocation = ""classpath:logback-config.xml""; <line4> try { <line5> initialContext = new InitialContext(); <line6> customLogLocation = (String) initialContext.lookup(this.logConfig); <line7> if (new File(customLogLocation).exists()) { <line8> this.initializeLoggingContext(customLogLocation); <line9> } else { <line10> this.initializeLoggingContext(defaultLogLocation); <line11> } <line12> } catch (final NamingException | FileNotFoundException | JoranException e) { <line13> throw new ServletException(e); <line14> } <line15> } <line16> } <line17> "	 <line13>	Yes
public class A { <line0> public synchronized void disconnect() throws IOException { <line1> for (IoSession session : getManagedSessions().values()) { <line2> session.close(true); <line3> } <line4> fireServiceInactivated(); <line5> idleChecker.destroy(); <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> protected static void setInvalid() { <line1> if (JBoss6VFS.valid != null && JBoss6VFS.valid) { <line2> JBoss6VFS.valid = false; <line3> } <line4> } <line5> } <line6> 	 <line0>	No
public class A { <line0> private ParametersHolder createParametersHolder(CommandLine cli) <line1> throws ParseException, YarnException { <line2> String yamlConfigFile = cli.getOptionValue(CliConstants.YAML_CONFIG); <line3> if (yamlConfigFile != null) { <line4> YamlConfigFile yamlConfig = readYamlConfigFile(yamlConfigFile); <line5> checkYamlConfig(yamlConfigFile, yamlConfig); <line6> return ParametersHolder.createWithCmdLineAndYaml(cli, yamlConfig, Command.RUN_JOB); <line7> } else { <line8> return ParametersHolder.createWithCmdLine(cli, Command.RUN_JOB); <line9> } <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> private IServerTypeDesc createServerTypeDescInstance( <line1> String typeName, <line2> ITypeDesc typeDesc, <line3> String superTypeName, <line4> Map<String, IServerTypeDesc> localTypeMap) { <line5> logEnter(""createServerTypeDescInstance"", ""typeName"", typeName); <line6> IServerTypeDesc superTypeDesc = superTypeName != null ? localTypeMap.get(superTypeName) : null; <line7> ServerTypeDesc serverTypeDesc = <line8> new ServerTypeDesc(_typeIdGenerator.incrementAndGet(), typeName, typeDesc, superTypeDesc); <line9> localTypeMap.put(typeName, serverTypeDesc); <line10> if (_logger.isDebugEnabled()) { <line11> if (_logger.isTraceEnabled()) logTypeMap(localTypeMap); <line12> else if (_logger.isDebugEnabled()) logServerTypeDesc(serverTypeDesc, LogLevel.DEBUG); <line13> } <line14> for (IServerTypeDescListener listener : _typeDescListeners) <line15> listener.onTypeAdded(serverTypeDesc); <line16> logExit(""createServerTypeDescInstance"", ""typeName"", typeName); <line17> return serverTypeDesc; <line18> } <line19> } <line20> "	 <line11>	Yes
"public class A { <line0> public List<LoadBalancerUpstream> getUpstreamsForTasks( <line1> List<SingularityTask> tasks, String requestId, Optional<String> loadBalancerUpstreamGroup) { <line2> final List<LoadBalancerUpstream> upstreams = Lists.newArrayListWithCapacity(tasks.size()); <line3> for (SingularityTask task : tasks) { <line4> final Optional<Long> maybeLoadBalancerPort = <line5> MesosUtils.getPortByIndex( <line6> mesosProtosUtils.toResourceList(task.getMesosTask().getResources()), <line7> task.getTaskRequest().getDeploy().getLoadBalancerPortIndex().orElse(0)); <line8> if (maybeLoadBalancerPort.isPresent()) { <line9> String upstream = String.format(""%s:%d"", task.getHostname(), maybeLoadBalancerPort.get()); <line10> Optional<String> group = loadBalancerUpstreamGroup; <line11> if (taskLabelForLoadBalancerUpstreamGroup.isPresent()) { <line12> for (MesosParameter label : task.getMesosTask().getLabels().getLabels()) { <line13> if (label.hasKey() <line14> && label.getKey().equals(taskLabelForLoadBalancerUpstreamGroup.get()) <line15> && label.hasValue()) { <line16> group = Optional.of(label.getValue()); <line17> break; <line18> } <line19> } <line20> } <line21> upstreams.add( <line22> new LoadBalancerUpstream(upstream, group.orElse(""default""), task.getRackId())); <line23> } else { <line24> } <line25> } <line26> return upstreams; <line27> } <line28> } <line29> "	 <line3>	No
"public class A { <line0> public static IRealization selectRealization(OLAPContext olapContext) <line1> throws NoRealizationFoundException { <line2> ProjectManager prjMgr = ProjectManager.getInstance(olapContext.olapSchema.getConfig()); <line3> String factTableName = olapContext.firstTableScan.getTableName(); <line4> String projectName = olapContext.olapSchema.getProjectName(); <line5> List<IRealization> realizations = <line6> Lists.newArrayList(prjMgr.getRealizationsByTable(projectName, factTableName)); <line7> RoutingRule.applyRules(realizations, olapContext); <line8> if (realizations.size() == 0) { <line9> throw new NoRealizationFoundException( <line10> ""Can't find any realization. Please confirm with providers. SQL digest: "" <line11> + olapContext.getSQLDigest().toString()); <line12> } <line13> return realizations.get(0); <line14> } <line15> } <line16> "	 <line11>	No
"public class A { <line0> private static SimpleFeatureType getSimpleFeatureType() { <line1> SimpleFeatureType type = null; <line2> try { <line3> type = <line4> DataUtilities.createType( <line5> ""testCityData"", <line6> CITY_ATTRIBUTE <line7> + "":String,"" <line8> + STATE_ATTRIBUTE <line9> + "":String,"" <line10> + POPULATION_ATTRIBUTE <line11> + "":Double,"" <line12> + LAND_AREA_ATTRIBUTE <line13> + "":Double,"" <line14> + GEOMETRY_ATTRIBUTE <line15> + "":Geometry""); <line16> } catch (final SchemaException e) { <line17> } <line18> return type; <line19> } <line20> } <line21> "	 <line17>	Yes
"public class A { <line0> @Test <line1> public void testDifferentEventTypesInBatchWithAvroReflect() throws IOException { <line2> loadProperties(""flume-log4jtest-avro-reflect.properties""); <line3> props.put(""log4j.appender.out2.Port"", String.valueOf(port)); <line4> PropertyConfigurator.configure(props); <line5> Logger logger = LogManager.getLogger(getClass()); <line6> List<Object> events = Arrays.asList(""string"", new AppEvent(""appEvent"")); <line7> Transaction transaction = ch.getTransaction(); <line8> transaction.begin(); <line9> for (Object o : events) { <line10> Event e = ch.take(); <line11> Assert.assertNotNull(e); <line12> ReflectDatumReader<?> reader = new ReflectDatumReader<>(o.getClass()); <line13> BinaryDecoder decoder = DecoderFactory.get().binaryDecoder(e.getBody(), null); <line14> Object readObject = reader.read(null, decoder); <line15> Assert.assertEquals(o, readObject); <line16> Map<String, String> hdrs = e.getHeaders(); <line17> Assert.assertNull(hdrs.get(Log4jAvroHeaders.MESSAGE_ENCODING.toString())); <line18> Assert.assertNull( <line19> ""Schema URL should not be set"", hdrs.get(Log4jAvroHeaders.AVRO_SCHEMA_URL.toString())); <line20> Assert.assertEquals( <line21> ""Schema string should be set"", <line22> ReflectData.get().getSchema(readObject.getClass()).toString(), <line23> hdrs.get(Log4jAvroHeaders.AVRO_SCHEMA_LITERAL.toString())); <line24> } <line25> Assert.assertNull(""There should be no more events in the channel"", ch.take()); <line26> } <line27> } <line28> "	 <line7>	Yes
public class A { <line0> public CharSequence postProcess(CharSequence object) { <line1> return (prefix + object); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void onFileChange(File file) { <line2> super.onFileChange(file); <line3> try { <line4> if (hbaseAdapter.getHbaseMapping().containsKey(file.getName())) { <line5> String configContent = <line6> MappingConfigsLoader.loadConfig(adapterName + File.separator + file.getName()); <line7> if (configContent == null) { <line8> onFileDelete(file); <line9> return; <line10> } <line11> MappingConfig config = <line12> YmlConfigBinder.bindYmlToObj( <line13> null, configContent, MappingConfig.class, null, envProperties); <line14> if (config == null) { <line15> return; <line16> } <line17> config.validate(); <line18> if (hbaseAdapter.getHbaseMapping().containsKey(file.getName())) { <line19> deleteConfigFromCache(file); <line20> } <line21> addConfigToCache(file, config); <line22> } <line23> } catch (Exception e) { <line24> } <line25> } <line26> } <line27> 	 <line24>	Yes
public class A { <line0> @Override <line1> public boolean isAuth(UserDetails user, Content content) throws ApsSystemException { <line2> if (null == content) { <line3> return false; <line4> } else if (Content.STATUS_NEW.equals(content.getStatus()) && null == content.getMainGroup()) { <line5> return true; <line6> } <line7> return this.getAuthorizationManager().isAuth(user, content); <line8> } <line9> } <line10> 	 <line7>	No
public class A { <line0> private boolean isHostCompatibleForVcenterCluster(Host host) { <line1> if (host.getType().equalsIgnoreCase(Host.HostType.Esx.name())) { <line2> return true; <line3> } else { <line4> return false; <line5> } <line6> } <line7> } <line8> 	 <line2>	Yes
public class A { <line0> private static String getURL( <line1> String action, String collectionName, MCRCategLinkReference reference, boolean absolute) { <line2> MCRCollection defaultCollection = <line3> reference != null ? getCollectionWithAction(reference.getType(), action, null) : null; <line4> MCRCollection collection = getCollectionWithAction(collectionName, action, defaultCollection); <line5> if (collection == null) { <line6> return null; <line7> } <line8> return getURL(action, collection, reference, absolute); <line9> } <line10> } <line11> 	 <line6>	Yes
"public class A { <line0> private BusinessList retrieveBusinessesListFromUDDI(ExchangeType exchange) <line1> throws UDDIAccessorException { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> BusinessList businessList; <line5> try { <line6> UDDIFindBusinessProxyObjectFactory uddiFactory = new UDDIFindBusinessProxyObjectFactory(); <line7> UDDIFindBusinessProxy uddiProxy = uddiFactory.getUDDIBusinessInfoProxy(); <line8> businessList = uddiProxy.findBusinessesFromUDDI(exchange); <line9> removeIgnoredBusinesses(businessList); <line10> } catch (UDDIFindBusinessException e) { <line11> String sErrorMessage = <line12> ""Failed to call 'find_business' web service on the NHIN UDDI server.  Error: "" <line13> + e.getMessage(); <line14> throw new UDDIAccessorException(sErrorMessage, e); <line15> } <line16> return businessList; <line17> } <line18> } <line19> "	 <line1>	No
"public class A { <line0> @Effector( <line1> description = <line2> ""Deploys the given artifact, from a source URL, to a given deployment filename/context"") <line3> public void deploy( <line4> @EffectorParam(name = ""url"", description = ""URL of WAR file"") String url, <line5> @EffectorParam( <line6> name = ""targetName"", <line7> description = ""context path where WAR should be deployed (/ for ROOT)"") <line8> String targetName) { <line9> try { <line10> checkNotNull(url, ""url""); <line11> checkNotNull(targetName, ""targetName""); <line12> JavaWebAppDriver driver = getDriver(); <line13> String deployedName = driver.deploy(url, targetName); <line14> Set<String> deployedWars = getAttribute(DEPLOYED_WARS); <line15> if (deployedWars == null) { <line16> deployedWars = Sets.newLinkedHashSet(); <line17> } <line18> deployedWars.add(deployedName); <line19> sensors().set(DEPLOYED_WARS, deployedWars); <line20> } catch (RuntimeException e) { <line21> throw Throwables.propagate(e); <line22> } <line23> } <line24> } <line25> "	 <line21>	Yes
public class A { <line0> private boolean store(Object value, S step, String propertyName, Class<?> expectedType) { <line1> Method setterMethod = getSetterMethod(step, propertyName, expectedType); <line2> if (setterMethod != null) { <line3> try { <line4> setterMethod.invoke(step, value); <line5> return true; <line6> } catch (Exception e) { <line7> } <line8> } else { <line9> if (LOG.isWarnEnabled()) { <line10> } <line11> } <line12> return false; <line13> } <line14> } <line15> 	 <line11>	No
"public class A { <line0> @RateLimited <line1> @POST <line2> @Consumes(MediaType.APPLICATION_OCTET_STREAM) <line3> @Path(""/"") <line4> public int upload(@QueryParam(""size"") int size, InputStream stream) throws IOException { <line5> if (size > MAX_UPLOAD_SIZE) { <line6> return -1; <line7> } <line8> CLIENT_COUNT.incrementAndGet(); <line9> byte[] b = new byte[1024]; <line10> int totalCount = 0; <line11> int count; <line12> try { <line13> while ((count = stream.read(b)) > -1) { <line14> totalCount += count; <line15> } <line16> } finally { <line17> CLIENT_COUNT.decrementAndGet(); <line18> } <line19> return totalCount; <line20> } <line21> } <line22> "	 <line21>	No
"public class A { <line0> @ServiceActivator(inputChannel = ""requests"", outputChannel = ""replies"") <line1> public String process(String message) { <line2> String result = message + "": "" + count; <line3> if (count < expected.size()) { <line4> processed.add(message); <line5> count++; <line6> } <line7> if (""fail"".equals(message)) { <line8> throw new RuntimeException(""Planned failure""); <line9> } <line10> return result; <line11> } <line12> } <line13> "	 <line3>	Yes
"public class A { <line0> @Then( <line1> ""^the platform buffers a set light schedule response message for device \""([^\""]*)\"" that"" <line2> + "" contains a soap fault$"") <line3> public void thePlatformBuffersASetLightScheduleResponseMessageForDeviceContainsSoapFault( <line4> final String deviceIdentification, final Map<String, String> expectedResponseData) <line5> throws Throwable { <line6> final SetScheduleAsyncRequest request = new SetScheduleAsyncRequest(); <line7> final AsyncRequest asyncRequest = new AsyncRequest(); <line8> asyncRequest.setDeviceId(deviceIdentification); <line9> asyncRequest.setCorrelationUid( <line10> (String) ScenarioContext.current().get(PlatformPubliclightingKeys.KEY_CORRELATION_UID)); <line11> request.setAsyncRequest(asyncRequest); <line12> Wait.untilAndReturn( <line13> () -> { <line14> try { <line15> this.client.getSetSchedule(request); <line16> } catch (final SoapFaultClientException ex) { <line17> final String faultString = ex.getFaultStringOrReason(); <line18> if (""CorrelationUid is unknown."".equals(faultString)) { <line19> throw new Exception( <line20> ""Received a SOAP fault on setSchedule that could be rejected because the"" <line21> + "" CorrelationUid is unknown""); <line22> } <line23> ScenarioContext.current().put(PlatformKeys.RESPONSE, ex); <line24> return null; <line25> } <line26> throw new Exception(""Received a setSchedule message without a SOAP fault""); <line27> }); <line28> GenericResponseSteps.verifySoapFault(expectedResponseData); <line29> } <line30> } <line31> "	 <line17>	Yes
"public class A { <line0> protected void checkAndAddSpatialFilteringProfileCriterion( <line1> Criteria c, GetObservationRequest request, Session session, StringBuilder logArgs) <line2> throws OwsExceptionReport { <line3> if (request.hasSpatialFilteringProfileSpatialFilter()) { <line4> if (getGeometryHandler().isSpatialDatasource()) { <line5> c.add( <line6> SpatialRestrictions.filter( <line7> DataEntity.PROPERTY_GEOMETRY_ENTITY, <line8> ((GetObservationRequest) request).getSpatialFilter().getOperator(), <line9> getGeometryHandler() <line10> .switchCoordinateAxisFromToDatasourceIfNeeded( <line11> ((GetObservationRequest) request).getSpatialFilter().getGeometry()))); <line12> logArgs.append("", spatialFilter""); <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> "	 <line14>	Yes
public class A { <line0> public void start(final boolean exitOnOSGiShutDown) <line1> throws InstantiationException, IllegalAccessException, ClassNotFoundException, <line2> BundleException, IOException, InterruptedException { <line3> printBanner(); <line4> FrameworkFactory factory = (FrameworkFactory) Class.forName(factoryClass).newInstance(); <line5> framework = factory.newFramework(frameworkProperties); <line6> framework.init(); <line7> BundleContext context = framework.getBundleContext(); <line8> List<Bundle> bundles = new ArrayList<>(); <line9> int startLevel = 1; <line10> for (BundleSearchPath searchPath : searchPaths) { <line11> bundles.addAll(installBundles(context, searchPath, startLevel++)); <line12> } <line13> startBundles(bundles); <line14> try { <line15> framework.start(); <line16> } catch (BundleException e) { <line17> } <line18> addShutdownHook(); <line19> addCleanupOnExit(exitOnOSGiShutDown); <line20> } <line21> } <line22> 	 <line7>	Yes
public class A { <line0> @Override <line1> public int minHealthyVolumeNum(List<DatanodeDetails> dnList) { <line2> List<Integer> volumeCountList = new ArrayList<>(dnList.size()); <line3> for (DatanodeDetails dn : dnList) { <line4> try { <line5> volumeCountList.add(nodeStateManager.getNode(dn).getHealthyVolumeCount()); <line6> } catch (NodeNotFoundException e) { <line7> } <line8> } <line9> Preconditions.checkArgument(!volumeCountList.isEmpty()); <line10> return Collections.min(volumeCountList); <line11> } <line12> } <line13> 	 <line4>	No
"public class A { <line0> private boolean askUser(String promptText) { <line1> OptionsManager optionsManager = OptionsManager.getInstance(); <line2> Boolean response = optionsManager.getSshPromptAnswer(promptText); <line3> if (logger.isDebugEnabled()) { <line4> } <line5> if (response == null) { <line6> String[] options = new String[] {""   Yes   "", ""   No   ""}; <line7> int[] optonsId = new int[] {0, 1}; <line8> int result = <line9> ((StandalonePluginWorkspace) PluginWorkspaceProvider.getPluginWorkspace()) <line10> .showConfirmDialog(""Connection"", promptText, options, optonsId); <line11> if (logger.isDebugEnabled()) { <line12> } <line13> if (result == 0) { <line14> response = Boolean.TRUE; <line15> } else { <line16> response = Boolean.FALSE; <line17> } <line18> optionsManager.saveSshPrompt(promptText, response); <line19> } <line20> return response; <line21> } <line22> } <line23> "	 <line21>	No
"public class A { <line0> @Override <line1> protected void onActivate(Optional<Object> message) { <line2> WonMessage connectMessage = <line3> WonMessageBuilder.connect() <line4> .sockets() <line5> .sender(URI.create(atomUri1.toString() + ""#holdableSocket"")) <line6> .recipient(URI.create(atomUri3.toString() + ""#holderSocket"")) <line7> .direction() <line8> .fromOwner() <line9> .build(); <line10> connectMessage = ctx.getWonMessageSender().prepareMessage(connectMessage); <line11> EventListener successCallback = <line12> event -> { <line13> failTest( <line14> bus, <line15> String.format( <line16> ""Unexpectedly, holdable %s accepted connection to another holder"", <line17> atomUri1.toString())); <line18> }; <line19> EventListener failureCallback = <line20> event -> { <line21> passTest(bus); <line22> }; <line23> EventBotActionUtils.makeAndSubscribeResponseListener( <line24> connectMessage, successCallback, failureCallback, ctx); <line25> ctx.getWonMessageSender().sendMessage(connectMessage); <line26> } <line27> } <line28> "	 <line27>	No
"public class A { <line0> @Override <line1> public boolean initialize() { <line2> SkebbyParameters.getSkebbyParameters(); <line3> String url = SkebbyParameters.URL; <line4> if (url.equals("""")) { <line5> return false; <line6> } <line7> return Ping.ping(url, SmsParameters.TIMEOUT); <line8> } <line9> } <line10> "	 <line5>	Yes
public class A { <line0> List<GitBlameWithUsage> getGitBlameWithUsagesFromLine( <line1> String line, List<GitBlameWithUsage> gitBlameWithUsages, FileType fileType) { <line2> List<GitBlameWithUsage> gitBlameWithUsagesWithLine = new ArrayList<>(); <line3> if (line != null) { <line4> for (GitBlameWithUsage gitBlameWithUsage : gitBlameWithUsages) { <line5> String textUnitNameInSource = <line6> textUnitNameToTextUnitNameInSource( <line7> gitBlameWithUsage.getTextUnitName(), <line8> fileType, <line9> gitBlameWithUsage.getPluralForm() != null); <line10> if (line.contains(textUnitNameInSource)) { <line11> gitBlameWithUsagesWithLine.add(gitBlameWithUsage); <line12> } <line13> } <line14> } <line15> return gitBlameWithUsagesWithLine; <line16> } <line17> } <line18> 	 <line11>	Yes
public class A { <line0> public void onError(java.lang.Exception e) { <line1> byte msgType = org.apache.thrift.protocol.TMessageType.REPLY; <line2> org.apache.thrift.TSerializable msg; <line3> resourceGet_result result = new resourceGet_result(); <line4> if (e instanceof InterpreterRPCException) { <line5> result.ex = (InterpreterRPCException) e; <line6> result.setExIsSet(true); <line7> msg = result; <line8> } else if (e instanceof org.apache.thrift.transport.TTransportException) { <line9> fb.close(); <line10> return; <line11> } else if (e instanceof org.apache.thrift.TApplicationException) { <line12> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line13> msg = (org.apache.thrift.TApplicationException) e; <line14> } else { <line15> msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION; <line16> msg = <line17> new org.apache.thrift.TApplicationException( <line18> org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage()); <line19> } <line20> try { <line21> fcall.sendResponse(fb, msg, msgType, seqid); <line22> } catch (java.lang.Exception ex) { <line23> fb.close(); <line24> } <line25> } <line26> } <line27> 	 <line2>	No
"public class A { <line0> @Override <line1> public List<String> getURLsFromPage(Document doc) { <line2> List<String> imageURLs = new ArrayList<>(); <line3> String apiKey = getAPIKey(doc); <line4> int x = 1; <line5> while (true) { <line6> JSONObject jsonData = getJSON(String.valueOf(x), apiKey); <line7> if (jsonData.has(""stat"") && jsonData.getString(""stat"").equals(""fail"")) { <line8> break; <line9> } else { <line10> JSONObject rootData; <line11> try { <line12> rootData = jsonData.getJSONObject(""photoset""); <line13> } catch (JSONException e) { <line14> try { <line15> rootData = jsonData.getJSONObject(""photos""); <line16> } catch (JSONException innerE) { <line17> break; <line18> } <line19> } <line20> int totalPages = rootData.getInt(""pages""); <line21> JSONArray pictures = rootData.getJSONArray(""photo""); <line22> for (int i = 0; i < pictures.length(); i++) { <line23> JSONObject data = (JSONObject) pictures.get(i); <line24> try { <line25> addURLToDownload(getLargestImageURL(data.getString(""id""), apiKey)); <line26> } catch (MalformedURLException e) { <line27> } <line28> } <line29> if (x >= totalPages) { <line30> break; <line31> } <line32> x++; <line33> } <line34> } <line35> return imageURLs; <line36> } <line37> } <line38> "	 <line23>	Yes
public class A { <line0> @Override <line1> public CTAutoResolutionInfo remove(Serializable primaryKey) <line2> throws NoSuchAutoResolutionInfoException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> CTAutoResolutionInfo ctAutoResolutionInfo = <line7> (CTAutoResolutionInfo) session.get(CTAutoResolutionInfoImpl.class, primaryKey); <line8> if (ctAutoResolutionInfo == null) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> throw new NoSuchAutoResolutionInfoException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line12> } <line13> return remove(ctAutoResolutionInfo); <line14> } catch (NoSuchAutoResolutionInfoException noSuchEntityException) { <line15> throw noSuchEntityException; <line16> } catch (Exception exception) { <line17> throw processException(exception); <line18> } finally { <line19> closeSession(session); <line20> } <line21> } <line22> } <line23> 	 <line4>	No
"public class A { <line0> @Override <line1> public void analyse( <line2> String source, ArchiveRecordHeader header, InputStream tikainput, SolrRecord solr) { <line3> final String url = Normalisation.sanitiseWARCHeaderValue(header.getUrl()); <line4> final long start = System.nanoTime(); <line5> try { <line6> if (passUriToFormatTools) { <line7> solr = this.extract(source, solr, tikainput, url); <line8> } else { <line9> solr = this.extract(source, solr, tikainput, null); <line10> } <line11> } catch (Exception i) { <line12> } <line13> Instrument.timeRel( <line14> ""WARCPayloadAnalyzers.analyze#total"", <line15> ""WARCPayloadAnalyzers.analyze#tikasolrextract"", <line16> start); <line17> } <line18> } <line19> "	 <line8>	No
"public class A { <line0> private String handleClientException(Exception ce) { <line1> String msg = """"; <line2> Throwable cause = ce.getCause(); <line3> String sourceId = getId(); <line4> if (cause instanceof WebApplicationException) { <line5> msg = handleWebApplicationException((WebApplicationException) cause); <line6> } else if (cause instanceof IllegalArgumentException) { <line7> msg = <line8> WFS_ERROR_MESSAGE <line9> + String.format(SOURCE_FORMAT, sourceId) <line10> + "". The URI '"" <line11> + getWfsUrl() <line12> + ""' does not specify a valid protocol or could not be correctly parsed. "" <line13> + ce.getMessage(); <line14> } else if (cause instanceof SSLHandshakeException) { <line15> msg = <line16> WFS_ERROR_MESSAGE <line17> + String.format(SOURCE_FORMAT, sourceId) <line18> + "" with URL '"" <line19> + getWfsUrl() <line20> + ""': "" <line21> + ce.getMessage(); <line22> } else if (cause instanceof ConnectException) { <line23> msg = <line24> WFS_ERROR_MESSAGE <line25> + String.format(SOURCE_FORMAT, sourceId) <line26> + "" may not be running.\n"" <line27> + ce.getMessage(); <line28> } else { <line29> msg = WFS_ERROR_MESSAGE + String.format(SOURCE_FORMAT, sourceId) + ""\n"" + ce; <line30> } <line31> return msg; <line32> } <line33> } <line34> "	 <line11>	No
"public class A { <line0> public String pathToKey(Path path) { <line1> Objects.requireNonNull(path, ""Path can't be null!""); <line2> if (!path.isAbsolute()) { <line3> path = new Path(workingDir, path); <line4> } <line5> String key = path.toUri().getPath(); <line6> if (!OzoneFSUtils.isValidName(key)) { <line7> throw new InvalidPathException(""Invalid path Name "" + key); <line8> } <line9> key = key.substring(1); <line10> return key; <line11> } <line12> } <line13> "	 <line8>	No
public class A { <line0> private synchronized void monitor() { <line1> try { <line2> monitorRequestPending.set(false); <line3> if (this.modems.isEmpty()) { <line4> return; <line5> } <line6> final HashMap<String, InterfaceState> newInterfaceStatuses = new HashMap<>(); <line7> for (final Entry<String, MonitoredModem> e : this.modems.entrySet()) { <line8> processMonitor(newInterfaceStatuses, e.getKey(), e.getValue()); <line9> } <line10> checkStatusChange(this.interfaceStatuses, newInterfaceStatuses); <line11> this.interfaceStatuses = newInterfaceStatuses; <line12> } catch (Exception ex) { <line13> } <line14> } <line15> } <line16> 	 <line11>	No
public class A { <line0> @Override <line1> public synchronized V put(K key, V value) { <line2> clearGCCollected(); <line3> map.put(key, new SoftValue<K, V>(value, key, queue)); <line4> return value; <line5> } <line6> } <line7> 	 <line1>	No
"public class A { <line0> public void openOpenshiftPage() throws Exception { <line1> selenium.getDriver().get(ocRoute); <line2> if (waitUntilLoginPage()) { <line3> selenium.takeScreenShot(); <line4> try { <line5> logout(); <line6> } catch (Exception ex) { <line7> } <line8> if (!login()) throw new IllegalAccessException(loginPage.getAlertMessage()); <line9> } <line10> if (!waitUntilConsolePage()) { <line11> throw new IllegalStateException(""Openshift console not loaded""); <line12> } <line13> } <line14> } <line15> "	 <line7>	Yes
"public class A { <line0> @Override <line1> protected void preProcess() { <line2> if (didBackfill) { <line3> return; <line4> } <line5> if (backfillAttempts > 10) { <line6> return; <line7> } <line8> backfillAttempts++; <line9> boolean updateFailed = false; <line10> NamespaceStore namespaceStore = new DefaultNamespaceStore(this.transactionRunner); <line11> List<String> namespaces = <line12> namespaceStore.list().stream().map(NamespaceMeta::getName).collect(Collectors.toList()); <line13> for (String namespace : namespaces) { <line14> List<ApplicationMeta> apps = <line15> TransactionRunners.run( <line16> this.transactionRunner, <line17> context -> { <line18> AppMetadataStore appMetadataStore = AppMetadataStore.create(context); <line19> return appMetadataStore.getAllApplications(namespace); <line20> }); <line21> try { <line22> this.getPluginCounts(namespace, apps); <line23> } catch (IOException e) { <line24> updateFailed = true; <line25> } <line26> } <line27> if (!updateFailed) { <line28> didBackfill = true; <line29> TransactionRunners.run( <line30> transactionRunner, <line31> (TxRunnable) <line32> context -> <line33> AppMetadataStore.create(context) <line34> .persistSubscriberState( <line35> getTopicId().getTopic(), BACKFILL_SUBSCRIBER_NAME, ""true"")); <line36> } <line37> } <line38> } <line39> "	 <line21>	Yes
"public class A { <line0> private void checkTokenGenerationRequest(final TokenGenerationRequestDTO request) { <line1> final String origin = CommonConstants.AUTHORIZATION_URI + CommonConstants.OP_AUTH_TOKEN_URI; <line2> if (request.getConsumer() == null) { <line3> throw new BadPayloadException(""Consumer system is null"", HttpStatus.SC_BAD_REQUEST, origin); <line4> } <line5> checkSystemRequest(request.getConsumer(), origin, false); <line6> if (request.getConsumerCloud() != null <line7> && Utilities.isEmpty(request.getConsumerCloud().getOperator())) { <line8> throw new BadPayloadException( <line9> ""Consumer cloud's operator is null or blank"", HttpStatus.SC_BAD_REQUEST, origin); <line10> } <line11> if (request.getConsumerCloud() != null <line12> && Utilities.isEmpty(request.getConsumerCloud().getName())) { <line13> throw new BadPayloadException( <line14> ""Consumer cloud's name is null or blank"", HttpStatus.SC_BAD_REQUEST, origin); <line15> } <line16> if (request.getProviders() == null || request.getProviders().isEmpty()) { <line17> throw new BadPayloadException( <line18> ""Provider list is null or empty"", HttpStatus.SC_BAD_REQUEST, origin); <line19> } <line20> for (final TokenGenerationProviderDTO provider : request.getProviders()) { <line21> checkTokenGenerationProviderDTO(provider, origin); <line22> } <line23> if (Utilities.isEmpty(request.getService())) { <line24> throw new BadPayloadException(""Service is null or blank"", HttpStatus.SC_BAD_REQUEST, origin); <line25> } <line26> } <line27> } <line28> "	 <line1>	Yes
public class A { <line0> public void beforeSuite(@Observes BeforeSuite event) { <line1> try { <line2> citrusInstance.get().beforeSuite(configurationInstance.get().getSuiteName()); <line3> } catch (Exception e) { <line4> throw e; <line5> } <line6> } <line7> } <line8> 	 <line0>	No
public class A { <line0> protected String toJSON(Object answer) throws IOException { <line1> try { <line2> StringWriter writer = new StringWriter(); <line3> mapper.writeValue(writer, answer); <line4> return writer.toString(); <line5> } catch (IOException e) { <line6> throw new IOException(e.getMessage()); <line7> } <line8> } <line9> } <line10> 	 <line3>	No
public class A { <line0> public NodeSet search( <line1> final int contextId, <line2> final DocumentSet docs, <line3> final List<QName> qnames, <line4> final String query, <line5> final String ngram, <line6> final XQueryContext context, <line7> final NodeSet contextSet, <line8> final int axis) <line9> throws XPathException { <line10> final List<QName> searchQnames; <line11> if (qnames == null || qnames.isEmpty()) { <line12> searchQnames = getDefinedIndexes(context.getBroker(), docs); <line13> } else { <line14> searchQnames = qnames; <line15> } <line16> final NodeSet result = new ExtArrayNodeSet(docs.getDocumentCount(), 250); <line17> for (final Iterator<Collection> iter = docs.getCollectionIterator(); iter.hasNext(); ) { <line18> final int collectionId = iter.next().getId(); <line19> for (final QName qname : searchQnames) { <line20> final NGramQNameKey key = <line21> new NGramQNameKey(collectionId, qname, index.getBrokerPool().getSymbols(), query); <line22> try (final ManagedLock<ReentrantLock> dbLock = <line23> lockManager.acquireBtreeReadLock(index.db.getLockName())) { <line24> final SearchCallback cb = <line25> new SearchCallback( <line26> contextId, <line27> query, <line28> ngram, <line29> docs, <line30> contextSet, <line31> context, <line32> result, <line33> axis == NodeSet.ANCESTOR); <line34> final int op = <line35> query.codePointCount(0, query.length()) < getN() <line36> ? IndexQuery.TRUNC_RIGHT <line37> : IndexQuery.EQ; <line38> index.db.query(new IndexQuery(op, key), cb); <line39> } catch (final LockException e) { <line40> } catch (final IOException | BTreeException e) { <line41> } <line42> } <line43> } <line44> result.iterate(); <line45> return result; <line46> } <line47> } <line48> 	 <line40>	Yes
"public class A { <line0> @Override <line1> @Secured({ServicesData.ROLE_GET_CUSTOMERS}) <line2> @GetMapping(CommonConstants.PATH_ID) <line3> public CustomerDto getOne(final @PathVariable(""id"") String id) { <line4> ParameterChecker.checkParameter(""Identifier is mandatory : "", id); <line5> return customerExternalService.getOne(id); <line6> } <line7> } <line8> "	 <line0>	No
public class A { <line0> @Override <line1> public boolean isReadOnly() { <line2> return false; <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void removeAllElectronContainers() { <line2> super.removeAllElectronContainers(); <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testFilter() { <line2> String xml = <line3> ""<wfs:GetFeature service=\""WFS\"" version=\""1.1.0\"" outputFormat=\""gml32\"""" <line4> + "" xmlns:ogc=\""http://www.opengis.net/ogc\"" xmlns:wfs=\""http://www.opengis.net/wfs\"""" <line5> + "" xmlns:gml=\""http://www.opengis.net/gml/3.2\"""" <line6> + "" xmlns:wml2dr=\""http://www.opengis.net/waterml/DR/2.0\"""" <line7> + "" xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\"" "" <line8> + ""xsi:schemaLocation=\""http://www.opengis.net/wfs"" <line9> + "" http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\""><wfs:Query"" <line10> + "" typeName=\""wml2dr:MeasurementTimeseriesDomainRange\"">    <ogc:Filter>       "" <line11> + "" <ogc:PropertyIsLike wildCard=\""*\"" singleChar=\""#\"" escapeChar=\""\\\"">           "" <line12> + "" <ogc:PropertyName>wml2dr:MeasurementTimeseriesDomainRange/gml:rangeSet/gml:QuantityList</ogc:PropertyName>"" <line13> + ""            <ogc:Literal>*16.2*</ogc:Literal>        </ogc:PropertyIsLike>   "" <line14> + "" </ogc:Filter></wfs:Query> </wfs:GetFeature>""; <line15> validate(xml); <line16> Document doc = postAsDOM(""wfs"", xml); <line17> assertEquals(""wfs:FeatureCollection"", doc.getDocumentElement().getNodeName()); <line18> assertXpathEvaluatesTo(""1"", ""/wfs:FeatureCollection/@numberReturned"", doc); <line19> assertXpathCount(1, ""//wml2dr:MeasurementTimeseriesDomainRange"", doc); <line20> assertXpathEvaluatesTo(""ID2"", ""//wml2dr:MeasurementTimeseriesDomainRange/@gml:id"", doc); <line21> assertXpathEvaluatesTo( <line22> ""tpl."" + ""ID2"", <line23> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line24> + ""ID2"" <line25> + ""']/gml:domainSet/wml2dr:TimePositionList/@gml:id"", <line26> doc); <line27> assertXpathEvaluatesTo( <line28> ""16.2"", <line29> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line30> + ""ID2"" <line31> + ""']/gml:rangeSet/gml:QuantityList"", <line32> doc); <line33> assertXpathEvaluatesTo( <line34> ""degC"", <line35> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line36> + ""ID2"" <line37> + ""']/gml:rangeSet/gml:QuantityList/@uom"", <line38> doc); <line39> assertXpathEvaluatesTo( <line40> ""string"", <line41> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line42> + ""ID2"" <line43> + ""']/gml:coverageFunction/gml:MappingRule"", <line44> doc); <line45> assertXpathEvaluatesTo( <line46> ""http://ns.bgs.ac.uk/thesaurus/lithostratigraphy"", <line47> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line48> + ""ID2"" <line49> + ""']/gmlcov:rangeType/@xlink:href"", <line50> doc); <line51> assertXpathEvaluatesTo( <line52> ""1949-05-01T00:00:00Z"", <line53> ""//wml2dr:MeasurementTimeseriesDomainRange[@gml:id='"" <line54> + ""ID2"" <line55> + ""']/gml:domainSet/wml2dr:TimePositionList/wml2dr:timePositionList"", <line56> doc); <line57> } <line58> } <line59> "	 <line17>	Yes
public class A { <line0> public Mono<byte[]> decrypt(byte[] input) { <line1> if (LOGGER.isDebugEnabled()) { <line2> } <line3> ObjectNode itemJObj = Utils.parse(input, ObjectNode.class); <line4> assert (itemJObj != null); <line5> return initEncryptionSettingsIfNotInitializedAsync() <line6> .then( <line7> Mono.defer( <line8> () -> { <line9> for (ClientEncryptionIncludedPath includedPath : <line10> this.clientEncryptionPolicy.getIncludedPaths()) { <line11> if (StringUtils.isEmpty(includedPath.getPath()) <line12> || includedPath.getPath().charAt(0) != '/' <line13> || includedPath.getPath().lastIndexOf('/') != 0) { <line14> } <line15> } <line16> List<Mono<Void>> encryptionMonoList = new ArrayList<>(); <line17> for (ClientEncryptionIncludedPath includedPath : <line18> this.clientEncryptionPolicy.getIncludedPaths()) { <line19> String propertyName = includedPath.getPath().substring(1); <line20> JsonNode propertyValueHolder = itemJObj.get(propertyName); <line21> if (propertyValueHolder != null && !propertyValueHolder.isNull()) { <line22> Mono<Void> voidMono = <line23> this.encryptionSettings <line24> .getEncryptionSettingForPropertyAsync(propertyName, this) <line25> .flatMap( <line26> settings -> { <line27> try { <line28> decryptAndSerializeProperty( <line29> settings, itemJObj, propertyValueHolder, propertyName); <line30> } catch (MicrosoftDataEncryptionException <line31> | JsonProcessingException ex) { <line32> } catch (IOException e) { <line33> e.printStackTrace(); <line34> } <line35> return Mono.empty(); <line36> }); <line37> encryptionMonoList.add(voidMono); <line38> } <line39> } <line40> Mono<List<Void>> listMono = <line41> Flux.mergeSequential(encryptionMonoList).collectList(); <line42> return listMono.flatMap( <line43> aVoid -> <line44> Mono.just( <line45> EncryptionUtils.serializeJsonToByteArray( <line46> EncryptionUtils.getSimpleObjectMapper(), itemJObj))); <line47> })); <line48> } <line49> } <line50> 	 <line5>	No
"public class A { <line0> public static <T> List<T> getResults( <line1> String name, List<InternalInstrumented<T>> instrumentedList) { <line2> Objects.requireNonNull(instrumentedList, ""instrumentedList""); <line3> final List<ListenableFuture<T>> listenableFutures = new ArrayList<>(instrumentedList.size()); <line4> for (InternalInstrumented<T> each : instrumentedList) { <line5> listenableFutures.add(each.getStats()); <line6> } <line7> ListenableFuture<List<T>> listListenableFuture = Futures.allAsList(listenableFutures); <line8> try { <line9> return listListenableFuture.get(timeout, TimeUnit.MILLISECONDS); <line10> } catch (InterruptedException e) { <line11> Thread.currentThread().interrupt(); <line12> } catch (ExecutionException e) { <line13> } catch (TimeoutException e) { <line14> } <line15> return null; <line16> } <line17> } <line18> "	 <line13>	Yes
"public class A { <line0> public InputStream getReport(int reportId) { <line1> String baseUrl = restConfig.getBaseUrlWithSlash(); <line2> String token = restConfig.getAccessToken(); <line3> if (StringUtils.isEmpty(baseUrl) || StringUtils.isEmpty(token)) { <line4> return null; <line5> } <line6> if (reportId < 0) { <line7> return null; <line8> } <line9> HttpHeaders headers = new HttpHeaders(); <line10> headers.set(""Authorization"", ""Bearer "" + token); <line11> try { <line12> ResponseEntity<Resource> responseEntity = <line13> restTemplate.exchange( <line14> baseUrl + ""report/"" + reportId, <line15> HttpMethod.GET, <line16> new HttpEntity<>(headers), <line17> Resource.class); <line18> return responseEntity.getBody().getInputStream(); <line19> } catch (RestClientException | IOException e) { <line20> return null; <line21> } <line22> } <line23> } <line24> "	 <line21>	No
public class A { <line0> private static void CreateCFSet() { <line1> try { <line2> InputStream fin = VocabDefinitions.class.getClassLoader().getResourceAsStream(CF_PARAMETERS); <line3> InputStreamReader freader = new InputStreamReader(fin); <line4> cfSet = new HashSet<String>(); <line5> StringBuilder builder = new StringBuilder(); <line6> char[] buffer = new char[1]; <line7> while (freader.read(buffer) > 0) { <line8> if (buffer[0] == ';') { <line9> cfSet.add(builder.toString()); <line10> builder.setLength(0); <line11> } else { <line12> builder.append(buffer[0]); <line13> } <line14> } <line15> } catch (Exception ex) { <line16> } <line17> } <line18> } <line19> 	 <line1>	No
public class A { <line0> private void getServerProfileCompliancePreview() { <line1> ServerProfile serverProfile = this.serverProfileClient.getByName(SERVER_PROFILE_NAME).get(0); <line2> ServerProfileCompliancePreview compliance = <line3> serverProfileClient.getCompliancePreview(serverProfile.getResourceId()); <line4> } <line5> } <line6> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> List<Map<String, String>> routeStats = getRoutes(integration, ""[a-zA-z0-9_-]+""); <line4> routeStats.forEach( <line5> m -> { <line6> long messages = toLong(m.getOrDefault(EXCHANGES_TOTAL, ""0"")); <line7> long errors = toLong(m.getOrDefault(EXCHANGES_FAILED, ""0"")); <line8> Instant lastCompleted = toInstant(m.get(LAST_COMPLETED_TIMESTAMP)); <line9> Instant lastFailed = toInstant(m.get(LAST_FAILED_TIMESTAMP)); <line10> Instant lastMessage = <line11> (lastCompleted == null && lastFailed != null) <line12> || (lastCompleted != null <line13> && lastFailed != null <line14> && lastFailed.isAfter(lastCompleted)) <line15> ? lastFailed <line16> : lastCompleted; <line17> Instant resetDate = toInstant(m.get(RESET_TIMESTAMP)); <line18> Instant startDate = toInstant(m.get(START_TIMESTAMP)); <line19> handler.persist( <line20> new RawMetrics.Builder() <line21> .pod(pod) <line22> .integrationId(integrationId) <line23> .version(version) <line24> .messages(messages) <line25> .errors(errors) <line26> .startDate(startDate) <line27> .lastProcessed(Optional.ofNullable(lastMessage)) <line28> .resetDate(resetDate) <line29> .build()); <line30> }); <line31> } catch (MalformedObjectNameException | J4pException e) { <line32> } <line33> } <line34> } <line35> "	 <line32>	Yes
public class A { <line0> private ScheduledReporter createAndGetConfiguredCSVReporter(String prefix, String csvDir) <line1> throws IOException { <line2> File outputDir; <line3> if (Strings.isNullOrEmpty(prefix)) { <line4> outputDir = new File(csvDir, prefix); <line5> } else { <line6> outputDir = new File(csvDir); <line7> } <line8> FileUtils.forceMkdir(outputDir); <line9> return CsvReporter.forRegistry(metrics) <line10> .convertRatesTo(TimeUnit.SECONDS) <line11> .convertDurationsTo(TimeUnit.MILLISECONDS) <line12> .build(outputDir); <line13> } <line14> } <line15> 	 <line9>	Yes
"public class A { <line0> public static com.liferay.commerce.price.list.model.CommerceTierPriceEntry <line1> getCommerceTierPriceEntry(HttpPrincipal httpPrincipal, long commerceTierPriceEntryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> CommerceTierPriceEntryServiceUtil.class, <line7> ""getCommerceTierPriceEntry"", <line8> _getCommerceTierPriceEntryParameterTypes11); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, commerceTierPriceEntryId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.commerce.price.list.model.CommerceTierPriceEntry) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	 <line21>	Yes
"public class A { <line0> public String getKeystorePassword() { <line1> String keycloakPodName = <line2> kubeClient().listPodsByPrefixInName(""keycloak-"").get(0).getMetadata().getName(); <line3> String inputFile = <line4> ResourceManager.cmdKubeClient() <line5> .execInPod( <line6> keycloakPodName, <line7> ""cat"", <line8> ""/opt/jboss/keycloak/standalone/configuration/standalone-ha.xml"") <line9> .out() <line10> .trim(); <line11> Matcher keystoreMatcher = keystorePattern.matcher(inputFile); <line12> String keystorePassword = null; <line13> if (keystoreMatcher.find()) { <line14> String result = keystoreMatcher.group(0); <line15> String[] shards = result.split(""\n""); <line16> Matcher keystorePasswordMatcher = keystorePasswordPattern.matcher(shards[3]); <line17> if (keystorePasswordMatcher.find()) { <line18> keystorePassword = keystorePasswordMatcher.group(0); <line19> keystorePassword = keystorePassword.substring(1, keystorePassword.length() - 1); <line20> } <line21> } <line22> return keystorePassword; <line23> } <line24> } <line25> "	 <line4>	No
public class A { <line0> protected void optimizeFile() { <line1> final ElapsedTimer timer = new ElapsedTimer(); <line2> timesOptimized++; <line3> IndexedDiskElementDescriptor[] defragList = null; <line4> storageLock.writeLock().lock(); <line5> try { <line6> queueInput = true; <line7> doRecycle = false; <line8> defragList = createPositionSortedDescriptorList(); <line9> } finally { <line10> storageLock.writeLock().unlock(); <line11> } <line12> long expectedNextPos = defragFile(defragList, 0); <line13> storageLock.writeLock().lock(); <line14> try { <line15> try { <line16> if (!queuedPutList.isEmpty()) { <line17> defragList = <line18> queuedPutList.toArray(new IndexedDiskElementDescriptor[queuedPutList.size()]); <line19> expectedNextPos = defragFile(defragList, expectedNextPos); <line20> } <line21> dataFile.truncate(expectedNextPos); <line22> } catch (final IOException e) { <line23> } <line24> removeCount = 0; <line25> resetBytesFree(); <line26> this.recycle.clear(); <line27> queuedPutList.clear(); <line28> queueInput = false; <line29> doRecycle = true; <line30> isOptimizing = false; <line31> } finally { <line32> storageLock.writeLock().unlock(); <line33> } <line34> } <line35> } <line36> 	 <line3>	Yes
public class A { <line0> @Test <line1> @InRequestScope <line2> public void testExecuteToGetAll() throws Exception { <line3> GetTransUnitList action = GetTransUnitList.newAction(new GetTransUnitActionContext(document)); <line4> prepareActionAndMockLocaleService(action); <line5> long startTime = System.nanoTime(); <line6> GetTransUnitListResult result = handler.execute(action, null); <line7> assertThat(result.getDocumentId()).isEqualTo(document.getId()); <line8> assertThat(result.getGotoRow()).isEqualTo(0); <line9> assertThat(getIntIds(result.getUnits())).contains(1, 2, 3, 4, 5); <line10> } <line11> } <line12> 	 <line7>	Yes
"public class A { <line0> public TableState updateTableStateCache(TableId tableId) { <line1> synchronized (tableStateCache) { <line2> TableState tState = TableState.UNKNOWN; <line3> byte[] data = <line4> zooStateCache.get(zkRoot + Constants.ZTABLES + ""/"" + tableId + Constants.ZTABLE_STATE); <line5> if (data != null) { <line6> String sState = new String(data, UTF_8); <line7> try { <line8> tState = TableState.valueOf(sState); <line9> } catch (IllegalArgumentException e) { <line10> } <line11> tableStateCache.put(tableId, tState); <line12> } <line13> return tState; <line14> } <line15> } <line16> } <line17> "	 <line10>	Yes
"public class A { <line0> @Test <line1> public void testDistinctCountGroupByQuery() throws Exception { <line2> String query; <line3> String[] testColumns = new String[] {""AirTime"", ""ArrDelayMinutes"", ""ArrTimeBlk""}; <line4> boolean hasWhere = true; <line5> for (String column : testColumns) { <line6> for (int i = 0; i < 2; i++) { <line7> query = ""select Carrier, distinctcount("" + column + "") from 'mytable'""; <line8> if (hasWhere) { <line9> query += "" where DaysSinceEpoch >= 16312""; <line10> } <line11> query += "" group by Carrier""; <line12> super.runQuery( <line13> query, <line14> Collections.singletonList( <line15> query <line16> .replace(""'mytable'"", ""mytable"") <line17> .replace(""distinctcount("", ""count(distinct ""))); <line18> hasWhere = !hasWhere; <line19> } <line20> } <line21> } <line22> } <line23> "	 <line2>	No
public class A { <line0> @Override <line1> public void downPhysicalInterface(LogicalPort iface) throws CapabilityException { <line2> iface.setOperationalStatus(OperationalStatus.STOPPED); <line3> IAction action = createActionAndCheckParams(ChassisActionSet.CONFIGURESTATUS, iface); <line4> queueAction(action); <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> private void rejectPermission(int personId) { <line1> Person user = personDao.read(personId); <line2> user.setAuthority(""ROLE_READER""); <line3> personDao.update(user); <line4> String email = user.getEmail(); <line5> sendEmail(email, false); <line6> } <line7> } <line8> "	 <line3>	Yes
public class A { <line0> public static com.liferay.segments.model.SegmentsExperimentRelSoap updateSegmentsExperimentRel( <line1> long segmentsExperimentRelId, double split) throws RemoteException { <line2> try { <line3> com.liferay.segments.model.SegmentsExperimentRel returnValue = <line4> SegmentsExperimentRelServiceUtil.updateSegmentsExperimentRel( <line5> segmentsExperimentRelId, split); <line6> return com.liferay.segments.model.SegmentsExperimentRelSoap.toSoapModel(returnValue); <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	 <line4>	No
public class A { <line0> private String cloneVMforVvols( <line1> VmwareContext context, <line2> VmwareHypervisorHost hyperHost, <line3> TemplateObjectTO template, <line4> VirtualMachineMO vmTemplate, <line5> VolumeObjectTO volume, <line6> DatacenterMO dcMo, <line7> DatastoreMO dsMo) <line8> throws Exception { <line9> ManagedObjectReference morDatastore = dsMo.getMor(); <line10> ManagedObjectReference morPool = hyperHost.getHyperHostOwnerResourcePool(); <line11> ManagedObjectReference morCluster = hyperHost.getHyperHostCluster(); <line12> if (template.getSize() != null) { <line13> _fullCloneFlag = volume.getSize() > template.getSize() ? true : _fullCloneFlag; <line14> } <line15> String vmName = volume.getVmName(); <line16> if (volume.getVolumeType() == Volume.Type.DATADISK) vmName = volume.getName(); <line17> if (!_fullCloneFlag) { <line18> createVMLinkedClone(vmTemplate, dcMo, vmName, morDatastore, morPool); <line19> } else { <line20> createVMFullClone(vmTemplate, dcMo, dsMo, vmName, morDatastore, morPool); <line21> } <line22> VirtualMachineMO vmMo = new ClusterMO(context, morCluster).findVmOnHyperHost(vmName); <line23> assert (vmMo != null); <line24> String vmdkFileBaseName = vmMo.getVmdkFileBaseNames().get(0); <line25> if (volume.getVolumeType() == Volume.Type.DATADISK) { <line26> vmMo.detachAllDisks(); <line27> vmMo.destroy(); <line28> } <line29> return vmdkFileBaseName; <line30> } <line31> } <line32> 	 <line26>	Yes
public class A { <line0> @Override <line1> public boolean cancel(boolean mayInterruptIfRunning) { <line2> cancel = true; <line3> if (this.isDone() || this.isCompletedExceptionally()) { <line4> return false; <line5> } <line6> while (thread == null) { <line7> try { <line8> Thread.sleep(1000); <line9> } catch (InterruptedException e) { <line10> Thread.currentThread().interrupt(); <line11> return false; <line12> } <line13> } <line14> thread.interrupt(); <line15> return true; <line16> } <line17> } <line18> 	 <line7>	No
"public class A { <line0> @Override <line1> public boolean givesPermissionInternal(Registration registration, Set<Integer> considered) { <line2> if (registration.isLIMSAdmin()) { <line3> return true; <line4> } <line5> boolean consideredBefore = considered.contains(this.getSwAccession()); <line6> if (!consideredBefore) { <line7> considered.add(this.getSwAccession()); <line8> } else { <line9> return true; <line10> } <line11> boolean hasPermission; <line12> if (study != null) { <line13> StudyService ss = BeanFactory.getStudyServiceBean(); <line14> Study newStudy = ss.findBySWAccession(study.getSwAccession()); <line15> hasPermission = newStudy.givesPermission(registration, considered); <line16> } else { <line17> if (registration.equals(this.owner) || registration.isLIMSAdmin()) { <line18> hasPermission = true; <line19> } else if (owner == null) { <line20> hasPermission = true; <line21> } else { <line22> hasPermission = false; <line23> } <line24> } <line25> if (!hasPermission) { <line26> throw new SecurityException( <line27> ""User "" <line28> + registration.getEmailAddress() <line29> + "" does not have permission to modify "" <line30> + this.getName()); <line31> } <line32> return hasPermission; <line33> } <line34> } <line35> "	 <line26>	Yes
"public class A { <line0> public static void unregisterSyncDevice(HttpPrincipal httpPrincipal, String uuid) <line1> throws com.liferay.portal.kernel.exception.PortalException { <line2> try { <line3> MethodKey methodKey = <line4> new MethodKey( <line5> SyncDeviceServiceUtil.class, <line6> ""unregisterSyncDevice"", <line7> _unregisterSyncDeviceParameterTypes1); <line8> MethodHandler methodHandler = new MethodHandler(methodKey, uuid); <line9> try { <line10> TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line18> throw systemException; <line19> } <line20> } <line21> } <line22> "	 <line2>	No
public class A { <line0> public CompletableFuture<Void> verify(final TestContext context) { <line1> Preconditions.checkNotNull(context.getServiceTemplate()); <line2> Preconditions.checkNotNull(context.getServiceTemplateInstance()); <line3> return CompletableFuture.supplyAsync( <line4> () -> { <line5> final List<CompletableFuture<DeploymentTestResult>> futures = Lists.newArrayList(); <line6> for (final NodeTemplateInstance nodeTemplateInstance : <line7> context.getNodeTemplateInstances()) { <line8> for (final TestExecutionPlugin plugin : this.plugins) { <line9> final TNodeTemplate nodeTemplate = context.getNodeTemplate(nodeTemplateInstance); <line10> final Csar csar = context.getCsar(); <line11> final List<TPolicyTemplate> policyTemplates = <line12> Optional.ofNullable(nodeTemplate.getPolicies()) <line13> .map(ps -> ps.getPolicy()) <line14> .orElse(Collections.emptyList()) <line15> .stream() <line16> .filter(Objects::nonNull) <line17> .map( <line18> p -> <line19> (TPolicyTemplate) <line20> csar.queryRepository(new PolicyTemplateId(p.getPolicyRef()))) <line21> .collect(Collectors.toList()); <line22> for (final TPolicyTemplate policyTemplate : policyTemplates) { <line23> if (plugin.canExecute(nodeTemplate, policyTemplate)) { <line24> futures.add( <line25> submit(plugin, context, nodeTemplate, nodeTemplateInstance, policyTemplate)); <line26> } <line27> } <line28> } <line29> } <line30> final List<DeploymentTestResult> results = <line31> futures.stream().map(CompletableFuture::join).collect(Collectors.toList()); <line32> context.setDeploymentTestResults(results); <line33> return null; <line34> }, <line35> this.testExecutor); <line36> } <line37> } <line38> 	 <line33>	Yes
"public class A { <line0> @Override <line1> public EntityChangedMessage update(PostgresPersistenceManager<J> pm, ObservedProperty op, J opId) <line2> throws NoSuchEntityException, IncompleteEntityException { <line3> Map<Field, Object> update = new HashMap<>(); <line4> EntityChangedMessage message = new EntityChangedMessage(); <line5> if (op.isSetDefinition()) { <line6> if (op.getDefinition() == null) { <line7> throw new IncompleteEntityException(""definition"" + CAN_NOT_BE_NULL); <line8> } <line9> update.put(table.colDefinition, op.getDefinition()); <line10> message.addField(EntityPropertyMain.DEFINITION); <line11> } <line12> if (op.isSetDescription()) { <line13> if (op.getDescription() == null) { <line14> throw new IncompleteEntityException( <line15> EntityPropertyMain.DESCRIPTION.jsonName + CAN_NOT_BE_NULL); <line16> } <line17> update.put(table.colDescription, op.getDescription()); <line18> message.addField(EntityPropertyMain.DESCRIPTION); <line19> } <line20> if (op.isSetName()) { <line21> if (op.getName() == null) { <line22> throw new IncompleteEntityException(""name"" + CAN_NOT_BE_NULL); <line23> } <line24> update.put(table.colName, op.getName()); <line25> message.addField(EntityPropertyMain.NAME); <line26> } <line27> if (op.isSetProperties()) { <line28> update.put(table.colProperties, new JsonValue(op.getProperties())); <line29> message.addField(EntityPropertyMain.PROPERTIES); <line30> } <line31> DSLContext dslContext = pm.getDslContext(); <line32> long count = 0; <line33> if (!update.isEmpty()) { <line34> count = dslContext.update(table).set(update).where(table.getId().equal(opId)).execute(); <line35> } <line36> if (count > 1) { <line37> throw new IllegalStateException(CHANGED_MULTIPLE_ROWS); <line38> } <line39> linkDatastreams(op, pm, dslContext, opId); <line40> if (!op.getMultiDatastreams().isEmpty()) { <line41> throw new IllegalArgumentException(""Can not add MultiDatastreams to an ObservedProperty.""); <line42> } <line43> return message; <line44> } <line45> } <line46> "	 <line43>	Yes
"public class A { <line0> @Test <line1> public void h_getObservationTest() { <line2> g_logObservationsTest(); <line3> GetObservations getObservationRequest = <line4> GetObservations.newBuilder() <line5> .setId(experimentRun.getId()) <line6> .setObservationKey(""Google developer Observation artifact"") <line7> .build(); <line8> GetObservations.Response response = <line9> experimentRunServiceStub.getObservations(getObservationRequest); <line10> for (Observation observation : response.getObservationsList()) { <line11> if (observation.hasAttribute()) { <line12> assertEquals( <line13> ""ExperimentRun observations not match with expected observations "", <line14> ""Google developer Observation artifact"", <line15> observation.getAttribute().getKey()); <line16> } else if (observation.hasArtifact()) { <line17> assertEquals( <line18> ""ExperimentRun observations not match with expected observations "", <line19> ""Google developer Observation artifact"", <line20> observation.getArtifact().getKey()); <line21> } <line22> } <line23> } <line24> } <line25> "	 <line11>	No
"public class A { <line0> @Override <line1> public Object invoke(Object... args) throws ReflectiveOperationException { <line2> if (!isController()) { <line3> return super.invoke(args); <line4> } <line5> Csrf.CsrfOptions csrfOptions = Csrf.CsrfOptions.EXPLICIT; <line6> Object csrfProtection = _configuration.getProperty(Csrf.CSRF_PROTECTION); <line7> if (csrfProtection != null) { <line8> if (csrfProtection instanceof Csrf.CsrfOptions) { <line9> csrfOptions = (Csrf.CsrfOptions) csrfProtection; <line10> } else { <line11> try { <line12> csrfOptions = Csrf.CsrfOptions.valueOf(csrfProtection.toString()); <line13> } catch (IllegalArgumentException illegalArgumentException) { <line14> } <line15> } <line16> } <line17> if (csrfOptions == Csrf.CsrfOptions.OFF) { <line18> return super.invoke(args); <line19> } <line20> if ((csrfOptions == Csrf.CsrfOptions.EXPLICIT) <line21> && !_method.isAnnotationPresent(CsrfProtected.class)) { <line22> return super.invoke(args); <line23> } <line24> boolean proceed = false; <line25> if (args.length == 2) { <line26> if (args[0] instanceof ClientDataRequest) { <line27> ClientDataRequest clientDataRequest = (ClientDataRequest) args[0]; <line28> String method = StringUtil.toLowerCase(clientDataRequest.getMethod()); <line29> if (method.equals(""post"")) { <line30> ThemeDisplay themeDisplay = <line31> (ThemeDisplay) clientDataRequest.getAttribute(WebKeys.THEME_DISPLAY); <line32> try { <line33> AuthTokenUtil.checkCSRFToken( <line34> themeDisplay.getRequest(), CsrfValidationInterceptor.class.getName()); <line35> proceed = true; <line36> } catch (PrincipalException principalException) { <line37> } <line38> } else { <line39> proceed = true; <line40> } <line41> } else { <line42> } <line43> } else { <line44> } <line45> if (proceed) { <line46> return super.invoke(args); <line47> } <line48> return null; <line49> } <line50> } <line51> "	 <line37>	Yes
"public class A { <line0> @Override <line1> protected void onSubmit(AjaxRequestTarget target, Form<?> form) { <line2> if (createMode) { <line3> Class<?> permissionClass = permissionTypeModel.getObject(); <line4> user.getPermissions().add(new PermissionInput(permissionClass, values, State.NEW)); <line5> } else { <line6> permissionInput.setState(State.UPDATED); <line7> } <line8> editorPanel.replaceWith(new EmptyPanel(""permissionEditor"")); <line9> submitButton.setVisible(false); <line10> target.add(container); <line11> afterSubmit(target, form); <line12> } <line13> } <line14> "	 <line9>	No
public class A { <line0> @Override <line1> public Void repeat(final SessionPool pool, final PasswordCallback callback) { <line2> scheduler.repeat( <line3> () -> { <line4> try { <line5> final Session<Client> session = pool.borrow(BackgroundActionState.running); <line6> try { <line7> this.operate(session, callback, null); <line8> } finally { <line9> pool.release(session, null); <line10> } <line11> } catch (ConnectionCanceledException e) { <line12> this.shutdown(); <line13> } catch (BackgroundException e) { <line14> } catch (Exception e) { <line15> this.shutdown(); <line16> } <line17> }, <line18> period, <line19> TimeUnit.MILLISECONDS); <line20> return null; <line21> } <line22> } <line23> 	 <line15>	Yes
public class A { <line0> public CompletableFuture<byte[]> readCharacteristic(UUID serviceUUID, UUID characteristicUUID) { <line1> var future = executeWithConnection(serviceUUID, characteristicUUID, device::readCharacteristic); <line2> if (logger.isDebugEnabled()) { <line3> future = <line4> future.whenComplete( <line5> (data, t) -> { <line6> if (t == null) { <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> }); <line11> } <line12> return future; <line13> } <line14> } <line15> 	 <line7>	No
"public class A { <line0> @BeforeClass <line1> public static void createFsCrawlerJobDir() throws IOException { <line2> metadataDir = rootTmpDir.resolve("".fscrawler""); <line3> if (Files.notExists(metadataDir)) { <line4> Files.createDirectory(metadataDir); <line5> } <line6> copyDefaultResources(metadataDir); <line7> } <line8> } <line9> "	 <line0>	No
public class A { <line0> public TaskDefinition getTask(Integer taskId) throws DAOException { <line1> TaskDefinition task = <line2> (TaskDefinition) sessionFactory.getCurrentSession().get(TaskDefinition.class, taskId); <line3> if (task == null) { <line4> throw new ObjectRetrievalFailureException(TaskDefinition.class, taskId); <line5> } <line6> return task; <line7> } <line8> } <line9> 	 <line7>	No
"public class A { <line0> private void retryWorkflowWithCompletedTask() { <line1> JsonParser parser = new JsonParser(); <line2> List<InsightsWorkflowExecutionHistory> readyToRunWorkflowHistory = <line3> workflowProcessing.getNextTasksForRetry(); <line4> for (InsightsWorkflowExecutionHistory lastCompletedTaskExecution : readyToRunWorkflowHistory) { <line5> JsonObject mqRetryJsonObject = <line6> parser.parse(lastCompletedTaskExecution.getRequestMessage()).getAsJsonObject(); <line7> mqRetryJsonObject.addProperty(""exectionHistoryId"", lastCompletedTaskExecution.getId()); <line8> String message = new Gson().toJson(mqRetryJsonObject); <line9> Map<String, Object> requestMessage = WorkflowUtils.convertJsonObjectToMap(message); <line10> try { <line11> workflowProcessing.publishMessageToNextInMQ(requestMessage); <line12> } catch (WorkflowTaskInitializationException e) { <line13> InsightsStatusProvider.getInstance() <line14> .createInsightStatusNode( <line15> ""In WorkflowRetryExecutor,retryWorkflowWithCompletedTask failed due to exception."" <line16> + "" Last completed execution: "" <line17> + lastCompletedTaskExecution, <line18> PlatformServiceConstants.FAILURE); <line19> } <line20> } <line21> } <line22> } <line23> "	 <line10>	Yes
"public class A { <line0> @Test <line1> @SuppressWarnings(""SleepWhileInLoop"") <line2> public void testMetricPropagation() throws Exception { <line3> dag.getAttributes().put(LogicalPlan.STREAMING_WINDOW_SIZE_MILLIS, 300); <line4> dag.getAttributes().put(LogicalPlan.CONTAINERS_MAX_COUNT, 1); <line5> TestOperator testOper = dag.addOperator(""TestOperator"", TestOperator.class); <line6> TestStatsListener sl = new TestStatsListener(); <line7> dag.setOperatorAttribute( <line8> testOper, OperatorContext.STATS_LISTENERS, Lists.newArrayList((StatsListener) sl)); <line9> GenericTestOperator collector = dag.addOperator(""Collector"", new GenericTestOperator()); <line10> dag.addStream(""TestTuples"", testOper.outport, collector.inport1) <line11> .setLocality(Locality.CONTAINER_LOCAL); <line12> StramLocalCluster lc = new StramLocalCluster(dag); <line13> lc.runAsync(); <line14> long startTms = System.currentTimeMillis(); <line15> while (TestOperator.lastMetric == null <line16> && StramTestSupport.DEFAULT_TIMEOUT_MILLIS > System.currentTimeMillis() - startTms) { <line17> Thread.sleep(300); <line18> } <line19> while (StramTestSupport.DEFAULT_TIMEOUT_MILLIS > System.currentTimeMillis() - startTms) { <line20> if (sl.lastPropVal) { <line21> break; <line22> } <line23> Thread.sleep(100); <line24> } <line25> lc.shutdown(); <line26> Assert.assertNotNull(""metric received"", TestOperator.lastMetric); <line27> Assert.assertEquals(""metric message"", ""interesting"", TestOperator.lastMetric.message); <line28> Assert.assertTrue( <line29> ""attribute defined stats listener called"", TestOperator.lastMetric.attributeListenerCalled); <line30> Assert.assertSame( <line31> ""single thread"", TestOperator.definePartitionsThread, TestOperator.processStatsThread); <line32> Assert.assertTrue(""property set"", sl.lastPropVal); <line33> } <line34> } <line35> "	 <line13>	No
public class A { <line0> private void scheduleIdleChecks( <line1> Duration idleCheckInterval, ScheduledExecutorService idleCheckExecutor) { <line2> idleCheckExecutor.scheduleWithFixedDelay( <line3> () -> { <line4> try { <line5> cleanUpExpiredTransactions(); <line6> } catch (Throwable t) { <line7> } <line8> }, <line9> idleCheckInterval.toMillis(), <line10> idleCheckInterval.toMillis(), <line11> MILLISECONDS); <line12> } <line13> } <line14> 	 <line7>	Yes
public class A { <line0> public void releaseBrokenClient(Client client) { <line1> try { <line2> clientPool.invalidateObject(client); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	 <line3>	No
"public class A { <line0> @Override <line1> public DepotAppCustomization findByD_E(long depotEntryId, boolean enabled) <line2> throws NoSuchAppCustomizationException { <line3> DepotAppCustomization depotAppCustomization = fetchByD_E(depotEntryId, enabled); <line4> if (depotAppCustomization == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""depotEntryId=""); <line8> sb.append(depotEntryId); <line9> sb.append("", enabled=""); <line10> sb.append(enabled); <line11> sb.append(""}""); <line12> if (_log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchAppCustomizationException(sb.toString()); <line15> } <line16> return depotAppCustomization; <line17> } <line18> } <line19> "	 <line5>	No
public class A { <line0> @Override <line1> public void runAtDriver(RuntimeContainer container) { <line2> if (container != null) { <line3> DatabaseClient containerClient = <line4> (DatabaseClient) <line5> container.getComponentData( <line6> properties.getReferencedComponentId(), MarkLogicConnection.CONNECTION); <line7> if (containerClient != null) { <line8> containerClient.release(); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line9>	Yes
public class A { <line0> private void checkContext() { <line1> Collection<String> expectedContextEntries = code.getExpectedContextEntries(); <line2> if (expectedContextEntries == null) { <line3> } else { <line4> List<String> missingEntries = new ArrayList<>(); <line5> for (String expectedEntry : expectedContextEntries) { <line6> if (!context.contains(expectedEntry)) { <line7> missingEntries.add(expectedEntry); <line8> } <line9> } <line10> if (missingEntries.size() > 0) { <line11> } <line12> } <line13> } <line14> } <line15> 	 <line12>	No
"public class A { <line0> @Override <line1> public String createEntityExtractUrl( <line2> DataStore store, String installPath, Storage.ImageFormat format, DataObject dataObject) { <line3> EndPoint ep = _epSelector.select(store); <line4> if (ep == null) { <line5> String errMsg = ""No remote endpoint to send command, check if host or ssvm is down?""; <line6> return null; <line7> } <line8> String path = installPath; <line9> String uuid = UUID.randomUUID().toString() + ""."" + format.getFileExtension(); <line10> return generateCopyUrl(ep.getPublicAddr(), uuid); <line11> } <line12> } <line13> "	 <line0>	No
public class A { <line0> private void installSnapshotUsers(IAuthorizer authorizer, MetaSimpleSnapshot snapshot) { <line1> try { <line2> authorizer.replaceAllUsers(snapshot.getUserMap()); <line3> } catch (AuthException e) { <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
"public class A { <line0> public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) <line1> throws IOException, ServletException { <line2> if (ignore || (request.getCharacterEncoding() == null)) { <line3> String encoding = this.encoding; <line4> if (encoding != null) { <line5> request.setCharacterEncoding(encoding); <line6> response.setContentType(""text/html;charset="" + encoding); <line7> if (logger.isDebugEnabled()) { <line8> } <line9> } <line10> } <line11> chain.doFilter(request, response); <line12> } <line13> } <line14> "	 <line8>	Yes
"public class A { <line0> private boolean parseFile(Map<String, Map<String, Map<String, String>>> bulkMap) { <line1> String filepath = (String) options.valueOf(""file""); <line2> File file = new File(filepath); <line3> try { <line4> try (BufferedReader freader = new BufferedReader(new FileReader(file))) { <line5> String line = null; <line6> while ((line = freader.readLine()) != null) { <line7> String[] args = line.split("",""); <line8> if (!checkArgs(args)) return false; <line9> Map<String, Map<String, String>> types = bulkMap.get(args[0]); <line10> if (types == null) { <line11> types = new HashMap<>(); <line12> bulkMap.put(args[0], types); <line13> } <line14> Map<String, String> ids = types.get(args[1]); <line15> if (ids == null) { <line16> ids = new LinkedHashMap<>(); <line17> types.put(args[1], ids); <line18> } <line19> ids.put(args[2], args[3]); <line20> } <line21> } <line22> } catch (FileNotFoundException e) { <line23> return false; <line24> } catch (IOException ex) { <line25> return false; <line26> } <line27> return true; <line28> } <line29> } <line30> "	 <line25>	Yes
public class A { <line0> @Test(timeOut = 10_000) <line1> public void testZkClientLosingSession() throws Exception { <line2> long sessionId = zkClient.getZookeeperClient().getZooKeeper().getSessionId(); <line3> byte[] sessionPasswd = zkClient.getZookeeperClient().getZooKeeper().getSessionPasswd(); <line4> ZooKeeper zk = new ZooKeeper(ZK_CLUSTER, 1000, null, sessionId, sessionPasswd); <line5> zk.close(); <line6> long previousMaxTimestamp = INITIAL_MAX_TS_VALUE; <line7> for (int i = 0; i < ITERATION_COUNT; i++) { <line8> long newMaxTimestamp = previousMaxTimestamp + 1_000_000; <line9> storage.updateMaxTimestamp(previousMaxTimestamp, newMaxTimestamp); <line10> previousMaxTimestamp = newMaxTimestamp; <line11> } <line12> assertEquals(storage.getMaxTimestamp(), 1_000_000 * ITERATION_COUNT); <line13> } <line14> } <line15> 	 <line8>	No
"public class A { <line0> @Override <line1> public List<Pipeline> createAllPossiblePipelines() { <line2> @SuppressWarnings(""unused"") <line3> List<Module> modules = moduleDAO.getModules(); <line4> return null; <line5> } <line6> } <line7> "	 <line2>	Yes
public class A { <line0> @Override <line1> protected void newAssignmentClickPerformed( <line2> AjaxRequestTarget target, AssignmentObjectRelation assignmentTargetRelation) { <line3> PrismContainerValue<AssignmentType> newAssignment = getModelObject().getItem().createNewValue(); <line4> AssignmentType assignmentType = newAssignment.asContainerable(); <line5> try { <line6> newAssignment.findOrCreateContainer(AssignmentType.F_POLICY_RULE); <line7> assignmentType.setPolicyRule(new PolicyRuleType()); <line8> } catch (SchemaException e) { <line9> target.add(getPageBase().getFeedbackPanel()); <line10> return; <line11> } <line12> PrismContainerValueWrapper<AssignmentType> newAssignmentWrapper = <line13> getMultivalueContainerListPanel() <line14> .createNewItemContainerValueWrapper(newAssignment, getModelObject(), target); <line15> getMultivalueContainerListPanel() <line16> .itemDetailsPerformed(target, Collections.singletonList(newAssignmentWrapper)); <line17> } <line18> } <line19> 	 <line9>	Yes
"public class A { <line0> public void editDomain(ActionEvent event) { <line1> UpdateDomain updateDomain = new UpdateDomain(); <line2> updateDomain.setDomain(selectedDomain); <line3> try { <line4> directService.updateDomain(updateDomain); <line5> selectedDomain = null; <line6> refreshDomains(); <line7> } catch (DomainException domainException) { <line8> FacesContext.getCurrentInstance().validationFailed(); <line9> FacesContext.getCurrentInstance() <line10> .addMessage( <line11> ""domainEditErrors"", <line12> new FacesMessage( <line13> FacesMessage.SEVERITY_ERROR, <line14> ""Cannot update domain: "" + domainException.getLocalizedMessage(), <line15> """")); <line16> } <line17> } <line18> } <line19> "	 <line18>	No
public class A { <line0> public void updateConfigGroup(String clusterName, String groupId, ApiConfigGroup configGroup) <line1> throws AmbariApiException { <line2> String confGroup = ApiUtils.objectToJson(configGroup); <line3> Response response = null; <line4> try { <line5> response = <line6> apiResourceRootV1 <line7> .getClustersResource() <line8> .getConfigGroupsResource(clusterName) <line9> .updateConfigGroup(groupId, confGroup); <line10> } catch (Exception e) { <line11> throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e); <line12> } <line13> handleAmbariResponse(response); <line14> } <line15> } <line16> 	 <line2>	No
"public class A { <line0> @RestAccessControl(permission = Permission.MANAGE_USERS) <line1> @RequestMapping( <line2> value = ""/{target:.+}"", <line3> method = RequestMethod.DELETE, <line4> produces = MediaType.APPLICATION_JSON_VALUE) <line5> public ResponseEntity<SimpleRestResponse<Map>> deleteUser( <line6> @ModelAttribute(""user"") UserDetails user, <line7> @PathVariable String target, <line8> BindingResult bindingResult) <line9> throws ApsSystemException { <line10> if (isAdminUser(target)) { <line11> throw new ValidationGenericException(createDeleteAdminError()); <line12> } <line13> if (isUserDeletingHimself(target, user.getUsername())) { <line14> throw new ValidationGenericException(createSelfDeleteUserError(bindingResult)); <line15> } <line16> this.getUserService().removeUser(target); <line17> Map<String, String> result = new HashMap<>(); <line18> result.put(""code"", target); <line19> return new ResponseEntity<>(new SimpleRestResponse<>(result), HttpStatus.OK); <line20> } <line21> } <line22> "	 <line13>	No
public class A { <line0> @Override <line1> public String returnAvatarStream() { <line2> AvatarConfig config = this.getAvatarManager().getConfig(); <line3> String stype = config.getStyle(); <line4> if (null == stype || AvatarConfig.STYLE_DEFAULT.equals(stype)) { <line5> return super.returnAvatarStream(); <line6> } else if (AvatarConfig.STYLE_GRAVATAR.equals(stype)) { <line7> return super.extractGravatar(); <line8> } <line9> try { <line10> String url = this.getAvatarManager().getAvatarUrl(this.getUsername()); <line11> if (null == url) { <line12> return this.extractDefaultAvatarStream(); <line13> } <line14> MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap(); <line15> this.setMimeType(mimeTypesMap.getContentType(url)); <line16> File avatar = this.getAvatarManager().getAvatarResource(this.getUsername()); <line17> if (null == avatar) { <line18> return this.extractDefaultAvatarStream(); <line19> } <line20> this.setInputStream(new FileInputStream(avatar)); <line21> } catch (Throwable t) { <line22> return this.extractDefaultAvatarStream(); <line23> } <line24> return SUCCESS; <line25> } <line26> } <line27> 	 <line22>	Yes
"public class A { <line0> @Override <line1> @Deprecated <line2> @SuppressFBWarnings(""SLF4J_SIGN_ONLY_FORMAT"") <line3> public void onLinkRemoved(final LinkRemoved notification) { <line4> LOG.debug(""-------------------------------------------""); <line5> } <line6> } <line7> "	 <line1>	No
public class A { <line0> @Override <line1> public void handleUpdate(LutronCommandType type, String... parameters) { <line2> if (outputType == CcoOutputType.MAINTAINED) { <line3> if (type == LutronCommandType.OUTPUT <line4> && parameters.length > 1 <line5> && OutputCommand.ACTION_STATE.toString().equals(parameters[0])) { <line6> if (getThing().getStatus() == ThingStatus.UNKNOWN) { <line7> updateStatus(ThingStatus.ONLINE); <line8> } <line9> try { <line10> BigDecimal state = new BigDecimal(parameters[1]); <line11> updateState( <line12> CHANNEL_SWITCH, state.compareTo(BigDecimal.ZERO) == 0 ? OnOffType.OFF : OnOffType.ON); <line13> } catch (NumberFormatException e) { <line14> return; <line15> } <line16> } <line17> } else { <line18> if (getThing().getStatus() == ThingStatus.UNKNOWN) { <line19> updateStatus(ThingStatus.ONLINE); <line20> } <line21> } <line22> } <line23> } <line24> 	 <line16>	No
public class A { <line0> @Override <line1> public SchemaIdVersion addSchemaVersion( <line2> SchemaMetadata schemaMetadata, SchemaVersion schemaVersion, boolean disableCanonicalCheck) <line3> throws InvalidSchemaException, IncompatibleSchemaException, SchemaNotFoundException, <line4> SchemaBranchNotFoundException { <line5> return schemaVersionLifecycleManager.addSchemaVersion( <line6> SchemaBranch.MASTER_BRANCH, <line7> schemaMetadata, <line8> schemaVersion, <line9> x -> registerSchemaMetadata(x), <line10> disableCanonicalCheck); <line11> } <line12> } <line13> 	 <line6>	No
public class A { <line0> @Override <line1> public void removeProcedureForOffering(String offering, String procedure) { <line2> CacheValidation.notNullOrEmpty(OFFERING, offering); <line3> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line4> this.proceduresForOfferings.getOrDefault(offering, Collections.emptySet()).remove(procedure); <line5> } <line6> } <line7> 	 <line0>	No
public class A { <line0> @Override <line1> public @Nullable Thing createThingOfType( <line2> ThingTypeUID thingTypeUID, <line3> @Nullable ThingUID thingUID, <line4> @Nullable ThingUID bridgeUID, <line5> @Nullable String label, <line6> Configuration configuration) { <line7> for (ThingHandlerFactory thingHandlerFactory : thingHandlerFactories) { <line8> if (thingHandlerFactory.supportsThingType(thingTypeUID)) { <line9> Thing thing = <line10> thingHandlerFactory.createThing(thingTypeUID, configuration, thingUID, bridgeUID); <line11> if (thing == null) { <line12> } else { <line13> thing.setLabel(label); <line14> return thing; <line15> } <line16> } <line17> } <line18> return null; <line19> } <line20> } <line21> 	 <line8>	No
"public class A { <line0> @Override <line1> public AuthenticationResponse authenticate(AuthenticationRequest authenticationRequest) <line2> throws InvalidCredentialsException, IdentityAccessException { <line3> if (provider == null) { <line4> throw new IdentityAccessException(""The Kerberos authentication provider is not initialized.""); <line5> } <line6> try { <line7> final String rawPrincipal = authenticationRequest.getUsername(); <line8> final Object credentials = authenticationRequest.getCredentials(); <line9> final String parsedRealm = KerberosPrincipalParser.getRealm(rawPrincipal); <line10> boolean realmInRawPrincipal = StringUtils.isNotBlank(parsedRealm); <line11> final String identity; <line12> if (realmInRawPrincipal) { <line13> identity = rawPrincipal; <line14> } else if (StringUtils.isNotBlank(defaultRealm)) { <line15> identity = StringUtils.joinWith(""@"", rawPrincipal, defaultRealm); <line16> } else { <line17> identity = rawPrincipal; <line18> } <line19> final UsernamePasswordAuthenticationToken token = <line20> new UsernamePasswordAuthenticationToken(identity, credentials); <line21> if (logger.isDebugEnabled()) { <line22> } <line23> final Authentication authentication = provider.authenticate(token); <line24> if (logger.isDebugEnabled()) { <line25> } <line26> return new AuthenticationResponse(authentication.getName(), identity, expiration, issuer); <line27> } catch (final AuthenticationException e) { <line28> throw new InvalidCredentialsException(e.getMessage(), e); <line29> } <line30> } <line31> } <line32> "	 <line17>	No
"public class A { <line0> @Test <line1> public void should_find_by_id_async() throws Exception { <line2> final long id = RandomUtils.nextLong(0, Long.MAX_VALUE); <line3> scriptExecutor.executeScriptTemplate( <line4> ""SimpleEntity/insert_single_row.cql"", ImmutableMap.of(""id"", id, ""table"", ""simple"")); <line5> final Date date = buildDateKey(); <line6> final CountDownLatch latch = new CountDownLatch(1); <line7> final CassandraLogAsserter logAsserter = new CassandraLogAsserter(); <line8> logAsserter.prepareLogLevel(ASYNC_LOGGER_STRING, ""%msg - [%thread]%n""); <line9> final CompletableFuture<Tuple2<SimpleEntity, ExecutionInfo>> tuple2 = <line10> manager <line11> .crud() <line12> .findById(id, date) <line13> .withResultSetAsyncListener( <line14> rs -> { <line15> latch.countDown(); <line16> return rs; <line17> }) <line18> .getAsyncWithStats(); <line19> latch.await(); <line20> final SimpleEntity actual = tuple2.get()._1(); <line21> final ExecutionInfo executionInfo = tuple2.get()._2(); <line22> assertThat(actual).isNotNull(); <line23> assertThat(actual.getConsistencyList()) <line24> .containsExactly(ConsistencyLevel.QUORUM, ConsistencyLevel.LOCAL_ONE); <line25> assertThat(executionInfo.getQueriedHost().isUp()).isTrue(); <line26> logAsserter.assertContains(""Called - [achilles-default-executor""); <line27> } <line28> } <line29> "	 <line25>	No
public class A { <line0> @Override <line1> protected @Nullable ThingHandler createHandler(Thing thing) { <line2> ThingHandler resultHandler = null; <line3> ThingTypeUID thingTypeUID = thing.getThingTypeUID(); <line4> if (VeluxBindingConstants.SUPPORTED_THINGS_BINDING.contains(thingTypeUID)) { <line5> resultHandler = createBindingHandler(thing); <line6> } else if (VeluxBindingConstants.SUPPORTED_THINGS_BRIDGE.contains(thingTypeUID)) { <line7> resultHandler = createBridgeHandler(thing); <line8> } else if (VeluxBindingConstants.SUPPORTED_THINGS_ITEMS.contains(thingTypeUID)) { <line9> resultHandler = createThingHandler(thing); <line10> } else { <line11> } <line12> updateBindingState(); <line13> return resultHandler; <line14> } <line15> } <line16> 	 <line11>	Yes
"public class A { <line0> @Test <line1> public void checkOverlaps() throws IOException { <line2> final StringWriter writer = new StringWriter(); <line3> subject.checkOverlaps(writer); <line4> final String output = writer.getBuffer().toString(); <line5> final List<String> overlaps = Splitter.on(""\n"").splitToList(output); <line6> assertThat(overlaps, hasSize(11)); <line7> assertThat( <line8> overlaps, <line9> containsInAnyOrder( <line10> ""GRS1	GRS2	aut-num     	AS1-AS2"", <line11> ""GRS1	GRS2	inetnum     	10.0.0.0-10.0.0.0"", <line12> ""GRS1	GRS2	inetnum     	192.0.0.1-192.0.0.2"", <line13> ""GRS1	GRS2	inet6num    	::/0"", <line14> ""GRS1	GRS3	aut-num     	AS1-AS1"", <line15> ""GRS1	GRS3	inetnum     	193.0.0.10-193.0.0.11"", <line16> ""GRS1	GRS3	inet6num    	::/0"", <line17> ""GRS2	GRS3	aut-num     	AS10-AS10"", <line18> ""GRS2	GRS3	aut-num     	AS1-AS1"", <line19> ""GRS2	GRS3	inet6num    	::/0"", <line20> """")); <line21> } <line22> } <line23> "	 <line0>	No
"public class A { <line0> protected Answer execute(DeleteStoragePoolCommand cmd) { <line1> if (s_logger.isInfoEnabled()) { <line2> } <line3> try { <line4> if (cmd.getRemoveDatastore()) { <line5> _storageProcessor.handleDatastoreAndVmdkDetach( <line6> cmd, <line7> cmd.getDetails().get(DeleteStoragePoolCommand.DATASTORE_NAME), <line8> cmd.getDetails().get(DeleteStoragePoolCommand.IQN), <line9> cmd.getDetails().get(DeleteStoragePoolCommand.STORAGE_HOST), <line10> Integer.parseInt(cmd.getDetails().get(DeleteStoragePoolCommand.STORAGE_PORT))); <line11> return new Answer(cmd, true, ""success""); <line12> } else { <line13> return new Answer(cmd, true, ""success""); <line14> } <line15> } catch (Throwable e) { <line16> if (e instanceof RemoteException) { <line17> invalidateServiceContext(); <line18> } <line19> StorageFilerTO pool = cmd.getPool(); <line20> String msg = <line21> ""DeleteStoragePoolCommand (pool: "" <line22> + pool.getHost() <line23> + "", path: "" <line24> + pool.getPath() <line25> + "") failed due to "" <line26> + VmwareHelper.getExceptionMessage(e); <line27> return new Answer(cmd, false, msg); <line28> } <line29> } <line30> } <line31> "	 <line30>	No
public class A { <line0> private WireRecord processRecord(WireRecord record) { <line1> final Map<String, TypedValue<?>> inputProperties = record.getProperties(); <line2> final Map<String, TypedValue<?>> outProperties = new HashMap<>(); <line3> if (this.options.shouldEmitReceivedProperties()) { <line4> outProperties.putAll(inputProperties); <line5> } <line6> for (GainOffsetEntry e : this.options.getEntries()) { <line7> final String propertyName = e.getPropertyName(); <line8> final TypedValue<?> typedValue = inputProperties.get(propertyName); <line9> if (typedValue == null) { <line10> continue; <line11> } <line12> final Object value = typedValue.getValue(); <line13> if (value == null || !(value instanceof Number)) { <line14> continue; <line15> } <line16> outProperties.put( <line17> propertyName, <line18> TypedValues.newDoubleValue(((Number) value).doubleValue() * e.getGain() + e.getOffset())); <line19> } <line20> return new WireRecord(outProperties); <line21> } <line22> } <line23> 	 <line0>	No
public class A { <line0> public static void afterRouteSynchronizations( <line1> Route route, Exchange exchange, List<Synchronization> synchronizations, Logger log) { <line2> List<Synchronization> copy = new ArrayList<>(synchronizations); <line3> Collections.reverse(copy); <line4> copy.sort(OrderedComparator.get()); <line5> for (Synchronization synchronization : copy) { <line6> if (synchronization instanceof SynchronizationRouteAware) { <line7> try { <line8> ((SynchronizationRouteAware) synchronization).onAfterRoute(route, exchange); <line9> } catch (Throwable e) { <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	 <line11>	No
public class A { <line0> @Override <line1> public void warning(final String msg) { <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> WonMessage message = WonCamelHelper.getResponseRequired(exchange); <line3> URI parentURI = WonCamelHelper.getParentURIRequired(exchange); <line4> if (logger.isDebugEnabled()) { <line5> } <line6> messageService.saveMessage(message, parentURI); <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public Object call() throws Exception { <line2> RdfReader rdfReader = RdfReaderFactory.createFileOrResourceReader(schemaPath, uri); <line3> SchemaSource schemaSource = <line4> SchemaSourceFactory.createSchemaSourceSimple(prefix, uri, rdfReader); <line5> RDFUnit rdfUnit = RDFUnit.createWithAllGenerators().init(); <line6> Collection<TestGenerator> testGenerators = rdfUnit.getAutoGenerators(); <line7> ImmutableList.Builder<RdfUnitTestGenerator> builder = ImmutableList.builder(); <line8> builder.add(new TagRdfUnitTestGenerator(testGenerators)); <line9> builder.add(new ShaclTestGenerator()); <line10> RdfUnitTestGenerator g; <line11> if (datafolder != null) { <line12> String testFolder = this.datafolder + ""tests/""; <line13> g = <line14> new GenerateAndCacheRdfUnitTestGenerator( <line15> new CompositeTestGenerator(builder.build()), testFolder); <line16> } else { <line17> g = new CompositeTestGenerator(builder.build()); <line18> } <line19> Collection<GenericTestCase> tests = new ArrayList<>(g.generate(schemaSource)); <line20> if (!tests.isEmpty()) { <line21> if (output.trim().equals(""-"")) { <line22> TestUtils.writeTestsToFile(tests, new RdfStreamWriter(System.out), addExplicitWhere); <line23> } else { <line24> File outputFile = new File(output); <line25> outputFile.getParentFile().mkdirs(); <line26> TestUtils.writeTestsToFile(tests, new RdfFileWriter(outputFile.getAbsolutePath())); <line27> } <line28> } <line29> return null; <line30> } <line31> } <line32> "	 <line5>	Yes
public class A { <line0> public void run(List<Variant> variantList) { <line1> if (variantList != null && !variantList.isEmpty()) { <line2> CellBaseDataResponse<VariantAnnotation> response; <line3> try { <line4> response = variantClient.getAnnotation(variantList, queryOptions, true); <line5> } catch (IOException e) { <line6> e.printStackTrace(); <line7> return; <line8> } <line9> List<CellBaseDataResult<VariantAnnotation>> cellBaseDataResultList = response.getResponses(); <line10> for (int i = 0; i < cellBaseDataResultList.size(); i++) { <line11> if (cellBaseDataResultList.get(i).getResults() != null <line12> && cellBaseDataResultList.get(i).getResults().size() > 0) { <line13> if (variantList.get(i).getAnnotation() == null) { <line14> variantList.get(i).setAnnotation(cellBaseDataResultList.get(i).getResults().get(0)); <line15> } else { <line16> mergeAnnotation( <line17> variantList.get(i).getAnnotation(), <line18> cellBaseDataResultList.get(i).getResults().get(0)); <line19> } <line20> } else { <line21> } <line22> } <line23> } <line24> } <line25> } <line26> 	 <line12>	No
public class A { <line0> private void scheduleNextRetry(GeneratedMessageV3 request, int remainingRetryCount) { <line1> final TimerTask timerTask = <line2> new TimerTask() { <line3> @Override <line4> public void run(Timeout timeout) throws Exception { <line5> if (timeout.cancel()) { <line6> return; <line7> } <line8> request(request, remainingRetryCount - 1); <line9> } <line10> }; <line11> try { <line12> retryTimer.newTimeout(timerTask, 1000, TimeUnit.MILLISECONDS); <line13> } catch (RejectedExecutionException e) { <line14> } <line15> } <line16> } <line17> 	 <line14>	Yes
public class A { <line0> @Override <line1> public void restart(long seekTo) { <line2> lastCurrentPosition = 0; <line3> load(videoUri, seekTo, playWhenPrepared); <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> private void identifyDuplicateGroupNames(final Collection<Group> groups) { <line1> final List<String> groupNames = new ArrayList<String>(); <line2> for (final Group group : groups) { <line3> if (groupNames.contains(group.getName())) { <line4> throw new WroRuntimeException(""Duplicate group name detected: "" + group.getName()); <line5> } <line6> groupNames.add(group.getName()); <line7> } <line8> } <line9> } <line10> "	 <line1>	Yes
public class A { <line0> private Object parseArray(Object value, Schema schema) throws GoraException { <line1> if (value == null) { <line2> return null; <line3> } <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> Schema elementSchema = schema.getElementType(); <line7> JSONArray jsonArray = new JSONArray(String.valueOf(value)); <line8> List<Object> valueList = new ArrayList<>(); <line9> for (int i = 0; i < jsonArray.length(); i++) { <line10> valueList.add(parseSchema(elementSchema, jsonArray.get(i))); <line11> } <line12> return valueList; <line13> } <line14> } <line15> 	 <line11>	No
"public class A { <line0> @Override <line1> public Object getService(Filter filter, long timeout) throws OsgiServiceNotAvailableException { <line2> ServiceTracker t = new ServiceTracker(bundleContext, filter, null); <line3> Object result = waitForServiceFromTracker(t, timeout); <line4> if (result == null) { <line5> throw new OsgiServiceNotAvailableException( <line6> String.format( <line7> ""no service matching filter \""%s\"" available at the time"", filter.toString())); <line8> } <line9> return result; <line10> } <line11> } <line12> "	 <line9>	No
public class A { <line0> @Override <line1> public void releaseAddress(String ip) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> public void shutdown() { <line1> if (!this.protocolConnector.isEmpty()) { <line2> for (Connector listener : this.protocolConnector.values()) { <line3> listener.shutdown(); <line4> } <line5> this.protocolConnector.clear(); <line6> this.sechmaMapping.clear(); <line7> } <line8> } <line9> } <line10> 	 <line7>	No
public class A { <line0> @Override <line1> public void run(NeedReplyMessage msg, MessageReply reply) { <line2> ConnectHostMsg cmsg = (ConnectHostMsg) msg; <line3> if (reply.isSuccess()) { <line4> } else if (reply.isCanceled()) { <line5> } else { <line6> } <line7> } <line8> } <line9> 	 <line7>	No
"public class A { <line0> @Override <line1> public void clearCache() throws AiravataSecurityException { <line2> try { <line3> AuthzCache.getInstance().clear(); <line4> } catch (ApplicationSettingsException e) { <line5> throw new AiravataSecurityException(""Error in obtaining the authorization cache instance.""); <line6> } <line7> } <line8> } <line9> "	 <line5>	Yes
"public class A { <line0> @Override <line1> public ModelNode execute( <line2> ModelNode operation, <line3> OperationMessageHandler handler, <line4> OperationTransactionControl control, <line5> OperationAttachments attachments) { <line6> this.operation = operation; <line7> executeLatch.countDown(); <line8> try { <line9> Thread.sleep(10000000); <line10> ModelNode result = new ModelNode(); <line11> result.get(""testing"").set(operation.get(""test"")); <line12> return result; <line13> } catch (InterruptedException e) { <line14> interrupted.countDown(); <line15> throw new RuntimeException(e); <line16> } <line17> } <line18> } <line19> "	 <line9>	Yes
public class A { <line0> public static TransactionGetReceiptResponse getReceiptByTransactionId( <line1> CryptoServiceGrpc.CryptoServiceBlockingStub stub, TransactionID transactionId) <line2> throws Exception { <line3> while (true) { <line4> Response response = <line5> querySubmit( <line6> () -> { <line7> try { <line8> return Query.newBuilder() <line9> .setTransactionGetReceipt( <line10> RequestBuilder.getTransactionGetReceiptQuery( <line11> transactionId, ResponseType.ANSWER_ONLY)) <line12> .build(); <line13> } catch (Exception e) { <line14> return null; <line15> } <line16> }, <line17> stub::getTransactionReceipts); <line18> ResponseCodeEnum code = response.getTransactionGetReceipt().getReceipt().getStatus(); <line19> ResponseCodeEnum preCheck = <line20> response.getTransactionGetReceipt().getHeader().getNodeTransactionPrecheckCode(); <line21> if (preCheck == ResponseCodeEnum.RECEIPT_NOT_FOUND) { <line22> return null; <line23> } else if (code == ResponseCodeEnum.UNKNOWN) { <line24> Thread.sleep(200); <line25> } else if (code == ResponseCodeEnum.SUCCESS) { <line26> return response.getTransactionGetReceipt(); <line27> } else { <line28> return response.getTransactionGetReceipt(); <line29> } <line30> } <line31> } <line32> } <line33> 	 <line32>	No
"public class A { <line0> public ActivityFrequencyBean getFrequencyRunsDetailsForActiveTasks( <line1> ActiveTaskDto activeTask, ActivityFrequencyBean frequencyDetails, Session session) <line2> throws DAOException { <line3> LOGGER.entry(""begin getFrequencyRunsDetailsForActiveTasks()""); <line4> List<ActivityFrequencyScheduleBean> runDetailsBean = new ArrayList<>(); <line5> List<ActivityFrequencyAnchorRunsBean> anchorRunDetailsBean = new ArrayList<>(); <line6> try { <line7> switch (activeTask.getFrequency()) { <line8> case StudyMetaDataConstants.FREQUENCY_TYPE_DAILY: <line9> runDetailsBean = <line10> this.getActiveTaskFrequencyDetailsForDaily(activeTask, runDetailsBean, session); <line11> break; <line12> case StudyMetaDataConstants.FREQUENCY_TYPE_MANUALLY_SCHEDULE: <line13> runDetailsBean = <line14> this.getActiveTaskFrequencyDetailsForManuallySchedule( <line15> activeTask, runDetailsBean, session); <line16> break; <line17> default: <line18> break; <line19> } <line20> frequencyDetails.setRuns(runDetailsBean); <line21> anchorRunDetailsBean = <line22> this.getAcivetaskFrequencyAncorDetailsForManuallySchedule( <line23> activeTask, anchorRunDetailsBean, session); <line24> frequencyDetails.setAnchorRuns(anchorRunDetailsBean); <line25> } catch (Exception e) { <line26> } <line27> LOGGER.exit(""getFrequencyRunsDetailsForActiveTasks() :: Ends""); <line28> return frequencyDetails; <line29> } <line30> } <line31> "	 <line26>	Yes
public class A { <line0> @Override <line1> public Folder getParentFolder() throws PortalException { <line2> Folder parentFolder = null; <line3> try { <line4> parentFolder = super.getParentFolder(); <line5> if (parentFolder != null) { <line6> return parentFolder; <line7> } <line8> } catch (Exception exception) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> } <line12> if (_cmisFolder.isRootFolder()) { <line13> Folder folder = DLAppLocalServiceUtil.getMountFolder(getRepositoryId()); <line14> parentFolder = folder.getParentFolder(); <line15> } else { <line16> Session session = _cmisRepository.getSession(); <line17> String path = _cmisFolder.getPath(); <line18> path = path.substring(0, path.lastIndexOf(CharPool.SLASH)); <line19> if (path.length() == 0) { <line20> path = StringPool.SLASH; <line21> } <line22> CmisObject parentCmisFolder = session.getObjectByPath(path); <line23> parentFolder = <line24> _cmisRepository.toFolder( <line25> (org.apache.chemistry.opencmis.client.api.Folder) parentCmisFolder); <line26> } <line27> setParentFolder(parentFolder); <line28> return parentFolder; <line29> } <line30> } <line31> 	 <line4>	No
public class A { <line0> private void initialize(ChannelHandlerContext ctx) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> switch (state) { <line4> case 1: <line5> case 2: <line6> return; <line7> } <line8> state = 1; <line9> EventExecutor loop = ctx.executor(); <line10> lastExecutionTime = System.nanoTime(); <line11> resenderTimeout = <line12> loop.schedule(new WriterIdleTimeoutTask(ctx), resenderTimeNanos, TimeUnit.NANOSECONDS); <line13> } <line14> } <line15> 	 <line6>	No
public class A { <line0> @Override <line1> public KaleoTransition findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchTransitionException { <line3> KaleoTransition kaleoTransition = fetchByPrimaryKey(primaryKey); <line4> if (kaleoTransition == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchTransitionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return kaleoTransition; <line10> } <line11> } <line12> 	 <line6>	Yes
public class A { <line0> Set<DLockRemoteToken> getLockTokensForRecovery(LockGrantorId newlockGrantorId) { <line1> Set<DLockRemoteToken> heldLockSet = Collections.EMPTY_SET; <line2> LockGrantorId currentLockGrantorId = null; <line3> synchronized (this.lockGrantorIdLock) { <line4> if (isDestroyed()) { <line5> return heldLockSet; <line6> } <line7> currentLockGrantorId = this.lockGrantorId; <line8> } <line9> if (currentLockGrantorId != null <line10> && currentLockGrantorId.hasLockGrantorVersion() <line11> && newlockGrantorId.isNewerThan(currentLockGrantorId)) { <line12> nullLockGrantorId(currentLockGrantorId); <line13> } <line14> final boolean isDebugEnabled_DLS = logger.isTraceEnabled(LogMarker.DLS_VERBOSE); <line15> synchronized (this.lockGrantorIdLock) { <line16> synchronized (this.tokens) { <line17> for (DLockToken token : this.tokens.values()) { <line18> synchronized (token) { <line19> if (token.isLeaseHeld()) { <line20> if (token.ignoreForRecovery()) { <line21> if (isDebugEnabled_DLS) { <line22> } <line23> } else { <line24> if (heldLockSet == Collections.EMPTY_SET) { <line25> heldLockSet = new HashSet<>(); <line26> } <line27> heldLockSet.add(DLockRemoteToken.createFromDLockToken(token)); <line28> } <line29> } <line30> } <line31> } <line32> } <line33> return heldLockSet; <line34> } <line35> } <line36> } <line37> 	 <line18>	No
public class A { <line0> @Override <line1> public Object visit(PropertyName expression, Object data) { <line2> return data; <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> public static void printSizeStats(String type, double density, long count, long totalBytes) { <line1> } <line2> } <line3> 	 <line0>	No
"public class A { <line0> @Override <line1> public synchronized void start() { <line2> Assert.state(m_worker == null, ""The fiber has already run or is running""); <line3> m_worker = new Thread(this, getName()); <line4> m_worker.start(); <line5> m_status = STARTING; <line6> } <line7> } <line8> "	 <line6>	Yes
"public class A { <line0> private Message deserializeHelper(String json, Object context) throws Exception { <line1> JSONObject jo = new JSONObject(json); <line2> if (!SchemaUtils.checkValidKeys(jo, FIRST_LEVEL_FIELD_COMBINATIONS)) { <line3> throw new IOException(""Invalid keys""); <line4> } <line5> String id = jo.getString(DataQuerySnapshot.FIELD_ID); <line6> String type = jo.getString(DataQuerySnapshot.FIELD_TYPE); <line7> if (!type.equals(DataQuerySnapshot.TYPE)) { <line8> return null; <line9> } <line10> long countdown = -1L; <line11> boolean hasCountdown = jo.has(DataQuerySnapshot.FIELD_COUNTDOWN); <line12> if (hasCountdown) { <line13> countdown = jo.getLong(DataQuerySnapshot.FIELD_COUNTDOWN); <line14> } <line15> Map<String, String> schemaKeys = null; <line16> Set<String> fieldsSet = Sets.newHashSet(); <line17> if (jo.has(DataQuerySnapshot.FIELD_DATA)) { <line18> JSONObject data = jo.getJSONObject(DataQuerySnapshot.FIELD_DATA); <line19> if (!SchemaUtils.checkValidKeys(data, DATA_FIELD_COMBINATIONS)) { <line20> throw new IOException(""Invalid keys""); <line21> } <line22> if (data.has(DataQuerySnapshot.FIELD_SCHEMA_KEYS)) { <line23> schemaKeys = <line24> SchemaUtils.extractMap(data.getJSONObject(DataQuerySnapshot.FIELD_SCHEMA_KEYS)); <line25> } <line26> if (data.has(DataQuerySnapshot.FIELD_FIELDS)) { <line27> JSONArray jArray = data.getJSONArray(DataQuerySnapshot.FIELD_FIELDS); <line28> for (int index = 0; index < jArray.length(); index++) { <line29> String field = jArray.getString(index); <line30> if (!fieldsSet.add(field)) { <line31> } <line32> } <line33> } <line34> } <line35> Fields fields = new Fields(fieldsSet); <line36> if (!hasCountdown) { <line37> return new DataQuerySnapshot(id, fields, schemaKeys); <line38> } else { <line39> return new DataQuerySnapshot(id, fields, countdown, schemaKeys); <line40> } <line41> } <line42> } <line43> "	 <line28>	No
"public class A { <line0> public void doGet(HttpServletRequest request, HttpServletResponse response) <line1> throws ServletException, IOException { <line2> String jsonOutput; <line3> String inGeomWKT = request.getParameter(""geometry""); <line4> String fromSRID = request.getParameter(""srid""); <line5> JSONObject obj = new JSONObject(); <line6> JSONArray arr = new JSONArray(); <line7> try { <line8> if (fromSRID == ""4326"" || fromSRID == ""EPSG:4326"") { <line9> obj.put(""Geometry"", inGeomWKT); <line10> obj.put(""SRID"", fromSRID); <line11> arr.put(obj); <line12> } else { <line13> String outGeomWKT = <line14> SpatialReferenceSystemTransformationUtil.Transform(inGeomWKT, fromSRID, ""4326""); <line15> obj.put(""Geometry"", outGeomWKT); <line16> obj.put(""SRID"", 4326); <line17> arr.put(obj); <line18> } <line19> } catch (JSONException e) { <line20> } <line21> jsonOutput = arr.toString(); <line22> PrintWriter pw = response.getWriter(); <line23> response.setContentType(MimeType.APPLICATION_JSON); <line24> pw.write(jsonOutput); <line25> return; <line26> } <line27> } <line28> "	 <line14>	No
"public class A { <line0> void doInstanceDiscovery( <line1> final Map<String, String> headers, final Proxy proxy, final SSLSocketFactory sslSocketFactory) <line2> throws Exception { <line3> if (!instanceDiscoveryCompleted) { <line4> if (!doStaticInstanceDiscovery()) { <line5> if (validateAuthority && !doDynamicInstanceDiscovery(headers, proxy, sslSocketFactory)) { <line6> throw new AuthenticationException(AuthenticationErrorMessage.AUTHORITY_NOT_IN_VALID_LIST); <line7> } <line8> } <line9> String msg = <line10> LogHelper.createMessage( <line11> ""Instance discovery was successful"", <line12> headers.get(ClientDataHttpHeaders.CORRELATION_ID_HEADER_NAME)); <line13> instanceDiscoveryCompleted = true; <line14> } <line15> } <line16> } <line17> "	 <line13>	Yes
"public class A { <line0> @Override <line1> public Alert findAlertByPrimaryKey(BigInteger id) { <line2> requireNotDisposed(); <line3> requireArgument(id != null && id.compareTo(ZERO) > 0, ""ID must be a positive non-zero value.""); <line4> EntityManager em = _emProvider.get(); <line5> em.getEntityManagerFactory().getCache().evictAll(); <line6> Alert result = Alert.findByPrimaryKey(em, id, Alert.class); <line7> return result; <line8> } <line9> } <line10> "	 <line8>	No
public class A { <line0> @Override <line1> public void status( <line2> WorkloadStatusSnapshot status, <line3> RecentThroughputAndDuration recentThroughputAndDuration, <line4> long completionTimeAsMilli) { <line5> String statusString; <line6> statusString = <line7> (detailedStatus) <line8> ? formatWithCt( <line9> status.operationCount(), <line10> status.runDurationAsMilli(), <line11> status.durationSinceLastMeasurementAsMilli(), <line12> status.throughput(), <line13> recentThroughputAndDuration.throughput(), <line14> recentThroughputAndDuration.duration(), <line15> completionTimeAsMilli) <line16> : formatWithoutCt( <line17> status.operationCount(), <line18> status.runDurationAsMilli(), <line19> status.durationSinceLastMeasurementAsMilli(), <line20> status.throughput(), <line21> recentThroughputAndDuration.throughput(), <line22> recentThroughputAndDuration.duration()); <line23> } <line24> } <line25> 	 <line14>	No
"public class A { <line0> @Test <line1> public void sqlBench() { <line2> int warmUpIterations = 100; <line3> int realIterations = 200; <line4> SqlService sqlService = inst.getSql(); <line5> inst.getMap(""m"").put(1, 1); <line6> int numRows = 0; <line7> for (int i = 0; i < warmUpIterations; i++) { <line8> for (SqlRow r : sqlService.execute(""select * from m"")) { <line9> numRows++; <line10> } <line11> } <line12> long start = System.nanoTime(); <line13> for (int i = 0; i < realIterations; i++) { <line14> for (SqlRow r : sqlService.execute(""select * from m"")) { <line15> numRows++; <line16> } <line17> } <line18> long elapsedMicros = NANOSECONDS.toMicros(System.nanoTime() - start); <line19> System.out.println(numRows); <line20> System.out.println( <line21> realIterations + "" queries run in "" + (elapsedMicros / realIterations) + "" us/job""); <line22> } <line23> } <line24> "	 <line12>	Yes
"public class A { <line0> public Object evaluateKey(Object object) { <line1> Object value = object; <line2> ExecutionContext newContext = null; <line3> Object key = null; <line4> try { <line5> if (object instanceof RegionEntry) { <line6> RegionEntry regionEntry = (RegionEntry) object; <line7> newContext = createExecutionContext(regionEntry); <line8> value = getTargetObjectForUpdate(regionEntry); <line9> } <line10> List iterators = newContext.getCurrentIterators(); <line11> RuntimeIterator itr = (RuntimeIterator) iterators.get(0); <line12> itr.setCurrent(value); <line13> key = this.indexedExpr.evaluate(newContext); <line14> } catch (Exception e) { <line15> if (logger.isDebugEnabled()) { <line16> } <line17> throw new Error(""Could not reevaluate key for hash index"", e); <line18> } <line19> if (key == null) { <line20> key = IndexManager.NULL; <line21> } <line22> return key; <line23> } <line24> } <line25> "	 <line10>	No
"public class A { <line0> @Override <line1> @SuppressWarnings(""PMD.CollapsibleIfStatements"") <line2> public synchronized void save( <line3> Preferences preferences, CipherFactory cipherFactory, boolean compressed) <line4> throws IOException, JAXBException { <line5> final File aFile = <line6> getFile(preferences.getTopic(), getExtension(cipherFactory != null, compressed)); <line7> if (!aFile.getParentFile().exists() && !aFile.getParentFile().mkdirs()) { <line8> throw new IOException( <line9> ""Unable to create parent directory for preferences file: "" + aFile.getAbsolutePath()); <line10> } <line11> final File temp = <line12> File.createTempFile(preferences.getTopic(), TMP_SUFFIX, aFile.getParentFile()); <line13> OutputStream os = new FileOutputStream(temp); <line14> boolean success = false; <line15> try { <line16> if (cipherFactory != null) { <line17> try { <line18> final Cipher cipher = cipherFactory.initCipher(Cipher.ENCRYPT_MODE); <line19> writeEncryptionParametersToStream(os, cipher); <line20> @SuppressWarnings(""resource"") <line21> final CipherOutputStream cos = new CipherOutputStream(os, cipher); <line22> os = cos; <line23> } catch (final CipherException e) { <line24> return; <line25> } <line26> } <line27> if (compressed) { <line28> final ZipOutputStream zos = new ZipOutputStream(os); <line29> zos.putNextEntry( <line30> new ZipEntry( <line31> preferences.getTopic().replaceAll("" "", """").replaceAll(""\n"", """").concat("".xml""))); <line32> os = zos; <line33> } <line34> XMLUtilities.writeXMLObject(preferences, os); <line35> success = true; <line36> } finally { <line37> os.close(); <line38> if (success && (aFile.exists() && !aFile.delete() || !temp.renameTo(aFile))) { <line39> } else if (!temp.delete() && LOGGER.isDebugEnabled()) { <line40> } <line41> } <line42> } <line43> } <line44> "	 <line30>	No
"public class A { <line0> @Override <line1> public final void enforceCompareDatastreamChecksum( <line2> Context context, String pid, String datastreamId, Date versionDate) throws AuthzException { <line3> try { <line4> String target = Constants.ACTION.COMPARE_DATASTREAM_CHECKSUM.uri; <line5> context.setActionAttributes(null); <line6> MultiValueMap<URI> resourceAttributes = new MultiValueMap<URI>(); <line7> URI name = null; <line8> try { <line9> name = Constants.DATASTREAM.ID.attributeId; <line10> resourceAttributes.set(name, datastreamId); <line11> name = Constants.RESOURCE.AS_OF_DATETIME.attributeId; <line12> resourceAttributes.set(name, ensureDate(versionDate, context)); <line13> } catch (Exception e) { <line14> context.setResourceAttributes(null); <line15> throw new AuthzOperationalException(target + "" couldn't set "" + name, e); <line16> } <line17> context.setResourceAttributes(resourceAttributes); <line18> xacmlPep.enforce( <line19> context.getSubjectValue(Constants.SUBJECT.LOGIN_ID.uri), <line20> target, <line21> Constants.ACTION.APIM.uri, <line22> pid, <line23> extractNamespace(pid), <line24> context); <line25> } finally { <line26> } <line27> } <line28> } <line29> "	 <line26>	Yes
public class A { <line0> public void loginEvent( <line1> final User user, <line2> final String surrogateIdentifier, <line3> final String ip, <line4> final String errorMessage) { <line5> } <line6> } <line7> 	 <line5>	Yes
"public class A { <line0> private void addPersistContentIfManagedBundle( <line1> final BrooklynObjectType type, <line2> final String id, <line3> List<ListenableFuture<?>> futures, <line4> final PersistenceExceptionHandler exceptionHandler) { <line5> if (type == BrooklynObjectType.MANAGED_BUNDLE) { <line6> if (mgmt == null) { <line7> throw new IllegalStateException(""Cannot persist bundles without a management context""); <line8> } <line9> final ManagedBundle mb = <line10> ((ManagementContextInternal) mgmt).getOsgiManager().get().getManagedBundles().get(id); <line11> if (mb == null) { <line12> return; <line13> } <line14> if (mb instanceof BasicManagedBundle) { <line15> if (((BasicManagedBundle) mb).getPersistenceNeeded()) { <line16> futures.add( <line17> executor.submit( <line18> new Runnable() { <line19> @Override <line20> public void run() { <line21> if (!((BasicManagedBundle) mb).getPersistenceNeeded()) { <line22> return; <line23> } <line24> persist( <line25> type.getSubPathName(), <line26> type, <line27> id + "".jar"", <line28> com.google.common.io.Files.asByteSource( <line29> ((ManagementContextInternal) mgmt) <line30> .getOsgiManager() <line31> .get() <line32> .getBundleFile(mb)), <line33> exceptionHandler); <line34> ((BasicManagedBundle) mb).setPersistenceNeeded(false); <line35> } <line36> })); <line37> } <line38> } <line39> } <line40> } <line41> } <line42> "	 <line21>	No
"public class A { <line0> @ActivityStreamAuditable <line1> @RestAccessControl(permission = Permission.MANAGE_PAGES) <line2> @RequestMapping( <line3> value = ""/pages/{pageCode}"", <line4> method = RequestMethod.DELETE, <line5> produces = MediaType.APPLICATION_JSON_VALUE) <line6> public ResponseEntity<SimpleRestResponse<?>> deletePage( <line7> @ModelAttribute(""user"") UserDetails user, @PathVariable String pageCode) <line8> throws ApsSystemException { <line9> if (!this.getAuthorizationService().isAuth(user, pageCode)) { <line10> return new ResponseEntity<>(new SimpleRestResponse<>(new PageDto()), HttpStatus.UNAUTHORIZED); <line11> } <line12> DataBinder binder = new DataBinder(pageCode); <line13> BindingResult bindingResult = binder.getBindingResult(); <line14> if (bindingResult.hasErrors()) { <line15> throw new ValidationGenericException(bindingResult); <line16> } <line17> getPageValidator().validateOnlinePage(pageCode, bindingResult); <line18> if (bindingResult.hasErrors()) { <line19> throw new ValidationGenericException(bindingResult); <line20> } <line21> getPageValidator().validateChildren(pageCode, bindingResult); <line22> if (bindingResult.hasErrors()) { <line23> throw new ValidationGenericException(bindingResult); <line24> } <line25> this.getPageService().removePage(pageCode); <line26> Map<String, String> payload = new HashMap<>(); <line27> payload.put(""code"", pageCode); <line28> return new ResponseEntity<>(new SimpleRestResponse<>(payload), HttpStatus.OK); <line29> } <line30> } <line31> "	 <line0>	No
public class A { <line0> private void logDebug(String pattern, Object... arguments) { <line1> if (userMessageLogger != null) { <line2> } <line3> } <line4> } <line5> 	 <line0>	No
"public class A { <line0> @Override <line1> public URL createAttachmentURL( <line2> String filename, <line3> String spaces, <line4> String name, <line5> String action, <line6> String querystring, <line7> String xwikidb, <line8> XWikiContext context) { <line9> if ((context != null) <line10> && ""viewrev"".equals(context.getAction()) <line11> && context.get(""rev"") != null <line12> && isContextDoc(xwikidb, spaces, name, context)) { <line13> try { <line14> String docRevision = context.get(""rev"").toString(); <line15> XWikiAttachment attachment = <line16> findAttachmentForDocRevision(context.getDoc(), docRevision, filename, context); <line17> if (attachment == null) { <line18> action = ""viewattachrev""; <line19> } else { <line20> long arbId = <line21> findDeletedAttachmentForDocRevision(context.getDoc(), docRevision, filename, context); <line22> return createAttachmentRevisionURL( <line23> filename, <line24> spaces, <line25> name, <line26> attachment.getVersion(), <line27> arbId, <line28> querystring, <line29> xwikidb, <line30> context); <line31> } <line32> } catch (XWikiException e) { <line33> if (LOGGER.isErrorEnabled()) { <line34> } <line35> } <line36> } <line37> StringBuffer newpath = new StringBuffer(this.contextPath); <line38> addServletPath(newpath, xwikidb, context); <line39> EntityReference spaceReference = <line40> this.relativeEntityReferenceResolver.resolve(spaces, EntityType.SPACE); <line41> addAction(newpath, spaceReference, action, context); <line42> addSpaces(newpath, spaceReference, action, context); <line43> addName(newpath, name, action, context); <line44> addFileName(newpath, filename, context); <line45> if (!StringUtils.isEmpty(querystring)) { <line46> newpath.append(""?""); <line47> newpath.append(StringUtils.removeEnd(StringUtils.removeEnd(querystring, ""&""), ""&amp;"")); <line48> } <line49> try { <line50> return normalizeURL(new URL(getServerURL(xwikidb, context), newpath.toString()), context); <line51> } catch (Exception e) { <line52> return null; <line53> } <line54> } <line55> } <line56> "	 <line12>	No
"public class A { <line0> public String getPredictionColumn(String usecase) { <line1> try { <line2> Map<String, Object> parameters = new HashMap<>(); <line3> parameters.put(USECASE, usecase); <line4> AutoMLConfig result = <line5> getSingleResult( <line6> ""FROM AutoMLConfig AC WHERE AC.usecase = :usecase"", AutoMLConfig.class, parameters); <line7> return result.getPredictionColumn(); <line8> } catch (Exception e) { <line9> throw e; <line10> } <line11> } <line12> } <line13> "	 <line9>	Yes
public class A { <line0> @Override <line1> public TaskStatus runTask(TaskToolbox toolbox) throws Exception { <line2> final List<ParallelIndexIngestionSpec> ingestionSpecs = <line3> createIngestionSchema( <line4> toolbox, <line5> getTaskLockHelper().getLockGranularityToUse(), <line6> segmentProvider, <line7> partitionConfigurationManager, <line8> dimensionsSpec, <line9> metricsSpec, <line10> granularitySpec, <line11> toolbox.getCoordinatorClient(), <line12> segmentLoaderFactory, <line13> retryPolicyFactory, <line14> ioConfig.isDropExisting()); <line15> final List<ParallelIndexSupervisorTask> indexTaskSpecs = <line16> IntStream.range(0, ingestionSpecs.size()) <line17> .mapToObj( <line18> i -> { <line19> ParallelIndexIngestionSpec ingestionSpec = ingestionSpecs.get(i); <line20> final String baseSequenceName = createIndexTaskSpecId(i); <line21> return newTask(baseSequenceName, ingestionSpec); <line22> }) <line23> .collect(Collectors.toList()); <line24> if (indexTaskSpecs.isEmpty()) { <line25> return TaskStatus.failure(getId()); <line26> } else { <line27> registerResourceCloserOnAbnormalExit(currentSubTaskHolder); <line28> final int totalNumSpecs = indexTaskSpecs.size(); <line29> int failCnt = 0; <line30> for (ParallelIndexSupervisorTask eachSpec : indexTaskSpecs) { <line31> final String json = <line32> toolbox.getJsonMapper().writerWithDefaultPrettyPrinter().writeValueAsString(eachSpec); <line33> if (!currentSubTaskHolder.setTask(eachSpec)) { <line34> return TaskStatus.failure(getId()); <line35> } <line36> try { <line37> if (eachSpec.isReady(toolbox.getTaskActionClient())) { <line38> final TaskStatus eachResult = eachSpec.run(toolbox); <line39> if (!eachResult.isSuccess()) { <line40> failCnt++; <line41> } <line42> } else { <line43> failCnt++; <line44> } <line45> } catch (Exception e) { <line46> failCnt++; <line47> } <line48> } <line49> return failCnt == 0 ? TaskStatus.success(getId()) : TaskStatus.failure(getId()); <line50> } <line51> } <line52> } <line53> 	 <line44>	Yes
"public class A { <line0> public static Map<String, List<EgressOnlyInternetGateway>> fetchEgressGateway( <line1> BasicSessionCredentials temporaryCredentials, <line2> String skipRegions, <line3> String accountId, <line4> String accountName) { <line5> Map<String, List<EgressOnlyInternetGateway>> egressGatewayMap = new LinkedHashMap<>(); <line6> AmazonEC2 ec2Client; <line7> String expPrefix = <line8> InventoryConstants.ERROR_PREFIX_CODE <line9> + accountId <line10> + ""\"",\""Message\"": \""Exception in fetching info for resource in specific region\"""" <line11> + "" ,\""type\"": \""egressgateway\"" , \""region\"":\""""; <line12> for (Region region : RegionUtils.getRegions()) { <line13> try { <line14> if (!skipRegions.contains(region.getName())) { <line15> ec2Client = <line16> AmazonEC2ClientBuilder.standard() <line17> .withCredentials(new AWSStaticCredentialsProvider(temporaryCredentials)) <line18> .withRegion(region.getName()) <line19> .build(); <line20> List<EgressOnlyInternetGateway> egressGatewayList = <line21> ec2Client <line22> .describeEgressOnlyInternetGateways( <line23> new DescribeEgressOnlyInternetGatewaysRequest()) <line24> .getEgressOnlyInternetGateways(); <line25> if (!egressGatewayList.isEmpty()) { <line26> egressGatewayMap.put( <line27> accountId + delimiter + accountName + delimiter + region.getName(), <line28> egressGatewayList); <line29> } <line30> } <line31> } catch (Exception e) { <line32> ErrorManageUtil.uploadError(accountId, region.getName(), ""egressgateway"", e.getMessage()); <line33> } <line34> } <line35> return egressGatewayMap; <line36> } <line37> } <line38> "	 <line32>	Yes
public class A { <line0> private Object getResource(final ResourceId resourceId) { <line1> ManagedInterpreterGroup intpGroup = <line2> interpreterSettingManager.getInterpreterGroupById(resourceId.getResourcePoolId()); <line3> if (intpGroup == null) { <line4> return null; <line5> } <line6> RemoteInterpreterProcess remoteInterpreterProcess = intpGroup.getRemoteInterpreterProcess(); <line7> ByteBuffer buffer = <line8> remoteInterpreterProcess.callRemoteFunction( <line9> client -> <line10> client.resourceGet( <line11> resourceId.getNoteId(), resourceId.getParagraphId(), resourceId.getName())); <line12> try { <line13> return Resource.deserializeObject(buffer); <line14> } catch (Exception e) { <line15> } <line16> return null; <line17> } <line18> } <line19> 	 <line6>	No
"public class A { <line0> @Override <line1> public void run() { <line2> if (!hooked.isEmpty()) { <line3> final StringBuilder string = new StringBuilder(); <line4> for (final String plugin : hooked) { <line5> string.append(plugin).append("", ""); <line6> } <line7> final String plugins = string.substring(0, string.length() - 2); <line8> } <line9> } <line10> } <line11> "	 <line8>	Yes
public class A { <line0> @Override <line1> public KuraMessage doDel(RequestHandlerContext context, KuraMessage reqMessage) <line2> throws KuraException { <line3> final List<String> resourcePath = extractResourcePath(reqMessage); <line4> KuraPayload reqPayload = reqMessage.getPayload(); <line5> if (resourcePath.size() != 2 <line6> || reqPayload.getBody() == null <line7> || reqPayload.getBody().length == 0 <line8> || !resourcePath.get(0).equals(KEYSTORES)) { <line9> throw new KuraException(KuraErrorCode.BAD_REQUEST); <line10> } <line11> if (resourcePath.get(1).equals(ENTRIES)) { <line12> String body = new String(reqPayload.getBody(), StandardCharsets.UTF_8); <line13> EntryInfo request = unmarshal(body, EntryInfo.class); <line14> if (request != null) { <line15> deleteKeyEntryInternal(request.getKeystoreServicePid(), request.getAlias()); <line16> return new KuraMessage(new KuraResponsePayload(200)); <line17> } else { <line18> throw new KuraException(KuraErrorCode.BAD_REQUEST); <line19> } <line20> } else { <line21> throw new KuraException(KuraErrorCode.BAD_REQUEST); <line22> } <line23> } <line24> } <line25> 	 <line9>	Yes
"public class A { <line0> public synchronized boolean saveDataHostIndexToZk(String dataHost, int curIndex) { <line1> boolean result = false; <line2> try { <line3> try { <line4> dnindexLock.acquire(30, TimeUnit.SECONDS); <line5> String path = ZKUtils.getZKBasePath() + ""bindata/dnindex.properties""; <line6> Map<String, String> propertyMap = new HashMap<>(); <line7> propertyMap.put(dataHost, String.valueOf(curIndex)); <line8> result = ZKUtils.writeProperty(path, propertyMap); <line9> } finally { <line10> dnindexLock.release(); <line11> } <line12> } catch (Exception e) { <line13> } <line14> return result; <line15> } <line16> } <line17> "	 <line13>	Yes
"public class A { <line0> @Override <line1> public final boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) { <line2> if (environment == null) { <line3> return false; <line4> } <line5> try { <line6> if (annotations.isEmpty() == false) { <line7> run(annotations, roundEnv); <line8> } <line9> } catch (RuntimeException e) { <line10> environment <line11> .getProcessingEnvironment() <line12> .getMessager() <line13> .printMessage( <line14> Diagnostic.Kind.ERROR, <line15> MessageFormat.format( <line16> Messages.getString(""AbstractOperatorAnnotationProcessor.errorFailCompile""), <line17> e.toString())); <line18> } <line19> return false; <line20> } <line21> } <line22> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> sender.sendHeartbeat(); <line4> } catch (Throwable e) { <line5> } <line6> } <line7> } <line8> 	 <line2>	No
"public class A { <line0> public void log(UserData o) { <line1> Node n = o.getNode(); <line2> StringBuilder sb = new StringBuilder(); <line3> sb.append(n.getParent()); <line4> sb.append("" parent->""); <line5> sb.append(""(""); <line6> sb.append(n); <line7> sb.append("")->""); <line8> List<Spatial> children = n.getChildren(); <line9> for (int i = 0; i < children.size(); ++i) { <line10> sb.append(n.getChild(i)); <line11> if (i != children.size() - 1) { <line12> sb.append("",""); <line13> } <line14> } <line15> } <line16> } <line17> "	 <line15>	Yes
public class A { <line0> void extractUsageIfMatch(String value) { <line1> if (usagesKeyPattern != null) { <line2> Matcher m = usagesKeyPattern.matcher(currentKeyName); <line3> if (m.matches()) { <line4> if (usagesAnnotation == null || usagesKeepOrReplace) { <line5> usagesAnnotation = new UsagesAnnotation(new HashSet<>()); <line6> } <line7> usagesAnnotation.getUsages().add(value); <line8> } <line9> } <line10> } <line11> } <line12> 	 <line7>	No
public class A { <line0> @Override <line1> public void onFailure(IMqttToken token, Throwable throwable) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> public static void debug(Object msg, Object[] obj) { <line1> Logger logger = LogUtil.getLogger(); <line2> if (logger != null && logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	 <line4>	No
public class A { <line0> @Override <line1> public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception { <line2> RoomParticipant user = (RoomParticipant) session.getAttributes().get(USER); <line3> if (user != null && !user.isClosed()) { <line4> } <line5> } <line6> } <line7> 	 <line6>	No
"public class A { <line0> private void resolvePessimisticLock(BackOffer bo, Lock lock, Set<RegionVerID> cleanRegion) { <line1> while (true) { <line2> region = regionManager.getRegionByKey(lock.getKey()); <line3> if (cleanRegion.contains(region.getVerID())) { <line4> return; <line5> } <line6> final long forUpdateTS = <line7> lock.getLockForUpdateTs() == 0L ? Long.MAX_VALUE : lock.getLockForUpdateTs(); <line8> Supplier<Kvrpcpb.PessimisticRollbackRequest> factory = <line9> () -> <line10> Kvrpcpb.PessimisticRollbackRequest.newBuilder() <line11> .setContext(region.getContext()) <line12> .setStartVersion(lock.getTxnID()) <line13> .setForUpdateTs(forUpdateTS) <line14> .addKeys(lock.getKey()) <line15> .build(); <line16> KVErrorHandler<Kvrpcpb.PessimisticRollbackResponse> handler = <line17> new KVErrorHandler<>( <line18> regionManager, <line19> this, <line20> this, <line21> region, <line22> resp -> resp.hasRegionError() ? resp.getRegionError() : null, <line23> resp -> resp.getErrorsCount() > 0 ? resp.getErrorsList().get(0) : null, <line24> resolveLockResult -> null, <line25> 0L, <line26> false); <line27> Kvrpcpb.PessimisticRollbackResponse resp = <line28> callWithRetry(bo, TikvGrpc.getKVPessimisticRollbackMethod(), factory, handler); <line29> if (resp == null) { <line30> regionManager.onRequestFail(region); <line31> bo.doBackOff( <line32> BoRegionMiss, <line33> new TiClientInternalException(""getKVPessimisticRollbackMethod failed without a cause"")); <line34> continue; <line35> } <line36> if (resp.hasRegionError()) { <line37> bo.doBackOff(BoRegionMiss, new RegionException(resp.getRegionError())); <line38> continue; <line39> } <line40> if (resp.getErrorsCount() > 0) { <line41> throw new KeyException(resp.getErrorsList().get(0)); <line42> } <line43> } <line44> } <line45> } <line46> "	 <line6>	No
public class A { <line0> @Override <line1> public State calcState(Device dev) { <line2> TellstickDevice device = (TellstickDevice) dev; <line3> State st = null; <line4> switch (device.getStatus()) { <line5> case JNA.CLibrary.TELLSTICK_TURNON: <line6> st = OnOffType.ON; <line7> break; <line8> case JNA.CLibrary.TELLSTICK_TURNOFF: <line9> st = OnOffType.OFF; <line10> break; <line11> case JNA.CLibrary.TELLSTICK_DIM: <line12> BigDecimal dimValue = new BigDecimal(device.getData()); <line13> if (dimValue.intValue() == 0) { <line14> st = OnOffType.OFF; <line15> } else if (dimValue.intValue() >= 255) { <line16> st = OnOffType.ON; <line17> } else { <line18> st = OnOffType.ON; <line19> } <line20> break; <line21> default: <line22> } <line23> return st; <line24> } <line25> } <line26> 	 <line22>	Yes
public class A { <line0> @Override <line1> public void onContainerStarted( <line2> ContainerId containerId, Map<String, ByteBuffer> allServiceResponse) { <line3> controller.containerStarted(containerId); <line4> } <line5> } <line6> 	 <line3>	Yes
public class A { <line0> private void reindexSpaces(String index) throws ImejiException { <line1> ElasticIndexer indexer = <line2> new ElasticIndexer(index, ElasticTypes.spaces, ElasticService.ANALYSER); <line3> SpaceController controller = new SpaceController(); <line4> List<Space> items = controller.retrieveAll(); <line5> indexer.indexBatch(items); <line6> indexer.commit(); <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> private InputStream getKeyStoreStream() { <line1> final InputStream keyStoreStream; <line2> if (this.bbClientConfiguration.getKeystore().getLocation() == null) { <line3> keyStoreStream = BlueButtonClientImpl.class.getResourceAsStream(KEYSTORE_RESOURCE_KEY); <line4> if (keyStoreStream == null) { <line5> throw new BlueButtonClientSetupException( <line6> ""Unable to get keystore from resources"", <line7> new MissingResourceException( <line8> """", BlueButtonClientImpl.class.getName(), KEYSTORE_RESOURCE_KEY)); <line9> } <line10> } else { <line11> final String keyStorePath = this.bbClientConfiguration.getKeystore().getLocation(); <line12> try { <line13> keyStoreStream = new FileInputStream(keyStorePath); <line14> } catch (FileNotFoundException e) { <line15> throw new BlueButtonClientSetupException(""Unable to find keystore"", e); <line16> } <line17> } <line18> return keyStoreStream; <line19> } <line20> } <line21> "	 <line15>	Yes
public class A { <line0> @Deactivate <line1> protected void deactivate(ComponentContext context) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> private void writeCheckpoint(long nextSequenceNumber) { <line1> try { <line2> UfsJournalCheckpointWriter journalWriter = mJournal.getCheckpointWriter(nextSequenceNumber); <line3> try { <line4> synchronized (mCheckpointingLock) { <line5> if (mShutdownInitiated) { <line6> journalWriter.cancel(); <line7> return; <line8> } <line9> mCheckpointing = true; <line10> } <line11> mMaster.writeToCheckpoint(journalWriter); <line12> } catch (Throwable t) { <line13> if (ExceptionUtils.containsInterruptedException(t)) { <line14> Thread.currentThread().interrupt(); <line15> } else { <line16> } <line17> journalWriter.cancel(); <line18> return; <line19> } finally { <line20> synchronized (mCheckpointingLock) { <line21> mCheckpointing = false; <line22> } <line23> if (Thread.interrupted() && !mShutdownInitiated) { <line24> Thread.currentThread().interrupt(); <line25> } <line26> journalWriter.close(); <line27> } <line28> mNextSequenceNumberToCheckpoint = nextSequenceNumber; <line29> } catch (IOException e) { <line30> } <line31> } <line32> } <line33> 	 <line18>	Yes
"public class A { <line0> public static String getTypeString(Object o) { <line1> String typeValue = null; <line2> try { <line3> Field[] fields = o.getClass().getDeclaredFields(); <line4> for (int i = 0; i < fields.length && typeValue == null; i++) { <line5> Field field = fields[i]; <line6> if (field.getName().equals(""type"")) { <line7> try { <line8> String methodName = <line9> ""get"" <line10> + Character.toUpperCase(field.getName().charAt(0)) <line11> + field.getName().substring(1); <line12> typeValue = <line13> (String) <line14> o.getClass().getMethod(methodName, (Class[]) null).invoke(o, new Object[] {}); <line15> } catch (NoSuchMethodException e) { <line16> typeValue = (String) field.get(o); <line17> } <line18> } <line19> } <line20> } catch (Exception e) { <line21> } <line22> if (typeValue == null) { <line23> typeValue = """"; <line24> } <line25> return typeValue; <line26> } <line27> } <line28> "	 <line4>	No
"public class A { <line0> private void startMiniTajoCluster(File testBuildDir, final int numSlaves, boolean local) <line1> throws Exception { <line2> TajoConf c = getConfiguration(); <line3> c.setVar(ConfVars.TAJO_MASTER_CLIENT_RPC_ADDRESS, ""localhost:0""); <line4> c.setVar(ConfVars.TAJO_MASTER_UMBILICAL_RPC_ADDRESS, ""localhost:0""); <line5> c.setVar(ConfVars.RESOURCE_TRACKER_RPC_ADDRESS, ""localhost:0""); <line6> c.setVar(ConfVars.WORKER_PEER_RPC_ADDRESS, ""localhost:0""); <line7> c.setVar( <line8> ConfVars.WORKER_TEMPORAL_DIR, <line9> ""file://"" + testBuildDir.getAbsolutePath() + ""/tajo-localdir""); <line10> c.setVar(ConfVars.REST_SERVICE_ADDRESS, ""localhost:0""); <line11> if (!local) { <line12> String tajoRootDir = getMiniDFSCluster().getFileSystem().getUri().toString() + ""/tajo""; <line13> c.setVar(ConfVars.ROOT_DIR, tajoRootDir); <line14> URI defaultTsUri = TajoConf.getWarehouseDir(c).toUri(); <line15> FileTablespace defaultTableSpace = <line16> new FileTablespace(TablespaceManager.DEFAULT_TABLESPACE_NAME, defaultTsUri, null); <line17> defaultTableSpace.init(conf); <line18> TablespaceManager.addTableSpaceForTest(defaultTableSpace); <line19> } else { <line20> c.setVar(ConfVars.ROOT_DIR, ""file://"" + testBuildDir.getAbsolutePath() + ""/tajo""); <line21> } <line22> setupCatalogForTesting(c, testBuildDir); <line23> tajoMaster = new TajoMaster(); <line24> tajoMaster.init(c); <line25> tajoMaster.start(); <line26> this.conf.setVar(ConfVars.WORKER_PEER_RPC_ADDRESS, c.getVar(ConfVars.WORKER_PEER_RPC_ADDRESS)); <line27> this.conf.setVar( <line28> ConfVars.TAJO_MASTER_CLIENT_RPC_ADDRESS, c.getVar(ConfVars.TAJO_MASTER_CLIENT_RPC_ADDRESS)); <line29> InetSocketAddress tajoMasterAddress = <line30> tajoMaster.getContext().getTajoMasterService().getBindAddress(); <line31> this.conf.setVar( <line32> ConfVars.TAJO_MASTER_UMBILICAL_RPC_ADDRESS, NetUtils.getHostPortString(tajoMasterAddress)); <line33> this.conf.setVar( <line34> ConfVars.RESOURCE_TRACKER_RPC_ADDRESS, c.getVar(ConfVars.RESOURCE_TRACKER_RPC_ADDRESS)); <line35> this.conf.setVar(ConfVars.CATALOG_ADDRESS, c.getVar(ConfVars.CATALOG_ADDRESS)); <line36> InetSocketAddress tajoRestAddress = tajoMaster.getContext().getRestServer().getBindAddress(); <line37> this.conf.setVar(ConfVars.REST_SERVICE_ADDRESS, NetUtils.getHostPortString(tajoRestAddress)); <line38> startTajoWorkers(numSlaves); <line39> isTajoClusterRunning = true; <line40> LOG.info( <line41> ""====================================================================================""); <line42> LOG.info( <line43> ""====================================================================================""); <line44> } <line45> } <line46> "	 <line40>	Yes
"public class A { <line0> @SuppressWarnings(""synthetic-access"") <line1> public InitialImageAdvice adviseInitialImage( <line2> InitialImageAdvice previousAdvice, boolean persistent) { <line3> initializationGate(); <line4> if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_ADVISOR_VERBOSE)) { <line5> dumpProfiles(""AdviseInitialImage""); <line6> } <line7> Profile[] allProfiles = profiles; <line8> if (allProfiles.length == 0) { <line9> return new InitialImageAdvice(); <line10> } <line11> Set<InternalDistributedMember> replicates = new HashSet<>(); <line12> Set<InternalDistributedMember> others = new HashSet<>(); <line13> Set<InternalDistributedMember> preloaded = new HashSet<>(); <line14> Set<InternalDistributedMember> empties = new HashSet<>(); <line15> Set<InternalDistributedMember> uninitialized = new HashSet<>(); <line16> Set<InternalDistributedMember> nonPersistent = new HashSet<>(); <line17> Map<InternalDistributedMember, CacheProfile> memberProfiles = new HashMap<>(); <line18> for (Profile allProfile : allProfiles) { <line19> CacheProfile profile = (CacheProfile) allProfile; <line20> if (previousAdvice != null) { <line21> CacheProfile previousProfile = <line22> previousAdvice.memberProfiles.get(profile.getDistributedMember()); <line23> if (previousProfile != null <line24> && previousProfile.getSerialNumber() == profile.getSerialNumber() <line25> && previousProfile.getVersion() == profile.getVersion()) { <line26> continue; <line27> } <line28> } <line29> if (profile.getInRecovery()) { <line30> uninitialized.add(profile.getDistributedMember()); <line31> continue; <line32> } <line33> if (!profile.regionInitialized) { <line34> uninitialized.add(profile.getDistributedMember()); <line35> continue; <line36> } <line37> if (profile.dataPolicy.withReplication()) { <line38> if (!persistent || profile.dataPolicy.withPersistence()) { <line39> replicates.add(profile.getDistributedMember()); <line40> } else { <line41> nonPersistent.add(profile.getDistributedMember()); <line42> } <line43> memberProfiles.put(profile.getDistributedMember(), profile); <line44> } else if (profile.dataPolicy.isPreloaded()) { <line45> preloaded.add(profile.getDistributedMember()); <line46> memberProfiles.put(profile.getDistributedMember(), profile); <line47> } else if (profile.dataPolicy.withStorage()) { <line48> others.add(profile.getDistributedMember()); <line49> memberProfiles.put(profile.getDistributedMember(), profile); <line50> } else { <line51> empties.add(profile.getDistributedMember()); <line52> } <line53> } <line54> InitialImageAdvice advice = <line55> new InitialImageAdvice( <line56> replicates, others, preloaded, empties, uninitialized, nonPersistent, memberProfiles); <line57> if (logger.isDebugEnabled()) { <line58> } <line59> return advice; <line60> } <line61> } <line62> "	 <line61>	No
public class A { <line0> public boolean checkPermission(String permission) { <line1> return true; <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> private void loadExtensions() { <line1> for (InstalledExtension localExtension : this.installedRepository.getInstalledExtensions()) { <line2> if (XarExtensionHandler.TYPE.equalsIgnoreCase(localExtension.getType())) { <line3> try { <line4> XarInstalledExtension xarInstalledExtension = addCacheXarExtension(localExtension); <line5> if (xarInstalledExtension.getNamespaces() == null) { <line6> pagesUpdated(xarInstalledExtension, null, true); <line7> } else { <line8> for (String namespace : localExtension.getNamespaces()) { <line9> pagesUpdated(xarInstalledExtension, namespace, true); <line10> } <line11> } <line12> } catch (Exception e) { <line13> continue; <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	 <line6>	No
"public class A { <line0> @PostConstruct <line1> public void start() { <line2> if (configuration.getApi().isDisableApiServer()) { <line3> return; <line4> } <line5> registerLoginProvider(); <line6> registerRolesProvider(); <line7> ApiConfiguration apiConfiguration = configuration.getApi(); <line8> String[] args = <line9> new String[] { <line10> ""secret="" + apiConfiguration.getSecret(), <line11> ""on.address="" + apiConfiguration.getListen(), <line12> ""on.port="" + apiConfiguration.getPort() <line13> }; <line14> On.changes().ignore(); <line15> GuiceBeans beans = Integrate.guice(injector); <line16> App.run(args).auth(); <line17> App.register(beans); <line18> } <line19> } <line20> "	 <line3>	Yes
"public class A { <line0> @Override <line1> public void cmnRmMemberId(long drId, PersistentMemberID pmid) { <line2> DiskRegionView dr = getDiskRegionById(drId); <line3> if (dr != null) { <line4> if (!dr.rmOnlineMember(pmid)) { <line5> if (!dr.rmOfflineMember(pmid)) { <line6> dr.rmEqualMember(pmid); <line7> } <line8> } <line9> this.ifLiveRecordCount--; <line10> this.ifTotalRecordCount++; <line11> } else { <line12> if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY_VERBOSE)) { <line13> } else { <line14> throw new IllegalStateException(""bad disk region id""); <line15> } <line16> } <line17> } <line18> } <line19> "	 <line13>	Yes
public class A { <line0> private int stageBundleForServing(BundleDeployStatus status, String s3Path) { <line1> int bundlesDownloaded = 0; <line2> List<String> bundles = listFiles(s3Path, MAX_RESULTS); <line3> if (bundles != null && !bundles.isEmpty()) { <line4> clearBundleStagingDirectory(); <line5> } else { <line6> return bundlesDownloaded; <line7> } <line8> for (String bundle : bundles) { <line9> String bundleFilename = parseFileName(bundle); <line10> get(bundle, _localBundleStagingPath); <line11> try { <line12> String bundleFileLocation = _localBundleStagingPath + File.separator + bundleFilename; <line13> _fileUtil.unGzip(new File(bundleFileLocation), new File(_localBundleStagingPath)); <line14> String tarFilename = parseTarName(bundleFileLocation); <line15> _fileUtil.unTar(new File(tarFilename), new File(_localBundleStagingPath)); <line16> status.addBundleName(bundleFilename); <line17> new File(tarFilename).delete(); <line18> new File(bundleFileLocation).delete(); <line19> bundlesDownloaded++; <line20> } catch (Exception e) { <line21> } <line22> } <line23> status.setStatus(BundleDeployStatus.STATUS_COMPLETE); <line24> return bundlesDownloaded; <line25> } <line26> } <line27> 	 <line14>	No
"public class A { <line0> @Test <line1> public void testMappedFeature() { <line2> String path = <line3> ""wfs?request=GetFeature&version=1.1.0&typeName=gsml:MappedFeature&featureid=gsml.mappedfeature.195201,gsml.mappedfeature.192654,gsml.mappedfeature.191921,gsml.mappedfeature.179239,gsml.mappedfeature.185969,gsml.mappedfeature.186037,gsml.mappedfeature.185817,gsml.mappedfeature.185911,gsml.mappedfeature.178855,gsml.mappedfeature.185608""; <line4> validateGet(path); <line5> Document doc = getAsDOM(path); <line6> if (printDoc) { <line7> } <line8> assertXpathEvaluatesTo(""10"", ""//wfs:FeatureCollection/@numberOfFeatures"", doc); <line9> assertXpathCount(10, ""//gsml:MappedFeature"", doc); <line10> assertXpathEvaluatesTo( <line11> ""previous mapping"", <line12> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.179239']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value"", <line13> doc); <line14> assertXpathEvaluatesTo( <line15> ""urn:cgi:classifierScheme:GSV:InterpretationMethod"", <line16> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.179239']/gsml:observationMethod/gsml:CGI_TermValue/gsml:value/@codeSpace"", <line17> doc); <line18> assertXpathEvaluatesTo( <line19> ""approximate"", <line20> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185608']/gsml:positionalAccuracy/gsml:CGI_TermValue/gsml:value"", <line21> doc); <line22> assertXpathEvaluatesTo( <line23> ""urn:cgi:classifierScheme:GSV:PositionalAccuracy"", <line24> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185608']/gsml:positionalAccuracy/gsml:CGI_TermValue/gsml:value/@codeSpace"", <line25> doc); <line26> assertXpathEvaluatesTo( <line27> ""urn:cgi:feature:CGI:EarthNaturalSurface"", <line28> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185911']/gsml:samplingFrame/@xlink:href"", <line29> doc); <line30> ArrayList<String> specs = new ArrayList<>(); <line31> for (int i = 1; i <= 10; i++) { <line32> specs.add( <line33> this.evaluate( <line34> ""/wfs:FeatureCollection/gml:featureMember["" <line35> + i <line36> + ""]/gsml:MappedFeature/gsml:specification/@xlink:href"", <line37> doc)); <line38> } <line39> int[] countType = new int[3]; <line40> for (String spec : specs) { <line41> if (spec.contains(""ShearDisplacementStructure"")) { <line42> countType[0]++; <line43> } <line44> if (spec.contains(""GeologicUnit"")) { <line45> countType[1]++; <line46> } <line47> if (spec.contains(""Contact"")) { <line48> countType[2]++; <line49> } <line50> } <line51> assertEquals(5, countType[0]); <line52> assertEquals(3, countType[1]); <line53> assertEquals(2, countType[2]); <line54> String expected = <line55> ""-38.410785700000325 143.86545265833303 -38.40925703333365 143.86857949166634""; <line56> String actual = <line57> evaluate( <line58> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.179239']/gsml:shape/gml:MultiCurve/gml:curveMember/gml:LineString/gml:posList"", <line59> doc); <line60> assertTrue(this.isEqualGeometry(actual, expected, 5)); <line61> expected = ""-38.139133550000324 144.2364237333331 -38.13991570000029 144.2415325499997""; <line62> actual = <line63> evaluate( <line64> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.185969']/gsml:shape/gml:MultiCurve/gml:curveMember/gml:LineString/gml:posList"", <line65> doc); <line66> assertTrue(this.isEqualGeometry(actual, expected, 5)); <line67> assertXpathEvaluatesTo( <line68> ""2"", <line69> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.192654']/gsml:shape/gml:MultiSurface/@srsDimension"", <line70> doc); <line71> expected = <line72> ""-37.469102166666666 143.76702998333334 -37.470454841666665 143.76797201666668 -37.4716163"" <line73> + "" 143.76817698333332 -37.472777758333336 143.7679037 -37.473939216666665"" <line74> + "" 143.76776705833333 -37.475100675 143.76797201666668 -37.475715566666665"" <line75> + "" 143.76899683333335 -37.476877025 143.76927011666666 -37.478038483333336"" <line76> + "" 143.76933844166666 -37.4790633 143.76988500833335 -37.480224766666666"" <line77> + "" 143.76974836666668 -37.480293083333336 143.76858690833333 -37.480088125"" <line78> + "" 143.76742545 -37.478516733333336 143.76571741666666 -37.479336591666666"" <line79> + "" 143.76489756666666 -37.47954155 143.76257465 -37.480429725 143.76332618333333"" <line80> + "" -37.481591183333336 143.7633945 -37.482684325 143.76291625 -37.483367533333336"" <line81> + "" 143.760729975 -37.4835725 143.75956851666666 -37.48364083333333 143.75840705833335"" <line82> + "" -37.483504175 143.7572456 -37.482889291666666 143.75622078333333 -37.48213775833334"" <line83> + "" 143.75533260833333 -37.481864475 143.75417114166666 -37.4822744 143.751848225"" <line84> + "" -37.4822744 143.75068676666666 -37.48213775833334 143.74952530833335"" <line85> + "" -37.479814833333336 143.749252025 -37.479609875 143.74809055833333 -37.47954155"" <line86> + "" 143.7469291 -37.47865338333333 143.74617756666666 -37.477560241666666"" <line87> + "" 143.74583596666668 -37.47721863333334 143.744742825 -37.47721863333334"" <line88> + "" 143.74358136666666 -37.47694535 143.74241990833335 -37.476193808333335"" <line89> + "" 143.740233625 -37.476193808333335 143.73907216666666 -37.476398775"" <line90> + "" 143.73791070833335 -37.4774236 143.73579275 -37.476877025 143.73476793333333"" <line91> + "" -37.4764671 143.7336748 -37.475783891666666 143.7327183 -37.474827391666665"" <line92> + "" 143.730532025 -37.474622425 143.72937056666666 -37.474554108333336"" <line93> + "" 143.72820910833335 -37.474622425 143.7265694 -37.473460966666664 143.7265694"" <line94> + "" -37.47236784166667 143.726979325 -37.471547975 143.727799175 -37.470386516666665"" <line95> + "" 143.727799175 -37.469293375 143.72738925 -37.4684052 143.72663771666666"" <line96> + "" -37.468131916666664 143.72547625833334 -37.467312066666665 143.72445143333334"" <line97> + "" -37.466355566666664 143.72410983333333 -37.465262433333336 143.72438313333333"" <line98> + "" -37.464784183333336 143.72547625833334 -37.464647541666665 143.72663771666666"" <line99> + "" -37.464784183333336 143.727799175 -37.465262433333336 143.72889231666667 -37.465809"" <line100> + "" 143.72991713333334 -37.466492208333335 143.73087363333335 -37.467380383333335"" <line101> + "" 143.73169348333334 -37.469498341666664 143.734426325 -37.4703182 143.73531450833335"" <line102> + "" -37.470933083333335 143.736339325 -37.472299508333336 143.73825231666666"" <line103> + "" -37.473051041666665 143.73914049166666 -37.474075858333336 143.74125845"" <line104> + "" -37.474417466666665 143.74235158333335 -37.474485783333336 143.74351304166666"" <line105> + "" -37.474759075 143.74467450833333 -37.47544228333334 143.745631 -37.475783891666666"" <line106> + "" 143.74672414166668 -37.47598885 143.7478856 -37.4764671 143.74897873333333"" <line107> + "" -37.476535425 143.75246311666666 -37.476125491666664 143.75355625833333 -37.4755106"" <line108> + "" 143.754581075 -37.473597608333336 143.75594749166666 -37.472777758333336"" <line109> + "" 143.75676735 -37.472299508333336 143.75786048333333 -37.47236784166667"" <line110> + "" 143.76018340833332 -37.47209455 143.76134486666666 -37.469293375 143.76517085"" <line111> + "" -37.469020091666664 143.76633230833335 -37.469102166666666 143.76702998333334""; <line112> actual = <line113> evaluate( <line114> ""//gsml:MappedFeature[@gml:id='gsml.mappedfeature.192654']/gsml:shape/gml:MultiSurface/gml:surfaceMember/gml:Polygon/gml:exterior/gml:LinearRing/gml:posList"", <line115> doc); <line116> assertTrue(this.isEqualGeometry(actual, expected, 5)); <line117> } <line118> } <line119> "	 <line32>	No
public class A { <line0> @Override <line1> public void telegramReceived(P1Telegram telegram) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> final Entry<Collection<DSMRMeterDescriptor>, Map<CosemObjectType, CosemObject>> detectedMeters = <line5> meterDetector.detectMeters(telegram); <line6> verifyUnregisteredCosemObjects(telegram, detectedMeters.getValue()); <line7> validateConfiguredMeters( <line8> dsmrBridgeHandler.getThing().getThings(), <line9> detectedMeters.getKey().stream().map(md -> md.getMeterType()).collect(Collectors.toSet())); <line10> detectedMeters.getKey().forEach(m -> meterDiscovered(m, dsmrBridgeHandler.getThing().getUID())); <line11> } <line12> } <line13> 	 <line10>	No
public class A { <line0> public synchronized void addCamelComponentForWonNodeBrokerForTopics( <line1> URI brokerUri, String brokerComponentName) { <line2> ActiveMQComponent activeMQComponent; <line3> if (getCamelContext().getComponent(brokerComponentName) == null) { <line4> activeMQComponent = <line5> (ActiveMQComponent) <line6> brokerComponentFactory.getBrokerComponent( <line7> brokerUri, MessagingType.Topic, getMessagingContext()); <line8> activeMQComponent.setTransacted(false); <line9> activeMQComponent.setUsePooledConnection(true); <line10> getCamelContext().addComponent(brokerComponentName, activeMQComponent); <line11> try { <line12> activeMQComponent.start(); <line13> } catch (Exception e) { <line14> } <line15> } <line16> brokerComponentMap.put(brokerUri, brokerComponentName); <line17> } <line18> } <line19> 	 <line13>	No
public class A { <line0> private static void setKeyManagers(TLSClientParameters tlsClientParameters) { <line1> try { <line2> KeyManagerFactory keyFactory = getInstance().keyFactory; <line3> if (keyFactory != null) { <line4> KeyManager[] keyManager = keyFactory.getKeyManagers(); <line5> if (keyManager != null) { <line6> tlsClientParameters.setKeyManagers(keyManager); <line7> } <line8> } else { <line9> } <line10> } catch (IllegalStateException e) { <line11> } <line12> } <line13> } <line14> 	 <line11>	Yes
public class A { <line0> @Override <line1> protected void doInTransactionWithoutResult(TransactionStatus theArg0) { <line2> int maxResult = 1000; <line3> Page<TermConcept> concepts = <line4> myConceptDao.findResourcesRequiringReindexing(PageRequest.of(0, maxResult)); <line5> if (!concepts.hasContent()) { <line6> if (myChildToParentPidCache != null) { <line7> myChildToParentPidCache = null; <line8> } <line9> return; <line10> } <line11> if (myChildToParentPidCache == null) { <line12> myChildToParentPidCache = ArrayListMultimap.create(); <line13> } <line14> int count = 0; <line15> StopWatch stopwatch = new StopWatch(); <line16> for (TermConcept nextConcept : concepts) { <line17> if (isBlank(nextConcept.getParentPidsAsString())) { <line18> StringBuilder parentsBuilder = new StringBuilder(); <line19> createParentsString(parentsBuilder, nextConcept.getId()); <line20> nextConcept.setParentPids(parentsBuilder.toString()); <line21> } <line22> myConceptStorageSvc.saveConcept(nextConcept); <line23> count++; <line24> } <line25> } <line26> } <line27> 	 <line14>	Yes
public class A { <line0> private int getRemotePathCount( <line1> PartitionGroup partitionGroup, List<String> pathsToQuery, int level) <line2> throws MetadataException { <line3> List<Node> coordinatedNodes = QueryCoordinator.getINSTANCE().reorderNodes(partitionGroup); <line4> for (Node node : coordinatedNodes) { <line5> try { <line6> Integer count; <line7> if (ClusterDescriptor.getInstance().getConfig().isUseAsyncServer()) { <line8> AsyncDataClient client = <line9> metaGroupMember <line10> .getClientProvider() <line11> .getAsyncDataClient(node, RaftServer.getReadOperationTimeoutMS()); <line12> client.setTimeout(RaftServer.getReadOperationTimeoutMS()); <line13> count = <line14> SyncClientAdaptor.getPathCount( <line15> client, partitionGroup.getHeader(), pathsToQuery, level); <line16> } else { <line17> try (SyncDataClient syncDataClient = <line18> metaGroupMember <line19> .getClientProvider() <line20> .getSyncDataClient(node, RaftServer.getReadOperationTimeoutMS())) { <line21> syncDataClient.setTimeout(RaftServer.getReadOperationTimeoutMS()); <line22> count = syncDataClient.getPathCount(partitionGroup.getHeader(), pathsToQuery, level); <line23> } <line24> } <line25> if (count != null) { <line26> return count; <line27> } <line28> } catch (IOException | TException e) { <line29> throw new MetadataException(e); <line30> } catch (InterruptedException e) { <line31> Thread.currentThread().interrupt(); <line32> throw new MetadataException(e); <line33> } <line34> } <line35> return 0; <line36> } <line37> } <line38> 	 <line11>	No
"public class A { <line0> public static void sendErrorMail(String code, String errorMsg) { <line1> Response clientResponse = null; <line2> Client client = ClientBuilder.newBuilder().register(JacksonFeature.class).build(); <line3> try { <line4> WebTarget webResource = <line5> client.target( <line6> AnalyticsConfigurator.getInstance() <line7> .getProperty(AnalyticsConfigurationProperty.TAGGER_REST_URI) <line8> + ""/misc/sendErrorEmail""); <line9> Form form = new Form(); <line10> form.param(""module"", ""AIDRAnalytics""); <line11> form.param(""code"", code); <line12> form.param(""description"", errorMsg); <line13> clientResponse = <line14> webResource <line15> .request() <line16> .post(Entity.entity(form, MediaType.APPLICATION_FORM_URLENCODED), Response.class); <line17> if (clientResponse.getStatus() != 200) { <line18> } <line19> } catch (Exception e) { <line20> } <line21> } <line22> } <line23> "	 <line5>	No
"public class A { <line0> @Override <line1> public boolean disenrollDevice(DeviceIdentifier deviceId) throws DeviceManagementException { <line2> boolean status; <line3> try { <line4> if (log.isDebugEnabled()) { <line5> } <line6> DeviceTypeDAO.beginTransaction(); <line7> status = deviceTypeDAO.getDeviceTypeDAO().deleteDevice(deviceId.getId()); <line8> DeviceTypeDAO.commitTransaction(); <line9> } catch (DeviceMgtPluginException e) { <line10> try { <line11> DeviceTypeDAO.rollbackTransaction(); <line12> } catch (DeviceMgtPluginException iotDAOEx) { <line13> String msg = <line14> ""Error occurred while roll back the device dis enrol transaction :"" <line15> + deviceId.toString(); <line16> } <line17> String msg = ""Error while removing the sampledevice device : "" + deviceId.getId(); <line18> throw new DeviceManagementException(msg, e); <line19> } <line20> return status; <line21> } <line22> } <line23> "	 <line17>	No
"public class A { <line0> public int doMove(PrintStream resultOs, PrintStream logOs) throws Exception { <line1> for (int retryTimes = 0; retryTimes < maxRetryTimes; retryTimes++) { <line2> final AtomicInteger running = new AtomicInteger(0); <line3> for (final ReplicaMove replicaMove : allMoves) { <line4> moveExecutor.execute( <line5> new Runnable() { <line6> @Override <line7> public void run() { <line8> try { <line9> running.incrementAndGet(); <line10> replicaMove.run(); <line11> } finally { <line12> running.decrementAndGet(); <line13> } <line14> } <line15> }); <line16> if (maxConcurrentMovesPerInst != 0) { <line17> while (running.get() > (maxConcurrentMovesPerInst * 1.0 / instances.get())) { <line18> Thread.sleep(50); <line19> } <line20> } <line21> } <line22> int sleeped = 0; <line23> int[] stat = new int[2]; <line24> while (true) { <line25> ReplicaMove.countStatus(allMoves, stat); <line26> if (stat[0] == allMoves.size()) { <line27> status.increaseMovedBlocks(stat[1]); <line28> break; <line29> } <line30> Thread.sleep(10); <line31> sleeped += 10; <line32> } <line33> int remaining = ReplicaMove.refreshMoverList(allMoves); <line34> if (allMoves.size() == 0) { <line35> return 0; <line36> } <line37> if (logOs != null) { <line38> logOs.println( <line39> String.format( <line40> ""The %d/%d retry, remaining = %d"", retryTimes + 1, maxRetryTimes, remaining)); <line41> } <line42> if (sleeped < 1000) { <line43> Thread.sleep(1000 - sleeped); <line44> } <line45> } <line46> int failedMoves = ReplicaMove.failedMoves(allMoves); <line47> return failedMoves; <line48> } <line49> } <line50> "	 <line35>	Yes
"public class A { <line0> @Test <line1> public void testAggregateProcessDefinitions() throws Exception { <line2> String xml1 = read(this.getClass().getResourceAsStream(""/jaxb/process-def-1.xml"")); <line3> String xml2 = read(this.getClass().getResourceAsStream(""/jaxb/process-def-2.xml"")); <line4> JaxbXMLResponseAggregator aggregate = new JaxbXMLResponseAggregator(); <line5> List<String> data = new ArrayList<>(); <line6> data.add(xml1); <line7> data.add(xml2); <line8> String result = aggregate.aggregate(data); <line9> Document xml = toXml(result); <line10> assertNotNull(xml); <line11> NodeList processes = xml.getElementsByTagName(""process-definitions""); <line12> assertNotNull(processes); <line13> assertEquals(1, processes.getLength()); <line14> NodeList processDefs = xml.getElementsByTagName(""processes""); <line15> assertNotNull(processDefs); <line16> assertEquals(5, processDefs.getLength()); <line17> } <line18> } <line19> "	 <line9>	Yes
public class A { <line0> private void scheduleConnectionMonitorJob() { <line1> connectionMonitorJob = <line2> scheduler.scheduleWithFixedDelay( <line3> connectionMonitorRunnable, <line4> CONNECTION_MONITOR_START_DELAY, <line5> CONNECTION_MONITOR_FREQUENCY, <line6> TimeUnit.SECONDS); <line7> } <line8> } <line9> 	 <line1>	Yes
"public class A { <line0> public static void main(String[] args) { <line1> try { <line2> String port = ""COM10""; <line3> LoggingFactory.init(Level.INFO); <line4> MrlComm arduino = (MrlComm) Runtime.start(""arduino"", ""MrlComm""); <line5> Servo servo01 = (Servo) Runtime.start(""servo01"", ""Servo""); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> "	 <line4>	No
"public class A { <line0> @SuppressWarnings(""deprecation"") <line1> protected void internalUnsubscribeNamespaceBundle( <line2> String subscription, String bundleRange, boolean authoritative) { <line3> validateNamespaceOperation(namespaceName, NamespaceOperation.UNSUBSCRIBE); <line4> checkNotNull(subscription, ""Subscription should not be null""); <line5> checkNotNull(bundleRange, ""BundleRange should not be null""); <line6> Policies policies = getNamespacePolicies(namespaceName); <line7> if (namespaceName.isGlobal()) { <line8> validateGlobalNamespaceOwnership(namespaceName); <line9> } else { <line10> validateClusterOwnership(namespaceName.getCluster()); <line11> validateClusterForTenant(namespaceName.getTenant(), namespaceName.getCluster()); <line12> } <line13> validateNamespaceBundleOwnership( <line14> namespaceName, policies.bundles, bundleRange, authoritative, true); <line15> unsubscribe(namespaceName, bundleRange, subscription); <line16> } <line17> } <line18> "	 <line16>	Yes
"public class A { <line0> @RequestMapping(value = ""/api/samples/{sampleId}/metadata"", method = RequestMethod.GET) <line1> public ModelMap getSampleMetadata(@PathVariable Long sampleId) { <line2> ModelMap modelMap = new ModelMap(); <line3> Sample s = sampleService.read(sampleId); <line4> Set<MetadataEntry> metadataForSample = sampleService.getMetadataForSample(s); <line5> SampleMetadataResponse response = buildSampleMetadataResponse(s, metadataForSample); <line6> modelMap.addAttribute(RESTGenericController.RESOURCE_NAME, response); <line7> return modelMap; <line8> } <line9> } <line10> "	 <line9>	No
public class A { <line0> @Override <line1> public void moveTo(final double x, final double y) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> final Path2D subPath = new Path2D.Double(); <line5> final Point2D p = transformation_.transform(new Point2D.Double(x, y), null); <line6> subPath.moveTo(p.getX(), p.getY()); <line7> subPaths_.add(subPath); <line8> } <line9> } <line10> 	 <line5>	No
"public class A { <line0> private String createItemInAuthority( <line1> AuthorityClient client, String vcsid, String shortId, String authRefName) { <line2> final String testName = ""createItemInAuthority("" + vcsid + "","" + authRefName + "")""; <line3> if (logger.isDebugEnabled()) { <line4> } <line5> Map<String, String> taxonMap = new HashMap<String, String>(); <line6> taxonMap.put(TaxonJAXBSchema.SHORT_IDENTIFIER, shortId); <line7> taxonMap.put(TaxonJAXBSchema.TERM_STATUS, TEST_TERM_STATUS); <line8> taxonMap.put(TaxonJAXBSchema.NAME, TEST_TAXON_FULL_NAME); <line9> taxonMap.put(TaxonJAXBSchema.TAXON_RANK, TEST_TAXON_RANK); <line10> taxonMap.put(TaxonJAXBSchema.TAXON_CURRENCY, TEST_TAXON_CURRENCY); <line11> taxonMap.put(TaxonJAXBSchema.TAXON_YEAR, TEST_TAXON_YEAR); <line12> taxonMap.put(TaxonJAXBSchema.TAXONOMIC_STATUS, TEST_TAXONOMIC_STATUS); <line13> taxonMap.put(TaxonJAXBSchema.TAXON_IS_NAMED_HYBRID, TEST_TAXON_IS_NAMED_HYBRID); <line14> TaxonCitationList taxonCitationList = new TaxonCitationList(); <line15> List<String> taxonCitations = taxonCitationList.getTaxonCitation(); <line16> taxonCitations.add(TEST_TAXON_CITATION); <line17> TaxonAuthorGroupList taxonAuthorGroupList = new TaxonAuthorGroupList(); <line18> List<TaxonAuthorGroup> taxonAuthorGroups = taxonAuthorGroupList.getTaxonAuthorGroup(); <line19> TaxonAuthorGroup taxonAuthorGroup = new TaxonAuthorGroup(); <line20> taxonAuthorGroup.setTaxonAuthor(TEST_TAXON_AUTHOR); <line21> taxonAuthorGroup.setTaxonAuthorType(TEST_TAXON_AUTHOR_TYPE); <line22> taxonAuthorGroups.add(taxonAuthorGroup); <line23> CommonNameGroupList commonNameGroupList = new CommonNameGroupList(); <line24> List<CommonNameGroup> commonNameGroups = commonNameGroupList.getCommonNameGroup(); <line25> CommonNameGroup commonNameGroup = new CommonNameGroup(); <line26> commonNameGroup.setCommonName(TEST_TAXON_FULL_NAME); <line27> commonNameGroups.add(commonNameGroup); <line28> String newID = <line29> TaxonomyAuthorityClientUtils.createItemInAuthority( <line30> vcsid, <line31> authRefName, <line32> taxonMap, <line33> NULL_TAXON_TERMS_LIST, <line34> taxonAuthorGroupList, <line35> taxonCitationList, <line36> commonNameGroupList, <line37> (TaxonomyAuthorityClient) client); <line38> if (knownItemResourceId == null) { <line39> setKnownItemResource(newID, shortId); <line40> if (logger.isDebugEnabled()) { <line41> } <line42> } <line43> allResourceItemIdsCreated.put(newID, vcsid); <line44> return newID; <line45> } <line46> } <line47> "	 <line4>	Yes
public class A { <line0> private Path createIfNotExistsDirectory(Path pathToDir) { <line1> try { <line2> if (!Files.exists(pathToDir)) Files.createDirectory(pathToDir); <line3> } catch (IOException e) { <line4> } <line5> return pathToDir; <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> private StreamResponse writeNdjsonResponse(final String id, final Consumer<Writer> writeCall) { <line1> return asStream(id) <line2> .header(""Pragma"", ""no-cache"") <line3> .header(""Cache-Control"", ""no-cache"") <line4> .header(""Expires"", ""Thu, 01 Dec 1994 16:00:00 GMT"") <line5> .header(""Content-Type"", ""application/x-ndjson"") <line6> .stream( <line7> out -> { <line8> try (final Writer writer = <line9> new BufferedWriter( <line10> new OutputStreamWriter(out.stream(), Constants.CHARSET_UTF_8))) { <line11> writeCall.accept(writer); <line12> writer.flush(); <line13> } catch (final Exception e) { <line14> } <line15> }); <line16> } <line17> } <line18> "	 <line8>	No
public class A { <line0> protected void resetAuthentication() { <line1> authenticationToken = emptyAuthenticationToken; <line2> return; <line3> } <line4> } <line5> 	 <line1>	Yes
public class A { <line0> private void replicate(final IndexedRaftLogEntry indexed, final AppendListener appendListener) { <line1> raft.checkThread(); <line2> appender <line3> .appendEntries(indexed.index()) <line4> .whenCompleteAsync( <line5> (commitIndex, commitError) -> { <line6> if (!isRunning()) { <line7> return; <line8> } <line9> if (commitError == null) { <line10> appendListener.onCommit(indexed); <line11> raft.notifyCommitListeners(indexed.index()); <line12> } else { <line13> appendListener.onCommitError(indexed, commitError); <line14> } <line15> }, <line16> raft.getThreadContext()); <line17> } <line18> } <line19> 	 <line14>	Yes
public class A { <line0> public List<String> get() { <line1> if (!this.loggedBasePackageInfo) { <line2> if (this.packages.isEmpty()) { <line3> if (logger.isWarnEnabled()) { <line4> } <line5> } else { <line6> if (logger.isDebugEnabled()) { <line7> String packageNames = StringUtils.collectionToCommaDelimitedString(this.packages); <line8> } <line9> } <line10> this.loggedBasePackageInfo = true; <line11> } <line12> return this.packages; <line13> } <line14> } <line15> 	 <line7>	No
public class A { <line0> @Override <line1> public Boolean run(final Session<?> session) throws BackgroundException { <line2> final DistributionConfiguration feature = session.getFeature(DistributionConfiguration.class); <line3> if (log.isDebugEnabled()) { <line4> } <line5> final PathContainerService container = session.getFeature(PathContainerService.class); <line6> for (Path file : this.getContainers(container, files)) { <line7> if (this.isCanceled()) { <line8> throw new ConnectionCanceledException(); <line9> } <line10> write(feature, file); <line11> } <line12> return true; <line13> } <line14> } <line15> 	 <line11>	No
public class A { <line0> private void startUpdateProcessorTimeJob() { <line1> if (updateTimeJob != null) { <line2> updateTimeJob.cancel(false); <line3> updateTimeJob = null; <line4> } <line5> updateTimeJob = <line6> scheduler.scheduleWithFixedDelay(() -> updateProcessorTime(), 0, 1, TimeUnit.DAYS); <line7> } <line8> } <line9> 	 <line6>	No
public class A { <line0> @Override <line1> protected String getSEQWARE_PASSWORD() { <line2> if (settings.containsKey(SqwKeys.BASIC_TEST_DB_PASSWORD.getSettingKey())) { <line3> return settings.get(SqwKeys.BASIC_TEST_DB_PASSWORD.getSettingKey()); <line4> } <line5> return super.getSEQWARE_PASSWORD(); <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void accept(AisMessage message) { <line2> try { <line3> queue.push(message); <line4> } catch (MessageQueueOverflowException e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> @Override <line1> public DLSyncEvent remove(Serializable primaryKey) throws NoSuchEventException { <line2> Session session = null; <line3> try { <line4> session = openSession(); <line5> DLSyncEvent dlSyncEvent = (DLSyncEvent) session.get(DLSyncEventImpl.class, primaryKey); <line6> if (dlSyncEvent == null) { <line7> if (_log.isDebugEnabled()) { <line8> } <line9> throw new NoSuchEventException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line10> } <line11> return remove(dlSyncEvent); <line12> } catch (NoSuchEventException noSuchEntityException) { <line13> throw noSuchEntityException; <line14> } catch (Exception exception) { <line15> throw processException(exception); <line16> } finally { <line17> closeSession(session); <line18> } <line19> } <line20> } <line21> 	 <line7>	No
public class A { <line0> @Override <line1> protected DynRealmTO resolveReference(final Method method, final Object... args) <line2> throws UnresolvedReferenceException { <line3> String key = null; <line4> if (ArrayUtils.isNotEmpty(args)) { <line5> for (int i = 0; key == null && i < args.length; i++) { <line6> if (args[i] instanceof String) { <line7> key = (String) args[i]; <line8> } else if (args[i] instanceof DynRealmTO) { <line9> key = ((DynRealmTO) args[i]).getKey(); <line10> } <line11> } <line12> } <line13> if (key != null) { <line14> try { <line15> return binder.getDynRealmTO(dynRealmDAO.find(key)); <line16> } catch (Throwable ignore) { <line17> throw new UnresolvedReferenceException(ignore); <line18> } <line19> } <line20> throw new UnresolvedReferenceException(); <line21> } <line22> } <line23> 	 <line17>	Yes
"public class A { <line0> @Test <line1> public void testClassLdapConnectionPool() { <line2> LdapConnection ldapConnection = null; <line3> TrackingLdapConnectionFactory factory = (TrackingLdapConnectionFactory) ldapConnectionFactory; <line4> try { <line5> ldapConnection = ldapConnectionPool.getConnection(); <line6> assertEquals(1, factory.getBindCalled()); <line7> } catch (LdapException e) { <line8> fail(e.getMessage()); <line9> } finally { <line10> if (ldapConnection != null) { <line11> try { <line12> ldapConnectionPool.releaseConnection(ldapConnection); <line13> assertEquals(1, factory.getBindCalled()); <line14> } catch (LdapException e) { <line15> fail(""failed to release connection: "" + e.getMessage()); <line16> } <line17> } <line18> } <line19> try { <line20> ldapConnection = ldapConnectionPool.getConnection(); <line21> assertEquals(1, factory.getBindCalled()); <line22> ldapConnection.bind(ServerDNConstants.ADMIN_SYSTEM_DN, ""secret""); <line23> assertEquals(1, factory.getBindCalled()); <line24> } catch (LdapException e) { <line25> fail(e.getMessage()); <line26> } finally { <line27> if (ldapConnection != null) { <line28> try { <line29> ldapConnectionPool.releaseConnection(ldapConnection); <line30> assertEquals(2, factory.getBindCalled()); <line31> } catch (LdapException e) { <line32> fail(""failed to release connection: "" + e.getMessage()); <line33> } <line34> } <line35> } <line36> } <line37> } <line38> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public void process(Exchange exchange) throws Exception { <line2> Object body = exchange.getIn().getBody(); <line3> try { <line4> ObjectNode node = MAPPER.createObjectNode(); <line5> node.put(MESSAGE_ATTRIBUTE, body.toString()); <line6> String newBody = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(node); <line7> exchange.getIn().setBody(newBody); <line8> } catch (Exception ex) { <line9> throw new IllegalStateException( <line10> ""Failed to post-process the TemplateStep's message into JSON"", ex); <line11> } <line12> } <line13> } <line14> "	 <line4>	No
"public class A { <line0> @Override <line1> protected File produceResource(URL aUrl) throws IOException { <line2> Properties metadata = getResourceMetaData(); <line3> SingletonTagset morphFeats = <line4> new SingletonTagset(MorphologicalFeatures.class, metadata.getProperty(""morph.tagset"")); <line5> try (LittleEndianDataInputStream is = new LittleEndianDataInputStream(aUrl.openStream())) { <line6> byte type = is.readByte(); <line7> if (type != 0x63) { <line8> throw new IOException(""Incompatible model. Must be a compact model.""); <line9> } <line10> byte enc = is.readByte(); <line11> short n = is.readShort(); <line12> for (int i = 0; i < n; i++) { <line13> @SuppressWarnings(""unused"") <line14> int idx = is.readShort(); <line15> String symbol = readZeroTerminatedString(is, ""UTF-8""); <line16> if (symbol.startsWith(""<"") && symbol.endsWith("">"") && symbol.length() > 2) { <line17> morphFeats.add(symbol); <line18> } <line19> } <line20> } <line21> addTagset(morphFeats); <line22> if (printTagSet) { <line23> } <line24> return ResourceUtils.getUrlAsFile(aUrl, true); <line25> } <line26> } <line27> "	 <line23>	Yes
public class A { <line0> public void setSessionId(String sessionId) { <line1> this.sessionId = sessionId; <line2> if (sessionId.isEmpty()) { <line3> setUserState(UserState.Disconnected); <line4> lostConnection(); <line5> } else if (userState == UserState.Created) { <line6> setUserState(UserState.Connected); <line7> } else { <line8> setUserState(UserState.Connected); <line9> reconnect(); <line10> } <line11> } <line12> } <line13> 	 <line4>	No
"public class A { <line0> @Override <line1> public void initialize(URI name, Configuration conf) throws IOException { <line2> super.initialize(name, conf); <line3> this.bucket = name.getHost(); <line4> if (this.store == null) { <line5> this.store = createDefaultStore(conf); <line6> } <line7> this.store.initialize(name, conf); <line8> setConf(conf); <line9> this.uri = URI.create(name.getScheme() + ""://"" + name.getAuthority()); <line10> this.workingDir = <line11> new Path(""/user"", System.getProperty(""user.name"")) <line12> .makeQualified(this.uri, this.getWorkingDirectory()); <line13> this.owner = getOwnerId(); <line14> this.group = getGroupId(); <line15> BufferPool.getInstance().initialize(this.getConf()); <line16> int uploadThreadPoolSize = <line17> this.getConf() <line18> .getInt( <line19> CosNConfigKeys.UPLOAD_THREAD_POOL_SIZE_KEY, <line20> CosNConfigKeys.DEFAULT_UPLOAD_THREAD_POOL_SIZE); <line21> int readAheadPoolSize = <line22> this.getConf() <line23> .getInt( <line24> CosNConfigKeys.READ_AHEAD_QUEUE_SIZE, CosNConfigKeys.DEFAULT_READ_AHEAD_QUEUE_SIZE); <line25> int ioThreadPoolSize = uploadThreadPoolSize + readAheadPoolSize / 3; <line26> long threadKeepAlive = <line27> this.getConf() <line28> .getLong( <line29> CosNConfigKeys.THREAD_KEEP_ALIVE_TIME_KEY, <line30> CosNConfigKeys.DEFAULT_THREAD_KEEP_ALIVE_TIME); <line31> this.boundedIOThreadPool = <line32> BlockingThreadPoolExecutorService.newInstance( <line33> ioThreadPoolSize / 2, <line34> ioThreadPoolSize, <line35> threadKeepAlive, <line36> TimeUnit.SECONDS, <line37> ""cos-transfer-thread-pool""); <line38> int copyThreadPoolSize = <line39> this.getConf() <line40> .getInt( <line41> CosNConfigKeys.COPY_THREAD_POOL_SIZE_KEY, <line42> CosNConfigKeys.DEFAULT_COPY_THREAD_POOL_SIZE); <line43> this.boundedCopyThreadPool = <line44> BlockingThreadPoolExecutorService.newInstance( <line45> CosNConfigKeys.DEFAULT_COPY_THREAD_POOL_SIZE, <line46> copyThreadPoolSize, <line47> 60L, <line48> TimeUnit.SECONDS, <line49> ""cos-copy-thread-pool""); <line50> } <line51> } <line52> "	 <line15>	Yes
public class A { <line0> private void scheduledLogStatus() { <line1> scheduleRunAsync(this::scheduledLogStatus, STATUS_LOG_INTERVAL_MS, TimeUnit.MILLISECONDS); <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> public int getTableColumnViewIndex(IColumn col, int defaultIndex, String configName) { <line1> if (m_prefs == null) { <line2> return defaultIndex; <line3> } <line4> String key = createColumnConfigKey(col, configName, TABLE_COLUMN_UIINDEX); <line5> String value = m_prefs.get(key, null); <line6> if (value != null) { <line7> try { <line8> return Integer.parseInt(value); <line9> } catch (Exception e) { <line10> } <line11> } <line12> return defaultIndex; <line13> } <line14> } <line15> 	 <line5>	No
public class A { <line0> public static ColumnVisibility getColumnVisibilityForHit(Document document, String hitTerm) { <line1> int idx = hitTerm.indexOf(':'); <line2> if (idx == -1) return null; <line3> String hitName = hitTerm.substring(0, idx); <line4> String hitValue = hitTerm.substring(idx + 1); <line5> Attribute<?> documentAttribute = document.get(hitName); <line6> if (documentAttribute == null) { <line7> } else if (documentAttribute instanceof Attributes) { <line8> Attributes documentAttributes = (Attributes) documentAttribute; <line9> for (Attribute<?> documentAttr : documentAttributes.getAttributes()) { <line10> if (documentAttr instanceof TypeAttribute) { <line11> TypeAttribute<?> typeAttribute = (TypeAttribute) documentAttr; <line12> Type<?> type = typeAttribute.getType(); <line13> Collection<String> expansions = <line14> Sets.newHashSet(type.getNormalizedValue(), type.getDelegate().toString()); <line15> for (String expansion : expansions) { <line16> if (expansion.equals(hitValue)) { <line17> return documentAttr.getColumnVisibility(); <line18> } <line19> } <line20> } else if (hitValue.equals(documentAttr.getData())) { <line21> return documentAttr.getColumnVisibility(); <line22> } <line23> } <line24> } else { <line25> if (documentAttribute instanceof TypeAttribute) { <line26> TypeAttribute<?> typeAttribute = (TypeAttribute<?>) documentAttribute; <line27> Type<?> type = typeAttribute.getType(); <line28> Collection<String> expansions = <line29> Sets.newHashSet(type.getNormalizedValue(), type.getDelegate().toString()); <line30> for (String expansion : expansions) { <line31> if (expansion.equals(hitValue)) { <line32> return documentAttribute.getColumnVisibility(); <line33> } <line34> } <line35> } else if (hitValue.equals(documentAttribute.getData())) { <line36> return documentAttribute.getColumnVisibility(); <line37> } <line38> } <line39> return null; <line40> } <line41> } <line42> 	 <line7>	Yes
"public class A { <line0> private String computeInstanceId(String source, String detectInstance) { <line1> String result; <line2> if (!isNullOrEmpty(source)) { <line3> result = source; <line4> } else { <line5> if (""AWS"".equalsIgnoreCase(detectInstance)) { <line6> result = <line7> getLocalInstanceId(""AWS"", ""http://169.254.169.254/latest/meta-data/instance-id"", null); <line8> if (result != null) { <line9> } else { <line10> } <line11> } else if (""GCE"".equalsIgnoreCase(detectInstance)) { <line12> result = <line13> getLocalInstanceId( <line14> ""GCE"", <line15> ""http://metadata/computeMetadata/v1/instance/id"", <line16> ImmutableMap.of(""X-Google-Metadata-Request"", ""True"")); <line17> if (result == null) { <line18> } <line19> } else { <line20> result = null; <line21> } <line22> } <line23> return result; <line24> } <line25> } <line26> "	 <line21>	Yes
public class A { <line0> public ID menuKeyEquivalentTarget_forEvent(NSMenu menu, NSEvent event) { <line1> if (log.isTraceEnabled()) { <line2> } <line3> return this.getTarget(); <line4> } <line5> } <line6> 	 <line0>	No
"public class A { <line0> @Override <line1> public RemoteFileOperations<FTPFile> createRemoteFileOperations() throws Exception { <line2> FTPClient client = ftpClient; <line3> if (client == null) { <line4> client = createFtpClient(); <line5> } <line6> if (getBufferSize() > 0) { <line7> client.setBufferSize(getBufferSize()); <line8> } <line9> if (getConfiguration().getConnectTimeout() > -1) { <line10> client.setConnectTimeout(getConfiguration().getConnectTimeout()); <line11> } <line12> if (getConfiguration().getSoTimeout() > -1) { <line13> soTimeout = getConfiguration().getSoTimeout(); <line14> } <line15> dataTimeout = getConfiguration().getTimeout(); <line16> if (getConfiguration().getActivePortRange() != null) { <line17> String[] parts = getConfiguration().getActivePortRange().split(""-""); <line18> if (parts.length != 2) { <line19> throw new IllegalArgumentException( <line20> ""The option activePortRange should have syntax: min-max""); <line21> } <line22> int min = getCamelContext().getTypeConverter().mandatoryConvertTo(int.class, parts[0]); <line23> int max = getCamelContext().getTypeConverter().mandatoryConvertTo(int.class, parts[1]); <line24> client.setActivePortRange(min, max); <line25> } <line26> if (ftpClientParameters != null) { <line27> Map<String, Object> localParameters = new HashMap<>(ftpClientParameters); <line28> Object timeout = localParameters.remove(""soTimeout""); <line29> if (timeout != null) { <line30> soTimeout = getCamelContext().getTypeConverter().convertTo(int.class, timeout); <line31> } <line32> timeout = localParameters.remove(""dataTimeout""); <line33> if (timeout != null) { <line34> dataTimeout = getCamelContext().getTypeConverter().convertTo(int.class, timeout); <line35> } <line36> setProperties(client, localParameters); <line37> } <line38> if (ftpClientConfigParameters != null) { <line39> if (ftpClientConfig == null) { <line40> ftpClientConfig = new FTPClientConfig(); <line41> } <line42> Map<String, Object> localConfigParameters = new HashMap<>(ftpClientConfigParameters); <line43> setProperties(ftpClientConfig, localConfigParameters); <line44> } <line45> if (dataTimeout > 0) { <line46> client.setDataTimeout(dataTimeout); <line47> } <line48> if (LOG.isDebugEnabled()) { <line49> } <line50> FtpOperations operations = new FtpOperations(client, getFtpClientConfig()); <line51> operations.setEndpoint(this); <line52> return operations; <line53> } <line54> } <line55> "	 <line49>	Yes
public class A { <line0> public Boolean apply(WebDriver driver) { <line1> driver.manage().window().maximize(); <line2> return true; <line3> } <line4> } <line5> 	 <line3>	No
"public class A { <line0> @PayloadRoot( <line1> localPart = ""FindDevicesWhichHaveNoOwnerRequest"", <line2> namespace = DEVICE_MANAGEMENT_NAMESPACE) <line3> @ResponsePayload <line4> public FindDevicesWhichHaveNoOwnerResponse findDevicesWhichHaveNoOwner( <line5> @OrganisationIdentification final String organisationIdentification, <line6> @RequestPayload final FindDevicesWhichHaveNoOwnerRequest request) <line7> throws OsgpException { <line8> final FindDevicesWhichHaveNoOwnerResponse response = new FindDevicesWhichHaveNoOwnerResponse(); <line9> try { <line10> final List<org.opensmartgridplatform.domain.core.entities.Device> devicesWithoutOwner = <line11> this.deviceManagementService.findDevicesWhichHaveNoOwner(organisationIdentification); <line12> response <line13> .getDevices() <line14> .addAll( <line15> this.deviceManagementMapper.mapAsList( <line16> devicesWithoutOwner, <line17> org.opensmartgridplatform.adapter.ws.schema.admin.devicemanagement.Device.class)); <line18> } catch (final ConstraintViolationException e) { <line19> throw new FunctionalException( <line20> FunctionalExceptionType.VALIDATION_ERROR, <line21> COMPONENT_TYPE_WS_ADMIN, <line22> new ValidationException(e.getConstraintViolations())); <line23> } catch (final Exception e) { <line24> this.handleException(e); <line25> } <line26> return response; <line27> } <line28> } <line29> "	 <line8>	Yes
public class A { <line0> protected void writeCustomRequestHeaders(HttpRequest httpReq, Map<String, String> customHeaders) { <line1> if (customHeaders == null) { <line2> return; <line3> } <line4> for (Entry<String, String> header : customHeaders.entrySet()) { <line5> httpReq.getHeaders().set(header.getKey(), header.getValue()); <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> if (LOG.isTraceEnabled()) { <line3> } <line4> while (waitForWork()) { <line5> readResponse(); <line6> } <line7> if (LOG.isTraceEnabled()) { <line8> } <line9> } <line10> } <line11> 	 <line5>	No
public class A { <line0> @Override <line1> protected void onProfileProperty( <line2> String profileName, <line3> String propertyKey, <line4> String propertyValue, <line5> boolean isSupportedProperty, <line6> String line) { <line7> Map<String, String> properties = allProfileProperties.get(profileName); <line8> if (properties.containsKey(propertyKey)) { <line9> } <line10> properties.put(propertyKey, propertyValue); <line11> } <line12> } <line13> 	 <line12>	No
public class A { <line0> private void delUserRoles() throws BuildException { <line1> if (deluserroles == null) { <line2> return; <line3> } <line4> for (Deluserrole deluserrole : deluserroles) { <line5> List<UserRole> userroles = deluserrole.getUserRoles(); <line6> for (UserRole userRole : userroles) { <line7> try { <line8> adminMgr.deassignUser(userRole); <line9> } catch (SecurityException se) { <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	 <line4>	No
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> SavedSearch savedSearch = twitter.createSavedSearch(query); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.createdSavedSearch(savedSearch); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> @Test <line1> public void testEventAvailabilityScope() throws Exception { <line2> startGrids(GRID_COUNT); <line3> final CacheEventListener lsnr = new CacheEventListener(); <line4> ContinuousQuery<Object, Object> qry = new ContinuousQuery<>(); <line5> qry.setLocalListener(lsnr); <line6> qry.setRemoteFilterFactory(new FilterFactory()); <line7> Object keys[] = new Object[GRID_COUNT]; <line8> for (int i = 0; i < GRID_COUNT; ++i) { <line9> keys[i] = primaryKey(grid(i).cache(DEFAULT_CACHE_NAME)); <line10> grid(0).cache(DEFAULT_CACHE_NAME).put(keys[i], -1); <line11> } <line12> try (QueryCursor<?> cur = grid(0).cache(DEFAULT_CACHE_NAME).query(qry)) { <line13> for (int i = 0; i < KEYS_COUNT; i++) { <line14> grid(i % GRID_COUNT).cache(DEFAULT_CACHE_NAME).put(keys[i % GRID_COUNT], i); <line15> } <line16> } <line17> assertTrue(""There are not filtered events"", !events.isEmpty()); <line18> for (CacheEntryEvent<?, ?> event : events) { <line19> assertNotNull(""Key is null"", event.getKey()); <line20> assertNotNull(""Value is null"", event.getValue()); <line21> assertNotNull(""Old value is null"", event.getOldValue()); <line22> } <line23> } <line24> } <line25> "	 <line14>	Yes
public class A { <line0> private boolean importData() { <line1> Map<Integer, List<JsonNode>> altNamesMap = new HashMap<>(); <line2> Map<Integer, List<JsonNode>> identifiersMap = new HashMap<>(); <line3> Map<Integer, JsonNode> dnNameMap = new HashMap<>(); <line4> Map<Integer, Integer> deletedElementsMap = new HashMap<>(); <line5> try (ZipFile zip = new ZipFile(ftpsFileDownloader.getLocalFilePath())) { <line6> processAltNamesFile(zip, altNamesMap, dnNameMap); <line7> processIdentifiersFile(zip, identifiersMap); <line8> processDeletedElementsFile(zip, deletedElementsMap); <line9> processInstitutions(zip, altNamesMap, identifiersMap, dnNameMap); <line10> processDeletedElements(deletedElementsMap); <line11> return true; <line12> } catch (Exception e) { <line13> return false; <line14> } finally { <line15> } <line16> } <line17> } <line18> 	 <line5>	Yes
public class A { <line0> @Override <line1> protected List<Invoker<T>> list(Invocation invocation) throws RpcException { <line2> List<Invoker<T>> invokers = super.list(invocation); <line3> if (null == invokers || invokers.size() < 2) { <line4> return invokers; <line5> } <line6> List<Invoker<T>> interfaceInvokers = new ArrayList<>(); <line7> List<Invoker<T>> serviceInvokers = new ArrayList<>(); <line8> boolean addressChanged = false; <line9> for (Invoker<T> invoker : invokers) { <line10> MigrationClusterInvoker migrationClusterInvoker = (MigrationClusterInvoker) invoker; <line11> if (migrationClusterInvoker.isServiceInvoker()) { <line12> serviceInvokers.add(invoker); <line13> } else { <line14> interfaceInvokers.add(invoker); <line15> } <line16> if (migrationClusterInvoker.invokersChanged().compareAndSet(true, false)) { <line17> addressChanged = true; <line18> } <line19> } <line20> if (serviceInvokers.isEmpty() || interfaceInvokers.isEmpty()) { <line21> return invokers; <line22> } <line23> MigrationRule rule = null; <line24> for (Invoker<T> invoker : serviceInvokers) { <line25> MigrationClusterInvoker migrationClusterInvoker = (MigrationClusterInvoker) invoker; <line26> if (rule == null) { <line27> rule = migrationClusterInvoker.getMigrationRule(); <line28> continue; <line29> } <line30> if (!rule.equals(migrationClusterInvoker.getMigrationRule())) { <line31> rule = MigrationRule.queryRule(); <line32> break; <line33> } <line34> } <line35> MigrationStep step = rule.getStep(); <line36> switch (step) { <line37> case FORCE_INTERFACE: <line38> clusterRefresh(addressChanged, interfaceInvokers); <line39> clusterDestroy(addressChanged, serviceInvokers, true); <line40> if (logger.isDebugEnabled()) { <line41> } <line42> return interfaceInvokers; <line43> case APPLICATION_FIRST: <line44> clusterRefresh(addressChanged, serviceInvokers); <line45> clusterRefresh(addressChanged, interfaceInvokers); <line46> boolean serviceAvailable = !serviceInvokers.isEmpty(); <line47> if (serviceAvailable) { <line48> if (shouldMigrate(addressChanged, serviceInvokers, interfaceInvokers)) { <line49> if (logger.isDebugEnabled()) { <line50> } <line51> return serviceInvokers; <line52> } <line53> } <line54> if (logger.isDebugEnabled()) { <line55> } <line56> return interfaceInvokers; <line57> case FORCE_APPLICATION: <line58> clusterRefresh(addressChanged, serviceInvokers); <line59> clusterDestroy(addressChanged, interfaceInvokers, true); <line60> if (logger.isDebugEnabled()) { <line61> } <line62> return serviceInvokers; <line63> } <line64> throw new UnsupportedOperationException(rule.getStep().name()); <line65> } <line66> } <line67> 	 <line55>	Yes
public class A { <line0> @Override <line1> public void getRetweetsOfMe() { <line2> getDispatcher() <line3> .invokeLater( <line4> new AsyncTask(RETWEETS_OF_ME, listeners) { <line5> @Override <line6> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line7> ResponseList<Status> statuses = twitter.getRetweetsOfMe(); <line8> for (TwitterListener listener : listeners) { <line9> try { <line10> listener.gotRetweetsOfMe(statuses); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> }); <line16> } <line17> } <line18> 	 <line12>	Yes
public class A { <line0> public void destroy() throws Exception { <line1> if (remoteClientAssociation != null) { <line2> this.management.stopAssociation(remoteClientAssociationName); <line3> this.management.removeAssociation(remoteClientAssociationName); <line4> remoteClientAssociation = null; <line5> } <line6> if (serverAssociation != null) { <line7> this.management.stopAssociation(serverAssociationName); <line8> this.management.removeAssociation(serverAssociationName); <line9> this.management.stopServer(serverName); <line10> this.management.removeServer(serverName); <line11> this.management.stop(); <line12> serverAssociation = null; <line13> } <line14> } <line15> } <line16> 	 <line1>	Yes
"public class A { <line0> private void saveAudioAndTextToFile(String text, File cacheFile, byte[] audio, String voiceName) <line1> throws IOException { <line2> try (FileOutputStream audioFileOutputStream = new FileOutputStream(cacheFile)) { <line3> audioFileOutputStream.write(audio); <line4> } <line5> String textFileName = removeExtension(cacheFile.getName()) + "".txt""; <line6> try (FileOutputStream textFileOutputStream = <line7> new FileOutputStream(new File(cacheFolder, textFileName))) { <line8> StringBuilder sb = <line9> new StringBuilder(""Config: "") <line10> .append(config.toConfigString()) <line11> .append("",voice="") <line12> .append(voiceName) <line13> .append(System.lineSeparator()) <line14> .append(""Text: "") <line15> .append(text) <line16> .append(System.lineSeparator()); <line17> textFileOutputStream.write(sb.toString().getBytes(StandardCharsets.UTF_8)); <line18> } <line19> } <line20> } <line21> "	 <line6>	Yes
"public class A { <line0> private void stop(boolean swallowException) { <line1> AtomicReference<Throwable> firstException = new AtomicReference<>(); <line2> this.stopped = true; <line3> Utils.closeQuietly(coordinator, ""coordinator"", firstException); <line4> Utils.closeQuietly(metrics, ""consumer metrics"", firstException); <line5> Utils.closeQuietly(client, ""consumer network client"", firstException); <line6> AppInfoParser.unregisterAppInfo(JMX_PREFIX, clientId, metrics); <line7> if (firstException.get() != null && !swallowException) <line8> throw new KafkaException(""Failed to stop the Connect group member"", firstException.get()); <line9> } <line10> } <line11> "	 <line4>	No
"public class A { <line0> private void setupConfig(Job job) throws DataProviderException { <line1> Configuration conf = job.getConfiguration(); <line2> String strBasePath = HdfsMrsImageDataProvider.getBasePath(conf).toString(); <line3> conf.set(""hdfs."" + MrGeoConstants.MRGEO_HDFS_IMAGE, strBasePath); <line4> String input = context.getInput(); <line5> HdfsMrsImageDataProvider dp = new HdfsMrsImageDataProvider(job.getConfiguration(), input, null); <line6> String image = HdfsMrsPyramidInputFormat.getZoomName(dp, context.getZoomLevel()); <line7> if (image == null) { <line8> try { <line9> MrsPyramid pyramid; <line10> try { <line11> pyramid = MrsPyramid.open(dp); <line12> } catch (IOException e) { <line13> throw new DataProviderException(""Failure opening input image pyramid: "" + input, e); <line14> } <line15> MrsPyramidMetadata metadata = pyramid.getMetadata(); <line16> image = HdfsMrsPyramidInputFormat.getZoomName(dp, metadata.getMaxZoomLevel()); <line17> } catch (IOException e) { <line18> throw new DataProviderException(""Failure opening input image: "" + input, e); <line19> } <line20> } <line21> String zoomInput = image; <line22> try { <line23> HdfsMrsPyramidInputFormat.setInputInfo(job, zoomInput); <line24> } catch (IOException e) { <line25> throw new DataProviderException(""Failure configuring map/reduce job with HDFS input info"", e); <line26> } <line27> } <line28> } <line29> "	 <line4>	No
public class A { <line0> private void createStreamingServer(WPSCapabilitiesType capabilities, ComponentsFactory factory) { <line1> ProcessOfferings offerings = capabilities.getProcessOfferings(); <line2> if (offerings != null) { <line3> Set<String> processNames = New.set(); <line4> for (ProcessBriefType briefType : offerings.getProcess()) { <line5> processNames.add(briefType.getIdentifier().getValue()); <line6> } <line7> boolean serverHasStreaming = <line8> processNames.contains(StreamingConstants.SUBSCRIBE_PROCESS) <line9> && processNames.contains(StreamingConstants.UNSUBSCRIBE_PROCESS); <line10> if (serverHasStreaming) { <line11> myServer = new WPSStreamingServer(factory); <line12> ServerProvider<StreamingServer> provider = <line13> myProviderRegistry.getProvider(StreamingServer.class); <line14> if (provider instanceof ModifiableServerProvider) { <line15> ((ModifiableServerProvider<StreamingServer>) provider).addServer(myServer); <line16> } else { <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	 <line8>	No
public class A { <line0> @Override <line1> public AccessControlPolicyIterator getApplicablePolicies(String absPath) <line2> throws PathNotFoundException, AccessDeniedException, RepositoryException { <line3> checkInitialized(); <line4> checkPermission(absPath, Permission.READ_AC); <line5> if (editor != null) { <line6> try { <line7> AccessControlPolicy[] applicable = editor.editAccessControlPolicies(absPath); <line8> return new AccessControlPolicyIteratorAdapter(Arrays.asList(applicable)); <line9> } catch (AccessControlException e) { <line10> } <line11> } <line12> return AccessControlPolicyIteratorAdapter.EMPTY; <line13> } <line14> } <line15> 	 <line5>	No
"public class A { <line0> private static boolean isAndroid0() { <line1> boolean android; <line2> try { <line3> Class.forName(""android.app.Application"", false, getSystemClassLoader()); <line4> android = true; <line5> } catch (Throwable ignored) { <line6> android = false; <line7> } <line8> if (android) { <line9> } <line10> return android; <line11> } <line12> } <line13> "	 <line9>	Yes
public class A { <line0> public void attachDirty(StgSysExport instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> protected void addChildren(RebindContext rebindContext, LocationMemento memento) { <line1> for (String childId : memento.getChildren()) { <line2> Location child = rebindContext.lookup().lookupLocation(childId); <line3> if (child != null) { <line4> location.addChild(child); <line5> } else { <line6> } <line7> } <line8> } <line9> } <line10> 	 <line3>	No
"public class A { <line0> @Test <line1> public void testPendingMessagesOverflow() throws Exception { <line2> Ignite coord = startGrid(""coordinator""); <line3> TcpDiscoverySpi coordDisco = (TcpDiscoverySpi) coord.configuration().getDiscoverySpi(); <line4> Set<TcpDiscoveryAbstractMessage> sentEnsuredMsgs = new GridConcurrentHashSet<>(); <line5> coordDisco.addSendMessageListener( <line6> msg -> { <line7> if (coordDisco.ensured(msg)) sentEnsuredMsgs.add(msg); <line8> }); <line9> Ignite mediator = startGrid(""mediator""); <line10> Ignite victim = startGrid(""victim""); <line11> startGrid(""listener""); <line12> sentEnsuredMsgs.clear(); <line13> receivedEnsuredMsgs.clear(); <line14> sendDummyCustomMessage(coordDisco, IgniteUuid.randomUuid()); <line15> assertTrue( <line16> ""Sent: "" + sentEnsuredMsgs + ""; received: "" + receivedEnsuredMsgs, <line17> GridTestUtils.waitForCondition( <line18> () -> { <line19> return receivedEnsuredMsgs.equals(sentEnsuredMsgs); <line20> }, <line21> 10000)); <line22> blockMsgs = true; <line23> int msgsNum = 2000; <line24> for (int i = 0; i < msgsNum; i++) sendDummyCustomMessage(coordDisco, IgniteUuid.randomUuid()); <line25> mediator.close(); <line26> victim.close(); <line27> assertTrue( <line28> ""Sent: "" + sentEnsuredMsgs + ""; received: "" + receivedEnsuredMsgs, <line29> GridTestUtils.waitForCondition( <line30> () -> { <line31> return receivedEnsuredMsgs.equals(sentEnsuredMsgs); <line32> }, <line33> 10000)); <line34> } <line35> } <line36> "	 <line14>	No
"public class A { <line0> @Override <line1> public void processAssetEntryQuery( <line2> long companyId, <line3> String userId, <line4> UnicodeProperties unicodeProperties, <line5> AssetEntryQuery assetEntryQuery) { <line6> if (Validator.isNull(userId)) { <line7> return; <line8> } <line9> boolean enableContentRecommendation = <line10> GetterUtil.getBoolean(unicodeProperties.getProperty(""enableContentRecommendation"")); <line11> if (!enableContentRecommendation || (_asahInterestTermProvider == null)) { <line12> return; <line13> } <line14> String[] interestTerms = _asahInterestTermProvider.getInterestTerms(companyId, userId); <line15> if (interestTerms.length == 0) { <line16> return; <line17> } <line18> if (_log.isDebugEnabled()) { <line19> } <line20> assetEntryQuery.setAnyKeywords(interestTerms); <line21> } <line22> } <line23> "	 <line19>	Yes
public class A { <line0> public RulesValidator setRules(final String validationRuleFile) { <line1> try (final BufferedReader br = <line2> new BufferedReader( <line3> new InputStreamReader( <line4> new FileInputStream(validationRuleFile), StandardCharsets.UTF_8))) { <line5> processAssertions(br); <line6> } catch (final Exception ex) { <line7> } <line8> return this; <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> public void persist(RechteRolleBericht transientInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().persist(transientInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line3>	Yes
public class A { <line0> public static KylinConfig createInstanceFromUri(String uri) { <line1> UriType uriType = decideUriType(uri); <line2> if (uriType == UriType.LOCAL_FOLDER) { <line3> KylinConfig config = new KylinConfig(); <line4> config.setMetadataUrl(uri); <line5> return config; <line6> } else if (uriType == UriType.PROPERTIES_FILE) { <line7> KylinConfig config; <line8> try { <line9> config = new KylinConfig(); <line10> InputStream is = new FileInputStream(uri); <line11> config.reloadKylinConfig(is); <line12> is.close(); <line13> } catch (IOException e) { <line14> throw new RuntimeException(e); <line15> } <line16> return config; <line17> } else { <line18> try { <line19> KylinConfig config = new KylinConfig(); <line20> RestClient client = new RestClient(uri); <line21> String propertyText = client.getKylinProperties(); <line22> InputStream is = IOUtils.toInputStream(propertyText); <line23> config.reloadKylinConfig(is); <line24> is.close(); <line25> return config; <line26> } catch (IOException e) { <line27> throw new RuntimeException(e); <line28> } <line29> } <line30> } <line31> } <line32> 	 <line27>	No
public class A { <line0> @Override <line1> protected void updatePartitionLagFromStream() { <line2> getRecordSupplierLock().lock(); <line3> try { <line4> Set<Integer> partitionIds; <line5> try { <line6> partitionIds = recordSupplier.getPartitionIds(getIoConfig().getStream()); <line7> } catch (Exception e) { <line8> throw new StreamException(e); <line9> } <line10> Set<StreamPartition<Integer>> partitions = <line11> partitionIds.stream() <line12> .map(e -> new StreamPartition<>(getIoConfig().getStream(), e)) <line13> .collect(Collectors.toSet()); <line14> recordSupplier.seekToLatest(partitions); <line15> latestSequenceFromStream = <line16> partitions.stream() <line17> .collect( <line18> Collectors.toMap(StreamPartition::getPartitionId, recordSupplier::getPosition)); <line19> } catch (InterruptedException e) { <line20> throw new StreamException(e); <line21> } finally { <line22> getRecordSupplierLock().unlock(); <line23> } <line24> } <line25> } <line26> 	 <line14>	No
"public class A { <line0> @Override <line1> protected void doStop() { <line2> try { <line3> logSafe(""Stopping store {}-{}..."", topic, partitionGroup); <line4> logSafe(""Waiting for flush finished {}-{}..."", topic, partitionGroup); <line5> try { <line6> while (!isAllStoreClean()) { <line7> Thread.sleep(50); <line8> } <line9> } catch (InterruptedException e) { <line10> } <line11> stopWriteThread(); <line12> logSafe(""Stopping flush thread {}-{}..."", topic, partitionGroup); <line13> stopFlushThread(); <line14> flushCheckpoint(); <line15> if (config.printMetricIntervalMs > 0) { <line16> logSafe(""Stopping metric threads {}-{}..."", topic, partitionGroup); <line17> metricThread.stop(); <line18> } <line19> System.out.println(""Store stopped. "" + base.getAbsolutePath()); <line20> logSafe(""Store stopped {}-{}."", topic, partitionGroup); <line21> } catch (Throwable t) { <line22> } <line23> } <line24> } <line25> "	 <line1>	No
"public class A { <line0> private static void prepareLuceneQueryForPartitionKey( <line1> LuceneQueryBuilder queryBuilder, <line2> Object key, <line3> MetamodelImpl metaModel, <line4> String indexName, <line5> Class valueClazz) { <line6> Field[] fields = key.getClass().getDeclaredFields(); <line7> EmbeddableType embeddable = metaModel.embeddable(key.getClass()); <line8> boolean appendAnd = false; <line9> try { <line10> for (int i = 0; i < fields.length; i++) { <line11> if (!ReflectUtils.isTransientOrStatic(fields[i])) { <line12> if (metaModel.isEmbeddable( <line13> ((AbstractAttribute) embeddable.getAttribute(fields[i].getName())) <line14> .getBindableJavaType())) { <line15> fields[i].setAccessible(true); <line16> prepareLuceneQueryForPartitionKey( <line17> queryBuilder, fields[i].get(key), metaModel, indexName, valueClazz); <line18> } else { <line19> if (appendAnd) { <line20> queryBuilder.buildQuery(""AND"", ""AND"", String.class); <line21> } <line22> appendAnd = true; <line23> String fieldValue = PropertyAccessorHelper.getString(key, fields[i]); <line24> fieldValue = fieldValue.replaceAll(""[^a-zA-Z0-9]"", ""_""); <line25> queryBuilder <line26> .appendIndexName(indexName) <line27> .appendPropertyName(fields[i].getName()) <line28> .buildQuery(""="", fieldValue, valueClazz); <line29> } <line30> } <line31> } <line32> } catch (IllegalArgumentException e) { <line33> throw new PersistenceException(e); <line34> } catch (IllegalAccessException e) { <line35> } <line36> } <line37> } <line38> "	 <line8>	No
public class A { <line0> private static void updateEnsembleInfo( <line1> LedgerManager ledgerManager, <line2> AsyncCallback.VoidCallback ensembleUpdatedCb, <line3> long fragmentStartId, <line4> LedgerHandle lh, <line5> Map<BookieId, BookieId> oldBookie2NewBookie) { <line6> MetadataUpdateLoop updateLoop = <line7> new MetadataUpdateLoop( <line8> ledgerManager, <line9> lh.getId(), <line10> lh::getVersionedLedgerMetadata, <line11> (metadata) -> { <line12> List<BookieId> ensemble = metadata.getAllEnsembles().get(fragmentStartId); <line13> return oldBookie2NewBookie.keySet().stream().anyMatch(ensemble::contains); <line14> }, <line15> (currentMetadata) -> { <line16> List<BookieId> newEnsemble = <line17> currentMetadata.getAllEnsembles().get(fragmentStartId).stream() <line18> .map((bookie) -> oldBookie2NewBookie.getOrDefault(bookie, bookie)) <line19> .collect(Collectors.toList()); <line20> return LedgerMetadataBuilder.from(currentMetadata) <line21> .replaceEnsembleEntry(fragmentStartId, newEnsemble) <line22> .build(); <line23> }, <line24> lh::setLedgerMetadata); <line25> updateLoop <line26> .run() <line27> .whenComplete( <line28> (result, ex) -> { <line29> if (ex == null) { <line30> ensembleUpdatedCb.processResult(BKException.Code.OK, null, null); <line31> } else { <line32> ensembleUpdatedCb.processResult( <line33> BKException.getExceptionCode(ex, BKException.Code.UnexpectedConditionException), <line34> null, <line35> null); <line36> } <line37> }); <line38> } <line39> } <line40> 	 <line0>	No
public class A { <line0> public static long getInitialSeedUniquifier() { <line1> long initialSeedUniquifier = ThreadLocalRandom.initialSeedUniquifier; <line2> if (initialSeedUniquifier != 0) { <line3> return initialSeedUniquifier; <line4> } <line5> synchronized (ThreadLocalRandom.class) { <line6> initialSeedUniquifier = ThreadLocalRandom.initialSeedUniquifier; <line7> if (initialSeedUniquifier != 0) { <line8> return initialSeedUniquifier; <line9> } <line10> final long timeoutSeconds = 3; <line11> final long deadLine = seedGeneratorStartTime + TimeUnit.SECONDS.toNanos(timeoutSeconds); <line12> boolean interrupted = false; <line13> for (; ; ) { <line14> final long waitTime = deadLine - System.nanoTime(); <line15> try { <line16> final byte[] seed; <line17> if (waitTime <= 0) { <line18> seed = seedQueue.poll(); <line19> } else { <line20> seed = seedQueue.poll(waitTime, TimeUnit.NANOSECONDS); <line21> } <line22> if (seed != null) { <line23> initialSeedUniquifier = <line24> ((long) seed[0] & 0xff) << 56 <line25> | ((long) seed[1] & 0xff) << 48 <line26> | ((long) seed[2] & 0xff) << 40 <line27> | ((long) seed[3] & 0xff) << 32 <line28> | ((long) seed[4] & 0xff) << 24 <line29> | ((long) seed[5] & 0xff) << 16 <line30> | ((long) seed[6] & 0xff) << 8 <line31> | (long) seed[7] & 0xff; <line32> break; <line33> } <line34> } catch (InterruptedException e) { <line35> interrupted = true; <line36> break; <line37> } <line38> if (waitTime <= 0) { <line39> seedGeneratorThread.interrupt(); <line40> break; <line41> } <line42> } <line43> initialSeedUniquifier ^= 0x3255ecdc33bae119L; <line44> initialSeedUniquifier ^= Long.reverse(System.nanoTime()); <line45> ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier; <line46> if (interrupted) { <line47> Thread.currentThread().interrupt(); <line48> seedGeneratorThread.interrupt(); <line49> } <line50> if (seedGeneratorEndTime == 0) { <line51> seedGeneratorEndTime = System.nanoTime(); <line52> } <line53> return initialSeedUniquifier; <line54> } <line55> } <line56> } <line57> 	 <line40>	Yes
"public class A { <line0> private boolean validateGLCode(final Transaxtion txn, final DataCollection dc) <line1> throws TaskFailedException { <line2> final HashMap hm = getGlAccountCodes(); <line3> if (hm == null) { <line4> dc.addMessage(""Account Codes not initialized"", txn.getGlCode() + "" For "" + txn.getGlName()); <line5> return false; <line6> } <line7> if (hm.get(txn.getGlCode()) == null) { <line8> final Iterator itr = hm.keySet().iterator(); <line9> while (itr.hasNext()) <line10> } <line11> final Object obj = hm.get(txn.getGlCode()); <line12> final GLAccount glAcc = (GLAccount) hm.get(txn.getGlCode()); <line13> if (glAcc == null) { <line14> dc.addMessage(""exilInvalidCode"", txn.getGlCode() + "" For "" + txn.getGlName()); <line15> return false; <line16> } <line17> txn.setGlName(glAcc.getName()); <line18> if (LOGGER.isInfoEnabled()) <line19> if (!glAcc.isActiveForPosting()) { <line20> dc.addMessage(""exilInActiveAccount"", txn.getGlCode() + "" For "" + txn.glName); <line21> return false; <line22> } <line23> if (glAcc.getClassification() != 4) { <line24> dc.addMessage(""exilNotDetailAccount"", txn.getGlCode()); <line25> return false; <line26> } <line27> if (Double.parseDouble(txn.getDrAmount()) > 0 && Double.parseDouble(txn.getCrAmount()) > 0) { <line28> dc.addMessage(""exilInvalidTrxn""); <line29> return false; <line30> } <line31> if (!isRequiredPresent(txn, glAcc, dc)) return false; <line32> return true; <line33> } <line34> } <line35> "	 <line9>	No
public class A { <line0> @Override <line1> public void operationComplete(IoWriteFuture future) { <line2> if (future.isDone()) { <line3> if (future.isWritten()) { <line4> int available; <line5> synchronized (availableCount) { <line6> available = isOpen() ? availableCount.incrementAndGet() : Integer.MIN_VALUE; <line7> availableCount.notifyAll(); <line8> } <line9> if (available > 0) { <line10> if (log.isTraceEnabled()) { <line11> } <line12> return; <line13> } <line14> } else { <line15> Throwable err = future.getException(); <line16> } <line17> } else { <line18> } <line19> try { <line20> close(); <line21> } catch (IOException e) { <line22> } <line23> } <line24> } <line25> 	 <line14>	Yes
public class A { <line0> private List<Recommendation> createMetroPointRecommendations( <line1> VirtualArray srcVarray, <line2> List<VirtualArray> tgtVarrays, <line3> VirtualPool srcVpool, <line4> VirtualArray haVarray, <line5> VirtualPool haVpool, <line6> Project project, <line7> VirtualPoolCapabilityValuesWrapper capabilities, <line8> List<StoragePool> candidatePrimaryPools, <line9> List<StoragePool> candidateSecondaryPools, <line10> Volume vpoolChangeVolume) { <line11> List<Recommendation> recommendations = new ArrayList<Recommendation>(); <line12> RPProtectionRecommendation rpProtectionRecommendaton = null; <line13> Map<VirtualArray, List<StoragePool>> tgtVarrayStoragePoolsMap = <line14> getVplexTargetMatchingPools(tgtVarrays, srcVpool, project, capabilities, vpoolChangeVolume); <line15> rpProtectionRecommendaton = <line16> createRPProtectionRecommendationForMetroPoint( <line17> srcVarray, <line18> tgtVarrays, <line19> srcVpool, <line20> haVarray, <line21> haVpool, <line22> capabilities, <line23> candidatePrimaryPools, <line24> candidateSecondaryPools, <line25> tgtVarrayStoragePoolsMap, <line26> vpoolChangeVolume, <line27> project); <line28> recommendations.add(rpProtectionRecommendaton); <line29> return recommendations; <line30> } <line31> } <line32> 	 <line28>	Yes
public class A { <line0> public void collectNaive(final double... x) { <line1> double xj, yk, w = 1; <line2> if (x.length == dim + 1) { <line3> w = x[dim]; <line4> } <line5> if (w <= 0) { <line6> return; <line7> } <line8> entries++; <line9> sumW += w; <line10> for (int j = 0; j < dim; j++) { <line11> xj = x[j]; <line12> sumX[j] += w * xj; <line13> minX[j] = min(minX[j], xj); <line14> maxX[j] = max(maxX[j], xj); <line15> for (int k = 0; k < dim; k++) { <line16> yk = x[k]; <line17> sumXY[j][k] += w * xj * yk; <line18> } <line19> means[j] = sumX[j] / sumW; <line20> } <line21> for (int j = 0; j < dim; j++) { <line22> for (int k = 0; k <= j; k++) { <line23> covar[j][k] = sumXY[j][k] / sumW - means[j] * means[k]; <line24> covar[k][j] = covar[j][k]; <line25> } <line26> } <line27> } <line28> } <line29> 	 <line14>	No
public class A { <line0> @Override <line1> public NewSplitsAndState<T> call() throws Exception { <line2> List<Tuple2<Partition, T>> partitions = <line3> fetcher.fetchPartitions(fetcherContext, currentReadOffset); <line4> if (partitions.isEmpty()) { <line5> return new NewSplitsAndState<>( <line6> Collections.emptyList(), currentReadOffset, seenPartitionsSinceOffset); <line7> } <line8> partitions.sort(Comparator.comparing(o -> o.f1)); <line9> List<HiveSourceSplit> newSplits = new ArrayList<>(); <line10> T maxOffset = currentReadOffset; <line11> Set<List<String>> nextSeen = new HashSet<>(); <line12> for (Tuple2<Partition, T> tuple2 : partitions) { <line13> Partition partition = tuple2.f0; <line14> List<String> partSpec = partition.getValues(); <line15> if (seenPartitionsSinceOffset.add(partSpec)) { <line16> T offset = tuple2.f1; <line17> if (offset.compareTo(currentReadOffset) >= 0) { <line18> nextSeen.add(partSpec); <line19> } <line20> if (offset.compareTo(maxOffset) >= 0) { <line21> maxOffset = offset; <line22> } <line23> newSplits.addAll( <line24> HiveSourceFileEnumerator.createInputSplits( <line25> 0, <line26> Collections.singletonList(fetcherContext.toHiveTablePartition(partition)), <line27> jobConf)); <line28> } <line29> } <line30> currentReadOffset = maxOffset; <line31> if (!nextSeen.isEmpty()) { <line32> seenPartitionsSinceOffset.clear(); <line33> seenPartitionsSinceOffset.addAll(nextSeen); <line34> } <line35> return new NewSplitsAndState<>(newSplits, currentReadOffset, seenPartitionsSinceOffset); <line36> } <line37> } <line38> 	 <line23>	Yes
public class A { <line0> @Override <line1> public Stream get() { <line2> Stream defaultStream = sharedInstance.get(); <line3> if (defaultStream != null) { <line4> return defaultStream; <line5> } <line6> synchronized (this) { <line7> defaultStream = sharedInstance.get(); <line8> if (defaultStream != null) { <line9> return defaultStream; <line10> } <line11> int i = 0; <line12> do { <line13> try { <line14> defaultStream = service.load(Stream.DEFAULT_STREAM_ID); <line15> } catch (NotFoundException ignored) { <line16> if (i % 10 == 0) { <line17> } <line18> i++; <line19> Uninterruptibles.sleepUninterruptibly(500, TimeUnit.MILLISECONDS); <line20> } <line21> } while (defaultStream == null); <line22> sharedInstance.set(defaultStream); <line23> } <line24> return defaultStream; <line25> } <line26> } <line27> 	 <line17>	Yes
public class A { <line0> public void endSpan(Span span) { <line1> if (!span.isSampled()) { <line2> span.decrementReferences(); <line3> return; <line4> } <line5> if (span.getDuration() < coreConfiguration.getSpanMinDuration().getMillis() * 1000) { <line6> span.requestDiscarding(); <line7> } <line8> if (span.isDiscarded()) { <line9> Transaction transaction = span.getTransaction(); <line10> if (transaction != null) { <line11> transaction.getSpanCount().getDropped().incrementAndGet(); <line12> } <line13> span.decrementReferences(); <line14> return; <line15> } <line16> reportSpan(span); <line17> } <line18> } <line19> 	 <line14>	No
"public class A { <line0> public List<JsonObject> parserResponseTemplate( <line1> JsonNode nodeResponseTemplate, JsonNode nodeOriginalData) { <line2> List<JsonObject> responceDataList = new ArrayList<>(0); <line3> List<JsonObject> responceFinalDataList = new ArrayList<>(0); <line4> JsonObject responceData = new JsonObject(); <line5> try { <line6> for (Iterator<Map.Entry<String, JsonNode>> it = nodeResponseTemplate.fields(); <line7> it.hasNext(); ) { <line8> Map.Entry<String, JsonNode> field = it.next(); <line9> String key = field.getKey(); <line10> JsonNode valueResponse = field.getValue(); <line11> JsonNode jsonChildNode = nodeOriginalData.get(key); <line12> if (jsonChildNode != null) { <line13> if (jsonChildNode.isArray()) { <line14> processJsonChildArray( <line15> responceDataList, responceData, key, valueResponse, jsonChildNode); <line16> } else if (jsonChildNode.isObject()) { <line17> parseResponseChildObject(valueResponse, jsonChildNode, responceData, key); <line18> } else if (!jsonChildNode.isContainerNode()) { <line19> getNodeValue(jsonChildNode.toString(), jsonChildNode, valueResponse, responceData); <line20> } <line21> } else if (valueResponse != null <line22> && valueResponse.isArray() <line23> && key.equalsIgnoreCase(""extensions"")) { <line24> processExtension(valueResponse, nodeOriginalData, responceData); <line25> } <line26> } <line27> prepareFinalExtractedDataList(responceDataList, responceFinalDataList, responceData); <line28> } catch (Exception e) { <line29> } <line30> return responceFinalDataList; <line31> } <line32> } <line33> "	 <line2>	Yes
public class A { <line0> private long extractEndTimeMsFromSegmentZKMetadataZNRecord( <line1> String segment, @Nullable ZNRecord znRecord) { <line2> if (znRecord == null) { <line3> return INVALID_END_TIME_MS; <line4> } <line5> long totalDocs = znRecord.getLongField(CommonConstants.Segment.TOTAL_DOCS, -1); <line6> long endTimeMs = INVALID_END_TIME_MS; <line7> if (totalDocs != 0) { <line8> long endTime = znRecord.getLongField(CommonConstants.Segment.END_TIME, -1); <line9> if (endTime > 0) { <line10> TimeUnit timeUnit = <line11> znRecord.getEnumField(CommonConstants.Segment.TIME_UNIT, TimeUnit.class, TimeUnit.DAYS); <line12> endTimeMs = timeUnit.toMillis(endTime); <line13> } else { <line14> } <line15> } <line16> return endTimeMs; <line17> } <line18> } <line19> 	 <line3>	Yes
public class A { <line0> private static int getCurrentIterationNumber( <line1> Configuration config, Path modelTempDir, int maxIterations) throws IOException { <line2> FileSystem fs = FileSystem.get(config); <line3> int iterationNumber = 1; <line4> Path iterationPath = modelPath(modelTempDir, iterationNumber); <line5> while (fs.exists(iterationPath) && iterationNumber <= maxIterations) { <line6> iterationNumber++; <line7> iterationPath = modelPath(modelTempDir, iterationNumber); <line8> } <line9> return iterationNumber - 1; <line10> } <line11> } <line12> 	 <line6>	Yes
public class A { <line0> private void migrate(List<Event> events) <line1> throws EventStreamException, InterruptedException, ExecutionException { <line2> List<Event> eventsToSave = getEventsToSave(events); <line3> CompletableFuture<?> future = null; <line4> for (Iterator<Event> it = eventsToSave.iterator(); it.hasNext(); ) { <line5> future = migrate(it.next()); <line6> } <line7> if (future != null) { <line8> future.get(); <line9> } <line10> if (getRequest().isVerbose()) { <line11> } <line12> } <line13> } <line14> 	 <line11>	Yes
"public class A { <line0> @Test <line1> public void test19AnonUpdate() { <line2> Thing thing = THINGS.get(0).withOnlyId(); <line3> thing.setDescription(""Anon Updated Thing made by Admin.""); <line4> try { <line5> serviceAnon.update(thing); <line6> Assert.fail(ANON_SHOULD_NOT_BE_ABLE_TO_UPDATE); <line7> } catch (NotAuthorizedException ex) { <line8> } catch (ServiceFailureException ex) { <line9> Assert.fail(""Expected NotAuthorizedException, got "" + ex); <line10> } <line11> EntityUtils.filterAndCheck(serviceRead.things(), """", THINGS); <line12> } <line13> } <line14> "	 <line8>	Yes
"public class A { <line0> public static Map<String, StreamDefinition> loadStreamDefinitions(String sampleNumber) { <line1> String directoryPath; <line2> if (sampleNumber.length() != 0) { <line3> directoryPath = sampleStreamDefinitionsDirectoryPath.replace(""sampleNumber"", sampleNumber); <line4> } else { <line5> directoryPath = configDirectoryPath; <line6> } <line7> File directory = new File(directoryPath); <line8> Map<String, StreamDefinition> streamDefinitions = new HashMap<String, StreamDefinition>(); <line9> if (!directory.exists()) { <line10> return streamDefinitions; <line11> } <line12> if (!directory.isDirectory()) { <line13> return streamDefinitions; <line14> } <line15> File[] defFiles = directory.listFiles(); <line16> if (defFiles != null) { <line17> for (final File fileEntry : defFiles) { <line18> if (!fileEntry.isDirectory()) { <line19> BufferedReader bufferedReader = null; <line20> StringBuilder stringBuilder = new StringBuilder(); <line21> try { <line22> bufferedReader = new BufferedReader(new FileReader(fileEntry)); <line23> String line; <line24> while ((line = bufferedReader.readLine()) != null) { <line25> stringBuilder.append(line).append(""\n""); <line26> } <line27> StreamDefinition streamDefinition = <line28> EventDefinitionConverterUtils.convertFromJson(stringBuilder.toString().trim()); <line29> streamDefinitions.put(streamDefinition.getStreamId(), streamDefinition); <line30> } catch (FileNotFoundException e) { <line31> log.error(""Error in reading file "" + fileEntry.getName(), e); <line32> } catch (IOException e) { <line33> } catch (MalformedStreamDefinitionException e) { <line34> } finally { <line35> try { <line36> if (bufferedReader != null) { <line37> bufferedReader.close(); <line38> } <line39> } catch (IOException e) { <line40> } <line41> } <line42> } <line43> } <line44> } <line45> return streamDefinitions; <line46> } <line47> } <line48> "	 <line14>	No
"public class A { <line0> @GET <line1> @Produces(MediaType.APPLICATION_JSON) <line2> @Path(""/editors"") <line3> @RolesAllowed({ADMIN_ROLE}) <line4> public Collection<String> getEditors() { <line5> return appFormerActivities.getAllEditorIds(); <line6> } <line7> } <line8> "	 <line5>	Yes
"public class A { <line0> public ActionForward ajaxChangeDiagnosis( <line1> ActionMapping mapping, <line2> ActionForm form, <line3> HttpServletRequest request, <line4> HttpServletResponse response) { <line5> HttpSession session = request.getSession(); <line6> if (session.getAttribute(""userrole"") == null) return mapping.findForward(""expired""); <line7> String strIndex = request.getParameter(""change_diagnosis_id""); <line8> int idx = Integer.parseInt(strIndex); <line9> String substitution = request.getParameter(""newIssueId""); <line10> String sessionFrmName = ""caseManagementEntryForm"" + getDemographicNo(request); <line11> CaseManagementEntryFormBean sessionFrm = <line12> (CaseManagementEntryFormBean) session.getAttribute(sessionFrmName); <line13> CheckBoxBean[] curIssues = sessionFrm.getIssueCheckList(); <line14> if (substitution != null) { <line15> Issue iss = caseManagementMgr.getIssue(substitution); <line16> curIssues[idx].getIssue().setIssue(iss); <line17> curIssues[idx].getIssue().setIssue_id(iss.getId()); <line18> this.caseManagementMgr.saveCaseIssue(curIssues[idx].getIssue()); <line19> Set<CaseManagementIssue> issueset = new HashSet<CaseManagementIssue>(); <line20> for (int i = 0; i < curIssues.length; ++i) { <line21> if (curIssues[i].getChecked().equalsIgnoreCase(""on"")) issueset.add(curIssues[i].getIssue()); <line22> } <line23> sessionFrm.getCaseNote().setIssues(issueset); <line24> } <line25> sessionFrm.setIssueCheckList(curIssues); <line26> request.setAttribute(""caseManagementEntryForm"", sessionFrm); <line27> return mapping.findForward(""issueList_ajax""); <line28> } <line29> } <line30> "	 <line5>	Yes
public class A { <line0> public void passivateObject(LdapConnection connection) { <line1> } <line2> } <line3> 	 <line1>	Yes
public class A { <line0> private boolean isKubernetesVersionSupportsHA() { <line1> boolean haSupported = false; <line2> KubernetesSupportedVersion version = getKubernetesClusterVersion(); <line3> if (version != null) { <line4> try { <line5> if (KubernetesVersionManagerImpl.compareSemanticVersions( <line6> version.getSemanticVersion(), <line7> KubernetesClusterService.MIN_KUBERNETES_VERSION_HA_SUPPORT) <line8> >= 0) { <line9> haSupported = true; <line10> } <line11> } catch (IllegalArgumentException e) { <line12> } <line13> } <line14> return haSupported; <line15> } <line16> } <line17> 	 <line16>	No
"public class A { <line0> protected boolean isValid( <line1> AopMethodInvocation aopMethodInvocation, Object[] arguments, int phase) { <line2> Method method = aopMethodInvocation.getMethod(); <line3> Class<?>[] parameterTypes = method.getParameterTypes(); <line4> if (parameterTypes.length == 0) { <line5> if (_log.isDebugEnabled() && (phase == _PHASE_BEFORE)) { <line6> } <line7> return false; <line8> } <line9> Class<?> parameterType = parameterTypes[0]; <line10> if (!ClassedModel.class.isAssignableFrom(parameterType)) { <line11> if (_log.isDebugEnabled() && (phase == _PHASE_BEFORE)) { <line12> } <line13> return false; <line14> } <line15> ClassedModel classedModel = (ClassedModel) arguments[0]; <line16> if ((classedModel == null) || !(classedModel.getPrimaryKeyObj() instanceof Long)) { <line17> if (_log.isDebugEnabled() && (phase == _PHASE_BEFORE)) { <line18> } <line19> return false; <line20> } <line21> if (phase != _PHASE_AFTER_RETURNING) { <line22> return true; <line23> } <line24> if (!AuditedModel.class.isAssignableFrom(parameterType) <line25> && !GroupedModel.class.isAssignableFrom(parameterType) <line26> && !StagedModel.class.isAssignableFrom(parameterType)) { <line27> if (_log.isDebugEnabled()) { <line28> StringBundler sb = new StringBundler(4); <line29> sb.append(""If send is true, the first parameter of ""); <line30> sb.append(aopMethodInvocation); <line31> sb.append("" must implement AuditedModel, GroupedModel, or ""); <line32> sb.append(""StagedModel""); <line33> } <line34> return false; <line35> } <line36> return true; <line37> } <line38> } <line39> "	 <line15>	No
public class A { <line0> private void scanForEvaluators(Reflections annotatedClasses) { <line1> Set<Class<?>> defaultEvaluatorAnnotations = <line2> annotatedClasses.getTypesAnnotatedWith(Evaluator.class, true); <line3> Map<Class<? extends TestFunction>, Class<QueryEvaluator>> testFunctionEvaluators = <line4> new HashMap<>(); <line5> Map<Class<? extends NodeSelector>, Class<QueryEvaluator>> defaultEvaluators = new HashMap<>(); <line6> Map<Class<? extends NodeTest>, Class<TestEvaluator>> testEvaluators = new HashMap<>(); <line7> Map<Class<? extends SelectorFunction>, Class<QueryEvaluator>> functionEvaluators = <line8> new HashMap<>(); <line9> for (Class clazz : defaultEvaluatorAnnotations) { <line10> Evaluator evaluator = (Evaluator) clazz.getAnnotation(Evaluator.class); <line11> Class[] functionClasses = evaluator.value(); <line12> for (Class functionClass : functionClasses) { <line13> if (ClassUtils.isAssignable(functionClass, TestFunction.class)) { <line14> testFunctionEvaluators.put((Class<? extends TestFunction>) functionClass, clazz); <line15> } else if (ClassUtils.isAssignable(functionClass, NodeTest.class)) { <line16> testEvaluators.put((Class<? extends NodeTest>) functionClass, clazz); <line17> } else if (ClassUtils.isAssignable(functionClass, SelectorFunction.class)) { <line18> functionEvaluators.put((Class<? extends SelectorFunction>) functionClass, clazz); <line19> } else { <line20> defaultEvaluators.put((Class<? extends NodeSelector>) functionClass, clazz); <line21> } <line22> } <line23> } <line24> evaluatorConfiguration.setDefaultEvaluators(defaultEvaluators); <line25> evaluatorConfiguration.setTestEvaluators(testEvaluators); <line26> evaluatorConfiguration.setTestFunctionEvaluators(testFunctionEvaluators); <line27> evaluatorConfiguration.setFunctionEvaluators(functionEvaluators); <line28> } <line29> } <line30> 	 <line1>	No
"public class A { <line0> @Override <line1> public InterpreterResult interpret(String cypherQuery, InterpreterContext interpreterContext) { <line2> if (StringUtils.isBlank(cypherQuery)) { <line3> return new InterpreterResult(Code.SUCCESS); <line4> } <line5> final List<String> queries = <line6> isMultiStatementEnabled <line7> ? Arrays.asList(cypherQuery.split("";[^'|^\""|^(\\w+`)]"")) <line8> : Arrays.asList(cypherQuery); <line9> if (queries.size() == 1) { <line10> final String query = queries.get(0); <line11> return runQuery(query, interpreterContext); <line12> } else { <line13> final int lastIndex = queries.size() - 1; <line14> final List<String> subQueries = queries.subList(0, lastIndex); <line15> for (String query : subQueries) { <line16> runQuery(query, interpreterContext); <line17> } <line18> return runQuery(queries.get(lastIndex), interpreterContext); <line19> } <line20> } <line21> } <line22> "	 <line3>	No
"public class A { <line0> private void processAttributes( <line1> Iterator<Attribute> att, <line2> QName currentNode, <line3> Stack<Object> sbmlElements, <line4> ReadingParser parser, <line5> boolean hasAttributes, <line6> boolean isInsideAnnotation) { <line7> ReadingParser attributeParser = null; <line8> while (att.hasNext()) { <line9> Attribute attribute = att.next(); <line10> boolean isLastAttribute = !att.hasNext(); <line11> QName attributeName = attribute.getName(); <line12> if (attribute.getName().getNamespaceURI().length() > 0) { <line13> String attributeNamespaceURI = attribute.getName().getNamespaceURI(); <line14> if (isInsideAnnotation) { <line15> attributeParser = initializedParsers.get(""anyXML""); <line16> } else { <line17> attributeParser = initializedParsers.get(attributeNamespaceURI); <line18> } <line19> } else { <line20> attributeParser = parser; <line21> } <line22> if (attributeParser != null) { <line23> boolean isAttributeRead = <line24> attributeParser.processAttribute( <line25> currentNode.getLocalPart(), <line26> attributeName.getLocalPart(), <line27> attribute.getValue(), <line28> attributeName.getNamespaceURI(), <line29> attributeName.getPrefix(), <line30> isLastAttribute, <line31> sbmlElements.peek()); <line32> if (!isAttributeRead) { <line33> AbstractReaderWriter.processUnknownAttribute( <line34> attributeName.getLocalPart(), <line35> attributeName.getNamespaceURI(), <line36> attribute.getValue(), <line37> attributeName.getPrefix(), <line38> sbmlElements.peek()); <line39> } <line40> } else { <line41> } <line42> } <line43> } <line44> } <line45> "	 <line41>	Yes
"public class A { <line0> @POST <line1> @Timed <line2> @Produces(""application/x-yaml"") <line3> @Path(""adps"") <line4> @ApiOperation(""Get SeaClouds-compliant ADP list from an AAM document"") <line5> public Response getAdps(@ApiParam() String aam) { <line6> if (aam == null) { <line7> return Response.status(Response.Status.NOT_ACCEPTABLE).build(); <line8> } else { <line9> return Response.ok(planner.getAdps(aam)).build(); <line10> } <line11> } <line12> } <line13> "	 <line7>	Yes
public class A { <line0> @Override <line1> public void onSuccess(Request request) { <line2> final UserJS userJS = request.getResult(); <line3> if (userJS != null) { <line4> final UserDTO userDTO = userJS.toDTO(); <line5> transaction.getObjectCache().put(id, userDTO); <line6> orgUnitDAO.get( <line7> userJS.getMainOrgUnit(), <line8> new AsyncCallback<OrgUnitDTO>() { <line9> @Override <line10> public void onFailure(Throwable caught) { <line11> } <line12>  <line13> @Override <line14> public void onSuccess(OrgUnitDTO result) { <line15> userDTO.setMainOrgUnit(result); <line16> callback.onSuccess(userDTO); <line17> } <line18> }, <line19> transaction); <line20> } else { <line21> callback.onSuccess(null); <line22> } <line23> } <line24> } <line25> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void onFailure(final ProviderException result) { <line2> lock.readLock().lock(); <line3> try { <line4> if (closingConnection.get() || closed.get() || failed.get()) { <line5> requests.remove(id); <line6> super.onFailure(result); <line7> } else { <line8> processAlternates(provider.getAlternateURIs()); <line9> handleProviderFailure( <line10> activeProvider, ProviderExceptionSupport.createOrPassthroughFatal(result)); <line11> } <line12> } finally { <line13> lock.readLock().unlock(); <line14> } <line15> } <line16> } <line17> 	 <line14>	No
public class A { <line0> void handleLoopException(Throwable t) { <line1> try { <line2> Thread.sleep(1000); <line3> } catch (InterruptedException e) { <line4> } <line5> } <line6> } <line7> 	 <line2>	No
"public class A { <line0> private void handleRoomScene(ChannelUID channelUID, OnOffType command) { <line1> int linkNum; <line2> switch (channelUID.getId()) { <line3> case ""scene_a"": <line4> linkNum = 0; <line5> break; <line6> case ""scene_b"": <line7> linkNum = 1; <line8> break; <line9> case ""scene_c"": <line10> linkNum = 2; <line11> break; <line12> case ""scene_d"": <line13> linkNum = 3; <line14> break; <line15> default: <line16> return; <line17> } <line18> int roomNum = (thingID + 7) / 8; <line19> int param2 = ((roomNum * 6) - 3) + linkNum; <line20> sendOmnilinkCommand( <line21> OnOffType.ON.equals(command) <line22> ? CommandMessage.CMD_UNIT_UPB_LINK_ON <line23> : CommandMessage.CMD_UNIT_UPB_LINK_OFF, <line24> 0, <line25> param2); <line26> } <line27> } <line28> "	 <line1>	Yes
"public class A { <line0> public String run() throws IOException { <line1> Process process = new ProcessBuilder(mCommand).redirectErrorStream(true).start(); <line2> BufferedReader inReader = <line3> new BufferedReader( <line4> new InputStreamReader(process.getInputStream(), Charset.defaultCharset())); <line5> try { <line6> StringBuilder output = new StringBuilder(); <line7> String line = inReader.readLine(); <line8> while (line != null) { <line9> output.append(line); <line10> output.append(""\n""); <line11> line = inReader.readLine(); <line12> } <line13> int exitCode = process.waitFor(); <line14> if (exitCode != 0) { <line15> throw new ShellUtils.ExitCodeException(exitCode, output.toString()); <line16> } <line17> return output.toString(); <line18> } catch (InterruptedException e) { <line19> Thread.currentThread().interrupt(); <line20> throw new IOException(e); <line21> } finally { <line22> try { <line23> InputStream stdout = process.getInputStream(); <line24> synchronized (stdout) { <line25> inReader.close(); <line26> } <line27> } catch (IOException e) { <line28> } <line29> process.destroy(); <line30> } <line31> } <line32> } <line33> "	 <line9>	No
"public class A { <line0> private static void test(int m, int n) { <line1> for (int a = 2; ; a++) { <line2> BigInteger aPow = BigInteger.valueOf(a).pow(m); <line3> long nthRoot = Roots.ithRoot(aPow, n)[0].longValue(); <line4> long bMin = Math.max(0, nthRoot - b_COUNT); <line5> long bMax = nthRoot + b_COUNT; <line6> for (long b = bMax; b >= bMin; b--) { <line7> if (gcdEngine.gcd(a, b) == 1) { <line8> BigInteger bPow = BigInteger.valueOf(b).pow(n); <line9> BigInteger lhs = aPow.add(bPow); <line10> PurePowerTest.Result rhs = powerTest.test(lhs); <line11> if (rhs != null) { <line12> LOG.debug(n + "".th root(a^m) = "" + nthRoot + "", b - nthRoot = "" + (b - nthRoot)); <line13> } <line14> } <line15> } <line16> for (long b = nthRoot; b >= bMin; b--) { <line17> if (gcdEngine.gcd(a, b) == 1) { <line18> BigInteger bPow = BigInteger.valueOf(b).pow(n); <line19> BigInteger lhs = aPow.subtract(bPow); <line20> PurePowerTest.Result rhs = powerTest.test(lhs); <line21> if (rhs != null) { <line22> LOG.debug(n + "".th root(a^m) = "" + nthRoot + "", b - nthRoot = "" + (b - nthRoot)); <line23> } <line24> } <line25> } <line26> for (long b = nthRoot + 1; b <= bMax; b++) { <line27> if (gcdEngine.gcd(a, b) == 1) { <line28> BigInteger bPow = BigInteger.valueOf(b).pow(n); <line29> BigInteger lhs = bPow.subtract(aPow); <line30> PurePowerTest.Result rhs = powerTest.test(lhs); <line31> if (rhs != null) { <line32> } <line33> } <line34> } <line35> } <line36> } <line37> } <line38> "	 <line31>	No
public class A { <line0> private PolicyFinder createPolicyFinder() { <line1> PolicyFinder policyFinder = new PolicyFinder(); <line2> PollingPolicyFinderModule policyFinderModule = <line3> new PollingPolicyFinderModule( <line4> xacmlPolicyDirectories, defaultPollingIntervalInSeconds, securityLogger); <line5> policyFinderModule.start(); <line6> Set<PolicyFinderModule> policyFinderModules = new HashSet<>(1); <line7> policyFinderModules.add(policyFinderModule); <line8> policyFinder.setModules(policyFinderModules); <line9> return policyFinder; <line10> } <line11> } <line12> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> Group group = this.group; <line3> if (group == null) { <line4> return; <line5> } <line6> if (command instanceof RefreshType) { <line7> } else { <line8> if (channelUID.getId().equals(CBusBindingConstants.CHANNEL_VALUE)) { <line9> try { <line10> if (command instanceof DecimalType) { <line11> group.TriggerEvent(((DecimalType) command).intValue()); <line12> } <line13> } catch (CGateException e) { <line14> updateStatus( <line15> ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ""Communication Error""); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> "	 <line12>	No
"public class A { <line0> private void bulkInsertContentData(List<Object[]> contentRows) <line1> throws DatabaseException, SQLException { <line2> if (contentRows.size() > 0) { <line3> PreparedStatement statement = <line4> this.generateBulkInsertStatement( <line5> ""cp2_content"", <line6> contentRows.size(), <line7> ""uuid"", <line8> ""content_id"", <line9> ""created"", <line10> ""updated"", <line11> ""contenturl"", <line12> ""gpgurl"", <line13> ""label"", <line14> ""metadataexpire"", <line15> ""name"", <line16> ""releasever"", <line17> ""requiredtags"", <line18> ""type"", <line19> ""vendor"", <line20> ""arches"", <line21> ""locked""); <line22> int index = 0; <line23> for (Object[] row : contentRows) { <line24> for (Object col : row) { <line25> this.setParameter(statement, ++index, col); <line26> } <line27> } <line28> int count = statement.executeUpdate(); <line29> if (count != contentRows.size()) { <line30> String errmsg = <line31> String.format( <line32> ""Wrong number of contents migrated. Expected: %s, Inserted: %s"", <line33> contentRows.size(), count); <line34> throw new DatabaseException(errmsg); <line35> } <line36> statement.close(); <line37> } <line38> } <line39> } <line40> "	 <line36>	Yes
public class A { <line0> protected void onNodeDeletePost( <line1> final String networkId, final Node node, final HashMap<String, Response> respList) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> protected void requestFinalize(String fileName) { <line1> Set<String> filesPerWindow = finalizedFiles.get(currentWindow); <line2> if (filesPerWindow == null) { <line3> filesPerWindow = Sets.newHashSet(); <line4> finalizedFiles.put(currentWindow, filesPerWindow); <line5> } <line6> if (rollingFile) { <line7> MutableInt part = finalizedPart.get(fileName); <line8> if (part == null) { <line9> part = new MutableInt(-1); <line10> finalizedPart.put(fileName, part); <line11> } <line12> MutableInt currentOpenPart = openPart.get(fileName); <line13> for (int x = part.getValue() + 1; x <= currentOpenPart.getValue(); x++) { <line14> String prevPartNotFinalized = getPartFileName(fileName, x); <line15> filesPerWindow.add(prevPartNotFinalized); <line16> } <line17> fileName = getPartFileNamePri(fileName); <line18> part.setValue(currentOpenPart.getValue()); <line19> } <line20> filesPerWindow.add(fileName); <line21> } <line22> } <line23> 	 <line5>	No
"public class A { <line0> @Override <line1> public Response toResponse(ContextInferrenceFailedException exception) { <line2> Object entity = Collections.EMPTY_LIST; <line3> if (headers.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XML_TYPE)) { <line4> entity = new EmptyResponse(); <line5> } <line6> return Response.status(Status.NOT_FOUND).entity(entity).header(""TotalCount"", 0).build(); <line7> } <line8> } <line9> "	 <line7>	No
"public class A { <line0> @Test <line1> public void test() throws IOException { <line2> JsonRpcClient client = createJsonRpcClient(""/jsonrpc""); <line3> Params params = new Params(); <line4> params.param1 = ""Value1""; <line5> params.param2 = ""Value2""; <line6> Params result = client.sendRequest(""echo"", params, Params.class); <line7> Assert.assertEquals(params.param1, result.param1); <line8> Assert.assertEquals(params.param2, result.param2); <line9> client.close(); <line10> } <line11> } <line12> "	 <line7>	Yes
"public class A { <line0> @After <line1> public void tearDown() { <line2> try { <line3> if (nominalLabel != null) { <line4> entityManager.getTransaction().begin(); <line5> nominalLabelResourceFacadeImp.deleteNominalLabel(nominalLabel); <line6> entityManager.getTransaction().commit(); <line7> nominalLabel = null; <line8> } <line9> } catch (PropertyNotSetException e) { <line10> fail(""tearDown failed""); <line11> } <line12> } <line13> } <line14> "	 <line10>	Yes
public class A { <line0> public void writeMetadataValue(Locator locator, String metaKey, String metaValue) <line1> throws ConnectionException { <line2> Timer.Context ctx = <line3> Instrumentation.getWriteTimerContext(CassandraModel.CF_METRICS_METADATA_NAME); <line4> try { <line5> keyspace <line6> .prepareColumnMutation(CassandraModel.CF_METRICS_METADATA, locator, metaKey) <line7> .putValue(metaValue, StringMetadataSerializer.get(), null) <line8> .execute(); <line9> } catch (ConnectionException e) { <line10> Instrumentation.markWriteError(e); <line11> throw e; <line12> } finally { <line13> ctx.stop(); <line14> } <line15> } <line16> } <line17> 	 <line9>	No
"public class A { <line0> public static void main(String[] args) { <line1> long startTime = 0; <line2> long endTime = 0; <line3> long aggregatorStart = Calendar.getInstance().getTimeInMillis(); <line4> long longest = 0; <line5> if (args.length >= 4) { <line6> ParsePosition pp = new ParsePosition(0); <line7> SimpleDateFormat format = new SimpleDateFormat(""yyyy-MM-dd HH:mm""); <line8> String buffer = args[0] + "" "" + args[1]; <line9> Date tmp = format.parse(buffer, pp); <line10> startTime = tmp.getTime(); <line11> buffer = args[2] + "" "" + args[3]; <line12> pp = new ParsePosition(0); <line13> tmp = format.parse(buffer, pp); <line14> endTime = tmp.getTime(); <line15> } <line16> String longQuery = null; <line17> String cluster = System.getProperty(""CLUSTER""); <line18> if (cluster == null) { <line19> cluster = ""unknown""; <line20> } <line21> String queries = <line22> Aggregator.getContents( <line23> new File(System.getenv(""CHUKWA_CONF_DIR"") + File.separator + ""aggregator.sql"")); <line24> String[] query = queries.split(""\n""); <line25> while (startTime <= endTime) { <line26> for (int i = 0; i < query.length; i++) { <line27> if (query[i].indexOf(""#"") == 0) { <line28> } else if (!query[i].equals("""")) { <line29> Aggregator dba = new Aggregator(); <line30> dba.setWriter(new DatabaseWriter(cluster)); <line31> long start = Calendar.getInstance().getTimeInMillis(); <line32> try { <line33> if (startTime != 0 && endTime != 0) { <line34> dba.process(startTime, startTime, query[i]); <line35> } else { <line36> dba.process(query[i]); <line37> } <line38> } catch (Throwable e) { <line39> } <line40> long end = Calendar.getInstance().getTimeInMillis(); <line41> long duration = end - start; <line42> if (duration >= longest) { <line43> longest = duration; <line44> longQuery = query[i]; <line45> } <line46> } <line47> } <line48> startTime = startTime + 5 * 60000; <line49> } <line50> long aggregatorEnd = Calendar.getInstance().getTimeInMillis(); <line51> } <line52> } <line53> "	 <line51>	Yes
"public class A { <line0> @RequestMapping(value = ""upload"", method = RequestMethod.POST) <line1> public @ResponseBody ResponseEntity<UploadFileContainer> upload( <line2> MultipartHttpServletRequest request, HttpServletResponse response) { <line3> if (path == null) { <line4> return new ResponseEntity<UploadFileContainer>(HttpStatus.INTERNAL_SERVER_ERROR); <line5> } <line6> LinkedList<FileMeta> files = new LinkedList<FileMeta>(); <line7> MultipartFile mpf = null; <line8> for (Iterator<String> it = request.getFileNames(); it.hasNext(); ) { <line9> mpf = request.getFile(it.next()); <line10> FileMeta fileContainer = new FileMeta(); <line11> fileContainer.setName(mpf.getOriginalFilename()); <line12> fileContainer.setSize(mpf.getSize() / 1024 + ""Kb""); <line13> fileContainer.setFileType(mpf.getContentType()); <line14> try { <line15> fileContainer.setBytes(mpf.getBytes()); <line16> createFolderIfNotExists(); <line17> FileCopyUtils.copy( <line18> mpf.getBytes(), <line19> new BufferedOutputStream(new FileOutputStream(path + mpf.getOriginalFilename()))); <line20> } catch (IOException e) { <line21> fileContainer.setError(e.getMessage()); <line22> } <line23> files.add(fileContainer); <line24> } <line25> UploadFileContainer uploadFileContainer = new UploadFileContainer(files); <line26> return new ResponseEntity<UploadFileContainer>(uploadFileContainer, HttpStatus.OK); <line27> } <line28> } <line29> "	 <line18>	No
public class A { <line0> public static List<HoodieRecord> convertMetadataToRecords( <line1> HoodieCleanerPlan cleanerPlan, String instantTime) { <line2> List<HoodieRecord> records = new LinkedList<>(); <line3> int[] fileDeleteCount = {0}; <line4> cleanerPlan <line5> .getFilePathsToBeDeletedPerPartition() <line6> .forEach( <line7> (partition, deletedPathInfo) -> { <line8> fileDeleteCount[0] += deletedPathInfo.size(); <line9> List<String> deletedFilenames = <line10> deletedPathInfo.stream() <line11> .map(p -> new Path(p.getFilePath()).getName()) <line12> .collect(Collectors.toList()); <line13> HoodieRecord record = <line14> HoodieMetadataPayload.createPartitionFilesRecord( <line15> partition, Option.empty(), Option.of(deletedFilenames)); <line16> records.add(record); <line17> }); <line18> return records; <line19> } <line20> } <line21> 	 <line20>	No
public class A { <line0> private Map<String, Action> loadAllReferencedActions(Auth auth) { <line1> Map<String, Action> actionMap = new HashMap<>(); <line2> for (Userprofile userprofile : auth.getUserprofiles().getUserprofile()) { <line3> List<ProfileRef> profileList = userprofile.getProfileRef(); <line4> if (profileList != null) { <line5> for (ProfileRef profileRef : profileList) { <line6> Profile profileWithActions = getProfileMap().get(profileRef.getName()); <line7> if (profileWithActions != null) { <line8> List<Action> actionList = profileWithActions.getAction(); <line9> for (Action action : actionList) { <line10> actionMap.put(action.getId(), action); <line11> } <line12> } else { <line13> } <line14> } <line15> } <line16> } <line17> return actionMap; <line18> } <line19> } <line20> 	 <line5>	No
"public class A { <line0> @Override <line1> public Authentication authenticate(Authentication authentication) <line2> throws InsightsAuthenticationException { <line3> if (!supports(authentication.getClass())) { <line4> throw new IllegalArgumentException( <line5> ""Only SAMLAuthenticationToken is supported, "" <line6> + authentication.getClass() <line7> + "" was attempted""); <line8> } <line9> if (authentication.getPrincipal() == null) { <line10> throw new AuthenticationCredentialsNotFoundException(""Authentication token is missing""); <line11> } <line12> validateIncomingToken(authentication.getPrincipal()); <line13> return authentication; <line14> } <line15> } <line16> "	 <line14>	No
"public class A { <line0> private String _getViewURL(Locale locale, ThemeDisplay themeDisplay) { <line1> try { <line2> ThemeDisplay clonedThemeDisplay = (ThemeDisplay) themeDisplay.clone(); <line3> clonedThemeDisplay.setScopeGroupId(_journalArticle.getGroupId()); <line4> return Optional.ofNullable( <line5> _assetDisplayPageFriendlyURLProvider.getFriendlyURL( <line6> JournalArticle.class.getName(), <line7> _journalArticle.getResourcePrimKey(), <line8> locale, <line9> clonedThemeDisplay)) <line10> .map( <line11> url -> { <line12> String backURL = ParamUtil.getString(_httpServletRequest, ""backURL""); <line13> if (Validator.isNotNull(backURL)) { <line14> return _http.setParameter(url, ""p_l_back_url"", backURL); <line15> } <line16> return _http.setParameter(url, ""p_l_back_url"", themeDisplay.getURLCurrent()); <line17> }) <line18> .orElse(StringPool.BLANK); <line19> } catch (CloneNotSupportedException | PortalException exception) { <line20> return StringPool.BLANK; <line21> } <line22> } <line23> } <line24> "	 <line21>	No
public class A { <line0> private void requeueAll() { <line1> Map<String, Set<String>> depositSet = getQueuedDepositsWithJobs(); <line2> Set<Map<String, String>> depositStatuses = depositStatusFactory.getAll(); <line3> for (Map<String, String> fields : depositStatuses) { <line4> DepositState depositState = DepositState.valueOf(fields.get(DepositField.state.name())); <line5> if (DepositState.running.equals(depositState) || DepositState.quieted.equals(depositState)) { <line6> String uuid = fields.get(DepositField.uuid.name()); <line7> depositStatusFactory.removeSupervisorLock(uuid); <line8> if (depositSet.containsKey(uuid)) { <line9> if (depositSet.get(uuid).contains(CleanupDepositJob.class.getName())) { <line10> depositStatusFactory.setState(uuid, DepositState.finished); <line11> } else { <line12> } <line13> } else { <line14> depositStatusFactory.requestAction(uuid, DepositAction.resume); <line15> } <line16> } <line17> } <line18> for (Map<String, String> fields : depositStatuses) { <line19> DepositState depositState = DepositState.valueOf(fields.get(DepositField.state.name())); <line20> if (DepositState.queued.equals(depositState)) { <line21> String uuid = fields.get(DepositField.uuid.name()); <line22> depositStatusFactory.removeSupervisorLock(uuid); <line23> if (depositSet.containsKey(uuid)) { <line24> if (depositSet.get(uuid).contains(CleanupDepositJob.class.getName())) { <line25> depositStatusFactory.setState(uuid, DepositState.finished); <line26> } else { <line27> } <line28> } else { <line29> List<String> successfulJobs = jobStatusFactory.getSuccessfulJobNames(uuid); <line30> if (successfulJobs != null && successfulJobs.size() > 0) { <line31> depositStatusFactory.requestAction(uuid, DepositAction.resume); <line32> } else { <line33> depositStatusFactory.requestAction(uuid, DepositAction.register); <line34> } <line35> } <line36> } <line37> } <line38> } <line39> } <line40> 	 <line12>	Yes
public class A { <line0> private BookieId setBookieInTheEnsemble( <line1> int ensembleSize, <line2> int writeQuorumSize, <line3> List<BookieId> currentEnsemble, <line4> List<BookieId> newEnsemble, <line5> int bookieToReplaceIndex, <line6> int desiredNumZonesPerWriteQuorumForThisEnsemble, <line7> Set<BookieId> excludeBookies) <line8> throws BKNotEnoughBookiesException { <line9> BookieId bookieToReplace = currentEnsemble.get(bookieToReplaceIndex); <line10> Set<String> zonesToExclude = null; <line11> Set<BookieNode> bookiesToConsiderAfterExcludingZonesAndUDs = null; <line12> for (int numberOfNeighborsToConsider = (desiredNumZonesPerWriteQuorumForThisEnsemble - 1); <line13> numberOfNeighborsToConsider >= (minNumZonesPerWriteQuorum - 1); <line14> numberOfNeighborsToConsider--) { <line15> zonesToExclude = <line16> getZonesOfNeighboringNodesInEnsemble( <line17> currentEnsemble, bookieToReplaceIndex, (numberOfNeighborsToConsider)); <line18> bookiesToConsiderAfterExcludingZonesAndUDs = <line19> getBookiesToConsiderAfterExcludingZonesAndUDs( <line20> ensembleSize, <line21> writeQuorumSize, <line22> currentEnsemble, <line23> bookieToReplaceIndex, <line24> excludeBookies, <line25> zonesToExclude); <line26> if (!bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) { <line27> break; <line28> } <line29> } <line30> if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) { <line31> zonesToExclude = <line32> getZonesToExcludeToMaintainMinZones( <line33> currentEnsemble, bookieToReplaceIndex, writeQuorumSize); <line34> bookiesToConsiderAfterExcludingZonesAndUDs = <line35> getBookiesToConsiderAfterExcludingZonesAndUDs( <line36> ensembleSize, <line37> writeQuorumSize, <line38> currentEnsemble, <line39> bookieToReplaceIndex, <line40> excludeBookies, <line41> zonesToExclude); <line42> } <line43> if (bookiesToConsiderAfterExcludingZonesAndUDs.isEmpty()) { <line44> throw new BKNotEnoughBookiesException(); <line45> } <line46> BookieId candidateAddr = <line47> selectCandidateNode(bookiesToConsiderAfterExcludingZonesAndUDs).getAddr(); <line48> newEnsemble.set(bookieToReplaceIndex, candidateAddr); <line49> return candidateAddr; <line50> } <line51> } <line52> 	 <line47>	No
"public class A { <line0> @Test <line1> public final void testWaitingForConnectionPoolDisabled(TestContext testContext) { <line2> final MailConfig config = configNoSSL().setMaxPoolSize(1).setKeepAlive(false); <line3> Async async = testContext.async(); <line4> Async async2 = testContext.async(); <line5> AtomicBoolean haveGotConnection = new AtomicBoolean(false); <line6> SMTPConnectionPool pool = new SMTPConnectionPool(vertx, config); <line7> testContext.assertEquals(0, pool.connCount()); <line8> pool.getConnection( <line9> ""hostname"", <line10> result -> { <line11> if (result.succeeded()) { <line12> testContext.assertEquals(1, pool.connCount()); <line13> pool.getConnection( <line14> ""hostname"", <line15> result2 -> { <line16> if (result2.succeeded()) { <line17> haveGotConnection.set(true); <line18> testContext.assertEquals(1, pool.connCount()); <line19> result2.result().returnToPool(); <line20> pool.close( <line21> v -> { <line22> testContext.assertEquals(0, pool.connCount()); <line23> async.complete(); <line24> }); <line25> } else { <line26> testContext.fail(result2.cause()); <line27> } <line28> }); <line29> testContext.assertFalse( <line30> haveGotConnection.get(), ""got a connection on the 2nd try already""); <line31> testContext.assertEquals(1, pool.connCount()); <line32> result.result().returnToPool(); <line33> vertx.setTimer( <line34> 1000, <line35> v -> { <line36> testContext.assertTrue( <line37> haveGotConnection.get(), ""didn't get a connection on the 2nd try""); <line38> testContext.assertEquals(0, pool.connCount()); <line39> async2.complete(); <line40> }); <line41> } else { <line42> testContext.fail(result.cause()); <line43> } <line44> }); <line45> } <line46> } <line47> "	 <line9>	No
public class A { <line0> private void loadTasksFromDB(List<DataSourceInfoModel> dataSources) { <line1> try { <line2> for (final DataSourceInfoModel dataSource : dataSources) { <line3> initTask(dataSource); <line4> } <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
"public class A { <line0> protected void appendLimitQueryBlock(FieldSearchFilter[] filters, StringBuffer query) { <line1> try { <line2> if (null == filters || filters.length == 0) { <line3> return; <line4> } <line5> for (FieldSearchFilter filter : filters) { <line6> if (filter.getOffset() != null && filter.getLimit() != null) { <line7> query.append( <line8> QueryLimitResolver.createLimitBlock( <line9> filter, this.getDataSource(), this.getDataSourceClassName())); <line10> break; <line11> } <line12> } <line13> } catch (Throwable t) { <line14> throw new RuntimeException(""error building limit query"", t); <line15> } <line16> } <line17> } <line18> "	 <line3>	Yes
public class A { <line0> private static void importDirectory(ZipInputStream zis, ZipEntry entry) throws IOException { <line1> if (entry.isDirectory()) { <line2> File newDir = new File(entry.getName()); <line3> if (!newDir.exists()) { <line4> newDir.mkdirs(); <line5> } <line6> } else { <line7> File newFile = new File(entry.getName()); <line8> boolean overwrite = false; <line9> if (!newFile.exists()) { <line10> overwrite = true; <line11> } else { <line12> if (newFile.lastModified() < entry.getTime()) { <line13> overwrite = true; <line14> } <line15> } <line16> if (overwrite) { <line17> FileOutputStream fos = new FileOutputStream(newFile); <line18> IOUtils.copy(zis, fos); <line19> fos.flush(); <line20> fos.close(); <line21> } <line22> } <line23> } <line24> } <line25> 	 <line15>	No
public class A { <line0> static void reTryKerberos(boolean enabled) { <line1> if (enabled) { <line2> try { <line3> if (UserGroupInformation.isLoginKeytabBased()) { <line4> UserGroupInformation.getLoginUser().reloginFromKeytab(); <line5> } else if (UserGroupInformation.isLoginTicketBased()) { <line6> UserGroupInformation.getLoginUser().reloginFromTicketCache(); <line7> } <line8> } catch (IOException e) { <line9> throw new RuntimeException(e); <line10> } <line11> } <line12> } <line13> } <line14> 	 <line1>	No
public class A { <line0> @Override <line1> public Iterator<TypedValue<Item>> iterator() { <line2> return new Iterator<TypedValue<Item>>() { <line3> private SequenceIterator iterator; <line4>  <line5> private SequenceIterator getIterator() { <line6> if (iterator == null) { <line7> try { <line8> iterator = sequence.iterate(); <line9> } catch (final XPathException xpe) { <line10> iterator = SequenceIterator.EMPTY_ITERATOR; <line11> } <line12> } <line13> return iterator; <line14> } <line15>  <line16> @Override <line17> public boolean hasNext() { <line18> return getIterator().hasNext(); <line19> } <line20>  <line21> @Override <line22> public TypedValue<Item> next() { <line23> return createTypedValue(getIterator().nextItem()); <line24> } <line25>  <line26> @Override <line27> public void remove() {} <line28> }; <line29> } <line30> } <line31> 	 <line10>	Yes
public class A { <line0> @Override <line1> public Note get(String noteId, String notePath, String revId, AuthenticationInfo subject) { <line2> Note revisionNote = null; <line3> try { <line4> if (isRevisionSupportedInDefaultRepo()) { <line5> revisionNote = <line6> ((NotebookRepoWithVersionControl) getRepo(0)).get(noteId, notePath, revId, subject); <line7> } <line8> } catch (IOException e) { <line9> } <line10> return revisionNote; <line11> } <line12> } <line13> 	 <line9>	Yes
"public class A { <line0> @Test <line1> public void testFindObjectsXML01() { <line2> try { <line3> String url = ""objects?terms=*Helicopter&resultFormat=xml""; <line4> String response = httpUtils.get(url); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> boolean check = response.contains(""<pid>test:1000003</pid>""); <line8> Assert.assertTrue(""Expected object data not found"", check); <line9> } catch (AuthorizationDeniedException ade) { <line10> if (logger.isDebugEnabled()) { <line11> } <line12> } catch (Exception re) { <line13> Assert.fail(re.getMessage()); <line14> } <line15> } <line16> } <line17> "	 <line11>	Yes
public class A { <line0> @Override <line1> public void draggedImage_movedTo(NSImage image, NSPoint point) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> @Override <line1> public void setData(DataID dataId, String dataValue) { <line2> XNamedGraph g = getOrCreateWollMuxDatenGraph(); <line3> if (g == null) { <line4> return; <line5> } <line6> try { <line7> XURI uri = getDataIdURI(dataId); <line8> try { <line9> g.removeStatements(xDMA, uri, null); <line10> } catch (NoSuchElementException x) { <line11> } <line12> g.addStatement(xDMA, uri, Literal.create(UNO.defaultContext, dataValue)); <line13> } catch (Exception e) { <line14> } <line15> } <line16> } <line17> 	 <line7>	No
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private void insertOrgInfoToEs(Request actorMessage) { <line2> Map<String, String> headerMap = new HashMap<>(); <line3> String header = ProjectUtil.getConfigValue(JsonKey.EKSTEP_AUTHORIZATION); <line4> header = JsonKey.BEARER + header; <line5> headerMap.put(JsonKey.AUTHORIZATION, header); <line6> headerMap.put(""Content-Type"", ""application/json""); <line7> Map<String, Object> orgMap = <line8> (Map<String, Object>) actorMessage.getRequest().get(JsonKey.ORGANISATION); <line9> if (MapUtils.isNotEmpty(orgMap)) { <line10> Util.DbInfo orgDbInfo = Util.dbInfoMap.get(JsonKey.ORG_DB); <line11> String id = (String) orgMap.get(JsonKey.ID); <line12> Response orgResponse = <line13> cassandraOperation.getRecordById( <line14> orgDbInfo.getKeySpace(), <line15> orgDbInfo.getTableName(), <line16> id, <line17> actorMessage.getRequestContext()); <line18> List<Map<String, Object>> orgList = <line19> (List<Map<String, Object>>) orgResponse.getResult().get(JsonKey.RESPONSE); <line20> Map<String, Object> esMap = new HashMap<>(); <line21> if (!(orgList.isEmpty())) { <line22> esMap = orgList.get(0); <line23> esMap.remove(JsonKey.CONTACT_DETAILS); <line24> String orgLocation = (String) esMap.get(JsonKey.ORG_LOCATION); <line25> List orgLocationList = new ArrayList<>(); <line26> if (StringUtils.isNotBlank(orgLocation)) { <line27> try { <line28> ObjectMapper mapper = new ObjectMapper(); <line29> orgLocationList = mapper.readValue(orgLocation, List.class); <line30> } catch (Exception e) { <line31> } <line32> } <line33> esMap.put(JsonKey.ORG_LOCATION, orgLocationList); <line34> } <line35> registertag(id, ""{}"", headerMap, actorMessage.getRequestContext()); <line36> insertDataToElastic( <line37> ProjectUtil.EsIndex.sunbird.getIndexName(), <line38> ProjectUtil.EsType.organisation.getTypeName(), <line39> id, <line40> esMap, <line41> actorMessage.getRequestContext()); <line42> } <line43> } <line44> } <line45> "	 <line31>	Yes
public class A { <line0> private void testAddFailover(IgniteQueue<Integer> queue, final List<Integer> killIdxs) <line1> throws Exception { <line2> assert !killIdxs.isEmpty(); <line3> final AtomicBoolean stop = new AtomicBoolean(); <line4> IgniteInternalFuture<?> fut = startNodeKiller(stop, new AtomicInteger(), killIdxs); <line5> final int ITEMS = (collectionCacheAtomicityMode() == ATOMIC) ? 10_000 : 3000; <line6> try { <line7> for (int i = 0; i < ITEMS; i++) { <line8> assertTrue(queue.add(i)); <line9> } <line10> } finally { <line11> stop.set(true); <line12> } <line13> fut.get(); <line14> for (int i = 0; i < ITEMS; i++) { <line15> assertEquals((Integer) i, queue.poll()); <line16> } <line17> assertNull(queue.poll()); <line18> assertEquals(0, queue.size()); <line19> } <line20> } <line21> 	 <line9>	Yes
public class A { <line0> private CommitLevel getCommitLevel(String commitLevel) { <line1> if (commitLevel == null) return CommitLevel.COMMIT_ALL; <line2> for (CommitLevel commitLevelEnum : CommitLevel.values()) { <line3> if (commitLevel.equalsIgnoreCase(commitLevelEnum.toString())) { <line4> return commitLevelEnum; <line5> } <line6> } <line7> return CommitLevel.COMMIT_ALL; <line8> } <line9> } <line10> 	 <line0>	No
public class A { <line0> @Override <line1> public String getURL(PortletRequest portletRequest, PortletResponse portletResponse) { <line2> String url = StringPool.BLANK; <line3> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line4> try { <line5> UserGroup userGroup = ActionUtil.getUserGroup(portletRequest); <line6> Group userGroupGroup = userGroup.getGroup(); <line7> url = <line8> PermissionsURLTag.doTag( <line9> StringPool.BLANK, <line10> Group.class.getName(), <line11> themeDisplay.getScopeGroupName(), <line12> null, <line13> String.valueOf(userGroupGroup.getGroupId()), <line14> LiferayWindowState.POP_UP.toString(), <line15> null, <line16> themeDisplay.getRequest()); <line17> } catch (Exception exception) { <line18> if (_log.isDebugEnabled()) { <line19> } <line20> } <line21> return url; <line22> } <line23> } <line24> 	 <line19>	Yes
"public class A { <line0> @Override <line1> public void onReceive(Double doubleOut, String stringOut) { <line2> if (!stringOut.equals(""boom"") || !IltUtil.cmpDouble(doubleOut, 1.1d)) { <line3> subscribeBroadcastWithMultiplePrimitiveParametersCallbackResult = false; <line4> } else { <line5> subscribeBroadcastWithMultiplePrimitiveParametersCallbackResult = true; <line6> } <line7> subscribeBroadcastWithMultiplePrimitiveParametersCallbackDone = true; <line8> } <line9> } <line10> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void audit(String message, Supplier... paramSuppliers) { <line2> StringBuilder messageBuilder = new StringBuilder(); <line3> requestIpAndPortAndUserMessage(PhaseInterceptorChain.getCurrentMessage(), messageBuilder); <line4> } <line5> } <line6> 	 <line0>	No
"public class A { <line0> @RequestMapping(method = RequestMethod.DELETE, value = ""/{query}"") <line1> @ApiOperation( <line2> value = ""delete parametrized query"", <line3> notes = ""delete named, parametrized query by ID"") <line4> @ApiResponses({ <line5> @ApiResponse(code = 200, message = ""Deleted successfully.""), <line6> @ApiResponse(code = 401, message = ""Invalid Username or Password.""), <line7> @ApiResponse(code = 403, message = ""Insufficient privileges for operation.""), <line8> @ApiResponse(code = 404, message = ""queryId does not exist.""), <line9> @ApiResponse(code = 500, message = ""GemFire throws an error or exception"") <line10> }) <line11> @PreAuthorize(""@securityService.authorize('DATA', 'WRITE')"") <line12> public ResponseEntity<?> delete(@PathVariable(""query"") final String queryId) { <line13> deleteNamedQuery(PARAMETERIZED_QUERIES_REGION, queryId); <line14> compiledQueries.remove(queryId); <line15> return new ResponseEntity<>(HttpStatus.OK); <line16> } <line17> } <line18> "	 <line4>	No
"public class A { <line0> public ItemsVO createNewEntryInItemsTable(ItemsVO vo) { <line1> long timerStart = System.currentTimeMillis(); <line2> Long i = conf.getDBDAO().doCreateNewEntryInItemsTable(vo); <line3> vo.setItemid(i.intValue()); <line4> logTime(""doCreateNewEntryInItemsTable"", timerStart, System.currentTimeMillis()); <line5> return vo; <line6> } <line7> } <line8> "	 <line1>	Yes
"public class A { <line0> @GET <line1> @Path(""/{id}"") <line2> public Response getRepairSchedule(@PathParam(""id"") UUID repairScheduleId) { <line3> Optional<RepairSchedule> repairSchedule = context.storage.getRepairSchedule(repairScheduleId); <line4> if (repairSchedule.isPresent()) { <line5> return Response.ok().entity(getRepairScheduleStatus(repairSchedule.get())).build(); <line6> } else { <line7> return Response.status(404) <line8> .entity(""repair schedule with id "" + repairScheduleId + "" doesn't exist"") <line9> .build(); <line10> } <line11> } <line12> } <line13> "	 <line11>	No
"public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMStructureVersion getStructureVersion( <line1> HttpPrincipal httpPrincipal, long structureVersionId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DDMStructureVersionServiceUtil.class, <line7> ""getStructureVersion"", <line8> _getStructureVersionParameterTypes1); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, structureVersionId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.dynamic.data.mapping.model.DDMStructureVersion) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	 <line15>	No
"public class A { <line0> @Override <line1> public void deleteHivePolicy(String categoryName, String feedName) { <line2> String rangerHivePolicyName = getHivePolicyName(categoryName, feedName); <line3> Map<String, Object> searchHiveCriteria = new HashMap<>(); <line4> searchHiveCriteria.put(POLICY_NAME, rangerHivePolicyName); <line5> searchHiveCriteria.put(REPOSITORY_TYPE, HIVE_REPOSITORY_TYPE); <line6> List<RangerPolicy> hadoopPolicyList = this.searchPolicy(searchHiveCriteria); <line7> if (hadoopPolicyList.size() == 0) { <line8> } else if (hadoopPolicyList.size() > 1) { <line9> throw new RuntimeException(""Unable to find Hive unique policy.""); <line10> } else { <line11> for (RangerPolicy hadoopPolicy : hadoopPolicyList) { <line12> try { <line13> rangerRestClient.deletePolicy(hadoopPolicy.getId()); <line14> } catch (Exception e) { <line15> throw new RuntimeException(""Unable to delete policy for "" + rangerHivePolicyName, e); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> "	 <line8>	Yes
"public class A { <line0> public Boolean call() throws Exception { <line1> long start = System.currentTimeMillis(); <line2> try { <line3> for (int i = 0; i < numEvents; i++) { <line4> runtime.sendEventBean(new SupportBean(""E"" + Integer.toString(i), 0), ""SupportBean""); <line5> } <line6> } catch (Exception ex) { <line7> return null; <line8> } <line9> long end = System.currentTimeMillis(); <line10> return true; <line11> } <line12> } <line13> "	 <line2>	No
"public class A { <line0> private Firehose connectInternal( <line1> StringInputRowParser firehoseParser, <line2> @Nullable File temporaryDirectory, <line3> FetchConfig fetchConfig, <line4> CacheManager cacheManager) <line5> throws IOException { <line6> if (objects == null) { <line7> objects = ImmutableList.copyOf(Preconditions.checkNotNull(initObjects(), ""objects"")); <line8> } <line9> if (cacheManager.isEnabled() || fetchConfig.getMaxFetchCapacityBytes() > 0) { <line10> Preconditions.checkNotNull(temporaryDirectory, ""temporaryDirectory""); <line11> Preconditions.checkArgument( <line12> temporaryDirectory.exists(), ""temporaryDirectory[%s] does not exist"", temporaryDirectory); <line13> Preconditions.checkArgument( <line14> temporaryDirectory.isDirectory(), <line15> ""temporaryDirectory[%s] is not a directory"", <line16> temporaryDirectory); <line17> } <line18> final ExecutorService fetchExecutor = Execs.singleThreaded(""firehose_fetch_%d""); <line19> final FileFetcher<T> fetcher = <line20> new FileFetcher<T>( <line21> cacheManager, <line22> objects, <line23> fetchExecutor, <line24> temporaryDirectory, <line25> fetchConfig, <line26> new ObjectOpenFunction<T>() { <line27> @Override <line28> public InputStream open(T object) throws IOException { <line29> return openObjectStream(object); <line30> } <line31>  <line32> @Override <line33> public InputStream open(T object, long start) throws IOException { <line34> return openObjectStream(object, start); <line35> } <line36> }, <line37> getRetryCondition()); <line38> return new FileIteratingFirehose( <line39> new Iterator<LineIterator>() { <line40> @Override <line41> public boolean hasNext() { <line42> return fetcher.hasNext(); <line43> } <line44>  <line45> @Override <line46> public LineIterator next() { <line47> if (!hasNext()) { <line48> throw new NoSuchElementException(); <line49> } <line50> final OpenObject<T> openObject = fetcher.next(); <line51> try { <line52> return new ResourceCloseableLineIterator( <line53> new InputStreamReader( <line54> wrapObjectStream(openObject.getObject(), openObject.getObjectStream()), <line55> StandardCharsets.UTF_8), <line56> openObject.getResourceCloser()); <line57> } catch (IOException e) { <line58> try { <line59> openObject.getResourceCloser().close(); <line60> } catch (Throwable t) { <line61> e.addSuppressed(t); <line62> } <line63> throw new RuntimeException(e); <line64> } <line65> } <line66> }, <line67> firehoseParser, <line68> () -> { <line69> fetchExecutor.shutdownNow(); <line70> try { <line71> Preconditions.checkState( <line72> fetchExecutor.awaitTermination( <line73> fetchConfig.getFetchTimeout(), TimeUnit.MILLISECONDS)); <line74> } catch (InterruptedException e) { <line75> Thread.currentThread().interrupt(); <line76> throw new ISE(""Failed to shutdown fetch executor during close""); <line77> } <line78> }); <line79> } <line80> } <line81> "	 <line18>	Yes
"public class A { <line0> @Test <line1> public void correctRecordsCompleteFile() throws Exception { <line2> try (AccumuloClient client = Accumulo.newClient().from(getClientProperties()).build()) { <line3> String table = ""table1""; <line4> client <line5> .tableOperations() <line6> .create( <line7> table, <line8> new NewTableConfiguration() <line9> .setProperties(singletonMap(Property.TABLE_REPLICATION.getKey(), ""true""))); <line10> try (BatchWriter bw = client.createBatchWriter(table)) { <line11> for (int i = 0; i < 10; i++) { <line12> Mutation m = new Mutation(Integer.toString(i)); <line13> m.put(new byte[0], new byte[0], new byte[0]); <line14> bw.addMutation(m); <line15> } <line16> } <line17> while (!ReplicationTable.isOnline(client)) { <line18> sleepUninterruptibly(MILLIS_BETWEEN_REPLICATION_TABLE_ONLINE_CHECKS, TimeUnit.MILLISECONDS); <line19> } <line20> assertTrue(""Replication table did not exist"", ReplicationTable.isOnline(client)); <line21> for (int i = 0; i < 5; i++) { <line22> if (client <line23> .securityOperations() <line24> .hasTablePermission(""root"", ReplicationTable.NAME, TablePermission.READ)) { <line25> break; <line26> } <line27> Thread.sleep(2000); <line28> } <line29> assertTrue( <line30> ""'root' user could not read the replication table"", <line31> client <line32> .securityOperations() <line33> .hasTablePermission(""root"", ReplicationTable.NAME, TablePermission.READ)); <line34> Set<String> replRows = new HashSet<>(); <line35> int attempts = 5; <line36> while (replRows.isEmpty() && attempts > 0) { <line37> try (Scanner scanner = ReplicationTable.getScanner(client)) { <line38> StatusSection.limit(scanner); <line39> for (Entry<Key, Value> entry : scanner) { <line40> Key k = entry.getKey(); <line41> String fileUri = k.getRow().toString(); <line42> try { <line43> new URI(fileUri); <line44> } catch (URISyntaxException e) { <line45> fail(""Expected a valid URI: "" + fileUri); <line46> } <line47> replRows.add(fileUri); <line48> } <line49> } <line50> } <line51> Set<String> wals = new HashSet<>(); <line52> attempts = 5; <line53> while (wals.isEmpty() && attempts > 0) { <line54> WalStateManager markers = new WalStateManager(getServerContext()); <line55> for (Entry<Path, WalState> entry : markers.getAllState().entrySet()) { <line56> wals.add(entry.getKey().toString()); <line57> } <line58> attempts--; <line59> } <line60> assertEquals(""Rows found: "" + replRows, 1, replRows.size()); <line61> replRows.removeAll(wals); <line62> assertEquals(2, wals.size()); <line63> assertEquals(0, replRows.size()); <line64> } <line65> } <line66> } <line67> "	 <line27>	Yes
public class A { <line0> @Override <line1> public void initialize() { <line2> if (getConfig().get(BAUD_RATE) == null) { <line3> baud = 2400; <line4> } else { <line5> baud = (int) getConfig().get(BAUD_RATE); <line6> } <line7> if (getConfig().get(BUFFER_SIZE) == null) { <line8> bufferSize = 1024; <line9> } else { <line10> bufferSize = (int) getConfig().get(BUFFER_SIZE); <line11> } <line12> port = (String) getConfig().get(PORT); <line13> sleep = 250; <line14> interval = 5000; <line15> super.initialize(); <line16> } <line17> } <line18> 	 <line10>	No
"public class A { <line0> public void logPerformance() { <line1> final ComponentLog logger = getLogger(); <line2> if (!logger.isDebugEnabled()) { <line3> return; <line4> } <line5> final long earliestTimestamp = performanceTracker.getEarliestTimestamp(); <line6> final long millis = System.currentTimeMillis() - earliestTimestamp; <line7> final long seconds = TimeUnit.MILLISECONDS.toSeconds(millis); <line8> for (final DiskOperation operation : DiskOperation.values()) { <line9> final OperationStatistics stats = performanceTracker.getOperationStatistics(operation); <line10> final StringBuilder sb = new StringBuilder(); <line11> if (stats.getCount() == 0) { <line12> sb.append(""Over the past "") <line13> .append(seconds) <line14> .append("" seconds, for Operation '"") <line15> .append(operation) <line16> .append(""' there were no operations performed""); <line17> } else { <line18> sb.append(""Over the past "") <line19> .append(seconds) <line20> .append("" seconds, For Operation '"") <line21> .append(operation) <line22> .append(""' there were "") <line23> .append(stats.getCount()) <line24> .append("" operations performed with an average time of "") <line25> .append(stats.getAverage()) <line26> .append("" milliseconds; Standard Deviation = "") <line27> .append(stats.getStandardDeviation()) <line28> .append("" millis; Min Time = "") <line29> .append(stats.getMin()) <line30> .append("" millis, Max Time = "") <line31> .append(stats.getMax()) <line32> .append("" millis""); <line33> if (logger.isDebugEnabled()) { <line34> final Map<String, Long> outliers = stats.getOutliers(); <line35> sb.append(""; "").append(stats.getOutliers().size()).append("" significant outliers: ""); <line36> sb.append(outliers); <line37> } <line38> } <line39> } <line40> performanceLoggingTimestamp = System.currentTimeMillis(); <line41> } <line42> } <line43> "	 <line39>	Yes
public class A { <line0> public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) { <line1> if (minEvictableIdleTimeMillis < 1000 * 30) { <line2> } <line3> this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis; <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> private boolean putClusterMeta(ClusterMetaEntity entity) { <line1> if (!raftInitialized()) { <line2> return false; <line3> } <line4> ClusterMetaType metaType = entity.getMetaType(); <line5> String metaKey = entity.getKey(); <line6> HashMap<String, Object> newMetaValue = entity.getValues(); <line7> if (LOGGER.isDebugEnabled()) { <line8> } <line9> newMetaValue.put(ClusterMeta.SERVER_HOST, zeplServerHost); <line10> newMetaValue.put(ClusterMeta.SERVER_PORT, raftServerPort); <line11> raftSessionClient <line12> .execute(operation(ClusterStateMachine.PUT, clientSerializer.encode(entity))) <line13> .<Long>thenApply(clientSerializer::decode); <line14> return true; <line15> } <line16> } <line17> 	 <line14>	No
"public class A { <line0> private void stop(final boolean sendDisconnect, final TransportError reason) { <line1> if (initialConnectTimer != null) { <line2> initialConnectTimer.cancel(); <line3> } <line4> if (degradeToUnitialized()) { <line5> setState(BusState.UNINITIALIZED); <line6> deferredMessages.clear(); <line7> remotes.clear(); <line8> deferredSubscriptions.clear(); <line9> } else if (state != BusState.LOCAL_ONLY) { <line10> setState(BusState.LOCAL_ONLY, reason); <line11> } <line12> if (sendDisconnect && isRemoteCommunicationEnabled()) { <line13> encodeAndTransmit( <line14> CommandMessage.create() <line15> .toSubject(BuiltInServices.ServerBus.name()) <line16> .command(BusCommand.Disconnect) <line17> .set(MessageParts.PriorityProcessing, ""1"")); <line18> } <line19> deferredMessages.addAll(transportHandler.stop(true)); <line20> } <line21> } <line22> "	 <line5>	No
"public class A { <line0> @Override <line1> @SecurityCheck <line2> public String addGateway(AuthzToken authzToken, Gateway gateway) <line3> throws TenantProfileServiceException, AuthorizationException, TException { <line4> try { <line5> gateway.setAiravataInternalGatewayId(UUID.randomUUID().toString()); <line6> if (!checkDuplicateGateway(gateway)) { <line7> if (gateway.getIdentityServerPasswordToken() != null) { <line8> copyAdminPasswordToGateway(authzToken, gateway); <line9> } <line10> gateway = tenantProfileRepository.create(gateway); <line11> if (gateway != null) { <line12> if (gateway.getGatewayApprovalStatus().equals(GatewayApprovalStatus.APPROVED)) { <line13> dbEventPublisherUtils.publish(EntityType.TENANT, CrudType.CREATE, gateway); <line14> } <line15> return gateway.getAiravataInternalGatewayId(); <line16> } else { <line17> throw new Exception(""Gateway object is null.""); <line18> } <line19> } else { <line20> throw new TenantProfileServiceException( <line21> ""An approved Gateway already exists with the same GatewayId, Name or URL""); <line22> } <line23> } catch (Exception ex) { <line24> TenantProfileServiceException exception = new TenantProfileServiceException(); <line25> exception.setMessage(""Error adding gateway-profile, reason: "" + ex.getMessage()); <line26> throw exception; <line27> } <line28> } <line29> } <line30> "	 <line12>	Yes
"public class A { <line0> private void restartWithSystem(InternalDistributedSystem newSystem, InternalCache newCache) <line1> throws IOException { <line2> synchronized (locatorLock) { <line3> if (locator != this && hasLocator()) { <line4> throw new IllegalStateException( <line5> ""A locator can not be created because one already exists in this JVM.""); <line6> } <line7> } <line8> internalDistributedSystem = newSystem; <line9> internalCache = newCache; <line10> try { <line11> restartHandlers.forEach( <line12> handler -> handler.restarting(newSystem, newCache, configurationPersistenceService)); <line13> membershipLocator.restarting(); <line14> } catch (CancelException e) { <line15> internalDistributedSystem = null; <line16> internalCache = null; <line17> throw e; <line18> } <line19> if (isSharedConfigurationEnabled()) { <line20> configurationPersistenceService = <line21> new InternalConfigurationPersistenceService( <line22> newCache, workingDirectory, JAXBService.create()); <line23> startClusterManagementService(); <line24> } <line25> if (!membershipLocator.isAlive()) { <line26> startTcpServer(); <line27> } <line28> startJmxManagerLocationService(newCache); <line29> endStartLocator(internalDistributedSystem); <line30> restartHandlers.forEach(handler -> handler.restartCompleted(newSystem)); <line31> } <line32> } <line33> "	 <line17>	Yes
public class A { <line0> private void markerMessageThrowable(Level level) { <line1> switch (level) { <line2> case TRACE: <line3> break; <line4> case DEBUG: <line5> break; <line6> case INFO: <line7> break; <line8> case WARN: <line9> break; <line10> case ERROR: <line11> break; <line12> } <line13> verifyMessage(level, marker, null, exception); <line14> } <line15> } <line16> 	 <line5>	Yes
public class A { <line0> @VisibleForTesting <line1> AtlasEntityWithExtInfo updateEntityInAtlas(AtlasEntityWithExtInfo entity) throws Exception { <line2> AtlasEntityWithExtInfo ret; <line3> EntityMutationResponse response = atlasClientV2.updateEntity(entity); <line4> if (response != null) { <line5> List<AtlasEntityHeader> entities = response.getUpdatedEntities(); <line6> if (CollectionUtils.isNotEmpty(entities)) { <line7> AtlasEntityWithExtInfo getByGuidResponse = <line8> atlasClientV2.getEntityByGuid(entities.get(0).getGuid()); <line9> ret = getByGuidResponse; <line10> } else { <line11> ret = entity; <line12> } <line13> } else { <line14> ret = entity; <line15> } <line16> return ret; <line17> } <line18> } <line19> 	 <line11>	Yes
public class A { <line0> @Override <line1> public RequestResponse updateContext(VitamContext vitamContext, String id, JsonNode queryDsl) <line2> throws AccessExternalClientException { <line3> VitamRequestBuilder request = <line4> put() <line5> .withPath(UPDATE_CONTEXT + id) <line6> .withHeaders(vitamContext.getHeaders()) <line7> .withBody(queryDsl) <line8> .withJson(); <line9> try (Response response = make(request)) { <line10> check(response); <line11> return RequestResponse.parseFromResponse(response); <line12> } catch (VitamClientInternalException e) { <line13> throw new AccessExternalClientServerException(e); <line14> } catch (AdminExternalClientException e) { <line15> return e.getVitamError(); <line16> } <line17> } <line18> } <line19> 	 <line15>	Yes
"public class A { <line0> @PUT <line1> @Path(""/{id}"") <line2> public Response updateDocument( <line3> @PathParam(""id"") String id, @Context HttpHeaders headers, InputStream message) { <line4> return Response.ok().build(); <line5> } <line6> } <line7> "	 <line4>	Yes
public class A { <line0> public static String fixForComponentHome(Component component, String suffixPath) { <line1> String prefix = System.getProperty(component.getHome()); <line2> if (prefix == null) { <line3> prefix = System.getenv().get(component.getHome()); <line4> } <line5> StringBuilder path = new StringBuilder(); <line6> if (prefix != null && !prefix.trim().isEmpty()) { <line7> prefix = prefix.trim(); <line8> path.append(prefix.endsWith(SEPARATOR) ? prefix : prefix + SEPARATOR); <line9> } <line10> path.append( <line11> suffixPath.startsWith(ZPaths.SEPARATOR) <line12> ? suffixPath.substring(ZPaths.SEPARATOR.length()) <line13> : suffixPath); <line14> return path.toString(); <line15> } <line16> } <line17> 	 <line5>	No
"public class A { <line0> public void sleepBookie( <line1> BookieSocketAddress addr, final CountDownLatch l, final CountDownLatch suspendLatch) <line2> throws InterruptedException, IOException { <line3> for (final BookieServer bookie : bs) { <line4> if (bookie.getLocalAddress().equals(addr)) { <line5> Thread sleeper = <line6> new Thread() { <line7> @Override <line8> public void run() { <line9> try { <line10> bookie.suspendProcessing(); <line11> if (null != suspendLatch) { <line12> suspendLatch.countDown(); <line13> } <line14> l.await(); <line15> bookie.resumeProcessing(); <line16> } catch (Exception e) { <line17> } <line18> } <line19> }; <line20> sleeper.start(); <line21> return; <line22> } <line23> } <line24> throw new IOException(""Bookie not found""); <line25> } <line26> } <line27> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void debug(String msg, Throwable thrown) { <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void forget(Xid xid) throws XAException { <line2> AbstractTransactionContext context = resourceManager.getTransactionalResource(xid); <line3> if (context == null) { <line4> throw new XAException(XAException.XAER_NOTA); <line5> } <line6> resourceManager.removeActiveTransactionalResource(xid); <line7> resourceManager.removeSuspendedTransactionalResource(xid); <line8> } <line9> } <line10> 	 <line2>	Yes
public class A { <line0> public void stopForcefully() { <line1> stopRequested.set(true); <line2> runThread.interrupt(); <line3> } <line4> } <line5> 	 <line3>	No
public class A { <line0> public static ManagerEvent build(final org.asteriskjava.manager.event.ManagerEvent event) { <line1> ManagerEvent iEvent = null; <line2> Class<? extends ManagerEvent> target = null; <line3> if (event instanceof org.asteriskjava.manager.event.ResponseEvent) <line4> target = CoherentEventFactory.mapResponses.get(event.getClass()); <line5> else target = CoherentEventFactory.mapEvents.get(event.getClass()); <line6> if (target == null) { <line7> } else { <line8> try { <line9> iEvent = target.getDeclaredConstructor(event.getClass()).newInstance(event); <line10> } catch (NoSuchMethodException <line11> | SecurityException <line12> | InstantiationException <line13> | IllegalAccessException <line14> | IllegalArgumentException <line15> | InvocationTargetException e) { <line16> } <line17> } <line18> return iEvent; <line19> } <line20> } <line21> 	 <line11>	No
"public class A { <line0> @Override <line1> public Void call() throws Exception { <line2> if (id.isEmpty()) { <line3> throw new InvalidRequestException(""Invalid empty ID in createTask request.""); <line4> } <line5> ManagedTask task = tasks.get(id); <line6> if (task != null) { <line7> if (!task.originalSpec.equals(originalSpec)) { <line8> throw new RequestConflictException( <line9> ""Task ID "" <line10> + id <line11> + "" already "" <line12> + ""exists, and has a different spec "" <line13> + task.originalSpec); <line14> } <line15> return null; <line16> } <line17> TaskController controller = null; <line18> String failure = null; <line19> try { <line20> controller = spec.newController(id); <line21> } catch (Throwable t) { <line22> failure = ""Failed to create TaskController: "" + t.getMessage(); <line23> } <line24> if (failure != null) { <line25> task = new ManagedTask(id, originalSpec, spec, null, TaskStateType.DONE); <line26> task.doneMs = time.milliseconds(); <line27> task.maybeSetError(failure); <line28> tasks.put(id, task); <line29> return null; <line30> } <line31> task = new ManagedTask(id, originalSpec, spec, controller, TaskStateType.PENDING); <line32> tasks.put(id, task); <line33> long delayMs = task.startDelayMs(time.milliseconds()); <line34> task.startFuture = scheduler.schedule(executor, new RunTask(task), delayMs); <line35> return null; <line36> } <line37> } <line38> "	 <line27>	No
"public class A { <line0> @Override <line1> public final void updateIndexDocuments( <line2> final String indexName, final Map<String, String> documentMap) { <line3> List<String> allIndices = getAliases(indexName); <line4> try (final RestHighLevelClient restHighLevelClient = <line5> elasticsearchRestHighLevelClientFactory.getRestHighLevelClient()) { <line6> for (String index : allIndices) { <line7> BulkRequest bulkRequest = new BulkRequest(); <line8> documentMap.forEach( <line9> (id, jsonString) -> <line10> bulkRequest.add( <line11> new IndexRequest(index).id(id).source(jsonString, XContentType.JSON))); <line12> BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT); <line13> if (bulkResponse.hasFailures()) { <line14> } <line15> } <line16> } catch (final IOException ioException) { <line17> throw new ElasticsearchRestClientException( <line18> ""Caught IOException while attempting to use the ElasticsearchRestHighLevelClient."", <line19> ioException); <line20> } <line21> } <line22> } <line23> "	 <line14>	Yes
"public class A { <line0> @Override <line1> protected ActionForward unspecified( <line2> ActionMapping mapping, <line3> ActionForm form, <line4> HttpServletRequest request, <line5> HttpServletResponse response) { <line6> LoggedInInfo loggedInInfo = LoggedInInfo.getLoggedInInfoFromSession(request); <line7> String providerNo = loggedInInfo.getLoggedInProviderNo(); <line8> String uuidToAdd = request.getParameter(""uuid""); <line9> String pAck = request.getParameter(""ack""); <line10> String addToMyInboxParameter = request.getParameter(""addToMyInbox""); <line11> boolean doNotAddToMyInbox = <line12> addToMyInboxParameter != null && ""false"".equals(addToMyInboxParameter); <line13> boolean doAck = false; <line14> if (pAck != null && pAck.equals(""true"")) { <line15> doAck = true; <line16> } <line17> OLISResults result = olisResultsDao.findByUUID(uuidToAdd); <line18> String fileLocation = System.getProperty(""java.io.tmpdir"") + ""/olis_"" + uuidToAdd + "".response""; <line19> File file = new File(fileLocation); <line20> FileWriter fw = null; <line21> try { <line22> fw = new FileWriter(file); <line23> IOUtils.write(result.getResults(), fw); <line24> } catch (IOException e) { <line25> } finally { <line26> IOUtils.closeQuietly(fw); <line27> } <line28> OLISHL7Handler msgHandler = (OLISHL7Handler) HandlerClassFactory.getHandler(""OLIS_HL7""); <line29> InputStream is = null; <line30> try { <line31> is = new FileInputStream(fileLocation); <line32> int check = FileUploadCheck.addFile(file.getName(), is, providerNo); <line33> String successMessage = """"; <line34> if (check != FileUploadCheck.UNSUCCESSFUL_SAVE) { <line35> if (msgHandler.parse(loggedInInfo, ""OLIS_HL7"", fileLocation, check, !doNotAddToMyInbox) <line36> != null) { <line37> successMessage = ""Successully added lab to EMR.""; <line38> request.setAttribute(""result"", ""Success""); <line39> if (doAck) { <line40> String demographicID = getDemographicIdFromLab(""HL7"", msgHandler.getLastSegmentId()); <line41> LogAction.addLog( <line42> (String) request.getSession().getAttribute(""user""), <line43> LogConst.ACK, <line44> LogConst.CON_HL7_LAB, <line45> """" + msgHandler.getLastSegmentId(), <line46> request.getRemoteAddr(), <line47> demographicID); <line48> CommonLabResultData.updateReportStatus( <line49> msgHandler.getLastSegmentId(), providerNo, 'A', ""Sign-off from OLIS inbox"", ""HL7""); <line50> successMessage = ""Successully added lab to EMR and acknowledged lab in inbox.""; <line51> } <line52> if (result != null) { <line53> result.setStatus(""added""); <line54> olisResultsDao.merge(result); <line55> } <line56> request.setAttribute(""result"", successMessage); <line57> } else { <line58> request.setAttribute(""result"", ""Error adding Lab to EMR""); <line59> } <line60> } else { <line61> request.setAttribute(""result"", ""Lab already Added. Nothing to do""); <line62> } <line63> } catch (Exception e) { <line64> request.setAttribute(""result"", ""Error""); <line65> } finally { <line66> IOUtils.closeQuietly(is); <line67> } <line68> return mapping.findForward(""ajax""); <line69> } <line70> } <line71> "	 <line19>	No
public class A { <line0> public void deleteReply(Long replyId) { <line1> Reply reply = this.getEntityManager().find(Reply.class, replyId); <line2> if (reply == null) { <line3> return; <line4> } <line5> reply.setModifiedDate(Calendar.getInstance()); <line6> reply.setModifier(SystemContextHolder.get().getUserHistory()); <line7> reply.setStatus(BCConstants.STATUS_DELETED); <line8> this.getEntityManager().merge(reply); <line9> } <line10> } <line11> 	 <line3>	Yes
"public class A { <line0> private WebSocketBehavior newWsBehavior() { <line1> return new WebSocketBehavior() { <line2> private static final long serialVersionUID = 1L; <line3>  <line4> @Override <line5> public void renderHead(Component component, IHeaderResponse response) { <line6> super.renderHead(component, response); <line7> response.render( <line8> JavaScriptHeaderItem.forScript( <line9> String.format( <line10> ""Wicket.Event.subscribe(Wicket.Event.Topic.WebSocket.Opened, function()"" <line11> + "" {Wicket.WebSocket.send('%s');});"", <line12> CONNECTED_MSG), <line13> ""ws-connected-script"")); <line14> } <line15>  <line16> @Override <line17> protected void onConnect(ConnectedMessage message) { <line18> super.onConnect(message); <line19> OmWebSocketPanel.this.onConnect(message); <line20> } <line21>  <line22> @Override <line23> protected void onMessage(WebSocketRequestHandler handler, TextMessage msg) { <line24> if (CONNECTED_MSG.equals(msg.getText())) { <line25> if (connected.compareAndSet(false, true)) { <line26> OmWebSocketPanel.this.onConnect(handler); <line27> } <line28> } else { <line29> final JSONObject m; <line30> try { <line31> m = new JSONObject(msg.getText()); <line32> switch (m.optString(""type"", """")) { <line33> case KURENTO_TYPE: <line34> kHandler.onMessage(getWsClient(), m); <line35> break; <line36> case ""mic"": <line37> micMessage(m); <line38> break; <line39> case ""ping"": <line40> handler.appendJavaScript(""OmUtil.ping();""); <line41> WebSocketHelper.sendClient( <line42> getWsClient(), new byte[] {getUserId() == null ? 0 : getUserId().byteValue()}); <line43> break; <line44> default: <line45> OmWebSocketPanel.this.onMessage(handler, m); <line46> } <line47> } catch (Exception e) { <line48> } <line49> } <line50> } <line51>  <line52> @Override <line53> protected void onAbort(AbortedMessage msg) { <line54> closeHandler(msg); <line55> } <line56>  <line57> @Override <line58> protected void onClose(ClosedMessage msg) { <line59> closeHandler(msg); <line60> } <line61>  <line62> @Override <line63> protected void onError(WebSocketRequestHandler handler, ErrorMessage msg) { <line64> closeHandler(msg); <line65> } <line66>  <line67> private void micMessage(final JSONObject m) { <line68> IWsClient curClient = getWsClient(); <line69> if (!(curClient instanceof Client)) { <line70> return; <line71> } <line72> Client c = (Client) curClient; <line73> if (c.getRoomId() == null) { <line74> return; <line75> } <line76> WebSocketHelper.sendRoomOthers(c.getRoomId(), c.getUid(), m.put(""uid"", c.getUid())); <line77> } <line78> }; <line79> } <line80> } <line81> "	 <line40>	Yes
public class A { <line0> public GetPQValuesResponse dequeueGetPQValuesResponse(final String correlationUid) <line1> throws OsgpException { <line2> return (GetPQValuesResponse) this.processResponse(correlationUid); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> protected void rollback() { <line1> try { <line2> if (conn != null && !conn.isClosed()) { <line3> conn.rollback(); <line4> } <line5> } catch (SQLException e) { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
public class A { <line0> @Test <line1> public void testClientClosure() throws Exception { <line2> for (int i = 0; i < NODES_CNT; i++) { <line3> Ignite ignite = grid(i); <line4> Collection<String> res = <line5> ignite <line6> .compute(ignite.cluster().forClients()) <line7> .broadcast( <line8> new IgniteCallable<String>() { <line9> @IgniteInstanceResource Ignite ignite; <line10>  <line11> @Override <line12> public String call() throws Exception { <line13> assertTrue(ignite.configuration().isClientMode()); <line14> return ignite.name(); <line15> } <line16> }); <line17> assertEquals(1, res.size()); <line18> assertEquals(getTestIgniteInstanceName(CLIENT_IDX), F.first(res)); <line19> } <line20> } <line21> } <line22> 	 <line17>	No
public class A { <line0> public void loadSettings(@NotNull InputStream in, @NotNull String systemId) <line1> throws ConfigurationException, IOException { <line2> VaultSettings settings = new VaultSettings(); <line3> settings.load(in); <line4> setSettings(settings); <line5> } <line6> } <line7> 	 <line5>	Yes
public class A { <line0> protected GetStorageStatsAnswer execute(final GetStorageStatsCommand cmd) { <line1> try { <line2> OvmStoragePool.Details d = OvmStoragePool.getDetailsByUuid(_conn, cmd.getStorageId()); <line3> return new GetStorageStatsAnswer(cmd, d.totalSpace, d.usedSpace); <line4> } catch (Exception e) { <line5> return new GetStorageStatsAnswer(cmd, e.getMessage()); <line6> } <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> private void showGenericGitErrorNotificationWithBranch(BranchHelper branch) { <line1> Platform.runLater( <line2> () -> { <line3> notificationPaneController.addNotification( <line4> String.format(""Sorry, there was a git error on branch %s."", branch.getRefName())); <line5> }); <line6> } <line7> } <line8> "	 <line1>	No
"public class A { <line0> @Override <line1> public PersistenceContext get( <line2> String persistenceUnitName, <line3> URI defaultURI, <line4> String version, <line5> Map<String, Object> initializationProperties) { <line6> PersistenceContext persistenceContext = <line7> getDynamicPersistenceContext(persistenceUnitName, version); <line8> if (persistenceContext == null) { <line9> try { <line10> DynamicClassLoader dcl = <line11> new DynamicRestClassLoader(Thread.currentThread().getContextClassLoader()); <line12> Map<String, Object> properties = new HashMap<>(); <line13> properties.put(PersistenceUnitProperties.CLASSLOADER, dcl); <line14> if (initializationProperties != null) { <line15> properties.putAll(initializationProperties); <line16> } <line17> properties.putIfAbsent(PersistenceUnitProperties.WEAVING_REST, ""true""); <line18> EntityManagerFactoryImpl factory = <line19> (EntityManagerFactoryImpl) <line20> Persistence.createEntityManagerFactory(persistenceUnitName, properties); <line21> ClassLoader sessionLoader = factory.getServerSession().getLoader(); <line22> if (!DynamicClassLoader.class.isAssignableFrom(sessionLoader.getClass())) { <line23> properties = new HashMap<>(); <line24> dcl = new DynamicRestClassLoader(sessionLoader); <line25> properties.put(PersistenceUnitProperties.CLASSLOADER, dcl); <line26> if (initializationProperties != null) { <line27> properties.putAll(initializationProperties); <line28> } <line29> properties.putIfAbsent(PersistenceUnitProperties.WEAVING_REST, ""true""); <line30> factory.refreshMetadata(properties); <line31> } <line32> persistenceContext = <line33> bootstrapPersistenceContext(persistenceUnitName, factory, defaultURI, version, true); <line34> } catch (Exception e) { <line35> JPARSLogger.exception( <line36> ""exception_creating_persistence_context"", <line37> new Object[] {persistenceUnitName, e.toString()}, <line38> e); <line39> } <line40> } <line41> if ((persistenceContext != null) && (!persistenceContext.isWeavingEnabled())) { <line42> throw JPARSException.invalidConfiguration(); <line43> } <line44> return persistenceContext; <line45> } <line46> } <line47> "	 <line27>	No
public class A { <line0> public OriginateResult[] dial( <line1> final NewChannelListener listener, <line2> final EndPoint localHandset, <line3> final AgiChannelActivityAction action, <line4> final CallerID callerID, <line5> Integer timeout, <line6> final boolean hideCallerId, <line7> Map<String, String> channelVarsToSet) <line8> throws PBXException, InterruptedException { <line9> final PBX pbx = PBXFactory.getActivePBX(); <line10> try (final OriginateToExtension originate = new OriginateToExtension(listener)) { <line11> this.startListener(); <line12> originator = originate; <line13> final OriginateResult trcResult = <line14> originate.originate( <line15> localHandset, <line16> pbx.getExtensionAgi(), <line17> true, <line18> ((AsteriskPBX) pbx).getManagementContext(), <line19> callerID, <line20> timeout, <line21> hideCallerId, <line22> channelVarsToSet); <line23> this.result[0] = trcResult; <line24> if (trcResult.isSuccess()) { <line25> if (trcResult.getChannel() != null) { <line26> trcResult.getChannel().setCurrentActivityAction(action); <line27> if (trcResult.getChannel().waitForChannelToReachAgi(30, TimeUnit.SECONDS)) { <line28> } else { <line29> } <line30> } else { <line31> } <line32> } else { <line33> } <line34> return this.result; <line35> } finally { <line36> this.close(); <line37> } <line38> } <line39> } <line40> 	 <line11>	No
public class A { <line0> @Override <line1> public Mono<HandlerMethod> getHandlerInternal(ServerWebExchange request) { <line2> String path = request.getRequest().getPath().pathWithinApplication().value(); <line3> if (StringUtils.hasText(this.prefix) && !path.startsWith(this.prefix)) { <line4> return Mono.empty(); <line5> } <line6> Mono<HandlerMethod> handler = super.getHandlerInternal(request); <line7> if (path == null) { <line8> return handler; <line9> } <line10> if (path.startsWith(this.prefix)) { <line11> path = path.substring(this.prefix.length()); <line12> } <line13> Object function = <line14> FunctionWebUtils.findFunction( <line15> request.getRequest().getMethod(), <line16> this.functions, <line17> request.getAttributes(), <line18> path, <line19> new String[] {}); <line20> if (function != null) { <line21> if (this.logger.isDebugEnabled()) { <line22> } <line23> request.getAttributes().put(WebRequestConstants.HANDLER, function); <line24> } <line25> Object actual = function; <line26> return handler.filter(method -> actual != null); <line27> } <line28> } <line29> 	 <line3>	No
"public class A { <line0> boolean isUnique( <line1> final String value, <line2> final String valueContext, <line3> final Set<String> alreadySeen, <line4> final String valueName, <line5> final String collectionName, <line6> final List<ValidationFailureDetails> failures) { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> boolean valid = true; <line10> if (StringUtils.isBlank(value)) { <line11> failures.add( <line12> new ValidationFailureDetailsBuilder() <line13> .field(valueName) <line14> .subField(valueContext) <line15> .isMissing() <line16> .becauseOf(String.format(""%s[%s] is null/empty"", valueName, value)) <line17> .build()); <line18> valid = false; <line19> } else if (alreadySeen.contains(value.toLowerCase())) { <line20> failures.add( <line21> new ValidationFailureDetailsBuilder() <line22> .field(valueName) <line23> .subField(value) <line24> .isSemanticallyIncorrect() <line25> .becauseOf(String.format(""duplicate %s[%s] in %s"", valueName, value, collectionName)) <line26> .build()); <line27> valid = false; <line28> } else { <line29> alreadySeen.add(value.toLowerCase()); <line30> } <line31> if (LOG.isDebugEnabled()) { <line32> } <line33> return valid; <line34> } <line35> } <line36> "	 <line8>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public List<ClientReferral> getReferralsByFacility(Long clientId, Integer facilityId) { <line2> if (clientId == null || clientId.longValue() <= 0) { <line3> throw new IllegalArgumentException(); <line4> } <line5> if (facilityId == null || facilityId.intValue() < 0) { <line6> throw new IllegalArgumentException(); <line7> } <line8> String sSQL = <line9> ""from ClientReferral cr where cr.ClientId = ?  and ( (cr.FacilityId=?) or (cr.ProgramId in"" <line10> + "" (select s.id from Program s where s.facilityId=? or s.facilityId is null)))""; <line11> List<ClientReferral> results = <line12> this.getHibernateTemplate().find(sSQL, new Object[] {clientId, facilityId, facilityId}); <line13> if (log.isDebugEnabled()) { <line14> } <line15> results = displayResult(results); <line16> return results; <line17> } <line18> } <line19> "	 <line14>	Yes
public class A { <line0> private List<Command> performSubstitutionInCommands(List<Command> commands) { <line1> List<Command> tmp = new ArrayList<>(); <line2> try { <line3> for (Command originalCommand : commands) { <line4> Command clonedCmd = resolve(originalCommand); <line5> tmp.add(clonedCmd); <line6> } <line7> } catch (Exception e) { <line8> } <line9> return tmp; <line10> } <line11> } <line12> 	 <line4>	No
public class A { <line0> private <T> boolean isFeatureFlagEnabled( <line1> Feature feature, T featureContext, Predicate<T> featurePredicate) { <line2> boolean enabled; <line3> Optional<String> systemPropertyName = feature.getOverridingSystemPropertyName(); <line4> if (systemPropertyName.isPresent() && getProperty(systemPropertyName.get()) != null) { <line5> enabled = getBoolean(systemPropertyName.get()); <line6> } else { <line7> enabled = featurePredicate.test(featureContext); <line8> } <line9> return enabled; <line10> } <line11> } <line12> 	 <line10>	No
public class A { <line0> public static boolean saveObject(String path, HVPSettings obj) { <line1> if (obj == null) { <line2> return false; <line3> } <line4> try { <line5> FileOutputStream fileOut = new FileOutputStream(path); <line6> ObjectOutputStream out = new ObjectOutputStream(fileOut); <line7> out.writeObject(obj); <line8> out.close(); <line9> fileOut.close(); <line10> } catch (Exception ex) { <line11> return false; <line12> } <line13> return true; <line14> } <line15> } <line16> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void clearCache() { <line2> aclClassCache.invalidateAll(); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (command instanceof RefreshType) { <line3> lastRefresh = 0; <line4> } <line5> } <line6> } <line7> 	 <line3>	No
"public class A { <line0> @Override <line1> public List<String> listZoneNames() throws JargonException { <line2> IRODSGenQueryExecutor irodsGenQueryExecutor = <line3> new IRODSGenQueryExecutorImpl(getIRODSSession(), getIRODSAccount()); <line4> IRODSGenQueryBuilder builder = new IRODSGenQueryBuilder(true, null); <line5> IRODSQueryResultSet resultSet; <line6> try { <line7> builder <line8> .addSelectAsGenQueryValue(RodsGenQueryEnum.COL_ZONE_NAME) <line9> .addOrderByGenQueryField(RodsGenQueryEnum.COL_ZONE_NAME, OrderByType.ASC); <line10> IRODSGenQueryFromBuilder irodsQuery = builder.exportIRODSQueryFromBuilder(50); <line11> resultSet = irodsGenQueryExecutor.executeIRODSQueryAndCloseResultInZone(irodsQuery, 0, """"); <line12> } catch (JargonQueryException e) { <line13> log.error(CollectionListingUtils.QUERY_EXCEPTION_FOR_QUERY, e); <line14> throw new JargonException(""error in query"", e); <line15> } catch (GenQueryBuilderException e) { <line16> throw new JargonException(""error in query"", e); <line17> } <line18> List<String> zones = new ArrayList<String>(); <line19> String zone; <line20> for (IRODSQueryResultRow row : resultSet.getResults()) { <line21> zone = row.getColumn(0); <line22> zones.add(zone); <line23> } <line24> return zones; <line25> } <line26> } <line27> "	 <line10>	No
"public class A { <line0> private static void getFromJceks(Configuration conf, String path, String alias, String key) { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> if (conf != null) { <line4> String pathValue = conf.get(path); <line5> String aliasValue = conf.get(alias); <line6> if (pathValue != null && aliasValue != null) { <line7> String storeType = conf.get(""ranger.keystore.file.type"", KeyStore.getDefaultType()); <line8> String xaDBPassword = <line9> CredentialReader.getDecryptedString(pathValue.trim(), aliasValue.trim(), storeType); <line10> if (xaDBPassword != null <line11> && !xaDBPassword.trim().isEmpty() <line12> && !xaDBPassword.trim().equalsIgnoreCase(""none"")) { <line13> conf.set(key, xaDBPassword); <line14> } else { <line15> } <line16> } <line17> } <line18> } <line19> } <line20> "	 <line15>	Yes
"public class A { <line0> public void addGrid(String name, Vector3f pos, int size, String color) { <line1> Spatial s = find(name); <line2> if (s != null) { <line3> return; <line4> } <line5> Geometry g = new Geometry(""wireframe grid"", new Grid(size, size, 1.0f)); <line6> Material mat = new Material(assetManager, ""Common/MatDefs/Misc/Unshaded.j3md""); <line7> mat.getAdditionalRenderState().setWireframe(true); <line8> mat.setColor(""Color"", Jme3Util.toColor(color)); <line9> g.setMaterial(mat); <line10> g.center().move(pos); <line11> Node n = new Node(name); <line12> n.attachChild(g); <line13> rootNode.attachChild(n); <line14> } <line15> } <line16> "	 <line3>	Yes
public class A { <line0> protected void dumpMessage(Message message, boolean sending) { <line1> if (log.isInfoEnabled()) { <line2> try { <line3> printAvps(message.getAvps()); <line4> } catch (AvpDataException e) { <line5> e.printStackTrace(); <line6> } <line7> } <line8> } <line9> } <line10> 	 <line6>	No
"public class A { <line0> @Override <line1> public DDMDataProviderResponse getData(DDMDataProviderRequest ddmDataProviderRequest) { <line2> Optional<Long> dataProviderInstanceIdOptional = <line3> ddmDataProviderRequest.getParameterOptional(""dataProviderInstanceId"", String.class); <line4> long dataProviderInstanceId = 0; <line5> if (dataProviderInstanceIdOptional.isPresent()) { <line6> dataProviderInstanceId = GetterUtil.getLong(dataProviderInstanceIdOptional.get()); <line7> } <line8> DDMDataProviderResponse.Builder builder = DDMDataProviderResponse.Builder.newBuilder(); <line9> List<KeyValuePair> keyValuePairs = new ArrayList<>(); <line10> if (dataProviderInstanceId == 0) { <line11> return builder.withOutput(""outputParameterNames"", keyValuePairs).build(); <line12> } <line13> try { <line14> DDMDataProviderOutputParametersSettings[] ddmDataProviderOutputParametersSettings = <line15> getDDMDataProviderOutputParametersSettings(dataProviderInstanceId); <line16> for (DDMDataProviderOutputParametersSettings ddmDataProviderOutputParametersSetting : <line17> ddmDataProviderOutputParametersSettings) { <line18> keyValuePairs.add( <line19> new KeyValuePair( <line20> ddmDataProviderOutputParametersSetting.outputParameterId(), <line21> ddmDataProviderOutputParametersSetting.outputParameterName())); <line22> } <line23> } catch (Exception exception) { <line24> } <line25> return builder.withOutput(""outputParameterNames"", keyValuePairs).build(); <line26> } <line27> } <line28> "	 <line6>	No
"public class A { <line0> private String handleAndReturnExceptionResponse(Exception e) { <line1> if (e instanceof InterruptedException) { <line2> Thread.currentThread().interrupt(); <line3> } <line4> StringBuilder response = new StringBuilder(); <line5> response <line6> .append(DEFAULT_EXCEPTION_RESPONSE) <line7> .append("": "") <line8> .append(e.getClass().getCanonicalName()); <line9> if (e.getMessage() != null) { <line10> response.append("": "").append(e.getMessage()); <line11> } <line12> return response.toString(); <line13> } <line14> } <line15> "	 <line1>	Yes
public class A { <line0> @Override <line1> public void initialize(final ExtensionContext context) { <line2> final SubsystemRegistration subsystem = <line3> context.registerSubsystem(SUBSYSTEM_NAME, MGMT_API_VERSION); <line4> ManagementResourceRegistration registration = <line5> subsystem.registerSubsystemModel(KEYCLOAK_SUBSYSTEM_RESOURCE); <line6> registration.registerSubModel(REALM_DEFINITION); <line7> ManagementResourceRegistration secureDeploymentRegistration = <line8> registration.registerSubModel(SECURE_DEPLOYMENT_DEFINITION); <line9> secureDeploymentRegistration.registerSubModel(CREDENTIAL_DEFINITION); <line10> secureDeploymentRegistration.registerSubModel(REDIRECT_RULE_DEFINITON); <line11> ManagementResourceRegistration secureServerRegistration = <line12> registration.registerSubModel(SECURE_SERVER_DEFINITION); <line13> secureServerRegistration.registerSubModel(CREDENTIAL_DEFINITION); <line14> secureServerRegistration.registerSubModel(REDIRECT_RULE_DEFINITON); <line15> subsystem.registerXMLElementWriter(PARSER); <line16> } <line17> } <line18> 	 <line2>	Yes
public class A { <line0> void executeNext() { <line1> final int index = attempt.getAndIncrement(); <line2> final InetSocketAddress remoteAddress = <line3> new InetSocketAddress(remoteAddresses[index], remoteEndpoint.getPort()); <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> final Future<IOSession> sessionFuture = <line7> connectionInitiator.connect( <line8> remoteEndpoint, <line9> remoteAddress, <line10> localAddress, <line11> connectTimeout, <line12> attachment, <line13> new FutureCallback<IOSession>() { <line14> @Override <line15> public void completed(final IOSession session) { <line16> if (LOG.isDebugEnabled()) { <line17> if (LOG.isDebugEnabled()) { <line18> } <line19> } <line20> future.completed(session); <line21> } <line22>  <line23> @Override <line24> public void failed(final Exception cause) { <line25> if (attempt.get() >= remoteAddresses.length) { <line26> if (LOG.isDebugEnabled()) { <line27> } <line28> if (cause instanceof IOException) { <line29> future.failed( <line30> ConnectExceptionSupport.enhance( <line31> (IOException) cause, remoteEndpoint, remoteAddresses)); <line32> } else { <line33> future.failed(cause); <line34> } <line35> } else { <line36> if (LOG.isDebugEnabled()) { <line37> } <line38> executeNext(); <line39> } <line40> } <line41>  <line42> @Override <line43> public void cancelled() { <line44> future.cancel(); <line45> } <line46> }); <line47> future.setDependency(sessionFuture); <line48> } <line49> } <line50> 	 <line6>	No
public class A { <line0> @Override <line1> public InputStream getResourceContent(ITransaction transaction, String uri) <line2> throws WebdavException { <line3> File file = new File(root, uri); <line4> InputStream in; <line5> try { <line6> in = new BufferedInputStream(new FileInputStream(file)); <line7> } catch (IOException e) { <line8> throw new WebdavException(e); <line9> } <line10> return in; <line11> } <line12> } <line13> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public Properties getConnectionProperties() throws BeelineHS2ConnectionFileParseException { <line2> Properties props = new Properties(); <line3> String fileLocation = getFileLocation(); <line4> if (fileLocation == null) { <line5> return props; <line6> } <line7> props.setProperty(HS2ConnectionFileParser.URL_PREFIX_PROPERTY_KEY, ""jdbc:hive2://""); <line8> Configuration conf = new Configuration(false); <line9> conf.addResource(new Path(new File(fileLocation).toURI())); <line10> try { <line11> for (Entry<String, String> kv : conf) { <line12> String key = kv.getKey(); <line13> if (key.startsWith(BEELINE_CONNECTION_PROPERTY_PREFIX)) { <line14> props.setProperty( <line15> key.substring(BEELINE_CONNECTION_PROPERTY_PREFIX.length()), kv.getValue()); <line16> } <line17> } <line18> } catch (Exception ex) { <line19> throw new BeelineHS2ConnectionFileParseException(ex.getMessage(), ex); <line20> } <line21> return props; <line22> } <line23> } <line24> "	 <line7>	Yes
public class A { <line0> protected void setStartLoopPoint(long startLoopPoint, boolean generateLoopBuffers) { <line1> this.startLoopPoint = startLoopPoint; <line2> if (generateLoopBuffers) { <line3> generateLoopBuffers(LOOP_POINT_START); <line4> } <line5> if (log.isDebugEnabled()) { <line6> } <line7> } <line8> } <line9> 	 <line4>	No
public class A { <line0> public Airport getAirport(String code) { <line1> if (StringUtils.isBlank(code)) { <line2> return null; <line3> } <line4> if (code.length() == 3) { <line5> AirportVo airportVo = airportService.getAirportByThreeLetterCode(code); <line6> if (airportVo != null) { <line7> return AirportServiceImpl.buildAirport(airportVo); <line8> } <line9> } else if (code.length() == 4) { <line10> AirportVo airportVo = airportService.getAirportByThreeLetterCode(code); <line11> if (airportVo != null) { <line12> return AirportServiceImpl.buildAirport(airportVo); <line13> } <line14> } <line15> return null; <line16> } <line17> } <line18> 	 <line0>	No
"public class A { <line0> @AcceptsPreStepAuth <line1> @GET <line2> @Path(""/consents/{consentId}/status"") <line3> public Response getConsentStatus(@NotEmpty @NotBlank @PathParam(""consentId"") String consentId) <line4> throws BankRequestFailedException { <line5> XS2AFactoryInput xs2AFactoryInput = new XS2AFactoryInput(); <line6> xs2AFactoryInput.setConsentId(consentId); <line7> IOProcessor ioProcessor = new IOProcessor(getXS2AStandard()); <line8> ioProcessor.modifyInput(xs2AFactoryInput); <line9> AISRequest request = <line10> new AISRequestFactory() <line11> .create(getXS2AStandard().getRequestClassProvider().consentStatus(), xs2AFactoryInput); <line12> request.getHeaders().putAll(getAdditionalHeaders()); <line13> ioProcessor.modifyRequest(request, xs2AFactoryInput); <line14> ConsentStatus state = getXS2AStandard().getCs().getStatus(request); <line15> GetConsentStatusResponse response = new GetConsentStatusResponse(state); <line16> return Response.status(ResponseConstant.OK).entity(response).build(); <line17> } <line18> } <line19> "	 <line3>	No
"public class A { <line0> @Override <line1> public void configure(JobConf job) { <line2> try { <line3> BayesParameters params = new BayesParameters(job.get(""bayes.parameters"", """")); <line4> Algorithm algorithm; <line5> Datastore datastore; <line6> if (""hdfs"".equals(params.get(""dataSource""))) { <line7> if (""bayes"".equalsIgnoreCase(params.get(""classifierType""))) { <line8> algorithm = new BayesAlgorithm(); <line9> datastore = new InMemoryBayesDatastore(params); <line10> } else if (""cbayes"".equalsIgnoreCase(params.get(""classifierType""))) { <line11> algorithm = new CBayesAlgorithm(); <line12> datastore = new InMemoryBayesDatastore(params); <line13> } else { <line14> throw new IllegalArgumentException( <line15> ""Unrecognized classifier type: "" + params.get(""classifierType"")); <line16> } <line17> } else { <line18> throw new IllegalArgumentException( <line19> ""Unrecognized dataSource type: "" + params.get(""dataSource"")); <line20> } <line21> classifier = new ClassifierContext(algorithm, datastore); <line22> classifier.initialize(); <line23> defaultCategory = params.get(""defaultCat""); <line24> gramSize = params.getGramSize(); <line25> } catch (IOException ex) { <line26> } catch (InvalidDatastoreException e) { <line27> } <line28> } <line29> } <line30> "	 <line24>	No
"public class A { <line0> @Override <line1> public void enableResource( <line2> final String clusterName, final String resourceName, final boolean enabled) { <line3> String path = PropertyPathBuilder.idealState(clusterName, resourceName); <line4> BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<ZNRecord>(_zkClient); <line5> if (!baseAccessor.exists(path, 0)) { <line6> throw new HelixException( <line7> ""Cluster "" <line8> + clusterName <line9> + "", resource: "" <line10> + resourceName <line11> + "", ideal-state does not exist""); <line12> } <line13> baseAccessor.update( <line14> path, <line15> new DataUpdater<ZNRecord>() { <line16> @Override <line17> public ZNRecord update(ZNRecord currentData) { <line18> if (currentData == null) { <line19> throw new HelixException( <line20> ""Cluster: "" <line21> + clusterName <line22> + "", resource: "" <line23> + resourceName <line24> + "", ideal-state is null""); <line25> } <line26> IdealState idealState = new IdealState(currentData); <line27> idealState.enable(enabled); <line28> return idealState.getRecord(); <line29> } <line30> }, <line31> AccessOption.PERSISTENT); <line32> } <line33> } <line34> "	 <line3>	Yes
public class A { <line0> private void prepareStandardView(RenderRequest request) throws IOException { <line1> List<Component> componentList = getFilteredComponentList(request); <line2> Set<String> vendorNames; <line3> try { <line4> vendorNames = thriftClients.makeVendorClient().getAllVendorNames(); <line5> } catch (TException e) { <line6> vendorNames = Collections.emptySet(); <line7> } <line8> List<String> componentTypeNames = <line9> Arrays.asList(ComponentType.values()).stream() <line10> .map(ThriftEnumUtils::enumToString) <line11> .collect(Collectors.toList()); <line12> request.setAttribute(VENDOR_LIST, new ThriftJsonSerializer().toJson(vendorNames)); <line13> request.setAttribute(COMPONENT_LIST, componentList); <line14> request.setAttribute( <line15> COMPONENT_TYPE_LIST, new ThriftJsonSerializer().toJson(componentTypeNames)); <line16> } <line17> } <line18> 	 <line6>	Yes
"public class A { <line0> public void fireLifecycleEvent(LifecycleEvent.LifecycleState lifecycleState) { <line1> final LifecycleEvent lifecycleEvent = new LifecycleEvent(lifecycleState); <line2> String revision = buildInfo.getRevision(); <line3> if (isNullOrEmpty(revision)) { <line4> revision = """"; <line5> } else { <line6> revision = "" - "" + revision; <line7> BuildInfo upstreamInfo = buildInfo.getUpstreamBuildInfo(); <line8> if (upstreamInfo != null) { <line9> String upstreamRevision = upstreamInfo.getRevision(); <line10> if (!isNullOrEmpty(upstreamRevision)) { <line11> revision += "", "" + upstreamRevision; <line12> } <line13> } <line14> } <line15> getLogger() <line16> executor.execute( <line17> new Runnable() { <line18> @Override <line19> public void run() { <line20> for (LifecycleListener lifecycleListener : lifecycleListeners.values()) { <line21> lifecycleListener.stateChanged(lifecycleEvent); <line22> } <line23> } <line24> }); <line25> } <line26> } <line27> "	 <line16>	Yes
public class A { <line0> private BaseQueryImpl<?> parse(CriteriaBuilderImpl cb) { <line1> final CommonTree tree = this.parse(this.qlString); <line2> return this.construct(cb, tree); <line3> } <line4> } <line5> 	 <line3>	No
public class A { <line0> public void shutdown() { <line1> if (startupLogger != null) { <line2> } <line3> try { <line4> uiModule.close(); <line5> syntheticMonitorService.close(); <line6> rollupService.close(); <line7> updateAgentConfigIfNeededService.close(); <line8> grpcServer.close(); <line9> centralAlertingService.close(); <line10> alertingService.close(); <line11> session.close(); <line12> cluster.close(); <line13> clusterManager.close(); <line14> if (startupLogger != null) { <line15> for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) { <line16> Thread thread = entry.getKey(); <line17> StackTraceElement[] stackTrace = entry.getValue(); <line18> if (!thread.isDaemon() && thread != Thread.currentThread() && stackTrace.length != 0) { <line19> } <line20> } <line21> } <line22> } catch (Throwable t) { <line23> if (startupLogger == null) { <line24> t.printStackTrace(); <line25> } else { <line26> } <line27> } <line28> } <line29> } <line30> 	 <line2>	Yes
"public class A { <line0> private void moveConfirmationConfiguration() { <line1> Map<String, EmailConfirmationConfiguration> attrsConfig = new HashMap<>(); <line2> Map<String, EmailConfirmationConfiguration> idsConfig = new HashMap<>(); <line3> List<GenericObjectBean> conConfs = <line4> genericObjectsDAO.getObjectsOfType(""confirmationConfiguration""); <line5> for (GenericObjectBean confirmationConfig : conConfs) { <line6> ObjectNode objContent = JsonUtil.parse(confirmationConfig.getContents()); <line7> EmailConfirmationConfiguration emailConfig = new EmailConfirmationConfiguration(); <line8> emailConfig.setMessageTemplate(objContent.get(""msgTemplate"").asText()); <line9> if (objContent.get(""validityTime"") != null) <line10> emailConfig.setValidityTime(objContent.get(""validityTime"").asInt()); <line11> if (objContent.get(""typeToConfirm"").asText().equals(""attribute"")) { <line12> attrsConfig.put(objContent.get(""nameToConfirm"").asText(), emailConfig); <line13> } else if (objContent.get(""typeToConfirm"").asText().equals(""identity"")) { <line14> idsConfig.put(objContent.get(""nameToConfirm"").asText(), emailConfig); <line15> } <line16> } <line17> updateAttributeTypes(attrsConfig); <line18> updateIdentityTypes(idsConfig); <line19> genericObjectsDAO.removeObjectsByType(""confirmationConfiguration""); <line20> } <line21> } <line22> "	 <line19>	Yes
public class A { <line0> @Override <line1> public boolean insert(PostgresPersistenceManager<J> pm, FeatureOfInterest foi) <line2> throws IncompleteEntityException { <line3> Map<Field, Object> insert = new HashMap<>(); <line4> insert.put(table.colName, foi.getName()); <line5> insert.put(table.colDescription, foi.getDescription()); <line6> insert.put(table.colProperties, new JsonValue(foi.getProperties())); <line7> String encodingType = foi.getEncodingType(); <line8> insert.put(table.colEncodingType, encodingType); <line9> EntityFactories.insertGeometry( <line10> insert, table.colFeature, table.colGeom, encodingType, foi.getFeature()); <line11> entityFactories.insertUserDefinedId(pm, insert, table.getId(), foi); <line12> DSLContext dslContext = pm.getDslContext(); <line13> Record1<J> result = <line14> dslContext.insertInto(table).set(insert).returningResult(table.getId()).fetchOne(); <line15> J generatedId = result.component1(); <line16> foi.setId(entityFactories.idFromObject(generatedId)); <line17> return true; <line18> } <line19> } <line20> 	 <line16>	Yes
public class A { <line0> @AfterClass <line1> public static void tearDownAfterClass() throws Exception { <line2> try { <line3> application.stop(); <line4> } catch (final Exception e) { <line5> } <line6> junitHelper.releasePort(port); <line7> VitamClientFactory.resetConnections(); <line8> } <line9> } <line10> 	 <line4>	No
public class A { <line0> private static File getExplicitConfigurationDirectory(Map<String, String> envp) { <line1> String conf = envp.get(ENV_HADOOP_CONF); <line2> if (conf == null) { <line3> return null; <line4> } <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> return new File(conf); <line8> } <line9> } <line10> 	 <line5>	No
"public class A { <line0> public static Model parse(MolgenisOptions options) throws Exception { <line1> Model model = null; <line2> try { <line3> model = MolgenisModelParser.parseDbSchema(options.model_database); <line4> for (String eName : options.authorizable) { <line5> eName = eName.trim(); <line6> Vector<String> implNames = model.getEntity(eName).getImplementsNames(); <line7> if (!implNames.contains(""Authorizable"")) { <line8> implNames.add(""Authorizable""); <line9> model.getEntity(eName).setImplements(implNames); <line10> } <line11> } <line12> MolgenisModelValidator.validate(model, options); <line13> model = MolgenisModelParser.parseUiSchema(options.path + options.model_userinterface, model); <line14> MolgenisModelValidator.validateUI(model, options); <line15> } catch (MolgenisModelException e) { <line16> e.printStackTrace(); <line17> throw e; <line18> } <line19> return model; <line20> } <line21> } <line22> "	 <line14>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> while (!shutdown.get()) { <line4> try { <line5> final List<ScheduleMeasurements_args> list = new ArrayList<ScheduleMeasurements_args>(); <line6> argQueue.drainTo(list); <line7> if (!list.isEmpty()) { <line8> scheduleMeasurements(list); <line9> } <line10> Thread.sleep(30000); <line11> } catch (InterruptedException e) { <line12> } <line13> } <line14> } catch (Throwable t) { <line15> } <line16> } <line17> } <line18> 	 <line13>	No
"public class A { <line0> @POST <line1> @Consumes(""application/activemq.jms.queue+xml"") <line2> public Response createJmsQueue(@Context UriInfo uriInfo, Document document) { <line3> try { <line4> JMSQueueConfiguration queue = <line5> FileJMSConfiguration.parseQueueConfiguration(document.getDocumentElement()); <line6> ActiveMQQueue activeMQQueue = ActiveMQDestination.createQueue(queue.getName()); <line7> String queueName = activeMQQueue.getAddress(); <line8> ClientSession session = manager.getSessionFactory().createSession(false, false, false); <line9> try { <line10> ClientSession.QueueQuery query = session.queueQuery(new SimpleString(queueName)); <line11> if (!query.isExists()) { <line12> if (queue.getSelector() != null) { <line13> session.createQueue( <line14> new QueueConfiguration(queueName) <line15> .setFilterString(queue.getSelector()) <line16> .setDurable(queue.isDurable())); <line17> } else { <line18> session.createQueue(new QueueConfiguration(queueName).setDurable(queue.isDurable())); <line19> } <line20> } else { <line21> throw new WebApplicationException( <line22> Response.status(412).type(""text/plain"").entity(""Queue already exists."").build()); <line23> } <line24> } finally { <line25> try { <line26> session.close(); <line27> } catch (Exception ignored) { <line28> } <line29> } <line30> URI uri = uriInfo.getRequestUriBuilder().path(queueName).build(); <line31> return Response.created(uri).build(); <line32> } catch (Exception e) { <line33> if (e instanceof WebApplicationException) throw (WebApplicationException) e; <line34> throw new WebApplicationException( <line35> e, Response.serverError().type(""text/plain"").entity(""Failed to create queue."").build()); <line36> } <line37> } <line38> } <line39> "	 <line20>	No
public class A { <line0> public List<PersonInfo> getPeople() { <line1> List<PersonInfo> people = new LinkedList<PersonInfo>(); <line2> List<Person> peopleDb = personDao.getAllRecords(); <line3> for (Person subject : peopleDb) { <line4> PersonInfo person = createPersonInfo(subject); <line5> people.add(person); <line6> } <line7> return people; <line8> } <line9> } <line10> 	 <line7>	Yes
"public class A { <line0> public void loadConfiguration() throws IOException { <line1> FileUtils.checkDirectory(Paths.get(this.conf)); <line2> Path path = Paths.get(this.conf).resolve(""configuration.yml""); <line3> if (Files.exists(path)) { <line4> this.configuration = Configuration.load(new FileInputStream(path.toFile())); <line5> } else { <line6> this.configuration = <line7> Configuration.load( <line8> Configuration.class.getClassLoader().getResourceAsStream(""configuration.yml"")); <line9> } <line10> } <line11> } <line12> "	 <line6>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> start.await(); <line4> retrieves.addAll(retrieve(store)); <line5> done.countDown(); <line6> } catch (IOException e) { <line7> } catch (InterruptedException e) { <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> private List<Cloud> getCloudsByCloudRequestDTOs(final List<CloudRequestDTO> cloudDTOs) { <line1> final List<Cloud> clouds = new ArrayList<>(); <line2> for (final CloudRequestDTO dto : cloudDTOs) { <line3> final Cloud cloud = <line4> gatekeeperDBService.getCloudByOperatorAndName(dto.getOperator(), dto.getName()); <line5> clouds.add(cloud); <line6> } <line7> return clouds; <line8> } <line9> } <line10> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void configure(ApplicationContext applicationContext, SpringCamelContext camelContext) { <line2> CamelConfigurationProperties config = <line3> applicationContext.getBean(CamelConfigurationProperties.class); <line4> if (config != null) { <line5> try { <line6> CamelAutoConfiguration.doConfigureCamelContext(applicationContext, camelContext, config); <line7> } catch (Exception e) { <line8> throw RuntimeCamelException.wrapRuntimeCamelException(e); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line5>	No
public class A { <line0> public ApplicationMap selectApplicationMapWithScatterData(FilteredMapServiceOption option) { <line1> StopWatch watch = new StopWatch(); <line2> watch.start(); <line3> final List<List<SpanBo>> filterList = <line4> selectFilteredSpan( <line5> option.getTransactionIdList(), option.getFilter(), option.getColumnGetCount()); <line6> FilteredMapBuilder filteredMapBuilder = <line7> new FilteredMapBuilder( <line8> applicationFactory, registry, option.getOriginalRange(), option.getVersion()); <line9> filteredMapBuilder.serverMapDataFilter(serverMapDataFilter); <line10> filteredMapBuilder.addTransactions(filterList); <line11> FilteredMap filteredMap = filteredMapBuilder.build(); <line12> ApplicationMap map = createMap(option, filteredMap); <line13> Map<Application, ScatterData> applicationScatterData = <line14> filteredMap.getApplicationScatterData( <line15> option.getOriginalRange().getFrom(), <line16> option.getOriginalRange().getTo(), <line17> option.getxGroupUnit(), <line18> option.getyGroupUnit()); <line19> ApplicationMapWithScatterData applicationMapWithScatterData = <line20> new ApplicationMapWithScatterData(map, applicationScatterData); <line21> watch.stop(); <line22> return applicationMapWithScatterData; <line23> } <line24> } <line25> 	 <line12>	No
public class A { <line0> protected String getURLViewInContext( <line1> JournalArticle article, String portletId, ServiceContext serviceContext) { <line2> String defaultArticleURL = StringPool.BLANK; <line3> try { <line4> defaultArticleURL = _portal.getControlPanelFullURL(article.getGroupId(), portletId, null); <line5> } catch (PortalException portalException) { <line6> } <line7> LiferayPortletRequest liferayPortletRequest = serviceContext.getLiferayPortletRequest(); <line8> if (liferayPortletRequest == null) { <line9> return defaultArticleURL; <line10> } <line11> try { <line12> AssetRendererFactory<JournalArticle> assetRendererFactory = <line13> AssetRendererFactoryRegistryUtil.getAssetRendererFactoryByClass(JournalArticle.class); <line14> AssetRenderer<JournalArticle> assetRenderer = <line15> assetRendererFactory.getAssetRenderer(article, AssetRendererFactory.TYPE_LATEST_APPROVED); <line16> return assetRenderer.getURLViewInContext(liferayPortletRequest, null, defaultArticleURL); <line17> } catch (Exception exception) { <line18> } <line19> return StringPool.BLANK; <line20> } <line21> } <line22> 	 <line14>	No
"public class A { <line0> public static com.liferay.knowledge.base.model.KBArticle fetchKBArticleByUrlTitle( <line1> HttpPrincipal httpPrincipal, long groupId, long kbFolderId, String urlTitle) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KBArticleServiceUtil.class, <line7> ""fetchKBArticleByUrlTitle"", <line8> _fetchKBArticleByUrlTitleParameterTypes8); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, kbFolderId, urlTitle); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.knowledge.base.model.KBArticle) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	 <line19>	No
public class A { <line0> protected final boolean isLayerizedNetwork(String networkId) { <line1> String connType = getConnectionType(networkId); <line2> if (LAYERIZED_NETWORK.equals(connType)) { <line3> return true; <line4> } <line5> return false; <line6> } <line7> } <line8> 	 <line1>	Yes
"public class A { <line0> public static Map<String, List<Trip>> getTripsByBlockInSortedOrder(GtfsMutableRelationalDao dao) { <line1> Map<String, List<Trip>> tripsByBlockId = new HashMap<String, List<Trip>>(); <line2> Map<Trip, Integer> averageStopTimeByTrip = new HashMap<Trip, Integer>(); <line3> int totalTrips = 0; <line4> int tripsWithoutStopTimes = 0; <line5> for (Trip trip : dao.getAllTrips()) { <line6> totalTrips++; <line7> String blockId = trip.getBlockId(); <line8> if (blockId == null) blockId = trip.getId() + ""-"" + Math.random(); <line9> List<Trip> trips = tripsByBlockId.get(blockId); <line10> if (trips == null) { <line11> trips = new ArrayList<Trip>(); <line12> tripsByBlockId.put(blockId, trips); <line13> } <line14> trips.add(trip); <line15> List<StopTime> stopTimes = dao.getStopTimesForTrip(trip); <line16> if (stopTimes.isEmpty()) { <line17> tripsWithoutStopTimes++; <line18> } else { <line19> int arrivalTimes = 0; <line20> int arrivalTimeCount = 0; <line21> for (StopTime stopTime : stopTimes) { <line22> if (stopTime.isArrivalTimeSet()) { <line23> arrivalTimes += stopTime.getArrivalTime(); <line24> arrivalTimeCount++; <line25> } <line26> } <line27> if (arrivalTimeCount > 0) { <line28> int averageArrivalTime = arrivalTimes / arrivalTimeCount; <line29> averageStopTimeByTrip.put(trip, averageArrivalTime); <line30> } <line31> } <line32> } <line33> TripComparator c = new TripComparator(averageStopTimeByTrip); <line34> for (List<Trip> tripsInBlock : tripsByBlockId.values()) { <line35> Collections.sort(tripsInBlock, c); <line36> } <line37> return tripsByBlockId; <line38> } <line39> } <line40> "	 <line36>	No
public class A { <line0> private void loadWeightDataForOneDay(UpdateInfo updateInfo, String formattedDate) <line1> throws Exception { <line2> String json = getWeightData(updateInfo, formattedDate); <line3> String fatJson = getBodyFatData(updateInfo, formattedDate); <line4> JSONObject jsonWeight = JSONObject.fromObject(json); <line5> JSONObject jsonFat = JSONObject.fromObject(fatJson); <line6> json = mergeWeightInfos(jsonWeight, jsonFat); <line7> apiDataService.eraseApiData(updateInfo.apiKey, weightOT, Arrays.asList(formattedDate)); <line8> if (json != null) { <line9> JSONObject fitbitResponse = JSONObject.fromObject(json); <line10> final List<FitbitWeightFacet> createdOrUpdatedWeightFacets = <line11> fitbitPersistenceHelper.createOrUpdateWeightFacets(updateInfo, fitbitResponse); <line12> bodyTrackStorageService.storeApiData(updateInfo.apiKey, createdOrUpdatedWeightFacets); <line13> } <line14> } <line15> } <line16> 	 <line7>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> monitorHeartbeats(); <line4> } catch (final Exception e) { <line5> clusterCoordinator.reportEvent( <line6> null, Severity.ERROR, ""Failed to process heartbeats from nodes due to "" + e.toString()); <line7> } <line8> } <line9> } <line10> "	 <line7>	Yes
"public class A { <line0> protected final Service createService() { <line1> Service service = null; <line2> URL wsdlURL; <line3> if (StringUtils.isNotBlank(wsdlLocation) && StringUtils.isNotBlank(serviceName)) { <line4> try { <line5> URIResolver uriResolver = new URIResolver(); <line6> uriResolver.resolve("""", wsdlLocation, this.getClass()); <line7> wsdlURL = uriResolver.isResolved() ? uriResolver.getURL() : new URL(wsdlLocation); <line8> service = <line9> AccessController.doPrivileged( <line10> (PrivilegedAction<Service>) <line11> () -> Service.create(wsdlURL, QName.valueOf(serviceName))); <line12> auditRemoteConnection(wsdlURL); <line13> } catch (Exception e) { <line14> } <line15> } <line16> return service; <line17> } <line18> } <line19> "	 <line3>	No
public class A { <line0> private static VoltageLevel createVoltageLevel( <line1> MBus mBus, <line2> String voltageLevelId, <line3> Substation substation, <line4> Network network, <line5> PerUnitContext perUnitContext) { <line6> double nominalV = <line7> perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage(); <line8> VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId); <line9> if (voltageLevel == null) { <line10> voltageLevel = <line11> substation <line12> .newVoltageLevel() <line13> .setId(voltageLevelId) <line14> .setNominalV(nominalV) <line15> .setTopologyKind(TopologyKind.BUS_BREAKER) <line16> .add(); <line17> } <line18> return voltageLevel; <line19> } <line20> } <line21> 	 <line17>	Yes
"public class A { <line0> void writeSolrConfiguration(String core) { <line1> File configDir = Paths.get(this.dataDirectory.getAbsolutePath(), core, ""conf"").toFile(); <line2> boolean directoriesMade = configDir.mkdirs(); <line3> for (String filename : SOLR_CONFIG_FILES) { <line4> File currentFile = new File(configDir, filename); <line5> File backupFile = new File(configDir, filename + "".bak""); <line6> if (!currentFile.exists() && !backupFile.exists()) { <line7> try (InputStream inputStream = <line8> ConfigurationFileProxy.class <line9> .getClassLoader() <line10> .getResourceAsStream(""solr/conf/"" + filename); <line11> FileOutputStream outputStream = new FileOutputStream(currentFile)) { <line12> long byteCount = IOUtils.copyLarge(inputStream, outputStream); <line13> } catch (IOException e) { <line14> } <line15> } <line16> } <line17> } <line18> } <line19> "	 <line11>	No
public class A { <line0> public LdapContextFactory getLdapContextFactory() { <line1> if (this.ldapContextFactory == null) { <line2> DefaultLdapContextFactory defaultFactory = new DefaultLdapContextFactory(); <line3> defaultFactory.setPrincipalSuffix(this.principalSuffix); <line4> defaultFactory.setSearchBase(this.searchBase); <line5> defaultFactory.setUrl(this.url); <line6> defaultFactory.setSystemUsername(this.systemUsername); <line7> defaultFactory.setSystemPassword(getSystemPassword()); <line8> this.ldapContextFactory = defaultFactory; <line9> } <line10> return this.ldapContextFactory; <line11> } <line12> } <line13> 	 <line5>	No
public class A { <line0> private void graphCommit() { <line1> try { <line2> graph.commit(); <line3> } catch (Exception ex) { <line4> graphRollback(); <line5> } <line6> } <line7> } <line8> 	 <line0>	No
public class A { <line0> private DescendantConsumers getDescendantConsumers(PCollectionNode inputPCollection) { <line1> Set<PTransformNode> unfused = new HashSet<>(); <line2> NavigableSet<CollectionConsumer> downstreamConsumers = new TreeSet<>(); <line3> for (PTransformNode consumer : pipeline.getPerElementConsumers(inputPCollection)) { <line4> if (pipeline.getEnvironment(consumer).isPresent()) { <line5> downstreamConsumers.add(CollectionConsumer.of(inputPCollection, consumer)); <line6> } else { <line7> unfused.add(consumer); <line8> for (PCollectionNode output : pipeline.getOutputPCollections(consumer)) { <line9> DescendantConsumers descendants = getDescendantConsumers(output); <line10> unfused.addAll(descendants.getUnfusedNodes()); <line11> downstreamConsumers.addAll(descendants.getFusibleConsumers()); <line12> } <line13> } <line14> } <line15> return DescendantConsumers.of(unfused, downstreamConsumers); <line16> } <line17> } <line18> 	 <line7>	Yes
"public class A { <line0> private List<String> getConnectedDevices() { <line1> String deviceUDID = ""(.*)\\tdevice$""; <line2> String[] cmd = CmdLine.insertCommandsAfter(executor.getDefaultCmd(), ""devices""); <line3> List<String> cmdOutput = executor.execute(cmd); <line4> List<String> connectedDevices = <line5> cmdOutput.stream() <line6> .parallel() <line7> .filter((d) -> d.matches(deviceUDID)) <line8> .collect(Collectors.toList()); <line9> return connectedDevices; <line10> } <line11> } <line12> "	 <line9>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> Collection<StreamingSegmentManager> segmentManagers = getAllCubeSegmentManagers(); <line3> long curr = System.currentTimeMillis(); <line4> for (StreamingSegmentManager segmentManager : segmentManagers) { <line5> CubeInstance cubeInstance = segmentManager.getCubeInstance(); <line6> String cubeName = cubeInstance.getName(); <line7> try { <line8> Collection<StreamingCubeSegment> activeSegments = segmentManager.getActiveSegments(); <line9> for (StreamingCubeSegment segment : activeSegments) { <line10> long delta = curr - segment.getLastUpdateTime(); <line11> if (curr > segment.getDateRangeEnd() && delta > segmentManager.cubeDuration) { <line12> segmentManager.makeSegmentImmutable(segment.getSegmentName()); <line13> } <line14> } <line15> RetentionPolicyInfo retentionPolicyInfo = new RetentionPolicyInfo(); <line16> String policyName = cubeInstance.getConfig().getStreamingSegmentRetentionPolicy(); <line17> Map<String, String> policyProps = <line18> cubeInstance.getConfig().getStreamingSegmentRetentionPolicyProperties(policyName); <line19> retentionPolicyInfo.setName(policyName); <line20> retentionPolicyInfo.setProperties(policyProps); <line21> Collection<StreamingCubeSegment> segments = <line22> segmentManager.getRequireRemotePersistSegments(); <line23> if (!segments.isEmpty()) { <line24> } else { <line25> continue; <line26> } <line27> handleImmutableCubeSegments(cubeName, segmentManager, segments, retentionPolicyInfo); <line28> } catch (Exception e) { <line29> } <line30> } <line31> } <line32> } <line33> 	 <line29>	Yes
"public class A { <line0> public static java.util.List<com.liferay.dynamic.data.mapping.model.DDMTemplate> <line1> getTemplatesByClassPK( <line2> HttpPrincipal httpPrincipal, <line3> long companyId, <line4> long groupId, <line5> long classPK, <line6> long resourceClassNameId, <line7> int status) { <line8> try { <line9> MethodKey methodKey = <line10> new MethodKey( <line11> DDMTemplateServiceUtil.class, <line12> ""getTemplatesByClassPK"", <line13> _getTemplatesByClassPKParameterTypes16); <line14> MethodHandler methodHandler = <line15> new MethodHandler(methodKey, companyId, groupId, classPK, resourceClassNameId, status); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> return (java.util.List<com.liferay.dynamic.data.mapping.model.DDMTemplate>) returnObj; <line23> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line24> throw systemException; <line25> } <line26> } <line27> } <line28> "	 <line24>	Yes
public class A { <line0> private static synchronized RpcEngine getProtocolEngine(Class protocol, Configuration conf) { <line1> RpcEngine engine = PROTOCOL_ENGINES.get(protocol); <line2> if (engine == null) { <line3> Class<?> defaultEngine = ProtobufRpcEngine.class; <line4> Class<?> impl = defaultEngine; <line5> engine = (RpcEngine) ReflectionUtils.newInstance(impl, conf); <line6> if (protocol.isInterface()) <line7> PROXY_ENGINES.put(Proxy.getProxyClass(protocol.getClassLoader(), protocol), engine); <line8> PROTOCOL_ENGINES.put(protocol, engine); <line9> } <line10> return engine; <line11> } <line12> } <line13> 	 <line5>	Yes
public class A { <line0> @Override <line1> public ScriptEngineManager call() { <line2> long start = System.currentTimeMillis(); <line3> try { <line4> return new ScriptEngineManager(); <line5> } finally { <line6> long end = System.currentTimeMillis(); <line7> } <line8> } <line9> } <line10> 	 <line9>	No
public class A { <line0> private void releaseListeners() { <line1> for (Entry<String, WebRtcEndpoint> entry : listeners.entrySet()) { <line2> final String inUid = entry.getKey(); <line3> final WebRtcEndpoint ep = entry.getValue(); <line4> outgoingMedia.disconnect( <line5> ep, <line6> new Continuation<Void>() { <line7> @Override <line8> public void onSuccess(Void result) throws Exception { <line9> } <line10>  <line11> @Override <line12> public void onError(Throwable cause) throws Exception { <line13> } <line14> }); <line15> ep.release( <line16> new Continuation<Void>() { <line17> @Override <line18> public void onSuccess(Void result) throws Exception { <line19> } <line20>  <line21> @Override <line22> public void onError(Throwable cause) throws Exception { <line23> } <line24> }); <line25> } <line26> listeners.clear(); <line27> } <line28> } <line29> 	 <line2>	No
public class A { <line0> @Override <line1> public List<AggregateResult> calcResult(long curStartTime, long curEndTime) throws IOException { <line2> List<ByteBuffer> aggrBuffers; <line3> try { <line4> if (ClusterDescriptor.getInstance().getConfig().isUseAsyncServer()) { <line5> AsyncDataClient client = <line6> metaGroupMember <line7> .getClientProvider() <line8> .getAsyncDataClient(source, RaftServer.getReadOperationTimeoutMS()); <line9> aggrBuffers = <line10> SyncClientAdaptor.getGroupByResult( <line11> client, header, executorId, curStartTime, curEndTime); <line12> } else { <line13> try (SyncDataClient syncDataClient = <line14> metaGroupMember <line15> .getClientProvider() <line16> .getSyncDataClient(source, RaftServer.getReadOperationTimeoutMS())) { <line17> aggrBuffers = <line18> syncDataClient.getGroupByResult(header, executorId, curStartTime, curEndTime); <line19> } <line20> } <line21> } catch (TException e) { <line22> throw new IOException(e); <line23> } catch (InterruptedException e) { <line24> Thread.currentThread().interrupt(); <line25> throw new IOException(e); <line26> } <line27> resetAggregateResults(); <line28> if (aggrBuffers != null) { <line29> for (int i = 0; i < aggrBuffers.size(); i++) { <line30> AggregateResult result = AggregateResult.deserializeFrom(aggrBuffers.get(i)); <line31> results.get(i).merge(result); <line32> } <line33> } <line34> return results; <line35> } <line36> } <line37> 	 <line34>	Yes
"public class A { <line0> public String getAttachmentContentById( <line1> String containerId, Number taskId, Number attachmentId, String marshallingType) { <line2> containerId = <line3> context.getContainerId(containerId, new ByTaskIdContainerLocator(taskId.longValue())); <line4> Object attachment = <line5> userTaskService.getAttachmentContentById( <line6> containerId, taskId.longValue(), attachmentId.longValue()); <line7> if (attachment == null) { <line8> throw new IllegalStateException( <line9> ""No attachment found for id "" + attachmentId + "" for task "" + taskId); <line10> } <line11> String response = marshallerHelper.marshal(containerId, marshallingType, attachment); <line12> return response; <line13> } <line14> } <line15> "	 <line11>	Yes
public class A { <line0> @Override <line1> public boolean isShow(PortletRequest portletRequest) { <line2> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line3> try { <line4> MBMessage message = ActionUtil.getMessage(portletRequest); <line5> return ModelResourcePermissionUtil.contains( <line6> _categoryModelResourcePermission, <line7> themeDisplay.getPermissionChecker(), <line8> themeDisplay.getScopeGroupId(), <line9> message.getCategoryId(), <line10> ActionKeys.LOCK_THREAD); <line11> } catch (Exception exception) { <line12> if (_log.isDebugEnabled()) { <line13> } <line14> } <line15> return false; <line16> } <line17> } <line18> 	 <line12>	No
public class A { <line0> @Override <line1> public void processCancelSmResp(Command pduHeader, byte[] pdu, ResponseHandler responseHandler) <line2> throws IOException { <line3> PendingResponse<Command> pendingResp = <line4> responseHandler.removeSentItem(pduHeader.getSequenceNumber()); <line5> if (pendingResp != null) { <line6> CancelSmResp resp = pduDecomposer.cancelSmResp(pdu); <line7> pendingResp.done(resp); <line8> } else { <line9> } <line10> } <line11> } <line12> 	 <line9>	Yes
public class A { <line0> private static void setFileSize(DatenDownload datenDownload) { <line1> try { <line2> final File testFile = new File(datenDownload.arr[DatenDownload.DOWNLOAD_ZIEL_PFAD_DATEINAME]); <line3> if (testFile.exists()) { <line4> final long length = testFile.length(); <line5> if (length > 0) { <line6> datenDownload.mVFilmSize.setSize(length); <line7> } <line8> } <line9> } catch (Exception ex) { <line10> } <line11> } <line12> } <line13> 	 <line10>	Yes
"public class A { <line0> protected void startTraceJaegerGrpcListener( <line1> final String strPort, <line2> ReportableEntityHandlerFactory handlerFactory, <line3> @Nullable WavefrontSender wfSender, <line4> SpanSampler sampler) { <line5> if (tokenAuthenticator.authRequired()) { <line6> logger.warning(""Port: "" + strPort + "" is not compatible with HTTP authentication, ignoring""); <line7> return; <line8> } <line9> final int port = Integer.parseInt(strPort); <line10> startAsManagedThread( <line11> port, <line12> () -> { <line13> activeListeners.inc(); <line14> try { <line15> io.grpc.Server server = <line16> NettyServerBuilder.forPort(port) <line17> .addService( <line18> new JaegerGrpcCollectorHandler( <line19> strPort, <line20> handlerFactory, <line21> wfSender, <line22> () -> entityProps.get(ReportableEntityType.TRACE).isFeatureDisabled(), <line23> () -> <line24> entityProps <line25> .get(ReportableEntityType.TRACE_SPAN_LOGS) <line26> .isFeatureDisabled(), <line27> preprocessors.get(strPort), <line28> sampler, <line29> proxyConfig.getTraceJaegerApplicationName(), <line30> proxyConfig.getTraceDerivedCustomTagKeys())) <line31> .build(); <line32> server.start(); <line33> } catch (Exception e) { <line34> logger.log(Level.SEVERE, ""Jaeger gRPC trace collector exception"", e); <line35> } finally { <line36> activeListeners.dec(); <line37> } <line38> }, <line39> ""listener-jaeger-grpc-"" + strPort); <line40> } <line41> } <line42> "	 <line40>	Yes
"public class A { <line0> @Override <line1> public void deleteFile(String name) throws IOException { <line2> if (_readOnly) { <line3> throw new IOException(""Directory is in read only mode.""); <line4> } <line5> Long length = _files.remove(name); <line6> if (length != null) { <line7> long blocks = length / _blockSize; <line8> _store.delete(new BytesRef(name + LENGTH)); <line9> _store.delete(new BytesRef(name + LASTMOD)); <line10> for (long l = 0; l <= blocks; l++) { <line11> _store.delete(new BytesRef(name + ""/"" + l)); <line12> } <line13> writeFileNamesAndSync(); <line14> } <line15> } <line16> } <line17> "	 <line2>	No
public class A { <line0> @Override <line1> public void onPendingFailure(ProviderException cause) { <line2> participants.put(envelope.getConsumerId(), envelope.getConsumerId()); <line3> } <line4> } <line5> 	 <line1>	No
public class A { <line0> @Override <line1> public synchronized void beforePhase(PhaseEvent event) { <line2> if (event.getPhaseId() == PhaseId.RESTORE_VIEW) { <line3> restoreMessages(event.getFacesContext()); <line4> } <line5> } <line6> } <line7> 	 <line5>	No
public class A { <line0> protected void createOCFS2Sr(StorageFilerTO pool) throws XmlRpcException { <line1> OvmStoragePool.Details d = new OvmStoragePool.Details(); <line2> d.path = pool.getPath(); <line3> d.type = OvmStoragePool.OCFS2; <line4> d.uuid = pool.getUuid(); <line5> OvmStoragePool.create(_conn, d); <line6> } <line7> } <line8> 	 <line6>	Yes
public class A { <line0> private void executeService( <line1> String requestType, HttpServletRequest request, HttpServletResponse response) { <line2> CoreSettings coreSettings = <line3> (CoreSettings) request.getServletContext().getAttribute(TAG_CORE_SETTINGS); <line4> try (Service service = new Service(coreSettings)) { <line5> sendResponse(service.execute(serviceRequestFromHttpRequest(request, requestType)), response); <line6> } catch (Exception exc) { <line7> sendResponse(new ServiceResponse<>(500, exc.getMessage()), response); <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> private void writeInternal(ByteBuffer buff, long position, Handler<AsyncResult<Void>> handler) { <line1> ch.write( <line2> buff, <line3> position, <line4> null, <line5> new java.nio.channels.CompletionHandler<Integer, Object>() { <line6> public void completed(Integer bytesWritten, Object attachment) { <line7> long pos = position; <line8> if (buff.hasRemaining()) { <line9> pos += bytesWritten; <line10> writeInternal(buff, pos, handler); <line11> } else { <line12> context.runOnContext( <line13> (v) -> { <line14> synchronized (AsyncFileImpl.this) { <line15> writesOutstanding -= buff.limit(); <line16> } <line17> handler.handle(Future.succeededFuture()); <line18> }); <line19> } <line20> } <line21>  <line22> public void failed(Throwable exc, Object attachment) { <line23> if (exc instanceof Exception) { <line24> context.runOnContext( <line25> (v) -> { <line26> synchronized (AsyncFileImpl.this) { <line27> writesOutstanding -= buff.limit(); <line28> } <line29> handler.handle(Future.failedFuture(exc)); <line30> }); <line31> } else { <line32> } <line33> } <line34> }); <line35> } <line36> } <line37> 	 <line19>	No
"public class A { <line0> @Override <line1> public final Assertion validate(final String ticket, final String service) <line2> throws TicketValidationException { <line3> final String validationUrl = constructValidationUrl(ticket, service); <line4> try { <line5> final String serverResponse = retrieveResponseFromServer(new URL(validationUrl), ticket); <line6> if (serverResponse == null) { <line7> throw new TicketValidationException(""The CAS server returned no response.""); <line8> } <line9> return parseResponseFromServer(serverResponse); <line10> } catch (final MalformedURLException e) { <line11> throw new TicketValidationException(e); <line12> } <line13> } <line14> } <line15> "	 <line9>	Yes
public class A { <line0> private void establishServer() throws TTransportException { <line1> if (ClusterDescriptor.getInstance().getConfig().isUseAsyncServer()) { <line2> poolServer = createAsyncServer(); <line3> } else { <line4> poolServer = createSyncServer(); <line5> } <line6> clientService = Executors.newSingleThreadExecutor(r -> new Thread(r, getServerClientName())); <line7> clientService.submit(() -> poolServer.serve()); <line8> } <line9> } <line10> 	 <line1>	Yes
public class A { <line0> private void correctPowerState(OnOffType powerState) { <line1> if (configuration.getPowerStateChanging() == PowerStateChanging.ALWAYS_OFF <line2> && (powerState != OnOffType.OFF)) { <line3> handleOnOffCommand(OnOffType.OFF); <line4> } else if (configuration.getPowerStateChanging() == PowerStateChanging.ALWAYS_ON <line5> && (powerState != OnOffType.ON)) { <line6> handleOnOffCommand(OnOffType.ON); <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
"public class A { <line0> @GetMapping(""/hystrix"") <line1> public Object hystrixPluginFallback() { <line2> } <line3> } <line4> "	 <line2>	Yes
public class A { <line0> private void handleProcessingTime(long processingTime, String documentId) <line1> throws IOException, InterruptedException { <line2> if (processingTime > processingTimeThreshold) { <line3> Map<CharSequence, CharSequence> supplementaryData = new HashMap<CharSequence, CharSequence>(); <line4> supplementaryData.put( <line5> FAULT_SUPPLEMENTARY_DATA_PROCESSING_TIME, String.valueOf(processingTime)); <line6> mos.write( <line7> namedOutputFault, <line8> new AvroKey<Fault>( <line9> Fault.newBuilder() <line10> .setInputObjectId(documentId) <line11> .setTimestamp(System.currentTimeMillis()) <line12> .setCode(FAULT_CODE_PROCESSING_TIME_THRESHOLD_EXCEEDED) <line13> .setSupplementaryData(supplementaryData) <line14> .build())); <line15> } <line16> } <line17> } <line18> 	 <line16>	Yes
public class A { <line0> @Override <line1> public void completed(Object body) { <line2> try { <line3> Response response = client.getResponse(); <line4> saveCookies(exchange, client, cxfRsEndpoint.getCookieHandler()); <line5> if (shouldHandleError(response)) { <line6> handleError(response); <line7> return; <line8> } <line9> if (!exchange.getPattern().isOutCapable()) { <line10> return; <line11> } <line12> exchange.getOut().getHeaders().putAll(exchange.getIn().getHeaders()); <line13> final CxfRsBinding binding = cxfRsEndpoint.getBinding(); <line14> exchange <line15> .getOut() <line16> .getHeaders() <line17> .putAll(binding.bindResponseHeadersToCamelHeaders(response, exchange)); <line18> exchange.getOut().setBody(binding.bindResponseToCamelBody(body, exchange)); <line19> exchange.getOut().setHeader(Exchange.HTTP_RESPONSE_CODE, response.getStatus()); <line20> } catch (Exception exception) { <line21> fail(exception); <line22> } finally { <line23> callback.done(false); <line24> } <line25> } <line26> } <line27> 	 <line21>	Yes
"public class A { <line0> private static void initadminUser() { <line1> try { <line2> adminUser = new User(); <line3> adminUser.setPerson(ImejiFactory.newPerson(""Admin"", ""imeji"", ""imeji community"")); <line4> adminUser.setEmail(ADMIN_EMAIL_INIT); <line5> adminUser.setEncryptedPassword(StringHelper.convertToMD5(ADMIN_PASSWORD_INIT)); <line6> adminUser <line7> .getGrants() <line8> .addAll(AuthorizationPredefinedRoles.imejiAdministrator(adminUser.getId().toString())); <line9> adminUser.setApiKey(APIKeyAuthentication.generateKey(adminUser.getId(), Integer.MAX_VALUE)); <line10> UserController uc = new UserController(Imeji.adminUser); <line11> List<User> admins = uc.retrieveAllAdmins(); <line12> if (admins.size() == 0) { <line13> try { <line14> uc.retrieve(Imeji.adminUser.getEmail()); <line15> } catch (NotFoundException e) { <line16> Imeji.adminUser = uc.create(Imeji.adminUser, USER_TYPE.ADMIN); <line17> } <line18> } else { <line19> for (User admin : admins) { <line20> } <line21> } <line22> } catch (AlreadyExistsException e) { <line23> } catch (Exception e) { <line24> if (e.getCause() instanceof AlreadyExistsException) { <line25> } else { <line26> throw new RuntimeException(""Error initializing Admin user! "", e); <line27> } <line28> } <line29> } <line30> } <line31> "	 <line25>	Yes
public class A { <line0> @Override <line1> public void handleTransportError(WebSocketSession session, Throwable tError) throws Exception { <line2> super.handleTransportError(session, tError); <line3> SessionMetaData sessionMd = internalSessionMap.get(session.getId()); <line4> if (sessionMd != null) { <line5> processInWebSocketService(sessionMd.sessionRef, SessionEvent.onError(tError)); <line6> } else { <line7> } <line8> } <line9> } <line10> 	 <line5>	No
public class A { <line0> private void clearResourceDefinitions() { <line1> resourceDefinitionRepository.deleteAll(); <line2> } <line3> } <line4> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void init() { <line2> messageRouter.registerMessageProcessedListener(this); <line3> mqttClient.setMessageListener(this); <line4> mqttClient.start(); <line5> mqttClientFactory.createSender(ownGbid).start(); <line6> subscribe(); <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> private int startServiceOnPort(int port) throws IOException { <line1> if (!(port == 0 || (1024 <= port && port < 65536))) { <line2> throw new IllegalArgumentException( <line3> String.format( <line4> ""startPort should be between 1024 and 65535 (inclusive), "" <line5> + ""or 0 for a random free port. but now is %s."", <line6> port)); <line7> } <line8> for (int attempt = 0; attempt < START_SERVICE_MAX_RETRIES; attempt++) { <line9> int tryPort = port == 0 ? port : (port + attempt - 1024) % (65536 - 1024) + 1024; <line10> try { <line11> app.start(tryPort); <line12> return app.port(); <line13> } catch (Exception e) { <line14> if (e.getMessage() != null && e.getMessage().contains(""Failed to bind to"")) { <line15> if (tryPort == 0) { <line16> } else { <line17> } <line18> } else { <line19> } <line20> } <line21> } <line22> throw new IOException( <line23> String.format( <line24> ""Timeline server start failed on port %d, after retry %d times"", <line25> port, START_SERVICE_MAX_RETRIES)); <line26> } <line27> } <line28> "	 <line13>	No
public class A { <line0> private boolean getBooleanValueFromYaml(String option) { <line1> String stringValue = yamlStringConfigs.get(option); <line2> boolean result = stringValue != null && Boolean.valueOf(stringValue).equals(Boolean.TRUE); <line3> return result; <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> @Override <line1> public void init(String storageResourceId, String gatewayId, String loginUser, String token) <line2> throws AgentException { <line3> try { <line4> StorageResourceDescription storageResource = <line5> AgentUtils.getRegistryServiceClient().getStorageResource(storageResourceId); <line6> SSHCredential sshCredential = <line7> AgentUtils.getCredentialClient().getSSHCredential(token, gatewayId); <line8> if (sshCredential == null) { <line9> throw new AgentException(""Null credential for token "" + token); <line10> } <line11> SshAdaptorParams adaptorParams = new SshAdaptorParams(); <line12> adaptorParams.setHostName(storageResource.getHostName()); <line13> adaptorParams.setUserName(loginUser); <line14> adaptorParams.setPassphrase(sshCredential.getPassphrase()); <line15> adaptorParams.setPrivateKey(sshCredential.getPrivateKey().getBytes()); <line16> adaptorParams.setPublicKey(sshCredential.getPublicKey().getBytes()); <line17> adaptorParams.setStrictHostKeyChecking(false); <line18> init(adaptorParams); <line19> } catch (Exception e) { <line20> throw new AgentException( <line21> ""Error while initializing ssh agent for storage resource "" <line22> + storageResourceId <line23> + "" to token "" <line24> + token, <line25> e); <line26> } <line27> } <line28> } <line29> "	 <line28>	No
public class A { <line0> @Override <line1> public int addToInt(Session session, int delta) { <line2> SessionImpl impl = (SessionImpl) session; <line3> IntVar var = impl.requireSet(index, key); <line4> int prev = var.intValue(session); <line5> if (trace) { <line6> } <line7> var.set(prev + delta); <line8> return prev; <line9> } <line10> } <line11> 	 <line6>	Yes
"public class A { <line0> protected static void saveFlowObjectStack( <line1> final NodeSettingsWO settings, final SingleNodeContainer nc) { <line2> NodeSettingsWO stackSet = settings.addNodeSettings(""flow_stack""); <line3> FlowObjectStack stack = nc.getOutgoingFlowObjectStack(); <line4> @SuppressWarnings(""unchecked"") <line5> Iterable<FlowObject> myObjs = <line6> stack == null <line7> ? Collections.EMPTY_LIST <line8> : stack.getFlowObjectsOwnedBy(nc.getID(), Scope.Local); <line9> int c = 0; <line10> for (FlowObject s : myObjs) { <line11> if (s instanceof FlowVariable) { <line12> FlowVariable v = (FlowVariable) s; <line13> NodeSettingsWO sub = stackSet.addNodeSettings(""Variable_"" + c); <line14> sub.addString(""type"", ""variable""); <line15> v.save(sub); <line16> } else if (s instanceof FlowLoopContext) { <line17> if (!((FlowLoopContext) s).isInactiveScope()) { <line18> NodeSettingsWO sub = stackSet.addNodeSettings(""Loop_"" + c); <line19> sub.addString(""type"", ""loopcontext""); <line20> } else { <line21> NodeSettingsWO sub = stackSet.addNodeSettings(""Inactive_Loop_"" + c); <line22> sub.addString(""type"", ""loopcontext_inactive""); <line23> } <line24> } else if (s instanceof InnerFlowLoopContext) { <line25> NodeSettingsWO sub = stackSet.addNodeSettings(""Loop_Execute_"" + c); <line26> sub.addString(""type"", ""loopcontext_execute""); <line27> } else if (s instanceof FlowCaptureContext) { <line28> if (!((FlowScopeContext) s).isInactiveScope()) { <line29> NodeSettingsWO sub = stackSet.addNodeSettings(""FlowCapture_"" + c); <line30> sub.addString(""type"", ""flowcapturecontext""); <line31> } else { <line32> NodeSettingsWO sub = stackSet.addNodeSettings(""Inactive_FlowCapture_"" + c); <line33> sub.addString(""type"", ""flowcapturecontext_inactive""); <line34> } <line35> } else if (s instanceof FlowScopeContext) { <line36> if (!((FlowScopeContext) s).isInactiveScope()) { <line37> NodeSettingsWO sub = stackSet.addNodeSettings(""Scope_"" + c); <line38> sub.addString(""type"", ""scopecontext""); <line39> } else { <line40> NodeSettingsWO sub = stackSet.addNodeSettings(""Inactive_Scope_"" + c); <line41> sub.addString(""type"", ""scopecontext_inactive""); <line42> } <line43> } else { <line44> } <line45> c += 1; <line46> } <line47> } <line48> } <line49> "	 <line44>	Yes
public class A { <line0> protected void closeRandomAccessFileIfNotNull(RandomAccessFile raf) { <line1> if (raf != null) { <line2> try { <line3> raf.close(); <line4> } catch (IOException e) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> public MutablePortletParameters set(PortletParameters inParams) { <line1> checkNull(""params"", inParams); <line2> MutablePortletParameters oldparms = this.clone(); <line3> int ctr = 0; <line4> HashSet<String> remNames = new HashSet<String>(params.keySet()); <line5> boolean removed = params.keySet().retainAll(inParams.getNames()); <line6> if (removed && urlProvider != null) { <line7> remNames.removeAll(inParams.getNames()); <line8> for (String name : remNames) { <line9> urlProvider.removeParameter(windowId, name, type); <line10> } <line11> } <line12> for (String name : inParams.getNames()) { <line13> String[] vals = inParams.getValues(name).clone(); <line14> ctr++; <line15> params.put(name, vals); <line16> if (urlProvider != null) { <line17> urlProvider.setParameter(windowId, name, type, vals); <line18> } <line19> } <line20> if (isTrace) { <line21> StringBuilder txt = new StringBuilder(); <line22> txt.append(""Window ID: "") <line23> .append(windowId) <line24> .append("", Removed values from old map:  "") <line25> .append(removed) <line26> .append("", set "") <line27> .append(ctr) <line28> .append("" values.""); <line29> } <line30> return oldparms; <line31> } <line32> } <line33> "	 <line29>	Yes
public class A { <line0> public boolean validateBatchGeocodeResult( <line1> Class<? extends GeocodeService> source, <line2> ArrayList<Address> addresses, <line3> ArrayList<GeocodeResult> geocodeResults, <line4> List<GeocodedAddress> geocodedAddresses, <line5> Boolean freeze) { <line6> boolean hasValidResult = false; <line7> geocodeResults.clear(); <line8> if (geocodedAddresses != null && geocodedAddresses.size() == addresses.size()) { <line9> for (GeocodedAddress geocodedAddress : geocodedAddresses) { <line10> GeocodeResult geocodeResult = new GeocodeResult(source); <line11> if (validateGeocodeResult(source, geocodedAddress, geocodeResult, false)) { <line12> hasValidResult = true; <line13> } <line14> geocodeResults.add(geocodeResult); <line15> } <line16> } else { <line17> for (Address a : addresses) { <line18> geocodeResults.add(new GeocodeResult(source, NO_GEOCODE_RESULT, new GeocodedAddress(a))); <line19> } <line20> } <line21> if (hasValidResult) { <line22> removeGeocoderBlock(source); <line23> } else if (freeze) { <line24> recordFailedResult(source); <line25> } <line26> return hasValidResult; <line27> } <line28> } <line29> 	 <line17>	Yes
"public class A { <line0> @Override <line1> public Answer execute(DestroyCommand cmd) { <line2> if (s_logger.isInfoEnabled()) { <line3> } <line4> try { <line5> VmwareContext context = getServiceContext(null); <line6> VmwareHypervisorHost hyperHost = getHyperHost(context, null); <line7> VolumeTO vol = cmd.getVolume(); <line8> VirtualMachineMO vmMo = findVmOnDatacenter(context, hyperHost, vol); <line9> if (vmMo != null) { <line10> if (s_logger.isInfoEnabled()) { <line11> } <line12> if (vmMo.isTemplate()) { <line13> vmMo.markAsVirtualMachine(hyperHost.getHyperHostOwnerResourcePool(), hyperHost.getMor()); <line14> } <line15> vmMo.destroy(); <line16> } else { <line17> if (s_logger.isInfoEnabled()) { <line18> } <line19> } <line20> return new Answer(cmd, true, ""Success""); <line21> } catch (Throwable e) { <line22> if (e instanceof RemoteException) { <line23> invalidateServiceContext(null); <line24> } <line25> String msg = ""DestroyCommand failed due to "" + VmwareHelper.getExceptionMessage(e); <line26> return new Answer(cmd, false, msg); <line27> } <line28> } <line29> } <line30> "	 <line11>	Yes
"public class A { <line0> private static String convertPKCS1ToPKCS8(String pkcs1) throws IOException { <line1> String uuid = UUID.randomUUID().toString(); <line2> File pkcs1File = new File(""keys/"" + uuid + ""/pkcs1.key""); <line3> File pkcs8File = new File(""keys/"" + uuid + ""/pkcs8.key""); <line4> String transformCmd = <line5> ""openssl rsa  -RSAPublicKey_in -in "" + pkcs1File.toPath() + "" -out "" + pkcs8File.toPath(); <line6> FileUtils.writeStringToFile(pkcs1File, pkcs1, ""UTF-8""); <line7> Process p = Runtime.getRuntime().exec(transformCmd); <line8> BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream())); <line9> String s; <line10> while ((s = stdError.readLine()) != null) { <line11> if (!s.contains(""writing RSA key"")) { <line12> throw new IOException(s); <line13> } <line14> } <line15> return FileUtils.readFileToString(pkcs8File, ""UTF-8""); <line16> } <line17> } <line18> "	 <line9>	No
public class A { <line0> public MongoCursor<Document> execute( <line1> MongoTableHandle tableHandle, List<MongoColumnHandle> columns) { <line2> Document output = new Document(); <line3> for (MongoColumnHandle column : columns) { <line4> output.append(column.getName(), 1); <line5> } <line6> MongoCollection<Document> collection = getCollection(tableHandle.getSchemaTableName()); <line7> Document query = buildQuery(tableHandle.getConstraint()); <line8> FindIterable<Document> iterable = collection.find(query).projection(output); <line9> tableHandle.getLimit().ifPresent(iterable::limit); <line10> if (cursorBatchSize != 0) { <line11> iterable.batchSize(cursorBatchSize); <line12> } <line13> return iterable.iterator(); <line14> } <line15> } <line16> 	 <line15>	No
"public class A { <line0> @Test <line1> public void test_01_dup() { <line2> String genome = ""testHg19Chr17""; <line3> String vcf = path(""hgvs_dup.vcf""); <line4> String args[] = {genome, vcf}; <line5> SnpEffCmdEff snpeff = new SnpEffCmdEff(); <line6> snpeff.parseArgs(args); <line7> snpeff.setDebug(debug); <line8> snpeff.setVerbose(verbose); <line9> snpeff.setSupressOutput(!verbose); <line10> snpeff.setFormatVersion(EffFormatVersion.FORMAT_EFF_4); <line11> snpeff.setUpDownStreamLength(0); <line12> List<VcfEntry> results = snpeff.run(true); <line13> for (VcfEntry ve : results) { <line14> String hgvsCexp = ve.getInfo(""HGVS_C"") != null ? ve.getInfo(""HGVS_C"") : """"; <line15> String trIdC = Hgvs.parseTranscript(hgvsCexp); <line16> hgvsCexp = Hgvs.removeTranscript(hgvsCexp); <line17> String hgvsPexp = ve.getInfo(""HGVS_P"") != null ? ve.getInfo(""HGVS_P"") : """"; <line18> String trIdP = Hgvs.parseTranscript(hgvsPexp); <line19> hgvsPexp = Hgvs.removeTranscript(hgvsPexp); <line20> if (verbose) { <line21> System.out.println(ve); <line22> if (trIdC != null) System.out.println(""\tExpected HGVS_C: "" + trIdC + "":"" + hgvsCexp); <line23> if (trIdP != null) <line24> System.out.println(""\tExpected HGVS_P: "" + trIdP + "":"" + hgvsPexp + ""\n""); <line25> } <line26> boolean okC = false, okP = false; <line27> for (VcfEffect veff : ve.getVcfEffects()) { <line28> String trId = veff.getTranscriptId(); <line29> String hgvsCactual = veff.getHgvsDna() != null ? veff.getHgvsDna() : """"; <line30> String hgvsPactual = veff.getHgvsProt() != null ? veff.getHgvsProt() : """"; <line31> if (verbose) <line32> if (trId != null && trId.equals(trIdC)) { <line33> Assert.assertEquals(hgvsCexp, hgvsCactual); <line34> okC = true; <line35> } <line36> if (trId != null && trId.equals(trIdP)) { <line37> Assert.assertEquals(hgvsPexp, hgvsPactual); <line38> okP = true; <line39> } <line40> } <line41> Assert.assertTrue(""HGVS (DNA) not found: '"" + hgvsCexp + ""'"", okC); <line42> if (!hgvsPexp.isEmpty()) <line43> Assert.assertTrue(""HGVS (Protein) not found: '"" + hgvsPexp + ""'"", okP); <line44> } <line45> } <line46> } <line47> "	 <line2>	Yes
"public class A { <line0> private ContentItem readContent(URI uri) throws StorageException { <line1> Path path = getContentFilePath(uri); <line2> if (path == null) { <line3> throw new StorageException( <line4> ""Unable to find file for content ID: "" + uri.getSchemeSpecificPart()); <line5> } <line6> String filename = path.getFileName().toString(); <line7> InputStream contentInputStream; <line8> String extension; <line9> try { <line10> if (REF_EXT.equals(FilenameUtils.getExtension(filename))) { <line11> extension = <line12> FilenameUtils.getExtension( <line13> FilenameUtils.removeExtension(path.getFileName().toString())); <line14> contentInputStream = getInputStreamFromReference(path); <line15> } else { <line16> extension = FilenameUtils.getExtension(path.getFileName().toString()); <line17> contentInputStream = getInputStreamFromResource(path); <line18> } <line19> } catch (IOException e) { <line20> throw new StorageException( <line21> String.format(""Unable to resolve InputStream given URI of %s"", uri), e); <line22> } <line23> ByteSource byteSource = decryptStream(contentInputStream); <line24> long size = 0; <line25> try { <line26> size = byteSource.size(); <line27> } catch (IOException e) { <line28> } <line29> String mimeType = determineMimeType(extension, path, byteSource); <line30> return new ContentItemImpl( <line31> uri.getSchemeSpecificPart(), uri.getFragment(), byteSource, mimeType, filename, size, null); <line32> } <line33> } <line34> "	 <line27>	No
public class A { <line0> @Override <line1> protected IXtextDocument run() throws Exception { <line2> IWorkbenchPage activePage = workbench.getActiveWorkbenchWindow().getActivePage(); <line3> if (activePage == null) return null; <line4> for (IEditorReference editorReference : activePage.getEditorReferences()) { <line5> try { <line6> IEditorInput editorInput = editorReference.getEditorInput(); <line7> if (editorInput instanceof IStorageEditorInput <line8> && contains(storages, ((IStorageEditorInput) editorInput).getStorage())) { <line9> IEditorPart editor = editorReference.getEditor(true); <line10> if (editor instanceof XtextEditor) { <line11> XtextEditor xtextEditor = (XtextEditor) editor; <line12> return xtextEditor.getDocument(); <line13> } <line14> } <line15> } catch (Exception e) { <line16> } <line17> } <line18> return null; <line19> } <line20> } <line21> 	 <line0>	No
public class A { <line0> public void deleteSegments(Predicate<LogSegment> predicate, DeleteHook afterDeleted) { <line1> int count = segments.size(); <line2> if (count <= 1) return; <line3> for (final Map.Entry<Long, LogSegment> entry : segments.entrySet()) { <line4> if (count <= 1) return; <line5> final LogSegment segment = entry.getValue(); <line6> if (predicate.test(segment)) { <line7> if (deleteSegment(entry.getKey(), segment)) { <line8> count = count - 1; <line9> executeHook(afterDeleted, segment); <line10> } else { <line11> return; <line12> } <line13> } <line14> } <line15> } <line16> } <line17> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void invoke(List<TwitterListener> listeners) throws TwitterException { <line2> ResponseList<Status> statuses = twitter.getFavorites(screenName); <line3> for (TwitterListener listener : listeners) { <line4> try { <line5> listener.gotFavorites(statuses); <line6> } catch (Exception e) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void close() { <line2> try { <line3> store.close(); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
public class A { <line0> @Override <line1> public boolean hasSoftwareVersion() { <line2> Avp terminalInfoAvp = super.message.getAvps().getAvp(Avp.TERMINAL_INFORMATION); <line3> if (terminalInfoAvp != null) { <line4> try { <line5> return terminalInfoAvp.getGrouped().getAvp(Avp.SOFTWARE_VERSION) != null; <line6> } catch (AvpDataException ex) { <line7> } <line8> } <line9> return false; <line10> } <line11> } <line12> 	 <line7>	Yes
public class A { <line0> public SortedSet<String> queryAsSet(String sparqlQueryString, String variable) { <line1> ResultSet rs = null; <line2> try { <line3> String jsonString = query(sparqlQueryString); <line4> rs = SparqlQuery.convertJSONtoResultSet(jsonString); <line5> } catch (Exception e) { <line6> } <line7> return getStringSetForVariableFromResultSet(ResultSetFactory.makeRewindable(rs), variable); <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> @Test <line1> public void testGetBridge() { <line2> SchemaPlatformBridge bridge = SchemaPlatformBridge.get(); <line3> assertNotNull(bridge); <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> public boolean collect(ExportableData collection, Line line, Date startDate, Date endDate) { <line1> boolean res = collect(collection, line, startDate, endDate, true, true); <line2> if (line.getNetwork() == null) { <line3> return false; <line4> } <line5> if (line.getCompany() == null) { <line6> return false; <line7> } <line8> return res; <line9> } <line10> } <line11> 	 <line6>	Yes
"public class A { <line0> private void buildNames(Set<Table> tables) { <line1> for (Table table : tables) { <line2> String graphqlName = NameConversions.toGraphql(table.name(), IdentifierType.TABLE); <line3> String clashingCqlName = entityNames.inverse().get(graphqlName); <line4> if (clashingCqlName != null) { <line5> String message = <line6> String.format( <line7> ""Couldn't convert table %s because its GraphQL name %s would collide with table %s"", <line8> table.name(), graphqlName, clashingCqlName); <line9> warnings.add(message); <line10> } else { <line11> if (!graphqlName.equals(table.name())) { <line12> warnings.add(String.format(""Table %s mapped as %s"", table.name(), graphqlName)); <line13> } <line14> entityNames.put(table.name(), graphqlName); <line15> columnNames.put(table.name(), buildColumnNames(table.columns())); <line16> } <line17> } <line18> } <line19> } <line20> "	 <line10>	Yes
public class A { <line0> protected ExecutorService createThreadExecutor(JRFillContext fillContext) { <line1> SubreportsThreadFactory threadFactory = new SubreportsThreadFactory(fillContext); <line2> ExecutorService threadExecutor = Executors.newCachedThreadPool(threadFactory); <line3> if (log.isDebugEnabled()) { <line4> } <line5> return threadExecutor; <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> public Set<State> processEvent(Event event, String stateMachineInstanceId) { <line1> StateMachine stateMachine = null; <line2> stateMachine = stateMachinesDAO.findById(stateMachineInstanceId); <line3> if (stateMachine == null) { <line4> throw new RuntimeException( <line5> ""StateMachine with id "" <line6> + stateMachineInstanceId <line7> + "" not found while processing event "" <line8> + event.getName()); <line9> } <line10> Context context = new RAMContext(System.currentTimeMillis(), null, stateMachine); <line11> final Set<State> dependantStates = context.getDependantStates(event.getName()); <line12> Set<State> executableStates = getExecutableStates(dependantStates, stateMachine.getId()); <line13> executeStates(stateMachine, executableStates, event, false); <line14> return executableStates; <line15> } <line16> } <line17> "	 <line16>	No
public class A { <line0> private void processEntry(FsDirectoryEntry entry, URI uri, String newPath) <line1> throws CommandExecutionException, IOException { <line2> String name = entry.getName(); <line3> if (!entry.isDirectory()) { <line4> final RequestMetaData metaData = new RequestMetaData(entry.getFile().getLength(), 2L, name); <line5> final RequestIdentifier identifier = new RequestIdentifier(uri); <line6> FatFileIdentificationRequest req = <line7> new FatFileIdentificationRequest(metaData, identifier, getTmpDir()); <line8> ByteBuffer buffer = ByteBuffer.allocate((int) entry.getFile().getLength()); <line9> entry.getFile().read(0, buffer); <line10> buffer.flip(); <line11> expandContainer( <line12> req, <line13> new ByteArrayInputStream(buffer.array(), buffer.position(), buffer.limit()), <line14> newPath); <line15> } else { <line16> } <line17> } <line18> } <line19> 	 <line16>	Yes
"public class A { <line0> private void verifyServiceInstances(final Service service) throws Exception { <line1> final Instances instances = <line2> graphql.instances( <line3> new InstancesQuery().serviceId(service.getKey()).start(startTime).end(now())); <line4> load(""expected/profile/instances.yml"").as(InstancesMatcher.class).verify(instances); <line5> } <line6> } <line7> "	 <line5>	No
public class A { <line0> @Override <line1> protected void flush() { <line2> if (!listOpeParms.isValid()) { <line3> return; <line4> } <line5> MarketoSyncResult mktoResult = new MarketoSyncResult(); <line6> for (int i = 0; i < getRetryAttemps(); i++) { <line7> result.apiCalls++; <line8> switch (operation) { <line9> case addTo: <line10> mktoResult = client.addToList(listOpeParms); <line11> break; <line12> case isMemberOf: <line13> mktoResult = client.isMemberOfList(listOpeParms); <line14> break; <line15> case removeFrom: <line16> mktoResult = client.removeFromList(listOpeParms); <line17> break; <line18> } <line19> if (!mktoResult.isSuccess()) { <line20> if (dieOnError) { <line21> throw new MarketoRuntimeException(mktoResult.getErrorsString()); <line22> } <line23> if (client.isErrorRecoverable(mktoResult.getErrors())) { <line24> waitForRetryAttempInterval(); <line25> continue; <line26> } else { <line27> break; <line28> } <line29> } else { <line30> break; <line31> } <line32> } <line33> processResult(mktoResult); <line34> listOpeParms.reset(); <line35> } <line36> } <line37> 	 <line13>	No
public class A { <line0> private SmbNegotiation negotiate2(Smb2NegotiateResponse first) <line1> throws IOException, SocketException { <line2> int size = 0; <line3> int securityMode = getRequestSecurityMode(first); <line4> Smb2NegotiateRequest smb2neg = new Smb2NegotiateRequest(getContext().getConfig(), securityMode); <line5> Smb2NegotiateResponse r = null; <line6> byte[] negoReqBuffer = null; <line7> byte[] negoRespBuffer = null; <line8> try { <line9> smb2neg.setRequestCredits(Math.max(1, this.desiredCredits - this.credits.availablePermits())); <line10> int reqLen = negotiateWrite(smb2neg, first != null); <line11> boolean doPreauth = <line12> getContext().getConfig().getMaximumVersion().atLeast(DialectVersion.SMB311); <line13> if (doPreauth) { <line14> negoReqBuffer = new byte[reqLen]; <line15> System.arraycopy(this.sbuf, 4, negoReqBuffer, 0, reqLen); <line16> } <line17> negotiatePeek(); <line18> r = smb2neg.initResponse(getContext()); <line19> int respLen = r.decode(this.sbuf, 4); <line20> r.received(); <line21> if (doPreauth) { <line22> negoRespBuffer = new byte[respLen]; <line23> System.arraycopy(this.sbuf, 4, negoRespBuffer, 0, respLen); <line24> } else { <line25> negoReqBuffer = null; <line26> } <line27> if (log.isTraceEnabled()) { <line28> } <line29> return new SmbNegotiation(smb2neg, r, negoReqBuffer, negoRespBuffer); <line30> } finally { <line31> int grantedCredits = r != null ? r.getGrantedCredits() : 0; <line32> if (grantedCredits == 0) { <line33> grantedCredits = 1; <line34> } <line35> this.credits.release(grantedCredits); <line36> Arrays.fill(this.sbuf, (byte) 0); <line37> } <line38> } <line39> } <line40> 	 <line38>	No
"public class A { <line0> @Override <line1> public void init() { <line2> pythonParameters = <line3> JSONUtils.parseObject(taskExecutionContext.getTaskParams(), PythonParameters.class); <line4> if (!pythonParameters.checkParameters()) { <line5> throw new RuntimeException(""python task params is not valid""); <line6> } <line7> } <line8> } <line9> "	 <line1>	No
"public class A { <line0> @Override <line1> public Path getPath(URI uri) { <line2> String str = uri.getSchemeSpecificPart(); <line3> int i = str.indexOf(""!/""); <line4> if (i == -1) { <line5> throw new IllegalArgumentException( <line6> ""URI: "" + uri + "" does not contain path info - e.g., root:file://foo/bar!/""); <line7> } <line8> FileSystem fs = getFileSystem(uri); <line9> String subPath = str.substring(i + 1); <line10> Path p = fs.getPath(subPath); <line11> if (log.isTraceEnabled()) { <line12> } <line13> return p; <line14> } <line15> } <line16> "	 <line12>	Yes
"public class A { <line0> @Override <line1> public void exportTo(Path targetPath) throws IOException { <line2> CsarExporter exporter = new CsarExporter(this.wineryRepo); <line3> Map<String, Object> exportConfiguration = new HashMap<>(); <line4> try (OutputStream out = <line5> Files.newOutputStream( <line6> targetPath, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)) { <line7> try { <line8> exporter.writeCsar(entryServiceTemplate.get(), out, exportConfiguration); <line9> } catch (RepositoryCorruptException <line10> | InterruptedException <line11> | AccountabilityException <line12> | ExecutionException e) { <line13> throw new IOException(""Failed to export CSAR"", e); <line14> } <line15> } <line16> } <line17> } <line18> "	 <line9>	No
public class A { <line0> @Override <line1> public void setup(ProfilerPluginSetupContext context) { <line2> final JspPluginConfig config = new JspPluginConfig(context.getConfig()); <line3> if (logger.isInfoEnabled()) { <line4> } <line5> if (!config.isEnable()) { <line6> if (logger.isInfoEnabled()) { <line7> } <line8> return; <line9> } <line10> if (logger.isInfoEnabled()) { <line11> } <line12> addJasper2JspEngine(); <line13> } <line14> } <line15> 	 <line14>	No
"public class A { <line0> @GET <line1> @Path(""/history"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Operation( <line4> tags = {""dex""}, <line5> summary = ""Get history"", <line6> description = ""getting history"") <line7> @ApiResponses( <line8> value = { <line9> @ApiResponse(responseCode = ""200"", description = ""Exchange offers""), <line10> @ApiResponse(responseCode = ""200"", description = ""Unexpected error"") <line11> }) <line12> public Response getHistoday2( <line13> @Parameter(description = ""Cryptocurrency identifier"") @QueryParam(""symbol"") String symbol, <line14> @Parameter(description = ""resolution"") @QueryParam(""resolution"") String resolution, <line15> @Parameter(description = FROM_PARAM) @QueryParam(FROM_PARAM) Integer from, <line16> @Parameter(description = TO_PARAM) @QueryParam(TO_PARAM) Integer to, <line17> @Context HttpServletRequest req) <line18> throws NotFoundException { <line19> if (to <= 1569369600) { <line20> TradingDataOutput tdo = new TradingDataOutput(); <line21> tdo.setC(null); <line22> tdo.setH(null); <line23> tdo.setL(null); <line24> tdo.setO(null); <line25> tdo.setT(null); <line26> tdo.setV(null); <line27> tdo.setNextTime(null); <line28> tdo.setS(""no_data""); <line29> return Response.ok(converter.apply(tdo)).build(); <line30> } <line31> TradingDataOutput tradingDataOutput = <line32> tradingViewService.getUpdatedDataForIntervalFromOffers(symbol, resolution, to, from); <line33> return Response.ok(new TradingDataOutputToDtoConverter().apply(tradingDataOutput)).build(); <line34> } <line35> } <line36> "	 <line9>	No
"public class A { <line0> @Override <line1> public BroadcastSmResult processBroadcastSm(final BroadcastSm broadcastSm) <line2> throws ProcessRequestException { <line3> try { <line4> BroadcastSmResult broadcastSmResult = fireAcceptBroadcastSm(broadcastSm); <line5> if (broadcastSmResult == null) { <line6> String msg = <line7> ""Invalid broadcastSmResult, shouldn't null value. "" <line8> + ServerMessageReceiverListener.class <line9> + ""#onAcceptBroadcastSm(broadcastSm) return null value""; <line10> throw new ProcessRequestException(msg, SMPPConstant.STAT_ESME_RX_R_APPN); <line11> } <line12> return broadcastSmResult; <line13> } catch (ProcessRequestException e) { <line14> throw e; <line15> } catch (Exception e) { <line16> String msg = ""Invalid runtime exception thrown when processing broadcast_sm""; <line17> throw new ProcessRequestException(msg, SMPPConstant.STAT_ESME_RSYSERR); <line18> } <line19> } <line20> } <line21> "	 <line15>	No
"public class A { <line0> @Override <line1> protected void handleMessage(JsonNode message) { <line2> if (message.isArray()) { <line3> String type = message.get(1).asText(); <line4> if (type.equals(""hb"")) { <line5> return; <line6> } <line7> } <line8> JsonNode event = message.get(EVENT); <line9> if (event != null) { <line10> switch (event.textValue()) { <line11> case INFO: <line12> JsonNode version = message.get(VERSION); <line13> if (version != null) { <line14> } <line15> if (isAuthenticated()) auth(); <line16> break; <line17> case AUTH: <line18> if (message.get(STATUS).textValue().equals(BitfinexAuthRequestStatus.FAILED.name())) { <line19> } <line20> if (message.get(STATUS).textValue().equals(BitfinexAuthRequestStatus.OK.name())) { <line21> } <line22> break; <line23> case SUBSCRIBED: <line24> { <line25> String channel = message.get(""channel"").asText(); <line26> String pair = message.get(""pair"").asText(); <line27> String channelId = message.get(CHANNEL_ID).asText(); <line28> try { <line29> String subscriptionUniqueId = getSubscriptionUniqueId(channel, pair); <line30> subscribedChannels.put(channelId, subscriptionUniqueId); <line31> } catch (Exception e) { <line32> } <line33> break; <line34> } <line35> case UNSUBSCRIBED: <line36> { <line37> String channelId = message.get(CHANNEL_ID).asText(); <line38> subscribedChannels.remove(channelId); <line39> break; <line40> } <line41> case ERROR: <line42> if (message.get(""code"").asInt() == SUBSCRIPTION_FAILED) { <line43> return; <line44> } <line45> if (message.get(""code"").asInt() == SUBSCRIPTION_DUP) { <line46> return; <line47> } <line48> super.handleError( <line49> message, new ExchangeException(""Error code: "" + message.get(ERROR_CODE).asText())); <line50> break; <line51> } <line52> } else { <line53> try { <line54> if (""0"".equals(getChannelNameFromMessage(message)) <line55> && message.isArray() <line56> && message.size() == 3) { <line57> processAuthenticatedMessage(message); <line58> return; <line59> } <line60> } catch (IOException e) { <line61> throw new RuntimeException(""Failed to get channel name from message"", e); <line62> } <line63> super.handleMessage(message); <line64> } <line65> } <line66> } <line67> "	 <line19>	Yes
"public class A { <line0> @Test(expected = InvalidQueryException.class) <line1> public void updateInvalidScript() { <line2> Version fromVersion = Version.of(1); <line3> Version toVersion = Version.of(2); <line4> String schema = ""schema""; <line5> expect(schemaProducer.schema(fromVersion, toVersion)).andReturn(schema); <line6> expect(session.execute(schema)).andThrow(new InvalidQueryException(""expected message"")); <line7> expectLastCall(); <line8> expectLastCall(); <line9> mocks.replay(); <line10> try { <line11> testee.migrate(fromVersion, toVersion); <line12> } catch (Exception e) { <line13> mocks.verify(); <line14> throw e; <line15> } <line16> } <line17> } <line18> "	 <line6>	No
"public class A { <line0> private void handleCreateConnector(Context context) { <line1> String connectorName = context.param(""connectorName""); <line2> String arg = context.queryParam(""config""); <line3> if (arg == null) { <line4> context.result(""failed! query param 'config' is required ""); <line5> return; <line6> } <line7> Map keyValue = JSON.parseObject(arg, Map.class); <line8> ConnectKeyValue configs = new ConnectKeyValue(); <line9> for (Object key : keyValue.keySet()) { <line10> configs.put((String) key, keyValue.get(key).toString()); <line11> } <line12> try { <line13> String result = <line14> connectController.getConfigManagementService().putConnectorConfig(connectorName, configs); <line15> if (result != null && result.length() > 0) { <line16> context.result(result); <line17> } else { <line18> context.result(""success""); <line19> } <line20> } catch (Exception e) { <line21> context.result(""failed""); <line22> } <line23> } <line24> } <line25> "	 <line14>	No
public class A { <line0> @VisibleForTesting <line1> protected void deleteDirectoryContainingSingleFile(File file) { <line2> File parent = file.getParentFile(); <line3> File[] files = parent.listFiles(); <line4> if (files != null && files.length == 1 && files[0].equals(file)) { <line5> try { <line6> FileUtils.deleteDirectory(parent); <line7> } catch (IOException e) { <line8> } <line9> } <line10> } <line11> } <line12> 	 <line7>	Yes
public class A { <line0> private void discoverDevices() { <line1> if (bridge.getThing().getStatus() != ThingStatus.ONLINE) { <line2> return; <line3> } <line4> for (Location location : bridge.getEvohomeConfig()) { <line5> for (Gateway gateway : location.getGateways()) { <line6> for (TemperatureControlSystem tcs : gateway.getTemperatureControlSystems()) { <line7> addDisplayDiscoveryResult(location, tcs); <line8> for (Zone zone : tcs.getZones()) { <line9> addZoneDiscoveryResult(location, zone); <line10> } <line11> } <line12> } <line13> } <line14> stopScan(); <line15> } <line16> } <line17> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void init(FilterConfig filterConfig) throws ServletException { <line2> super.init(filterConfig); <line3> forwardPath = filterConfig.getInitParameter(""forwardPath""); <line4> displayPath = filterConfig.getInitParameter(""displayPath""); <line5> } <line6> } <line7> "	 <line3>	No
public class A { <line0> public void resume() { <line1> if (currentAction != null) { <line2> currentAction.resume(); <line3> } <line4> pauseHandler.resume(); <line5> setStatus(EventConsumerStatus.EXECUTING); <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> protected void createOut() { <line1> try { <line2> out = new PrintWriter(new FileWriter(file, true)); <line3> } catch (IOException e) { <line4> out = new PrintWriter(new NullWriter()); <line5> } <line6> } <line7> } <line8> 	 <line3>	No
public class A { <line0> private ByteBuffer recommendProtocolVersion() { <line1> final ByteBuffer buffer = ByteBuffer.allocate(1); <line2> buffer.put((byte) protocolVersion); <line3> buffer.rewind(); <line4> readTimeout = System.currentTimeMillis() + timeoutMillis; <line5> phase = TransactionPhase.RECEIVE_PROTOCOL_VERSION_ACKNOWLEDGMENT; <line6> return buffer; <line7> } <line8> } <line9> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public void validate(Action action, ServiceContext ctx) throws InvalidDocumentException { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> if (action.equals(Action.DELETE)) { <line5> return; <line6> } <line7> try { <line8> MultipartServiceContext mctx = (MultipartServiceContext) ctx; <line9> VocabulariesCommon vocab = <line10> (VocabulariesCommon) <line11> mctx.getInputPart(mctx.getCommonPartLabel(), VocabulariesCommon.class); <line12> String msg = """"; <line13> boolean invalid = false; <line14> String displayName = vocab.getDisplayName(); <line15> if ((displayName == null) || (displayName.trim().length() < 2)) { <line16> invalid = true; <line17> msg += ""displayName must be non-null and contain at least 2 non-whitespace characters""; <line18> } <line19> if (action.equals(Action.CREATE)) { <line20> String shortId = vocab.getShortIdentifier(); <line21> if ((shortId != null) && (shortIdBadPattern.matcher(shortId).find())) { <line22> invalid = true; <line23> msg += ""shortIdentifier must only contain standard word characters""; <line24> } <line25> } else if (action.equals(Action.UPDATE)) { <line26> } <line27> if (invalid) { <line28> throw new InvalidDocumentException(msg); <line29> } <line30> } catch (InvalidDocumentException ide) { <line31> throw ide; <line32> } catch (Exception e) { <line33> throw new InvalidDocumentException(e); <line34> } <line35> } <line36> } <line37> "	 <line3>	Yes
public class A { <line0> private void notifyChange() { <line1> try { <line2> AuthSvcInternalApiClientIterator authSvcItr = <line3> new AuthSvcInternalApiClientIterator(_authSvcEndPointLocator, _coordinator); <line4> while (authSvcItr.hasNext()) { <line5> String endpoint = authSvcItr.peek().toString(); <line6> try { <line7> ClientResponse response = authSvcItr.post(_URI_RELOAD, null); <line8> if (response.getStatus() != ClientResponse.Status.OK.getStatusCode()) { <line9> } <line10> } catch (Exception e) { <line11> } <line12> } <line13> } catch (CoordinatorException e) { <line14> } <line15> } <line16> } <line17> 	 <line13>	No
public class A { <line0> private void buildSuggesterIndex(SolrSuggester suggester, SolrIndexSearcher newSearcher) { <line1> try { <line2> final long startMillis = System.currentTimeMillis(); <line3> suggester.build(core, newSearcher); <line4> final long timeTakenMillis = System.currentTimeMillis() - startMillis; <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
public class A { <line0> private List<List<String>> getAllAvailablePipelines() { <line1> List<List<String>> configurations = new ArrayList<>(); <line2> CSVReader reader = null; <line3> try { <line4> reader = new CSVReader(new FileReader(csvFilePipelines)); <line5> String[] line; <line6> while ((line = reader.readNext()) != null) { <line7> List<String> configuration = new LinkedList<String>(); <line8> configuration.add(line[0]); <line9> configuration.add(line[1]); <line10> configurations.add(configuration); <line11> } <line12> } catch (IOException e) { <line13> e.printStackTrace(); <line14> } <line15> return configurations; <line16> } <line17> } <line18> 	 <line7>	Yes
"public class A { <line0> @SuppressFBWarnings({""SERVLET_HEADER"", ""SERVLET_QUERY_STRING""}) <line1> private ContainerRequest servletRequestToContainerRequest(ServletRequest request) { <line2> Timer.start(""JERSEY_SERVLET_REQUEST_TO_CONTAINER""); <line3> HttpServletRequest servletRequest = (HttpServletRequest) request; <line4> if (baseUri == null) { <line5> baseUri = getBaseUri(request, ""/""); <line6> } <line7> String requestFullPath = servletRequest.getRequestURI(); <line8> if (LambdaContainerHandler.getContainerConfig().getServiceBasePath() != null <line9> && LambdaContainerHandler.getContainerConfig().isStripBasePath()) { <line10> if (requestFullPath.startsWith( <line11> LambdaContainerHandler.getContainerConfig().getServiceBasePath())) { <line12> requestFullPath = <line13> requestFullPath.replaceFirst( <line14> LambdaContainerHandler.getContainerConfig().getServiceBasePath(), """"); <line15> if (!requestFullPath.startsWith(""/"")) { <line16> requestFullPath = ""/"" + requestFullPath; <line17> } <line18> } <line19> } <line20> UriBuilder uriBuilder = UriBuilder.fromUri(baseUri).path(requestFullPath); <line21> uriBuilder.replaceQuery(servletRequest.getQueryString()); <line22> PropertiesDelegate apiGatewayProperties = new MapPropertiesDelegate(); <line23> apiGatewayProperties.setProperty( <line24> API_GATEWAY_CONTEXT_PROPERTY, servletRequest.getAttribute(API_GATEWAY_CONTEXT_PROPERTY)); <line25> apiGatewayProperties.setProperty( <line26> API_GATEWAY_STAGE_VARS_PROPERTY, <line27> servletRequest.getAttribute(API_GATEWAY_STAGE_VARS_PROPERTY)); <line28> apiGatewayProperties.setProperty( <line29> LAMBDA_CONTEXT_PROPERTY, servletRequest.getAttribute(LAMBDA_CONTEXT_PROPERTY)); <line30> apiGatewayProperties.setProperty(JERSEY_SERVLET_REQUEST_PROPERTY, servletRequest); <line31> ContainerRequest requestContext = <line32> new ContainerRequest( <line33> null, <line34> uriBuilder.build(), <line35> servletRequest.getMethod().toUpperCase(Locale.ENGLISH), <line36> (SecurityContext) servletRequest.getAttribute(JAX_SECURITY_CONTEXT_PROPERTY), <line37> apiGatewayProperties); <line38> InputStream requestInputStream; <line39> try { <line40> requestInputStream = servletRequest.getInputStream(); <line41> if (requestInputStream != null) { <line42> requestContext.setEntityStream(requestInputStream); <line43> } <line44> } catch (IOException e) { <line45> throw new RuntimeException(""Could not read request input stream"", e); <line46> } <line47> Enumeration<String> headerNames = servletRequest.getHeaderNames(); <line48> while (headerNames.hasMoreElements()) { <line49> String headerKey = headerNames.nextElement(); <line50> requestContext <line51> .getHeaders() <line52> .addAll(headerKey, Collections.list(servletRequest.getHeaders(headerKey))); <line53> } <line54> Timer.stop(""JERSEY_SERVLET_REQUEST_TO_CONTAINER""); <line55> return requestContext; <line56> } <line57> } <line58> "	 <line3>	No
public class A { <line0> @PreDestroy <line1> public synchronized void destroy() { <line2> if (!running) { <line3> return; <line4> } <line5> try { <line6> running = false; <line7> if (adapterLoader != null) { <line8> adapterLoader.destroy(); <line9> adapterLoader = null; <line10> } <line11> for (DruidDataSource druidDataSource : DatasourceConfig.DATA_SOURCES.values()) { <line12> try { <line13> druidDataSource.close(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> DatasourceConfig.DATA_SOURCES.clear(); <line18> } catch (Throwable e) { <line19> } finally { <line20> } <line21> } <line22> } <line23> 	 <line16>	No
public class A { <line0> protected void ignoreRecord( <line1> List<CassandraToSqlColumnData[]> batchData, CassandraToSqlColumnData[] data) { <line2> int index = batchData.indexOf(data); <line3> if (index > 0) { <line4> batchData.remove(index); <line5> } <line6> } <line7> } <line8> 	 <line1>	No
"public class A { <line0> private void updateDiskConfiguration( <line1> VirtualMachineConfigSpec vmConfigSpec, <line2> List<VirtualDevice> devices, <line3> int vdKey, <line4> long newDiskSpace) <line5> throws Exception { <line6> VirtualDisk vdDataDisk = findDataDisk(devices, vdKey); <line7> if (vdDataDisk != null && newDiskSpace > vdDataDisk.getCapacityInKB()) { <line8> if (newDiskSpace < vdDataDisk.getCapacityInKB()) { <line9> throw new Exception(Messages.getAll(""error_invalid_diskspacereduction"").get(0).getText()); <line10> } else if (newDiskSpace > vdDataDisk.getCapacityInKB()) { <line11> vdDataDisk.setCapacityInKB(newDiskSpace); <line12> VirtualDeviceConfigSpec vmDeviceSpec = new VirtualDeviceConfigSpec(); <line13> vmDeviceSpec.setOperation(VirtualDeviceConfigSpecOperation.EDIT); <line14> vmDeviceSpec.setDevice(vdDataDisk); <line15> vmConfigSpec.getDeviceChange().add(vmDeviceSpec); <line16> } else { <line17> } <line18> } <line19> } <line20> } <line21> "	 <line17>	Yes
public class A { <line0> protected void setDefaultUncaughtExceptionHandler() { <line1> Thread.setDefaultUncaughtExceptionHandler( <line2> new UncaughtExceptionHandler() { <line3> @Override <line4> public void uncaughtException(final Thread t, final Throwable e) { <line5> } <line6> }); <line7> } <line8> } <line9> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public void start() { <line2> excludeSelfRequests = selfRequests == SelfRequests.exclude; <line3> noopSelfRequests = selfRequests == SelfRequests.noop; <line4> if (!started) { <line5> try { <line6> ch = new JChannel(configFile); <line7> disp = new RpcDispatcher(ch, null, this, this); <line8> disp.setMethodLookup( <line9> new MethodLookup() { <line10> public Method findMethod(short id) { <line11> return METHODS[id]; <line12> } <line13> }); <line14> ch.connect(""x""); <line15> } catch (Exception e) { <line16> throw new RuntimeException(e); <line17> } <line18> localAddr = ch.getAddress(); <line19> started = true; <line20> } <line21> } <line22> } <line23> "	 <line5>	Yes
public class A { <line0> public void logHadoopEvent(String path, FsAction action, boolean accessGranted) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> if (auditEvent != null) { <line4> auditEvent.setResultReason(path); <line5> auditEvent.setAccessResult((short) (accessGranted ? 1 : 0)); <line6> auditEvent.setAclEnforcer(hadoopModuleName); <line7> auditEvent.setPolicyId(-1); <line8> String accessType = (action == null) ? null : action.toString(); <line9> if (StringUtils.isBlank(auditEvent.getAccessType())) { <line10> auditEvent.setAccessType(accessType); <line11> } <line12> if (accessType != null) { <line13> auditEvent.setAction(getAccessType(accessType)); <line14> } <line15> setRequestData(); <line16> } <line17> if (LOG.isDebugEnabled()) { <line18> } <line19> } <line20> } <line21> 	 <line13>	No
public class A { <line0> private String getDataTagsConfigXML(final EquipmentCacheObject pEquipment) { <line1> StringBuilder str = new StringBuilder(); <line2> ThreadPoolExecutor tagXmlExecutor = <line3> new ThreadPoolExecutor( <line4> 8, <line5> 10, <line6> 5, <line7> TimeUnit.SECONDS, <line8> new LinkedBlockingQueue<>(10000), <line9> new ThreadPoolExecutor.CallerRunsPolicy()); <line10> Collection<Long> dataTags = equipmentFacade.getDataTagIds(pEquipment.getId()); <line11> for (Long subEquipmentId : pEquipment.getSubEquipmentIds()) { <line12> dataTags.addAll(subEquipmentFacade.getDataTagIds(subEquipmentId)); <line13> } <line14> if (dataTags != null) { <line15> LinkedList<Future<String>> futureXmlStrings = new LinkedList<>(); <line16> LinkedList<Long> partialList = new LinkedList<>(); <line17> Iterator<Long> it = dataTags.iterator(); <line18> while (it.hasNext()) { <line19> while (partialList.size() < 100 && it.hasNext()) { <line20> partialList.addLast(it.next()); <line21> } <line22> Callable<String> tagTask = new GetTagXmlTask((LinkedList<Long>) partialList.clone()); <line23> partialList.clear(); <line24> futureXmlStrings.addFirst(tagXmlExecutor.submit(tagTask)); <line25> } <line26> tagXmlExecutor.shutdown(); <line27> try { <line28> tagXmlExecutor.awaitTermination(120, TimeUnit.SECONDS); <line29> while (!futureXmlStrings.isEmpty()) { <line30> str.append(futureXmlStrings.pollFirst().get()); <line31> } <line32> } catch (InterruptedException | ExecutionException e) { <line33> } <line34> } <line35> str.append(appendAliveTagDaqXmlConfiguration(pEquipment.getAliveTagId())); <line36> for (Long subEquipmentId : pEquipment.getSubEquipmentIds()) { <line37> str.append( <line38> appendAliveTagDaqXmlConfiguration(subEquipmentCache.get(subEquipmentId).getAliveTagId())); <line39> } <line40> return str.toString(); <line41> } <line42> } <line43> 	 <line33>	Yes
"public class A { <line0> public List<IPage> searchPages() { <line1> List<IPage> result = null; <line2> try { <line3> List<String> allowedGroupCodes = this.getAllowedGroupCodes(); <line4> result = this.getPageManager().searchPages(this.getPageCodeToken(), allowedGroupCodes); <line5> } catch (Throwable t) { <line6> throw new RuntimeException(""Error on searching pages"", t); <line7> } <line8> return result; <line9> } <line10> } <line11> "	 <line1>	No
"public class A { <line0> public FilterSuchenFelderTxt findById(sernet.gs.reveng.FilterSuchenFelderTxtId id) { <line1> try { <line2> FilterSuchenFelderTxt instance = <line3> (FilterSuchenFelderTxt) <line4> sessionFactory.getCurrentSession().get(""sernet.gs.reveng.FilterSuchenFelderTxt"", id); <line5> if (instance == null) { <line6> } else { <line7> } <line8> return instance; <line9> } catch (RuntimeException re) { <line10> throw re; <line11> } <line12> } <line13> } <line14> "	 <line12>	No
public class A { <line0> @Override <line1> public List<String> getAll(BatchRunContext batchRunContext) { <line2> SystemAccount actor = getSystemAccount(); <line3> List<String> allShares = service.findAllExpiredEntries(actor, actor); <line4> return allShares; <line5> } <line6> } <line7> 	 <line1>	No
public class A { <line0> @Test <line1> public void simplestUsage() { <line2> Log log = LogFactory.getLog(CommonsLoggingApiTest.class); <line3> } <line4> } <line5> 	 <line4>	No
"public class A { <line0> @Override <line1> @Deprecated <line2> public AbstractEntity configure(Map flags) { <line3> if (!inConstruction && getManagementSupport().isDeployed()) { <line4> } <line5> Entity suppliedParent = (Entity) flags.remove(""parent""); <line6> if (suppliedParent != null) { <line7> suppliedParent.addChild(getProxyIfAvailable()); <line8> } <line9> Map<ConfigKey, ?> suppliedOwnConfig = (Map<ConfigKey, ?>) flags.remove(""config""); <line10> if (suppliedOwnConfig != null) { <line11> for (Map.Entry<ConfigKey, ?> entry : suppliedOwnConfig.entrySet()) { <line12> setConfigEvenIfOwned(entry.getKey(), entry.getValue()); <line13> } <line14> } <line15> if (flags.get(""displayName"") != null) { <line16> displayName.set((String) flags.remove(""displayName"")); <line17> displayNameAutoGenerated = false; <line18> } else if (flags.get(""name"") != null) { <line19> displayName.set((String) flags.remove(""name"")); <line20> displayNameAutoGenerated = false; <line21> } else if (isLegacyConstruction()) { <line22> displayName.set(getAutogeneratedDefaultDisplayName()); <line23> displayNameAutoGenerated = true; <line24> } <line25> if (flags.get(BrooklynConfigKeys.ICON_URL.getName()) != null) { <line26> tags() <line27> .addTag( <line28> BrooklynTags.newIconUrlTag( <line29> (String) flags.remove(BrooklynConfigKeys.ICON_URL.getName()))); <line30> } <line31> flags = ConfigUtilsInternal.setAllConfigKeys(flags, getEntityType().getConfigKeys(), this); <line32> if (flags.size() > 0) { <line33> FlagUtils.setFieldsFromFlags(flags, this); <line34> flags = FlagUtils.setAllConfigKeys(flags, this, false); <line35> } <line36> for (Iterator<Map.Entry> fi = flags.entrySet().iterator(); fi.hasNext(); ) { <line37> Map.Entry entry = fi.next(); <line38> Object k = entry.getKey(); <line39> if (k instanceof HasConfigKey) k = ((HasConfigKey) k).getConfigKey(); <line40> if (k instanceof ConfigKey) { <line41> setConfigEvenIfOwned((ConfigKey) k, entry.getValue()); <line42> fi.remove(); <line43> } <line44> } <line45> if (!flags.isEmpty()) { <line46> configsInternal.putAll(flags); <line47> } <line48> return this; <line49> } <line50> } <line51> "	 <line4>	Yes
public class A { <line0> public static void dropHTables(final HBaseAdmin hbaseAdmin, List<String> hTables) { <line1> runSingleThreadTaskQuietly( <line2> () -> { <line3> try { <line4> for (String htable : hTables) { <line5> if (hbaseAdmin.tableExists(htable)) { <line6> if (hbaseAdmin.isTableEnabled(htable)) { <line7> hbaseAdmin.disableTable(htable); <line8> } <line9> hbaseAdmin.deleteTable(htable); <line10> } else { <line11> } <line12> } <line13> } catch (Exception e) { <line14> } finally { <line15> IOUtils.closeQuietly(hbaseAdmin); <line16> } <line17> }); <line18> } <line19> } <line20> 	 <line11>	Yes
public class A { <line0> @Override <line1> public void open() throws NuvoException { <line2> setConnected(false); <line3> } <line4> } <line5> 	 <line3>	No
public class A { <line0> @POST <line1> @Schema(request = Schemas.PASSWORD_RESET_REQUEST) <line2> @Consumes({MediaTypes.JSON}) <line3> public Response get(ResetPasswordRequest resetPassword) throws BadRequestException { <line4> checkRights(getRights().canAccessPasswordReset()); <line5> getUserService().requestPasswordReset(resetPassword.getUser()); <line6> return Response.noContent().build(); <line7> } <line8> } <line9> 	 <line4>	No
public class A { <line0> private void appendAttrToBeIndexedLater(AttrImpl attr, NodePath path, LuceneIndexConfig conf) { <line1> if (currentElement == null) { <line2> } else { <line3> pendingAttrs.add(new PendingAttr(attr, path, conf)); <line4> } <line5> } <line6> } <line7> 	 <line0>	No
"public class A { <line0> void commit( <line1> final OfHeader messageToCommit, <line2> final FutureCallback<OfHeader> commitCallback, <line3> final Function<OfHeader, Boolean> isCommitCompletedFunction) { <line4> if (this.completed) { <line5> if (commitCallback != null) { <line6> commitCallback.onFailure(new OutboundQueueException(""Can't commit a completed message."")); <line7> } <line8> } else { <line9> this.message = messageToCommit; <line10> this.callback = commitCallback; <line11> this.barrier = messageToCommit instanceof BarrierInput; <line12> this.isCompletedFunction = isCommitCompletedFunction; <line13> this.committed = true; <line14> } <line15> } <line16> } <line17> "	 <line9>	No
public class A { <line0> @Override <line1> public void collisionResolve(SpaceStationMir mir) { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void setWorkingDir(URL url) throws IOException { <line2> String path = Utils.getWorkingDirectory().getCanonicalPath(); <line3> if (!path.endsWith(File.separator)) { <line4> path += File.separator; <line5> } <line6> String title; <line7> if (Utils.getConfigBoolean(""album_titles.save"", true)) { <line8> title = getAlbumTitle(this.url); <line9> } else { <line10> title = super.getAlbumTitle(this.url); <line11> } <line12> title = Utils.filesystemSafe(title); <line13> path += title; <line14> path = Utils.getOriginalDirectory(path) + File.separator; <line15> this.workingDir = new File(path); <line16> if (!this.workingDir.exists()) { <line17> this.workingDir.mkdirs(); <line18> } <line19> } <line20> } <line21> "	 <line17>	Yes
"public class A { <line0> @GET <line1> @Path(""{seriesId}/hasEvents.json"") <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @RestQuery( <line4> name = ""hasEvents"", <line5> description = ""Check if given series has events"", <line6> returnDescription = ""true if series has events, otherwise false"", <line7> pathParameters = { <line8> @RestParameter( <line9> name = ""seriesId"", <line10> isRequired = true, <line11> description = ""The series identifier"", <line12> type = Type.STRING) <line13> }, <line14> responses = { <line15> @RestResponse( <line16> responseCode = SC_BAD_REQUEST, <line17> description = ""The required form params were missing in the request.""), <line18> @RestResponse( <line19> responseCode = SC_NOT_FOUND, <line20> description = ""If the series has not been found.""), <line21> @RestResponse(responseCode = SC_OK, description = ""The access information "") <line22> }) <line23> public Response getSeriesEvents(@PathParam(""seriesId"") String seriesId) throws Exception { <line24> if (StringUtils.isBlank(seriesId)) <line25> return RestUtil.R.badRequest(""Path parameter series ID is missing""); <line26> long elementsCount = 0; <line27> try { <line28> EventSearchQuery query = <line29> new EventSearchQuery( <line30> securityService.getOrganization().getId(), securityService.getUser()); <line31> query.withSeriesId(seriesId); <line32> SearchResult<Event> result = searchIndex.getByQuery(query); <line33> elementsCount = result.getHitCount(); <line34> } catch (SearchIndexException e) { <line35> throw new WebApplicationException(Status.INTERNAL_SERVER_ERROR); <line36> } <line37> JSONObject jsonReturnObj = new JSONObject(); <line38> jsonReturnObj.put(""hasEvents"", elementsCount > 0); <line39> return Response.ok(jsonReturnObj.toString()).build(); <line40> } <line41> } <line42> "	 <line35>	Yes
public class A { <line0> public void setTo(List<MailAddress> mailAddresses) throws MessagingException { <line1> if (!mailAddresses.isEmpty()) { <line2> InternetAddress[] internetAddresses = MailAddressUtils.toInternetAddressArray(mailAddresses); <line3> mail.getMessage().setRecipients(Message.RecipientType.TO, internetAddresses); <line4> if (mailet.getInitParameters().isDebug()) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> private void registerConfigurationChangeListeners() { <line1> childAdded(null, _broker); <line2> if (_log.isDebugEnabled()) { <line3> } <line4> for (VirtualHostNode<?> vhostNode : _broker.getVirtualHostNodes()) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> VirtualHost<?, ?, ?> vhost = vhostNode.getVirtualHost(); <line8> if (vhost != null) { <line9> vhost.addChangeListener(this); <line10> addListenersForConnectionsAndChildren(vhost); <line11> addListenersForExchangesAndChildren(vhost); <line12> addListenersForQueuesAndChildren(vhost); <line13> } <line14> } <line15> if (_log.isDebugEnabled()) { <line16> } <line17> } <line18> } <line19> 	 <line3>	Yes
"public class A { <line0> public String data() throws Exception { <line1> Date startTime = new Date(); <line2> if (this.page != null) { <line3> this.page = this.findPage(); <line4> this.es = this.page.getData(); <line5> this.html = getGridData(this.getGridColumns()); <line6> } else { <line7> this.es = this.findList(); <line8> this.html = getGridData(this.getGridColumns()); <line9> } <line10> return ""page""; <line11> } <line12> } <line13> "	 <line3>	No
public class A { <line0> @Override <line1> public int getSeriesCount() throws SeriesException { <line2> try { <line3> return (int) index.count(); <line4> } catch (SeriesServiceDatabaseException e) { <line5> throw new SeriesException(e); <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> @Override <line1> public double getDouble(Object bean, String param, double defaultValue) { <line2> double beanValue = defaultValue; <line3> if (bean != null) { <line4> try { <line5> Object value = BeanUtil.pojo.getProperty(bean, param); <line6> beanValue = _converter.toDoubleValue(value, defaultValue); <line7> } catch (Exception exception) { <line8> } <line9> } <line10> return beanValue; <line11> } <line12> } <line13> 	 <line8>	Yes
public class A { <line0> public static String runAndWaitArray(final String[] command) { <line1> String result = runAndWaitNoLog(command); <line2> return result; <line3> } <line4> } <line5> 	 <line1>	Yes
public class A { <line0> public void run() { <line1> try { <line2> run0(); <line3> } catch (Exception e) { <line4> } <line5> } <line6> } <line7> 	 <line5>	No
public class A { <line0> private void sendResponse(ServiceResponse<?> serviceResponse, HttpServletResponse httpResponse) { <line1> httpResponse.setStatus(serviceResponse.getCode()); <line2> serviceResponse <line3> .getHeaders() <line4> .entrySet() <line5> .forEach(x -> httpResponse.setHeader(x.getKey(), x.getValue())); <line6> try { <line7> if (serviceResponse.getCode() >= 200 <line8> && serviceResponse.getCode() < 300 <line9> && serviceResponse.getResultFormatted() != null <line10> && !serviceResponse.getResultFormatted().isEmpty()) { <line11> httpResponse.setContentType(serviceResponse.getContentType()); <line12> httpResponse.setCharacterEncoding(ENCODING); <line13> httpResponse.getWriter().write(serviceResponse.getResultFormatted()); <line14> } else if (serviceResponse.getMessage() != null && !serviceResponse.getMessage().isEmpty()) { <line15> httpResponse.getWriter().write(serviceResponse.getMessage()); <line16> } <line17> } catch (IOException ex) { <line18> httpResponse.setStatus(500); <line19> } <line20> } <line21> } <line22> 	 <line17>	No
public class A { <line0> @Override <line1> public SExpIR caseANarrowExp(ANarrowExp node, IRInfo question) throws AnalysisException { <line2> PExp exp = node.getTest(); <line3> PType type = null; <line4> if (node.getBasicType() != null) { <line5> type = node.getBasicType(); <line6> } else if (node.getTypedef() != null) { <line7> type = question.getTcFactory().createPDefinitionAssistant().getType(node.getTypedef()); <line8> } <line9> SExpIR expCg = exp.apply(question.getExpVisitor(), question); <line10> STypeIR typeCg; <line11> if (type != null) { <line12> typeCg = type.apply(question.getTypeVisitor(), question); <line13> } else { <line14> typeCg = new AUnknownTypeIR(); <line15> typeCg.setSourceNode(new SourceNode(node)); <line16> } <line17> ACastUnaryExpIR cast = new ACastUnaryExpIR(); <line18> cast.setExp(expCg); <line19> cast.setType(typeCg); <line20> return cast; <line21> } <line22> } <line23> 	 <line14>	Yes
"public class A { <line0> public GroupDto getGroupById(final ExternalHttpContext context, final String id) { <line1> final HttpEntity<Void> request = new HttpEntity<>(buildHeaders(context)); <line2> final URIBuilder builder = getUriBuilderFromPath(""/groups/"" + id + ""/""); <line3> final ResponseEntity<GroupDto> response = <line4> restTemplate.exchange(buildUriBuilder(builder), HttpMethod.GET, request, GroupDto.class); <line5> checkResponse(response); <line6> return response.getBody(); <line7> } <line8> } <line9> "	 <line3>	No
"public class A { <line0> @Test(timeout = 30000) <line1> public void testRepeatedWrongPasswordAttempts() throws Exception { <line2> for (int i = 0; i < 25; ++i) { <line3> Connection connection = null; <line4> try { <line5> connection = createConnection(fullUser, ""wrongPassword"", null, false); <line6> connection.start(); <line7> fail(""Expected JMSException""); <line8> } catch (JMSSecurityException ex) { <line9> } finally { <line10> if (connection != null) { <line11> connection.close(); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public Class<?> findClass(String name) throws ClassNotFoundException { <line2> byte[] classBytes = null; <line3> try { <line4> Entry configEntry = null; <line5> try { <line6> configEntry = directoryService.getAdminSession().lookup(defaultSearchDn); <line7> } catch (LdapException e) { <line8> } <line9> if (configEntry != null) { <line10> List<Dn> searchContexts = new ArrayList<>(); <line11> Attribute attr = configEntry.get(""classLoaderDefaultSearchContext""); <line12> for (Value val : attr) { <line13> Dn dn = directoryService.getDnFactory().create(val.getString()); <line14> searchContexts.add(dn); <line15> } <line16> try { <line17> classBytes = findClassInDIT(searchContexts, name); <line18> if (LOG.isDebugEnabled()) { <line19> } <line20> } catch (ClassNotFoundException e) { <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> } <line24> } <line25> if (classBytes == null) { <line26> List<Dn> namingContexts = new ArrayList<>(); <line27> Set<String> suffixes = directoryService.getPartitionNexus().listSuffixes(); <line28> for (String suffix : suffixes) { <line29> Dn suffixDn = directoryService.getDnFactory().create(suffix); <line30> namingContexts.add(suffixDn); <line31> } <line32> classBytes = findClassInDIT(namingContexts, name); <line33> } <line34> } catch (ClassNotFoundException e) { <line35> String msg = I18n.err(I18n.ERR_293, name); <line36> throw new ClassNotFoundException(msg); <line37> } catch (Exception e) { <line38> String msg = I18n.err(I18n.ERR_70, name); <line39> throw new ClassNotFoundException(msg); <line40> } <line41> return defineClass(name, classBytes, 0, classBytes.length); <line42> } <line43> } <line44> "	 <line35>	No
"public class A { <line0> private void loadLog4j1Configuration( <line1> ConfigurableApplicationContext applicationContext, <line2> List<String> log4jLocations, <line3> List<String> loadedConfigurations, <line4> List<String> ignoredConfigurations) <line5> throws IOException { <line6> boolean hasSource = false; <line7> MutablePropertySources sources = new MutablePropertySources(); <line8> List<String> propertyNames = new ArrayList<>(); <line9> for (String location : log4jLocations) { <line10> if (applicationContext.getResource(location).exists()) { <line11> loadedConfigurations.add(location); <line12> hasSource = true; <line13> ResourcePropertySource source = <line14> new ResourcePropertySource(applicationContext.getResource(location)); <line15> sources.addFirst(source); <line16> propertyNames.addAll(Arrays.asList(source.getPropertyNames())); <line17> } else { <line18> ignoredConfigurations.add(location); <line19> } <line20> } <line21> if (hasSource) { <line22> PropertySourcesPropertyResolver resolver = new PropertySourcesPropertyResolver(sources); <line23> resolver.setPlaceholderPrefix(""#{""); <line24> resolver.setPlaceholderSuffix(""}""); <line25> Properties properties = new Properties(); <line26> for (String propertyName : propertyNames) { <line27> if (resolver.containsProperty(propertyName)) { <line28> properties.put(propertyName, resolver.getProperty(propertyName)); <line29> } else { <line30> } <line31> } <line32> reconfigure(LoggerImplementation.LOG4J.configurationClass, properties, null); <line33> } else { <line34> if (LOGGER.isWarnEnabled()) { <line35> } <line36> } <line37> } <line38> } <line39> "	 <line37>	No
public class A { <line0> public static void main(String[] args) { <line1> try { <line2> IoTDBConfigCheck.getInstance().checkConfig(); <line3> } catch (IOException e) { <line4> } <line5> IoTDB daemon = IoTDB.getInstance(); <line6> daemon.active(); <line7> } <line8> } <line9> 	 <line1>	No
public class A { <line0> private void removePage(final DOMPage page) { <line1> if (LOG.isDebugEnabled() && !lockManager.isBtreeLockedForWrite(getLockName())) { <line2> } <line3> final DOMFilePageHeader pageHeader = page.getPageHeader(); <line4> if (pageHeader.getNextDataPage() != NO_PAGE) { <line5> final DOMPage nextPage = getDOMPage(pageHeader.getNextDataPage()); <line6> nextPage.getPageHeader().setPrevDataPage(pageHeader.getPreviousDataPage()); <line7> nextPage.setDirty(true); <line8> dataCache.add(nextPage); <line9> } <line10> if (pageHeader.getPreviousDataPage() != NO_PAGE) { <line11> final DOMPage previousPage = getDOMPage(pageHeader.getPreviousDataPage()); <line12> previousPage.getPageHeader().setNextDataPage(pageHeader.getNextDataPage()); <line13> previousPage.setDirty(true); <line14> dataCache.add(previousPage); <line15> } <line16> try { <line17> pageHeader.setNextDataPage(NO_PAGE); <line18> pageHeader.setPrevDataPage(NO_PAGE); <line19> pageHeader.setDataLength(0); <line20> pageHeader.setNextTupleID(ItemId.UNKNOWN_ID); <line21> pageHeader.setRecordCount((short) 0); <line22> unlinkPages(page.page); <line23> page.setDirty(true); <line24> dataCache.remove(page); <line25> } catch (final IOException ioe) { <line26> } <line27> if (currentDocument != null) { <line28> currentDocument.decPageCount(); <line29> } <line30> } <line31> } <line32> 	 <line25>	No
public class A { <line0> public void init() { <line1> this.plugin.init(); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> public HttpService addingService(ServiceReference<HttpService> serviceRef) { <line2> httpService = super.addingService(serviceRef); <line3> HttpContext httpContext = new CustomHttpContext(context.getBundle()); <line4> registerServlet(httpContext); <line5> registerResources(httpContext); <line6> return httpService; <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> public static com.liferay.mobile.device.rules.model.MDRRule addRule( <line1> HttpPrincipal httpPrincipal, <line2> long ruleGroupId, <line3> java.util.Map<java.util.Locale, String> nameMap, <line4> java.util.Map<java.util.Locale, String> descriptionMap, <line5> String type, <line6> String typeSettings, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey(MDRRuleServiceUtil.class, ""addRule"", _addRuleParameterTypes0); <line12> MethodHandler methodHandler = <line13> new MethodHandler( <line14> methodKey, ruleGroupId, nameMap, descriptionMap, type, typeSettings, serviceContext); <line15> Object returnObj = null; <line16> try { <line17> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line18> } catch (Exception exception) { <line19> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line20> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line21> } <line22> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line23> } <line24> return (com.liferay.mobile.device.rules.model.MDRRule) returnObj; <line25> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line26> throw systemException; <line27> } <line28> } <line29> } <line30> "	 <line22>	No
public class A { <line0> public static void forEach(Collection<GlobalSession> sessions, GlobalSessionHandler handler) { <line1> for (GlobalSession globalSession : sessions) { <line2> try { <line3> MDC.put(RootContext.MDC_KEY_XID, globalSession.getXid()); <line4> handler.handle(globalSession); <line5> } catch (Throwable th) { <line6> } finally { <line7> MDC.remove(RootContext.MDC_KEY_XID); <line8> } <line9> } <line10> } <line11> } <line12> 	 <line11>	No
"public class A { <line0> @RequestMapping(value = ""/keepers/check"", method = RequestMethod.POST) <line1> public RetMessage isKeeper(@RequestBody HostPort hostPort) { <line2> try { <line3> boolean result = keeperService.isKeeper(hostPort); <line4> return GenericRetMessage.createGenericRetMessage(result); <line5> } catch (Exception e) { <line6> return RetMessage.createFailMessage(e.getMessage()); <line7> } <line8> } <line9> } <line10> "	 <line4>	No
"public class A { <line0> @POST <line1> @Path(""/reports/{report-id}/share"") <line2> public void shareReport( <line3> HttpServiceRequest request, <line4> HttpServiceResponder responder, <line5> @PathParam(""report-id"") String reportId) { <line6> Location reportIdDir; <line7> try { <line8> String userName = getUserName(request.getAllHeaders()); <line9> reportIdDir = <line10> getDatasetBaseLocation(ReportGenerationApp.REPORT_FILESET) <line11> .append(userName) <line12> .append(reportId); <line13> if (!reportIdDir.exists()) { <line14> responder.sendError( <line15> 404, String.format(""Invalid report-id %s, report does not exist"", reportId)); <line16> return; <line17> } <line18> String shareId = encodeShareId(new ReportIdentifier(userName, reportId)); <line19> responder.sendJson(200, new ShareId(shareId), ShareId.class, GSON); <line20> } catch (IOException | GeneralSecurityException e) { <line21> responder.sendError( <line22> 500, <line23> String.format( <line24> ""Failed to read report with id %s because of error: %s"", reportId, e.getMessage())); <line25> return; <line26> } <line27> } <line28> } <line29> "	 <line9>	No
"public class A { <line0> public static void main(String[] args) { <line1> try { <line2> Runtime.start(""gui"", ""SwingGui""); <line3> OpenCV cv = (OpenCV) Runtime.start(""cv"", ""OpenCV""); <line4> OpenCVFilterAddMask mask = new OpenCVFilterAddMask(""mask""); <line5> cv.addFilter(mask); <line6> mask.test(); <line7> boolean done = true; <line8> if (done) { <line9> return; <line10> } <line11> cv.capture(""src\\test\\resources\\OpenCV\\multipleFaces.jpg""); <line12> cv.addFilter(mask); <line13> cv.capture(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> "	 <line15>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public static MachineProvisioningLocation<? extends SshMachineLocation> createLocation( <line2> ManagementContext mgmt) { <line3> Location bestLocation = mgmt.getLocationRegistry().resolveIfPossible(""named:SaltTests""); <line4> if (bestLocation == null) { <line5> bestLocation = mgmt.getLocationRegistry().resolveIfPossible(""jclouds:aws-ec2:us-east-1""); <line6> } <line7> if (bestLocation == null) { <line8> throw new IllegalStateException( <line9> ""Need a location called named:SaltTests or AWS configured for these tests""); <line10> } <line11> return (MachineProvisioningLocation<? extends SshMachineLocation>) bestLocation; <line12> } <line13> } <line14> "	 <line5>	Yes
"public class A { <line0> @Override <line1> public void runJob(Path input, Path output, BayesParameters params) throws IOException { <line2> Configurable client = new JobClient(); <line3> JobConf conf = new JobConf(BayesWeightSummerDriver.class); <line4> conf.setJobName(""TfIdf Driver running over input: "" + input); <line5> conf.setOutputKeyClass(StringTuple.class); <line6> conf.setOutputValueClass(DoubleWritable.class); <line7> FileInputFormat.addInputPath(conf, new Path(output, ""trainer-termDocCount"")); <line8> FileInputFormat.addInputPath(conf, new Path(output, ""trainer-wordFreq"")); <line9> FileInputFormat.addInputPath(conf, new Path(output, ""trainer-featureCount"")); <line10> Path outPath = new Path(output, ""trainer-tfIdf""); <line11> FileOutputFormat.setOutputPath(conf, outPath); <line12> conf.setJarByClass(BayesTfIdfDriver.class); <line13> conf.setMapperClass(BayesTfIdfMapper.class); <line14> conf.setInputFormat(SequenceFileInputFormat.class); <line15> conf.setCombinerClass(BayesTfIdfReducer.class); <line16> conf.setReducerClass(BayesTfIdfReducer.class); <line17> conf.setOutputFormat(BayesTfIdfOutputFormat.class); <line18> conf.set( <line19> ""io.serializations"", <line20> ""org.apache.hadoop.io.serializer.JavaSerialization,"" <line21> + ""org.apache.hadoop.io.serializer.WritableSerialization""); <line22> HadoopUtil.delete(conf, outPath); <line23> Path interimFile = new Path(output, ""trainer-docCount/part-*""); <line24> Map<String, Double> labelDocumentCounts = <line25> SequenceFileModelReader.readLabelDocumentCounts(interimFile, conf); <line26> DefaultStringifier<Map<String, Double>> mapStringifier = <line27> new DefaultStringifier<Map<String, Double>>( <line28> conf, GenericsUtil.getClass(labelDocumentCounts)); <line29> String labelDocumentCountString = mapStringifier.toString(labelDocumentCounts); <line30> Map<String, Double> c = mapStringifier.fromString(labelDocumentCountString); <line31> conf.set(""cnaivebayes.labelDocumentCounts"", labelDocumentCountString); <line32> conf.set(""bayes.parameters"", params.toString()); <line33> client.setConf(conf); <line34> JobClient.runJob(conf); <line35> } <line36> } <line37> "	 <line10>	No
public class A { <line0> @Override <line1> public void warn(String string, Object o) { <line2> } <line3> } <line4> 	 <line1>	No
"public class A { <line0> private void updateCoords( <line1> String cluster, BundleJob bundle, int concurrency, Date endTime, Entity entity) <line2> throws FalconException { <line3> if (endTime.compareTo(DateUtil.now()) <= 0) { <line4> throw new FalconException( <line5> ""End time "" + SchemaHelper.formatDateUTC(endTime) + "" can't be in the past""); <line6> } <line7> if (bundle.getCoordinators() == null || bundle.getCoordinators().isEmpty()) { <line8> throw new FalconException( <line9> ""Invalid state. Oozie coords are still not created. Try again later""); <line10> } <line11> for (CoordinatorJob coord : bundle.getCoordinators()) { <line12> Frequency delay = null; <line13> if (entity.getEntityType().equals(EntityType.FEED)) { <line14> delay = getDelay((Feed) entity, coord); <line15> } <line16> endTime = <line17> (delay == null) <line18> ? endTime <line19> : EntityUtil.getNextInstanceTimeWithDelay( <line20> endTime, delay, EntityUtil.getTimeZone(entity)); <line21> Date lastActionTime = getCoordLastActionTime(coord); <line22> if (lastActionTime == null) { <line23> if (endTime.compareTo(coord.getStartTime()) <= 0) { <line24> change(cluster, coord.getId(), concurrency, coord.getStartTime(), null); <line25> } else { <line26> change(cluster, coord.getId(), concurrency, endTime, null); <line27> } <line28> } else { <line29> if (!endTime.after(lastActionTime)) { <line30> Date pauseTime = DateUtil.offsetTime(endTime, -1 * 60); <line31> change(cluster, coord.getId(), concurrency, null, SchemaHelper.formatDateUTC(pauseTime)); <line32> } <line33> change(cluster, coord.getId(), concurrency, endTime, null); <line34> } <line35> } <line36> } <line37> } <line38> "	 <line29>	Yes
"public class A { <line0> @Test <line1> public void headSupported() { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> String url = serviceClient.getBaseURL() + ""intakes""; <line5> HeadMethod method = new HeadMethod(url); <line6> try { <line7> int statusCode = httpClient.executeMethod(method); <line8> Assert.assertEquals(method.getResponseBody(), null, ""expected null""); <line9> if (logger.isDebugEnabled()) { <line10> for (Header h : method.getResponseHeaders()) { <line11> } <line12> } <line13> Assert.assertEquals(statusCode, HttpStatus.SC_OK, ""expected "" + HttpStatus.SC_OK); <line14> } catch (HttpException e) { <line15> } catch (IOException e) { <line16> } catch (Exception e) { <line17> } finally { <line18> method.releaseConnection(); <line19> } <line20> } <line21> } <line22> "	 <line5>	No
public class A { <line0> private boolean isPolicyValid(EDXLDistribution body, AssertionType assertion) { <line1> boolean result = false; <line2> if (body != null) { <line3> result = policyChecker.checkIncomingPolicy(body, assertion); <line4> } else { <line5> } <line6> return result; <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> private void print(PipelineInfo<RESPONSE> pipeline) { <line1> for (PipelineStep<RESPONSE> step : pipeline.getPipeline()) { <line2> printStep(INDENT, step); <line3> } <line4> } <line5> } <line6> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void appendUpdateRecordTransactional( <line2> final long txID, <line3> final long id, <line4> final byte recordType, <line5> final Persister persister, <line6> final Object record) <line7> throws Exception { <line8> if (logger.isTraceEnabled()) { <line9> } <line10> checkJournalIsLoaded(); <line11> appendExecutor.execute( <line12> new Runnable() { <line13> @Override <line14> public void run() { <line15> journalLock.readLock().lock(); <line16> final JournalTransaction tx = getTransactionInfo(txID); <line17> try { <line18> tx.checkErrorCondition(); <line19> JournalInternalRecord updateRecordTX = <line20> new JournalAddRecordTX(false, txID, id, recordType, persister, record); <line21> JournalFile usedFile = appendRecord(updateRecordTX, false, false, tx, null); <line22> if (logger.isTraceEnabled()) { <line23> } <line24> tx.addPositive(usedFile, id, updateRecordTX.getEncodeSize()); <line25> } catch (Throwable e) { <line26> setErrorCondition(null, tx, e); <line27> } finally { <line28> journalLock.readLock().unlock(); <line29> } <line30> } <line31> }); <line32> } <line33> } <line34> 	 <line26>	Yes
public class A { <line0> void closeInternal(long lastWriteTime, boolean explicit) throws CIFSException { <line1> SmbTreeHandleImpl t = this.tree; <line2> try { <line3> if (t != null && isValid()) { <line4> if (log.isDebugEnabled()) { <line5> } <line6> if (t.isSMB2()) { <line7> Smb2CloseRequest req = new Smb2CloseRequest(this.cfg, this.fileId); <line8> t.send(req, RequestParam.NO_RETRY); <line9> } else { <line10> t.send( <line11> new SmbComClose(this.cfg, this.fid, lastWriteTime), <line12> new SmbComBlankResponse(this.cfg), <line13> RequestParam.NO_RETRY); <line14> } <line15> } <line16> } finally { <line17> this.open = false; <line18> if (t != null) { <line19> t.release(); <line20> } <line21> this.tree = null; <line22> } <line23> } <line24> } <line25> 	 <line7>	No
public class A { <line0> @Override <line1> public void serviceStop() throws Exception { <line2> if (rpcServer != null) { <line3> this.rpcServer.shutdown(); <line4> } <line5> if (store != null) { <line6> store.close(); <line7> } <line8> super.serviceStop(); <line9> } <line10> } <line11> 	 <line2>	Yes
public class A { <line0> private void connectionUnreachable(String webSocketServerUrl) { <line1> retryConnection(webSocketServerUrl); <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> protected static GeoWaveValue[] getFieldValuesFromDataIdIndex( <line1> final DataStoreOperations operations, <line2> final PersistentAdapterStore adapterStore, <line3> final AdapterIndexMappingStore mappingStore, <line4> final InternalAdapterStore internalAdapterStore, <line5> final Pair<String[], InternalDataAdapter<?>> fieldSubsets, <line6> final Pair<InternalDataAdapter<?>, Aggregation<?, ?, ?>> aggregation, <line7> final String[] additionalAuthorizations, <line8> final Short adapterId, <line9> final byte[] dataId) { <line10> try (final RowReader<GeoWaveRow> reader = <line11> getRowReader( <line12> operations, <line13> adapterStore, <line14> mappingStore, <line15> internalAdapterStore, <line16> fieldSubsets, <line17> aggregation, <line18> additionalAuthorizations, <line19> adapterId, <line20> dataId)) { <line21> if (reader.hasNext()) { <line22> return reader.next().getFieldValues(); <line23> } else { <line24> } <line25> } catch (final Exception e) { <line26> } <line27> return null; <line28> } <line29> } <line30> 	 <line14>	No
"public class A { <line0> private boolean initMembershipChangeScheduleForLeavingMember( <line1> long commitIndex, CPMemberInfo leavingMember) { <line2> List<CPGroupId> leavingGroupIds = new ArrayList<>(); <line3> List<CPGroupMembershipChange> changes = new ArrayList<>(); <line4> for (CPGroupInfo group : groups.values()) { <line5> CPGroupId groupId = group.id(); <line6> if (!group.containsMember(leavingMember.toRaftEndpoint()) || group.status() == DESTROYED) { <line7> continue; <line8> } <line9> CPMemberInfo substitute = findSubstitute(group); <line10> RaftEndpoint substituteEndpoint = substitute != null ? substitute.toRaftEndpoint() : null; <line11> leavingGroupIds.add(groupId); <line12> changes.add( <line13> new CPGroupMembershipChange( <line14> groupId, <line15> group.getMembersCommitIndex(), <line16> group.memberImpls(), <line17> substituteEndpoint, <line18> leavingMember.toRaftEndpoint())); <line19> } <line20> if (changes.isEmpty()) { <line21> if (logger.isFineEnabled()) { <line22> logger.fine( <line23> ""Removing "" + leavingMember + "" directly since it is not present in any CP group.""); <line24> } <line25> removeActiveMember(commitIndex, leavingMember); <line26> return true; <line27> } <line28> membershipChangeSchedule = <line29> MembershipChangeSchedule.forLeavingMember( <line30> singletonList(commitIndex), leavingMember, changes); <line31> if (logger.isFineEnabled()) { <line32> } else { <line33> } <line34> return false; <line35> } <line36> } <line37> "	 <line33>	Yes
"public class A { <line0> @Override <line1> public RequestCtx handleRequest(HttpServletRequest request, HttpServletResponse response) <line2> throws IOException, ServletException { <line3> if (logger.isDebugEnabled()) { <line4> } <line5> String[] parts = getPathParts(request); <line6> if (parts.length < 5) { <line7> throw new ServletException( <line8> ""Not enough path components on the URI: "" + request.getRequestURI()); <line9> } <line10> String asOfDateTime = request.getParameter(""asOfDateTime""); <line11> if (!isDate(asOfDateTime)) { <line12> asOfDateTime = null; <line13> } <line14> RequestCtx req = null; <line15> Map<URI, AttributeValue> actions = new HashMap<URI, AttributeValue>(); <line16> Map<URI, AttributeValue> resAttr; <line17> try { <line18> resAttr = ResourceAttributes.getResources(parts); <line19> if (asOfDateTime != null && !asOfDateTime.isEmpty()) { <line20> resAttr.put( <line21> Constants.DATASTREAM.AS_OF_DATETIME.getURI(), <line22> DateTimeAttribute.getInstance(asOfDateTime)); <line23> } <line24> actions.put( <line25> Constants.ACTION.ID.getURI(), Constants.ACTION.GET_DATASTREAM.getStringAttribute()); <line26> actions.put( <line27> Constants.ACTION.ID.getURI(), <line28> Constants.ACTION.GET_DATASTREAM_DISSEMINATION.getStringAttribute()); <line29> actions.put(Constants.ACTION.API.getURI(), Constants.ACTION.APIA.getStringAttribute()); <line30> req = <line31> getContextHandler() <line32> .buildRequest(getSubjects(request), actions, resAttr, getEnvironment(request)); <line33> LogUtil.statLog( <line34> request.getRemoteUser(), <line35> Constants.ACTION.GET_DATASTREAM_DISSEMINATION.uri, <line36> parts[1], <line37> parts[3]); <line38> } catch (Exception e) { <line39> throw new ServletException(e.getMessage(), e); <line40> } <line41> return req; <line42> } <line43> } <line44> "	 <line4>	Yes
public class A { <line0> public void attachDirty(ModZobjBstMassMitarb instance) { <line1> try { <line2> getSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line7>	No
"public class A { <line0> @Override <line1> public void handleSplitRequest(int subtask, @Nullable String hostname) { <line2> if (!context.registeredReaders().containsKey(subtask)) { <line3> return; <line4> } <line5> if (LOG.isInfoEnabled()) { <line6> final String hostInfo = <line7> hostname == null ? ""(no host locality info)"" : ""(on host '"" + hostname + ""')""; <line8> } <line9> final Optional<FileSourceSplit> nextSplit = splitAssigner.getNext(hostname); <line10> if (nextSplit.isPresent()) { <line11> final FileSourceSplit split = nextSplit.get(); <line12> context.assignSplit(split, subtask); <line13> } else { <line14> context.signalNoMoreSplits(subtask); <line15> } <line16> } <line17> } <line18> "	 <line13>	Yes
"public class A { <line0> public static com.liferay.knowledge.base.model.KBFolder fetchFirstChildKBFolder( <line1> HttpPrincipal httpPrincipal, long groupId, long kbFolderId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> KBFolderServiceUtil.class, <line7> ""fetchFirstChildKBFolder"", <line8> _fetchFirstChildKBFolderParameterTypes2); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, groupId, kbFolderId); <line10> Object returnObj = null; <line11> try { <line12> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line13> } catch (Exception exception) { <line14> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line15> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line16> } <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> return (com.liferay.knowledge.base.model.KBFolder) returnObj; <line20> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line21> throw systemException; <line22> } <line23> } <line24> } <line25> "	 <line18>	No
"public class A { <line0> private void handleUnregisterInterest(Message clientMessage) { <line1> String regionName = null; <line2> Object key = null; <line3> final boolean isDebugEnabled = logger.isDebugEnabled(); <line4> try { <line5> if (isDebugEnabled) { <line6> } <line7> int partCnt = 0; <line8> Part regionNamePart = clientMessage.getPart(partCnt++); <line9> Part keyPart = clientMessage.getPart(partCnt++); <line10> Part interestTypePart = clientMessage.getPart(partCnt++); <line11> Part isDurablePart = clientMessage.getPart(partCnt++); <line12> Part receiveUpdatesAsInvalidatesPart = clientMessage.getPart(partCnt); <line13> regionName = regionNamePart.getCachedString(); <line14> key = keyPart.getStringOrObject(); <line15> int interestType = (Integer) interestTypePart.getObject(); <line16> boolean isDurable = (Boolean) isDurablePart.getObject(); <line17> boolean receiveUpdatesAsInvalidates = (Boolean) receiveUpdatesAsInvalidatesPart.getObject(); <line18> LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName); <line19> if (region == null) { <line20> if (isDebugEnabled) { <line21> } <line22> return; <line23> } <line24> if (!region.hasServerProxy()) { <line25> return; <line26> } <line27> if (key instanceof List) { <line28> region <line29> .getServerProxy() <line30> .removeListInterest((List) key, isDurable, receiveUpdatesAsInvalidates); <line31> } else { <line32> region <line33> .getServerProxy() <line34> .removeSingleInterest(key, interestType, isDurable, receiveUpdatesAsInvalidates); <line35> } <line36> } catch (Exception e) { <line37> String message = <line38> "": The following exception occurred while attempting to add interest (region: "" <line39> + regionName <line40> + "" key: "" <line41> + key <line42> + ""): ""; <line43> handleException(message, e); <line44> } <line45> } <line46> } <line47> "	 <line21>	Yes
public class A { <line0> @Override <line1> public void onError(final String reason) { <line2> PrometheusExporter.instance().increaseTotalPushRequestsFail(); <line3> pushMessageMetricsService.appendError(pushMessageInformation, variant, reason); <line4> } <line5> } <line6> 	 <line5>	No
"public class A { <line0> @Reference( <line1> policy = ReferencePolicy.DYNAMIC, <line2> policyOption = ReferencePolicyOption.GREEDY, <line3> target = ""(entity.model.name="" + ContextEntityModel.NAME + "")"", <line4> unbind = ""unbindFilterParser"") <line5> public void setFilterParser(FilterParser filterParser) { <line6> if (_log.isInfoEnabled()) { <line7> } <line8> _filterParser = filterParser; <line9> } <line10> } <line11> "	 <line7>	Yes
public class A { <line0> private void loadTimelinesFromAllPartitions(String storageTableName, String timeLineKey) <line1> throws HiveException, LensException { <line2> Table storageTable = getTable(storageTableName); <line3> List<String> timeParts = getTimePartColNamesOfTable(storageTable); <line4> List<FieldSchema> partCols = storageTable.getPartCols(); <line5> for (Partition partition : getPartitionsByFilter(storageTableName, null)) { <line6> UpdatePeriod period = deduceUpdatePeriod(partition); <line7> List<String> values = partition.getValues(); <line8> if (values.contains(StorageConstants.LATEST_PARTITION_VALUE)) { <line9> getClient().dropPartition(storageTableName, values, false); <line10> continue; <line11> } <line12> for (int i = 0; i < partCols.size(); i++) { <line13> if (timeParts.contains(partCols.get(i).getName())) { <line14> addForBatchAddition( <line15> timeLineKey, storageTableName, period, partCols.get(i).getName(), values.get(i)); <line16> } <line17> } <line18> } <line19> } <line20> } <line21> 	 <line0>	No
"public class A { <line0> @Test <line1> public void testJacksonJSONParsing() throws Exception { <line2> RepairScheduleStatus data = new RepairScheduleStatus(); <line3> data.setClusterName(""testCluster""); <line4> data.setColumnFamilies(Lists.<String>newArrayList()); <line5> data.setCreationTime(DateTime.now().withMillis(0)); <line6> data.setDaysBetween(2); <line7> data.setId(UUIDs.timeBased()); <line8> data.setIntensity(0.75); <line9> data.setIncrementalRepair(false); <line10> data.setKeyspaceName(""testKeyspace""); <line11> data.setOwner(""testuser""); <line12> data.setRepairParallelism(RepairParallelism.PARALLEL); <line13> data.setState(RepairSchedule.State.ACTIVE); <line14> ObjectMapper mapper = new ObjectMapper(); <line15> String dataAsJson = mapper.writeValueAsString(data); <line16> RepairScheduleStatus dataAfter = SimpleReaperClient.parseRepairScheduleStatusJSON(dataAsJson); <line17> assertEquals(data.getClusterName(), dataAfter.getClusterName()); <line18> assertEquals(data.getColumnFamilies(), dataAfter.getColumnFamilies()); <line19> assertEquals(data.getCreationTime(), dataAfter.getCreationTime()); <line20> assertEquals(data.getDaysBetween(), dataAfter.getDaysBetween()); <line21> assertEquals(data.getId(), dataAfter.getId()); <line22> assertEquals(data.getIntensity(), dataAfter.getIntensity(), 0.0); <line23> assertEquals(data.getIncrementalRepair(), dataAfter.getIncrementalRepair()); <line24> assertEquals(data.getKeyspaceName(), dataAfter.getKeyspaceName()); <line25> assertEquals(data.getRepairParallelism(), dataAfter.getRepairParallelism()); <line26> assertEquals(data.getState(), dataAfter.getState()); <line27> } <line28> } <line29> "	 <line7>	No
public class A { <line0> private Map<Integer, BookieId> getReplacementBookiesByIndexes( <line1> LedgerHandle lh, <line2> List<BookieId> ensemble, <line3> Set<Integer> bookieIndexesToRereplicate, <line4> Optional<Set<BookieId>> excludedBookies) <line5> throws BKException.BKNotEnoughBookiesException { <line6> Map<Integer, BookieId> targetBookieAddresses = <line7> Maps.newHashMapWithExpectedSize(bookieIndexesToRereplicate.size()); <line8> Set<BookieId> bookiesToExclude = Sets.newHashSet(); <line9> if (excludedBookies.isPresent()) { <line10> bookiesToExclude.addAll(excludedBookies.get()); <line11> } <line12> for (Integer bookieIndex : bookieIndexesToRereplicate) { <line13> BookieId bookie = ensemble.get(bookieIndex); <line14> bookiesToExclude.add(bookie); <line15> } <line16> for (Integer bookieIndex : bookieIndexesToRereplicate) { <line17> BookieId oldBookie = ensemble.get(bookieIndex); <line18> EnsemblePlacementPolicy.PlacementResult<BookieId> replaceBookieResponse = <line19> bkc.getPlacementPolicy() <line20> .replaceBookie( <line21> lh.getLedgerMetadata().getEnsembleSize(), <line22> lh.getLedgerMetadata().getWriteQuorumSize(), <line23> lh.getLedgerMetadata().getAckQuorumSize(), <line24> lh.getLedgerMetadata().getCustomMetadata(), <line25> ensemble, <line26> oldBookie, <line27> bookiesToExclude); <line28> BookieId newBookie = replaceBookieResponse.getResult(); <line29> PlacementPolicyAdherence isEnsembleAdheringToPlacementPolicy = <line30> replaceBookieResponse.isAdheringToPolicy(); <line31> if (isEnsembleAdheringToPlacementPolicy == PlacementPolicyAdherence.FAIL) { <line32> if (LOG.isDebugEnabled()) { <line33> } <line34> } <line35> targetBookieAddresses.put(bookieIndex, newBookie); <line36> bookiesToExclude.add(newBookie); <line37> } <line38> return targetBookieAddresses; <line39> } <line40> } <line41> 	 <line33>	Yes
public class A { <line0> private void closeQuietly(final AutoCloseable... closeables) { <line1> if (closeables == null) { <line2> return; <line3> } <line4> for (final AutoCloseable closeable : closeables) { <line5> if (closeable == null) { <line6> continue; <line7> } <line8> try { <line9> closeable.close(); <line10> } catch (final Exception e) { <line11> } <line12> } <line13> } <line14> } <line15> 	 <line11>	Yes
"public class A { <line0> private Cloud readCloud() { <line1> cloudConfigurationHolder = getCloudConfigurationFromManagementSpace(); <line2> final String cloudConfigurationFilePath = <line3> cloudConfigurationHolder.getCloudConfigurationFilePath(); <line4> if (cloudConfigurationFilePath == null) { <line5> return null; <line6> } <line7> Cloud cloudConfiguration = null; <line8> try { <line9> final File cloudConfigurationFile = new File(cloudConfigurationFilePath); <line10> cloudConfigurationDir = cloudConfigurationFile.getParentFile(); <line11> cloudConfiguration = ServiceReader.readCloud(cloudConfigurationFile); <line12> } catch (final DSLException e) { <line13> throw new IllegalArgumentException( <line14> ""Failed to read cloud configuration file: "" <line15> + cloudConfigurationHolder <line16> + "". Error was: "" <line17> + e.getMessage(), <line18> e); <line19> } catch (final IOException e) { <line20> throw new IllegalArgumentException( <line21> ""Failed to read cloud configuration file: "" <line22> + cloudConfigurationHolder <line23> + "". Error was: "" <line24> + e.getMessage(), <line25> e); <line26> } <line27> return cloudConfiguration; <line28> } <line29> } <line30> "	 <line27>	Yes
public class A { <line0> @VisibleForTesting <line1> InternetAddress getUserEmail(UserDataRequest udr) throws UnexpectedObmSyncServerException { <line2> String email = authenticationService.getUserEmail(udr); <line3> try { <line4> InternetAddress address = new InternetAddress(email, true); <line5> address.setPersonal(udr.getUser().getDisplayName(), Charsets.UTF_8.name()); <line6> return address; <line7> } catch (UnsupportedEncodingException | AddressException e) { <line8> throw Throwables.propagate(e); <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
"public class A { <line0> public String createQueue(String queueName) { <line1> Map<String, String[]> params = new HashMap<String, String[]>(); <line2> CommunicationUtils.addParam(params, ""Action"", ""CreateQueue""); <line3> CommunicationUtils.addParam(params, ""QueueName"", queueName); <line4> CommunicationUtils.addParam(params, ""AWSAccessKeyId"", user.getAccessKey()); <line5> CommunicationUtils.addParam(params, ""Version"", ""2009-02-01""); <line6> try { <line7> String response = send(params, CMBProperties.getInstance().getCQSServiceUrl()); <line8> return CqsStressTester.deserialize(response, ""QueueUrl"").trim(); <line9> } catch (Exception e) { <line10> return null; <line11> } <line12> } <line13> } <line14> "	 <line2>	No
public class A { <line0> @Override <line1> public void run() throws Exception { <line2> if (!pathStatRecord.pathChecked()) { <line3> Stat stat = null; <line4> if (!pathExists) { <line5> stat = getStat(path, false); <line6> } else { <line7> stat = installWatchOnlyPathExist(path); <line8> } <line9> pathStatRecord.recordPathStat(stat, notificationTime); <line10> } <line11> if (!pathStatRecord.pathExists()) { <line12> listener.getDataListener().handleDataDeleted(path); <line13> } else { <line14> Object data = null; <line15> if (listener.isPrefetchData()) { <line16> if (LOG.isDebugEnabled()) { <line17> } <line18> try { <line19> data = readData(path, null, true); <line20> } catch (ZkNoNodeException e) { <line21> listener.getDataListener().handleDataDeleted(path); <line22> return; <line23> } <line24> } <line25> listener.getDataListener().handleDataChange(path, data); <line26> } <line27> } <line28> } <line29> 	 <line11>	No
"public class A { <line0> public void testCreateTemporaryQueueThenCreateAQueueFromItsName() throws Exception { <line1> Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line2> Queue tempQueue = session.createTemporaryQueue(); <line3> String name = tempQueue.getQueueName(); <line4> Queue createdQueue = session.createQueue(name); <line5> assertEquals(""created queue not equal to temporary queue"", tempQueue, createdQueue); <line6> } <line7> } <line8> "	 <line4>	Yes
"public class A { <line0> @Override <line1> public void endElement(@Nullable String uri, @Nullable String localName, @Nullable String qName) <line2> throws SAXException { <line3> if (""Alarm"".equals(qName)) { <line4> int finalID = 0; <line5> int finalVolume = 0; <line6> boolean finalEnabled = !""0"".equals(enabled); <line7> boolean finalIncludeLinkedZones = !""0"".equals(includeLinkedZones); <line8> try { <line9> String id = this.id; <line10> if (id == null) { <line11> throw new NumberFormatException(); <line12> } <line13> finalID = Integer.parseInt(id); <line14> String volume = this.volume; <line15> if (volume == null) { <line16> throw new NumberFormatException(); <line17> } <line18> finalVolume = Integer.parseInt(volume); <line19> } catch (NumberFormatException e) { <line20> } <line21> alarms.add( <line22> new SonosAlarm( <line23> finalID, <line24> startTime, <line25> duration, <line26> recurrence, <line27> finalEnabled, <line28> roomUUID, <line29> programURI, <line30> programMetaData, <line31> playMode, <line32> finalVolume, <line33> finalIncludeLinkedZones)); <line34> } <line35> } <line36> } <line37> "	 <line20>	Yes
public class A { <line0> @Test <line1> public void testSpdyServerSessionHandlerGoAway() { <line2> testSpdySessionHandlerGoAway(SpdyVersion.SPDY_3, true); <line3> testSpdySessionHandlerGoAway(SpdyVersion.SPDY_3_1, true); <line4> } <line5> } <line6> 	 <line3>	Yes
"public class A { <line0> private void checkCacheReload() { <line1> if (nextLoadTime > System.currentTimeMillis()) { <line2> return; <line3> } <line4> if (nextLoadTime > 0) { <line5> } else { <line6> } <line7> int numRetry = 0; <line8> while (true) { <line9> cache.clear(); <line10> try { <line11> long count = 0; <line12> GenericRowData reuse = new GenericRowData(rowType.getFieldCount()); <line13> partitionReader.open(partitionFetcher.fetch(fetcherContext)); <line14> RowData row; <line15> while ((row = partitionReader.read(reuse)) != null) { <line16> count++; <line17> RowData key = extractLookupKey(row); <line18> List<RowData> rows = cache.computeIfAbsent(key, k -> new ArrayList<>()); <line19> rows.add(serializer.copy(row)); <line20> } <line21> partitionReader.close(); <line22> nextLoadTime = System.currentTimeMillis() + reloadInterval.toMillis(); <line23> return; <line24> } catch (Exception e) { <line25> if (numRetry >= MAX_RETRIES) { <line26> throw new FlinkRuntimeException( <line27> String.format(""Failed to load table into cache after %d retries"", numRetry), e); <line28> } <line29> numRetry++; <line30> long toSleep = numRetry * RETRY_INTERVAL.toMillis(); <line31> try { <line32> Thread.sleep(toSleep); <line33> } catch (InterruptedException ex) { <line34> throw new FlinkRuntimeException(ex); <line35> } <line36> } <line37> } <line38> } <line39> } <line40> "	 <line31>	Yes
public class A { <line0> private boolean isBootstrappedWithRetries() { <line1> return Retries.callWithRetries( <line2> this::isBootstrapped, <line3> RetryStrategies.fixDelay(6, TimeUnit.SECONDS), <line4> t -> { <line5> State serviceState = state(); <line6> if (serviceState != State.STARTING && serviceState != State.RUNNING) { <line7> return false; <line8> } <line9> if (t instanceof InterruptedException) { <line10> return false; <line11> } <line12> Throwable rootCause = Throwables.getRootCause(t); <line13> if (!(rootCause instanceof SocketTimeoutException <line14> || rootCause instanceof ConnectException)) { <line15> } <line16> return true; <line17> }); <line18> } <line19> } <line20> 	 <line15>	Yes
public class A { <line0> void doRead(SelectionKey key) throws InterruptedException { <line1> int count = 0; <line2> Connection c = (Connection) key.attachment(); <line3> if (c == null) { <line4> return; <line5> } <line6> c.setLastContact(System.currentTimeMillis()); <line7> try { <line8> count = c.readAndProcess(); <line9> } catch (InterruptedException ieo) { <line10> throw ieo; <line11> } catch (Exception e) { <line12> count = -1; <line13> } <line14> if (count < 0) { <line15> if (LOG.isDebugEnabled()) <line16> closeConnection(c); <line17> c = null; <line18> } else { <line19> c.setLastContact(System.currentTimeMillis()); <line20> } <line21> } <line22> } <line23> 	 <line16>	Yes
"public class A { <line0> @Test(timeout = 60 * 1000) <line1> public void automaticSplitWith250Same() throws Exception { <line2> final String tableName = getUniqueNames(1)[0]; <line3> try (AccumuloClient client = Accumulo.newClient().from(getClientProperties()).build()) { <line4> client.tableOperations().create(tableName); <line5> client <line6> .tableOperations() <line7> .setProperty(tableName, Property.TABLE_SPLIT_THRESHOLD.getKey(), ""10K""); <line8> client <line9> .tableOperations() <line10> .setProperty(tableName, Property.TABLE_FILE_COMPRESSION_TYPE.getKey(), ""none""); <line11> client <line12> .tableOperations() <line13> .setProperty(tableName, Property.TABLE_FILE_COMPRESSED_BLOCK_SIZE.getKey(), ""64""); <line14> client <line15> .tableOperations() <line16> .setProperty(tableName, Property.TABLE_MAX_END_ROW_SIZE.getKey(), ""1000""); <line17> BatchWriter batchWriter = client.createBatchWriter(tableName, new BatchWriterConfig()); <line18> byte[] data = <line19> new byte <line20> [(int) <line21> (ConfigurationTypeHelper.getFixedMemoryAsBytes( <line22> Property.TABLE_MAX_END_ROW_SIZE.getDefaultValue()) <line23> + 2)]; <line24> for (int i = 0; i < data.length - 1; i++) { <line25> data[i] = (byte) 'm'; <line26> } <line27> for (int i = 0; i < 250; i++) { <line28> data[data.length - 1] = (byte) i; <line29> Mutation m = new Mutation(data); <line30> m.put(""cf"", ""cq"", ""value""); <line31> batchWriter.addMutation(m); <line32> } <line33> batchWriter.close(); <line34> client.tableOperations().flush(tableName, new Text(), new Text(""z""), true); <line35> Thread.sleep(500); <line36> int count = 0; <line37> try (Scanner scanner = client.createScanner(tableName, Authorizations.EMPTY)) { <line38> for (Entry<Key, Value> entry : scanner) { <line39> Key k = entry.getKey(); <line40> data[data.length - 1] = (byte) count; <line41> String expected = new String(data, UTF_8); <line42> assertEquals(expected, k.getRow().toString()); <line43> assertEquals(""cf"", k.getColumnFamily().toString()); <line44> assertEquals(""cq"", k.getColumnQualifier().toString()); <line45> assertEquals(""value"", entry.getValue().toString()); <line46> count++; <line47> } <line48> } <line49> assertEquals(250, count); <line50> assertEquals(0, client.tableOperations().listSplits(tableName).size()); <line51> } <line52> } <line53> } <line54> "	 <line2>	Yes
public class A { <line0> public void addAccess( <line1> String typename, <line2> String[][] methodsAndConstructors, <line3> String[][] fields, <line4> boolean silent, <line5> Flag... flags) { <line6> if (!silent) { <line7> } <line8> List<AccessChecker> accessCheckers = ts.getAccessCheckers(); <line9> for (AccessChecker accessChecker : accessCheckers) { <line10> boolean isOK = accessChecker.check(ts, typename); <line11> if (!isOK) { <line12> return; <line13> } <line14> } <line15> ClassDescriptor cd = ClassDescriptor.of(typename); <line16> if (cd == null) { <line17> cd = ClassDescriptor.of(typename); <line18> } <line19> for (Flag f : flags) { <line20> cd.setFlag(f); <line21> } <line22> if (methodsAndConstructors != null) { <line23> for (String[] mc : methodsAndConstructors) { <line24> MethodDescriptor md = MethodDescriptor.of(mc[0], subarray(mc)); <line25> if (!cd.contains(md)) { <line26> cd.addMethodDescriptor(md); <line27> } <line28> } <line29> } <line30> if (fields != null) { <line31> for (String[] field : fields) { <line32> FieldDescriptor fieldDescriptor = FieldDescriptor.of(field); <line33> FieldDescriptor existingFieldDescriptor = <line34> cd.getFieldDescriptorNamed(fieldDescriptor.getName()); <line35> if (existingFieldDescriptor != null) { <line36> existingFieldDescriptor.merge(fieldDescriptor); <line37> } else { <line38> cd.addFieldDescriptor(fieldDescriptor); <line39> } <line40> } <line41> } <line42> collector.addClassDescriptor(cd); <line43> } <line44> } <line45> 	 <line12>	Yes
public class A { <line0> @Override <line1> public FastIDSet getItemIDsFromUser(long userID) throws TasteException { <line2> Connection conn = null; <line3> PreparedStatement stmt = null; <line4> ResultSet rs = null; <line5> try { <line6> conn = dataSource.getConnection(); <line7> stmt = <line8> conn.prepareStatement( <line9> getUserSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); <line10> stmt.setFetchDirection(ResultSet.FETCH_FORWARD); <line11> stmt.setFetchSize(getFetchSize()); <line12> setLongParameter(stmt, 1, userID); <line13> rs = stmt.executeQuery(); <line14> FastIDSet result = new FastIDSet(); <line15> while (rs.next()) { <line16> result.add(getLongColumn(rs, 2)); <line17> } <line18> if (result.isEmpty()) { <line19> throw new NoSuchUserException(userID); <line20> } <line21> return result; <line22> } catch (SQLException sqle) { <line23> throw new TasteException(sqle); <line24> } finally { <line25> IOUtils.quietClose(rs, stmt, conn); <line26> } <line27> } <line28> } <line29> 	 <line17>	No
public class A { <line0> protected void activate( <line1> final ComponentContext componentContext, final Map<String, Object> properties) { <line2> this.wireSupport = <line3> this.wireHelperService.newWireSupport( <line4> this, (ServiceReference<WireComponent>) componentContext.getServiceReference()); <line5> this.options = new CloudSubscriberOptions(properties); <line6> } <line7> } <line8> 	 <line6>	Yes
"public class A { <line0> public boolean hasTimedOut(Map args) { <line1> boolean bRet = true; <line2> Long maxIdleTime = (Long) args.get(""maxIdleTime""); <line3> if (maxIdleTime <= timeoutPeriod) { <line4> bRet = false; <line5> } else { <line6> } <line7> return bRet; <line8> } <line9> } <line10> "	 <line4>	Yes
"public class A { <line0> private void checkDescribeOpportunities() throws IOException { <line1> MarketoSource source = new MarketoSource(); <line2> source.initialize(null, iprops); <line3> MarketoRESTClient client = (MarketoRESTClient) source.getClientService(null); <line4> MarketoRecordResult opps = client.describeOpportunity(iprops); <line5> assertNotNull(opps.getRecords()); <line6> assertNotNull(opps.getRecords().get(0)); <line7> IndexedRecord record = opps.getRecords().get(0); <line8> assertNotNull(record.get(record.getSchema().getField(""idField"").pos())); <line9> assertNotNull(record.get(record.getSchema().getField(""dedupeFields"").pos())); <line10> assertNotNull(record.get(record.getSchema().getField(""searchableFields"").pos())); <line11> assertNotNull(record.get(record.getSchema().getField(""fields"").pos())); <line12> } <line13> } <line14> "	 <line5>	Yes
public class A { <line0> @Override <line1> public Object unmarshal(final Node nodeToUnmarshal, final Class<?> destinationClazz) { <line2> try { <line3> final Unmarshaller u = JAXBSupport.createUnmarshaller(); <line4> final JAXBElement<?> jaxbElement = u.unmarshal(nodeToUnmarshal, destinationClazz); <line5> if (jaxbElement != null) { <line6> return jaxbElement.getValue(); <line7> } <line8> } catch (final JAXBException e) { <line9> e.printStackTrace(); <line10> } finally { <line11> this.printErrorsWhileSerialization(); <line12> } <line13> return null; <line14> } <line15> } <line16> 	 <line2>	Yes
"public class A { <line0> @Test <line1> public void testGetJSDateWithDate() { <line2> GregorianCalendar calendar = new GregorianCalendar(2009, 11, 11); <line3> String expectedJavascript = ""new Date(2009,11,11,0,0,0,0)""; <line4> String generatedJavascript = DateHelper.getJSDate(calendar.getTime()).toString(); <line5> assertEquals(generatedJavascript, expectedJavascript); <line6> } <line7> } <line8> "	 <line5>	Yes
"public class A { <line0> private void handleEvent(EvdevDevice.InputEvent event) { <line1> if (event.type() != EvdevLibrary.Type.KEY) { <line2> return; <line3> } <line4> @Nullable Channel channel = channels.get(event.getCode()); <line5> if (channel == null) { <line6> String msg = ""Could not find channel for code {}""; <line7> if (isInitialized()) { <line8> } else { <line9> } <line10> return; <line11> } <line12> int eventValue = event.getValue(); <line13> switch (eventValue) { <line14> case EvdevLibrary.KeyEventValue.DOWN: <line15> String keyCode = channel.getUID().getIdWithoutGroup(); <line16> updateState(keyChannel.getUID(), new StringType(keyCode)); <line17> updateState(channel.getUID(), OpenClosedType.CLOSED); <line18> triggerChannel(keyChannel.getUID(), keyCode); <line19> triggerChannel(channel.getUID(), CommonTriggerEvents.PRESSED); <line20> updateState(keyChannel.getUID(), new StringType()); <line21> break; <line22> case EvdevLibrary.KeyEventValue.UP: <line23> updateState(channel.getUID(), OpenClosedType.OPEN); <line24> triggerChannel(channel.getUID(), CommonTriggerEvents.RELEASED); <line25> break; <line26> case EvdevLibrary.KeyEventValue.REPEAT: <line27> break; <line28> default: <line29> break; <line30> } <line31> } <line32> } <line33> "	 <line29>	Yes
public class A { <line0> static Optional<ConfigSource> findFile(String name, String type) { <line1> Path path = Paths.get(name); <line2> if (Files.exists(path) && Files.isReadable(path) && !Files.isDirectory(path)) { <line3> return Optional.of(ConfigSources.file(path).build()); <line4> } <line5> return Optional.empty(); <line6> } <line7> } <line8> 	 <line1>	No
public class A { <line0> public static void writePrimitiveShort(short value, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> out.writeShort(value); <line5> } <line6> } <line7> 	 <line6>	No
public class A { <line0> public static void writeFile(File file, DataOutput out) throws IOException { <line1> InternalDataSerializer.checkOut(out); <line2> if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) { <line3> } <line4> writeString((file != null) ? file.getCanonicalPath() : null, out); <line5> } <line6> } <line7> 	 <line3>	Yes
"public class A { <line0> protected Response putTopology(Topology newTopology) throws Exception { <line1> if (newTopology.getVersion() != null <line2> && !topology.getVersion().equals(newTopology.getVersion())) { <line3> return createErrorResponse(Response.CONFLICT, topology); <line4> } <line5> if (!newTopology.validate()) { <line6> return createErrorResponse( <line7> Response.BAD_REQUEST, <line8> String.format(""Invalid Topology Format. [invalid topology: %s]"", newTopology)); <line9> } <line10> Map<String, Link> newLinks = newTopology.getLinkMap(); <line11> Map<String, Node> newNodes = newTopology.getNodeMap(); <line12> for (Link link : newLinks.values()) { <line13> if (link == null || !link.validate()) { <line14> return createErrorResponse( <line15> Response.BAD_REQUEST, <line16> String.format(""Invalid Topology's link Format. [invalid link: %s]"", link)); <line17> } <line18> } <line19> for (Node node : newNodes.values()) { <line20> if (node == null || !node.validate()) { <line21> return createErrorResponse( <line22> Response.BAD_REQUEST, <line23> String.format(""Invalid Topology's node Format. [invalid node: %s]"", node)); <line24> } <line25> for (Port port : node.getPortMap().values()) { <line26> if (port == null || !port.validate()) { <line27> return createErrorResponse( <line28> Response.BAD_REQUEST, <line29> String.format(""Invalid Topology's port Format. [invalid port: %s]"", port)); <line30> } <line31> } <line32> } <line33> Topology oldTopology = topology; <line34> topology = newTopology.clone(); <line35> if (oldTopology == null) { <line36> notifyTopologyChangedToAdd(newTopology); <line37> } else { <line38> notifyTopologyChangedToUpdate(oldTopology, newTopology); <line39> } <line40> return new Response(Response.OK, newTopology); <line41> } <line42> } <line43> "	 <line1>	Yes
public class A { <line0> @Override <line1> public Image getImage(ZYXImageKey key) { <line2> DataModelCategory imageCategory = <line3> new DataModelCategory(myLayer.getServerUrl(), XYZTileUtils.TILES_FAMILY, myLayer.getName()); <line4> List<PropertyMatcher<?>> matchers = New.list(); <line5> ZYXKeyPropertyMatcher keyMatcher = <line6> new ZYXKeyPropertyMatcher(XYZTileUtils.KEY_PROPERTY_DESCRIPTOR, key); <line7> matchers.add(keyMatcher); <line8> SimpleQuery<InputStream> query = <line9> new SimpleQuery<>(imageCategory, XYZTileUtils.IMAGE_PROPERTY_DESCRIPTOR, matchers); <line10> Image image = null; <line11> QueryTracker tracker = myRegistry.performQuery(query); <line12> if (query.getResults() != null && !query.getResults().isEmpty()) { <line13> try { <line14> InputStream stream = query.getResults().get(0); <line15> StreamingDDSImage.setThreadByteBufferPool(ourByteBufferPool); <line16> try (ObjectInputStream ois = new CustomObjectInputStream(myClassProvider, stream)) { <line17> image = (Image) ois.readObject(); <line18> } catch (ClassNotFoundException e) { <line19> } finally { <line20> StreamingDDSImage.setThreadByteBufferPool(null); <line21> } <line22> } catch (ClosedByInterruptException e) { <line23> if (LOGGER.isDebugEnabled()) { <line24> } <line25> } catch (IOException e) { <line26> } <line27> } else if (tracker.getException() != null) { <line28> } <line29> return image; <line30> } <line31> } <line32> 	 <line23>	No
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrderItem updateCommerceOrderItemUnitPrice( <line1> HttpPrincipal httpPrincipal, <line2> long commerceOrderItemId, <line3> int quantity, <line4> java.math.BigDecimal unitPrice) <line5> throws com.liferay.portal.kernel.exception.PortalException { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> CommerceOrderItemServiceUtil.class, <line10> ""updateCommerceOrderItemUnitPrice"", <line11> _updateCommerceOrderItemUnitPriceParameterTypes29); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, commerceOrderItemId, quantity, unitPrice); <line14> Object returnObj = null; <line15> try { <line16> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line17> } catch (Exception exception) { <line18> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line19> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line20> } <line21> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line22> } <line23> return (com.liferay.commerce.model.CommerceOrderItem) returnObj; <line24> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line25> throw systemException; <line26> } <line27> } <line28> } <line29> "	 <line25>	Yes
public class A { <line0> @Override <line1> public int getAssertionLifetime(String entityId) { <line2> long companyId = CompanyThreadLocal.getCompanyId(); <line3> try { <line4> SamlIdpSpConnection samlIdpSpConnection = <line5> _samlIdpSpConnectionLocalService.getSamlIdpSpConnection(companyId, entityId); <line6> return samlIdpSpConnection.getAssertionLifetime(); <line7> } catch (Exception exception) { <line8> if (_log.isDebugEnabled()) { <line9> } <line10> } <line11> SamlProviderConfiguration samlProviderConfiguration = <line12> _samlProviderConfigurationHelper.getSamlProviderConfiguration(); <line13> return samlProviderConfiguration.defaultAssertionLifetime(); <line14> } <line15> } <line16> 	 <line13>	No
"public class A { <line0> public List<BoxEvent> getEnterpriseEvents( <line1> String position, Date after, Date before, BoxEvent.Type... types) { <line2> try { <line3> if (after == null) { <line4> throw new IllegalArgumentException(""Parameter 'after' can not be null""); <line5> } <line6> if (before == null) { <line7> throw new IllegalArgumentException(""Parameter 'before' can not be null""); <line8> } <line9> if (types == null) { <line10> types = new BoxEvent.Type[0]; <line11> } <line12> EventLog eventLog = <line13> EventLog.getEnterpriseEvents(boxConnection, position, after, before, types); <line14> List<BoxEvent> results = new ArrayList<>(); <line15> for (BoxEvent event : eventLog) { <line16> results.add(event); <line17> } <line18> return results; <line19> } catch (BoxAPIException e) { <line20> throw new RuntimeException( <line21> String.format( <line22> ""Box API returned the error code %d%n%n%s"", e.getResponseCode(), e.getResponse()), <line23> e); <line24> } <line25> } <line26> } <line27> "	 <line3>	Yes
"public class A { <line0> @Issue(""JENKINS-53311"") <line1> @Test <line2> public void nodeWrongFinishedStatus() throws Exception { <line3> WorkflowJob job = j.jenkins.createProject(WorkflowJob.class, ""p""); <line4> URL resource = Resources.getResource(getClass(), ""JENKINS-53311.jenkinsfile""); <line5> String jenkinsFile = Resources.toString(resource, Charsets.UTF_8); <line6> job.setDefinition(new CpsFlowDefinition(jenkinsFile, true)); <line7> WorkflowRun build = job.scheduleBuild2(0).waitForStart(); <line8> long start = System.currentTimeMillis(); <line9> while (build.isBuilding()) { <line10> List<Map<String, String>> nodes = <line11> get(""/organizations/jenkins/pipelines/p/runs/1/nodes/"", List.class); <line12> if (nodes.size() >= 4) { <line13> Optional<Map<String, String>> optionalMap = findNodeMap(nodes, ""Nested B-1""); <line14> if (optionalMap.isPresent()) { <line15> long now = System.currentTimeMillis(); <line16> if (TimeUnit.SECONDS.convert(now - start, TimeUnit.MILLISECONDS) >= 10) { <line17> continue; <line18> } <line19> assertEquals( <line20> build.isBuilding() <line21> ? BlueRun.BlueRunState.RUNNING.name() <line22> : BlueRun.BlueRunState.FINISHED, <line23> optionalMap.get().get(""state"")); <line24> } <line25> } <line26> Thread.sleep(500); <line27> } <line28> List<Map<String, String>> nodes = <line29> get(""/organizations/jenkins/pipelines/p/runs/1/nodes/"", List.class); <line30> Optional<Map<String, String>> optionalMap = findNodeMap(nodes, ""Nested B-1""); <line31> if (optionalMap.isPresent()) { <line32> assertEquals(BlueRun.BlueRunState.FINISHED.name(), optionalMap.get().get(""state"")); <line33> } <line34> j.assertBuildStatus(Result.SUCCESS, build); <line35> } <line36> } <line37> "	 <line9>	No
public class A { <line0> private boolean addVolume(String volumeRoot, StorageType storageType) { <line1> String hddsRoot = HddsVolumeUtil.getHddsRoot(volumeRoot); <line2> boolean success; <line3> this.writeLock(); <line4> try { <line5> if (volumeMap.containsKey(hddsRoot)) { <line6> success = false; <line7> } else { <line8> if (failedVolumeMap.containsKey(hddsRoot)) { <line9> failedVolumeMap.remove(hddsRoot); <line10> } <line11> HddsVolume hddsVolume = createVolume(volumeRoot, storageType); <line12> volumeMap.put(hddsVolume.getHddsRootDir().getPath(), hddsVolume); <line13> volumeStateMap.get(hddsVolume.getStorageType()).add(hddsVolume); <line14> success = true; <line15> } <line16> } catch (IOException ex) { <line17> success = false; <line18> } finally { <line19> this.writeUnlock(); <line20> } <line21> return success; <line22> } <line23> } <line24> 	 <line6>	Yes
"public class A { <line0> @Override <line1> public Set<String> addArtifactToCatalog( <line2> CamelCatalog camelCatalog, String groupId, String artifactId, String version) { <line3> final Set<String> names = new LinkedHashSet<>(); <line4> try { <line5> if (cacheDirectory != null) { <line6> if (log) { <line7> } <line8> System.setProperty(""grape.root"", cacheDirectory); <line9> } <line10> Grape.setEnableAutoDownload(true); <line11> try (final GroovyClassLoader classLoader = new GroovyClassLoader()) { <line12> Map<String, Object> param = new HashMap<>(); <line13> param.put(""classLoader"", classLoader); <line14> param.put(""group"", groupId); <line15> param.put(""module"", artifactId); <line16> param.put(""version"", version); <line17> param.put(""validate"", false); <line18> param.put(""transitive"", false); <line19> if (log) { <line20> } <line21> Grape.grab(param); <line22> if (camelCatalog != null) { <line23> scanCamelComponents(camelCatalog, classLoader, names); <line24> } <line25> } <line26> } catch (Exception e) { <line27> if (log) { <line28> } <line29> } <line30> return names; <line31> } <line32> } <line33> "	 <line11>	No
public class A { <line0> @Override <line1> public StreamsResultSet readCurrent() { <line2> StreamsResultSet result; <line3> try { <line4> lock.readLock().lock(); <line5> result = new StreamsResultSet(persistQueue); <line6> persistQueue = constructQueue(); <line7> } finally { <line8> lock.readLock().unlock(); <line9> } <line10> return result; <line11> } <line12> } <line13> 	 <line3>	Yes
public class A { <line0> @Override <line1> public void evict(TenantId tenantId, DeviceProfileId profileId) { <line2> DeviceProfile oldProfile = deviceProfilesMap.remove(profileId); <line3> DeviceProfile newProfile = get(tenantId, profileId); <line4> if (newProfile != null) { <line5> notifyProfileListeners(newProfile); <line6> } <line7> } <line8> } <line9> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public void handle(HttpExchange exchange) { <line2> Optional<PrometheusMeterRegistry> registry = <line3> Metrics.globalRegistry.getRegistries().stream() <line4> .filter(meterRegistry -> meterRegistry instanceof PrometheusMeterRegistry) <line5> .map(meterRegistry -> (PrometheusMeterRegistry) meterRegistry) <line6> .findFirst(); <line7> if (registry.isPresent()) { <line8> this.render(registry.get().scrape(), exchange, HttpStatus.SC_OK); <line9> } else { <line10> this.render(""Not Found"", exchange, HttpStatus.SC_NOT_FOUND); <line11> } <line12> } <line13> } <line14> "	 <line10>	Yes
"public class A { <line0> @PatchMapping(value = CommonConstants.PATH_ID) <line1> @ApiOperation(value = ""Update partially provider"") <line2> @ResponseStatus(HttpStatus.OK) <line3> public IdentityProviderDto patchProvider( <line4> final @RequestBody Map<String, Object> provider, final @PathVariable String id) { <line5> ParameterChecker.checkParameter(""Parameters are mandatory : "", provider, id); <line6> return service.patch(buildUiHttpContext(), provider, null, null, id, ProviderPatchType.JSON); <line7> } <line8> } <line9> "	 <line7>	No
"public class A { <line0> @Override <line1> public SimpleFeature apply(final CSVRecord input) { <line2> if (input == null) { <line3> return null; <line4> } <line5> final String entityId = input.get(""entityId""); <line6> final double cloudCover = Double.parseDouble(input.get(""cloudCover"")); <line7> final String processingLevel = input.get(""processingLevel""); <line8> final int path = Integer.parseInt(input.get(""path"")); <line9> final int row = Integer.parseInt(input.get(""row"")); <line10> final String downloadUrl = input.get(""download_url""); <line11> final MultiPolygon shape = wrs2Geometry.getGeometry(path, row); <line12> featureBuilder.add(shape); <line13> featureBuilder.add(entityId); <line14> Date aquisitionDate; <line15> final SimpleDateFormat sdf = new SimpleDateFormat(AQUISITION_DATE_FORMAT); <line16> try { <line17> aquisitionDate = sdf.parse(input.get(""acquisitionDate"")); <line18> featureBuilder.add(aquisitionDate); <line19> } catch (final ParseException e) { <line20> featureBuilder.add(null); <line21> } <line22> featureBuilder.add(cloudCover); <line23> featureBuilder.add(processingLevel); <line24> featureBuilder.add(path); <line25> featureBuilder.add(row); <line26> featureBuilder.add(downloadUrl); <line27> return featureBuilder.buildFeature(entityId); <line28> } <line29> } <line30> "	 <line4>	No
"public class A { <line0> private PipeLine createPipeLineFromPropertiesFile(File propertiesFile) <line1> throws IOException, ConfigurationException { <line2> Properties props = new Properties(); <line3> FileInputStream fis = null; <line4> try { <line5> fis = new FileInputStream(propertiesFile); <line6> props.load(fis); <line7> } finally { <line8> try { <line9> if (fis != null) { <line10> fis.close(); <line11> } <line12> } catch (IOException e) { <line13> } <line14> } <line15> PipeLine pipeLine = new PipeLine(); <line16> String inputXsd = null; <line17> if (props.containsKey(""input.xsd"")) { <line18> inputXsd = props.getProperty(""input.xsd""); <line19> String inputNamespace = props.getProperty(""input.namespace""); <line20> String inputRoot = props.getProperty(""input.root""); <line21> String inputCmhString = props.getProperty(""input.cmh"", ""1""); <line22> int inputCmh = Integer.parseInt(inputCmhString); <line23> File inputXsdFile = new File(propertiesFile.getParent(), inputXsd); <line24> EsbSoapValidator inputValidator = <line25> createValidator(inputXsdFile, inputNamespace, inputRoot, 1, inputCmh); <line26> pipeLine.setInputValidator(inputValidator); <line27> } <line28> if (props.containsKey(""output.xsd"")) { <line29> String outputXsd = props.getProperty(""output.xsd""); <line30> String outputNamespace = props.getProperty(""output.namespace""); <line31> String outputRoot = props.getProperty(""output.root""); <line32> String outputCmhString = props.getProperty(""output.cmh"", ""1""); <line33> int outputCmh = Integer.parseInt(outputCmhString); <line34> File outputXsdFile = new File(propertiesFile.getParent(), outputXsd); <line35> int rootPosition; <line36> if (inputXsd != null && inputXsd.equalsIgnoreCase(outputXsd)) { <line37> rootPosition = 2; <line38> } else { <line39> rootPosition = 1; <line40> } <line41> EsbSoapValidator outputValidator = <line42> createValidator(outputXsdFile, outputNamespace, outputRoot, rootPosition, outputCmh); <line43> pipeLine.setOutputValidator(outputValidator); <line44> } <line45> return pipeLine; <line46> } <line47> } <line48> "	 <line7>	No
public class A { <line0> private Field convertToField(String content) { <line1> try { <line2> switch (type) { <line3> case Type.INTEGER: <line4> case Type.LONG: <line5> case Type.UNSIGNED_LONG: <line6> long lvalue = Long.parseLong(content); <line7> return new LongField(fieldName, lvalue, LongField.TYPE_STORED); <line8> case Type.INT: <line9> case Type.UNSIGNED_INT: <line10> case Type.SHORT: <line11> case Type.UNSIGNED_SHORT: <line12> int ivalue = Integer.parseInt(content); <line13> return new IntField(fieldName, ivalue, IntField.TYPE_STORED); <line14> case Type.DECIMAL: <line15> case Type.DOUBLE: <line16> double dvalue = Double.parseDouble(content); <line17> return new DoubleField(fieldName, dvalue, DoubleField.TYPE_STORED); <line18> case Type.FLOAT: <line19> float fvalue = Float.parseFloat(content); <line20> return new FloatField(fieldName, fvalue, FloatField.TYPE_STORED); <line21> case Type.DATE: <line22> DateValue dv = new DateValue(content); <line23> long dl = dateToLong(dv); <line24> return new LongField(fieldName, dl, LongField.TYPE_STORED); <line25> case Type.TIME: <line26> TimeValue tv = new TimeValue(content); <line27> long tl = timeToLong(tv); <line28> return new LongField(fieldName, tl, LongField.TYPE_STORED); <line29> case Type.DATE_TIME: <line30> DateTimeValue dtv = new DateTimeValue(content); <line31> String dateStr = dateTimeToString(dtv); <line32> return new TextField(fieldName, dateStr, Field.Store.YES); <line33> default: <line34> return new TextField(fieldName, content, store ? Field.Store.YES : Field.Store.NO); <line35> } <line36> } catch (NumberFormatException | XPathException e) { <line37> } <line38> return null; <line39> } <line40> } <line41> 	 <line37>	Yes
"public class A { <line0> protected void configureChannels() { <line1> Channel channel; <line2> ChannelTypeUID channelTypeUID; <line3> ChannelUID channelUID; <line4> List<Channel> channelList = new ArrayList<>(); <line5> List<Channel> existingChannels = getThing().getChannels(); <line6> if (!existingChannels.isEmpty()) { <line7> ThingBuilder thingBuilder = editThing(); <line8> thingBuilder.withChannels(channelList); <line9> updateThing(thingBuilder.build()); <line10> } <line11> ThingBuilder thingBuilder = editThing(); <line12> for (KeypadComponent component : buttonList) { <line13> channelTypeUID = <line14> new ChannelTypeUID(BINDING_ID, advancedChannels ? ""buttonAdvanced"" : ""button""); <line15> channelUID = new ChannelUID(getThing().getUID(), component.channel()); <line16> channel = <line17> ChannelBuilder.create(channelUID, ""Switch"") <line18> .withType(channelTypeUID) <line19> .withLabel(component.description()) <line20> .build(); <line21> channelList.add(channel); <line22> } <line23> for (KeypadComponent component : ledList) { <line24> channelTypeUID = <line25> new ChannelTypeUID( <line26> BINDING_ID, advancedChannels ? ""ledIndicatorAdvanced"" : ""ledIndicator""); <line27> channelUID = new ChannelUID(getThing().getUID(), component.channel()); <line28> channel = <line29> ChannelBuilder.create(channelUID, ""Switch"") <line30> .withType(channelTypeUID) <line31> .withLabel(component.description()) <line32> .build(); <line33> channelList.add(channel); <line34> } <line35> for (KeypadComponent component : cciList) { <line36> channelTypeUID = new ChannelTypeUID(BINDING_ID, ""cciState""); <line37> channelUID = new ChannelUID(getThing().getUID(), component.channel()); <line38> channel = <line39> ChannelBuilder.create(channelUID, ""Contact"") <line40> .withType(channelTypeUID) <line41> .withLabel(component.description()) <line42> .build(); <line43> channelList.add(channel); <line44> } <line45> thingBuilder.withChannels(channelList); <line46> updateThing(thingBuilder.build()); <line47> } <line48> } <line49> "	 <line0>	No
public class A { <line0> protected E getValidTokenForUser(User user, Integer expirationTimeInMinutes) <line1> throws NoSuchMethodException, SecurityException, InstantiationException, <line2> IllegalAccessException, IllegalArgumentException, InvocationTargetException { <line3> E userToken = findByUser(user); <line4> if (userToken != null) { <line5> if (userToken.expiresWithin(EXPIRY_THRESHOLD_MINUTES)) { <line6> dao.delete(userToken); <line7> } else { <line8> return userToken; <line9> } <line10> } <line11> userToken = buildConcreteInstance(user, expirationTimeInMinutes); <line12> dao.saveOrUpdate(userToken); <line13> final String tokenType = userToken.getClass().getSimpleName(); <line14> return userToken; <line15> } <line16> } <line17> 	 <line4>	No
"public class A { <line0> @Override <line1> public void run(String... args) { <line2> securityUtil.logInAs(""system""); <line3> Page<ProcessDefinition> processDefinitionPage = <line4> processRuntime.processDefinitions(Pageable.of(0, 10)); <line5> for (ProcessDefinition pd : processDefinitionPage.getContent()) { <line6> } <line7> } <line8> } <line9> "	 <line6>	Yes
public class A { <line0> private void test_streamed_triples_bad(final String data, int expected) <line1> throws TimeoutException, InterruptedException { <line2> final PipedRDFIterator<Triple> it = new PipedRDFIterator<>(); <line3> final PipedTriplesStream out = new PipedTriplesStream(it); <line4> Runnable runParser = <line5> new Runnable() { <line6> @Override <line7> public void run() { <line8> Charset utf8 = StandardCharsets.UTF_8; <line9> ByteArrayInputStream input = new ByteArrayInputStream(data.getBytes(utf8)); <line10> try { <line11> RDFParser.source(input).lang(Lang.TTL).parse(out); <line12> } catch (Throwable t) { <line13> } <line14> return; <line15> } <line16> }; <line17> Callable<Integer> consumeTriples = <line18> new Callable<Integer>() { <line19> @Override <line20> public Integer call() { <line21> int count = 0; <line22> while (it.hasNext()) { <line23> it.next(); <line24> count++; <line25> } <line26> return count; <line27> } <line28> }; <line29> Future<?> genResult = executor.submit(runParser); <line30> Future<Integer> result = executor.submit(consumeTriples); <line31> Integer count = 0; <line32> try { <line33> count = result.get(10, TimeUnit.SECONDS); <line34> } catch (TimeoutException e) { <line35> try { <line36> genResult.get(); <line37> } catch (ExecutionException ex) { <line38> } <line39> throw e; <line40> } catch (ExecutionException e) { <line41> Assert.fail(e.getMessage()); <line42> } <line43> Assert.assertEquals(expected, (int) count); <line44> } <line45> } <line46> 	 <line38>	Yes
"public class A { <line0> public static void launchDAG( <line1> final IRDAG dag, final Map<Serializable, Object> broadcastVariables, final String jobId) { <line2> if (!isSetUp) { <line3> try { <line4> setup(new String[] {""-job_id"", jobId}); <line5> } catch (Exception e) { <line6> throw new RuntimeException(e); <line7> } <line8> } <line9> try { <line10> driverReadyLatch.await(); <line11> } catch (final InterruptedException e) { <line12> LOG.warn(INTERRUPTED, e); <line13> Thread.currentThread().interrupt(); <line14> } <line15> serializedDAG = Base64.getEncoder().encodeToString(SerializationUtils.serialize(dag)); <line16> if (jobDoneLatch.getCount() == 0) { <line17> jobDoneLatch = new CountDownLatch(1); <line18> } <line19> driverRPCServer.send( <line20> ControlMessage.ClientToDriverMessage.newBuilder() <line21> .setType(ControlMessage.ClientToDriverMessageType.LaunchDAG) <line22> .setLaunchDAG( <line23> ControlMessage.LaunchDAGMessage.newBuilder() <line24> .setDag(serializedDAG) <line25> .setBroadcastVars( <line26> ByteString.copyFrom( <line27> SerializationUtils.serialize((Serializable) broadcastVariables))) <line28> .build()) <line29> .build()); <line30> try { <line31> jobDoneLatch.await(); <line32> } catch (final InterruptedException e) { <line33> Thread.currentThread().interrupt(); <line34> throw new RuntimeException(e); <line35> } finally { <line36> shutdown(); <line37> } <line38> } <line39> } <line40> "	 <line24>	No
public class A { <line0> protected ProcessBuilder createProcessBuilder(List<String> command, EnvironmentDescriptor env) { <line1> ProcessBuilder processBuilder = new ProcessBuilder(command); <line2> processBuilder.directory(new File(env.getWorkingDirectory())); <line3> processBuilder.environment().putAll(env.getParameters()); <line4> processBuilder.redirectErrorStream(true); <line5> return processBuilder; <line6> } <line7> } <line8> 	 <line2>	Yes
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Transfer""}, <line2> description = ""missing column min_transfer_time"", <line3> priority = 217) <line4> public void verifyTest_2_4_1() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""transfer_4_1"", GTFS_1_GTFS_Common_15, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 5, ""detail count""); <line10> int i = 2; <line11> for (CheckPointErrorReport detail : getDetails(context, result)) { <line12> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line13> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line14> Assert.assertEquals( <line15> detail.getSource().getFile().getFilename(), <line16> ""transfers.txt"", <line17> ""detail must refer bad file""); <line18> Assert.assertEquals( <line19> detail.getSource().getFile().getLineNumber(), <line20> Integer.valueOf(i++), <line21> ""detail must refer bad line""); <line22> } <line23> } <line24> } <line25> "	 <line13>	No
"public class A { <line0> @Override <line1> public void delete(BulkActionContext bac, boolean ignoreChecks, boolean recursive) { <line2> if (!ignoreChecks) { <line3> if (getProject().getBaseNode().getUuid().equals(getUuid())) { <line4> throw error(METHOD_NOT_ALLOWED, ""node_basenode_not_deletable""); <line5> } <line6> } <line7> if (log.isDebugEnabled()) { <line8> } <line9> if (recursive) { <line10> for (Node child : getChildren()) { <line11> child.delete(bac); <line12> bac.process(); <line13> } <line14> } <line15> for (NodeGraphFieldContainer container : getGraphFieldContainers(INITIAL)) { <line16> container.delete(bac); <line17> } <line18> if (log.isDebugEnabled()) { <line19> } <line20> addReferenceUpdates(bac); <line21> bac.add(onDeleted(getUuid(), getSchemaContainer(), null, null, null)); <line22> getElement().remove(); <line23> bac.process(); <line24> } <line25> } <line26> "	 <line23>	No
public class A { <line0> private static int translateCategory(CompilerMessageCategory category) { <line1> if (CompilerMessageCategory.ERROR.equals(category)) { <line2> return MessageCategory.ERROR; <line3> } <line4> if (CompilerMessageCategory.WARNING.equals(category)) { <line5> return MessageCategory.WARNING; <line6> } <line7> if (CompilerMessageCategory.STATISTICS.equals(category)) { <line8> return MessageCategory.STATISTICS; <line9> } <line10> if (CompilerMessageCategory.INFORMATION.equals(category)) { <line11> return MessageCategory.INFORMATION; <line12> } <line13> return 0; <line14> } <line15> } <line16> 	 <line8>	No
"public class A { <line0> public static void update() { <line1> final String jsonSerialiserClass = <line2> System.getProperty(JSON_SERIALISER_CLASS_KEY, DEFAULT_SERIALISER_CLASS_NAME); <line3> final JSONSerialiser newInstance; <line4> try { <line5> newInstance = <line6> Class.forName(jsonSerialiserClass).asSubclass(JSONSerialiser.class).newInstance(); <line7> } catch (final InstantiationException | IllegalAccessException | ClassNotFoundException e) { <line8> throw new IllegalArgumentException( <line9> ""Property "" <line10> + JSON_SERIALISER_CLASS_KEY <line11> + "" must be set to a class that is a sub class of "" <line12> + JSONSerialiser.class.getName() <line13> + "". This class is not valid: "" <line14> + jsonSerialiserClass, <line15> e); <line16> } <line17> final String moduleFactories = System.getProperty(JSON_SERIALISER_MODULES, """"); <line18> final Set<String> factoryClasses = Sets.newHashSet(moduleFactories.split("","")); <line19> factoryClasses.remove(""""); <line20> for (final String factoryClass : factoryClasses) { <line21> final JSONSerialiserModules factory; <line22> try { <line23> factory = Class.forName(factoryClass).asSubclass(JSONSerialiserModules.class).newInstance(); <line24> } catch (final InstantiationException | IllegalAccessException | ClassNotFoundException e) { <line25> throw new IllegalArgumentException( <line26> ""Property "" <line27> + JSON_SERIALISER_MODULES <line28> + "" must be set to a csv of classes that are a sub class of "" <line29> + JSONSerialiserModules.class.getName() <line30> + "". These classes are not valid: "" <line31> + factoryClass, <line32> e); <line33> } <line34> final List<Module> modules = factory.getModules(); <line35> if (null != modules) { <line36> newInstance.mapper.registerModules(modules); <line37> } <line38> } <line39> newInstance.mapper.configure( <line40> DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <line41> Boolean.parseBoolean(System.getProperty(STRICT_JSON, STRICT_JSON_DEFAULT_STR))); <line42> instance = newInstance; <line43> } <line44> } <line45> "	 <line43>	Yes
"public class A { <line0> @SuppressWarnings(""java:S2445"") <line1> private void sendHeartbeats(Collection<Node> nodes) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> synchronized (nodes) { <line5> for (Node node : nodes) { <line6> if (node.equals(localMember.getThisNode())) { <line7> continue; <line8> } <line9> if (Thread.currentThread().isInterrupted()) { <line10> Thread.currentThread().interrupt(); <line11> return; <line12> } <line13> if (localMember.getCharacter() != NodeCharacter.LEADER) { <line14> return; <line15> } <line16> if (ClusterDescriptor.getInstance().getConfig().isUseAsyncServer()) { <line17> sendHeartbeatAsync(node); <line18> } else { <line19> sendHeartbeatSync(node); <line20> } <line21> } <line22> } <line23> } <line24> } <line25> "	 <line16>	No
"public class A { <line0> @NamespacePermission( <line1> fields = ""#businessObjectDefinitionTagKey.businessObjectDefinitionKey.namespace"", <line2> permissions = { <line3> NamespacePermissionEnum.WRITE_DESCRIPTIVE_CONTENT, <line4> NamespacePermissionEnum.WRITE <line5> }) <line6> @Override <line7> public BusinessObjectDefinitionTag deleteBusinessObjectDefinitionTag( <line8> BusinessObjectDefinitionTagKey businessObjectDefinitionTagKey) { <line9> validateBusinessObjectDefinitionTagKey(businessObjectDefinitionTagKey); <line10> BusinessObjectDefinitionTagEntity businessObjectDefinitionTagEntity = <line11> getBusinessObjectDefinitionTagEntity(businessObjectDefinitionTagKey); <line12> businessObjectDefinitionTagDao.delete(businessObjectDefinitionTagEntity); <line13> BusinessObjectDefinitionEntity businessObjectDefinitionEntity = <line14> businessObjectDefinitionDaoHelper.getBusinessObjectDefinitionEntity( <line15> businessObjectDefinitionTagKey.getBusinessObjectDefinitionKey()); <line16> searchIndexUpdateHelper.modifyBusinessObjectDefinitionInSearchIndex( <line17> businessObjectDefinitionEntity, SEARCH_INDEX_UPDATE_TYPE_UPDATE); <line18> return createBusinessObjectDefinitionTagFromEntity(businessObjectDefinitionTagEntity); <line19> } <line20> } <line21> "	 <line0>	No
"public class A { <line0> protected void addCommandToResponse( <line1> final Response response, final CommandContext commandContext, final Span currentSpan) { <line2> final Command command = commandContext.getCommand(); <line3> final OptionSet options = response.getOptions(); <line4> options.addLocationQuery(Constants.HEADER_COMMAND + ""="" + command.getName()); <line5> if (command.isOneWay()) { <line6> options.setLocationPath(CommandConstants.COMMAND_ENDPOINT); <line7> } else { <line8> options.setLocationPath(CommandConstants.COMMAND_RESPONSE_ENDPOINT); <line9> } <line10> currentSpan.setTag(Constants.HEADER_COMMAND, command.getName()); <line11> commandContext.getTracingSpan().log(""forwarding command to device in CoAP response""); <line12> if (command.isTargetedAtGateway()) { <line13> options.addLocationPath(command.getTenant()); <line14> options.addLocationPath(command.getDeviceId()); <line15> currentSpan.setTag(Constants.HEADER_COMMAND_TARGET_DEVICE, command.getDeviceId()); <line16> } <line17> if (!command.isOneWay()) { <line18> options.addLocationPath(command.getRequestId()); <line19> currentSpan.setTag(Constants.HEADER_COMMAND_REQUEST_ID, command.getRequestId()); <line20> } <line21> final int formatCode = MediaTypeRegistry.parse(command.getContentType()); <line22> if (formatCode != MediaTypeRegistry.UNDEFINED) { <line23> options.setContentFormat(formatCode); <line24> } else { <line25> currentSpan.log( <line26> ""ignoring unknown content type ["" + command.getContentType() + ""] of command""); <line27> } <line28> Optional.ofNullable(command.getPayload()).ifPresent(b -> response.setPayload(b.getBytes())); <line29> } <line30> } <line31> "	 <line11>	Yes
public class A { <line0> @Before <line1> public void setUp() throws Exception { <line2> IOHelper.deleteFile(schedulerStoreDir); <line3> createBroker(); <line4> broker.start(); <line5> broker.waitUntilStarted(); <line6> schedulerStore = (JobSchedulerStoreImpl) broker.getJobSchedulerStore(); <line7> } <line8> } <line9> 	 <line3>	Yes
"public class A { <line0> private void createClickLogCondition(final SearchLogPager pager, final ClickLogCB cb) { <line1> if (StringUtil.isNotBlank(pager.queryId)) { <line2> cb.query().setQueryId_Term(pager.queryId); <line3> } <line4> if (StringUtil.isNotBlank(pager.userSessionId)) { <line5> cb.query().setUserSessionId_Term(pager.userSessionId); <line6> } <line7> if (StringUtil.isNotBlank(pager.requestedTimeRange)) { <line8> final String[] values = pager.requestedTimeRange.split("" - ""); <line9> final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(YYYY_MM_DD_HH_MM); <line10> try { <line11> if (values.length > 0) { <line12> cb.query().setRequestedAt_GreaterEqual(LocalDateTime.parse(values[0], formatter)); <line13> } <line14> if (values.length > 1) { <line15> cb.query().setRequestedAt_LessEqual(LocalDateTime.parse(values[1], formatter)); <line16> } <line17> } catch (final Exception e) { <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } <line21> } <line22> } <line23> } <line24> "	 <line10>	No
public class A { <line0> public void setResourceState( <line1> String resourceName, <line2> ExternalView externalView, <line3> IdealState idealState, <line4> StateModelDefinition stateModelDef) { <line5> try { <line6> ResourceMonitor resourceMonitor = getOrCreateResourceMonitor(resourceName); <line7> if (resourceMonitor != null) { <line8> resourceMonitor.updateResourceState(externalView, idealState, stateModelDef); <line9> } <line10> } catch (Exception e) { <line11> } <line12> } <line13> } <line14> 	 <line10>	No
public class A { <line0> @Override <line1> public ProjectRecord getProject(Long idProject) { <line2> ProjectRecord record = null; <line3> try { <line4> record = <line5> create.selectFrom(Tables.PROJECT).where(Tables.PROJECT.ID.equal(idProject)).fetchOne(); <line6> if (record == null) { <line7> return null; <line8> } <line9> } catch (org.jooq.exception.DataAccessException sqex) { <line10> return null; <line11> } catch (Exception ex) { <line12> return null; <line13> } <line14> ProjectRecord prjRecord = alterReadRecord(record); <line15> if (prjRecord == null) { <line16> return null; <line17> } <line18> return prjRecord; <line19> } <line20> } <line21> 	 <line14>	Yes
public class A { <line0> private void prepareExtendedRandomLength(ExtendedRandomExtensionMessage msg) { <line1> msg.setExtendedRandomLength(msg.getExtendedRandom().getValue().length); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> private List<AttributeData> getAttributeDataList(SearchResultEntry entry) { <line1> if (entry == null) { <line2> return null; <line3> } <line4> List<AttributeData> result = new ArrayList<AttributeData>(); <line5> for (Attribute attribute : entry.getAttributes()) { <line6> String[] attributeValueStrings = NO_STRINGS; <line7> String attributeName = attribute.getName(); <line8> if (LOG.isTraceEnabled()) { <line9> if (attribute.needsBase64Encoding()) { <line10> } <line11> } <line12> attributeValueStrings = attribute.getValues(); <line13> if (attribute.needsBase64Encoding()) { <line14> boolean binaryAttribute = getOperationService().isBinaryAttribute(attributeName); <line15> boolean certificateAttribute = getOperationService().isCertificateAttribute(attributeName); <line16> if (binaryAttribute || certificateAttribute) { <line17> byte[][] attributeValues = attribute.getValueByteArrays(); <line18> if (attributeValues != null) { <line19> attributeValueStrings = new String[attributeValues.length]; <line20> for (int i = 0; i < attributeValues.length; i++) { <line21> attributeValueStrings[i] = Base64.encodeBase64String(attributeValues[i]); <line22> } <line23> } <line24> } <line25> if (certificateAttribute) { <line26> attributeName = getOperationService().getCertificateAttributeName(attributeName); <line27> } <line28> } <line29> boolean multiValued = attributeValueStrings.length > 1; <line30> AttributeData tmpAttribute = <line31> new AttributeData(attributeName, attributeValueStrings, multiValued); <line32> result.add(tmpAttribute); <line33> } <line34> return result; <line35> } <line36> } <line37> 	 <line10>	Yes
public class A { <line0> @Override <line1> public Boolean call(Realm realm) { <line2> try { <line3> if (list != null) { <line4> for (int i = 0; i < list.size(); i++) { <line5> AppItemOnlineVo vo = list.get(i); <line6> NativeAppDataRealmObject realmObject = new NativeAppDataRealmObject(); <line7> realmObject.setId(vo.getId()); <line8> realmObject.setName(vo.getName()); <line9> realmObject.setKey(vo.getKey()); <line10> realmObject.setEnable(vo.getEnable()); <line11> realm.copyToRealm(realmObject); <line12> } <line13> } <line14> } catch (Exception e) { <line15> return false; <line16> } <line17> return true; <line18> } <line19> } <line20> 	 <line14>	No
public class A { <line0> @Override <line1> public STypeIR caseAUnresolvedType(AUnresolvedType node, IRInfo question) <line2> throws AnalysisException { <line3> return new AUnknownTypeIR(); <line4> } <line5> } <line6> 	 <line3>	Yes
"public class A { <line0> private void deleteFileFromList(String deleteFileListName) { <line1> try (BufferedReader br = <line2> new BufferedReader( <line3> new InputStreamReader( <line4> new FileInputStream(deleteFileListName), StandardCharsets.UTF_8)); ) { <line5> String line; <line6> while ((line = br.readLine()) != null) { <line7> if (line.contains("".."")) { <line8> } else { <line9> String fullPath = TARGET_DIR + File.separator + line; <line10> File file = new File(fullPath); <line11> if (file.exists()) { <line12> if (file.delete()) { <line13> } else { <line14> } <line15> } <line16> } <line17> } <line18> } catch (SecurityException | IOException e) { <line19> } <line20> } <line21> } <line22> "	 <line12>	No
"public class A { <line0> private boolean sendCodeViaEmail() { <line1> try { <line2> backend.sendCode(settings.emailSecurityCodeMsgTemplate, false); <line3> return true; <line4> } catch (Exception e) { <line5> NotificationPopup.showError( <line6> msg.getMessage(""error""), msg.getMessage(""CredentialReset.resetNotPossible"")); <line7> onCancel(); <line8> return false; <line9> } <line10> } <line11> } <line12> "	 <line5>	Yes
"public class A { <line0> public void shortExample2() throws Exception { <line1> String sequence = ""QIKDLLVSSSTDLDTTLVLVNAIYFKGMWKTAFNAEDTREMPFHVTKQESKPVQMMCMNNSFNVATLPAE""; <line2> Map<ATTRIBUTE, Map<TRANSITION, Double>> attribute2Transition2Double = <line3> ProfeatProperties.getTransition(sequence); <line4> for (ATTRIBUTE a : attribute2Transition2Double.keySet()) { <line5> } <line6> } <line7> } <line8> "	 <line1>	No
"public class A { <line0> @PayloadRoot(localPart = ""SwitchConfigurationAsyncRequest"", namespace = NAMESPACE) <line1> @ResponsePayload <line2> public SwitchConfigurationResponse getSwitchConfigurationResponse( <line3> @OrganisationIdentification final String organisationIdentification, <line4> @RequestPayload final SwitchConfigurationAsyncRequest request) <line5> throws OsgpException { <line6> final SwitchConfigurationResponse response = new SwitchConfigurationResponse(); <line7> try { <line8> final ResponseMessage message = <line9> this.configurationManagementService.dequeueSwitchConfigurationResponse( <line10> request.getAsyncRequest().getCorrelationUid()); <line11> if (message != null) { <line12> response.setResult(OsgpResultType.fromValue(message.getResult().getValue())); <line13> } else { <line14> } <line15> } catch (final Exception e) { <line16> this.handleException(e); <line17> } <line18> return response; <line19> } <line20> } <line21> "	 <line19>	No
public class A { <line0> public Optional<SipStackProcessor> createSipStackProcessor( <line1> String name, Room r, ISipCallbacks callbacks) throws Exception { <line2> if (factory == null || !isSipEnabled() || !r.isSipEnabled()) { <line3> return Optional.empty(); <line4> } <line5> int port; <line6> synchronized (ports) { <line7> int free = ports.nextClearBit(0); <line8> ports.flip(free); <line9> port = minLocalWsPort + free; <line10> } <line11> return Optional.of(new SipStackProcessor(this, name, port, callbacks)); <line12> } <line13> } <line14> 	 <line12>	No
"public class A { <line0> @Override <line1> public void reduce( <line2> Text key, <line3> Iterable<BytesWritable> values, <line4> Reducer<Text, BytesWritable, Text, Text>.Context context) <line5> throws IOException, InterruptedException { <line6> long startTime = new Date().getTime(); <line7> Configuration conf = context.getConfiguration(); <line8> initialMaxDocsSetSize = conf.getInt(""INITIAL_MAX_DOCS_SET_SIZE"", initialMaxDocsSetSize); <line9> process(key, context, values, initialMaxDocsSetSize); <line10> } <line11> } <line12> "	 <line8>	No
public class A { <line0> @Override <line1> public void removeItemMetadata(String name) { <line2> getAll().stream() <line3> .filter(MetadataPredicates.ofItem(name)) <line4> .map(Metadata::getUID) <line5> .forEach(this::remove); <line6> } <line7> } <line8> 	 <line2>	Yes
"public class A { <line0> protected List<NameValuePair> getUpdateMethodParameters( <line1> QueryLanguage ql, <line2> String update, <line3> String baseURI, <line4> Dataset dataset, <line5> boolean includeInferred, <line6> int maxQueryTime, <line7> Binding... bindings) { <line8> List<NameValuePair> queryParams = new ArrayList<>(); <line9> if (update != null) { <line10> if (baseURI != null && !baseURI.isEmpty()) { <line11> update = ""BASE <"" + baseURI + ""> \n"" + update; <line12> } <line13> queryParams.add(new BasicNameValuePair(Protocol.UPDATE_PARAM_NAME, update)); <line14> } <line15> if (dataset != null) { <line16> if (dataset.getDefaultRemoveGraphs().size() > 0) { <line17> if (!(dataset.getDefaultRemoveGraphs().equals(dataset.getDefaultGraphs()))) { <line18> } <line19> for (IRI graphURI : dataset.getDefaultRemoveGraphs()) { <line20> if (dataset.getDefaultInsertGraph() != null) { <line21> if (!dataset.getDefaultInsertGraph().equals(graphURI)) { <line22> } <line23> } <line24> queryParams.add( <line25> new BasicNameValuePair(Protocol.USING_GRAPH_PARAM_NAME, String.valueOf(graphURI))); <line26> } <line27> } <line28> if (dataset.getDefaultInsertGraph() != null) { <line29> if (!dataset.getDefaultGraphs().isEmpty()) { <line30> if (!(dataset.getDefaultGraphs().size() == 1 <line31> && dataset.getDefaultGraphs().contains(dataset.getDefaultInsertGraph()))) { <line32> } <line33> } <line34> queryParams.add( <line35> new BasicNameValuePair( <line36> Protocol.USING_GRAPH_PARAM_NAME, String.valueOf(dataset.getDefaultInsertGraph()))); <line37> } <line38> for (IRI defaultGraphURI : dataset.getDefaultGraphs()) { <line39> queryParams.add( <line40> new BasicNameValuePair( <line41> Protocol.USING_GRAPH_PARAM_NAME, String.valueOf(defaultGraphURI))); <line42> } <line43> for (IRI namedGraphURI : dataset.getNamedGraphs()) { <line44> queryParams.add( <line45> new BasicNameValuePair( <line46> Protocol.USING_NAMED_GRAPH_PARAM_NAME, String.valueOf(namedGraphURI))); <line47> } <line48> } <line49> return queryParams; <line50> } <line51> } <line52> "	 <line14>	Yes
"public class A { <line0> @Test <line1> public void testFilterClassifierApp() throws FileNotFoundException, IOException { <line2> Logger logger = LoggerFactory.getLogger(FilterClassifierAppTest.class); <line3> LocalMode lm = LocalMode.newInstance(); <line4> Configuration conf = new Configuration(); <line5> InputStream is = new FileInputStream(""src/site/conf/dt-site-testbench.xml""); <line6> conf.addResource(is); <line7> conf.get(""dt.application.FilterClassifier.operator.hmapOper.keys""); <line8> conf.get(""dt.application.FilterClassifier.operator.hmapOper.numKeys""); <line9> try { <line10> lm.prepareDAG(new FilterClassifierApp(), conf); <line11> LocalMode.Controller lc = lm.getController(); <line12> lc.run(20000); <line13> } catch (Exception ex) { <line14> } <line15> is.close(); <line16> } <line17> } <line18> "	 <line7>	No
"public class A { <line0> @POST <line1> @Path(""/distributesync"") <line2> @Produces(MediaType.TEXT_XML) <line3> @RestQuery( <line4> name = ""distributesync"", <line5> description = ""Synchronously distribute a media package element to this distribution channel"", <line6> returnDescription = ""The distribution"", <line7> restParameters = { <line8> @RestParameter( <line9> name = ""mediapackage"", <line10> isRequired = true, <line11> description = ""The mediapackage"", <line12> type = Type.TEXT), <line13> @RestParameter( <line14> name = ""channelId"", <line15> isRequired = true, <line16> description = ""The publication channel ID"", <line17> type = Type.TEXT), <line18> @RestParameter( <line19> name = ""elementId"", <line20> isRequired = true, <line21> description = ""The element to distribute"", <line22> type = Type.STRING), <line23> @RestParameter( <line24> name = ""checkAvailability"", <line25> isRequired = false, <line26> description = ""If the service should try to access the distributed element"", <line27> type = Type.BOOLEAN) <line28> }, <line29> responses = { <line30> @RestResponse( <line31> responseCode = SC_OK, <line32> description = ""An XML representation of the distribution"") <line33> }) <line34> public Response distributeSync( <line35> @FormParam(""mediapackage"") String mediaPackageXml, <line36> @FormParam(""channelId"") String channelId, <line37> @FormParam(""elementId"") String elementId, <line38> @FormParam(""checkAvailability"") @DefaultValue(""true"") boolean checkAvailability) <line39> throws Exception { <line40> List<MediaPackageElement> result = null; <line41> try { <line42> Gson gson = new Gson(); <line43> Set<String> setElementIds = <line44> gson.fromJson(elementId, new TypeToken<Set<String>>() {}.getType()); <line45> MediaPackage mediapackage = MediaPackageParser.getFromXml(mediaPackageXml); <line46> result = service.distributeSync(channelId, mediapackage, setElementIds, checkAvailability); <line47> } catch (IllegalArgumentException e) { <line48> return status(Status.BAD_REQUEST).build(); <line49> } catch (Exception e) { <line50> return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build(); <line51> } <line52> return Response.ok(MediaPackageElementParser.getArrayAsXml(result)).build(); <line53> } <line54> } <line55> "	 <line41>	No
public class A { <line0> public void setWorkManager(final WorkManager workManager) { <line1> this.workManager = workManager; <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> @Test(timeout = 60000) <line1> public void testPeriodicCheckWhenLedgerDeleted() throws Exception { <line2> for (AuditorElector e : auditorElectors.values()) { <line3> e.shutdown(); <line4> } <line5> final int numLedgers = 100; <line6> List<Long> ids = new LinkedList<Long>(); <line7> for (int i = 0; i < numLedgers; i++) { <line8> LedgerHandle lh = bkc.createLedger(3, 3, DigestType.CRC32, ""passwd"".getBytes()); <line9> ids.add(lh.getId()); <line10> for (int j = 0; j < 10; j++) { <line11> lh.addEntry(""testdata"".getBytes()); <line12> } <line13> lh.close(); <line14> } <line15> final Auditor auditor = <line16> new Auditor(Bookie.getBookieAddress(bsConfs.get(0)).toString(), bsConfs.get(0), zkc); <line17> final AtomicBoolean exceptionCaught = new AtomicBoolean(false); <line18> final CountDownLatch latch = new CountDownLatch(1); <line19> Thread t = <line20> new Thread() { <line21> public void run() { <line22> try { <line23> latch.countDown(); <line24> for (int i = 0; i < numLedgers; i++) { <line25> auditor.checkAllLedgers(); <line26> } <line27> } catch (Exception e) { <line28> exceptionCaught.set(true); <line29> } <line30> } <line31> }; <line32> t.start(); <line33> latch.await(); <line34> for (Long id : ids) { <line35> bkc.deleteLedger(id); <line36> } <line37> t.join(); <line38> assertFalse(""Shouldn't have thrown exception"", exceptionCaught.get()); <line39> } <line40> } <line41> "	 <line4>	No
public class A { <line0> public static int getCommerceWishListItemByContainsCProductCount( <line1> long commerceWishListId, long cProductId) throws RemoteException { <line2> try { <line3> int returnValue = <line4> CommerceWishListItemServiceUtil.getCommerceWishListItemByContainsCProductCount( <line5> commerceWishListId, cProductId); <line6> return returnValue; <line7> } catch (Exception exception) { <line8> throw new RemoteException(exception.getMessage()); <line9> } <line10> } <line11> } <line12> 	 <line7>	No
public class A { <line0> private void addUserAdminRoles() throws BuildException { <line1> if (adduseradminroles == null) { <line2> return; <line3> } <line4> for (Adduseradminrole adduserrole : adduseradminroles) { <line5> List<UserAdminRole> userroles = adduserrole.getUserRoles(); <line6> for (UserAdminRole userRole : userroles) { <line7> try { <line8> dAdminMgr.assignUser(userRole); <line9> } catch (SecurityException se) { <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	 <line2>	No
public class A { <line0> public static boolean initConfigCacheFromResources() { <line1> URL resource = <line2> ApplicationConfigCache.class.getClassLoader().getResource(ConfigOptions.CONFIG_FILE); <line3> File configFile = new File(resource.getFile()); <line4> StringBuilder json = new StringBuilder(); <line5> try (BufferedReader reader = new BufferedReader(new FileReader(configFile), 1024)) { <line6> String line; <line7> while ((line = reader.readLine()) != null) { <line8> json.append(line); <line9> } <line10> } catch (Exception e) { <line11> } <line12> return initialize(json.toString()); <line13> } <line14> } <line15> 	 <line11>	Yes
public class A { <line0> public void testCalculator() { <line1> try { <line2> IsotopicDistribution lCalc = new IsotopicDistribution(60, 13, 86, 13, 2); <line3> Assert.assertEquals(0.39350045799282984, lCalc.getPercMax()[2], 0); <line4> Assert.assertEquals(0.16628993915006032, lCalc.getPercTot()[2], 0); <line5> } catch (Exception e) { <line6> fail(e.getMessage()); <line7> } <line8> } <line9> } <line10> 	 <line6>	Yes
public class A { <line0> private static void createTarFile(File archiveFile) { <line1> try { <line2> archiveFile.createNewFile(); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
public class A { <line0> private boolean isVersionEmpty(HProjectIteration version) { <line1> if (version.getDocuments().isEmpty()) { <line2> return true; <line3> } <line4> return false; <line5> } <line6> } <line7> 	 <line2>	Yes
public class A { <line0> private void executeFinalActions(TestContext context) { <line1> if (!finalActions.isEmpty()) { <line2> for (final TestActionBuilder<?> actionBuilder : finalActions) { <line3> TestAction action = actionBuilder.build(); <line4> if (!action.isDisabled(context)) { <line5> context.getTestActionListeners().onTestActionStart(this, action); <line6> action.execute(context); <line7> context.getTestActionListeners().onTestActionFinish(this, action); <line8> } else { <line9> context.getTestActionListeners().onTestActionSkipped(this, action); <line10> } <line11> } <line12> } <line13> if (testResult.isSuccess() && context.hasExceptions()) { <line14> CitrusRuntimeException contextException = context.getExceptions().remove(0); <line15> testResult = TestResult.failed(getName(), testClass.getName(), contextException); <line16> throw new TestCaseFailedException(contextException); <line17> } <line18> } <line19> } <line20> 	 <line19>	No
"public class A { <line0> @Override <line1> public boolean processEvent(StateEvent event) { <line2> switch (event.encodeType(EventTypes.class)) { <line3> case DISCONNECT_EVENT: <line4> setTimer(REC_TIMEOUT); <line5> switchToNextState(FsmState.REOPEN); <line6> break; <line7> case TIMEOUT_EVENT: <line8> doDisconnect(); <line9> setTimer(REC_TIMEOUT); <line10> switchToNextState(FsmState.REOPEN); <line11> break; <line12> case STOP_EVENT: <line13> clearTimer(); <line14> doDisconnect(); <line15> switchToNextState(FsmState.DOWN); <line16> break; <line17> case CEA_EVENT: <line18> clearTimer(); <line19> if (context.processCeaMessage( <line20> ((FsmEvent) event).getKey(), ((FsmEvent) event).getMessage())) { <line21> switchToNextState(FsmState.OKAY); <line22> } else { <line23> doDisconnect(); <line24> setTimer(REC_TIMEOUT); <line25> switchToNextState(FsmState.REOPEN); <line26> } <line27> break; <line28> case SEND_MSG_EVENT: <line29> throw new RuntimeException(""Connection is down""); <line30> default: <line31> return false; <line32> } <line33> return true; <line34> } <line35> } <line36> "	 <line31>	Yes
public class A { <line0> public void renderEditView(RenderRequest request, RenderResponse response) <line1> throws IOException, PortletException { <line2> String id = request.getParameter(MODERATION_ID); <line3> try { <line4> renderEditViewForId(request, response, id); <line5> } catch (TException e) { <line6> } <line7> } <line8> } <line9> 	 <line3>	No
"public class A { <line0> @Test <line1> void testFeedGetsUpdatedEvents() throws Exception { <line2> MockEndpoint endpoint = getMockEndpoint(""mock:results""); <line3> endpoint.expectedMessageCount(7); <line4> assertMockEndpointsSatisfied(); <line5> List<Exchange> list = endpoint.getReceivedExchanges(); <line6> String[] expectedTitles = { <line7> ""Speaking at the Irish Java Technology Conference on Thursday and Friday"", <line8> ""a great presentation on REST, JAX-WS and JSR 311"", <line9> ""my slides on ActiveMQ and Camel from last weeks Dublin Conference"", <line10> ""webcast today on Apache ActiveMQ"", <line11> ""Feedback on my Camel talk at the IJTC conference"", <line12> ""More thoughts on RESTful Message Queues"", <line13> ""ActiveMQ webinar archive available"" <line14> }; <line15> int counter = 0; <line16> for (Exchange exchange : list) { <line17> Entry entry = exchange.getIn().getBody(Entry.class); <line18> assertNotNull(entry, ""No entry found for exchange: "" + exchange); <line19> String expectedTitle = expectedTitles[counter]; <line20> String title = entry.getTitle(); <line21> assertEquals(expectedTitle, title, ""Title of message "" + counter); <line22> counter++; <line23> } <line24> } <line25> } <line26> "	 <line22>	Yes
public class A { <line0> public void showHighlightColor(boolean showHighlightColor) { <line1> if (highlightColor != null) { <line2> if (showHighlightColor) { <line3> try { <line4> Integer bgColor = Integer.valueOf(Integer.parseInt(highlightColor, 16)); <line5> XTextCursor cursor = getTextCursor(); <line6> Utils.setProperty(cursor, UnoProperty.CHAR_BACK_COLOR, bgColor); <line7> cursor.collapseToEnd(); <line8> UnoProperty.setPropertyToDefault(cursor, UnoProperty.CHAR_BACK_COLOR); <line9> } catch (NumberFormatException | UnoHelperException e) { <line10> } <line11> } else { <line12> try { <line13> UnoProperty.setPropertyToDefault(getTextCursor(), UnoProperty.CHAR_BACK_COLOR); <line14> } catch (UnoHelperException e) { <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	 <line15>	Yes
public class A { <line0> @Override <line1> public void debug(final String format, final Object... arguments) { <line2> if (m_nodeLogger.isDebugEnabled()) { <line3> FormattingTuple ft = MessageFormatter.arrayFormat(format, arguments); <line4> } <line5> } <line6> } <line7> 	 <line3>	No
public class A { <line0> public void initTimer() { <line1> final int delay = 30; <line2> final int interval = DEFAULT_INTERVAL; <line3> timerEvent.fire( <line4> new TimerEvent( <line5> new TimerSchedule(delay, interval), <line6> new MetadataValidationEvent(), <line7> Scheduled.Literal.INSTANCE)); <line8> } <line9> } <line10> 	 <line2>	No
"public class A { <line0> @Override <line1> public void configure(Context context) { <line2> super.configure(context); <line3> serializerType = context.getString(""serializer"", ""TEXT""); <line4> useRawLocalFileSystem = context.getBoolean(""hdfs.useRawLocalFileSystem"", false); <line5> serializerContext = new Context(context.getSubProperties(EventSerializer.CTX_PREFIX)); <line6> } <line7> } <line8> "	 <line6>	Yes
"public class A { <line0> private Connection getConnection(Configuration conf) { <line1> Connection connection; <line2> try { <line3> String url = conf.get(DBConfiguration.URL_PROPERTY); <line4> try { <line5> DriverManager.getDriver(url); <line6> } catch (SQLException e) { <line7> if (driverShim == null) { <line8> if (driver == null) { <line9> ClassLoader classLoader = conf.getClassLoader(); <line10> @SuppressWarnings(""unchecked"") <line11> Class<? extends Driver> driverClass = <line12> (Class<? extends Driver>) <line13> classLoader.loadClass(conf.get(DBConfiguration.DRIVER_CLASS_PROPERTY)); <line14> driver = driverClass.newInstance(); <line15> DBUtils.deregisterAllDrivers(driverClass); <line16> } <line17> driverShim = new JDBCDriverShim(driver); <line18> DriverManager.registerDriver(driverShim); <line19> } <line20> } <line21> Properties properties = <line22> ConnectionConfig.getConnectionArguments( <line23> conf.get(DBUtils.CONNECTION_ARGUMENTS), <line24> conf.get(DBConfiguration.USERNAME_PROPERTY), <line25> conf.get(DBConfiguration.PASSWORD_PROPERTY)); <line26> connection = DriverManager.getConnection(url, properties); <line27> boolean autoCommitEnabled = conf.getBoolean(AUTO_COMMIT_ENABLED, false); <line28> if (autoCommitEnabled) { <line29> connection = new NoOpCommitConnection(connection); <line30> } else { <line31> connection.setAutoCommit(false); <line32> } <line33> String level = conf.get(TransactionIsolationLevel.CONF_KEY); <line34> connection.setTransactionIsolation(TransactionIsolationLevel.getLevel(level)); <line35> } catch (Exception e) { <line36> throw Throwables.propagate(e); <line37> } <line38> return connection; <line39> } <line40> } <line41> "	 <line13>	No
"public class A { <line0> @Test <line1> public void testLiveIsolated() throws Exception { <line2> backupServer.stop(); <line3> FakeServiceComponent component = new FakeServiceComponent(""Component for "" + getName()); <line4> liveServer.getServer().addExternalComponent(component, true); <line5> liveServer <line6> .getServer() <line7> .getConfiguration() <line8> .setNetworkCheckList(badAddress) <line9> .setNetworkCheckPeriod(100) <line10> .setNetworkCheckTimeout(100); <line11> ((ActiveMQServerImpl) liveServer.getServer()).reloadNetworkHealthCheck(); <line12> try { <line13> Assert.assertEquals(100L, liveServer.getServer().getNetworkHealthCheck().getPeriod()); <line14> liveServer.getServer().getNetworkHealthCheck().setTimeUnit(TimeUnit.MILLISECONDS); <line15> Assert.assertFalse(liveServer.getServer().getNetworkHealthCheck().check()); <line16> Wait.assertFalse(liveServer::isStarted); <line17> liveServer <line18> .getServer() <line19> .getNetworkHealthCheck() <line20> .setIgnoreLoopback(true) <line21> .addAddress(""127.0.0.1""); <line22> Wait.assertTrue(liveServer::isStarted); <line23> Assert.assertTrue(component.isStarted()); <line24> } catch (Throwable e) { <line25> throw e; <line26> } finally { <line27> liveServer.getServer().stop(); <line28> backupServer.getServer().stop(); <line29> } <line30> } <line31> } <line32> "	 <line25>	Yes
"public class A { <line0> @Test <line1> public void testContextualQueryNullMetadata() throws Exception { <line2> String methodName = ""testContextualQueryNullMetadata""; <line3> String searchPhrase = ""serengeti event""; <line4> MockQuery query = new MockQuery(); <line5> query.addContextualFilter(searchPhrase, null); <line6> SubscriptionFilterVisitor visitor = new SubscriptionFilterVisitor(); <line7> Predicate predicate = (Predicate) query.getFilter().accept(visitor, null); <line8> MetacardImpl metacard = new MetacardImpl(); <line9> metacard.setId(""ABC123""); <line10> metacard.setMetadata(TestDataLibrary.getCatAndDogEntry()); <line11> HashMap<String, Object> properties = new HashMap<>(); <line12> properties.put(PubSubConstants.HEADER_ID_KEY, metacard.getId()); <line13> properties.put(PubSubConstants.HEADER_ENTRY_KEY, metacard); <line14> properties.put(PubSubConstants.HEADER_OPERATION_KEY, PubSubConstants.CREATE); <line15> Event testEvent = new Event(""topic"", properties); <line16> assertFalse(predicate.matches(testEvent)); <line17> } <line18> } <line19> "	 <line7>	No
public class A { <line0> @Nonnull <line1> @Override <line2> public AccessLevel getAccessLevel( <line3> @Nullable final PrimaryEntity entity, @Nullable final EntityReference userOrGroup) { <line4> AccessLevel result = resolveAccessLevel(NONE); <line5> if (entity == null || userOrGroup == null) { <line6> return result; <line7> } <line8> try { <line9> final Owner ownerObj = getOwner(entity); <line10> final EntityReference owner = ownerObj == null ? null : ownerObj.getUser(); <line11> final Collection<Collaborator> collaborators = getCollaborators(entity); <line12> final Set<DocumentReference> processedEntities = new HashSet<>(); <line13> final Queue<DocumentReference> entitiesToCheck = new LinkedList<>(); <line14> entitiesToCheck.add((DocumentReference) userOrGroup); <line15> AccessLevel currentItemAccess; <line16> DocumentReference currentItem; <line17> final XWikiContext context = this.xcontextProvider.get(); <line18> final XWikiGroupService groupService = context.getWiki().getGroupService(context); <line19> while (!entitiesToCheck.isEmpty()) { <line20> currentItem = entitiesToCheck.poll(); <line21> currentItemAccess = getAccessLevel(currentItem, owner, collaborators); <line22> if (currentItemAccess.compareTo(result) > 0) { <line23> result = currentItemAccess; <line24> } <line25> processedEntities.add(currentItem); <line26> final Collection<DocumentReference> groups = <line27> groupService.getAllGroupsReferencesForMember(currentItem, 0, 0, context); <line28> groups.removeAll(processedEntities); <line29> entitiesToCheck.addAll(groups); <line30> } <line31> } catch (final XWikiException ex) { <line32> } <line33> return result; <line34> } <line35> } <line36> 	 <line32>	Yes
public class A { <line0> public static void setExecuteStatusLogLevelInfo(boolean executeStatusLogLevelInfo) { <line1> assertUnlocked(); <line2> if (_log.isInfoEnabled()) { <line3> } <line4> _executeStatusLogLevelInfo = executeStatusLogLevelInfo; <line5> lock(); <line6> } <line7> } <line8> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public MCCIIN000002UV01 processPatientDiscoveryAsyncReq( <line2> PRPAIN201305UV02 message, AssertionType assertion, NhinTargetCommunitiesType target) { <line3> MCCIIN000002UV01 response = new MCCIIN000002UV01(); <line4> try { <line5> RespondingGatewayPRPAIN201305UV02RequestType request = <line6> new RespondingGatewayPRPAIN201305UV02RequestType(); <line7> request.setAssertion(assertion); <line8> request.setNhinTargetCommunities(target); <line9> request.setPRPAIN201305UV02(message); <line10> String url = <line11> oProxyHelper.getUrlLocalHomeCommunity( <line12> NhincConstants.PATIENT_DISCOVERY_ENTITY_ASYNC_REQ_SERVICE_NAME); <line13> ServicePortDescriptor<EntityPatientDiscoveryAsyncReqPortType> portDescriptor = <line14> new EntityPatientDiscoveryAsyncReqServicePortDescriptor(); <line15> CONNECTClient<EntityPatientDiscoveryAsyncReqPortType> client = <line16> CONNECTClientFactory.getInstance() <line17> .getCONNECTClientUnsecured(portDescriptor, url, assertion); <line18> response = <line19> (MCCIIN000002UV01) <line20> client.invokePort( <line21> EntityPatientDiscoveryAsyncReqPortType.class, <line22> ""processPatientDiscoveryAsyncReq"", <line23> request); <line24> } catch (Exception ex) { <line25> throw new ErrorEventException(ex, ""Error calling Patient Discovery Service""); <line26> } <line27> return response; <line28> } <line29> } <line30> "	 <line20>	No
public class A { <line0> @Override <line1> protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp) <line2> throws ServletException, IOException { <line3> final String servletBaseURL = req.getRequestURL().toString(); <line4> final Map<String, String> replaceMap = new HashMap<>(); <line5> handleSpotifyRedirect(replaceMap, servletBaseURL, req.getQueryString()); <line6> resp.setContentType(CONTENT_TYPE); <line7> replaceMap.put(KEY_REDIRECT_URI, servletBaseURL); <line8> replaceMap.put(KEY_PLAYERS, formatPlayers(playerTemplate, servletBaseURL)); <line9> resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap)); <line10> resp.getWriter().close(); <line11> } <line12> } <line13> 	 <line3>	Yes
public class A { <line0> @Override <line1> public void audit(AuditContext auditContext, AuditMessage... auditMessages) { <line2> for (var message : auditMessages) { <line3> var s = Current.toString(message, true); <line4> if (needValidation) { <line5> validator.validate(source(s), NEW_VALIDATION_SCHEMA); <line6> } <line7> messages.add(message); <line8> } <line9> } <line10> } <line11> 	 <line4>	Yes
public class A { <line0> public boolean init7SegmentDisplay() { <line1> try { <line2> if (device == null) { <line3> return false; <line4> } <line5> device.write(0x21, (byte) 0x00); <line6> device.write(0x81, (byte) 0x00); <line7> device.write(0xEF, (byte) 0x00); <line8> device.write(0x00, new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 16); <line9> } catch (Exception e) { <line10> Logging.logError(e); <line11> } <line12> return true; <line13> } <line14> } <line15> 	 <line3>	Yes
"public class A { <line0> public void startAsync(AsyncContextEvent event) { <line1> final List<AsyncListener> lastAsyncListeners; <line2> try (AutoLock l = lock()) { <line3> if (_state != State.HANDLING || _requestState != RequestState.BLOCKING) <line4> throw new IllegalStateException(this.getStatusStringLocked()); <line5> _requestState = RequestState.ASYNC; <line6> _event = event; <line7> lastAsyncListeners = _asyncListeners; <line8> _asyncListeners = null; <line9> } <line10> if (lastAsyncListeners != null) { <line11> Runnable callback = <line12> new Runnable() { <line13> @Override <line14> public void run() { <line15> for (AsyncListener listener : lastAsyncListeners) { <line16> try { <line17> listener.onStartAsync(event); <line18> } catch (Throwable e) { <line19> } <line20> } <line21> } <line22>  <line23> @Override <line24> public String toString() { <line25> return ""startAsync""; <line26> } <line27> }; <line28> runInContext(event, callback); <line29> } <line30> } <line31> } <line32> "	 <line25>	No
public class A { <line0> @Override <line1> public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent event) <line2> throws Exception { <line3> try { <line4> if (isConnected() <line5> && (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED) <line6> || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED) <line7> || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))) { <line8> synchronized (this) { <line9> Participant participant = leaderLatch.getLeader(); <line10> if (isLeader(participant) && !leaderLatch.hasLeadership()) { <line11> currentLeader = participant; <line12> } <line13> } <line14> } <line15> } catch (InterruptedException e) { <line16> } <line17> } <line18> } <line19> 	 <line16>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> private CacheInvokeEntry.Operation applyEntryProcessor( <line2> GridCacheContext cctx, <line3> KeyCacheObject key, <line4> GridCacheVersion ver, <line5> EntryProcessor entryProc, <line6> Object[] invokeArgs, <line7> MvccUpdateDataRow updateRow, <line8> CacheDataRow oldRow, <line9> boolean keepBinary) { <line10> Object procRes = null; <line11> Exception err = null; <line12> CacheObject oldVal = oldRow == null ? null : oldRow.value(); <line13> CacheInvokeEntry invokeEntry = <line14> new CacheInvokeEntry<>( <line15> key, oldVal, ver, keepBinary, new GridDhtDetachedCacheEntry(cctx, key)); <line16> try { <line17> procRes = entryProc.process(invokeEntry, invokeArgs); <line18> if (invokeEntry.modified() && invokeEntry.op() != CacheInvokeEntry.Operation.REMOVE) { <line19> Object val = invokeEntry.getValue(true); <line20> CacheObject val0 = cctx.toCacheObject(val); <line21> val0 = val0.prepareForCache(cctx.cacheObjectContext(), true); <line22> updateRow.value(val0); <line23> } <line24> } catch (Exception e) { <line25> err = e; <line26> } <line27> CacheInvokeResult invokeRes = <line28> err == null ? CacheInvokeResult.fromResult(procRes) : CacheInvokeResult.fromError(err); <line29> updateRow.invokeResult(invokeRes); <line30> return invokeEntry.op(); <line31> } <line32> } <line33> "	 <line30>	No
public class A { <line0> public static @Nullable String getDimensionName(Unit<?> unit) { <line1> for (Class<? extends SystemOfUnits> system : ALL_SYSTEM_OF_UNITS) { <line2> for (Field field : system.getDeclaredFields()) { <line3> if (field.getType().isAssignableFrom(Unit.class) <line4> && Modifier.isStatic(field.getModifiers())) { <line5> Type genericType = field.getGenericType(); <line6> if (genericType instanceof ParameterizedType) { <line7> String dimension = <line8> ((Class<?>) ((ParameterizedType) genericType).getActualTypeArguments()[0]) <line9> .getSimpleName(); <line10> Unit<?> systemUnit; <line11> try { <line12> systemUnit = (Unit<?>) field.get(null); <line13> if (systemUnit == null) { <line14> } else if (systemUnit.isCompatible(unit)) { <line15> return dimension; <line16> } <line17> } catch (IllegalArgumentException | IllegalAccessException e) { <line18> } <line19> } else { <line20> } <line21> } <line22> } <line23> } <line24> return null; <line25> } <line26> } <line27> 	 <line14>	Yes
public class A { <line0> @Override <line1> protected int calculateIndex( <line2> int index, int numPartitions, String tableName, int cutPointArrayLength) { <line3> if (SPLIT_TO_REDUCER_MAP.containsKey(tableName) <line4> && SPLIT_TO_REDUCER_MAP.get(tableName).containsKey(index)) { <line5> return SPLIT_TO_REDUCER_MAP.get(tableName).get(index); <line6> } else { <line7> int i = cutPointArrayLength; <line8> int reducer = numPartitions - 1; <line9> Map<Integer, Integer> tempSplitReducerMap = new HashMap<>(); <line10> tempSplitReducerMap.put(i, reducer); <line11> tempSplitReducerMap.put(-i - 1, reducer); <line12> i--; <line13> reducer--; <line14> while (i >= 0) { <line15> while (reducer >= 0) { <line16> tempSplitReducerMap.put(i, reducer); <line17> tempSplitReducerMap.put(-i - 1, reducer); <line18> i--; <line19> reducer--; <line20> if (i < 0) break; <line21> } <line22> reducer = numPartitions - 1; <line23> } <line24> SPLIT_TO_REDUCER_MAP.put(tableName, tempSplitReducerMap); <line25> if (SPLIT_TO_REDUCER_MAP.containsKey(tableName) <line26> && SPLIT_TO_REDUCER_MAP.get(tableName).containsKey(index)) { <line27> return SPLIT_TO_REDUCER_MAP.get(tableName).get(index); <line28> } <line29> return 0; <line30> } <line31> } <line32> } <line33> 	 <line28>	No
public class A { <line0> private void addSdsets() throws BuildException { <line1> if (addsdsets == null) { <line2> return; <line3> } <line4> for (Addsdset addsdset : addsdsets) { <line5> List<SDSetAnt> sds = addsdset.getSdset(); <line6> for (SDSetAnt sd : sds) { <line7> try { <line8> if (sd.getType() == SDSet.SDType.STATIC) { <line9> adminMgr.createSsdSet(sd); <line10> } else { <line11> adminMgr.createDsdSet(sd); <line12> } <line13> } catch (SecurityException se) { <line14> } <line15> } <line16> } <line17> } <line18> } <line19> 	 <line6>	No
public class A { <line0> private boolean hasSufficientTimeElapsed() { <line1> long now = Time.currentElapsedTime(); <line2> if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN) { <line3> return false; <line4> } <line5> setLastLogin(now); <line6> return true; <line7> } <line8> } <line9> 	 <line3>	Yes
"public class A { <line0> private void replyError() { <line1> if (dismissed.get()) { <line2> return; <line3> } <line4> ErrorCode err = <line5> err( <line6> SysErrors.MANAGEMENT_NODE_UNAVAILABLE_ERROR, <line7> ""management node[uuid:%s] is unavailable"", <line8> mgmtNodeId); <line9> if (rmeta.needApiEvent) { <line10> APIEvent evt = new APIEvent(rmeta.msgId); <line11> eventProperty(evt); <line12> evt.setError(err); <line13> wire.publish(evt); <line14> } else { <line15> MessageReply reply = new MessageReply(); <line16> reply.setError(err); <line17> AMQP.BasicProperties.Builder builder = new AMQP.BasicProperties.Builder(); <line18> reply.setAMQPProperties(builder.deliveryMode(1).build()); <line19> reply.getHeaders().put(CloudBus.HEADER_IS_MESSAGE_REPLY, Boolean.TRUE.toString()); <line20> reply.putHeaderEntry(CloudBus.HEADER_CORRELATION_ID, rmeta.msgId); <line21> reply.setServiceId(rmeta.replyTo); <line22> wire.send(reply, false); <line23> } <line24> dismiss(); <line25> } <line26> } <line27> "	 <line9>	Yes
public class A { <line0> public static FunctionalSet<ValueTuple> afterLoadDate(Iterable<?> fieldValue, String start) { <line1> FunctionalSet<ValueTuple> matches = FunctionalSet.emptySet(); <line2> if (fieldValue != null) { <line3> try { <line4> for (Object o : fieldValue) { <line5> if (betweenInclusive( <line6> Long.parseLong(ValueTuple.getStringValue(o)), getTime(start, true), Long.MAX_VALUE)) { <line7> matches = FunctionalSet.singleton(getHitTerm(o)); <line8> break; <line9> } <line10> break; <line11> } <line12> } catch (ParseException pe) { <line13> } catch (NumberFormatException nfe) { <line14> } <line15> } <line16> return matches; <line17> } <line18> } <line19> 	 <line13>	Yes
public class A { <line0> @Override <line1> @DeadlockAutoRestart <line2> public void eoCleanup(Class VOClazz) { <line3> EntityInfo info = getEntityInfo(VOClazz); <line4> if (!info.hasEO()) { <line5> return; <line6> } <line7> _eoCleanup(VOClazz); <line8> } <line9> } <line10> 	 <line5>	Yes
public class A { <line0> public void setBundleContext(BundleContext bundleContext) throws Exception { <line1> if (objectFactory != null) { <line2> PentahoSystem.deregisterObjectFactory(objectFactory); <line3> } <line4> objectFactory = new OSGIObjectFactory(bundleContext); <line5> PentahoSystem.registerObjectFactory(objectFactory); <line6> PentahoSystem.setBundleContext(bundleContext); <line7> } <line8> } <line9> 	 <line4>	No
"public class A { <line0> @Override <line1> public GeoEvent process(GeoEvent ge) throws Exception { <line2> double radius; <line3> if (!ge.getGeoEventDefinition().getTagNames().contains(""GEOMETRY"")) { <line4> return null; <line5> } <line6> srIn = ge.getGeometry().getSpatialReference(); <line7> if (isRadiusConstant) { <line8> radius = radiusConstant; <line9> } else { <line10> radius = (Double) ge.getField(radiusEventfld); <line11> } <line12> double elevation; <line13> if (isElevConstant) { <line14> elevation = elevConstant; <line15> } else { <line16> elevation = (Double) ge.getField(elevEventfld); <line17> } <line18> GeoEvent outGeo = <line19> ConstructVisibilityRest(ge, gp, is, radius, radiusUnit, elevation, units_elev, procwkid); <line20> return outGeo; <line21> } <line22> } <line23> "	 <line18>	Yes
public class A { <line0> @Override <line1> public void removeItemPref(long userID, long itemID, float prefValue) throws TasteException { <line2> Connection conn = null; <line3> PreparedStatement stmt = null; <line4> ResultSet rs = null; <line5> try { <line6> conn = dataSource.getConnection(); <line7> stmt = <line8> conn.prepareStatement( <line9> getDiffsAffectedByUserSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); <line10> stmt.setFetchDirection(ResultSet.FETCH_FORWARD); <line11> stmt.setFetchSize(getFetchSize()); <line12> stmt.setLong(1, userID); <line13> rs = stmt.executeQuery(); <line14> while (rs.next()) { <line15> int count = rs.getInt(1); <line16> long itemIDA = rs.getLong(3); <line17> long itemIDB = rs.getLong(4); <line18> if (count == minDiffCount) { <line19> removeOneDiff(conn, itemIDA, itemIDB); <line20> } else { <line21> float average = rs.getFloat(2); <line22> float currentOtherPrefValue = rs.getFloat(5); <line23> float prefDelta; <line24> if (itemID == itemIDA) { <line25> prefDelta = currentOtherPrefValue - prefValue; <line26> } else { <line27> prefDelta = prefValue - currentOtherPrefValue; <line28> } <line29> float newAverage = (average * count - prefDelta) / (count - 1); <line30> updateOneDiff(conn, count - 1, newAverage, itemIDA, itemIDB); <line31> } <line32> } <line33> } catch (SQLException sqle) { <line34> throw new TasteException(sqle); <line35> } finally { <line36> IOUtils.quietClose(rs, stmt, conn); <line37> } <line38> } <line39> } <line40> 	 <line38>	No
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrder updateCommerceOrder( <line1> HttpPrincipal httpPrincipal, <line2> String externalReferenceCode, <line3> long commerceOrderId, <line4> long billingAddressId, <line5> long shippingAddressId, <line6> String commercePaymentMethodKey, <line7> long commerceShippingMethodId, <line8> String shippingOptionName, <line9> String purchaseOrderNumber, <line10> java.math.BigDecimal subtotal, <line11> java.math.BigDecimal shippingAmount, <line12> java.math.BigDecimal total, <line13> java.math.BigDecimal subtotalWithTaxAmount, <line14> java.math.BigDecimal shippingWithTaxAmount, <line15> java.math.BigDecimal totalWithTaxAmount, <line16> String advanceStatus, <line17> com.liferay.commerce.context.CommerceContext commerceContext) <line18> throws com.liferay.portal.kernel.exception.PortalException { <line19> try { <line20> MethodKey methodKey = <line21> new MethodKey( <line22> CommerceOrderServiceUtil.class, <line23> ""updateCommerceOrder"", <line24> _updateCommerceOrderParameterTypes37); <line25> MethodHandler methodHandler = <line26> new MethodHandler( <line27> methodKey, <line28> externalReferenceCode, <line29> commerceOrderId, <line30> billingAddressId, <line31> shippingAddressId, <line32> commercePaymentMethodKey, <line33> commerceShippingMethodId, <line34> shippingOptionName, <line35> purchaseOrderNumber, <line36> subtotal, <line37> shippingAmount, <line38> total, <line39> subtotalWithTaxAmount, <line40> shippingWithTaxAmount, <line41> totalWithTaxAmount, <line42> advanceStatus, <line43> commerceContext); <line44> Object returnObj = null; <line45> try { <line46> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line47> } catch (Exception exception) { <line48> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line49> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line50> } <line51> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line52> } <line53> return (com.liferay.commerce.model.CommerceOrder) returnObj; <line54> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line55> throw systemException; <line56> } <line57> } <line58> } <line59> "	 <line55>	Yes
public class A { <line0> @Override <line1> public void register(Registration registration) { <line2> if (StringUtils.isEmpty(registration.getServiceId())) { <line3> return; <line4> } <line5> NamingService namingService = namingService(); <line6> String serviceId = registration.getServiceId(); <line7> String group = nacosDiscoveryProperties.getGroup(); <line8> Instance instance = getNacosInstanceFromRegistration(registration); <line9> try { <line10> namingService.registerInstance(serviceId, group, instance); <line11> } catch (Exception e) { <line12> rethrowRuntimeException(e); <line13> } <line14> } <line15> } <line16> 	 <line12>	Yes
"public class A { <line0> @Override <line1> public void completed(HttpClientCallbackResult result) { <line2> String results = result.getReplyDataAsString(); <line3> JSONObject jo = JSON.parseObject(results); <line4> String code = jo.getString(""code""); <line5> String desc = jo.getString(""desc""); <line6> if (log.isDebugEnable()) { <line7> } <line8> } <line9> } <line10> "	 <line5>	No
"public class A { <line0> protected final void stateChanged() { <line1> for (AbstractNodeView<?> view : m_views) { <line2> try { <line3> view.callModelChanged(); <line4> } catch (Exception e) { <line5> String msg = <line6> ""View ["" <line7> + view.getViewName() <line8> + ""] caused an error while displaying new contents: "" <line9> + e.getMessage(); <line10> setWarningMessage(msg); <line11> } <line12> } <line13> } <line14> } <line15> "	 <line11>	Yes
public class A { <line0> @Override <line1> public void startPlugins() { <line2> for (PluginWrapper pluginWrapper : resolvedPlugins) { <line3> PluginState pluginState = pluginWrapper.getPluginState(); <line4> if ((PluginState.DISABLED != pluginState) && (PluginState.STARTED != pluginState)) { <line5> try { <line6> Plugin plugin = pluginWrapper.getPlugin(); <line7> plugin.start(); <line8> pluginWrapper.setPluginState(PluginState.STARTED); <line9> if (plugin instanceof MeshPlugin) { <line10> MeshPlugin meshPlugin = (MeshPlugin) plugin; <line11> setStatus(meshPlugin.id(), PluginStatus.STARTED); <line12> pluginRegistry.preRegister(meshPlugin); <line13> } <line14> startedPlugins.add(pluginWrapper); <line15> firePluginStateEvent(new PluginStateEvent(this, pluginWrapper, pluginState)); <line16> } catch (Throwable e) { <line17> } <line18> } <line19> } <line20> } <line21> } <line22> 	 <line6>	Yes
"public class A { <line0> @Test <line1> public void testHeaderAndTrailer() throws Exception { <line2> results.expectedMessageCount(1); <line3> results.message(0).body().isInstanceOf(Document.class); <line4> results.message(0).header(""camelFlatpackCounter"").isEqualTo(6); <line5> results.assertIsSatisfied(); <line6> Document data = results.getExchanges().get(0).getIn().getBody(Document.class); <line7> Element docElement = data.getDocumentElement(); <line8> assertEquals(""Dataset"", docElement.getTagName()); <line9> Element header = (Element) docElement.getElementsByTagName(""DatasetHeader"").item(0); <line10> NodeList headerNodes = header.getElementsByTagName(""Column""); <line11> for (int i = 0; i < headerNodes.getLength(); i++) { <line12> Element column = (Element) headerNodes.item(i); <line13> if (column.getAttribute(""name"").equals(""INDICATOR"")) { <line14> assertEquals(""HBT"", column.getTextContent()); <line15> } else if (column.getAttribute(""name"").equals(""DATE"")) { <line16> assertEquals(""20080817"", column.getTextContent()); <line17> } else { <line18> fail(""Invalid Header Field""); <line19> } <line20> } <line21> NodeList list = docElement.getElementsByTagName(""DatasetRecord""); <line22> for (int counter = 0; counter < list.getLength(); counter++) { <line23> Element record = (Element) list.item(counter); <line24> NodeList columnNodes = record.getElementsByTagName(""Column""); <line25> boolean firstNameFound = false; <line26> for (int i = 0; i < columnNodes.getLength(); i++) { <line27> Element column = (Element) columnNodes.item(i); <line28> if (column.getAttribute(""name"").equals(""FIRSTNAME"")) { <line29> assertEquals(expectedFirstName[counter], column.getTextContent()); <line30> firstNameFound = true; <line31> } <line32> } <line33> assertTrue(firstNameFound); <line34> } <line35> Element trailer = (Element) docElement.getElementsByTagName(""DatasetTrailer"").item(0); <line36> NodeList trailerNodes = trailer.getElementsByTagName(""Column""); <line37> for (int i = 0; i < trailerNodes.getLength(); i++) { <line38> Element column = (Element) trailerNodes.item(i); <line39> if (column.getAttribute(""name"").equals(""INDICATOR"")) { <line40> assertEquals(""FBT"", column.getTextContent()); <line41> } else if (column.getAttribute(""name"").equals(""STATUS"")) { <line42> assertEquals(""SUCCESS"", column.getTextContent()); <line43> } else { <line44> fail(""Invalid Trailer Field""); <line45> } <line46> } <line47> } <line48> } <line49> "	 <line37>	No
public class A { <line0> public PluginWithExecutionId<ExecutablePlugin> getLatestSuccessfulExecutablePlugin( <line1> String datasetId, Set<ExecutablePluginType> pluginTypes, boolean limitToValidData) { <line2> verifyEnumSetIsValidAndNotEmpty(pluginTypes); <line3> final Set<PluginType> convertedPluginTypes = <line4> pluginTypes.stream().map(ExecutablePluginType::toPluginType).collect(Collectors.toSet()); <line5> final PluginWithExecutionId<MetisPlugin> uncastResultWrapper = <line6> getFirstOrLastFinishedPlugin(datasetId, convertedPluginTypes, false); <line7> final MetisPlugin uncastResult = <line8> Optional.ofNullable(uncastResultWrapper).map(PluginWithExecutionId::getPlugin).orElse(null); <line9> if (uncastResult == null) { <line10> return null; <line11> } <line12> if (!(uncastResult instanceof ExecutablePlugin)) { <line13> return null; <line14> } <line15> final ExecutablePlugin castResult = (ExecutablePlugin) uncastResult; <line16> final PluginWithExecutionId<ExecutablePlugin> result; <line17> if (limitToValidData && MetisPlugin.getDataStatus(castResult) != DataStatus.VALID) { <line18> result = null; <line19> } else { <line20> result = new PluginWithExecutionId<>(uncastResultWrapper.getExecutionId(), castResult); <line21> } <line22> return result; <line23> } <line24> } <line25> 	 <line13>	Yes
public class A { <line0> @Override <line1> public boolean deleteModelFamily(Long modelFamilyID) throws PropertyNotSetException { <line2> ModelFamily modelFamily = getEntityManager().find(ModelFamily.class, modelFamilyID); <line3> if (modelFamily != null) { <line4> try { <line5> getEntityManager().remove(modelFamily); <line6> } catch (HibernateException he) { <line7> return false; <line8> } <line9> return true; <line10> } else { <line11> return false; <line12> } <line13> } <line14> } <line15> 	 <line12>	No
"public class A { <line0> @RequestMapping(value = ""/clusters/"" + CLUSTER_NAME_PATH_VARIABLE, method = RequestMethod.PUT) <line1> public void updateCluster(@PathVariable String clusterName, @RequestBody ClusterTbl cluster) { <line2> clusterService.updateCluster(clusterName, cluster); <line3> } <line4> } <line5> "	 <line2>	Yes
public class A { <line0> private boolean processPsiFileRoots( <line1> @Nonnull List<VirtualFile> files, <line2> final int totalSize, <line3> int alreadyProcessedFiles, <line4> @Nonnull final ProgressIndicator progress, <line5> @Nonnull final Processor<? super PsiFile> localProcessor) { <line6> myManager.startBatchFilesProcessingMode(); <line7> try { <line8> final AtomicInteger counter = new AtomicInteger(alreadyProcessedFiles); <line9> final AtomicBoolean stopped = new AtomicBoolean(false); <line10> return processFilesConcurrentlyDespiteWriteActions( <line11> myManager.getProject(), <line12> files, <line13> progress, <line14> stopped, <line15> vfile -> { <line16> TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages(); <line17> try { <line18> processVirtualFile(vfile, stopped, localProcessor); <line19> } catch (ProcessCanceledException | IndexNotReadyException e) { <line20> throw e; <line21> } catch (Throwable e) { <line22> throw e; <line23> } <line24> if (progress.isRunning()) { <line25> double fraction = (double) counter.incrementAndGet() / totalSize; <line26> progress.setFraction(fraction); <line27> } <line28> return !stopped.get(); <line29> }); <line30> } finally { <line31> myManager.finishBatchFilesProcessingMode(); <line32> } <line33> } <line34> } <line35> 	 <line22>	Yes
public class A { <line0> @Override <line1> public void closeMetrics() { <line2> executor.close(); <line3> long potentialWriteTime = System.currentTimeMillis(); <line4> if (lastRunTime + 1000 < potentialWriteTime) { <line5> run(); <line6> } else { <line7> } <line8> logStream.close(); <line9> } <line10> } <line11> 	 <line7>	Yes
"public class A { <line0> protected Job doLoad(Configuration conf, TableDescriptor tableDescriptor) throws Exception { <line1> Path outputDir = getTestDir(TEST_NAME, ""load-output""); <line2> NMapInputFormat.setNumMapTasks(conf, conf.getInt(NUM_MAP_TASKS_KEY, NUM_MAP_TASKS_DEFAULT)); <line3> conf.set(TABLE_NAME_KEY, tableDescriptor.getTableName().getNameAsString()); <line4> Job job = Job.getInstance(conf); <line5> job.setJobName(TEST_NAME + "" Load for "" + tableDescriptor.getTableName()); <line6> job.setJarByClass(this.getClass()); <line7> setMapperClass(job); <line8> job.setInputFormatClass(NMapInputFormat.class); <line9> job.setNumReduceTasks(0); <line10> setJobScannerConf(job); <line11> FileOutputFormat.setOutputPath(job, outputDir); <line12> TableMapReduceUtil.addDependencyJars(job); <line13> TableMapReduceUtil.addDependencyJarsForClasses(job.getConfiguration(), AbstractHBaseTool.class); <line14> TableMapReduceUtil.initCredentials(job); <line15> assertTrue(job.waitForCompletion(true)); <line16> return job; <line17> } <line18> } <line19> "	 <line11>	No
"public class A { <line0> @Override <line1> public String startStopAgent(String agentId, String toolName, String osversion, String action) <line2> throws InsightsCustomException { <line3> try { <line4> String agentDaemonQueueName = <line5> ApplicationConfigProvider.getInstance().getAgentDetails().getAgentPkgQueue(); <line6> if (AGENTACTION.START.equals(AGENTACTION.valueOf(action))) { <line7> performAgentAction(agentId, toolName, osversion, action, agentDaemonQueueName); <line8> } else if (AGENTACTION.STOP.equals(AGENTACTION.valueOf(action)) <line9> && ""WINDOWS"".equalsIgnoreCase(osversion)) { <line10> performAgentAction(agentId, toolName, osversion, action, agentDaemonQueueName); <line11> } else { <line12> performAgentAction(agentId, toolName, osversion, action, agentId); <line13> } <line14> agentConfigDAL.updateAgentRunningStatus(agentId, AGENTACTION.valueOf(action)); <line15> } catch (Exception e) { <line16> throw new InsightsCustomException(e.toString()); <line17> } <line18> return AgentCommonConstant.SUCCESS; <line19> } <line20> } <line21> "	 <line5>	No
"public class A { <line0> @Override <line1> public void deleteRecord(DataIdentifier identifier) throws DataStoreException { <line2> long start = System.currentTimeMillis(); <line3> String key = getKeyName(identifier); <line4> ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); <line5> try { <line6> Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); <line7> s3service.deleteObject(bucket, key); <line8> } catch (AmazonServiceException e) { <line9> throw new DataStoreException(""Could not delete dataIdentifier "" + identifier, e); <line10> } finally { <line11> if (contextClassLoader != null) { <line12> Thread.currentThread().setContextClassLoader(contextClassLoader); <line13> } <line14> } <line15> } <line16> } <line17> "	 <line0>	No
public class A { <line0> @Override <line1> public void iterationDone(Model model, int iteration, int epoch) { <line2> if (printIterations <= 0) printIterations = 1; <line3> if (iteration % printIterations == 0) { <line4> double score = model.score(); <line5> } <line6> } <line7> } <line8> 	 <line2>	No
public class A { <line0> @Test <line1> public void testScheduler() throws Exception { <line2> FileStoreMonitor storeMonitor = <line3> new FileStoreMonitor( <line4> scheduledExecutorService, executorService, 20, TimeUnit.MILLISECONDS, 0.9, null); <line5> final ReusableLatch latch = new ReusableLatch(5); <line6> storeMonitor.addStore(getTestDirfile()); <line7> storeMonitor.addCallback( <line8> new FileStoreMonitor.Callback() { <line9> @Override <line10> public void tick(long usableSpace, long totalSpace) { <line11> latch.countDown(); <line12> } <line13>  <line14> @Override <line15> public void over(long usableSpace, long totalSpace) {} <line16>  <line17> @Override <line18> public void under(long usableSpace, long totalSpace) {} <line19> }); <line20> storeMonitor.start(); <line21> Assert.assertTrue(latch.await(1, TimeUnit.SECONDS)); <line22> storeMonitor.stop(); <line23> latch.setCount(1); <line24> Assert.assertFalse(latch.await(100, TimeUnit.MILLISECONDS)); <line25> } <line26> } <line27> 	 <line15>	No
public class A { <line0> protected Set<DocumentRef> undeleteDocumentList(CoreSession session, List<DocumentModel> docs) { <line1> Set<DocumentRef> undeleted = new HashSet<>(); <line2> for (DocumentModel doc : docs) { <line3> DocumentRef docRef = doc.getRef(); <line4> if (session <line5> .getAllowedStateTransitions(docRef) <line6> .contains(LifeCycleConstants.UNDELETE_TRANSITION)) { <line7> undeleteDocument(session, doc); <line8> undeleted.add(docRef); <line9> } else { <line10> } <line11> } <line12> return undeleted; <line13> } <line14> } <line15> 	 <line2>	No
public class A { <line0> private static void write( <line1> VeriniceElementTransfer transfer, TransferData transferData, List<?> elements) { <line2> try { <line3> ByteArrayOutputStream out = new ByteArrayOutputStream(); <line4> ObjectOutputStream objectOut = new ObjectOutputStream(out); <line5> objectOut.writeObject(elements.toArray(new Object[elements.size()])); <line6> transfer.doJavaToNative(out.toByteArray(), transferData); <line7> } catch (IOException e) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> public void execute(DelegateExecution execution) { <line1> if (sentenceGenerator != null) { <line2> execution.setVariable(""myVar"", sentenceGenerator.getSentence()); <line3> } else { <line4> execution.setVariable(""myVar"", ""SentenceGenerator is not injected by spring""); <line5> } <line6> if (someField != null) { <line7> execution.setVariable(""fieldInjection"", someField.getValue(execution)); <line8> } else { <line9> execution.setVariable(""fieldInjection"", ""Field injection not working""); <line10> } <line11> } <line12> } <line13> "	 <line5>	No
"public class A { <line0> public void configureRequestLog() { <line1> LogConfiguration lc = configuration.logging(); <line2> if (lc.getLogNCSADirectory() == null) { <line3> throw new IllegalArgumentException( <line4> ""Log directory for NCSA logging is not specified. Please set"" <line5> + "" org.ops4j.pax.web.log.ncsa.directory property.""); <line6> } <line7> File logDir = new File(lc.getLogNCSADirectory()); <line8> if (logDir.isFile()) { <line9> throw new IllegalArgumentException( <line10> logDir + "" is not a valid directory to store request logs""); <line11> } <line12> RequestLogWriter writer = new RequestLogWriter(); <line13> writer.setAppend(lc.isLogNCSAAppend()); <line14> if (lc.getLogNCSAFile() != null) { <line15> writer.setFilename(new File(lc.getLogNCSADirectory(), lc.getLogNCSAFile()).getAbsolutePath()); <line16> } else { <line17> writer.setFilename( <line18> new File(lc.getLogNCSADirectory(), ""yyyy_mm_dd.request.log"").getAbsolutePath()); <line19> } <line20> writer.setFilenameDateFormat(lc.getLogNCSAFilenameDateFormat()); <line21> writer.setRetainDays(lc.getLogNCSARetainDays()); <line22> writer.setTimeZone(lc.getLogNCSATimeZone()); <line23> CustomRequestLog requestLog = <line24> new CustomRequestLog( <line25> writer, <line26> lc.isLogNCSAExtended() <line27> ? CustomRequestLog.EXTENDED_NCSA_FORMAT <line28> : CustomRequestLog.EXTENDED_NCSA_FORMAT); <line29> server.setRequestLog(requestLog); <line30> } <line31> } <line32> "	 <line30>	Yes
public class A { <line0> public void reportFPComplications(FormSubmission submission) { <line1> EligibleCouple couple = allEligibleCouples.findByCaseId(submission.entityId()); <line2> if (couple == null) { <line3> return; <line4> } <line5> FPProductInformation fpProductInformation = <line6> new FPProductInformation( <line7> submission.entityId(), <line8> submission.anmId(), <line9> null, <line10> null, <line11> null, <line12> null, <line13> null, <line14> null, <line15> submission.getField(SUBMISSION_DATE_FIELD_NAME), <line16> null, <line17> submission.getField(COMPLICATION_DATE_FIELD_NAME), <line18> submission.getField(NEEDS_FOLLOWUP_FIELD_NAME), <line19> submission.getField(NEEDS_REFERRAL_FOLLOWUP_FIELD_NAME)); <line20> schedulingService.reportFPComplications(fpProductInformation); <line21> } <line22> } <line23> 	 <line3>	Yes
public class A { <line0> private List<JRJsonNode> goDown(JRJsonNode jrJsonNode) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> List<JRJsonNode> result = new ArrayList<>(); <line4> JsonNode dataNode = jrJsonNode.getDataNode(); <line5> if (dataNode.isObject()) { <line6> if (expression.isWildcard()) { <line7> ArrayNode container = getEvaluationContext().getObjectMapper().createArrayNode(); <line8> Iterator<Map.Entry<String, JsonNode>> it = dataNode.fields(); <line9> while (it.hasNext()) { <line10> JsonNode current = it.next().getValue(); <line11> if (applyFilter(jrJsonNode.createChild(current))) { <line12> container.add(current); <line13> } <line14> } <line15> if (container.size() > 0) { <line16> result.add(jrJsonNode.createChild(container)); <line17> } <line18> } else { <line19> JRJsonNode deeperNode = goDeeperIntoObjectNode(jrJsonNode, isCalledFromFilter); <line20> if (deeperNode != null) { <line21> result.add(deeperNode); <line22> } <line23> } <line24> } else if (dataNode.isArray()) { <line25> if (expression.isWildcard()) { <line26> result = filterArrayNode(jrJsonNode, (ArrayNode) dataNode, null, isCalledFromFilter); <line27> } else { <line28> result = <line29> filterArrayNode( <line30> jrJsonNode, (ArrayNode) dataNode, expression.getObjectKey(), isCalledFromFilter); <line31> } <line32> } <line33> return result; <line34> } <line35> } <line36> 	 <line2>	Yes
public class A { <line0> private void transfer(List<JsonLabelVO> trashs, String type) { <line1> List<String> recycles = new ArrayList<>(); <line2> for (JsonLabelVO trash : trashs) { <line3> InstallPathRecycleVO vo = <line4> JSONObjectUtil.toObject(trash.getLabelValue(), InstallPathRecycleVO.class); <line5> try { <line6> vo = dbf.persistAndRefresh(vo); <line7> recycles.add(String.valueOf(vo.getTrashId())); <line8> } catch (Exception e) { <line9> logger.warn(e.getMessage()); <line10> logger.warn(trash.getLabelValue()); <line11> } <line12> } <line13> for (JsonLabelVO trash : trashs) { <line14> try { <line15> dbf.remove(trash); <line16> } catch (Exception e) { <line17> } <line18> } <line19> if (!recycles.isEmpty()) { <line20> } <line21> } <line22> } <line23> 	 <line22>	No
public class A { <line0> public String create(LogicalInfrastructure logicalInfrastructure) throws RestServiceException { <line1> String resourceId = <line2> vcpeNetworkService.createVCPENetwork( <line3> OpennaasBeanUtils.getVCPENetwork(logicalInfrastructure)); <line4> while (!vcpeNetworkService.hasFinishedBuild(resourceId)) { <line5> try { <line6> Thread.sleep(10 * 1000); <line7> } catch (InterruptedException e) { <line8> break; <line9> } <line10> } <line11> vcpeNetworkService.getBuildResult(resourceId); <line12> return resourceId; <line13> } <line14> } <line15> 	 <line1>	Yes
"public class A { <line0> protected final void logUpdatedDeliveryState( <line1> final Span currentSpan, final Message message, final ProtonDelivery delivery) { <line2> Objects.requireNonNull(currentSpan); <line3> final String messageId = <line4> message.getMessageId() != null ? message.getMessageId().toString() : """"; <line5> final String messageAddress = getMessageAddress(message); <line6> final DeliveryState remoteState = delivery.getRemoteState(); <line7> if (Accepted.class.isInstance(remoteState)) { <line8> currentSpan.log(""message accepted by peer""); <line9> Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED); <line10> } else { <line11> final Map<String, Object> events = new HashMap<>(); <line12> if (Rejected.class.isInstance(remoteState)) { <line13> final Rejected rejected = (Rejected) delivery.getRemoteState(); <line14> Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_BAD_REQUEST); <line15> if (rejected.getError() == null) { <line16> logMessageSendingError( <line17> ""message [ID: {}, address: {}] rejected by peer"", messageId, messageAddress); <line18> events.put(Fields.MESSAGE, ""message rejected by peer""); <line19> } else { <line20> logMessageSendingError( <line21> ""message [ID: {}, address: {}] rejected by peer: {}, {}"", <line22> messageId, <line23> messageAddress, <line24> rejected.getError().getCondition(), <line25> rejected.getError().getDescription()); <line26> events.put( <line27> Fields.MESSAGE, <line28> String.format( <line29> ""message rejected by peer: %s, %s"", <line30> rejected.getError().getCondition(), rejected.getError().getDescription())); <line31> } <line32> } else if (Released.class.isInstance(remoteState)) { <line33> logMessageSendingError( <line34> ""message [ID: {}, address: {}] not accepted by peer, remote state: {}"", <line35> messageId, <line36> messageAddress, <line37> remoteState.getClass().getSimpleName()); <line38> Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE); <line39> events.put(Fields.MESSAGE, ""message not accepted by peer, remote state: "" + remoteState); <line40> } else if (Modified.class.isInstance(remoteState)) { <line41> final Modified modified = (Modified) delivery.getRemoteState(); <line42> logMessageSendingError( <line43> ""message [ID: {}, address: {}] not accepted by peer, remote state: {}"", <line44> messageId, <line45> messageAddress, <line46> modified); <line47> Tags.HTTP_STATUS.set( <line48> currentSpan, <line49> modified.getUndeliverableHere() <line50> ? HttpURLConnection.HTTP_NOT_FOUND <line51> : HttpURLConnection.HTTP_UNAVAILABLE); <line52> events.put(Fields.MESSAGE, ""message not accepted by peer, remote state: "" + remoteState); <line53> } <line54> TracingHelper.logError(currentSpan, events); <line55> } <line56> } <line57> } <line58> "	 <line51>	No
public class A { <line0> public static TemplatePool getTemplatePool(Client client) throws InternalServerErrorException { <line1> TemplatePool templatePool = (TemplatePool) generateOnePool(client, TemplatePool.class); <line2> OneResponse response = templatePool.infoAll(); <line3> if (response.isError()) { <line4> throw new InternalServerErrorException(response.getErrorMessage()); <line5> } <line6> return templatePool; <line7> } <line8> } <line9> 	 <line4>	Yes
public class A { <line0> @NotNull <line1> public Multimap<Chromosome, CobaltCount> tumorOnly(@NotNull final String tumorBam) <line2> throws IOException, ExecutionException, InterruptedException { <line3> final File tumorFile = new File(tumorBam); <line4> final String chromosomeLengthFileName = <line5> ChromosomeLengthFile.generateFilename(mOutputDir, mTumorId); <line6> final List<ChromosomeLength> lengths; <line7> try (SamReader reader = mReaderFactory.open(tumorFile)) { <line8> lengths = ChromosomeLengthFactory.create(reader.getFileHeader()); <line9> } <line10> ChromosomeLengthFile.write(chromosomeLengthFileName, lengths); <line11> final List<Future<ChromosomeReadCount>> tumorFutures = <line12> createFutures(mReaderFactory, tumorFile, lengths); <line13> final Multimap<Chromosome, ReadCount> tumorCounts = fromFutures(tumorFutures); <line14> return CobaltCountFactory.tumorOnly(tumorCounts); <line15> } <line16> } <line17> 	 <line11>	Yes
"public class A { <line0> protected void printOperationInfo(Logger logger) { <line1> StringBuilder strb = new StringBuilder(35); <line2> strb.append(""["") <line3> .append(dateFormat.format(new Date(getPreExecutionTime()))) <line4> .append("" - "") <line5> .append(dateFormat.format(new Date(getPostExecutionTime()))) <line6> .append("" ("") <line7> .append(getPostExecutionTime() - getPreExecutionTime()) <line8> .append(""ms)]""); <line9> strb.append("" "").append(getOperation().getClass().getSimpleName()).append("" ""); <line10> if (getExecutionId() != null) { <line11> strb.append(""with execution "").append(getExecutionId()); <line12> if (getFlowElementId() != null) { <line13> strb.append("" at flow element "") <line14> .append(getFlowElementId()) <line15> .append("" ("") <line16> .append(getFlowElementClass().getSimpleName()) <line17> .append("")""); <line18> } <line19> } <line20> } <line21> } <line22> "	 <line1>	No
"public class A { <line0> @Override <line1> public StartedJobInfo getMostRecentByJobId(long jobId) { <line2> Connection c = HarvestDBConnection.get(); <line3> Statement stm = null; <line4> try { <line5> stm = c.createStatement(); <line6> ResultSet rs = <line7> stm.executeQuery( <line8> ""SELECT "" <line9> + HM_COLUMN.getColumnsInOrder() <line10> + "" FROM runningJobsMonitor"" <line11> + "" WHERE jobId="" <line12> + jobId); <line13> if (rs.next()) { <line14> String harvestName = rs.getString(HM_COLUMN.harvestName.rank()); <line15> StartedJobInfo sji = new StartedJobInfo(harvestName, jobId); <line16> sji.setElapsedSeconds(rs.getLong(HM_COLUMN.elapsedSeconds.rank())); <line17> sji.setHostUrl(rs.getString(HM_COLUMN.hostUrl.rank())); <line18> sji.setProgress(rs.getDouble(HM_COLUMN.progress.rank())); <line19> sji.setQueuedFilesCount(rs.getLong(HM_COLUMN.queuedFilesCount.rank())); <line20> sji.setTotalQueuesCount(rs.getLong(HM_COLUMN.totalQueuesCount.rank())); <line21> sji.setActiveQueuesCount(rs.getLong(HM_COLUMN.activeQueuesCount.rank())); <line22> sji.setRetiredQueuesCount(rs.getLong(HM_COLUMN.retiredQueuesCount.rank())); <line23> sji.setExhaustedQueuesCount(rs.getLong(HM_COLUMN.exhaustedQueuesCount.rank())); <line24> sji.setAlertsCount(rs.getLong(HM_COLUMN.alertsCount.rank())); <line25> sji.setDownloadedFilesCount(rs.getLong(HM_COLUMN.downloadedFilesCount.rank())); <line26> sji.setCurrentProcessedKBPerSec(rs.getLong(HM_COLUMN.currentProcessedKBPerSec.rank())); <line27> sji.setProcessedKBPerSec(rs.getLong(HM_COLUMN.processedKBPerSec.rank())); <line28> sji.setCurrentProcessedDocsPerSec( <line29> rs.getDouble(HM_COLUMN.currentProcessedDocsPerSec.rank())); <line30> sji.setProcessedDocsPerSec(rs.getDouble(HM_COLUMN.processedDocsPerSec.rank())); <line31> sji.setActiveToeCount(rs.getInt(HM_COLUMN.activeToeCount.rank())); <line32> sji.setStatus(CrawlStatus.values()[rs.getInt(HM_COLUMN.status.rank())]); <line33> sji.setTimestamp(new Date(rs.getTimestamp(HM_COLUMN.tstamp.rank()).getTime())); <line34> return sji; <line35> } <line36> } catch (SQLException e) { <line37> String message = <line38> ""SQL error querying runningJobsMonitor"" + ""\n"" + ExceptionUtils.getSQLExceptionCause(e); <line39> throw new IOFailure(message, e); <line40> } finally { <line41> DBUtils.closeStatementIfOpen(stm); <line42> HarvestDBConnection.release(c); <line43> } <line44> throw new UnknownID(""No running job with ID "" + jobId); <line45> } <line46> } <line47> "	 <line34>	Yes
"public class A { <line0> @Override <line1> public void leave() { <line2> synchronized (viewInstallationLock) { <line3> GMSMembershipView<ID> view = currentView; <line4> isStopping = true; <line5> stopCoordinatorServices(); <line6> if (view != null) { <line7> if (view.size() > 1) { <line8> List<ID> coords = view.getPreferredCoordinators(Collections.emptySet(), localAddress, 5); <line9> LeaveRequestMessage<ID> m = <line10> new LeaveRequestMessage<>(coords, this.localAddress, ""this member is shutting down""); <line11> services.getMessenger().send(m); <line12> } <line13> } <line14> } <line15> } <line16> } <line17> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public UserGroup findByC_N(long companyId, String name) throws NoSuchUserGroupException { <line2> UserGroup userGroup = fetchByC_N(companyId, name); <line3> if (userGroup == null) { <line4> StringBundler sb = new StringBundler(6); <line5> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line6> sb.append(""companyId=""); <line7> sb.append(companyId); <line8> sb.append("", name=""); <line9> sb.append(name); <line10> sb.append(""}""); <line11> if (_log.isDebugEnabled()) { <line12> } <line13> throw new NoSuchUserGroupException(sb.toString()); <line14> } <line15> return userGroup; <line16> } <line17> } <line18> "	 <line17>	No
public class A { <line0> @Override <line1> public void sendScreenshotMissingMessage(String branchName, String messageId, String username) <line2> throws BranchNotificationMessageSenderException { <line3> try { <line4> differentialRevision.addComment( <line5> branchName, branchNotificationMessageBuilderPhabricator.getScreenshotMissingMessage()); <line6> } catch (PhabricatorException e) { <line7> throw new BranchNotificationMessageSenderException(e); <line8> } <line9> } <line10> } <line11> 	 <line9>	No
"public class A { <line0> public void solveMockSettings() { <line1> if (openSettingsButton.isElementPresent(MINIMAL_TIMEOUT)) { <line2> openSettingsButton.clickIfPresent(DELAY); <line3> String currentAndroidVersion = IDriverPool.getDefaultDevice().getOsVersion(); <line4> if (currentAndroidVersion.contains(""7."")) { <line5> swipe(allowMock7, devSettingsContainer); <line6> allowMock7.clickIfPresent(MINIMAL_TIMEOUT); <line7> fakeGpsPackage.clickIfPresent(DELAY); <line8> } else { <line9> swipe(allowMock, devSettingsContainer); <line10> allowMock.clickIfPresent(MINIMAL_TIMEOUT); <line11> fakeGpsPackage.clickIfPresent(DELAY / 3); <line12> } <line13> getDriver().navigate().back(); <line14> } <line15> } <line16> } <line17> "	 <line4>	Yes
"public class A { <line0> @Override <line1> public ChannelPipeline getPipeline() throws Exception { <line2> ChannelPipeline pipeline = Channels.pipeline(); <line3> pipeline.addLast( <line4> ""test"", <line5> new SimpleChannelHandler() { <line6> @Override <line7> public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception { <line8> String name = Thread.currentThread().getName(); <line9> Thread.sleep(10000); <line10> } <line11> }); <line12> return pipeline; <line13> } <line14> } <line15> "	 <line9>	Yes
"public class A { <line0> private List<OmObservation> querySeriesObservation(GetObservationRequest request, Session session) <line1> throws OwsExceptionReport, ConverterException { <line2> if (request.isSetResultFilter()) { <line3> throw new NotYetSupportedException(""result filtering""); <line4> } <line5> Locale requestedLocale = getRequestedLocale(request); <line6> String pdf = getProcedureDescriptionFormat(request.getResponseFormat()); <line7> final long start = System.currentTimeMillis(); <line8> List<String> features = request.getFeatureIdentifiers(); <line9> Collection<DataEntity<?>> seriesObservations = Lists.newArrayList(); <line10> AbstractSeriesDAO seriesDAO = daoFactory.getSeriesDAO(); <line11> for (IndeterminateValue sosIndeterminateTime : request.getFirstLatestTemporalFilter()) { <line12> for (DatasetEntity series : <line13> getSeries(seriesDAO, request, features, sosIndeterminateTime, session)) { <line14> if (sosIndeterminateTime.equals(ExtendedIndeterminateTime.FIRST)) { <line15> seriesObservations.add(series.getFirstObservation()); <line16> } else if (sosIndeterminateTime.equals(ExtendedIndeterminateTime.LATEST)) { <line17> seriesObservations.add(series.getLastObservation()); <line18> } <line19> } <line20> } <line21> final List<OmObservation> result = new LinkedList<>(); <line22> if (profileHandler.getActiveProfile().isShowMetadataOfEmptyObservations()) { <line23> Map<Long, DatasetEntity> seriesToCheckMap = Maps.newHashMap(); <line24> for (DatasetEntity series : seriesDAO.getSeries(request, features, session)) { <line25> seriesToCheckMap.put(series.getId(), series); <line26> } <line27> for (DataEntity<?> seriesObs : seriesObservations) { <line28> long seriesId = seriesObs.getDataset().getId(); <line29> if (seriesToCheckMap.containsKey(seriesId)) { <line30> seriesToCheckMap.remove(seriesId); <line31> } <line32> } <line33> for (DatasetEntity series : seriesToCheckMap.values()) { <line34> HibernateObservationUtilities.createSosObservationFromSeries( <line35> series, request, requestedLocale, pdf, observationCreatorContext, session) <line36> .forEachRemaining(result::add); <line37> } <line38> } <line39> toSosObservation( <line40> new ArrayList<>(seriesObservations), <line41> request, <line42> requestedLocale, <line43> pdf, <line44> observationCreatorContext, <line45> session) <line46> .forEachRemaining(result::add); <line47> return result; <line48> } <line49> } <line50> "	 <line4>	No
"public class A { <line0> @Override <line1> public Object invoke(Object object, Method method, Object[] args) throws Throwable { <line2> return ""RESULT""; <line3> } <line4> } <line5> "	 <line1>	No
public class A { <line0> @Override <line1> public ProcessingStatus onDocuments(List<Document> docs) { <line2> if (docs.size() == 0) { <line3> return ProcessingStatus.OK; <line4> } <line5> ArrayList<SolrInputDocument> docsToSend = new ArrayList<SolrInputDocument>(); <line6> for (Document d : docs) { <line7> docsToSend.add(convertDocument(d)); <line8> } <line9> try { <line10> if (embeddedSolrServer != null) { <line11> embeddedSolrServer.add(docsToSend); <line12> } else { <line13> solrServer.add(docsToSend); <line14> } <line15> return ProcessingStatus.OK; <line16> } catch (Exception e) { <line17> return ProcessingStatus.DROP; <line18> } <line19> } <line20> } <line21> 	 <line17>	Yes
public class A { <line0> @Override <line1> public Number getAggregated() { <line2> if (currentValue == null) { <line3> return null; <line4> } <line5> Number result = currentValue - previousValue; <line6> return result; <line7> } <line8> } <line9> 	 <line4>	No
"public class A { <line0> private Method reflectGetNumCurrentReplicas(FSDataOutputStream os) { <line1> Method m = null; <line2> if (os != null) { <line3> Class<? extends OutputStream> wrappedStreamClass = os.getWrappedStream().getClass(); <line4> try { <line5> m = wrappedStreamClass.getDeclaredMethod(""getNumCurrentReplicas"", new Class<?>[] {}); <line6> m.setAccessible(true); <line7> } catch (NoSuchMethodException e) { <line8> } catch (SecurityException e) { <line9> m = null; <line10> } <line11> } <line12> if (m != null) { <line13> } <line14> return m; <line15> } <line16> } <line17> "	 <line8>	Yes
public class A { <line0> public List<DataSourceColumnDto> findAllDataFileColumns(final Long dataFileId) { <line1> final List<DataSourceColumn> result = new ArrayList<>(); <line2> final DataFile dataFile = dataFileService.find(dataFileId); <line3> for (DataFileColumn dataFileColumn : dataFile.getColumns()) { <line4> result.add( <line5> DataSourceColumn.builder() <line6> .details(dataFileColumn.getName()) <line7> .parameters(dataFileColumn.getDataValueType(), dataFileColumn.getPosition()) <line8> .build()); <line9> } <line10> return dataSourceColumnToDataSourceColumnDtoConverter.convertToList(result); <line11> } <line12> } <line13> 	 <line3>	No
"public class A { <line0> public static void deleteFileVersion( <line1> HttpPrincipal httpPrincipal, long fileEntryId, String version) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> DLFileEntryServiceUtil.class, <line7> ""deleteFileVersion"", <line8> _deleteFileVersionParameterTypes10); <line9> MethodHandler methodHandler = new MethodHandler(methodKey, fileEntryId, version); <line10> try { <line11> TunnelUtil.invoke(httpPrincipal, methodHandler); <line12> } catch (Exception exception) { <line13> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line14> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line15> } <line16> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line17> } <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	 <line19>	Yes
"public class A { <line0> public static boolean isExpiredTimestamp(String lastUpdated) { <line1> ZoneId utc = ZoneId.of(""UTC""); <line2> LocalDate today = LocalDate.now(utc); <line3> DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""yyyyMMddHHmmss"").withZone(utc); <line4> try { <line5> LocalDate lastUpdatedDate = <line6> LocalDate.parse(lastUpdated, formatter).atStartOfDay().toLocalDate(); <line7> return today.isAfter(lastUpdatedDate); <line8> } catch (DateTimeParseException e) { <line9> return false; <line10> } <line11> } <line12> } <line13> "	 <line0>	No
public class A { <line0> @Override <line1> public void onNext(DiscoveryResponse response) { <line2> XdsSchedulerManager.getInstance().stopAPIDiscoveryScheduling(); <line3> latestReceived = response; <line4> try { <line5> List<Api> apis = handleResponse(response); <line6> apiFactory.addApis(apis); <line7> ack(); <line8> } catch (Exception e) { <line9> onError(e); <line10> } <line11> } <line12> } <line13> 	 <line7>	No
"public class A { <line0> @PostConstruct <line1> void init() throws IOException { <line2> final Properties properties = new Properties(); <line3> final var velocityLog = fedoraPropsConfig.getVelocityLog().toString(); <line4> properties.setProperty(""runtime.log"", velocityLog); <line5> final URL propertiesUrl = getClass().getResource(velocityPropertiesLocation); <line6> try (final InputStream propertiesStream = propertiesUrl.openStream()) { <line7> properties.load(propertiesStream); <line8> } <line9> velocity.init(properties); <line10> } <line11> } <line12> "	 <line10>	Yes
"public class A { <line0> private void readDockerConf(File src, Properties properties) { <line1> File dockerConf = new File(src, ""docker.yml""); <line2> if (dockerConf.exists()) { <line3> try { <line4> confs.putAll(Confs.read(dockerConf, properties)); <line5> } catch (IOException e) { <line6> throw new OrchestrationException(e); <line7> } <line8> } <line9> } <line10> } <line11> "	 <line1>	No
"public class A { <line0> @Override <line1> public XDRAcknowledgementType processDocSubmissionRequest( <line2> ProvideAndRegisterDocumentSetRequestType body, AssertionType assertion) { <line3> logInfoServiceProcess(this.getClass()); <line4> XDRAcknowledgementType response; <line5> String localHCID = getLocalHCID(); <line6> if (isPolicyValid(body, assertion, localHCID)) { <line7> try { <line8> getDocSubmissionUtils().convertDataToFileLocationIfEnabled(body); <line9> response = sendToAdapter(body, assertion); <line10> } catch (LargePayloadException lpe) { <line11> response = MessageGeneratorUtils.getInstance().createXDRAckWithRegistryErrorResponse(); <line12> } <line13> } else { <line14> response = sendErrorToAdapter(body, assertion, ""Policy Check Failed""); <line15> } <line16> return response; <line17> } <line18> } <line19> "	 <line17>	No
public class A { <line0> @Override <line1> public void onException(ChunkedOutput<OutboundEvent> chunkedOutput, Exception exception) { <line2> super.onException(chunkedOutput, exception); <line3> } <line4> } <line5> 	 <line0>	No
public class A { <line0> @Override <line1> public Long getExperimentCount(List<String> projectIds) { <line2> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line3> Query<?> query = session.createQuery(GET_PROJECT_EXPERIMENTS_COUNT_HQL); <line4> query.setParameterList(ModelDBConstants.PROJECT_IDS, projectIds); <line5> Long count = (Long) query.uniqueResult(); <line6> return count; <line7> } catch (Exception ex) { <line8> if (ModelDBUtils.needToRetry(ex)) { <line9> return getExperimentCount(projectIds); <line10> } else { <line11> throw ex; <line12> } <line13> } <line14> } <line15> } <line16> 	 <line3>	No
"public class A { <line0> public void updateVmPriorityOnHost(HostInventory inv) { <line1> List<String> vmUuids = <line2> Q.New(VmInstanceVO.class) <line3> .select(VmInstanceVO_.uuid) <line4> .eq(VmInstanceVO_.hostUuid, inv.getUuid()) <line5> .eq(VmInstanceVO_.state, VmInstanceState.Running) <line6> .eq(VmInstanceVO_.type, VmInstanceConstant.USER_VM_TYPE) <line7> .listValues(); <line8> if (vmUuids.isEmpty()) { <line9> return; <line10> } <line11> List<String> updatedVms = <line12> Q.New(SystemTagVO.class) <line13> .select(SystemTagVO_.resourceUuid) <line14> .like(SystemTagVO_.tag, ""vmPriority::%"") <line15> .in(SystemTagVO_.resourceUuid, vmUuids) <line16> .listValues(); <line17> vmUuids.removeAll(updatedVms); <line18> vmUuids.removeIf(v -> !destinationMaker.isManagedByUs(v)); <line19> if (vmUuids.isEmpty()) { <line20> return; <line21> } <line22> VmPriorityConfigVO priorityVO = <line23> Q.New(VmPriorityConfigVO.class) <line24> .eq(VmPriorityConfigVO_.level, VmPriorityLevel.Normal) <line25> .find(); <line26> List<PriorityConfigStruct> priorityConfigStructs = new ArrayList<>(); <line27> vmUuids.forEach( <line28> v -> { <line29> priorityConfigStructs.add(new PriorityConfigStruct(priorityVO, v)); <line30> }); <line31> UpdateVmPriorityMsg msg = new UpdateVmPriorityMsg(); <line32> msg.setHostUuid(inv.getUuid()); <line33> msg.setPriorityConfigStructs(priorityConfigStructs); <line34> bus.makeTargetServiceIdByResourceUuid(msg, HostConstant.SERVICE_ID, inv.getUuid()); <line35> bus.send( <line36> msg, <line37> new CloudBusCallBack(msg) { <line38> @Override <line39> public void run(MessageReply reply) { <line40> UpdateVmPriorityReply r = new UpdateVmPriorityReply(); <line41> if (!reply.isSuccess()) { <line42> return; <line43> } <line44> new VmPriorityOperator().batchSetVmPriority(vmUuids, VmPriorityLevel.Normal); <line45> } <line46> }); <line47> } <line48> } <line49> "	 <line42>	Yes
public class A { <line0> public static com.liferay.dynamic.data.mapping.model.DDMTemplateSoap updateTemplate( <line1> long templateId, <line2> long classPK, <line3> String[] nameMapLanguageIds, <line4> String[] nameMapValues, <line5> String[] descriptionMapLanguageIds, <line6> String[] descriptionMapValues, <line7> String type, <line8> String mode, <line9> String language, <line10> String script, <line11> boolean cacheable, <line12> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line13> throws RemoteException { <line14> try { <line15> Map<Locale, String> nameMap = <line16> LocalizationUtil.getLocalizationMap(nameMapLanguageIds, nameMapValues); <line17> Map<Locale, String> descriptionMap = <line18> LocalizationUtil.getLocalizationMap(descriptionMapLanguageIds, descriptionMapValues); <line19> com.liferay.dynamic.data.mapping.model.DDMTemplate returnValue = <line20> DDMTemplateServiceUtil.updateTemplate( <line21> templateId, <line22> classPK, <line23> nameMap, <line24> descriptionMap, <line25> type, <line26> mode, <line27> language, <line28> script, <line29> cacheable, <line30> serviceContext); <line31> return com.liferay.dynamic.data.mapping.model.DDMTemplateSoap.toSoapModel(returnValue); <line32> } catch (Exception exception) { <line33> throw new RemoteException(exception.getMessage()); <line34> } <line35> } <line36> } <line37> 	 <line27>	No
public class A { <line0> public Contact getContact(RosterEntry r) { <line1> Contact contact = new Contact(); <line2> contact.name = r.getName(); <line3> contact.user = r.getUser(); <line4> contact.type = r.getType().toString(); <line5> Type presenceType = roster.getPresence(r.getUser()).getType(); <line6> if (presenceType != null) { <line7> contact.presence = presenceType.toString(); <line8> } <line9> ItemStatus status = r.getStatus(); <line10> if (status != null) { <line11> contact.status = status.toString(); <line12> } <line13> return contact; <line14> } <line15> } <line16> 	 <line12>	No
"public class A { <line0> @Override <line1> public List<String> getContentsId(IDataObjectListTagBean bean, RequestContext reqCtx) <line2> throws Throwable { <line3> List<String> dataObjectsId = null; <line4> try { <line5> dataObjectsId = this.extractContentsId(bean, reqCtx); <line6> dataObjectsId = this.executeFullTextSearch(bean, dataObjectsId, reqCtx); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error extracting dataObjects id"", t); <line9> } <line10> return dataObjectsId; <line11> } <line12> } <line13> "	 <line8>	Yes
"public class A { <line0> @Override <line1> public void initialise() throws InitialisationException { <line2> scheduler = <line3> schedulerService.customScheduler( <line4> SchedulerConfig.config() <line5> .withMaxConcurrentTasks(1) <line6> .withName(""PolicyManager-StaleCleaner"")); <line7> operationPolicyProcessorFactory = new DefaultOperationPolicyProcessorFactory(); <line8> sourcePolicyProcessorFactory = new DefaultSourcePolicyProcessorFactory(); <line9> policyProvider = registry.lookupByType(PolicyProvider.class).orElse(new NullPolicyProvider()); <line10> if (muleContext.getArtifactType().equals(APP)) { <line11> policyProvider.onPoliciesChanged( <line12> () -> { <line13> evictCaches(); <line14> isSourcePoliciesAvailable.set(policyProvider.isSourcePoliciesAvailable()); <line15> isOperationPoliciesAvailable.set(policyProvider.isOperationPoliciesAvailable()); <line16> }); <line17> isSourcePoliciesAvailable.set(policyProvider.isSourcePoliciesAvailable()); <line18> isOperationPoliciesAvailable.set(policyProvider.isOperationPoliciesAvailable()); <line19> } <line20> policyPointcutParametersManager = <line21> new PolicyPointcutParametersManager( <line22> registry.lookupAllByType(SourcePolicyPointcutParametersFactory.class), <line23> registry.lookupAllByType(OperationPolicyPointcutParametersFactory.class)); <line24> notificationManager.addListener( <line25> new FlowConstructNotificationListener<FlowConstructNotification>() { <line26> @Override <line27> public boolean isBlocking() { <line28> return false; <line29> } <line30>  <line31> @Override <line32> public void onNotification(FlowConstructNotification notification) { <line33> if (Integer.parseInt(notification.getAction().getIdentifier()) <line34> == FLOW_CONSTRUCT_STOPPED) { <line35> invalidateDisposedFlowFromCaches(notification.getResourceIdentifier()); <line36> } <line37> } <line38> }); <line39> } <line40> } <line41> "	 <line35>	Yes
public class A { <line0> @Override <line1> public void onPing(String ping) { <line2> } <line3> } <line4> 	 <line1>	No
"public class A { <line0> protected String checkDelete() { <line1> Category currentCategory = this.getCategory(this.getSelectedNode()); <line2> if (null == currentCategory) { <line3> this.addActionError(this.getText(""error.category.selectCategory"")); <line4> return ""categoryTree""; <line5> } <line6> if (currentCategory.getCode().equals(currentCategory.getParentCode())) { <line7> this.addActionError(this.getText(""error.category.homeDelete.notAllowed"")); <line8> return ""categoryTree""; <line9> } <line10> if (currentCategory.getChildrenCodes().length != 0) { <line11> this.addActionError(this.getText(""error.category.deleteWithChildren.notAllowed"")); <line12> return ""categoryTree""; <line13> } <line14> this.extractReferencingObjects(this.getSelectedNode()); <line15> if (null != this.getReferences() && this.getReferences().size() > 0) { <line16> return ""references""; <line17> } <line18> return null; <line19> } <line20> } <line21> "	 <line3>	Yes
public class A { <line0> protected void logProgress(Object info) { <line1> if (logger.isDebugEnabled()) { <line2> Runtime runtime = Runtime.getRuntime(); <line3> } <line4> } <line5> } <line6> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public synchronized void addConsumer(Consumer consumer) throws BrokerServiceException { <line2> if (IS_CLOSED_UPDATER.get(this) == TRUE) { <line3> consumer.disconnect(); <line4> return; <line5> } <line6> if (consumerList.isEmpty()) { <line7> if (havePendingRead || havePendingReplayRead) { <line8> shouldRewindBeforeReadingOrReplaying = true; <line9> } else { <line10> cursor.rewind(); <line11> shouldRewindBeforeReadingOrReplaying = false; <line12> } <line13> messagesToRedeliver.clear(); <line14> } <line15> if (isConsumersExceededOnSubscription()) { <line16> throw new ConsumerBusyException(""Subscription reached max consumers limit""); <line17> } <line18> consumerList.add(consumer); <line19> consumerList.sort((c1, c2) -> c1.getPriorityLevel() - c2.getPriorityLevel()); <line20> consumerSet.add(consumer); <line21> } <line22> } <line23> "	 <line3>	Yes
public class A { <line0> public static Image getImage(Client client, String imageId) <line1> throws InvalidParameterException, UnauthorizedRequestException, InstanceNotFoundException { <line2> Image image = (Image) generateOnePoolElement(client, imageId, Image.class); <line3> if (response.isError()) { <line4> String message = response.getErrorMessage(); <line5> if (message.contains(RESPONSE_NOT_AUTHORIZED)) { <line6> throw new UnauthorizedRequestException(); <line7> } <line8> throw new InstanceNotFoundException(message); <line9> } <line10> return image; <line11> } <line12> } <line13> 	 <line12>	No
public class A { <line0> protected synchronized void close() { <line1> if (isClosed) { <line2> return; <line3> } <line4> try { <line5> if (stmt != null) { <line6> try { <line7> stmt.close(); <line8> } catch (SQLException e) { <line9> } <line10> } <line11> } finally { <line12> if (conn != null) { <line13> try { <line14> conn.close(); <line15> } catch (SQLException e) { <line16> } <line17> } <line18> } <line19> isClosed = true; <line20> } <line21> } <line22> 	 <line9>	Yes
"public class A { <line0> protected Map<String, Object> loadProperties(ServletContext context) { <line1> Map<String, Object> returnMap = new HashMap<>(); <line2> Object configDir = context.getAttribute(""configDir""); <line3> if (configDir != null && configDir instanceof String) { <line4> configFile = new File(((String) configDir) + ""/godiva3.properties""); <line5> if (configFile.exists()) { <line6> lastModified = configFile.lastModified(); <line7> try (FileInputStream fis = new FileInputStream(configFile)) { <line8> Properties props = new Properties(); <line9> props.load(fis); <line10> for (Object key : props.keySet()) { <line11> Object value = props.getProperty((String) key); <line12> if (value instanceof String) { <line13> try { <line14> value = Integer.parseInt((String) value); <line15> } catch (Exception e) { <line16> } <line17> } <line18> if (key instanceof String) { <line19> returnMap.put((String) key, value); <line20> } <line21> } <line22> } catch (IOException e) { <line23> } <line24> } else { <line25> try (BufferedWriter writer = new BufferedWriter(new FileWriter(configFile))) { <line26> writer.write(""#mapHeight=512\n""); <line27> writer.write(""#mapWidth=1024\n""); <line28> writer.write(""#proxy=http://proxyUrlGoesHere/\n""); <line29> writer.write(""# Definition of user layers\n""); <line30> writer.write(""# First we define a layer with ID \""user\""\n""); <line31> writer.write(""# The URL of the WMS.  MANDATORY\n""); <line32> writer.write(""#userURL=http://wmsurl.com/with/query/separator/wms?\n""); <line33> writer.write( <line34> ""# The Title for the layer switcher. Defaults to the ID (i.e. \""user\"" in this"" <line35> + "" case)\n""); <line36> writer.write(""#userTitle=My WMS Layer\n""); <line37> writer.write(""# The layer(s) to plot.  MANDATORY\n""); <line38> writer.write(""#userLayers=wmslayer1,wmslayer2\n""); <line39> writer.write(""# The projection to use.  Defaults to \""CRS:84\""\n""); <line40> writer.write(""#userProjection=EPSG:4326\n""); <line41> writer.write(""# The WMS version to use.  Defaults to \""1.1.1\""\n""); <line42> writer.write(""#userVersion=1.3.0\n""); <line43> writer.write(""# The image format to use.  Defaults to \""image/png\""\n""); <line44> writer.write(""#userFormat=image/png\n""); <line45> writer.write( <line46> ""# Whether a layer should be switched on at load.  Can be defined for multiple"" <line47> + "" overlays, but only for one base layer\n""); <line48> writer.write(""#userOnByDefault=true\n""); <line49> writer.write( <line50> ""# Whether to use as an overlay (as opposed to a base map).  Defaults to false\n""); <line51> writer.write(""#userIsOverlay=true\n""); <line52> writer.close(); <line53> } catch (IOException e) { <line54> } <line55> } <line56> } else { <line57> } <line58> return returnMap; <line59> } <line60> } <line61> "	 <line23>	Yes
public class A { <line0> private int logRunningTime( <line1> String operationName, SupplierWithException<Integer, IOException> supplier) <line2> throws IOException { <line3> long startTimeMillis = System.currentTimeMillis(); <line4> int result = supplier.get(); <line5> return result; <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> public static void info(final Object caller, final String message) { <line1> String id = <line2> (caller == null) <line3> ? Messages.getInstance().getString(""Logger.DEBUG_LOG_UNKNOWN"") <line4> : caller.getClass().getName(); <line5> if (Logger.logLevel <= ILogger.INFO) { <line6> } <line7> } <line8> } <line9> "	 <line4>	No
"public class A { <line0> @Test <line1> public void wildcardResourcesAreOrderedAlphabetically() { <line2> final WroModel model = new WroModel(); <line3> final String uri = <line4> String.format( <line5> ClasspathUriLocator.PREFIX + ""%s/expander/order/**.js"", <line6> WroUtil.toPackageAsFolder(getClass())); <line7> model.addGroup(new Group(""group"").addResource(Resource.create(uri, ResourceType.JS))); <line8> Mockito.when(decoratedFactory.create()).thenReturn(model); <line9> final WroModel changedModel = transformer.transform(model); <line10> final Group group = new WroModelInspector(changedModel).getGroupByName(""group""); <line11> assertEquals(7, group.getResources().size()); <line12> final List<Resource> resources = group.getResources(); <line13> assertEquals(""01-xyc.js"", FilenameUtils.getName(resources.get(0).getUri())); <line14> assertEquals(""02-xyc.js"", FilenameUtils.getName(resources.get(1).getUri())); <line15> assertEquals(""03-jquery-ui.js"", FilenameUtils.getName(resources.get(2).getUri())); <line16> assertEquals(""04-xyc.js"", FilenameUtils.getName(resources.get(3).getUri())); <line17> assertEquals(""05-xyc.js"", FilenameUtils.getName(resources.get(4).getUri())); <line18> assertEquals(""06-xyc.js"", FilenameUtils.getName(resources.get(5).getUri())); <line19> assertEquals(""07-jquery-impromptu.js"", FilenameUtils.getName(resources.get(6).getUri())); <line20> } <line21> } <line22> "	 <line17>	No
public class A { <line0> @Override <line1> public void setOptionsToDefault(Session session) { <line2> if (session != null) { <line3> session.setCerberus_selenium_wait_element( <line4> session.getCerberus_selenium_wait_element_default()); <line5> session.setCerberus_appium_wait_element(session.getCerberus_appium_wait_element_default()); <line6> session.setCerberus_sikuli_wait_element(session.getCerberus_sikuli_wait_element_default()); <line7> session.setCerberus_selenium_highlightElement( <line8> session.getCerberus_selenium_highlightElement_default()); <line9> session.setCerberus_sikuli_highlightElement( <line10> session.getCerberus_sikuli_highlightElement_default()); <line11> session.setCerberus_sikuli_minSimilarity(session.getCerberus_sikuli_minSimilarity_default()); <line12> } <line13> } <line14> } <line15> 	 <line1>	No
"public class A { <line0> public boolean login() throws LoginException { <line1> try { <line2> users = readProperties(usersUrl); <line3> } catch (final IOException ioe) { <line4> throw new LoginException(""Unable to load user properties file "" + usersUrl.getFile()); <line5> } <line6> try { <line7> groups = readProperties(groupsUrl); <line8> } catch (final IOException ioe) { <line9> throw new LoginException(""Unable to load group properties file "" + groupsUrl.getFile()); <line10> } <line11> final Callback[] callbacks = new Callback[2]; <line12> callbacks[0] = new NameCallback(""Username: ""); <line13> callbacks[1] = new PasswordCallback(""Password: "", false); <line14> try { <line15> callbackHandler.handle(callbacks); <line16> } catch (final IOException ioe) { <line17> throw new LoginException(ioe.getMessage()); <line18> } catch (final UnsupportedCallbackException uce) { <line19> throw new LoginException(uce.getMessage() + "" not available to obtain information from user""); <line20> } <line21> user = ((NameCallback) callbacks[0]).getName(); <line22> char[] tmpPassword = ((PasswordCallback) callbacks[1]).getPassword(); <line23> if (tmpPassword == null) { <line24> tmpPassword = new char[0]; <line25> } <line26> final String password = users.getProperty(user); <line27> if (password == null) { <line28> throw new FailedLoginException(""User does not exist""); <line29> } <line30> if (!password.equals(new String(tmpPassword))) { <line31> throw new FailedLoginException(""Password does not match""); <line32> } <line33> users.clear(); <line34> if (debug) { <line35> } <line36> return true; <line37> } <line38> } <line39> "	 <line13>	No
"public class A { <line0> @Test( <line1> groups = {""Phase 1 Shape""}, <line2> description = ""invalid column shape_dist_traveled"", <line3> priority = 242) <line4> public void verifyTest_2_7() throws Exception { <line5> Context context = new Context(); <line6> CheckPointReport result = <line7> verifyValidation( <line8> log, context, ""shape_7"", GTFS_1_GTFS_Common_16, SEVERITY.ERROR, RESULT.NOK, true); <line9> Assert.assertEquals(result.getCheckPointErrorCount(), 1, ""detail count""); <line10> for (CheckPointErrorReport detail : getDetails(context, result)) { <line11> Assert.assertNotNull(detail.getSource(), ""detail must refer a source""); <line12> Assert.assertNotNull(detail.getSource().getFile(), ""detail must refer a file source""); <line13> Assert.assertEquals( <line14> detail.getSource().getFile().getFilename(), ""shapes.txt"", ""detail must refer bad file""); <line15> Assert.assertEquals( <line16> detail.getSource().getFile().getLineNumber(), <line17> Integer.valueOf(4), <line18> ""detail must refer bad line""); <line19> } <line20> } <line21> } <line22> "	 <line4>	No
"public class A { <line0> @Test <line1> public void testSetCombinerConfigurationIfNecessary() <line2> throws AccumuloSecurityException, AccumuloException, TableNotFoundException { <line3> try { <line4> AbstractTableConfigHelperTest.TestAbstractTableConfigHelperImpl uut = <line5> new AbstractTableConfigHelperTest.TestAbstractTableConfigHelperImpl(); <line6> Assert.assertNotNull(""AbstractTableConfigHelper.cTor failed to create an instance"", uut); <line7> uut.parent = this; <line8> uut.exposeSetCombinerConfigurationIfNecessaryForTest(); <line9> } finally { <line10> } <line11> } <line12> } <line13> "	 <line10>	Yes
public class A { <line0> public void setRight(long position) throws IOException { <line1> if (position == right()) return; <line2> try { <line3> flushLock.lock(); <line4> writeLock.lock(); <line5> deleteLock.lock(); <line6> if (position <= left() || position > right()) { <line7> clear(); <line8> this.leftPosition.set(position); <line9> this.rightPosition.set(position); <line10> this.flushPosition.set(position); <line11> } else if (position < right()) { <line12> rollbackFiles(position); <line13> this.rightPosition.set(position); <line14> if (this.flushPosition() > position) this.flushPosition.set(position); <line15> } <line16> resetWriteStoreFile(); <line17> } finally { <line18> deleteLock.unlock(); <line19> writeLock.unlock(); <line20> flushLock.unlock(); <line21> } <line22> } <line23> } <line24> 	 <line21>	Yes
public class A { <line0> private static void validateFESLPOLICY(InputStream content) throws ValidationException { <line1> if (feslPolicyParser != null) { <line2> feslPolicyParser.copy().parse(content, validateFeslPolicy); <line3> } <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> void securityMessageReceived(NextFilter nextFilter, IoSession session, Object message) <line1> throws Exception { <line2> final boolean loggerIsEnabled = logger != null && logger.isTraceEnabled(); <line3> if (!httpRequestMessageReceived(nextFilter, session, message)) return; <line4> HttpRequestMessage httpRequest = (HttpRequestMessage) message; <line5> ResourceAddress httpAddress = httpRequest.getLocalAddress(); <line6> if (alreadyLoggedIn(httpRequest)) { <line7> if (httpRequest.getLoginContext() == null) { <line8> setUnprotectedLoginContext(httpRequest); <line9> } <line10> if (loggerIsEnabled) { <line11> } <line12> super.doMessageReceived(nextFilter, session, message); <line13> return; <line14> } <line15> HttpRealmInfo[] realms = httpAddress.getOption(HttpResourceAddress.REALMS); <line16> if (realms.length == 0) { <line17> setUnprotectedLoginContext(httpRequest); <line18> if (loggerIsEnabled) { <line19> } <line20> super.doMessageReceived(nextFilter, session, message); <line21> return; <line22> } <line23> String challengeIdentity = httpRequest.getHeader(HEADER_SEC_CHALLENGE_IDENTITY); <line24> LoginContext[] loginContexts = getLoginContexts(challengeIdentity); <line25> int realmIndex = findCurrentRealm(loginContexts); <line26> HttpRealmInfo realm = realms[realmIndex]; <line27> AuthenticationTokenExtractor tokenExtractor = DefaultAuthenticationTokenExtractor.INSTANCE; <line28> DefaultAuthenticationToken authToken = <line29> (DefaultAuthenticationToken) tokenExtractor.extract(httpRequest, realm); <line30> String expectedChallengeScheme = getBaseAuthScheme(realm.getChallengeScheme()); <line31> if (authToken.getScheme() == null) { <line32> authToken.setScheme(expectedChallengeScheme); <line33> } <line34> suspendIncoming(session); <line35> TypedCallbackHandlerMap additionalCallbacks = null; <line36> if (realmIndex > 0) { <line37> additionalCallbacks = new TypedCallbackHandlerMap(); <line38> Function<String, Subject> subjects = <line39> name -> findNamedSubject(name, realms, realmIndex, loginContexts); <line40> NamedSubjectCallbackHandler callbackHandler = new NamedSubjectCallbackHandler(subjects); <line41> additionalCallbacks.put(NamedSubjectCallback.class, callbackHandler); <line42> } <line43> LoginContextTask loginContextTask = <line44> new LoginContextTask( <line45> nextFilter, <line46> session, <line47> httpRequest, <line48> authToken, <line49> additionalCallbacks, <line50> realms, <line51> realmIndex, <line52> loginContexts); <line53> scheduler.execute(loginContextTask); <line54> } <line55> } <line56> 	 <line11>	Yes
"public class A { <line0> public void run() { <line1> try { <line2> this.sleep(2000); <line3> } catch (InterruptedException e) { <line4> return; <line5> } <line6> for (int j = 0; j < nodeNum; j++) { <line7> VcVirtualMachine vm = MockVcCache.getIgnoreMissing(VM_MOB_PREFIX + j); <line8> Map<String, String> map = new HashMap<String, String>(); <line9> switch (settings) { <line10> case 0: <line11> if (flag) { <line12> map.put(Constants.VM_DISK_FORMAT_STATUS_KEY, ""1""); <line13> map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY, ""1""); <line14> } <line15> break; <line16> case 1: <line17> if (flag) { <line18> map.put(Constants.VM_DISK_FORMAT_STATUS_KEY, ""0""); <line19> map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY, ""0""); <line20> map.put( <line21> ""guestinfo.network_info"", <line22> ""{'nics': [{'device': 'eth0', 'ipaddr': '192.168.1.100', 'fqdn':"" <line23> + "" 'vmname.eng.vmware.com', 'portgroup': 'test_portgroup'}]}""); <line24> } else { <line25> map.put(Constants.VM_DISK_FORMAT_STATUS_KEY, ""1""); <line26> map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY, ""1""); <line27> } <line28> break; <line29> default: <line30> break; <line31> } <line32> Mockito.when(vm.getGuestVariables()).thenReturn(map); <line33> } <line34> } <line35> } <line36> "	 <line4>	Yes
"public class A { <line0> public String getDateVsTaskInstanceCount(String filters) { <line1> String sortedResult = """"; <line2> try { <line3> if (BPMNAnalyticsCoreUtils.isDASAnalyticsActivated()) { <line4> JSONObject filterObj = new JSONObject(filters); <line5> long from = filterObj.getLong(BPMNAnalyticsCoreConstants.START_TIME); <line6> long to = filterObj.getLong(BPMNAnalyticsCoreConstants.END_TIME); <line7> String processId = filterObj.getString(BPMNAnalyticsCoreConstants.PROCESS_ID); <line8> JSONArray taskIdList = filterObj.getJSONArray(BPMNAnalyticsCoreConstants.TASK_ID_LIST); <line9> AggregateField countField = new AggregateField(); <line10> countField.setFieldName(BPMNAnalyticsCoreConstants.ALL); <line11> countField.setAggregate(BPMNAnalyticsCoreConstants.COUNT); <line12> countField.setAlias(BPMNAnalyticsCoreConstants.TASK_INSTANCE_COUNT); <line13> ArrayList<AggregateField> aggregateFields = new ArrayList<>(); <line14> aggregateFields.add(countField); <line15> AggregateQuery query = new AggregateQuery(); <line16> query.setTableName(BPMNAnalyticsCoreConstants.TASK_USAGE_TABLE); <line17> query.setGroupByField(BPMNAnalyticsCoreConstants.FINISHED_TIME); <line18> String queryStr = <line19> BPMNAnalyticsCoreUtils.getDateRangeQuery( <line20> BPMNAnalyticsCoreConstants.COLUMN_FINISHED_TIME, from, to); <line21> queryStr += ""AND "" + ""processDefinitionId:"" + ""\""'"" + processId + ""'\""""; <line22> if (taskIdList.length() != 0) { <line23> queryStr += "" AND ""; <line24> for (int i = 0; i < taskIdList.length(); i++) { <line25> if (i == 0) { <line26> queryStr += ""(taskDefinitionKey:"" + ""\""'"" + taskIdList.getString(i) + ""'\""""; <line27> } else { <line28> queryStr += "" OR "" + ""taskDefinitionKey:"" + ""\""'"" + taskIdList.getString(i) + ""'\""""; <line29> } <line30> if (i == taskIdList.length() - 1) { <line31> queryStr += "")""; <line32> } <line33> } <line34> } <line35> query.setQuery(queryStr); <line36> query.setAggregateFields(aggregateFields); <line37> String result = <line38> BPMNAnalyticsCoreRestClient.post( <line39> BPMNAnalyticsCoreUtils.getURL(BPMNAnalyticsCoreConstants.ANALYTICS_AGGREGATE), <line40> BPMNAnalyticsCoreUtils.getJSONString(query)); <line41> JSONArray unsortedResultArray = new JSONArray(result); <line42> Hashtable<Long, Integer> table = new Hashtable<>(); <line43> if (unsortedResultArray.length() != 0) { <line44> for (int i = 0; i < unsortedResultArray.length(); i++) { <line45> JSONObject jsonObj = unsortedResultArray.getJSONObject(i); <line46> JSONObject values = jsonObj.getJSONObject(BPMNAnalyticsCoreConstants.VALUES); <line47> long completedTime = <line48> Long.parseLong( <line49> values.getJSONArray(BPMNAnalyticsCoreConstants.FINISHED_TIME).getString(0)); <line50> int taskInstanceCount = values.getInt(BPMNAnalyticsCoreConstants.TASK_INSTANCE_COUNT); <line51> table.put(completedTime, taskInstanceCount); <line52> } <line53> sortedResult = <line54> BPMNAnalyticsCoreUtils.getLongKeySortedList( <line55> table, <line56> BPMNAnalyticsCoreConstants.FINISHED_TIME, <line57> BPMNAnalyticsCoreConstants.TASK_INSTANCE_COUNT); <line58> } <line59> } <line60> } catch (JSONException | IOException | XMLStreamException e) { <line61> } <line62> if (log.isDebugEnabled()) { <line63> } <line64> return sortedResult; <line65> } <line66> } <line67> "	 <line61>	Yes
public class A { <line0> @PostConstruct <line1> public void setup() { <line2> if (!_initialized) { <line3> final InitThread initThread = new InitThread(this); <line4> new Thread(initThread).start(); <line5> _initialized = true; <line6> } <line7> } <line8> } <line9> 	 <line5>	No
public class A { <line0> public void close() { <line1> close( <line2> h -> { <line3> if (h.failed()) { <line4> } <line5> }); <line6> } <line7> } <line8> 	 <line2>	No
"public class A { <line0> public List<AttributeInterface> getAllowedAttributeElementTypes() { <line1> List<AttributeInterface> attributes = new ArrayList<AttributeInterface>(); <line2> try { <line3> IEntityManager entityManager = this.getEntityManager(); <line4> Map<String, AttributeInterface> attributeTypes = entityManager.getEntityAttributePrototypes(); <line5> Iterator<AttributeInterface> attributeIter = attributeTypes.values().iterator(); <line6> while (attributeIter.hasNext()) { <line7> AttributeInterface attribute = attributeIter.next(); <line8> if (attribute.isSimple()) { <line9> attributes.add(attribute); <line10> } <line11> } <line12> Collections.sort(attributes, new BeanComparator(""type"")); <line13> } catch (Throwable t) { <line14> throw new RuntimeException(""Error extracting the allowed types of attribute elements"", t); <line15> } <line16> return attributes; <line17> } <line18> } <line19> "	 <line5>	No
"public class A { <line0> public static ImageWriter getImageWriterFromImageIOServiceRegistry(ImageWriterParam param) { <line1> Iterator<ImageWriter> iter = ImageIO.getImageWritersByFormatName(param.formatName); <line2> if (!iter.hasNext()) <line3> throw new RuntimeException(""No Writer for format: "" + param.formatName + "" registered""); <line4> ImageWriter writer = iter.next(); <line5> if (param.className != null) { <line6> while (!param.className.equals(writer.getClass().getName())) { <line7> if (iter.hasNext()) writer = iter.next(); <line8> else { <line9> break; <line10> } <line11> } <line12> } <line13> return writer; <line14> } <line15> } <line16> "	 <line2>	No
"public class A { <line0> private ClusterDatabaseSet tryAdapt(DefaultDatabaseSet defaultDatabaseSet) { <line1> try { <line2> DataBase master = defaultDatabaseSet.getMasterDbs().iterator().next(); <line3> if ((master instanceof DefaultDataBase) && !(master instanceof ProviderDataBase)) { <line4> String databaseKey = master.getConnectionString(); <line5> Map<String, DalConnectionString> failedConnectionStrings = <line6> DataSourceConfigureLocatorManager.getInstance().getFailedConnectionStrings(); <line7> if (failedConnectionStrings == null || !failedConnectionStrings.containsKey(databaseKey)) { <line8> ClusterInfo clusterInfo = clusterInfoProvider.getClusterInfo(databaseKey); <line9> if (clusterInfo != null <line10> && clusterInfo.getRole() == DatabaseRole.MASTER <line11> && !clusterInfo.dbSharding()) { <line12> String clusterName = clusterInfo.getClusterName(); <line13> Cluster cluster = <line14> clusterManager.getOrCreateCluster( <line15> clusterName, new DefaultDalConfigCustomizedOption()); <line16> if (checkCluster(cluster)) { <line17> LOGGER.logEvent( <line18> DalLogTypes.DAL_VALIDATION, <line19> ""ClusterAdaptSucceeded"", <line20> String.format( <line21> ""databaseSet: %s, clusterName: %s"", <line22> defaultDatabaseSet.getName(), clusterName)); <line23> return new ClusterDatabaseSet( <line24> defaultDatabaseSet.getName(), cluster, connectionLocator); <line25> } <line26> } <line27> } <line28> } <line29> LOGGER.logEvent( <line30> DalLogTypes.DAL_VALIDATION, <line31> ""ClusterAdaptSkipped"", <line32> String.format(""databaseSet: %s"", defaultDatabaseSet.getName())); <line33> } catch (Throwable t) { <line34> LOGGER.logEvent( <line35> DalLogTypes.DAL_VALIDATION, <line36> ""ClusterAdaptFailed"", <line37> String.format(""databaseSet: %s"", defaultDatabaseSet.getName())); <line38> } <line39> return null; <line40> } <line41> } <line42> "	 <line38>	Yes
"public class A { <line0> private void registerCustomCodeRunner(HelixManager manager) { <line1> try { <line2> if (manager.getInstanceName().equals(""localhost_12918"")) { <line3> Thread.sleep(2000); <line4> } <line5> HelixCustomCodeRunner customCodeRunner = new HelixCustomCodeRunner(manager, ZK_ADDR); <line6> customCodeRunner <line7> .invoke(_callback) <line8> .on(ChangeType.LIVE_INSTANCE) <line9> .usingLeaderStandbyModel(""TestParticLeader"") <line10> .start(); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> "	 <line1>	No
"public class A { <line0> @Test <line1> public void testEvent() <line2> throws EventDeliveryException, MQBrokerException, MQClientException, InterruptedException, <line3> UnsupportedEncodingException, RemotingException { <line4> DefaultMQProducer producer = new DefaultMQProducer(producerGroup); <line5> producer.setNamesrvAddr(nameServer); <line6> String sendMsg = <line7> ""\""Hello Flume\"""" + "","" + DateFormatUtils.format(new Date(), ""yyyy-MM-dd hh:mm:ss""); <line8> producer.start(); <line9> Message msg = new Message(TOPIC_DEFAULT, tag, sendMsg.getBytes(""UTF-8"")); <line10> SendResult sendResult = producer.send(msg); <line11> Context context = new Context(); <line12> context.put(NAME_SERVER_CONFIG, nameServer); <line13> context.put(TAG_CONFIG, tag); <line14> Channel channel = new MemoryChannel(); <line15> Configurables.configure(channel, context); <line16> List<Channel> channels = new ArrayList<>(); <line17> channels.add(channel); <line18> ChannelSelector channelSelector = new ReplicatingChannelSelector(); <line19> channelSelector.setChannels(channels); <line20> ChannelProcessor channelProcessor = new ChannelProcessor(channelSelector); <line21> RocketMQSource source = new RocketMQSource(); <line22> source.setChannelProcessor(channelProcessor); <line23> Configurables.configure(source, context); <line24> source.start(); <line25> Thread.sleep(2000); <line26> sendMsg = ""\""Hello Flume\"""" + "","" + DateFormatUtils.format(new Date(), ""yyyy-MM-dd hh:mm:ss""); <line27> msg = new Message(TOPIC_DEFAULT, tag, sendMsg.getBytes(""UTF-8"")); <line28> sendResult = producer.send(msg); <line29> PollableSource.Status status = source.process(); <line30> if (status == PollableSource.Status.BACKOFF) { <line31> fail(""Error""); <line32> } <line33> Thread.sleep(1000); <line34> producer.shutdown(); <line35> source.stop(); <line36> Transaction transaction = channel.getTransaction(); <line37> transaction.begin(); <line38> Event event = channel.take(); <line39> if (event == null) { <line40> transaction.commit(); <line41> fail(""Error""); <line42> } <line43> byte[] body = event.getBody(); <line44> String receiveMsg = new String(body, ""UTF-8""); <line45> assertEquals(sendMsg, receiveMsg); <line46> } <line47> } <line48> "	 <line7>	No
public class A { <line0> private void ackSentQueue(int ackNum) { <line1> if (sentTime != 0) { <line2> stopRetryTimer(); <line3> receiveTimeout = <line4> (int) ((receiveTimeout * 7 / 8) + ((System.nanoTime() - sentTime) / 2000000)); <line5> if (receiveTimeout < T_RX_ACK_MIN) { <line6> receiveTimeout = T_RX_ACK_MIN; <line7> } else if (receiveTimeout > T_RX_ACK_MAX) { <line8> receiveTimeout = T_RX_ACK_MAX; <line9> } <line10> sentTime = 0; <line11> } <line12> while (sentQueue.peek() != null && sentQueue.peek().getFrmNum() != ackNum) { <line13> AshFrameData ackedFrame = sentQueue.poll(); <line14> } <line15> } <line16> } <line17> 	 <line10>	Yes
"public class A { <line0> @Test <line1> public void testHandleGetRequest() { <line2> String jsonResponse = JsonLoader.loadJson(DomainHelper.getRestUrlV2() + ""/content/words""); <line3> JSONArray wordsJSONArray = new JSONArray(jsonResponse); <line4> assertThat(wordsJSONArray.length() > 0, is(true)); <line5> JSONObject wordJsonObject = wordsJSONArray.getJSONObject(0); <line6> assertThat(wordJsonObject.getLong(""id""), not(nullValue())); <line7> assertThat(wordJsonObject.getString(""text""), not(nullValue())); <line8> } <line9> } <line10> "	 <line3>	Yes
"public class A { <line0> public RetryMessageModel getMessageById(final String topic, final String app, final long id) <line1> throws JoyQueueException { <line2> final long nowTime = SystemClock.now(); <line3> try { <line4> RetryMessageModel retryMessageModel = <line5> DaoUtil.queryObject( <line6> readDataSource, <line7> GET_SQL, <line8> new DaoUtil.QueryCallback<RetryMessageModel>() { <line9> @Override <line10> public void before(PreparedStatement preparedStatement) throws Exception { <line11> preparedStatement.setString(1, topic); <line12> preparedStatement.setString(2, app); <line13> preparedStatement.setTimestamp(3, new Timestamp(nowTime)); <line14> preparedStatement.setLong(4, id); <line15> } <line16>  <line17> @Override <line18> public RetryMessageModel map(ResultSet rs) throws Exception { <line19> RetryMessageModel message = new RetryMessageModel(); <line20> message.setIndex(rs.getInt(1)); <line21> message.setBusinessId(rs.getString(2)); <line22> message.setTopic(rs.getString(3)); <line23> message.setApp(rs.getString(4)); <line24> message.setPartition(Partition.RETRY_PARTITION_ID); <line25> message.setBrokerMessage(rs.getBytes(5)); <line26> message.setException(rs.getBytes(6)); <line27> message.setSendTime(rs.getLong(7)); <line28> return message; <line29> } <line30> }); <line31> return retryMessageModel; <line32> } catch (Exception e) { <line33> throw new JoyQueueException( <line34> String.format( <line35> ""%s topic:%s,app:%s,id:%d"", JoyQueueCode.CN_DB_ERROR.getMessage(), topic, app, id), <line36> e, <line37> JoyQueueCode.CN_DB_ERROR.getCode()); <line38> } <line39> } <line40> } <line41> "	 <line28>	No
public class A { <line0> private void handleTransferState(@NotNull TransferStateOuterClass.TransferState cmd) { <line1> try { <line2> String sessionId = state.transfer(cmd); <line3> events.contextChanged(); <line4> loadSession(sessionId, !cmd.getPlayback().getIsPaused(), true); <line5> } catch (IOException | MercuryClient.MercuryException ex) { <line6> panicState(null); <line7> } catch (AbsSpotifyContext.UnsupportedContextException ex) { <line8> panicState(null); <line9> } <line10> } <line11> } <line12> 	 <line8>	Yes
"public class A { <line0> public boolean send( <line1> final Mail composedMessage, <line2> final String icalContent, <line3> final Collection<? extends MailAttachment> attachments, <line4> boolean async) { <line5> if (composedMessage == null) { <line6> return false; <line7> } <line8> final List<InternetAddress> to = composedMessage.getTo(); <line9> if (to == null || to.size() == 0) { <line10> throw new UserException(""mail.error.missingToAddress""); <line11> } <line12> MailSessionLocalSettingsConfigModel cf = <line13> configurationService.createMailSessionLocalSettingsConfigModel(); <line14> if (cf == null || !cf.isEmailEnabled()) { <line15> return false; <line16> } <line17> if (async) { <line18> CompletableFuture.runAsync(() -> sendIt(composedMessage, icalContent, attachments)); <line19> } else { <line20> sendIt(composedMessage, icalContent, attachments); <line21> } <line22> return true; <line23> } <line24> } <line25> "	 <line6>	Yes
"public class A { <line0> protected Response makeBearerError(BearerTokenError error) { <line1> String header = error.toWWWAuthenticateHeader(); <line2> return toResponse( <line3> Response.status(error.getHTTPStatusCode()).header(""WWW-Authenticate"", header)); <line4> } <line5> } <line6> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void onError(Throwable throwable) { <line2> XdsSchedulerManager.getInstance().startApplicationKeyMappingDiscoveryScheduling(); <line3> nack(throwable); <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void schedule(JobExecutionContext jobExecutionContext) throws Exception { <line2> List<String> ids = null; <line3> try (EntityManagerContainer emc = EntityManagerContainerFactory.instance().create()) { <line4> ids = attendanceDetailMobileService.listAllAnalyseWithStatus(emc, 0); <line5> } catch (Exception e) { <line6> } <line7> if (ids != null && !ids.isEmpty()) { <line8> for (String id : ids) { <line9> try { <line10> attendanceDetailMobileAnalyseServiceAdv.analyseAttendanceDetailMobile(id, false); <line11> } catch (Exception e) { <line12> } <line13> } <line14> } <line15> } <line16> } <line17> 	 <line8>	No
"public class A { <line0> public void commitParticipant( <line1> final List<HmilyParticipant> hmilyParticipantList, final Long selfParticipantId) { <line2> if (CollectionUtils.isEmpty(hmilyParticipantList)) { <line3> return; <line4> } <line5> for (HmilyParticipant participant : hmilyParticipantList) { <line6> try { <line7> if (participant.getParticipantId().equals(selfParticipantId)) { <line8> HmilyTacLocalParticipantExecutor.confirm(participant); <line9> } else { <line10> HmilyReflector.executor(HmilyActionEnum.CONFIRMING, ExecutorTypeEnum.RPC, participant); <line11> } <line12> } catch (Throwable throwable) { <line13> throw new HmilyRuntimeException( <line14> "" hmilyParticipant execute confirm exception:"" + participant.toString()); <line15> } finally { <line16> HmilyContextHolder.remove(); <line17> } <line18> } <line19> } <line20> } <line21> "	 <line4>	No
public class A { <line0> private void successJoin(SIPCallImpl call) { <line1> try { <line2> _peer = _call2; <line3> MediaDialect dialect = ((ApplicationContextImpl) _call1.getApplicationContext()).getDialect(); <line4> dialect.setDtmfPassThrough((NetworkConnection) _call1.getMediaObject(), dtmfPassThrough); <line5> dialect.setDtmfPassThrough((NetworkConnection) call.getMediaObject(), dtmfPassThrough); <line6> _call1.linkCall(call, _joinType, _direction); <line7> _call1.setJoiningPeer(null); <line8> call.setJoiningPeer(null); <line9> done(Cause.JOINED, null); <line10> } catch (final Exception e) { <line11> done(Cause.ERROR, e); <line12> failCall(call, e); <line13> if (!candidateCalls.isEmpty()) { <line14> disconnectCalls(candidateCalls); <line15> } <line16> } <line17> } <line18> } <line19> 	 <line18>	No
public class A { <line0> private void refresh() { <line1> List<Thing> things = <line2> getThing().getThings().stream() <line3> .filter(thing -> thing.getHandler() instanceof NikobusModuleHandler) <line4> .collect(Collectors.toList()); <line5> if (!commandListeners.isEmpty()) { <line6> NikobusConnection connection = this.connection; <line7> if (connection == null) { <line8> return; <line9> } <line10> try { <line11> connectIfNeeded(connection); <line12> } catch (IOException e) { <line13> connection.close(); <line14> updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage()); <line15> return; <line16> } <line17> } <line18> if (things.isEmpty()) { <line19> return; <line20> } <line21> refreshThingIndex = (refreshThingIndex + 1) % things.size(); <line22> ThingHandler thingHandler = things.get(refreshThingIndex).getHandler(); <line23> if (thingHandler == null) { <line24> return; <line25> } <line26> NikobusModuleHandler handler = (NikobusModuleHandler) thingHandler; <line27> handler.refreshModule(); <line28> } <line29> } <line30> 	 <line19>	Yes
"public class A { <line0> public static void main(String[] args) throws Exception { <line1> initTracing(); <line2> initStatsExporter(); <line3> Server server = new Server(8080); <line4> ServletContextHandler contextHandler = <line5> new ServletContextHandler(ServletContextHandler.SESSIONS); <line6> contextHandler.setContextPath(""/helloworld""); <line7> ServletHolder sh = new ServletHolder(new HelloServlet()); <line8> contextHandler.addServlet(sh, ""/request/*""); <line9> contextHandler.addFilter(OcHttpServletFilter.class, ""/*"", EnumSet.of(DispatcherType.REQUEST)); <line10> server.setHandler(contextHandler); <line11> try { <line12> server.start(); <line13> server.join(); <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> "	 <line15>	Yes
public class A { <line0> @Override <line1> public Map<String, Object> getServiceBindingParameters(UUID guid) { <line2> return delegate.getServiceBindingParameters(guid); <line3> } <line4> } <line5> 	 <line1>	No
public class A { <line0> private void downloadUpdatedFiles(List<String> toDownload) throws IOException { <line1> for (String path : toDownload) { <line2> long t3 = SystemTime.currentTimeMillis(); <line3> InputStream in = _ftpClient.retrieveFileStream(path); <line4> if (!FTPReply.isPositivePreliminary(_ftpClient.getReplyCode())) { <line5> continue; <line6> } <line7> _reader.readEntities(OrbcadRecord.class, in); <line8> in.close(); <line9> if (!_ftpClient.completePendingCommand()) { <line10> continue; <line11> } <line12> long t4 = SystemTime.currentTimeMillis(); <line13> } <line14> } <line15> } <line16> 	 <line5>	Yes
"public class A { <line0> @Test <line1> void withHeaderLoggerShouldBeUsedAsHeader() throws IOException { <line2> Path targetFile = dir.homePath().resolve(""debug.log""); <line3> Path targetFile1 = dir.homePath().resolve(""debug.log.1""); <line4> ctx = <line5> LogConfig.createBuilder(fs, targetFile, Level.INFO) <line6> .withRotation(30, 2) <line7> .withHeaderLogger( <line8> log -> { <line9> }, <line10> ""org.neo4j.HeaderClassName"") <line11> .build(); <line12> assertThat(fs.fileExists(targetFile)).isEqualTo(true); <line13> Logger logger = ctx.getLogger(""className""); <line14> assertThat(fs.fileExists(targetFile)).isEqualTo(true); <line15> assertThat(fs.fileExists(targetFile1)).isEqualTo(true); <line16> assertThat(Files.readString(targetFile1)) <line17> .matches( <line18> DATE_PATTERN <line19> + format( <line20> "" %-5s \\[className] Long line that will get next message to be written to next"" <line21> + "" file%n"", <line22> Level.WARN)); <line23> assertThat(Files.readString(targetFile)) <line24> .matches( <line25> format( <line26> DATE_PATTERN <line27> + "" %-5s \\[o\\.n\\.HeaderClassName] My Header%n"" <line28> + DATE_PATTERN <line29> + "" %-5s \\[o\\.n\\.HeaderClassName] In Two Lines%n"" <line30> + DATE_PATTERN <line31> + "" %-5s \\[className] test2%n"", <line32> Level.WARN, <line33> Level.WARN, <line34> Level.WARN)); <line35> } <line36> } <line37> "	 <line24>	No
"public class A { <line0> public Map<String, Object> getUniqueApp(String assetGroup) { <line1> Map<String, Object> uniqueApp = new HashMap<>(); <line2> StringBuilder urlToQuery = new StringBuilder(esUrl).append(""/"").append(assetGroup); <line3> urlToQuery.append(""/"").append(""_search?filter_path=aggregations""); <line4> StringBuilder requestBody = <line5> new StringBuilder( <line6> ""{\""size\"":0,\""query\"":{\""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""_entity\"":true}}]}},"" <line7> + ""\""aggs\"":{\""severity\"":{\""filters\"":{\""filters\"":{\""S3\"":{\""has_child\"":{\""type\"":\""vulninfo\"",\""query\"":{"" <line8> + "" \""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""severitylevel.keyword\"":3}}]}}}},\""S4\"":{\""has_child\"":{\""type\"":\""vulninfo\"",\""query\"":{"" <line9> + "" \""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""severitylevel.keyword\"":4}}]}}}},\""S5\"":{\""has_child\"":{\""type\"":\""vulninfo\"",\""query\"":{"" <line10> + "" \""bool\"":{\""must\"":[{\""match\"":{\""latest\"":true}},{\""match\"":{\""severitylevel.keyword\"":5}}]}}}}}},\""aggs\"":{\""NAME\"":{\""cardinality\"":{\""field\"":\""tags.Application.keyword\"",\""precision_threshold\"":"" <line11> + "" 40000}}}}}}""); <line12> String responseJson = """"; <line13> try { <line14> responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString()); <line15> } catch (Exception e) { <line16> } <line17> JsonParser jsonParser = new JsonParser(); <line18> if (StringUtils.isNotEmpty(responseJson)) { <line19> JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson); <line20> JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString()); <line21> JsonObject buckets = aggsJson.getAsJsonObject(SEVERITY).getAsJsonObject(BUCKETS); <line22> for (int i = 3; i <= 5; i++) { <line23> uniqueApp.put( <line24> String.valueOf(i), <line25> buckets <line26> .get(""S"" + i) <line27> .getAsJsonObject() <line28> .get(""NAME"") <line29> .getAsJsonObject() <line30> .get(VALUE) <line31> .getAsLong()); <line32> } <line33> } <line34> return uniqueApp; <line35> } <line36> } <line37> "	 <line16>	Yes
"public class A { <line0> private void handleClusterTopologyUpdate(Message<?> handler) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> try { <line4> synchronizeProjectRoutes(); <line5> } catch (Exception e) { <line6> handler.fail(400, ""Could not initialize projects.""); <line7> } <line8> permCache.get().clear(); <line9> } <line10> } <line11> "	 <line6>	Yes
public class A { <line0> private boolean valid(MultiSearchResult.MultiSearchResponse multiSearchResponse) { <line1> if (multiSearchResponse.isError) { <line2> return false; <line3> } <line4> return true; <line5> } <line6> } <line7> 	 <line4>	No
"public class A { <line0> CompletableFuture<String> triggerSavepoint(String targetDirectory, boolean cancelJob) { <line1> final CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator(); <line2> if (checkpointCoordinator == null) { <line3> throw new IllegalStateException( <line4> String.format(""Job %s is not a streaming job."", executionGraph.getJobID())); <line5> } else if (targetDirectory == null <line6> && !checkpointCoordinator.getCheckpointStorage().hasDefaultSavepointLocation()) { <line7> throw new IllegalStateException( <line8> ""No savepoint directory configured. You can either specify a directory "" <line9> + ""while cancelling via -s :targetDirectory or configure a cluster-wide "" <line10> + ""default via key '"" <line11> + CheckpointingOptions.SAVEPOINT_DIRECTORY.key() <line12> + ""'.""); <line13> } <line14> if (cancelJob) { <line15> checkpointCoordinator.stopCheckpointScheduler(); <line16> } <line17> return checkpointCoordinator <line18> .triggerSavepoint(targetDirectory) <line19> .thenApply(CompletedCheckpoint::getExternalPointer) <line20> .handleAsync( <line21> (path, throwable) -> { <line22> if (throwable != null) { <line23> if (cancelJob && context.isState(this)) { <line24> startCheckpointScheduler(checkpointCoordinator); <line25> } <line26> throw new CompletionException(throwable); <line27> } else if (cancelJob && context.isState(this)) { <line28> cancel(); <line29> } <line30> return path; <line31> }, <line32> context.getMainThreadExecutor()); <line33> } <line34> } <line35> "	 <line2>	No
"public class A { <line0> @Override <line1> protected boolean sendHeartBeat() { <line2> if (clientHeartbeat == null) { <line3> return super.sendHeartBeat(); <line4> } <line5> Session session = getSession(); <line6> try { <line7> boolean withReply = !GenericUtils.isNegativeOrNull(heartbeatReplyMaxWait); <line8> Buffer buf = <line9> session.createBuffer( <line10> SshConstants.SSH_MSG_GLOBAL_REQUEST, heartbeatRequest.length() + Byte.SIZE); <line11> buf.putString(heartbeatRequest); <line12> buf.putBoolean(withReply); <line13> if (withReply) { <line14> Buffer reply = session.request(heartbeatRequest, buf, heartbeatReplyMaxWait); <line15> if (reply != null) { <line16> if (log.isTraceEnabled()) { <line17> } <line18> } <line19> } else { <line20> IoWriteFuture future = session.writePacket(buf); <line21> future.addListener(this::futureDone); <line22> } <line23> heartbeatCount.incrementAndGet(); <line24> return true; <line25> } catch (IOException | RuntimeException | Error e) { <line26> session.exceptionCaught(e); <line27> warn( <line28> ""sendHeartBeat({}) failed ({}) to send heartbeat #{} request={}: {}"", <line29> session, <line30> e.getClass().getSimpleName(), <line31> heartbeatCount, <line32> heartbeatRequest, <line33> e.getMessage(), <line34> e); <line35> return false; <line36> } <line37> } <line38> } <line39> "	 <line11>	No
public class A { <line0> @Override <line1> public void delete(ConnectionParameterKey metadataKey) { <line2> if (!exists(metadataKey)) { <line3> throw new MetadataDoesNotExistException(metadataKey); <line4> } <line5> String deleteStatement = deleteStatement(metadataKey); <line6> getMetadataRepository().executeUpdate(deleteStatement); <line7> } <line8> } <line9> 	 <line4>	No
"public class A { <line0> @Before <line1> public void setUp() { <line2> testPath = <line3> ""file:///tmp/flume-test."" <line4> + Calendar.getInstance().getTimeInMillis() <line5> + ""."" <line6> + Thread.currentThread().getId(); <line7> sink = new HDFSEventSink(); <line8> sink.setName(""HDFSEventSink-"" + UUID.randomUUID().toString()); <line9> dirCleanup(); <line10> } <line11> } <line12> "	 <line10>	No
public class A { <line0> @Override <line1> public void updateConsumeQueue(String subject, String group, int consumeFromWhereCode) { <line2> final ConsumerLog consumerLog = consumerLogManager.getConsumerLog(subject); <line3> if (consumerLog == null) { <line4> return; <line5> } <line6> final ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.codeOf(consumeFromWhereCode); <line7> final OffsetBound bound = consumerLog.getOffsetBound(); <line8> switch (consumeFromWhere) { <line9> case UNKNOWN: <line10> break; <line11> case EARLIEST: <line12> consumeQueueManager.update(subject, group, bound.getMinOffset()); <line13> break; <line14> case LATEST: <line15> consumeQueueManager.update(subject, group, bound.getMaxOffset()); <line16> break; <line17> } <line18> } <line19> } <line20> 	 <line5>	No
public class A { <line0> @Override <line1> public void process(final DistributionManager dm, ReplyProcessor21 processor) { <line2> final long startTime = getTimestamp(); <line3> if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) { <line4> } <line5> if (processor == null) { <line6> if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) { <line7> } <line8> return; <line9> } <line10> processor.process(this); <line11> } <line12> } <line13> 	 <line2>	No
"public class A { <line0> private static String elemNames( <line1> Class<? extends Enum<?>> enumClass, Map<? extends Enum<?>, QName> map) { <line2> List<String> names = new LinkedList<String>(); <line3> for (Enum<?> e : enumClass.getEnumConstants()) { <line4> QName qname = map.get(e); <line5> if (qname != null) { <line6> names.add(qname.toString()); <line7> } <line8> } <line9> return ArrayUtils.join("", "", names); <line10> } <line11> } <line12> "	 <line6>	Yes
"public class A { <line0> @SuppressWarnings(""serial"") <line1> private void write() { <line2> try { <line3> if (!file.exists()) { <line4> file.createNewFile(); <line5> } <line6> FileWriter out = new FileWriter(file); <line7> gson.toJson(clients, new TypeToken<Map<String, RegisteredClient>>() {}.getType(), out); <line8> out.close(); <line9> } catch (IOException e) { <line10> } <line11> } <line12> } <line13> "	 <line10>	Yes
public class A { <line0> private static boolean isValidTemporalColumn(long tableId, Type type) { <line1> if (!type.equals(DATE) && !type.equals(TIMESTAMP)) { <line2> return false; <line3> } <line4> return true; <line5> } <line6> } <line7> 	 <line2>	Yes
public class A { <line0> protected ProjectOverviewDTO getProjectOverview(UIContext uiContext) { <line1> StopWatch watch = new StopWatch(); <line2> ProjectOverviewDTO projectOverview = new ProjectOverviewDTO(); <line3> File rootFolder = getSelectionFolder(uiContext); <line4> if (rootFolder != null) { <line5> List<GetOverviewCommand.FileProcessor> processors = loadFileMatches(); <line6> scanProject(rootFolder, processors, projectOverview, 0, 3); <line7> } <line8> return projectOverview; <line9> } <line10> } <line11> 	 <line9>	No
"public class A { <line0> @Override <line1> public void initialize() throws InitializationException { <line2> try { <line3> System.setProperty( <line4> ""groovy.root"", <line5> new File(this.environmentProvider.get().getPermanentDirectory(), ""cache/groovy"") <line6> .getAbsolutePath()); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	 <line8>	Yes
"public class A { <line0> private void doCap(T t, int rc, Throwable throwable, Method method, Object res) { <line1> String user = """"; <line2> try { <line3> Connection conn = null; <line4> try { <line5> conn = t.getConnection(); <line6> } catch (SQLException ignore) { <line7> } <line8> if (conn != null && !conn.isClosed()) { <line9> user = conn.getMetaData().getUserName(); <line10> } <line11> } catch (SQLException e) { <line12> } <line13> Map<String, Object> params = new HashMap<String, Object>(); <line14> params.put(CaptureConstants.INFO_CLIENT_TARGETSERVER, targetServer + ""@"" + user); <line15> params.put(CaptureConstants.INFO_CLIENT_RESPONSECODE, rc); <line16> if (logger.isDebugable()) { <line17> } <line18> UAVServer.instance() <line19> .runMonitorCaptureOnServerCapPoint( <line20> CaptureConstants.CAPPOINT_APP_CLIENT, Monitor.CapturePhase.DOCAP, params); <line21> if (rc == -1) { <line22> params.put(CaptureConstants.INFO_CLIENT_RESPONSESTATE, throwable.toString()); <line23> } <line24> if (ivcContextParams != null) { <line25> ivcContextParams.putAll(params); <line26> } <line27> Object[] objs = {method, res, t}; <line28> UAVServer.instance() <line29> .runSupporter( <line30> ""com.creditease.uav.apm.supporters.InvokeChainSupporter"", <line31> ""runCap"", <line32> InvokeChainConstants.CHAIN_APP_CLIENT, <line33> InvokeChainConstants.CapturePhase.DOCAP, <line34> ivcContextParams, <line35> JdbcDriverAdapter.class, <line36> objs); <line37> } <line38> } <line39> "	 <line33>	No
"public class A { <line0> private Optional<FileStatus> stat(Path path) { <line1> try { <line2> return Optional.of(dataSourceParameter.getHadoopFileSystem(path).getFileStatus(path)); <line3> } catch (FileNotFoundException e) { <line4> return Optional.empty(); <line5> } catch (IOException e) { <line6> throw new CommandConfigurationException( <line7> MessageFormat.format(""error occurred while resolving Hadoop path: {0}"", path), e); <line8> } <line9> } <line10> } <line11> "	 <line4>	Yes
"public class A { <line0> @Override <line1> protected List<Configurer<SSLEngine>> getSSLEngineConfigurers(SSLContext context) { <line2> List<Configurer<SSLEngine>> sslEngineConfigurers = new LinkedList<>(); <line3> if (this.getClientAuthentication() != null) { <line4> final ClientAuthentication clientAuthValue = <line5> ClientAuthentication.valueOf(this.parsePropertyValue(this.getClientAuthentication())); <line6> Configurer<SSLEngine> sslEngineConfigurer = <line7> new Configurer<SSLEngine>() { <line8> @Override <line9> public SSLEngine configure(SSLEngine engine) { <line10> switch (clientAuthValue) { <line11> case NONE: <line12> engine.setWantClientAuth(false); <line13> engine.setNeedClientAuth(false); <line14> break; <line15> case WANT: <line16> engine.setWantClientAuth(true); <line17> break; <line18> case REQUIRE: <line19> engine.setNeedClientAuth(true); <line20> break; <line21> default: <line22> throw new RuntimeCamelException( <line23> ""Unknown ClientAuthentication value: "" + clientAuthValue); <line24> } <line25> return engine; <line26> } <line27> }; <line28> sslEngineConfigurers.add(sslEngineConfigurer); <line29> } <line30> return sslEngineConfigurers; <line31> } <line32> } <line33> "	 <line10>	Yes
public class A { <line0> public void stop() { <line1> try { <line2> server.shutdown().awaitTermination(10L, TimeUnit.SECONDS); <line3> } catch (InterruptedException ex) { <line4> } <line5> } <line6> } <line7> 	 <line6>	No
public class A { <line0> static long copyFileChannel( <line1> final FileChannel src, final WritableByteChannel dest, final int bufferSize) <line2> throws IOException { <line3> long bytes = 0L; <line4> long time = -System.currentTimeMillis(); <line5> long size = src.size(); <line6> while (bytes < size) { <line7> long bytesToTransfer = Math.min(bufferSize, size - bytes); <line8> long bytesTransfered = src.transferTo(bytes, bytesToTransfer, dest); <line9> bytes += bytesTransfered; <line10> if (LOGGER.isDebugEnabled()) { <line11> long percentage = Math.round(bytes / ((double) size) * 100.0); <line12> } <line13> } <line14> if (LOGGER.isDebugEnabled()) { <line15> time += System.currentTimeMillis(); <line16> double kBps = (bytes / 1024.0) / (time / 1000.0); <line17> } <line18> return bytes; <line19> } <line20> } <line21> 	 <line4>	No
"public class A { <line0> private static MCRCategoryImpl buildCategoryFromPrefetchedList( <line1> List<MCRCategoryDTO> list, MCRCategoryID returnID) { <line2> MCRCategoryImpl predecessor = null; <line3> for (MCRCategoryDTO entry : list) { <line4> predecessor = entry.merge(predecessor); <line5> } <line6> return MCRStreamUtils.flatten( <line7> predecessor.getRoot(), MCRCategory::getChildren, Collection::parallelStream) <line8> .filter(c -> c.getId().equals(returnID)) <line9> .findFirst() <line10> .map(MCRCategoryImpl.class::cast) <line11> .orElseThrow(() -> new MCRException(""Could not find "" + returnID + "" in database result."")); <line12> } <line13> } <line14> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public Map<DistrictType, Map<String, DistrictMap>> extractData(ResultSet rs) throws SQLException { <line2> districtMapCache = new HashMap<>(); <line3> districtMapLookup = new HashMap<>(); <line4> while (rs.next()) { <line5> DistrictType type = DistrictType.resolveType(rs.getString(""type"")); <line6> if (type != null) { <line7> if (!districtMapCache.containsKey(type)) { <line8> districtMapCache.put(type, new ArrayList<DistrictMap>()); <line9> districtMapLookup.put(type, new HashMap<String, DistrictMap>()); <line10> } <line11> String code = getDistrictCode(rs); <line12> DistrictMetadata metadata = new DistrictMetadata(type, rs.getString(""name""), code); <line13> DistrictMap map = getDistrictMapFromJson(rs.getString(""map"")); <line14> map.setDistrictMetadata(metadata); <line15> if (code != null && map != null) { <line16> districtMapCache.get(type).add(map); <line17> districtMapLookup.get(type).put(code, map); <line18> } <line19> } <line20> } <line21> return districtMapLookup; <line22> } <line23> } <line24> "	 <line8>	Yes
public class A { <line0> @Override <line1> public DataTreeNode getOrCreateNode(final TreeMapState state, final String name) { <line2> if (hard) { <line3> DataTreeNode node = state.getLeasedNode(name); <line4> if (node != null) { <line5> return node; <line6> } <line7> } <line8> String[] p = new String[path.length]; <line9> for (int i = 0; i < p.length; i++) { <line10> p[i] = ValueUtil.asNativeString(path[i].getFilteredValue(state)); <line11> } <line12> DataTreeNode alias = null; <line13> if (peer) { <line14> alias = DataTreeUtil.pathLocateFrom(state.current(), p); <line15> } else if (relativeUp > 0) { <line16> alias = DataTreeUtil.pathLocateFrom(state.peek(relativeUp), p); <line17> } else { <line18> alias = DataTreeUtil.pathLocateFrom(state.current().getTreeRoot(), p); <line19> } <line20> if (alias != null) { <line21> final DataTreeNode finalAlias = alias; <line22> DataTreeNodeInitializer init = <line23> new DataTreeNodeInitializer() { <line24> @Override <line25> public void onNewNode(DataTreeNode child) { <line26> child.aliasTo(finalAlias); <line27> state.onNewNode(child); <line28> } <line29> }; <line30> if (debug > 0) { <line31> debug(true); <line32> } <line33> return state.getOrCreateNode(name, init); <line34> } else { <line35> if (debug > 0) { <line36> debug(false); <line37> } <line38> if (log.isDebugEnabled() || debug == 1) { <line39> } <line40> return null; <line41> } <line42> } <line43> } <line44> 	 <line23>	No
"public class A { <line0> public RuleResult execute( <line1> final Map<String, String> ruleParam, Map<String, String> resourceAttributes) { <line2> Annotation annotation = null; <line3> String validTo = null; <line4> long expiredDuration; <line5> long targetExpiredDuration; <line6> String targetExpiryDurationInString = ruleParam.get(PacmanRuleConstants.EXPIRED_DURATION); <line7> String severity = ruleParam.get(PacmanRuleConstants.SEVERITY); <line8> String category = ruleParam.get(PacmanRuleConstants.CATEGORY); <line9> MDC.put(""executionId"", ruleParam.get(""executionId"")); <line10> MDC.put(""ruleId"", ruleParam.get(PacmanSdkConstants.RULE_ID)); <line11> List<LinkedHashMap<String, Object>> issueList = new ArrayList<>(); <line12> LinkedHashMap<String, Object> issue = new LinkedHashMap<>(); <line13> if (!PacmanUtils.doesAllHaveValue(targetExpiryDurationInString, severity, category)) { <line14> throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION); <line15> } <line16> if (resourceAttributes != null) { <line17> validTo = StringUtils.trim(resourceAttributes.get(PacmanRuleConstants.VALID_TO)); <line18> expiredDuration = calculateSslExpiredDuration(validTo); <line19> targetExpiredDuration = Long.parseLong(targetExpiryDurationInString); <line20> if (expiredDuration > 0) { <line21> if (expiredDuration <= targetExpiredDuration) { <line22> annotation = Annotation.buildAnnotation(ruleParam, Annotation.Type.ISSUE); <line23> annotation.put( <line24> PacmanSdkConstants.DESCRIPTION, <line25> ""SSL Expiry within "" + targetExpiryDurationInString + "" days found!!""); <line26> annotation.put(PacmanRuleConstants.SEVERITY, severity); <line27> annotation.put(PacmanRuleConstants.CATEGORY, category); <line28> issue.put( <line29> PacmanRuleConstants.VIOLATION_REASON, <line30> ""SSL Expiry within "" + targetExpiryDurationInString + "" days found!!""); <line31> issueList.add(issue); <line32> annotation.put(""issueDetails"", issueList.toString()); <line33> return new RuleResult( <line34> PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation); <line35> } <line36> } else { <line37> } <line38> } <line39> return new RuleResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE); <line40> } <line41> } <line42> "	 <line39>	Yes
"public class A { <line0> @Override <line1> public void handleDelivery( <line2> String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) <line3> throws IOException { <line4> GraphDBHandler dbHandler = new GraphDBHandler(); <line5> String message = new String(body, MQMessageConstants.MESSAGE_ENCODING); <line6> String routingKey = envelope.getRoutingKey(); <line7> List<JsonObject> dataList = new ArrayList<JsonObject>(); <line8> JsonElement json = new JsonParser().parse(message); <line9> if (json.isJsonObject()) { <line10> dataList.add(json.getAsJsonObject()); <line11> } <line12> try { <line13> if (!dataList.isEmpty()) { <line14> String healthLabels = "":"" + routingKey.replace(""."", "":""); <line15> boolean isRecordUpdate = createHealthNodes(dbHandler, dataList, healthLabels); <line16> if (isRecordUpdate) { <line17> getChannel().basicAck(envelope.getDeliveryTag(), false); <line18> } <line19> } else { <line20> EngineStatusLogger.getInstance() <line21> .createEngineStatusNode( <line22> "" Data List is empty for webhook health record: "" + routingKey, <line23> PlatformServiceConstants.FAILURE); <line24> } <line25> } catch (InsightsCustomException e) { <line26> } <line27> } <line28> } <line29> "	 <line20>	Yes
"public class A { <line0> @ParallelTest <line1> void testMirrorMakerLogSetting(ExtensionContext extensionContext) { <line2> String clusterName = mapWithClusterNames.get(extensionContext.getDisplayName()); <line3> String mirrorMakerName = clusterName + ""-mirror-maker""; <line4> resourceManager.createResource( <line5> extensionContext, <line6> KafkaMirrorMakerTemplates.kafkaMirrorMaker( <line7> mirrorMakerName, <line8> LOG_SETTING_CLUSTER_NAME, <line9> GC_LOGGING_SET_NAME, <line10> ""my-group"", <line11> 1, <line12> false) <line13> .editMetadata() <line14> .withNamespace(NAMESPACE) <line15> .endMetadata() <line16> .editSpec() <line17> .withNewInlineLogging() <line18> .withLoggers(MIRROR_MAKER_LOGGERS) <line19> .endInlineLogging() <line20> .withNewJvmOptions() <line21> .withGcLoggingEnabled(true) <line22> .endJvmOptions() <line23> .endSpec() <line24> .build()); <line25> String mmDepName = KafkaMirrorMakerResources.deploymentName(mirrorMakerName); <line26> Map<String, String> mmPods = DeploymentUtils.depSnapshot(NAMESPACE, mmDepName); <line27> String mirrorMakerMap = KafkaMirrorMakerResources.metricsAndLogConfigMapName(mirrorMakerName); <line28> assertThat( <line29> ""KafkaMirrorMaker's log level is set properly"", <line30> checkLoggersLevel(NAMESPACE, MIRROR_MAKER_LOGGERS, mirrorMakerMap), <line31> is(true)); <line32> assertThat( <line33> ""Mirror-maker GC logging is enabled"", <line34> checkGcLoggingDeployments(NAMESPACE, mmDepName), <line35> is(true)); <line36> KafkaMirrorMakerResource.replaceMirrorMakerResourceInSpecificNamespace( <line37> mirrorMakerName, mm -> mm.getSpec().setJvmOptions(JVM_OPTIONS), NAMESPACE); <line38> DeploymentUtils.waitTillDepHasRolled(NAMESPACE, mmDepName, 1, mmPods); <line39> assertThat( <line40> ""Mirror-maker GC logging is disabled"", <line41> checkGcLoggingDeployments(NAMESPACE, mmDepName), <line42> is(false)); <line43> kubectlGetStrimziUntilOperationIsSuccessful(NAMESPACE, mirrorMakerName); <line44> checkContainersHaveProcessOneAsTini(NAMESPACE, mirrorMakerName); <line45> } <line46> } <line47> "	 <line6>	No
"public class A { <line0> public static com.liferay.segments.model.SegmentsEntry getSegmentsEntry( <line1> HttpPrincipal httpPrincipal, long segmentsEntryId) <line2> throws com.liferay.portal.kernel.exception.PortalException { <line3> try { <line4> MethodKey methodKey = <line5> new MethodKey( <line6> SegmentsEntryServiceUtil.class, ""getSegmentsEntry"", _getSegmentsEntryParameterTypes8); <line7> MethodHandler methodHandler = new MethodHandler(methodKey, segmentsEntryId); <line8> Object returnObj = null; <line9> try { <line10> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line11> } catch (Exception exception) { <line12> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line13> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line14> } <line15> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line16> } <line17> return (com.liferay.segments.model.SegmentsEntry) returnObj; <line18> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line19> throw systemException; <line20> } <line21> } <line22> } <line23> "	 <line15>	No
public class A { <line0> public Completable readAllAsync(int expectedNumberOfDocuments) { <line1> return Completable.defer( <line2> () -> { <line3> while (true) { <line4> int totalItemRead = 0; <line5> FeedResponse<Document> response = null; <line6> do { <line7> FeedOptions options = new FeedOptions(); <line8> options.setRequestContinuation( <line9> response != null ? response.getResponseContinuation() : null); <line10> response = <line11> this.client <line12> .readDocuments(this.documentCollectionUri, options) <line13> .first() <line14> .subscribeOn(schedulerForBlockingWork) <line15> .toBlocking() <line16> .single(); <line17> totalItemRead += response.getResults().size(); <line18> } while (response.getResponseContinuation() != null); <line19> if (totalItemRead < expectedNumberOfDocuments) { <line20> try { <line21> TimeUnit.SECONDS.sleep(1); <line22> } catch (InterruptedException e) { <line23> break; <line24> } <line25> continue; <line26> } else { <line27> break; <line28> } <line29> } <line30> return Completable.complete(); <line31> }); <line32> } <line33> } <line34> 	 <line27>	Yes
public class A { <line0> public static com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap <line1> addCommerceInventoryWarehouse( <line2> String externalReferenceCode, <line3> String name, <line4> String description, <line5> boolean active, <line6> String street1, <line7> String street2, <line8> String street3, <line9> String city, <line10> String zip, <line11> String commerceRegionCode, <line12> String commerceCountryCode, <line13> double latitude, <line14> double longitude, <line15> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line16> throws RemoteException { <line17> try { <line18> com.liferay.commerce.inventory.model.CommerceInventoryWarehouse returnValue = <line19> CommerceInventoryWarehouseServiceUtil.addCommerceInventoryWarehouse( <line20> externalReferenceCode, <line21> name, <line22> description, <line23> active, <line24> street1, <line25> street2, <line26> street3, <line27> city, <line28> zip, <line29> commerceRegionCode, <line30> commerceCountryCode, <line31> latitude, <line32> longitude, <line33> serviceContext); <line34> return com.liferay.commerce.inventory.model.CommerceInventoryWarehouseSoap.toSoapModel( <line35> returnValue); <line36> } catch (Exception exception) { <line37> throw new RemoteException(exception.getMessage()); <line38> } <line39> } <line40> } <line41> 	 <line18>	No
public class A { <line0> public void doSomething() { <line1> log.getName(); <line2> } <line3> } <line4> 	 <line1>	Yes
"public class A { <line0> @Managed(description = ""Put in rotation"") <line1> public void putInRotation() { <line2> outOfRotation.set(false); <line3> for (ServiceRegistry serviceRegistry : serviceRegistries) { <line4> try { <line5> serviceRegistry.register(); <line6> } catch (RuntimeException e) { <line7> } <line8> } <line9> } <line10> } <line11> "	 <line5>	No
"public class A { <line0> public static com.liferay.commerce.model.CommerceOrder updateCustomFields( <line1> HttpPrincipal httpPrincipal, <line2> long commerceOrderId, <line3> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line4> throws com.liferay.portal.kernel.exception.PortalException { <line5> try { <line6> MethodKey methodKey = <line7> new MethodKey( <line8> CommerceOrderServiceUtil.class, <line9> ""updateCustomFields"", <line10> _updateCustomFieldsParameterTypes44); <line11> MethodHandler methodHandler = new MethodHandler(methodKey, commerceOrderId, serviceContext); <line12> Object returnObj = null; <line13> try { <line14> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line15> } catch (Exception exception) { <line16> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line17> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line18> } <line19> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line20> } <line21> return (com.liferay.commerce.model.CommerceOrder) returnObj; <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	 <line4>	No
"public class A { <line0> @Override <line1> public void apply(final DBBroker broker, final Txn transaction) { <line2> try (final LockedDocument lockedDoc = <line3> broker.getXMLResource(getTarget(), Lock.LockMode.WRITE_LOCK)) { <line4> final DocumentImpl doc = lockedDoc.getDocument(); <line5> final Permission permission = doc.getPermissions(); <line6> PermissionFactory.chown( <line7> broker, permission, Optional.ofNullable(getOwner()), Optional.ofNullable(getGroup())); <line8> PermissionFactory.chmod( <line9> broker, <line10> permission, <line11> Optional.of(getMode()), <line12> Optional.ofNullable(permission instanceof ACLPermission ? getAces() : null)); <line13> broker.storeXMLResource(transaction, doc); <line14> } catch (final PermissionDeniedException e) { <line15> final String msg = ""ERROR: Failed to set permissions on Document '"" + getTarget() + ""'.""; <line16> } <line17> } <line18> } <line19> "	 <line16>	Yes
public class A { <line0> @Override <line1> public synchronized boolean storeSecretStorage() { <line2> deleteSecretStorage(secureStoragePathCopy); <line3> storeSecretStorage(SECURE_STORE_KEY, secureStoragePathCopy); <line4> try { <line5> Files.copy(secureStoragePathCopy, secureStoragePath, REPLACE_EXISTING); <line6> } catch (IOException e) { <line7> } <line8> return true; <line9> } <line10> } <line11> 	 <line4>	Yes
"public class A { <line0> public static boolean requiresNewLauncher( <line1> String workflowClass, String workflowEngine, String workflowType) { <line2> if (workflowClass != null) { <line3> return true; <line4> } else if ((workflowEngine != null <line5> && workflowEngine.contains(""Oozie"") <line6> && !workflowEngine.contains(""Pegasus"")) <line7> || (workflowType != null && workflowType.contains(""ftl2""))) { <line8> return true; <line9> } <line10> return false; <line11> } <line12> } <line13> "	 <line8>	Yes
public class A { <line0> @Override <line1> public void stopService() { <line2> bus.stop(); <line3> DefaultTaskManager.get().requestStop(); <line4> for (Runnable runnable : shutdownHooks) { <line5> try { <line6> runnable.run(); <line7> } catch (Throwable e) { <line8> } <line9> } <line10> bus = null; <line11> config = null; <line12> sessionProvider = null; <line13> dispatcher = null; <line14> shutdownHooks = null; <line15> DefaultRemoteCallBuilder.destroyProxyFactory(); <line16> ErraiServiceSingleton.resetProxyAndService(); <line17> } <line18> } <line19> 	 <line8>	Yes
"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> public static boolean isManagedByTapestry( <line2> final Class type, final AnnotationProvider annotationProvider, final ObjectLocator locator) { <line3> if (type == null) return false; <line4> try { <line5> if (tapestry_injectable_resources.contains(type.getName()) <line6> || isAnnotation(annotationProvider, Symbol.class) <line7> || isAnnotation(annotationProvider, Path.class) <line8> || locator.getService(type) != null) { <line9> return true; <line10> } <line11> } catch (RuntimeException e) { <line12> } <line13> return false; <line14> } <line15> } <line16> "	 <line9>	Yes
"public class A { <line0> @Override <line1> public void put(T object) throws IOException { <line2> try { <line3> support.setParameters(object); <line4> statement.addBatch(); <line5> } catch (SQLException e) { <line6> sawError = true; <line7> for (SQLException ex = e; ex != null; ex = ex.getNextException()) { <line8> } <line9> throw new IOException( <line10> MessageFormat.format( <line11> ""Failed to put object to JDBC drain: {2} (resource={0}, table={1})"", <line12> profile.getResourceName(), script.getTableName(), object), <line13> e); <line14> } <line15> putLimitRest--; <line16> if (putLimitRest == 0) { <line17> flush(); <line18> } <line19> assert putLimitRest > 0; <line20> } <line21> } <line22> "	 <line4>	No
"public class A { <line0> public void alterAddColumnToCloudUsage(final Connection conn) { <line1> final String alterTableSql = <line2> ""ALTER TABLE `cloud_usage`.`cloud_usage` ADD COLUMN `quota_calculated` tinyint(1) DEFAULT 0"" <line3> + "" NOT NULL COMMENT 'quota calculation status'""; <line4> try (PreparedStatement pstmt = conn.prepareStatement(alterTableSql)) { <line5> pstmt.executeUpdate(); <line6> } catch (SQLException e) { <line7> if (e.getMessage().contains(""quota_calculated"")) { <line8> } else { <line9> throw new CloudRuntimeException( <line10> ""Unable to create column quota_calculated in table cloud_usage.cloud_usage"", e); <line11> } <line12> } <line13> } <line14> } <line15> "	 <line8>	Yes
public class A { <line0> @Override <line1> public void onSuccess() { <line2> try { <line3> coordinator.declare(txId, request); <line4> } catch (Exception e) { <line5> request.onFailure(e); <line6> } <line7> } <line8> } <line9> 	 <line5>	No
"public class A { <line0> @Test <line1> public void testEntityConnections() throws Exception { <line2> EntityManager em = app.getEntityManager(); <line3> final UUID applicationId = app.getId(); <line4> assertNotNull(em); <line5> Map<String, Object> properties = new LinkedHashMap<String, Object>(); <line6> properties.put(""name"", ""Dylan""); <line7> Entity catA = em.create(""cat"", properties); <line8> assertNotNull(catA); <line9> Entity cat = em.get(catA); <line10> assertNotNull(cat); <line11> properties = new LinkedHashMap<String, Object>(); <line12> properties.put(""name"", ""Nico""); <line13> Entity catB = em.create(""cat"", properties); <line14> assertNotNull(catB); <line15> properties = new LinkedHashMap<String, Object>(); <line16> properties.put(""name"", ""Best Cat Ever""); <line17> Entity awardA = em.create(""award"", properties); <line18> assertNotNull(awardA); <line19> em.createConnection(catA, ""likes"", catB); <line20> em.createConnection(awardA, ""awarded"", catB); <line21> app.waitForQueueDrainAndRefreshIndex(); <line22> testEntityConnections(applicationId, catA.getUuid(), ""likes"", ""cat"", 1); <line23> testEntityConnections(applicationId, awardA.getUuid(), ""awarded"", ""award"", 1); <line24> em.createConnection(awardA, ""awarded"", catA); <line25> app.waitForQueueDrainAndRefreshIndex(); <line26> testApplicationCollections(applicationId, ""cats"", 2); <line27> testApplicationCollections(applicationId, ""awards"", 1); <line28> } <line29> } <line30> "	 <line13>	No
public class A { <line0> private void complete(Subscriber<? super T> subscriber) { <line1> if (subscriber.isUnsubscribed()) { <line2> } else { <line3> subscriber.onCompleted(); <line4> } <line5> } <line6> } <line7> 	 <line1>	No
public class A { <line0> void close() { <line1> try { <line2> changeZkState(States.CLOSED); <line3> } catch (IOException e) { <line4> } <line5> clientCnxnSocket.onClosing(); <line6> } <line7> } <line8> 	 <line5>	No
"public class A { <line0> public static com.liferay.portal.kernel.json.JSONArray getWARThemes(HttpPrincipal httpPrincipal) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey(ThemeServiceUtil.class, ""getWARThemes"", _getWARThemesParameterTypes1); <line4> MethodHandler methodHandler = new MethodHandler(methodKey); <line5> Object returnObj = null; <line6> try { <line7> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line8> } catch (Exception exception) { <line9> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line10> } <line11> return (com.liferay.portal.kernel.json.JSONArray) returnObj; <line12> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line13> throw systemException; <line14> } <line15> } <line16> } <line17> "	 <line13>	Yes
"public class A { <line0> @Override <line1> public void registerDriver(String name, String clazz, Map<String, String> config) { <line2> try { <line3> Class.forName(clazz); <line4> providers.put(name, new DriverInfo(clazz, config)); <line5> } catch (ClassNotFoundException e) { <line6> throw new IllegalArgumentException(""Cannot register ASR driver "" + clazz, e); <line7> } <line8> } <line9> } <line10> "	 <line6>	Yes
"public class A { <line0> @Override <line1> public void forget(Xid xid) throws XAException { <line2> log.entering(this.getClass().getName(), ""forget""); <line3> try { <line4> List<XAResource> resources = getXAResourcesForXid(xid); <line5> if (resources == null) { <line6> throw new XAException(""forget: Unknown Xid""); <line7> } <line8> String xidString = displayXid(xid); <line9> setBypassFailures(Boolean.TRUE); <line10> for (XAResource resource : resources) { <line11> resource.forget(xid); <line12> } <line13> } finally { <line14> setBypassFailures(Boolean.FALSE); <line15> log.exiting(this.getClass().getName(), ""forget""); <line16> } <line17> } <line18> } <line19> "	 <line9>	Yes
"public class A { <line0> protected List<Metacard> ingestMetacards(CatalogFacade provider, List<Metacard> metacards) { <line1> if (metacards.isEmpty()) { <line2> return Collections.emptyList(); <line3> } <line4> List<Metacard> createdMetacards = new ArrayList<>(); <line5> CreateRequest createRequest = new CreateRequestImpl(metacards); <line6> CreateResponse createResponse; <line7> try { <line8> createResponse = provider.create(createRequest); <line9> createdMetacards = createResponse.getCreatedMetacards(); <line10> } catch (IngestException e) { <line11> printErrorMessage(String.format(""Received error while ingesting: %s%n"", e.getMessage())); <line12> return ingestSingly(provider, metacards); <line13> } catch (SourceUnavailableException e) { <line14> printErrorMessage(String.format(""Received error while ingesting: %s%n"", e.getMessage())); <line15> return createdMetacards; <line16> } catch (Exception e) { <line17> printErrorMessage( <line18> String.format(""Unexpected Exception received while ingesting: %s%n"", e.getMessage())); <line19> return createdMetacards; <line20> } <line21> ingestedCount.addAndGet(createdMetacards.size()); <line22> failedCount.addAndGet(metacards.size() - createdMetacards.size()); <line23> failedMetacards.addAll(subtract(metacards, createdMetacards)); <line24> return createdMetacards; <line25> } <line26> } <line27> "	 <line3>	No
"public class A { <line0> private int getFudgeFactor() { <line1> final String val = agentConfig.getProperty(""agent.dsl.fudge"", ""0""); <line2> try { <line3> return Integer.parseInt(val); <line4> } catch (NumberFormatException e) { <line5> return 0; <line6> } <line7> } <line8> } <line9> "	 <line8>	No
public class A { <line0> @Override <line1> public void removeAllValues(String table) throws IOException { <line2> final Set<String> keysToRemove = keySet(table); <line3> for (String key : keysToRemove) { <line4> removeValues(table, key); <line5> } <line6> } <line7> } <line8> 	 <line4>	No
"public class A { <line0> public Layout parseLayout(String className, Element layoutElement, XmlConfiguration config) { <line1> PluginType<?> plugin = plugins.get(className.toLowerCase()); <line2> if (plugin != null) { <line3> try { <line4> @SuppressWarnings(""unchecked"") <line5> LayoutBuilder builder = (LayoutBuilder) LoaderUtil.newInstanceOf(plugin.getPluginClass()); <line6> return builder.parseLayout(layoutElement, config); <line7> } catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) { <line8> } <line9> } <line10> return null; <line11> } <line12> } <line13> "	 <line8>	Yes
public class A { <line0> @Override <line1> public void call(Boolean ignored) { <line2> if (configObservable != null) { <line3> configObservable.onCompleted(); <line4> } <line5> } <line6> } <line7> 	 <line2>	No
public class A { <line0> @Override <line1> public IOperatorNodePushable createPushRuntime( <line2> IHyracksTaskContext ctx, <line3> IRecordDescriptorProvider recordDescProvider, <line4> int partition, <line5> int nPartitions) <line6> throws HyracksDataException { <line7> return new AbstractLibraryNodePushable(ctx) { <line8> @Override <line9> protected void execute() throws IOException { <line10> if (LOGGER.isInfoEnabled()) { <line11> } <line12> try { <line13> closeLibrary(); <line14> } finally { <line15> FileReference libDir = getLibraryDir(); <line16> dropIfExists(libDir); <line17> flushDirectory(libDir.getFile().getParentFile()); <line18> } <line19> } <line20> }; <line21> } <line22> } <line23> 	 <line11>	Yes
public class A { <line0> private void genericParseLargeMessage() { <line1> try { <line2> parsingBuffer.position(0); <line3> scanMessageData(parsingBuffer); <line4> lazyDecodeApplicationProperties(parsingBuffer); <line5> parsingBuffer = null; <line6> } catch (RuntimeException expected) { <line7> } <line8> } <line9> } <line10> 	 <line6>	No
public class A { <line0> private static List<String> resetCoprocessorOnHTables( <line1> HBaseAdmin hbaseAdmin, Path hdfsCoprocessorJar, List<String> tableNames) throws IOException { <line2> List<String> processed = new ArrayList<String>(); <line3> for (String tableName : tableNames) { <line4> try { <line5> resetCoprocessor(tableName, hbaseAdmin, hdfsCoprocessorJar); <line6> processed.add(tableName); <line7> } catch (IOException ex) { <line8> } <line9> } <line10> return processed; <line11> } <line12> } <line13> 	 <line4>	No
public class A { <line0> @Override <line1> public void concretProcessor(Object expKey, Map expValue, BasicDBObject set) { <line2> Map expressions = (Map) expValue.get(expKey); <line3> Set keys = expressions.keySet(); <line4> Iterator iter = keys.iterator(); <line5> while (iter.hasNext()) { <line6> String key = (String) iter.next(); <line7> Object value = expressions.get(key); <line8> if (value instanceof Map) { <line9> KVStrategy kv = new KVStrategy(); <line10> kv.concretProcessor(key, expressions, set); <line11> } else { <line12> set.append(key, value); <line13> } <line14> } <line15> } <line16> } <line17> 	 <line11>	No
"public class A { <line0> @Test <line1> public void shouldReturnNotActiveOnUnknownToken() throws Exception { <line2> TokensManagement tokensManagement = new MockTokensMan(); <line3> TokenIntrospectionResource tested = createIntrospectionResource(tokensManagement); <line4> setupInvocationContext(111); <line5> Response r = tested.introspectToken(""UNKNOWN-TOKEN""); <line6> assertEquals(HTTPResponse.SC_OK, r.getStatus()); <line7> JSONObject parsed = (JSONObject) JSONValue.parse((r.getEntity().toString())); <line8> assertThat(parsed.getAsString(""active"")).isEqualTo(""false""); <line9> assertThat(parsed.size()).isEqualTo(1); <line10> } <line11> } <line12> "	 <line8>	Yes
public class A { <line0> @Override <line1> public void trace(Marker marker, String msg) { <line2> traceMessages.add(new LogMessage(marker, msg, null)); <line3> } <line4> } <line5> 	 <line3>	Yes
public class A { <line0> @Override <line1> public BackgroundTaskQueue getTasks() { <line2> BackgroundTaskQueue queue = new BackgroundTaskQueue(); <line3> List<ContainerBlockInfo> containers = Lists.newArrayList(); <line4> try { <line5> containers = chooseContainerForBlockDeletion(blockLimitPerInterval, containerDeletionPolicy); <line6> BlockDeletingTask containerBlockInfos = null; <line7> long totalBlocks = 0; <line8> for (ContainerBlockInfo containerBlockInfo : containers) { <line9> containerBlockInfos = <line10> new BlockDeletingTask( <line11> containerBlockInfo.containerData, <line12> TASK_PRIORITY_DEFAULT, <line13> containerBlockInfo.numBlocksToDelete); <line14> queue.add(containerBlockInfos); <line15> totalBlocks += containerBlockInfo.numBlocksToDelete; <line16> } <line17> if (containers.size() > 0) { <line18> } <line19> } catch (StorageContainerException e) { <line20> } catch (Exception e) { <line21> if (LOG.isDebugEnabled()) { <line22> } <line23> } <line24> return queue; <line25> } <line26> } <line27> 	 <line22>	Yes
public class A { <line0> @Override <line1> public void text(String text) { <line2> here.addChild(TreeNode.create_text(text)); <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> @Override <line1> protected void postProcessResponse( <line2> boolean isGet, <line3> HttpServletRequest httpReq, <line4> HttpServletResponse httpResp, <line5> String samlResponse, <line6> String relayState) <line7> throws IOException { <line8> try { <line9> SAMLBindings binding = isGet ? SAMLBindings.HTTP_REDIRECT : SAMLBindings.HTTP_POST; <line10> LogoutResponseDocument respDoc = LogoutResponseDocument.Factory.parse(samlResponse); <line11> SAMLVerifiableElement verifiableMessage = <line12> binding == SAMLBindings.HTTP_REDIRECT <line13> ? new RedirectedMessage(httpReq.getQueryString()) <line14> : new XMLExpandedMessage(respDoc, respDoc.getLogoutResponse()); <line15> SAMLMessage<LogoutResponseDocument> responseMessage = <line16> new SAMLMessage<>(verifiableMessage, relayState, binding, respDoc); <line17> logoutProcessor.handleAsyncLogoutResponse(responseMessage, httpResp); <line18> } catch (XmlException e) { <line19> httpResp.sendError( <line20> HttpServletResponse.SC_BAD_REQUEST, ""Invalid SLO response (XML is malformed)""); <line21> } catch (EopException e) { <line22> } <line23> } <line24> } <line25> "	 <line19>	Yes
public class A { <line0> @Override <line1> public S3CacheEntry getEntry(String key, Path localPath, File primaryFile, File secondaryFile) { <line2> if (primaryFile.exists()) { <line3> return new S3FileCacheEntry(localPath, primaryFile, secondaryFile); <line4> } <line5> return null; <line6> } <line7> } <line8> 	 <line1>	No
public class A { <line0> @Override <line1> public String createSubscription(Subscription subscription) throws InvalidSubscriptionException { <line2> String uuid = UUID.randomUUID().toString(); <line3> try { <line4> createSubscription(subscription, uuid); <line5> } catch (SubscriptionExistsException e) { <line6> throw new InvalidSubscriptionException(e); <line7> } <line8> return uuid; <line9> } <line10> } <line11> 	 <line4>	No
"public class A { <line0> private CSVParser createParser(Reader reader, CSVFormat csvFormat) throws DMPControllerException { <line1> try { <line2> return new CSVParser(reader, csvFormat); <line3> } catch (final IOException e) { <line4> final String message = <line5> ""couldn't process lookup table to JSON, because couldn't read it with the given CSV"" <line6> + "" format configuration""; <line7> throw new DMPControllerException(message, e); <line8> } <line9> } <line10> } <line11> "	 <line0>	No
public class A { <line0> public void delete(StgG20Sys persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line5>	No
public class A { <line0> private String extractUserRoleCodeSystemName(AssertionType assertion) { <line1> String value = null; <line2> if (assertion != null <line3> && assertion.getUserInfo() != null <line4> && assertion.getUserInfo().getRoleCoded() != null) { <line5> value = assertion.getUserInfo().getRoleCoded().getCodeSystemName(); <line6> } else { <line7> } <line8> return value; <line9> } <line10> } <line11> 	 <line6>	No
public class A { <line0> public void attachClean(MbBaust instance) { <line1> try { <line2> getSession().lock(instance, LockMode.NONE); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line1>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> while (!stopped && !Thread.currentThread().isInterrupted()) { <line3> try { <line4> Thread.sleep(monitorInterval); <line5> } catch (InterruptedException e) { <line6> break; <line7> } <line8> synchronized (HdfsServiceTracker.this) { <line9> try { <line10> if (!currentActiveMaster.equals(masterName)) { <line11> if (LOG.isDebugEnabled()) { <line12> } <line13> if (!stopped && !checkConnection(currentActiveMaster)) { <line14> Path activeFile = new Path(activePath, currentActiveMaster.replaceAll("":"", ""_"")); <line15> fs.delete(activeFile, false); <line16> Path lockFile = new Path(activePath, HAConstants.ACTIVE_LOCK_FILE); <line17> fs.delete(lockFile, false); <line18> register(); <line19> } <line20> } <line21> } catch (Exception e) { <line22> } <line23> } <line24> } <line25> } <line26> } <line27> "	 <line3>	No
"public class A { <line0> void updateCategory(String categoryUrl, String parentUrl, String name) throws IOException { <line1> Put request = new Put(categoryUrl, credentials); <line2> request.setAccept(APPLICATION_JSON); <line3> request.addString(""parent"", parentUrl); <line4> request.addString(""name"", name); <line5> String result = request.executeAsString(); <line6> if (request.isUnAuthorized()) <line7> throw new UnAuthorizedException(""Not authorized to update category "" + name, categoryUrl); <line8> if (request.isForbidden()) <line9> throw new ForbiddenException(""Forbidden to update category "" + name, categoryUrl); <line10> if (request.isNotFound()) throw new NotFoundException(""Category not found"", categoryUrl); <line11> if (request.isBadRequest()) <line12> throw new NotOwnerException(""Not owner of category to update"", categoryUrl); <line13> if (request.isPreconditionFailed()) <line14> throw new DuplicateNameException(""Category "" + name + "" already exists"", categoryUrl); <line15> if (!request.isSuccessful()) <line16> throw new IOException( <line17> ""PUT on "" <line18> + categoryUrl <line19> + "" with payload "" <line20> + parentUrl <line21> + ""/"" <line22> + name <line23> + "" not successful: "" <line24> + result); <line25> } <line26> } <line27> "	 <line1>	Yes
"public class A { <line0> @Override <line1> public void deleteAVUMetadata(final String resourceName, final AvuData avuData) <line2> throws InvalidResourceException, JargonException { <line3> if (resourceName == null || resourceName.isEmpty()) { <line4> throw new IllegalArgumentException(""null or empty resource name""); <line5> } <line6> if (avuData == null) { <line7> throw new IllegalArgumentException(""null AVU data""); <line8> } <line9> final ModAvuMetadataInp modifyAvuMetadataInp = <line10> ModAvuMetadataInp.instanceForDeleteResourceMetadata(resourceName, avuData); <line11> try { <line12> getIRODSProtocol().irodsFunction(modifyAvuMetadataInp); <line13> } catch (JargonException je) { <line14> if (je.getMessage().indexOf(""-817000"") > -1) { <line15> throw new DataNotFoundException(""Target resource was not found, could not remove AVU""); <line16> } <line17> throw je; <line18> } <line19> } <line20> } <line21> "	 <line3>	No
public class A { <line0> @Override <line1> public void run(ApplicationArguments args) { <line2> try { <line3> federationBatchInfoService.applyRetentionPolicy(retentionDays); <line4> } catch (Exception e) { <line5> } <line6> } <line7> } <line8> 	 <line6>	No
"public class A { <line0> protected void startLogsIngestionListener(int port, LogsIngester logsIngester) { <line1> if (tokenAuthenticator.authRequired()) { <line2> logger.warning(""Filebeat log ingestion is not compatible with HTTP authentication, ignoring""); <line3> return; <line4> } <line5> final Server filebeatServer = <line6> new Server( <line7> ""0.0.0.0"", <line8> port, <line9> proxyConfig.getListenerIdleConnectionTimeout(), <line10> Runtime.getRuntime().availableProcessors()); <line11> filebeatServer.setMessageListener( <line12> new FilebeatIngester(logsIngester, System::currentTimeMillis)); <line13> startAsManagedThread( <line14> port, <line15> () -> { <line16> try { <line17> activeListeners.inc(); <line18> filebeatServer.listen(); <line19> } catch (InterruptedException e) { <line20> } catch (Exception e) { <line21> if (e instanceof BindException) { <line22> bindErrors.inc(); <line23> logger.severe(""Unable to start listener - port "" + port + "" is already in use!""); <line24> } else { <line25> logger.log(Level.SEVERE, ""Filebeat exception"", e); <line26> } <line27> } finally { <line28> activeListeners.dec(); <line29> } <line30> }, <line31> ""listener-logs-filebeat-"" + port); <line32> } <line33> } <line34> "	 <line13>	No
public class A { <line0> public void init() { <line1> synchronized (this) { <line2> if (!isInited) { <line3> try { <line4> Class<?> tuningClass = <line5> this.getClass().getClassLoader().loadClass(PersistenceConf.TUNING_CLASS.getValue()); <line6> ApplicationContext context = DataWorkCloudApplication.getApplicationContext(); <line7> if (context != null) { <line8> try { <line9> tuningObject = context.getBean(tuningClass); <line10> } catch (NoSuchBeanDefinitionException e) { <line11> } <line12> } <line13> if (tuningObject == null) { <line14> tuningObject = tuningClass.newInstance(); <line15> } <line16> tuningMethod = <line17> tuningClass.getMethod(PersistenceConf.TUNING_METHOD.getValue(), Object.class); <line18> tuningIsOpen = true; <line19> } catch (ClassNotFoundException <line20> | InstantiationException <line21> | IllegalAccessException <line22> | NoSuchMethodException e) { <line23> } finally { <line24> isInited = true; <line25> } <line26> } <line27> } <line28> } <line29> } <line30> 	 <line18>	No
public class A { <line0> @Override <line1> public void postProcessContext(DeploymentUnit deploymentUnit, StandardContext webContext) { <line2> if (webContext instanceof SIPWebContext) { <line3> ((SIPWebContext) webContext).postProcessContext(deploymentUnit); <line4> } <line5> } <line6> } <line7> 	 <line1>	No
public class A { <line0> private static void dumpEndpoints( <line1> final String message, final EndpointDescription[] availableEndpoints) { <line2> if (logger.isDebugEnabled()) { <line3> for (final EndpointDescription desc : availableEndpoints) { <line4> } <line5> } else if (logger.isTraceEnabled()) { <line6> for (final EndpointDescription desc : availableEndpoints) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line6>	No
"public class A { <line0> @Override <line1> public void create() { <line2> if (getSourceCidrList() != null) { <line3> String guestCidr = _networkService.getNetwork(getNetworkId()).getCidr(); <line4> for (String cidr : getSourceCidrList()) { <line5> if (!NetUtils.isValidIp4Cidr(cidr) && !NetUtils.isValidIp6Cidr(cidr)) { <line6> throw new ServerApiException( <line7> ApiErrorCode.PARAM_ERROR, ""Source cidrs formatting error "" + cidr); <line8> } <line9> if (cidr.equals(NetUtils.ALL_IP4_CIDRS)) { <line10> continue; <line11> } <line12> if (!NetUtils.isNetworkAWithinNetworkB(cidr, guestCidr)) { <line13> throw new ServerApiException( <line14> ApiErrorCode.PARAM_ERROR, cidr + "" is not within the guest cidr "" + guestCidr); <line15> } <line16> } <line17> } <line18> if (destCidrList != null) { <line19> for (String cidr : destCidrList) { <line20> if (!NetUtils.isValidIp4Cidr(cidr) && !NetUtils.isValidIp6Cidr(cidr)) { <line21> throw new ServerApiException( <line22> ApiErrorCode.PARAM_ERROR, ""Destination cidrs formatting error"" + cidr); <line23> } <line24> } <line25> } <line26> if (getProtocol().equalsIgnoreCase(NetUtils.ALL_PROTO)) { <line27> if (getSourcePortStart() != null && getSourcePortEnd() != null) { <line28> throw new InvalidParameterValueException( <line29> ""Do not pass ports to protocol ALL, protocol ALL do not require ports. Unable to create"" <line30> + "" firewall rule for the network id="" <line31> + networkId); <line32> } <line33> } <line34> if (getVpcId() != null) { <line35> throw new InvalidParameterValueException( <line36> ""Unable to create firewall rule for the network id="" <line37> + networkId <line38> + "" as firewall egress rule can be created only for non vpc networks.""); <line39> } <line40> try { <line41> FirewallRule result = _firewallService.createEgressFirewallRule(this); <line42> if (result != null) { <line43> setEntityId(result.getId()); <line44> setEntityUuid(result.getUuid()); <line45> } <line46> } catch (NetworkRuleConflictException ex) { <line47> throw new ServerApiException(ApiErrorCode.NETWORK_RULE_CONFLICT_ERROR, ex.getMessage()); <line48> } <line49> } <line50> } <line51> "	 <line5>	No
public class A { <line0> @Test <line1> void testWithoutFields() throws Exception { <line2> Logger logger = lc.getLogger(getClass()); <line3> assertThat(GelfTestSender.getMessages()).hasSize(1); <line4> GelfMessage gelfMessage = GelfTestSender.getMessages().get(0); <line5> String myMdc = gelfMessage.getField(MDC_MY_MDC); <line6> assertThat(myMdc).isNull(); <line7> } <line8> } <line9> 	 <line4>	No
public class A { <line0> @Override <line1> protected void convertToProperties( <line2> EntityDescriptorType meta, <line3> Properties properties, <line4> SamlProperties realConfigG, <line5> String configKey) { <line6> SamlIdpProperties realConfig = (SamlIdpProperties) realConfigG; <line7> SPSSODescriptorType[] spDefs = meta.getSPSSODescriptorArray(); <line8> RequestAcceptancePolicy trustMode = <line9> realConfig.getEnumValue(SamlIdpProperties.SP_ACCEPT_POLICY, RequestAcceptancePolicy.class); <line10> if (spDefs == null || spDefs.length == 0) return; <line11> String entityId = meta.getEntityID(); <line12> Random r = new Random(); <line13> for (SPSSODescriptorType spDef : spDefs) { <line14> if (!MetaToConfigConverterHelper.supportsSaml2(spDef)) { <line15> continue; <line16> } <line17> EntityAttributesType entityAttributes = parseMDAttributes(meta.getExtensions(), entityId); <line18> if (isDisabled(entityAttributes)) { <line19> continue; <line20> } <line21> KeyDescriptorType[] keys = spDef.getKeyDescriptorArray(); <line22> List<X509Certificate> certs = getSigningCerts(keys, entityId); <line23> if (!certs.isEmpty()) { <line24> try { <line25> updatePKICerts(certs, entityId, IDP_META_CERT); <line26> } catch (EngineException e) { <line27> continue; <line28> } <line29> } else if (trustMode == RequestAcceptancePolicy.strict) { <line30> continue; <line31> } <line32> Map<Integer, String> endpointURLs = <line33> getEndpointURLs( <line34> spDef.getAssertionConsumerServiceArray(), SAMLConstants.BINDING_HTTP_POST); <line35> String defaultEndpoint = <line36> getDefaultEndpoint( <line37> spDef.getAssertionConsumerServiceArray(), SAMLConstants.BINDING_HTTP_POST); <line38> if (defaultEndpoint == null || endpointURLs.isEmpty()) continue; <line39> EndpointType redirectSLOEndpoint = <line40> selectEndpointByBinding( <line41> spDef.getSingleLogoutServiceArray(), SAMLConstants.BINDING_HTTP_REDIRECT); <line42> EndpointType postSLOEndpoint = <line43> selectEndpointByBinding( <line44> spDef.getSingleLogoutServiceArray(), SAMLConstants.BINDING_HTTP_POST); <line45> EndpointType soapSLOEndpoint = <line46> selectEndpointByBinding(spDef.getSingleLogoutServiceArray(), SAMLConstants.BINDING_SOAP); <line47> UIInfoType uiInfo = <line48> MetaToConfigConverterHelper.parseMDUIInfo(spDef.getExtensions(), entityId); <line49> Map<String, String> names = <line50> MetaToConfigConverterHelper.getLocalizedNames(msg, uiInfo, spDef, meta); <line51> Map<String, LogoType> logos = MetaToConfigConverterHelper.getLocalizedLogos(uiInfo); <line52> addEntryToProperties( <line53> entityId, <line54> defaultEndpoint, <line55> endpointURLs, <line56> soapSLOEndpoint, <line57> postSLOEndpoint, <line58> redirectSLOEndpoint, <line59> realConfig, <line60> configKey, <line61> properties, <line62> r, <line63> certs, <line64> names, <line65> logos); <line66> } <line67> } <line68> } <line69> 	 <line19>	Yes
"public class A { <line0> @RequestMapping(""/healthCheck"") <line1> @ResponseBody <line2> public String healthCheck() { <line3> Session session = null; <line4> Connection connection = null; <line5> try { <line6> ConnectionFactory factory = new ActiveMQConnectionFactory(USER_NAME, PASSWORD, brokenUrl); <line7> connection = factory.createConnection(); <line8> connection.start(); <line9> connection.getMetaData().getJMSVersion(); <line10> connection.close(); <line11> } catch (Exception ex) { <line12> try { <line13> session.close(); <line14> connection.close(); <line15> } catch (JMSException e) { <line16> } <line17> return FAIL; <line18> } <line19> return SUCCESS; <line20> } <line21> } <line22> "	 <line17>	No
"public class A { <line0> public static Node copy(Session session, String srcPath, String destPath) { <line1> try { <line2> session.getWorkspace().copy(srcPath, destPath); <line3> return session.getNode(destPath); <line4> } catch (AccessDeniedException e) { <line5> throw new AccessControlException(e.getMessage()); <line6> } catch (RepositoryException e) { <line7> throw new MetadataRepositoryException( <line8> ""Failed to copy source path: "" + srcPath + "" to destination path: "" + destPath, e); <line9> } <line10> } <line11> } <line12> "	 <line5>	Yes
"public class A { <line0> @Override <line1> public void initCache(IGroupDAO groupDAO) throws ApsSystemException { <line2> try { <line3> Cache cache = this.getCache(); <line4> this.releaseCachedObjects(cache); <line5> Map<String, Group> groups = groupDAO.loadGroups(); <line6> this.insertObjectsOnCache(cache, groups); <line7> } catch (Throwable t) { <line8> throw new ApsSystemException(""Error loading groups"", t); <line9> } <line10> } <line11> } <line12> "	 <line8>	Yes
public class A { <line0> protected boolean isBackOrderAllowed(CPInstance cpInstance) { <line1> try { <line2> if (cpDefinitionInventoryEngine.isBackOrderAllowed(cpInstance)) { <line3> return true; <line4> } <line5> } catch (PortalException portalException) { <line6> } <line7> return false; <line8> } <line9> } <line10> 	 <line6>	Yes
"public class A { <line0> public static void main(String args[]) { <line1> String destination = ""example""; <line2> CanalConnector connector = <line3> CanalConnectors.newClusterConnector(""127.0.0.1:2181"", destination, ""canal"", ""canal""); <line4> final ClusterCanalClientTest clientTest = new ClusterCanalClientTest(destination); <line5> clientTest.setConnector(connector); <line6> clientTest.start(); <line7> Runtime.getRuntime() <line8> .addShutdownHook( <line9> new Thread( <line10> () -> { <line11> try { <line12> clientTest.stop(); <line13> } catch (Throwable e) { <line14> } finally { <line15> } <line16> })); <line17> } <line18> } <line19> "	 <line12>	Yes
public class A { <line0> @Nonnull <line1> @Override <line2> public Optional<Link> extractLink(String s) { <line3> return extractLinkLiteral(s) <line4> .flatMap( <line5> l -> { <line6> try { <line7> URI uri = new URI(l); <line8> return Optional.of(new HTTPLink(uri)); <line9> } catch (URISyntaxException e) { <line10> return Optional.empty(); <line11> } <line12> }); <line13> } <line14> } <line15> 	 <line10>	Yes
"public class A { <line0> public void validatePluginOptions(final Properties properties, final Console console) <line1> throws ParameterException { <line2> final PropertiesUtils propsUtils = new PropertiesUtils(properties); <line3> final boolean defaultEchoEnabled = <line4> propsUtils.getBoolean(Constants.CONSOLE_DEFAULT_ECHO_ENABLED_KEY, false); <line5> final boolean passwordEchoEnabled = <line6> propsUtils.getBoolean(Constants.CONSOLE_PASSWORD_ECHO_ENABLED_KEY, defaultEchoEnabled); <line7> for (final Field field : this.getClass().getDeclaredFields()) { <line8> for (final Annotation annotation : field.getAnnotations()) { <line9> if (annotation.annotationType() == Parameter.class) { <line10> final Parameter parameter = (Parameter) annotation; <line11> if (JCommanderParameterUtils.isRequired(parameter)) { <line12> field.setAccessible(true); <line13> Object value = null; <line14> try { <line15> value = field.get(this); <line16> if (value == null) { <line17> console.println( <line18> ""Field ["" <line19> + field.getName() <line20> + ""] is required: "" <line21> + Arrays.toString(parameter.names()) <line22> + "": "" <line23> + parameter.description()); <line24> console.print(""Enter value for ["" + field.getName() + ""]: ""); <line25> final boolean echoEnabled = <line26> JCommanderParameterUtils.isPassword(parameter) <line27> ? passwordEchoEnabled <line28> : defaultEchoEnabled; <line29> char[] password = console.readPassword(echoEnabled); <line30> final String strPassword = new String(password); <line31> password = null; <line32> if (!"""".equals(strPassword.trim())) { <line33> value = <line34> ((strPassword != null) && !"""".equals(strPassword.trim())) <line35> ? strPassword.trim() <line36> : null; <line37> } <line38> if (value == null) { <line39> throw new ParameterException( <line40> ""Value for ["" + field.getName() + ""] cannot be null""); <line41> } else { <line42> field.set(this, value); <line43> } <line44> } <line45> } catch (final Exception ex) { <line46> } <line47> } <line48> } <line49> } <line50> } <line51> } <line52> } <line53> "	 <line46>	Yes
public class A { <line0> public void attachDirty(TmpRepZobbaumas instance) { <line1> try { <line2> sessionFactory.getCurrentSession().saveOrUpdate(instance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> public static <T> T fromJsonStrict(final String jsonString, final TypeReference<T> clazz) { <line1> if (StringUtils.isNotBlank(jsonString)) { <line2> try { <line3> return STRICT_OBJECT_MAPPER.readValue(jsonString, clazz); <line4> } catch (final Exception ex) { <line5> } <line6> } <line7> return null; <line8> } <line9> } <line10> 	 <line5>	Yes
public class A { <line0> public Set<DetectionAlertScheme> loadAlertSchemes( <line1> DetectionAlertConfigDTO alertConfig, <line2> ThirdEyeAnomalyConfiguration thirdeyeConfig, <line3> DetectionAlertFilterResult result) <line4> throws Exception { <line5> Preconditions.checkNotNull(alertConfig); <line6> Map<String, Object> alertSchemes = alertConfig.getAlertSchemes(); <line7> if (alertSchemes == null || alertSchemes.isEmpty()) { <line8> Map<String, Object> emailScheme = new HashMap<>(); <line9> emailScheme.put(PROP_CLASS_NAME, DEFAULT_ALERT_SCHEME); <line10> alertSchemes = Collections.singletonMap(PROP_EMAIL_SCHEME, emailScheme); <line11> } <line12> Set<DetectionAlertScheme> detectionAlertSchemeSet = new HashSet<>(); <line13> for (String alertSchemeType : alertSchemes.keySet()) { <line14> Preconditions.checkNotNull(alertSchemes.get(alertSchemeType)); <line15> Preconditions.checkNotNull( <line16> ConfigUtils.getMap(alertSchemes.get(alertSchemeType)).get(PROP_CLASS_NAME)); <line17> Constructor<?> constructor = <line18> Class.forName( <line19> ConfigUtils.getMap(alertSchemes.get(alertSchemeType)) <line20> .get(PROP_CLASS_NAME) <line21> .toString() <line22> .trim()) <line23> .getConstructor( <line24> DetectionAlertConfigDTO.class, <line25> ThirdEyeAnomalyConfiguration.class, <line26> DetectionAlertFilterResult.class); <line27> detectionAlertSchemeSet.add( <line28> (DetectionAlertScheme) constructor.newInstance(alertConfig, thirdeyeConfig, result)); <line29> } <line30> return detectionAlertSchemeSet; <line31> } <line32> } <line33> 	 <line14>	Yes
public class A { <line0> @Override <line1> public boolean statusUpdate(TaskAttemptID taskId, TaskStatus taskStatus) <line2> throws IOException, InterruptedException { <line3> TaskInProgress tip = tasks.get(taskId); <line4> if (tip != null) { <line5> tip.reportProgress(taskStatus); <line6> return true; <line7> } else { <line8> return false; <line9> } <line10> } <line11> } <line12> 	 <line5>	No
public class A { <line0> private Optional<Path> getLocalAttachmentPath( <line1> SW360SparseAttachment attachment, Path releasePath) { <line2> Path localPath = releasePath.resolve(attachment.getFilename()); <line3> try { <line4> return Files.exists(localPath) <line5> && calculateLocalAttachmentHash(localPath).equals(attachment.getSha1()) <line6> ? Optional.of(localPath) <line7> : Optional.empty(); <line8> } catch (SW360ClientException e) { <line9> return Optional.empty(); <line10> } <line11> } <line12> } <line13> 	 <line2>	No
"public class A { <line0> @Override <line1> public Optional<ExecutionRequestLabel> get(ExecutionRequestLabelKey executionRequestLabelKey) { <line2> try { <line3> String queryScriptLabel = <line4> ""select ID, REQUEST_ID, NAME, VALUE from "" <line5> + getMetadataRepository().getTableNameByLabel(""ExecutionRequestLabels"") <line6> + "" where ID = "" <line7> + SQLTools.getStringForSQL(executionRequestLabelKey.getId()) <line8> + "";""; <line9> CachedRowSet cachedRowSet = getMetadataRepository().executeQuery(queryScriptLabel, ""reader""); <line10> if (cachedRowSet.size() == 0) { <line11> return Optional.empty(); <line12> } else if (cachedRowSet.size() > 1) { <line13> } <line14> cachedRowSet.next(); <line15> return Optional.of( <line16> new ExecutionRequestLabel( <line17> executionRequestLabelKey, <line18> new ExecutionRequestKey(cachedRowSet.getString(""REQUEST_ID"")), <line19> cachedRowSet.getString(""NAME""), <line20> cachedRowSet.getString(""VALUE""))); <line21> } catch (SQLException e) { <line22> throw new RuntimeException(e); <line23> } <line24> } <line25> } <line26> "	 <line1>	No
"public class A { <line0> private void replaceStreamThread(final Throwable throwable) { <line1> if (globalStreamThread != null <line2> && Thread.currentThread().getName().equals(globalStreamThread.getName())) { <line3> closeToError(); <line4> } <line5> final StreamThread deadThread = (StreamThread) Thread.currentThread(); <line6> deadThread.shutdown(); <line7> addStreamThread(); <line8> if (throwable instanceof RuntimeException) { <line9> throw (RuntimeException) throwable; <line10> } else if (throwable instanceof Error) { <line11> throw (Error) throwable; <line12> } else { <line13> throw new RuntimeException( <line14> ""Unexpected checked exception caught in the uncaught exception handler"", throwable); <line15> } <line16> } <line17> } <line18> "	 <line10>	No
"public class A { <line0> private SubscriptionPath createRandomSubscription(PipelineOptions options) { <line1> TopicPath topicPath = topic.get(); <line2> ProjectPath projectPath; <line3> if (project != null) { <line4> projectPath = project.get(); <line5> } else { <line6> String projectId = options.as(GcpOptions.class).getProject(); <line7> checkState( <line8> projectId != null, <line9> ""Cannot create subscription to topic %s because pipeline option 'project' not specified"", <line10> topicPath); <line11> projectPath = PubsubClient.projectPathFromId(options.as(GcpOptions.class).getProject()); <line12> } <line13> try { <line14> try (PubsubClient pubsubClient = <line15> pubsubFactory.newClient( <line16> timestampAttribute, idAttribute, options.as(PubsubOptions.class))) { <line17> SubscriptionPath subscriptionPath = <line18> pubsubClient.createRandomSubscription(projectPath, topicPath, DEAULT_ACK_TIMEOUT_SEC); <line19> return subscriptionPath; <line20> } <line21> } catch (Exception e) { <line22> throw new RuntimeException( <line23> String.format( <line24> ""Failed to create subscription to topic %s on project %s: %s"", <line25> topicPath, projectPath, e.getMessage()), <line26> e); <line27> } <line28> } <line29> } <line30> "	 <line19>	Yes
"public class A { <line0> private void handleBookmark(Object textPortion, List<Node> textPortions, XTextDocument doc) { <line1> boolean isStart = false; <line2> boolean isCollapsed = false; <line3> XNamed bookmark = null; <line4> try { <line5> isStart = <line6> ((Boolean) UnoProperty.getProperty(textPortion, UnoProperty.IS_START)).booleanValue(); <line7> isCollapsed = <line8> ((Boolean) UnoProperty.getProperty(textPortion, UnoProperty.IS_COLLAPSED)).booleanValue(); <line9> if (isCollapsed) { <line10> isStart = true; <line11> } <line12> bookmark = UNO.XNamed(UnoProperty.getProperty(textPortion, UnoProperty.BOOKMARK)); <line13> } catch (Exception x) { <line14> return; <line15> } <line16> if (bookmark == null) { <line17> return; <line18> } <line19> String name = bookmark.getName(); <line20> Matcher m = DocumentCommands.INSERTION_BOOKMARK.matcher(name); <line21> if (m.matches()) { <line22> try { <line23> ConfigThingy conf = new ConfigThingy("""", null, new StringReader(m.group(1))); <line24> textPortions.add(new InsertionBookmarkNode(new Bookmark(bookmark, doc), isStart, conf)); <line25> if (isCollapsed) { <line26> textPortions.add(new InsertionBookmarkNode(new Bookmark(bookmark, doc), false, conf)); <line27> } <line28> } catch (Exception x) { <line29> LOGGER.error(L.m(""Fehlerhaftes WM()-Bookmark: \""%1\"""", name), x); <line30> return; <line31> } <line32> return; <line33> } <line34> m = GROUP_BOOKMARK.matcher(name); <line35> if (m.matches()) { <line36> try { <line37> ConfigThingy conf = new ConfigThingy("""", null, new StringReader(m.group(1))); <line38> textPortions.add(new GroupBookmarkNode(new Bookmark(bookmark, doc), isStart, conf)); <line39> if (isCollapsed) { <line40> textPortions.add(new GroupBookmarkNode(new Bookmark(bookmark, doc), false, conf)); <line41> } <line42> } catch (Exception x) { <line43> return; <line44> } <line45> } <line46> } <line47> } <line48> "	 <line43>	Yes
public class A { <line0> public void loadDefaultTests() { <line1> List<MetaData> types = ServiceData.getLocalInstance().getServiceTypes(); <line2> for (int i = 0; i < types.size(); ++i) { <line3> MetaData type = types.get(i); <line4> matrix.servicesToTest.add(type.getSimpleName()); <line5> } <line6> for (String test : tests) { <line7> matrix.testsToRun.add(test); <line8> } <line9> matrix.currentProgress.totalTests = matrix.servicesToTest.size() * matrix.testsToRun.size(); <line10> } <line11> } <line12> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public List<Integer> getActionRecords(IActionLogRecordSearchBean searchBean) <line2> throws ApsSystemException { <line3> List<Integer> records = new ArrayList<>(); <line4> try { <line5> records = this.getActionLogDAO().getActionRecords(searchBean); <line6> } catch (Throwable t) { <line7> throw new ApsSystemException(""Error loading actionlogger records"", t); <line8> } <line9> return records; <line10> } <line11> } <line12> "	 <line3>	No
"public class A { <line0> @BeforeClass <line1> public static void start() throws Exception { <line2> SubmarineConfiguration conf = SubmarineConfiguration.getInstance(); <line3> String serverHost = NetworkUtils.findAvailableHostAddress(); <line4> int serverPort = NetworkUtils.findRandomAvailablePortOnAllLocalInterfaces(); <line5> String clusterAdd = serverHost + "":"" + serverPort; <line6> conf.setClusterAddress(clusterAdd); <line7> startUp(SubmarineServerClusterTest.class.getSimpleName()); <line8> Class clazz = ClusterClient.class; <line9> Constructor constructor = null; <line10> constructor = clazz.getDeclaredConstructor(); <line11> constructor.setAccessible(true); <line12> clusterClient = (ClusterClient) constructor.newInstance(); <line13> clusterClient.start(SubmarineServerClusterTest.class.getSimpleName()); <line14> int wait = 0; <line15> while (wait++ < 100) { <line16> if (clusterClient.raftInitialized()) { <line17> break; <line18> } <line19> sleep(3000); <line20> } <line21> assertTrue(""Can not start Submarine server!"", clusterClient.raftInitialized()); <line22> sleep(10000); <line23> } <line24> } <line25> "	 <line23>	No
public class A { <line0> public void truncateSchema() throws GoraException { <line1> try { <line2> this.client.getSession().execute(CassandraQueryFactory.getTruncateTableQuery(mapping)); <line3> } catch (Exception e) { <line4> throw new GoraException(e); <line5> } <line6> } <line7> } <line8> 	 <line2>	Yes
"public class A { <line0> private Directory getStoreDirectory(String store) throws BackendException { <line1> Preconditions.checkArgument(StringUtils.isAlphanumeric(store), ""Invalid store name: %s"", store); <line2> String dir = basePath + File.separator + store; <line3> try { <line4> File path = new File(dir); <line5> if (!path.exists()) path.mkdirs(); <line6> if (!path.exists() || !path.isDirectory() || !path.canWrite()) <line7> throw new PermanentBackendException(""Cannot access or write to directory: "" + dir); <line8> return FSDirectory.open(path); <line9> } catch (IOException e) { <line10> throw new PermanentBackendException(""Could not open directory: "" + dir, e); <line11> } <line12> } <line13> } <line14> "	 <line8>	Yes
public class A { <line0> private FileWriteHandle closeBufAndRollover( <line1> FileWriteHandle currWriteHandle, @Nullable WALRecord rec, RolloverType rolloverType) <line2> throws IgniteCheckedException { <line3> long idx = currWriteHandle.getSegmentId(); <line4> currWriteHandle.closeBuffer(); <line5> FileWriteHandle res = <line6> rollOver(currWriteHandle, rolloverType == RolloverType.NEXT_SEGMENT ? rec : null); <line7> if (log != null && log.isInfoEnabled()) { <line8> } <line9> return res; <line10> } <line11> } <line12> 	 <line8>	Yes
public class A { <line0> public List<String> getAllPIDs(final String uri) { <line1> final List<String> pidStringList = new ArrayList<>(); <line2> setEndpoint(uri); <line3> final ProcessManagementPortType client = getProcessManagementServiceClient(); <line4> TProcessInfo[] processList; <line5> try { <line6> processList = client.listAllProcesses().getProcessInfo(); <line7> if (processList == null) { <line8> return new ArrayList<>(); <line9> } <line10> for (final TProcessInfo pinfo : processList) { <line11> pidStringList.add(pinfo.getPid()); <line12> } <line13> } catch (final RemoteException e) { <line14> } <line15> return pidStringList; <line16> } <line17> } <line18> 	 <line1>	No
"public class A { <line0> protected boolean handleEventForEventBased(StateEvent event) <line1> throws InternalException, OverloadException { <line2> try { <line3> sendAndStateLock.lock(); <line4> ClientRoSessionState state = sessionData.getClientRoSessionState(); <line5> Event localEvent = (Event) event; <line6> Event.Type eventType = (Type) localEvent.getType(); <line7> switch (state) { <line8> case IDLE: <line9> switch (eventType) { <line10> case SEND_EVENT_REQUEST: <line11> startTx((RoCreditControlRequest) localEvent.getRequest()); <line12> setState(ClientRoSessionState.PENDING_EVENT); <line13> try { <line14> dispatchEvent(localEvent.getRequest()); <line15> } catch (Exception e) { <line16> handleSendFailure(e, eventType, localEvent.getRequest().getMessage()); <line17> } <line18> break; <line19> default: <line20> logger.warn(""Wrong event type ({}) on state {}"", eventType, state); <line21> break; <line22> } <line23> break; <line24> case PENDING_EVENT: <line25> switch (eventType) { <line26> case RECEIVE_EVENT_ANSWER: <line27> AppAnswerEvent answer = (AppAnswerEvent) localEvent.getAnswer(); <line28> try { <line29> long resultCode = answer.getResultCodeAvp().getUnsigned32(); <line30> if (isSuccess(resultCode)) { <line31> setState(ClientRoSessionState.IDLE, false); <line32> } <line33> if (isProvisional(resultCode) || isFailure(resultCode)) { <line34> handleFailureMessage( <line35> (RoCreditControlAnswer) answer, <line36> (RoCreditControlRequest) localEvent.getRequest(), <line37> eventType); <line38> } <line39> deliverRoAnswer( <line40> (RoCreditControlRequest) localEvent.getRequest(), <line41> (RoCreditControlAnswer) localEvent.getAnswer()); <line42> } catch (AvpDataException e) { <line43> setState(ClientRoSessionState.IDLE, false); <line44> } <line45> break; <line46> case Tx_TIMER_FIRED: <line47> handleTxExpires(localEvent.getRequest().getMessage()); <line48> break; <line49> default: <line50> logger.warn(""Wrong event type ({}) on state {}"", eventType, state); <line51> break; <line52> } <line53> break; <line54> case PENDING_BUFFERED: <line55> switch (eventType) { <line56> case RECEIVE_EVENT_ANSWER: <line57> setState(ClientRoSessionState.IDLE, false); <line58> sessionData.setBuffer(null); <line59> deliverRoAnswer( <line60> (RoCreditControlRequest) localEvent.getRequest(), <line61> (RoCreditControlAnswer) localEvent.getAnswer()); <line62> break; <line63> default: <line64> break; <line65> } <line66> break; <line67> default: <line68> break; <line69> } <line70> dispatch(); <line71> return true; <line72> } catch (Exception e) { <line73> throw new InternalException(e); <line74> } finally { <line75> sendAndStateLock.unlock(); <line76> } <line77> } <line78> } <line79> "	 <line76>	No
public class A { <line0> @Test <line1> public void geodeLoggerDebugNotLoggedAfterRestoringLogLevelToDefault() { <line2> when(config.getLogLevel()).thenReturn(FINE.intLevel()); <line3> configuration.configChanged(); <line4> geodeConsoleAppender.clearLogEvents(); <line5> when(config.getLogLevel()).thenReturn(CONFIG.intLevel()); <line6> configuration.configChanged(); <line7> assertThat(geodeConsoleAppender.getLogEvents()).isEmpty(); <line8> } <line9> } <line10> 	 <line4>	No
"public class A { <line0> @Override <line1> public Command<PrimaryDcCheckMessage> buildDcCheckCommand( <line2> final String cluster, final String shard, final String dc, final String newPrimaryDc) { <line3> return new AbstractCommand<MetaServerConsoleService.PrimaryDcCheckMessage>() { <line4> @Override <line5> public String getName() { <line6> return ""PrimaryDcCheck""; <line7> } <line8>  <line9> @Override <line10> protected void doExecute() throws Exception { <line11> PrimaryDcCheckMessage result = null; <line12> try { <line13> result = <line14> metaServerConsoleServiceManagerWrapper <line15> .get(dc) <line16> .changePrimaryDcCheck(cluster, shard, newPrimaryDc); <line17> future().setSuccess(result); <line18> } catch (Exception e) { <line19> getLogger() <line20> future().setFailure(e); <line21> } <line22> } <line23>  <line24> @Override <line25> protected void doReset() {} <line26> }; <line27> } <line28> } <line29> "	 <line21>	No
"public class A { <line0> @Override <line1> public void transform(Message message, DataType from, DataType to) throws Exception { <line2> assertEquals(""name=XOrder"", message.getBody()); <line3> message.setBody(new XOrder()); <line4> } <line5> } <line6> "	 <line3>	Yes
public class A { <line0> public Connection accept(final boolean close) throws IOException { <line1> Socket socket = serverSocket.accept(); <line2> if (close) { <line3> close(); <line4> } <line5> return new ConnectionImpl(socket); <line6> } <line7> } <line8> 	 <line1>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> doRunServer(); <line4> synchronized (this) { <line5> } <line6> } catch (final Throwable e) { <line7> } <line8> } <line9> } <line10> 	 <line8>	No
"public class A { <line0> private void readLangSysTable(OFTableName tableTag, long langSysTable, String langSysTag) <line1> throws IOException { <line2> in.seekSet(langSysTable); <line3> if (log.isDebugEnabled()) { <line4> } <line5> int lo = in.readTTFUShort(); <line6> int rf = in.readTTFUShort(); <line7> String rfi; <line8> if (rf != 65535) { <line9> rfi = ""f"" + rf; <line10> } else { <line11> rfi = null; <line12> } <line13> int nf = in.readTTFUShort(); <line14> if (log.isDebugEnabled()) { <line15> } <line16> List fl = new java.util.ArrayList(); <line17> for (int i = 0; i < nf; i++) { <line18> int fi = in.readTTFUShort(); <line19> if (log.isDebugEnabled()) { <line20> } <line21> fl.add(""f"" + fi); <line22> } <line23> if (seLanguages == null) { <line24> seLanguages = new java.util.LinkedHashMap(); <line25> } <line26> seLanguages.put(langSysTag, new Object[] {rfi, fl}); <line27> } <line28> } <line29> "	 <line15>	Yes
"public class A { <line0> private void initScheduledTask(Long batchWaitInterval) { <line1> try { <line2> if (batchWaitInterval > 0) { <line3> this.scheduler = <line4> new ScheduledThreadPoolExecutor(1, new DTThreadFactory(""hbase-batch-flusher"")); <line5> this.scheduledFuture = <line6> this.scheduler.scheduleWithFixedDelay( <line7> () -> { <line8> synchronized (HbaseOutputFormat.this) { <line9> if (!records.isEmpty()) { <line10> dealBatchOperation(records); <line11> } <line12> } <line13> }, <line14> batchWaitInterval, <line15> batchWaitInterval, <line16> TimeUnit.MILLISECONDS); <line17> } <line18> } catch (Exception e) { <line19> throw new RuntimeException(e); <line20> } <line21> } <line22> } <line23> "	 <line19>	Yes
"public class A { <line0> private void verifyRequestContentForAction(ExecutionServiceInput executionServiceInput) { <line1> ActionIdentifiers actionIdentifiers = executionServiceInput.getActionIdentifiers(); <line2> assertThat(actionIdentifiers.getBlueprintName()).isEqualTo(TEST_PNF_RESOURCE_BLUEPRINT_NAME); <line3> assertThat(actionIdentifiers.getBlueprintVersion()) <line4> .isEqualTo(TEST_PNF_RESOURCE_BLUEPRINT_VERSION); <line5> assertThat(actionIdentifiers.getActionName()).isEqualTo(this.action); <line6> CommonHeader commonHeader = executionServiceInput.getCommonHeader(); <line7> assertThat(commonHeader.getOriginatorId()).isEqualTo(""SO""); <line8> assertThat(commonHeader.getRequestId()).isEqualTo(TEST_MSO_REQUEST_ID); <line9> Struct payload = executionServiceInput.getPayload(); <line10> Struct requeststruct = payload.getFieldsOrThrow(this.action + ""-request"").getStructValue(); <line11> assertThat(requeststruct.getFieldsOrThrow(""resolution-key"").getStringValue()) <line12> .isEqualTo(TEST_PNF_CORRELATION_ID); <line13> Struct propertiesStruct = <line14> requeststruct.getFieldsOrThrow(this.action + ""-properties"").getStructValue(); <line15> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-name"").getStringValue()) <line16> .isEqualTo(TEST_PNF_CORRELATION_ID); <line17> assertThat(propertiesStruct.getFieldsOrThrow(""service-model-uuid"").getStringValue()) <line18> .isEqualTo(TEST_MODEL_UUID); <line19> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-customization-uuid"").getStringValue()) <line20> .isEqualTo(TEST_PNF_RESOURCE_CUSTOMIZATION_UUID); <line21> if (action.equalsIgnoreCase(DEPLOY_ACTION)) { <line22> assertThat(actionIdentifiers.getMode()).isEqualTo(""async""); <line23> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-ipv4-address"").getStringValue()) <line24> .isEqualTo(""1.1.1.1""); <line25> assertThat(propertiesStruct.getFieldsOrThrow(""pnf-ipv6-address"").getStringValue()) <line26> .isEqualTo(""::/128""); <line27> } else if (!action.equalsIgnoreCase(ASSIGN_ACTION)) { <line28> assertThat(actionIdentifiers.getMode()).isEqualTo(""sync""); <line29> assertThat(propertiesStruct.getFieldsOrThrow(""target-software-version"").getStringValue()) <line30> .isEqualTo(TEST_SOFTWARE_VERSION); <line31> } else { <line32> assertThat(actionIdentifiers.getMode()).isEqualTo(""sync""); <line33> } <line34> } <line35> } <line36> "	 <line1>	Yes
"public class A { <line0> public static ConsentPurpose build(OMElement consentPurposeOM) <line1> throws IdentityApplicationManagementException { <line2> ConsentPurpose consentPurpose = new ConsentPurpose(); <line3> if (consentPurposeOM == null) { <line4> return consentPurpose; <line5> } <line6> Iterator<?> children = consentPurposeOM.getChildElements(); <line7> while (children.hasNext()) { <line8> OMElement member = (OMElement) children.next(); <line9> if (PURPOSE_ID_ELEM.equals(member.getLocalName())) { <line10> try { <line11> consentPurpose.setPurposeId(Integer.parseInt(member.getText())); <line12> } catch (NumberFormatException e) { <line13> throw new IdentityApplicationManagementException( <line14> ""Invalid purpose ID: "" + member.getText(), e); <line15> } <line16> } else { <line17> if (DISPLAY_ORDER_ELEM.equals(member.getLocalName())) { <line18> try { <line19> consentPurpose.setDisplayOrder(Integer.parseInt(member.getText())); <line20> } catch (NumberFormatException e) { <line21> consentPurpose.setDisplayOrder(DEFAULT_DISPLAY_ORDER); <line22> } <line23> } <line24> } <line25> } <line26> return consentPurpose; <line27> } <line28> } <line29> "	 <line22>	No
public class A { <line0> static boolean hasAddressSpaceChanged(AddressSpace original, AddressSpace addressSpace) { <line1> boolean changed = false; <line2> if (!Objects.equals(original.getMetadata(), addressSpace.getMetadata())) { <line3> changed = true; <line4> } <line5> if (!Objects.equals(original.getSpec(), addressSpace.getSpec())) { <line6> changed = true; <line7> } <line8> if (!Objects.equals(original.getStatus(), addressSpace.getStatus())) { <line9> changed = true; <line10> } <line11> return changed; <line12> } <line13> } <line14> 	 <line3>	Yes
"public class A { <line0> @Override <line1> public void _init() { <line2> panel = new JPanel(new BorderLayout()); <line3> final String groupId = context.getUserData(AzureFunctionsConstants.WIZARD_GROUPID_KEY); <line4> final String artifactId = context.getUserData(AzureFunctionsConstants.WIZARD_ARTIFACTID_KEY); <line5> final String version = context.getUserData(AzureFunctionsConstants.WIZARD_VERSION_KEY); <line6> final String packageName = context.getUserData(AzureFunctionsConstants.WIZARD_PACKAGE_NAME_KEY); <line7> try { <line8> final FormBuilder formBuilder = new FormBuilder(); <line9> final CollectionComboBoxModel<String> toolModel = <line10> new CollectionComboBoxModel<>(Arrays.asList(MAVEN_TOOL, GRADLE_TOOL)); <line11> toolComboBox = new ComboBox<>(toolModel); <line12> formBuilder.addLabeledComponent(""Tool:"", toolComboBox); <line13> groupIdField = new JBTextField(getCurrentOrDefaultValue(groupId, ""com.example"")); <line14> formBuilder.addLabeledComponent(""Group:"", groupIdField); <line15> artifactIdField = <line16> new JBTextField(getCurrentOrDefaultValue(artifactId, ""azure-function-examples"")); <line17> formBuilder.addLabeledComponent(""Artifact:"", artifactIdField); <line18> versionField = new JBTextField(getCurrentOrDefaultValue(version, ""1.0.0-SNAPSHOT"")); <line19> formBuilder.addLabeledComponent(""Version:"", versionField); <line20> packageNameField = <line21> new JBTextField(getCurrentOrDefaultValue(packageName, ""org.example.functions"")); <line22> formBuilder.addLabeledComponent(""Package name:"", packageNameField); <line23> panel.add(ScrollPaneFactory.createScrollPane(formBuilder.getPanel(), true), ""North""); <line24> } catch (final RuntimeException e) { <line25> throw e; <line26> } <line27> } <line28> } <line29> "	 <line25>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> addCategories(); <line4> for (CitilinkCategoryGrabber ccg : citilinkCategoryGrabbers) { <line5> ccg.run(); <line6> } <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> 	 <line6>	No
public class A { <line0> @Override <line1> public PipelinedSubpartitionView createReadView(BufferAvailabilityListener availabilityListener) { <line2> synchronized (buffers) { <line3> checkState(!isReleased); <line4> releaseView(); <line5> readView = new PipelinedApproximateSubpartitionView(this, availabilityListener); <line6> } <line7> return readView; <line8> } <line9> } <line10> 	 <line5>	Yes
public class A { <line0> @Override <line1> public ActionResponse execute(IProtocolSessionManager protocolSessionManager) <line2> throws ActionException { <line3> GenericNetworkModel networkModel = (GenericNetworkModel) getModelToUpdate(); <line4> NetworkStatistics netStats = new NetworkStatistics(); <line5> if (networkModel == null) { <line6> } else { <line7> if (networkModel.getTopology() == null) { <line8> } else { <line9> for (NetworkElement ne : networkModel.getTopology().getNetworkElements()) { <line10> try { <line11> SwitchPortStatistics switchPortStatistics = <line12> getSwitchPortStatisticsForNetworkElement(ne, networkModel); <line13> netStats.addPortSwitchStatistic(ne.getId(), switchPortStatistics); <line14> } catch (Exception e) { <line15> } <line16> } <line17> if (netStats.getSwitchStatistics().isEmpty()) { <line18> } <line19> } <line20> } <line21> ActionResponse response = ActionResponse.okResponse(getActionID()); <line22> response.setResult(netStats); <line23> return response; <line24> } <line25> } <line26> 	 <line12>	No
public class A { <line0> private void scheduleFlush() throws HyracksDataException { <line1> ILSMIndex selectedIndex = null; <line2> synchronized (GlobalVirtualBufferCache.this) { <line3> while (flushingIndexes.size() < maxConcurrentFlushes <line4> && ((selectedIndex = selectFlushIndex()) != null)) { <line5> flushingIndexes.add(selectedIndex); <line6> } <line7> } <line8> } <line9> } <line10> 	 <line5>	Yes
"public class A { <line0> protected void doInitialize(IndexProvider provider) throws RepositoryException { <line1> Reflection.setValue(provider, ""context"", repository.context()); <line2> Reflection.setValue(provider, ""environment"", repository.environment()); <line3> provider.initialize(); <line4> Method postInitialize = Reflection.findMethod(IndexProvider.class, ""postInitialize""); <line5> Reflection.invokeAccessibly(provider, postInitialize, new Object[] {}); <line6> if (logger.isDebugEnabled()) { <line7> } <line8> } <line9> } <line10> "	 <line7>	Yes
"public class A { <line0> @Override <line1> public void onStartup(final Set<Class<?>> c, final ServletContext ctx) throws ServletException { <line2> try { <line3> ctx.getClassLoader().loadClass(""org.apache.logging.log4j.web.ServletRequestThreadContext""); <line4> } catch (final ClassNotFoundException e) { <line5> return; <line6> } <line7> final FilterRegistration.Dynamic filter = <line8> ctx.addFilter(""mdc-request-binder"", MdcRequestBinder.class); <line9> filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*""); <line10> filter.setAsyncSupported(true); <line11> } <line12> } <line13> "	 <line5>	Yes
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> Thread.sleep(1000); <line4> long timeout = 10000L; <line5> long startTms = System.currentTimeMillis(); <line6> while (System.currentTimeMillis() - startTms < timeout) { <line7> if (receiver.count < testNum * 3) { <line8> Thread.sleep(10); <line9> } else { <line10> break; <line11> } <line12> } <line13> } catch (InterruptedException ex) { <line14> DTThrowable.rethrow(ex); <line15> } finally { <line16> lc.shutdown(); <line17> try { <line18> Thread.sleep(1000); <line19> } catch (InterruptedException e) { <line20> DTThrowable.rethrow(e); <line21> } finally { <line22> t.interrupt(); <line23> receiver.teardown(); <line24> } <line25> } <line26> } <line27> } <line28> 	 <line18>	No
public class A { <line0> @Override <line1> public void addParentProcedure(String procedure, String parentProcedure) { <line2> CacheValidation.notNullOrEmpty(PROCEDURE, procedure); <line3> CacheValidation.notNullOrEmpty(PARENT_PROCEDURE, parentProcedure); <line4> this.parentProceduresForProcedures <line5> .computeIfAbsent(procedure, createSynchronizedSet()) <line6> .add(parentProcedure); <line7> this.childProceduresForProcedures <line8> .computeIfAbsent(parentProcedure, createSynchronizedSet()) <line9> .add(procedure); <line10> } <line11> } <line12> 	 <line0>	No
"public class A { <line0> public static long getOpenFileHandlesLimit() { <line1> if (OperatingSystem.isWindows()) { <line2> return -1L; <line3> } <line4> Class<?> sunBeanClass; <line5> try { <line6> sunBeanClass = Class.forName(""com.sun.management.UnixOperatingSystemMXBean""); <line7> } catch (ClassNotFoundException e) { <line8> return -1L; <line9> } <line10> try { <line11> Method fhLimitMethod = sunBeanClass.getMethod(""getMaxFileDescriptorCount""); <line12> Object result = fhLimitMethod.invoke(ManagementFactory.getOperatingSystemMXBean()); <line13> return (Long) result; <line14> } catch (Throwable t) { <line15> return -1L; <line16> } <line17> } <line18> } <line19> "	 <line15>	Yes
"public class A { <line0> public static void loadBitstreamFormats(Context context, String filename) <line1> throws SQLException, IOException, ParserConfigurationException, SAXException, <line2> TransformerException, AuthorizeException { <line3> Document document = loadXML(filename); <line4> NodeList typeNodes = XPathAPI.selectNodeList(document, ""dspace-bitstream-types/bitstream-type""); <line5> for (int i = 0; i < typeNodes.getLength(); i++) { <line6> Node n = typeNodes.item(i); <line7> loadFormat(context, n); <line8> } <line9> } <line10> } <line11> "	 <line8>	No
public class A { <line0> private Map<EncodingStrategy<T>, Integer> getBufferSizes(List<T> values) { <line1> Map<EncodingStrategy<T>, Integer> bufferSizes = new HashMap<EncodingStrategy<T>, Integer>(); <line2> for (EncodingStrategy<T> strategy : getEncodingStrategies()) { <line3> Buffer encodedBuffer = new AutomaticBuffer(); <line4> codec.encodeValues(encodedBuffer, strategy, values); <line5> int encodedBufferSize = encodedBuffer.getBuffer().length; <line6> bufferSizes.put(strategy, encodedBufferSize); <line7> } <line8> return bufferSizes; <line9> } <line10> } <line11> 	 <line8>	Yes
public class A { <line0> private static void loadAdaptorsJars() { <line1> String compssHome = System.getenv(COMPSsConstants.COMPSS_HOME); <line2> if (compssHome == null || compssHome.isEmpty()) { <line3> return; <line4> } <line5> try { <line6> Classpath.loadPath(compssHome + ADAPTORS_REL_PATH, LOGGER); <line7> } catch (FileNotFoundException ex) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
public class A { <line0> @Override <line1> public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) <line2> throws Exception { <line3> if (APIUtil.isAnalyticsEnabled()) { <line4> WebSocketUtils.setApiPropertyToChannel( <line5> ctx, <line6> org.wso2.carbon.apimgt.gateway.handlers.analytics.Constants.REQUEST_START_TIME_PROPERTY, <line7> System.currentTimeMillis()); <line8> } <line9> if ((msg instanceof CloseWebSocketFrame) || (msg instanceof PongWebSocketFrame)) { <line10> outboundHandler().write(ctx, msg, promise); <line11> } else if (msg instanceof WebSocketFrame) { <line12> if (isAllowed(ctx, (WebSocketFrame) msg)) { <line13> outboundHandler().write(ctx, msg, promise); <line14> if (APIUtil.isAnalyticsEnabled()) { <line15> inboundHandler().publishSubscribeEvent(ctx); <line16> } <line17> } else { <line18> if (APIUtil.isAnalyticsEnabled()) { <line19> inboundHandler().publishSubscribeThrottledEvent(ctx); <line20> } <line21> if (log.isDebugEnabled()) { <line22> } <line23> } <line24> } else { <line25> outboundHandler().write(ctx, msg, promise); <line26> } <line27> } <line28> } <line29> 	 <line28>	No
public class A { <line0> public static Future<Boolean> acquireLock( <line1> Lock lockImpl, String lock, String token, long lockExpiryMs, Logger log) { <line2> Future<Boolean> future = Future.future(); <line3> if (lockImpl == null) { <line4> future.complete(Boolean.TRUE); <line5> return future; <line6> } <line7> lockImpl <line8> .acquireLock(lock, token, lockExpiryMs) <line9> .setHandler( <line10> lockEvent -> { <line11> if (lockEvent.succeeded()) { <line12> if (lockEvent.result()) { <line13> future.complete(Boolean.TRUE); <line14> } else { <line15> future.complete(Boolean.FALSE); <line16> } <line17> } else { <line18> future.fail(lockEvent.cause()); <line19> } <line20> }); <line21> return future; <line22> } <line23> } <line24> 	 <line1>	No
public class A { <line0> @Override <line1> public void setParentExperimentRunId(String experimentRunId, String parentExperimentRunId) { <line2> try (Session session = modelDBHibernateUtil.getSessionFactory().openSession()) { <line3> ExperimentRunEntity experimentRunEntity = <line4> session.load(ExperimentRunEntity.class, experimentRunId, LockMode.PESSIMISTIC_WRITE); <line5> experimentRunEntity.setParent_id(parentExperimentRunId); <line6> long currentTimestamp = Calendar.getInstance().getTimeInMillis(); <line7> experimentRunEntity.setDate_updated(currentTimestamp); <line8> Transaction transaction = session.beginTransaction(); <line9> session.update(experimentRunEntity); <line10> transaction.commit(); <line11> } catch (Exception ex) { <line12> if (ModelDBUtils.needToRetry(ex)) { <line13> setParentExperimentRunId(experimentRunId, parentExperimentRunId); <line14> } else { <line15> throw ex; <line16> } <line17> } <line18> } <line19> } <line20> 	 <line11>	Yes
"public class A { <line0> @Test <line1> public void testSesionHandleEvent() throws Exception { <line2> LensSessionHandle sessionHandle = new LensSessionHandle(UUID.randomUUID(), UUID.randomUUID()); <line3> String user = ""user""; <line4> long now = System.currentTimeMillis(); <line5> SessionOpened sessionOpenedEvent = new SessionOpened(now, sessionHandle, user); <line6> SessionClosed sessionClosedEvent = new SessionClosed(now, sessionHandle); <line7> SessionRestored sessionRestored = new SessionRestored(now, sessionHandle); <line8> SessionExpired sessionExpired = new SessionExpired(now, sessionHandle); <line9> try { <line10> latch = new CountDownLatch(3); <line11> service.notifyEvent(sessionOpenedEvent); <line12> service.notifyEvent(sessionRestored); <line13> latch.await(5, TimeUnit.SECONDS); <line14> assertTrue(genericEventListener.processed); <line15> assertTrue(sessionOpenedListener.processed); <line16> assertTrue(sessionRestoredListener.processed); <line17> resetSessionListeners(); <line18> LensEvent genEvent = <line19> new LensEvent(now) { <line20> @Override <line21> public String getEventId() { <line22> return ""TEST_EVENT""; <line23> } <line24> }; <line25> latch = new CountDownLatch(2); <line26> service.notifyEvent(genEvent); <line27> latch.await(5, TimeUnit.SECONDS); <line28> assertTrue(genericEventListener.processed); <line29> resetSessionListeners(); <line30> latch = new CountDownLatch(3); <line31> service.notifyEvent(sessionClosedEvent); <line32> service.notifyEvent(sessionExpired); <line33> latch.await(5, TimeUnit.SECONDS); <line34> assertTrue(sessionClosedListener.processed); <line35> assertTrue(sessionExpiredListner.processed); <line36> assertFalse(sessionOpenedListener.processed); <line37> assertFalse(sessionRestoredListener.processed); <line38> } catch (LensException e) { <line39> fail(e.getMessage()); <line40> } <line41> } <line42> } <line43> "	 <line31>	Yes
public class A { <line0> public boolean isRunning() { <line1> if (nuxeoProcess != null) { <line2> try { <line3> nuxeoProcess.exitValue(); <line4> nuxeoProcess = null; <line5> } catch (IllegalThreadStateException exception) { <line6> return true; <line7> } <line8> } <line9> try { <line10> return (getPid() != null); <line11> } catch (IOException e) { <line12> return false; <line13> } <line14> } <line15> } <line16> 	 <line12>	Yes
public class A { <line0> private void sendError(HttpSession session, AsyncContext context, BoshBindingError bindingError) <line1> throws IOException { <line2> if (HttpBindManager.LOG_HTTPBIND_ENABLED.getValue()) { <line3> } <line4> try { <line5> if ((session.getMajorVersion() == 1 && session.getMinorVersion() >= 6) <line6> || session.getMajorVersion() > 1) { <line7> final String errorBody = <line8> createErrorBody(bindingError.getErrorType().getType(), bindingError.getCondition()); <line9> respond(session, context, errorBody, true); <line10> } else { <line11> sendLegacyError(context, bindingError); <line12> } <line13> } finally { <line14> if (bindingError.getErrorType() == BoshBindingError.Type.terminate) { <line15> session.close(); <line16> } <line17> } <line18> } <line19> } <line20> 	 <line15>	Yes
public class A { <line0> DLockGrantToken handleLockQuery(DLockQueryMessage query) throws InterruptedException { <line1> if (logger.isTraceEnabled(LogMarker.DLS_VERBOSE)) { <line2> } <line3> if (acquireDestroyReadLock(0)) { <line4> try { <line5> checkDestroyed(); <line6> return getGrantToken(query.objectName); <line7> } finally { <line8> releaseDestroyReadLock(); <line9> } <line10> } <line11> return null; <line12> } <line13> } <line14> 	 <line2>	Yes
public class A { <line0> @Override <line1> public String getClientID() throws JMSException { <line2> if (ActiveMQRALogger.LOGGER.isTraceEnabled()) { <line3> } <line4> checkClosed(); <line5> if (clientID == null) { <line6> return ((ActiveMQResourceAdapter) mcf.getResourceAdapter()).getProperties().getClientID(); <line7> } <line8> return clientID; <line9> } <line10> } <line11> 	 <line10>	No
"public class A { <line0> @Override <line1> @SuppressWarnings(""nls"") <line2> public void listClientVersions( <line3> String organizationId, <line4> String clientId, <line5> int page, <line6> int pageSize, <line7> IAsyncResultHandler<List<String>> handler) { <line8> String query = <line9> ""{"" <line10> + ""  \""query\"": {"" <line11> + ""    \""bool\"": {"" <line12> + ""      \""filter\"": ["" <line13> + ""        {"" <line14> + ""          \""term\"": {"" <line15> + ""            \""organizationId\"": \""{{organizationId}}\"""" <line16> + ""          }"" <line17> + ""        },"" <line18> + ""        {"" <line19> + ""          \""term\"": {"" <line20> + ""            \""clientId\"": \""{{clientId}}\"""" <line21> + ""          }"" <line22> + ""        }"" <line23> + ""      ]"" <line24> + ""    }"" <line25> + ""  },"" <line26> + ""    \""aggs\"": {"" <line27> + ""      \""client_versions\"": {"" <line28> + ""        \""terms\"": {"" <line29> + ""          \""field\"": \""version\"""" <line30> + ""        }"" <line31> + ""      }"" <line32> + ""    }"" <line33> + ""}""; <line34> SearchTemplateRequest searchTemplateRequest = new SearchTemplateRequest(); <line35> searchTemplateRequest.setRequest( <line36> new SearchRequest(getIndexPrefix() + EsConstants.INDEX_CLIENTS)); <line37> searchTemplateRequest.setScriptType(ScriptType.INLINE); <line38> searchTemplateRequest.setScript(query); <line39> Map<String, Object> scriptParams = new HashMap<>(); <line40> scriptParams.put(""organizationId"", organizationId); <line41> scriptParams.put(""clientId"", clientId); <line42> searchTemplateRequest.setScriptParams(scriptParams); <line43> try { <line44> SearchTemplateResponse response = <line45> getClient().searchTemplate(searchTemplateRequest, RequestOptions.DEFAULT); <line46> SearchResponse searchResponse = response.getResponse(); <line47> List terms = <line48> ((ParsedTerms) searchResponse.getAggregations().asMap().get(""client_versions"")) <line49> .getBuckets(); <line50> List<String> results = <line51> (List<String>) <line52> terms.stream() <line53> .map(o -> ((ParsedTerms.ParsedBucket) o).getKey()) <line54> .collect(Collectors.toList()); <line55> handler.handle(AsyncResultImpl.create(results)); <line56> } catch (IOException e) { <line57> } <line58> } <line59> } <line60> "	 <line21>	No
public class A { <line0> @Override <line1> public boolean updateCachedCveData(Bug _b, boolean _force) { <line2> boolean update_happened = false; <line3> if (_force || this.needsCveData(_b)) { <line4> try { <line5> String cve_id = Cve.extractCveIdentifier(_b.getBugId()); <line6> if (cve_id == null) cve_id = Cve.extractCveIdentifier(_b.getBugIdAlt()); <line7> final Cve cve = CveReader2.read(cve_id); <line8> if (cve != null) { <line9> boolean to_save = false; <line10> if (cve.getSummary() != null <line11> && (_b.getDescription() == null || !(cve.getSummary().equals(_b.getDescription())))) { <line12> _b.setDescription(cve.getSummary()); <line13> to_save = true; <line14> } <line15> if (cve.getCvssScore() != null <line16> && (_b.getCvssScore() == null || !(cve.getCvssScore().equals(_b.getCvssScore())))) { <line17> _b.setCvssScore(cve.getCvssScore()); <line18> to_save = true; <line19> } <line20> if (cve.getCvssVersion() != null <line21> && (_b.getCvssVersion() == null <line22> || !(cve.getCvssVersion().equals(_b.getCvssVersion())))) { <line23> _b.setCvssVersion(cve.getCvssVersion()); <line24> to_save = true; <line25> } <line26> if (cve.getCvssVector() != null <line27> && (_b.getCvssVector() == null <line28> || !(cve.getCvssVector().equals(_b.getCvssVector())))) { <line29> _b.setCvssVector(cve.getCvssVector()); <line30> to_save = true; <line31> } <line32> if (to_save) { <line33> this.customSave(_b, false); <line34> update_happened = true; <line35> } else { <line36> } <line37> } <line38> } catch (CacheException e) { <line39> } catch (PersistenceException e) { <line40> } <line41> } else { <line42> } <line43> return update_happened; <line44> } <line45> } <line46> 	 <line42>	Yes
public class A { <line0> public static com.liferay.portal.kernel.model.RegionSoap addRegion( <line1> long countryId, <line2> boolean active, <line3> String name, <line4> double position, <line5> String regionCode, <line6> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line7> throws RemoteException { <line8> try { <line9> com.liferay.portal.kernel.model.Region returnValue = <line10> RegionServiceUtil.addRegion( <line11> countryId, active, name, position, regionCode, serviceContext); <line12> return com.liferay.portal.kernel.model.RegionSoap.toSoapModel(returnValue); <line13> } catch (Exception exception) { <line14> throw new RemoteException(exception.getMessage()); <line15> } <line16> } <line17> } <line18> 	 <line3>	No
"public class A { <line0> @Override <line1> public GraphIndexStatusReport call() throws InterruptedException { <line2> Preconditions.checkNotNull(g, ""Graph instance must not be null""); <line3> Preconditions.checkNotNull(graphIndexName, ""Index name must not be null""); <line4> Preconditions.checkNotNull(status, ""Target status must not be null""); <line5> Map<String, SchemaStatus> notConverged = new HashMap<>(); <line6> Map<String, SchemaStatus> converged = new HashMap<>(); <line7> TitanGraphIndex idx; <line8> Timer t = new Timer(TimestampProviders.MILLI).start(); <line9> boolean timedOut; <line10> while (true) { <line11> TitanManagement mgmt = null; <line12> try { <line13> mgmt = g.openManagement(); <line14> idx = mgmt.getGraphIndex(graphIndexName); <line15> for (PropertyKey pk : idx.getFieldKeys()) { <line16> SchemaStatus s = idx.getIndexStatus(pk); <line17> if (!status.equals(s)) notConverged.put(pk.toString(), s); <line18> else converged.put(pk.toString(), s); <line19> } <line20> } finally { <line21> if (null != mgmt) mgmt.rollback(); <line22> } <line23> String waitingOn = Joiner.on("","").withKeyValueSeparator(""="").join(notConverged); <line24> if (!notConverged.isEmpty()) { <line25> } else { <line26> return new GraphIndexStatusReport( <line27> true, graphIndexName, status, notConverged, converged, t.elapsed()); <line28> } <line29> timedOut = null != timeout && 0 < t.elapsed().compareTo(timeout); <line30> if (timedOut) { <line31> return new GraphIndexStatusReport( <line32> false, graphIndexName, status, notConverged, converged, t.elapsed()); <line33> } <line34> notConverged.clear(); <line35> converged.clear(); <line36> Thread.sleep(poll.toMillis()); <line37> } <line38> } <line39> } <line40> "	 <line2>	No
"public class A { <line0> public void run() { <line1> EntityManager em = MCREntityManagerProvider.getEntityManagerFactory().createEntityManager(); <line2> EntityTransaction transaction = em.getTransaction(); <line3> transaction.begin(); <line4> StringBuilder sb = new StringBuilder(""FROM MCRJob WHERE ""); <line5> if (action != null) { <line6> sb.append(""action='"").append(action.getName()).append(""' AND ""); <line7> } <line8> sb.append("" status='"" + MCRJobStatus.PROCESSING + ""' ORDER BY id ASC""); <line9> TypedQuery<MCRJob> query = em.createQuery(sb.toString(), MCRJob.class); <line10> long current = new Date(System.currentTimeMillis()).getTime() / 60000; <line11> boolean reset = <line12> query.getResultList().stream() <line13> .map( <line14> job -> { <line15> boolean ret = false; <line16> long start = job.getStart().getTime() / 60000; <line17> if (current - start >= maxTimeDiff) { <line18> job.setStatus(MCRJobStatus.NEW); <line19> job.setStart(null); <line20> ret = true; <line21> } else { <line22> } <line23> return ret; <line24> }) <line25> .reduce(Boolean::logicalOr) <line26> .orElse(false); <line27> try { <line28> transaction.commit(); <line29> } catch (RollbackException e) { <line30> e.printStackTrace(); <line31> if (transaction != null) { <line32> transaction.rollback(); <line33> reset = false; <line34> } <line35> } <line36> if (reset) { <line37> synchronized (MCRJobQueue.getInstance(action)) { <line38> MCRJobQueue.getInstance(action).notifyListener(); <line39> } <line40> } <line41> em.close(); <line42> } <line43> } <line44> "	 <line18>	Yes
"public class A { <line0> @Override <line1> public Map<String, String> start() { <line2> try { <line3> container = <line4> new GenericContainer<>(IMAGE) <line5> .withExposedPorts(TCP_PORT) <line6> .withLogConsumer(new Slf4jLogConsumer(LOGGER)) <line7> .waitingFor(Wait.forLogMessage("".* mosquitto version .* running"", 1)) <line8> .waitingFor(Wait.forListeningPort()); <line9> container.start(); <line10> return CollectionHelper.mapOf( <line11> ""paho5.broker.tcp.url"", <line12> String.format(""tcp://localhost:%d"", container.getMappedPort(TCP_PORT))); <line13> } catch (Exception e) { <line14> throw new RuntimeException(e); <line15> } <line16> } <line17> } <line18> "	 <line2>	Yes
"public class A { <line0> public void doFilter( <line1> ServletRequest servletrequest, ServletResponse servletresponse, FilterChain filterchain) <line2> throws IOException, ServletException { <line3> HttpServletRequest httpreq = (HttpServletRequest) servletrequest; <line4> BufferedServletRequestWrapper req = new BufferedServletRequestWrapper(httpreq); <line5> HttpServletResponse res = (HttpServletResponse) servletresponse; <line6> if (LOG.isDebugEnabled()) { <line7> BufferedReader reader = <line8> new BufferedReader(new InputStreamReader(req.getInputStream(), ""UTF-8"")); <line9> String line; <line10> StringBuilder builder = new StringBuilder(); <line11> while ((line = reader.readLine()) != null) { <line12> builder.append(line); <line13> } <line14> reader.close(); <line15> } <line16> filterchain.doFilter(req, res); <line17> } <line18> } <line19> "	 <line15>	Yes
"public class A { <line0> @SuppressWarnings(""unchecked"") <line1> public Object methodException(Class claz, String method, Exception e) throws Exception { <line2> if (""format"".equals(method)) { <line3> return null; <line4> } <line5> throw e; <line6> } <line7> } <line8> "	 <line4>	No
"public class A { <line0> @Override <line1> public void execute() throws Exception { <line2> String subCommandString = getParsedSubCommand(jobCommandOptions.jCommander); <line3> configure(); <line4> switch (subCommandString) { <line5> case ""secondary-index"": <line6> secondaryIndex(); <line7> break; <line8> default: <line9> break; <line10> } <line11> } <line12> } <line13> "	 <line7>	No
"public class A { <line0> @Test <line1> public void testThroughputCounterApp() throws FileNotFoundException, IOException { <line2> Logger logger = LoggerFactory.getLogger(ThroughputCounterAppTest.class); <line3> LocalMode lm = LocalMode.newInstance(); <line4> Configuration conf = new Configuration(); <line5> InputStream is = new FileInputStream(""src/site/conf/dt-site-testbench.xml""); <line6> conf.addResource(is); <line7> conf.get(""dt.application.ThroughputCounterApp.operator.hmapOper.keys""); <line8> conf.get(""dt.application.ThroughputCounterApp.operator.hmapOper.numKeys""); <line9> try { <line10> lm.prepareDAG(new ThroughputCounterApp(), conf); <line11> LocalMode.Controller lc = lm.getController(); <line12> lc.run(20000); <line13> } catch (Exception ex) { <line14> } <line15> is.close(); <line16> } <line17> } <line18> "	 <line14>	Yes
"public class A { <line0> private Stat transmitNode(ZooKeeper zooKeeper, DataStatAclNode node) { <line1> Preconditions.checkNotNull(zooKeeper, ""zooKeeper must not be null""); <line2> Preconditions.checkNotNull(node, ""node must not be null""); <line3> try { <line4> zooKeeper.setData(node.getPath(), node.getData(), -1); <line5> zooKeeper.setACL(node.getPath(), node.getAcls(), -1); <line6> } catch (InterruptedException | KeeperException e) { <line7> if (e instanceof InterruptedException) { <line8> Thread.currentThread().interrupt(); <line9> } <line10> throw new RuntimeException( <line11> String.format(""unable to transmit data to %s for path %s"", zooKeeper, node.getPath()), e); <line12> } <line13> return node.getStat(); <line14> } <line15> } <line16> "	 <line4>	Yes
public class A { <line0> private PoolEntry createPoolEntry() { <line1> try { <line2> final PoolEntry poolEntry = newPoolEntry(); <line3> final long maxLifetime = config.getMaxLifetime(); <line4> if (maxLifetime > 0) { <line5> final long variance = <line6> maxLifetime > 10_000 ? ThreadLocalRandom.current().nextLong(maxLifetime / 40) : 0; <line7> final long lifetime = maxLifetime - variance; <line8> poolEntry.setFutureEol( <line9> houseKeepingExecutorService.schedule( <line10> new MaxLifetimeTask(poolEntry), lifetime, MILLISECONDS)); <line11> } <line12> final long keepaliveTime = config.getKeepaliveTime(); <line13> if (keepaliveTime > 0) { <line14> final long variance = ThreadLocalRandom.current().nextLong(keepaliveTime / 10); <line15> final long heartbeatTime = keepaliveTime - variance; <line16> poolEntry.setKeepalive( <line17> houseKeepingExecutorService.scheduleWithFixedDelay( <line18> new KeepaliveTask(poolEntry), heartbeatTime, heartbeatTime, MILLISECONDS)); <line19> } <line20> return poolEntry; <line21> } catch (ConnectionSetupException e) { <line22> if (poolState == POOL_NORMAL) { <line23> lastConnectionFailure.set(e); <line24> } <line25> } catch (Exception e) { <line26> if (poolState == POOL_NORMAL) { <line27> } <line28> } <line29> return null; <line30> } <line31> } <line32> 	 <line24>	No
"public class A { <line0> public static Set<String> evaluateEL(String expression) { <line1> String regex = ""\\$\\{(\\w+)\\}""; <line2> Set<String> matches = new HashSet<String>(); <line3> Pattern pattern = Pattern.compile(regex); <line4> Matcher matcher = pattern.matcher(expression); <line5> while (matcher.find()) { <line6> String key = matcher.group(1); <line7> matches.add(key); <line8> } <line9> return matches; <line10> } <line11> } <line12> "	 <line6>	No
public class A { <line0> protected void orderedScan(IIndexAccessor indexAccessor, ISerializerDeserializer[] fieldSerdes) <line1> throws Exception { <line2> if (LOGGER.isInfoEnabled()) { <line3> } <line4> IIndexCursor scanCursor = indexAccessor.createSearchCursor(false); <line5> try { <line6> RangePredicate nullPred = new RangePredicate(null, null, true, true, null, null); <line7> indexAccessor.search(scanCursor, nullPred); <line8> try { <line9> while (scanCursor.hasNext()) { <line10> scanCursor.next(); <line11> ITupleReference frameTuple = scanCursor.getTuple(); <line12> String rec = TupleUtils.printTuple(frameTuple, fieldSerdes); <line13> if (LOGGER.isInfoEnabled()) { <line14> } <line15> } <line16> } finally { <line17> scanCursor.close(); <line18> } <line19> } finally { <line20> scanCursor.destroy(); <line21> } <line22> } <line23> } <line24> 	 <line3>	Yes
"public class A { <line0> public static SQLDialect investigateDialect(Connection connection) { <line1> SQLDialect dialect = null; <line2> try { <line3> DatabaseMetaData metaData = connection.getMetaData(); <line4> String dbProduct = metaData.getDatabaseProductName(); <line5> dialect = identifyDialect(dbProduct); <line6> if (dialect == null) { <line7> dialect = identifyDialect(metaData.getDriverName()); <line8> } <line9> if (dialect == null) { <line10> logger.warnf( <line11> ""Unable to detect database dialect from connection metadata or JDBC driver name.""); <line12> } else { <line13> logger.debugf(""Detect database dialect as '%s'."", dialect); <line14> } <line15> } catch (Exception e) { <line16> } <line17> return dialect; <line18> } <line19> } <line20> "	 <line11>	No
public class A { <line0> private void letMessageDieForEndpoint() { <line1> if (endpointPublishJobCount.decrementAndGet() == 0) { <line2> try { <line3> CQSHandler.deleteMessage(queueUrl, receiptHandle); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> private void testEndNoSuccessors() { <line1> try { <line2> prepare(4); <line3> FakeAllocatableAction instance0 = new FakeAllocatableAction(fao, 0); <line4> instance0.assignResource(rs); <line5> FakeAllocatableAction instance1 = new FakeAllocatableAction(fao, 1); <line6> instance1.assignResource(rs); <line7> FakeAllocatableAction instance2 = new FakeAllocatableAction(fao, 2); <line8> instance2.assignResource(rs); <line9> FakeAllocatableAction instance3 = new FakeAllocatableAction(fao, 3); <line10> instance3.assignResource(rs); <line11> instance0.tryToLaunch(); <line12> completed(instance0); <line13> checkExecutions(new int[] {1, 0, 0, 0}); <line14> } catch (Exception e) { <line15> fail(e.getMessage()); <line16> } <line17> } <line18> } <line19> 	 <line7>	No
public class A { <line0> @Override <line1> public CommerceShippingFixedOptionRel remove(Serializable primaryKey) <line2> throws NoSuchShippingFixedOptionRelException { <line3> Session session = null; <line4> try { <line5> session = openSession(); <line6> CommerceShippingFixedOptionRel commerceShippingFixedOptionRel = <line7> (CommerceShippingFixedOptionRel) <line8> session.get(CommerceShippingFixedOptionRelImpl.class, primaryKey); <line9> if (commerceShippingFixedOptionRel == null) { <line10> if (_log.isDebugEnabled()) { <line11> } <line12> throw new NoSuchShippingFixedOptionRelException( <line13> _NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line14> } <line15> return remove(commerceShippingFixedOptionRel); <line16> } catch (NoSuchShippingFixedOptionRelException noSuchEntityException) { <line17> throw noSuchEntityException; <line18> } catch (Exception exception) { <line19> throw processException(exception); <line20> } finally { <line21> closeSession(session); <line22> } <line23> } <line24> } <line25> 	 <line11>	Yes
"public class A { <line0> @Pollable(expectedSubTaskNumber = 3, message = ""Importing file: {fileName}"") <line1> private void importFile( <line2> DropImporter dropImporter, <line3> DropExporter dropExporter, <line4> @MsgArg(name = ""fileName"", accessor = ""getName"") DropFile dropFile, <line5> TMTextUnitVariant.Status importStatus, <line6> @ParentTask PollableTask parentTask, <line7> @InjectCurrentTask PollableTask currentTask) <line8> throws DropImporterException, DropExporterException, ImportDropException { <line9> downloadDropFileContent(dropImporter, dropFile, currentTask); <line10> UpdateTMWithXLIFFResult updateReport = <line11> updateTMWithLocalizedXLIFF(dropFile, importStatus, currentTask); <line12> exportImportedFile( <line13> dropExporter, <line14> dropFile, <line15> updateReport.getXliffContent(), <line16> updateReport.getComment(), <line17> currentTask); <line18> } <line19> } <line20> "	 <line12>	No
public class A { <line0> @Override <line1> public void resetExpectations() { <line2> activeThrottles = throttling.activeThrottlesFor(CryptoTransfer); <line3> if (activeThrottles.isEmpty()) { <line4> } <line5> ensureConfigUpToDate(); <line6> rebuildState(); <line7> } <line8> } <line9> 	 <line8>	No
"public class A { <line0> public static DeviceManagementProviderService getDeviceManagementService() { <line1> PrivilegedCarbonContext ctx = PrivilegedCarbonContext.getThreadLocalCarbonContext(); <line2> DeviceManagementProviderService deviceManagementProviderService = <line3> (DeviceManagementProviderService) <line4> ctx.getOSGiService(DeviceManagementProviderService.class, null); <line5> if (deviceManagementProviderService == null) { <line6> String msg = ""Device Management service has not initialized.""; <line7> throw new IllegalStateException(msg); <line8> } <line9> return deviceManagementProviderService; <line10> } <line11> } <line12> "	 <line11>	No
public class A { <line0> @Override <line1> public void messageArrived(String topic, MqttMessage message) throws Exception { <line2> } <line3> } <line4> 	 <line0>	No
"public class A { <line0> @Override <line1> public void setAVUMetadata(final String userName, final AvuData avuData) <line2> throws DataNotFoundException, JargonException { <line3> if (userName == null || userName.isEmpty()) { <line4> throw new IllegalArgumentException(""null or empty userName""); <line5> } <line6> if (avuData == null) { <line7> throw new IllegalArgumentException(""null AVU data""); <line8> } <line9> if (!getIRODSServerProperties().isSupportsMetadataSet()) { <line10> throw new OperationNotSupportedByThisServerException( <line11> ""set avu not available on this iRODS version""); <line12> } <line13> final ModAvuMetadataInp modifyAvuMetadataInp = <line14> ModAvuMetadataInp.instanceForSetUserMetadata(userName, avuData); <line15> try { <line16> getIRODSProtocol().irodsFunction(modifyAvuMetadataInp); <line17> } catch (JargonException je) { <line18> if (je.getMessage().indexOf(""-827000"") > -1) { <line19> throw new DataNotFoundException(""User was not found, could not add AVU""); <line20> } <line21> throw je; <line22> } <line23> } <line24> } <line25> "	 <line3>	Yes
public class A { <line0> protected String getPlan(final String queryStr, boolean expandFields, boolean expandValues) <line1> throws Exception { <line2> Date[] startEndDate = this.dataManager.getShardStartEndDate(); <line3> if (log.isDebugEnabled()) { <line4> } <line5> QueryImpl q = new QueryImpl(); <line6> q.setBeginDate(startEndDate[0]); <line7> q.setEndDate(startEndDate[1]); <line8> q.setQuery(queryStr); <line9> q.setId(UUID.randomUUID()); <line10> q.setPagesize(Integer.MAX_VALUE); <line11> q.setQueryAuthorizations(auths.toString()); <line12> return this.logic.getPlan(client, q, this.authSet, expandFields, expandValues); <line13> } <line14> } <line15> 	 <line4>	Yes
"public class A { <line0> @Override <line1> public HttpResponse invoke(HttpCommand command) { <line2> HttpResponse response = null; <line3> for (; ; ) { <line4> HttpRequest request = command.getCurrentRequest(); <line5> Q nativeRequest = null; <line6> try { <line7> for (HttpRequestFilter filter : request.getFilters()) { <line8> request = filter.filter(request); <line9> } <line10> checkRequestHasContentLengthOrChunkedEncoding( <line11> request, <line12> ""After filtering, the request has neither chunked encoding nor content length: "" <line13> + request); <line14> wirePayloadIfEnabled(wire, request); <line15> utils.logRequest(headerLog, request, "">>""); <line16> nativeRequest = convert(request); <line17> response = invoke(nativeRequest); <line18> utils.logResponse(headerLog, response, ""<<""); <line19> if (response.getPayload() != null && wire.enabled()) wire.input(response); <line20> nativeRequest = null; <line21> int statusCode = response.getStatusCode(); <line22> if (statusCode >= 300) { <line23> if (shouldContinue(command, response)) continue; <line24> else break; <line25> } else { <line26> break; <line27> } <line28> } catch (Exception e) { <line29> IOException ioe = getFirstThrowableOfType(e, IOException.class); <line30> if (ioe != null && ioRetryHandler.shouldRetryRequest(command, ioe)) { <line31> continue; <line32> } <line33> command.setException( <line34> new HttpResponseException( <line35> e.getMessage() + "" connecting to "" + command.getCurrentRequest().getRequestLine(), <line36> command, <line37> null, <line38> e)); <line39> break; <line40> } finally { <line41> cleanup(nativeRequest); <line42> } <line43> } <line44> if (command.getException() != null) throw propagate(command.getException()); <line45> return response; <line46> } <line47> } <line48> "	 <line18>	Yes
"public class A { <line0> @Override <line1> protected void validate(List<TableInfo> tableInfos) { <line2> try { <line3> if (isNamespaceAvailable(databaseName)) { <line4> for (TableInfo tableInfo : tableInfos) { <line5> if (tableInfo != null) { <line6> HTableDescriptor hTableDescriptor = <line7> admin.getTableDescriptor( <line8> (databaseName + "":"" + tableInfo.getTableName()).getBytes()); <line9> boolean columnFamilyFound = false; <line10> Boolean f = false; <line11> for (HColumnDescriptor columnDescriptor : hTableDescriptor.getColumnFamilies()) { <line12> if (!columnFamilyFound <line13> && columnDescriptor <line14> .getNameAsString() <line15> .equalsIgnoreCase(tableInfo.getTableName())) { <line16> columnFamilyFound = true; <line17> } <line18> for (CollectionColumnInfo cci : tableInfo.getCollectionColumnMetadatas()) { <line19> if (columnDescriptor <line20> .getNameAsString() <line21> .equalsIgnoreCase(cci.getCollectionColumnName())) { <line22> f = true; <line23> break; <line24> } <line25> } <line26> if (!(columnFamilyFound || f)) { <line27> throw new SchemaGenerationException( <line28> ""column "" <line29> + tableInfo.getTableName() <line30> + "" does not exist in table "" <line31> + databaseName <line32> + """", <line33> ""Hbase"", <line34> databaseName, <line35> tableInfo.getTableName()); <line36> } <line37> } <line38> } <line39> } <line40> } else { <line41> throw new SchemaGenerationException( <line42> ""Namespace"" + databaseName + ""does not exist"", ""HBase"", databaseName); <line43> } <line44> } catch (TableNotFoundException tnfex) { <line45> throw new SchemaGenerationException( <line46> ""table "" + databaseName + "" does not exist "", tnfex, ""Hbase""); <line47> } catch (IOException ioe) { <line48> throw new SchemaGenerationException(ioe, ""Hbase""); <line49> } <line50> } <line51> } <line52> "	 <line29>	No
public class A { <line0> public void onError(final Throwable t) { <line1> } <line2> } <line3> 	 <line1>	Yes
"public class A { <line0> @ValidationErrorPage(value = LIST) <line1> @SkipValidation <line2> public String modifyAdvancePayment() { <line3> paymentheader = <line4> (Paymentheader) <line5> persistenceService.find("" from Paymentheader where id=? "", paymentheader.getId()); <line6> addDropdownData( <line7> ""bankaccountList"", <line8> persistenceService.findAllBy( <line9> "" from Bankaccount where bankbranch.id=? and isactive=true and fund.id=?"", <line10> paymentheader.getBankaccount().getBankbranch().getId(), <line11> paymentheader.getBankaccount().getFund().getId())); <line12> loadbankBranch(paymentheader.getVoucherheader().getFundId()); <line13> advanceRequisitionList.addAll(paymentActionHelper.getAdvanceRequisitionDetails(paymentheader)); <line14> final String vNumGenMode = voucherTypeForULB.readVoucherTypes(""Payment""); <line15> if (!""Auto"".equalsIgnoreCase(vNumGenMode)) { <line16> voucherNumberPrefix = <line17> paymentheader <line18> .getVoucherheader() <line19> .getVoucherNumber() <line20> .substring(0, Integer.valueOf(FinancialConstants.VOUCHERNO_TYPE_LENGTH)); <line21> voucherNumberSuffix = <line22> paymentheader <line23> .getVoucherheader() <line24> .getVoucherNumber() <line25> .substring( <line26> Integer.valueOf( <line27> FinancialConstants.VOUCHERNO_TYPE_LENGTH, <line28> paymentheader.getVoucherheader().getVoucherNumber().length())); <line29> } <line30> try { <line31> balance = <line32> paymentService.getAccountBalance( <line33> paymentheader.getBankaccount().getId().toString(), <line34> formatter.format(new Date()), <line35> paymentheader.getPaymentAmount(), <line36> paymentheader.getId(), <line37> paymentheader.getBankaccount().getChartofaccounts().getId()); <line38> } catch (final ParseException e) { <line39> throw new ValidationException( <line40> Arrays.asList( <line41> new ValidationError(""Error While formatting date"", ""Error While formatting date""))); <line42> } <line43> return ""advancePaymentModify""; <line44> } <line45> } <line46> "	 <line3>	Yes
public class A { <line0> @Override <line1> public void tearDown() throws Exception { <line2> super.tearDown(); <line3> DefaultCamelContext dcc = (DefaultCamelContext) context; <line4> while (!dcc.isStopped()) { <line5> } <line6> if (getSession() != null) { <line7> getSession().close(); <line8> setSession(null); <line9> } <line10> if (connection != null) { <line11> connection.stop(); <line12> connection = null; <line13> } <line14> if (broker != null) { <line15> broker.stop(); <line16> broker = null; <line17> } <line18> } <line19> } <line20> 	 <line5>	Yes
public class A { <line0> private void figureOutLocalIP() { <line1> if (!config.outboundIP.trim().isEmpty()) { <line2> try { <line3> localAddress = InetAddress.getByName(config.outboundIP); <line4> return; <line5> } catch (UnknownHostException e) { <line6> } <line7> } <line8> NetworkAddressService network = networkAS; <line9> String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null; <line10> if (adr != null) { <line11> try { <line12> localAddress = InetAddress.getByName(adr); <line13> } catch (UnknownHostException e) { <line14> } <line15> } <line16> } <line17> } <line18> 	 <line4>	Yes
public class A { <line0> void debug() { <line1> nodeEquipments.forEach(this::debug); <line2> } <line3> } <line4> 	 <line3>	No
public class A { <line0> private void deleteResource(IndexedRecord record) { <line1> assertNotNull(record); <line2> String id = (String) record.get(0); <line3> assertNotNull(id); <line4> properties.file.setValue(id); <line5> runtime.initialize(container, properties); <line6> runtime.runAtDriver(container); <line7> String fileId = <line8> (String) <line9> container.getComponentData( <line10> container.getCurrentComponentId(), <line11> getStudioName(GoogleDriveDeleteDefinition.RETURN_FILE_ID)); <line12> assertNotNull(fileId); <line13> } <line14> } <line15> 	 <line3>	No
public class A { <line0> @Test <line1> public void testObjectToString() { <line2> Foo arg = new Foo(); <line3> expect(mockLog.isLevelEnabled(Level.TRACE)).andReturn(true); <line4> mockLog.log(Level.TRACE, Foo.TO_STRING); <line5> replay(mockLog); <line6> verify(mockLog); <line7> } <line8> } <line9> 	 <line5>	No
public class A { <line0> @Override <line1> public final void onCachePeriodChanged(final long period) { <line2> cacheSchedulerHelper.scheduleWithPeriod(period); <line3> cacheStrategy.clear(); <line4> } <line5> } <line6> 	 <line3>	No
public class A { <line0> private void closeConnection() { <line1> if (pollingJob != null && !pollingJob.isCancelled()) { <line2> pollingJob.cancel(true); <line3> pollingJob = null; <line4> } <line5> if (connector != null) { <line6> connector.removeEventListener(this); <line7> connector.disconnect(); <line8> } <line9> } <line10> } <line11> 	 <line8>	No
"public class A { <line0> private void deployTestSpecificResources(ExtensionContext extensionContext) { <line1> prepareEnvForOperator( <line2> extensionContext, <line3> CO_NAMESPACE, <line4> Arrays.asList(CO_NAMESPACE, SECOND_NAMESPACE, THIRD_NAMESPACE)); <line5> applyBindings(extensionContext, CO_NAMESPACE); <line6> List<ClusterRoleBinding> clusterRoleBindingList = <line7> ClusterRoleBindingTemplates.clusterRoleBindingsForAllNamespaces(CO_NAMESPACE); <line8> clusterRoleBindingList.forEach( <line9> clusterRoleBinding -> <line10> ClusterRoleBindingResource.clusterRoleBinding(extensionContext, clusterRoleBinding)); <line11> resourceManager.createResource( <line12> extensionContext, <line13> BundleResource.clusterOperator(CO_NAMESPACE, ""*"", Constants.RECONCILIATION_INTERVAL) <line14> .build()); <line15> String previousNamespace = cluster.setNamespace(THIRD_NAMESPACE); <line16> resourceManager.createResource( <line17> extensionContext, <line18> KafkaTemplates.kafkaEphemeral(MAIN_NAMESPACE_CLUSTER_NAME, 1, 1) <line19> .editSpec() <line20> .editEntityOperator() <line21> .editTopicOperator() <line22> .withWatchedNamespace(SECOND_NAMESPACE) <line23> .endTopicOperator() <line24> .editUserOperator() <line25> .withWatchedNamespace(SECOND_NAMESPACE) <line26> .endUserOperator() <line27> .endEntityOperator() <line28> .endSpec() <line29> .build()); <line30> cluster.setNamespace(SECOND_NAMESPACE); <line31> resourceManager.createResource( <line32> extensionContext, KafkaTemplates.kafkaEphemeral(SECOND_CLUSTER_NAME, 3).build()); <line33> cluster.setNamespace(previousNamespace); <line34> } <line35> } <line36> "	 <line1>	Yes
"public class A { <line0> @Override <line1> public OpenCGAResult update( <line2> Query query, <line3> ObjectMap parameters, <line4> List<VariableSet> variableSetList, <line5> QueryOptions queryOptions) <line6> throws CatalogDBException, CatalogParameterException, CatalogAuthorizationException { <line7> if (parameters.containsKey(QueryParams.ID.key())) { <line8> if (count(query).getNumMatches() != 1) { <line9> throw new CatalogDBException( <line10> ""Operation not supported: '"" <line11> + QueryParams.ID.key() <line12> + ""' can only be updated for one family""); <line13> } <line14> } <line15> QueryOptions options = <line16> new QueryOptions( <line17> QueryOptions.INCLUDE, <line18> Arrays.asList( <line19> QueryParams.ID.key(), <line20> QueryParams.UID.key(), <line21> QueryParams.VERSION.key(), <line22> QueryParams.STUDY_UID.key())); <line23> DBIterator<Family> iterator = iterator(query, options); <line24> OpenCGAResult<Cohort> result = OpenCGAResult.empty(); <line25> while (iterator.hasNext()) { <line26> Family family = iterator.next(); <line27> try { <line28> result.append( <line29> runTransaction( <line30> clientSession -> <line31> privateUpdate( <line32> clientSession, family, parameters, variableSetList, queryOptions))); <line33> } catch (CatalogDBException | CatalogParameterException | CatalogAuthorizationException e) { <line34> result.getEvents().add(new Event(Event.Type.ERROR, family.getId(), e.getMessage())); <line35> result.setNumMatches(result.getNumMatches() + 1); <line36> } <line37> } <line38> return result; <line39> } <line40> } <line41> "	 <line39>	No
"public class A { <line0> @Override <line1> public void init(ServletConfig servletConfig) throws ServletException { <line2> super.init(servletConfig); <line3> this.excludeOwnerPages = WebloggerConfig.getBooleanProperty(""cache.excludeOwnerEditPages""); <line4> this.weblogPageCache = WeblogPageCache.getInstance(); <line5> this.siteWideCache = SiteWideCache.getInstance(); <line6> this.processReferrers = <line7> WebloggerConfig.getBooleanProperty(""site.bannedwordslist.enable.referrers""); <line8> String robotPatternStr = WebloggerConfig.getProperty(""referrer.robotCheck.userAgentPattern""); <line9> if (robotPatternStr != null && robotPatternStr.length() > 0) { <line10> try { <line11> robotPattern = Pattern.compile(robotPatternStr); <line12> } catch (Exception e) { <line13> } <line14> } <line15> themeReload = WebloggerConfig.getBooleanProperty(""themes.reload.mode""); <line16> } <line17> } <line18> "	 <line16>	No
public class A { <line0> private List<GluuAttribute> getAllPersonAtributes( <line1> GluuUserRole gluuUserRole, Collection<GluuAttribute> attributes) { <line2> List<GluuAttribute> attributeList = new ArrayList<GluuAttribute>(); <line3> String[] objectClassTypes = appConfiguration.getPersonObjectClassTypes(); <line4> for (GluuAttribute attribute : attributes) { <line5> if (StringHelper.equalsIgnoreCase( <line6> attribute.getOrigin(), appConfiguration.getPersonCustomObjectClass()) <line7> && (GluuUserRole.ADMIN == gluuUserRole)) { <line8> attribute.setCustom(true); <line9> attributeList.add(attribute); <line10> continue; <line11> } <line12> for (String objectClassType : objectClassTypes) { <line13> if (attribute.getOrigin().equals(objectClassType)) { <line14> attributeList.add(attribute); <line15> break; <line16> } <line17> } <line18> } <line19> return attributeList; <line20> } <line21> } <line22> 	 <line16>	No
public class A { <line0> private void seekToOffset(final RandomAccessFile local, final long offset) <line1> throws JargonException { <line2> if (offset < 0) { <line3> return; <line4> } else if (offset > 0) { <line5> if (parallelGetFileTransferStrategy.getFileRestartInfo() != null) { <line6> parallelGetFileTransferStrategy <line7> .getRestartManager() <line8> .updateOffsetForSegment( <line9> parallelGetFileTransferStrategy.getFileRestartInfo().identifierFromThisInfo(), <line10> getThreadNumber(), <line11> offset); <line12> } <line13> try { <line14> if (offset == local.getFilePointer()) { <line15> return; <line16> } <line17> local.seek(offset); <line18> } catch (Exception e) { <line19> throw new JargonException(IO_EXCEPTION_OCCURRED_DURING_PARALLEL_FILE_TRANSFER, e); <line20> } <line21> } <line22> } <line23> } <line24> 	 <line0>	No
public class A { <line0> @Nullable <line1> public static Ipv6ArbitraryMask extractIpv6AddressMask(final Ipv6Prefix ipv6Prefix) { <line2> Iterator<String> addressParts = PREFIX_SPLITTER.split(ipv6Prefix.getValue()).iterator(); <line3> addressParts.next(); <line4> int maskLength = 0; <line5> if (addressParts.hasNext()) { <line6> maskLength = Integer.parseInt(addressParts.next()); <line7> } <line8> BitSet ipmask = new BitSet(128); <line9> ipmask.set(0, maskLength, true); <line10> ipmask.set(maskLength + 1, 128, false); <line11> byte[] finalmask = new byte[16]; <line12> System.arraycopy(ipmask.toByteArray(), 0, finalmask, 0, ipmask.toByteArray().length); <line13> InetAddress inetAddress = null; <line14> try { <line15> inetAddress = InetAddress.getByAddress(finalmask); <line16> } catch (UnknownHostException e) { <line17> return null; <line18> } <line19> return new Ipv6ArbitraryMask(inetAddress.getHostAddress()); <line20> } <line21> } <line22> 	 <line17>	Yes
public class A { <line0> private void tryConnectingOrphans() <line1> throws VerificationException, BlockStoreException, PrunedException { <line2> checkState(lock.isHeldByCurrentThread()); <line3> int blocksConnectedThisRound; <line4> do { <line5> blocksConnectedThisRound = 0; <line6> Iterator<OrphanBlock> iter = orphanBlocks.values().iterator(); <line7> while (iter.hasNext()) { <line8> OrphanBlock orphanBlock = iter.next(); <line9> StoredBlock prev = getStoredBlockInCurrentScope(orphanBlock.block.getPrevBlockHash()); <line10> if (prev == null) { <line11> continue; <line12> } <line13> add(orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn); <line14> iter.remove(); <line15> blocksConnectedThisRound++; <line16> } <line17> if (blocksConnectedThisRound > 0) { <line18> } <line19> } while (blocksConnectedThisRound > 0); <line20> } <line21> } <line22> 	 <line12>	No
public class A { <line0> public static void warn(Logger logger, Throwable cause, String format, Object[] args) { <line1> if (logger.isWarnEnabled()) { <line2> if (needToPrintStackTrace()) { <line3> } else { <line4> } <line5> } <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> @Test <line1> public void alertDetailsMessageTime() { <line2> alertingService.addAlertListener(member, SEVERE); <line3> assertThat(captureAlertDetails().getMsgTime()).isNotNull(); <line4> } <line5> } <line6> 	 <line3>	Yes
public class A { <line0> public static <SESSION extends ISession> SESSION currentSession(final Class<SESSION> type) { <line1> ISession session = ISession.CURRENT.get(); <line2> if (session == null) { <line3> return null; <line4> } <line5> if (!type.isInstance(session)) { <line6> return null; <line7> } <line8> return type.cast(session); <line9> } <line10> } <line11> 	 <line9>	No
public class A { <line0> public void onServiceStartedEvent( <line1> ServiceStartedEvent event, ActivityContextInterface aci, EventContext eventContext) { <line2> ServiceID serviceID = event.getService(); <line3> SbbStates.setSmscRxSmppServerServiceState(true); <line4> } <line5> } <line6> 	 <line5>	No
public class A { <line0> void execute(Task task, String description) { <line1> try { <line2> executor <line3> .submit(() -> executeThread(task, description)) <line4> .get(timeout.toMillis(), TimeUnit.MILLISECONDS); <line5> } catch (InterruptedException e) { <line6> } catch (TimeoutException e) { <line7> } catch (Throwable e) { <line8> } <line9> } <line10> } <line11> 	 <line4>	No
"public class A { <line0> public static int getGroupTagsCount(HttpPrincipal httpPrincipal, long groupId) { <line1> try { <line2> MethodKey methodKey = <line3> new MethodKey( <line4> AssetTagServiceUtil.class, ""getGroupTagsCount"", _getGroupTagsCountParameterTypes6); <line5> MethodHandler methodHandler = new MethodHandler(methodKey, groupId); <line6> Object returnObj = null; <line7> try { <line8> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line9> } catch (Exception exception) { <line10> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line11> } <line12> return ((Integer) returnObj).intValue(); <line13> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line14> throw systemException; <line15> } <line16> } <line17> } <line18> "	 <line14>	Yes
"public class A { <line0> protected static Collection<Generator> loadGenerators(KogitoBuildContext context) { <line1> Collection<CollectedResource> collectedResources = <line2> CollectedResourceProducer.fromPaths(context.getAppPaths().getPaths()); <line3> ServiceLoader<GeneratorFactory> generatorFactories = ServiceLoader.load(GeneratorFactory.class); <line4> List<Generator> generators = <line5> StreamSupport.stream(generatorFactories.spliterator(), false) <line6> .map(gf -> gf.create(context, collectedResources)) <line7> .sorted(Comparator.comparingInt(Generator::priority)) <line8> .collect(Collectors.toList()); <line9> if (LOGGER.isInfoEnabled()) { <line10> String generatorMessages = <line11> generators.stream().map(Generator::name).collect(Collectors.joining("", "")); <line12> } <line13> return generators; <line14> } <line15> } <line16> "	 <line12>	Yes
public class A { <line0> public MbSchicht merge(MbSchicht detachedInstance) { <line1> try { <line2> MbSchicht result = (MbSchicht) sessionFactory.getCurrentSession().merge(detachedInstance); <line3> return result; <line4> } catch (RuntimeException re) { <line5> throw re; <line6> } <line7> } <line8> } <line9> 	 <line3>	Yes
public class A { <line0> @Override <line1> public void sendEmailMessages() { <line2> List<Object[]> orcidsWithUnsentNotifications = new ArrayList<Object[]>(); <line3> orcidsWithUnsentNotifications = notificationDaoReadOnly.findRecordsWithUnsentNotifications(); <line4> for (final Object[] element : orcidsWithUnsentNotifications) { <line5> String orcid = (String) element[0]; <line6> try { <line7> Float emailFrequencyDays = null; <line8> Date recordActiveDate = null; <line9> recordActiveDate = (Date) element[1]; <line10> List<Notification> notifications = <line11> notificationManager.findNotificationsToSend( <line12> orcid, emailFrequencyDays, recordActiveDate); <line13> EmailEntity primaryEmail = emailDao.findPrimaryEmail(orcid); <line14> if (primaryEmail == null) { <line15> return; <line16> } <line17> if (!notifications.isEmpty()) { <line18> EmailMessage digestMessage; <line19> if (Features.VERBOSE_NOTIFICATIONS.isActive()) { <line20> digestMessage = createDigest(orcid, notifications); <line21> } else { <line22> digestMessage = createDigestLegacy(orcid, notifications); <line23> } <line24> digestMessage.setFrom(DIGEST_FROM_ADDRESS); <line25> digestMessage.setTo(primaryEmail.getEmail()); <line26> boolean successfullySent = <line27> mailGunManager.sendEmail( <line28> digestMessage.getFrom(), <line29> digestMessage.getTo(), <line30> digestMessage.getSubject(), <line31> digestMessage.getBodyText(), <line32> digestMessage.getBodyHtml()); <line33> if (successfullySent) { <line34> for (Notification notification : notifications) { <line35> notificationDao.flagAsSent(notification.getPutCode()); <line36> } <line37> } <line38> } <line39> } catch (RuntimeException e) { <line40> } <line41> } <line42> } <line43> } <line44> 	 <line42>	No
"public class A { <line0> public static String getDepartment(User user) { <line1> String department = """"; <line2> try { <line3> List<Organization> organizations = user.getOrganizations(); <line4> if (!organizations.isEmpty()) { <line5> Organization organization = organizations.get(0); <line6> department = organization.getName(); <line7> } <line8> } catch (PortalException | SystemException e) { <line9> } <line10> return department; <line11> } <line12> } <line13> "	 <line12>	No
"public class A { <line0> private <C extends Component> void executeHeaderTest( <line1> final Class<C> componentClass, String expectedFile) throws IOException { <line2> final MockPageWithLinkAndComponent page = new MockPageWithLinkAndComponent(); <line3> page.add(new WebComponent(MockPageWithLinkAndComponent.COMPONENT_ID).setOutputMarkupId(true)); <line4> page.add( <line5> new AjaxLink<Void>(MockPageWithLinkAndComponent.LINK_ID) { <line6> private static final long serialVersionUID = 1L; <line7>  <line8> @Override <line9> public void onClick(AjaxRequestTarget target) { <line10> try { <line11> Constructor<? extends Component> con = <line12> componentClass.getConstructor(new Class[] {String.class}); <line13> Component comp = con.newInstance(MockPageWithLinkAndComponent.COMPONENT_ID); <line14> page.replace(comp); <line15> comp.setOutputMarkupId(true); <line16> target.add(comp); <line17> } catch (Exception e) { <line18> } <line19> } <line20> }); <line21> tester.startPage(page); <line22> tester.debugComponentTrees(); <line23> tester.clickLink(MockPageWithLinkAndComponent.LINK_ID); <line24> String document = tester.getLastResponseAsString(); <line25> String headerContribution = null; <line26> Pattern pat = <line27> Pattern.compile("".*<header-contribution.*?>(.*?)</header-contribution>.*"", Pattern.DOTALL); <line28> Matcher mat = pat.matcher(document); <line29> if (mat.matches()) { <line30> headerContribution = mat.group(1); <line31> } <line32> if (expectedFile == null) { <line33> assertNull( <line34> headerContribution, <line35> ""There was a header contribution on the response "" <line36> + ""(though we didn't expect one): <"" <line37> + headerContribution <line38> + "">""); <line39> } else if (headerContribution == null) { <line40> fail(""Failed to find header contribution: \n"" + document); <line41> } else { <line42> DiffUtil.validatePage(headerContribution, getClass(), expectedFile, true); <line43> } <line44> } <line45> } <line46> "	 <line25>	No
public class A { <line0> private static Collection<SpecParameter<?>> resolveParameters( <line1> Collection<? extends SpecParameter<?>> newParams, AbstractBrooklynObjectSpec<?, ?> spec) { <line2> Collection<? extends SpecParameter<?>> existingReferenceParams = spec.getParameters(); <line3> Map<String, SpecParameter<?>> existingToKeep = MutableMap.of(); <line4> if (existingReferenceParams != null) { <line5> for (SpecParameter<?> p : existingReferenceParams) { <line6> if (ConfigInheritances.isKeyReinheritable( <line7> p.getConfigKey(), InheritanceContext.TYPE_DEFINITION)) { <line8> existingToKeep.put(p.getConfigKey().getName(), p); <line9> } <line10> } <line11> } <line12> List<SpecParameter<?>> result = MutableList.<SpecParameter<?>>of(); <line13> if (newParams != null) { <line14> for (SpecParameter<?> p : newParams) { <line15> final SpecParameter<?> existingP = existingToKeep.get(p.getConfigKey().getName()); <line16> if (p instanceof SpecParameterIncludingDefinitionForInheritance) { <line17> p = <line18> ((SpecParameterIncludingDefinitionForInheritance<?>) p) <line19> .resolveWithAncestor(existingP); <line20> } else { <line21> } <line22> if (existingP != null) { <line23> existingToKeep.put(p.getConfigKey().getName(), p); <line24> } else { <line25> result.add(p); <line26> } <line27> } <line28> } <line29> result.addAll(existingToKeep.values()); <line30> return result; <line31> } <line32> } <line33> 	 <line19>	No
public class A { <line0> protected void localPerform() throws IOException { <line1> ServerName server = PolicyBasedChaosMonkey.selectRandomItem(getCurrentServers()); <line2> String hostname = server.getHostname(); <line3> try { <line4> clusterManager.execSudoWithRetries(hostname, timeout, getCommand(ADD)); <line5> Thread.sleep(duration); <line6> } catch (InterruptedException e) { <line7> } finally { <line8> clusterManager.execSudoWithRetries(hostname, timeout, getCommand(DELETE)); <line9> } <line10> } <line11> } <line12> 	 <line1>	Yes
public class A { <line0> @Override <line1> public ShareStudy findByID(Integer shareStudyId) { <line2> ShareStudy shareStudy = null; <line3> if (shareStudyId != null) { <line4> try { <line5> shareStudy = dao.findByID(shareStudyId); <line6> } catch (Exception exception) { <line7> } <line8> } <line9> return shareStudy; <line10> } <line11> } <line12> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void cmdExecute( <line2> final Message clientMessage, <line3> final ServerConnection serverConnection, <line4> final SecurityService securityService, <line5> long start) <line6> throws IOException { <line7> writeErrorResponse(clientMessage, MessageType.INVALID, serverConnection); <line8> } <line9> } <line10> 	 <line5>	No
"public class A { <line0> @Override <line1> public CompletableFuture<Acknowledge> sendOperatorEventToTask( <line2> ExecutionAttemptID executionAttemptID, <line3> OperatorID operatorId, <line4> SerializedValue<OperatorEvent> evt) { <line5> final Task task = taskSlotTable.getTask(executionAttemptID); <line6> if (task == null) { <line7> return FutureUtils.completedExceptionally( <line8> new TaskNotRunningException( <line9> ""Task "" + executionAttemptID + "" not running on TaskManager"")); <line10> } <line11> try { <line12> task.deliverOperatorEvent(operatorId, evt); <line13> return CompletableFuture.completedFuture(Acknowledge.get()); <line14> } catch (Throwable t) { <line15> ExceptionUtils.rethrowIfFatalError(t); <line16> return FutureUtils.completedExceptionally(t); <line17> } <line18> } <line19> } <line20> "	 <line6>	No
"public class A { <line0> @Override <line1> public void configure( <line2> DBBroker broker, Txn transaction, Collection parent, Map<String, List<?>> parameters) <line3> throws TriggerException { <line4> super.configure(broker, transaction, parent, parameters); <line5> final String stylesheet = (String) parameters.get(""src"").get(0); <line6> if (stylesheet == null) { <line7> throw new TriggerException(""STXTransformerTrigger requires an attribute 'src'""); <line8> } <line9> XmldbURI stylesheetUri = null; <line10> try { <line11> stylesheetUri = XmldbURI.xmldbUriFor(stylesheet); <line12> } catch (final URISyntaxException e) { <line13> } <line14> if (stylesheetUri == null || stylesheet.indexOf(':') == Constants.STRING_NOT_FOUND) { <line15> stylesheetUri = parent.getURI().resolveCollectionPath(stylesheetUri); <line16> DocumentImpl doc; <line17> try { <line18> doc = (DocumentImpl) broker.getXMLResource(stylesheetUri); <line19> if (doc == null) { <line20> throw new TriggerException(""stylesheet "" + stylesheetUri + "" not found in database""); <line21> } <line22> if (doc instanceof BinaryDocument) { <line23> throw new TriggerException( <line24> ""stylesheet "" <line25> + stylesheetUri <line26> + "" must be stored as an xml document and not a binary document!""); <line27> } <line28> handler = <line29> factory.newTransformerHandler( <line30> STXTemplatesCache.getInstance().getOrUpdateTemplate(broker, doc)); <line31> } catch (final TransformerConfigurationException <line32> | PermissionDeniedException <line33> | SAXException <line34> | LockException e) { <line35> throw new TriggerException(e.getMessage(), e); <line36> } <line37> } else { <line38> try { <line39> final Templates template = factory.newTemplates(new StreamSource(stylesheet)); <line40> handler = factory.newTransformerHandler(template); <line41> } catch (final TransformerConfigurationException e) { <line42> throw new TriggerException(e.getMessage(), e); <line43> } <line44> } <line45> } <line46> } <line47> "	 <line39>	Yes
"public class A { <line0> public static void waitForServiceDeletion(String serviceName) { <line1> TestUtils.waitFor( <line2> ""Service "" + serviceName + "" to be deleted"", <line3> Constants.POLL_INTERVAL_FOR_RESOURCE_READINESS, <line4> DELETION_TIMEOUT, <line5> () -> kubeClient().getService(serviceName) == null); <line6> } <line7> } <line8> "	 <line1>	Yes
public class A { <line0> @Test <line1> public void testUnsupportedInstallTasks() <line2> throws IOException, PackageException, RepositoryException { <line3> PackageId idC = registry.register(getStream(TEST_PACKAGE_C_10), false); <line4> ExecutionPlanBuilder builder = registry.createExecutionPlan(); <line5> builder.with( <line6> new ProgressTrackerListener() { <line7> public void onMessage(Mode mode, String action, String path) { <line8> } <line9>  <line10> public void onError(Mode mode, String path, Exception e) { <line11> } <line12> }); <line13> builder.addTask().with(idC).with(PackageTask.Type.INSTALL); <line14> ExecutionPlan plan = builder.with(admin).execute(); <line15> assertTrue(plan.hasErrors()); <line16> assertFalse(registry.open(idC).isInstalled()); <line17> } <line18> } <line19> 	 <line11>	Yes
"public class A { <line0> protected void singleOrderBySameRangeScanGreater(IoHelper io) throws Exception { <line1> io.doSetup(); <line2> int size = 20; <line3> int queryLimit = 10; <line4> int startValue = 9; <line5> long start = System.currentTimeMillis(); <line6> List<String> expected = new ArrayList<String>(size); <line7> for (int i = 0; i < size; i++) { <line8> String name = String.valueOf(i); <line9> Map<String, Object> entity = new HashMap<String, Object>(); <line10> entity.put(""name"", name); <line11> entity.put(""index"", i); <line12> io.writeEntity(entity); <line13> expected.add(name); <line14> } <line15> app.waitForQueueDrainAndRefreshIndex(); <line16> Thread.sleep(500); <line17> long stop = System.currentTimeMillis(); <line18> Query query = Query.fromQL(""select * where index >= "" + startValue + "" order by index desc""); <line19> query.setLimit(queryLimit); <line20> int count = 0; <line21> start = System.currentTimeMillis(); <line22> Results results; <line23> do { <line24> results = io.getResults(query); <line25> for (int i = 0; i < results.size(); i++) { <line26> assertEquals(expected.get(size - count - 1), results.getEntities().get(i).getName()); <line27> count++; <line28> } <line29> query.setCursor(results.getCursor()); <line30> } while (results.hasCursor()); <line31> assertEquals(expected.size() - startValue, count); <line32> stop = System.currentTimeMillis(); <line33> } <line34> } <line35> "	 <line23>	No
public class A { <line0> @Override <line1> protected void loadBeanDefinitions(XmlBeanDefinitionReader xmlBeanDefinitionReader) { <line2> try { <line3> super.loadBeanDefinitions(xmlBeanDefinitionReader); <line4> } catch (Exception exception) { <line5> if (_log.isWarnEnabled()) { <line6> } <line7> } <line8> xmlBeanDefinitionReader.setResourceLoader(new PathMatchingResourcePatternResolver()); <line9> if (PropsValues.SPRING_CONFIGS == null) { <line10> return; <line11> } <line12> for (String configLocation : PropsValues.SPRING_CONFIGS) { <line13> try { <line14> xmlBeanDefinitionReader.loadBeanDefinitions(configLocation); <line15> } catch (Exception exception) { <line16> Throwable throwable = exception.getCause(); <line17> if (throwable instanceof FileNotFoundException) { <line18> if (_log.isWarnEnabled()) { <line19> } <line20> } else { <line21> } <line22> } <line23> } <line24> } <line25> } <line26> 	 <line11>	No
public class A { <line0> void stop(Duration timeout, Duration graceTimeoutForSubsequentOperations) { <line1> synchronized (startStopMutex) { <line2> state = ListenerState.STOPPING; <line3> try { <line4> if (scheduledTask != null) { <line5> CountdownTimer expiry = timeout.countdownTimer(); <line6> try { <line7> scheduledTask.cancel(false); <line8> waitForPendingComplete( <line9> expiry <line10> .getDurationRemaining() <line11> .lowerBound(Duration.ZERO) <line12> .add(graceTimeoutForSubsequentOperations), <line13> true); <line14> } catch (Exception e) { <line15> throw Exceptions.propagate(e); <line16> } <line17> scheduledTask.blockUntilEnded( <line18> expiry <line19> .getDurationRemaining() <line20> .lowerBound(Duration.ZERO) <line21> .add(graceTimeoutForSubsequentOperations)); <line22> scheduledTask.cancel(true); <line23> boolean reallyEnded = <line24> Tasks.blockUntilInternalTasksEnded( <line25> scheduledTask, <line26> expiry <line27> .getDurationRemaining() <line28> .lowerBound(Duration.ZERO) <line29> .add(graceTimeoutForSubsequentOperations)); <line30> if (!reallyEnded) { <line31> } <line32> scheduledTask = null; <line33> } <line34> synchronized (this) { <line35> deltaCollector = new DeltaCollector(); <line36> } <line37> } finally { <line38> state = ListenerState.STOPPED; <line39> } <line40> } <line41> } <line42> } <line43> 	 <line38>	No
"public class A { <line0> private void fixBasicZoneNicCount(Connection conn) { <line1> try { <line2> PreparedStatement pstmt = <line3> conn.prepareStatement(""SELECT id from data_center where networktype='Basic'""); <line4> ResultSet rs = pstmt.executeQuery(); <line5> while (rs.next()) { <line6> Long zoneId = rs.getLong(1); <line7> Long networkId = null; <line8> Long vmCount = 0L; <line9> pstmt = <line10> conn.prepareStatement( <line11> ""SELECT id from networks where data_center_id=? AND guest_type='Direct'""); <line12> pstmt.setLong(1, zoneId); <line13> rs = pstmt.executeQuery(); <line14> if (rs.next()) { <line15> networkId = rs.getLong(1); <line16> } else { <line17> continue; <line18> } <line19> pstmt = <line20> conn.prepareStatement( <line21> ""SELECT count(*) from vm_instance where name like 'i-%' and (state='Running' or"" <line22> + "" state='Starting' or state='Stopping')""); <line23> rs = pstmt.executeQuery(); <line24> if (rs.next()) { <line25> vmCount = rs.getLong(1); <line26> } <line27> pstmt = conn.prepareStatement(""UPDATE op_networks set nics_count=? where id=?""); <line28> pstmt.setLong(1, vmCount); <line29> pstmt.setLong(2, networkId); <line30> pstmt.executeUpdate(); <line31> } <line32> rs.close(); <line33> pstmt.close(); <line34> } catch (SQLException e) { <line35> throw new CloudRuntimeException(""Unable to drop 'path' index for 'domain' table due to:"", e); <line36> } <line37> } <line38> } <line39> "	 <line9>	Yes
"public class A { <line0> public void open( <line1> Connection conn, String fileName, long filePosition, final int serverId, boolean nonBlocking) <line2> throws IOException { <line3> try { <line4> this.conn = conn; <line5> Class<?> connClazz = Class.forName(""com.mysql.jdbc.ConnectionImpl""); <line6> Object unwrapConn = unwrapConnection(conn, connClazz); <line7> if (unwrapConn == null) { <line8> throw new IOException( <line9> ""Unable to unwrap "" + conn.getClass().getName() + "" to com.mysql.jdbc.ConnectionImpl""); <line10> } <line11> Object connIo = getDeclaredField(unwrapConn, connClazz, ""io""); <line12> if (connIo == null) { <line13> throw new IOException(""Get null field:"" + conn.getClass().getName() + ""#io""); <line14> } <line15> mysqlOutput = (OutputStream) getDeclaredField(connIo, connIo.getClass(), ""mysqlOutput""); <line16> mysqlInput = (InputStream) getDeclaredField(connIo, connIo.getClass(), ""mysqlInput""); <line17> if (filePosition == 0) filePosition = BIN_LOG_HEADER_SIZE; <line18> sendBinlogDump(fileName, filePosition, serverId, nonBlocking); <line19> position = 0; <line20> } catch (IOException e) { <line21> close(); <line22> throw e; <line23> } catch (ClassNotFoundException e) { <line24> close(); <line25> throw new IOException(""Unable to load com.mysql.jdbc.ConnectionImpl"", e); <line26> } <line27> } <line28> } <line29> "	 <line22>	Yes
public class A { <line0> protected <T> ServiceResponse<T> makeBackwardCompatibleHttpPostRequestAndCreateServiceResponse( <line1> String uri, String body, Class<T> resultType) { <line2> KieServerHttpRequest request = newRequest(uri).body(body).post(); <line3> KieServerHttpResponse response = request.response(); <line4> owner.setConversationId(response.header(KieServerConstants.KIE_CONVERSATION_ID_TYPE_HEADER)); <line5> if (response.code() == Response.Status.OK.getStatusCode()) { <line6> ServiceResponse serviceResponse = deserialize(response.body(), ServiceResponse.class); <line7> serviceResponse.setResult(serialize(serviceResponse.getResult())); <line8> checkResultType(serviceResponse, resultType); <line9> return serviceResponse; <line10> } else { <line11> throw createExceptionForUnexpectedResponseCode(request, response); <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
public class A { <line0> @Override <line1> public boolean isVisible(String locator) { <line2> boolean result = false; <line3> try { <line4> result = super.isVisible(locator); <line5> } catch (Throwable t) { <line6> } <line7> return result; <line8> } <line9> } <line10> 	 <line7>	No
"public class A { <line0> private Response getFluxtreamCapturePhoto( <line1> final long uid, <line2> final Request request, <line3> @NotNull final FluxtreamCapturePhotoFetchStrategy photoFetchStrategy) { <line4> boolean accessAllowed = false; <line5> Long loggedInUserId = null; <line6> try { <line7> loggedInUserId = AuthHelper.getGuestId(); <line8> accessAllowed = isOwnerOrAdmin(uid); <line9> if (!accessAllowed) { <line10> final TrustedBuddy trustedBuddy = buddiesService.getTrustedBuddy(loggedInUserId, uid); <line11> if (trustedBuddy != null) { <line12> List<ApiKey> flxApiKeys = <line13> guestService.getApiKeys( <line14> trustedBuddy.guestId, Connector.getConnector(""fluxtream_capture"")); <line15> if (flxApiKeys == null || flxApiKeys.size() == 0) accessAllowed = false; <line16> else { <line17> ApiKey flxApiKey = flxApiKeys.get(0); <line18> accessAllowed = hasSharedChannel(flxApiKey, trustedBuddy, ""photo""); <line19> } <line20> } <line21> } <line22> } catch (Exception e) { <line23> } <line24> if (accessAllowed) { <line25> final FluxtreamCapturePhotoStore.Photo photo; <line26> try { <line27> photo = photoFetchStrategy.getPhoto(); <line28> } catch (Exception e) { <line29> final String message = <line30> ""Exception while trying to get photo ["" + photoFetchStrategy.getPhotoIdentifier() + ""]""; <line31> return jsonResponseHelper.internalServerError(message); <line32> } <line33> if (photo == null) { <line34> final String message = <line35> ""Photo ["" <line36> + photoFetchStrategy.getPhotoIdentifier() <line37> + ""] requested by user ["" <line38> + loggedInUserId <line39> + ""] not found""; <line40> return jsonResponseHelper.notFound(message); <line41> } <line42> final CacheControl cc = new CacheControl(); <line43> cc.setNoTransform(true); <line44> cc.setMustRevalidate(false); <line45> cc.setNoCache(false); <line46> cc.setMaxAge(ONE_WEEK_IN_SECONDS); <line47> EntityTag etag; <line48> try { <line49> etag = new EntityTag(HashUtils.computeMd5Hash(photo.getPhotoBytes())); <line50> final Response.ResponseBuilder responseBuilder = request.evaluatePreconditions(etag); <line51> if (responseBuilder != null) { <line52> return responseBuilder.cacheControl(cc).build(); <line53> } <line54> } catch (NoSuchAlgorithmException e) { <line55> etag = null; <line56> } <line57> Response.ResponseBuilder responseBuilder = Response.ok().cacheControl(cc); <line58> if (etag != null) { <line59> responseBuilder = responseBuilder.tag(etag); <line60> } <line61> final Long lastUpdatedTimestamp = photo.getLastUpdatedTimestamp(); <line62> if (lastUpdatedTimestamp != null) { <line63> responseBuilder = responseBuilder.lastModified(new Date(lastUpdatedTimestamp)); <line64> } <line65> return responseBuilder <line66> .type(photo.getImageType().getMediaType()) <line67> .expires(new DateTime().plusMonths(1).toDate()) <line68> .entity(photo.getPhotoBytes()) <line69> .build(); <line70> } <line71> return jsonResponseHelper.forbidden( <line72> ""User ["" <line73> + loggedInUserId <line74> + ""] is not authorized to view photo ["" <line75> + photoFetchStrategy.getPhotoIdentifier() <line76> + ""]""); <line77> } <line78> } <line79> "	 <line23>	Yes
public class A { <line0> public void leave(RoomParticipant user) { <line1> checkClosed(); <line2> this.removeParticipant(user.getName()); <line3> user.close(); <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> private void rollbackTransaction() { <line1> if (transaction != null) { <line2> try { <line3> transaction.rollback(); <line4> } catch (RuntimeException ex) { <line5> } finally { <line6> transaction.close(); <line7> this.transaction = null; <line8> } <line9> } <line10> } <line11> } <line12> 	 <line5>	Yes
"public class A { <line0> @Override <line1> protected void setUp() throws Exception { <line2> if (broker == null) { <line3> broker = createBroker(bindAddress); <line4> } <line5> factory = createConnectionFactory(bindAddress); <line6> managementConnection = factory.createConnection(); <line7> managementSession = managementConnection.createSession(false, Session.AUTO_ACKNOWLEDGE); <line8> Destination startDestination = createDestination(managementSession, getClass() + "".start""); <line9> Destination endDestination = createDestination(managementSession, getClass() + "".end""); <line10> controller = new LoadController(""Controller"", factory); <line11> controller.setBatchSize(batchSize); <line12> controller.setNumberOfBatches(numberOfBatches); <line13> controller.setDeliveryMode(deliveryMode); <line14> controller.setConnectionPerMessage(connectionPerMessage); <line15> controller.setStartDestination(startDestination); <line16> controller.setNextDestination(endDestination); <line17> controller.setTimeout(timeout); <line18> clients = new LoadClient[numberOfClients]; <line19> for (int i = 0; i < numberOfClients; i++) { <line20> Destination inDestination = null; <line21> if (i == 0) { <line22> inDestination = startDestination; <line23> } else { <line24> inDestination = createDestination(managementSession, getClass() + "".client."" + (i)); <line25> } <line26> Destination outDestination = null; <line27> if (i == (numberOfClients - 1)) { <line28> outDestination = endDestination; <line29> } else { <line30> outDestination = createDestination(managementSession, getClass() + "".client."" + (i + 1)); <line31> } <line32> LoadClient client = new LoadClient(""client("" + i + "")"", factory); <line33> client.setTimeout(timeout); <line34> client.setDeliveryMode(deliveryMode); <line35> client.setConnectionPerMessage(connectionPerMessage); <line36> client.setStartDestination(inDestination); <line37> client.setNextDestination(outDestination); <line38> clients[i] = client; <line39> } <line40> super.setUp(); <line41> } <line42> } <line43> "	 <line22>	No
"public class A { <line0> @Override <line1> public void executeImpl(DelegateExecution execution) throws Exception { <line2> String contentTypeString = <line3> activitiHelper <line4> .getRequiredExpressionVariableAsString(contentType, execution, ""ContentType"") <line5> .trim(); <line6> String requestString = <line7> activitiHelper <line8> .getRequiredExpressionVariableAsString( <line9> businessObjectDataStorageFilesCreateRequest, <line10> execution, <line11> ""BusinessObjectDataCreateRequest"") <line12> .trim(); <line13> BusinessObjectDataStorageFilesCreateRequest request = <line14> getRequestObject( <line15> contentTypeString, requestString, BusinessObjectDataStorageFilesCreateRequest.class); <line16> BusinessObjectDataStorageFilesCreateResponse businessObjectDataStorageFilesCreateResponse = <line17> businessObjectDataStorageFileService.createBusinessObjectDataStorageFiles(request); <line18> setJsonResponseAsWorkflowVariable(businessObjectDataStorageFilesCreateResponse, execution); <line19> } <line20> } <line21> "	 <line16>	Yes
"public class A { <line0> @Override <line1> public Map<String, String> writeXMLAttributes() { <line2> Map<String, String> attributes = new TreeMap<String, String>(); <line3> int level = getLevel(); <line4> if (1 < level) { <line5> if (isSetAnnotation() && getAnnotation().isSetRDFannotation() && !isSetMetaId()) { <line6> SBMLDocument doc = getSBMLDocument(); <line7> if (doc != null) { <line8> setMetaId(doc.nextMetaId()); <line9> getAnnotation().setAbout('#' + getMetaId()); <line10> } else { <line11> } <line12> } <line13> if (isSetMetaId()) { <line14> attributes.put(""metaid"", getMetaId()); <line15> } <line16> if (((level == 2) && (getVersion() >= 2)) || (level > 2)) { <line17> if (isSetSBOTerm()) { <line18> attributes.put(""sboTerm"", getSBOTermID()); <line19> } <line20> } <line21> } <line22> if (isSetId()) { <line23> if (getLevel() != 1) { <line24> attributes.put(""id"", getId()); <line25> } else { <line26> attributes.put(""name"", getId()); <line27> } <line28> } <line29> if (isSetName()) { <line30> attributes.put(""name"", getName()); <line31> } <line32> if ((extensions != null) && (extensions.size() > 0)) { <line33> for (String key : extensions.keySet()) { <line34> SBasePlugin plugin = extensions.get(key); <line35> if (plugin != null) { <line36> Map<String, String> pluginAttributes = plugin.writeXMLAttributes(); <line37> if (pluginAttributes != null) { <line38> attributes.putAll(pluginAttributes); <line39> } <line40> } else { <line41> } <line42> } <line43> } <line44> return attributes; <line45> } <line46> } <line47> "	 <line41>	Yes
public class A { <line0> public void onFailure(Object problem) { <line1> if (log != null) { <line2> } <line3> this.problem = problem; <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> public static String post(String url, String message) throws IOException, XMLStreamException { <line1> RegistryUtils.setTrustStoreSystemProperties(); <line2> HttpClient httpClient = new HttpClient(); <line3> PostMethod postRequest = new PostMethod(url); <line4> postRequest.setRequestHeader(""Authorization"", BPMNAnalyticsCoreUtils.getAuthorizationHeader()); <line5> BufferedReader br = null; <line6> try { <line7> StringRequestEntity input = new StringRequestEntity(message, ""application/json"", ""UTF-8""); <line8> postRequest.setRequestEntity(input); <line9> int returnCode = httpClient.executeMethod(postRequest); <line10> if (returnCode != HttpStatus.SC_OK) { <line11> String errorCode = ""Failed : HTTP error code : "" + returnCode; <line12> throw new RuntimeException(errorCode); <line13> } <line14> String charsetname = StandardCharsets.UTF_8.name(); <line15> if (postRequest.getResponseCharSet() != null) { <line16> charsetname = postRequest.getResponseCharSet(); <line17> } <line18> InputStreamReader reader = <line19> new InputStreamReader((postRequest.getResponseBodyAsStream()), charsetname); <line20> br = new BufferedReader(reader); <line21> String output = null; <line22> StringBuilder totalOutput = new StringBuilder(); <line23> if (log.isDebugEnabled()) { <line24> } <line25> while ((output = br.readLine()) != null) { <line26> totalOutput.append(output); <line27> } <line28> return totalOutput.toString(); <line29> } catch (UnsupportedEncodingException e) { <line30> String errMsg = ""Async DAS client unsupported encoding exception.""; <line31> throw new UnsupportedEncodingException(errMsg); <line32> } catch (UnsupportedOperationException e) { <line33> String errMsg = ""Async DAS client unsupported operation exception.""; <line34> throw new UnsupportedOperationException(errMsg); <line35> } catch (IOException e) { <line36> String errMsg = ""Async DAS client I/O exception.""; <line37> } finally { <line38> postRequest.releaseConnection(); <line39> if (br != null) { <line40> try { <line41> br.close(); <line42> } catch (Exception e) { <line43> String errMsg = ""Async DAS rest client BufferedReader close exception.""; <line44> } <line45> } <line46> } <line47> return null; <line48> } <line49> } <line50> "	 <line24>	Yes
"public class A { <line0> @Override <line1> public Object invoke(Object proxy, Method method, Method proceed, Object[] args) <line2> throws Throwable { <line3> try { <line4> Aspect aspect = intf.getAnnotation(Aspect.class); <line5> if (aspect != null) { <line6> Class<? extends Advice> adviceClass = aspect.advice(); <line7> Advice advice = adviceClass.newInstance(); <line8> Object ret = advice.invoke(target, proceed, args); <line9> return ret; <line10> } <line11> aspect = method.getAnnotation(Aspect.class); <line12> if (aspect != null) { <line13> Class<? extends Advice> adviceClass = aspect.advice(); <line14> Advice advice = adviceClass.newInstance(); <line15> Object ret = advice.invoke(target, proceed, args); <line16> return ret; <line17> } <line18> if (target instanceof AbstractDao) { <line19> Advice advice = new Transaction(); <line20> Object ret = advice.invoke(target, proceed, args); <line21> return ret; <line22> } <line23> if (logger.isTraceEnabled()) { <line24> } <line25> Object ret = proceed.invoke(proxy, args); <line26> if (logger.isTraceEnabled()) { <line27> } <line28> return ret; <line29> } catch (Throwable e) { <line30> if (e instanceof InvocationTargetException) { <line31> InvocationTargetException invocationTargetException = (InvocationTargetException) e; <line32> Throwable throwable = invocationTargetException.getTargetException(); <line33> if (logger.isInfoEnabled()) { <line34> StringBuilder builder = new StringBuilder(); <line35> builder <line36> .append(""error. [object]"") <line37> .append(proxy.getClass().toString()) <line38> .append(""[proceed]"") <line39> .append(proceed.getName()); <line40> if (args != null) { <line41> int count = 0; <line42> for (Object param : args) { <line43> builder.append(""[param"").append(count++).append(""]"").append(param); <line44> } <line45> } <line46> builder.append(""\n[throwable.getMessage()] "").append(throwable.getMessage()); <line47> } <line48> throw throwable; <line49> } else { <line50> if (logger.isInfoEnabled()) { <line51> if (e.getCause() != null) { <line52> } <line53> } <line54> } <line55> throw e; <line56> } <line57> } <line58> } <line59> "	 <line54>	No
public class A { <line0> private void validateEntry( <line1> long ledgerId, long entryId, long entryLogId, long pos, ByteBuf sizeBuff) <line2> throws IOException, EntryLookupException { <line3> int entrySize = sizeBuff.readInt(); <line4> if (entrySize > maxSaneEntrySize) { <line5> } <line6> if (entrySize < MIN_SANE_ENTRY_SIZE) { <line7> throw new EntryLookupException.InvalidEntryLengthException( <line8> ledgerId, entryId, entryLogId, pos); <line9> } <line10> long thisLedgerId = sizeBuff.getLong(4); <line11> long thisEntryId = sizeBuff.getLong(12); <line12> if (thisLedgerId != ledgerId || thisEntryId != entryId) { <line13> throw new EntryLookupException.WrongEntryException( <line14> thisEntryId, thisLedgerId, ledgerId, entryId, entryLogId, pos); <line15> } <line16> } <line17> } <line18> 	 <line7>	Yes
public class A { <line0> private void logMQTTMessage(ChannelHandlerContext ctx, Object message, String direction) { <line1> if (!(message instanceof MqttMessage)) { <line2> return; <line3> } <line4> MqttMessage msg = (MqttMessage) message; <line5> String clientID = NettyUtils.clientID(ctx.channel()); <line6> MqttMessageType messageType = msg.fixedHeader().messageType(); <line7> switch (messageType) { <line8> case CONNECT: <line9> case CONNACK: <line10> case PINGREQ: <line11> case PINGRESP: <line12> case DISCONNECT: <line13> break; <line14> case SUBSCRIBE: <line15> MqttSubscribeMessage subscribe = (MqttSubscribeMessage) msg; <line16> break; <line17> case UNSUBSCRIBE: <line18> MqttUnsubscribeMessage unsubscribe = (MqttUnsubscribeMessage) msg; <line19> break; <line20> case PUBLISH: <line21> MqttPublishMessage publish = (MqttPublishMessage) msg; <line22> break; <line23> case PUBREC: <line24> case PUBCOMP: <line25> case PUBREL: <line26> case PUBACK: <line27> case UNSUBACK: <line28> break; <line29> case SUBACK: <line30> MqttSubAckMessage suback = (MqttSubAckMessage) msg; <line31> final List<Integer> grantedQoSLevels = suback.payload().grantedQoSLevels(); <line32> break; <line33> } <line34> } <line35> } <line36> 	 <line28>	Yes
public class A { <line0> private void cancelTimeout(Timeout timeout) { <line1> if (timeout != null) { <line2> timeout.cancel(); <line3> } <line4> } <line5> } <line6> 	 <line2>	Yes
public class A { <line0> private void trySendBounce(Mail originalMail) throws MessagingException { <line1> MailImpl newMail = MailImpl.duplicate(originalMail); <line2> try { <line3> newMail.setRemoteHost(getRemoteHost()); <line4> newMail.setRemoteAddr(getRemoteAddr()); <line5> newMail.setRecipients(getSenderAsList(originalMail)); <line6> if (getInitParameters().isDebug()) { <line7> } <line8> newMail.setMessage(createBounceMessage(originalMail)); <line9> MailModifier mailModifier = <line10> MailModifier.builder().mailet(this).mail(newMail).dns(dns).build(); <line11> mailModifier.setRecipients(getRecipients(originalMail)); <line12> mailModifier.setTo(getTo(originalMail)); <line13> mailModifier.setSubjectPrefix(originalMail); <line14> mailModifier.setReplyTo(getReplyTo(originalMail)); <line15> mailModifier.setReversePath(getReversePath(originalMail)); <line16> mailModifier.setIsReply(getInitParameters().isReply(), originalMail); <line17> mailModifier.setSender(getSender(originalMail)); <line18> newMail.getMessage().setHeader(RFC2822Headers.DATE, getDateHeader(originalMail)); <line19> newMail.getMessage().saveChanges(); <line20> getMailetContext().sendMail(newMail); <line21> } finally { <line22> newMail.dispose(); <line23> } <line24> } <line25> } <line26> 	 <line9>	No
"public class A { <line0> static void linkUserData(String tempDirName) { <line1> String userDataFilePath = <line2> tempDirName + ConfigDrive.cloudStackConfigDriveName + ""userdata/user_data.txt""; <line3> File file = new File(userDataFilePath); <line4> if (file.exists()) { <line5> Script hardLink = new Script(""ln"", Duration.standardSeconds(300), LOG); <line6> hardLink.add(userDataFilePath); <line7> hardLink.add(tempDirName + ConfigDrive.openStackConfigDriveName + ""user_data""); <line8> String executionResult = hardLink.execute(); <line9> if (StringUtils.isNotBlank(executionResult)) { <line10> throw new CloudRuntimeException( <line11> ""Unable to create user_data link due to "" + executionResult); <line12> } <line13> } <line14> } <line15> } <line16> "	 <line13>	No
public class A { <line0> @Override <line1> public void emitSchemaChangeEvent(Receiver receiver) throws InterruptedException { <line2> final Table tableBefore = schema.tableFor(tableId); <line3> final OracleDdlParser parser = schema.getDdlParser(); <line4> final DdlChanges ddlChanges = parser.getDdlChanges(); <line5> try { <line6> ddlChanges.reset(); <line7> parser.setCurrentDatabase(sourceDatabaseName); <line8> parser.setCurrentSchema(objectOwner); <line9> parser.parse(ddlText, schema.getTables()); <line10> } catch (ParsingException | MultipleParsingExceptions e) { <line11> if (databaseHistory.skipUnparseableDdlStatements()) { <line12> streamingMetrics.incrementWarningCount(); <line13> streamingMetrics.incrementUnparsableDdlCount(); <line14> } else { <line15> throw e; <line16> } <line17> } <line18> if (!ddlChanges.isEmpty() && filters.isIncluded(tableId)) { <line19> List<SchemaChangeEvent> changeEvents = new ArrayList<>(); <line20> ddlChanges.getEventsByDatabase( <line21> (String dbName, List<DdlParserListener.Event> events) -> { <line22> events.forEach( <line23> event -> { <line24> switch (event.type()) { <line25> case CREATE_TABLE: <line26> changeEvents.add(createTableEvent((TableCreatedEvent) event)); <line27> break; <line28> case ALTER_TABLE: <line29> changeEvents.add(alterTableEvent((TableAlteredEvent) event)); <line30> break; <line31> case DROP_TABLE: <line32> changeEvents.add(dropTableEvent(tableBefore, (TableDroppedEvent) event)); <line33> break; <line34> default: <line35> break; <line36> } <line37> }); <line38> }); <line39> for (SchemaChangeEvent event : changeEvents) { <line40> receiver.schemaChangeEvent(event); <line41> } <line42> } <line43> } <line44> } <line45> 	 <line35>	Yes
"public class A { <line0> private static Stream<MCRPath> defaultDerivateFileStream(MCRDerivate derivate) { <line1> MCRObjectID derivateId = derivate.getId(); <line2> Path derivRoot = MCRPath.getPath(derivateId.toString(), ""/""); <line3> try { <line4> return Files.walk(derivRoot) <line5> .map(MCRPath::toMCRPath) <line6> .filter(p -> !Files.isDirectory(p)) <line7> .filter(p -> !p.equals(derivRoot)); <line8> } catch (IOException e) { <line9> } catch (SecurityException s) { <line10> } <line11> return Stream.empty(); <line12> } <line13> } <line14> "	 <line10>	Yes
"public class A { <line0> @Override <line1> public DataCell[] getCells(final DataRow row) { <line2> DataCell[] newcells = new DataCell[m_colindices.length]; <line3> for (int i = 0; i < newcells.length; i++) { <line4> DataCell dc = row.getCell(m_colindices[i]); <line5> if (!dc.isMissing()) { <line6> final String s = ((StringValue) dc).getStringValue(); <line7> if (s.trim().length() == 0) { <line8> newcells[i] = DataType.getMissingCell(); <line9> continue; <line10> } <line11> try { <line12> String corrected = s; <line13> if (m_thousandsSep != null && m_thousandsSep.length() > 0) { <line14> corrected = s.replaceAll(Pattern.quote(m_thousandsSep), """"); <line15> } <line16> if (!""."".equals(m_decimalSep)) { <line17> if (corrected.contains(""."")) { <line18> throw new NumberFormatException(""Invalid floating point number""); <line19> } <line20> if (m_decimalSep != null && m_decimalSep.length() > 0) { <line21> corrected = corrected.replaceAll(Pattern.quote(m_decimalSep), "".""); <line22> } <line23> } <line24> if (!m_genericParse) { <line25> corrected = check(corrected); <line26> } <line27> if (m_type.equals(DoubleCell.TYPE)) { <line28> double parsedDouble = Double.parseDouble(corrected); <line29> newcells[i] = new DoubleCell(parsedDouble); <line30> } else if (m_type.equals(IntCell.TYPE)) { <line31> int parsedInteger = Integer.parseInt(corrected); <line32> newcells[i] = new IntCell(parsedInteger); <line33> } else if (m_type.equals(LongCell.TYPE)) { <line34> long parsedLong = Long.parseLong(corrected); <line35> newcells[i] = new LongCell(parsedLong); <line36> } else { <line37> m_error = ""No valid parse type.""; <line38> } <line39> } catch (NumberFormatException e) { <line40> if (m_parseErrorCount == 0) { <line41> m_error = <line42> ""'"" <line43> + s <line44> + ""' (RowKey: "" <line45> + row.getKey().toString() <line46> + "", Position: "" <line47> + m_colindices[i] <line48> + "")""; <line49> } <line50> m_parseErrorCount++; <line51> newcells[i] = DataType.getMissingCell(); <line52> } <line53> } else { <line54> newcells[i] = DataType.getMissingCell(); <line55> } <line56> } <line57> return newcells; <line58> } <line59> } <line60> "	 <line28>	No
public class A { <line0> @Override <line1> protected void postParse(CommandLine commandLine) throws CommandLineParseException { <line2> certificateAuthorityHostname = <line3> commandLine.getOptionValue(CERTIFICATE_AUTHORITY_HOSTNAME_ARG, TlsConfig.DEFAULT_HOSTNAME); <line4> days = getIntValue(commandLine, DAYS_ARG, TlsConfig.DEFAULT_DAYS); <line5> keySize = getIntValue(commandLine, KEY_SIZE_ARG, TlsConfig.DEFAULT_KEY_SIZE); <line6> keyAlgorithm = <line7> commandLine.getOptionValue(KEY_ALGORITHM_ARG, TlsConfig.DEFAULT_KEY_PAIR_ALGORITHM); <line8> keyStoreType = commandLine.getOptionValue(KEY_STORE_TYPE_ARG, getKeyStoreTypeDefault()); <line9> if (KeystoreType.PKCS12.toString().equalsIgnoreCase(keyStoreType)) { <line10> } <line11> signingAlgorithm = <line12> commandLine.getOptionValue(SIGNING_ALGORITHM_ARG, TlsConfig.DEFAULT_SIGNING_ALGORITHM); <line13> differentPasswordForKeyAndKeystore = <line14> commandLine.hasOption(DIFFERENT_KEY_AND_KEYSTORE_PASSWORDS_ARG); <line15> } <line16> } <line17> 	 <line2>	No
"public class A { <line0> private void addEntryToTar(File source, String entryName, byte[] buffer, int length) <line1> throws IOException, ArchiveException { <line2> File tmpTar = Files.createTempFile(parentDir.toPath(), source.getName(), null).toFile(); <line3> tmpTar.delete(); <line4> if (!source.renameTo(tmpTar)) { <line5> throw new IOException(""Cannot create temp file: "" + source.getName()); <line6> } <line7> FileInputStream fis = new FileInputStream(tmpTar); <line8> TarArchiveInputStream tin = <line9> (TarArchiveInputStream) <line10> new ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.TAR, fis); <line11> TarArchiveOutputStream tos = new TarArchiveOutputStream(new FileOutputStream(source)); <line12> tos.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX); <line13> tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX); <line14> ArchiveEntry nextEntry; <line15> while ((nextEntry = tin.getNextEntry()) != null) { <line16> tos.putArchiveEntry(nextEntry); <line17> IOUtils.copy(tin, tos); <line18> tos.closeArchiveEntry(); <line19> } <line20> TarArchiveEntry entry = new TarArchiveEntry(entryName); <line21> entry.setSize(length); <line22> tos.putArchiveEntry(entry); <line23> tos.write(buffer, 0, length); <line24> tos.closeArchiveEntry(); <line25> IOHelper.close(fis, tin, tos); <line26> FileUtil.deleteFile(tmpTar); <line27> } <line28> } <line29> "	 <line26>	Yes
"public class A { <line0> public static com.liferay.asset.kernel.model.AssetVocabulary addVocabulary( <line1> HttpPrincipal httpPrincipal, <line2> long groupId, <line3> String title, <line4> java.util.Map<java.util.Locale, String> titleMap, <line5> java.util.Map<java.util.Locale, String> descriptionMap, <line6> String settings, <line7> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line8> throws com.liferay.portal.kernel.exception.PortalException { <line9> try { <line10> MethodKey methodKey = <line11> new MethodKey( <line12> AssetVocabularyServiceUtil.class, ""addVocabulary"", _addVocabularyParameterTypes1); <line13> MethodHandler methodHandler = <line14> new MethodHandler( <line15> methodKey, groupId, title, titleMap, descriptionMap, settings, serviceContext); <line16> Object returnObj = null; <line17> try { <line18> returnObj = TunnelUtil.invoke(httpPrincipal, methodHandler); <line19> } catch (Exception exception) { <line20> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line21> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line22> } <line23> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line24> } <line25> return (com.liferay.asset.kernel.model.AssetVocabulary) returnObj; <line26> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line27> throw systemException; <line28> } <line29> } <line30> } <line31> "	 <line17>	No
public class A { <line0> @Override <line1> public synchronized void start() { <line2> executorService = Executors.newFixedThreadPool(threadCount); <line3> } <line4> } <line5> 	 <line3>	No
public class A { <line0> public static Properties makePropertiesWithEnvironmentVariables(String properties_file) { <line1> Properties properties = new Properties(); <line2> try { <line3> properties.load(PropertiesUtil.class.getClassLoader().getResourceAsStream(properties_file)); <line4> } catch (IOException ex) { <line5> } <line6> Properties env_properties = new Properties(); <line7> for (String name : properties.stringPropertyNames()) { <line8> env_properties.setProperty(name, resolveValueWithEnvVars(properties.getProperty(name))); <line9> } <line10> return env_properties; <line11> } <line12> } <line13> 	 <line5>	Yes
public class A { <line0> public static FileLock tryLock(FileSystem fs, Path fileToLock, Path lockDirPath, String spoutId) <line1> throws IOException { <line2> Path lockFile = new Path(lockDirPath, fileToLock.getName()); <line3> try { <line4> FSDataOutputStream ostream = HdfsUtils.tryCreateFile(fs, lockFile); <line5> if (ostream != null) { <line6> return new FileLock(fs, lockFile, ostream, spoutId); <line7> } else { <line8> return null; <line9> } <line10> } catch (IOException e) { <line11> throw e; <line12> } <line13> } <line14> } <line15> 	 <line5>	No
public class A { <line0> @Override <line1> public void onStopContainerError(ContainerId containerId, Throwable t) { <line2> containers.remove(containerId); <line3> } <line4> } <line5> 	 <line4>	No
"public class A { <line0> @Test <line1> public void testCollectionToPrimitiveArrayConversion() throws Exception { <line2> List<Integer> list = new ArrayList<>(); <line3> list.add(5); <line4> list.add(6); <line5> Integer[] integerArray = converter.convertTo(Integer[].class, list); <line6> assertEquals(2, integerArray.length, ""Integer[] length""); <line7> int[] intArray = converter.convertTo(int[].class, list); <line8> assertEquals(2, intArray.length, ""int[] length""); <line9> long[] longArray = converter.convertTo(long[].class, intArray); <line10> assertEquals(2, longArray.length, ""long[] length""); <line11> List<?> resultList = converter.convertTo(List.class, intArray); <line12> assertEquals(2, resultList.size(), ""List size""); <line13> } <line14> } <line15> "	 <line13>	Yes
"public class A { <line0> private static void buildHistogramForManualFields( <line1> TransportClient dataClient, <line2> TransportClient statClient, <line3> StatContainer statContainer, <line4> String index, <line5> String type) { <line6> try { <line7> Optional<List<Field>> fields = StatUtil.getFieldsWithManualHistogram(statContainer, type); <line8> if (fields.isPresent() && !fields.get().isEmpty()) { <line9> for (Field field : fields.get()) { <line10> Histogram hist = field.getHistogram(); <line11> if (field.getFilter() != null && !field.getFilter().isEmpty()) { <line12> Filter direction = <line13> field.getFilter().stream() <line14> .filter(filter -> ""direction"".equals(filter.getName())) <line15> .findFirst() <line16> .get(); <line17> List<StatGlobalCardinalityResult> bucketsResults = <line18> EsUtil.getGlobalCardinalityHistogramResults( <line19> dataClient, <line20> index, <line21> type, <line22> field.getField(), <line23> direction.getValue(), <line24> ((HistogramManual<?>) hist).getBuckets()); <line25> populateBuckets(statIndexName, statTypeGlobalName, statClient, bucketsResults); <line26> } else if (hist.getDataType() == DataType.numericDouble <line27> || hist.getDataType() == DataType.numericLong) { <line28> List<StatRangeResult<Number>> bucketsResults = <line29> EsUtil.getManualHistogramResults( <line30> dataClient, <line31> index, <line32> type, <line33> field.getField(), <line34> field.getHistogram().getDataType(), <line35> ((HistogramManual<Number>) hist).getBuckets()); <line36> populateBuckets(statIndexName, statTypeNumericName, statClient, bucketsResults); <line37> } else if (hist.getDataType() == DataType.string) { <line38> List<StatRangeResult<Number>> bucketsResults = <line39> EsUtil.getManualHistogramResults( <line40> dataClient, <line41> index, <line42> type, <line43> field.getField(), <line44> field.getHistogram().getDataType(), <line45> ((HistogramManual<Number>) hist).getBuckets()); <line46> populateBuckets(statIndexName, statTypeStringName, statClient, bucketsResults); <line47> } <line48> } <line49> } <line50> } catch (Exception e) { <line51> } <line52> } <line53> } <line54> "	 <line45>	No
public class A { <line0> protected synchronized void notifyLostLock() { <line1> if (!isStarted) { <line2> return; <line3> } <line4> lockListeners.forEach( <line5> lockListener -> { <line6> try { <line7> lockListener.lostLock(); <line8> } catch (Exception e) { <line9> } <line10> }); <line11> } <line12> } <line13> 	 <line5>	No
public class A { <line0> private void writeSerializedPublicKeyLength(SrpClientKeyExchangeMessage msg) { <line1> appendInt(msg.getPublicKeyLength().getValue(), HandshakeByteLength.SRP_PUBLICKEY_LENGTH); <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> private void addAuthorities( <line1> Set<GrantedAuthority> authorities, <line2> final String[] values, <line3> final boolean addAsGroup, <line4> final boolean addPrefix) { <line5> if (values != null) { <line6> Organization org = securityService.getOrganization(); <line7> if (!organization.equals(org)) { <line8> throw new SecurityException( <line9> String.format( <line10> ""Current request belongs to the organization \""%s\"". Expected \""%s\"""", <line11> org.getId(), organization.getId())); <line12> } <line13> for (String value : values) { <line14> String authority = roleCleanUpperCase(value, uppercase); <line15> if (!authority.isEmpty()) { <line16> List<Role> groupRoles; <line17> if (groupRoleProvider != null && addAsGroup) <line18> groupRoles = groupRoleProvider.getRolesForGroup(authority); <line19> else groupRoles = Collections.emptyList(); <line20> String prefix = this.prefix; <line21> if (addPrefix) { <line22> if (!prefix.isEmpty()) { <line23> boolean hasExcludePrefix = false; <line24> for (String excludePrefix : excludedPrefixes) { <line25> if (authority.startsWith(excludePrefix)) { <line26> hasExcludePrefix = true; <line27> break; <line28> } <line29> } <line30> if (hasExcludePrefix) prefix = """"; <line31> } <line32> } else { <line33> prefix = """"; <line34> } <line35> authority = (prefix + authority).replaceAll(ROLE_CLEAN_REGEXP, ROLE_CLEAN_REPLACEMENT); <line36> if (!groupRoles.isEmpty()) { <line37> for (Role role : groupRoles) { <line38> authorities.add(new SimpleGrantedAuthority(role.getName())); <line39> } <line40> } <line41> authorities.add(new SimpleGrantedAuthority(authority)); <line42> } else { <line43> } <line44> } <line45> } <line46> } <line47> } <line48> "	 <line10>	No
public class A { <line0> @Override <line1> public void handleCommand(ChannelUID channelUID, Command command) { <line2> if (channelUID.getIdWithoutGroup().equals(CONTROL_CHANNEL)) { <line3> if (command == UpDownType.UP) { <line4> bridge.getStick().sendCommand(CommandType.UP, Collections.singletonList(channelId)); <line5> } else if (command == UpDownType.DOWN) { <line6> bridge.getStick().sendCommand(CommandType.DOWN, Collections.singletonList(channelId)); <line7> } else if (command == StopMoveType.STOP) { <line8> bridge.getStick().sendCommand(CommandType.STOP, Collections.singletonList(channelId)); <line9> } else if (command instanceof PercentType) { <line10> CommandType cmd = CommandType.getForPercent(((PercentType) command).intValue()); <line11> if (cmd != null) { <line12> bridge.getStick().sendCommand(cmd, Collections.singletonList(channelId)); <line13> } else { <line14> } <line15> } else if (command == RefreshType.REFRESH) { <line16> bridge.getStick().requestUpdate(Collections.singletonList(channelId)); <line17> } <line18> } <line19> } <line20> } <line21> 	 <line2>	Yes
"public class A { <line0> private ICacheElement<K, V> spoolLastElement() throws Error { <line1> ICacheElement<K, V> toSpool = null; <line2> final MemoryElementDescriptor<K, V> last = list.getLast(); <line3> if (last != null) { <line4> toSpool = last.getCacheElement(); <line5> if (toSpool == null) { <line6> throw new Error(""update: last.ce is null!""); <line7> } <line8> getCompositeCache().spoolToDisk(toSpool); <line9> if (map.remove(toSpool.getKey()) == null) { <line10> if (log.isTraceEnabled()) { <line11> verifyCache(); <line12> } <line13> } <line14> list.remove(last); <line15> } <line16> return toSpool; <line17> } <line18> } <line19> "	 <line16>	No
public class A { <line0> @Override <line1> public Representation represent(final Variant variant) throws ResourceException { <line2> List<Recommendation> recommendations; <line3> if (maxResults > 0) { <line4> recommendations = <line5> getRecommendationMapper().findBySubjectOpenSocialId(openSocialId, maxResults); <line6> } else { <line7> recommendations = getRecommendationMapper().findBySubjectOpenSocialId(openSocialId); <line8> } <line9> JSONObject json = new JSONObject(); <line10> JSONArray recos = new JSONArray(); <line11> if (null != recommendations && recommendations.size() > 0) { <line12> Map<String, Person> people = getPeopleInfoForRecommendations(recommendations); <line13> for (Recommendation reco : recommendations) { <line14> recos.add( <line15> convertRecoToJSON( <line16> reco, <line17> people.get(reco.getAuthorOpenSocialId()), <line18> people.get(reco.getSubjectOpenSocialId()))); <line19> } <line20> } <line21> json.put(RECOMMENDATIONS_KEY, recos); <line22> Representation rep = new StringRepresentation(json.toString(), MediaType.APPLICATION_JSON); <line23> rep.setExpirationDate(new Date(0L)); <line24> return rep; <line25> } <line26> } <line27> 	 <line9>	Yes
"public class A { <line0> private void deleteItem(String version, Connection conn) { <line1> PreparedStatement stat = null; <line2> try { <line3> stat = conn.prepareStatement(DELETE_ITEM); <line4> stat.setString(1, InitializerManager.REPORT_CONFIG_ITEM); <line5> stat.setString(2, version); <line6> stat.executeUpdate(); <line7> } catch (Throwable t) { <line8> throw new RuntimeException(""Error deleting item"", t); <line9> } finally { <line10> closeDaoResources(null, stat); <line11> } <line12> } <line13> } <line14> "	 <line8>	Yes
"public class A { <line0> public Option<Request> apply(Tuple2<Session<Delivery>, Delivery> event) { <line1> queue.assertExecuting(); <line2> Session<Delivery> session = event._1(); <line3> final Delivery delivery = event._2(); <line4> session_manager.delivered(session, delivery.size()); <line5> SimpleAddress topic = delivery.sender().head().simple(); <line6> QoS qos = addresses.get(topic); <line7> if (qos == null) { <line8> qos = Scala2Java.<QoS>head(wildcards.get(topic.path())); <line9> } <line10> if (qos == null) { <line11> acked(delivery, Consumed$.MODULE$); <line12> return Scala2Java.none(); <line13> } else { <line14> PUBLISH publish = new PUBLISH(); <line15> publish.topicName( <line16> new UTF8Buffer(destination_parser.encode_destination(delivery.sender().head()))); <line17> if (delivery.redeliveries() > 0) { <line18> publish.dup(true); <line19> } <line20> if (delivery.message().codec() == RawMessageCodec$.MODULE$) { <line21> publish.payload(((RawMessage) delivery.message()).payload()); <line22> } else { <line23> if (publish_body) { <line24> try { <line25> publish.payload(delivery.message().getBodyAs(Buffer.class)); <line26> } catch (FilterException e) { <line27> } <line28> } else { <line29> publish.payload(delivery.message().encoded()); <line30> } <line31> } <line32> handler.messages_sent.incrementAndGet(); <line33> UnitFn1<DeliveryResult> ack = <line34> new UnitFn1<DeliveryResult>() { <line35> @Override <line36> public void call(DeliveryResult result) { <line37> acked(delivery, result); <line38> } <line39> }; <line40> if (delivery.ack() != null && (qos != QoS.AT_MOST_ONCE)) { <line41> publish.qos(qos); <line42> short id = to_message_id(clean_session ? get_next_seq_id() : delivery.seq()); <line43> publish.messageId(id); <line44> Request request = new Request(id, publish, ack); <line45> Request prev = in_flight_publishes.put(id, request); <line46> if (prev != null) { <line47> if (prev.message == null) { <line48> in_flight_publishes.remove(id); <line49> acked(delivery, Consumed$.MODULE$); <line50> } else { <line51> handler.async_die(""Client not acking regularly."", null); <line52> } <line53> } <line54> return Scala2Java.some(request); <line55> } else { <line56> publish.qos(QoS.AT_MOST_ONCE); <line57> return Scala2Java.some(new Request((short) 0, publish, ack)); <line58> } <line59> } <line60> } <line61> } <line62> "	 <line24>	No
public class A { <line0> public long revert(long revision) throws LdapException { <line1> if (changeLog == null || !changeLog.isEnabled()) { <line2> throw new IllegalStateException(I18n.err(I18n.ERR_310)); <line3> } <line4> if (revision < 0) { <line5> throw new IllegalArgumentException(I18n.err(I18n.ERR_239)); <line6> } <line7> if (revision >= changeLog.getChangeLogStore().getCurrentRevision()) { <line8> throw new IllegalArgumentException(I18n.err(I18n.ERR_314)); <line9> } <line10> Cursor<ChangeLogEvent> cursor = changeLog.getChangeLogStore().findAfter(revision); <line11> PartitionTxn transaction = systemPartition.beginWriteTransaction(); <line12> adminSession.addTransaction(systemPartition, transaction); <line13> adminSession.beginSessionTransaction(); <line14> try { <line15> cursor.afterLast(); <line16> while (cursor.previous()) { <line17> ChangeLogEvent event = cursor.get(); <line18> List<LdifEntry> reverses = event.getReverseLdifs(); <line19> for (LdifEntry reverse : reverses) { <line20> switch (reverse.getChangeType().getChangeType()) { <line21> case ChangeType.ADD_ORDINAL: <line22> adminSession.add(new DefaultEntry(schemaManager, reverse.getEntry()), true); <line23> break; <line24> case ChangeType.DELETE_ORDINAL: <line25> adminSession.delete(reverse.getDn(), true); <line26> break; <line27> case ChangeType.MODIFY_ORDINAL: <line28> List<Modification> mods = reverse.getModifications(); <line29> adminSession.modify(reverse.getDn(), mods, true); <line30> break; <line31> case ChangeType.MODDN_ORDINAL: <line32> case ChangeType.MODRDN_ORDINAL: <line33> Dn forwardDn = event.getForwardLdif().getDn(); <line34> Dn reverseDn = reverse.getDn(); <line35> moddn(reverseDn, forwardDn, reverse.isDeleteOldRdn()); <line36> break; <line37> default: <line38> throw new NotImplementedException(I18n.err(I18n.ERR_76, reverse.getChangeType())); <line39> } <line40> } <line41> adminSession.endSessionTransaction(true); <line42> } <line43> } catch (Exception e) { <line44> try { <line45> adminSession.endSessionTransaction(false); <line46> } catch (IOException ioe) { <line47> throw new LdapOperationException(ioe.getMessage(), ioe); <line48> } <line49> throw new LdapOperationException(e.getMessage(), e); <line50> } finally { <line51> try { <line52> cursor.close(); <line53> } catch (Exception e) { <line54> throw new LdapOperationException(e.getMessage(), e); <line55> } <line56> } <line57> return changeLog.getCurrentRevision(); <line58> } <line59> } <line60> 	 <line19>	No
public class A { <line0> @Override <line1> protected void decode(ChannelHandlerContext ctx, DatagramPacket msg, List<Object> out) { <line2> MessageConsumer consumer = UdpConnectionMap.getMessageConsumer(msg.sender()); <line3> if (consumer == null) { <line4> ConnectionFacade connectionFacade = <line5> adapterFactory.createConnectionFacade( <line6> ctx.channel(), msg.sender(), false, channelOutboundQueueSize); <line7> connectionHandler.onSwitchConnected(connectionFacade); <line8> connectionFacade.checkListeners(); <line9> UdpConnectionMap.addConnection(msg.sender(), connectionFacade); <line10> } <line11> ByteBuf bb = msg.content(); <line12> int readableBytes = bb.readableBytes(); <line13> if (readableBytes < LENGTH_OF_HEADER) { <line14> if (LOG.isDebugEnabled()) { <line15> } <line16> return; <line17> } <line18> int length = bb.getUnsignedShort(bb.readerIndex() + LENGTH_INDEX_IN_HEADER); <line19> if (readableBytes < length) { <line20> if (LOG.isDebugEnabled()) { <line21> } <line22> return; <line23> } <line24> byte version = bb.readByte(); <line25> if (version == EncodeConstants.OF13_VERSION_ID || version == EncodeConstants.OF10_VERSION_ID) { <line26> ByteBuf messageBuffer = bb.slice(); <line27> out.add(new VersionMessageUdpWrapper(version, messageBuffer, msg.sender())); <line28> messageBuffer.retain(); <line29> } else { <line30> } <line31> bb.skipBytes(bb.readableBytes()); <line32> } <line33> } <line34> 	 <line21>	Yes
"public class A { <line0> public static void cleanEnvSnapshot(String envName) { <line1> File tmp = new File(LOCAL_SNAPSHOT_PATH, envName + ""_nacos""); <line2> tmp = new File(tmp, ""snapshot""); <line3> try { <line4> IoUtils.cleanDirectory(tmp); <line5> } catch (IOException e) { <line6> e.printStackTrace(); <line7> } <line8> } <line9> } <line10> "	 <line6>	Yes
public class A { <line0> private void refresh() { <line1> List<MigrationEvent> events = Lists.newArrayList(currentWorkingEvents.values()); <line2> for (MigrationEvent migrationEvent : events) { <line3> if (migrationEvent.isDone()) { <line4> continue; <line5> } <line6> try { <line7> MigrationEvent other = <line8> migrationEventDao.buildMigrationEvent(migrationEvent.getMigrationEventId()); <line9> if (other.isDone()) { <line10> currentWorkingEvents.put(other.getMigrationEventId(), other); <line11> } else if (diff(migrationEvent, other)) { <line12> currentWorkingEvents.put(other.getMigrationEventId(), other); <line13> } <line14> } catch (Exception e) { <line15> } <line16> } <line17> } <line18> } <line19> 	 <line11>	No
public class A { <line0> private boolean isDuplicatedSlot( <line1> TaskSlot taskSlot, JobID jobId, ResourceProfile resourceProfile, int index) { <line2> return taskSlot.getJobId().equals(jobId) <line3> && taskSlot.getResourceProfile().equals(resourceProfile) <line4> && (isDynamicIndex(index) || taskSlot.getIndex() == index); <line5> } <line6> } <line7> 	 <line2>	Yes
public class A { <line0> @Deprecated <line1> private RegisteredType getCatalogItemForType(String typeName) { <line2> final RegisteredType resultI; <line3> if (CatalogUtils.looksLikeVersionedId(typeName)) { <line4> resultI = mgmt.getTypeRegistry().get(typeName); <line5> } else { <line6> Iterable<CatalogItem<Object, Object>> resultL = <line7> mgmt.getCatalog() <line8> .getCatalogItems(CatalogPredicates.javaType(Predicates.equalTo(typeName))); <line9> if (!Iterables.isEmpty(resultL)) { <line10> resultI = RegisteredTypes.of(sortVersionsDesc(resultL).iterator().next()); <line11> if (log.isDebugEnabled() && Iterables.size(resultL) > 1) { <line12> } <line13> } else { <line14> resultI = mgmt.getTypeRegistry().get(typeName, BrooklynCatalog.DEFAULT_VERSION); <line15> if (resultI != null) { <line16> if (resultI.getSuperTypes().isEmpty()) { <line17> return null; <line18> } <line19> } <line20> } <line21> } <line22> return resultI; <line23> } <line24> } <line25> 	 <line17>	Yes
"public class A { <line0> @Override <line1> public IUS getIUS(int swAccession) { <line2> try { <line3> return ll.findIUS(""/"" + swAccession); <line4> } catch (IOException | JAXBException ex) { <line5> } <line6> return null; <line7> } <line8> } <line9> "	 <line7>	No
"public class A { <line0> @Test <line1> public void testAppend() throws Exception { <line2> context.addRoutes( <line3> new RouteBuilder() { <line4> @Override <line5> public void configure() throws Exception { <line6> from(""direct:start1"") <line7> .toF( <line8> ""hdfs://%s:%d/tmp/test/test-camel-simple-write-file1?append=true&fileSystemType=HDFS"", <line9> service.getHDFSHost(), service.getPort()); <line10> } <line11> }); <line12> startCamelContext(); <line13> for (int i = 0; i < 10; ++i) { <line14> template.sendBody(""direct:start1"", ""PIPPQ""); <line15> } <line16> Configuration conf = new Configuration(); <line17> String path = <line18> String.format( <line19> ""hdfs://%s:%d/tmp/test/test-camel-simple-write-file1"", <line20> service.getHDFSHost(), service.getPort()); <line21> Path file = new Path(path); <line22> FileSystem fs = FileSystem.get(file.toUri(), conf); <line23> FSDataInputStream in = fs.open(file); <line24> byte[] buffer = new byte[5]; <line25> int ret = 0; <line26> for (int i = 0; i < 20; ++i) { <line27> ret = in.read(buffer); <line28> } <line29> ret = in.read(buffer); <line30> assertEquals(-1, ret); <line31> in.close(); <line32> } <line33> } <line34> "	 <line16>	No
"public class A { <line0> @Override <line1> public void afterPropertiesSet() throws Exception { <line2> Assert.state(repository != null, ""A CrudRepository implementation is required""); <line3> if (this.methodName != null) { <line4> Assert.hasText(this.methodName, ""methodName must not be empty.""); <line5> } else { <line6> } <line7> } <line8> } <line9> "	 <line6>	Yes
public class A { <line0> private void writeResult(ValidationResult result, PrintWriter output) { <line1> ObjectMapper objectMapper = new ObjectMapper(); <line2> objectMapper.enable(SerializationFeature.INDENT_OUTPUT); <line3> try { <line4> String content = objectMapper.writeValueAsString(result); <line5> output.write(content); <line6> } catch (JsonProcessingException e) { <line7> } <line8> } <line9> } <line10> 	 <line4>	No
"public class A { <line0> protected Checksum compute( <line1> final InputStream in, final long offset, final ByteBuffer header, final NonceGenerator nonces) <line2> throws ChecksumException { <line3> if (log.isDebugEnabled()) { <line4> } <line5> try { <line6> final PipedOutputStream source = new PipedOutputStream(); <line7> final CryptoOutputStream<Void> out = <line8> new CryptoOutputStream<Void>( <line9> new VoidStatusOutputStream(source), <line10> cryptomator.getFileContentCryptor(), <line11> cryptomator.getFileHeaderCryptor().decryptHeader(header), <line12> nonces, <line13> cryptomator.numberOfChunks(offset)); <line14> final PipedInputStream sink = <line15> new PipedInputStream(source, PreferencesFactory.get().getInteger(""connection.chunksize"")); <line16> final ThreadPool pool = ThreadPoolFactory.get(""checksum"", 1); <line17> try { <line18> final Future execute = <line19> pool.execute( <line20> new Callable<TransferStatus>() { <line21> @Override <line22> public TransferStatus call() throws Exception { <line23> if (offset == 0) { <line24> source.write(header.array()); <line25> } <line26> final TransferStatus status = new TransferStatus(); <line27> new StreamCopier(status, status).transfer(in, out); <line28> return status; <line29> } <line30> }); <line31> try { <line32> return delegate.compute(sink, new TransferStatus()); <line33> } finally { <line34> try { <line35> execute.get(); <line36> } catch (InterruptedException e) { <line37> throw new ChecksumException( <line38> LocaleFactory.localizedString(""Checksum failure"", ""Error""), e.getMessage(), e); <line39> } catch (ExecutionException e) { <line40> if (e.getCause() instanceof BackgroundException) { <line41> throw (BackgroundException) e.getCause(); <line42> } <line43> throw new DefaultExceptionMappingService().map(e.getCause()); <line44> } <line45> } <line46> } finally { <line47> pool.shutdown(true); <line48> } <line49> } catch (ChecksumException e) { <line50> throw e; <line51> } catch (IOException | BackgroundException e) { <line52> throw new ChecksumException( <line53> LocaleFactory.localizedString(""Checksum failure"", ""Error""), e.getMessage(), e); <line54> } <line55> } <line56> } <line57> "	 <line4>	Yes
"public class A { <line0> private void setState(final BusState newState, final TransportError reason) { <line1> if (state == newState) { <line2> GWT.log(""bus tried to transition to "" + state + "", but it already is""); <line3> return; <line4> } <line5> final List<BusEventType> events = new ArrayList<>(); <line6> switch (state) { <line7> case UNINITIALIZED: <line8> case LOCAL_ONLY: <line9> if (newState == BusState.CONNECTING) { <line10> events.add(BusEventType.ASSOCIATING); <line11> } else if (newState == BusState.CONNECTED) { <line12> events.add(BusEventType.ASSOCIATING); <line13> events.add(BusEventType.ONLINE); <line14> } <line15> break; <line16> case CONNECTION_INTERRUPTED: <line17> if (newState == BusState.CONNECTED) { <line18> } <line19> case CONNECTING: <line20> if (newState == BusState.LOCAL_ONLY) { <line21> events.add(BusEventType.DISASSOCIATING); <line22> } else if (newState == BusState.CONNECTED) { <line23> events.add(BusEventType.ONLINE); <line24> } <line25> break; <line26> case CONNECTED: <line27> if (newState == BusState.CONNECTING || newState == BusState.CONNECTION_INTERRUPTED) { <line28> events.add(BusEventType.OFFLINE); <line29> } else if (newState == BusState.LOCAL_ONLY) { <line30> events.add(BusEventType.OFFLINE); <line31> events.add(BusEventType.DISASSOCIATING); <line32> } <line33> break; <line34> default: <line35> throw new IllegalStateException(""Bus is in unknown state: "" + state); <line36> } <line37> state = newState; <line38> if (newState == BusState.CONNECTION_INTERRUPTED) { <line39> } <line40> if (newState.isShadowDeliverable()) { <line41> sendDeferredToShadow(); <line42> } <line43> for (final BusEventType et : events) { <line44> final BusLifecycleEvent e = new BusLifecycleEvent(this, reason); <line45> for (int i = lifecycleListeners.size() - 1; i >= 0; i--) { <line46> try { <line47> et.deliverTo(lifecycleListeners.get(i), e); <line48> } catch (final Throwable t) { <line49> t.printStackTrace(); <line50> } <line51> } <line52> } <line53> } <line54> } <line55> "	 <line39>	Yes
public class A { <line0> public List<InputSplit> getSplits(Configuration conf, int numSplits) { <line1> int nbTrees = Builder.getNbTrees(conf); <line2> int splitSize = nbTrees / numSplits; <line3> seed = Builder.getRandomSeed(conf); <line4> isSingleSeed = isSingleSeed(conf); <line5> if (rng != null && seed != null) { <line6> } <line7> rng = seed == null || isSingleSeed ? null : RandomUtils.getRandom(seed); <line8> int id = 0; <line9> List<InputSplit> splits = new ArrayList<>(numSplits); <line10> for (int index = 0; index < numSplits - 1; index++) { <line11> splits.add(new InMemInputSplit(id, splitSize, nextSeed())); <line12> id += splitSize; <line13> } <line14> splits.add(new InMemInputSplit(id, nbTrees - id, nextSeed())); <line15> return splits; <line16> } <line17> } <line18> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void onFailure(DiscoveryError error) { <line2> switch (error) { <line3> case NO_ENTRY_FOR_PARTICIPANT: <line4> case NO_ENTRY_FOR_SELECTED_BACKENDS: <line5> if (isArbitrationInTime()) { <line6> restartArbitration(new ApplicationException(error)); <line7> } else { <line8> arbitrationFailed(new ApplicationException(error)); <line9> } <line10> break; <line11> case UNKNOWN_GBID: <line12> case INVALID_GBID: <line13> case INTERNAL_ERROR: <line14> default: <line15> arbitrationFailed(new ApplicationException(error)); <line16> break; <line17> } <line18> } <line19> } <line20> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void snapshotState(FunctionSnapshotContext context) throws Exception { <line2> if (!running) { <line3> } else { <line4> if (LOG.isDebugEnabled()) { <line5> } <line6> sequenceNumsStateForCheckpoint.clear(); <line7> if (fetcher == null) { <line8> if (sequenceNumsToRestore != null) { <line9> for (Map.Entry<StreamShardMetadata.EquivalenceWrapper, SequenceNumber> entry : <line10> sequenceNumsToRestore.entrySet()) { <line11> int hashCode = <line12> shardAssigner.assign( <line13> KinesisDataFetcher.convertToStreamShardHandle( <line14> entry.getKey().getShardMetadata()), <line15> getRuntimeContext().getNumberOfParallelSubtasks()); <line16> if (KinesisDataFetcher.isThisSubtaskShouldSubscribeTo( <line17> hashCode, <line18> getRuntimeContext().getNumberOfParallelSubtasks(), <line19> getRuntimeContext().getIndexOfThisSubtask())) { <line20> sequenceNumsStateForCheckpoint.add( <line21> Tuple2.of(entry.getKey().getShardMetadata(), entry.getValue())); <line22> } <line23> } <line24> } <line25> } else { <line26> HashMap<StreamShardMetadata, SequenceNumber> lastStateSnapshot = fetcher.snapshotState(); <line27> if (LOG.isDebugEnabled()) { <line28> } <line29> for (Map.Entry<StreamShardMetadata, SequenceNumber> entry : lastStateSnapshot.entrySet()) { <line30> sequenceNumsStateForCheckpoint.add(Tuple2.of(entry.getKey(), entry.getValue())); <line31> } <line32> } <line33> } <line34> } <line35> } <line36> 	 <line3>	Yes
public class A { <line0> @Override <line1> public MDRRuleGroupInstance findByPrimaryKey(Serializable primaryKey) <line2> throws NoSuchRuleGroupInstanceException { <line3> MDRRuleGroupInstance mdrRuleGroupInstance = fetchByPrimaryKey(primaryKey); <line4> if (mdrRuleGroupInstance == null) { <line5> if (_log.isDebugEnabled()) { <line6> } <line7> throw new NoSuchRuleGroupInstanceException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line8> } <line9> return mdrRuleGroupInstance; <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> private void updateRouterNetworkRef(Connection conn) { <line1> PreparedStatement pstmt = null; <line2> ResultSet rs = null; <line3> try { <line4> pstmt = <line5> conn.prepareStatement( <line6> ""SELECT d.id, d.network_id FROM `cloud`.`domain_router` d, `cloud`.`vm_instance` v "" <line7> + ""WHERE d.id=v.id AND v.removed is NULL""); <line8> rs = pstmt.executeQuery(); <line9> while (rs.next()) { <line10> Long routerId = rs.getLong(1); <line11> Long networkId = rs.getLong(2); <line12> pstmt = conn.prepareStatement(""SELECT guest_type from `cloud`.`networks` where id=?""); <line13> pstmt.setLong(1, networkId); <line14> ResultSet rs1 = pstmt.executeQuery(); <line15> rs1.next(); <line16> String networkType = rs1.getString(1); <line17> pstmt = <line18> conn.prepareStatement( <line19> ""INSERT INTO `cloud`.`router_network_ref` (router_id, network_id, guest_type) "" <line20> + ""VALUES (?, ?, ?)""); <line21> pstmt.setLong(1, routerId); <line22> pstmt.setLong(2, networkId); <line23> pstmt.setString(3, networkType); <line24> pstmt.executeUpdate(); <line25> } <line26> } catch (SQLException e) { <line27> throw new CloudRuntimeException(""Failed to update the router/network reference "", e); <line28> } finally { <line29> closeAutoCloseable(rs); <line30> closeAutoCloseable(pstmt); <line31> } <line32> } <line33> } <line34> "	 <line1>	Yes
"public class A { <line0> @Override <line1> protected void parse(final ProtocolFactory protocols, final Local file) <line2> throws AccessDeniedException { <line3> final NSDictionary serialized = NSDictionary.dictionaryWithContentsOfFile(file.getAbsolute()); <line4> if (null == serialized) { <line5> throw new LocalAccessDeniedException(String.format(""Invalid bookmark file %s"", file)); <line6> } <line7> final List<NSDictionary> array = <line8> new PlistDeserializer(serialized).listForKey(""CustomPluginSettings""); <line9> if (null == array) { <line10> return; <line11> } <line12> for (NSDictionary dict : array) { <line13> final PlistDeserializer bookmark = new PlistDeserializer(dict); <line14> final String identifier = bookmark.stringForKey(""MountFSClassName""); <line15> if (StringUtils.isBlank(identifier)) { <line16> continue; <line17> } <line18> final Protocol protocol; <line19> switch (identifier) { <line20> case ""FtpConnection"": <line21> protocol = protocols.forType(Protocol.Type.ftp); <line22> break; <line23> case ""WebDAVConnection"": <line24> protocol = protocols.forType(Protocol.Type.dav); <line25> break; <line26> case ""OpenStackConnection"": <line27> protocol = protocols.forType(Protocol.Type.swift); <line28> break; <line29> case ""BBConnection"": <line30> protocol = protocols.forType(Protocol.Type.b2); <line31> break; <line32> case ""S3Connection"": <line33> protocol = protocols.forType(Protocol.Type.s3); <line34> break; <line35> case ""DropboxConnection"": <line36> protocol = protocols.forType(Protocol.Type.dropbox); <line37> break; <line38> case ""GDriveConnection"": <line39> protocol = protocols.forType(Protocol.Type.googledrive); <line40> break; <line41> default: <line42> protocol = null; <line43> break; <line44> } <line45> if (null == protocol) { <line46> continue; <line47> } <line48> final NSDictionary details = bookmark.objectForKey(""MountFSOptions""); <line49> if (null == details) { <line50> continue; <line51> } <line52> final PlistDeserializer options = new PlistDeserializer(details); <line53> final String hostname = options.stringForKey(""host""); <line54> if (StringUtils.isBlank(hostname)) { <line55> continue; <line56> } <line57> final Host host = <line58> new Host(protocol, hostname, new Credentials(options.stringForKey(""login""))); <line59> host.setNickname(bookmark.stringForKey(""MountFSLabel"")); <line60> host.setDefaultPath(options.stringForKey(""remotePath"")); <line61> this.add(host); <line62> } <line63> } <line64> } <line65> "	 <line52>	No
public class A { <line0> private void refreshMemoryPools() { <line1> boolean reInitPools = false; <line2> Iterator<Map.Entry<MemoryPoolMXBean, Statistics>> it = mpMap.entrySet().iterator(); <line3> while (it.hasNext()) { <line4> Map.Entry<MemoryPoolMXBean, Statistics> me = it.next(); <line5> MemoryPoolMXBean mp = me.getKey(); <line6> Statistics s = me.getValue(); <line7> if (!mp.isValid()) { <line8> s.close(); <line9> it.remove(); <line10> reInitPools = true; <line11> } else { <line12> MemoryUsage mu = null; <line13> try { <line14> mu = mp.getUsage(); <line15> } catch (IllegalArgumentException ex) { <line16> continue; <line17> } catch (InternalError ie) { <line18> s.close(); <line19> it.remove(); <line20> reInitPools = true; <line21> continue; <line22> } <line23> s.setLong(mp_l_initMemoryId, mu.getInit()); <line24> s.setLong(mp_l_usedMemoryId, mu.getUsed()); <line25> s.setLong(mp_l_committedMemoryId, mu.getCommitted()); <line26> s.setLong(mp_l_maxMemoryId, mu.getMax()); <line27> if (mp.isUsageThresholdSupported()) { <line28> s.setLong(mp_usageThresholdId, mp.getUsageThreshold()); <line29> s.setLong(mp_usageExceededId, mp.getUsageThresholdCount()); <line30> } <line31> mu = null; <line32> if (!this.isCollectionUsageUnsupported(mp)) { <line33> try { <line34> mu = mp.getCollectionUsage(); <line35> } catch (UnsupportedOperationException ex) { <line36> this.setCollectionUsageUnsupported(mp); <line37> } catch (IllegalArgumentException ex) { <line38> this.setCollectionUsageUnsupported(mp); <line39> } <line40> } <line41> if (mu != null) { <line42> s.setLong(mp_gc_usedMemoryId, mu.getUsed()); <line43> if (mp.isCollectionUsageThresholdSupported()) { <line44> s.setLong(mp_collectionUsageThresholdId, mp.getCollectionUsageThreshold()); <line45> s.setLong(mp_collectionUsageExceededId, mp.getCollectionUsageThresholdCount()); <line46> } <line47> } <line48> } <line49> } <line50> if (reInitPools) { <line51> initMemoryPools(); <line52> } <line53> } <line54> } <line55> 	 <line21>	Yes
public class A { <line0> @Override <line1> public void remove(PartitionWriteTxn transaction, K key, V value) throws LdapException { <line2> try { <line3> if (key == null) { <line4> return; <line5> } <line6> org.apache.directory.mavibot.btree.Tuple<K, V> tuple = <line7> bt.delete(((MavibotWriteTxn) transaction).getWriteTransaction(), key, value); <line8> if (tuple != null) { <line9> count--; <line10> } <line11> } catch (IOException ioe) { <line12> throw new LdapOtherException(ioe.getMessage(), ioe); <line13> } <line14> } <line15> } <line16> 	 <line10>	No
public class A { <line0> @Override <line1> public PooledDataSourceFactory getDataSourceFactory(DPCAttributionConfiguration configuration) { <line2> return configuration.getDatabase(); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> @Override <line1> public void handleDelivery( <line2> String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) <line3> throws IOException { <line4> receivedHeaders.putAll(properties.getHeaders()); <line5> received.add(new String(body)); <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> protected void onEvent(String path, Trigger c) { <line1> eventCallbacks.put( <line2> path, <line3> new EventCallback() { <line4> @Override <line5> @AsyncThread <line6> protected void run(Map tokens, Object data) { <line7> GarbageCollectorVO vo = dbf.findByUuid(uuid, GarbageCollectorVO.class); <line8> if (vo == null) { <line9> cancel(); <line10> return; <line11> } <line12> if (!c.trigger(tokens, data)) { <line13> return; <line14> } <line15> if (!lock()) { <line16> return; <line17> } <line18> vo.setStatus(GCStatus.Processing); <line19> dbf.update(vo); <line20> runTrigger(); <line21> } <line22> }); <line23> } <line24> } <line25> 	 <line18>	Yes
public class A { <line0> public Map<String, String> buildReadableResult() { <line1> if (crs.size() == 0) { <line2> return Collections.emptyMap(); <line3> } <line4> Map<String, String> map = new LinkedHashMap<>(); <line5> for (ConditionResult cr : crs) { <line6> NotifyStrategy.Condition cond = cr.getCond(); <line7> if (StringHelper.isEmpty(cond.getRelation())) { <line8> boolean fire = false; <line9> for (boolean b : cr.getCondResult()) { <line10> fire = fire || b; <line11> } <line12> if (fire && cr.isJudgeTime()) { <line13> map.put(String.valueOf(cond.getIndex()), toReadable(cr.getExprResult(), null)); <line14> } <line15> } else { <line16> String script = generateJsExpression(cond.getRelation(), cr.getCondResult()); <line17> Object result = JsHelper.eval(script); <line18> if (result == null) { <line19> if (log.isTraceEnable()) { <line20> } <line21> continue; <line22> } <line23> if (Boolean.parseBoolean(result.toString()) && cr.isJudgeTime()) { <line24> map.put( <line25> String.valueOf(cond.getIndex()), toReadable(cr.getExprResult(), cond.getRelation())); <line26> } <line27> } <line28> } <line29> if (log.isDebugEnable()) { <line30> } <line31> return map; <line32> } <line33> } <line34> 	 <line30>	Yes
"public class A { <line0> @Override <line1> public void onWebSocketText(String message) { <line2> final String resultMessage; <line3> if (message.startsWith(""add-servlet"")) { <line4> final String path = message.split("":"")[1].trim(); <line5> servletHandler.addServletWithMapping(servletHolder, path); <line6> resultMessage = ""Deployed new servlet under: "" + path; <line7> } else { <line8> resultMessage = ""Got message: "" + message; <line9> } <line10> try { <line11> getSession().getRemote().sendString(resultMessage); <line12> } catch (IOException e) { <line13> } <line14> } <line15> } <line16> "	 <line14>	No
"public class A { <line0> private Map<LightMeasurementDevice, FcModelNode> processReportedDataForLightMeasurementDevices( <line1> final List<FcModelNode> dataSetMembers) { <line2> final Map<LightMeasurementDevice, FcModelNode> result = new HashMap<>(); <line3> final List<LightMeasurementDevice> lmds = <line4> this.deviceManagementService.findRealLightMeasurementDevices(); <line5> for (final LightMeasurementDevice lmd : lmds) { <line6> final String nodeName = <line7> LogicalNode.getSpggioByIndex(lmd.getDigitalInput()).getDescription().concat("".""); <line8> for (final FcModelNode member : dataSetMembers) { <line9> if (member.getReference().toString().contains(nodeName)) { <line10> result.put(lmd, member); <line11> } <line12> } <line13> } <line14> return result; <line15> } <line16> } <line17> "	 <line0>	No
public class A { <line0> @Transactional <line1> public void updateUserInfo( <line2> int userId, String name, String surname, int age, String userName, String password) { <line3> User user = this.entityManager.find(User.class, userId); <line4> user.setName(name); <line5> user.setSurname(surname); <line6> user.setAge(age); <line7> user.setUserName(userName); <line8> user.setPassword(password); <line9> } <line10> } <line11> 	 <line3>	Yes
"public class A { <line0> @Test <line1> @Retry(3) <line2> public void testCreatePipelineFull() throws IOException { <line3> byte[] content = ""stage('build') { echo 'yes' }"".getBytes(""UTF-8""); <line4> GHContentUpdateResponse updateResponse = <line5> helper.getGithubRepository().createContent(content, ""Jenkinsfile"", ""Jenkinsfile"", ""main""); <line6> helper <line7> .getGithubRepository() <line8> .createRef(""refs/heads/branch1"", updateResponse.getCommit().getSHA1()); <line9> helper.getGithubRepository().createContent(""hi there"", ""newfile"", ""newfile"", ""branch1""); <line10> creationPage.createPipeline( <line11> helper.getAccessToken(), <line12> helper.getOrganizationOrUsername(), <line13> helper.getActualRepositoryName()); <line14> } <line15> } <line16> "	 <line12>	No
"public class A { <line0> @Test <line1> public void findDuplicateVariables() throws IOException { <line2> Map<String, List<Variable>> variablesById = new LinkedHashMap<>(); <line3> for (SupportedCodebook supportedCodebook : SupportedCodebook.values()) { <line4> Codebook codebook = PdfParser.parseCodebookPdf(supportedCodebook); <line5> for (Variable variable : codebook.getVariables()) { <line6> if (!variablesById.containsKey(variable.getId())) <line7> variablesById.put(variable.getId(), new ArrayList<>()); <line8> variablesById.get(variable.getId()).add(variable); <line9> } <line10> } <line11> List<String> duplicatedVariableIds = new ArrayList<>(); <line12> for (String variableId : variablesById.keySet()) { <line13> List<Variable> variables = variablesById.get(variableId); <line14> if (variables.size() > 1) duplicatedVariableIds.add(variableId); <line15> } <line16> for (String duplicatedVariableId : duplicatedVariableIds) { <line17> List<Variable> duplicatedVariables = variablesById.get(duplicatedVariableId); <line18> } <line19> Assert.assertTrue(duplicatedVariableIds.contains(""BENE_ID"")); <line20> Assert.assertTrue(duplicatedVariableIds.contains(""DOB_DT"")); <line21> Assert.assertTrue(duplicatedVariableIds.contains(""GNDR_CD"")); <line22> Assert.assertEquals(87, duplicatedVariableIds.size()); <line23> } <line24> } <line25> "	 <line18>	Yes
public class A { <line0> @Test <line1> public final void testIllegalArgument() { <line2> try { <line3> new GUIDImpl(WRONG_ARK1); <line4> fail(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION); <line5> } catch (final InvalidGuidOperationException e) { <line6> LOGGER.debug(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION, e); <line7> } <line8> try { <line9> new GUIDImpl(WRONG_ARK2); <line10> fail(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION); <line11> } catch (final InvalidGuidOperationException e) { <line12> LOGGER.debug(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION, e); <line13> } <line14> try { <line15> new GUIDImpl(WRONG_ARK3); <line16> fail(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION); <line17> } catch (final InvalidGuidOperationException e) { <line18> LOGGER.debug(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION, e); <line19> } <line20> final byte[] bytes = StringUtils.getBytesFromArraysToString(WRONG_BYTES); <line21> try { <line22> new GUIDImpl(bytes); <line23> fail(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION); <line24> } catch (final InvalidGuidOperationException e) { <line25> LOGGER.debug(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION, e); <line26> } <line27> try { <line28> new GUIDImpl(WRONG_STRING_ID); <line29> fail(ResourcesPublicUtilTest.SHOULD_HAVE_AN_EXCEPTION); <line30> } catch (final InvalidGuidOperationException e) { <line31> } <line32> GUIDImpl guid = null; <line33> GUIDImpl guid2 = null; <line34> try { <line35> guid = new GUIDImpl(properties.getProperty(FIELDS.BASE32.name())); <line36> guid2 = new GUIDImpl(properties.getProperty(FIELDS.BASE16.name())); <line37> } catch (final InvalidGuidOperationException e) { <line38> fail(ResourcesPublicUtilTest.SHOULD_NOT_HAVE_AN_EXCEPTION); <line39> return; <line40> } <line41> assertFalse(guid.equals(null)); <line42> assertFalse(guid.equals(new Object())); <line43> assertTrue(guid.equals(guid)); <line44> assertTrue(guid.equals(guid2)); <line45> } <line46> } <line47> 	 <line31>	Yes
"public class A { <line0> private PushErrorResponse _exec() { <line1> try { <line2> clientRequest.setHttpMethod(getHttpMethod()); <line3> clientRequest.header(""Content-Type"", getRequest().getContentType()); <line4> if (StringUtils.isNotBlank(getRequest().getClientNotificationToken())) { <line5> clientRequest.header( <line6> ""Authorization"", ""Bearer "" + getRequest().getClientNotificationToken()); <line7> } <line8> JSONObject requestBody = getRequest().getJSONParameters(); <line9> clientRequest.body(MediaType.APPLICATION_JSON, requestBody.toString(4)); <line10> clientResponse = clientRequest.post(String.class); <line11> setResponse(new PushErrorResponse(clientResponse)); <line12> } catch (Exception e) { <line13> } finally { <line14> closeConnection(); <line15> } <line16> return getResponse(); <line17> } <line18> } <line19> "	 <line13>	Yes
"public class A { <line0> @SuppressWarnings(""ConstantConditions"") <line1> private void scheduleRenewal(Reactor reactor) { <line2> int sasTokenRenewalPeriod = <line3> this.amqpsSessionHandler <line4> .getDeviceClientConfig() <line5> .getSasTokenAuthentication() <line6> .getMillisecondsBeforeProactiveRenewal(); <line7> reactor.schedule(sasTokenRenewalPeriod, this); <line8> } <line9> } <line10> "	 <line5>	No
"public class A { <line0> public PortletRequestDispatcher getRequestDispatcher( <line1> ServletContext servletContext, PortletApplicationDefinition app, String path) { <line2> if (LOG.isDebugEnabled()) { <line3> } <line4> if (path == null || !path.startsWith(""/"")) { <line5> if (LOG.isInfoEnabled()) { <line6> } <line7> return null; <line8> } <line9> PortletRequestDispatcher portletRequestDispatcher = null; <line10> try { <line11> RequestDispatcher servletRequestDispatcher = servletContext.getRequestDispatcher(path); <line12> if (servletRequestDispatcher != null) { <line13> portletRequestDispatcher = <line14> new PortletRequestDispatcherImpl(servletRequestDispatcher, path, false); <line15> } else { <line16> if (LOG.isInfoEnabled()) { <line17> } <line18> } <line19> } catch (Exception ex) { <line20> if (LOG.isInfoEnabled()) { <line21> } <line22> portletRequestDispatcher = null; <line23> } <line24> return portletRequestDispatcher; <line25> } <line26> } <line27> "	 <line6>	Yes
"public class A { <line0> @SuppressWarnings({""unchecked""}) <line1> public void before(Method method, Object[] args, Object target) throws Throwable { <line2> if (log.isDebugEnabled()) { <line3> } <line4> if (log.isDebugEnabled()) { <line5> User user = Context.getAuthenticatedUser(); <line6> if (user != null) { <line7> } <line8> } <line9> AuthorizedAnnotationAttributes attributes = new AuthorizedAnnotationAttributes(); <line10> Collection<String> privileges = attributes.getAttributes(method); <line11> boolean requireAll = attributes.getRequireAll(method); <line12> if (!privileges.isEmpty()) { <line13> for (String privilege : privileges) { <line14> if (privilege == null || privilege.isEmpty()) { <line15> return; <line16> } <line17> if (log.isDebugEnabled()) { <line18> } <line19> if (Context.hasPrivilege(privilege)) { <line20> if (!requireAll) { <line21> return; <line22> } <line23> } else { <line24> if (requireAll) { <line25> throwUnauthorized(Context.getAuthenticatedUser(), method, privilege); <line26> } <line27> } <line28> } <line29> if (!requireAll) { <line30> throwUnauthorized(Context.getAuthenticatedUser(), method, privileges); <line31> } <line32> } else if (attributes.hasAuthorizedAnnotation(method) && !Context.isAuthenticated()) { <line33> throwUnauthorized(Context.getAuthenticatedUser(), method); <line34> } <line35> } <line36> } <line37> "	 <line34>	No
public class A { <line0> private synchronized boolean yield() { <line1> if (taskQueue.isEmpty()) { <line2> cleanUp(); <line3> } else { <line4> try { <line5> executor.execute(this); <line6> if (logger.isDebugEnabled()) { <line7> } <line8> } catch (RejectedExecutionException e) { <line9> return false; <line10> } <line11> } <line12> return true; <line13> } <line14> } <line15> 	 <line7>	Yes
"public class A { <line0> @Override <line1> @ActionEvent( <line2> eventType = EventTypes.EVENT_EXTERNAL_SWITCH_MGMT_DEVICE_DELETE, <line3> eventDescription = ""deleting VSM"", <line4> async = true) <line5> public boolean deleteCiscoNexusVSM(DeleteCiscoNexusVSMCmd cmd) { <line6> boolean result; <line7> try { <line8> result = deleteCiscoNexusVSM(cmd.getCiscoNexusVSMDeviceId()); <line9> } catch (ResourceInUseException e) { <line10> throw new CloudRuntimeException(""Failed to delete specified VSM""); <line11> } <line12> return result; <line13> } <line14> } <line15> "	 <line10>	Yes
"public class A { <line0> @Override <line1> public void addUserGroupAsGroupAdmin(final UserGroup userGroup) <line2> throws DuplicateDataException, JargonException { <line3> if (userGroup == null) { <line4> throw new IllegalArgumentException(""null userGroup""); <line5> } <line6> if (userGroup.getUserGroupName() == null || userGroup.getUserGroupName().isEmpty()) { <line7> throw new IllegalArgumentException(""userGroup has no userGroupName""); <line8> } <line9> if (userGroup.getZone() == null || userGroup.getZone().isEmpty()) { <line10> throw new IllegalArgumentException(""userGroup has no zone""); <line11> } <line12> if (!userGroup.getZone().equals(this.getIRODSAccount().getZone())) { <line13> throw new JargonException(""cannot create a cross-zone group""); <line14> } <line15> try { <line16> UserAdminInp adminPI = UserAdminInp.instanceForAddUserGroup(userGroup); <line17> getIRODSProtocol().irodsFunction(adminPI); <line18> } catch (NoMoreRulesException nmr) { <line19> throw new DuplicateDataException( <line20> ""no more rules exception interpreted as duplicate user"", nmr); <line21> } <line22> } <line23> } <line24> "	 <line10>	No
public class A { <line0> private void wait(Thread thread) { <line1> long t0 = SystemClock.now(); <line2> long timeout = 1000L; <line3> while (SystemClock.now() - t0 < timeout && thread.isAlive()) { <line4> try { <line5> Thread.sleep(10); <line6> } catch (InterruptedException ignored) { <line7> } <line8> } <line9> } <line10> } <line11> 	 <line1>	Yes
public class A { <line0> protected void executeSilently(String sql) { <line1> try { <line2> jdbcTemplate.execute(sql); <line3> } catch (BadSqlGrammarException ex) { <line4> } <line5> } <line6> } <line7> 	 <line3>	No
public class A { <line0> public void initTaskanaProperties(String propertiesFile, String separator) { <line1> if (LOGGER.isDebugEnabled()) { <line2> } <line3> Properties props = readPropertiesFromFile(propertiesFile); <line4> initTaskanaRoles(props, separator); <line5> initJobParameters(props); <line6> initDomains(props); <line7> initClassificationTypes(props); <line8> initClassificationCategories(props); <line9> initBooleanProperty( <line10> props, TASKANA_GERMAN_HOLIDAYS_ENABLED, this::setGermanPublicHolidaysEnabled); <line11> initBooleanProperty( <line12> props, TASKANA_GERMAN_HOLIDAYS_CORPUS_CHRISTI_ENABLED, this::setCorpusChristiEnabled); <line13> initBooleanProperty( <line14> props, <line15> TASKANA_HISTORY_DELETION_ON_TASK_DELETION_ENABLED, <line16> this::setDeleteHistoryOnTaskDeletionEnabled); <line17> initCustomHolidays(props, separator); <line18> } <line19> } <line20> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public boolean print(byte[] content, JsonNode configuration, User user) { <line2> try { <line3> DocFlavor flavor = new DocFlavor(""application/vnd.cups-raster"", ""[B""); <line4> for (PrintService service : <line5> PrintServiceLookup.lookupPrintServices(flavor, new HashPrintRequestAttributeSet())) { <line6> DocPrintJob job = service.createPrintJob(); <line7> Doc doc = new SimpleDoc(content, flavor, null); <line8> job.print(doc, null); <line9> return true; <line10> } <line11> return false; <line12> } catch (PrintException e) { <line13> } <line14> return false; <line15> } <line16> } <line17> "	 <line13>	Yes
public class A { <line0> private SpecificQueryResultSet queryOnAliasGivenDefinition( <line1> final SpecificQuery specificQuery, <line2> final int maxRows, <line3> final SpecificQueryDefinition specificQueryDefinition, <line4> final int userDefinedOffset) <line5> throws JargonException { <line6> SpecificQueryInp specificQueryInp = <line7> SpecificQueryInp.instance( <line8> specificQuery.getArguments(), <line9> specificQuery.getQueryString(), <line10> maxRows, <line11> specificQuery.getContinuationValue(), <line12> specificQuery.getZoneHint()); <line13> Tag response = null; <line14> try { <line15> response = getIRODSProtocol().irodsFunction(specificQueryInp); <line16> } catch (DataNotFoundException e) { <line17> return new SpecificQueryResultSet(specificQuery, specificQueryDefinition.getColumnNames()); <line18> } <line19> int continuation = QueryResultProcessingUtils.getContinuationValue(response); <line20> boolean hasMoreRecords = false; <line21> if (continuation != 0) { <line22> hasMoreRecords = true; <line23> } <line24> List<IRODSQueryResultRow> resultRows = <line25> QueryResultProcessingUtils.translateResponseIntoResultSet( <line26> response, specificQueryDefinition.getColumnNames(), continuation, userDefinedOffset); <line27> SpecificQueryResultSet results = <line28> new SpecificQueryResultSet( <line29> specificQuery, <line30> resultRows, <line31> specificQueryDefinition.getColumnNames(), <line32> hasMoreRecords, <line33> continuation); <line34> closeResultSet(results); <line35> return results; <line36> } <line37> } <line38> 	 <line29>	No
"public class A { <line0> public static void execute( <line1> long cycle, CommandTemplate commandTemplate, WebContext context, boolean dryrun) { <line2> Map<String, String> cmdprops = commandTemplate.getCommand(cycle); <line3> String command = cmdprops.get(""command""); <line4> Optional<Verb> oVerb = Verb.find(command); <line5> Verb verb = oVerb.orElseThrow(() -> new BasicError(""I don't know how to '"" + command + ""'"")); <line6> WebDriverVerb resolve = verb.resolve(cmdprops); <line7> if (dryrun) { <line8> return; <line9> } else { <line10> } <line11> resolve.execute(context); <line12> } <line13> } <line14> "	 <line13>	No
"public class A { <line0> private void rollCurrentFileInTrackerDir(File fileToRoll) throws IOException { <line1> Path path = fileToRoll.toPath(); <line2> Path relToRoll = getRelPathToSpoolDir(path); <line3> File dest = new File(trackerDirectory.getPath(), relToRoll + completedSuffix); <line4> if (dest.exists()) { <line5> String message = <line6> ""File name has been re-used with different"" <line7> + "" files. Spooling assumptions violated for "" <line8> + dest; <line9> throw new IllegalStateException(message); <line10> } <line11> dest.getParentFile().mkdirs(); <line12> if (!dest.createNewFile()) { <line13> throw new IOException(""Could not create tracker file: "" + dest); <line14> } <line15> } <line16> } <line17> "	 <line12>	No
"public class A { <line0> @SuppressWarnings(""all"") <line1> public static void warn( <line2> Logger log, <line3> String message, <line4> Object o1, <line5> Object o2, <line6> Object o3, <line7> Object o4, <line8> Object o5, <line9> Object o6, <line10> Object o7, <line11> Throwable t) { <line12> if (log.isDebugEnabled() && (t != null)) { <line13> } else { <line14> } <line15> } <line16> } <line17> "	 <line3>	No
"public class A { <line0> private void parseAdditionalParameters(Map<String, String> parameters) { <line1> if (Objects.equals(infoRequest, InfoRequest.emptyInfoRequest())) { <line2> throw new IllegalArgumentException(infoParameter + "": "" + infoRequest.helpMessage()); <line3> } <line4> if (infoRequest.hasAdditionalParameters()) { <line5> infoRequest.parseAdditionalParameter(parameters); <line6> } else if (parameters.size() < 1) { <line7> } <line8> if (!infoRequest.isValid()) { <line9> throw new IllegalStateException( <line10> ""The information parameter "" <line11> + infoRequest.getInfoParameter() <line12> + "" you requested does not have all parameters it needs."" <line13> + System.lineSeparator() <line14> + infoRequest.helpMessage()); <line15> } <line16> } <line17> } <line18> "	 <line14>	No
public class A { <line0> private float[] solveWithoutPivot(final float[][] a, final float[] y) { <line1> int i, j, n = a.length; <line2> float[][] ma = copy(a); <line3> float[][] r = ma, l = ma; <line4> float[] x = new float[n]; <line5> float[] z = copy(y); <line6> float tmp; <line7> matrixCheck(a); <line8> lrdecompose(ma); <line9> for (i = 0; i < n; z[i] = tmp, i++) <line10> for (tmp = z[i], j = 0; j < i; tmp -= l[i][j] * z[j], j++) <line11> ; <line12> for (j = n - 1; j >= 0; z[j] = tmp, x[j] = tmp / r[j][j], j--) <line13> for (tmp = z[j], i = j + 1; i < n; tmp -= r[j][i] * x[i], i++) <line14> ; <line15> float[] dy = residual(a, y, x); <line16> float resErr = maxnorm(dy); <line17> if (resErr > getResidualError() * maxnorm(y)) { <line18> residualCorrection(a, ma, y, x); <line19> if (GDEBUG) { <line20> resErr = maxnorm(residual(a, y, x)); <line21> } <line22> } <line23> return x; <line24> } <line25> } <line26> 	 <line13>	No
"public class A { <line0> @Override <line1> public DistStageAck executeOnWorker() { <line2> if (!isServiceRunning()) { <line3> return errorResponse(""Service is not runnning"", null); <line4> } <line5> DistStageAck result = null; <line6> Object prevResult = null; <line7> Statistics stats = statisticsPrototype.copy(); <line8> stats.begin(); <line9> for (int i = 0; i < numExecutions; i++) { <line10> prevResult = streamTaskResult; <line11> result = executeStreamTask(stats); <line12> if (prevResult != null) { <line13> if (prevResult.equals(streamTaskResult)) { <line14> } else { <line15> break; <line16> } <line17> } <line18> if (result.isError() && exitOnFailure) { <line19> break; <line20> } <line21> } <line22> stats.end(); <line23> return result; <line24> } <line25> } <line26> "	 <line14>	Yes
public class A { <line0> public Object getInstance(Class<?> clazz) { <line1> Object o = null; <line2> try { <line3> o = clazz.newInstance(); <line4> return o; <line5> } catch (InstantiationException ie) { <line6> return null; <line7> } catch (IllegalAccessException iae) { <line8> return null; <line9> } <line10> } <line11> } <line12> 	 <line2>	No
public class A { <line0> @Override <line1> public void processPacketFrom(PentairPacket p) { <line2> switch (p.getAction()) { <line3> case 1: <line4> break; <line5> case 4: <line6> break; <line7> case 5: <line8> break; <line9> case 6: <line10> break; <line11> case 7: <line12> if (p.getLength() != 15) { <line13> return; <line14> } <line15> PentairPacketPumpStatus ppsOld = ppscur; <line16> ppscur = new PentairPacketPumpStatus(p); <line17> updateChannel(INTELLIFLO_RUN, ppsOld); <line18> updateChannel(INTELLIFLO_MODE, ppsOld); <line19> updateChannel(INTELLIFLO_DRIVESTATE, ppsOld); <line20> updateChannel(INTELLIFLO_POWER, ppsOld); <line21> updateChannel(INTELLIFLO_RPM, ppsOld); <line22> updateChannel(INTELLIFLO_PPC, ppsOld); <line23> updateChannel(INTELLIFLO_ERROR, ppsOld); <line24> updateChannel(INTELLIFLO_TIMER, ppsOld); <line25> break; <line26> default: <line27> break; <line28> } <line29> } <line30> } <line31> 	 <line12>	No
public class A { <line0> private void bindMetricsRegistryToHikariDataSource(HikariDataSource hikari) { <line1> if (hikari.getMetricRegistry() == null && hikari.getMetricsTrackerFactory() == null) { <line2> try { <line3> hikari.setMetricsTrackerFactory(new MicrometerMetricsTrackerFactory(this.registry)); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> private void prepareKeyShareLength() { <line1> entry.setPublicKeyLength(entry.getPublicKey().getValue().length); <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> protected static void writeKeySetErrorResponse( <line1> Message origMsg, int messageType, String message, ServerConnection servConn) <line2> throws IOException { <line3> ChunkedMessage chunkedResponseMsg = servConn.getKeySetResponseMessage(); <line4> if (logger.isDebugEnabled()) { <line5> } <line6> chunkedResponseMsg.setMessageType(messageType); <line7> chunkedResponseMsg.setTransactionId(origMsg.getTransactionId()); <line8> chunkedResponseMsg.sendHeader(); <line9> if (logger.isDebugEnabled()) { <line10> } <line11> chunkedResponseMsg.setNumberOfParts(1); <line12> chunkedResponseMsg.setLastChunk(true); <line13> chunkedResponseMsg.addStringPart(message); <line14> chunkedResponseMsg.sendChunk(servConn); <line15> } <line16> } <line17> 	 <line10>	Yes
public class A { <line0> public WebElement waitForElementPresent(String locator) throws InterruptedException { <line1> try { <line2> this.by = getBySelector(locator); <line3> this.wait = new WebDriverWait(driver, TIMEOUT); <line4> } catch (Exception sc) { <line5> sc.printStackTrace(); <line6> } <line7> return this.wait.until(presenceOfElementLocated(this.by)); <line8> } <line9> } <line10> 	 <line4>	Yes
public class A { <line0> public void removeHttpSession(String scoutSessionId, String httpSessionId) { <line1> final ServerSessionEntry removedEntry = <line2> m_lockBySessionId.remove(scoutSessionId, entry -> removeEntry(entry, httpSessionId)); <line3> if (removedEntry != null) { <line4> removedEntry.destroy(); <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> @Override <line1> public void execute(Date expirationTime) { <line2> try { <line3> int removedOldFilesCount = fileService.deleteModifiedBefore(expirationTime); <line4> } catch (FileStorageException e) { <line5> throw new SLException(e, Messages.COULD_NOT_DELETE_FILES_MODIFIED_BEFORE_0, expirationTime); <line6> } <line7> } <line8> } <line9> 	 <line2>	Yes
public class A { <line0> public Cache<K, V> getCache(int timeout, String type) { <line1> if (_cache == null) { <line2> _cache = CacheBuilder.newBuilder().expireAfterWrite(timeout, TimeUnit.SECONDS).build(); <line3> } <line4> if (memcache == null && useMemcached) { <line5> try { <line6> memcache = new MemcachedClient(new BinaryConnectionFactory(), AddrUtil.getAddresses(addr)); <line7> } catch (Exception e) { <line8> } <line9> } <line10> if (_disabled) _cache.invalidateAll(); <line11> return _cache; <line12> } <line13> } <line14> 	 <line13>	No
"public class A { <line0> protected void updateZones(LocalScheduleResponse status) { <line1> ZonedDateTime now = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS); <line2> status.relays.forEach( <line3> r -> { <line4> String group = ""zone"" + r.getRelayNumber(); <line5> relayMap.put(group, r); <line6> updateGroupState(group, CHANNEL_ZONE_NAME, new StringType(r.name)); <line7> updateGroupState(group, CHANNEL_ZONE_TYPE, new DecimalType(r.type)); <line8> updateGroupState( <line9> group, <line10> CHANNEL_ZONE_TIME, <line11> r.runTimeSeconds != null ? new DecimalType(r.runTimeSeconds) : UnDefType.UNDEF); <line12> String icon = r.icon; <line13> if (icon != null && !icon.isBlank()) { <line14> updateGroupState(group, CHANNEL_ZONE_ICON, new StringType(BASE_IMAGE_URL + icon)); <line15> } <line16> if (r.time >= MAX_RUN_TIME) { <line17> updateGroupState(group, CHANNEL_ZONE_NEXT_RUN_TIME_TIME, UnDefType.UNDEF); <line18> } else { <line19> updateGroupState( <line20> group, <line21> CHANNEL_ZONE_NEXT_RUN_TIME_TIME, <line22> new DateTimeType(now.plusSeconds(r.time).truncatedTo(ChronoUnit.MINUTES))); <line23> } <line24> Optional<Running> running = <line25> status.running.stream() <line26> .filter(z -> Integer.parseInt(z.relayId) == r.relayId.intValue()) <line27> .findAny(); <line28> if (running.isPresent()) { <line29> updateGroupState(group, CHANNEL_ZONE_RUN, OnOffType.ON); <line30> updateGroupState( <line31> group, CHANNEL_ZONE_TIME_LEFT, new DecimalType(running.get().timeLeft)); <line32> } else { <line33> updateGroupState(group, CHANNEL_ZONE_RUN, OnOffType.OFF); <line34> updateGroupState(group, CHANNEL_ZONE_TIME_LEFT, new DecimalType(0)); <line35> } <line36> updateGroupState( <line37> CHANNEL_GROUP_ALLZONES, <line38> CHANNEL_ZONE_RUN, <line39> !status.running.isEmpty() ? OnOffType.ON : OnOffType.OFF); <line40> }); <line41> } <line42> } <line43> "	 <line3>	No
public class A { <line0> @Override <line1> public Point doGetLocation() { <line2> Point point = element.getLocation(); <line3> return point; <line4> } <line5> } <line6> 	 <line0>	No
"public class A { <line0> public Set<CardinalityIntersectionRecord> scanCardinalities( <line1> List<String> fields, <line2> DateAggregationType dateAggregationType, <line3> DatatypeAggregationType datatypeAggregationType) <line4> throws Exception { <line5> Map<CardinalityIntersectionRecord, HyperLogLogPlus> cardinalityMap = new TreeMap<>(); <line6> try (AccumuloClient client = <line7> Accumulo.newClient() <line8> .to(config.getInstanceName(), config.getZookeepers()) <line9> .as(config.getUsername(), config.getPassword()) <line10> .build()) { <line11> Collection<Authorizations> authCollection = <line12> Collections.singleton(new Authorizations(config.getAuths().split("",""))); <line13> if (!client.tableOperations().exists(config.getTableName())) { <line14> throw new IllegalArgumentException(""Table "" + config.getTableName() + "" does not exist""); <line15> } <line16> try (Scanner scanner = <line17> ScannerHelper.createScanner(client, config.getTableName(), authCollection)) { <line18> Range r = new Range(config.getBeginDate(), config.getEndDate() + ""\0""); <line19> scanner.setRange(r); <line20> Iterator<Map.Entry<Key, Value>> itr = scanner.iterator(); <line21> while (itr.hasNext()) { <line22> Map.Entry<Key, Value> nextEntry = itr.next(); <line23> Key key = nextEntry.getKey(); <line24> String field = key.getColumnFamily().toString(); <line25> if (fields != null && !fields.isEmpty() && !fields.contains(field)) { <line26> continue; <line27> } else { <line28> addEntry(cardinalityMap, nextEntry, dateAggregationType, datatypeAggregationType); <line29> } <line30> } <line31> } <line32> } catch (Exception e) { <line33> } <line34> return cardinalityMap.keySet(); <line35> } <line36> } <line37> "	 <line34>	No
public class A { <line0> @Override <line1> public void operationComplete(ChannelFuture channelFuture) throws Exception { <line2> if (!channelFuture.isSuccess()) { <line3> statsLogger <line4> .getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE) <line5> .registerFailedEvent(MathUtils.elapsedMicroSec(writeStartNanos)); <line6> if (channelFuture.getCause() instanceof ClosedChannelException) { <line7> cb.operationComplete(ChannelRequestCompletionCode.ChannelClosedException, null); <line8> } else { <line9> cb.operationComplete(ChannelRequestCompletionCode.UnknownError, null); <line10> } <line11> } else { <line12> statsLogger <line13> .getOpStatsLogger(BookKeeperClientStats.CHANNEL_WRITE) <line14> .registerSuccessfulEvent(MathUtils.elapsedMicroSec(writeStartNanos)); <line15> cb.operationComplete(ChannelRequestCompletionCode.OK, null); <line16> } <line17> } <line18> } <line19> 	 <line9>	Yes
"public class A { <line0> @Override <line1> public KeeperException.Code handleAuthentication(ServerObjs serverObjs, byte[] authData) { <line2> byte[] key = getKey(serverObjs.getZks()); <line3> String authStr = new String(authData, UTF_8); <line4> String keyStr = """"; <line5> if (key != null) { <line6> if (!validate(key, authData)) { <line7> keyStr = new String(key, UTF_8); <line8> return KeeperException.Code.AUTHFAILED; <line9> } <line10> } <line11> serverObjs.getCnxn().addAuthInfo(new Id(getScheme(), keyStr)); <line12> return KeeperException.Code.OK; <line13> } <line14> } <line15> "	 <line10>	No
"public class A { <line0> @Test <line1> public void shouldDecodeNRowResponseSmallyChunked() throws Exception { <line2> String response = Resources.read(""chunked.json"", this.getClass()); <line3> String[] chunks = <line4> new String[] { <line5> response.substring(0, 48), <line6> response.substring(48, 84), <line7> response.substring(84, 144), <line8> response.substring(144, 258), <line9> response.substring(258, 438), <line10> response.substring(438, 564), <line11> response.substring(564, 702), <line12> response.substring(702, 740), <line13> response.substring(740) <line14> }; <line15> StringBuilder sb = new StringBuilder(""Chunks:""); <line16> for (String chunk : chunks) { <line17> sb.append(""\n>"").append(chunk); <line18> } <line19> shouldDecodeChunked(true, chunks); <line20> } <line21> } <line22> "	 <line5>	No
public class A { <line0> @Override <line1> protected long getLastModified(HttpServletRequest httpServletRequest) { <line2> try { <line3> URL url = getResourceURL(httpServletRequest); <line4> if (url != null) { <line5> URLConnection urlConnection = url.openConnection(); <line6> return urlConnection.getLastModified(); <line7> } <line8> return super.getLastModified(httpServletRequest); <line9> } catch (IOException ioException) { <line10> if (_log.isDebugEnabled()) { <line11> } <line12> return super.getLastModified(httpServletRequest); <line13> } <line14> } <line15> } <line16> 	 <line11>	Yes
public class A { <line0> public ResourceResolver getTemplateResourceResolver( <line1> WebuiRequestContext context, String template) { <line2> try { <line3> DMSConfiguration dmsConfiguration = getApplicationComponent(DMSConfiguration.class); <line4> String workspace = dmsConfiguration.getConfig().getSystemWorkspace(); <line5> resourceResolver = new JCRResourceResolver(workspace); <line6> } catch (Exception e) { <line7> if (LOG.isWarnEnabled()) { <line8> } <line9> } <line10> return resourceResolver; <line11> } <line12> } <line13> 	 <line8>	Yes
public class A { <line0> public Mono<PolicyRetrievalResult> retrievePoliciesCollector( <line1> EvaluationContext subscriptionScopedEvaluationContext) { <line2> if (!consistent) return Mono.just(new PolicyRetrievalResult().withInvalidState()); <line3> var documentsWithMatchingInformation = <line4> Flux.merge( <line5> documentsByName.values().stream() <line6> .map( <line7> document -> <line8> document <line9> .matches(subscriptionScopedEvaluationContext) <line10> .map(val -> Tuples.of(document, val))) <line11> .collect(Collectors.toList())); <line12> return documentsWithMatchingInformation.reduce( <line13> new PolicyRetrievalResult(), <line14> (policyRetrievalResult, documentWithMatchingInformation) -> { <line15> var match = documentWithMatchingInformation.getT2(); <line16> if (match.isError()) return policyRetrievalResult.withError(); <line17> if (!match.isBoolean()) { <line18> return policyRetrievalResult.withError(); <line19> } <line20> if (match.getBoolean()) <line21> return policyRetrievalResult.withMatch(documentWithMatchingInformation.getT1()); <line22> return policyRetrievalResult; <line23> }); <line24> } <line25> } <line26> 	 <line21>	No
"public class A { <line0> @Override <line1> protected void doGet( <line2> HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) <line3> throws ServletException, IOException { <line4> RequestParams params = new RequestParams(httpServletRequest.getParameterMap()); <line5> try { <line6> String request = params.getMandatoryString(""request""); <line7> dispatchWmsRequest(request, params, httpServletRequest, httpServletResponse, catalogue); <line8> } catch (EdalException wmse) { <line9> boolean v130; <line10> try { <line11> v130 = ""1.3.0"".equals(params.getMandatoryWmsVersion()); <line12> } catch (EdalException e) { <line13> v130 = true; <line14> } <line15> handleWmsException(wmse, httpServletResponse, v130); <line16> } catch (SocketException se) { <line17> } catch (IOException ioe) { <line18> if (ioe.getClass().getName().equals(""org.apache.catalina.connector.ClientAbortException"")) { <line19> return; <line20> } <line21> throw ioe; <line22> } catch (Exception e) { <line23> e.printStackTrace(); <line24> throw new IOException(e); <line25> } <line26> } <line27> } <line28> "	 <line10>	No
"public class A { <line0> private void loadMetadataDefinitions() throws IOException { <line1> String metadataDefEditHome = <line2> repository + File.separator + ""core"" + File.separator + ""metadata"" + File.separator + ""def""; <line3> final File[] inputDefFolders = FolderTools.getFilesInFolder(metadataDefEditHome, ""all"", """"); <line4> for (final File inputDefFolder : inputDefFolders) { <line5> if (inputDefFolder.isDirectory()) { <line6> final File[] inputDefTables = <line7> FolderTools.getFilesInFolder( <line8> inputDefFolder.getAbsolutePath() + File.separator + ""Tables"", ""regex"", "".+\\.yml""); <line9> List<DataObject> defTableDataObjects = new ArrayList<>(); <line10> for (final File inputDef : inputDefTables) { <line11> DataObjectOperation inputDataObjectOperation = <line12> new DataObjectOperation(inputDef.getAbsolutePath()); <line13> ObjectMapper inputObjectMapper = new ObjectMapper(); <line14> defTableDataObjects.addAll(inputDataObjectOperation.getDataObjects()); <line15> String metadataDefFileName = inputDefFolder.getName() + ""Tables.json""; <line16> String metadataDefFilePath = metadataDefEditHome + File.separator + metadataDefFileName; <line17> inputObjectMapper <line18> .writerWithDefaultPrettyPrinter() <line19> .writeValue(new File(metadataDefFilePath), defTableDataObjects); <line20> FileTools.copyFromFileToFile( <line21> metadataDefFilePath, <line22> repository <line23> + File.separator <line24> + ""docs"" <line25> + File.separator <line26> + ""_data"" <line27> + File.separator <line28> + ""datamodel"" <line29> + File.separator <line30> + metadataDefFileName); <line31> } <line32> final File[] inputDefObjects = <line33> FolderTools.getFilesInFolder( <line34> inputDefFolder.getAbsolutePath() + File.separator + ""Objects"", ""regex"", "".+\\.yml""); <line35> List<DataObject> defObjectDataObjects = new ArrayList<>(); <line36> for (final File inputDef : inputDefObjects) { <line37> DataObjectOperation inputDataObjectOperation = <line38> new DataObjectOperation(inputDef.getAbsolutePath()); <line39> ObjectMapper inputObjectMapper = new ObjectMapper(); <line40> defObjectDataObjects.addAll(inputDataObjectOperation.getDataObjects()); <line41> String metadataDefFileName = inputDefFolder.getName() + ""Objects.json""; <line42> String metadataDefFilePath = metadataDefEditHome + File.separator + metadataDefFileName; <line43> inputObjectMapper <line44> .writerWithDefaultPrettyPrinter() <line45> .writeValue(new File(metadataDefFilePath), defObjectDataObjects); <line46> FileTools.copyFromFileToFile( <line47> metadataDefFilePath, <line48> repository <line49> + File.separator <line50> + ""docs"" <line51> + File.separator <line52> + ""_data"" <line53> + File.separator <line54> + ""datamodel"" <line55> + File.separator <line56> + metadataDefFileName); <line57> } <line58> } <line59> } <line60> } <line61> } <line62> "	 <line1>	Yes
"public class A { <line0> @Override <line1> public LayoutPageTemplateEntry findByUUID_G(String uuid, long groupId) <line2> throws NoSuchPageTemplateEntryException { <line3> LayoutPageTemplateEntry layoutPageTemplateEntry = fetchByUUID_G(uuid, groupId); <line4> if (layoutPageTemplateEntry == null) { <line5> StringBundler sb = new StringBundler(6); <line6> sb.append(_NO_SUCH_ENTITY_WITH_KEY); <line7> sb.append(""uuid=""); <line8> sb.append(uuid); <line9> sb.append("", groupId=""); <line10> sb.append(groupId); <line11> sb.append(""}""); <line12> if (_log.isDebugEnabled()) { <line13> } <line14> throw new NoSuchPageTemplateEntryException(sb.toString()); <line15> } <line16> return layoutPageTemplateEntry; <line17> } <line18> } <line19> "	 <line6>	No
public class A { <line0> @Override <line1> public void postProcessEnvironment( <line2> ConfigurableEnvironment environment, SpringApplication application) { <line3> ProfileEnvironment profileEnvironment = newProfileEnvironment(); <line4> profileEnvironment.processEnvironment(environment); <line5> ExternalEnvironment externalEnvironment = <line6> new ExternalEnvironment(EXTERNAL_PROPERTY_SOURCE_NAME, EXTERNAL_CONFIGURATION_KEY); <line7> externalEnvironment.processEnvironment(environment); <line8> BaseEnvironment baseEnvironment = <line9> new BaseEnvironment(PROPERTY_SOURCE_NAME, Arrays.asList(resources)); <line10> baseEnvironment.processEnvironment(environment); <line11> MutablePropertySources propertySources = environment.getPropertySources(); <line12> for (PropertySource<?> propertySource : propertySources) { <line13> } <line14> } <line15> } <line16> 	 <line5>	No
"public class A { <line0> @Override <line1> protected Cons<VBoxBody> performValidCommit() { <line2> PersistenceBroker pb = getOJBBroker(); <line3> int currentPriority = Thread.currentThread().getPriority(); <line4> try { <line5> Thread.currentThread().setPriority(Thread.MAX_PRIORITY); <line6> try { <line7> if (!pb.isInTransaction()) { <line8> pb.beginTransaction(); <line9> } <line10> try { <line11> ActiveTransactionsRecord myRecord = this.activeTxRecord; <line12> if (TransactionChangeLogs.updateFromTxLogsOnDatabase(pb, myRecord, true) != myRecord) { <line13> if (!validateCommit()) { <line14> throw new jvstm.CommitException(); <line15> } <line16> } <line17> } catch (SQLException sqlex) { <line18> throw new CommitException(); <line19> } catch (LookupException le) { <line20> throw new Error(""Error while obtaining database connection"", le); <line21> } <line22> Cons<VBoxBody> newBodies = super.performValidCommit(); <line23> try { <line24> pb.commitTransaction(); <line25> } catch (Throwable t) { <line26> t.printStackTrace(); <line27> System.exit(-1); <line28> } <line29> pb = null; <line30> return newBodies; <line31> } finally { <line32> if (pb != null) { <line33> pb.abortTransaction(); <line34> } <line35> } <line36> } finally { <line37> Thread.currentThread().setPriority(currentPriority); <line38> } <line39> } <line40> } <line41> "	 <line18>	Yes
"public class A { <line0> @Test <line1> public void testUserExistsException() { <line2> final User user = new User(""admin""); <line3> user.setEmail(""matt@raibledesigns.com""); <line4> willThrow(new DataIntegrityViolationException("""")).given(userDao).saveUser(user); <line5> try { <line6> userManager.saveUser(user); <line7> fail(""Expected UserExistsException not thrown""); <line8> } catch (UserExistsException e) { <line9> assertNotNull(e); <line10> } <line11> } <line12> } <line13> "	 <line9>	Yes
public class A { <line0> private HashFullOuterJoinExec createFullOuterHashJoinPlan( <line1> TaskAttemptContext context, JoinNode plan, PhysicalExec leftExec, PhysicalExec rightExec) <line2> throws IOException { <line3> String[] leftLineage = PlannerUtil.getRelationLineage(plan.getLeftChild()); <line4> String[] rightLineage = PlannerUtil.getRelationLineage(plan.getRightChild()); <line5> long outerSize2 = estimateSizeRecursive(context, leftLineage); <line6> long innerSize2 = estimateSizeRecursive(context, rightLineage); <line7> PhysicalExec selectedRight; <line8> PhysicalExec selectedLeft; <line9> if (outerSize2 <= innerSize2) { <line10> selectedLeft = leftExec; <line11> selectedRight = rightExec; <line12> } else { <line13> selectedLeft = rightExec; <line14> selectedRight = leftExec; <line15> } <line16> return new HashFullOuterJoinExec(context, plan, selectedRight, selectedLeft); <line17> } <line18> } <line19> 	 <line12>	No
public class A { <line0> private synchronized boolean installPackage(final Map<String, Object> config) { <line1> boolean configChanged = false; <line2> Object packageName = config.get(OpenHAB.CFG_PACKAGE); <line3> if (packageName instanceof String) { <line4> currentPackage = (String) packageName; <line5> String fullName = PREFIX + PREFIX_PACKAGE + ((String) packageName).trim(); <line6> if (MINIMAL_PACKAGE.equals(currentPackage)) { <line7> configChanged = false; <line8> } else { <line9> if (installFeature(fullName)) { <line10> configChanged = true; <line11> } <line12> } <line13> try { <line14> for (Feature feature : featuresService.listFeatures()) { <line15> if (feature.getName().startsWith(PREFIX + PREFIX_PACKAGE) <line16> && !feature.getName().equals(fullName)) { <line17> uninstallFeature(feature.getName()); <line18> } <line19> } <line20> } catch (Exception e) { <line21> } <line22> } <line23> return configChanged; <line24> } <line25> } <line26> 	 <line13>	No
public class A { <line0> @Override <line1> protected List<MenuItem> getPortletTitleMenuItems( <line2> PortletRequest portletRequest, PortletResponse portletResponse) { <line3> ThemeDisplay themeDisplay = (ThemeDisplay) portletRequest.getAttribute(WebKeys.THEME_DISPLAY); <line4> Layout layout = themeDisplay.getLayout(); <line5> if (!_hasAddArticlePermission(themeDisplay) || layout.isLayoutPrototypeLinkActive()) { <line6> return Collections.emptyList(); <line7> } <line8> List<MenuItem> menuItems = new ArrayList<>(); <line9> try { <line10> addPortletTitleAddJournalArticleMenuItems(menuItems, themeDisplay, portletRequest); <line11> } catch (Exception exception) { <line12> } <line13> return menuItems; <line14> } <line15> } <line16> 	 <line11>	No
public class A { <line0> @Override <line1> public boolean deleteDocument(DocumentMetadataType document) { <line2> DeleteDocumentRequestMessageType request = new DeleteDocumentRequestMessageType(); <line3> request.setConfigAssertion(buildConfigAssertion()); <line4> request.setDocument(document); <line5> try { <line6> LoadTestDataSimpleResponseMessageType response = <line7> (LoadTestDataSimpleResponseMessageType) <line8> invokeClientPort(AdminWSConstants.ADMIN_LTD_DELETEDOCUMENT, request); <line9> logDebug( <line10> AdminWSConstants.ADMIN_LTD_DELETEDOCUMENT, response.isStatus(), response.getMessage()); <line11> return response.isStatus(); <line12> } catch (Exception e) { <line13> } <line14> return false; <line15> } <line16> } <line17> 	 <line11>	No
public class A { <line0> public synchronized void stop() { <line1> for (MLDriver driver : drivers) { <line2> try { <line3> driver.stop(); <line4> } catch (LensException e) { <line5> } <line6> } <line7> drivers.clear(); <line8> udfStatusExpirySvc.shutdownNow(); <line9> } <line10> } <line11> 	 <line1>	No
"public class A { <line0> public static List<JsonObject> predictRegression( <line1> List<JsonObject> data, JsonArray columnNames, String usecaseName) <line2> throws IOException, PredictException { <line3> List<JsonObject> predictionData = new ArrayList<>(); <line4> try { <line5> RegressionModelPrediction p = null; <line6> AutoMLConfig autoMLConfig = autoMlDAL.getMLConfigByUsecase(usecaseName); <line7> String deployedMojoName = autoMLConfig.getMojoDeployed(); <line8> String predectionColumn = autoMLConfig.getPredictionColumn(); <line9> String path = FileUtils.getTempDirectoryPath(); <line10> byte[] mojoData = autoMLConfig.getMojoDeployedZip(); <line11> File file = new File(path + usecaseName + "".zip""); <line12> FileUtils.writeByteArrayToFile(file, mojoData); <line13> EasyPredictModelWrapper model = <line14> new EasyPredictModelWrapper(MojoModel.load(new TmpMojoReaderBackend(file))); <line15> Gson gson = new Gson(); <line16> Type type = new TypeToken<Map<String, String>>() {}.getType(); <line17> for (JsonElement eachObject : data) { <line18> JsonObject object = eachObject.getAsJsonObject(); <line19> RowData row = new RowData(); <line20> JsonObject rowObject = new JsonObject(); <line21> for (JsonElement eachColumn : columnNames) { <line22> String column = eachColumn.getAsString(); <line23> String value = object.get(column) == null ? """" : object.get(column).getAsString(); <line24> if (!value.equals("""")) { <line25> rowObject.addProperty(column, value); <line26> } <line27> } <line28> Map<String, String> eachRow = gson.fromJson(rowObject, type); <line29> row.putAll(eachRow); <line30> p = model.predictRegression(row); <line31> object.addProperty(""predictedColumn"", predectionColumn); <line32> object.addProperty(""predictedValue"", String.valueOf(p.value)); <line33> predictionData.add(object); <line34> } <line35> } catch (Exception e) { <line36> throw new PredictException( <line37> ""Something went wrong while executing regression prediction for "" <line38> + usecaseName <line39> + "" "" <line40> + e.getMessage()); <line41> } <line42> return predictionData; <line43> } <line44> } <line45> "	 <line15>	Yes
public class A { <line0> public HttpURLConnection connect( <line1> String endpoint, <line2> Map<String, List<String>> param, <line3> String method, <line4> String data, <line5> Map<String, String> headers) <line6> throws Exception { <line7> for (int i = 0; i < ips.size() && !ips.isEmpty(); ++i, ++index) { <line8> if (index >= ips.size()) { <line9> index = 0; <line10> } <line11> try { <line12> URL url = buildUrl(endpoint, param, ips.get(index), ports.get(index)); <line13> HttpURLConnection conn = openConnection(url); <line14> conn.setConnectTimeout(DEFAULT_CONNECTION_TIMEOUT); <line15> if (headers != null) { <line16> headers.forEach((k, v) -> conn.setRequestProperty(k, v)); <line17> } <line18> conn.setRequestMethod(method); <line19> conn.setUseCaches(false); <line20> conn.setDoInput(true); <line21> for (int j = 0; j < maxRetry + 1; ++j) { <line22> if (j > 0) { <line23> TimeUnit.SECONDS.sleep(RETRY_INTERVAL); <line24> } <line25> try { <line26> if (data != null) { <line27> conn.setDoOutput(true); <line28> DataOutputStream wr = new DataOutputStream(conn.getOutputStream()); <line29> wr.writeBytes(data); <line30> wr.flush(); <line31> wr.close(); <line32> } <line33> int code = conn.getResponseCode(); <line34> if (code == 200 || code == 401) { <line35> return conn; <line36> } <line37> if ((code / 100) == 5 || (code / 100) == 3) { <line38> continue; <line39> } <line40> break; <line41> } catch (IOException e) { <line42> } <line43> } <line44> } catch (URISyntaxException | IOException | InterruptedException e) { <line45> } <line46> } <line47> throw new ConnectException(); <line48> } <line49> } <line50> 	 <line45>	Yes
public class A { <line0> private PoxPayloadOut createPottagInstance(String familyName, String taggedBy, String commonName) <line1> throws Exception { <line2> PottagsCommon pottagCommon = new PottagsCommon(); <line3> pottagCommon.setFamily(familyName); <line4> pottagCommon.setTaggedBy(taggedBy); <line5> pottagCommon.setCommonName(commonName); <line6> PoxPayloadOut multipart = new PoxPayloadOut(this.getServicePathComponent()); <line7> PayloadOutputPart commonPart = <line8> multipart.addPart(new PottagClient().getCommonPartName(), pottagCommon); <line9> if (logger.isDebugEnabled()) { <line10> } <line11> return multipart; <line12> } <line13> } <line14> 	 <line6>	No
"public class A { <line0> public void sendSuccessEdgeNotification(final MonitoredMessage trackMessage) { <line1> final String subject = <line2> MessageMonitoringUtil.getSuccessfulMessageSubjectPrefix() + trackMessage.getSubject(); <line3> final String emailText = <line4> MessageMonitoringUtil.getSuccessfulMessageEmailText() + trackMessage.getRecipients(); <line5> final String postmasterEmailId = <line6> MessageMonitoringUtil.getDomainPostmasterEmailId() <line7> + ""@"" <line8> + MessageMonitoringUtil.getDomainFromEmail(trackMessage.getSenderemailid()); <line9> final DirectEdgeProxy proxy = MessageMonitoringUtil.getDirectEdgeProxy(); <line10> MimeMessage message = null; <line11> String errorMsg = null; <line12> try { <line13> message = <line14> MessageMonitoringUtil.createMimeMessage( <line15> postmasterEmailId, <line16> subject, <line17> trackMessage.getSenderemailid(), <line18> emailText, <line19> trackMessage.getMessageid()); <line20> proxy.provideAndRegisterDocumentSetB(message); <line21> getDirectEventLogger().log(DirectEventType.DIRECT_EDGE_NOTIFICATION_SUCCESSFUL, message); <line22> } catch (final MessagingException ex) { <line23> errorMsg = ex.getLocalizedMessage(); <line24> } <line25> } <line26> } <line27> "	 <line24>	Yes
"public class A { <line0> private String propertyReplace(String location) { <line1> String result = location; <line2> if (location.startsWith(""${"")) { <line3> int pos = location.indexOf('}'); <line4> if (pos > 0) { <line5> String property = location.substring(2, pos); <line6> String rest = location.substring(pos + 1); <line7> String value = System.getProperty(property); <line8> if (null == value) { <line9> value = <line10> System.getProperty(""java.io.tmpdir"") <line11> + File.separator <line12> + ""geomajas"" <line13> + File.separator <line14> + ""cache""; <line15> } <line16> result = value + rest; <line17> } else { <line18> } <line19> } <line20> return result; <line21> } <line22> } <line23> "	 <line18>	Yes
"public class A { <line0> @Override <line1> public StartupCommand[] initialize() { <line2> final KVMHostInfo info = new KVMHostInfo(_dom0MinMem, _dom0OvercommitMem); <line3> String capabilities = String.join("","", info.getCapabilities()); <line4> if (dpdkSupport) { <line5> capabilities += "",dpdk""; <line6> } <line7> final StartupRoutingCommand cmd = <line8> new StartupRoutingCommand( <line9> info.getCpus(), <line10> info.getCpuSpeed(), <line11> info.getTotalMemory(), <line12> info.getReservedMemory(), <line13> capabilities, <line14> _hypervisorType, <line15> RouterPrivateIpStrategy.HostLocal); <line16> cmd.setCpuSockets(info.getCpuSockets()); <line17> fillNetworkInformation(cmd); <line18> _privateIp = cmd.getPrivateIpAddress(); <line19> cmd.getHostDetails().putAll(getVersionStrings()); <line20> cmd.getHostDetails().put(KeyStoreUtils.SECURED, String.valueOf(isHostSecured()).toLowerCase()); <line21> cmd.setPool(_pool); <line22> cmd.setCluster(_clusterId); <line23> cmd.setGatewayIpAddress(_localGateway); <line24> cmd.setIqn(getIqn()); <line25> if (cmd.getHostDetails().containsKey(""Host.OS"")) { <line26> _hostDistro = cmd.getHostDetails().get(""Host.OS""); <line27> } <line28> StartupStorageCommand sscmd = null; <line29> try { <line30> final KVMStoragePool localStoragePool = <line31> _storagePoolMgr.createStoragePool( <line32> _localStorageUUID, <line33> ""localhost"", <line34> -1, <line35> _localStoragePath, <line36> """", <line37> StoragePoolType.Filesystem); <line38> final com.cloud.agent.api.StoragePoolInfo pi = <line39> new com.cloud.agent.api.StoragePoolInfo( <line40> localStoragePool.getUuid(), <line41> cmd.getPrivateIpAddress(), <line42> _localStoragePath, <line43> _localStoragePath, <line44> StoragePoolType.Filesystem, <line45> localStoragePool.getCapacity(), <line46> localStoragePool.getAvailable()); <line47> sscmd = new StartupStorageCommand(); <line48> sscmd.setPoolInfo(pi); <line49> sscmd.setGuid(pi.getUuid()); <line50> sscmd.setDataCenter(_dcId); <line51> sscmd.setResourceType(Storage.StorageResourceType.STORAGE_POOL); <line52> } catch (final CloudRuntimeException e) { <line53> } <line54> if (sscmd != null) { <line55> return new StartupCommand[] {cmd, sscmd}; <line56> } else { <line57> return new StartupCommand[] {cmd}; <line58> } <line59> } <line60> } <line61> "	 <line17>	No
"public class A { <line0> @Test <line1> @Deprecated <line2> public void testAddLegacyLocationDefinition() { <line3> Map<String, String> expectedConfig = <line4> ImmutableMap.of(""identity"", ""bob"", ""credential"", ""CR3dential""); <line5> ClientResponse response = <line6> client() <line7> .resource(""/v1/locations"") <line8> .type(MediaType.APPLICATION_JSON_TYPE) <line9> .post( <line10> ClientResponse.class, <line11> new org.apache.brooklyn.rest.domain.LocationSpec( <line12> legacyLocationName, ""aws-ec2:us-east-1"", expectedConfig)); <line13> URI addedLegacyLocationUri = response.getLocation(); <line14> LocationSummary location = client().resource(response.getLocation()).get(LocationSummary.class); <line15> assertEquals( <line16> location.getSpec(), ""brooklyn.catalog:"" + legacyLocationName + "":"" + legacyLocationVersion); <line17> assertTrue(addedLegacyLocationUri.toString().startsWith(""/v1/locations/"")); <line18> JcloudsLocation l = <line19> (JcloudsLocation) getManagementContext().getLocationRegistry().resolve(legacyLocationName); <line20> Assert.assertEquals(l.getProvider(), ""aws-ec2""); <line21> Assert.assertEquals(l.getRegion(), ""us-east-1""); <line22> Assert.assertEquals(l.getIdentity(), ""bob""); <line23> Assert.assertEquals(l.getCredential(), ""CR3dential""); <line24> } <line25> } <line26> "	 <line14>	Yes
"public class A { <line0> @Test <line1> public void testDeserialize_out() throws Exception { <line2> Optional<? extends RpcDefinition> loadRpc = <line3> ConverterUtils.loadRpc(this.effectiveModelContext, SIMPLE_IO_RPC_QNAME); <line4> String loadIoRpcOut = loadResourceAsString(""input-output-rpc-out.json""); <line5> NormalizedNode<?, ?> deserializeRpc = <line6> bindingSerializer.deserialize(loadRpc.get(), new StringReader(loadIoRpcOut)); <line7> Assert.assertNotNull(deserializeRpc); <line8> } <line9> } <line10> "	 <line5>	No
"public class A { <line0> @InternalMethod <line1> @RequestMapping(value = ""internal/{fileName:.+}"", method = RequestMethod.POST) <line2> public UploadResponse uploadInternal( <line3> @PathVariable() final String fileName, <line4> @RequestParam(value = CloudifyConstants.UPLOAD_FILE_PARAM_NAME, required = true) <line5> final MultipartFile file) <line6> throws RestErrorException { <line7> String name = fileName; <line8> if (StringUtils.isEmpty(fileName)) { <line9> name = file.getOriginalFilename(); <line10> } <line11> if (logger.isLoggable(Level.INFO)) { <line12> } <line13> String uploadKey = null; <line14> try { <line15> uploadKey = uploadRepo.put(name, file); <line16> } catch (IOException e) { <line17> if (logger.isLoggable(Level.WARNING)) { <line18> logger.warning(""could not upload file "" + name + "" error was - "" + e.getMessage()); <line19> } <line20> throw new RestErrorException( <line21> CloudifyMessageKeys.UPLOAD_FAILED.getName(), name, e.getMessage()); <line22> } <line23> if (logger.isLoggable(Level.INFO)) { <line24> } <line25> UploadResponse response = new UploadResponse(); <line26> response.setUploadKey(uploadKey); <line27> return response; <line28> } <line29> } <line30> "	 <line13>	No
"public class A { <line0> @Override <line1> public ArrayList<GwtFirewallOpenPortEntry> findDeviceFirewallOpenPorts(GwtXSRFToken xsrfToken) <line2> throws GwtKuraException { <line3> checkXSRFToken(xsrfToken); <line4> NetworkAdminService nas = ServiceLocator.getInstance().getService(NetworkAdminService.class); <line5> List<GwtFirewallOpenPortEntry> gwtOpenPortEntries = new ArrayList<>(); <line6> try { <line7> List<NetConfig> firewallConfigs = nas.getFirewallConfiguration(); <line8> if (firewallConfigs != null && !firewallConfigs.isEmpty()) { <line9> for (NetConfig netConfig : firewallConfigs) { <line10> if (netConfig instanceof FirewallOpenPortConfigIP4) { <line11> GwtFirewallOpenPortEntry entry = new GwtFirewallOpenPortEntry(); <line12> if (((FirewallOpenPortConfigIP4) netConfig).getPortRange() != null) { <line13> entry.setPortRange(((FirewallOpenPortConfigIP4) netConfig).getPortRange()); <line14> } else { <line15> entry.setPortRange(String.valueOf(((FirewallOpenPortConfigIP4) netConfig).getPort())); <line16> } <line17> entry.setProtocol(((FirewallOpenPortConfigIP4) netConfig).getProtocol().toString()); <line18> entry.setPermittedNetwork( <line19> ((FirewallOpenPortConfigIP4) netConfig) <line20> .getPermittedNetwork() <line21> .getIpAddress() <line22> .getHostAddress() <line23> + ""/"" <line24> + ((FirewallOpenPortConfigIP4) netConfig).getPermittedNetwork().getPrefix()); <line25> entry.setPermittedInterfaceName( <line26> ((FirewallOpenPortConfigIP4) netConfig).getPermittedInterfaceName()); <line27> entry.setUnpermittedInterfaceName( <line28> ((FirewallOpenPortConfigIP4) netConfig).getUnpermittedInterfaceName()); <line29> entry.setPermittedMAC(((FirewallOpenPortConfigIP4) netConfig).getPermittedMac()); <line30> entry.setSourcePortRange(((FirewallOpenPortConfigIP4) netConfig).getSourcePortRange()); <line31> gwtOpenPortEntries.add(entry); <line32> } <line33> } <line34> } <line35> return new ArrayList<>(gwtOpenPortEntries); <line36> } catch (KuraException e) { <line37> throw new GwtKuraException(GwtKuraErrorCode.INTERNAL_ERROR, e); <line38> } <line39> } <line40> } <line41> "	 <line11>	Yes
public class A { <line0> @Override <line1> public String toJsonString() throws IOException { <line2> if (partitionToWriteStats.containsKey(null)) { <line3> partitionToWriteStats.remove(null); <line4> } <line5> if (partitionToReplaceFileIds.containsKey(null)) { <line6> partitionToReplaceFileIds.remove(null); <line7> } <line8> return getObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(this); <line9> } <line10> } <line11> 	 <line6>	Yes
public class A { <line0> private void printContainerLog(String containerId) { <line1> LogCallback loggingCallback = new LogCallback(); <line2> dockerClient <line3> .logContainerCmd(containerId) <line4> .withStdErr(true) <line5> .withStdOut(true) <line6> .withFollowStream(true) <line7> .withTailAll() <line8> .exec(loggingCallback); <line9> try { <line10> loggingCallback.awaitCompletion(3, TimeUnit.SECONDS); <line11> } catch (InterruptedException e) { <line12> Thread.currentThread().interrupt(); <line13> } <line14> } <line15> } <line16> 	 <line12>	Yes
"public class A { <line0> public void setVCenter(VCenter vcenter) throws Exception { <line1> try (Connection con = getDatasource().getConnection(); ) { <line2> String query1 = ""UPDATE vcenter SET url = ?, userid = ?, password = ? WHERE tkey = ?""; <line3> try (PreparedStatement stmt = con.prepareStatement(query1); ) { <line4> stmt.setString(1, vcenter.getUrl()); <line5> stmt.setString(2, vcenter.getUserid()); <line6> stmt.setString(3, vcenter.getPassword()); <line7> stmt.setInt(4, vcenter.tkey); <line8> stmt.executeUpdate(); <line9> } <line10> } catch (SQLException e) { <line11> throw new Exception(Messages.get(locale, ""error_db_save_conf"")); <line12> } <line13> } <line14> } <line15> "	 <line14>	No
public class A { <line0> protected void generatePojo(TableDefinition table) { <line1> JavaWriter out = newJavaWriter(getFile(table, Mode.POJO)); <line2> generatePojo(table, out); <line3> closeJavaWriter(out); <line4> } <line5> } <line6> 	 <line3>	No
public class A { <line0> public static boolean download(URL url, File destFolder, String filename) throws IOException { <line1> File destinationFile = new File(destFolder.getPath(), filename); <line2> URLConnection urlc = url.openConnection(); <line3> boolean result = false; <line4> try (BufferedInputStream bis = new BufferedInputStream(urlc.getInputStream()); <line5> BufferedOutputStream bos = <line6> new BufferedOutputStream(new FileOutputStream(destinationFile.getPath())); ) { <line7> int i; <line8> while ((i = bis.read()) != -1) { <line9> bos.write(i); <line10> } <line11> result = true; <line12> } <line13> return result; <line14> } <line15> } <line16> 	 <line2>	Yes
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void testExpandDimsGradient(Nd4jBackend backend) { <line3> val origShape = new long[] {3, 4}; <line4> List<String> failed = new ArrayList<>(); <line5> boolean first = true; <line6> for (int i = 0; i < 3; i++) { <line7> long[] expExpandShape; <line8> switch (i) { <line9> case 0: <line10> expExpandShape = new long[] {1, 3, 4}; <line11> break; <line12> case 1: <line13> expExpandShape = new long[] {3, 1, 4}; <line14> break; <line15> case 2: <line16> expExpandShape = new long[] {3, 4, 1}; <line17> break; <line18> default: <line19> throw new RuntimeException(); <line20> } <line21> for (Pair<INDArray, String> p : <line22> NDArrayCreationUtil.getAllTestMatricesWithShape( <line23> origShape[0], origShape[1], 12345, DataType.DOUBLE)) { <line24> INDArray inArr = p.getFirst().muli(100); <line25> SameDiff sd = SameDiff.create(); <line26> SDVariable in = sd.var(""in"", inArr); <line27> SDVariable expand = sd.expandDims(in, i); <line28> SDVariable stdev = sd.standardDeviation(""out"", expand, true); <line29> Map<String, INDArray> m = sd.outputAll(null); <line30> INDArray expOut = in.getArr().std(true); <line31> assertArrayEquals(expExpandShape, m.get(expand.name()).shape()); <line32> INDArray expExpand = inArr.dup('c').reshape(expExpandShape); <line33> String msg = ""expandDim="" + i + "", source="" + p.getSecond(); <line34> TestCase tc = new TestCase(sd); <line35> tc.testName(msg).expectedOutput(""out"", expOut).expectedOutput(expand.name(), expExpand); <line36> String error = OpValidation.validate(tc); <line37> if (error != null) { <line38> failed.add(error); <line39> } <line40> } <line41> } <line42> assertEquals(0, failed.size(), failed.toString()); <line43> } <line44> } <line45> "	 <line30>	No
"public class A { <line0> protected void setupServer() throws IOException { <line1> com.trilead.ssh2.Connection sshConnection = new com.trilead.ssh2.Connection(_ip, 22); <line2> sshConnection.connect(null, 60000, 60000); <line3> if (!sshConnection.authenticateWithPassword(_username, _password)) { <line4> throw new CloudRuntimeException(""Unable to authenticate""); <line5> } <line6> SCPClient scp = new SCPClient(sshConnection); <line7> String configScriptName = ""scripts/vm/hypervisor/ovm/configureOvm.sh""; <line8> String configScriptPath = Script.findScript("""", configScriptName); <line9> if (configScriptPath == null) { <line10> throw new CloudRuntimeException(""Unable to find "" + configScriptName); <line11> } <line12> scp.put(configScriptPath, ""/usr/bin/"", ""0755""); <line13> if (!SSHCmdHelper.sshExecuteCmd(sshConnection, ""sh /usr/bin/configureOvm.sh preSetup"")) { <line14> throw new CloudRuntimeException(""Execute configureOvm.sh preSetup failed on "" + _ip); <line15> } <line16> File tmp = new File(configScriptPath); <line17> File scriptDir = new File(tmp.getParent()); <line18> File[] scripts = scriptDir.listFiles(); <line19> for (int i = 0; i < scripts.length; i++) { <line20> File script = scripts[i]; <line21> if (script.getName().equals(""configureOvm.sh"")) { <line22> continue; <line23> } <line24> if (s_logger.isDebugEnabled()) { <line25> } <line26> scp.put(script.getPath(), s_ovsAgentPath, ""0644""); <line27> } <line28> sshConnection = SSHCmdHelper.acquireAuthorizedConnection(_ip, _username, _password); <line29> if (sshConnection == null) { <line30> throw new CloudRuntimeException( <line31> String.format( <line32> ""Cannot connect to ovm host(IP=%1$s, username=%2$s, password=%3$s"", <line33> _ip, _username, _password)); <line34> } <line35> if (!SSHCmdHelper.sshExecuteCmd(sshConnection, ""sh /usr/bin/configureOvm.sh postSetup"")) { <line36> throw new CloudRuntimeException(""Execute configureOvm.sh postSetup failed on "" + _ip); <line37> } <line38> } <line39> } <line40> "	 <line4>	No
"public class A { <line0> @Test <line1> public void testSyncCommandBasicExportImport() { <line2> try { <line3> createTestNodes(TestOne.class, 100); <line4> app.command(SyncCommand.class).execute(toMap(""mode"", ""export"", ""file"", EXPORT_FILENAME)); <line5> final Path exportFile = Paths.get(EXPORT_FILENAME); <line6> assertTrue(""Export file doesn't exist!"", Files.exists(exportFile)); <line7> cleanDatabaseAndSchema(); <line8> app.command(SyncCommand.class).execute(toMap(""mode"", ""import"", ""file"", EXPORT_FILENAME)); <line9> try (final Tx tx = app.tx()) { <line10> assertEquals(100, app.nodeQuery(TestOne.class).getAsList().size()); <line11> } <line12> Files.delete(exportFile); <line13> } catch (Exception ex) { <line14> fail(""Unexpected exception.""); <line15> } <line16> } <line17> } <line18> "	 <line14>	Yes
public class A { <line0> public void onComplete(ResultCode o) { <line1> Log_result result = new Log_result(); <line2> result.success = o; <line3> try { <line4> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line5> } catch (org.apache.thrift.transport.TTransportException e) { <line6> fb.close(); <line7> } catch (java.lang.Exception e) { <line8> onError(e); <line9> } <line10> } <line11> } <line12> 	 <line1>	No
"public class A { <line0> @Override <line1> protected void processCommittedData(FSRecordCompactionOperator.OutputMetaData outputMetaData) { <line2> try { <line3> Path path = new Path(outputMetaData.getPath()); <line4> if (fs.exists(path) == false) { <line5> return; <line6> } <line7> FSDataInputStream fsinput = fs.open(path); <line8> ObjectMetadata omd = new ObjectMetadata(); <line9> omd.setContentLength(outputMetaData.getSize()); <line10> String keyName = directoryName + Path.SEPARATOR + outputMetaData.getFileName(); <line11> PutObjectRequest request = new PutObjectRequest(bucketName, keyName, fsinput, omd); <line12> if (outputMetaData.getSize() < Integer.MAX_VALUE) { <line13> request.getRequestClientOptions().setReadLimit((int) outputMetaData.getSize()); <line14> } else { <line15> throw new RuntimeException(""PutRequestSize greater than Integer.MAX_VALUE""); <line16> } <line17> if (fs.exists(path)) { <line18> PutObjectResult result = s3client.putObject(request); <line19> } <line20> } catch (FileNotFoundException e) { <line21> } catch (IOException e) { <line22> } <line23> } <line24> } <line25> "	 <line22>	Yes
public class A { <line0> @OnShutdown <line1> public void closeIgniteCache() { <line2> if (getIgniteCache() != null) { <line3> getIgniteCache().close(); <line4> } <line5> super.closeIgnite(); <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> private void addClientToPoolGently(HClient client) { <line1> try { <line2> availableClientQueue.add(client); <line3> } catch (IllegalStateException ise) { <line4> client.close(); <line5> } <line6> } <line7> } <line8> 	 <line6>	No
public class A { <line0> @Override <line1> public void persist(AlertModel alert) { <line2> boolean accepted = _alerts.offer(alert); <line3> if (!accepted) { <line4> } <line5> } <line6> } <line7> 	 <line0>	No
public class A { <line0> @Override <line1> public void configUpdate(List<ParamFlowRule> list) { <line2> Map<String, List<ParamFlowRule>> rules = aggregateAndPrepareParamRules(list); <line3> if (rules != null) { <line4> PARAM_FLOW_RULES.clear(); <line5> PARAM_FLOW_RULES.putAll(rules); <line6> } <line7> } <line8> } <line9> 	 <line5>	No
public class A { <line0> @ShutdownHandler(phase = Phase.INBOUND_EVENT_CONNECTORS) <line1> @Override <line2> public CompletableFuture<Void> shutdownAsync() { <line3> return coordinator.stop(); <line4> } <line5> } <line6> 	 <line4>	No
public class A { <line0> public boolean finalizeUpdate() { <line1> if (newCigar == null) return false; <line2> if (newStart == -1) newStart = read.getAlignmentStart(); <line3> else if (Math.abs(newStart - read.getAlignmentStart()) > MAX_POS_MOVE_ALLOWED) { <line4> return false; <line5> } <line6> final Cigar oldCigar = read.getCigar(); <line7> final int oldStart = read.getAlignmentStart(); <line8> read.setCigar(newCigar); <line9> read.setAlignmentStart(newStart); <line10> if (realignmentProducesBadAlignment(read)) { <line11> read.setCigar(oldCigar); <line12> read.setAlignmentStart(oldStart); <line13> return false; <line14> } <line15> if (!NO_ORIGINAL_ALIGNMENT_TAGS) { <line16> read.setAttribute(ORIGINAL_CIGAR_TAG, oldCigar.toString()); <line17> if (newStart != oldStart) read.setAttribute(ORIGINAL_POSITION_TAG, oldStart); <line18> } <line19> return true; <line20> } <line21> } <line22> 	 <line21>	No
"public class A { <line0> public static void updateState(UUID taskId, TaskState state) { <line1> Connection connection = Persistence.getInstance().getConnection(); <line2> try (CallableStatement query = connection.prepareCall(""{call update_task_state(?, ?)}"")) { <line3> query.setObject(1, taskId); <line4> query.setString(2, state.toString()); <line5> query.executeQuery(); <line6> } catch (SQLException e) { <line7> } <line8> } <line9> } <line10> "	 <line6>	No
public class A { <line0> public void setRunInfo(final RunInfo runInfo) { <line1> if (log.isDebugEnabled()) { <line2> } <line3> this.runInfo = runInfo; <line4> for (final Reporter r : reporters) { <line5> r.setRunInfo(runInfo); <line6> } <line7> } <line8> } <line9> 	 <line2>	Yes
public class A { <line0> public void resumeMinorGC() { <line1> if (suspendMinorCompaction.compareAndSet(true, false)) { <line2> } <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> public static boolean isH2Connection(Settings configuration) { <line1> final String connStr; <line2> try { <line3> connStr = <line4> configuration.getConnectionString( <line5> Settings.KEYS.DB_CONNECTION_STRING, Settings.KEYS.DB_FILE_NAME); <line6> } catch (IOException ex) { <line7> return false; <line8> } <line9> return isH2Connection(connStr); <line10> } <line11> } <line12> 	 <line9>	No
public class A { <line0> public void process( <line1> ByteBuffer logsBatch, RemoteLogRecord reusableLog, IReplicationWorker worker) { <line2> while (logsBatch.hasRemaining()) { <line3> logsBatch.getInt(); <line4> reusableLog.readRemoteLog(logsBatch); <line5> reusableLog.setLogSource(LogSource.REMOTE); <line6> switch (reusableLog.getLogType()) { <line7> case LogType.UPDATE: <line8> case LogType.ENTITY_COMMIT: <line9> case LogType.FILTER: <line10> logManager.log(reusableLog); <line11> break; <line12> case LogType.JOB_COMMIT: <line13> case LogType.ABORT: <line14> RemoteLogRecord jobTerminationLog = new RemoteLogRecord(); <line15> TransactionUtil.formJobTerminateLogRecord( <line16> jobTerminationLog, <line17> reusableLog.getTxnId(), <line18> reusableLog.getLogType() == LogType.JOB_COMMIT); <line19> jobTerminationLog.setRequester(this); <line20> jobTerminationLog.setReplicationWorker(worker); <line21> jobTerminationLog.setLogSource(LogSource.REMOTE); <line22> logManager.log(jobTerminationLog); <line23> break; <line24> case LogType.FLUSH: <line25> RemoteLogRecord flushLog = new RemoteLogRecord(); <line26> TransactionUtil.formFlushLogRecord( <line27> flushLog, <line28> reusableLog.getDatasetId(), <line29> reusableLog.getResourcePartition(), <line30> reusableLog.getFlushingComponentMinId(), <line31> reusableLog.getFlushingComponentMaxId(), <line32> null); <line33> flushLog.setRequester(this); <line34> flushLog.setLogSource(LogSource.REMOTE); <line35> flushLog.setMasterLsn(reusableLog.getLSN()); <line36> logManager.log(flushLog); <line37> break; <line38> default: <line39> } <line40> } <line41> } <line42> } <line43> 	 <line19>	No
"public class A { <line0> @Override <line1> public boolean visitEnter(final HierComposite node) { <line2> if (node == null) { <line3> throw new IllegalArgumentException(""null node""); <line4> } <line5> aborted = checkControlRod(node); <line6> if (aborted) { <line7> return false; <line8> } <line9> try { <line10> List<MetaDataAndDomainData> metadata = <line11> collectionAO.findMetadataValuesForCollection(node.getAbsolutePath(), 0); <line12> metadataRollup.getMetadata().push(metadata); <line13> if (!checkIfIndexable(node, metadataRollup)) { <line14> return false; <line15> } <line16> boolean shortCircuit = visitEnterWithMetadata(node, metadataRollup); <line17> return shortCircuit; <line18> } catch (JargonException | JargonQueryException e) { <line19> throw new JargonRuntimeException(""error getting metadata"", e); <line20> } <line21> } <line22> } <line23> "	 <line13>	Yes
"public class A { <line0> @Override <line1> protected boolean operateOnPartitionedRegion( <line2> ClusterDistributionManager dm, PartitionedRegion pr, long startTime) <line3> throws CacheException, QueryException, DataLocationException, InterruptedException, <line4> IOException { <line5> final EntryEventImpl event = <line6> EntryEventImpl.create( <line7> pr, getOperation(), getKey(), null, null, false, getSender(), false, false); <line8> event.disallowOffHeapValues(); <line9> Assert.assertTrue(eventId != null); <line10> if (this.versionTag != null) { <line11> event.setVersionTag(this.versionTag); <line12> } <line13> event.setEventId(eventId); <line14> event.setPossibleDuplicate(this.posDup); <line15> event.setInvokePRCallbacks(false); <line16> event.setCausedByMessage(this); <line17> boolean sendReply = true; <line18> if (!notificationOnly) { <line19> PartitionedRegionDataStore ds = pr.getDataStore(); <line20> Assert.assertTrue( <line21> ds != null, ""This process should have storage for an item in "" + this.toString()); <line22> try { <line23> Integer bucket = Integer.valueOf(PartitionedRegionHelper.getHashKey(event)); <line24> pr.getDataView().updateEntryVersion(event); <line25> if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) { <line26> } <line27> } catch (EntryNotFoundException eee) { <line28> if (logger.isDebugEnabled()) { <line29> } <line30> sendReply(getSender(), getProcessorId(), dm, null, pr, startTime); <line31> sendReply = false; <line32> } catch (PrimaryBucketException pbe) { <line33> sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), pr, startTime); <line34> return false; <line35> } <line36> } <line37> return sendReply; <line38> } <line39> } <line40> "	 <line19>	No
public class A { <line0> @Override <line1> public void dispose() { <line2> ScheduledFuture<?> job = refreshJob; <line3> if (job != null && !job.isCancelled()) { <line4> job.cancel(true); <line5> } <line6> refreshJob = null; <line7> } <line8> } <line9> 	 <line2>	Yes
public class A { <line0> @Override <line1> public Integer getIntegerValue(String property, int defaultValue) { <line2> String strValue = getValue(property); <line3> if (StringUtils.isBlank(strValue)) { <line4> return defaultValue; <line5> } <line6> try { <line7> return Integer.valueOf(strValue.trim()); <line8> } catch (Exception e) { <line9> return defaultValue; <line10> } <line11> } <line12> } <line13> 	 <line0>	No
public class A { <line0> @Override <line1> public void addParentOfferings(final String offering, final Collection<String> parentOfferings) { <line2> CacheValidation.notNullOrEmpty(OFFERING, offering); <line3> CacheValidation.noNullOrEmptyValues(PARENT_OFFERINGS, parentOfferings); <line4> this.parentOfferingsForOfferings <line5> .computeIfAbsent(offering, createSynchronizedSet()) <line6> .addAll(parentOfferings); <line7> parentOfferings.forEach( <line8> parentOffering -> <line9> this.childOfferingsForOfferings <line10> .computeIfAbsent(parentOffering, createSynchronizedSet()) <line11> .add(offering)); <line12> } <line13> } <line14> 	 <line4>	Yes
"public class A { <line0> public void updateDefinedLocations() { <line1> synchronized (definedLocations) { <line2> int count = 0; <line3> String NAMED_LOCATION_PREFIX = ""brooklyn.location.named.""; <line4> ConfigMap namedLocationProps = <line5> mgmt.getConfig().submap(ConfigPredicates.nameStartsWith(NAMED_LOCATION_PREFIX)); <line6> for (String k : namedLocationProps.asMapWithStringKeys().keySet()) { <line7> String name = k.substring(NAMED_LOCATION_PREFIX.length()); <line8> if (!name.contains(""."")) { <line9> String spec = (String) namedLocationProps.asMapWithStringKeys().get(k); <line10> String id = Identifiers.makeRandomId(8); <line11> Map<String, Object> config = <line12> ConfigUtils.filterForPrefixAndStrip( <line13> namedLocationProps.asMapWithStringKeys(), k + "".""); <line14> definedLocations.put(id, new BasicLocationDefinition(id, name, spec, config)); <line15> count++; <line16> } <line17> } <line18> if (log.isDebugEnabled()) <line19> if (getDefinedLocationByName(""localhost"") == null <line20> && !BasicOsDetails.Factory.newLocalhostInstance().isWindows() <line21> && LocationConfigUtils.isEnabled(mgmt, ""brooklyn.location.localhost"")) { <line22> ImmutableMap<String, LocationDefinition> oldDefined = ImmutableMap.copyOf(definedLocations); <line23> definedLocations.clear(); <line24> String id = Identifiers.makeRandomId(8); <line25> definedLocations.put(id, localhost(id)); <line26> definedLocations.putAll(oldDefined); <line27> } <line28> for (RegisteredType item : <line29> mgmt.getTypeRegistry().getMatching(RegisteredTypePredicates.IS_LOCATION)) { <line30> updateDefinedLocation(item); <line31> count++; <line32> } <line33> } <line34> } <line35> } <line36> "	 <line31>	No
"public class A { <line0> private PortletURL _getEditAssetEntryURL() { <line1> boolean showEditURL = ParamUtil.getBoolean(_httpServletRequest, ""showEditURL"", true); <line2> if (!showEditURL) { <line3> return null; <line4> } <line5> try { <line6> if (!_assetRenderer.hasEditPermission(_themeDisplay.getPermissionChecker())) { <line7> return null; <line8> } <line9> String redirect = _themeDisplay.getURLCurrent(); <line10> if (Validator.isNotNull(_fullContentRedirect)) { <line11> redirect = _fullContentRedirect; <line12> } <line13> return PortletURLBuilder.create( <line14> _assetRenderer.getURLEdit( <line15> _liferayPortletRequest, <line16> _liferayPortletResponse, <line17> LiferayWindowState.NORMAL, <line18> redirect)) <line19> .setParameter( <line20> ""portletResource"", <line21> () -> { <line22> PortletDisplay portletDisplay = _themeDisplay.getPortletDisplay(); <line23> return portletDisplay.getPortletName(); <line24> }) <line25> .build(); <line26> } catch (Exception exception) { <line27> if (_log.isDebugEnabled()) { <line28> } <line29> } <line30> return null; <line31> } <line32> } <line33> "	 <line28>	Yes
public class A { <line0> public ByteBuffer encode(ByteBuffer buffer) throws EncoderException { <line1> if (buffer == null) { <line2> throw new EncoderException(I18n.err(I18n.ERR_148)); <line3> } <line4> try { <line5> buffer.put(UniversalTag.SEQUENCE.getValue()); <line6> buffer.put(TLV.getBytes(hostAddressLength)); <line7> buffer.put((byte) 0xA0); <line8> buffer.put(TLV.getBytes(addrTypeLength)); <line9> BerValue.encode(buffer, addrType.getValue()); <line10> buffer.put((byte) 0xA1); <line11> buffer.put(TLV.getBytes(addressLength)); <line12> BerValue.encode(buffer, address); <line13> } catch (BufferOverflowException boe) { <line14> throw new EncoderException(I18n.err(I18n.ERR_138), boe); <line15> } <line16> if (IS_DEBUG) { <line17> } <line18> return buffer; <line19> } <line20> } <line21> 	 <line8>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> String protocol = url.getProtocol(); <line4> String path = url.getPath(); <line5> if (URL_PROTOCOL_FILE.equals(protocol)) { <line6> findClasses(classList, packageName, path, recursive); <line7> } else if (URL_PROTOCOL_JAR.equals(protocol)) { <line8> findClasses(classList, packageName, url, recursive); <line9> } <line10> } catch (Throwable t) { <line11> } <line12> latch.countDown(); <line13> } <line14> } <line15> 	 <line6>	No
public class A { <line0> public boolean canCreateFlowManager(FileBasedFlowConfiguration configuration) { <line1> final File ovrTDir = configuration.getOverrideTempDir(); <line2> if (ovrTDir != null) { <line3> final File dir = ovrTDir; <line4> if (!dir.isAbsolute()) { <line5> return false; <line6> } <line7> if (!dir.exists() || !dir.isDirectory() || !dir.canWrite()) { <line8> return false; <line9> } <line10> } <line11> return true; <line12> } <line13> } <line14> 	 <line11>	No
public class A { <line0> @Override <line1> public void runTask() { <line2> try { <line3> FeedUpdater updater = new SingleThreadedFeedUpdater(); <line4> updater.updateSubscriptions(); <line5> } catch (Exception e) { <line6> } finally { <line7> WebloggerFactory.getWeblogger().release(); <line8> } <line9> } <line10> } <line11> 	 <line6>	Yes
"public class A { <line0> public JobProcessStatus getJobProcessStatus(int processId) { <line1> try { <line2> MapSqlParameterSource params = new MapSqlParameterSource(); <line3> params.addValue(""processId"", processId); <line4> List<JobProcessStatus> jobProcessStatusList = <line5> baseDao.geoApiNamedJbdcTemaplate.query( <line6> JobProcessQuery.GET_JOB_PROCESS_STATUS.getSql(baseDao.getJobSchema()), <line7> params, <line8> statusHandler); <line9> if (jobProcessStatusList != null && jobProcessStatusList.get(0) != null) { <line10> return jobProcessStatusList.get(0); <line11> } <line12> } catch (Exception ex) { <line13> } <line14> return null; <line15> } <line16> } <line17> "	 <line10>	No
"public class A { <line0> private TupleWriter getMapWriter(String mapName, TupleWriter rowWriter) { <line1> int index = rowWriter.tupleSchema().index(mapName); <line2> if (index == -1) { <line3> String tempFieldName = mapName + ""-"" + currentNestingLevel; <line4> XMLMap mapObject = nestedMapCollection.get(tempFieldName); <line5> if (mapObject != null) { <line6> return mapObject.getMapWriter(); <line7> } <line8> index = <line9> rowWriter.addColumn( <line10> SchemaBuilder.columnSchema(mapName, MinorType.MAP, DataMode.REQUIRED)); <line11> nestedMapCollection.put(tempFieldName, new XMLMap(mapName, rowWriter.tuple(index))); <line12> } <line13> return rowWriter.tuple(index); <line14> } <line15> } <line16> "	 <line14>	No
"public class A { <line0> private StringBuilder addFlowFileProcessorFingerprint( <line1> final StringBuilder builder, final Element processorElem) throws FingerprintException { <line2> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""id"")); <line3> appendFirstValue( <line4> builder, DomUtils.getChildNodesByTagName(processorElem, ""versionedComponentId"")); <line5> final NodeList childNodes = DomUtils.getChildNodesByTagName(processorElem, ""class""); <line6> final String className = childNodes.item(0).getTextContent(); <line7> appendFirstValue(builder, childNodes); <line8> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""annotationData"")); <line9> final BundleDTO bundle = <line10> FlowFromDOMFactory.getBundle(DomUtils.getChild(processorElem, ""bundle"")); <line11> addBundleFingerprint(builder, bundle); <line12> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""maxConcurrentTasks"")); <line13> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""schedulingPeriod"")); <line14> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""penalizationPeriod"")); <line15> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""yieldPeriod"")); <line16> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""bulletinLevel"")); <line17> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""lossTolerant"")); <line18> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""schedulingStrategy"")); <line19> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""executionNode"")); <line20> appendFirstValue(builder, DomUtils.getChildNodesByTagName(processorElem, ""runDurationNanos"")); <line21> final BundleCoordinate coordinate = getCoordinate(className, bundle); <line22> final ConfigurableComponent configurableComponent = <line23> extensionManager.getTempComponent(className, coordinate); <line24> if (configurableComponent == null) { <line25> } <line26> final NodeList propertyElems = DomUtils.getChildNodesByTagName(processorElem, ""property""); <line27> final List<Element> sortedPropertyElems = <line28> sortElements(propertyElems, getProcessorPropertiesComparator()); <line29> for (final Element propertyElem : sortedPropertyElems) { <line30> final String propName = <line31> DomUtils.getChildElementsByTagName(propertyElem, ""name"").get(0).getTextContent(); <line32> String propValue = <line33> getFirstValue(DomUtils.getChildNodesByTagName(propertyElem, ""value""), null); <line34> addPropertyFingerprint(builder, configurableComponent, propName, propValue); <line35> } <line36> final NodeList autoTerminateElems = <line37> DomUtils.getChildNodesByTagName(processorElem, ""autoTerminatedRelationship""); <line38> final List<Element> sortedAutoTerminateElems = <line39> sortElements(autoTerminateElems, getElementTextComparator()); <line40> for (final Element autoTerminateElem : sortedAutoTerminateElems) { <line41> builder.append(autoTerminateElem.getTextContent()); <line42> } <line43> return builder; <line44> } <line45> } <line46> "	 <line25>	Yes
public class A { <line0> public void replaceDirectory( <line1> final File oldIndexDir, final File newIndexDir, final boolean destroyOldIndex) { <line2> boolean replaced = false; <line3> synchronized (this) { <line4> for (final Map.Entry<Long, List<IndexLocation>> entry : indexLocationByTimestamp.entrySet()) { <line5> final List<IndexLocation> locations = entry.getValue(); <line6> final ListIterator<IndexLocation> itr = locations.listIterator(); <line7> while (itr.hasNext()) { <line8> final IndexLocation location = itr.next(); <line9> if (location.getIndexDirectory().equals(oldIndexDir)) { <line10> final IndexLocation updatedLocation = <line11> new IndexLocation( <line12> newIndexDir, location.getIndexStartTimestamp(), location.getPartitionName()); <line13> itr.set(updatedLocation); <line14> replaced = true; <line15> } <line16> } <line17> } <line18> } <line19> if (!replaced) { <line20> insertIndexDirectory(newIndexDir); <line21> } <line22> if (destroyOldIndex) { <line23> try { <line24> FileUtils.deleteFile(oldIndexDir, true); <line25> } catch (IOException e) { <line26> } <line27> } <line28> removeDirectory(oldIndexDir); <line29> } <line30> } <line31> 	 <line16>	No
public class A { <line0> public void closeHandles() { <line1> if (logger.isDebugEnabled()) { <line2> } <line3> if (null != handle) { <line4> closeLedger(handle); <line5> handle = null; <line6> } <line7> if (null != readHandle) { <line8> closeLedger(readHandle); <line9> readHandle = null; <line10> } <line11> } <line12> } <line13> 	 <line7>	No
public class A { <line0> public static String compressBBSImage(String oldFilePath) { <line1> BitmapFactory.Options options = BitmapUtil.INSTANCE.getImageOptions(oldFilePath); <line2> int width = options.outWidth; <line3> int height = options.outHeight; <line4> int showWidth = width; <line5> int showHeight = height; <line6> if (width > O2.INSTANCE.getBBS_IMAGE_MAX_WIDTH()) { <line7> double lv = width / O2.INSTANCE.getBBS_IMAGE_MAX_WIDTH(); <line8> showHeight = (int) (height / lv); <line9> showWidth = O2.INSTANCE.getBBS_IMAGE_MAX_WIDTH(); <line10> } <line11> Bitmap bitmap = BitmapUtil.INSTANCE.getFitSampleBitmap(oldFilePath, showWidth, showHeight); <line12> String filePath = FileExtensionHelper.generateBBSTempFilePath(); <line13> SDCardHelper.INSTANCE.bitmapToPNGFile(bitmap, filePath); <line14> return filePath; <line15> } <line16> } <line17> 	 <line13>	Yes
public class A { <line0> public void sendMessage( <line1> SmtpServerConfig smtpServerConfig, MimeMessage message, Address[] recipients) <line2> throws MessagingException { <line3> SmtpConnectionPoolEntry poolEntry = leaseConnection(smtpServerConfig); <line4> try { <line5> poolEntry.sendMessage(message, recipients); <line6> } catch (MessagingException e) { <line7> if (!isConnectionFailure(e)) { <line8> throw e; <line9> } <line10> poolEntry = exchangeConnection(poolEntry); <line11> try { <line12> poolEntry.sendMessage(message, recipients); <line13> } catch (RuntimeException | MessagingException e1) { <line14> throw e1; <line15> } <line16> } finally { <line17> releaseConnection(poolEntry); <line18> } <line19> } <line20> } <line21> 	 <line10>	Yes
public class A { <line0> @Override <line1> public void close() throws Exception { <line2> try { <line3> if (started) { <line4> context.close(); <line5> if (enumerator != null) { <line6> enumerator.close(); <line7> } <line8> } <line9> } finally { <line10> coordinatorExecutor.shutdownNow(); <line11> coordinatorExecutor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS); <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
"public class A { <line0> protected void loadDefaultConfigurationFromClasspath(String defaultConfigFile) { <line1> try { <line2> configurationUrl = Config.class.getClassLoader().getResource(defaultConfigFile); <line3> if (configurationUrl == null) { <line4> throw new HazelcastException( <line5> String.format( <line6> ""Could not find '%s' in the classpath! This may be due to a "" <line7> + ""wrong-packaged or corrupted jar file."", <line8> defaultConfigFile)); <line9> } <line10> in = Config.class.getClassLoader().getResourceAsStream(defaultConfigFile); <line11> if (in == null) { <line12> throw new HazelcastException( <line13> String.format(""Could not load '%s' from the classpath"", defaultConfigFile)); <line14> } <line15> } catch (RuntimeException e) { <line16> throw new HazelcastException(e); <line17> } <line18> } <line19> } <line20> "	 <line4>	No
public class A { <line0> public final List findByRowKeys( <line1> Class entityClass, <line2> List<String> relationNames, <line3> boolean isWrapReq, <line4> EntityMetadata metadata, <line5> Object... rowIds) { <line6> List entities = null; <line7> MetamodelImpl metaModel = <line8> (MetamodelImpl) <line9> kunderaMetadata.getApplicationMetadata().getMetamodel(metadata.getPersistenceUnit()); <line10> EntityType entityType = metaModel.entity(metadata.getEntityClazz()); <line11> List<AbstractManagedType> subManagedType = <line12> ((AbstractManagedType) entityType).getSubManagedType(); <line13> try { <line14> if (!subManagedType.isEmpty()) { <line15> for (AbstractManagedType subEntity : subManagedType) { <line16> EntityMetadata subEntityMetadata = <line17> KunderaMetadataManager.getEntityMetadata(kunderaMetadata, subEntity.getJavaType()); <line18> entities = <line19> getDataHandler() <line20> .fromThriftRow( <line21> entityClass, <line22> subEntityMetadata, <line23> subEntityMetadata.getRelationNames(), <line24> isWrapReq, <line25> getConsistencyLevel(), <line26> rowIds); <line27> if (entities != null && !entities.isEmpty()) { <line28> break; <line29> } <line30> } <line31> } else { <line32> entities = <line33> getDataHandler() <line34> .fromThriftRow( <line35> entityClass, metadata, relationNames, isWrapReq, getConsistencyLevel(), rowIds); <line36> } <line37> } catch (Exception e) { <line38> throw new KunderaException(e); <line39> } <line40> return entities; <line41> } <line42> } <line43> 	 <line38>	Yes
"public class A { <line0> private InvitationParam getInvitationFromJson(String jsonInvitation) <line1> throws WrongArgumentException { <line2> ObjectNode invNode = JsonUtil.parse(jsonInvitation); <line3> JsonNode itype = invNode.get(""type""); <line4> InvitationType type = null; <line5> if (itype == null) { <line6> type = InvitationType.REGISTRATION; <line7> } else { <line8> type = InvitationType.valueOf(invNode.get(""type"").asText()); <line9> } <line10> if (type.equals(InvitationType.REGISTRATION)) { <line11> return new RegistrationInvitationParam(invNode); <line12> } else { <line13> return new EnquiryInvitationParam(invNode); <line14> } <line15> } <line16> } <line17> "	 <line13>	No
"public class A { <line0> @VisibleForTesting <line1> protected void scheduledTask() { <line2> int totalCount, successCount, failCount; <line3> List<EventModel> events = alertEventService.getLastHourAlertEvent(); <line4> totalCount = events.size(); <line5> Pair<Integer, Integer> successAndFail = statistics(events); <line6> successCount = successAndFail.getKey(); <line7> failCount = successAndFail.getValue(); <line8> EventMonitor.DEFAULT.logEvent(EMAIL_SERVICE_CAT_TYPE, ""total sent out"", totalCount); <line9> EventMonitor.DEFAULT.logEvent(EMAIL_SERVICE_CAT_TYPE, ""success sent out"", successCount); <line10> EventMonitor.DEFAULT.logEvent(EMAIL_SERVICE_CAT_TYPE, ""fail sent out"", failCount); <line11> } <line12> } <line13> "	 <line6>	No
"public class A { <line0> private void initializeSMSChannel() { <line1> try { <line2> if (!config.isSet(UnityServerConfiguration.SMS_CONF)) { <line3> return; <line4> } <line5> File smsCfgFile = config.getFileValue(UnityServerConfiguration.SMS_CONF, false); <line6> String smsCfg = FileUtils.readFileToString(smsCfgFile, Charset.defaultCharset()); <line7> NotificationChannel smsCh = <line8> new NotificationChannel( <line9> UnityServerConfiguration.DEFAULT_SMS_CHANNEL, <line10> ""Default SMS channel"", <line11> smsCfg, <line12> SMSFacility.NAME); <line13> notManagement.addNotificationChannel(smsCh); <line14> } catch (Exception e) { <line15> throw new ConfigurationException(""Can't load SMS notification channel configuration"", e); <line16> } <line17> } <line18> } <line19> "	 <line17>	No
"public class A { <line0> private void warmUp() throws IOException { <line1> List<Thread> threads = new ArrayList<Thread>(); <line2> for (int i = 0; i < configurator.getNumConcurrentQueries(); ++i) { <line3> threads.add(new Thread(new WarmupRunnable(), ""Warmup Thread #"" + i)); <line4> } <line5> HankTimer timer = new HankTimer(); <line6> for (Thread thread : threads) { <line7> thread.start(); <line8> } <line9> for (Thread thread : threads) { <line10> try { <line11> thread.join(); <line12> } catch (InterruptedException e) { <line13> throw new IOException(""Failed to warm up data server"", e); <line14> } <line15> } <line16> long warmupDurationMs = timer.getDurationMs(); <line17> } <line18> } <line19> "	 <line17>	Yes
public class A { <line0> private AuthzStatus isAccessAllowed( <line1> INode inode, <line2> INodeAttributes inodeAttribs, <line3> String path, <line4> FsAction access, <line5> AuthzContext context) { <line6> AuthzStatus ret = null; <line7> String pathOwner = inodeAttribs != null ? inodeAttribs.getUserName() : null; <line8> if (pathOwner == null && inode != null) { <line9> pathOwner = inode.getUserName(); <line10> } <line11> if (RangerHadoopConstants.HDFS_ROOT_FOLDER_PATH_ALT.equals(path)) { <line12> path = HDFS_ROOT_FOLDER_PATH; <line13> } <line14> if (LOG.isDebugEnabled()) { <line15> } <line16> Set<String> accessTypes = access2ActionListMapper.get(access); <line17> if (accessTypes == null) { <line18> accessTypes = access2ActionListMapper.get(FsAction.NONE); <line19> } <line20> for (String accessType : accessTypes) { <line21> RangerHdfsAccessRequest request = <line22> new RangerHdfsAccessRequest( <line23> inode, <line24> path, <line25> pathOwner, <line26> access, <line27> accessType, <line28> context.operationName, <line29> context.user, <line30> context.userGroups); <line31> Map<String, Object> requestContext = request.getContext(); <line32> requestContext.put(RangerAccessRequestUtil.KEY_CONTEXT_ACCESSTYPES, accessTypes); <line33> RangerAccessResult result = context.plugin.isAccessAllowed(request, context.auditHandler); <line34> context.saveResult(result); <line35> if (result == null || !result.getIsAccessDetermined()) { <line36> ret = AuthzStatus.NOT_DETERMINED; <line37> } else if (!result.getIsAllowed()) { <line38> ret = AuthzStatus.DENY; <line39> break; <line40> } else { <line41> if (!AuthzStatus.NOT_DETERMINED.equals(ret)) { <line42> ret = AuthzStatus.ALLOW; <line43> } <line44> } <line45> } <line46> if (ret == null) { <line47> ret = AuthzStatus.NOT_DETERMINED; <line48> } <line49> if (LOG.isDebugEnabled()) { <line50> } <line51> return ret; <line52> } <line53> } <line54> 	 <line0>	No
"public class A { <line0> private Iterable<DiscoveryStrategy> loadDiscoveryStrategies(DiscoveryServiceSettings settings) { <line1> ClassLoader configClassLoader = settings.getConfigClassLoader(); <line2> try { <line3> Collection<DiscoveryStrategyConfig> discoveryStrategyConfigs = <line4> new ArrayList<DiscoveryStrategyConfig>(settings.getAllDiscoveryConfigs()); <line5> List<DiscoveryStrategyFactory> factories = <line6> collectFactories(discoveryStrategyConfigs, configClassLoader); <line7> List<DiscoveryStrategy> discoveryStrategies = new ArrayList<DiscoveryStrategy>(); <line8> for (DiscoveryStrategyConfig config : discoveryStrategyConfigs) { <line9> DiscoveryStrategy discoveryStrategy = buildDiscoveryStrategy(config, factories); <line10> discoveryStrategies.add(discoveryStrategy); <line11> } <line12> if (discoveryStrategies.isEmpty() && settings.isAutoDetectionEnabled()) { <line13> logger.fine(""Discovery auto-detection enabled, looking for available discovery strategies""); <line14> DiscoveryStrategyFactory autoDetectedFactory = detectDiscoveryStrategyFactory(factories); <line15> if (autoDetectedFactory != null) { <line16> discoveryStrategies.add( <line17> autoDetectedFactory.newDiscoveryStrategy( <line18> discoveryNode, logger, Collections.emptyMap())); <line19> } else { <line20> } <line21> } <line22> return discoveryStrategies; <line23> } catch (Exception e) { <line24> if (e instanceof ValidationException) { <line25> throw new InvalidConfigurationException(""Invalid configuration"", e); <line26> } else { <line27> throw new RuntimeException(""Failed to configure discovery strategies"", e); <line28> } <line29> } <line30> } <line31> } <line32> "	 <line9>	No
public class A { <line0> private synchronized void sendPingMessage() { <line1> try { <line2> Objects.requireNonNull(session).getRemote().sendPing(ByteBuffer.wrap(PING_PAYLOAD)); <line3> } catch (IOException e) { <line4> } <line5> } <line6> } <line7> 	 <line2>	No
public class A { <line0> @Override <line1> public boolean isMembershipAllowed(long userId, long groupId) { <line2> try { <line3> Group group = GroupLocalServiceUtil.getGroup(groupId); <line4> if (group.isLimitedToParentSiteMembers() <line5> && !GroupLocalServiceUtil.hasUserGroup(userId, group.getParentGroupId(), false)) { <line6> return false; <line7> } <line8> } catch (Exception exception) { <line9> } <line10> return true; <line11> } <line12> } <line13> 	 <line9>	Yes
"public class A { <line0> @Override <line1> public CardImageUrls generateTokenUrl(CardDownloadData card) throws IOException { <line2> String name = card.getName(); <line3> String set = card.getSet(); <line4> int type = card.getType(); <line5> if (name.toLowerCase(Locale.ENGLISH).contains(""emblem"")) { <line6> name = getEmblemName(name); <line7> } <line8> if (SET_NAMES_REPLACEMENT.containsKey(set.toLowerCase(Locale.ENGLISH))) { <line9> set = SET_NAMES_REPLACEMENT.get(set.toLowerCase(Locale.ENGLISH)); <line10> } <line11> if (tokensData.isEmpty()) { <line12> return null; <line13> } <line14> String key = set + ""/"" + name; <line15> List<TokenData> list = tokensData.get(key); <line16> if (list == null) { <line17> return null; <line18> } <line19> TokenData tokenData; <line20> if (type == 0) { <line21> tokenData = list.get(0); <line22> } else { <line23> if (type > list.size()) { <line24> return null; <line25> } <line26> tokenData = list.get(card.getType() - 1); <line27> } <line28> String url = <line29> ""https://tokens.mtg.onl/tokens/"" <line30> + tokenData.getExpansionSetCode().trim() <line31> + '_' <line32> + tokenData.getNumber().trim() <line33> + '-' <line34> + tokenData.getName().trim() <line35> + "".jpg""; <line36> url = url.replace(' ', '-'); <line37> return new CardImageUrls(url); <line38> } <line39> } <line40> "	 <line12>	Yes
public class A { <line0> private void testBookieRecoveryToRandomBookies(boolean async, int numBookiesToKill) <line1> throws Exception { <line2> int numLedgers = 3; <line3> List<LedgerHandle> lhs = createLedgers(numLedgers, 3, 3); <line4> int numMsgs = 10; <line5> writeEntriestoLedgers(numMsgs, 0, lhs); <line6> Set<BookieSocketAddress> bookiesSrc = new HashSet<BookieSocketAddress>(); <line7> for (int i = 0; i < numBookiesToKill; i++) { <line8> int portToKill = bsConfs.get(0).getBookiePort(); <line9> bs.get(0).shutdown(); <line10> bs.remove(0); <line11> BookieSocketAddress bookieToKill = <line12> new BookieSocketAddress(InetAddress.getLocalHost().getHostAddress(), portToKill); <line13> bookiesSrc.add(bookieToKill); <line14> } <line15> for (int i = 0; i < 3; i++) { <line16> startNewBookie(); <line17> } <line18> writeEntriestoLedgers(numMsgs, 10, lhs); <line19> if (async) { <line20> sync.value = false; <line21> bkAdmin.asyncRecoverBookieData(bookiesSrc, bookieRecoverCb, sync); <line22> synchronized (sync) { <line23> while (sync.value == false) { <line24> sync.wait(); <line25> } <line26> assertTrue(bookieRecoverCb.success); <line27> } <line28> } else { <line29> bkAdmin.recoverBookieData(bookiesSrc); <line30> } <line31> verifyLedgerMetadata(lhs, bookiesSrc); <line32> verifyRecoveredLedgers(lhs, 2 * numMsgs - 1); <line33> } <line34> } <line35> 	 <line12>	No
public class A { <line0> public void fixed(String what, String reason) { <line1> } <line2> } <line3> 	 <line2>	No
"public class A { <line0> @Override <line1> public void execute(FunctionContext context) { <line2> Cache cache = CacheFactory.getAnyInstance(); <line3> TXId txId = null; <line4> try { <line5> txId = (TXId) context.getArguments(); <line6> } catch (ClassCastException e) { <line7> throw e; <line8> } <line9> DistributedMember member = txId.getMemberId(); <line10> Boolean result = false; <line11> final boolean isDebugEnabled = logger.isDebugEnabled(); <line12> if (cache.getDistributedSystem().getDistributedMember().equals(member)) { <line13> if (isDebugEnabled) { <line14> } <line15> CacheTransactionManager txMgr = cache.getCacheTransactionManager(); <line16> if (txMgr.tryResume(txId)) { <line17> if (isDebugEnabled) { <line18> } <line19> txMgr.commit(); <line20> result = true; <line21> } <line22> } else { <line23> ArrayList args = new ArrayList(); <line24> args.add(txId); <line25> args.add(NestedTransactionFunction.COMMIT); <line26> Execution ex = FunctionService.onMember(member).setArguments(args); <line27> if (isDebugEnabled) { <line28> } <line29> try { <line30> List list = (List) ex.execute(new NestedTransactionFunction()).getResult(); <line31> result = (Boolean) list.get(0); <line32> } catch (FunctionException fe) { <line33> if (fe.getCause() instanceof FunctionInvocationTargetException) { <line34> throw new TransactionDataNodeHasDepartedException(""Could not commit on member:"" + member); <line35> } else { <line36> throw fe; <line37> } <line38> } <line39> } <line40> if (isDebugEnabled) { <line41> } <line42> context.getResultSender().lastResult(result); <line43> } <line44> } <line45> "	 <line35>	No
"public class A { <line0> private void linkReleaseToProject(ResourceRequest request, ResourceResponse response) <line1> throws IOException { <line2> User user = UserCacheHolder.getUserFromRequest(request); <line3> String projectId = request.getParameter(PortalConstants.PROJECT_ID); <line4> String releaseId = request.getParameter(PortalConstants.RELEASE_ID); <line5> try { <line6> ProjectService.Iface client = thriftClients.makeProjectClient(); <line7> Project project = client.getProjectByIdForEdit(projectId, user); <line8> project.putToReleaseIdToUsage( <line9> releaseId, <line10> new ProjectReleaseRelationship(ReleaseRelationship.CONTAINED, MainlineState.OPEN)); <line11> client.updateProject(project, user); <line12> JSONObject jsonObject = JSONFactoryUtil.createJSONObject(); <line13> jsonObject.put(""success"", true); <line14> jsonObject.put(""releaseId"", releaseId); <line15> jsonObject.put(""projectId"", projectId); <line16> writeJSON(request, response, jsonObject); <line17> } catch (TException exception) { <line18> response.setProperty(ResourceResponse.HTTP_STATUS_CODE, ""500""); <line19> } <line20> } <line21> } <line22> "	 <line18>	Yes
public class A { <line0> public static void close(Closeable closeable, String name, Logger log) { <line1> if (closeable != null) { <line2> try { <line3> closeable.close(); <line4> } catch (IOException e) { <line5> if (log == null) { <line6> log = LOG; <line7> } <line8> if (name != null) { <line9> } else { <line10> } <line11> } <line12> } <line13> } <line14> } <line15> 	 <line4>	No
"public class A { <line0> private void initCatalog() { <line1> try (InputStream input = <line2> CamelKafkaConnectorCatalog.class.getResourceAsStream( <line3> ""/"" + DESCRIPTORS_DIR + ""/"" + CONNECTORS_PROPERTIES)) { <line4> BufferedReader reader = new BufferedReader(new InputStreamReader(input)); <line5> while (reader.ready()) { <line6> String connector = reader.readLine(); <line7> if (connector.equalsIgnoreCase(""camel-coap-tcp-source"")) { <line8> connectorsName.add(""camel-coap+tcp-source""); <line9> } else if (connector.equalsIgnoreCase(""camel-coaps-tcp-source"")) { <line10> connectorsName.add(""camel-coaps+tcp-source""); <line11> } else if (connector.equalsIgnoreCase(""camel-coaps-tcp-sink"")) { <line12> connectorsName.add(""camel-coaps+tcp-sink""); <line13> } else if (connector.equalsIgnoreCase(""camel-coap-tcp-sink"")) { <line14> connectorsName.add(""camel-coap+tcp-sink""); <line15> } else { <line16> connectorsName.add(connector); <line17> } <line18> } <line19> } catch (FileNotFoundException e) { <line20> } catch (IOException e) { <line21> } <line22> } <line23> } <line24> "	 <line21>	Yes
"public class A { <line0> @Override <line1> public Map<String, Object> getLogsByGroupId(Integer groupId, Integer pageNo, Integer pageSize) { <line2> try { <line3> Map<String, Object> returnMap = new HashMap<>(); <line4> Page<OperationLog> page = PageHelper.startPage(pageNo, pageSize); <line5> operationLogDao.selectLogsByOperationGroupId(groupId); <line6> returnMap.put(""logData"", page); <line7> returnMap.put(""totalCount"", page.getTotal()); <line8> returnMap.put(""totalPage"", page.getPages()); <line9> return returnMap; <line10> } catch (Exception e) { <line11> return null; <line12> } <line13> } <line14> } <line15> "	 <line11>	Yes
"public class A { <line0> @Test <line1> public void testLogInitialize() throws Exception { <line2> log = new JavaLogger(); <line3> ((JavaLogger) log).setWorkDirectory(U.defaultWorkDirectory()); <line4> ((LoggerNodeIdAware) log).setNodeId(UUID.fromString(""00000000-1111-2222-3333-444444444444"")); <line5> System.out.println(log.toString()); <line6> assertTrue(log.toString().contains(""JavaLogger"")); <line7> assertTrue(log.toString().contains(JavaLogger.DFLT_CONFIG_PATH)); <line8> assert log.isInfoEnabled(); <line9> log.warning(""This is 'warning' message.""); <line10> log.warning(""This is 'warning' message."", new Exception(""It's a test warning exception"")); <line11> assert log.getLogger(JavaLoggerTest.class.getName()) instanceof JavaLogger; <line12> assert log.fileName() != null; <line13> assert !log.fileName().contains(""%""); <line14> } <line15> } <line16> "	 <line12>	No
public class A { <line0> public void registerLoggers() { <line1> for (EventLogger logger : loggers) { <line2> eventManager.addObserver(logger); <line3> } <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void start(Map<String, String> props) { <line2> try { <line3> config = new CosmosDBSourceConfig(props); <line4> } catch (ConfigException e) { <line5> throw new ConnectException( <line6> ""Couldn't start CosmosDBSourceConnector due to configuration error"", e); <line7> } <line8> } <line9> } <line10> "	 <line1>	No
"public class A { <line0> private void saveResults(Map data, String name, String path) { <line1> try { <line2> Gson gson = new GsonBuilder().setPrettyPrinting().create(); <line3> String json = gson.toJson(data); <line4> Date timestamp = new Date(System.currentTimeMillis()); <line5> Path logPath = Paths.get(path, ""timeMeasuring""); <line6> Files.createDirectories(logPath); <line7> Files.write( <line8> Paths.get( <line9> logPath.toString(), String.format(""%s-%s.json"", name, dateFormat.format(timestamp))), <line10> json.getBytes(Charset.forName(""UTF-8""))); <line11> } catch (Exception ex) { <line12> } <line13> } <line14> } <line15> "	 <line9>	No
"public class A { <line0> @Test <line1> public void parseTestAbbreviation_Array() throws IOException { <line2> BsonValue c = new BsonBoolean(true); <line3> BsonDocument document = <line4> new BsonDocument() <line5> .append(""double"", new BsonDouble(12.3)) <line6> .append( <line7> ""arrayInt"", <line8> new BsonArray( <line9> Arrays.asList( <line10> c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, <line11> c, c))); <line12> BasicDBObject query = new BasicDBObject(); <line13> query.put(""ComplexBson"", document); <line14> NormalizedBson stringStringValue = MongoUtil.parseBson(new Object[] {query}, true); <line15> List list = <line16> objectMapper.readValue(""["" + stringStringValue.getNormalizedBson() + ""]"", List.class); <line17> Assert.assertEquals(list.size(), 1); <line18> Map<String, ?> query1Map = (Map<String, ?>) list.get(0); <line19> checkValue(query1Map); <line20> } <line21> } <line22> "	 <line15>	Yes
public class A { <line0> @Override <line1> public void handleEvent(Event event) { <line2> if (event.getTopic().equals(RawSocketTransport.ERROR_EVENT_TOPIC)) { <line3> Exception error = (Exception) event.getProperty(RawSocketTransport.ERROR_PROPERTY_NAME); <line4> if (error != null) { <line5> errorHappened(error); <line6> } <line7> } else if (event.getTopic().equals(CMD_RCVD_EVENT_TOPIC)) { <line8> String response = (String) event.getProperty(COMMAND_PROPERTY_NAME); <line9> if (response != null) { <line10> commandReceived(response); <line11> } <line12> } <line13> } <line14> } <line15> 	 <line2>	Yes
"public class A { <line0> public String readInputResource(String path) { <line1> try { <line2> File inputFile = getInputResourcesTestDir().toPath().resolve(path).toFile(); <line3> if (!inputFile.exists()) { <line4> if (shouldCreateInputTestFiles()) { <line5> inputFile.getParentFile().mkdirs(); <line6> Files.write(""<replace with test data>"", inputFile, StandardCharsets.UTF_8); <line7> } <line8> } <line9> return Files.toString(inputFile, StandardCharsets.UTF_8); <line10> } catch (IOException e) { <line11> throw new UncheckedIOException(e); <line12> } <line13> } <line14> } <line15> "	 <line4>	Yes
"public class A { <line0> public static void main(String[] args) throws MalformedURLException { <line1> Utils.configureLogger(); <line2> System.setProperty(""apple.laf.useScreenMenuBar"", ""true""); <line3> System.setProperty(""com.apple.mrj.application.apple.menu.about.name"", ""RipMe""); <line4> logger = Logger.getLogger(App.class); <line5> if (args.length > 0) { <line6> handleArguments(args); <line7> } else { <line8> MainWindow mw = new MainWindow(); <line9> SwingUtilities.invokeLater(mw); <line10> } <line11> } <line12> } <line13> "	 <line11>	No
"public class A { <line0> public String inline() throws Exception { <line1> Date startTime = new Date(); <line2> String path = Attach.DATA_REAL_PATH + ""/"" + this.f; <line3> String extension = StringUtils.getFilenameExtension(path); <line4> if (this.n == null || this.n.length() == 0) this.n = StringUtils.getFilename(this.f); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> if (isConvertFile(extension)) { <line8> if (this.from == null || this.from.length() == 0) this.from = extension; <line9> if (this.to == null || this.to.length() == 0) { <line10> this.to = getText(""jodconverter.to.extension""); <line11> } <line12> this.inputStream = OfficeUtils.convert(this.f, this.to, true); <line13> this.contentType = AttachUtils.getContentType(this.to); <line14> this.contentLength = this.inputStream.available(); <line15> this.filename = <line16> WebUtils.encodeFileName( <line17> ServletActionContext.getRequest(), this.n == null ? ""bc"" : this.n + ""."" + this.to); <line18> if (logger.isDebugEnabled()) { <line19> } <line20> } else { <line21> if (ct != null && ct.length() > 0) { <line22> this.contentType = this.ct; <line23> } else { <line24> this.contentType = AttachUtils.getContentType(extension); <line25> } <line26> this.filename = WebUtils.encodeFileName(ServletActionContext.getRequest(), this.n); <line27> File file = new File(path); <line28> this.contentLength = file.length(); <line29> this.inputStream = new FileInputStream(file); <line30> } <line31> saveAttachHistory(AttachHistory.TYPE_INLINE, this.f, extension); <line32> return SUCCESS; <line33> } <line34> } <line35> "	 <line5>	No
public class A { <line0> @Override <line1> public Object convertFromString(Map context, String[] values, Class toClass) { <line2> if (values == null || values.length == 0 || values[0] == null || values[0].isEmpty()) { <line3> return null; <line4> } else { <line5> Calendar c = Calendar.getInstance(); <line6> c.setTimeInMillis(f.parseDateTime(values[0]).getMillis()); <line7> return c; <line8> } <line9> } <line10> } <line11> 	 <line2>	Yes
"public class A { <line0> @Bean(name = BEAN_NAME_EMBEDDED_MYSQL, destroyMethod = ""stop"") <line1> public MySQLContainer mysql(ConfigurableEnvironment environment, MySQLProperties properties) { <line2> MySQLContainer mysql = <line3> new MySQLContainer<>(properties.dockerImage) <line4> .withEnv(""MYSQL_ALLOW_EMPTY_PASSWORD"", ""yes"") <line5> .withUsername(properties.getUser()) <line6> .withDatabaseName(properties.getDatabase()) <line7> .withPassword(properties.getPassword()) <line8> .withCommand( <line9> ""--character-set-server="" + properties.getEncoding(), <line10> ""--collation-server="" + properties.getCollation()) <line11> .withExposedPorts(properties.port) <line12> .withCreateContainerCmdModifier( <line13> cmd -> cmd.getHostConfig().withCapAdd(Capability.NET_ADMIN)) <line14> .withInitScript(properties.initScriptPath); <line15> mysql = (MySQLContainer) configureCommonsAndStart(mysql, properties, log); <line16> registerMySQLEnvironment(mysql, environment, properties); <line17> return mysql; <line18> } <line19> } <line20> "	 <line19>	No
public class A { <line0> private Collection<JobConfig> removeDuplicateByJobName(Set<JobConfig> streamChangedJobs) { <line1> Map<String, JobConfig> streamChangedJobsMap = new HashMap<>(); <line2> for (JobConfig streamChangedJob : streamChangedJobs) { <line3> String jobName = streamChangedJob.getJobName(); <line4> if (streamChangedJobsMap.containsKey(jobName)) { <line5> } else { <line6> streamChangedJobsMap.put(jobName, streamChangedJob); <line7> } <line8> } <line9> return streamChangedJobsMap.values(); <line10> } <line11> } <line12> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public JSONObject getFirstPage() throws IOException { <line2> URL apiURL = new URL(baseURL + ""&consumer_key="" + CONSUMER_KEY); <line3> JSONObject json = Http.url(apiURL).getJSON(); <line4> if (baseURL.contains(""/galleries?"")) { <line5> JSONObject result = new JSONObject(); <line6> result.put(""photos"", new JSONArray()); <line7> JSONArray jsonGalleries = json.getJSONArray(""galleries""); <line8> for (int i = 0; i < jsonGalleries.length(); i++) { <line9> if (i > 0) { <line10> sleep(500); <line11> } <line12> JSONObject jsonGallery = jsonGalleries.getJSONObject(i); <line13> long galleryID = jsonGallery.getLong(""id""); <line14> String userID = Long.toString(jsonGallery.getLong(""user_id"")); <line15> String blogURL = <line16> ""https://api.500px.com/v1/users/"" <line17> + userID <line18> + ""/galleries/"" <line19> + galleryID <line20> + ""/items"" <line21> + ""?rpp=100"" <line22> + ""&image_size=5"" <line23> + ""&consumer_key="" <line24> + CONSUMER_KEY; <line25> logger.info(""Loading "" + blogURL); <line26> sendUpdate(STATUS.LOADING_RESOURCE, ""Gallery ID "" + galleryID + "" for userID "" + userID); <line27> JSONObject thisJSON = Http.url(blogURL).getJSON(); <line28> JSONArray thisPhotos = thisJSON.getJSONArray(""photos""); <line29> for (int j = 0; j < thisPhotos.length(); j++) { <line30> result.getJSONArray(""photos"").put(thisPhotos.getJSONObject(j)); <line31> } <line32> } <line33> return result; <line34> } else if (baseURL.contains(""/blogs?"")) { <line35> JSONObject result = new JSONObject(); <line36> result.put(""photos"", new JSONArray()); <line37> JSONArray jsonBlogs = json.getJSONArray(""blog_posts""); <line38> for (int i = 0; i < jsonBlogs.length(); i++) { <line39> if (i > 0) { <line40> sleep(500); <line41> } <line42> JSONObject jsonBlog = jsonBlogs.getJSONObject(i); <line43> int blogid = jsonBlog.getInt(""id""); <line44> String username = jsonBlog.getJSONObject(""user"").getString(""username""); <line45> String blogURL = <line46> ""https://api.500px.com/v1/blogs/"" <line47> + blogid <line48> + ""?feature=user"" <line49> + ""&username="" <line50> + username <line51> + ""&rpp=100"" <line52> + ""&image_size=5"" <line53> + ""&consumer_key="" <line54> + CONSUMER_KEY; <line55> sendUpdate(STATUS.LOADING_RESOURCE, ""Story ID "" + blogid + "" for user "" + username); <line56> JSONObject thisJSON = Http.url(blogURL).getJSON(); <line57> JSONArray thisPhotos = thisJSON.getJSONArray(""photos""); <line58> for (int j = 0; j < thisPhotos.length(); j++) { <line59> result.getJSONArray(""photos"").put(thisPhotos.getJSONObject(j)); <line60> } <line61> } <line62> return result; <line63> } <line64> return json; <line65> } <line66> } <line67> "	 <line13>	No
"public class A { <line0> @Override <line1> public void initialize() { <line2> final DSMRDeviceConfiguration deviceConfig = getConfigAs(DSMRDeviceConfiguration.class); <line3> if (smartyMeter <line4> && (deviceConfig.decryptionKey == null || deviceConfig.decryptionKey.length() != 32)) { <line5> updateStatus( <line6> ThingStatus.OFFLINE, <line7> ThingStatusDetail.CONFIGURATION_ERROR, <line8> ""@text/error.configuration.invalidsmartykey""); <line9> return; <line10> } <line11> updateStatus(ThingStatus.UNKNOWN); <line12> receivedTimeoutNanos = TimeUnit.SECONDS.toNanos(deviceConfig.receivedTimeout); <line13> final DSMRDevice dsmrDevice = createDevice(deviceConfig); <line14> resetLastReceivedState(); <line15> this.dsmrDevice = dsmrDevice; <line16> dsmrDeviceRunnable = new DSMRDeviceRunnable(dsmrDevice, this); <line17> dsmrDeviceThread = new Thread(dsmrDeviceRunnable); <line18> dsmrDeviceThread.setName(""OH-binding-"" + getThing().getUID()); <line19> dsmrDeviceThread.setDaemon(true); <line20> dsmrDeviceThread.start(); <line21> watchdog = <line22> scheduler.scheduleWithFixedDelay( <line23> this::alive, receivedTimeoutNanos, receivedTimeoutNanos, TimeUnit.NANOSECONDS); <line24> } <line25> } <line26> "	 <line1>	No
"public class A { <line0> @Override <line1> public RemoveRepositorySourceMirrorResult removeRepositorySourceMirror( <line2> RemoveRepositorySourceMirrorRequest request) { <line3> Preconditions.checkArgument(null != request, ""the request is required""); <line4> Preconditions.checkArgument( <line5> StringUtils.isNotBlank(request.code), ""the code is required on the request""); <line6> final ObjectContext context = serverRuntime.newContext(); <line7> RepositorySourceMirror repositorySourceMirror = <line8> RepositorySourceMirror.tryGetByCode(context, request.code) <line9> .orElseThrow( <line10> () -> <line11> new ObjectNotFoundException( <line12> RepositorySourceMirror.class.getSimpleName(), request.code)); <line13> if (repositorySourceMirror.getIsPrimary()) { <line14> throw new IllegalStateException(""unable to remove the primary mirror""); <line15> } <line16> repositorySourceMirror.getRepositorySource().getRepository().setModifyTimestamp(); <line17> context.deleteObject(repositorySourceMirror); <line18> context.commitChanges(); <line19> return new RemoveRepositorySourceMirrorResult(); <line20> } <line21> } <line22> "	 <line19>	Yes
public class A { <line0> public void testBoundaryValueVar32() { <line1> int boundSize = 0; <line2> for (int i = 0; i < Integer.MAX_VALUE; i++) { <line3> final int size = BytesUtils.computeVar32Size(i); <line4> if (size > boundSize) { <line5> boundSize = size; <line6> } <line7> } <line8> } <line9> } <line10> 	 <line7>	No
"public class A { <line0> @Override <line1> public String render(RenderRequest renderRequest, RenderResponse renderResponse) <line2> throws PortletException { <line3> try { <line4> CommerceVirtualOrderItemContentDisplayContext commerceVirtualOrderItemContentDisplayContext = <line5> new CommerceVirtualOrderItemContentDisplayContext( <line6> _commerceChannelLocalService, <line7> _commerceVirtualOrderItemLocalService, <line8> _cpDefinitionHelper, <line9> _commerceAccountHelper, <line10> _cpDefinitionVirtualSettingService, <line11> _cpInstanceHelper, <line12> _portal.getHttpServletRequest(renderRequest)); <line13> renderRequest.setAttribute( <line14> WebKeys.PORTLET_DISPLAY_CONTEXT, commerceVirtualOrderItemContentDisplayContext); <line15> } catch (PortalException portalException) { <line16> } <line17> return ""/view_commerce_virtual_order_item_terms_of_use.jsp""; <line18> } <line19> } <line20> "	 <line16>	Yes
public class A { <line0> @NotNull <line1> public static AstElement copyElementAndCheckReference(@NotNull final AstElement e) { <line2> AstElement clone = checkNotNull(e).copyOf(); <line3> if (clone == e && LOG.isDebugEnabled()) { <line4> } <line5> return clone; <line6> } <line7> } <line8> 	 <line7>	No
public class A { <line0> public void start() throws Exception { <line1> Objects.nonNull(config); <line2> this.client = <line3> com.basho.riak.client.api.RiakClient.newClient( <line4> config.getPort().intValue(), config.getHosts()); <line5> Objects.nonNull(client); <line6> Objects.nonNull(client.getRiakCluster()); <line7> assert (client.getRiakCluster().getNodes().size() > 0); <line8> } <line9> } <line10> 	 <line7>	No
"public class A { <line0> protected void dropTitleColumn() throws Exception { <line1> try { <line2> runSQL(""alter table JournalArticle drop column title""); <line3> } catch (SQLException sqlException) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> "	 <line5>	Yes
"public class A { <line0> private RepairRun buildRepairRunFromRow(Row repairRunResult, UUID id) { <line1> Date startTime = repairRunResult.getTimestamp(""start_time""); <line2> Date pauseTime = repairRunResult.getTimestamp(""pause_time""); <line3> Date endTime = repairRunResult.getTimestamp(""end_time""); <line4> return RepairRun.builder( <line5> repairRunResult.getString(""cluster_name""), repairRunResult.getUUID(""repair_unit_id"")) <line6> .creationTime(new DateTime(repairRunResult.getTimestamp(""creation_time""))) <line7> .intensity(repairRunResult.getDouble(""intensity"")) <line8> .segmentCount(repairRunResult.getInt(""segment_count"")) <line9> .repairParallelism( <line10> RepairParallelism.fromName(repairRunResult.getString(""repair_parallelism""))) <line11> .cause(repairRunResult.getString(""cause"")) <line12> .owner(repairRunResult.getString(""owner"")) <line13> .startTime(null != startTime ? new DateTime(startTime) : null) <line14> .pauseTime(null != pauseTime ? new DateTime(pauseTime) : null) <line15> .endTime(null != endTime ? new DateTime(endTime) : null) <line16> .lastEvent(repairRunResult.getString(""last_event"")) <line17> .runState(RunState.valueOf(repairRunResult.getString(""state""))) <line18> .tables(repairRunResult.getSet(""tables"", String.class)) <line19> .build(id); <line20> } <line21> } <line22> "	 <line9>	No
"public class A { <line0> @Override <line1> public boolean process(Exchange exchange, AsyncCallback callback) { <line2> if (!isRunAllowed()) { <line3> exchange.setException(new RejectedExecutionException(""Run is not allowed"")); <line4> callback.done(true); <line5> return true; <line6> } <line7> long delay; <line8> try { <line9> delay = calculateDelay(exchange); <line10> if (delay <= 0) { <line11> if (LOG.isTraceEnabled()) { <line12> } <line13> return processor.process(exchange, callback); <line14> } <line15> } catch (Throwable e) { <line16> exchange.setException(e); <line17> callback.done(true); <line18> return true; <line19> } <line20> return processDelay(exchange, callback, delay); <line21> } <line22> } <line23> "	 <line12>	Yes
public class A { <line0> public static void checkOutFileEntry( <line1> long fileEntryId, com.liferay.portal.kernel.service.ServiceContext serviceContext) <line2> throws RemoteException { <line3> try { <line4> DLAppServiceUtil.checkOutFileEntry(fileEntryId, serviceContext); <line5> } catch (Exception exception) { <line6> throw new RemoteException(exception.getMessage()); <line7> } <line8> } <line9> } <line10> 	 <line9>	No
public class A { <line0> @Override <line1> public void aroundWriteTo(WriterInterceptorContext context) <line2> throws IOException, WebApplicationException { <line3> ResponseMethodStats stats = doWrite(context); <line4> QueryCall queryCall = (QueryCall) context.getProperty(QueryCall.class.getName()); <line5> if (queryCall != null) { <line6> if (queryCache != null) { <line7> RunningQuery rq = queryCache.get(queryCall.queryID); <line8> if (rq != null) { <line9> BaseQueryLogic<?> baseLogic = null; <line10> QueryLogic<?> logic = rq.getLogic(); <line11> if (logic != null && logic instanceof BaseQueryLogic) { <line12> baseLogic = (BaseQueryLogic) logic; <line13> } <line14> if (baseLogic != null && baseLogic.getCollectQueryMetrics()) { <line15> try { <line16> BaseQueryMetric metric = rq.getMetric(); <line17> switch (queryCall.methodType) { <line18> case CREATE: <line19> metric.setCreateCallTime(stats.getCallTime()); <line20> metric.setLoginTime(stats.getLoginTime()); <line21> break; <line22> case CREATE_AND_NEXT: <line23> metric.setCreateCallTime(stats.getCallTime()); <line24> metric.setLoginTime(stats.getLoginTime()); <line25> List<PageMetric> pageTimes = metric.getPageTimes(); <line26> if (pageTimes != null && !pageTimes.isEmpty()) { <line27> PageMetric pm = pageTimes.get(pageTimes.size() - 1); <line28> pm.setCallTime(stats.getCallTime()); <line29> pm.setLoginTime(stats.getLoginTime()); <line30> pm.setSerializationTime(stats.getSerializationTime()); <line31> pm.setBytesWritten(stats.getBytesWritten()); <line32> } <line33> break; <line34> case NEXT: <line35> pageTimes = metric.getPageTimes(); <line36> if (pageTimes != null && !pageTimes.isEmpty()) { <line37> PageMetric pm = pageTimes.get(pageTimes.size() - 1); <line38> pm.setCallTime(stats.getCallTime()); <line39> pm.setLoginTime(stats.getLoginTime()); <line40> pm.setSerializationTime(stats.getSerializationTime()); <line41> pm.setBytesWritten(stats.getBytesWritten()); <line42> } <line43> break; <line44> } <line45> if (queryMetricsBean != null) queryMetricsBean.updateMetric(metric); <line46> } catch (Exception e) { <line47> } <line48> } <line49> } else { <line50> } <line51> } else { <line52> } <line53> } <line54> } <line55> } <line56> 	 <line46>	Yes
"public class A { <line0> public Set<Long> getClientCustomerIds() throws ApiException { <line1> Set<Long> clientCustomerIdsSet = new LinkedHashSet<Long>(); <line2> ManagedCustomerPage managedCustomerPage; <line3> int offset = 0; <line4> SelectorBuilder builder = new SelectorBuilder(); <line5> Selector selector = <line6> builder <line7> .fields(ManagedCustomerField.CustomerId) <line8> .offset(offset) <line9> .limit(NUMBER_OF_RESULTS) <line10> .equals(ManagedCustomerField.CanManageClients, String.valueOf(false)) <line11> .equals(""ExcludeHiddenAccounts"", String.valueOf(excludeHiddenAccounts)) <line12> .build(); <line13> do { <line14> managedCustomerPage = managedCustomerService.get(selector); <line15> addClientCustomerIds(managedCustomerPage, clientCustomerIdsSet); <line16> offset += NUMBER_OF_RESULTS; <line17> selector = builder.increaseOffsetBy(NUMBER_OF_RESULTS).build(); <line18> } while (managedCustomerPage.getTotalNumEntries() > offset); <line19> return clientCustomerIdsSet; <line20> } <line21> } <line22> "	 <line6>	No
public class A { <line0> @Override <line1> public Set<String> getSPEntityNames() { <line2> Set<String> result = new HashSet<>(); <line3> for (ExtendedMetadataDelegate delegate : getAvailableProviders()) { <line4> try { <line5> String sp = getSpName(delegate); <line6> if (StringUtils.hasText(sp)) { <line7> result.add(sp); <line8> } <line9> } catch (MetadataProviderException e) { <line10> } <line11> } <line12> return result; <line13> } <line14> } <line15> 	 <line3>	No
public class A { <line0> @Override <line1> public Resource next() { <line2> Resource ret = nextResource; <line3> nextResource = null; <line4> if (metadataIterator.hasNext()) { <line5> nextResource = metadataIterator.next(); <line6> } else { <line7> while (repIterator.hasNext()) { <line8> try { <line9> StoragePath metadataPath = <line10> DefaultStoragePath.parse( <line11> repIterator.next().getStoragePath(), <line12> RodaConstants.STORAGE_DIRECTORY_METADATA, <line13> RodaConstants.STORAGE_DIRECTORY_PRESERVATION); <line14> if (storage.hasDirectory(metadataPath)) { <line15> IOUtils.closeQuietly(metadataResources); <line16> metadataResources = storage.listResourcesUnderDirectory(metadataPath, true); <line17> metadataIterator = metadataResources.iterator(); <line18> if (metadataIterator.hasNext()) { <line19> break; <line20> } else { <line21> IOUtils.closeQuietly(metadataResources); <line22> } <line23> } <line24> } catch (RODAException e) { <line25> } <line26> } <line27> if (metadataIterator.hasNext()) { <line28> nextResource = metadataIterator.next(); <line29> } else { <line30> outerloop: <line31> while (aipIteratorSub.hasNext()) { <line32> try { <line33> StoragePath repPath = <line34> DefaultStoragePath.parse( <line35> aipIteratorSub.next().getStoragePath(), <line36> RodaConstants.STORAGE_DIRECTORY_REPRESENTATIONS); <line37> if (storage.hasDirectory(repPath)) { <line38> IOUtils.closeQuietly(repResources); <line39> repResources = storage.listResourcesUnderDirectory(repPath, false); <line40> repIterator = repResources.iterator(); <line41> while (repIterator.hasNext()) { <line42> StoragePath metadataPath = <line43> DefaultStoragePath.parse( <line44> repIterator.next().getStoragePath(), <line45> RodaConstants.STORAGE_DIRECTORY_METADATA, <line46> RodaConstants.STORAGE_DIRECTORY_PRESERVATION); <line47> if (storage.hasDirectory(metadataPath)) { <line48> IOUtils.closeQuietly(metadataResources); <line49> metadataResources = storage.listResourcesUnderDirectory(metadataPath, true); <line50> metadataIterator = metadataResources.iterator(); <line51> if (metadataIterator.hasNext()) { <line52> break outerloop; <line53> } else { <line54> IOUtils.closeQuietly(metadataResources); <line55> } <line56> } <line57> } <line58> } <line59> } catch (RODAException e) { <line60> } <line61> } <line62> if (metadataIterator != null && metadataIterator.hasNext()) { <line63> nextResource = metadataIterator.next(); <line64> } <line65> } <line66> } <line67> return ret; <line68> } <line69> } <line70> 	 <line25>	Yes
"public class A { <line0> public static void addSegmentsEntryClassPKs( <line1> HttpPrincipal httpPrincipal, <line2> long segmentsEntryId, <line3> long[] classPKs, <line4> com.liferay.portal.kernel.service.ServiceContext serviceContext) <line5> throws com.liferay.portal.kernel.exception.PortalException { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> SegmentsEntryServiceUtil.class, <line10> ""addSegmentsEntryClassPKs"", <line11> _addSegmentsEntryClassPKsParameterTypes2); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, segmentsEntryId, classPKs, serviceContext); <line14> try { <line15> TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> if (exception instanceof com.liferay.portal.kernel.exception.PortalException) { <line18> throw (com.liferay.portal.kernel.exception.PortalException) exception; <line19> } <line20> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line21> } <line22> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line23> throw systemException; <line24> } <line25> } <line26> } <line27> "	 <line23>	Yes
"public class A { <line0> private static ConfigLoader getLoader(Resource resource) { <line1> ConfigLoader loader = null; <line2> Class<? extends ConfigLoader> loaderClass = resource.getFormat().getLoaderClass(); <line3> try { <line4> loader = loaderClass.newInstance(); <line5> } catch (Exception e) { <line6> throw new RuntimeException( <line7> ""Failed to create "" + Conf.class.getPackage().getName() + "" for "" + loaderClass.getName(), <line8> e); <line9> } <line10> loader.setResource(resource); <line11> return loader; <line12> } <line13> } <line14> "	 <line6>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> conn = new Pop3Connection(this, socket); <line4> state = new Pop3State(manager); <line5> quitting = false; <line6> sendGreetings(); <line7> while (!quitting) { <line8> handleCommand(); <line9> } <line10> conn.close(); <line11> } catch (SocketTimeoutException ste) { <line12> conn.println(""421 Service shutting down and closing transmission channel""); <line13> } catch (Exception e) { <line14> if (!quitting) { <line15> throw new IllegalStateException(""Can not handle POP3 connection"", e); <line16> } <line17> } finally { <line18> try { <line19> socket.close(); <line20> } catch (IOException ioe) { <line21> } <line22> } <line23> } <line24> } <line25> "	 <line20>	No
"public class A { <line0> @GET <line1> @Path(""/listEffectiveAuthorizations"") <line2> @Produces({ <line3> ""application/xml"", <line4> ""text/xml"", <line5> ""text/plain"", <line6> ""application/json"", <line7> ""text/yaml"", <line8> ""text/x-yaml"", <line9> ""application/x-yaml"", <line10> ""application/x-protobuf"", <line11> ""text/html"" <line12> }) <line13> public AuthorizationsListBase listEffectiveAuthorizations() { <line14> final AuthorizationsListBase list = responseObjectFactory.getAuthorizationsList(); <line15> Principal p = context.getCallerPrincipal(); <line16> String name = p.getName(); <line17> if (p instanceof DatawavePrincipal) { <line18> DatawavePrincipal datawavePrincipal = (DatawavePrincipal) p; <line19> name = datawavePrincipal.getShortName(); <line20> DatawaveUser primaryUser = datawavePrincipal.getPrimaryUser(); <line21> list.setUserAuths( <line22> primaryUser.getDn().subjectDN(), <line23> primaryUser.getDn().issuerDN(), <line24> new HashSet<>(primaryUser.getAuths())); <line25> datawavePrincipal <line26> .getProxiedUsers() <line27> .forEach( <line28> u -> <line29> list.addAuths( <line30> u.getDn().subjectDN(), u.getDn().issuerDN(), new HashSet<>(u.getAuths()))); <line31> list.setAuthMapping(datawavePrincipal.getPrimaryUser().getRoleToAuthMapping().asMap()); <line32> } <line33> return list; <line34> } <line35> } <line36> "	 <line33>	Yes
"public class A { <line0> public void putContentStream(MIMETypedStream stream) throws StreamIOException { <line1> String oldDSLocation = DSLocation; <line2> try { <line3> File tempFile = File.createTempFile(""managedcontentupdate"", null); <line4> OutputStream os = new FileOutputStream(tempFile); <line5> StreamUtility.pipeStream(stream.getStream(), os, 32768); <line6> DSLocation = TEMP_SCHEME + tempFile.getAbsolutePath(); <line7> } catch (Exception e) { <line8> throw new StreamIOException( <line9> ""Error creating new temp file for updated managed content (existing content is:"" <line10> + oldDSLocation <line11> + "")"", <line12> e); <line13> } <line14> if (oldDSLocation != null && oldDSLocation.startsWith(TEMP_SCHEME)) { <line15> File oldFile; <line16> try { <line17> oldFile = new File(oldDSLocation.substring(TEMP_SCHEME.length())); <line18> } catch (Exception e) { <line19> throw new StreamIOException( <line20> ""Error removing old temp file while updating managed content (location: "" <line21> + oldDSLocation <line22> + "")"", <line23> e); <line24> } <line25> if (oldFile.exists()) { <line26> if (!oldFile.delete()) { <line27> oldFile.deleteOnExit(); <line28> } <line29> } else <line30> } <line31> } <line32> } <line33> "	 <line27>	Yes
"public class A { <line0> @Test( <line1> dependsOnMethods = {""createJob"", ""getJob""}, <line2> groups = {""expensive""}) <line3> public void canListAllJobIDs() throws IOException, InterruptedException { <line4> final MantaJob job1 = buildJob(); <line5> final UUID job1id = createJobAndSkipIfUnsupported(job1); <line6> final MantaJob job2 = buildJob(); <line7> final UUID job2id = createJobAndSkipIfUnsupported(job2); <line8> Assert.assertTrue(mantaClient.endJobInput(job1id)); <line9> Assert.assertTrue(mantaClient.endJobInput(job2id)); <line10> awaitJobCompletion(job1id); <line11> awaitJobCompletion(job2id); <line12> try (Stream<UUID> jobs = mantaClient.getAllJobIds()) { <line13> List<UUID> found = <line14> jobs.filter(id -> id.equals(job1id) || id.equals(job2id)).collect(Collectors.toList()); <line15> Assert.assertEquals(found.size(), 2, ""We should have found both jobs""); <line16> } catch (AssertionError e) { <line17> String msg = ""Couldn't find job in job list, retry test a few times to verify""; <line18> throw new SkipException(msg, e); <line19> } <line20> } <line21> } <line22> "	 <line18>	Yes
public class A { <line0> private void deleteTags(List<Tag> tags) { <line1> Iterable<Tag> customTags = <line2> filter( <line3> tags, <line4> new Predicate<Tag>() { <line5> @Override <line6> public boolean apply(Tag input) { <line7> Tag tag = api.getTagInfo(input.getUuid()); <line8> return groupNamingConvention.groupInSharedNameOrNull(tag.getName()) != null; <line9> } <line10> }); <line11> for (Tag tag : customTags) { <line12> try { <line13> api.deleteTag(tag.getUuid()); <line14> } catch (Exception ex) { <line15> } <line16> } <line17> } <line18> } <line19> 	 <line1>	Yes
"public class A { <line0> @Test <line1> public void testSequence() throws InterruptedException { <line2> int count = 100; <line3> Queue<Integer> list = new ConcurrentLinkedQueue<>(); <line4> CountDownLatch latch = new CountDownLatch(count); <line5> for (int i = 0; i < count; i++) { <line6> int finalI = i; <line7> oneThreadTaskExecutor.executeCommand( <line8> new AbstractCommand<Object>() { <line9> @Override <line10> protected void doExecute() throws Exception { <line11> try { <line12> list.offer(finalI); <line13> future().setSuccess(); <line14> } finally { <line15> latch.countDown(); <line16> } <line17> } <line18>  <line19> @Override <line20> protected void doReset() {} <line21>  <line22> @Override <line23> public String getName() { <line24> return getTestName() + "":"" + finalI; <line25> } <line26> }); <line27> } <line28> Assert.assertTrue(latch.await(5, TimeUnit.SECONDS)); <line29> Assert.assertEquals(count, list.size()); <line30> int previous = -1; <line31> while (true) { <line32> Integer current = list.poll(); <line33> if (current == null) { <line34> break; <line35> } <line36> Assert.assertTrue(current > previous); <line37> previous = current; <line38> } <line39> } <line40> } <line41> "	 <line29>	No
"public class A { <line0> @Path(""/blockchain/constants"") <line1> @GET <line2> @Produces(MediaType.APPLICATION_JSON) <line3> @Operation( <line4> summary = ""Returns constants information"", <line5> description = ""Returns constants  information on current node in run-time"", <line6> tags = {""info""}, <line7> responses = { <line8> @ApiResponse( <line9> responseCode = ""200"", <line10> description = ""Successful execution"", <line11> content = <line12> @Content( <line13> mediaType = ""application/json"", <line14> schema = @Schema(implementation = BlockchainConstantsDto.class))) <line15> }) <line16> @PermitAll <line17> public Response blockchainConstants() { <line18> ResponseBuilder response = ResponseBuilder.startTiming(); <line19> BlockchainConstantsDto dto = serverInfoService.getBlockchainConstants(); <line20> return response.bind(dto).build(); <line21> } <line22> } <line23> "	 <line20>	Yes
public class A { <line0> @Override <line1> public boolean predicate() throws IOException { <line2> Map<String, Object> config = predicate.getConfigMap(); <line3> String[] paths = null; <line4> String rootPath = null; <line5> if (config != null && !StringUtils.isEmpty((String) config.get(PREDICT_PATH))) { <line6> paths = ((String) config.get(PREDICT_PATH)).split(PATH_CONNECTOR_CHARACTER); <line7> rootPath = (String) config.get(PREDICT_ROOT_PATH); <line8> } <line9> if (ArrayUtils.isEmpty(paths) || StringUtils.isEmpty(rootPath)) { <line10> throw new NullPointerException(); <line11> } <line12> for (String path : paths) { <line13> String hdfsPath = rootPath + path; <line14> if (!FSUtil.isFileExist(hdfsPath)) { <line15> return false; <line16> } <line17> } <line18> return true; <line19> } <line20> } <line21> 	 <line10>	Yes
"public class A { <line0> private void runTest1() throws Exception { <line1> final int MAX_CONNECTIONS = 2; <line2> DataSource ds = null; <line3> try { <line4> Context ctx = cache.getJNDIContext(); <line5> ds = (DataSource) ctx.lookup(""java:/XAPooledDataSource""); <line6> } catch (NamingException e) { <line7> fail(""failed in naming lookup: "", e); <line8> return; <line9> } catch (Exception e) { <line10> fail(""failed in naming lookup: "", e); <line11> return; <line12> } <line13> try { <line14> for (int count = 0; count < MAX_CONNECTIONS; count++) { <line15> ds.getConnection(); <line16> } <line17> } catch (SQLException e) { <line18> fail(""runTest1 SQL Exception caught: "", e); <line19> } catch (Exception e) { <line20> fail(""Exception caught in runTest1: "", e); <line21> e.printStackTrace(); <line22> } <line23> } <line24> } <line25> "	 <line19>	No
public class A { <line0> @Override <line1> public void configure(JobConf job) { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> private boolean createCollection() { <line1> try { <line2> List<String> allCollectionList = getCollections(); <line3> if (allCollectionList != null) { <line4> if (!allCollectionList.contains(solr_collection_name)) { <line5> int shardsCalculation = <line6> solrCloudClient != null <line7> ? solrCloudClient.getClusterStateProvider().getLiveNodes().size() <line8> : DEFAULT_VALUE; <line9> int no_of_shards = EmbeddedServerUtil.getIntConfig(SOLR_NO_SHARDS, shardsCalculation); <line10> CollectionAdminRequest.Create createCollection = <line11> CollectionAdminRequest.createCollection( <line12> solr_collection_name, solr_config_name, no_of_shards, no_of_replicas); <line13> createCollection.setMaxShardsPerNode(max_node_per_shards); <line14> CollectionAdminResponse createResponse = createCollection.process(solrClient); <line15> if (createResponse.getStatus() != 0) { <line16> logger.severe( <line17> ""Error creating collection. collectionName="" <line18> + solr_collection_name <line19> + "" , solr config name = "" <line20> + solr_config_name <line21> + "" , replicas = "" <line22> + no_of_replicas <line23> + "", shards="" <line24> + no_of_shards <line25> + "" , max node per shards = "" <line26> + max_node_per_shards <line27> + "", response="" <line28> + createResponse); <line29> return false; <line30> } else { <line31> return true; <line32> } <line33> } else { <line34> return true; <line35> } <line36> } else { <line37> logger.severe(""Error while connecting to solr ""); <line38> return false; <line39> } <line40> } catch (Exception ex) { <line41> logger.severe(""Error while creating collection in solr : "" + ex); <line42> return false; <line43> } <line44> } <line45> } <line46> "	 <line13>	No
"public class A { <line0> @Override <line1> public void customize( <line2> JcloudsLocation location, ComputeService computeService, TemplateOptions templateOptions) { <line3> String provider = location.getProvider(); <line4> if (!(provider.equals(SoftLayerConstants.SOFTLAYER_PROVIDER_NAME) <line5> && templateOptions instanceof SoftLayerTemplateOptions)) { <line6> String message = <line7> String.format( <line8> ""Invalid location provider or template options: %s/%s"", <line9> provider, templateOptions.getClass().getSimpleName()); <line10> LOG.warn(message); <line11> throw new IllegalArgumentException(message); <line12> } <line13> String scopeUid = getScopeUid(location); <line14> SoftLayerTemplateOptions softLayerOptions = (SoftLayerTemplateOptions) templateOptions; <line15> Integer publicVlanId = softLayerOptions.getPrimaryNetworkComponentNetworkVlanId(); <line16> Integer privateVlanId = softLayerOptions.getPrimaryBackendNetworkComponentNetworkVlanId(); <line17> if (publicVlanId != null && privateVlanId != null) { <line18> return; <line19> } <line20> LOG.debug(""Looking up saved VLAN details {}"", scopeUid); <line21> publicVlanId = lookupPublicVlanId(location, scopeUid); <line22> privateVlanId = lookupPrivateVlanId(location, scopeUid); <line23> if (publicVlanId != null && privateVlanId != null) { <line24> saveVlanTemplateOptions(scopeUid, softLayerOptions, publicVlanId, privateVlanId); <line25> return; <line26> } <line27> CountDownLatch latch = null; <line28> synchronized (lock) { <line29> latch = lookupCountDownLatch(location, scopeUid); <line30> if (latch == null) { <line31> latch = createCountDownLatch(location, scopeUid); <line32> return; <line33> } <line34> } <line35> Duration timeout = getTimeout(location); <line36> Tasks.setBlockingDetails(""Waiting for VLAN details""); <line37> try { <line38> if (!Uninterruptibles.awaitUninterruptibly( <line39> latch, timeout.toMilliseconds(), TimeUnit.MILLISECONDS)) { <line40> latch.countDown(); <line41> removeCountDownLatch(location, scopeUid); <line42> throw new IllegalStateException( <line43> ""Timeout waiting on VLAN info in "" + location + "" for scope: "" + scopeUid); <line44> } <line45> } finally { <line46> Tasks.resetBlockingDetails(); <line47> } <line48> publicVlanId = lookupPublicVlanId(location, scopeUid); <line49> privateVlanId = lookupPrivateVlanId(location, scopeUid); <line50> if (privateVlanId == null && publicVlanId == null) { <line51> String message = <line52> String.format( <line53> ""Saved VLAN configuration not available for location %s scope %s"", <line54> location, scopeUid); <line55> throw new IllegalArgumentException(message); <line56> } <line57> saveVlanTemplateOptions(scopeUid, softLayerOptions, publicVlanId, privateVlanId); <line58> } <line59> } <line60> "	 <line18>	Yes
public class A { <line0> private boolean reset(List<LogicalTable> requiredTables) { <line1> try { <line2> this.requiredTables = requiredTables; <line3> if (needsReset) { <line4> if (this.searchStack != null) { <line5> this.searchStack.clear(); <line6> } <line7> for (Node n : nodes) { <line8> n.clearRequirement(); <line9> } <line10> for (Arc a : arcs) { <line11> a.clearRequirement(); <line12> } <line13> } else { <line14> this.needsReset = true; <line15> } <line16> for (Node n : nodes) { <line17> if (requiredTables.contains(n.getTable())) { <line18> n.setRequirement(true); <line19> } <line20> } <line21> return true; <line22> } catch (ConsistencyException cx) { <line23> return false; <line24> } <line25> } <line26> } <line27> 	 <line23>	Yes
public class A { <line0> @Override <line1> public DocumentInfo findDocumentByDocumentId(int documentId) { <line2> DocumentInfo document = dao.findById(DocumentInfo.class, documentId); <line3> return document; <line4> } <line5> } <line6> 	 <line1>	No
public class A { <line0> @Override <line1> public void perform(AbstractDevice device, Item item, String value) { <line2> String newValue = null; <line3> for (Entry<String, String> entry : device.getMapping().entrySet()) { <line4> if (Objects.equals(entry.getValue(), value)) { <line5> newValue = entry.getKey(); <line6> break; <line7> } <line8> } <line9> if (newValue == null) { <line10> return; <line11> } <line12> ItemCommandEvent event = <line13> ItemEventFactory.createCommandEvent( <line14> item.getName(), new DecimalType(newValue), COMMAND_SOURCE); <line15> eventPublisher.post(event); <line16> } <line17> } <line18> 	 <line4>	No
public class A { <line0> @Override <line1> public Double visit(LessThanFilter lessThanFilter) { <line2> int minBound = <line3> 9 <line4> - IntStream.rangeClosed(0, 9) <line5> .filter(i -> percentiles[9 - i] < lessThanFilter.getValue().doubleValue()) <line6> .findFirst() <line7> .orElse(0); <line8> final double result = ((double) minBound + 1.0) / 10.0; <line9> return result; <line10> } <line11> } <line12> 	 <line4>	No
"public class A { <line0> @Override <line1> protected boolean operateOnTx(TXId txId, ClusterDistributionManager dm) <line2> throws RemoteOperationException { <line3> InternalCache cache = dm.getCache(); <line4> TXManagerImpl txMgr = cache.getTXMgr(); <line5> if (logger.isDebugEnabled()) { <line6> } <line7> assert (!txMgr.isHostedTxRecentlyCompleted(txId)); <line8> TXLockService.createDTLS(cache.getInternalDistributedSystem()); <line9> final TXStateProxy txStateProxy = txMgr.getTXState(); <line10> boolean precommitSuccess = true; <line11> TreeMap<String, ArrayList<DistTxThinEntryState>> entryStateSortedMap = <line12> new TreeMap<String, ArrayList<DistTxThinEntryState>>(); <line13> if (txStateProxy != null) { <line14> if (!txStateProxy.isDistTx() <line15> || !txStateProxy.isTxStateProxy() <line16> || txStateProxy.isCreatedOnDistTxCoordinator()) { <line17> throw new UnsupportedOperationInTransactionException( <line18> String.format( <line19> ""Expected %s during a distributed transaction but got %s"", <line20> ""DistTXStateProxyImplOnDatanode"", txStateProxy.getClass().getSimpleName())); <line21> } <line22> ((DistTXStateProxyImplOnDatanode) txStateProxy).setPreCommitMessage(this); <line23> txMgr.precommit(); <line24> precommitSuccess = ((DistTXStateProxyImplOnDatanode) txStateProxy).getPreCommitResponse(); <line25> if (precommitSuccess) { <line26> precommitSuccess = <line27> ((DistTXStateProxyImplOnDatanode) txStateProxy) <line28> .populateDistTxEntryStateList(entryStateSortedMap); <line29> if (!precommitSuccess) { <line30> entryStateSortedMap.clear(); <line31> if (logger.isDebugEnabled()) { <line32> } <line33> } <line34> } else { <line35> if (logger.isDebugEnabled()) { <line36> } <line37> } <line38> } <line39> DistTxPrecommitResponse finalResponse = <line40> new DistTxPrecommitResponse( <line41> precommitSuccess, <line42> new ArrayList<ArrayList<DistTxThinEntryState>>(entryStateSortedMap.values())); <line43> DistTXPrecommitReplyMessage.send( <line44> getSender(), getProcessorId(), finalResponse, getReplySender(dm)); <line45> return false; <line46> } <line47> } <line48> "	 <line20>	No
public class A { <line0> public JSONArray readCommandsByTag(List<CommandTag> tag) { <line1> JSONArray filteredHistoryJson = new JSONArray(); <line2> try { <line3> String filename = <line4> CommandHistory.getHistorySaver(workspace.getId()).getHistoryFilepath(worksheetId); <line5> JSONArray historyJson = <line6> CommandHistory.getHistorySaver(workspace.getId()).loadHistory(filename); <line7> filteredHistoryJson = HistoryJsonUtil.filterCommandsByTag(tag, historyJson); <line8> } catch (JSONException e) { <line9> } catch (Exception e) { <line10> } <line11> return filteredHistoryJson; <line12> } <line13> } <line14> 	 <line11>	No
"public class A { <line0> @Override <line1> public void upgrade() { <line2> if (clusterConfigService.get(DefaultIndexSetCreated.class) != null) { <line3> return; <line4> } <line5> final IndexManagementConfig indexManagementConfig = <line6> clusterConfigService.get(IndexManagementConfig.class); <line7> checkState(indexManagementConfig != null, ""Couldn't find index management configuration""); <line8> final IndexSetConfig config = <line9> IndexSetConfig.builder() <line10> .title(""Default index set"") <line11> .description(""The Graylog default index set"") <line12> .indexPrefix(elasticsearchConfiguration.getIndexPrefix()) <line13> .shards(elasticsearchConfiguration.getShards()) <line14> .replicas(elasticsearchConfiguration.getReplicas()) <line15> .rotationStrategy(getRotationStrategyConfig(indexManagementConfig)) <line16> .retentionStrategy(getRetentionStrategyConfig(indexManagementConfig)) <line17> .creationDate(ZonedDateTime.now(ZoneOffset.UTC)) <line18> .indexAnalyzer(elasticsearchConfiguration.getAnalyzer()) <line19> .indexTemplateName(elasticsearchConfiguration.getTemplateName()) <line20> .indexOptimizationMaxNumSegments( <line21> elasticsearchConfiguration.getIndexOptimizationMaxNumSegments()) <line22> .indexOptimizationDisabled(elasticsearchConfiguration.isDisableIndexOptimization()) <line23> .build(); <line24> final IndexSetConfig savedConfig = indexSetService.save(config); <line25> clusterConfigService.write(DefaultIndexSetConfig.create(savedConfig.id())); <line26> clusterConfigService.write(DefaultIndexSetCreated.create()); <line27> } <line28> } <line29> "	 <line27>	Yes
public class A { <line0> private void handleMatchDescriptorResponse(MatchDescriptorResponse response) { <line1> if (response.getStatus() != ZdoStatus.SUCCESS || response.getMatchList().size() == 0) { <line2> return; <line3> } <line4> ZigBeeNode trustCentre; <line5> switch (seState) { <line6> case DISCOVER_KEY_ESTABLISHMENT_CLUSTER: <line7> if (response.getSourceAddress().getAddress() != 0) { <line8> return; <line9> } <line10> trustCentre = networkManager.getNode(0); <line11> if (trustCentre == null) { <line12> updateClientState(SmartEnergyClientState.DISCOVER_TRUST_CENTRE); <line13> return; <line14> } <line15> ZigBeeNode updatedTrustCentre = <line16> new ZigBeeNode(networkManager, trustCentre.getIeeeAddress()); <line17> trustCenterKeyEstablishmentEndpoint = response.getMatchList().get(0); <line18> ZigBeeEndpoint keEndpoint = <line19> new ZigBeeEndpoint(trustCentre, trustCenterKeyEstablishmentEndpoint); <line20> keEndpoint.setProfileId(ZigBeeProfileType.ZIGBEE_SMART_ENERGY.getKey()); <line21> updatedTrustCentre.addEndpoint(keEndpoint); <line22> ZclKeyEstablishmentCluster keCluster = new ZclKeyEstablishmentCluster(keEndpoint); <line23> keEndpoint.addInputCluster(keCluster); <line24> networkManager.updateNode(updatedTrustCentre); <line25> updateClientState(SmartEnergyClientState.PERFORM_KEY_ESTABLISHMENT); <line26> break; <line27> case DISCOVER_METERING_SERVERS: <line28> ZigBeeNode node = networkManager.getNode(response.getSourceAddress().getAddress()); <line29> if (node == null) { <line30> IeeeAddress ieeeAddress = requestIeeeAddress(response.getSourceAddress().getAddress()); <line31> node = new ZigBeeNode(networkManager, ieeeAddress); <line32> networkManager.updateNode(node); <line33> } <line34> if (!cbkeProvider.isAuthorised(node.getIeeeAddress())) { <line35> return; <line36> } <line37> ZigBeeNode updatedNode = <line38> new ZigBeeNode(networkManager, node.getIeeeAddress(), node.getNetworkAddress()); <line39> for (Integer endpointId : response.getMatchList()) { <line40> ZigBeeEndpoint endpoint = new ZigBeeEndpoint(updatedNode, endpointId); <line41> try { <line42> requestSimpleDescriptor(endpoint); <line43> } catch (InterruptedException | ExecutionException e) { <line44> } <line45> updatedNode.addEndpoint(endpoint); <line46> } <line47> setProfileSecurity(updatedNode); <line48> networkManager.updateNode(updatedNode); <line49> discoveryComplete(); <line50> break; <line51> case DISCOVER_KEEP_ALIVE: <line52> if (response.getSourceAddress().getAddress() != 0) { <line53> return; <line54> } <line55> trustCenterKeepAliveEndpoint = response.getMatchList().get(0); <line56> updateClientState(SmartEnergyClientState.KEEP_ALIVE); <line57> break; <line58> default: <line59> break; <line60> } <line61> } <line62> } <line63> 	 <line20>	No
public class A { <line0> @Override <line1> public Void doOperation(KieServicesClient client, Container container) { <line2> KieScannerResource scannerResource = new KieScannerResource(); <line3> scannerResource.setPollInterval(null); <line4> scannerResource.setStatus(KieScannerStatus.SCANNING); <line5> ServiceResponse<KieScannerResource> response = <line6> client.updateScanner(containerSpec.getId(), scannerResource); <line7> if (!response.getType().equals(ServiceResponse.ResponseType.SUCCESS)) { <line8> container.setStatus(KieContainerStatus.FAILED); <line9> } <line10> collectContainerInfo(containerSpec, client, container); <line11> return null; <line12> } <line13> } <line14> 	 <line8>	Yes
"public class A { <line0> @Override <line1> public void submitJobBatches(List<JobQueueBatch> jobBatches) { <line2> JobQueueBatch firstBatch = <line3> jobBatches.stream() <line4> .findFirst() <line5> .orElseThrow(() -> new JobQueueFailure(""No job batches to submit"")); <line6> try (final Session session = this.factory.openSession()) { <line7> final Transaction tx = session.beginTransaction(); <line8> try { <line9> for (JobQueueBatch batch : jobBatches) { <line10> session.persist(batch); <line11> } <line12> tx.commit(); <line13> } catch (Exception e) { <line14> tx.rollback(); <line15> throw new JobQueueFailure(firstBatch.getJobID(), firstBatch.getBatchID(), e); <line16> } <line17> } <line18> } <line19> } <line20> "	 <line6>	Yes
"public class A { <line0> @Override <line1> protected PropertyWidget<?> createPropertyWidget( <line2> final ComponentBuilder componentBuilder, <line3> final ConfiguredPropertyDescriptor propertyDescriptor) { <line4> final PropertyWidget<?> propertyWidget = <line5> super.createPropertyWidget(componentBuilder, propertyDescriptor); <line6> final String propertyName = propertyDescriptor.getName(); <line7> if (""Token target"".equals(propertyName)) { <line8> _tokenTargetPropertyWidget = (SingleEnumPropertyWidget) propertyWidget; <line9> _tokenTargetPropertyWidget.addComboListener( <line10> item -> { <line11> if (_numTokensPropertyWidget == null) { <line12> return; <line13> } <line14> if (item == TokenTarget.ROWS) { <line15> if (!_numTokensPropertyWidget.isSet()) { <line16> _numTokensPropertyWidget.onValueTouched(2); <line17> } <line18> _numTokensPropertyWidget.setEnabled(false); <line19> } else { <line20> _numTokensPropertyWidget.setEnabled(true); <line21> } <line22> }); <line23> if (_numTokensPropertyWidget != null <line24> && _tokenTargetPropertyWidget.getValue() == TokenTarget.ROWS) { <line25> _numTokensPropertyWidget.setEnabled(false); <line26> } <line27> } else if (""Number of tokens"".equals(propertyName)) { <line28> _numTokensPropertyWidget = (SingleNumberPropertyWidget) propertyWidget; <line29> } <line30> return propertyWidget; <line31> } <line32> } <line33> "	 <line12>	Yes
public class A { <line0> @Test <line1> public void testQueryWebPageQueryEmptyResults() throws Exception { <line2> DataStoreTestUtil.testQueryWebPageEmptyResults(webPageStore); <line3> } <line4> } <line5> 	 <line2>	Yes
public class A { <line0> public static com.liferay.journal.model.JournalArticleSoap[] getGroupArticles( <line1> long groupId, <line2> long userId, <line3> long rootFolderId, <line4> int status, <line5> int start, <line6> int end, <line7> com.liferay.portal.kernel.util.OrderByComparator<com.liferay.journal.model.JournalArticle> <line8> orderByComparator) <line9> throws RemoteException { <line10> try { <line11> java.util.List<com.liferay.journal.model.JournalArticle> returnValue = <line12> JournalArticleServiceUtil.getGroupArticles( <line13> groupId, userId, rootFolderId, status, start, end, orderByComparator); <line14> return com.liferay.journal.model.JournalArticleSoap.toSoapModels(returnValue); <line15> } catch (Exception exception) { <line16> throw new RemoteException(exception.getMessage()); <line17> } <line18> } <line19> } <line20> 	 <line16>	Yes
public class A { <line0> private Object getTimestamp(ResultSet resultSet, int columnIndex) throws SQLException { <line1> try { <line2> return resultSet.getTimestamp(columnIndex); <line3> } catch (SQLException e) { <line4> throw (e); <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> public void testInducedFailureOn1pc() throws Exception { <line1> extractInterceptorChain(cache(1)).addInterceptor(new FailInterceptor(), 1); <line2> tm(0).begin(); <line3> cache(0).put(""k"", ""v""); <line4> try { <line5> tm(0).commit(); <line6> assert false : ""Exception expected""; <line7> } catch (Exception e) { <line8> } <line9> fail = false; <line10> assertExpectedState(0); <line11> assertExpectedState(1); <line12> assertExpectedState(2); <line13> } <line14> } <line15> "	 <line5>	No
"public class A { <line0> @SuppressWarnings(""resource"") <line1> private FileLock tryLock(File dir) throws IOException { <line2> File lockF = new File(dir, FILE_LOCK); <line3> lockF.deleteOnExit(); <line4> RandomAccessFile file = new RandomAccessFile(lockF, ""rws""); <line5> FileLock res = null; <line6> try { <line7> res = file.getChannel().tryLock(); <line8> } catch (OverlappingFileLockException oe) { <line9> file.close(); <line10> return null; <line11> } catch (IOException e) { <line12> file.close(); <line13> throw e; <line14> } <line15> return res; <line16> } <line17> } <line18> "	 <line1>	No
public class A { <line0> public static TokenizerEngine create() { <line1> final TokenizerEngine engine = doCreate(); <line2> return engine; <line3> } <line4> } <line5> 	 <line0>	No
public class A { <line0> public String fire(String event) { <line1> try { <line2> fsm.fire(event); <line3> return event; <line4> } catch (Exception e) { <line5> } <line6> return event; <line7> } <line8> } <line9> 	 <line6>	No
public class A { <line0> public KeyInfo getKeyInfo(final PublicKey publicKey) throws SAMLComponentBuilderException { <line1> final KeyInfoBean keyInfoBean = new KeyInfoBean(); <line2> KeyInfo keyInfo = null; <line3> keyInfoBean.setPublicKey(publicKey); <line4> try { <line5> keyInfo = SAML1ComponentBuilder.createKeyInfo(keyInfoBean); <line6> } catch (SecurityException | WSSecurityException e) { <line7> throw new SAMLComponentBuilderException(e.getLocalizedMessage(), e); <line8> } <line9> return keyInfo; <line10> } <line11> } <line12> 	 <line10>	No
public class A { <line0> @Override <line1> protected boolean onAccessDenied( <line2> final ServletRequest servletRequest, final ServletResponse servletResponse) throws Exception { <line3> HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; <line4> if (StringUtils.equals(HttpMethod.OPTIONS.name(), httpServletRequest.getMethod())) { <line5> return true; <line6> } <line7> String tokenValue = httpServletRequest.getHeader(HEAD_TOKEN); <line8> if (StringUtils.isBlank(tokenValue)) { <line9> unionFailResponse(servletResponse); <line10> return false; <line11> } <line12> StatelessToken token = new StatelessToken(); <line13> token.setToken(tokenValue); <line14> Subject subject = getSubject(servletRequest, servletResponse); <line15> try { <line16> subject.login(token); <line17> } catch (Exception e) { <line18> unionFailResponse(servletResponse); <line19> return false; <line20> } <line21> return true; <line22> } <line23> } <line24> 	 <line4>	No
public class A { <line0> @Override <line1> public void report(final Measurement measurement) throws ReportingException { <line2> switch (level) { <line3> case DEBUG: <line4> if (log.isDebugEnabled()) { <line5> } <line6> break; <line7> case ERROR: <line8> break; <line9> case FATAL: <line10> break; <line11> case INFO: <line12> if (log.isInfoEnabled()) { <line13> } <line14> break; <line15> case TRACE: <line16> if (log.isTraceEnabled()) { <line17> } <line18> break; <line19> case WARN: <line20> break; <line21> } <line22> } <line23> } <line24> 	 <line0>	No
"public class A { <line0> private static void chkOutput() throws Exception { <line1> File file = new File(FILE_PATH); <line2> final int MAX = 60; <line3> for (int i = 0; i < MAX && (!file.exists()); ++i) { <line4> Thread.sleep(1000); <line5> } <line6> if (!file.exists()) { <line7> String msg = String.format(""Error: %s not found after %d seconds%n"", FILE_PATH, MAX); <line8> throw new RuntimeException(msg); <line9> } <line10> } <line11> } <line12> "	 <line1>	No
"public class A { <line0> @Override <line1> public void run() { <line2> Map<String, String> map = new HashMap<String, String>(); <line3> int processedRels = 0; <line4> Transaction tx = graphDb.beginTx(); <line5> ResourceIterable<Relationship> rels = graphDb.getAllRelationships(); <line6> for (Relationship rel : rels) { <line7> if (processedRels % batchCommitSize == 0) { <line8> tx.success(); <line9> tx.close(); <line10> tx = graphDb.beginTx(); <line11> } <line12> String relName = rel.getType().name(); <line13> if (map.containsKey(relName)) { <line14> rel.setProperty(edgeProperty, map.get(relName)); <line15> } else { <line16> String relLabel = relName; <line17> String query = ""START n = node:node_auto_index(iri='"" + relName + ""') match (n) return n""; <line18> Result result = graphDb.execute(query); <line19> if (result.hasNext()) { <line20> Node n = (Node) result.next().get(""n""); <line21> if (n.hasProperty(NodeProperties.LABEL)) { <line22> relLabel = <line23> GraphUtil.getProperties(n, NodeProperties.LABEL, String.class).iterator().next(); <line24> } <line25> } <line26> rel.setProperty(edgeProperty, relLabel); <line27> map.put(relName, relLabel); <line28> } <line29> processedRels++; <line30> } <line31> tx.success(); <line32> tx.close(); <line33> } <line34> } <line35> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void write(OutputStream out) throws IOException { <line2> try { <line3> IOUtils.copy(stream.getInputStream(), out); <line4> } catch (IOException ex) { <line5> throw ex; <line6> } <line7> } <line8> } <line9> 	 <line1>	No
public class A { <line0> public static void testAutoSyncHibernateSessionStateOnTxCreation() throws RemoteException { <line1> try { <line2> PortalServiceUtil.testAutoSyncHibernateSessionStateOnTxCreation(); <line3> } catch (Exception exception) { <line4> throw new RemoteException(exception.getMessage()); <line5> } <line6> } <line7> } <line8> 	 <line5>	No
public class A { <line0> private List<Entitlement> filterByConsumers( <line1> Set<Consumer> consumers, List<Entitlement> entitlements) { <line2> Map<String, List<Entitlement>> entitlementsByConsumerUuid = groupByConsumerUuid(entitlements); <line3> List<Entitlement> filteredEntitlements = new ArrayList<>(consumers.size()); <line4> for (Consumer consumer : consumers) { <line5> if (entitlementsByConsumerUuid.containsKey(consumer.getUuid())) { <line6> final List<Entitlement> foundEntitlements = <line7> entitlementsByConsumerUuid.get(consumer.getUuid()); <line8> filteredEntitlements.addAll(foundEntitlements); <line9> } <line10> } <line11> return filteredEntitlements; <line12> } <line13> } <line14> 	 <line13>	No
"public class A { <line0> public List<GenSolvablePolynomial<C>> call() { <line1> try { <line2> List<GenSolvablePolynomial<C>> G = e1.twosidedGB(modv, F); <line3> if (debug) { <line4> } <line5> return G; <line6> } catch (PreemptingException e) { <line7> throw new RuntimeException(""SGBProxy e1 preempted "" + e); <line8> } catch (Exception e) { <line9> throw new RuntimeException(""SGBProxy e1 "" + e); <line10> } <line11> } <line12> } <line13> "	 <line0>	No
"public class A { <line0> public FlowInfo parse(final File flowConfigurationFile) { <line1> if (flowConfigurationFile == null) { <line2> return null; <line3> } <line4> final Path flowPath = flowConfigurationFile.toPath(); <line5> try { <line6> if (!Files.exists(flowPath) || Files.size(flowPath) == 0) { <line7> return null; <line8> } <line9> } catch (IOException e) { <line10> return null; <line11> } <line12> try (final InputStream in = Files.newInputStream(flowPath, StandardOpenOption.READ); <line13> final InputStream gzipIn = new GZIPInputStream(in)) { <line14> final byte[] flowBytes = IOUtils.toByteArray(gzipIn); <line15> if (flowBytes == null || flowBytes.length == 0) { <line16> return null; <line17> } <line18> final DocumentBuilder docBuilder = XmlUtils.createSafeDocumentBuilder(flowSchema); <line19> docBuilder.setErrorHandler(new LoggingXmlParserErrorHandler(""Flow Configuration"", logger)); <line20> final Document document = docBuilder.parse(new ByteArrayInputStream(flowBytes)); <line21> final Element rootElement = document.getDocumentElement(); <line22> final Element rootGroupElement = <line23> (Element) rootElement.getElementsByTagName(""rootGroup"").item(0); <line24> if (rootGroupElement == null) { <line25> return null; <line26> } <line27> final Element rootGroupIdElement = <line28> (Element) rootGroupElement.getElementsByTagName(""id"").item(0); <line29> if (rootGroupIdElement == null) { <line30> return null; <line31> } <line32> final String rootGroupId = rootGroupIdElement.getTextContent(); <line33> final List<PortDTO> ports = new ArrayList<>(); <line34> ports.addAll(getPorts(rootGroupElement, ""inputPort"")); <line35> ports.addAll(getPorts(rootGroupElement, ""outputPort"")); <line36> return new FlowInfo(rootGroupId, ports); <line37> } catch (final SAXException | ParserConfigurationException | IOException ex) { <line38> return null; <line39> } <line40> } <line41> } <line42> "	 <line34>	No
"public class A { <line0> private void monitorThreads(Function<Boolean, Boolean> onShutdownCallback) { <line1> Executors.newSingleThreadExecutor( <line2> r -> { <line3> Thread t = new Thread(r, ""Monitor Thread""); <line4> t.setDaemon(isRunInDaemonMode()); <line5> return t; <line6> }) <line7> .submit( <line8> () -> { <line9> boolean error = false; <line10> try { <line11> future.get(); <line12> } catch (ExecutionException ex) { <line13> error = true; <line14> } catch (InterruptedException ie) { <line15> error = true; <line16> } finally { <line17> shutdown = true; <line18> if (null != onShutdownCallback) { <line19> onShutdownCallback.apply(error); <line20> } <line21> shutdown(false); <line22> } <line23> }); <line24> } <line25> } <line26> "	 <line1>	Yes
"public class A { <line0> @Override <line1> protected String getTemplateDirectory() { <line2> try { <line3> URL url = <line4> FileLocator.find( <line5> Activator.getDefault().getBundle(), <line6> new Path(""/WebContent/WEB-INF/reportDeposit/""), <line7> null); <line8> URL fileUrl = FileLocator.toFileURL(url); <line9> return FileUtils.toFile(fileUrl).getAbsolutePath(); <line10> } catch (IOException ex) { <line11> } <line12> return null; <line13> } <line14> } <line15> "	 <line3>	No
"public class A { <line0> private List<FloodlightOFAction> parseActions(JsonParser jp) <line1> throws JsonParseException, IOException { <line2> List<FloodlightOFAction> actions = new ArrayList<FloodlightOFAction>(); <line3> if (jp.getCurrentToken() != JsonToken.START_ARRAY) { <line4> throw new IOException(""Expected START_ARRAY and it was "" + jp.getCurrentToken()); <line5> } <line6> while (jp.nextToken() != JsonToken.END_ARRAY) { <line7> if (jp.getCurrentToken() != JsonToken.START_OBJECT) { <line8> throw new IOException(""Expected START_OBJECT and it was "" + jp.getCurrentToken()); <line9> } <line10> Map<String, String> actionMap = new HashMap<String, String>(); <line11> while (jp.nextToken() != JsonToken.END_OBJECT) { <line12> if (jp.getCurrentToken() != JsonToken.FIELD_NAME) { <line13> throw new IOException(""Expected FIELD_NAME and it was "" + jp.getCurrentToken()); <line14> } <line15> String fieldName = jp.getCurrentName(); <line16> jp.nextToken(); <line17> actionMap.put(fieldName.toLowerCase(), jp.getText()); <line18> } <line19> if (actionMap.get(""type"").equalsIgnoreCase(FloodlightOFAction.TYPE_OUTPUT.toLowerCase())) { <line20> FloodlightOFAction action = new FloodlightOFAction(); <line21> action.setType(FloodlightOFAction.TYPE_OUTPUT.toLowerCase()); <line22> action.setValue(actionMap.get(""port"")); <line23> actions.add(action); <line24> } else { <line25> } <line26> } <line27> return actions; <line28> } <line29> } <line30> "	 <line7>	No
public class A { <line0> @Override <line1> public Iterable<V> get(ByteString key, W window) { <line2> try (Locker locker = Locker.locked(stateBackendLock)) { <line3> prepareStateBackend(key); <line4> StateNamespace namespace = StateNamespaces.window(windowCoder, window); <line5> if (LOG.isDebugEnabled()) { <line6> } <line7> BagState<V> bagState = <line8> stateInternals.state(namespace, StateTags.bag(userStateId, valueCoder)); <line9> return bagState.read(); <line10> } <line11> } <line12> } <line13> 	 <line1>	No
"public class A { <line0> private static void createExperimentEntities() { <line1> ExperimentTest experimentTest = new ExperimentTest(); <line2> CreateExperiment createExperimentRequest = <line3> experimentTest.getCreateExperimentRequest(project.getId(), ""Experiment_1""); <line4> CreateExperiment.Response createExperimentResponse = <line5> experimentServiceStub.createExperiment(createExperimentRequest); <line6> experiment = createExperimentResponse.getExperiment(); <line7> assertEquals( <line8> ""Experiment name not match with expected Experiment name"", <line9> createExperimentRequest.getName(), <line10> experiment.getName()); <line11> } <line12> } <line13> "	 <line7>	Yes
public class A { <line0> private void schedulePing() { <line1> EventBusOptions options = eventBus.options(); <line2> pingTimeoutID = <line3> vertx.setTimer( <line4> options.getClusterPingInterval(), <line5> id1 -> { <line6> timeoutID = <line7> vertx.setTimer( <line8> options.getClusterPingReplyInterval(), <line9> id2 -> { <line10> close(); <line11> }); <line12> ClusteredMessage pingMessage = <line13> new ClusteredMessage<>( <line14> remoteNodeId, <line15> PING_ADDRESS, <line16> null, <line17> null, <line18> new PingMessageCodec(), <line19> true, <line20> eventBus); <line21> Buffer data = pingMessage.encodeToWire(); <line22> socket.write(data); <line23> }); <line24> } <line25> } <line26> 	 <line10>	Yes
"public class A { <line0> private void processQueryResult(Result<DynamoDBKey, Person> pQueryResult) { <line1> try { <line2> while (pQueryResult.next()) printPersonInfo(pQueryResult.get()); <line3> } catch (IOException e) { <line4> log.error(""error while processing tests results."", e.getMessage()); <line5> throw new RuntimeException(e); <line6> } catch (Exception e) { <line7> throw new RuntimeException(e); <line8> } <line9> } <line10> } <line11> "	 <line8>	No
"public class A { <line0> @DisplayName( <line1> ""Gather all derived tables, export data up to height = 8000,"" <line2> + "" delete rows up to height = 8000, import data back into db table"") <line3> @Test <line4> void testExportAndImportData() { <line5> DirProvider dirProvider = mock(DirProvider.class); <line6> doReturn(temporaryFolderExtension.newFolder(""csvExport"").toPath()) <line7> .when(dirProvider) <line8> .getDataExportDir(); <line9> Set<String> excludeColumnNames = Set.of(""DB_ID"", ""LATEST""); <line10> Collection<DerivedTableInterface> result = registry.getDerivedTables(); <line11> assertNotNull(result); <line12> int targetHeight = Integer.MAX_VALUE; <line13> result.forEach( <line14> item -> { <line15> assertNotNull(item); <line16> long minDbValue = 0; <line17> long maxDbValue = 0; <line18> int processedCount = 0; <line19> int totalCount = 0; <line20> int batchLimit = 1; <line21> try (Connection con = extension.getDatabaseManager().getDataSource().getConnection(); <line22> PreparedStatement pstmt = <line23> con.prepareStatement( <line24> ""select * from "" <line25> + item.toString() <line26> + "" where db_id BETWEEN ? and  ? limit ?""); <line27> CsvWriter csvWriter = <line28> new CsvWriterImpl( <line29> dirProvider.getDataExportDir(), excludeColumnNames, translator); ) { <line30> csvWriter.setOptions(""fieldDelimiter=""); <line31> MinMaxValue minMaxValue = item.getMinMaxValue(targetHeight); <line32> minDbValue = minMaxValue.getMin(); <line33> maxDbValue = minMaxValue.getMax(); <line34> assertTrue(minMaxValue.getMax() >= 0); <line35> if (minMaxValue.getCount() > 0) { <line36> do { <line37> CsvExportData csvExportData = <line38> csvWriter.append( <line39> item.toString(), item.getRangeByDbId(con, pstmt, minMaxValue, batchLimit)); <line40> processedCount = csvExportData.getProcessCount(); <line41> if (processedCount > 0) { <line42> minMaxValue.setMin((Long) csvExportData.getLastRow().get(""DB_ID"") + 1); <line43> } <line44> totalCount += processedCount; <line45> } while (processedCount > 0); <line46> assertEquals(minMaxValue.getCount(), totalCount); <line47> int deletedCount = dropDataByName(minDbValue, maxDbValue, item.toString()); <line48> assertEquals(minMaxValue.getCount(), deletedCount); <line49> int imported = importCsv(item.toString(), batchLimit, dirProvider.getDataExportDir()); <line50> assertEquals( <line51> minMaxValue.getCount(), <line52> imported, <line53> ""incorrect value for '"" + item.toString() + ""'""); <line54> } <line55> } catch (Exception e) { <line56> Throwables.throwIfUnchecked(e); <line57> throw new RuntimeException(e); <line58> } <line59> }); <line60> } <line61> } <line62> "	 <line11>	No
public class A { <line0> private static void delete(File file) { <line1> if (file.isDirectory()) { <line2> for (File subFile : file.listFiles()) { <line3> delete(subFile); <line4> } <line5> } <line6> if (file.exists() && !file.delete()) { <line7> } <line8> } <line9> } <line10> 	 <line7>	Yes
public class A { <line0> @Override <line1> public T get(int arg0) { <line2> if (serviceMap.values() != null) { <line3> ArrayList<T> list = new ArrayList<T>(serviceMap.values()); <line4> return list.get(arg0); <line5> } <line6> return null; <line7> } <line8> } <line9> 	 <line0>	No
public class A { <line0> @Override <line1> protected void shutDown() throws Exception { <line2> shuttingDown = true; <line3> offsetFlusherFuture.cancel(false); <line4> logRetentionFuture.cancel(false); <line5> checkpointFlusherFuture.cancel(false); <line6> dirtyLogFlushFuture.cancel(false); <line7> kafkaScheduler.shutdown(); <line8> logManager.shutdown(); <line9> offsetFlusher.run(); <line10> teardownLogMetrics(); <line11> } <line12> } <line13> 	 <line4>	No
public class A { <line0> public void cleanup() { <line1> long leakedValues = localValue.getAndSet(0); <line2> if (leakedValues == 0) { <line3> return; <line4> } <line5> totalValue.addAndGet(-leakedValues); <line6> } <line7> } <line8> 	 <line4>	No
"public class A { <line0> private static void move(InterpretationPipelineOptions options, String from, String to) { <line1> String targetPath = options.getTargetPath(); <line2> String deletePath = <line3> PathBuilder.buildPath(targetPath, to, options.getDatasetId() + ""_*"").toString(); <line4> FsUtils.deleteByPattern( <line5> options.getHdfsSiteConfig(), options.getCoreSiteConfig(), targetPath, deletePath); <line6> String filter = PathBuilder.buildFilePathViewUsingInputPath(options, from, ""*.avro""); <line7> String movePath = PathBuilder.buildPath(targetPath, to).toString(); <line8> FsUtils.moveDirectory( <line9> options.getHdfsSiteConfig(), options.getCoreSiteConfig(), movePath, filter); <line10> } <line11> } <line12> "	 <line8>	Yes
"public class A { <line0> private MessageEvent unexpectedError(Exception exception) { <line1> MessageEvent msg = new MessageEvent(MessageEventEnum.DATA_OPERATION_ERROR_UNEXPECTED); <line2> msg.setDescription(msg.getDescription().replace(""%DESCRIPTION%"", exception.toString())); <line3> return msg; <line4> } <line5> } <line6> "	 <line1>	Yes
"public class A { <line0> @Override <line1> public ListenableFuture<SegmentsAndCommitMetadata> push( <line2> final Collection<SegmentIdWithShardSpec> identifiers, <line3> @Nullable final Committer committer, <line4> final boolean useUniquePath) { <line5> final Map<SegmentIdWithShardSpec, Sink> theSinks = new HashMap<>(); <line6> AtomicLong pushedHydrantsCount = new AtomicLong(); <line7> for (final SegmentIdWithShardSpec identifier : identifiers) { <line8> final Sink sink = sinks.get(identifier); <line9> if (sink == null) { <line10> throw new ISE(""No sink for identifier: %s"", identifier); <line11> } <line12> theSinks.put(identifier, sink); <line13> if (sink.finishWriting()) { <line14> totalRows.addAndGet(-sink.getNumRows()); <line15> } <line16> pushedHydrantsCount.addAndGet(Iterables.size(sink)); <line17> } <line18> return Futures.transform( <line19> persistAll(committer), <line20> (Function<Object, SegmentsAndCommitMetadata>) <line21> commitMetadata -> { <line22> final List<DataSegment> dataSegments = new ArrayList<>(); <line23> for (Map.Entry<SegmentIdWithShardSpec, Sink> entry : theSinks.entrySet()) { <line24> if (droppingSinks.contains(entry.getKey())) { <line25> continue; <line26> } <line27> final DataSegment dataSegment = <line28> mergeAndPush(entry.getKey(), entry.getValue(), useUniquePath); <line29> if (dataSegment != null) { <line30> dataSegments.add(dataSegment); <line31> } else { <line32> } <line33> } <line34> return new SegmentsAndCommitMetadata(dataSegments, commitMetadata); <line35> }, <line36> pushExecutor); <line37> } <line38> } <line39> "	 <line1>	No
public class A { <line0> @Override <line1> public Flux<IType> allSubtypesOf(String fqName, boolean includeFocusType, boolean detailed) { <line2> JavaTypeHierarchyParams searchParams = <line3> new JavaTypeHierarchyParams(projectUri.toString(), fqName, includeFocusType, detailed); <line4> try { <line5> CompletableFuture<List<IType>> future = <line6> subtypesCache.get( <line7> searchParams, <line8> () -> <line9> client <line10> .javaSubTypes(searchParams) <line11> .handle( <line12> (results, exception) -> <line13> results.stream() <line14> .map( <line15> e -> <line16> detailed <line17> ? toType(e.getRight()) <line18> : toTypeFromDescriptor(e.getLeft())) <line19> .collect(Collectors.toList()))); <line20> return Mono.fromFuture(future).flatMapMany(results -> Flux.fromIterable(results)); <line21> } catch (ExecutionException e) { <line22> return Flux.empty(); <line23> } <line24> } <line25> } <line26> 	 <line24>	No
"public class A { <line0> @Override <line1> public void run() { <line2> boolean success = false; <line3> try (final Context context = metrics.getDownloadTimer().time()) { <line4> success = download(); <line5> if (!success) { <line6> metrics.getServerErrorsMeter().mark(); <line7> getResponse().sendError(500, ""Hit client timeout""); <line8> } <line9> } catch (Throwable t) { <line10> metrics.getServerErrorsMeter().mark(); <line11> exceptionNotifier.notify( <line12> String.format(""Error handling download (%s)"", t.getMessage()), <line13> t, <line14> ImmutableMap.of( <line15> ""s3Bucket"", <line16> artifactDownloadRequest.getS3Artifact().getS3Bucket(), <line17> ""s3Key"", <line18> artifactDownloadRequest.getS3Artifact().getS3ObjectKey(), <line19> ""targetDirectory"", <line20> artifactDownloadRequest.getTargetDirectory())); <line21> try { <line22> getResponse().sendError(500); <line23> } catch (Throwable t2) { <line24> } <line25> } finally { <line26> continuation.complete(); <line27> } <line28> } <line29> } <line30> "	 <line0>	No
"public class A { <line0> static void abort(AppContext context, RepairSegment segment, JmxProxy jmxConnection) { <line1> postpone(context, segment, context.storage.getRepairUnit(segment.getRepairUnitId())); <line2> String metric = <line3> MetricRegistry.name( <line4> SegmentRunner.class, <line5> ""abort"", <line6> Optional.ofNullable(segment.getCoordinatorHost()).orElse(""null"").replace('.', '-')); <line7> context.metricRegistry.counter(metric).inc(); <line8> jmxConnection.cancelAllRepairs(); <line9> } <line10> } <line11> "	 <line4>	No
public class A { <line0> private boolean thereIsWriteAuthorizationFor(Order order) { <line1> String loginName = SecurityUtils.getSessionUserLoginName(); <line2> try { <line3> User user = userDAO.findByLoginName(loginName); <line4> for (OrderAuthorization authorization : <line5> orderAuthorizationDAO.listByOrderUserAndItsProfiles(order, user)) { <line6> if (authorization.getAuthorizationType() == OrderAuthorizationType.WRITE_AUTHORIZATION) { <line7> return true; <line8> } <line9> } <line10> } catch (InstanceNotFoundException e) { <line11> } <line12> return false; <line13> } <line14> } <line15> 	 <line2>	No
"public class A { <line0> @ProcessElement <line1> public void processElement( <line2> ProcessContext context, <line3> @StateId(""valueState"") ValueState<Integer> intValueState, <line4> @StateId(""bagState"") BagState<Integer> intBagState) { <line5> long value = Objects.requireNonNull(context.element().getValue()); <line6> if (value == 0L) { <line7> intValueState.write(42); <line8> intBagState.add(40); <line9> intBagState.add(1); <line10> intBagState.add(1); <line11> } else if (value >= 1) { <line12> oneShotLatch.countDown(); <line13> } <line14> } <line15> } <line16> "	 <line5>	No
"public class A { <line0> private void assertEqualXMLConfigurations( <line1> String expectedXMLConfiguration, String generatedXMLConfiguration) <line2> throws IOException, SAXException, TransformerException, ParserConfigurationException { <line3> Assert.assertTrue( <line4> ""Generated configuration XML and expected configuration XML must be equal"", <line5> XmlHelper.compareXMLStrings(generatedXMLConfiguration, expectedXMLConfiguration)); <line6> } <line7> } <line8> "	 <line2>	No
"public class A { <line0> public List<DexOrder> getOverdueOrders(int currentTime) { <line1> List<DexOrder> dexOrders = new ArrayList<>(); <line2> try (Connection con = getDatabaseManager().getDataSource().getConnection(); <line3> PreparedStatement pstmt = <line4> con.prepareStatement( <line5> ""SELECT * FROM dex_offer AS offer where latest = true "" <line6> + ""AND offer.status = 0 AND offer.finish_time < ?"")) { <line7> int i = 0; <line8> pstmt.setLong(++i, currentTime); <line9> DbIterator<DexOrder> orders = getManyBy(con, pstmt, true); <line10> return CollectionUtil.toList(orders); <line11> } catch (SQLException ex) { <line12> } <line13> return dexOrders; <line14> } <line15> } <line16> "	 <line13>	No
public class A { <line0> @Override <line1> public void error(String format, Object argument) { <line2> if (isErrorEnabled()) { <line3> FormattingTuple formattingTuple = MessageFormatter.format(format, argument); <line4> } <line5> } <line6> } <line7> 	 <line2>	No
"public class A { <line0> private UpdateResponse doRemoteUpdate(UpdateRequest updateRequest) { <line1> HashSet<ProcessingDetails> exceptions = new HashSet<>(); <line2> Map<String, Serializable> properties = new HashMap<>(); <line3> List<CatalogStore> stores = <line4> opsCatStoreSupport.getCatalogStoresForRequest(updateRequest, exceptions); <line5> List<Update> updates = new ArrayList<>(); <line6> for (CatalogStore store : stores) { <line7> try { <line8> if (!store.isAvailable()) { <line9> exceptions.add( <line10> new ProcessingDetailsImpl(store.getId(), null, ""CatalogStore is not available"")); <line11> } else { <line12> UpdateResponse response = store.update(updateRequest); <line13> properties.put(store.getId(), new ArrayList<>(response.getUpdatedMetacards())); <line14> updates = response.getUpdatedMetacards(); <line15> } <line16> } catch (IngestException e) { <line17> exceptions.add(new ProcessingDetailsImpl(store.getId(), e)); <line18> } <line19> } <line20> return new UpdateResponseImpl(updateRequest, properties, updates, exceptions); <line21> } <line22> } <line23> "	 <line20>	No
"public class A { <line0> @Test <line1> public void testReaderRead() throws Exception { <line2> BeanConfig config = new BeanConfig(); <line3> config.setHost(""localhost:8080""); <line4> config.setSchemes(new String[] {""http""}); <line5> config.setBasePath(""/api""); <line6> config.setTitle(""Day""); <line7> config.setLicense(""Apache 2.0""); <line8> config.setLicenseUrl(""http://www.apache.org/licenses/LICENSE-2.0.html""); <line9> config.setVersion(""2.0""); <line10> RestOpenApiReader reader = new RestOpenApiReader(); <line11> OasDocument openApi = <line12> reader.read( <line13> context, <line14> context.getRestDefinitions(), <line15> null, <line16> config, <line17> context.getName(), <line18> new DefaultClassResolver()); <line19> assertNotNull(openApi); <line20> ObjectMapper mapper = new ObjectMapper(); <line21> mapper.enable(SerializationFeature.INDENT_OUTPUT); <line22> mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); <line23> Object dump = Library.writeNode(openApi); <line24> String json = mapper.writeValueAsString(dump); <line25> assertTrue(json.contains(""\""host\"" : \""localhost:8080\"""")); <line26> assertTrue(json.contains(""\""default\"" : \""friday\"""")); <line27> assertTrue( <line28> json.contains( <line29> ""\""enum\"" : [ \""monday\"", \""tuesday\"", \""wednesday\"", \""thursday\"", \""friday\"" ]"")); <line30> assertTrue(json.contains(""\""$ref\"" : \""#/definitions/DayResponse\"""")); <line31> assertTrue(json.contains(""\""format\"" : \""org.apache.camel.openapi.DayResponse\"""")); <line32> assertTrue(json.contains(""\""X-Rate-Limit-Limit\"" : {"")); <line33> assertTrue( <line34> json.contains( <line35> ""\""description\"" : \""The number of allowed requests in the current period\"""")); <line36> context.stop(); <line37> } <line38> } <line39> "	 <line13>	No
"public class A { <line0> @Override <line1> public synchronized void registerJSONWebServiceAction( <line2> String contextName, <line3> String contextPath, <line4> Object actionObject, <line5> Class<?> actionClass, <line6> Method actionMethod, <line7> String path, <line8> String method) { <line9> try { <line10> if (!_addJSONWebServiceActionConfig( <line11> new JSONWebServiceActionConfig( <line12> contextName, contextPath, actionObject, actionClass, actionMethod, path, method))) { <line13> if (_log.isWarnEnabled()) { <line14> } <line15> } <line16> } catch (Exception exception) { <line17> StringBundler sb = new StringBundler(17); <line18> sb.append(""Something went wrong attempting to register service ""); <line19> sb.append(""method {contextName=""); <line20> sb.append(contextName); <line21> sb.append("",contextPath=""); <line22> sb.append(contextPath); <line23> sb.append("",actionObject=""); <line24> sb.append(actionObject); <line25> sb.append("",actionClass=""); <line26> sb.append(actionClass); <line27> sb.append("",actionMethod=""); <line28> sb.append(actionMethod); <line29> sb.append("",path=""); <line30> sb.append(path); <line31> sb.append("",method=""); <line32> sb.append(method); <line33> sb.append(""} due to ""); <line34> sb.append(exception.getMessage()); <line35> } <line36> } <line37> } <line38> "	 <line12>	No
"public class A { <line0> public static RangerAdminClient createAdminClient(RangerPluginConfig pluginConfig) { <line1> if (LOG.isDebugEnabled()) { <line2> } <line3> RangerAdminClient ret = null; <line4> String propertyName = pluginConfig.getPropertyPrefix() + "".policy.source.impl""; <line5> String policySourceImpl = pluginConfig.get(propertyName); <line6> if (StringUtils.isEmpty(policySourceImpl)) { <line7> if (LOG.isDebugEnabled()) { <line8> } <line9> } else { <line10> if (LOG.isDebugEnabled()) { <line11> } <line12> try { <line13> @SuppressWarnings(""unchecked"") <line14> Class<RangerAdminClient> adminClass = <line15> (Class<RangerAdminClient>) Class.forName(policySourceImpl); <line16> ret = adminClass.newInstance(); <line17> } catch (Exception excp) { <line18> } <line19> } <line20> if (ret == null) { <line21> ret = new RangerAdminRESTClient(); <line22> } <line23> ret.init( <line24> pluginConfig.getServiceName(), <line25> pluginConfig.getAppId(), <line26> pluginConfig.getPropertyPrefix(), <line27> pluginConfig); <line28> if (LOG.isDebugEnabled()) { <line29> } <line30> return ret; <line31> } <line32> } <line33> "	 <line3>	No
public class A { <line0> private void scheduleTMRequest(GetTranslationMemory action) { <line1> lastRequest = action; <line2> if (submittedRequest == null) { <line3> submitTMRequest(action); <line4> } else { <line5> } <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> public void onGroupRenamed(UDGroup group) { <line1> Isy99iFrame.writeAreaLog( <line2> Isy99iUtilities.getDateTime() <line3> + "": Scene: "" <line4> + group.address <line5> + "" was removed by someone or something!""); <line6> } <line7> } <line8> "	 <line6>	Yes
"public class A { <line0> @Test <line1> public void listAllPreparedQueriesByUser() throws Exception { <line2> String user = ""diff"", pass = ""diff""; <line3> String session1 = sHelper.openSession(user, pass, lens.getCurrentDB()); <line4> QueryPrepareHandle queryPrepareHandle1 = qHelper.submitPreparedQuery(QueryInventory.QUERY); <line5> Assert.assertNotEquals(queryPrepareHandle1, null, ""Query Execute Failed""); <line6> QueryPrepareHandle queryPrepareHandle2 = <line7> qHelper.submitPreparedQuery(QueryInventory.QUERY, null, session1); <line8> Assert.assertNotEquals(queryPrepareHandle2, null, ""Query Execute Failed""); <line9> List<QueryPrepareHandle> list = qHelper.getPreparedQueryHandleList(null, lens.getUserName()); <line10> Assert.assertTrue( <line11> list.contains(queryPrepareHandle1), ""List of All QueryPreparedHandle By user failed""); <line12> list = qHelper.getPreparedQueryHandleList(null, user); <line13> Assert.assertTrue( <line14> list.contains(queryPrepareHandle2), ""List of All QueryPreparedHandle By user failed""); <line15> list = qHelper.getPreparedQueryHandleList(null, ""all""); <line16> Assert.assertTrue( <line17> list.contains(queryPrepareHandle1), ""List of All QueryPreparedHandle by 'all' user failed""); <line18> Assert.assertTrue( <line19> list.contains(queryPrepareHandle2), ""List of All QueryPreparedHandle by 'all' user failed""); <line20> } <line21> } <line22> "	 <line2>	No
"public class A { <line0> @Test <line1> public void add_failure() { <line2> IndexIndexer indexer = index.createIndexer(); <line3> setupHelper.getBackendAccessor().ensureIndexingOperationsFail(index.name()); <line4> CompletableFuture<?> future = <line5> indexer.add( <line6> referenceProvider(""1""), <line7> document -> document.addValue(index.binding().title, ""Document #1""), <line8> commitStrategy, <line9> refreshStrategy); <line10> Awaitility.await().until(future::isDone); <line11> assertThatFuture(future).isFailed(); <line12> try { <line13> setupHelper.cleanUp(); <line14> } catch (RuntimeException | IOException e) { <line15> } <line16> } <line17> } <line18> "	 <line15>	Yes
public class A { <line0> @Override <line1> protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress) <line2> throws Exception { <line3> if (localAddress != null) { <line4> socket.bind(localAddress); <line5> } <line6> boolean success = false; <line7> try { <line8> socket.connect(remoteAddress); <line9> success = true; <line10> } finally { <line11> if (!success) { <line12> try { <line13> socket.close(); <line14> } catch (Throwable t) { <line15> } <line16> } <line17> } <line18> } <line19> } <line20> 	 <line15>	Yes
public class A { <line0> @Override <line1> public void aggregateTemporal( <line2> BinContext ctx, Vector spatialVector, int numSpatialObs, WritableVector temporalVector) { <line3> final float value = spatialVector.get(0); <line4> final float currentMax = temporalVector.get(0); <line5> if (value > currentMax) { <line6> temporalVector.set(0, value); <line7> for (int i = 0; i < numSetFeatures + 1; i++) { <line8> temporalVector.set(i + 1, spatialVector.get(i + 1)); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line4>	Yes
"public class A { <line0> protected void checkAnyPermission(String permissions[], String instanceId) { <line1> if (!isAnyPermitted(permissions, instanceId)) { <line2> throw new ForbiddenException(""Not authorized to access resource id <"" + instanceId + "">""); <line3> } <line4> } <line5> } <line6> "	 <line1>	No
public class A { <line0> private void startPollStatus() { <line1> Runnable runnable = <line2> () -> { <line3> tivoConnection.ifPresent( <line4> connection -> { <line5> try { <line6> connection.statusRefresh(); <line7> } catch (InterruptedException e) { <line8> } <line9> }); <line10> }; <line11> if (tivoConfigData.isKeepConnActive()) { <line12> refreshJob = scheduler.schedule(runnable, INIT_POLLING_DELAY_S, TimeUnit.SECONDS); <line13> } else if (tivoConfigData.doPollChanges()) { <line14> refreshJob = <line15> scheduler.scheduleWithFixedDelay( <line16> runnable, INIT_POLLING_DELAY_S, tivoConfigData.getPollInterval(), TimeUnit.SECONDS); <line17> } else { <line18> tivoConnection.ifPresent( <line19> connection -> { <line20> try { <line21> connection.statusRefresh(); <line22> } catch (InterruptedException e) { <line23> } <line24> }); <line25> } <line26> } <line27> } <line28> 	 <line25>	No
public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> addByName(null, adaptorName, type, params, offset, numRetries, retryInterval); <line4> } catch (Exception e) { <line5> e.printStackTrace(); <line6> } <line7> } <line8> } <line9> 	 <line7>	No
public class A { <line0> @Override <line1> public void accept(RedisMeta redisMeta) { <line2> if (!isInterestedInCluster(redisMeta.parent().parent())) { <line3> return; <line4> } <line5> instanceManager.getOrCreate(redisMeta).getCheckInfo().isMaster(redisMeta.isMaster()); <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> @SuppressWarnings({""unchecked"", ""rawtypes""}) <line1> private int compare(final T o1, final T o2, final String prop, final boolean asc) { <line2> if (prop == null) { <line3> return 0; <line4> } <line5> try { <line6> final Object value1 = BeanHelper.getNestedProperty(o1, prop); <line7> final Object value2 = BeanHelper.getNestedProperty(o2, prop); <line8> if (value1 == null) { <line9> if (value2 == null) return 0; <line10> else return (asc) ? -1 : 1; <line11> } <line12> if (value2 == null) { <line13> return (asc) ? 1 : -1; <line14> } <line15> if (value1 instanceof String && value2 instanceof String) { <line16> if (checkAnnotation( <line17> BeanHelper.getDeclaredAnnotations(o1.getClass(), prop), <line18> StringAlphanumericSort.class) <line19> && checkAnnotation( <line20> BeanHelper.getDeclaredAnnotations(o2.getClass(), prop), <line21> StringAlphanumericSort.class)) { <line22> AlphanumericComparator alphanumericComparator = <line23> new AlphanumericComparator(ThreadLocalUserContext.getLocale()); <line24> if (asc) { <line25> return alphanumericComparator.compare((String) value2, (String) value1); <line26> } else { <line27> return alphanumericComparator.compare((String) value1, (String) value2); <line28> } <line29> } else { <line30> return StringComparator.compare((String) value1, (String) value2, asc); <line31> } <line32> } <line33> if (ClassUtils.isAssignable(value2.getClass(), value1.getClass())) { <line34> if (asc) { <line35> return ((Comparable) value1).compareTo(value2); <line36> } else { <line37> return -((Comparable) value1).compareTo(value2); <line38> } <line39> } else { <line40> final String sval1 = String.valueOf(value1); <line41> final String sval2 = String.valueOf(value2); <line42> if (asc) { <line43> return sval1.compareTo(sval2); <line44> } else { <line45> return -sval1.compareTo(sval2); <line46> } <line47> } <line48> } catch (final Exception ex) { <line49> return 0; <line50> } <line51> } <line52> } <line53> "	 <line50>	No
"public class A { <line0> @Override <line1> public void execute(final Map<String, Object> parameters) throws FrameworkException { <line2> final String mode = (String) parameters.get(""mode""); <line3> if (Boolean.FALSE.equals(deploymentActive.get())) { <line4> try { <line5> deploymentActive.set(true); <line6> if (""export"".equals(mode)) { <line7> doExport(parameters); <line8> } else if (""import"".equals(mode)) { <line9> doImport(parameters); <line10> } else { <line11> } <line12> } finally { <line13> deploymentActive.set(false); <line14> } <line15> } else { <line16> publishWarningMessage( <line17> ""Prevented deployment '"" + mode + ""'"", <line18> ""Another deployment is currently active. Please wait until it is finished.""); <line19> } <line20> } <line21> } <line22> "	 <line16>	Yes
public class A { <line0> @Override <line1> public void collectDirtyRecord(Record dirtyRecord, Throwable t, String errorMessage) { <line2> int logNum = currentLogNum.getAndIncrement(); <line3> if (logNum == 0 && t != null) { <line4> } <line5> if (maxLogNum.intValue() < 0 || currentLogNum.intValue() < maxLogNum.intValue()) { <line6> } <line7> super.collectDirtyRecord(dirtyRecord, t, errorMessage); <line8> } <line9> } <line10> 	 <line5>	No
public class A { <line0> @Secured({ServicesData.ROLE_GET_SECURITY_PROFILES}) <line1> @PostMapping(CommonConstants.PATH_CHECK) <line2> public ResponseEntity<Void> check( <line3> @RequestBody SecurityProfileDto accessContractDto, <line4> @RequestHeader(value = CommonConstants.X_TENANT_ID_HEADER) Integer tenant) { <line5> final boolean exist = securityProfileExternalService.check(accessContractDto); <line6> return RestUtils.buildBooleanResponse(exist); <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> @Override <line1> public List<Path> run(final Session<?> session) throws BackgroundException { <line2> final Restore feature = session.getFeature(Restore.class); <line3> if (log.isDebugEnabled()) { <line4> } <line5> for (Path file : files) { <line6> if (this.isCanceled()) { <line7> throw new ConnectionCanceledException(); <line8> } <line9> feature.restore(file, prompt); <line10> } <line11> return files; <line12> } <line13> } <line14> 	 <line6>	No
"public class A { <line0> public StgG20Anwb findById(sernet.gs.reveng.StgG20AnwbId id) { <line1> try { <line2> StgG20Anwb instance = <line3> (StgG20Anwb) sessionFactory.getCurrentSession().get(""sernet.gs.reveng.StgG20Anwb"", id); <line4> if (instance == null) { <line5> } else { <line6> } <line7> return instance; <line8> } catch (RuntimeException re) { <line9> throw re; <line10> } <line11> } <line12> } <line13> "	 <line0>	No
public class A { <line0> @Test <line1> public void testBench() { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void run(Timeout timeout) throws Exception { <line2> String message = <line3> ""Request ("" <line4> + _lastRequestId <line5> + "") to server "" <line6> + _server <line7> + "" timed-out waiting for response. Closing the channel !!""; <line8> Exception e = new Exception(message); <line9> _outstandingFuture.get().onError(e); <line10> close(); <line11> } <line12> } <line13> "	 <line8>	Yes
"public class A { <line0> private Pair<Boolean, List<User>> loadUsersForUpdate() { <line1> try { <line2> final List<User> userList = userSystemService.findAllUsers(); <line3> final int userListSize = userList != null ? userList.size() : 0; <line4> nextUsersSyncTime = calculateNextUsersSyncTime(); <line5> return Pair.of(true, userList); <line6> } catch (Exception e) { <line7> final String msg = <line8> String.format( <line9> ""An error was produced during users information loading from the external UserSystem"" <line10> + "" repository. Tasks status will still be updated and users synchronization next"" <line11> + "" attempt will be in a period of %s, error: %s"", <line12> syncInterval, e.getMessage()); <line13> return Pair.of(false, Collections.emptyList()); <line14> } <line15> } <line16> } <line17> "	 <line6>	No
"public class A { <line0> @Test <line1> public void testPostSettingExpectsOK() throws ParseException, IOException { <line2> String key = ""example_key""; <line3> String value = ""example_value""; <line4> JSONObject actual = <line5> (JSONObject) <line6> parser.parse( <line7> given() <line8> .formParam(""key"", key) <line9> .formParam(""value"", value) <line10> .expect() <line11> .statusCode(HttpStatus.SC_OK) <line12> .contentType(ContentType.JSON) <line13> .body(""key"", equalTo(key)) <line14> .body(""value"", equalTo(value)) <line15> .when() <line16> .post(rt.host(""setting"")) <line17> .asString()); <line18> } <line19> } <line20> "	 <line18>	Yes
public class A { <line0> public void startTimedScheduler() { <line1> Date startTime = DateTimeUtil.now().plusMinutes(START_DELAY_IN_MINUTES).toDate(); <line2> MotechEvent event = new MotechEvent(SUBJECT); <line3> RepeatingSchedulableJob job = <line4> new RepeatingSchedulableJob( <line5> event, startTime, null, REPEAT_INTERVAL_IN_MINUTES * MILLIS_PER_MINUTE); <line6> schedulerService.safeScheduleRepeatingJob(job); <line7> } <line8> } <line9> 	 <line3>	No
public class A { <line0> @Override <line1> public CoreEvent process(CoreEvent event) throws MuleException { <line2> if (wildcardAttributeEvaluator.hasWildcards()) { <line3> AtomicReference<CoreEvent> resultEvent = new AtomicReference<>(event); <line4> wildcardAttributeEvaluator.processValues( <line5> getPropertyNames((PrivilegedEvent) event), <line6> matchedValue -> { <line7> if (logger.isDebugEnabled()) { <line8> } <line9> resultEvent.set(removeProperty((PrivilegedEvent) event, matchedValue)); <line10> }); <line11> return resultEvent.get(); <line12> } else { <line13> String key = identifierEvaluator.resolveValue(event); <line14> if (key != null) { <line15> return removeProperty((PrivilegedEvent) event, key); <line16> } else { <line17> return event; <line18> } <line19> } <line20> } <line21> } <line22> 	 <line8>	Yes
public class A { <line0> private void checkQueueLength() { <line1> if (connectionExecutor.getQueue().size() > queuewarninglimit) { <line2> } <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> public static void getSubfolderIds( <line1> HttpPrincipal httpPrincipal, <line2> java.util.List<Long> folderIds, <line3> long groupId, <line4> long folderId, <line5> boolean recurse) { <line6> try { <line7> MethodKey methodKey = <line8> new MethodKey( <line9> BookmarksFolderServiceUtil.class, <line10> ""getSubfolderIds"", <line11> _getSubfolderIdsParameterTypes16); <line12> MethodHandler methodHandler = <line13> new MethodHandler(methodKey, folderIds, groupId, folderId, recurse); <line14> try { <line15> TunnelUtil.invoke(httpPrincipal, methodHandler); <line16> } catch (Exception exception) { <line17> throw new com.liferay.portal.kernel.exception.SystemException(exception); <line18> } <line19> } catch (com.liferay.portal.kernel.exception.SystemException systemException) { <line20> throw systemException; <line21> } <line22> } <line23> } <line24> "	 <line9>	No
"public class A { <line0> @Override <line1> protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) <line2> throws AuthenticationException { <line3> try { <line4> if (token instanceof OAuthToken) { <line5> return new SimpleAccount(token.getPrincipal(), token.getCredentials(), ""CloudSession""); <line6> } else { <line7> String principal = (String) token.getPrincipal(); <line8> String credentials = new String((char[]) token.getCredentials()); <line9> User user = SecurityServiceImpl.authenticateLocalUserStatic(principal, credentials); <line10> if (user == null) { <line11> return null; <line12> } <line13> try { <line14> return new SimpleAccount(token.getPrincipal(), token.getCredentials(), ""CloudSession""); <line15> } catch (Throwable t) { <line16> } <line17> } <line18> throw new AuthenticationException(""Unable to authenticate token""); <line19> } catch (UnknownUserException ex) { <line20> LOG.warn(""Authentication failed. Message: {}"", ex.getMessage()); <line21> throw new AuthenticationException(ex.getMessage()); <line22> } catch (UserBlockedException ex) { <line23> throw new AuthenticationException(ex.getMessage()); <line24> } catch (EmailNotConfirmedException ex) { <line25> throw new AuthenticationException(""EmailNotConfirmed""); <line26> } catch (InsufficientBucketTokensException ex) { <line27> throw new AuthenticationException(ex.getMessage()); <line28> } catch (NullPointerException npe) { <line29> throw new AuthenticationException(npe.getMessage()); <line30> } catch (Throwable t) { <line31> } <line32> return null; <line33> } <line34> } <line35> "	 <line21>	No
public class A { <line0> @Override <line1> public <T> T convertTo(Class<T> type, Exchange exchange, Object value) { <line2> String mimeTypeString = exchange.getOut().getHeader(HttpHeaders.CONTENT_TYPE, String.class); <line3> if (null == mimeTypeString) { <line4> mimeTypeString = MediaType.TEXT_PLAIN; <line5> } <line6> MimeType mimeType = null; <line7> try { <line8> mimeType = new MimeType(mimeTypeString); <line9> } catch (MimeTypeParseException e) { <line10> } <line11> T result = null; <line12> try { <line13> result = <line14> type.cast(new BinaryContentImpl(exchange.getOut().getBody(InputStream.class), mimeType)); <line15> } catch (ClassCastException e) { <line16> } <line17> return result; <line18> } <line19> } <line20> 	 <line19>	No
public class A { <line0> @Override <line1> public Status process() throws EventDeliveryException { <line2> Channel channel = getChannel(); <line3> Transaction tx = channel.getTransaction(); <line4> try { <line5> tx.begin(); <line6> Event event = channel.take(); <line7> if (event == null) { <line8> tx.commit(); <line9> return Status.READY; <line10> } <line11> String data = null; <line12> if (writeBody) { <line13> data = new String(event.getBody()); <line14> } else { <line15> data = mapper.writeValueAsString(event.getHeaders()); <line16> } <line17> producer.send(new KeyedMessage<String, String>(topic, data)); <line18> tx.commit(); <line19> return Status.READY; <line20> } catch (Exception e) { <line21> try { <line22> tx.rollback(); <line23> return Status.BACKOFF; <line24> } catch (Exception e2) { <line25> } <line26> return Status.BACKOFF; <line27> } finally { <line28> tx.close(); <line29> } <line30> } <line31> } <line32> 	 <line2>	No
"public class A { <line0> @Override <line1> public Can<IsisBeanMetaData> getAndDrainIntrospectableTypes() { <line2> if (introspectableTypes == null) { <line3> throw _Exceptions.illegalState(""introspectable types had already been drained (one shot)""); <line4> } <line5> val defensiveCopy = Can.ofCollection(introspectableTypes.values()); <line6> if (log.isDebugEnabled()) { <line7> defensiveCopy.forEach( <line8> type -> { <line9> }); <line10> } <line11> introspectableTypes = null; <line12> return defensiveCopy; <line13> } <line14> } <line15> "	 <line4>	No
public class A { <line0> public void removeTlsContext(String alias) { <line1> if (containsAlias(alias)) { <line2> TlsContext removeMe = tlsContexts.get(alias); <line3> inboundTlsContexts.remove(removeMe); <line4> outboundTlsContexts.remove(removeMe); <line5> tlsContexts.remove(alias); <line6> knownAliases.remove(alias); <line7> } else { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> protected IEntityManager extractEntityManager(String entityManagerCode) { <line1> IEntityManager entityManager = null; <line2> List<IEntityManager> managers = this.getEntityManagers(); <line3> for (IEntityManager manager : managers) { <line4> if (((IManager) manager).getName().equals(entityManagerCode)) { <line5> entityManager = manager; <line6> break; <line7> } <line8> } <line9> if (null == entityManager) { <line10> throw new ResourceNotFoundException(""entityManagerCode"", entityManagerCode); <line11> } <line12> return entityManager; <line13> } <line14> } <line15> "	 <line10>	Yes
"public class A { <line0> protected void releaseState(String peid, RunData rundata) { <line1> try { <line2> SessionState ss = ((JetspeedRunData) rundata).getPortletSessionState(peid); <line3> ControllerState state = (ControllerState) ss.getAttribute(""state""); <line4> state.recycle(); <line5> ss.removeAttribute(""state""); <line6> ss.clear(); <line7> } catch (Exception e) { <line8> } <line9> } <line10> } <line11> "	 <line8>	Yes
public class A { <line0> @Override <line1> public void init() throws IOException { <line2> List<RuleInfo> rules = null; <line3> try { <line4> rules = metaStore.getRuleInfo(); <line5> } catch (MetaStoreException e) { <line6> } <line7> for (RuleInfo rule : rules) { <line8> mapRules.put(rule.getId(), new RuleInfoRepo(rule, metaStore, serverContext.getConf())); <line9> } <line10> if (LOG.isDebugEnabled()) { <line11> for (RuleInfo info : rules) { <line12> } <line13> } <line14> } <line15> } <line16> 	 <line10>	Yes
public class A { <line0> @Override <line1> public void onNext(ResT value) { <line2> if (logger.isDebugEnabled()) { <line3> } <line4> } <line5> } <line6> 	 <line3>	Yes
public class A { <line0> public List<AttendeeRequest> getAttendeeRequests(Profile user, boolean includeAckd) { <line1> List<AttendeeRequest> list = new ArrayList<>(); <line2> if (user.getAttendeeRequests() != null) { <line3> for (AttendeeRequest ar : user.getAttendeeRequests()) { <line4> if (includeAckd || !ar.isAcknowledged() && ar.getAttendeeEvent() == null) { <line5> list.add(ar); <line6> } <line7> } <line8> } <line9> return list; <line10> } <line11> } <line12> 	 <line1>	Yes
"public class A { <line0> public void to(String destination) { <line1> Connection connection = null; <line2> try { <line3> if (transacted) { <line4> connection = xaConnectionFactory.createConnection(); <line5> } else { <line6> connection = connectionFactory.createConnection(); <line7> } <line8> Session session = connection.createSession(transacted, autoAcknowledgeMode); <line9> MessageProducer messageProducer = session.createProducer(session.createQueue(destination)); <line10> connection.start(); <line11> ObjectMessage objectMessage = session.createObjectMessage(message); <line12> for (Entry<String, Object> property : properties.entrySet()) { <line13> final Object value = property.getValue(); <line14> if (value instanceof String) { <line15> objectMessage.setStringProperty(property.getKey(), (String) value); <line16> } else if (value instanceof Long) { <line17> objectMessage.setLongProperty(property.getKey(), (Long) value); <line18> } <line19> } <line20> messageProducer.send(objectMessage); <line21> } catch (JMSException e) { <line22> throw new MessageDeliveryException(""Failed to queue push message for further processing"", e); <line23> } finally { <line24> if (connection != null) { <line25> try { <line26> connection.close(); <line27> } catch (JMSException e) { <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	 <line13>	No
public class A { <line0> @Override <line1> public void commitRecord(SourceRecord record, RecordMetadata metadata) { <line2> Integer claimCheck = ((CamelSourceRecord) record).getClaimCheck(); <line3> Exchange correlatedExchange = exchangesWaitingForAck[claimCheck]; <line4> try { <line5> UnitOfWorkHelper.doneSynchronizations( <line6> correlatedExchange, <line7> correlatedExchange.adapt(ExtendedExchange.class).handoverCompletions(), <line8> LOG); <line9> } catch (Throwable t) { <line10> throw new RuntimeException(t); <line11> } finally { <line12> exchangesWaitingForAck[claimCheck] = null; <line13> freeSlots.add(claimCheck); <line14> } <line15> } <line16> } <line17> 	 <line4>	No
public class A { <line0> @Override <line1> public void add(IRingSet ringSet) { <line2> super.add(ringSet); <line3> } <line4> } <line5> 	 <line0>	No
"public class A { <line0> @DELETE <line1> @Path(""{id}"") <line2> @Timed <line3> @ApiOperation(value = ""Delete index set"") <line4> @AuditEvent(type = AuditEventTypes.INDEX_SET_DELETE) <line5> @ApiResponses( <line6> value = { <line7> @ApiResponse(code = 403, message = ""Unauthorized""), <line8> @ApiResponse(code = 404, message = ""Index set not found""), <line9> }) <line10> public void delete( <line11> @ApiParam(name = ""id"", required = true) @PathParam(""id"") String id, <line12> @ApiParam(name = ""delete_indices"") @QueryParam(""delete_indices"") @DefaultValue(""true"") <line13> boolean deleteIndices) { <line14> checkPermission(RestPermissions.INDEXSETS_DELETE, id); <line15> final IndexSet indexSet = getIndexSet(indexSetRegistry, id); <line16> final IndexSet defaultIndexSet = indexSetRegistry.getDefault(); <line17> if (indexSet.equals(defaultIndexSet)) { <line18> throw new BadRequestException( <line19> ""Default index set <"" + indexSet.getConfig().id() + ""> cannot be deleted!""); <line20> } <line21> if (indexSetService.delete(id) == 0) { <line22> throw new NotFoundException(""Couldn't delete index set with ID <"" + id + "">""); <line23> } else { <line24> if (deleteIndices) { <line25> try { <line26> systemJobManager.submit(indexSetCleanupJobFactory.create(indexSet)); <line27> } catch (SystemJobConcurrencyException e) { <line28> } <line29> } <line30> } <line31> } <line32> } <line33> "	 <line28>	Yes
public class A { <line0> public static <T> T jaxbClone(T jaxbObject, Class<T> target) { <line1> if (jaxbObject != null) { <line2> try { <line3> ByteArrayOutputStream output = new ByteArrayOutputStream(); <line4> writeXMLObject(jaxbObject, output); <line5> return readXMLObject(new ByteArrayInputStream(output.toByteArray()), target); <line6> } catch (JAXBException e) { <line7> } <line8> } <line9> return jaxbObject; <line10> } <line11> } <line12> 	 <line6>	No
public class A { <line0> @Override <line1> public void execute(Runnable command) { <line2> this.runnables.add(command); <line3> } <line4> } <line5> 	 <line2>	Yes
"public class A { <line0> @Given(""^Stop Event Broker$"") <line1> public void stop() { <line2> if (NO_EMBEDDED_SERVERS) { <line3> return; <line4> } <line5> try (final Suppressed<RuntimeException> s = Suppressed.withRuntimeException()) { <line6> closables.values().stream().flatMap(values -> values.stream()).forEach(s::closeSuppressed); <line7> if (jmsServer != null) { <line8> jmsServer.stop(); <line9> jmsServer = null; <line10> } <line11> } catch (Exception e) { <line12> } <line13> if (EXTRA_STARTUP_DELAY > 0) { <line14> try { <line15> Thread.sleep(Duration.ofSeconds(EXTRA_STARTUP_DELAY).toMillis()); <line16> } catch (InterruptedException e) { <line17> e.printStackTrace(); <line18> } <line19> } <line20> } <line21> } <line22> "	 <line4>	No
"public class A { <line0> private void visitExtensible(Object obj) { <line1> ExtensibleImpl eobj = (ExtensibleImpl) obj; <line2> int currentVersion = 1; <line3> try { <line4> currentVersion = (Integer) eobj.getClass().getField(""CURRENT_CLASS_VERSION"").get(obj); <line5> } catch (Exception e) { <line6> e.printStackTrace(); <line7> } <line8> if (eobj.getClassVersion() != currentVersion) { <line9> newest = false; <line10> } <line11> List<Field> fields = MigUtils.getAllFields(obj.getClass()); <line12> for (Field f : fields) { <line13> f.setAccessible(true); <line14> try { <line15> Object value = f.get(obj); <line16> if (value != null) { <line17> traverse.traverseObject(value); <line18> } <line19> } catch (Exception e) { <line20> throw new RuntimeException(e); <line21> } <line22> } <line23> } <line24> } <line25> "	 <line20>	No
"public class A { <line0> @Override <line1> public IRequestHandler map(Exception e) { <line2> if (e instanceof AuthorizationException) { <line3> throw new AccessDeniedException(""Access denied by Wicket's security layer"", e); <line4> } <line5> try { <line6> return DELEGATE.map(e); <line7> } catch (RuntimeException e2) { <line8> if (LOGGER.isDebugEnabled()) { <line9> } <line10> return new ErrorCodeRequestHandler(500); <line11> } <line12> } <line13> } <line14> "	 <line10>	Yes
"public class A { <line0> public String processAttachmentsReferences( <line1> long userId, KBArticle kbArticle, ZipReader zipReader, Map<String, FileEntry> fileEntriesMap) <line2> throws PortalException { <line3> Set<Integer> indexes = new TreeSet<>(); <line4> int index = 0; <line5> while ((index = _html.indexOf(""<img"", index)) > -1) { <line6> indexes.add(index); <line7> index += 4; <line8> } <line9> if (indexes.isEmpty()) { <line10> return _html; <line11> } <line12> StringBundler sb = new StringBundler(); <line13> int previousIndex = 0; <line14> for (int curIndex : indexes) { <line15> if (curIndex < 0) { <line16> break; <line17> } <line18> if (curIndex > previousIndex) { <line19> String text = _html.substring(previousIndex, curIndex); <line20> sb.append(text); <line21> } <line22> int pos = _html.indexOf("">"", curIndex); <line23> if (pos < 0) { <line24> if (_log.isDebugEnabled()) { <line25> } <line26> sb.append(_html.substring(curIndex)); <line27> previousIndex = curIndex; <line28> break; <line29> } <line30> String text = _html.substring(curIndex, pos); <line31> String imageFileName = KBArticleImporterUtil.extractImageFileName(text); <line32> FileEntry imageFileEntry = <line33> KBArticleImporterUtil.addImageFileEntry( <line34> imageFileName, userId, kbArticle, zipReader, fileEntriesMap); <line35> if (imageFileEntry == null) { <line36> if (_log.isWarnEnabled()) { <line37> } <line38> sb.append(""<img alt=\""missing image\"" src=\""\"" ""); <line39> } else { <line40> String imageSrc = StringPool.BLANK; <line41> try { <line42> imageSrc = <line43> _dlURLHelper.getPreviewURL( <line44> imageFileEntry, imageFileEntry.getFileVersion(), null, StringPool.BLANK); <line45> } catch (PortalException portalException) { <line46> if (_log.isWarnEnabled()) { <line47> } <line48> } <line49> sb.append(""<img alt=\""""); <line50> sb.append(HtmlUtil.escapeAttribute(imageFileEntry.getTitle())); <line51> sb.append(""\"" src=\""""); <line52> sb.append(imageSrc); <line53> sb.append(""\"" ""); <line54> } <line55> previousIndex = pos; <line56> } <line57> if (previousIndex < _html.length()) { <line58> sb.append(_html.substring(previousIndex)); <line59> } <line60> return sb.toString(); <line61> } <line62> } <line63> "	 <line37>	Yes
public class A { <line0> public void setChannel(String name) { <line1> if (channels.containsKey(name)) { <line2> String id = channels.get(name); <line3> transmitWithResult(PATH_ZAP + UrlEncoded.encodeString(id)) <line4> .ifPresent(document -> channel = name); <line5> } else { <line6> } <line7> } <line8> } <line9> 	 <line6>	Yes
public class A { <line0> @Override <line1> public void removeBranchSession(GlobalSession globalSession, BranchSession branchSession) <line2> throws TransactionException { <line3> if (LOGGER.isDebugEnabled()) { <line4> } <line5> writeSession(LogOperation.BRANCH_REMOVE, branchSession); <line6> } <line7> } <line8> 	 <line4>	Yes
"public class A { <line0> private int serviceToID( <line1> final String systemName, final String serviceName, final Connection conn) { <line2> int id = -1; <line3> PreparedStatement stmt; <line4> try { <line5> String sql = ""SELECT id FROM dmhist_services WHERE system_name=? AND service_name=? LIMIT 1;""; <line6> stmt = conn.prepareStatement(sql); <line7> stmt.setString(1, systemName); <line8> stmt.setString(2, serviceName); <line9> ResultSet rs = stmt.executeQuery(); <line10> rs.next(); <line11> id = rs.getInt(""id""); <line12> rs.close(); <line13> stmt.close(); <line14> } catch (Exception e) { <line15> id = -1; <line16> } <line17> return id; <line18> } <line19> } <line20> "	 <line4>	No
"public class A { <line0> @Before <line1> public void setupManager() throws IOException, RepositoryException { <line2> String temp = System.getProperty(""java.io.tmpdir""); <line3> home = new File(temp, getClass().getName()); <line4> delete(home); <line5> home.deleteOnExit(); <line6> if (!home.mkdirs()) { <line7> throw new RuntimeException(""Could not create directory: "" + home.getAbsolutePath()); <line8> } <line9> InputStream configStream = getClass().getResourceAsStream(""repository.xml""); <line10> RepositoryConfig config = RepositoryConfig.create(configStream, home.getAbsolutePath()); <line11> repo = RepositoryImpl.create(config); <line12> Credentials credentials = new SimpleCredentials(""admin"", ""admin"".toCharArray()); <line13> Session session = repo.login(credentials); <line14> NamespaceRegistry nr = session.getWorkspace().getNamespaceRegistry(); <line15> nr.registerNamespace(""brix"", ""http://brix-cms.googlecode.com""); <line16> session.save(); <line17> manager = new LocalWorkspaceManager(repo).initialize(); <line18> } <line19> } <line20> "	 <line12>	Yes
public class A { <line0> @Override <line1> public int getPrivateLayoutsPageCount() { <line2> try { <line3> Group group = getGroup(); <line4> if (group == null) { <line5> return 0; <line6> } <line7> return group.getPrivateLayoutsPageCount(); <line8> } catch (Exception exception) { <line9> } <line10> return 0; <line11> } <line12> } <line13> 	 <line9>	Yes
public class A { <line0> private Set<ContainerDto> convertContainersToContainerJson( <line1> Set<EnvironmentContainerHost> containerHosts, String datasource) { <line2> Set<ContainerDto> containerDtos = Sets.newHashSet(); <line3> for (EnvironmentContainerHost containerHost : containerHosts) { <line4> ContainerDto containerDto = <line5> new ContainerDto( <line6> containerHost.getId(), <line7> containerHost.getEnvironmentId().getId(), <line8> containerHost.getHostname(), <line9> containerHost.getIp(), <line10> containerHost.getTemplateName(), <line11> containerHost.getContainerSize(), <line12> containerHost.getArch().toString(), <line13> containerHost.getTags(), <line14> containerHost.getPeerId(), <line15> containerHost.getResourceHostId().getId(), <line16> containerHost.isLocal(), <line17> datasource, <line18> containerHost.getState(), <line19> containerHost.getTemplateId(), <line20> containerHost.getContainerName(), <line21> containerHost.getResourceHostId().getId()); <line22> try { <line23> ContainerQuota containerQuota = containerHost.getQuota(); <line24> if (containerQuota != null) { <line25> containerDto.setQuota(new ContainerQuotaDto(containerQuota)); <line26> } <line27> } catch (Exception e) { <line28> } <line29> containerDtos.add(containerDto); <line30> } <line31> return containerDtos; <line32> } <line33> } <line34> 	 <line8>	No
public class A { <line0> @Override <line1> public synchronized void stopScan() { <line2> if (bridgeHandler == null) { <line3> return; <line4> } <line5> bridgeHandler.stopDiscovery(); <line6> super.stopScan(); <line7> } <line8> } <line9> 	 <line2>	No
public class A { <line0> @Override <line1> public void dispose() { <line2> ScheduledFuture<?> oldScheduler = pollingScheduler; <line3> if (oldScheduler != null) { <line4> boolean stopped = oldScheduler.cancel(true); <line5> } <line6> pollingScheduler = null; <line7> } <line8> } <line9> 	 <line0>	No
"public class A { <line0> public boolean acquire(int numOps) { <line1> try { <line2> if (!semaphore.tryAcquire(numOps)) { <line3> Thread.sleep(WAIT_BEFORE_NEXT_ACQUIRE_PERMIT_IN_MS); <line4> return acquire(numOps); <line5> } <line6> } catch (InterruptedException e) { <line7> throw new RuntimeException(""Unable to acquire permits"", e); <line8> } <line9> return true; <line10> } <line11> } <line12> "	 <line6>	Yes
"public class A { <line0> public void setup(String[] names, String[] tablepaths, Schema[] schemas) throws Exception { <line1> LOG.info(""===================================================""); <line2> LOG.info(""===================================================""); <line3> util = new TajoTestingCluster(); <line4> util.startMiniCluster(1); <line5> conf = util.getConfiguration(); <line6> client = util.newTajoClient(); <line7> FileSystem fs = util.getDefaultFileSystem(); <line8> Path rootDir = TajoConf.getWarehouseDir(conf); <line9> fs.mkdirs(rootDir); <line10> for (int i = 0; i < tablepaths.length; i++) { <line11> Path localPath = new Path(tablepaths[i]); <line12> Path tablePath = new Path(rootDir, names[i]); <line13> fs.mkdirs(tablePath); <line14> Path dfsPath = new Path(tablePath, localPath.getName()); <line15> fs.copyFromLocalFile(localPath, dfsPath); <line16> TableMeta meta = CatalogUtil.newTableMeta(BuiltinStorages.TEXT, conf); <line17> TableStats stats = new TableStats(); <line18> stats.setNumBytes(TPCH.tableVolumes.get(names[i])); <line19> TableDesc tableDesc = <line20> new TableDesc( <line21> IdentifierUtil.buildFQName(TajoConstants.DEFAULT_DATABASE_NAME, names[i]), <line22> schemas[i], <line23> meta, <line24> tablePath.toUri()); <line25> tableDesc.setStats(stats); <line26> util.getMaster().getCatalog().createTable(tableDesc); <line27> } <line28> LOG.info(""===================================================""); <line29> } <line30> } <line31> "	 <line2>	Yes
public class A { <line0> @Override <line1> public void onBeforeRemove(Group group) { <line2> try { <line3> CommerceChannel commerceChannel = <line4> _commerceChannelLocalService.fetchCommerceChannelBySiteGroupId(group.getGroupId()); <line5> if (commerceChannel != null) { <line6> _commerceChannelLocalService.updateCommerceChannel( <line7> commerceChannel.getCommerceChannelId(), <line8> GroupConstants.DEFAULT_PARENT_GROUP_ID, <line9> commerceChannel.getName(), <line10> commerceChannel.getType(), <line11> commerceChannel.getTypeSettingsProperties(), <line12> commerceChannel.getCommerceCurrencyCode()); <line13> } <line14> } catch (PortalException portalException) { <line15> if (_log.isWarnEnabled()) { <line16> } <line17> } <line18> } <line19> } <line20> 	 <line16>	Yes
public class A { <line0> private static IReflectionFactory initialize() { <line1> final Class<?> factoryClass = <line2> com.gigaspaces.internal.reflection.fast.ASMReflectionFactory.class; <line3> IReflectionFactory reflectionFactory = <line4> (IReflectionFactory) createInstanceWithOptionalDependencies(factoryClass); <line5> if (reflectionFactory == null) { <line6> reflectionFactory = new StandardReflectionFactory(); <line7> } <line8> return reflectionFactory; <line9> } <line10> } <line11> 	 <line0>	No
"public class A { <line0> public final synchronized void start(Module... modules) throws Throwable { <line1> if (!this.status.compareAndSet(Stopped, Processing)) { <line2> throw new IllegalStateException(""the container is already started""); <line3> } <line4> ArrayList<Module> findModules = new ArrayList<>(); <line5> findModules.addAll(Arrays.asList(this.findModules())); <line6> findModules.addAll(Arrays.asList(modules)); <line7> this.getContainer().preInitialize(); <line8> ApiBinder apiBinder = newApiBinder(); <line9> doBindBefore(apiBinder); <line10> for (Module module : findModules) { <line11> if (module != null) { <line12> this.installModule(apiBinder, module); <line13> } <line14> } <line15> doBindAfter(apiBinder); <line16> this.getContainer().init(); <line17> doInitializeCompleted(); <line18> Runtime.getRuntime().addShutdownHook(shutdownHook); <line19> doStart(); <line20> getEnvironment().getEventContext().fireSyncEvent(ContextEvent_Started, this); <line21> doStartCompleted(); <line22> status.compareAndSet(Processing, Started); <line23> } <line24> } <line25> "	 <line22>	Yes
"public class A { <line0> public List findByExample(NZobSb instance) { <line1> try { <line2> List results = <line3> getSession() <line4> .createCriteria(""sernet.gs.reveng.NZobSb"") <line5> .add(Example.create(instance)) <line6> .list(); <line7> return results; <line8> } catch (RuntimeException re) { <line9> throw re; <line10> } <line11> } <line12> } <line13> "	 <line12>	No
public class A { <line0> @Test <line1> public void testPutMissedDhtRequest_UnstableTopology() throws Exception { <line2> blockRebalance = true; <line3> ccfg = cacheConfiguration(1, FULL_SYNC); <line4> startServers(4); <line5> client = true; <line6> Ignite client = startGrid(4); <line7> IgniteCache<Integer, Integer> nearCache = client.cache(TEST_CACHE); <line8> testSpi(ignite(0)) <line9> .blockMessages( <line10> new IgniteBiPredicate<ClusterNode, Message>() { <line11> @Override <line12> public boolean apply(ClusterNode node, Message msg) { <line13> return msg instanceof GridDhtAtomicAbstractUpdateRequest; <line14> } <line15> }); <line16> Integer key = primaryKey(ignite(0).cache(TEST_CACHE)); <line17> IgniteFuture<?> fut = nearCache.putAsync(key, key); <line18> U.sleep(500); <line19> assertFalse(fut.isDone()); <line20> stopGrid(0); <line21> fut.get(); <line22> checkData(F.asMap(key, key)); <line23> } <line24> } <line25> 	 <line17>	Yes
public class A { <line0> private void appendBlock(final BlockPeek blockPeek) { <line1> final ByteBuffer rawBuffer = blockPeek.getRawBuffer(); <line2> final int bytes = rawBuffer.remaining(); <line3> final ByteBuffer copiedBuffer = ByteBuffer.allocate(bytes).put(rawBuffer).flip(); <line4> final Tuple<Long, Long> positions = readLowestHighestPosition(copiedBuffer); <line5> appendBackpressureMetrics.newEntryToAppend(); <line6> if (appendEntryLimiter.tryAcquire(positions.getRight())) { <line7> final var listener = new Listener(this, positions.getRight(), ActorClock.currentTimeMillis()); <line8> logStorage.append(positions.getLeft(), positions.getRight(), copiedBuffer, listener); <line9> blockPeek.markCompleted(); <line10> } else { <line11> appendBackpressureMetrics.deferred(); <line12> } <line13> } <line14> } <line15> 	 <line6>	No
public class A { <line0> private List<File> searchCasesinFolder(File folder) { <line1> ArrayList<File> files = new ArrayList<File>(); <line2> File[] subFiles = folder.listFiles(); <line3> if (subFiles != null) <line4> for (File file : subFiles) { <line5> if (file.isDirectory()) { <line6> if (new File(file, MODULE_DIR).exists()) files.add(file); <line7> else files.addAll(searchCasesinFolder(file)); <line8> } <line9> } <line10> return files; <line11> } <line12> } <line13> 	 <line1>	Yes
public class A { <line0> private void handleMessage(final GeneralAdvertisementMessageDTO gaMsg) { <line1> try { <line2> final Session session = relayClient.createConnection(relayHost, relayPort, securedRelay); <line3> final GatekeeperRelayRequest request = <line4> relayClient.sendAcknowledgementAndReturnRequest(session, gaMsg); <line5> final Object response = handleRequest(request); <line6> relayClient.sendResponse(session, request, response); <line7> } catch (final JMSException | ArrowheadException ex) { <line8> } <line9> } <line10> } <line11> 	 <line8>	Yes
"public class A { <line0> @Path(""/list"") <line1> @GET <line2> @Produces(""application/json"") <line3> public String getAllDisplays() { <line4> SignCodeData data = null; <line5> try { <line6> data = getDataObject(); <line7> } catch (IOException e) { <line8> throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR); <line9> } <line10> List<CCDestinationSignMessage> messages = data.getAllDisplays(); <line11> ModelCounterpartConverter<CCDestinationSignMessage, DestinationSign> tcipToJsonConverter = <line12> new SignMessageFromTcip(); <line13> List<DestinationSign> jsonSigns = new ArrayList<DestinationSign>(); <line14> for (CCDestinationSignMessage message : messages) { <line15> jsonSigns.add(tcipToJsonConverter.convert(message)); <line16> } <line17> DestinationSignsMessage outputMessage = new DestinationSignsMessage(); <line18> outputMessage.setSigns(jsonSigns); <line19> outputMessage.setStatus(""OK""); <line20> String output = null; <line21> try { <line22> output = writeJsonObjectToString(outputMessage); <line23> } catch (IOException e) { <line24> throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR); <line25> } <line26> return output; <line27> } <line28> } <line29> "	 <line26>	Yes
"public class A { <line0> @Override <line1> public void terminateAllResources(final long duration, final TimeUnit unit) <line2> throws TimeoutException, CloudProvisioningException { <line3> final long endTime = System.currentTimeMillis() + unit.toMillis(duration); <line4> try { <line5> terminateMachinesByPrefix(cloud.getProvider().getManagementGroup(), endTime); <line6> terminateMachinesByPrefix(cloud.getProvider().getMachineNamePrefix(), endTime); <line7> try { <line8> this.cleanAllSecurityGroups(); <line9> } catch (final Exception e) { <line10> logger.warning( <line11> ""Couldn't clean security groups "" + this.openstackPrefixes.getPrefix() + ""*""); <line12> logger.warning(""Reported error: "" + e.getMessage() + "", stack trace: "" + e.getStackTrace()); <line13> } <line14> try { <line15> this.cleanAllNetworks(); <line16> } catch (final Exception e) { <line17> logger.warning(""Couldn't clean networks "" + this.openstackPrefixes.getPrefix() + ""*""); <line18> logger.warning(""Reported error: "" + e.getMessage() + "", stack trace: "" + e.getStackTrace()); <line19> } <line20> } finally { <line21> if (this.computeApi != null) { <line22> this.computeApi.close(); <line23> } <line24> if (this.networkApi != null) { <line25> this.networkApi.close(); <line26> } <line27> } <line28> } <line29> } <line30> "	 <line3>	Yes
"public class A { <line0> private List<String> queryPatientsByLabelAndEid(String label, String id) throws QueryException { <line1> Query q = null; <line2> try { <line3> q = <line4> this.qm.createQuery( <line5> ""select doc.name from Document doc, doc.object(PhenoTips.LabeledIdentifierClass) obj "" <line6> + ""where obj.label = :label and obj.value = :value"", <line7> Query.XWQL); <line8> q.bindValue(KEY_LABEL, label); <line9> q.bindValue(KEY_VALUE, id); <line10> return q.execute(); <line11> } catch (QueryException ex) { <line12> throw new QueryException(ex.getMessage(), q, ex); <line13> } <line14> } <line15> } <line16> "	 <line12>	Yes
"public class A { <line0> public boolean onFail(Throwable cause) { <line1> while (true) { <line2> State current = _state.get(); <line3> switch (current.getType()) { <line4> case IDLE: <line5> case FAILED: <line6> if (DEBUG) { <line7> } <line8> return false; <line9> case PENDING: <line10> if (DEBUG) LOG.debug(""failed: {}"", this, cause); <line11> PendingState pending = (PendingState) current; <line12> if (updateState(pending, new FailedState(cause))) { <line13> pending._callback.failed(cause); <line14> return true; <line15> } <line16> break; <line17> case WRITING: <line18> case COMPLETING: <line19> if (updateState(current, new FailedState(cause))) return true; <line20> break; <line21> default: <line22> throw new IllegalStateException(); <line23> } <line24> } <line25> } <line26> } <line27> "	 <line25>	No
"public class A { <line0> public void stopMongoServer(Runtime runtime) throws IOException, InterruptedException { <line1> String line; <line2> Process ps = runtime.exec(""ps -ux""); <line3> InputStream is = ps.getInputStream(); <line4> InputStreamReader isr = new InputStreamReader(is); <line5> BufferedReader br = new BufferedReader(isr); <line6> while ((line = br.readLine()) != null) { <line7> StringTokenizer tokenizer = new StringTokenizer(line, "" ""); <line8> if (line.contains(""mongod"")) { <line9> System.out.println(line); <line10> tokenizer.nextElement(); <line11> String nextElement = (String) tokenizer.nextElement(); <line12> System.out.println(nextElement); <line13> runtime.exec(""kill -9 "" + nextElement); <line14> break; <line15> } <line16> } <line17> } <line18> } <line19> "	 <line12>	No
public class A { <line0> @OnReturn <line1> public static void onReturn( <line2> @BindReturn @Nullable Object returnValue, <line3> @BindReceiver HttpURLConnection httpURLConnection, <line4> @BindTraveler @Nullable TraceEntryOrTimer entryOrTimer) { <line5> if (httpURLConnection instanceof HasTraceEntryMixin) { <line6> if (returnValue instanceof HasTraceEntryMixin) { <line7> TraceEntry traceEntry = ((HasTraceEntryMixin) httpURLConnection).glowroot$getTraceEntry(); <line8> ((HasTraceEntryMixin) returnValue).glowroot$setTraceEntry(traceEntry); <line9> } else if (returnValue != null && !outputStreamIssueAlreadyLogged.getAndSet(true)) { <line10> } <line11> } <line12> ConnectAdvice.onReturn(entryOrTimer); <line13> } <line14> } <line15> 	 <line7>	No
"public class A { <line0> private FileSystem initializeFileSystem() { <line1> try { <line2> FileSystem fileSystem = HadoopClientFactory.get().createFalconFileSystem(storePath.toUri()); <line3> if (!fileSystem.exists(storePath)) { <line4> HadoopClientFactory.mkdirs(fileSystem, storePath, STORE_PERMISSION); <line5> } <line6> return fileSystem; <line7> } catch (Exception e) { <line8> throw new RuntimeException(""Unable to bring up config store for path: "" + storePath, e); <line9> } <line10> } <line11> } <line12> "	 <line5>	No
public class A { <line0> private void handleRemove( <line1> List<HostInternetScsiHbaStaticTarget> targetsToRemove, HostMO host, List<HostMO> hosts) { <line2> try { <line3> for (HostInternetScsiHbaStaticTarget target : targetsToRemove) { <line4> String datastoreName = <line5> waitForDatastoreName(host.getHostDatastoreSystemMO(), target.getIScsiName()); <line6> unmountVmfsDatastore2(host.getContext(), host, datastoreName, hosts); <line7> } <line8> addRemoveInternetScsiTargetsToAllHosts(false, targetsToRemove, hosts); <line9> rescanAllHosts(hosts, true, false); <line10> } catch (Exception ex) { <line11> } <line12> } <line13> } <line14> 	 <line11>	Yes
public class A { <line0> private void extractCharset(MaximalBodyDescriptor descriptor) { <line1> try { <line2> Optional.ofNullable(descriptor.getCharset()) <line3> .map(Charset::forName) <line4> .ifPresent(currentlyBuildMimePart::charset); <line5> } catch (Exception e) { <line6> } <line7> } <line8> } <line9> 	 <line5>	No
"public class A { <line0> private BuildSetTask buildProjectsAndWaitForUpdates( <line1> BuildConfigurationSet buildConfigurationSet, <line2> BuildCoordinator buildCoordinator, <line3> int nStatusUpdates, <line4> Consumer<BuildStatusChangedEvent> onStatusUpdate, <line5> List<BuildStatusChangedEvent> receivedStatuses, <line6> List<BuildSetStatusChangedEvent> receivedSetStatuses) <line7> throws InterruptedException, CoreException { <line8> Consumer<BuildStatusChangedEvent> onStatusUpdateInternal = <line9> (statusUpdate) -> { <line10> receivedStatuses.add(statusUpdate); <line11> onStatusUpdate.accept(statusUpdate); <line12> }; <line13> final Semaphore semaphore = <line14> registerReleaseListenersAndAcquireSemaphore(onStatusUpdateInternal, nStatusUpdates); <line15> final Semaphore buildSetSemaphore = <line16> registerBuildSetListeners(receivedSetStatuses, BUILD_SET_STATUS_UPDATES); <line17> BuildOptions buildOptions = new BuildOptions(); <line18> buildOptions.setRebuildMode(RebuildMode.FORCE); <line19> BuildSetTask buildSetTask = <line20> buildCoordinator.build(buildConfigurationSet, MockUser.newTestUser(1), buildOptions); <line21> assertBuildStartedSuccessfully(buildSetTask); <line22> waitForStatusUpdates(nStatusUpdates, semaphore, """"); <line23> log.debug( <line24> ""All status updates should be received. Semaphore has {} free entries."", <line25> semaphore.availablePermits()); <line26> waitForStatusUpdates( <line27> BUILD_SET_STATUS_UPDATES, buildSetSemaphore, ""build set task: "" + buildSetTask); <line28> return buildSetTask; <line29> } <line30> } <line31> "	 <line11>	No
"public class A { <line0> Future<Void> updateStatus( <line1> KafkaConnectS2I kafkaConnectS2Iassembly, <line2> Reconciliation reconciliation, <line3> KafkaConnectS2IStatus desiredStatus) { <line4> Promise<Void> updateStatusPromise = Promise.promise(); <line5> resourceOperator <line6> .getAsync( <line7> kafkaConnectS2Iassembly.getMetadata().getNamespace(), <line8> kafkaConnectS2Iassembly.getMetadata().getName()) <line9> .onComplete( <line10> getRes -> { <line11> if (getRes.succeeded()) { <line12> KafkaConnectS2I connect = getRes.result(); <line13> if (connect != null) { <line14> if (StatusUtils.isResourceV1alpha1(connect)) { <line15> updateStatusPromise.complete(); <line16> } else { <line17> KafkaConnectS2IStatus currentStatus = connect.getStatus(); <line18> StatusDiff ksDiff = new StatusDiff(currentStatus, desiredStatus); <line19> if (!ksDiff.isEmpty()) { <line20> KafkaConnectS2I resourceWithNewStatus = <line21> new KafkaConnectS2IBuilder(connect).withStatus(desiredStatus).build(); <line22> ((CrdOperator<OpenShiftClient, KafkaConnectS2I, KafkaConnectS2IList>) <line23> resourceOperator) <line24> .updateStatusAsync(resourceWithNewStatus) <line25> .onComplete( <line26> updateRes -> { <line27> if (updateRes.succeeded()) { <line28> updateStatusPromise.complete(); <line29> } else { <line30> updateStatusPromise.fail(updateRes.cause()); <line31> } <line32> }); <line33> } else { <line34> updateStatusPromise.complete(); <line35> } <line36> } <line37> } else { <line38> updateStatusPromise.fail(""Current Kafka ConnectS2I resource not found""); <line39> } <line40> } else { <line41> updateStatusPromise.fail(getRes.cause()); <line42> } <line43> }); <line44> return updateStatusPromise.future(); <line45> } <line46> } <line47> "	 <line30>	Yes
"public class A { <line0> @Override <line1> public Response listEnvironments() { <line2> Set<Environment> environments = environmentManager.getEnvironments(); <line3> Set<EnvironmentDto> environmentDtos = Sets.newHashSet(); <line4> for (Environment environment : environments) { <line5> try { <line6> String dataSource = <line7> (environment instanceof BazaarEnvironment <line8> || String.format(""Of %s"", Common.BAZAAR_ID).equals(environment.getName())) <line9> ? Common.BAZAAR_ID <line10> : Common.SUBUTAI_ID; <line11> EnvironmentDto environmentDto = <line12> new EnvironmentDto( <line13> environment.getId(), <line14> environment.getName(), <line15> environment.getStatus(), <line16> convertContainersToContainerJson(environment.getContainerHosts(), dataSource), <line17> dataSource, <line18> environmentManager.getEnvironmentOwnerName(environment)); <line19> environmentDtos.add(environmentDto); <line20> } catch (Exception e) { <line21> } <line22> } <line23> return Response.ok(JsonUtil.toJson(removeXss(environmentDtos))).build(); <line24> } <line25> } <line26> "	 <line21>	Yes
public class A { <line0> private Translator newTranslator() { <line1> final InstrumentEngine instrumentEngine = applicationContext.getInstrumentEngine(); <line2> if (instrumentEngine instanceof ASMEngine) { <line3> return new DefaultTranslator(this, applicationContext.getClassFileTransformer()); <line4> } <line5> return new DefaultTranslator(this, applicationContext.getClassFileTransformer()); <line6> } <line7> } <line8> 	 <line3>	Yes
"public class A { <line0> private static final String getExtension(String filename, String mappingType, String MIMETYPE) <line1> throws Exception { <line2> String extension = """"; <line3> if (mappingType.equals(""never"")) { <line4> extension = """"; <line5> } else { <line6> if (mappingType.equals(""ifmissing"") && filename.contains(""."")) { <line7> extension = """"; <line8> } else { <line9> if (mappingType.equals(""ifmissing"") || mappingType.equals(""always"")) { <line10> extension = getExtension(MIMETYPE); <line11> if (extension.isEmpty()) extension = m_datastreamDefaultExtension; <line12> } else { <line13> extension = m_datastreamDefaultExtension; <line14> } <line15> } <line16> } <line17> return extension; <line18> } <line19> } <line20> "	 <line18>	No
public class A { <line0> public static IActionSet getExampleActionSetService(String name, String version) <line1> throws ActivatorException { <line2> try { <line3> return (IActionSet) <line4> getServiceFromRegistry(context, createFilterExampleActionSet(name, version)); <line5> } catch (InvalidSyntaxException e) { <line6> throw new ActivatorException(e); <line7> } <line8> } <line9> } <line10> 	 <line9>	No
public class A { <line0> public void succeeded() { <line1> if (isEventWatched()) { <line2> reconciliationTimerSample.stop(reconciliationsTimer); <line3> successfulReconciliationsCounter.increment(); <line4> } <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public Group getGroup(String identifier) throws AuthorizationAccessException { <line2> Group group; <line3> synchronized (groupsById) { <line4> group = groupsById.get(identifier); <line5> } <line6> if (group == null) { <line7> refreshOneGroup(selectedShellCommands.getGroupById(identifier), ""Get Single Group by Id""); <line8> group = groupsById.get(identifier); <line9> } <line10> if (group == null) { <line11> } else { <line12> } <line13> return group; <line14> } <line15> } <line16> "	 <line12>	Yes
public class A { <line0> public void deployTarballResource(String url, String targetName) { <line1> try { <line2> doDeployTarballResource(url, targetName); <line3> } catch (RuntimeException e) { <line4> throw Throwables.propagate(e); <line5> } <line6> } <line7> } <line8> 	 <line4>	Yes
public class A { <line0> @Override <line1> public void onTrigger(final ProcessContext context, final ProcessSessionFactory sessionFactory) { <line2> final FlowFileRequest flowFileRequest; <line3> try { <line4> flowFileRequest = requestQueue.poll(100, TimeUnit.MILLISECONDS); <line5> } catch (final InterruptedException ie) { <line6> return; <line7> } <line8> if (flowFileRequest == null) { <line9> return; <line10> } <line11> flowFileRequest.setServiceBegin(); <line12> requestLock.lock(); <line13> try { <line14> if (shutdown) { <line15> final CommunicationsSession commsSession = <line16> flowFileRequest.getPeer().getCommunicationsSession(); <line17> if (commsSession != null) { <line18> commsSession.interrupt(); <line19> } <line20> } <line21> activeRequests.add(flowFileRequest); <line22> } finally { <line23> requestLock.unlock(); <line24> } <line25> final ProcessSession session = sessionFactory.createSession(); <line26> try { <line27> onTrigger(context, session, flowFileRequest); <line28> } catch (final TransmissionDisabledException e) { <line29> session.rollback(); <line30> } catch (final Exception e) { <line31> if (logger.isDebugEnabled()) { <line32> } <line33> session.rollback(); <line34> } finally { <line35> requestLock.lock(); <line36> try { <line37> activeRequests.remove(flowFileRequest); <line38> } finally { <line39> requestLock.unlock(); <line40> } <line41> } <line42> } <line43> } <line44> 	 <line31>	Yes
public class A { <line0> public void setSpatialOps(SpatialOperatorsType spatialOperators) { <line1> spatialOps = new ConcurrentHashMap<>(new EnumMap<>(SpatialOperatorNameType.class)); <line2> for (SpatialOperatorType spatialOp : spatialOperators.getSpatialOperator()) { <line3> spatialOps.put(spatialOp.getName(), spatialOp); <line4> } <line5> } <line6> } <line7> 	 <line4>	Yes
"public class A { <line0> @Override <line1> void repairMetadata() throws IOException { <line2> MCRContentInputStream cis = getContent().getContentInputStream(); <line3> IOUtils.copy(cis, DEV_NULL); <line4> cis.close(); <line5> String path = getPath(); <line6> writeData( <line7> e -> { <line8> e.setName(""file""); <line9> e.setAttribute(""name"", getName()); <line10> e.removeChildren(""file""); <line11> e.removeChildren(""directory""); <line12> String md5 = cis.getMD5String(); <line13> if (!md5.equals(e.getAttributeValue(""md5""))) { <line14> e.setAttribute(""md5"", md5); <line15> } <line16> }); <line17> } <line18> } <line19> "	 <line14>	Yes
"public class A { <line0> private String getTags(Document doc) { <line1> String tags = """"; <line2> if (doc != null) { <line3> DOMSource src = new DOMSource(doc); <line4> StringWriter sw = new StringWriter(); <line5> StreamResult res = new StreamResult(sw); <line6> try { <line7> Transformer trans = TransformerFactory.newInstance().newTransformer(); <line8> trans.setOutputProperty(OutputKeys.INDENT, ""yes""); <line9> trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes""); <line10> trans.setOutputProperty(OutputKeys.METHOD, ""html""); <line11> trans.transform(src, res); <line12> tags = sw.toString().replaceAll(ROOT_ELEMENT_REGEX, """"); <line13> } catch (Exception e) { <line14> StringBuilder txt = new StringBuilder(); <line15> txt.append(""Error converting tags to string. Exception: ""); <line16> txt.append(e.toString()); <line17> } <line18> } <line19> if (isTrace) { <line20> StringBuilder sb = new StringBuilder(); <line21> sb.append(""returning tags: ""); <line22> sb.append((tags.length() > 0) ? ""\n"" + tags : """"); <line23> } <line24> return tags; <line25> } <line26> } <line27> "	 <line2>	No
public class A { <line0> @Override <line1> public void onToServerRpcResponse(TransportProtos.ToServerRpcResponseMsg msg) { <line2> try { <line3> exchange.respond(coapTransportAdaptor.convertToPublish(isConRequest(), msg)); <line4> } catch (AdaptorException e) { <line5> exchange.respond(CoAP.ResponseCode.INTERNAL_SERVER_ERROR); <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> @Override <line1> public boolean performFinish() { <line2> try { <line3> itNetworkPage.setMessage(Messages.ItNetworkConverterWizard_PageTitle, DialogPage.INFORMATION); <line4> runConvertingInWizard(); <line5> CnAElementFactory.getInstance().reloadBpModelFromDatabase(); <line6> } catch (InvocationTargetException | InterruptedException e) { <line7> itNetworkPage.setMessage( <line8> Messages.ItNetworkConverterWizard_ErrorInformation, DialogPage.ERROR); <line9> return false; <line10> } <line11> return true; <line12> } <line13> } <line14> 	 <line7>	Yes
public class A { <line0> public void maybeTriggerWakeup() { <line1> if (!wakeupDisabled.get() && wakeup.get()) { <line2> wakeup.set(false); <line3> throw new WakeupException(); <line4> } <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> @Path(""/create"") <line1> @POST <line2> @Produces(""application/json"") <line3> public Response build( <line4> @FormParam(""bundleDirectory"") String bundleDirectory, <line5> @FormParam(""bundleName"") String bundleName, <line6> @FormParam(""email"") String email, <line7> @FormParam(""bundleStartDate"") String bundleStartDate, <line8> @FormParam(""bundleEndDate"") String bundleEndDate, <line9> @FormParam(""bundleComment"") String bundleComment, <line10> @FormParam(""archive"") boolean archiveFlag, <line11> @FormParam(""consolidate"") boolean consolidateFlag, <line12> @FormParam(""predate"") boolean predateFlag) { <line13> Response response = null; <line14> directoryName = bundleDirectory; <line15> this.bundleName = bundleName; <line16> startDate = bundleStartDate; <line17> endDate = bundleEndDate; <line18> emailTo = email; <line19> comment = bundleComment; <line20> archive = archiveFlag; <line21> consolidate = consolidateFlag; <line22> predate = predateFlag; <line23> if (!isAuthorized()) { <line24> return Response.noContent().build(); <line25> } <line26> BundleBuildResponse buildResponse = null; <line27> try { <line28> validateDates(bundleStartDate, bundleEndDate); <line29> } catch (DateValidationException e) { <line30> try { <line31> buildResponse = new BundleBuildResponse(); <line32> buildResponse.setException(e); <line33> response = constructResponse(buildResponse); <line34> } catch (Exception any) { <line35> _log.error(""exception in build:"", any); <line36> response = Response.serverError().build(); <line37> } <line38> } <line39> if (response == null) { <line40> BundleBuildRequest buildRequest = new BundleBuildRequest(); <line41> buildRequest.setBundleDirectory(bundleDirectory); <line42> buildRequest.setBundleName(bundleName); <line43> buildRequest.setEmailAddress(email); <line44> buildRequest.setBundleStartDate(bundleStartDate); <line45> buildRequest.setBundleEndDate(bundleEndDate); <line46> buildRequest.setBundleComment(bundleComment); <line47> buildRequest.setArchiveFlag(archive); <line48> buildRequest.setConsolidateFlag(consolidate); <line49> buildRequest.setPredate(predate); <line50> String session = RequestContextHolder.currentRequestAttributes().getSessionId(); <line51> buildRequest.setSessionId(session); <line52> try { <line53> String message = <line54> ""Starting bundle building process for bundle '"" <line55> + buildRequest.getBundleName() <line56> + ""' initiated by user : "" <line57> + _currentUserService.getCurrentUserDetails().getUsername(); <line58> String component = System.getProperty(""admin.chefRole""); <line59> loggingService.log(component, Level.INFO, message); <line60> buildResponse = _bundleService.build(buildRequest); <line61> buildResponse = _bundleService.buildBundleResultURL(buildResponse.getId()); <line62> response = constructResponse(buildResponse); <line63> } catch (Exception any) { <line64> response = Response.serverError().build(); <line65> } <line66> } else { <line67> } <line68> return response; <line69> } <line70> } <line71> "	 <line28>	Yes
public class A { <line0> public void delete(FilterCol persistentInstance) { <line1> try { <line2> sessionFactory.getCurrentSession().delete(persistentInstance); <line3> } catch (RuntimeException re) { <line4> throw re; <line5> } <line6> } <line7> } <line8> 	 <line5>	No
"public class A { <line0> @ParameterizedTest <line1> @MethodSource(""org.nd4j.linalg.BaseNd4jTestWithBackends#configs"") <line2> public void testImageResize(Nd4jBackend backend) { <line3> for (ImageResizeMethod method : ImageResizeMethod.values()) { <line4> if (method == ImageResizeMethod.ResizeLanczos5 <line5> || method == ImageResizeMethod.ResizeArea <line6> || method == ImageResizeMethod.ResizeMitchelcubic) { <line7> continue; <line8> } <line9> Nd4j.getRandom().setSeed(12345); <line10> SameDiff sd = SameDiff.create(); <line11> boolean preserveAspectRatio = true; <line12> boolean antialias = true; <line13> SDVariable inputImage = sd.var(Nd4j.rand(DataType.FLOAT, 1, 5, 5, 3)); <line14> long[] expectedShape = new long[] {1, 3, 3, 3}; <line15> SDVariable requestedSize = sd.constant(Nd4j.createFromArray(new long[] {3, 3})); <line16> Function<INDArray, String> checkFunction = <line17> in -> { <line18> boolean shapeOk = Arrays.equals(expectedShape, in.shape()); <line19> if (shapeOk) return null; <line20> return ""Failed: shape differs - expected "" <line21> + Arrays.toString(expectedShape) <line22> + "" vs "" <line23> + Arrays.toString(in.shape()) <line24> + "" on method "" <line25> + method; <line26> }; <line27> SDVariable out = <line28> new ImageResize(sd, inputImage, requestedSize, preserveAspectRatio, antialias, method) <line29> .outputVariable() <line30> .std(true); <line31> String err = <line32> OpValidation.validate( <line33> new TestCase(sd).gradientCheck(false).expected(""image_resize"", checkFunction)); <line34> assertNull(err); <line35> } <line36> } <line37> } <line38> "	 <line2>	No
"public class A { <line0> @ExceptionHandler(OAuthProblemException.class) <line1> public ModelAndView handleOAuthProblemException(OAuthProblemException ex) { <line2> ModelAndView modelAndView = new ModelAndView(""oauth_error""); <line3> modelAndView.addObject(""exception"", ex); <line4> return modelAndView; <line5> } <line6> } <line7> "	 <line6>	No
public class A { <line0> private <T, B extends T> void addAsRegistrationBean( <line1> ListableBeanFactory beanFactory, <line2> Class<T> type, <line3> Class<B> beanType, <line4> RegistrationBeanAdapter<T> adapter) { <line5> List<Map.Entry<String, B>> beans = getOrderedBeansOfType(beanFactory, beanType, this.seen); <line6> for (Entry<String, B> bean : beans) { <line7> if (this.seen.add(bean.getValue())) { <line8> int order = getOrder(bean.getValue()); <line9> String beanName = bean.getKey(); <line10> RegistrationBean registration = <line11> adapter.createRegistrationBean(beanName, bean.getValue(), beans.size()); <line12> registration.setName(beanName); <line13> registration.setOrder(order); <line14> this.initializers.add(type, registration); <line15> if (ServletContextInitializerBeans.logger.isDebugEnabled()) { <line16> } <line17> } <line18> } <line19> } <line20> } <line21> 	 <line16>	Yes
public class A { <line0> private ObjectValuePair<HashMap<String, Locale>, HashMap<String, Locale>> _createGroupLocales( <line1> long groupId) { <line2> String[] languageIds = PropsValues.LOCALES_ENABLED; <line3> Locale defaultLocale = LocaleUtil.getDefault(); <line4> try { <line5> Group group = GroupLocalServiceUtil.getGroup(groupId); <line6> defaultLocale = PortalUtil.getSiteDefaultLocale(group); <line7> UnicodeProperties typeSettingsUnicodeProperties = group.getTypeSettingsProperties(); <line8> String groupLanguageIds = typeSettingsUnicodeProperties.getProperty(PropsKeys.LOCALES); <line9> if (groupLanguageIds != null) { <line10> languageIds = StringUtil.split(groupLanguageIds); <line11> } <line12> } catch (Exception exception) { <line13> if (_log.isDebugEnabled()) { <line14> } <line15> } <line16> HashMap<String, Locale> groupLanguageIdLocalesMap = new LinkedHashMap<>(); <line17> HashMap<String, Locale> groupLanguageCodeLocalesMap = <line18> HashMapBuilder.put(defaultLocale.getLanguage(), defaultLocale).build(); <line19> for (String languageId : languageIds) { <line20> Locale locale = LocaleUtil.fromLanguageId(languageId, false); <line21> String languageCode = languageId; <line22> int pos = languageId.indexOf(CharPool.UNDERLINE); <line23> if (pos > 0) { <line24> languageCode = languageId.substring(0, pos); <line25> } <line26> if (!groupLanguageCodeLocalesMap.containsKey(languageCode)) { <line27> groupLanguageCodeLocalesMap.put(languageCode, locale); <line28> } <line29> groupLanguageIdLocalesMap.put(languageId, locale); <line30> } <line31> _groupLanguageCodeLocalesMapMap.put(groupId, groupLanguageCodeLocalesMap); <line32> _groupLanguageIdLocalesMap.put(groupId, groupLanguageIdLocalesMap); <line33> _updateLastModified(); <line34> return new ObjectValuePair<>(groupLanguageCodeLocalesMap, groupLanguageIdLocalesMap); <line35> } <line36> } <line37> 	 <line5>	No
public class A { <line0> private void handleControlMessage(OdeControlData controlData) { <line1> String infoMsg = controlData.toJson(false); <line2> } <line3> } <line4> 	 <line2>	Yes
public class A { <line0> @Override <line1> protected void doReceive(Message message) throws Exception { <line2> long backgroundTaskId = message.getLong(BackgroundTaskConstants.BACKGROUND_TASK_ID); <line3> if (backgroundTaskId != _backgroundTaskId) { <line4> return; <line5> } <line6> BackgroundTaskStatus backgroundTaskStatus = <line7> _backgroundTaskStatusRegistry.getBackgroundTaskStatus(backgroundTaskId); <line8> if (backgroundTaskStatus == null) { <line9> if (_log.isDebugEnabled()) { <line10> } <line11> return; <line12> } <line13> _backgroundTaskStatusMessageTranslator.translate(backgroundTaskStatus, message); <line14> } <line15> } <line16> 	 <line10>	Yes
public class A { <line0> @Override <line1> public Uni<SecurityIdentity> authenticate( <line2> TrustedAuthenticationRequest request, AuthenticationRequestContext context) { <line3> return context.runBlocking( <line4> new Supplier<SecurityIdentity>() { <line5> @Override <line6> public SecurityIdentity get() { <line7> EntityManager em = entityManagerFactory.createEntityManager(); <line8> ((org.hibernate.Session) em).setHibernateFlushMode(FlushMode.MANUAL); <line9> ((org.hibernate.Session) em).setDefaultReadOnly(true); <line10> try { <line11> return authenticate(em, request); <line12> } catch (SecurityException e) { <line13> throw new AuthenticationFailedException(); <line14> } finally { <line15> em.close(); <line16> } <line17> } <line18> }); <line19> } <line20> } <line21> 	 <line11>	No
"public class A { <line0> @POST <line1> @Path(""submitAndSchedule/{extension-name}"") <line2> @Consumes({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.MULTIPART_FORM_DATA}) <line3> @Produces({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON}) <line4> public APIResult submitAndSchedule( <line5> @PathParam(""extension-name"") String extensionName, <line6> @Context HttpServletRequest request, <line7> @DefaultValue("""") @QueryParam(""doAs"") String doAsUser, <line8> @QueryParam(""jobName"") String jobName, <line9> @QueryParam(""colo"") final String coloExpr, <line10> @FormDataParam(""processes"") List<FormDataBodyPart> processForms, <line11> @FormDataParam(""feeds"") List<FormDataBodyPart> feedForms, <line12> @FormDataParam(""config"") InputStream config) { <line13> checkIfExtensionServiceIsEnabled(); <line14> checkIfExtensionIsEnabled(extensionName); <line15> checkIfExtensionJobNameExists(jobName, extensionName); <line16> SortedMap<EntityType, List<Entity>> entityMap; <line17> SortedMap<EntityType, List<String>> entityNameMap; <line18> ExtensionMetaStore metaStore = ExtensionStore.getMetaStore(); <line19> try { <line20> entityMap = getEntityList(extensionName, jobName, feedForms, processForms, config); <line21> submitEntities(extensionName, jobName, entityMap, config, request); <line22> entityNameMap = getJobEntities(metaStore.getExtensionJobDetails(jobName)); <line23> scheduleEntities(entityNameMap, request, coloExpr); <line24> } catch (FalconException | IOException | JAXBException e) { <line25> throw FalconWebException.newAPIException(e, Response.Status.INTERNAL_SERVER_ERROR); <line26> } <line27> return new APIResult( <line28> APIResult.Status.SUCCEEDED, ""Extension job submitted and scheduled successfully""); <line29> } <line30> } <line31> "	 <line25>	Yes
public class A { <line0> @Override <line1> protected void implCloseChannel() throws IOException { <line2> } <line3> } <line4> 	 <line2>	Yes
"public class A { <line0> private void addUrl(URL url) { <line1> if (url.getProtocol().equals(""file"") && url.getPath().endsWith(""/"")) { <line2> try { <line3> this.folders.add(ResourceUtils.getFile(url)); <line4> } catch (Exception ex) { <line5> } <line6> } <line7> } <line8> } <line9> "	 <line6>	No
"public class A { <line0> public void initialize() { <line1> String applicationDirectoryPath = getApplicationDirectoryPath(); <line2> if (applicationDirectoryPath != null) <line3> try { <line4> applicationRoot = VFS.getManager().resolveFile(applicationDirectoryPath); <line5> if (applicationRoot.getType() != FileType.FOLDER) { <line6> applicationRoot = null; <line7> } <line8> } catch (FileSystemException e) { <line9> } <line10> if (applicationRoot == null) { <line11> try { <line12> applicationRoot = getDefaultApplicationRoot(); <line13> } catch (FileSystemException e) { <line14> initializationFailed(e); <line15> } <line16> } <line17> try { <line18> loadConfiguration(); <line19> } catch (Exception e) { <line20> initializationFailed(e); <line21> } <line22> String actionsDirectory = getConfiguration().getString(""portofino.actions.path"", ""actions""); <line23> codeBase = initApplicationRoot(actionsDirectory); <line24> } <line25> } <line26> "	 <line9>	Yes
public class A { <line0> private long doSeek(TopicPartition newTp, OffsetAndMetadata committedOffset) { <line1> if (committedOffset != null) { <line2> if (commitMetadataManager.isOffsetCommittedByThisTopology( <line3> newTp, committedOffset, Collections.unmodifiableMap(offsetManagers))) { <line4> consumer.seek(newTp, committedOffset.offset()); <line5> } else { <line6> if (firstPollOffsetStrategy.equals(EARLIEST)) { <line7> consumer.seekToBeginning(Collections.singleton(newTp)); <line8> } else if (firstPollOffsetStrategy.equals(LATEST)) { <line9> consumer.seekToEnd(Collections.singleton(newTp)); <line10> } else { <line11> consumer.seek(newTp, committedOffset.offset()); <line12> } <line13> } <line14> } else { <line15> if (firstPollOffsetStrategy.equals(EARLIEST) <line16> || firstPollOffsetStrategy.equals(UNCOMMITTED_EARLIEST)) { <line17> consumer.seekToBeginning(Collections.singleton(newTp)); <line18> } else if (firstPollOffsetStrategy.equals(LATEST) <line19> || firstPollOffsetStrategy.equals(UNCOMMITTED_LATEST)) { <line20> consumer.seekToEnd(Collections.singleton(newTp)); <line21> } <line22> } <line23> return consumer.position(newTp); <line24> } <line25> } <line26> 	 <line1>	Yes
public class A { <line0> @Override <line1> public boolean verify(final Host host, final PublicKey key) <line2> throws ConnectionCanceledException, ChecksumException { <line3> if (null == database) { <line4> return super.verify(host, key); <line5> } <line6> final KeyType type = KeyType.fromKey(key); <line7> if (type == KeyType.UNKNOWN) { <line8> return false; <line9> } <line10> boolean foundApplicableHostEntry = false; <line11> for (OpenSSHKnownHosts.KnownHostEntry entry : database.entries()) { <line12> try { <line13> if (entry.appliesTo(type, format(host))) { <line14> foundApplicableHostEntry = true; <line15> if (entry.verify(key)) { <line16> return true; <line17> } <line18> } <line19> } catch (IOException e) { <line20> return false; <line21> } <line22> } <line23> if (foundApplicableHostEntry) { <line24> try { <line25> return this.isChangedKeyAccepted(host, key); <line26> } catch (ConnectionCanceledException | ChecksumException e) { <line27> return false; <line28> } <line29> } <line30> try { <line31> return this.isUnknownKeyAccepted(host, key); <line32> } catch (ConnectionCanceledException | ChecksumException e) { <line33> return false; <line34> } <line35> } <line36> } <line37> 	 <line4>	Yes
public class A { <line0> public void createIdpEventInitCustomer(final IdentityProvider sourceEvent) { <line1> create( <line2> getCurrentProofTenantIdentifier(), <line3> sourceEvent.getIdentifier(), <line4> MongoDbCollections.PROVIDERS, <line5> EventType.EXT_VITAMUI_CREATE_IDP, <line6> converters <line7> .getIdpConverter() <line8> .convertToLogbook(converters.getIdpConverter().convertEntityToDto(sourceEvent))); <line9> } <line10> } <line11> 	 <line9>	No
"public class A { <line0> @RequiresPermissions(""environments:delete"") <line1> @Override <line2> public void deleteAll() { <line3> try { <line4> List<EnvironmentLogic> del = new ArrayList<>(environments); <line5> for (EnvironmentLogic el : del) { <line6> delete(el); <line7> } <line8> } catch (Exception e) { <line9> } finally { <line10> environments.clear(); <line11> } <line12> } <line13> } <line14> "	 <line5>	No
"public class A { <line0> private void extractYarnLogByApplicationId(String applicationId, File destDir) throws Exception { <line1> if (shouldDoLogCollection(applicationId, kylinConfig)) { <line2> File destFile = new File(destDir, applicationId + "".log""); <line3> String yarnCmd = <line4> ""yarn logs -applicationId "" + applicationId + "" > "" + destFile.getAbsolutePath(); <line5> try { <line6> kylinConfig.getCliCommandExecutor().execute(yarnCmd); <line7> } catch (Exception ex) { <line8> } <line9> } else { <line10> } <line11> } <line12> } <line13> "	 <line8>	Yes
public class A { <line0> private void processDisambiguatedOrg(OrgDisambiguatedEntity entity) { <line1> OrgDisambiguatedSolrDocument document = convertEntityToDocument(entity); <line2> if (!messaging.send(document, updateSolrQueueName)) { <line3> orgDisambiguatedDao.updateIndexingStatus(entity.getId(), IndexingStatus.FAILED); <line4> return; <line5> } <line6> orgDisambiguatedDao.updateIndexingStatus(entity.getId(), IndexingStatus.DONE); <line7> } <line8> } <line9> 	 <line4>	No
public class A { <line0> @Override <line1> public void write(long cuboidId, GTRecord record) throws IOException { <line2> if (lastCuboidId == null || !lastCuboidId.equals(cuboidId)) { <line3> if (lastCuboidId != null) { <line4> cuboidRowCount = 0; <line5> } <line6> initVariables(cuboidId); <line7> lastCuboidId = cuboidId; <line8> } <line9> cuboidRowCount++; <line10> rowKeyEncoder.encode(record, record.getInfo().getPrimaryKey(), keyBuf); <line11> valueBuf.clear(); <line12> try { <line13> record.exportColumns(measureColumns, valueBuf); <line14> } catch (BufferOverflowException boe) { <line15> valueBuf = ByteBuffer.allocate((int) (record.sizeOf(measureColumns) * 1.5)); <line16> record.exportColumns(measureColumns, valueBuf); <line17> } <line18> outputKey.set(keyBuf, 0, keyBuf.length); <line19> outputValue.set(valueBuf.array(), 0, valueBuf.position()); <line20> writeAsKeyValue(outputKey, outputValue); <line21> } <line22> } <line23> 	 <line11>	No
public class A { <line0> protected void logException(Exception e, String message) { <line1> } <line2> } <line3> 	 <line0>	No
"public class A { <line0> @POST <line1> @Path(""schedule/{job-name}"") <line2> @Consumes({MediaType.TEXT_XML, MediaType.TEXT_PLAIN}) <line3> @Produces({MediaType.TEXT_XML, MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON}) <line4> public APIResult schedule( <line5> @PathParam(""job-name"") String jobName, <line6> @Context HttpServletRequest request, <line7> @DefaultValue("""") @QueryParam(""doAs"") String doAsUser) { <line8> throw FalconWebException.newAPIException( <line9> ""schedule is not supported on Server. Please run your operation "" + ""on Prism.""); <line10> } <line11> } <line12> "	 <line10>	No
public class A { <line0> @Override <line1> public void rollback() throws TransactionException { <line2> } <line3> } <line4> 	 <line3>	No
"public class A { <line0> @Bean(name = ""domainDistributionAutomationInboundKafkaRequestsMessageListenerContainer"") <line1> public DefaultMessageListenerContainer messageListenerContainer( <line2> @Qualifier(""domainDistributionAutomationInboundKafkaRequestsMessageListener"") <line3> final MessageListener messageListener) { <line4> return this.jmsConfigurationFactory.initMessageListenerContainer(messageListener); <line5> } <line6> } <line7> "	 <line5>	No
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> int currentSize = getCurrentSizeOperator().apply(entity); <line4> int desiredSize = Math.min(max, Math.max(min, currentSize)); <line5> if (currentSize != desiredSize) { <line6> if (LOG.isInfoEnabled()) <line7> resizeNow(""Size "" + currentSize + "" not in new bounds""); <line8> } <line9> } catch (Exception e) { <line10> if (isRunning()) { <line11> } else { <line12> } <line13> } catch (Throwable t) { <line14> throw Throwables.propagate(t); <line15> } <line16> } <line17> } <line18> "	 <line12>	Yes
"public class A { <line0> @Singleton <line1> @Zone <line2> @Override <line3> public Map<String, Supplier<Set<String>>> get() { <line4> Set<String> regions = regionsSupplier.get(); <line5> if (regions.size() == 0) { <line6> return ImmutableMap.of(); <line7> } <line8> Builder<String, Supplier<Set<String>>> regionToZones = ImmutableMap.builder(); <line9> for (String region : regions) { <line10> String configKey = PROPERTY_REGION + ""."" + region + "".zones""; <line11> String zones = config.apply(configKey); <line12> else <line13> regionToZones.put( <line14> region, <line15> Suppliers.<Set<String>>ofInstance(ImmutableSet.copyOf(Splitter.on(',').split(zones)))); <line16> } <line17> return regionToZones.build(); <line18> } <line19> } <line20> "	 <line6>	Yes
"public class A { <line0> private static void convertModel( <line1> Configuration conf, <line2> String modelInputDir, <line3> String convertedModelDir, <line4> MatrixFilesMeta meta, <line5> ModelLineConvert lineConvert) <line6> throws IOException { <line7> List<List<MatrixPartitionMeta>> groupByParts = groupByPartitions(meta.getPartMetas()); <line8> Path modelPath = new Path(modelInputDir); <line9> Path convertedModelPath = new Path(convertedModelDir); <line10> FileSystem modelFs = modelPath.getFileSystem(conf); <line11> FileSystem convertedModelFs = convertedModelPath.getFileSystem(conf); <line12> if (convertedModelFs.exists(convertedModelPath)) { <line13> convertedModelFs.delete(convertedModelPath, true); <line14> } <line15> Vector<String> errorLogs = new Vector<>(); <line16> ConvertOp convertOp = <line17> new ConvertOp( <line18> modelPath, <line19> modelFs, <line20> convertedModelPath, <line21> convertedModelFs, <line22> lineConvert, <line23> groupByParts, <line24> meta, <line25> errorLogs, <line26> 0, <line27> groupByParts.size()); <line28> pool.execute(convertOp); <line29> convertOp.join(); <line30> if (!errorLogs.isEmpty()) { <line31> throw new IOException(String.join(""\n"", errorLogs)); <line32> } <line33> } <line34> } <line35> "	 <line13>	Yes
public class A { <line0> protected synchronized void debug(boolean hit) { <line1> if (hit) { <line2> match++; <line3> } else { <line4> miss++; <line5> } <line6> if (match + miss >= debug) { <line7> match = 0; <line8> miss = 0; <line9> } <line10> } <line11> } <line12> 	 <line7>	Yes
"public class A { <line0> public static AppEngine buildAppEngine(URL resource) { <line1> try (GenericXmlApplicationContext applicationContext = <line2> new GenericXmlApplicationContext(new UrlResource(resource))) { <line3> Map<String, AppEngine> beansOfType = applicationContext.getBeansOfType(AppEngine.class); <line4> if ((beansOfType == null) || beansOfType.isEmpty()) { <line5> throw new FlowableException( <line6> ""no "" <line7> + AppEngine.class.getName() <line8> + "" defined in the application context "" <line9> + resource.toString()); <line10> } <line11> AppEngine appEngine = beansOfType.values().iterator().next(); <line12> return appEngine; <line13> } <line14> } <line15> } <line16> "	 <line4>	No
"public class A { <line0> @Override <line1> public void evaluate() throws Throwable { <line2> URL composeYml = getClass().getResource(REDIS_COMPOSE_YML); <line3> assertThat(composeYml).as(""Cannot load resource "" + REDIS_COMPOSE_YML).isNotNull(); <line4> redisCluster = new DockerComposeContainer<>(""acceptance"", new File(composeYml.getFile())); <line5> for (int i = 0; i < NODE_COUNT; i++) { <line6> redisCluster.withExposedService(""redis-node-"" + i, REDIS_PORT); <line7> } <line8> redisCluster.withLocalCompose(true); <line9> redisCluster.waitingFor( <line10> ""redis-cluster-init_1"", Wait.forLogMessage("".*Ready to accept connections.*"", 1)); <line11> redisCluster.start(); <line12> int port = redisCluster.getServicePort(""redis-node-0"", REDIS_PORT); <line13> Jedis jedis = new Jedis(""localhost"", port); <line14> List<ClusterNode> nodes = ClusterNodes.parseClusterNodes(jedis.clusterNodes()).getNodes(); <line15> nodes.forEach(logger::info); <line16> assertThat(nodes.stream().mapToInt(x -> x.primary ? 1 : 0).sum()) <line17> .as(""Incorrect primary node count"") <line18> .isEqualTo(3); <line19> Map<HostPort, HostPort> translationMappings = new HashMap<>(); <line20> List<RedisProxy> proxies = new ArrayList<>(); <line21> for (int i = 0; i < NODE_COUNT; i++) { <line22> Map<String, ContainerNetwork> networks = <line23> redisCluster <line24> .getContainerByServiceName(""redis-node-"" + i + ""_1"") <line25> .get() <line26> .getContainerInfo() <line27> .getNetworkSettings() <line28> .getNetworks(); <line29> ContainerNetwork network = networks.values().iterator().next(); <line30> String containerIp = network.getIpAddress(); <line31> int socatPort = redisCluster.getServicePort(""redis-node-"" + i, REDIS_PORT); <line32> RedisProxy proxy = new RedisProxy(socatPort); <line33> Integer exposedPort = proxy.getExposedPort(); <line34> exposedPorts.add(exposedPort); <line35> translationMappings.put( <line36> new HostPort(containerIp, REDIS_PORT), new HostPort(""127.0.0.1"", exposedPort)); <line37> proxies.add(proxy); <line38> } <line39> proxies.forEach(p -> p.configure(translationMappings)); <line40> try { <line41> base.evaluate(); <line42> } finally { <line43> redisCluster.stop(); <line44> proxies.forEach(RedisProxy::stop); <line45> exposedPorts.clear(); <line46> } <line47> } <line48> } <line49> "	 <line16>	No
public class A { <line0> protected synchronized void stopInternal() { <line1> if (exec == null) return; <line2> for (Monitor m : monitors) { <line3> m.stop(); <line4> } <line5> Utils.shutdownAndWait(exec); <line6> if (!exec.isTerminated()) { <line7> } <line8> this.exec = null; <line9> } <line10> } <line11> 	 <line3>	No
public class A { <line0> public static long getLong(String key, long def) { <line1> String value = get(key); <line2> if (value == null) { <line3> return def; <line4> } <line5> value = value.trim().toLowerCase(); <line6> if (INTEGER_PATTERN.matcher(value).matches()) { <line7> try { <line8> return Long.parseLong(value); <line9> } catch (Exception e) { <line10> } <line11> } <line12> return def; <line13> } <line14> } <line15> 	 <line2>	No
"public class A { <line0> private void dumpClassIfNecessary(Class<?> clazz, byte[] data) { <line1> String className = clazz.getName(); <line2> ClassLoader classLoader = clazz.getClassLoader(); <line3> String classDumpDir = ""classdump""; <line4> File dumpDir = null; <line5> if (directory != null) { <line6> dumpDir = directory; <line7> } else { <line8> dumpDir = new File(arthasLogHome, classDumpDir); <line9> } <line10> if (!dumpDir.mkdirs() && !dumpDir.exists()) { <line11> return; <line12> } <line13> String fileName; <line14> if (classLoader != null) { <line15> fileName = <line16> classLoader.getClass().getName() <line17> + ""-"" <line18> + Integer.toHexString(classLoader.hashCode()) <line19> + File.separator <line20> + className.replace(""."", File.separator) <line21> + "".class""; <line22> } else { <line23> fileName = className.replace(""."", File.separator) + "".class""; <line24> } <line25> File dumpClassFile = new File(dumpDir, fileName); <line26> try { <line27> FileUtils.writeByteArrayToFile(dumpClassFile, data); <line28> dumpResult.put(clazz, dumpClassFile); <line29> } catch (IOException e) { <line30> } <line31> } <line32> } <line33> "	 <line11>	Yes
public class A { <line0> protected long getBatchTimeout(String sensorType, WriterConfiguration configurations) { <line1> int batchTimeoutSecs = configurations.getBatchTimeout(sensorType); <line2> if (batchTimeoutSecs <= 0 || batchTimeoutSecs > maxBatchTimeout) { <line3> batchTimeoutSecs = maxBatchTimeout; <line4> } <line5> return TimeUnit.SECONDS.toMillis(batchTimeoutSecs); <line6> } <line7> } <line8> 	 <line0>	No
"public class A { <line0> @BeforeClass <line1> public static void init() throws Exception { <line2> CCConfig ccConfig = new CCConfig(); <line3> ccConfig.setClientListenAddress(""127.0.0.1""); <line4> ccConfig.setClientListenPort(39000); <line5> ccConfig.setClusterListenAddress(""127.0.0.1""); <line6> ccConfig.setClusterListenPort(39001); <line7> ccConfig.setProfileDumpPeriod(10000); <line8> FileUtils.deleteQuietly(new File(""target"" + File.separator + ""data"")); <line9> FileUtils.copyDirectory(new File(""data""), new File(joinPath(""target"", ""data""))); <line10> File outDir = new File(""target"" + File.separator + ""ClusterController""); <line11> outDir.mkdirs(); <line12> File ccRoot = File.createTempFile(AbstractIntegrationTest.class.getName(), "".data"", outDir); <line13> ccRoot.delete(); <line14> ccRoot.mkdir(); <line15> ccConfig.setRootDir(ccRoot.getAbsolutePath()); <line16> cc = new ClusterControllerService(ccConfig); <line17> cc.start(); <line18> NCConfig ncConfig1 = new NCConfig(NC1_ID); <line19> ncConfig1.setClusterAddress(""localhost""); <line20> ncConfig1.setClusterPort(39001); <line21> ncConfig1.setClusterListenAddress(""127.0.0.1""); <line22> ncConfig1.setDataListenAddress(""127.0.0.1""); <line23> ncConfig1.setResultListenAddress(""127.0.0.1""); <line24> ncConfig1.setIODevices( <line25> new String[] {joinPath(System.getProperty(""user.dir""), ""target"", ""data"", ""device0"")}); <line26> nc1 = new NodeControllerService(ncConfig1); <line27> nc1.start(); <line28> NCConfig ncConfig2 = new NCConfig(NC2_ID); <line29> ncConfig2.setClusterAddress(""localhost""); <line30> ncConfig2.setClusterPort(39001); <line31> ncConfig2.setClusterListenAddress(""127.0.0.1""); <line32> ncConfig2.setDataListenAddress(""127.0.0.1""); <line33> ncConfig2.setResultListenAddress(""127.0.0.1""); <line34> ncConfig2.setIODevices( <line35> new String[] {joinPath(System.getProperty(""user.dir""), ""target"", ""data"", ""device1"")}); <line36> nc2 = new NodeControllerService(ncConfig2); <line37> nc2.start(); <line38> hcc = new HyracksConnection(ccConfig.getClientListenAddress(), ccConfig.getClientListenPort()); <line39> if (LOGGER.isInfoEnabled()) { <line40> } <line41> } <line42> } <line43> "	 <line13>	No
"public class A { <line0> @Override <line1> public void run() { <line2> final Bootstrap boot = new Bootstrap(); <line3> final ThreadFactory clientFactory = new DefaultThreadFactory(""client""); <line4> final NioEventLoopGroup connectGroup = <line5> new NioEventLoopGroup(1, clientFactory, NioUdtProvider.BYTE_PROVIDER); <line6> try { <line7> boot.group(connectGroup) <line8> .channelFactory(NioUdtProvider.BYTE_CONNECTOR) <line9> .handler( <line10> new ChannelInitializer<UdtChannel>() { <line11> @Override <line12> protected void initChannel(final UdtChannel ch) throws Exception { <line13> final ChannelPipeline pipeline = ch.pipeline(); <line14> pipeline.addLast( <line15> ""framer"", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); <line16> pipeline.addLast(""decoder"", new StringDecoder(CharsetUtil.UTF_8)); <line17> pipeline.addLast(""encoder"", new StringEncoder(CharsetUtil.UTF_8)); <line18> pipeline.addLast(""handler"", new ClientHandler()); <line19> } <line20> }); <line21> channel = boot.connect(address).sync().channel(); <line22> isRunning = true; <line23> waitForRunning(false); <line24> channel.close().sync(); <line25> isShutdown = true; <line26> } catch (final Throwable e) { <line27> } finally { <line28> connectGroup.shutdownGracefully().syncUninterruptibly(); <line29> } <line30> } <line31> } <line32> "	 <line27>	Yes
public class A { <line0> @Override <line1> public void prepareHandshakeMessageContents() { <line2> msg.prepareComputations(); <line3> msg.getComputations().setPrivateKey(chooser.getConfig().getDefaultServerEcPrivateKey()); <line4> prepareCurveType(msg); <line5> prepareEcDhParams(); <line6> SignatureAndHashAlgorithm signHashAlgo = chooser.getSelectedSigHashAlgorithm(); <line7> prepareSignatureAndHashAlgorithm(msg, signHashAlgo); <line8> byte[] signature = new byte[0]; <line9> try { <line10> signature = generateSignature(msg, signHashAlgo); <line11> } catch (CryptoException E) { <line12> } <line13> prepareSignature(msg, signature); <line14> prepareSignatureLength(msg); <line15> } <line16> } <line17> 	 <line4>	No
public class A { <line0> private void scheduleOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) { <line1> if (scheduledFuture.get() == null && !context.isCurrentChangeSetProcessed()) { <line2> lock.lock(); <line3> try { <line4> Supplier<TaskAssigningSolution> solutionSupplier = () -> lastBestSolution.get(); <line5> ScheduledFuture<?> future = <line6> executorService.schedule( <line7> () -> executeSolutionChange(chBestSolution, solutionSupplier), <line8> delay, <line9> TimeUnit.MILLISECONDS); <line10> scheduledFuture.set(future); <line11> } finally { <line12> lock.unlock(); <line13> } <line14> } <line15> } <line16> } <line17> 	 <line3>	Yes
public class A { <line0> public static long zip(File directory, File outputZipFile) throws IOException { <line1> if (!isZip(outputZipFile.getName())) { <line2> } <line3> try (final FileOutputStream out = new FileOutputStream(outputZipFile)) { <line4> return zip(directory, out); <line5> } <line6> } <line7> } <line8> 	 <line2>	Yes
"public class A { <line0> private Response getElementsFromIndex( <line1> final String graphName, final String indexName, final boolean showTypes) { <line2> final Index index = this.getIndexFromGraph(graphName, indexName); <line3> final RexsterApplicationGraph rag = this.getRexsterApplicationGraph(graphName); <line4> String key = null; <line5> Object value = null; <line6> final JSONObject theRequestObject = this.getRequestObject(); <line7> Object temp = theRequestObject.opt(Tokens.KEY); <line8> if (null != temp) key = temp.toString(); <line9> temp = theRequestObject.opt(Tokens.VALUE); <line10> if (null != temp) value = ElementHelper.getTypedPropertyValue(temp.toString()); <line11> final Long start = RequestObjectHelper.getStartOffset(theRequestObject); <line12> final Long end = RequestObjectHelper.getEndOffset(theRequestObject); <line13> final Set<String> returnKeys = RequestObjectHelper.getReturnKeys(theRequestObject); <line14> final GraphSONMode mode = showTypes ? GraphSONMode.EXTENDED : GraphSONMode.NORMAL; <line15> long counter = 0l; <line16> if (null != index && key != null && value != null) { <line17> final CloseableIterable<Element> indexElements = <line18> (CloseableIterable<Element>) index.get(key, value); <line19> try { <line20> final JSONArray elementArray = new JSONArray(); <line21> for (Element element : indexElements) { <line22> if (counter >= start && counter < end) { <line23> elementArray.put(GraphSONUtility.jsonFromElement(element, returnKeys, mode)); <line24> } <line25> counter++; <line26> } <line27> this.resultObject.put(Tokens.RESULTS, elementArray); <line28> this.resultObject.put(Tokens.TOTAL_SIZE, counter); <line29> this.resultObject.put(Tokens.QUERY_TIME, this.sh.stopWatch()); <line30> } catch (JSONException ex) { <line31> final JSONObject error = generateErrorObjectJsonFail(ex); <line32> throw new WebApplicationException( <line33> Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(error).build()); <line34> } finally { <line35> indexElements.close(); <line36> rag.tryCommit(); <line37> } <line38> } else if (null == index) { <line39> final String msg = ""Could not find index ["" + indexName + ""] on graph ["" + graphName + ""]""; <line40> final JSONObject error = generateErrorObject(msg); <line41> throw new WebApplicationException( <line42> Response.status(Response.Status.NOT_FOUND).entity(error).build()); <line43> } else { <line44> final HashMap map = new HashMap(); <line45> map.put(Tokens.QUERY_TIME, this.sh.stopWatch()); <line46> map.put(Tokens.RESULTS, createJSONObject(index)); <line47> this.resultObject = new JSONObject(map); <line48> } <line49> return Response.ok(this.resultObject).build(); <line50> } <line51> } <line52> "	 <line31>	Yes
public class A { <line0> @Override <line1> protected InputStream decorate(final InputStream in, final MessageDigest digest) <line2> throws IOException { <line3> if (null == digest) { <line4> return super.decorate(in, null); <line5> } else { <line6> return new DigestInputStream(super.decorate(in, digest), digest); <line7> } <line8> } <line9> } <line10> 	 <line4>	Yes
public class A { <line0> public void unset() { <line1> final LinkedList<Type> universeList = CURRENT_UNIVERSE.get(); <line2> if (universeList != null && !universeList.isEmpty()) { <line3> universeList.removeLast(); <line4> if (LOGGER.isDebugEnabled()) { <line5> } <line6> } <line7> } <line8> } <line9> 	 <line5>	Yes
public class A { <line0> private List<Certificate[]> getKeystoreCertificatesChains(KeyStore keystore) { <line1> List<Certificate[]> keystoreCertificateChains = new ArrayList<>(); <line2> try { <line3> Enumeration<String> aliases = keystore.aliases(); <line4> while (aliases.hasMoreElements()) { <line5> String alias = aliases.nextElement(); <line6> Certificate[] certificateChain = keystore.getCertificateChain(alias); <line7> if (certificateChain != null) { <line8> keystoreCertificateChains.add(certificateChain); <line9> } else { <line10> Certificate certificate = keystore.getCertificate(alias); <line11> keystoreCertificateChains.add(new Certificate[] {certificate}); <line12> } <line13> } <line14> } catch (KeyStoreException e) { <line15> } <line16> return keystoreCertificateChains; <line17> } <line18> } <line19> 	 <line15>	Yes
public class A { <line0> @Override <line1> protected void connectionLog(String message) { <line2> } <line3> } <line4> 	 <line0>	No
public class A { <line0> @Override <line1> public MDRAction findByPrimaryKey(Serializable primaryKey) throws NoSuchActionException { <line2> MDRAction mdrAction = fetchByPrimaryKey(primaryKey); <line3> if (mdrAction == null) { <line4> if (_log.isDebugEnabled()) { <line5> } <line6> throw new NoSuchActionException(_NO_SUCH_ENTITY_WITH_PRIMARY_KEY + primaryKey); <line7> } <line8> return mdrAction; <line9> } <line10> } <line11> 	 <line5>	Yes
public class A { <line0> @Override <line1> public void appendAddEvent( <line2> long id, <line3> byte recordType, <line4> Persister persister, <line5> Object record, <line6> boolean sync, <line7> IOCompletion completionCallback) <line8> throws Exception { <line9> if (log.isTraceEnabled()) { <line10> } <line11> replicationManager.appendUpdateRecord( <line12> journalID, ADD_OPERATION_TYPE.EVENT, id, recordType, persister, record); <line13> localJournal.appendAddEvent(id, recordType, persister, record, sync, completionCallback); <line14> } <line15> } <line16> 	 <line10>	Yes
public class A { <line0> @Override <line1> public void stop() { <line2> if (clientFactory != null) { <line3> clientFactory.release(); <line4> } <line5> } <line6> } <line7> 	 <line2>	Yes
"public class A { <line0> @RequestMapping(""/experimentoverview"") <line1> public @ResponseBody String experimentoverview( <line2> @RequestParam(value = ""experimentType"") String experimentType, <line3> @RequestParam(value = ""matching"") String matchingString) { <line4> Matching matching = MainController.getMatching(matchingString); <line5> ExperimentType eType = ExperimentType.valueOf(experimentType); <line6> String annotatorNames[] = loadAnnotators(eType); <line7> String datasetNames[] = loadDatasets(eType); <line8> double results[][] = loadLatestResults(eType, matching, annotatorNames, datasetNames); <line9> double correlations[][] = calculateCorrelations(results, datasetNames); <line10> return generateJson(results, correlations, annotatorNames, datasetNames); <line11> } <line12> } <line13> "	 <line4>	Yes
"public class A { <line0> @Override <line1> public void run2() throws CacheException { <line2> AttributesFactory factory = new AttributesFactory(); <line3> factory.setScope(Scope.DISTRIBUTED_ACK); <line4> factory.setDataPolicy(DataPolicy.REPLICATE); <line5> EvictionAttributes evictAttrs = <line6> EvictionAttributes.createLRUEntryAttributes( <line7> evictionThreshold, EvictionAction.OVERFLOW_TO_DISK); <line8> factory.setEvictionAttributes(evictAttrs); <line9> for (int i = 0; i < cqDUnitTest.regions.length; i++) { <line10> Region region = createRegion(cqDUnitTest.regions[i], factory.createRegionAttributes()); <line11> region.getAttributesMutator().addCacheListener(new CertifiableTestCacheListener()); <line12> } <line13> Wait.pause(2000); <line14> try { <line15> cqDUnitTest.startBridgeServer(0, true); <line16> } catch (Exception ex) { <line17> Assert.fail(""While starting CacheServer"", ex); <line18> } <line19> Wait.pause(2000); <line20> } <line21> } <line22> "	 <line16>	No
"public class A { <line0> public void deletedPaymentMethod( <line1> final Account account, <line2> final UUID paymentMethodId, <line3> final boolean deleteDefaultPaymentMethodWithAutoPayOff, <line4> final boolean forceDefaultPaymentMethodDeletion, <line5> final Iterable<PluginProperty> properties, <line6> final CallContext callContext, <line7> final InternalCallContext context) <line8> throws PaymentApiException { <line9> try { <line10> new WithAccountLock<Void, PaymentApiException>(paymentConfig) <line11> .processAccountWithLock( <line12> locker, <line13> account.getId(), <line14> new DispatcherCallback<PluginDispatcherReturnType<Void>, PaymentApiException>() { <line15> @Override <line16> public PluginDispatcherReturnType<Void> doOperation() throws PaymentApiException { <line17> @SuppressWarnings(""unused"") <line18> final PaymentMethodModelDao paymentMethodModel = <line19> getPaymentMethodById(paymentMethodId, false, context); <line20> try { <line21> if (paymentMethodId.equals(account.getPaymentMethodId())) { <line22> if (!deleteDefaultPaymentMethodWithAutoPayOff <line23> && !forceDefaultPaymentMethodDeletion) { <line24> throw new PaymentApiException( <line25> ErrorCode.PAYMENT_DEL_DEFAULT_PAYMENT_METHOD, account.getId()); <line26> } else { <line27> if (deleteDefaultPaymentMethodWithAutoPayOff <line28> && !isAccountAutoPayOff(account.getId(), context)) { <line29> setAccountAutoPayOff(account.getId(), context); <line30> } <line31> accountInternalApi.removePaymentMethod(account.getId(), context); <line32> } <line33> } <line34> final PaymentPluginApi pluginApi = <line35> getPaymentProviderPlugin(paymentMethodId, false, context); <line36> pluginApi.deletePaymentMethod( <line37> account.getId(), paymentMethodId, properties, callContext); <line38> paymentDao.deletedPaymentMethod(paymentMethodId, context); <line39> return PluginDispatcher.createPluginDispatcherReturnType(null); <line40> } catch (final PaymentPluginApiException e) { <line41> throw new PaymentApiException( <line42> e, <line43> ErrorCode.PAYMENT_DEL_PAYMENT_METHOD, <line44> account.getId(), <line45> e.getErrorMessage()); <line46> } catch (final AccountApiException e) { <line47> throw new PaymentApiException(e); <line48> } <line49> } <line50> }); <line51> } catch (final Exception e) { <line52> throw new PaymentApiException( <line53> e, ErrorCode.PAYMENT_INTERNAL_ERROR, MoreObjects.firstNonNull(e.getMessage(), """")); <line54> } <line55> } <line56> } <line57> "	 <line16>	No
"public class A { <line0> static void migrateLastIpColumn( <line1> Statement st, DatabaseMetaData metaData, String tableName, Columns col) throws SQLException { <line2> final boolean isNotNullWithoutDefault = <line3> SqlDataSourceUtils.isNotNullColumn(metaData, tableName, col.LAST_IP) <line4> && SqlDataSourceUtils.getColumnDefaultValue(metaData, tableName, col.LAST_IP) == null; <line5> if (isNotNullWithoutDefault) { <line6> String sql = <line7> String.format( <line8> ""ALTER TABLE %s MODIFY %s VARCHAR(40) CHARACTER SET ascii COLLATE ascii_bin"", <line9> tableName, col.LAST_IP); <line10> st.execute(sql); <line11> } <line12> } <line13> } <line14> "	 <line13>	No
public class A { <line0> private static void addAuthorization(SearchMetadataCollection doc, String aclString) { <line1> Map<String, List<String>> permissions = new HashMap<String, List<String>>(); <line2> for (Action action : Permissions.Action.values()) { <line3> permissions.put(action.toString(), new ArrayList<String>()); <line4> } <line5> AccessControlList acl = AccessControlParser.parseAclSilent(aclString); <line6> for (AccessControlEntry entry : acl.getEntries()) { <line7> if (!entry.isAllow()) { <line8> continue; <line9> } <line10> List<String> actionPermissions = permissions.get(entry.getAction()); <line11> if (actionPermissions == null) { <line12> actionPermissions = new ArrayList<String>(); <line13> permissions.put(entry.getAction(), actionPermissions); <line14> } <line15> actionPermissions.add(entry.getRole()); <line16> } <line17> for (Map.Entry<String, List<String>> entry : permissions.entrySet()) { <line18> String fieldName = EventIndexSchema.ACL_PERMISSION_PREFIX.concat(entry.getKey()); <line19> doc.addField(fieldName, entry.getValue(), false); <line20> } <line21> } <line22> } <line23> 	 <line8>	Yes
"public class A { <line0> private void flushInternal() { <line1> try { <line2> if (w != null && readyForCommit) { <line3> w.commit(); <line4> copy(index, FSDirectory.open(getIndexDirectory().toPath())); <line5> readyForCommit = false; <line6> reader = null; <line7> isInitialized = false; <line8> } <line9> } catch (Exception e) { <line10> throw new LuceneIndexingException(""Error while Flushing Lucene Indexes"", e); <line11> } <line12> } <line13> } <line14> "	 <line11>	No
public class A { <line0> @Override <line1> public BigDecimal calcDimValue(Device device) { <line2> BigDecimal dimValue = new BigDecimal(0); <line3> switch (((TellstickDevice) device).getStatus()) { <line4> case JNA.CLibrary.TELLSTICK_TURNON: <line5> dimValue = new BigDecimal(100); <line6> break; <line7> case JNA.CLibrary.TELLSTICK_TURNOFF: <line8> break; <line9> case JNA.CLibrary.TELLSTICK_DIM: <line10> dimValue = new BigDecimal(((TellstickDevice) device).getData()); <line11> dimValue = dimValue.multiply(new BigDecimal(100)); <line12> dimValue = dimValue.divide(new BigDecimal(255), 0, RoundingMode.HALF_UP); <line13> break; <line14> default: <line15> } <line16> return dimValue; <line17> } <line18> } <line19> 	 <line2>	No
"public class A { <line0> @Override <line1> public FlinkPod decorateFlinkPod(FlinkPod flinkPod) { <line2> final PodBuilder basicPodBuilder = new PodBuilder(flinkPod.getPodWithoutMainContainer()); <line3> final String serviceAccountName = <line4> KubernetesUtils.resolveUserDefinedValue( <line5> flinkConfig, <line6> KubernetesConfigOptions.JOB_MANAGER_SERVICE_ACCOUNT, <line7> kubernetesJobManagerParameters.getServiceAccount(), <line8> KubernetesUtils.getServiceAccount(flinkPod), <line9> ""service account""); <line10> if (flinkPod.getPodWithoutMainContainer().getSpec().getRestartPolicy() != null) { <line11> } <line12> basicPodBuilder <line13> .withApiVersion(API_VERSION) <line14> .editOrNewSpec() <line15> .withServiceAccount(serviceAccountName) <line16> .withServiceAccountName(serviceAccountName) <line17> .endSpec(); <line18> basicPodBuilder <line19> .editOrNewMetadata() <line20> .addToLabels(kubernetesJobManagerParameters.getLabels()) <line21> .addToAnnotations(kubernetesJobManagerParameters.getAnnotations()) <line22> .endMetadata() <line23> .editOrNewSpec() <line24> .addToImagePullSecrets(kubernetesJobManagerParameters.getImagePullSecrets()) <line25> .addToNodeSelector(kubernetesJobManagerParameters.getNodeSelector()) <line26> .addAllToTolerations( <line27> kubernetesJobManagerParameters.getTolerations().stream() <line28> .map(e -> KubernetesToleration.fromMap(e).getInternalResource()) <line29> .collect(Collectors.toList())) <line30> .endSpec(); <line31> final Container basicMainContainer = decorateMainContainer(flinkPod.getMainContainer()); <line32> return new FlinkPod.Builder(flinkPod) <line33> .withPod(basicPodBuilder.build()) <line34> .withMainContainer(basicMainContainer) <line35> .build(); <line36> } <line37> } <line38> "	 <line11>	Yes
"public class A { <line0> @Override <line1> protected void map( <line2> Object k, Object v, Mapper<Object, Object, BytesWritable, Text>.Context context) <line3> throws IOException, InterruptedException { <line4> Counter unparseableReport = context.getCounter(""app"", ""unparseable chunks""); <line5> Text t; <line6> BytesWritable bw; <line7> if (k instanceof ChukwaArchiveKey && v instanceof ChunkImpl) { <line8> ChunkImpl value = (ChunkImpl) v; <line9> Report xtrReport = Report.createFromString(new String(value.getData())); <line10> try { <line11> bw = new BytesWritable(xtrReport.getMetadata().getTaskId().get()); <line12> } catch (Exception e) { <line13> unparseableReport.increment(1); <line14> return; <line15> } <line16> t = new Text(value.getData()); <line17> } else if (k instanceof ChukwaRecordKey && v instanceof ChukwaRecord) { <line18> ChukwaRecord value = (ChukwaRecord) v; <line19> Report xtrReport = Report.createFromString(value.getValue(Record.bodyField)); <line20> bw = new BytesWritable(xtrReport.getMetadata().getTaskId().get()); <line21> t = new Text(value.getValue(Record.bodyField)); <line22> } else { <line23> return; <line24> } <line25> context.write(bw, t); <line26> } <line27> } <line28> "	 <line26>	No
"public class A { <line0> protected synchronized void activate( <line1> final Map<String, Object> properties, ComponentContext componentContext) { <line2> this.filter = String.valueOf(properties.getOrDefault(REGEX_PROP, """")); <line3> this.componentPid = String.valueOf(properties.get(KURA_SERVICE_PID)); <line4> this.filterType = getType(properties); <line5> this.wireSupport = <line6> this.wireHelperService.newWireSupport( <line7> this, (ServiceReference<WireComponent>) componentContext.getServiceReference()); <line8> } <line9> } <line10> "	 <line2>	Yes
public class A { <line0> private void prepareCcsProtocolType(ChangeCipherSpecMessage msg) { <line1> msg.setCcsProtocolType(CCS_PROTOCOL_TYPE); <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> @Override <line1> public List<TMTextUnit> doWithRetry(RetryContext context) throws DataIntegrityViolationException { <line2> if (context.getRetryCount() > 0) { <line3> long mapExactMatches = mapExactMatches(assetExtractionId, tmId, assetId); <line4> } <line5> return createTMTextUnitForUnmappedAssetTextUnits( <line6> createdByUser, assetExtractionId, tmId, assetId); <line7> } <line8> } <line9> 	 <line4>	Yes
"public class A { <line0> private void registerListener() { <line1> clusterConfig.addListener( <line2> new Listener<ClusterConfig>() { <line3> @Override <line4> public void onChanged(ClusterConfig current) { <line5> try { <line6> doSwitch(current); <line7> } catch (Throwable t) { <line8> String msg = ""ClusterConfig changed listener error""; <line9> throw new DalRuntimeException(msg, t); <line10> } <line11> } <line12> }); <line13> } <line14> } <line15> "	 <line14>	No
public class A { <line0> @Override <line1> public void updateUserStats(List<UserStatisticsVO> userStats) { <line2> TransactionLegacy txn = TransactionLegacy.currentTxn(); <line3> try { <line4> txn.start(); <line5> String sql = UPDATE_USER_STATS; <line6> PreparedStatement pstmt = null; <line7> pstmt = txn.prepareAutoCloseStatement(sql); <line8> for (UserStatisticsVO userStat : userStats) { <line9> pstmt.setLong(1, userStat.getNetBytesReceived()); <line10> pstmt.setLong(2, userStat.getNetBytesSent()); <line11> pstmt.setLong(3, userStat.getCurrentBytesReceived()); <line12> pstmt.setLong(4, userStat.getCurrentBytesSent()); <line13> pstmt.setLong(5, userStat.getAggBytesReceived()); <line14> pstmt.setLong(6, userStat.getAggBytesSent()); <line15> pstmt.setLong(7, userStat.getId()); <line16> pstmt.addBatch(); <line17> } <line18> pstmt.executeBatch(); <line19> txn.commit(); <line20> } catch (Exception ex) { <line21> txn.rollback(); <line22> throw new CloudRuntimeException(ex.getMessage()); <line23> } <line24> } <line25> } <line26> 	 <line22>	Yes
"public class A { <line0> @Override <line1> public void onTimeOut() { <line2> _statusUpdateUtil.logError( <line3> _originalMessage, SchedulerAsyncCallback.class, ""Task timeout"", _manager); <line4> addSummary(_resultSummaryMap, _originalMessage, _manager, true); <line5> } <line6> } <line7> "	 <line1>	No
"public class A { <line0> @RequestMapping(""/execute"") <line1> public @ResponseBody String execute( <line2> @RequestParam(value = ""experimentData"") String experimentData) { <line3> Object obj = JSONValue.parse(experimentData); <line4> JSONObject configuration = (JSONObject) obj; <line5> String typeString = (String) configuration.get(""type""); <line6> ExperimentType type = null; <line7> try { <line8> type = ExperimentType.valueOf(typeString); <line9> } catch (IllegalArgumentException e) { <line10> return null; <line11> } <line12> String matching = (String) configuration.get(""matching""); <line13> JSONArray jsonAnnotators = (JSONArray) configuration.get(""annotator""); <line14> String[] annotators = new String[jsonAnnotators.size()]; <line15> for (int i = 0; i < jsonAnnotators.size(); i++) { <line16> annotators[i] = (String) jsonAnnotators.get(i); <line17> } <line18> JSONArray jsonDataset = (JSONArray) configuration.get(""dataset""); <line19> String[] datasets = new String[jsonDataset.size()]; <line20> for (int i = 0; i < jsonDataset.size(); i++) { <line21> datasets[i] = (String) jsonDataset.get(i); <line22> } <line23> ExperimentTaskConfiguration[] configs = <line24> new ExperimentTaskConfiguration[annotators.length * datasets.length]; <line25> int count = 0; <line26> for (String annotator : annotators) { <line27> for (String dataset : datasets) { <line28> configs[count] = <line29> new ExperimentTaskConfiguration( <line30> adapterManager.getAnnotatorConfig(annotator, type), <line31> adapterManager.getDatasetConfig(dataset, type), <line32> type, <line33> getMatching(matching)); <line34> ++count; <line35> } <line36> } <line37> String experimentId = IDCreator.getInstance().createID(); <line38> Experimenter exp = <line39> new Experimenter(overseer, dao, globalRetriever, evFactory, configs, experimentId); <line40> exp.setAnnotatorOutputWriter(annotatorOutputWriter); <line41> exp.run(); <line42> return experimentId; <line43> } <line44> } <line45> "	 <line35>	No
public class A { <line0> Source loadXml(String theSchemaName) { <line1> String pathToBase = myCtx.getVersion().getPathToSchemaDefinitions() + '/' + theSchemaName; <line2> String contents = ClasspathUtil.loadResource(pathToBase, ClasspathUtil.withBom()); <line3> return new StreamSource(new StringReader(contents), null); <line4> } <line5> } <line6> 	 <line2>	Yes
"public class A { <line0> @Override <line1> public void run() { <line2> BsonTimestamp firstAvailablePosition = findFirstOplogPosition(); <line3> Position userConfigOrRuntimePosition = replicaSetConfig.getPosition(); <line4> boolean needDataSync = <line5> !userConfigOrRuntimePosition.isValid() <line6> || userConfigOrRuntimePosition.isInitSync() <line7> || userConfigOrRuntimePosition.converBsonTimeStamp().compareTo(firstAvailablePosition) <line8> < 0; <line9> if (needDataSync) { <line10> recordLastOplogPosition(); <line11> InitSync initSync = <line12> new InitSync(replicaSetConfig, mongoClient, replicaSetsContext, replicaSet); <line13> initSync.start(); <line14> } <line15> if (!replicaSet.isRuning() || replicaSetsContext.isInitSyncAbort()) { <line16> return; <line17> } <line18> MongoDatabase localDataBase = mongoClient.getDatabase(Constants.MONGO_LOCAL_DATABASE); <line19> FindIterable<Document> iterable = <line20> localDataBase <line21> .getCollection(Constants.MONGO_OPLOG_RS) <line22> .find(Filters.gt(""ts"", replicaSetConfig.getPosition().converBsonTimeStamp())); <line23> MongoCursor<Document> cursor = <line24> iterable <line25> .sort(new Document(""$natural"", 1)) <line26> .noCursorTimeout(true) <line27> .cursorType(CursorType.TailableAwait) <line28> .batchSize(200) <line29> .iterator(); <line30> while (replicaSet.isRuning()) { <line31> try { <line32> executorCursor(cursor); <line33> } catch (Exception e) { <line34> } finally { <line35> if (cursor != null) { <line36> cursor.close(); <line37> } <line38> replicaSet.shutdown(); <line39> } <line40> } <line41> } <line42> } <line43> "	 <line28>	No
"public class A { <line0> @ApiOperation(value = ""Returns the form information for a specified task instance."") <line1> @ApiResponses( <line2> value = { <line3> @ApiResponse(code = 500, message = ""Unexpected error""), <line4> @ApiResponse(code = 404, message = ""Task, form or Container Id not found""), <line5> @ApiResponse( <line6> code = 200, <line7> response = String.class, <line8> message = ""Successfull response"", <line9> examples = <line10> @Example(value = {@ExampleProperty(mediaType = JSON, value = TASK_FORM_DEF_JSON)})) <line11> }) <line12> @GET <line13> @Path(TASK_FORM_GET_URI) <line14> @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) <line15> public Response getTaskForm( <line16> @javax.ws.rs.core.Context HttpHeaders headers, <line17> @ApiParam( <line18> value = ""container id that task instance belongs to"", <line19> required = true, <line20> example = ""evaluation_1.0.0-SNAPSHOT"") <line21> @PathParam(CONTAINER_ID) <line22> String containerId, <line23> @ApiParam( <line24> value = ""identifier of task instance that form should be fetched for"", <line25> required = true, <line26> example = ""123"") <line27> @PathParam(TASK_INSTANCE_ID) <line28> Long taskId, <line29> @ApiParam(value = ""optional language that the form should be found for"", required = false) <line30> @QueryParam(""lang"") <line31> @DefaultValue(""en"") <line32> String language, <line33> @ApiParam( <line34> value = ""optional filter flag if form should be filtered or returned as is"", <line35> required = false) <line36> @QueryParam(""filter"") <line37> boolean filter, <line38> @ApiParam( <line39> value = <line40> ""optional type of the form, defaults to ANY so system will find the most current"" <line41> + "" one"", <line42> required = false) <line43> @QueryParam(""type"") <line44> @DefaultValue(""ANY"") <line45> String formType, <line46> @ApiParam( <line47> value = <line48> ""optional marshall content flag if the content should be transformed or not,"" <line49> + "" defaults to true"", <line50> required = false) <line51> @QueryParam(""marshallContent"") <line52> @DefaultValue(""true"") <line53> boolean marshallContent, <line54> @ApiParam( <line55> value = <line56> ""optional user id to be used instead of authenticated user - only when bypass"" <line57> + "" authenticated user is enabled"", <line58> required = false) <line59> @QueryParam(""user"") <line60> String user) { <line61> Variant variant = getVariant(headers); <line62> Header conversationIdHeader = buildConversationIdHeader(containerId, context, headers); <line63> try { <line64> String response = <line65> formServiceBase.getFormDisplayTask(containerId, taskId, user, language, filter, formType); <line66> if (marshallContent) { <line67> response = marshallFormContent(response, formType, variant); <line68> } <line69> return createResponse(response, variant, Response.Status.OK, conversationIdHeader); <line70> } catch (PermissionDeniedException e) { <line71> return permissionDenied( <line72> MessageFormat.format(TASK_PERMISSION_ERROR, taskId), variant, conversationIdHeader); <line73> } catch (TaskNotFoundException e) { <line74> return notFound( <line75> MessageFormat.format(TASK_INSTANCE_NOT_FOUND, taskId), variant, conversationIdHeader); <line76> } catch (DeploymentNotFoundException e) { <line77> return notFound( <line78> MessageFormat.format(CONTAINER_NOT_FOUND, containerId), variant, conversationIdHeader); <line79> } catch (IllegalStateException e) { <line80> return notFound(""Form for task id "" + taskId + "" not found"", variant, conversationIdHeader); <line81> } catch (Exception e) { <line82> return internalServerError(errorMessage(e), variant, conversationIdHeader); <line83> } <line84> } <line85> } <line86> "	 <line69>	Yes
public class A { <line0> @Override <line1> public Iterable<Object> vertexIds(int offset, int limit) { <line2> Set<Object> result = new HashSet<>(limit); <line3> Iterable<JanusGraphVertex> it = query.limit(offset + limit).vertices(); <line4> if (LOG.isDebugEnabled()) { <line5> if (query instanceof GraphCentricQueryBuilder) { <line6> } else { <line7> } <line8> } <line9> Iterator<? extends Vertex> iter = it.iterator(); <line10> for (long resultIdx = 0; iter.hasNext() && result.size() < limit; resultIdx++) { <line11> if (resultIdx < offset) { <line12> continue; <line13> } <line14> result.add(iter.next().id()); <line15> } <line16> return result; <line17> } <line18> } <line19> 	 <line13>	No
"public class A { <line0> @RequestMapping( <line1> value = ""/{rsid}"" + POLICYURL, <line2> method = RequestMethod.POST, <line3> produces = MimeTypeUtils.APPLICATION_JSON_VALUE) <line4> public String createNewPolicyForResourceSet( <line5> @PathVariable(value = ""rsid"") Long rsid, <line6> @RequestBody String jsonString, <line7> Model m, <line8> Authentication auth) { <line9> ResourceSet rs = resourceSetService.getById(rsid); <line10> if (rs == null) { <line11> m.addAttribute(HttpCodeView.CODE, HttpStatus.NOT_FOUND); <line12> return HttpCodeView.VIEWNAME; <line13> } <line14> if (!rs.getOwner().equals(auth.getName())) { <line15> m.addAttribute(HttpCodeView.CODE, HttpStatus.FORBIDDEN); <line16> return HttpCodeView.VIEWNAME; <line17> } <line18> Policy p = gson.fromJson(jsonString, Policy.class); <line19> if (p.getId() != null) { <line20> m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST); <line21> return HttpCodeView.VIEWNAME; <line22> } <line23> for (Claim claim : p.getClaimsRequired()) { <line24> if (claim.getId() != null) { <line25> m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST); <line26> return HttpCodeView.VIEWNAME; <line27> } <line28> } <line29> rs.getPolicies().add(p); <line30> ResourceSet saved = resourceSetService.update(rs, rs); <line31> Collection<Policy> newPolicies = <line32> Sets.difference(new HashSet<>(saved.getPolicies()), new HashSet<>(rs.getPolicies())); <line33> if (newPolicies.size() == 1) { <line34> Policy newPolicy = newPolicies.iterator().next(); <line35> m.addAttribute(JsonEntityView.ENTITY, newPolicy); <line36> return JsonEntityView.VIEWNAME; <line37> } else { <line38> m.addAttribute(HttpCodeView.CODE, HttpStatus.INTERNAL_SERVER_ERROR); <line39> return HttpCodeView.VIEWNAME; <line40> } <line41> } <line42> } <line43> "	 <line38>	Yes
"public class A { <line0> @Override <line1> public boolean needDeploy() { <line2> Ssh ssh = new Ssh(); <line3> ssh.setUsername(username) <line4> .setPrivateKey(privateKey) <line5> .setPassword(password) <line6> .setPort(sshPort) <line7> .setHostname(targetIp); <line8> try { <line9> for (SrcDestPair b : srcDestPairs) { <line10> String sourceFilePath = b.srcPath; <line11> String destFilePath = b.destPath; <line12> ssh.command( <line13> String.format(""echo %s | sudo -S md5sum %s 2>/dev/null"", password, destFilePath)); <line14> SshResult ret = ssh.run(); <line15> if (ret.getReturnCode() != 0) { <line16> return true; <line17> } <line18> ssh.reset(); <line19> String destMd5 = ret.getStdout().split("" "")[0]; <line20> ShellResult sret = ShellUtils.runAndReturn(String.format(""md5sum %s"", sourceFilePath)); <line21> sret.raiseExceptionIfFail(); <line22> String srcMd5 = sret.getStdout().split("" "")[0]; <line23> if (!destMd5.equals(srcMd5)) { <line24> return true; <line25> } <line26> } <line27> } finally { <line28> ssh.close(); <line29> } <line30> return false; <line31> } <line32> } <line33> "	 <line24>	Yes
public class A { <line0> public void run(Operation object) { <line1> if (!followerTimer.get()) { <line2> return; <line3> } <line4> if (object.getStatus() != ServerStatus.Follower) { <line5> return; <line6> } <line7> boolean leaderHeartbeat = object.getLastHeartbeat() > lastLeaderHeartbeat; <line8> if (leaderHeartbeat) { <line9> printLeader(); <line10> return; <line11> } <line12> if (object.getStatus() == ServerStatus.Follower) { <line13> landContext.fireStatus(ServerStatus.Candidate); <line14> } <line15> } <line16> } <line17> 	 <line5>	Yes
public class A { <line0> @Override <line1> public List<GenericEntity> getStudentSummaries( <line2> String token, List<String> studentIds, String sessionId, String sectionId) { <line3> long startTime = System.nanoTime(); <line4> List<GenericEntity> studentSummaries = entityManager.getStudents(token, sectionId); <line5> return studentSummaries; <line6> } <line7> } <line8> 	 <line5>	Yes
"public class A { <line0> @Override <line1> public BeanPropertyBindingResult validate(WidgetConfigurationRequest widget, IPage page) { <line2> BeanPropertyBindingResult bindingResult = <line3> new BeanPropertyBindingResult(widget, widget.getClass().getSimpleName()); <line4> try { <line5> WidgetValidatorCmsHelper.validateTitle(widget, getLangManager(), bindingResult); <line6> WidgetValidatorCmsHelper.validateLink( <line7> widget, getLangManager(), getPageManager(), bindingResult); <line8> this.validateContentType(widget, bindingResult); <line9> this.validateFilters(widget, bindingResult); <line10> this.validateContentModel(widget, bindingResult); <line11> } catch (Throwable e) { <line12> throw new RestServerError(""error in widget config validation"", e); <line13> } <line14> return bindingResult; <line15> } <line16> } <line17> "	 <line1>	No
"public class A { <line0> private JsonObject addProperties(Project project) { <line1> JsonObject result = new JsonObject(); <line2> try { <line3> result.addProperty(""id"", project.getId()); <line4> result.addProperty(""name"", project.getName()); <line5> result.addProperty(""description"", project.getDescription()); <line6> result.addProperty(""description-html"", project.getDescriptionHtml()); <line7> result.addProperty(""type"", project.getType().name()); <line8> result.addProperty(""board"", project.getBoard()); <line9> result.addProperty(""private"", project.getPrivate()); <line10> result.addProperty(""shared"", project.getShared()); <line11> result.addProperty( <line12> ""modified"", DateConversion.toDateTimeString(project.getModified().getTime())); <line13> result.addProperty(""settings"", project.getSettings()); <line14> } catch (Exception ex) { <line15> } <line16> return result; <line17> } <line18> } <line19> "	 <line15>	Yes
"public class A { <line0> protected Answer execute(PingTestCommand cmd) { <line1> if (s_logger.isInfoEnabled()) { <line2> } <line3> String controlIp = cmd.getRouterIp(); <line4> if (controlIp != null) { <line5> String args = "" -c 1 -n -q "" + cmd.getPrivateIp(); <line6> try { <line7> Pair<Boolean, String> result = <line8> SshHelper.sshExecute( <line9> controlIp, <line10> DefaultDomRSshPort, <line11> ""root"", <line12> getSystemVmKeyFile(), <line13> null, <line14> ""/bin/ping"" + args); <line15> if (result.first()) return new Answer(cmd); <line16> } catch (Exception e) { <line17> } <line18> return new Answer(cmd, false, ""PingTestCommand failed""); <line19> } else { <line20> VmwareContext context = getServiceContext(); <line21> VmwareHypervisorHost hyperHost = getHyperHost(context); <line22> try { <line23> HostMO hostMo = (HostMO) hyperHost; <line24> ClusterMO clusterMo = new ClusterMO(context, hostMo.getHyperHostCluster()); <line25> VmwareManager mgr = context.getStockObject(VmwareManager.CONTEXT_STOCK_NAME); <line26> List<Pair<ManagedObjectReference, String>> hosts = clusterMo.getClusterHosts(); <line27> for (Pair<ManagedObjectReference, String> entry : hosts) { <line28> HostMO hostInCluster = new HostMO(context, entry.first()); <line29> String hostIp = hostInCluster.getHostManagementIp(mgr.getManagementPortGroupName()); <line30> if (hostIp != null && hostIp.equals(cmd.getComputingHostIp())) { <line31> if (hostInCluster.isHyperHostConnected()) return new Answer(cmd); <line32> else return new Answer(cmd, false, ""PingTestCommand failed""); <line33> } <line34> } <line35> } catch (Exception e) { <line36> } <line37> return new Answer(cmd, false, ""PingTestCommand failed""); <line38> } <line39> } <line40> } <line41> "	 <line6>	No
public class A { <line0> public void onComplete(org.apache.airavata.model.data.replica.DataProductModel o) { <line1> getDataProduct_result result = new getDataProduct_result(); <line2> result.success = o; <line3> try { <line4> fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid); <line5> } catch (org.apache.thrift.transport.TTransportException e) { <line6> fb.close(); <line7> } catch (java.lang.Exception e) { <line8> onError(e); <line9> } <line10> } <line11> } <line12> 	 <line6>	Yes
"public class A { <line0> public String getWarnings(LoggedInInfo loggedInInfo, String demo) { <line1> String ret = dataCache.get(demo); <line2> if (ret == null) { <line3> try { <line4> Prevention prev = <line5> PreventionData.getLocalandRemotePreventions(loggedInInfo, Integer.parseInt(demo)); <line6> pf.getMessages(prev); <line7> @SuppressWarnings(""unchecked"") <line8> Map<String, Object> m = prev.getWarningMsgs(); <line9> @SuppressWarnings(""rawtypes"") <line10> Set set = m.entrySet(); <line11> @SuppressWarnings(""rawtypes"") <line12> Iterator i = set.iterator(); <line13> String k = """"; <line14> if (ret == null || ret.equals(""null"")) { <line15> ret = """"; <line16> } <line17> while (i.hasNext()) { <line18> @SuppressWarnings(""rawtypes"") <line19> Map.Entry me = (Map.Entry) i.next(); <line20> k = ""["" + me.getKey() + ""="" + me.getValue() + ""]""; <line21> boolean prevCheck = PreventionManager.isPrevDisabled(me.getKey().toString()); <line22> if (prevCheck == false) { <line23> ret = ret + k; <line24> } <line25> } <line26> dataCache.put(demo, ret); <line27> } catch (Exception e) { <line28> ret = """"; <line29> } <line30> } <line31> return ret; <line32> } <line33> } <line34> "	 <line27>	No
"public class A { <line0> public void exportFileVersion() { <line1> File file = null; <line2> String cookePrefix = Constants.RESPONSE_MONITOR_COOKIE; <line3> String cookieName = cookePrefix + ""_"" + WebStudioUtils.getRequestParameter(cookePrefix); <line4> try { <line5> UserWorkspace userWorkspace = getUserWorkspace(); <line6> RulesProject selectedProject = <line7> userWorkspace.getProject(repositoryId, currentProjectName, false); <line8> AProjectResource projectResource; <line9> if (version == null <line10> || version.equals(VIEWING_VERSION) <line11> || version.equals(IN_EDITING_VERSION)) { <line12> AProjectArtefact artefact = selectedProject.getArtefact(getArtifactName()); <line13> projectResource = (AProjectResource) artefact; <line14> } else { <line15> Repository repository = selectedProject.getDesignRepository(); <line16> String branch = <line17> repository.supports().branches() ? ((BranchRepository) repository).getBranch() : null; <line18> AProject forExport = <line19> userWorkspace <line20> .getDesignTimeRepository() <line21> .getProjectByPath( <line22> repository.getId(), branch, selectedProject.getRealPath(), version); <line23> projectResource = (AProjectResource) forExport.getArtefact(getArtifactName()); <line24> } <line25> file = File.createTempFile(""export-"", ""-file""); <line26> IOUtils.copyAndClose(projectResource.getContent(), new FileOutputStream(file)); <line27> addCookie(cookieName, ""success"", -1); <line28> final FacesContext facesContext = FacesContext.getCurrentInstance(); <line29> HttpServletResponse response = <line30> (HttpServletResponse) WebStudioUtils.getExternalContext().getResponse(); <line31> ExportFile.writeOutContent(response, file, getFileName()); <line32> facesContext.responseComplete(); <line33> } catch (Exception e) { <line34> String msg = ""Failed to export file version. ""; <line35> addCookie(cookieName, msg + e.getMessage(), -1); <line36> } finally { <line37> FileUtils.deleteQuietly(file); <line38> } <line39> } <line40> } <line41> "	 <line11>	No
"public class A { <line0> public static void main(String[] args) { <line1> monkeyPatchBeansBinding(); <line2> for (String s : args) { <line3> if (s.equals(""--version"")) { <line4> System.out.println(getVersion()); <line5> System.exit(0); <line6> } <line7> } <line8> System.setProperty(""apple.laf.useScreenMenuBar"", ""true""); <line9> try { <line10> UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName()); <line11> } catch (Exception e) { <line12> throw new Error(e); <line13> } <line14> File configurationDirectory = new File(System.getProperty(""user.home"")); <line15> configurationDirectory = new File(configurationDirectory, "".openpnp2""); <line16> if (System.getProperty(""configDir"") != null) { <line17> configurationDirectory = new File(System.getProperty(""configDir"")); <line18> } <line19> configurationDirectory.mkdirs(); <line20> configureLogging(configurationDirectory); <line21> Configuration.initialize(configurationDirectory); <line22> final Configuration configuration = Configuration.get(); <line23> Locale.setDefault(Configuration.get().getLocale()); <line24> ThemeInfo theme = configuration.getThemeInfo(); <line25> new ThemeSettingsPanel().setTheme(theme, configuration.getFontSize()); <line26> ThemeDialog.getInstance().setOldTheme(theme); <line27> EventQueue.invokeLater( <line28> new Runnable() { <line29> public void run() { <line30> try { <line31> MainFrame frame = new MainFrame(configuration); <line32> frame.setVisible(true); <line33> configuration.getScripting().on(""Startup"", null); <line34> } catch (Exception e) { <line35> e.printStackTrace(); <line36> } <line37> } <line38> }); <line39> } <line40> } <line41> "	 <line33>	Yes
"public class A { <line0> protected void setupNamedClsGen(String appName, String path, Map<String, Object> lastafluteMap) { <line1> final String baseDir = path + ""/src/main""; <line2> final String middlePath = ""resources/namedcls""; <line3> final String namedclsPath = baseDir + ""/"" + middlePath; <line4> final File namedclsDir = new File(namedclsPath); <line5> if (!namedclsDir.exists()) { <line6> return; <line7> } <line8> final String filePrefix = appName + ""_""; <line9> final String fileSuffix = ""_cls.dfprop""; <line10> final File[] dfpropFiles = <line11> namedclsDir.listFiles( <line12> file -> { <line13> return file.isFile() <line14> && file.getName().startsWith(filePrefix) <line15> && file.getName().endsWith(fileSuffix); <line16> }); <line17> if (dfpropFiles == null || dfpropFiles.length == 0) { <line18> return; <line19> } <line20> for (File dfpropFile : dfpropFiles) { <line21> final String dfpropName = dfpropFile.getName(); <line22> final String clsDomain = <line23> Srl.extractScopeFirst(dfpropName, filePrefix, fileSuffix).getContent(); <line24> doSetupNamedClsGen(appName, clsDomain, lastafluteMap, baseDir, middlePath, dfpropName); <line25> } <line26> } <line27> } <line28> "	 <line18>	Yes
public class A { <line0> public List<TimeseriesMetadata> readTimeseriesMetadata(String device, Set<String> measurements) <line1> throws IOException { <line2> readFileMetadata(); <line3> MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex(); <line4> Pair<MetadataIndexEntry, Long> metadataIndexPair = <line5> getMetadataAndEndOffset(deviceMetadataIndexNode, device, true, false); <line6> if (metadataIndexPair == null) { <line7> return Collections.emptyList(); <line8> } <line9> List<TimeseriesMetadata> resultTimeseriesMetadataList = new ArrayList<>(); <line10> List<String> measurementList = new ArrayList<>(measurements); <line11> Set<String> measurementsHadFound = new HashSet<>(); <line12> for (int i = 0; i < measurementList.size(); i++) { <line13> if (measurementsHadFound.contains(measurementList.get(i))) { <line14> continue; <line15> } <line16> ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right); <line17> Pair<MetadataIndexEntry, Long> measurementMetadataIndexPair = metadataIndexPair; <line18> List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>(); <line19> MetadataIndexNode metadataIndexNode = deviceMetadataIndexNode; <line20> if (!metadataIndexNode.getNodeType().equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) { <line21> try { <line22> metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer); <line23> } catch (BufferOverflowException e) { <line24> throw e; <line25> } <line26> measurementMetadataIndexPair = <line27> getMetadataAndEndOffset(metadataIndexNode, measurementList.get(i), false, false); <line28> } <line29> if (measurementMetadataIndexPair == null) { <line30> return Collections.emptyList(); <line31> } <line32> buffer = <line33> readData( <line34> measurementMetadataIndexPair.left.getOffset(), measurementMetadataIndexPair.right); <line35> while (buffer.hasRemaining()) { <line36> try { <line37> timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer, true)); <line38> } catch (BufferOverflowException e) { <line39> throw e; <line40> } <line41> } <line42> for (int j = i; j < measurementList.size(); j++) { <line43> String current = measurementList.get(j); <line44> if (!measurementsHadFound.contains(current)) { <line45> int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList, current); <line46> if (searchResult >= 0) { <line47> resultTimeseriesMetadataList.add(timeseriesMetadataList.get(searchResult)); <line48> measurementsHadFound.add(current); <line49> } <line50> } <line51> if (measurementsHadFound.size() == measurements.size()) { <line52> return resultTimeseriesMetadataList; <line53> } <line54> } <line55> } <line56> return resultTimeseriesMetadataList; <line57> } <line58> } <line59> 	 <line35>	No
public class A { <line0> private void handleError(ChannelHandlerContext ctx, Message.Request request, Throwable error) { <line1> try { <line2> if (logger.isTraceEnabled()) <line3> UnexpectedChannelExceptionHandler handler = <line4> new UnexpectedChannelExceptionHandler(ctx.channel(), true); <line5> if (error instanceof ExecutionException) error = error.getCause(); <line6> if (error instanceof CompletionException) error = error.getCause(); <line7> flush( <line8> new Message.Dispatcher.FlushItem( <line9> ctx, <line10> ErrorMessage.fromException(error, handler).setStreamId(request.getStreamId()), <line11> request.getSourceFrameBodySizeInBytes(), <line12> this)); <line13> } catch (Throwable t) { <line14> } finally { <line15> ClientWarn.instance.resetWarnings(); <line16> } <line17> } <line18> } <line19> 	 <line7>	No
public class A { <line0> public List<String> close() throws SAXException, RepositoryException { <line1> if (states.peek() != State.INITIAL) { <line2> } <line3> List<String> paths = new ArrayList<>(); <line4> importPolicy.apply(paths); <line5> return paths; <line6> } <line7> } <line8> 	 <line2>	Yes
"public class A { <line0> private Object convertLtreeArray(Column column, Field fieldDefn, Object data) { <line1> return convertValue( <line2> column, <line3> fieldDefn, <line4> data, <line5> Collections.emptyList(), <line6> r -> { <line7> if (data instanceof byte[]) { <line8> String s = new String((byte[]) data, databaseCharset); <line9> s = s.substring(1, s.length() - 1); <line10> List<String> ltrees = Arrays.asList(s.split("","")); <line11> r.deliver(ltrees); <line12> } else if (data instanceof List) { <line13> List<Object> list = (List<Object>) data; <line14> List<String> ltrees = new ArrayList<>(list.size()); <line15> for (Object value : list) { <line16> ltrees.add(value.toString()); <line17> } <line18> r.deliver(ltrees); <line19> } else if (data instanceof PgArray) { <line20> PgArray pgArray = (PgArray) data; <line21> try { <line22> Object[] array = (Object[]) pgArray.getArray(); <line23> List<String> ltrees = new ArrayList<>(array.length); <line24> for (Object value : array) { <line25> ltrees.add(value.toString()); <line26> } <line27> r.deliver(ltrees); <line28> } catch (SQLException e) { <line29> } <line30> } <line31> }); <line32> } <line33> } <line34> "	 <line29>	Yes
"public class A { <line0> private static JAXBContext initJaxbContext() { <line1> JAXBContext jaxbContext = null; <line2> String contextPath = <line3> StringUtils.join( <line4> new String[] { <line5> CswConstants.OGC_CSW_PACKAGE, <line6> CswConstants.OGC_FILTER_PACKAGE, <line7> CswConstants.OGC_GML_PACKAGE, <line8> CswConstants.OGC_OWS_PACKAGE <line9> }, <line10> "":""); <line11> try { <line12> jaxbContext = <line13> JAXBContext.newInstance(contextPath, CswJAXBElementProvider.class.getClassLoader()); <line14> } catch (JAXBException e) { <line15> } <line16> return jaxbContext; <line17> } <line18> } <line19> "	 <line6>	No
"public class A { <line0> public FileStatus[] listFileStatus(String filePath) throws Exception { <line1> try { <line2> return fs.listStatus(new Path(filePath)); <line3> } catch (IOException e) { <line4> throw new Exception(""Get file list exception"", e); <line5> } <line6> } <line7> } <line8> "	 <line5>	No
"public class A { <line0> @Test <line1> public void testRunAllParagraph_FirstFailed() throws IOException { <line2> Note note1 = null; <line3> try { <line4> note1 = TestUtils.getInstance(Notebook.class).createNote(""note1"", anonymous); <line5> Paragraph p1 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS); <line6> Paragraph p2 = note1.addNewParagraph(AuthenticationInfo.ANONYMOUS); <line7> p1.setText( <line8> ""%python from __future__ import print_function\n"" <line9> + ""import time\n"" <line10> + ""time.sleep(1)\n"" <line11> + ""print(user2)""); <line12> p2.setText(""%python user2='abc'\nprint(user2)""); <line13> CloseableHttpResponse post = <line14> httpPost(""/notebook/job/"" + note1.getId() + ""?blocking=true"", """"); <line15> assertThat(post, isAllowed()); <line16> assertEquals(Job.Status.ERROR, p1.getStatus()); <line17> assertEquals(Job.Status.READY, p2.getStatus()); <line18> post.close(); <line19> } finally { <line20> if (null != note1) { <line21> TestUtils.getInstance(Notebook.class).removeNote(note1, anonymous); <line22> } <line23> } <line24> } <line25> } <line26> "	 <line2>	Yes
"public class A { <line0> @Override <line1> public void execute() { <line2> if (inputs != null) { <line3> List<String> weblogs = (List<String>) inputs.get(""weblogs""); <line4> if (weblogs == null) { <line5> return; <line6> } <line7> if (""true"".equals(inputs.get(""feed-entries-rss""))) { <line8> this.warmupFeedCache(weblogs, ""entries"", ""rss""); <line9> } <line10> if (""true"".equals(inputs.get(""feed-entries-atom""))) { <line11> this.warmupFeedCache(weblogs, ""entries"", ""atom""); <line12> } <line13> } <line14> } <line15> } <line16> "	 <line1>	No
public class A { <line0> @Override <line1> protected void decode(ChannelHandlerContext chc, DatagramPacket msg, List<Object> list) { <line2> ByteBuf bb = msg.content(); <line3> if (bb.readableBytes() < LENGTH_OF_HEADER) { <line4> return; <line5> } <line6> int length = bb.getUnsignedShort(bb.readerIndex() + LENGTH_INDEX_IN_HEADER); <line7> if (bb.readableBytes() < length) { <line8> return; <line9> } <line10> ByteBuf messageBuffer = bb.slice(bb.readerIndex(), length); <line11> list.add(messageBuffer); <line12> messageBuffer.retain(); <line13> bb.skipBytes(length); <line14> } <line15> } <line16> 	 <line10>	Yes
public class A { <line0> @Override <line1> public void close() throws IOException { <line2> out.close(); <line3> final byte[] bytes = ByteArrayOutputStream.class.cast(out).toByteArray(); <line4> if (!destination.exists() || isDifferent(bytes)) { <line5> try (final OutputStream out = new FileOutputStream(destination)) { <line6> out.write(bytes); <line7> } <line8> } else { <line9> } <line10> } <line11> } <line12> 	 <line2>	No
public class A { <line0> private void getServerProfileTemplateById() { <line1> ServerProfileTemplate template = <line2> this.serverProfileTemplateClient.getByName(SERVER_PROFILE_TEMPLATE_NAME).get(0); <line3> template = serverProfileTemplateClient.getById(template.getResourceId()); <line4> } <line5> } <line6> 	 <line2>	No
public class A { <line0> @Override <line1> public T lookup(final CacheReference<T> reference) { <line2> for (AttributedList<T> entry : impl.asMap().values()) { <line3> final T f = entry.find(reference); <line4> if (null == f) { <line5> continue; <line6> } <line7> return f; <line8> } <line9> return null; <line10> } <line11> } <line12> 	 <line9>	Yes
"public class A { <line0> public synchronized void start() { <line1> if (jmsTaskManagerState == STATE_PAUSED) { <line2> return; <line3> } <line4> if (!pollingTasks.isEmpty()) { <line5> stop(); <line6> } <line7> if (cacheLevel == JMSConstants.CACHE_AUTO) { <line8> cacheLevel = <line9> transactionality == BaseConstants.TRANSACTION_NONE <line10> ? JMSConstants.CACHE_CONSUMER <line11> : JMSConstants.CACHE_NONE; <line12> } <line13> switch (cacheLevel) { <line14> case JMSConstants.CACHE_NONE: <line15> break; <line16> case JMSConstants.CACHE_CONNECTION: <line17> break; <line18> case JMSConstants.CACHE_SESSION: <line19> break; <line20> case JMSConstants.CACHE_CONSUMER: <line21> break; <line22> default: <line23> { <line24> handleException(""Invalid cache level : "" + cacheLevel + "" for  "" + jmsConsumerName); <line25> } <line26> } <line27> for (int i = 0; i < concurrentConsumers; i++) { <line28> workerPool.execute(new MessageListenerTask()); <line29> } <line30> jmsTaskManagerState = STATE_STARTED; <line31> } <line32> } <line33> "	 <line30>	No
"public class A { <line0> @Override <line1> protected void parse(final ProtocolFactory protocols, final Local file) <line2> throws AccessDeniedException { <line3> try { <line4> final JsonReader reader = <line5> new JsonReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8)); <line6> reader.beginArray(); <line7> String url; <line8> String user; <line9> boolean ssl; <line10> Protocol protocol; <line11> while (reader.hasNext()) { <line12> reader.beginObject(); <line13> boolean skip = false; <line14> url = null; <line15> ssl = false; <line16> protocol = null; <line17> user = null; <line18> while (reader.hasNext()) { <line19> final String name = reader.nextName(); <line20> switch (name) { <line21> case ""url"": <line22> url = this.readNext(name, reader); <line23> if (StringUtils.isBlank(url)) { <line24> skip = true; <line25> } <line26> break; <line27> case ""ssl"": <line28> ssl = reader.nextBoolean(); <line29> break; <line30> case ""user"": <line31> user = this.readNext(name, reader); <line32> break; <line33> case ""type"": <line34> final String type = this.readNext(name, reader); <line35> switch (type) { <line36> case ""google_cloud_storage"": <line37> protocol = protocols.forType(Protocol.Type.googlestorage); <line38> break; <line39> case ""gdrive"": <line40> protocol = protocols.forType(Protocol.Type.googledrive); <line41> break; <line42> default: <line43> protocol = protocols.forName(type); <line44> } <line45> break; <line46> default: <line47> reader.skipValue(); <line48> break; <line49> } <line50> } <line51> reader.endObject(); <line52> if (!skip && protocol != null && StringUtils.isNotBlank(user)) { <line53> if (ssl) { <line54> switch (protocol.getType()) { <line55> case ftp: <line56> protocol = protocols.forScheme(Scheme.ftps); <line57> break; <line58> case dav: <line59> protocol = protocols.forScheme(Scheme.davs); <line60> break; <line61> } <line62> } <line63> try { <line64> this.add(new HostParser(protocols, protocol).get(url)); <line65> } catch (HostParserException e) { <line66> } <line67> } <line68> } <line69> reader.endArray(); <line70> } catch (IllegalStateException | IOException e) { <line71> throw new LocalAccessDeniedException(e.getMessage(), e); <line72> } <line73> } <line74> } <line75> "	 <line66>	Yes
public class A { <line0> private void setApplicationName(String applicationName) { <line1> synchronized (this) { <line2> properties.put(APPLICATION_NAME, applicationName); <line3> } <line4> } <line5> } <line6> 	 <line0>	No
public class A { <line0> @Override <line1> public void run() { <line2> for (ClusterTopologyListener listener : copy) { <line3> if (logger.isTraceEnabled()) { <line4> } <line5> try { <line6> listener.nodeDown(uniqueEventID, nodeId); <line7> } catch (Exception e) { <line8> ActiveMQClientLogger.LOGGER.errorSendingTopologyNodedown(e); <line9> } <line10> } <line11> } <line12> } <line13> 	 <line4>	Yes
public class A { <line0> protected void checkIntegrationStatusIfNotAlreadyInProgress(String id) { <line1> executor.execute( <line2> () -> { <line3> IntegrationDeployment integrationDeployment = <line4> dataManager.fetch(IntegrationDeployment.class, id); <line5> if (integrationDeployment != null) { <line6> String scheduledKey = getIntegrationMarkerKey(integrationDeployment); <line7> if (!scheduledChecks.contains(scheduledKey)) { <line8> checkIntegrationStatus(integrationDeployment); <line9> } else { <line10> } <line11> } else { <line12> } <line13> }); <line14> } <line15> } <line16> 	 <line7>	Yes
public class A { <line0> @Override <line1> public void setHeader(Metadata header, String name, String value) { <line2> final Metadata.Key<String> key = Metadata.Key.of(name, Metadata.ASCII_STRING_MARSHALLER); <line3> header.put(key, value); <line4> if (isDebug) { <line5> } <line6> } <line7> } <line8> 	 <line3>	No
public class A { <line0> @Override <line1> protected void i_createTables(TableCreatingConnection tcConn, List<TableSpec> tSpecs) <line2> throws SQLException { <line3> Iterator<TableSpec> nii = tSpecs.iterator(); <line4> while (nii.hasNext()) { <line5> TableSpec spec = nii.next(); <line6> if (logger.isInfoEnabled()) { <line7> StringBuilder sqlCmds = new StringBuilder(128); <line8> Iterator<String> iter = tcConn.getDDLConverter().getDDL(spec).iterator(); <line9> while (iter.hasNext()) { <line10> sqlCmds.append('\n'); <line11> sqlCmds.append(iter.next()); <line12> sqlCmds.append(';'); <line13> } <line14> } <line15> tcConn.createTable(spec); <line16> } <line17> } <line18> } <line19> 	 <line10>	No
public class A { <line0> @ApiOperation( <line1> value = OP_GET_QOS_MONITOR_INTRA_PING_MEDIAN_MEASUREMENT_BY_ATTRIBUTE, <line2> response = QoSIntraPingMeasurementResponseDTO.class, <line3> tags = {CoreCommonConstants.SWAGGER_TAG_PRIVATE}) <line4> @ApiResponses( <line5> value = { <line6> @ApiResponse( <line7> code = HttpStatus.SC_OK, <line8> message = OP_GET_QOS_MONITOR_INTRA_PING_MEDIAN_MEASUREMENT_BY_ATTRIBUTE_200_MESSAGE), <line9> @ApiResponse( <line10> code = HttpStatus.SC_BAD_REQUEST, <line11> message = <line12> OP_GET_QOS_MONITOR_INTRA_PING_MEDIAN_MEASUREMENT_BY_ATTRIBUTE_HTTP_400_MESSAGE), <line13> @ApiResponse( <line14> code = HttpStatus.SC_UNAUTHORIZED, <line15> message = CommonConstants.SWAGGER_HTTP_401_MESSAGE), <line16> @ApiResponse( <line17> code = HttpStatus.SC_INTERNAL_SERVER_ERROR, <line18> message = CommonConstants.SWAGGER_HTTP_500_MESSAGE) <line19> }) <line20> @GetMapping( <line21> path = CommonConstants.OP_QOS_MONITOR_INTRA_PING_MEDIAN_MEASUREMENT, <line22> produces = MediaType.APPLICATION_JSON_VALUE) <line23> @ResponseBody <line24> public QoSIntraPingMeasurementResponseDTO getIntraPingMedianMeasurement( <line25> @PathVariable final String attribute) { <line26> final QoSIntraPingMeasurementResponseDTO response = <line27> pingService.getMedianIntraPingMeasurement( <line28> Utilities.convertStringToQoSMeasurementAttribute(attribute)); <line29> return response; <line30> } <line31> } <line32> 	 <line16>	No
public class A { <line0> @BeforeEach <line1> void logTest(TestInfo testInfo) { <line2> } <line3> } <line4> 	 <line1>	No
public class A { <line0> @Override <line1> public void run() { <line2> group = new NioEventLoopGroup(); <line3> UdpSimpleClientInitializer clientInitializer = new UdpSimpleClientInitializer(isOnlineFuture); <line4> clientInitializer.setScenario(scenarioHandler); <line5> try { <line6> Bootstrap b = new Bootstrap(); <line7> b.group(group) <line8> .channel(NioDatagramChannel.class) <line9> .option(ChannelOption.SO_BROADCAST, false) <line10> .handler(clientInitializer); <line11> b.connect(host, port).sync(); <line12> synchronized (scenarioHandler) { <line13> while (!scenarioHandler.isScenarioFinished()) { <line14> scenarioHandler.wait(); <line15> } <line16> } <line17> } catch (Exception ex) { <line18> } finally { <line19> try { <line20> group.shutdownGracefully().get(); <line21> } catch (InterruptedException | ExecutionException e) { <line22> } <line23> } <line24> scenarioDone.set(true); <line25> } <line26> } <line27> 	 <line10>	No
"public class A { <line0> @Override <line1> public void run() { <line2> try { <line3> if (!isDisposed() && _isSchedulingServiceEnabled()) { <line4> if (LockType.ALERT_SCHEDULING.equals(lockType)) { <line5> synchronized (_alertService) { <line6> _alertService.enqueueAlerts(Arrays.asList(new Alert[] {Alert.class.cast(job)})); <line7> } <line8> } else { <line9> throw new SystemException(""Unsupported lock type "" + lockType); <line10> } <line11> } <line12> } catch (Exception ex) { <line13> _auditService.createAudit( <line14> ""Could not enqueue scheduled job. "" + ex.getMessage(), JPAEntity.class.cast(job)); <line15> } <line16> } <line17> } <line18> "	 <line7>	No
public class A { <line0> public void putClient(Node node, Client client) { <line1> ClusterNode clusterNode = new ClusterNode(node); <line2> Deque<Client> clientStack = clientCaches.computeIfAbsent(clusterNode, n -> new ArrayDeque<>()); <line3> synchronized (this) { <line4> if (client.getInputProtocol() != null && client.getInputProtocol().getTransport().isOpen()) { <line5> clientStack.push(client); <line6> NodeStatusManager.getINSTANCE().activate(node); <line7> } else { <line8> try { <line9> clientStack.push(syncClientFactory.getSyncClient(node, this)); <line10> NodeStatusManager.getINSTANCE().activate(node); <line11> } catch (TTransportException e) { <line12> nodeClientNumMap.computeIfPresent(clusterNode, (n, oldValue) -> oldValue - 1); <line13> NodeStatusManager.getINSTANCE().deactivate(node); <line14> } <line15> } <line16> this.notifyAll(); <line17> } <line18> } <line19> } <line20> 	 <line12>	Yes
public class A { <line0> @Override <line1> public void afterApplicationStart(CamelContext camelContext) { <line2> RoutesDefinition routes = new RoutesDefinition(); <line3> routes.setRoutes(camelContext.getRouteDefinitions()); <line4> try { <line5> if (LOGGER.isDebugEnabled()) { <line6> } <line7> } catch (JAXBException e) { <line8> throw new IllegalArgumentException(e); <line9> } <line10> } <line11> } <line12> 	 <line7>	No
"public class A { <line0> @Test <line1> public void markers() { <line2> Logger log = LogManager.getLogger(Log4j2NativeApiTest.class); <line3> Marker m1 = MarkerManager.getMarker(""m1""); <line4> m1.addParents(MarkerManager.getMarker(""p1""), MarkerManager.getMarker(""p2"")); <line5> } <line6> } <line7> "	 <line3>	No
